{"sha": "d732da813bac73d2c81caddd06df3df3d9609e3d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3MzJkYTgxM2JhYzczZDJjODFjYWRkZDA2ZGYzZGYzZDk2MDllM2Q=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-14T07:09:19Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2017-12-14T10:22:08Z"}, "message": "Use PathBuf instead of String where applicable", "tree": {"sha": "cd0e25895e11c8c70e296b98de5fc8a16073c324", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd0e25895e11c8c70e296b98de5fc8a16073c324"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d732da813bac73d2c81caddd06df3df3d9609e3d", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAloyUNAACgkQpp+NIls6\n19ka9g//djDY1BNNiaJ/3V5i1FAa4X7Z1djn1dopZcdxMi0KSoO+mQ00xBQG5cOL\nnTYkPzURCypbhy8SJkugfNVFcRqyrR92Zl0x1eq9EbZnHhsXJURfQTG70heCW+Bu\nkU+mn8lkeKCBBxPlNt2sVbOu9yRFbyhzb5tkTbZSJnDQzECdp+Fp6JtscEl09nC9\nKtqn4skFBSjkRLr0SyO87uBHZ0EO4nlHX9ZqPME100XrkDKyfpEKeF147PoExUWM\niNxu4qykbVMphaH5fU626/G9IlJIigG370wGiSsUUukr5rAsOjDUdB4OUXJuOmxI\ncGeItBNY6vdIC22z0mPxZI2Oo6okWoxzETmGbW2Wmz2eQYzDBV6ZODq5uesQhPUb\nEK5AK6qPE464KrGZhCmDGyAKr6tB0LkgILS7lEAovhzALlAR9a50YXX40jQRwfw7\n/vs9MhG7KecHlpKFKu6CwfUBqM7QaF9jBNyYUoPMJ/O4IJkp+OiDBpi4pqpgTXmv\n9kqwqTmzAd9/oaWi6/Rb4ztSWxM2FLDGXyaT6e4a4GpMCDvdODtgHNDKpj8DOp2E\nfQzBMLc/vtCkIcO0O3i+IDrhRglv1ImjDLCdSP/31Do/0cpLHZOE9hym4unw6ARM\nfMnG3vc2Yp0e4C1Il3iPWlyMiW9h56TWiO0LGBm1dQAcFkn3siU=\n=InvA\n-----END PGP SIGNATURE-----", "payload": "tree cd0e25895e11c8c70e296b98de5fc8a16073c324\nparent 8954b16beb844fcac0cefe229e1c714a17de16e5\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1513235359 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1513246928 +0100\n\nUse PathBuf instead of String where applicable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d732da813bac73d2c81caddd06df3df3d9609e3d", "html_url": "https://github.com/rust-lang/rust/commit/d732da813bac73d2c81caddd06df3df3d9609e3d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d732da813bac73d2c81caddd06df3df3d9609e3d/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8954b16beb844fcac0cefe229e1c714a17de16e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8954b16beb844fcac0cefe229e1c714a17de16e5", "html_url": "https://github.com/rust-lang/rust/commit/8954b16beb844fcac0cefe229e1c714a17de16e5"}], "stats": {"total": 753, "additions": 444, "deletions": 309}, "files": [{"sha": "625edc02b7729dddf42aa853d18e527a9ccd7ce8", "filename": "src/libproc_macro/lib.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibproc_macro%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibproc_macro%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibproc_macro%2Flib.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -59,7 +59,7 @@ use syntax::parse::{self, token};\n use syntax::symbol::Symbol;\n use syntax::tokenstream;\n use syntax_pos::DUMMY_SP;\n-use syntax_pos::{FileMap, Pos, SyntaxContext};\n+use syntax_pos::{FileMap, Pos, SyntaxContext, FileName};\n use syntax_pos::hygiene::Mark;\n \n /// The main type provided by this crate, representing an abstract stream of\n@@ -89,7 +89,7 @@ impl FromStr for TokenStream {\n     fn from_str(src: &str) -> Result<TokenStream, LexError> {\n         __internal::with_sess(|(sess, mark)| {\n             let src = src.to_string();\n-            let name = \"<proc-macro source code>\".to_string();\n+            let name = FileName::ProcMacroSourceCode;\n             let expn_info = mark.expn_info().unwrap();\n             let call_site = expn_info.call_site;\n             // notify the expansion info that it is unhygienic\n@@ -279,7 +279,7 @@ pub struct SourceFile {\n }\n \n impl SourceFile {\n-    /// Get the path to this source file as a string.\n+    /// Get the path to this source file.\n     ///\n     /// ### Note\n     /// If the code span associated with this `SourceFile` was generated by an external macro, this\n@@ -290,7 +290,7 @@ impl SourceFile {\n     ///\n     /// [`is_real`]: #method.is_real\n     # [unstable(feature = \"proc_macro\", issue = \"38356\")]\n-    pub fn as_str(&self) -> &str {\n+    pub fn path(&self) -> &FileName {\n         &self.filemap.name\n     }\n \n@@ -306,17 +306,17 @@ impl SourceFile {\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl AsRef<str> for SourceFile {\n-    fn as_ref(&self) -> &str {\n-        self.as_str()\n+impl AsRef<FileName> for SourceFile {\n+    fn as_ref(&self) -> &FileName {\n+        self.path()\n     }\n }\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n impl fmt::Debug for SourceFile {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"SourceFile\")\n-            .field(\"path\", &self.as_str())\n+            .field(\"path\", self.path())\n             .field(\"is_real\", &self.is_real())\n             .finish()\n     }\n@@ -333,8 +333,8 @@ impl PartialEq for SourceFile {\n impl Eq for SourceFile {}\n \n #[unstable(feature = \"proc_macro\", issue = \"38356\")]\n-impl PartialEq<str> for SourceFile {\n-    fn eq(&self, other: &str) -> bool {\n+impl PartialEq<FileName> for SourceFile {\n+    fn eq(&self, other: &FileName) -> bool {\n         self.as_ref() == other\n     }\n }"}, {"sha": "fb502ecb996ae9668ec69e7f37a80ebc0acc3a9c", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -21,7 +21,7 @@ use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax::util::parser::{self, AssocOp, Fixity};\n-use syntax_pos::{self, BytePos};\n+use syntax_pos::{self, BytePos, FileName};\n \n use hir;\n use hir::{PatKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier, RangeEnd};\n@@ -125,7 +125,7 @@ pub const default_columns: usize = 78;\n pub fn print_crate<'a>(cm: &'a CodeMap,\n                        sess: &ParseSess,\n                        krate: &hir::Crate,\n-                       filename: String,\n+                       filename: FileName,\n                        input: &mut Read,\n                        out: Box<Write + 'a>,\n                        ann: &'a PpAnn,\n@@ -144,7 +144,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n                           sess: &ParseSess,\n-                          filename: String,\n+                          filename: FileName,\n                           input: &mut Read,\n                           out: Box<Write + 'a>,\n                           ann: &'a PpAnn,"}, {"sha": "c25aa10eb1e73d45052e426a9d325ece5b18ae67", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -371,6 +371,17 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n     QuestionMark\n });\n \n+impl_stable_hash_for!(enum ::syntax_pos::FileName {\n+    Real(pb),\n+    Macros(s),\n+    QuoteExpansion,\n+    Anon,\n+    MacroExpansion,\n+    ProcMacroSourceCode,\n+    CfgSpec,\n+    Custom(s)\n+});\n+\n impl<'gcx> HashStable<StableHashingContext<'gcx>> for FileMap {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'gcx>,"}, {"sha": "e80ea16f565abc64dbda58cbcd0aa602c9066316", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -607,7 +607,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 let span_key = msp.primary_span().and_then(|sp: Span|\n                     if sp != DUMMY_SP {\n                         let file = cm.lookup_char_pos(sp.lo()).file;\n-                        if file.name.starts_with(\"<\") && file.name.ends_with(\" macros>\") {\n+                        if file.name.is_macros() {\n                             None\n                         } else {\n                             Some(span)"}, {"sha": "d4d33af1d59e381b0d4484f1aec28eed9a462bba", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 28, "deletions": 9, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -27,7 +27,7 @@ use lint;\n use middle::cstore;\n \n use syntax::ast::{self, IntTy, UintTy};\n-use syntax::codemap::FilePathMapping;\n+use syntax::codemap::{FilePathMapping, FileName};\n use syntax::parse::token;\n use syntax::parse;\n use syntax::symbol::Symbol;\n@@ -440,7 +440,7 @@ pub enum Input {\n     File(PathBuf),\n     Str {\n         /// String that is shown in place of a filename\n-        name: String,\n+        name: FileName,\n         /// Anonymous source string\n         input: String,\n     },\n@@ -733,7 +733,9 @@ macro_rules! options {\n             Some(\"one of: `y`, `yes`, `on`, `n`, `no`, or `off`\");\n         pub const parse_string: Option<&'static str> = Some(\"a string\");\n         pub const parse_string_push: Option<&'static str> = Some(\"a string\");\n+        pub const parse_pathbuf_push: Option<&'static str> = Some(\"a path\");\n         pub const parse_opt_string: Option<&'static str> = Some(\"a string\");\n+        pub const parse_opt_pathbuf: Option<&'static str> = Some(\"a path\");\n         pub const parse_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n         pub const parse_opt_list: Option<&'static str> = Some(\"a space-separated list of strings\");\n         pub const parse_uint: Option<&'static str> = Some(\"a number\");\n@@ -757,6 +759,7 @@ macro_rules! options {\n     mod $mod_set {\n         use super::{$struct_name, Passes, SomePasses, AllPasses, Sanitizer};\n         use rustc_back::{LinkerFlavor, PanicStrategy, RelroLevel};\n+        use std::path::PathBuf;\n \n         $(\n             pub fn $opt(cg: &mut $struct_name, v: Option<&str>) -> bool {\n@@ -797,6 +800,13 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_opt_pathbuf(slot: &mut Option<PathBuf>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { *slot = Some(PathBuf::from(s)); true },\n+                None => false,\n+            }\n+        }\n+\n         fn parse_string(slot: &mut String, v: Option<&str>) -> bool {\n             match v {\n                 Some(s) => { *slot = s.to_string(); true },\n@@ -811,6 +821,13 @@ macro_rules! options {\n             }\n         }\n \n+        fn parse_pathbuf_push(slot: &mut Vec<PathBuf>, v: Option<&str>) -> bool {\n+            match v {\n+                Some(s) => { slot.push(PathBuf::from(s)); true },\n+                None => false,\n+            }\n+        }\n+\n         fn parse_list(slot: &mut Vec<String>, v: Option<&str>)\n                       -> bool {\n             match v {\n@@ -931,7 +948,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n          CG_OPTIONS, cg_type_desc, cgsetters,\n     ar: Option<String> = (None, parse_opt_string, [UNTRACKED],\n         \"this option is deprecated and does nothing\"),\n-    linker: Option<String> = (None, parse_opt_string, [UNTRACKED],\n+    linker: Option<PathBuf> = (None, parse_opt_pathbuf, [UNTRACKED],\n         \"system linker to link outputs with\"),\n     link_arg: Vec<String> = (vec![], parse_string_push, [UNTRACKED],\n         \"a single extra argument to append to the linker invocation (can be used several times)\"),\n@@ -1151,9 +1168,9 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n         \"set the optimization fuel quota for a crate\"),\n     print_fuel: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"make Rustc print the total optimization fuel used by a crate\"),\n-    remap_path_prefix_from: Vec<String> = (vec![], parse_string_push, [TRACKED],\n+    remap_path_prefix_from: Vec<PathBuf> = (vec![], parse_pathbuf_push, [TRACKED],\n         \"add a source pattern to the file path remapping config\"),\n-    remap_path_prefix_to: Vec<String> = (vec![], parse_string_push, [TRACKED],\n+    remap_path_prefix_to: Vec<PathBuf> = (vec![], parse_pathbuf_push, [TRACKED],\n         \"add a mapping target to the file path remapping config\"),\n     force_unstable_if_unmarked: bool = (false, parse_bool, [TRACKED],\n         \"force all crates to be `rustc_private` unstable\"),\n@@ -1472,7 +1489,7 @@ pub fn parse_cfgspecs(cfgspecs: Vec<String> ) -> ast::CrateConfig {\n     cfgspecs.into_iter().map(|s| {\n         let sess = parse::ParseSess::new(FilePathMapping::empty());\n         let mut parser =\n-            parse::new_parser_from_source_str(&sess, \"cfgspec\".to_string(), s.to_string());\n+            parse::new_parser_from_source_str(&sess, FileName::CfgSpec, s.to_string());\n \n         let meta_item = panictry!(parser.parse_meta_item());\n \n@@ -1594,13 +1611,13 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         for source in &debugging_opts.remap_path_prefix_from[remap_path_prefix_targets..] {\n             early_error(error_format,\n                 &format!(\"option `-Zremap-path-prefix-from='{}'` does not have \\\n-                         a corresponding `-Zremap-path-prefix-to`\", source))\n+                         a corresponding `-Zremap-path-prefix-to`\", source.display()))\n         }\n     } else if remap_path_prefix_targets > remap_path_prefix_sources {\n         for target in &debugging_opts.remap_path_prefix_to[remap_path_prefix_sources..] {\n             early_error(error_format,\n                 &format!(\"option `-Zremap-path-prefix-to='{}'` does not have \\\n-                          a corresponding `-Zremap-path-prefix-from`\", target))\n+                          a corresponding `-Zremap-path-prefix-from`\", target.display()))\n         }\n     }\n \n@@ -2001,6 +2018,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(usize);\n     impl_dep_tracking_hash_via_hash!(u64);\n     impl_dep_tracking_hash_via_hash!(String);\n+    impl_dep_tracking_hash_via_hash!(PathBuf);\n     impl_dep_tracking_hash_via_hash!(lint::Level);\n     impl_dep_tracking_hash_via_hash!(Option<bool>);\n     impl_dep_tracking_hash_via_hash!(Option<usize>);\n@@ -2025,6 +2043,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(Option<Sanitizer>);\n \n     impl_dep_tracking_hash_for_sortable_vec_of!(String);\n+    impl_dep_tracking_hash_for_sortable_vec_of!(PathBuf);\n     impl_dep_tracking_hash_for_sortable_vec_of!(CrateType);\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, lint::Level));\n     impl_dep_tracking_hash_for_sortable_vec_of!((String, Option<String>,\n@@ -2533,7 +2552,7 @@ mod tests {\n         opts.cg.ar = Some(String::from(\"abc\"));\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n-        opts.cg.linker = Some(String::from(\"linker\"));\n+        opts.cg.linker = Some(PathBuf::from(\"linker\"));\n         assert_eq!(reference.dep_tracking_hash(), opts.dep_tracking_hash());\n \n         opts.cg.link_args = Some(vec![String::from(\"abc\"), String::from(\"def\")]);"}, {"sha": "d6f72fb116dc04121fa7ab90900620bcb1a0bf32", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -69,10 +69,10 @@ pub struct Session {\n     pub default_sysroot: Option<PathBuf>,\n     /// The name of the root source file of the crate, in the local file system.\n     /// `None` means that there is no source file.\n-    pub local_crate_source_file: Option<String>,\n+    pub local_crate_source_file: Option<PathBuf>,\n     /// The directory the compiler has been executed in plus a flag indicating\n     /// if the value stored here has been affected by path remapping.\n-    pub working_dir: (String, bool),\n+    pub working_dir: (PathBuf, bool),\n     pub lint_store: RefCell<lint::LintStore>,\n     pub buffered_lints: RefCell<Option<lint::LintBuffer>>,\n     /// Set of (DiagnosticId, Option<Span>, message) tuples tracking\n@@ -864,7 +864,7 @@ pub fn build_session_(sopts: config::Options,\n     let file_path_mapping = sopts.file_path_mapping();\n \n     let local_crate_source_file = local_crate_source_file.map(|path| {\n-        file_path_mapping.map_prefix(path.to_string_lossy().into_owned()).0\n+        file_path_mapping.map_prefix(path).0\n     });\n \n     let optimization_fuel_crate = sopts.debugging_opts.fuel.as_ref().map(|i| i.0.clone());\n@@ -874,7 +874,7 @@ pub fn build_session_(sopts: config::Options,\n     let print_fuel = Cell::new(0);\n \n     let working_dir = match env::current_dir() {\n-        Ok(dir) => dir.to_string_lossy().into_owned(),\n+        Ok(dir) => dir,\n         Err(e) => {\n             panic!(p_s.span_diagnostic.fatal(&format!(\"Current directory is invalid: {}\", e)))\n         }"}, {"sha": "a9ad0a591880e88ce602fcdb59559ce239654ad8", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -59,6 +59,7 @@ use syntax::ext::base::ExtCtxt;\n use syntax::fold::Folder;\n use syntax::parse::{self, PResult};\n use syntax::util::node_count::NodeCounter;\n+use syntax_pos::FileName;\n use syntax;\n use syntax_ext;\n use arena::DroplessArena;\n@@ -306,17 +307,9 @@ fn keep_hygiene_data(sess: &Session) -> bool {\n     sess.opts.debugging_opts.keep_hygiene_data\n }\n \n-\n-/// The name used for source code that doesn't originate in a file\n-/// (e.g. source from stdin or a string)\n-pub fn anon_src() -> String {\n-    \"<anon>\".to_string()\n-}\n-\n-pub fn source_name(input: &Input) -> String {\n+pub fn source_name(input: &Input) -> FileName {\n     match *input {\n-        // FIXME (#9639): This needs to handle non-utf8 paths\n-        Input::File(ref ifile) => ifile.to_str().unwrap().to_string(),\n+        Input::File(ref ifile) => ifile.clone().into(),\n         Input::Str { ref name, .. } => name.clone(),\n     }\n }\n@@ -573,7 +566,9 @@ pub fn phase_1_parse_input<'a>(control: &CompileController,\n                 parse::parse_crate_from_file(file, &sess.parse_sess)\n             }\n             Input::Str { ref input, ref name } => {\n-                parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n+                parse::parse_crate_from_source_str(name.clone(),\n+                                                   input.clone(),\n+                                                   &sess.parse_sess)\n             }\n         }\n     })?;\n@@ -1135,10 +1130,10 @@ pub fn phase_5_run_llvm_passes<Trans: TransCrate>(sess: &Session,\n     (sess.compile_status(), trans)\n }\n \n-fn escape_dep_filename(filename: &str) -> String {\n+fn escape_dep_filename(filename: &FileName) -> String {\n     // Apparently clang and gcc *only* escape spaces:\n     // http://llvm.org/klaus/clang/commit/9d50634cfc268ecc9a7250226dd5ca0e945240d4\n-    filename.replace(\" \", \"\\\\ \")\n+    filename.to_string().replace(\" \", \"\\\\ \")\n }\n \n fn write_out_deps(sess: &Session, outputs: &OutputFilenames, crate_name: &str) {"}, {"sha": "8bfcb0cca05b48dae94eceb888cdf7b8c3557c3c", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -98,7 +98,7 @@ use syntax::ast;\n use syntax::codemap::{CodeMap, FileLoader, RealFileLoader};\n use syntax::feature_gate::{GatedCfg, UnstableFeatures};\n use syntax::parse::{self, PResult};\n-use syntax_pos::{DUMMY_SP, MultiSpan};\n+use syntax_pos::{DUMMY_SP, MultiSpan, FileName};\n \n #[cfg(test)]\n mod test;\n@@ -274,7 +274,7 @@ fn make_input(free_matches: &[String]) -> Option<(Input, Option<PathBuf>)> {\n         if ifile == \"-\" {\n             let mut src = String::new();\n             io::stdin().read_to_string(&mut src).unwrap();\n-            Some((Input::Str { name: driver::anon_src(), input: src },\n+            Some((Input::Str { name: FileName::Anon, input: src },\n                   None))\n         } else {\n             Some((Input::File(PathBuf::from(ifile)),\n@@ -1165,7 +1165,9 @@ fn parse_crate_attrs<'a>(sess: &'a Session, input: &Input) -> PResult<'a, Vec<as\n             parse::parse_crate_attrs_from_file(ifile, &sess.parse_sess)\n         }\n         Input::Str { ref name, ref input } => {\n-            parse::parse_crate_attrs_from_source_str(name.clone(), input.clone(), &sess.parse_sess)\n+            parse::parse_crate_attrs_from_source_str(name.clone(),\n+                                                     input.clone(),\n+                                                     &sess.parse_sess)\n         }\n     }\n }"}, {"sha": "8d99ed858ee0eb77d1a1a9ed4422ea42a89dc357", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -34,7 +34,7 @@ use syntax::print::{pprust};\n use syntax::print::pprust::PrintState;\n use syntax::ptr::P;\n use syntax::util::small_vector::SmallVector;\n-use syntax_pos;\n+use syntax_pos::{self, FileName};\n \n use graphviz as dot;\n \n@@ -841,7 +841,7 @@ pub fn fold_crate(sess: &Session, krate: ast::Crate, ppm: PpMode) -> ast::Crate\n     }\n }\n \n-fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, String) {\n+fn get_source(input: &Input, sess: &Session) -> (Vec<u8>, FileName) {\n     let src_name = driver::source_name(input);\n     let src = sess.codemap()\n         .get_filemap(&src_name)\n@@ -885,7 +885,7 @@ pub fn print_after_parsing(sess: &Session,\n                 pprust::print_crate(sess.codemap(),\n                                     &sess.parse_sess,\n                                     krate,\n-                                    src_name.to_string(),\n+                                    src_name,\n                                     &mut rdr,\n                                     box out,\n                                     annotation.pp_ann(),\n@@ -944,7 +944,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     pprust::print_crate(sess.codemap(),\n                                         &sess.parse_sess,\n                                         krate,\n-                                        src_name.to_string(),\n+                                        src_name,\n                                         &mut rdr,\n                                         box out,\n                                         annotation.pp_ann(),\n@@ -969,7 +969,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     pprust_hir::print_crate(sess.codemap(),\n                                             &sess.parse_sess,\n                                             krate,\n-                                            src_name.to_string(),\n+                                            src_name,\n                                             &mut rdr,\n                                             box out,\n                                             annotation.pp_ann(),\n@@ -1011,7 +1011,7 @@ pub fn print_after_hir_lowering<'tcx, 'a: 'tcx>(sess: &'a Session,\n                     let hir_map = annotation.hir_map().expect(\"--unpretty missing HIR map\");\n                     let mut pp_state = pprust_hir::State::new_from_input(sess.codemap(),\n                                                                          &sess.parse_sess,\n-                                                                         src_name.to_string(),\n+                                                                         src_name,\n                                                                          &mut rdr,\n                                                                          box out,\n                                                                          annotation.pp_ann(),"}, {"sha": "f04e01f3f961df8b06be762676bad50cd10943ee", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -33,7 +33,7 @@ use rustc_trans_utils::trans_crate::TransCrate;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::abi::Abi;\n-use syntax::codemap::{CodeMap, FilePathMapping};\n+use syntax::codemap::{CodeMap, FilePathMapping, FileName};\n use errors;\n use errors::emitter::Emitter;\n use errors::{Level, DiagnosticBuilder};\n@@ -113,7 +113,7 @@ fn test_env<F>(source_string: &str,\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n     let input = config::Input::Str {\n-        name: driver::anon_src(),\n+        name: FileName::Anon,\n         input: source_string.to_string(),\n     };\n     let krate = driver::phase_1_parse_input(&driver::CompileController::basic(),"}, {"sha": "6bba6fbc295c53d3e8d9d118c99f9e903aaa6e43", "filename": "src/librustc_errors/emitter.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_errors%2Femitter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_errors%2Femitter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Femitter.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -765,7 +765,7 @@ impl EmitterWriter {\n                                                      })));\n                         }\n                         // Check to make sure we're not in any <*macros>\n-                        if !cm.span_to_filename(def_site).contains(\"macros>\") &&\n+                        if !cm.span_to_filename(def_site).is_macros() &&\n                            !trace.macro_decl_name.starts_with(\"#[\") ||\n                            always_backtrace {\n                             new_labels.push((trace.call_site,\n@@ -791,7 +791,7 @@ impl EmitterWriter {\n                 if sp_label.span == DUMMY_SP {\n                     continue;\n                 }\n-                if cm.span_to_filename(sp_label.span.clone()).contains(\"macros>\") &&\n+                if cm.span_to_filename(sp_label.span.clone()).is_macros() &&\n                     !always_backtrace\n                 {\n                     let v = sp_label.span.macro_backtrace();\n@@ -987,14 +987,20 @@ impl EmitterWriter {\n \n                     buffer.prepend(buffer_msg_line_offset, \"--> \", Style::LineNumber);\n                     buffer.append(buffer_msg_line_offset,\n-                                  &format!(\"{}:{}:{}\", loc.file.name, loc.line, loc.col.0 + 1),\n+                                  &format!(\"{}:{}:{}\",\n+                                           loc.file.name,\n+                                           loc.line,\n+                                           loc.col.0 + 1),\n                                   Style::LineAndColumn);\n                     for _ in 0..max_line_num_len {\n                         buffer.prepend(buffer_msg_line_offset, \" \", Style::NoStyle);\n                     }\n                 } else {\n                     buffer.prepend(0,\n-                                   &format!(\"{}:{}:{} - \", loc.file.name, loc.line, loc.col.0 + 1),\n+                                   &format!(\"{}:{}:{} - \",\n+                                            loc.file.name,\n+                                            loc.line,\n+                                            loc.col.0 + 1),\n                                    Style::LineAndColumn);\n                 }\n             } else if !self.short_message {\n@@ -1007,7 +1013,7 @@ impl EmitterWriter {\n                 // Then, the secondary file indicator\n                 buffer.prepend(buffer_msg_line_offset + 1, \"::: \", Style::LineNumber);\n                 buffer.append(buffer_msg_line_offset + 1,\n-                              &annotated_file.file.name,\n+                              &annotated_file.file.name.to_string(),\n                               Style::LineAndColumn);\n                 for _ in 0..max_line_num_len {\n                     buffer.prepend(buffer_msg_line_offset + 1, \" \", Style::NoStyle);"}, {"sha": "90580de07be566d18ed0857a8ebe5b804b49c91b", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -37,7 +37,7 @@ use syntax::attr;\n use syntax::ext::base::SyntaxExtension;\n use syntax::parse::filemap_to_stream;\n use syntax::symbol::Symbol;\n-use syntax_pos::{Span, NO_EXPANSION};\n+use syntax_pos::{Span, NO_EXPANSION, FileName};\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc::hir;\n \n@@ -460,7 +460,7 @@ impl CrateStore for cstore::CStore {\n         }\n \n         let (name, def) = data.get_macro(id.index);\n-        let source_name = format!(\"<{} macros>\", name);\n+        let source_name = FileName::Macros(name.to_string());\n \n         let filemap = sess.parse_sess.codemap().new_filemap(source_name, def.body);\n         let local_span = Span::new(filemap.start_pos, filemap.end_pos, NO_EXPANSION);"}, {"sha": "caeee989283fc4b4c362a5308c1875af23868e31", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -39,7 +39,7 @@ use syntax::ast::{self, CRATE_NODE_ID};\n use syntax::codemap::Spanned;\n use syntax::attr;\n use syntax::symbol::Symbol;\n-use syntax_pos;\n+use syntax_pos::{self, FileName};\n \n use rustc::hir::{self, PatKind};\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n@@ -279,20 +279,22 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 // `-Zremap-path-prefix` we assume the user has already set\n                 // things up the way they want and don't touch the path values\n                 // anymore.\n-                let name = Path::new(&filemap.name);\n-                if filemap.name_was_remapped ||\n-                   (name.is_relative() && working_dir_was_remapped) {\n-                    // This path of this FileMap has been modified by\n-                    // path-remapping, so we use it verbatim (and avoid cloning\n-                    // the whole map in the process).\n-                    filemap.clone()\n-                } else {\n-                    let mut adapted = (**filemap).clone();\n-                    let abs_path = Path::new(&working_dir).join(name)\n-                                                         .to_string_lossy()\n-                                                         .into_owned();\n-                    adapted.name = abs_path;\n-                    Rc::new(adapted)\n+                match filemap.name {\n+                    FileName::Real(ref name) => {\n+                        if filemap.name_was_remapped ||\n+                        (name.is_relative() && working_dir_was_remapped) {\n+                            // This path of this FileMap has been modified by\n+                            // path-remapping, so we use it verbatim (and avoid cloning\n+                            // the whole map in the process).\n+                            filemap.clone()\n+                        } else {\n+                            let mut adapted = (**filemap).clone();\n+                            adapted.name = Path::new(&working_dir).join(name).into();\n+                            Rc::new(adapted)\n+                        }\n+                    },\n+                    // expanded code, not from a file\n+                    _ => filemap.clone(),\n                 }\n             })\n             .collect::<Vec<_>>();"}, {"sha": "7989dba11f7b8eb5a2c167b4b0d370d76c15f0c6", "filename": "src/librustc_save_analysis/dump_visitor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_save_analysis%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fdump_visitor.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -1359,7 +1359,7 @@ impl<'l, 'tcx: 'l, 'll, O: DumpOutput + 'll> Visitor<'l> for DumpVisitor<'l, 'tc\n                 name: String::new(),\n                 qualname,\n                 span,\n-                value: filename,\n+                value: filename.to_string(),\n                 children,\n                 parent: None,\n                 decl_id: None,"}, {"sha": "a815c81a6fe0bb9b68e0b030b2ebecb0496df4ab", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -93,7 +93,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n         let end = cm.lookup_char_pos(span.hi());\n \n         SpanData {\n-            file_name: start.file.name.clone().into(),\n+            file_name: start.file.name.clone().to_string().into(),\n             byte_start: span.lo().0,\n             byte_end: span.hi().0,\n             line_start: Row::new_one_indexed(start.line as u32),\n@@ -117,6 +117,8 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n             };\n             let lo_loc = self.span_utils.sess.codemap().lookup_char_pos(span.lo());\n             result.push(ExternalCrateData {\n+                // FIXME: change file_name field to PathBuf in rls-data\n+                // https://github.com/nrc/rls-data/issues/7\n                 file_name: SpanUtils::make_path_string(&lo_loc.file.name),\n                 num: n.as_u32(),\n                 id: GlobalCrateId {\n@@ -271,7 +273,7 @@ impl<'l, 'tcx: 'l> SaveContext<'l, 'tcx> {\n                     name: item.ident.to_string(),\n                     qualname,\n                     span: self.span_from_span(sub_span.unwrap()),\n-                    value: filename,\n+                    value: filename.to_string(),\n                     parent: None,\n                     children: m.items\n                         .iter()"}, {"sha": "25e81e6f326e1c8ae04318828c5cac3295b43ee7", "filename": "src/librustc_save_analysis/span_utils.rs", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_save_analysis%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fspan_utils.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -14,7 +14,6 @@ use generated_code;\n \n use std::cell::Cell;\n use std::env;\n-use std::path::Path;\n \n use syntax::parse::lexer::{self, StringReader};\n use syntax::parse::token::{self, Token};\n@@ -37,16 +36,15 @@ impl<'a> SpanUtils<'a> {\n         }\n     }\n \n-    pub fn make_path_string(file_name: &str) -> String {\n-        let path = Path::new(file_name);\n-        if path.is_absolute() {\n-            path.clone().display().to_string()\n-        } else {\n-            env::current_dir()\n-                .unwrap()\n-                .join(&path)\n-                .display()\n-                .to_string()\n+    pub fn make_path_string(path: &FileName) -> String {\n+        match *path {\n+            FileName::Real(ref path) if !path.is_absolute() =>\n+                env::current_dir()\n+                    .unwrap()\n+                    .join(&path)\n+                    .display()\n+                    .to_string(),\n+            _ => path.to_string(),\n         }\n     }\n "}, {"sha": "ec1c7e16c71f006ce43a61d7a8b0ce17fda56787", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -57,7 +57,7 @@ pub use rustc_trans_utils::link::{find_crate_name, filename_for_input, default_o\n // The third parameter is for env vars, used on windows to set up the\n // path for MSVC to find its DLLs, and gcc to find its bundled\n // toolchain\n-pub fn get_linker(sess: &Session) -> (String, Command, Vec<(OsString, OsString)>) {\n+pub fn get_linker(sess: &Session) -> (PathBuf, Command, Vec<(OsString, OsString)>) {\n     let envs = vec![(\"PATH\".into(), command_path(sess))];\n \n     // If our linker looks like a batch script on Windows then to execute this\n@@ -68,7 +68,7 @@ pub fn get_linker(sess: &Session) -> (String, Command, Vec<(OsString, OsString)>\n     // This worked historically but is needed manually since #42436 (regression\n     // was tagged as #42791) and some more info can be found on #44443 for\n     // emscripten itself.\n-    let cmd = |linker: &str| {\n+    let cmd = |linker: &Path| {\n         if cfg!(windows) && linker.ends_with(\".bat\") {\n             let mut cmd = Command::new(\"cmd\");\n             cmd.arg(\"/c\").arg(linker);\n@@ -82,10 +82,11 @@ pub fn get_linker(sess: &Session) -> (String, Command, Vec<(OsString, OsString)>\n         (linker.clone(), cmd(linker), envs)\n     } else if sess.target.target.options.is_like_msvc {\n         let (cmd, envs) = msvc_link_exe_cmd(sess);\n-        (\"link.exe\".to_string(), cmd, envs)\n+        (PathBuf::from(\"link.exe\"), cmd, envs)\n     } else {\n-        let linker = &sess.target.target.options.linker;\n-        (linker.clone(), cmd(linker), envs)\n+        let linker = PathBuf::from(&sess.target.target.options.linker);\n+        let cmd = cmd(&linker);\n+        (linker, cmd, envs)\n     }\n }\n \n@@ -696,7 +697,7 @@ fn link_natively(sess: &Session,\n                 let mut output = prog.stderr.clone();\n                 output.extend_from_slice(&prog.stdout);\n                 sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n-                                         pname,\n+                                         pname.display(),\n                                          prog.status))\n                     .note(&format!(\"{:?}\", &cmd))\n                     .note(&escape_string(&output))\n@@ -707,7 +708,7 @@ fn link_natively(sess: &Session,\n             info!(\"linker stdout:\\n{}\", escape_string(&prog.stdout));\n         },\n         Err(e) => {\n-            sess.struct_err(&format!(\"could not exec the linker `{}`: {}\", pname, e))\n+            sess.struct_err(&format!(\"could not exec the linker `{}`: {}\", pname.display(), e))\n                 .note(&format!(\"{:?}\", &cmd))\n                 .emit();\n             if sess.target.target.options.is_like_msvc && e.kind() == io::ErrorKind::NotFound {"}, {"sha": "d8e95cd2cf2e0cb1138a040ef8f88a63a5c5f386", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -1955,7 +1955,7 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n                 note.extend_from_slice(&prog.stdout);\n \n                 sess.struct_err(&format!(\"linking with `{}` failed: {}\",\n-                                         pname,\n+                                         pname.display(),\n                                          prog.status))\n                     .note(&format!(\"{:?}\", &cmd))\n                     .note(str::from_utf8(&note[..]).unwrap())\n@@ -1964,7 +1964,7 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n             }\n         },\n         Err(e) => {\n-            sess.err(&format!(\"could not exec the linker `{}`: {}\", pname, e));\n+            sess.err(&format!(\"could not exec the linker `{}`: {}\", pname.display(), e));\n             sess.abort_if_errors();\n         }\n     }"}, {"sha": "d09272df3451d1079c5b47f7075890804a437766", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -41,10 +41,10 @@ use libc::{c_uint, c_longlong};\n use std::ffi::CString;\n use std::fmt::Write;\n use std::ptr;\n-use std::path::Path;\n+use std::path::{Path, PathBuf};\n use syntax::ast;\n use syntax::symbol::{Interner, InternedString, Symbol};\n-use syntax_pos::{self, Span};\n+use syntax_pos::{self, Span, FileName};\n \n \n // From DWARF 5.\n@@ -675,21 +675,21 @@ pub fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n }\n \n pub fn file_metadata(cx: &CrateContext,\n-                     file_name: &str,\n+                     file_name: &FileName,\n                      defining_crate: CrateNum) -> DIFile {\n     debug!(\"file_metadata: file_name: {}, defining_crate: {}\",\n            file_name,\n            defining_crate);\n \n     let directory = if defining_crate == LOCAL_CRATE {\n-        &cx.sess().working_dir.0[..]\n+        &cx.sess().working_dir.0\n     } else {\n         // If the path comes from an upstream crate we assume it has been made\n         // independent of the compiler's working directory one way or another.\n-        \"\"\n+        Path::new(\"\")\n     };\n \n-    file_metadata_raw(cx, file_name, directory)\n+    file_metadata_raw(cx, &file_name.to_string(), &directory.to_string_lossy())\n }\n \n pub fn unknown_file_metadata(cx: &CrateContext) -> DIFile {\n@@ -792,25 +792,26 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n                              -> DIDescriptor {\n     let mut name_in_debuginfo = match sess.local_crate_source_file {\n         Some(ref path) => path.clone(),\n-        None => scc.tcx().crate_name(LOCAL_CRATE).to_string(),\n+        None => PathBuf::from(&*scc.tcx().crate_name(LOCAL_CRATE).as_str()),\n     };\n \n     // The OSX linker has an idiosyncrasy where it will ignore some debuginfo\n     // if multiple object files with the same DW_AT_name are linked together.\n     // As a workaround we generate unique names for each object file. Those do\n     // not correspond to an actual source file but that should be harmless.\n     if scc.sess().target.target.options.is_like_osx {\n-        name_in_debuginfo.push_str(\"@\");\n-        name_in_debuginfo.push_str(codegen_unit_name);\n+        name_in_debuginfo.push(\"@\");\n+        name_in_debuginfo.push(codegen_unit_name);\n     }\n \n     debug!(\"compile_unit_metadata: {:?}\", name_in_debuginfo);\n     // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n     let producer = format!(\"clang LLVM (rustc version {})\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n+    let name_in_debuginfo = name_in_debuginfo.to_string_lossy().into_owned();\n     let name_in_debuginfo = CString::new(name_in_debuginfo).unwrap();\n-    let work_dir = CString::new(&sess.working_dir.0[..]).unwrap();\n+    let work_dir = CString::new(&sess.working_dir.0.to_string_lossy()[..]).unwrap();\n     let producer = CString::new(producer).unwrap();\n     let flags = \"\\0\";\n     let split_name = \"\\0\";"}, {"sha": "e9350256c3055dec882b8cbcb79b029da3e60e3a", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -469,7 +469,7 @@ pub fn declare_local<'a, 'tcx>(bcx: &Builder<'a, 'tcx>,\n \n     let file = span_start(cx, span).file;\n     let file_metadata = file_metadata(cx,\n-                                      &file.name[..],\n+                                      &file.name,\n                                       dbg_context.get_ref(span).defining_crate);\n \n     let loc = span_start(cx, span);"}, {"sha": "fd3408676db8c0cb89e835057a285dd9744f8486", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -335,7 +335,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n                 // Get the location information.\n                 let loc = bcx.sess().codemap().lookup_char_pos(span.lo());\n-                let filename = Symbol::intern(&loc.file.name).as_str();\n+                let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n                 let filename = C_str_slice(bcx.ccx, filename);\n                 let line = C_u32(bcx.ccx, loc.line as u32);\n                 let col = C_u32(bcx.ccx, loc.col.to_usize() as u32 + 1);"}, {"sha": "91908de98a65d89a1117adb9218cbd3a22e45c82", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -25,7 +25,7 @@ use syntax::attr;\n use syntax::codemap::Spanned;\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n-use syntax_pos::{self, DUMMY_SP, Pos};\n+use syntax_pos::{self, DUMMY_SP, Pos, FileName};\n \n use rustc::middle::const_val::ConstVal;\n use rustc::middle::privacy::AccessLevels;\n@@ -45,7 +45,6 @@ use rustc::hir;\n use rustc_const_math::ConstInt;\n use std::{mem, slice, vec};\n use std::iter::FromIterator;\n-use std::path::PathBuf;\n use std::rc::Rc;\n use std::sync::Arc;\n use std::u32;\n@@ -114,7 +113,7 @@ impl<T: Clean<U>, U> Clean<Vec<U>> for P<[T]> {\n pub struct Crate {\n     pub name: String,\n     pub version: Option<String>,\n-    pub src: PathBuf,\n+    pub src: FileName,\n     pub module: Option<Item>,\n     pub externs: Vec<(CrateNum, ExternalCrate)>,\n     pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n@@ -200,7 +199,7 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct ExternalCrate {\n     pub name: String,\n-    pub src: PathBuf,\n+    pub src: FileName,\n     pub attrs: Attributes,\n     pub primitives: Vec<(DefId, PrimitiveType, Attributes)>,\n }\n@@ -271,7 +270,7 @@ impl Clean<ExternalCrate> for CrateNum {\n \n         ExternalCrate {\n             name: cx.tcx.crate_name(*self).to_string(),\n-            src: PathBuf::from(krate_src),\n+            src: krate_src,\n             attrs: cx.tcx.get_attrs(root).clean(cx),\n             primitives,\n         }\n@@ -2518,7 +2517,7 @@ impl Clean<VariantKind> for hir::VariantData {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Span {\n-    pub filename: String,\n+    pub filename: FileName,\n     pub loline: usize,\n     pub locol: usize,\n     pub hiline: usize,\n@@ -2528,7 +2527,7 @@ pub struct Span {\n impl Span {\n     pub fn empty() -> Span {\n         Span {\n-            filename: \"\".to_string(),\n+            filename: FileName::Anon,\n             loline: 0, locol: 0,\n             hiline: 0, hicol: 0,\n         }\n@@ -2546,7 +2545,7 @@ impl Clean<Span> for syntax_pos::Span {\n         let lo = cm.lookup_char_pos(self.lo());\n         let hi = cm.lookup_char_pos(self.hi());\n         Span {\n-            filename: filename.to_string(),\n+            filename,\n             loline: lo.line,\n             locol: lo.col.to_usize(),\n             hiline: hi.line,"}, {"sha": "ef01c3e6bdb0c224b69168552082b069a3e00f36", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -30,15 +30,15 @@ use syntax::codemap::{CodeMap, FilePathMapping};\n use syntax::parse::lexer::{self, TokenAndSpan};\n use syntax::parse::token;\n use syntax::parse;\n-use syntax_pos::Span;\n+use syntax_pos::{Span, FileName};\n \n /// Highlights `src`, returning the HTML output.\n pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>,\n                                 extension: Option<&str>,\n                                 tooltip: Option<(&str, &str)>) -> String {\n     debug!(\"highlighting: ================\\n{}\\n==============\", src);\n     let sess = parse::ParseSess::new(FilePathMapping::empty());\n-    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n+    let fm = sess.codemap().new_filemap(FileName::Custom(\"stdin\".to_string()), src.to_string());\n \n     let mut out = Vec::new();\n     if let Some((tooltip, class)) = tooltip {\n@@ -65,7 +65,7 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n /// an enclosing `<pre>` block.\n pub fn render_inner_with_highlighting(src: &str) -> io::Result<String> {\n     let sess = parse::ParseSess::new(FilePathMapping::empty());\n-    let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n+    let fm = sess.codemap().new_filemap(FileName::Custom(\"stdin\".to_string()), src.to_string());\n \n     let mut out = Vec::new();\n     let mut classifier = Classifier::new(lexer::StringReader::new(&sess, fm), sess.codemap());"}, {"sha": "8ed35aa8f439658c9e93e0062339ca465585ba4b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -54,6 +54,7 @@ use externalfiles::ExternalHtml;\n \n use serialize::json::{ToJson, Json, as_json};\n use syntax::{abi, ast};\n+use syntax::codemap::FileName;\n use rustc::hir::def_id::{CrateNum, CRATE_DEF_INDEX, DefId};\n use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n@@ -491,9 +492,12 @@ pub fn run(mut krate: clean::Crate,\n            css_file_extension: Option<PathBuf>,\n            renderinfo: RenderInfo,\n            render_type: RenderType) -> Result<(), Error> {\n-    let src_root = match krate.src.parent() {\n-        Some(p) => p.to_path_buf(),\n-        None => PathBuf::new(),\n+    let src_root = match krate.src {\n+        FileName::Real(ref p) => match p.parent() {\n+            Some(p) => p.to_path_buf(),\n+            None => PathBuf::new(),\n+        },\n+        _ => PathBuf::new(),\n     };\n     let mut scx = SharedContext {\n         src_root,\n@@ -596,9 +600,12 @@ pub fn run(mut krate: clean::Crate,\n \n     // Cache where all our extern crates are located\n     for &(n, ref e) in &krate.externs {\n-        let src_root = match Path::new(&e.src).parent() {\n-            Some(p) => p.to_path_buf(),\n-            None => PathBuf::new(),\n+        let src_root = match e.src {\n+            FileName::Real(ref p) => match p.parent() {\n+                Some(p) => p.to_path_buf(),\n+                None => PathBuf::new(),\n+            },\n+            _ => PathBuf::new(),\n         };\n         cache.extern_locations.insert(n, (e.name.clone(), src_root,\n                                           extern_location(e, &cx.dst)));\n@@ -1075,14 +1082,10 @@ impl<'a> DocFolder for SourceCollector<'a> {\n         // If we're including source files, and we haven't seen this file yet,\n         // then we need to render it out to the filesystem.\n         if self.scx.include_sources\n-            // skip all invalid spans\n-            && item.source.filename != \"\"\n+            // skip all invalid or macro spans\n+            && item.source.filename.is_real()\n             // skip non-local items\n-            && item.def_id.is_local()\n-            // Macros from other libraries get special filenames which we can\n-            // safely ignore.\n-            && !(item.source.filename.starts_with(\"<\")\n-                && item.source.filename.ends_with(\"macros>\")) {\n+            && item.def_id.is_local() {\n \n             // If it turns out that we couldn't read this file, then we probably\n             // can't read any of the files (generating html output from json or\n@@ -1107,9 +1110,12 @@ impl<'a> DocFolder for SourceCollector<'a> {\n \n impl<'a> SourceCollector<'a> {\n     /// Renders the given filename into its corresponding HTML source file.\n-    fn emit_source(&mut self, filename: &str) -> io::Result<()> {\n-        let p = PathBuf::from(filename);\n-        if self.scx.local_sources.contains_key(&p) {\n+    fn emit_source(&mut self, filename: &FileName) -> io::Result<()> {\n+        let p = match *filename {\n+            FileName::Real(ref file) => file,\n+            _ => return Ok(()),\n+        };\n+        if self.scx.local_sources.contains_key(&**p) {\n             // We've already emitted this source\n             return Ok(());\n         }\n@@ -1158,7 +1164,7 @@ impl<'a> SourceCollector<'a> {\n                        &page, &(\"\"), &Source(contents),\n                        self.scx.css_file_extension.is_some())?;\n         w.flush()?;\n-        self.scx.local_sources.insert(p, href);\n+        self.scx.local_sources.insert(p.clone(), href);\n         Ok(())\n     }\n }\n@@ -1670,18 +1676,20 @@ impl<'a> Item<'a> {\n \n         let cache = cache();\n         let mut path = String::new();\n+\n+        // We can safely ignore macros from other libraries\n+        let file = match self.item.source.filename {\n+            FileName::Real(ref path) => path,\n+            _ => return None,\n+        };\n+\n         let (krate, path) = if self.item.def_id.is_local() {\n-            let path = PathBuf::from(&self.item.source.filename);\n-            let path = self.cx.shared.local_sources.get(&path)?;\n-            (&self.cx.shared.layout.krate, path)\n-        } else {\n-            // Macros from other libraries get special filenames which we can\n-            // safely ignore.\n-            if self.item.source.filename.starts_with(\"<\") &&\n-               self.item.source.filename.ends_with(\"macros>\") {\n+            if let Some(path) = self.cx.shared.local_sources.get(file) {\n+                (&self.cx.shared.layout.krate, path)\n+            } else {\n                 return None;\n             }\n-\n+        } else {\n             let (krate, src_root) = match cache.extern_locations.get(&self.item.def_id.krate) {\n                 Some(&(ref name, ref src, Local)) => (name, src),\n                 Some(&(ref name, ref src, Remote(ref s))) => {\n@@ -1691,7 +1699,6 @@ impl<'a> Item<'a> {\n                 Some(&(_, _, Unknown)) | None => return None,\n             };\n \n-            let file = Path::new(&self.item.source.filename);\n             clean_srcpath(&src_root, file, false, |component| {\n                 path.push_str(component);\n                 path.push('/');"}, {"sha": "1cf71eca846812fdda1733844ff5acb1252409bc", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -58,7 +58,7 @@ use std::env;\n use std::fmt::Display;\n use std::io;\n use std::io::Write;\n-use std::path::PathBuf;\n+use std::path::{Path, PathBuf};\n use std::process;\n use std::sync::mpsc::channel;\n \n@@ -331,7 +331,8 @@ pub fn main_args(args: &[String]) -> isize {\n                                           .collect();\n \n     let should_test = matches.opt_present(\"test\");\n-    let markdown_input = input.ends_with(\".md\") || input.ends_with(\".markdown\");\n+    let markdown_input = Path::new(input).extension()\n+        .map_or(false, |e| e == \"md\" || e == \"markdown\");\n \n     let output = matches.opt_str(\"o\").map(|s| PathBuf::from(&s));\n     let css_file_extension = matches.opt_str(\"e\").map(|s| PathBuf::from(&s));\n@@ -367,18 +368,18 @@ pub fn main_args(args: &[String]) -> isize {\n     let playground_url = matches.opt_str(\"playground-url\");\n     let maybe_sysroot = matches.opt_str(\"sysroot\").map(PathBuf::from);\n     let display_warnings = matches.opt_present(\"display-warnings\");\n-    let linker = matches.opt_str(\"linker\");\n+    let linker = matches.opt_str(\"linker\").map(PathBuf::from);\n \n     match (should_test, markdown_input) {\n         (true, true) => {\n-            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot, render_type,\n-                                  display_warnings, linker)\n+            return markdown::test(input, cfgs, libs, externs, test_args, maybe_sysroot,\n+                                  render_type, display_warnings, linker)\n         }\n         (true, false) => {\n-            return test::run(input, cfgs, libs, externs, test_args, crate_name, maybe_sysroot,\n-                             render_type, display_warnings, linker)\n+            return test::run(Path::new(input), cfgs, libs, externs, test_args, crate_name,\n+                             maybe_sysroot, render_type, display_warnings, linker)\n         }\n-        (false, true) => return markdown::render(input,\n+        (false, true) => return markdown::render(Path::new(input),\n                                                  output.unwrap_or(PathBuf::from(\"doc\")),\n                                                  &matches, &external_html,\n                                                  !matches.opt_present(\"markdown-no-toc\"),\n@@ -387,7 +388,7 @@ pub fn main_args(args: &[String]) -> isize {\n     }\n \n     let output_format = matches.opt_str(\"w\");\n-    let res = acquire_input(input, externs, &matches, move |out| {\n+    let res = acquire_input(PathBuf::from(input), externs, &matches, move |out| {\n         let Output { krate, passes, renderinfo } = out;\n         info!(\"going to format\");\n         match output_format.as_ref().map(|s| &**s) {\n@@ -424,7 +425,7 @@ fn print_error<T>(error_message: T) where T: Display {\n \n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n-fn acquire_input<R, F>(input: &str,\n+fn acquire_input<R, F>(input: PathBuf,\n                        externs: Externs,\n                        matches: &getopts::Matches,\n                        f: F)\n@@ -459,7 +460,7 @@ fn parse_externs(matches: &getopts::Matches) -> Result<Externs, String> {\n /// generated from the cleaned AST of the crate.\n ///\n /// This form of input will run all of the plug/cleaning passes\n-fn rust_input<R, F>(cratefile: &str, externs: Externs, matches: &getopts::Matches, f: F) -> R\n+fn rust_input<R, F>(cratefile: PathBuf, externs: Externs, matches: &getopts::Matches, f: F) -> R\n where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n     let mut default_passes = !matches.opt_present(\"no-defaults\");\n     let mut passes = matches.opt_strs(\"passes\");\n@@ -488,7 +489,6 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n     let crate_version = matches.opt_str(\"crate-version\");\n     let plugin_path = matches.opt_str(\"plugin-path\");\n \n-    let cr = PathBuf::from(cratefile);\n     info!(\"starting to run rustc\");\n     let display_warnings = matches.opt_present(\"display-warnings\");\n \n@@ -501,7 +501,7 @@ where R: 'static + Send, F: 'static + Send + FnOnce(Output) -> R {\n         use rustc::session::config::Input;\n \n         let (mut krate, renderinfo) =\n-            core::run_core(paths, cfgs, externs, Input::File(cr), triple, maybe_sysroot,\n+            core::run_core(paths, cfgs, externs, Input::File(cratefile), triple, maybe_sysroot,\n                            display_warnings, force_unstable_if_unmarked);\n \n         info!(\"finished with rustc\");"}, {"sha": "af93505293cefb4589a5ce882acf81f8893f6bd5", "filename": "src/librustdoc/markdown.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -17,7 +17,7 @@ use getopts;\n use testing;\n use rustc::session::search_paths::SearchPaths;\n use rustc::session::config::Externs;\n-use syntax::codemap::DUMMY_SP;\n+use syntax::codemap::{DUMMY_SP, FileName};\n \n use clean::Span;\n \n@@ -54,15 +54,14 @@ fn extract_leading_metadata<'a>(s: &'a str) -> (Vec<&'a str>, &'a str) {\n \n /// Render `input` (e.g. \"foo.md\") into an HTML file in `output`\n /// (e.g. output = \"bar\" => \"bar/foo.html\").\n-pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n+pub fn render(input: &Path, mut output: PathBuf, matches: &getopts::Matches,\n               external_html: &ExternalHtml, include_toc: bool,\n               render_type: RenderType) -> isize {\n     // Span used for markdown hoedown/pulldown differences.\n     let mut span = Span::empty();\n-    span.filename = input.to_owned();\n+    span.filename = FileName::Real(input.to_owned());\n \n-    let input_p = Path::new(input);\n-    output.push(input_p.file_stem().unwrap());\n+    output.push(input.file_stem().unwrap());\n     output.set_extension(\"html\");\n \n     let mut css = String::new();\n@@ -175,7 +174,7 @@ pub fn render(input: &str, mut output: PathBuf, matches: &getopts::Matches,\n /// Run any tests/code examples in the markdown file `input`.\n pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n             mut test_args: Vec<String>, maybe_sysroot: Option<PathBuf>,\n-            render_type: RenderType, display_warnings: bool, linker: Option<String>) -> isize {\n+            render_type: RenderType, display_warnings: bool, linker: Option<PathBuf>) -> isize {\n     let input_str = match load_string(input) {\n         Ok(s) => s,\n         Err(LoadStringError::ReadFail) => return 1,\n@@ -184,9 +183,9 @@ pub fn test(input: &str, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n \n     let mut opts = TestOptions::default();\n     opts.no_crate_inject = true;\n-    let mut collector = Collector::new(input.to_string(), cfgs, libs, externs,\n+    let mut collector = Collector::new(input.to_owned(), cfgs, libs, externs,\n                                        true, opts, maybe_sysroot, None,\n-                                       Some(input.to_owned()),\n+                                       Some(PathBuf::from(input)),\n                                        render_type, linker);\n     if render_type == RenderType::Pulldown {\n         old_find_testable_code(&input_str, &mut collector, DUMMY_SP);"}, {"sha": "abb902003706c7156aefc35886899f51b34f7d06", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -38,7 +38,7 @@ use rustc_trans::back::link;\n use syntax::ast;\n use syntax::codemap::CodeMap;\n use syntax::feature_gate::UnstableFeatures;\n-use syntax_pos::{BytePos, DUMMY_SP, Pos, Span};\n+use syntax_pos::{BytePos, DUMMY_SP, Pos, Span, FileName};\n use errors;\n use errors::emitter::ColorConfig;\n \n@@ -51,7 +51,7 @@ pub struct TestOptions {\n     pub attrs: Vec<String>,\n }\n \n-pub fn run(input: &str,\n+pub fn run(input_path: &Path,\n            cfgs: Vec<String>,\n            libs: SearchPaths,\n            externs: Externs,\n@@ -60,10 +60,9 @@ pub fn run(input: &str,\n            maybe_sysroot: Option<PathBuf>,\n            render_type: RenderType,\n            display_warnings: bool,\n-           linker: Option<String>)\n+           linker: Option<PathBuf>)\n            -> isize {\n-    let input_path = PathBuf::from(input);\n-    let input = config::Input::File(input_path.clone());\n+    let input = config::Input::File(input_path.to_owned());\n \n     let sessopts = config::Options {\n         maybe_sysroot: maybe_sysroot.clone().or_else(\n@@ -85,7 +84,7 @@ pub fn run(input: &str,\n \n     let cstore = Rc::new(CStore::new(box rustc_trans::LlvmMetadataLoader));\n     let mut sess = session::build_session_(\n-        sessopts, Some(input_path.clone()), handler, codemap.clone(),\n+        sessopts, Some(input_path.to_owned()), handler, codemap.clone(),\n     );\n     rustc_trans::init(&sess);\n     rustc_lint::register_builtins(&mut sess.lint_store.borrow_mut(), Some(&sess));\n@@ -177,12 +176,12 @@ fn scrape_test_config(krate: &::rustc::hir::Crate) -> TestOptions {\n     opts\n }\n \n-fn run_test(test: &str, cratename: &str, filename: &str, cfgs: Vec<String>, libs: SearchPaths,\n+fn run_test(test: &str, cratename: &str, filename: &FileName, cfgs: Vec<String>, libs: SearchPaths,\n             externs: Externs,\n             should_panic: bool, no_run: bool, as_test_harness: bool,\n             compile_fail: bool, mut error_codes: Vec<String>, opts: &TestOptions,\n             maybe_sysroot: Option<PathBuf>,\n-            linker: Option<String>) {\n+            linker: Option<PathBuf>) {\n     // the test harness wants its own `main` & top level functions, so\n     // never wrap the test in `fn main() { ... }`\n     let test = make_test(test, Some(cratename), as_test_harness, opts);\n@@ -451,17 +450,17 @@ pub struct Collector {\n     maybe_sysroot: Option<PathBuf>,\n     position: Span,\n     codemap: Option<Rc<CodeMap>>,\n-    filename: Option<String>,\n+    filename: Option<PathBuf>,\n     // to be removed when hoedown will be removed as well\n     pub render_type: RenderType,\n-    linker: Option<String>,\n+    linker: Option<PathBuf>,\n }\n \n impl Collector {\n     pub fn new(cratename: String, cfgs: Vec<String>, libs: SearchPaths, externs: Externs,\n                use_headers: bool, opts: TestOptions, maybe_sysroot: Option<PathBuf>,\n-               codemap: Option<Rc<CodeMap>>, filename: Option<String>,\n-               render_type: RenderType, linker: Option<String>) -> Collector {\n+               codemap: Option<Rc<CodeMap>>, filename: Option<PathBuf>,\n+               render_type: RenderType, linker: Option<PathBuf>) -> Collector {\n         Collector {\n             tests: Vec::new(),\n             old_tests: HashMap::new(),\n@@ -481,16 +480,16 @@ impl Collector {\n         }\n     }\n \n-    fn generate_name(&self, line: usize, filename: &str) -> String {\n+    fn generate_name(&self, line: usize, filename: &FileName) -> String {\n         format!(\"{} - {} (line {})\", filename, self.names.join(\"::\"), line)\n     }\n \n     // to be removed once hoedown is gone\n-    fn generate_name_beginning(&self, filename: &str) -> String {\n+    fn generate_name_beginning(&self, filename: &FileName) -> String {\n         format!(\"{} - {} (line\", filename, self.names.join(\"::\"))\n     }\n \n-    pub fn add_old_test(&mut self, test: String, filename: String) {\n+    pub fn add_old_test(&mut self, test: String, filename: FileName) {\n         let name_beg = self.generate_name_beginning(&filename);\n         let entry = self.old_tests.entry(name_beg)\n                                   .or_insert(Vec::new());\n@@ -500,7 +499,7 @@ impl Collector {\n     pub fn add_test(&mut self, test: String,\n                     should_panic: bool, no_run: bool, should_ignore: bool,\n                     as_test_harness: bool, compile_fail: bool, error_codes: Vec<String>,\n-                    line: usize, filename: String, allow_fail: bool) {\n+                    line: usize, filename: FileName, allow_fail: bool) {\n         let name = self.generate_name(line, &filename);\n         // to be removed when hoedown is removed\n         if self.render_type == RenderType::Pulldown {\n@@ -578,21 +577,21 @@ impl Collector {\n         self.position = position;\n     }\n \n-    pub fn get_filename(&self) -> String {\n+    pub fn get_filename(&self) -> FileName {\n         if let Some(ref codemap) = self.codemap {\n             let filename = codemap.span_to_filename(self.position);\n-            if let Ok(cur_dir) = env::current_dir() {\n-                if let Ok(path) = Path::new(&filename).strip_prefix(&cur_dir) {\n-                    if let Some(path) = path.to_str() {\n-                        return path.to_owned();\n+            if let FileName::Real(ref filename) = filename {\n+                if let Ok(cur_dir) = env::current_dir() {\n+                    if let Ok(path) = filename.strip_prefix(&cur_dir) {\n+                        return path.to_owned().into();\n                     }\n                 }\n             }\n             filename\n         } else if let Some(ref filename) = self.filename {\n-            filename.clone()\n+            filename.clone().into()\n         } else {\n-            \"<input>\".to_owned()\n+            FileName::Custom(\"input\".to_owned())\n         }\n     }\n "}, {"sha": "2c91d60ce9d5922eadf3d037dd5a44f369cf828e", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -164,7 +164,7 @@ impl CodeMap {\n \n     pub fn load_file(&self, path: &Path) -> io::Result<Rc<FileMap>> {\n         let src = self.file_loader.read_file(path)?;\n-        Ok(self.new_filemap(path.to_str().unwrap().to_string(), src))\n+        Ok(self.new_filemap(path.to_owned().into(), src))\n     }\n \n     pub fn files(&self) -> Ref<Vec<Rc<FileMap>>> {\n@@ -196,9 +196,15 @@ impl CodeMap {\n         // Note that filename may not be a valid path, eg it may be `<anon>` etc,\n         // but this is okay because the directory determined by `path.pop()` will\n         // be empty, so the working directory will be used.\n-        let unmapped_path = PathBuf::from(filename.clone());\n-\n-        let (filename, was_remapped) = self.path_mapping.map_prefix(filename);\n+        let unmapped_path = filename.clone();\n+\n+        let (filename, was_remapped) = match filename {\n+            FileName::Real(filename) => {\n+                let (filename, was_remapped) = self.path_mapping.map_prefix(filename);\n+                (FileName::Real(filename), was_remapped)\n+            },\n+            other => (other, false),\n+        };\n         let filemap = Rc::new(FileMap::new(\n             filename,\n             was_remapped,\n@@ -217,8 +223,8 @@ impl CodeMap {\n     }\n \n     /// Creates a new filemap and sets its line information.\n-    pub fn new_filemap_and_lines(&self, filename: &str, src: &str) -> Rc<FileMap> {\n-        let fm = self.new_filemap(filename.to_string(), src.to_owned());\n+    pub fn new_filemap_and_lines(&self, filename: &Path, src: &str) -> Rc<FileMap> {\n+        let fm = self.new_filemap(filename.to_owned().into(), src.to_owned());\n         let mut byte_pos: u32 = fm.start_pos.0;\n         for line in src.lines() {\n             // register the start of this line\n@@ -373,7 +379,7 @@ impl CodeMap {\n     pub fn lookup_char_pos_adj(&self, pos: BytePos) -> LocWithOpt {\n         let loc = self.lookup_char_pos(pos);\n         LocWithOpt {\n-            filename: loc.file.name.to_string(),\n+            filename: loc.file.name.clone(),\n             line: loc.line,\n             col: loc.col,\n             file: Some(loc.file)\n@@ -433,7 +439,7 @@ impl CodeMap {\n         self.lookup_char_pos(sp.lo()).file.name.clone()\n     }\n \n-    pub fn span_to_unmapped_path(&self, sp: Span) -> PathBuf {\n+    pub fn span_to_unmapped_path(&self, sp: Span) -> FileName {\n         self.lookup_char_pos(sp.lo()).file.unmapped_path.clone()\n             .expect(\"CodeMap::span_to_unmapped_path called for imported FileMap?\")\n     }\n@@ -561,9 +567,9 @@ impl CodeMap {\n         self.span_until_char(sp, '{')\n     }\n \n-    pub fn get_filemap(&self, filename: &str) -> Option<Rc<FileMap>> {\n+    pub fn get_filemap(&self, filename: &FileName) -> Option<Rc<FileMap>> {\n         for fm in self.files.borrow().iter() {\n-            if filename == fm.name {\n+            if *filename == fm.name {\n                 return Some(fm.clone());\n             }\n         }\n@@ -650,7 +656,7 @@ impl CodeMapper for CodeMap {\n         self.merge_spans(sp_lhs, sp_rhs)\n     }\n     fn call_span_if_macro(&self, sp: Span) -> Span {\n-        if self.span_to_filename(sp.clone()).contains(\"macros>\") {\n+        if self.span_to_filename(sp.clone()).is_macros() {\n             let v = sp.macro_backtrace();\n             if let Some(use_site) = v.last() {\n                 return use_site.call_site;\n@@ -660,14 +666,17 @@ impl CodeMapper for CodeMap {\n     }\n     fn ensure_filemap_source_present(&self, file_map: Rc<FileMap>) -> bool {\n         file_map.add_external_src(\n-            || self.file_loader.read_file(Path::new(&file_map.name)).ok()\n+            || match file_map.name {\n+                FileName::Real(ref name) => self.file_loader.read_file(name).ok(),\n+                _ => None,\n+            }\n         )\n     }\n }\n \n #[derive(Clone)]\n pub struct FilePathMapping {\n-    mapping: Vec<(String, String)>,\n+    mapping: Vec<(PathBuf, PathBuf)>,\n }\n \n impl FilePathMapping {\n@@ -677,7 +686,7 @@ impl FilePathMapping {\n         }\n     }\n \n-    pub fn new(mapping: Vec<(String, String)>) -> FilePathMapping {\n+    pub fn new(mapping: Vec<(PathBuf, PathBuf)>) -> FilePathMapping {\n         FilePathMapping {\n             mapping,\n         }\n@@ -686,14 +695,13 @@ impl FilePathMapping {\n     /// Applies any path prefix substitution as defined by the mapping.\n     /// The return value is the remapped path and a boolean indicating whether\n     /// the path was affected by the mapping.\n-    pub fn map_prefix(&self, path: String) -> (String, bool) {\n+    pub fn map_prefix(&self, path: PathBuf) -> (PathBuf, bool) {\n         // NOTE: We are iterating over the mapping entries from last to first\n         //       because entries specified later on the command line should\n         //       take precedence.\n         for &(ref from, ref to) in self.mapping.iter().rev() {\n-            if path.starts_with(from) {\n-                let mapped = path.replacen(from, to, 1);\n-                return (mapped, true);\n+            if let Ok(rest) = path.strip_prefix(from) {\n+                return (to.join(rest), true);\n             }\n         }\n \n@@ -714,7 +722,7 @@ mod tests {\n     #[test]\n     fn t1 () {\n         let cm = CodeMap::new(FilePathMapping::empty());\n-        let fm = cm.new_filemap(\"blork.rs\".to_string(),\n+        let fm = cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n                                 \"first line.\\nsecond line\".to_string());\n         fm.next_line(BytePos(0));\n         // Test we can get lines with partial line info.\n@@ -730,7 +738,7 @@ mod tests {\n     #[should_panic]\n     fn t2 () {\n         let cm = CodeMap::new(FilePathMapping::empty());\n-        let fm = cm.new_filemap(\"blork.rs\".to_string(),\n+        let fm = cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n                                 \"first line.\\nsecond line\".to_string());\n         // TESTING *REALLY* BROKEN BEHAVIOR:\n         fm.next_line(BytePos(0));\n@@ -740,11 +748,11 @@ mod tests {\n \n     fn init_code_map() -> CodeMap {\n         let cm = CodeMap::new(FilePathMapping::empty());\n-        let fm1 = cm.new_filemap(\"blork.rs\".to_string(),\n+        let fm1 = cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n                                  \"first line.\\nsecond line\".to_string());\n-        let fm2 = cm.new_filemap(\"empty.rs\".to_string(),\n+        let fm2 = cm.new_filemap(PathBuf::from(\"empty.rs\").into(),\n                                  \"\".to_string());\n-        let fm3 = cm.new_filemap(\"blork2.rs\".to_string(),\n+        let fm3 = cm.new_filemap(PathBuf::from(\"blork2.rs\").into(),\n                                  \"first line.\\nsecond line\".to_string());\n \n         fm1.next_line(BytePos(0));\n@@ -762,15 +770,15 @@ mod tests {\n         let cm = init_code_map();\n \n         let fmabp1 = cm.lookup_byte_offset(BytePos(23));\n-        assert_eq!(fmabp1.fm.name, \"blork.rs\");\n+        assert_eq!(fmabp1.fm.name, PathBuf::from(\"blork.rs\").into());\n         assert_eq!(fmabp1.pos, BytePos(23));\n \n         let fmabp1 = cm.lookup_byte_offset(BytePos(24));\n-        assert_eq!(fmabp1.fm.name, \"empty.rs\");\n+        assert_eq!(fmabp1.fm.name, PathBuf::from(\"empty.rs\").into());\n         assert_eq!(fmabp1.pos, BytePos(0));\n \n         let fmabp2 = cm.lookup_byte_offset(BytePos(25));\n-        assert_eq!(fmabp2.fm.name, \"blork2.rs\");\n+        assert_eq!(fmabp2.fm.name, PathBuf::from(\"blork2.rs\").into());\n         assert_eq!(fmabp2.pos, BytePos(0));\n     }\n \n@@ -792,12 +800,12 @@ mod tests {\n         let cm = init_code_map();\n \n         let loc1 = cm.lookup_char_pos(BytePos(22));\n-        assert_eq!(loc1.file.name, \"blork.rs\");\n+        assert_eq!(loc1.file.name, PathBuf::from(\"blork.rs\").into());\n         assert_eq!(loc1.line, 2);\n         assert_eq!(loc1.col, CharPos(10));\n \n         let loc2 = cm.lookup_char_pos(BytePos(25));\n-        assert_eq!(loc2.file.name, \"blork2.rs\");\n+        assert_eq!(loc2.file.name, PathBuf::from(\"blork2.rs\").into());\n         assert_eq!(loc2.line, 1);\n         assert_eq!(loc2.col, CharPos(0));\n     }\n@@ -806,9 +814,9 @@ mod tests {\n         let cm = CodeMap::new(FilePathMapping::empty());\n         // \u20ac is a three byte utf8 char.\n         let fm1 =\n-            cm.new_filemap(\"blork.rs\".to_string(),\n+            cm.new_filemap(PathBuf::from(\"blork.rs\").into(),\n                            \"fir\u20acst \u20ac\u20ac\u20ac\u20ac line.\\nsecond line\".to_string());\n-        let fm2 = cm.new_filemap(\"blork2.rs\".to_string(),\n+        let fm2 = cm.new_filemap(PathBuf::from(\"blork2.rs\").into(),\n                                  \"first line\u20ac\u20ac.\\n\u20ac second line\".to_string());\n \n         fm1.next_line(BytePos(0));\n@@ -853,7 +861,7 @@ mod tests {\n         let span = Span::new(BytePos(12), BytePos(23), NO_EXPANSION);\n         let file_lines = cm.span_to_lines(span).unwrap();\n \n-        assert_eq!(file_lines.file.name, \"blork.rs\");\n+        assert_eq!(file_lines.file.name, PathBuf::from(\"blork.rs\").into());\n         assert_eq!(file_lines.lines.len(), 1);\n         assert_eq!(file_lines.lines[0].line_index, 1);\n     }\n@@ -876,7 +884,7 @@ mod tests {\n         let cm = CodeMap::new(FilePathMapping::empty());\n         let inputtext = \"aaaaa\\nbbbbBB\\nCCC\\nDDDDDddddd\\neee\\n\";\n         let selection = \"     \\n    ~~\\n~~~\\n~~~~~     \\n   \\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n+        cm.new_filemap_and_lines(Path::new(\"blork.rs\"), inputtext);\n         let span = span_from_selection(inputtext, selection);\n \n         // check that we are extracting the text we thought we were extracting\n@@ -919,7 +927,7 @@ mod tests {\n         let inputtext  = \"bbbb BB\\ncc CCC\\n\";\n         let selection1 = \"     ~~\\n      \\n\";\n         let selection2 = \"       \\n   ~~~\\n\";\n-        cm.new_filemap_and_lines(\"blork.rs\", inputtext);\n+        cm.new_filemap_and_lines(Path::new(\"blork.rs\"), inputtext);\n         let span1 = span_from_selection(inputtext, selection1);\n         let span2 = span_from_selection(inputtext, selection2);\n "}, {"sha": "5f06475919fec27dfd6b89d0f337ccad0f5c5abf", "filename": "src/libsyntax/diagnostics/metadata.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -20,7 +20,7 @@ use std::io::Write;\n use std::error::Error;\n use rustc_serialize::json::as_json;\n \n-use syntax_pos::Span;\n+use syntax_pos::{Span, FileName};\n use ext::base::ExtCtxt;\n use diagnostics::plugin::{ErrorMap, ErrorInfo};\n \n@@ -40,7 +40,7 @@ pub type ErrorMetadataMap = BTreeMap<String, ErrorMetadata>;\n /// JSON encodable error location type with filename and line number.\n #[derive(PartialEq, RustcDecodable, RustcEncodable)]\n pub struct ErrorLocation {\n-    pub filename: String,\n+    pub filename: FileName,\n     pub line: usize\n }\n "}, {"sha": "9a96432f11d4eacdc2ef5464a4d6589e6718693a", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -759,7 +759,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n \n     fn expr_fail(&self, span: Span, msg: Symbol) -> P<ast::Expr> {\n         let loc = self.codemap().lookup_char_pos(span.lo());\n-        let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name));\n+        let expr_file = self.expr_str(span, Symbol::intern(&loc.file.name.to_string()));\n         let expr_line = self.expr_u32(span, loc.line as u32);\n         let expr_col = self.expr_u32(span, loc.col.to_usize() as u32 + 1);\n         let expr_loc_tuple = self.expr_tuple(span, vec![expr_file, expr_line, expr_col]);"}, {"sha": "edf3d40be94a682235b94a7fcdc434eabe0155fa", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -27,7 +27,7 @@ use parse::parser::Parser;\n use ptr::P;\n use symbol::Symbol;\n use symbol::keywords;\n-use syntax_pos::{Span, DUMMY_SP};\n+use syntax_pos::{Span, DUMMY_SP, FileName};\n use syntax_pos::hygiene::ExpnFormat;\n use tokenstream::{TokenStream, TokenTree};\n use util::small_vector::SmallVector;\n@@ -38,6 +38,7 @@ use std::fs::File;\n use std::io::Read;\n use std::mem;\n use std::rc::Rc;\n+use std::path::PathBuf;\n \n macro_rules! expansions {\n     ($($kind:ident: $ty:ty [$($vec:ident, $ty_elt:ty)*], $kind_name:expr, .$make:ident,\n@@ -220,7 +221,10 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n     pub fn expand_crate(&mut self, mut krate: ast::Crate) -> ast::Crate {\n         let mut module = ModuleData {\n             mod_path: vec![Ident::from_str(&self.cx.ecfg.crate_name)],\n-            directory: self.cx.codemap().span_to_unmapped_path(krate.span),\n+            directory: match self.cx.codemap().span_to_unmapped_path(krate.span) {\n+                FileName::Real(path) => path,\n+                other => PathBuf::from(other.to_string()),\n+            },\n         };\n         module.directory.pop();\n         self.cx.root_path = module.directory.clone();\n@@ -978,7 +982,11 @@ impl<'a, 'b> Folder for InvocationCollector<'a, 'b> {\n                         module.directory.push(&*item.ident.name.as_str());\n                     }\n                 } else {\n-                    let mut path = self.cx.parse_sess.codemap().span_to_unmapped_path(inner);\n+                    let path = self.cx.parse_sess.codemap().span_to_unmapped_path(inner);\n+                    let mut path = match path {\n+                        FileName::Real(path) => path,\n+                        other => PathBuf::from(other.to_string()),\n+                    };\n                     let directory_ownership = match path.file_name().unwrap().to_str() {\n                         Some(\"mod.rs\") => DirectoryOwnership::Owned,\n                         _ => DirectoryOwnership::UnownedViaMod(false),"}, {"sha": "426dde4f2a7639cd71152bbffba3a3634e21f3e3", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -18,7 +18,6 @@ use parse::token;\n use ptr::P;\n use tokenstream::{TokenStream, TokenTree};\n \n-\n /// Quasiquoting works via token trees.\n ///\n /// This is registered as a set of expression syntax extension called quote!\n@@ -38,7 +37,7 @@ pub mod rt {\n     use tokenstream::{self, TokenTree, TokenStream};\n \n     pub use parse::new_parser_from_tts;\n-    pub use syntax_pos::{BytePos, Span, DUMMY_SP};\n+    pub use syntax_pos::{BytePos, Span, DUMMY_SP, FileName};\n     pub use codemap::{dummy_spanned};\n \n     pub trait ToTokens {\n@@ -343,27 +342,27 @@ pub mod rt {\n     impl<'a> ExtParseUtils for ExtCtxt<'a> {\n         fn parse_item(&self, s: String) -> P<ast::Item> {\n             panictry!(parse::parse_item_from_source_str(\n-                \"<quote expansion>\".to_string(),\n+                FileName::QuoteExpansion,\n                 s,\n                 self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_stmt(&self, s: String) -> ast::Stmt {\n             panictry!(parse::parse_stmt_from_source_str(\n-                \"<quote expansion>\".to_string(),\n+                FileName::QuoteExpansion,\n                 s,\n                 self.parse_sess())).expect(\"parse error\")\n         }\n \n         fn parse_expr(&self, s: String) -> P<ast::Expr> {\n             panictry!(parse::parse_expr_from_source_str(\n-                \"<quote expansion>\".to_string(),\n+                FileName::QuoteExpansion,\n                 s,\n                 self.parse_sess()))\n         }\n \n         fn parse_tts(&self, s: String) -> Vec<TokenTree> {\n-            let source_name = \"<quote expansion>\".to_owned();\n+            let source_name = FileName::QuoteExpansion;\n             parse::parse_stream_from_source_str(source_name, s, self.parse_sess(), None)\n                 .into_trees().collect()\n         }"}, {"sha": "2a80686aa0f30f52dcaee8f5447f723b18708f60", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use ast;\n-use syntax_pos::{self, Pos, Span};\n+use syntax_pos::{self, Pos, Span, FileName};\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n@@ -23,7 +23,7 @@ use util::small_vector::SmallVector;\n \n use std::fs::File;\n use std::io::prelude::*;\n-use std::path::{Path, PathBuf};\n+use std::path::PathBuf;\n use std::rc::Rc;\n \n // These macros all relate to the file system; they either return\n@@ -71,7 +71,7 @@ pub fn expand_file(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n \n     let topmost = cx.expansion_cause().unwrap_or(sp);\n     let loc = cx.codemap().lookup_char_pos(topmost.lo());\n-    base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name)))\n+    base::MacEager::expr(cx.expr_str(topmost, Symbol::intern(&loc.file.name.to_string())))\n }\n \n pub fn expand_stringify(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenTree])\n@@ -99,7 +99,7 @@ pub fn expand_include<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[tokenstream::T\n         None => return DummyResult::expr(sp),\n     };\n     // The file will be added to the code map by the parser\n-    let path = res_rel_file(cx, sp, Path::new(&file));\n+    let path = res_rel_file(cx, sp, file);\n     let directory_ownership = DirectoryOwnership::Owned;\n     let p = parse::new_sub_parser_from_file(cx.parse_sess(), &path, directory_ownership, None, sp);\n \n@@ -135,7 +135,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n     };\n-    let file = res_rel_file(cx, sp, Path::new(&file));\n+    let file = res_rel_file(cx, sp, file);\n     let mut bytes = Vec::new();\n     match File::open(&file).and_then(|mut f| f.read_to_end(&mut bytes)) {\n         Ok(..) => {}\n@@ -151,8 +151,7 @@ pub fn expand_include_str(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::TokenT\n         Ok(src) => {\n             // Add this input file to the code map to make it available as\n             // dependency information\n-            let filename = format!(\"{}\", file.display());\n-            cx.codemap().new_filemap_and_lines(&filename, &src);\n+            cx.codemap().new_filemap_and_lines(&file, &src);\n \n             base::MacEager::expr(cx.expr_str(sp, Symbol::intern(&src)))\n         }\n@@ -171,7 +170,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n         Some(f) => f,\n         None => return DummyResult::expr(sp)\n     };\n-    let file = res_rel_file(cx, sp, Path::new(&file));\n+    let file = res_rel_file(cx, sp, file);\n     let mut bytes = Vec::new();\n     match File::open(&file).and_then(|mut f| f.read_to_end(&mut bytes)) {\n         Err(e) => {\n@@ -182,8 +181,7 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n         Ok(..) => {\n             // Add this input file to the code map to make it available as\n             // dependency information, but don't enter it's contents\n-            let filename = format!(\"{}\", file.display());\n-            cx.codemap().new_filemap_and_lines(&filename, \"\");\n+            cx.codemap().new_filemap_and_lines(&file, \"\");\n \n             base::MacEager::expr(cx.expr_lit(sp, ast::LitKind::ByteStr(Rc::new(bytes))))\n         }\n@@ -192,16 +190,20 @@ pub fn expand_include_bytes(cx: &mut ExtCtxt, sp: Span, tts: &[tokenstream::Toke\n \n // resolve a file-system path to an absolute file-system path (if it\n // isn't already)\n-fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: &Path) -> PathBuf {\n+fn res_rel_file(cx: &mut ExtCtxt, sp: syntax_pos::Span, arg: String) -> PathBuf {\n+    let arg = PathBuf::from(arg);\n     // Relative paths are resolved relative to the file in which they are found\n     // after macro expansion (that is, they are unhygienic).\n     if !arg.is_absolute() {\n         let callsite = sp.source_callsite();\n-        let mut path = cx.codemap().span_to_unmapped_path(callsite);\n+        let mut path = match cx.codemap().span_to_unmapped_path(callsite) {\n+            FileName::Real(path) => path,\n+            other => panic!(\"cannot resolve relative path in non-file source `{}`\", other),\n+        };\n         path.pop();\n         path.push(arg);\n         path\n     } else {\n-        arg.to_path_buf()\n+        arg\n     }\n }"}, {"sha": "54c726d84621fe36f1bd28adf5cc338b2c8325e8", "filename": "src/libsyntax/json.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fjson.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -282,7 +282,7 @@ impl DiagnosticSpan {\n             })\n         });\n         DiagnosticSpan {\n-            file_name: start.file.name.clone(),\n+            file_name: start.file.name.to_string(),\n             byte_start: span.lo().0 - start.file.start_pos.0,\n             byte_end: span.hi().0 - start.file.start_pos.0,\n             line_start: start.line,"}, {"sha": "23449ee69abb3722ae4c553f5fe860201ed5a490", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -12,7 +12,7 @@ pub use self::CommentStyle::*;\n \n use ast;\n use codemap::CodeMap;\n-use syntax_pos::{BytePos, CharPos, Pos};\n+use syntax_pos::{BytePos, CharPos, Pos, FileName};\n use parse::lexer::{is_block_doc_comment, is_pattern_whitespace};\n use parse::lexer::{self, ParseSess, StringReader, TokenAndSpan};\n use print::pprust;\n@@ -343,7 +343,7 @@ pub struct Literal {\n \n // it appears this function is called only from pprust... that's\n // probably not a good thing.\n-pub fn gather_comments_and_literals(sess: &ParseSess, path: String, srdr: &mut Read)\n+pub fn gather_comments_and_literals(sess: &ParseSess, path: FileName, srdr: &mut Read)\n                                     -> (Vec<Comment>, Vec<Literal>) {\n     let mut src = Vec::new();\n     srdr.read_to_end(&mut src).unwrap();"}, {"sha": "798dfc6d20974e8fbe6793caa9e6f91906a89145", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -1714,6 +1714,7 @@ mod tests {\n     use std::cell::RefCell;\n     use std::collections::HashSet;\n     use std::io;\n+    use std::path::PathBuf;\n     use std::rc::Rc;\n \n     fn mk_sess(cm: Rc<CodeMap>) -> ParseSess {\n@@ -1735,7 +1736,7 @@ mod tests {\n                  sess: &'a ParseSess,\n                  teststr: String)\n                  -> StringReader<'a> {\n-        let fm = cm.new_filemap(\"zebra.rs\".to_string(), teststr);\n+        let fm = cm.new_filemap(PathBuf::from(\"zebra.rs\").into(), teststr);\n         StringReader::new(sess, fm)\n     }\n "}, {"sha": "4d435665d3ca9e470b1733ce9df598be5aa63e72", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -12,7 +12,7 @@\n \n use ast::{self, CrateConfig};\n use codemap::{CodeMap, FilePathMapping};\n-use syntax_pos::{self, Span, FileMap, NO_EXPANSION};\n+use syntax_pos::{self, Span, FileMap, NO_EXPANSION, FileName};\n use errors::{Handler, ColorConfig, DiagnosticBuilder};\n use feature_gate::UnstableFeatures;\n use parse::parser::Parser;\n@@ -107,17 +107,17 @@ pub fn parse_crate_attrs_from_file<'a>(input: &Path, sess: &'a ParseSess)\n     parser.parse_inner_attributes()\n }\n \n-pub fn parse_crate_from_source_str(name: String, source: String, sess: &ParseSess)\n+pub fn parse_crate_from_source_str(name: FileName, source: String, sess: &ParseSess)\n                                        -> PResult<ast::Crate> {\n     new_parser_from_source_str(sess, name, source).parse_crate_mod()\n }\n \n-pub fn parse_crate_attrs_from_source_str(name: String, source: String, sess: &ParseSess)\n+pub fn parse_crate_attrs_from_source_str(name: FileName, source: String, sess: &ParseSess)\n                                              -> PResult<Vec<ast::Attribute>> {\n     new_parser_from_source_str(sess, name, source).parse_inner_attributes()\n }\n \n-pub fn parse_expr_from_source_str(name: String, source: String, sess: &ParseSess)\n+pub fn parse_expr_from_source_str(name: FileName, source: String, sess: &ParseSess)\n                                       -> PResult<P<ast::Expr>> {\n     new_parser_from_source_str(sess, name, source).parse_expr()\n }\n@@ -126,29 +126,29 @@ pub fn parse_expr_from_source_str(name: String, source: String, sess: &ParseSess\n ///\n /// Returns `Ok(Some(item))` when successful, `Ok(None)` when no item was found, and `Err`\n /// when a syntax error occurred.\n-pub fn parse_item_from_source_str(name: String, source: String, sess: &ParseSess)\n+pub fn parse_item_from_source_str(name: FileName, source: String, sess: &ParseSess)\n                                       -> PResult<Option<P<ast::Item>>> {\n     new_parser_from_source_str(sess, name, source).parse_item()\n }\n \n-pub fn parse_meta_from_source_str(name: String, source: String, sess: &ParseSess)\n+pub fn parse_meta_from_source_str(name: FileName, source: String, sess: &ParseSess)\n                                       -> PResult<ast::MetaItem> {\n     new_parser_from_source_str(sess, name, source).parse_meta_item()\n }\n \n-pub fn parse_stmt_from_source_str(name: String, source: String, sess: &ParseSess)\n+pub fn parse_stmt_from_source_str(name: FileName, source: String, sess: &ParseSess)\n                                       -> PResult<Option<ast::Stmt>> {\n     new_parser_from_source_str(sess, name, source).parse_stmt()\n }\n \n-pub fn parse_stream_from_source_str(name: String, source: String, sess: &ParseSess,\n+pub fn parse_stream_from_source_str(name: FileName, source: String, sess: &ParseSess,\n                                     override_span: Option<Span>)\n                                     -> TokenStream {\n     filemap_to_stream(sess, sess.codemap().new_filemap(name, source), override_span)\n }\n \n // Create a new parser from a source string\n-pub fn new_parser_from_source_str(sess: &ParseSess, name: String, source: String)\n+pub fn new_parser_from_source_str(sess: &ParseSess, name: FileName, source: String)\n                                       -> Parser {\n     let mut parser = filemap_to_parser(sess, sess.codemap().new_filemap(name, source));\n     parser.recurse_into_file_modules = false;\n@@ -1018,7 +1018,7 @@ mod tests {\n     #[test] fn crlf_doc_comments() {\n         let sess = ParseSess::new(FilePathMapping::empty());\n \n-        let name = \"<source>\".to_string();\n+        let name = FileName::Custom(\"source\".to_string());\n         let source = \"/// doc comment\\r\\nfn foo() {}\".to_string();\n         let item = parse_item_from_source_str(name.clone(), source, &sess)\n             .unwrap().unwrap();\n@@ -1042,7 +1042,7 @@ mod tests {\n     #[test]\n     fn ttdelim_span() {\n         let sess = ParseSess::new(FilePathMapping::empty());\n-        let expr = parse::parse_expr_from_source_str(\"foo\".to_string(),\n+        let expr = parse::parse_expr_from_source_str(PathBuf::from(\"foo\").into(),\n             \"foo!( fn main() { body } )\".to_string(), &sess).unwrap();\n \n         let tts: Vec<_> = match expr.node {\n@@ -1065,7 +1065,7 @@ mod tests {\n     fn out_of_line_mod() {\n         let sess = ParseSess::new(FilePathMapping::empty());\n         let item = parse_item_from_source_str(\n-            \"foo\".to_owned(),\n+            PathBuf::from(\"foo\").into(),\n             \"mod foo { struct S; mod this_does_not_exist; }\".to_owned(),\n             &sess,\n         ).unwrap().unwrap();"}, {"sha": "b3ef70fd18eb901e47f0a6374c923888ef042259", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -41,7 +41,7 @@ use ast::{BinOpKind, UnOp};\n use ast::{RangeEnd, RangeSyntax};\n use {ast, attr};\n use codemap::{self, CodeMap, Spanned, respan};\n-use syntax_pos::{self, Span, BytePos};\n+use syntax_pos::{self, Span, BytePos, FileName, DUMMY_SP};\n use errors::{self, DiagnosticBuilder};\n use parse::{self, classify, token};\n use parse::common::SeqSep;\n@@ -527,9 +527,11 @@ impl<'a> Parser<'a> {\n \n         if let Some(directory) = directory {\n             parser.directory = directory;\n-        } else if parser.span != syntax_pos::DUMMY_SP {\n-            parser.directory.path = sess.codemap().span_to_unmapped_path(parser.span);\n-            parser.directory.path.pop();\n+        } else if !parser.span.source_equal(&DUMMY_SP) {\n+            if let FileName::Real(path) = sess.codemap().span_to_unmapped_path(parser.span) {\n+                parser.directory.path = path;\n+                parser.directory.path.pop();\n+            }\n         }\n \n         parser.process_potential_macro_variable();\n@@ -5764,15 +5766,17 @@ impl<'a> Parser<'a> {\n             let mut err = self.diagnostic().struct_span_err(id_sp,\n                 \"cannot declare a new module at this location\");\n             if id_sp != syntax_pos::DUMMY_SP {\n-                let src_path = PathBuf::from(self.sess.codemap().span_to_filename(id_sp));\n-                if let Some(stem) = src_path.file_stem() {\n-                    let mut dest_path = src_path.clone();\n-                    dest_path.set_file_name(stem);\n-                    dest_path.push(\"mod.rs\");\n-                    err.span_note(id_sp,\n-                                  &format!(\"maybe move this module `{}` to its own \\\n-                                            directory via `{}`\", src_path.to_string_lossy(),\n-                                           dest_path.to_string_lossy()));\n+                let src_path = self.sess.codemap().span_to_filename(id_sp);\n+                if let FileName::Real(src_path) = src_path {\n+                    if let Some(stem) = src_path.file_stem() {\n+                        let mut dest_path = src_path.clone();\n+                        dest_path.set_file_name(stem);\n+                        dest_path.push(\"mod.rs\");\n+                        err.span_note(id_sp,\n+                                    &format!(\"maybe move this module `{}` to its own \\\n+                                                directory via `{}`\", src_path.display(),\n+                                            dest_path.display()));\n+                    }\n                 }\n             }\n             if paths.path_exists {"}, {"sha": "05368c52d2c32658e583029abdedb5f5cf0f5e40", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -21,7 +21,7 @@ use ptr::P;\n use serialize::{Decodable, Decoder, Encodable, Encoder};\n use symbol::keywords;\n use syntax::parse::parse_stream_from_source_str;\n-use syntax_pos::{self, Span};\n+use syntax_pos::{self, Span, FileName};\n use tokenstream::{TokenStream, TokenTree};\n use tokenstream;\n \n@@ -495,9 +495,8 @@ impl Token {\n         tokens.unwrap_or_else(|| {\n             nt.1.force(|| {\n                 // FIXME(jseyfried): Avoid this pretty-print + reparse hack\n-                let name = \"<macro expansion>\".to_owned();\n                 let source = pprust::token_to_string(self);\n-                parse_stream_from_source_str(name, source, sess, Some(span))\n+                parse_stream_from_source_str(FileName::MacroExpansion, source, sess, Some(span))\n             })\n         })\n     }\n@@ -629,7 +628,7 @@ fn prepend_attrs(sess: &ParseSess,\n         assert_eq!(attr.style, ast::AttrStyle::Outer,\n                    \"inner attributes should prevent cached tokens from existing\");\n         // FIXME: Avoid this pretty-print + reparse hack as bove\n-        let name = \"<macro expansion>\".to_owned();\n+        let name = FileName::MacroExpansion;\n         let source = pprust::attr_to_string(attr);\n         let stream = parse_stream_from_source_str(name, source, sess, Some(span));\n         builder.push(stream);"}, {"sha": "e4b7dc26d326149aaacd28fc7e93357a86091a9a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -27,7 +27,7 @@ use print::pp::Breaks::{Consistent, Inconsistent};\n use ptr::P;\n use std_inject;\n use symbol::{Symbol, keywords};\n-use syntax_pos::DUMMY_SP;\n+use syntax_pos::{DUMMY_SP, FileName};\n use tokenstream::{self, TokenStream, TokenTree};\n \n use std::ascii;\n@@ -87,7 +87,7 @@ pub const DEFAULT_COLUMNS: usize = 78;\n pub fn print_crate<'a>(cm: &'a CodeMap,\n                        sess: &ParseSess,\n                        krate: &ast::Crate,\n-                       filename: String,\n+                       filename: FileName,\n                        input: &mut Read,\n                        out: Box<Write+'a>,\n                        ann: &'a PpAnn,\n@@ -120,7 +120,7 @@ pub fn print_crate<'a>(cm: &'a CodeMap,\n impl<'a> State<'a> {\n     pub fn new_from_input(cm: &'a CodeMap,\n                           sess: &ParseSess,\n-                          filename: String,\n+                          filename: FileName,\n                           input: &mut Read,\n                           out: Box<Write+'a>,\n                           ann: &'a PpAnn,"}, {"sha": "5072f2e2793f1bea2f5d9033aa3988cea9636579", "filename": "src/libsyntax/test_snippet.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest_snippet.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -16,6 +16,7 @@ use std::io::prelude::*;\n use std::rc::Rc;\n use std::str;\n use std::sync::{Arc, Mutex};\n+use std::path::Path;\n use syntax_pos::{BytePos, NO_EXPANSION, Span, MultiSpan};\n \n /// Identify a position in the text by the Nth occurrence of a string.\n@@ -48,7 +49,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n     let output = Arc::new(Mutex::new(Vec::new()));\n \n     let code_map = Rc::new(CodeMap::new(FilePathMapping::empty()));\n-    code_map.new_filemap_and_lines(\"test.rs\", &file_text);\n+    code_map.new_filemap_and_lines(Path::new(\"test.rs\"), &file_text);\n \n     let primary_span = make_span(&file_text, &span_labels[0].start, &span_labels[0].end);\n     let mut msp = MultiSpan::from_span(primary_span);"}, {"sha": "42cd7c8faa53279bb95a3eba6f0d06b941f55684", "filename": "src/libsyntax/util/parser_testing.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -16,16 +16,18 @@ use parse::parser::Parser;\n use ptr::P;\n use tokenstream::TokenStream;\n use std::iter::Peekable;\n+use std::path::PathBuf;\n \n /// Map a string to tts, using a made-up filename:\n pub fn string_to_stream(source_str: String) -> TokenStream {\n     let ps = ParseSess::new(FilePathMapping::empty());\n-    filemap_to_stream(&ps, ps.codemap().new_filemap(\"bogofile\".to_string(), source_str), None)\n+    filemap_to_stream(&ps, ps.codemap()\n+                             .new_filemap(PathBuf::from(\"bogofile\").into(), source_str), None)\n }\n \n /// Map string to parser (via tts)\n pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n-    new_parser_from_source_str(ps, \"bogofile\".to_string(), source_str)\n+    new_parser_from_source_str(ps, PathBuf::from(\"bogofile\").into(), source_str)\n }\n \n fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> T where"}, {"sha": "2a3812516632a179364f3c6a68e82f6bf6920d69", "filename": "src/libsyntax_pos/lib.rs", "status": "modified", "additions": 80, "deletions": 10, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Flib.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -54,7 +54,78 @@ pub use span_encoding::{Span, DUMMY_SP};\n \n pub mod symbol;\n \n-pub type FileName = String;\n+/// Differentiates between real files and common virtual files\n+#[derive(Debug, Eq, PartialEq, Clone, Ord, PartialOrd, Hash, RustcDecodable, RustcEncodable)]\n+pub enum FileName {\n+    Real(PathBuf),\n+    /// e.g. \"std\" macros\n+    Macros(String),\n+    /// call to `quote!`\n+    QuoteExpansion,\n+    /// Command line\n+    Anon,\n+    /// Hack in src/libsyntax/parse.rs\n+    /// FIXME(jseyfried)\n+    MacroExpansion,\n+    ProcMacroSourceCode,\n+    /// Strings provided as --cfg [cfgspec] stored in a crate_cfg\n+    CfgSpec,\n+    /// Custom sources for explicit parser calls from plugins and drivers\n+    Custom(String),\n+}\n+\n+impl std::fmt::Display for FileName {\n+    fn fmt(&self, fmt: &mut std::fmt::Formatter) -> std::fmt::Result {\n+        use self::FileName::*;\n+        match *self {\n+            Real(ref path) => write!(fmt, \"{}\", path.display()),\n+            Macros(ref name) => write!(fmt, \"<{} macros>\", name),\n+            QuoteExpansion => write!(fmt, \"<quote expansion>\"),\n+            MacroExpansion => write!(fmt, \"<macro expansion>\"),\n+            Anon => write!(fmt, \"<anon>\"),\n+            ProcMacroSourceCode => write!(fmt, \"<proc-macro source code>\"),\n+            CfgSpec => write!(fmt, \"cfgspec\"),\n+            Custom(ref s) => write!(fmt, \"<{}>\", s),\n+        }\n+    }\n+}\n+\n+impl From<PathBuf> for FileName {\n+    fn from(p: PathBuf) -> Self {\n+        assert!(!p.to_string_lossy().ends_with('>'));\n+        FileName::Real(p)\n+    }\n+}\n+\n+impl FileName {\n+    pub fn is_real(&self) -> bool {\n+        use self::FileName::*;\n+        match *self {\n+            Real(_) => true,\n+            Macros(_) |\n+            Anon |\n+            MacroExpansion |\n+            ProcMacroSourceCode |\n+            CfgSpec |\n+            Custom(_) |\n+            QuoteExpansion => false,\n+        }\n+    }\n+\n+    pub fn is_macros(&self) -> bool {\n+        use self::FileName::*;\n+        match *self {\n+            Real(_) |\n+            Anon |\n+            MacroExpansion |\n+            ProcMacroSourceCode |\n+            CfgSpec |\n+            Custom(_) |\n+            QuoteExpansion => false,\n+            Macros(_) => true,\n+        }\n+    }\n+}\n \n /// Spans represent a region of code, used for error reporting. Positions in spans\n /// are *absolute* positions from the beginning of the codemap, not positions\n@@ -600,7 +671,7 @@ pub struct FileMap {\n     pub name_was_remapped: bool,\n     /// The unmapped path of the file that the source came from.\n     /// Set to `None` if the FileMap was imported from an external crate.\n-    pub unmapped_path: Option<PathBuf>,\n+    pub unmapped_path: Option<FileName>,\n     /// Indicates which crate this FileMap was imported from.\n     pub crate_of_origin: u32,\n     /// The complete source code\n@@ -690,7 +761,7 @@ impl Decodable for FileMap {\n     fn decode<D: Decoder>(d: &mut D) -> Result<FileMap, D::Error> {\n \n         d.read_struct(\"FileMap\", 8, |d| {\n-            let name: String = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n+            let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n             let name_was_remapped: bool =\n                 d.read_struct_field(\"name_was_remapped\", 1, |d| Decodable::decode(d))?;\n             let src_hash: u128 =\n@@ -760,7 +831,7 @@ impl fmt::Debug for FileMap {\n impl FileMap {\n     pub fn new(name: FileName,\n                name_was_remapped: bool,\n-               unmapped_path: PathBuf,\n+               unmapped_path: FileName,\n                mut src: String,\n                start_pos: BytePos) -> FileMap {\n         remove_bom(&mut src);\n@@ -893,8 +964,7 @@ impl FileMap {\n     }\n \n     pub fn is_real_file(&self) -> bool {\n-        !(self.name.starts_with(\"<\") &&\n-          self.name.ends_with(\">\"))\n+        self.name.is_real()\n     }\n \n     pub fn is_imported(&self) -> bool {\n@@ -1114,18 +1184,18 @@ pub enum SpanSnippetError {\n     IllFormedSpan(Span),\n     DistinctSources(DistinctSources),\n     MalformedForCodemap(MalformedCodemapPositions),\n-    SourceNotAvailable { filename: String }\n+    SourceNotAvailable { filename: FileName }\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct DistinctSources {\n-    pub begin: (String, BytePos),\n-    pub end: (String, BytePos)\n+    pub begin: (FileName, BytePos),\n+    pub end: (FileName, BytePos)\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct MalformedCodemapPositions {\n-    pub name: String,\n+    pub name: FileName,\n     pub source_len: usize,\n     pub begin_pos: BytePos,\n     pub end_pos: BytePos"}, {"sha": "ea0c9ad2b83244c8902ee0cdf13e95e46cd62fb6", "filename": "src/test/codegen/remap_path_prefix/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fremap_path_prefix%2Fmain.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -32,7 +32,7 @@ fn main() {\n }\n \n // Here we check that local debuginfo is mapped correctly.\n-// CHECK: !DIFile(filename: \"/the/src/remap_path_prefix/main.rs\", directory: \"/the/cwd\")\n+// CHECK: !DIFile(filename: \"/the/src/remap_path_prefix/main.rs\", directory: \"/the/cwd/\")\n \n // And here that debuginfo from other crates are expanded to absolute paths.\n // CHECK: !DIFile(filename: \"/the/aux-src/remap_path_prefix_aux.rs\", directory: \"\")"}, {"sha": "cfe8048638a86f20eb10628d2c5d13028d3bac0d", "filename": "src/test/run-make/issue-19371/foo.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fissue-19371%2Ffoo.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -19,13 +19,13 @@ extern crate rustc_trans;\n extern crate syntax;\n \n use rustc::session::{build_session, Session};\n-use rustc::session::config::{basic_options, build_configuration, Input,\n+use rustc::session::config::{basic_options, Input,\n                              OutputType, OutputTypes};\n-use rustc_driver::driver::{compile_input, CompileController, anon_src};\n+use rustc_driver::driver::{compile_input, CompileController};\n use rustc_metadata::cstore::CStore;\n use rustc_errors::registry::Registry;\n+use syntax::codemap::FileName;\n \n-use std::collections::HashSet;\n use std::path::PathBuf;\n use std::rc::Rc;\n \n@@ -56,7 +56,7 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n     opts.output_types = OutputTypes::new(&[(OutputType::Exe, None)]);\n     opts.maybe_sysroot = Some(sysroot);\n     if let Ok(linker) = std::env::var(\"RUSTC_LINKER\") {\n-        opts.cg.linker = Some(linker);\n+        opts.cg.linker = Some(linker.into());\n     }\n \n     let descriptions = Registry::new(&rustc::DIAGNOSTICS);\n@@ -70,6 +70,6 @@ fn basic_sess(sysroot: PathBuf) -> (Session, Rc<CStore>) {\n fn compile(code: String, output: PathBuf, sysroot: PathBuf) {\n     let (sess, cstore) = basic_sess(sysroot);\n     let control = CompileController::basic();\n-    let input = Input::Str { name: anon_src(), input: code };\n+    let input = Input::Str { name: FileName::Anon, input: code };\n     let _ = compile_input(&sess, &cstore, &input, &None, &Some(output), None, &control);\n }"}, {"sha": "9f9ef477224240bdf9962f8bfcdc741429cb47c8", "filename": "src/test/run-pass-fulldeps/ast_stmt_expr_attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fast_stmt_expr_attr.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -17,7 +17,7 @@ extern crate syntax;\n use syntax::ast::*;\n use syntax::attr::*;\n use syntax::ast;\n-use syntax::codemap::FilePathMapping;\n+use syntax::codemap::{FilePathMapping, FileName};\n use syntax::parse;\n use syntax::parse::{ParseSess, PResult};\n use syntax::parse::new_parser_from_source_str;\n@@ -32,7 +32,7 @@ use std::fmt;\n // Copied out of syntax::util::parser_testing\n \n pub fn string_to_parser<'a>(ps: &'a ParseSess, source_str: String) -> Parser<'a> {\n-    new_parser_from_source_str(ps, \"bogofile\".to_string(), source_str)\n+    new_parser_from_source_str(ps, FileName::Custom(\"bogofile\".to_owned()), source_str)\n }\n \n fn with_error_checking_parse<'a, T, F>(s: String, ps: &'a ParseSess, f: F) -> PResult<'a, T> where"}, {"sha": "e84a982f7b3267a73e62aaf67201e6008192106f", "filename": "src/test/run-pass-fulldeps/pprust-expr-roundtrip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fpprust-expr-roundtrip.rs?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -33,7 +33,7 @@\n extern crate syntax;\n \n use syntax::ast::*;\n-use syntax::codemap::{Spanned, DUMMY_SP};\n+use syntax::codemap::{Spanned, DUMMY_SP, FileName};\n use syntax::codemap::FilePathMapping;\n use syntax::fold::{self, Folder};\n use syntax::parse::{self, ParseSess};\n@@ -44,7 +44,7 @@ use syntax::util::ThinVec;\n \n fn parse_expr(ps: &ParseSess, src: &str) -> P<Expr> {\n     let mut p = parse::new_parser_from_source_str(ps,\n-                                                  \"<expr>\".to_owned(),\n+                                                  FileName::Custom(\"expr\".to_owned()),\n                                                   src.to_owned());\n     p.parse_expr().unwrap()\n }"}, {"sha": "3f0d13b585c401efe3d833c6474ae0d07bc47fee", "filename": "src/tools/toolstate.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftools%2Ftoolstate.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d732da813bac73d2c81caddd06df3df3d9609e3d/src%2Ftools%2Ftoolstate.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftoolstate.toml?ref=d732da813bac73d2c81caddd06df3df3d9609e3d", "patch": "@@ -29,7 +29,7 @@ miri = \"Broken\"\n clippy = \"Testing\"\n \n # ping @nrc\n-rls = \"Testing\"\n+rls = \"Broken\"\n \n # ping @nrc\n-rustfmt = \"Testing\"\n+rustfmt = \"Broken\""}]}