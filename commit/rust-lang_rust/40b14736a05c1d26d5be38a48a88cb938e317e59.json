{"sha": "40b14736a05c1d26d5be38a48a88cb938e317e59", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwYjE0NzM2YTA1YzFkMjZkNWJlMzhhNDhhODhjYjkzOGUzMTdlNTk=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-09-01T23:05:19Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-09-02T01:21:29Z"}, "message": "x86: return single-float aggregates in a float register\n\nFollowing Clang's lead, and anecdotal evidence from the `float_one` part\nof `run-make/extern-fn-struct-passing-abi`, use a floating point\nregister to return single-float aggregates, except on MSVC targets.", "tree": {"sha": "24f72ac172e9507f17ef730faad73bb04ca4e5e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24f72ac172e9507f17ef730faad73bb04ca4e5e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40b14736a05c1d26d5be38a48a88cb938e317e59", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40b14736a05c1d26d5be38a48a88cb938e317e59", "html_url": "https://github.com/rust-lang/rust/commit/40b14736a05c1d26d5be38a48a88cb938e317e59", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40b14736a05c1d26d5be38a48a88cb938e317e59/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7c97040242fc689106455a73c41477bf76ebdd4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7c97040242fc689106455a73c41477bf76ebdd4", "html_url": "https://github.com/rust-lang/rust/commit/f7c97040242fc689106455a73c41477bf76ebdd4"}], "stats": {"total": 41, "additions": 35, "deletions": 6}, "files": [{"sha": "49634d6e78ce9a589eb68d9e68c5833aa7558bbc", "filename": "src/librustc_trans/cabi_x86.rs", "status": "modified", "additions": 35, "deletions": 6, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/40b14736a05c1d26d5be38a48a88cb938e317e59/src%2Flibrustc_trans%2Fcabi_x86.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40b14736a05c1d26d5be38a48a88cb938e317e59/src%2Flibrustc_trans%2Fcabi_x86.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86.rs?ref=40b14736a05c1d26d5be38a48a88cb938e317e59", "patch": "@@ -11,12 +11,30 @@\n use abi::{ArgAttribute, FnType, LayoutExt, Reg, RegKind};\n use common::CrateContext;\n \n+use rustc::ty::layout::{self, Layout, TyLayout};\n+\n #[derive(PartialEq)]\n pub enum Flavor {\n     General,\n     Fastcall\n }\n \n+fn is_single_fp_element<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                                  layout: TyLayout<'tcx>) -> bool {\n+    match *layout {\n+        Layout::Scalar { value: layout::F32, .. } |\n+        Layout::Scalar { value: layout::F64, .. } => true,\n+        Layout::Univariant { .. } => {\n+            if layout.field_count() == 1 {\n+                is_single_fp_element(ccx, layout.field(ccx, 0))\n+            } else {\n+                false\n+            }\n+        }\n+        _ => false\n+    }\n+}\n+\n pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                   fty: &mut FnType<'tcx>,\n                                   flavor: Flavor) {\n@@ -33,12 +51,23 @@ pub fn compute_abi_info<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             if t.options.is_like_osx || t.options.is_like_windows\n                 || t.options.is_like_openbsd {\n                 let size = fty.ret.layout.size(ccx);\n-                match size.bytes() {\n-                    1 => fty.ret.cast_to(ccx, Reg::i8()),\n-                    2 => fty.ret.cast_to(ccx, Reg::i16()),\n-                    4 => fty.ret.cast_to(ccx, Reg::i32()),\n-                    8 => fty.ret.cast_to(ccx, Reg::i64()),\n-                    _ => fty.ret.make_indirect(ccx)\n+\n+                // According to Clang, everyone but MSVC returns single-element\n+                // float aggregates directly in a floating-point register.\n+                if !t.options.is_like_msvc && is_single_fp_element(ccx, fty.ret.layout) {\n+                    match size.bytes() {\n+                        4 => fty.ret.cast_to(ccx, Reg::f32()),\n+                        8 => fty.ret.cast_to(ccx, Reg::f64()),\n+                        _ => fty.ret.make_indirect(ccx)\n+                    }\n+                } else {\n+                    match size.bytes() {\n+                        1 => fty.ret.cast_to(ccx, Reg::i8()),\n+                        2 => fty.ret.cast_to(ccx, Reg::i16()),\n+                        4 => fty.ret.cast_to(ccx, Reg::i32()),\n+                        8 => fty.ret.cast_to(ccx, Reg::i64()),\n+                        _ => fty.ret.make_indirect(ccx)\n+                    }\n                 }\n             } else {\n                 fty.ret.make_indirect(ccx);"}]}