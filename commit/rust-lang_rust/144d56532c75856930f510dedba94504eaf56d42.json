{"sha": "144d56532c75856930f510dedba94504eaf56d42", "node_id": "C_kwDOAAsO6NoAKDE0NGQ1NjUzMmM3NTg1NjkzMGY1MTBkZWRiYTk0NTA0ZWFmNTZkNDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-26T08:56:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-26T08:56:02Z"}, "message": "Auto merge of #1987 - saethlin:short-backtraces, r=oli-obk\n\nPrune stacktraces for tag-tracking diagnostics too\n\nIn https://github.com/rust-lang/miri/pull/1977 we forgot to use the pruning logic when printing tag-tracking messages. I just saw this output before this PR which is very silly:\n```\ntest sanity ... note: tracking was triggered\n   --> src/lib.rs:110:21\n    |\n110 |         unsafe { &*(&self.value[range] as *const [T] as *const Aligned<A, [T]>) }\n    |                     ^^^^^^^^^^^^^^^^^^ created tag 160954\n    |\n    = note: inside `<Aligned<A4, [u8]> as std::ops::Index<std::ops::RangeTo<usize>>>::index` at src/lib.rs:110:21\nnote: inside `sanity` at src/lib.rs:261:30\n   --> src/lib.rs:261:30\n    |\n261 |     let y: &Aligned<_, _> = &y[..2];\n    |                              ^^^^^^\nnote: inside closure at src/lib.rs:229:1\n   --> src/lib.rs:229:1\n    |\n228 |   #[test]\n    |   ------- in this procedural macro expansion\n229 | / fn sanity() {\n230 | |     use core::mem;\n231 | |\n232 | |     let x: Aligned<A2, _> = Aligned([0u8; 3]);\n...   |\n284 | |     let _: &[u8] = y;\n285 | | }\n    | |_^\n    = note: inside `<[closure@src/lib.rs:229:1: 285:2] as std::ops::FnOnce<()>>::call_once - shim` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/ops/function.rs:227:5\n    = note: inside `<fn() as std::ops::FnOnce<()>>::call_once - shim(fn())` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/ops/function.rs:227:5\n    = note: inside `test::__rust_begin_short_backtrace::<fn()>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:575:5\n    = note: inside closure at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:566:30\n    = note: inside `<[closure@test::run_test::{closure#1}] as std::ops::FnOnce<()>>::call_once - shim(vtable)` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/ops/function.rs:227:5\n    = note: inside `<std::boxed::Box<dyn std::ops::FnOnce() + std::marker::Send> as std::ops::FnOnce<()>>::call_once` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/alloc/src/boxed.rs:1854:9\n    = note: inside `<std::panic::AssertUnwindSafe<std::boxed::Box<dyn std::ops::FnOnce() + std::marker::Send>> as std::ops::FnOnce<()>>::call_once` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/panic/unwind_safe.rs:271:9\n    = note: inside `std::panicking::r#try::do_call::<std::panic::AssertUnwindSafe<std::boxed::Box<dyn std::ops::FnOnce() + std::marker::Send>>, ()>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panicking.rs:492:40\n    = note: inside `std::panicking::r#try::<(), std::panic::AssertUnwindSafe<std::boxed::Box<dyn std::ops::FnOnce() + std::marker::Send>>>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panicking.rs:456:19\n    = note: inside `std::panic::catch_unwind::<std::panic::AssertUnwindSafe<std::boxed::Box<dyn std::ops::FnOnce() + std::marker::Send>>, ()>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panic.rs:137:14\n    = note: inside `test::run_test_in_process` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:598:18\n    = note: inside closure at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:492:39\n    = note: inside `test::run_test::run_test_inner` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:530:13\n    = note: inside `test::run_test` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:562:28\n    = note: inside `test::run_tests::<[closure@test::run_tests_console::{closure#2}]>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:305:17\n    = note: inside `test::run_tests_console` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/console.rs:286:5\n    = note: inside `test::test_main` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:116:15\n    = note: inside `test::test_main_static` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/test/src/lib.rs:135:5\n    = note: inside `main`\n    = note: inside `<fn() as std::ops::FnOnce<()>>::call_once - shim(fn())` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/ops/function.rs:227:5\n    = note: inside `std::sys_common::backtrace::__rust_begin_short_backtrace::<fn(), ()>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/sys_common/backtrace.rs:122:18\n    = note: inside closure at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/rt.rs:145:18\n    = note: inside `std::ops::function::impls::<impl std::ops::FnOnce<()> for &dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe>::call_once` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/core/src/ops/function.rs:259:13\n    = note: inside `std::panicking::r#try::do_call::<&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe, i32>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panicking.rs:492:40\n    = note: inside `std::panicking::r#try::<i32, &dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panicking.rs:456:19\n    = note: inside `std::panic::catch_unwind::<&dyn std::ops::Fn() -> i32 + std::marker::Sync + std::panic::RefUnwindSafe, i32>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panic.rs:137:14\n    = note: inside closure at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/rt.rs:128:48\n    = note: inside `std::panicking::r#try::do_call::<[closure@std::rt::lang_start_internal::{closure#2}], isize>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panicking.rs:492:40\n    = note: inside `std::panicking::r#try::<isize, [closure@std::rt::lang_start_internal::{closure#2}]>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panicking.rs:456:19\n    = note: inside `std::panic::catch_unwind::<[closure@std::rt::lang_start_internal::{closure#2}], isize>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/panic.rs:137:14\n    = note: inside `std::rt::lang_start_internal` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/rt.rs:128:20\n    = note: inside `std::rt::lang_start::<()>` at /home/ben/.rustup/toolchains/miri/lib/rustlib/src/rust/library/std/src/rt.rs:144:17\n    = note: this note originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nerror: Undefined Behavior: trying to reborrow for SharedReadOnly at alloc61593+0x2, but parent tag <160954> does not have an appropriate item in the borrow stack\n   --> src/lib.rs:261:30\n    |\n261 |     let y: &Aligned<_, _> = &y[..2];\n    |                              ^^^^^^ trying to reborrow for SharedReadOnly at alloc61593+0x2, but parent tag <160954> does not have an appropriate item in the borrow stack\n    |\n    = help: this indicates a potential bug in the program: it performed an invalid operation, but the rules it violated are still experimental\n    = help: see https://github.com/rust-lang/unsafe-code-guidelines/blob/master/wip/stacked-borrows.md for further information\n\n    = note: inside `sanity` at src/lib.rs:261:30\nnote: inside closure at src/lib.rs:229:1\n   --> src/lib.rs:229:1\n    |\n228 |   #[test]\n    |   ------- in this procedural macro expansion\n229 | / fn sanity() {\n230 | |     use core::mem;\n231 | |\n232 | |     let x: Aligned<A2, _> = Aligned([0u8; 3]);\n...   |\n284 | |     let _: &[u8] = y;\n285 | | }\n    | |_^\n    = note: this error originates in the attribute macro `test` (in Nightly builds, run with -Z macro-backtrace for more info)\n\nnote: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n\nerror: aborting due to previous error\n\nerror: test failed, to rerun pass '--lib'\n```", "tree": {"sha": "c7bc8c5582f6c24bf7ed5d1046a8504c200852d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7bc8c5582f6c24bf7ed5d1046a8504c200852d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/144d56532c75856930f510dedba94504eaf56d42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/144d56532c75856930f510dedba94504eaf56d42", "html_url": "https://github.com/rust-lang/rust/commit/144d56532c75856930f510dedba94504eaf56d42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/144d56532c75856930f510dedba94504eaf56d42/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "538aedf09969fcc189a3aaee4a32cf01266c4941", "url": "https://api.github.com/repos/rust-lang/rust/commits/538aedf09969fcc189a3aaee4a32cf01266c4941", "html_url": "https://github.com/rust-lang/rust/commit/538aedf09969fcc189a3aaee4a32cf01266c4941"}, {"sha": "d2bb231954190da64d0b10c275beeb87833d87b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/d2bb231954190da64d0b10c275beeb87833d87b2", "html_url": "https://github.com/rust-lang/rust/commit/d2bb231954190da64d0b10c275beeb87833d87b2"}], "stats": {"total": 94, "additions": 53, "deletions": 41}, "files": [{"sha": "8494f8a8ef0faee6399c103684a49e7a4e4e06a5", "filename": "src/diagnostics.rs", "status": "modified", "additions": 53, "deletions": 41, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/144d56532c75856930f510dedba94504eaf56d42/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/144d56532c75856930f510dedba94504eaf56d42/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=144d56532c75856930f510dedba94504eaf56d42", "patch": "@@ -75,6 +75,54 @@ enum DiagLevel {\n     Note,\n }\n \n+fn has_local_frame(stacktrace: &[FrameInfo<'_>]) -> bool {\n+    stacktrace.iter().any(|frame| frame.instance.def_id().is_local())\n+}\n+\n+fn prune_stacktrace<'mir, 'tcx>(\n+    ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n+    mut stacktrace: Vec<FrameInfo<'tcx>>,\n+) -> Vec<FrameInfo<'tcx>> {\n+    match ecx.machine.backtrace_style {\n+        BacktraceStyle::Off => {\n+            // Retain one frame so that we can print a span for the error itself\n+            stacktrace.truncate(1);\n+        }\n+        BacktraceStyle::Short => {\n+            // Only prune frames if there is at least one local frame. This check ensures that if\n+            // we get a backtrace that never makes it to the user code because it has detected a\n+            // bug in the Rust runtime, we don't prune away every frame.\n+            if has_local_frame(&stacktrace) {\n+                // This is part of the logic that `std` uses to select the relevant part of a\n+                // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n+                // __rust_end_short_backtrace because the end symbol comes from a call to the default\n+                // panic handler.\n+                stacktrace = stacktrace\n+                    .into_iter()\n+                    .take_while(|frame| {\n+                        let def_id = frame.instance.def_id();\n+                        let path = ecx.tcx.tcx.def_path_str(def_id);\n+                        !path.contains(\"__rust_begin_short_backtrace\")\n+                    })\n+                    .collect::<Vec<_>>();\n+\n+                // After we prune frames from the bottom, there are a few left that are part of the\n+                // Rust runtime. So we remove frames until we get to a local symbol, which should be\n+                // main or a test.\n+                // This len check ensures that we don't somehow remove every frame, as doing so breaks\n+                // the primary error message.\n+                while stacktrace.len() > 1\n+                    && stacktrace.last().map_or(false, |e| !e.instance.def_id().is_local())\n+                {\n+                    stacktrace.pop();\n+                }\n+            }\n+        }\n+        BacktraceStyle::Full => {}\n+    }\n+    stacktrace\n+}\n+\n /// Emit a custom diagnostic without going through the miri-engine machinery\n pub fn report_error<'tcx, 'mir>(\n     ecx: &InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n@@ -157,46 +205,8 @@ pub fn report_error<'tcx, 'mir>(\n         }\n     };\n \n-    let mut stacktrace = ecx.generate_stacktrace();\n-    let has_local_frame = stacktrace.iter().any(|frame| frame.instance.def_id().is_local());\n-    match ecx.machine.backtrace_style {\n-        BacktraceStyle::Off => {\n-            // Retain one frame so that we can print a span for the error itself\n-            stacktrace.truncate(1);\n-        }\n-        BacktraceStyle::Short => {\n-            // Only prune frames if there is at least one local frame. This check ensures that if\n-            // we get a backtrace that never makes it to the user code because it has detected a\n-            // bug in the Rust runtime, we don't prune away every frame.\n-            if has_local_frame {\n-                // This is part of the logic that `std` uses to select the relevant part of a\n-                // backtrace. But here, we only look for __rust_begin_short_backtrace, not\n-                // __rust_end_short_backtrace because the end symbol comes from a call to the default\n-                // panic handler.\n-                stacktrace = stacktrace\n-                    .into_iter()\n-                    .take_while(|frame| {\n-                        let def_id = frame.instance.def_id();\n-                        let path = ecx.tcx.tcx.def_path_str(def_id);\n-                        !path.contains(\"__rust_begin_short_backtrace\")\n-                    })\n-                    .collect::<Vec<_>>();\n-\n-                // After we prune frames from the bottom, there are a few left that are part of the\n-                // Rust runtime. So we remove frames until we get to a local symbol, which should be\n-                // main or a test.\n-                // This len check ensures that we don't somehow remove every frame, as doing so breaks\n-                // the primary error message.\n-                while stacktrace.len() > 1\n-                    && stacktrace.last().map_or(false, |e| !e.instance.def_id().is_local())\n-                {\n-                    stacktrace.pop();\n-                }\n-            }\n-        }\n-        BacktraceStyle::Full => {}\n-    }\n-\n+    let stacktrace = ecx.generate_stacktrace();\n+    let stacktrace = prune_stacktrace(ecx, stacktrace);\n     e.print_backtrace();\n     let msg = e.to_string();\n     report_msg(\n@@ -210,7 +220,7 @@ pub fn report_error<'tcx, 'mir>(\n \n     // Include a note like `std` does for short backtraces, but since we are opt-out not opt-in, we\n     // do not include a note when backtraces are off.\n-    if ecx.machine.backtrace_style == BacktraceStyle::Short && has_local_frame {\n+    if ecx.machine.backtrace_style == BacktraceStyle::Short && has_local_frame(&stacktrace) {\n         ecx.tcx.sess.diagnostic().note_without_error(\n             \"some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\",\n         );\n@@ -367,6 +377,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 );\n             }\n \n+            let stacktrace = prune_stacktrace(this, stacktrace);\n+\n             // Show diagnostics.\n             for e in diagnostics.drain(..) {\n                 use NonHaltingDiagnostic::*;"}]}