{"sha": "214d6b6836413bbfe9132f7aff3d91ae67bc62ba", "node_id": "C_kwDOAAsO6NoAKDIxNGQ2YjY4MzY0MTNiYmZlOTEzMmY3YWZmM2Q5MWFlNjdiYzYyYmE", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-11-02T21:06:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-11-02T21:06:26Z"}, "message": "Rollup merge of #99801 - Neo-Zhixing:fix/generic_const_exprs_parent_opaque_predicates, r=oli-obk\n\nfix(generic_const_exprs): Fix predicate inheritance for children of opaque types\n\nFixes #99705\n\nWe currently have a special case to perform predicate inheritance when the const item is in the generics. I think we're also going to need this for opaque return types. When evaluating the predicates applied to the associated item, it'll inherit from its parent, the opaque type, which will never have predicates applied. This PR bypass the opaque typed parent and inherit predicates directly from the function itself.", "tree": {"sha": "cf6d81f856d3cd4779dffd35eed075402f69238b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf6d81f856d3cd4779dffd35eed075402f69238b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/214d6b6836413bbfe9132f7aff3d91ae67bc62ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjYtvSCRBK7hj4Ov3rIwAAGuUIABH/SDbybcseY4mUApuJsF+z\npeS3GUf7EdNNg09sg+GWpTHuNJu3e6j4ieBq8vp7fphcg5boJi2tj1LbVAVRfzmN\n5up6/PISPDxps1kICD9B1KjbvYdaRF8tcsg/k0g96UNlAzrSwWCspvVar3kngHT7\nwsv+7F56gyiV7+X+nKdcX3Us/xlnG5+836pw2fYtwBWs1Aw3jkWsQ5j9uik9eWQ4\nJeF4FdfoFZxTE6BHgqNDUn8E4ldr3KAa3PzUBzI9EpiSnhr1UWp2149kUmcWAVK0\nh2zCj4QxM/r9ebqxaQQodMWN1/qaI7fZvp5QNHzaCm72WMATPzgF/zTqNaYJ2QA=\n=iyts\n-----END PGP SIGNATURE-----\n", "payload": "tree cf6d81f856d3cd4779dffd35eed075402f69238b\nparent edf0182213a9e30982eb34f3925ddc4cf5ed3471\nparent 744fa610eb6bd476b875dd2d6f8be5b7b9f1b77c\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1667423186 +0100\ncommitter GitHub <noreply@github.com> 1667423186 +0100\n\nRollup merge of #99801 - Neo-Zhixing:fix/generic_const_exprs_parent_opaque_predicates, r=oli-obk\n\nfix(generic_const_exprs): Fix predicate inheritance for children of opaque types\n\nFixes #99705\n\nWe currently have a special case to perform predicate inheritance when the const item is in the generics. I think we're also going to need this for opaque return types. When evaluating the predicates applied to the associated item, it'll inherit from its parent, the opaque type, which will never have predicates applied. This PR bypass the opaque typed parent and inherit predicates directly from the function itself.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/214d6b6836413bbfe9132f7aff3d91ae67bc62ba", "html_url": "https://github.com/rust-lang/rust/commit/214d6b6836413bbfe9132f7aff3d91ae67bc62ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/214d6b6836413bbfe9132f7aff3d91ae67bc62ba/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "edf0182213a9e30982eb34f3925ddc4cf5ed3471", "url": "https://api.github.com/repos/rust-lang/rust/commits/edf0182213a9e30982eb34f3925ddc4cf5ed3471", "html_url": "https://github.com/rust-lang/rust/commit/edf0182213a9e30982eb34f3925ddc4cf5ed3471"}, {"sha": "744fa610eb6bd476b875dd2d6f8be5b7b9f1b77c", "url": "https://api.github.com/repos/rust-lang/rust/commits/744fa610eb6bd476b875dd2d6f8be5b7b9f1b77c", "html_url": "https://github.com/rust-lang/rust/commit/744fa610eb6bd476b875dd2d6f8be5b7b9f1b77c"}], "stats": {"total": 64, "additions": 62, "deletions": 2}, "files": [{"sha": "5d1ca1cbd2389046881a349839011366507c796d", "filename": "compiler/rustc_hir_analysis/src/collect/predicates_of.rs", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/214d6b6836413bbfe9132f7aff3d91ae67bc62ba/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214d6b6836413bbfe9132f7aff3d91ae67bc62ba/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Fpredicates_of.rs?ref=214d6b6836413bbfe9132f7aff3d91ae67bc62ba", "patch": "@@ -427,6 +427,8 @@ pub(super) fn explicit_predicates_of<'tcx>(\n     } else {\n         if matches!(def_kind, DefKind::AnonConst) && tcx.lazy_normalization() {\n             let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n+            let parent_def_id = tcx.hir().get_parent_item(hir_id);\n+\n             if tcx.hir().opt_const_param_default_param_hir_id(hir_id).is_some() {\n                 // In `generics_of` we set the generics' parent to be our parent's parent which means that\n                 // we lose out on the predicates of our actual parent if we dont return those predicates here.\n@@ -439,8 +441,33 @@ pub(super) fn explicit_predicates_of<'tcx>(\n                 //        parent of generics returned by `generics_of`\n                 //\n                 // In the above code we want the anon const to have predicates in its param env for `T: Trait`\n-                let item_def_id = tcx.hir().get_parent_item(hir_id);\n-                // In the above code example we would be calling `explicit_predicates_of(Foo)` here\n+                // and we would be calling `explicit_predicates_of(Foo)` here\n+                return tcx.explicit_predicates_of(parent_def_id);\n+            }\n+\n+            let parent_def_kind = tcx.def_kind(parent_def_id);\n+            if matches!(parent_def_kind, DefKind::OpaqueTy) {\n+                // In `instantiate_identity` we inherit the predicates of our parent.\n+                // However, opaque types do not have a parent (see `gather_explicit_predicates_of`), which means\n+                // that we lose out on the predicates of our actual parent if we dont return those predicates here.\n+                //\n+                //\n+                // fn foo<T: Trait>() -> impl Iterator<Output = Another<{ <T as Trait>::ASSOC }> > { todo!() }\n+                //                                                        ^^^^^^^^^^^^^^^^^^^ the def id we are calling\n+                //                                                                            explicit_predicates_of on\n+                //\n+                // In the above code we want the anon const to have predicates in its param env for `T: Trait`.\n+                // However, the anon const cannot inherit predicates from its parent since it's opaque.\n+                //\n+                // To fix this, we call `explicit_predicates_of` directly on `foo`, the parent's parent.\n+\n+                // In the above example this is `foo::{opaque#0}` or `impl Iterator`\n+                let parent_hir_id = tcx.hir().local_def_id_to_hir_id(parent_def_id.def_id);\n+\n+                // In the above example this is the function `foo`\n+                let item_def_id = tcx.hir().get_parent_item(parent_hir_id);\n+\n+                // In the above code example we would be calling `explicit_predicates_of(foo)` here\n                 return tcx.explicit_predicates_of(item_def_id);\n             }\n         }"}, {"sha": "75b57b621bb574160965e9d76f935458f8bd8d6e", "filename": "src/test/ui/const-generics/generic_const_exprs/issue-99705.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/214d6b6836413bbfe9132f7aff3d91ae67bc62ba/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-99705.rs", "raw_url": "https://github.com/rust-lang/rust/raw/214d6b6836413bbfe9132f7aff3d91ae67bc62ba/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-99705.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Fissue-99705.rs?ref=214d6b6836413bbfe9132f7aff3d91ae67bc62ba", "patch": "@@ -0,0 +1,33 @@\n+// check-pass\n+#![crate_type = \"lib\"]\n+#![feature(generic_const_exprs)]\n+#![allow(incomplete_features)]\n+pub trait MyIterator {\n+    type Output;\n+}\n+\n+pub trait Foo {\n+    const ABC: usize;\n+}\n+\n+pub struct IteratorStruct<const N: usize>{\n+\n+}\n+\n+pub struct Bar<const N: usize> {\n+    pub data: [usize; N]\n+}\n+\n+impl<const N: usize> MyIterator for IteratorStruct<N> {\n+    type Output = Bar<N>;\n+}\n+\n+pub fn test1<T: Foo>() -> impl MyIterator<Output = Bar<{T::ABC}>> where [(); T::ABC]: Sized {\n+    IteratorStruct::<{T::ABC}>{}\n+}\n+\n+pub trait Baz<const N: usize>{}\n+impl<const N: usize> Baz<N> for Bar<N> {}\n+pub fn test2<T: Foo>() -> impl MyIterator<Output = impl Baz<{ T::ABC }>> where [(); T::ABC]: Sized {\n+    IteratorStruct::<{T::ABC}>{}\n+}"}]}