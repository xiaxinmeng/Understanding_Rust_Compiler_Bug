{"sha": "fb0b388804ec6b4535e73a890feda7372182486f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMGIzODg4MDRlYzZiNDUzNWU3M2E4OTBmZWRhNzM3MjE4MjQ4NmY=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-03T20:51:49Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2013-08-30T05:49:26Z"}, "message": "Make the iterator protocol more explicit\n\nDocument the fact that the iterator protocol only defines behavior up\nuntil the first None is returned. After this point, iterators are free\nto behave how they wish.\n\nAdd a new iterator adaptor Fuse<T> that modifies iterators to return\nNone forever if they returned None once.", "tree": {"sha": "a8020a76bb4bd76303eb24e222d78874b803a18b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8020a76bb4bd76303eb24e222d78874b803a18b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb0b388804ec6b4535e73a890feda7372182486f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb0b388804ec6b4535e73a890feda7372182486f", "html_url": "https://github.com/rust-lang/rust/commit/fb0b388804ec6b4535e73a890feda7372182486f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb0b388804ec6b4535e73a890feda7372182486f/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c6c7519a75064d11f855de862bcdaddcbe5df4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c6c7519a75064d11f855de862bcdaddcbe5df4b", "html_url": "https://github.com/rust-lang/rust/commit/7c6c7519a75064d11f855de862bcdaddcbe5df4b"}], "stats": {"total": 147, "additions": 145, "deletions": 2}, "files": [{"sha": "7851e9852c115893a6f4cdba9c33f9c1501ab9b3", "filename": "doc/tutorial-container.md", "status": "modified", "additions": 35, "deletions": 2, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb0b388804ec6b4535e73a890feda7372182486f/doc%2Ftutorial-container.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb0b388804ec6b4535e73a890feda7372182486f/doc%2Ftutorial-container.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-container.md?ref=fb0b388804ec6b4535e73a890feda7372182486f", "patch": "@@ -105,14 +105,18 @@ impl Iterator<int> for ZeroStream {\n }\n ~~~\n \n+In general, you cannot rely on the behavior of the `next()` method after it has\n+returned `None`. Some iterators may return `None` forever. Others may behave\n+differently.\n+\n ## Container iterators\n \n Containers implement iteration over the contained elements by returning an\n iterator object. For example, vector slices several iterators available:\n \n * `iter()` and `rev_iter()`, for immutable references to the elements\n * `mut_iter()` and `mut_rev_iter()`, for mutable references to the elements\n-* `move_iter()` and `move_rev_iter`, to move the elements out by-value\n+* `move_iter()` and `move_rev_iter()`, to move the elements out by-value\n \n A typical mutable container will implement at least `iter()`, `mut_iter()` and\n `move_iter()` along with the reverse variants if it maintains an order.\n@@ -149,7 +153,7 @@ let result = xs.iter().fold(0, |accumulator, item| accumulator - *item);\n assert_eq!(result, -41);\n ~~~\n \n-Some adaptors return an adaptor object implementing the `Iterator` trait itself:\n+Most adaptors return an adaptor object implementing the `Iterator` trait itself:\n \n ~~~\n let xs = [1, 9, 2, 3, 14, 12];\n@@ -158,6 +162,35 @@ let sum = xs.iter().chain(ys.iter()).fold(0, |a, b| a + *b);\n assert_eq!(sum, 57);\n ~~~\n \n+Some iterator adaptors may return `None` before exhausting the underlying\n+iterator. Additionally, if these iterator adaptors are called again after\n+returning `None`, they may call their underlying iterator again even if the\n+adaptor will continue to return `None` forever. This may not be desired if the\n+underlying iterator has side-effects.\n+\n+In order to provide a guarantee about behavior once `None` has been returned, an\n+iterator adaptor named `fuse()` is provided. This returns an iterator that will\n+never call its underlying iterator again once `None` has been returned:\n+\n+~~~\n+let xs = [1,2,3,4,5];\n+let mut calls = 0;\n+let it = xs.iter().scan((), |_, x| {\n+    calls += 1;\n+    if *x < 3 { Some(x) } else { None }});\n+// the iterator will only yield 1 and 2 before returning None\n+// If we were to call it 5 times, calls would end up as 5, despite only 2 values\n+// being yielded (and therefore 3 unique calls being made). The fuse() adaptor\n+// can fix this.\n+let mut it = it.fuse();\n+it.next();\n+it.next();\n+it.next();\n+it.next();\n+it.next();\n+assert_eq!(calls, 3);\n+~~~\n+\n ## For loops\n \n The function `range` (or `range_inclusive`) allows to simply iterate through a given range:"}, {"sha": "841b6134410e614a4f9dbb08c5add52957026af3", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/fb0b388804ec6b4535e73a890feda7372182486f/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb0b388804ec6b4535e73a890feda7372182486f/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=fb0b388804ec6b4535e73a890feda7372182486f", "patch": "@@ -41,6 +41,13 @@ pub trait Extendable<A>: FromIterator<A> {\n /// An interface for dealing with \"external iterators\". These types of iterators\n /// can be resumed at any time as all state is stored internally as opposed to\n /// being located on the call stack.\n+///\n+/// The Iterator protocol states that an iterator yields a (potentially-empty,\n+/// potentially-infinite) sequence of values, and returns `None` to signal that\n+/// it's finished. The Iterator protocol does not define behavior after `None`\n+/// is returned. A concrete Iterator implementation may choose to behave however\n+/// it wishes, either by returning `None` infinitely, or by doing something\n+/// else.\n pub trait Iterator<A> {\n     /// Advance the iterator and return the next value. Return `None` when the end is reached.\n     fn next(&mut self) -> Option<A>;\n@@ -300,6 +307,36 @@ pub trait Iterator<A> {\n         FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n     }\n \n+    /// Creates an iterator that yields `None` forever after the underlying\n+    /// iterator yields `None`. Random-access iterator behavior is not\n+    /// affected, only single and double-ended iterator behavior.\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// fn process<U: Iterator<int>>(it: U) -> int {\n+    ///     let mut it = it.fuse();\n+    ///     let mut sum = 0;\n+    ///     for x in it {\n+    ///         if x > 5 {\n+    ///             break;\n+    ///         }\n+    ///         sum += x;\n+    ///     }\n+    ///     // did we exhaust the iterator?\n+    ///     if it.next().is_none() {\n+    ///         sum += 1000;\n+    ///     }\n+    ///     sum\n+    /// }\n+    /// let x = ~[1,2,3,7,8,9];\n+    /// assert_eq!(process(x.move_iter()), 1006);\n+    /// ~~~\n+    #[inline]\n+    fn fuse(self) -> Fuse<Self> {\n+        Fuse{iter: self, done: false}\n+    }\n+\n     /// Creates an iterator that calls a function with a reference to each\n     /// element before yielding it. This is often useful for debugging an\n     /// iterator pipeline.\n@@ -1421,6 +1458,79 @@ impl<'self,\n     }\n }\n \n+/// An iterator that yields `None` forever after the underlying iterator\n+/// yields `None` once.\n+#[deriving(Clone, DeepClone)]\n+pub struct Fuse<T> {\n+    priv iter: T,\n+    priv done: bool\n+}\n+\n+impl<A, T: Iterator<A>> Iterator<A> for Fuse<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> {\n+        if self.done {\n+            None\n+        } else {\n+            match self.iter.next() {\n+                None => {\n+                    self.done = true;\n+                    None\n+                }\n+                x => x\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) {\n+        if self.done {\n+            (0, Some(0))\n+        } else {\n+            self.iter.size_hint()\n+        }\n+    }\n+}\n+\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Fuse<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> {\n+        if self.done {\n+            None\n+        } else {\n+            match self.iter.next_back() {\n+                None => {\n+                    self.done = true;\n+                    None\n+                }\n+                x => x\n+            }\n+        }\n+    }\n+}\n+\n+// Allow RandomAccessIterators to be fused without affecting random-access behavior\n+impl<A, T: RandomAccessIterator<A>> RandomAccessIterator<A> for Fuse<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.iter.indexable()\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        self.iter.idx(index)\n+    }\n+}\n+\n+impl<T> Fuse<T> {\n+    /// Resets the fuse such that the next call to .next() or .next_back() will\n+    /// call the underlying iterator again even if it prevously returned None.\n+    #[inline]\n+    fn reset_fuse(&mut self) {\n+        self.done = false\n+    }\n+}\n+\n /// An iterator that calls a function with a reference to each\n /// element before yielding it.\n pub struct Inspect<'self, A, T> {"}]}