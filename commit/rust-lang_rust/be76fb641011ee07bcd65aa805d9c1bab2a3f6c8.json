{"sha": "be76fb641011ee07bcd65aa805d9c1bab2a3f6c8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNzZmYjY0MTAxMWVlMDdiY2Q2NWFhODA1ZDljMWJhYjJhM2Y2Yzg=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-13T17:09:53Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-10-13T17:09:53Z"}, "message": "Rollup merge of #28990 - ahmedcharles:libarena, r=nrc", "tree": {"sha": "58ce6536fcb1c9e394a8eb071f93ed418bfd2c96", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58ce6536fcb1c9e394a8eb071f93ed418bfd2c96"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be76fb641011ee07bcd65aa805d9c1bab2a3f6c8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be76fb641011ee07bcd65aa805d9c1bab2a3f6c8", "html_url": "https://github.com/rust-lang/rust/commit/be76fb641011ee07bcd65aa805d9c1bab2a3f6c8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be76fb641011ee07bcd65aa805d9c1bab2a3f6c8/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "749e93d313ff7c274cde3075c4117ecaf096d484", "url": "https://api.github.com/repos/rust-lang/rust/commits/749e93d313ff7c274cde3075c4117ecaf096d484", "html_url": "https://github.com/rust-lang/rust/commit/749e93d313ff7c274cde3075c4117ecaf096d484"}, {"sha": "21bb0dcc120011dbe308c5d8410d07188db61ca4", "url": "https://api.github.com/repos/rust-lang/rust/commits/21bb0dcc120011dbe308c5d8410d07188db61ca4", "html_url": "https://github.com/rust-lang/rust/commit/21bb0dcc120011dbe308c5d8410d07188db61ca4"}], "stats": {"total": 120, "additions": 50, "deletions": 70}, "files": [{"sha": "97621a2ac89d4f2f28d9d83323c8af5832e49c06", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 50, "deletions": 70, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/be76fb641011ee07bcd65aa805d9c1bab2a3f6c8/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be76fb641011ee07bcd65aa805d9c1bab2a3f6c8/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=be76fb641011ee07bcd65aa805d9c1bab2a3f6c8", "patch": "@@ -105,7 +105,7 @@ pub struct Arena<'longer_than_self> {\n     head: RefCell<Chunk>,\n     copy_head: RefCell<Chunk>,\n     chunks: RefCell<Vec<Chunk>>,\n-    _marker: marker::PhantomData<*mut &'longer_than_self()>,\n+    _marker: marker::PhantomData<*mut &'longer_than_self ()>,\n }\n \n impl<'a> Arena<'a> {\n@@ -197,7 +197,7 @@ fn un_bitpack_tydesc_ptr(p: usize) -> (*const TyDesc, bool) {\n struct TyDesc {\n     drop_glue: fn(*const i8),\n     size: usize,\n-    align: usize\n+    align: usize,\n }\n \n trait AllTypes { fn dummy(&self) { } }\n@@ -224,8 +224,7 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.copy_head.borrow().clone());\n \n-        *self.copy_head.borrow_mut() =\n-            chunk((new_min_chunk_size + 1).next_power_of_two(), true);\n+        *self.copy_head.borrow_mut() = chunk((new_min_chunk_size + 1).next_power_of_two(), true);\n \n         self.alloc_copy_inner(n_bytes, align)\n     }\n@@ -242,38 +241,32 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n         let copy_head = self.copy_head.borrow();\n         copy_head.fill.set(end);\n \n-        unsafe {\n-            copy_head.as_ptr().offset(start as isize)\n-        }\n+        unsafe { copy_head.as_ptr().offset(start as isize) }\n     }\n \n     #[inline]\n     fn alloc_copy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n-            let ptr = self.alloc_copy_inner(mem::size_of::<T>(),\n-                                            mem::align_of::<T>());\n+            let ptr = self.alloc_copy_inner(mem::size_of::<T>(), mem::align_of::<T>());\n             let ptr = ptr as *mut T;\n             ptr::write(&mut (*ptr), op());\n             &mut *ptr\n         }\n     }\n \n     // Functions for the non-POD part of the arena\n-    fn alloc_noncopy_grow(&self, n_bytes: usize,\n-                          align: usize) -> (*const u8, *const u8) {\n+    fn alloc_noncopy_grow(&self, n_bytes: usize, align: usize) -> (*const u8, *const u8) {\n         // Allocate a new chunk.\n         let new_min_chunk_size = cmp::max(n_bytes, self.chunk_size());\n         self.chunks.borrow_mut().push(self.head.borrow().clone());\n \n-        *self.head.borrow_mut() =\n-            chunk((new_min_chunk_size + 1).next_power_of_two(), false);\n+        *self.head.borrow_mut() = chunk((new_min_chunk_size + 1).next_power_of_two(), false);\n \n         self.alloc_noncopy_inner(n_bytes, align)\n     }\n \n     #[inline]\n-    fn alloc_noncopy_inner(&self, n_bytes: usize,\n-                           align: usize) -> (*const u8, *const u8) {\n+    fn alloc_noncopy_inner(&self, n_bytes: usize, align: usize) -> (*const u8, *const u8) {\n         // Be careful to not maintain any `head` borrows active, because\n         // `alloc_noncopy_grow` borrows it mutably.\n         let (start, end, tydesc_start, head_capacity) = {\n@@ -297,24 +290,23 @@ impl<'longer_than_self> Arena<'longer_than_self> {\n \n         unsafe {\n             let buf = head.as_ptr();\n-            (buf.offset(tydesc_start as isize), buf.offset(start as isize))\n+            (buf.offset(tydesc_start as isize),\n+             buf.offset(start as isize))\n         }\n     }\n \n     #[inline]\n     fn alloc_noncopy<T, F>(&self, op: F) -> &mut T where F: FnOnce() -> T {\n         unsafe {\n             let tydesc = get_tydesc::<T>();\n-            let (ty_ptr, ptr) =\n-                self.alloc_noncopy_inner(mem::size_of::<T>(),\n-                                         mem::align_of::<T>());\n+            let (ty_ptr, ptr) = self.alloc_noncopy_inner(mem::size_of::<T>(), mem::align_of::<T>());\n             let ty_ptr = ty_ptr as *mut usize;\n             let ptr = ptr as *mut T;\n             // Write in our tydesc along with a bit indicating that it\n             // has *not* been initialized yet.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, false);\n             // Actually initialize it\n-            ptr::write(&mut(*ptr), op());\n+            ptr::write(&mut (*ptr), op());\n             // Now that we are done, update the tydesc to indicate that\n             // the object is there.\n             *ty_ptr = bitpack_tydesc_ptr(tydesc, true);\n@@ -358,10 +350,10 @@ fn test_arena_destructors_fail() {\n     for i in 0..10 {\n         // Arena allocate something with drop glue to make sure it\n         // doesn't leak.\n-        arena.alloc(|| { Rc::new(i) });\n+        arena.alloc(|| Rc::new(i));\n         // Allocate something with funny size and alignment, to keep\n         // things interesting.\n-        arena.alloc(|| { [0u8, 1, 2] });\n+        arena.alloc(|| [0u8, 1, 2]);\n     }\n     // Now, panic while allocating\n     arena.alloc::<Rc<i32>, _>(|| {\n@@ -409,12 +401,13 @@ fn calculate_size<T>(capacity: usize) -> usize {\n \n impl<T> TypedArenaChunk<T> {\n     #[inline]\n-    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize)\n-           -> *mut TypedArenaChunk<T> {\n+    unsafe fn new(next: *mut TypedArenaChunk<T>, capacity: usize) -> *mut TypedArenaChunk<T> {\n         let size = calculate_size::<T>(capacity);\n-        let chunk = allocate(size, mem::align_of::<TypedArenaChunk<T>>())\n-                    as *mut TypedArenaChunk<T>;\n-        if chunk.is_null() { alloc::oom() }\n+        let chunk =\n+            allocate(size, mem::align_of::<TypedArenaChunk<T>>()) as *mut TypedArenaChunk<T>;\n+        if chunk.is_null() {\n+            alloc::oom()\n+        }\n         (*chunk).next = next;\n         (*chunk).capacity = capacity;\n         chunk\n@@ -437,7 +430,8 @@ impl<T> TypedArenaChunk<T> {\n         let next = self.next;\n         let size = calculate_size::<T>(self.capacity);\n         let self_ptr: *mut TypedArenaChunk<T> = self;\n-        deallocate(self_ptr as *mut u8, size,\n+        deallocate(self_ptr as *mut u8,\n+                   size,\n                    mem::align_of::<TypedArenaChunk<T>>());\n         if !next.is_null() {\n             let capacity = (*next).capacity;\n@@ -449,9 +443,7 @@ impl<T> TypedArenaChunk<T> {\n     #[inline]\n     fn start(&self) -> *const u8 {\n         let this: *const TypedArenaChunk<T> = self;\n-        unsafe {\n-            round_up(this.offset(1) as usize, mem::align_of::<T>()) as *const u8\n-        }\n+        unsafe { round_up(this.offset(1) as usize, mem::align_of::<T>()) as *const u8 }\n     }\n \n     // Returns a pointer to the end of the allocated space.\n@@ -545,22 +537,29 @@ mod tests {\n \n     #[test]\n     fn test_arena_alloc_nested() {\n-        struct Inner { value: u8 }\n-        struct Outer<'a> { inner: &'a Inner }\n-        enum EI<'e> { I(Inner), O(Outer<'e>) }\n+        struct Inner {\n+            value: u8,\n+        }\n+        struct Outer<'a> {\n+            inner: &'a Inner,\n+        }\n+        enum EI<'e> {\n+            I(Inner),\n+            O(Outer<'e>),\n+        }\n \n         struct Wrap<'a>(TypedArena<EI<'a>>);\n \n         impl<'a> Wrap<'a> {\n-            fn alloc_inner<F:Fn() -> Inner>(&self, f: F) -> &Inner {\n+            fn alloc_inner<F: Fn() -> Inner>(&self, f: F) -> &Inner {\n                 let r: &EI = self.0.alloc(EI::I(f()));\n                 if let &EI::I(ref i) = r {\n                     i\n                 } else {\n                     panic!(\"mismatch\");\n                 }\n             }\n-            fn alloc_outer<F:Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n+            fn alloc_outer<F: Fn() -> Outer<'a>>(&self, f: F) -> &Outer {\n                 let r: &EI = self.0.alloc(EI::O(f()));\n                 if let &EI::O(ref o) = r {\n                     o\n@@ -572,8 +571,9 @@ mod tests {\n \n         let arena = Wrap(TypedArena::new());\n \n-        let result = arena.alloc_outer(|| Outer {\n-            inner: arena.alloc_inner(|| Inner { value: 10 }) });\n+        let result = arena.alloc_outer(|| {\n+            Outer { inner: arena.alloc_inner(|| Inner { value: 10 }) }\n+        });\n \n         assert_eq!(result.inner.value, 10);\n     }\n@@ -582,49 +582,27 @@ mod tests {\n     pub fn test_copy() {\n         let arena = TypedArena::new();\n         for _ in 0..100000 {\n-            arena.alloc(Point {\n-                x: 1,\n-                y: 2,\n-                z: 3,\n-            });\n+            arena.alloc(Point { x: 1, y: 2, z: 3 });\n         }\n     }\n \n     #[bench]\n     pub fn bench_copy(b: &mut Bencher) {\n         let arena = TypedArena::new();\n-        b.iter(|| {\n-            arena.alloc(Point {\n-                x: 1,\n-                y: 2,\n-                z: 3,\n-            })\n-        })\n+        b.iter(|| arena.alloc(Point { x: 1, y: 2, z: 3 }))\n     }\n \n     #[bench]\n     pub fn bench_copy_nonarena(b: &mut Bencher) {\n         b.iter(|| {\n-            let _: Box<_> = box Point {\n-                x: 1,\n-                y: 2,\n-                z: 3,\n-            };\n+            let _: Box<_> = box Point { x: 1, y: 2, z: 3 };\n         })\n     }\n \n     #[bench]\n     pub fn bench_copy_old_arena(b: &mut Bencher) {\n         let arena = Arena::new();\n-        b.iter(|| {\n-            arena.alloc(|| {\n-                Point {\n-                    x: 1,\n-                    y: 2,\n-                    z: 3,\n-                }\n-            })\n-        })\n+        b.iter(|| arena.alloc(|| Point { x: 1, y: 2, z: 3 }))\n     }\n \n     #[allow(dead_code)]\n@@ -639,7 +617,7 @@ mod tests {\n         for _ in 0..100000 {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!( 1, 2, 3, 4, 5 ),\n+                array: vec!(1, 2, 3, 4, 5),\n             });\n         }\n     }\n@@ -650,7 +628,7 @@ mod tests {\n         b.iter(|| {\n             arena.alloc(Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!( 1, 2, 3, 4, 5 ),\n+                array: vec!(1, 2, 3, 4, 5),\n             })\n         })\n     }\n@@ -660,7 +638,7 @@ mod tests {\n         b.iter(|| {\n             let _: Box<_> = box Noncopy {\n                 string: \"hello world\".to_string(),\n-                array: vec!( 1, 2, 3, 4, 5 ),\n+                array: vec!(1, 2, 3, 4, 5),\n             };\n         })\n     }\n@@ -669,9 +647,11 @@ mod tests {\n     pub fn bench_noncopy_old_arena(b: &mut Bencher) {\n         let arena = Arena::new();\n         b.iter(|| {\n-            arena.alloc(|| Noncopy {\n-                string: \"hello world\".to_string(),\n-                array: vec!( 1, 2, 3, 4, 5 ),\n+            arena.alloc(|| {\n+                Noncopy {\n+                    string: \"hello world\".to_string(),\n+                    array: vec!(1, 2, 3, 4, 5),\n+                }\n             })\n         })\n     }"}]}