{"sha": "d98a2b90b2043e8b25701841c10e4598a3da2845", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5OGEyYjkwYjIwNDNlOGIyNTcwMTg0MWMxMGU0NTk4YTNkYTI4NDU=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-02-09T08:38:45Z"}, "committer": {"name": "Oliver Schneider", "email": "git-spam-no-reply9815368754983@oli-obk.de", "date": "2018-03-08T07:34:17Z"}, "message": "Rebase fallout", "tree": {"sha": "202d95b20fe6120d8caf1711c49b5f084723d26a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/202d95b20fe6120d8caf1711c49b5f084723d26a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d98a2b90b2043e8b25701841c10e4598a3da2845", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEYFTdM4NKd7XQft77pp+NIls619kFAlqg53kACgkQpp+NIls6\n19n/5BAArwutEvR41OCcap54os6dNNoGGyxDZkofvPQGimIW7XKgD0CWTAXvUamv\nKs4DF0TOcf68hXG7uJpYP6AhWREcZRNSof2f04Rsso/NhwoZST/FjO3Q+IStUFGC\n/byMp+qB9OpALMYoPrFPIdBrNWEziDvwsmROi//9/gKcC8RDvJO3rDleFEAmckqw\nC2A59LiHxwXGG/3kRXDy4jkjzpP50Ryw3MyZsPPPyJlvhCKE6F6kuJFveTD1S54O\nLTCZr5QbsGjwewC8049hY9ObsojqEksPQLlIGS/3+EVK8v6OdAM/8VjAlQ7A7H3w\nWbztXeXnBmkAfO+y2LGTbluGnQQU7MXatJ94lSut+eY/14Z3L9oT/QgItVTyMERl\nBKWQQJjOGFuiolY1hlXwJO1V6t/LlwuOHwBdp2WFnwoL9MSnZ2lE/7JrJqMXZ2XZ\nUa+yAxGbAewCsaoWbST/x2HuemkpD89hzuuZrqbrfKr0+7IASWu4lROGlHazTiy+\ng3UoS1663H6/ZR93aL9GFOOvK4Jxg5yxe8hjoRb4k8iFUh90TTUnDrVBJ6Iqoqgx\nUvoUCthRGV7nmKcYeISL3R5WBOodJcjM6JvHFt8vZWtC+K7BY3zsfAyc7YX45Xoi\nx70HQduhAuSjwxhV30JQbeertUQy22S7iWZAWXGofNPEoTo9H0M=\n=RvnX\n-----END PGP SIGNATURE-----", "payload": "tree 202d95b20fe6120d8caf1711c49b5f084723d26a\nparent 2f0e07730088b7656c244030f360406758f788ea\nauthor Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1518165525 +0100\ncommitter Oliver Schneider <git-spam-no-reply9815368754983@oli-obk.de> 1520494457 +0100\n\nRebase fallout\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d98a2b90b2043e8b25701841c10e4598a3da2845", "html_url": "https://github.com/rust-lang/rust/commit/d98a2b90b2043e8b25701841c10e4598a3da2845", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d98a2b90b2043e8b25701841c10e4598a3da2845/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f0e07730088b7656c244030f360406758f788ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f0e07730088b7656c244030f360406758f788ea", "html_url": "https://github.com/rust-lang/rust/commit/2f0e07730088b7656c244030f360406758f788ea"}], "stats": {"total": 1219, "additions": 22, "deletions": 1197}, "files": [{"sha": "da25969bf1177ea3ec226bcb9775a119d4a000f8", "filename": "src/librustc_mir/hair/cx/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fcx%2Fexpr.rs?ref=d98a2b90b2043e8b25701841c10e4598a3da2845", "patch": "@@ -18,7 +18,6 @@ use rustc::middle::const_val::ConstVal;\n use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n use rustc::ty::{self, AdtKind, VariantDef, Ty};\n use rustc::ty::adjustment::{Adjustment, Adjust, AutoBorrow, AutoBorrowMutability};\n-use rustc::mir::interpret::{Value, PrimVal};\n use rustc::ty::cast::CastKind as TyCastKind;\n use rustc::hir;\n use rustc::hir::def_id::LocalDefId;"}, {"sha": "42e095a0b5bebc4f6087c522b7d15eb271366405", "filename": "src/librustc_mir/hair/pattern/mod.rs", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fmod.rs?ref=d98a2b90b2043e8b25701841c10e4598a3da2845", "patch": "@@ -42,7 +42,6 @@ pub enum PatternError {\n     StaticInPattern(Span),\n     FloatBug,\n     NonConstPath(Span),\n-    AssociatedConstInPattern(Span),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -382,10 +381,24 @@ impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n                                 \"lower range bound must be less than upper\",\n                             ),\n                             (RangeEnd::Included, Ordering::Greater) => {\n-                                struct_span_err!(self.tcx.sess, lo_expr.span, E0030,\n-                                    \"lower range bound must be less than or equal to upper\")\n-                                    .span_label(lo_expr.span, \"lower bound larger than upper bound\")\n-                                    .emit();\n+                                let mut err = struct_span_err!(\n+                                    self.tcx.sess,\n+                                    lo_expr.span,\n+                                    E0030,\n+                                    \"lower range bound must be less than or equal to upper\"\n+                                );\n+                                err.span_label(\n+                                    lo_expr.span,\n+                                    \"lower bound larger than upper bound\",\n+                                );\n+                                if self.tcx.sess.teach(&err.get_code().unwrap()) {\n+                                    err.note(\"When matching against a range, the compiler \\\n+                                              verifies that the range is non-empty. Range \\\n+                                              patterns include both end-points, so this is \\\n+                                              equivalent to requiring the start of the range \\\n+                                              to be less than or equal to the end of the range.\");\n+                                }\n+                                err.emit();\n                             },\n                             (RangeEnd::Included, _) => {}\n                         }"}, {"sha": "2678984092a52b9cfe4e0a6f03964e29147dcee7", "filename": "src/librustc_mir/hair/pattern/pattern.rs", "status": "removed", "additions": 0, "deletions": 1187, "changes": 1187, "blob_url": "https://github.com/rust-lang/rust/blob/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f0e07730088b7656c244030f360406758f788ea/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fpattern.rs?ref=2f0e07730088b7656c244030f360406758f788ea", "patch": "@@ -1,1187 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use interpret::{const_val_field, const_discr};\n-\n-use rustc::middle::const_val::ConstVal;\n-use rustc::mir::{Field, BorrowKind, Mutability};\n-use rustc::mir::interpret::{GlobalId, Value, PrimVal};\n-use rustc::ty::{self, TyCtxt, AdtDef, Ty, Region};\n-use rustc::ty::subst::{Substs, Kind};\n-use rustc::hir::{self, PatKind, RangeEnd};\n-use rustc::hir::def::{Def, CtorKind};\n-use rustc::hir::pat_util::EnumerateAndAdjustIterator;\n-\n-use rustc_data_structures::indexed_vec::Idx;\n-use rustc_const_math::ConstFloat;\n-\n-use std::cmp::Ordering;\n-use std::fmt;\n-use syntax::ast;\n-use syntax::ptr::P;\n-use syntax_pos::Span;\n-\n-#[derive(Clone, Debug)]\n-pub enum PatternError {\n-    AssociatedConstInPattern(Span),\n-    StaticInPattern(Span),\n-    FloatBug,\n-    NonConstPath(Span),\n-}\n-\n-#[derive(Copy, Clone, Debug)]\n-pub enum BindingMode<'tcx> {\n-    ByValue,\n-    ByRef(Region<'tcx>, BorrowKind),\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct FieldPattern<'tcx> {\n-    pub field: Field,\n-    pub pattern: Pattern<'tcx>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub struct Pattern<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    pub span: Span,\n-    pub kind: Box<PatternKind<'tcx>>,\n-}\n-\n-#[derive(Clone, Debug)]\n-pub enum PatternKind<'tcx> {\n-    Wild,\n-\n-    /// x, ref x, x @ P, etc\n-    Binding {\n-        mutability: Mutability,\n-        name: ast::Name,\n-        mode: BindingMode<'tcx>,\n-        var: ast::NodeId,\n-        ty: Ty<'tcx>,\n-        subpattern: Option<Pattern<'tcx>>,\n-    },\n-\n-    /// Foo(...) or Foo{...} or Foo, where `Foo` is a variant name from an adt with >1 variants\n-    Variant {\n-        adt_def: &'tcx AdtDef,\n-        substs: &'tcx Substs<'tcx>,\n-        variant_index: usize,\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n-    },\n-\n-    /// (...), Foo(...), Foo{...}, or Foo, where `Foo` is a variant name from an adt with 1 variant\n-    Leaf {\n-        subpatterns: Vec<FieldPattern<'tcx>>,\n-    },\n-\n-    /// box P, &P, &mut P, etc\n-    Deref {\n-        subpattern: Pattern<'tcx>,\n-    },\n-\n-    Constant {\n-        value: &'tcx ty::Const<'tcx>,\n-    },\n-\n-    Range {\n-        lo: &'tcx ty::Const<'tcx>,\n-        hi: &'tcx ty::Const<'tcx>,\n-        end: RangeEnd,\n-    },\n-\n-    /// matches against a slice, checking the length and extracting elements.\n-    /// irrefutable when there is a slice pattern and both `prefix` and `suffix` are empty.\n-    /// e.g. `&[ref xs..]`.\n-    Slice {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n-    },\n-\n-    /// fixed match against an array, irrefutable\n-    Array {\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>,\n-    },\n-}\n-\n-fn print_const_val(value: &ty::Const, f: &mut fmt::Formatter) -> fmt::Result {\n-    match value.val {\n-        ConstVal::Value(v) => print_miri_value(v, value.ty, f),\n-        ConstVal::Unevaluated(..) => bug!(\"{:?} not printable in a pattern\", value)\n-    }\n-}\n-\n-fn print_miri_value(value: Value, ty: Ty, f: &mut fmt::Formatter) -> fmt::Result {\n-    use rustc::ty::TypeVariants::*;\n-    match (value, &ty.sty) {\n-        (Value::ByVal(PrimVal::Bytes(0)), &TyBool) => write!(f, \"false\"),\n-        (Value::ByVal(PrimVal::Bytes(1)), &TyBool) => write!(f, \"true\"),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyUint(..)) => write!(f, \"{:?}\", n),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyInt(..)) => write!(f, \"{:?}\", n as i128),\n-        (Value::ByVal(PrimVal::Bytes(n)), &TyChar) =>\n-            write!(f, \"{:?}\", ::std::char::from_u32(n as u32).unwrap()),\n-        _ => bug!(\"{:?}: {} not printable in a pattern\", value, ty),\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for Pattern<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self.kind {\n-            PatternKind::Wild => write!(f, \"_\"),\n-            PatternKind::Binding { mutability, name, mode, ref subpattern, .. } => {\n-                let is_mut = match mode {\n-                    BindingMode::ByValue => mutability == Mutability::Mut,\n-                    BindingMode::ByRef(_, bk) => {\n-                        write!(f, \"ref \")?;\n-                        match bk { BorrowKind::Mut { .. } => true, _ => false }\n-                    }\n-                };\n-                if is_mut {\n-                    write!(f, \"mut \")?;\n-                }\n-                write!(f, \"{}\", name)?;\n-                if let Some(ref subpattern) = *subpattern {\n-                    write!(f, \" @ {}\", subpattern)?;\n-                }\n-                Ok(())\n-            }\n-            PatternKind::Variant { ref subpatterns, .. } |\n-            PatternKind::Leaf { ref subpatterns } => {\n-                let variant = match *self.kind {\n-                    PatternKind::Variant { adt_def, variant_index, .. } => {\n-                        Some(&adt_def.variants[variant_index])\n-                    }\n-                    _ => if let ty::TyAdt(adt, _) = self.ty.sty {\n-                        if !adt.is_enum() {\n-                            Some(&adt.variants[0])\n-                        } else {\n-                            None\n-                        }\n-                    } else {\n-                        None\n-                    }\n-                };\n-\n-                let mut first = true;\n-                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n-\n-                if let Some(variant) = variant {\n-                    write!(f, \"{}\", variant.name)?;\n-\n-                    // Only for TyAdt we can have `S {...}`,\n-                    // which we handle separately here.\n-                    if variant.ctor_kind == CtorKind::Fictive {\n-                        write!(f, \" {{ \")?;\n-\n-                        let mut printed = 0;\n-                        for p in subpatterns {\n-                            if let PatternKind::Wild = *p.pattern.kind {\n-                                continue;\n-                            }\n-                            let name = variant.fields[p.field.index()].name;\n-                            write!(f, \"{}{}: {}\", start_or_continue(), name, p.pattern)?;\n-                            printed += 1;\n-                        }\n-\n-                        if printed < variant.fields.len() {\n-                            write!(f, \"{}..\", start_or_continue())?;\n-                        }\n-\n-                        return write!(f, \" }}\");\n-                    }\n-                }\n-\n-                let num_fields = variant.map_or(subpatterns.len(), |v| v.fields.len());\n-                if num_fields != 0 || variant.is_none() {\n-                    write!(f, \"(\")?;\n-                    for i in 0..num_fields {\n-                        write!(f, \"{}\", start_or_continue())?;\n-\n-                        // Common case: the field is where we expect it.\n-                        if let Some(p) = subpatterns.get(i) {\n-                            if p.field.index() == i {\n-                                write!(f, \"{}\", p.pattern)?;\n-                                continue;\n-                            }\n-                        }\n-\n-                        // Otherwise, we have to go looking for it.\n-                        if let Some(p) = subpatterns.iter().find(|p| p.field.index() == i) {\n-                            write!(f, \"{}\", p.pattern)?;\n-                        } else {\n-                            write!(f, \"_\")?;\n-                        }\n-                    }\n-                    write!(f, \")\")?;\n-                }\n-\n-                Ok(())\n-            }\n-            PatternKind::Deref { ref subpattern } => {\n-                match self.ty.sty {\n-                    ty::TyAdt(def, _) if def.is_box() => write!(f, \"box \")?,\n-                    ty::TyRef(_, mt) => {\n-                        write!(f, \"&\")?;\n-                        if mt.mutbl == hir::MutMutable {\n-                            write!(f, \"mut \")?;\n-                        }\n-                    }\n-                    _ => bug!(\"{} is a bad Deref pattern type\", self.ty)\n-                }\n-                write!(f, \"{}\", subpattern)\n-            }\n-            PatternKind::Constant { value } => {\n-                print_const_val(value, f)\n-            }\n-            PatternKind::Range { lo, hi, end } => {\n-                print_const_val(lo, f)?;\n-                match end {\n-                    RangeEnd::Included => write!(f, \"...\")?,\n-                    RangeEnd::Excluded => write!(f, \"..\")?,\n-                }\n-                print_const_val(hi, f)\n-            }\n-            PatternKind::Slice { ref prefix, ref slice, ref suffix } |\n-            PatternKind::Array { ref prefix, ref slice, ref suffix } => {\n-                let mut first = true;\n-                let mut start_or_continue = || if first { first = false; \"\" } else { \", \" };\n-                write!(f, \"[\")?;\n-                for p in prefix {\n-                    write!(f, \"{}{}\", start_or_continue(), p)?;\n-                }\n-                if let Some(ref slice) = *slice {\n-                    write!(f, \"{}\", start_or_continue())?;\n-                    match *slice.kind {\n-                        PatternKind::Wild => {}\n-                        _ => write!(f, \"{}\", slice)?\n-                    }\n-                    write!(f, \"..\")?;\n-                }\n-                for p in suffix {\n-                    write!(f, \"{}{}\", start_or_continue(), p)?;\n-                }\n-                write!(f, \"]\")\n-            }\n-        }\n-    }\n-}\n-\n-pub struct PatternContext<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub param_env: ty::ParamEnv<'tcx>,\n-    pub tables: &'a ty::TypeckTables<'tcx>,\n-    pub substs: &'tcx Substs<'tcx>,\n-    pub errors: Vec<PatternError>,\n-}\n-\n-impl<'a, 'tcx> Pattern<'tcx> {\n-    pub fn from_hir(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                    param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n-                    tables: &'a ty::TypeckTables<'tcx>,\n-                    pat: &'tcx hir::Pat) -> Self {\n-        let mut pcx = PatternContext::new(tcx, param_env_and_substs, tables);\n-        let result = pcx.lower_pattern(pat);\n-        if !pcx.errors.is_empty() {\n-            let msg = format!(\"encountered errors lowering pattern: {:?}\", pcx.errors);\n-            tcx.sess.delay_span_bug(pat.span, &msg);\n-        }\n-        debug!(\"Pattern::from_hir({:?}) = {:?}\", pat, result);\n-        result\n-    }\n-}\n-\n-impl<'a, 'tcx> PatternContext<'a, 'tcx> {\n-    pub fn new(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-               param_env_and_substs: ty::ParamEnvAnd<'tcx, &'tcx Substs<'tcx>>,\n-               tables: &'a ty::TypeckTables<'tcx>) -> Self {\n-        PatternContext {\n-            tcx,\n-            param_env: param_env_and_substs.param_env,\n-            tables,\n-            substs: param_env_and_substs.value,\n-            errors: vec![]\n-        }\n-    }\n-\n-    pub fn lower_pattern(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n-        // When implicit dereferences have been inserted in this pattern, the unadjusted lowered\n-        // pattern has the type that results *after* dereferencing. For example, in this code:\n-        //\n-        // ```\n-        // match &&Some(0i32) {\n-        //     Some(n) => { ... },\n-        //     _ => { ... },\n-        // }\n-        // ```\n-        //\n-        // the type assigned to `Some(n)` in `unadjusted_pat` would be `Option<i32>` (this is\n-        // determined in rustc_typeck::check::match). The adjustments would be\n-        //\n-        // `vec![&&Option<i32>, &Option<i32>]`.\n-        //\n-        // Applying the adjustments, we want to instead output `&&Some(n)` (as a HAIR pattern). So\n-        // we wrap the unadjusted pattern in `PatternKind::Deref` repeatedly, consuming the\n-        // adjustments in *reverse order* (last-in-first-out, so that the last `Deref` inserted\n-        // gets the least-dereferenced type).\n-        let unadjusted_pat = self.lower_pattern_unadjusted(pat);\n-        self.tables\n-            .pat_adjustments()\n-            .get(pat.hir_id)\n-            .unwrap_or(&vec![])\n-            .iter()\n-            .rev()\n-            .fold(unadjusted_pat, |pat, ref_ty| {\n-                    debug!(\"{:?}: wrapping pattern with type {:?}\", pat, ref_ty);\n-                    Pattern {\n-                        span: pat.span,\n-                        ty: ref_ty,\n-                        kind: Box::new(PatternKind::Deref { subpattern: pat }),\n-                    }\n-                },\n-            )\n-    }\n-\n-    fn lower_pattern_unadjusted(&mut self, pat: &'tcx hir::Pat) -> Pattern<'tcx> {\n-        let mut ty = self.tables.node_id_to_type(pat.hir_id);\n-\n-        let kind = match pat.node {\n-            PatKind::Wild => PatternKind::Wild,\n-\n-            PatKind::Lit(ref value) => self.lower_lit(value),\n-\n-            PatKind::Range(ref lo_expr, ref hi_expr, end) => {\n-                match (self.lower_lit(lo_expr), self.lower_lit(hi_expr)) {\n-                    (PatternKind::Constant { value: lo },\n-                     PatternKind::Constant { value: hi }) => {\n-                        use std::cmp::Ordering;\n-                        match (end, compare_const_vals(&lo.val, &hi.val, ty).unwrap()) {\n-                            (RangeEnd::Excluded, Ordering::Less) => {},\n-                            (RangeEnd::Excluded, _) => span_err!(\n-                                self.tcx.sess,\n-                                lo_expr.span,\n-                                E0579,\n-                                \"lower range bound must be less than upper\",\n-                            ),\n-                            (RangeEnd::Included, Ordering::Greater) => {\n-                                struct_span_err!(self.tcx.sess, lo_expr.span, E0030,\n-                                    \"lower range bound must be less than or equal to upper\")\n-                                    .span_label(lo_expr.span, \"lower bound larger than upper bound\")\n-                                    .emit();\n-                            },\n-                            (RangeEnd::Included, _) => {}\n-                        }\n-                        PatternKind::Range { lo, hi, end }\n-                    }\n-                    _ => PatternKind::Wild\n-                }\n-            }\n-\n-            PatKind::Path(ref qpath) => {\n-                return self.lower_path(qpath, pat.hir_id, pat.span);\n-            }\n-\n-            PatKind::Ref(ref subpattern, _) |\n-            PatKind::Box(ref subpattern) => {\n-                PatternKind::Deref { subpattern: self.lower_pattern(subpattern) }\n-            }\n-\n-            PatKind::Slice(ref prefix, ref slice, ref suffix) => {\n-                let ty = self.tables.node_id_to_type(pat.hir_id);\n-                match ty.sty {\n-                    ty::TyRef(_, mt) =>\n-                        PatternKind::Deref {\n-                            subpattern: Pattern {\n-                                ty: mt.ty,\n-                                span: pat.span,\n-                                kind: Box::new(self.slice_or_array_pattern(\n-                                    pat.span, mt.ty, prefix, slice, suffix))\n-                            },\n-                        },\n-\n-                    ty::TySlice(..) |\n-                    ty::TyArray(..) =>\n-                        self.slice_or_array_pattern(pat.span, ty, prefix, slice, suffix),\n-\n-                    ref sty =>\n-                        span_bug!(\n-                            pat.span,\n-                            \"unexpanded type for vector pattern: {:?}\",\n-                            sty),\n-                }\n-            }\n-\n-            PatKind::Tuple(ref subpatterns, ddpos) => {\n-                let ty = self.tables.node_id_to_type(pat.hir_id);\n-                match ty.sty {\n-                    ty::TyTuple(ref tys, _) => {\n-                        let subpatterns =\n-                            subpatterns.iter()\n-                                       .enumerate_and_adjust(tys.len(), ddpos)\n-                                       .map(|(i, subpattern)| FieldPattern {\n-                                            field: Field::new(i),\n-                                            pattern: self.lower_pattern(subpattern)\n-                                       })\n-                                       .collect();\n-\n-                        PatternKind::Leaf { subpatterns: subpatterns }\n-                    }\n-\n-                    ref sty => span_bug!(pat.span, \"unexpected type for tuple pattern: {:?}\", sty),\n-                }\n-            }\n-\n-            PatKind::Binding(_, id, ref ident, ref sub) => {\n-                let var_ty = self.tables.node_id_to_type(pat.hir_id);\n-                let region = match var_ty.sty {\n-                    ty::TyRef(r, _) => Some(r),\n-                    _ => None,\n-                };\n-                let bm = *self.tables.pat_binding_modes().get(pat.hir_id)\n-                                                         .expect(\"missing binding mode\");\n-                let (mutability, mode) = match bm {\n-                    ty::BindByValue(hir::MutMutable) =>\n-                        (Mutability::Mut, BindingMode::ByValue),\n-                    ty::BindByValue(hir::MutImmutable) =>\n-                        (Mutability::Not, BindingMode::ByValue),\n-                    ty::BindByReference(hir::MutMutable) =>\n-                        (Mutability::Not, BindingMode::ByRef(\n-                            region.unwrap(), BorrowKind::Mut { allow_two_phase_borrow: false })),\n-                    ty::BindByReference(hir::MutImmutable) =>\n-                        (Mutability::Not, BindingMode::ByRef(\n-                            region.unwrap(), BorrowKind::Shared)),\n-                };\n-\n-                // A ref x pattern is the same node used for x, and as such it has\n-                // x's type, which is &T, where we want T (the type being matched).\n-                if let ty::BindByReference(_) = bm {\n-                    if let ty::TyRef(_, mt) = ty.sty {\n-                        ty = mt.ty;\n-                    } else {\n-                        bug!(\"`ref {}` has wrong type {}\", ident.node, ty);\n-                    }\n-                }\n-\n-                PatternKind::Binding {\n-                    mutability,\n-                    mode,\n-                    name: ident.node,\n-                    var: id,\n-                    ty: var_ty,\n-                    subpattern: self.lower_opt_pattern(sub),\n-                }\n-            }\n-\n-            PatKind::TupleStruct(ref qpath, ref subpatterns, ddpos) => {\n-                let def = self.tables.qpath_def(qpath, pat.hir_id);\n-                let adt_def = match ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    _ => span_bug!(pat.span, \"tuple struct pattern not applied to an ADT\"),\n-                };\n-                let variant_def = adt_def.variant_of_def(def);\n-\n-                let subpatterns =\n-                        subpatterns.iter()\n-                                   .enumerate_and_adjust(variant_def.fields.len(), ddpos)\n-                                   .map(|(i, field)| FieldPattern {\n-                                       field: Field::new(i),\n-                                       pattern: self.lower_pattern(field),\n-                                   })\n-                                   .collect();\n-                self.lower_variant_or_leaf(def, pat.span, ty, subpatterns)\n-            }\n-\n-            PatKind::Struct(ref qpath, ref fields, _) => {\n-                let def = self.tables.qpath_def(qpath, pat.hir_id);\n-                let adt_def = match ty.sty {\n-                    ty::TyAdt(adt_def, _) => adt_def,\n-                    _ => {\n-                        span_bug!(\n-                            pat.span,\n-                            \"struct pattern not applied to an ADT\");\n-                    }\n-                };\n-                let variant_def = adt_def.variant_of_def(def);\n-\n-                let subpatterns =\n-                    fields.iter()\n-                          .map(|field| {\n-                              let index = variant_def.index_of_field_named(field.node.name);\n-                              let index = index.unwrap_or_else(|| {\n-                                  span_bug!(\n-                                      pat.span,\n-                                      \"no field with name {:?}\",\n-                                      field.node.name);\n-                              });\n-                              FieldPattern {\n-                                  field: Field::new(index),\n-                                  pattern: self.lower_pattern(&field.node.pat),\n-                              }\n-                          })\n-                          .collect();\n-\n-                self.lower_variant_or_leaf(def, pat.span, ty, subpatterns)\n-            }\n-        };\n-\n-        Pattern {\n-            span: pat.span,\n-            ty,\n-            kind: Box::new(kind),\n-        }\n-    }\n-\n-    fn lower_patterns(&mut self, pats: &'tcx [P<hir::Pat>]) -> Vec<Pattern<'tcx>> {\n-        pats.iter().map(|p| self.lower_pattern(p)).collect()\n-    }\n-\n-    fn lower_opt_pattern(&mut self, pat: &'tcx Option<P<hir::Pat>>) -> Option<Pattern<'tcx>>\n-    {\n-        pat.as_ref().map(|p| self.lower_pattern(p))\n-    }\n-\n-    fn flatten_nested_slice_patterns(\n-        &mut self,\n-        prefix: Vec<Pattern<'tcx>>,\n-        slice: Option<Pattern<'tcx>>,\n-        suffix: Vec<Pattern<'tcx>>)\n-        -> (Vec<Pattern<'tcx>>, Option<Pattern<'tcx>>, Vec<Pattern<'tcx>>)\n-    {\n-        let orig_slice = match slice {\n-            Some(orig_slice) => orig_slice,\n-            None => return (prefix, slice, suffix)\n-        };\n-        let orig_prefix = prefix;\n-        let orig_suffix = suffix;\n-\n-        // dance because of intentional borrow-checker stupidity.\n-        let kind = *orig_slice.kind;\n-        match kind {\n-            PatternKind::Slice { prefix, slice, mut suffix } |\n-            PatternKind::Array { prefix, slice, mut suffix } => {\n-                let mut orig_prefix = orig_prefix;\n-\n-                orig_prefix.extend(prefix);\n-                suffix.extend(orig_suffix);\n-\n-                (orig_prefix, slice, suffix)\n-            }\n-            _ => {\n-                (orig_prefix, Some(Pattern {\n-                    kind: box kind, ..orig_slice\n-                }), orig_suffix)\n-            }\n-        }\n-    }\n-\n-    fn slice_or_array_pattern(\n-        &mut self,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-        prefix: &'tcx [P<hir::Pat>],\n-        slice: &'tcx Option<P<hir::Pat>>,\n-        suffix: &'tcx [P<hir::Pat>])\n-        -> PatternKind<'tcx>\n-    {\n-        let prefix = self.lower_patterns(prefix);\n-        let slice = self.lower_opt_pattern(slice);\n-        let suffix = self.lower_patterns(suffix);\n-        let (prefix, slice, suffix) =\n-            self.flatten_nested_slice_patterns(prefix, slice, suffix);\n-\n-        match ty.sty {\n-            ty::TySlice(..) => {\n-                // matching a slice or fixed-length array\n-                PatternKind::Slice { prefix: prefix, slice: slice, suffix: suffix }\n-            }\n-\n-            ty::TyArray(_, len) => {\n-                // fixed-length array\n-                let len = len.val.unwrap_u64();\n-                assert!(len >= prefix.len() as u64 + suffix.len() as u64);\n-                PatternKind::Array { prefix: prefix, slice: slice, suffix: suffix }\n-            }\n-\n-            _ => {\n-                span_bug!(span, \"bad slice pattern type {:?}\", ty);\n-            }\n-        }\n-    }\n-\n-    fn lower_variant_or_leaf(\n-        &mut self,\n-        def: Def,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-        subpatterns: Vec<FieldPattern<'tcx>>)\n-        -> PatternKind<'tcx>\n-    {\n-        match def {\n-            Def::Variant(variant_id) | Def::VariantCtor(variant_id, ..) => {\n-                let enum_id = self.tcx.parent_def_id(variant_id).unwrap();\n-                let adt_def = self.tcx.adt_def(enum_id);\n-                if adt_def.is_enum() {\n-                    let substs = match ty.sty {\n-                        ty::TyAdt(_, substs) |\n-                        ty::TyFnDef(_, substs) => substs,\n-                        _ => bug!(\"inappropriate type for def: {:?}\", ty.sty),\n-                    };\n-                    PatternKind::Variant {\n-                        adt_def,\n-                        substs,\n-                        variant_index: adt_def.variant_index_with_id(variant_id),\n-                        subpatterns,\n-                    }\n-                } else {\n-                    PatternKind::Leaf { subpatterns: subpatterns }\n-                }\n-            }\n-\n-            Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-            Def::TyAlias(..) | Def::AssociatedTy(..) | Def::SelfTy(..) => {\n-                PatternKind::Leaf { subpatterns: subpatterns }\n-            }\n-\n-            _ => {\n-                self.errors.push(PatternError::NonConstPath(span));\n-                PatternKind::Wild\n-            }\n-        }\n-    }\n-\n-    fn lower_path(&mut self,\n-                  qpath: &hir::QPath,\n-                  id: hir::HirId,\n-                  span: Span)\n-                  -> Pattern<'tcx> {\n-        let ty = self.tables.node_id_to_type(id);\n-        let def = self.tables.qpath_def(qpath, id);\n-        let is_associated_const = match def {\n-            Def::AssociatedConst(_) => true,\n-            _ => false,\n-        };\n-        let kind = match def {\n-            Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n-                let substs = self.tables.node_substs(id);\n-                match ty::Instance::resolve(\n-                    self.tcx,\n-                    self.param_env,\n-                    def_id,\n-                    substs,\n-                ) {\n-                    Some(instance) => {\n-                        let cid = GlobalId {\n-                            instance,\n-                            promoted: None,\n-                        };\n-                        match self.tcx.at(span).const_eval(self.param_env.and(cid)) {\n-                            Ok(value) => {\n-                                return self.const_to_pat(instance, value, id, span)\n-                            },\n-                            Err(err) => {\n-                                err.report(self.tcx, span, \"pattern\");\n-                                PatternKind::Wild\n-                            },\n-                        }\n-                    },\n-                    None => {\n-                        self.errors.push(if is_associated_const {\n-                            PatternError::AssociatedConstInPattern(span)\n-                        } else {\n-                            PatternError::StaticInPattern(span)\n-                        });\n-                        PatternKind::Wild\n-                    },\n-                }\n-            }\n-            _ => self.lower_variant_or_leaf(def, span, ty, vec![]),\n-        };\n-\n-        Pattern {\n-            span,\n-            ty,\n-            kind: Box::new(kind),\n-        }\n-    }\n-\n-    fn lower_lit(&mut self, expr: &'tcx hir::Expr) -> PatternKind<'tcx> {\n-        match expr.node {\n-            hir::ExprLit(ref lit) => {\n-                let ty = self.tables.expr_ty(expr);\n-                match lit_to_const(&lit.node, self.tcx, ty, false) {\n-                    Ok(val) => {\n-                        let instance = ty::Instance::new(\n-                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n-                            self.substs,\n-                        );\n-                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n-                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n-                    },\n-                    Err(()) => {\n-                        self.errors.push(PatternError::FloatBug);\n-                        PatternKind::Wild\n-                    },\n-                }\n-            },\n-            hir::ExprPath(ref qpath) => *self.lower_path(qpath, expr.hir_id, expr.span).kind,\n-            hir::ExprUnary(hir::UnNeg, ref expr) => {\n-                let ty = self.tables.expr_ty(expr);\n-                let lit = match expr.node {\n-                    hir::ExprLit(ref lit) => lit,\n-                    _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n-                };\n-                match lit_to_const(&lit.node, self.tcx, ty, true) {\n-                    Ok(val) => {\n-                        let instance = ty::Instance::new(\n-                            self.tables.local_id_root.expect(\"literal outside any scope\"),\n-                            self.substs,\n-                        );\n-                        let cv = self.tcx.mk_const(ty::Const { val, ty });\n-                        *self.const_to_pat(instance, cv, expr.hir_id, lit.span).kind\n-                    },\n-                    Err(()) => {\n-                        self.errors.push(PatternError::FloatBug);\n-                        PatternKind::Wild\n-                    },\n-                }\n-            }\n-            _ => span_bug!(expr.span, \"not a literal: {:?}\", expr),\n-        }\n-    }\n-\n-    fn const_to_pat(\n-        &self,\n-        instance: ty::Instance<'tcx>,\n-        cv: &'tcx ty::Const<'tcx>,\n-        id: hir::HirId,\n-        span: Span,\n-    ) -> Pattern<'tcx> {\n-        debug!(\"const_to_pat: cv={:#?}\", cv);\n-        let kind = match cv.ty.sty {\n-            ty::TyFloat(_) => {\n-                let id = self.tcx.hir.hir_to_node_id(id);\n-                self.tcx.lint_node(\n-                    ::rustc::lint::builtin::ILLEGAL_FLOATING_POINT_LITERAL_PATTERN,\n-                    id,\n-                    span,\n-                    \"floating-point types cannot be used in patterns\",\n-                );\n-                PatternKind::Constant {\n-                    value: cv,\n-                }\n-            },\n-            ty::TyAdt(adt_def, _) if adt_def.is_union() => {\n-                // Matching on union fields is unsafe, we can't hide it in constants\n-                self.tcx.sess.span_err(span, \"cannot use unions in constant patterns\");\n-                PatternKind::Wild\n-            }\n-            ty::TyAdt(adt_def, _) if !self.tcx.has_attr(adt_def.did, \"structural_match\") => {\n-                let msg = format!(\"to use a constant of type `{}` in a pattern, \\\n-                                    `{}` must be annotated with `#[derive(PartialEq, Eq)]`\",\n-                                    self.tcx.item_path_str(adt_def.did),\n-                                    self.tcx.item_path_str(adt_def.did));\n-                self.tcx.sess.span_err(span, &msg);\n-                PatternKind::Wild\n-            },\n-            ty::TyAdt(adt_def, substs) if adt_def.is_enum() => {\n-                match cv.val {\n-                    ConstVal::Value(val) => {\n-                        let discr = const_discr(\n-                            self.tcx, self.param_env, instance, val, cv.ty\n-                        ).unwrap();\n-                        let variant_index = adt_def\n-                            .discriminants(self.tcx)\n-                            .position(|var| var.val == discr)\n-                            .unwrap();\n-                        PatternKind::Variant {\n-                            adt_def,\n-                            substs,\n-                            variant_index,\n-                            subpatterns: adt_def\n-                                .variants[variant_index]\n-                                .fields\n-                                .iter()\n-                                .enumerate()\n-                                .map(|(i, _)| {\n-                                let field = Field::new(i);\n-                                let val = match cv.val {\n-                                    ConstVal::Value(miri) => const_val_field(\n-                                        self.tcx, self.param_env, instance,\n-                                        Some(variant_index), field, miri, cv.ty,\n-                                    ).unwrap(),\n-                                    _ => bug!(\"{:#?} is not a valid tuple\", cv),\n-                                };\n-                                FieldPattern {\n-                                    field,\n-                                    pattern: self.const_to_pat(instance, val, id, span),\n-                                }\n-                            }).collect(),\n-                        }\n-                    },\n-                    _ => return Pattern {\n-                        span,\n-                        ty: cv.ty,\n-                        kind: Box::new(PatternKind::Constant {\n-                            value: cv,\n-                        }),\n-                    }\n-                }\n-            },\n-            ty::TyAdt(adt_def, _) => {\n-                let struct_var = adt_def.non_enum_variant();\n-                PatternKind::Leaf {\n-                    subpatterns: struct_var.fields.iter().enumerate().map(|(i, _)| {\n-                        let field = Field::new(i);\n-                        let val = match cv.val {\n-                            ConstVal::Value(miri) => const_val_field(\n-                                self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n-                            ).unwrap(),\n-                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n-                        };\n-                        FieldPattern {\n-                            field,\n-                            pattern: self.const_to_pat(instance, val, id, span),\n-                        }\n-                    }).collect()\n-                }\n-            }\n-            ty::TyTuple(fields, _) => {\n-                PatternKind::Leaf {\n-                    subpatterns: (0..fields.len()).map(|i| {\n-                        let field = Field::new(i);\n-                        let val = match cv.val {\n-                            ConstVal::Value(miri) => const_val_field(\n-                                self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n-                            ).unwrap(),\n-                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n-                        };\n-                        FieldPattern {\n-                            field,\n-                            pattern: self.const_to_pat(instance, val, id, span),\n-                        }\n-                    }).collect()\n-                }\n-            }\n-            ty::TyArray(_, n) => {\n-                PatternKind::Array {\n-                    prefix: (0..n.val.unwrap_u64()).map(|i| {\n-                        let i = i as usize;\n-                        let field = Field::new(i);\n-                        let val = match cv.val {\n-                            ConstVal::Value(miri) => const_val_field(\n-                                self.tcx, self.param_env, instance, None, field, miri, cv.ty,\n-                            ).unwrap(),\n-                            _ => bug!(\"{:#?} is not a valid tuple\", cv),\n-                        };\n-                        self.const_to_pat(instance, val, id, span)\n-                    }).collect(),\n-                    slice: None,\n-                    suffix: Vec::new(),\n-                }\n-            }\n-            _ => {\n-                PatternKind::Constant {\n-                    value: cv,\n-                }\n-            },\n-        };\n-\n-        Pattern {\n-            span,\n-            ty: cv.ty,\n-            kind: Box::new(kind),\n-        }\n-    }\n-}\n-\n-pub trait PatternFoldable<'tcx> : Sized {\n-    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        self.super_fold_with(folder)\n-    }\n-\n-    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self;\n-}\n-\n-pub trait PatternFolder<'tcx> : Sized {\n-    fn fold_pattern(&mut self, pattern: &Pattern<'tcx>) -> Pattern<'tcx> {\n-        pattern.super_fold_with(self)\n-    }\n-\n-    fn fold_pattern_kind(&mut self, kind: &PatternKind<'tcx>) -> PatternKind<'tcx> {\n-        kind.super_fold_with(self)\n-    }\n-}\n-\n-\n-impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Box<T> {\n-    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let content: T = (**self).fold_with(folder);\n-        box content\n-    }\n-}\n-\n-impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Vec<T> {\n-    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        self.iter().map(|t| t.fold_with(folder)).collect()\n-    }\n-}\n-\n-impl<'tcx, T: PatternFoldable<'tcx>> PatternFoldable<'tcx> for Option<T> {\n-    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self{\n-        self.as_ref().map(|t| t.fold_with(folder))\n-    }\n-}\n-\n-macro_rules! CloneImpls {\n-    (<$lt_tcx:tt> $($ty:ty),+) => {\n-        $(\n-            impl<$lt_tcx> PatternFoldable<$lt_tcx> for $ty {\n-                fn super_fold_with<F: PatternFolder<$lt_tcx>>(&self, _: &mut F) -> Self {\n-                    Clone::clone(self)\n-                }\n-            }\n-        )+\n-    }\n-}\n-\n-CloneImpls!{ <'tcx>\n-    Span, Field, Mutability, ast::Name, ast::NodeId, usize, &'tcx ty::Const<'tcx>,\n-    Region<'tcx>, Ty<'tcx>, BindingMode<'tcx>, &'tcx AdtDef,\n-    &'tcx Substs<'tcx>, &'tcx Kind<'tcx>\n-}\n-\n-impl<'tcx> PatternFoldable<'tcx> for FieldPattern<'tcx> {\n-    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        FieldPattern {\n-            field: self.field.fold_with(folder),\n-            pattern: self.pattern.fold_with(folder)\n-        }\n-    }\n-}\n-\n-impl<'tcx> PatternFoldable<'tcx> for Pattern<'tcx> {\n-    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_pattern(self)\n-    }\n-\n-    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Pattern {\n-            ty: self.ty.fold_with(folder),\n-            span: self.span.fold_with(folder),\n-            kind: self.kind.fold_with(folder)\n-        }\n-    }\n-}\n-\n-impl<'tcx> PatternFoldable<'tcx> for PatternKind<'tcx> {\n-    fn fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        folder.fold_pattern_kind(self)\n-    }\n-\n-    fn super_fold_with<F: PatternFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        match *self {\n-            PatternKind::Wild => PatternKind::Wild,\n-            PatternKind::Binding {\n-                mutability,\n-                name,\n-                mode,\n-                var,\n-                ty,\n-                ref subpattern,\n-            } => PatternKind::Binding {\n-                mutability: mutability.fold_with(folder),\n-                name: name.fold_with(folder),\n-                mode: mode.fold_with(folder),\n-                var: var.fold_with(folder),\n-                ty: ty.fold_with(folder),\n-                subpattern: subpattern.fold_with(folder),\n-            },\n-            PatternKind::Variant {\n-                adt_def,\n-                substs,\n-                variant_index,\n-                ref subpatterns,\n-            } => PatternKind::Variant {\n-                adt_def: adt_def.fold_with(folder),\n-                substs: substs.fold_with(folder),\n-                variant_index: variant_index.fold_with(folder),\n-                subpatterns: subpatterns.fold_with(folder)\n-            },\n-            PatternKind::Leaf {\n-                ref subpatterns,\n-            } => PatternKind::Leaf {\n-                subpatterns: subpatterns.fold_with(folder),\n-            },\n-            PatternKind::Deref {\n-                ref subpattern,\n-            } => PatternKind::Deref {\n-                subpattern: subpattern.fold_with(folder),\n-            },\n-            PatternKind::Constant {\n-                value\n-            } => PatternKind::Constant {\n-                value: value.fold_with(folder)\n-            },\n-            PatternKind::Range {\n-                lo,\n-                hi,\n-                end,\n-            } => PatternKind::Range {\n-                lo: lo.fold_with(folder),\n-                hi: hi.fold_with(folder),\n-                end,\n-            },\n-            PatternKind::Slice {\n-                ref prefix,\n-                ref slice,\n-                ref suffix,\n-            } => PatternKind::Slice {\n-                prefix: prefix.fold_with(folder),\n-                slice: slice.fold_with(folder),\n-                suffix: suffix.fold_with(folder)\n-            },\n-            PatternKind::Array {\n-                ref prefix,\n-                ref slice,\n-                ref suffix\n-            } => PatternKind::Array {\n-                prefix: prefix.fold_with(folder),\n-                slice: slice.fold_with(folder),\n-                suffix: suffix.fold_with(folder)\n-            },\n-        }\n-    }\n-}\n-\n-pub fn compare_const_vals(a: &ConstVal, b: &ConstVal, ty: Ty) -> Option<Ordering> {\n-    use rustc_const_math::ConstFloat;\n-    trace!(\"compare_const_vals: {:?}, {:?}\", a, b);\n-    use rustc::mir::interpret::{Value, PrimVal};\n-    match (a, b) {\n-        (&ConstVal::Value(Value::ByVal(PrimVal::Bytes(a))),\n-         &ConstVal::Value(Value::ByVal(PrimVal::Bytes(b)))) => {\n-            match ty.sty {\n-                ty::TyFloat(ty) => {\n-                    let l = ConstFloat {\n-                        bits: a,\n-                        ty,\n-                    };\n-                    let r = ConstFloat {\n-                        bits: b,\n-                        ty,\n-                    };\n-                    // FIXME(oli-obk): report cmp errors?\n-                    l.try_cmp(r).ok()\n-                },\n-                ty::TyInt(_) => Some((a as i128).cmp(&(b as i128))),\n-                _ => Some(a.cmp(&b)),\n-            }\n-        },\n-        _ if a == b => Some(Ordering::Equal),\n-        _ => None,\n-    }\n-}\n-\n-fn lit_to_const<'a, 'tcx>(lit: &'tcx ast::LitKind,\n-                          tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                          ty: Ty<'tcx>,\n-                          neg: bool)\n-                          -> Result<ConstVal<'tcx>, ()> {\n-    use syntax::ast::*;\n-\n-    use rustc::mir::interpret::*;\n-    let lit = match *lit {\n-        LitKind::Str(ref s, _) => {\n-            let s = s.as_str();\n-            let id = tcx.allocate_cached(s.as_bytes());\n-            let ptr = MemoryPointer::new(id, 0);\n-            Value::ByValPair(\n-                PrimVal::Ptr(ptr),\n-                PrimVal::from_u128(s.len() as u128),\n-            )\n-        },\n-        LitKind::ByteStr(ref data) => {\n-            let id = tcx.allocate_cached(data);\n-            let ptr = MemoryPointer::new(id, 0);\n-            Value::ByVal(PrimVal::Ptr(ptr))\n-        },\n-        LitKind::Byte(n) => Value::ByVal(PrimVal::Bytes(n as u128)),\n-        LitKind::Int(n, _) => {\n-            enum Int {\n-                Signed(IntTy),\n-                Unsigned(UintTy),\n-            }\n-            let ty = match ty.sty {\n-                ty::TyInt(IntTy::Isize) => Int::Signed(tcx.sess.target.isize_ty),\n-                ty::TyInt(other) => Int::Signed(other),\n-                ty::TyUint(UintTy::Usize) => Int::Unsigned(tcx.sess.target.usize_ty),\n-                ty::TyUint(other) => Int::Unsigned(other),\n-                _ => bug!(),\n-            };\n-            let n = match ty {\n-                // FIXME(oli-obk): are these casts correct?\n-                Int::Signed(IntTy::I8) if neg =>\n-                    (n as i128 as i8).overflowing_neg().0 as i128 as u128,\n-                Int::Signed(IntTy::I16) if neg =>\n-                    (n as i128 as i16).overflowing_neg().0 as i128 as u128,\n-                Int::Signed(IntTy::I32) if neg =>\n-                    (n as i128 as i32).overflowing_neg().0 as i128 as u128,\n-                Int::Signed(IntTy::I64) if neg =>\n-                    (n as i128 as i64).overflowing_neg().0 as i128 as u128,\n-                Int::Signed(IntTy::I128) if neg =>\n-                    (n as i128).overflowing_neg().0 as u128,\n-                Int::Signed(IntTy::I8) => n as i128 as i8 as i128 as u128,\n-                Int::Signed(IntTy::I16) => n as i128 as i16 as i128 as u128,\n-                Int::Signed(IntTy::I32) => n as i128 as i32 as i128 as u128,\n-                Int::Signed(IntTy::I64) => n as i128 as i64 as i128 as u128,\n-                Int::Signed(IntTy::I128) => n,\n-                Int::Unsigned(UintTy::U8) => n as u8 as u128,\n-                Int::Unsigned(UintTy::U16) => n as u16 as u128,\n-                Int::Unsigned(UintTy::U32) => n as u32 as u128,\n-                Int::Unsigned(UintTy::U64) => n as u64 as u128,\n-                Int::Unsigned(UintTy::U128) => n,\n-                _ => bug!(),\n-            };\n-            Value::ByVal(PrimVal::Bytes(n))\n-        },\n-        LitKind::Float(n, fty) => {\n-            let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n-        }\n-        LitKind::FloatUnsuffixed(n) => {\n-            let fty = match ty.sty {\n-                ty::TyFloat(fty) => fty,\n-                _ => bug!()\n-            };\n-            let n = n.as_str();\n-            let mut f = parse_float(&n, fty)?;\n-            if neg {\n-                f = -f;\n-            }\n-            let bits = f.bits;\n-            Value::ByVal(PrimVal::Bytes(bits))\n-        }\n-        LitKind::Bool(b) => Value::ByVal(PrimVal::Bytes(b as u128)),\n-        LitKind::Char(c) => Value::ByVal(PrimVal::Bytes(c as u128)),\n-    };\n-    Ok(ConstVal::Value(lit))\n-}\n-\n-fn parse_float<'tcx>(num: &str, fty: ast::FloatTy)\n-                     -> Result<ConstFloat, ()> {\n-    ConstFloat::from_str(num, fty).map_err(|_| ())\n-}"}, {"sha": "983a44920ea6df355b1f80985e8aab9e83c8bbb2", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=d98a2b90b2043e8b25701841c10e4598a3da2845", "patch": "@@ -81,8 +81,8 @@ impl<'a, 'tcx> Visitor<'tcx> for UniformArrayMoveOutVisitor<'a, 'tcx> {\n                 } else {\n                     let place_ty = proj.base.ty(self.mir, self.tcx).to_ty(self.tcx);\n                     if let ty::TyArray(item_ty, const_size) = place_ty.sty {\n-                        if let Some(size) = const_size.val.to_const_int().and_then(|v| v.to_u64()) {\n-                            assert!(size <= (u32::max_value() as u64),\n+                        if let Some(size) = const_size.val.to_raw_bits() {\n+                            assert!(size <= (u32::max_value() as u128),\n                                     \"unform array move out doesn't supported\n                                      for array bigger then u32\");\n                             self.uniform(location, dst_place, proj, item_ty, size as u32);"}, {"sha": "53f178619975e9f9b2a1dd0208e1795e19ad27de", "filename": "src/test/mir-opt/match_false_edges.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.rs?ref=d98a2b90b2043e8b25701841c10e4598a3da2845", "patch": "@@ -239,7 +239,7 @@ fn main() {\n //     _11 = const guard2(move _12) -> [return: bb14, unwind: bb1];\n // }\n // bb14: { // end of guard2\n-//     StorageDead(_11);\n+//     StorageDead(_12);\n //     switchInt(move _11) -> [false: bb15, otherwise: bb3];\n // }\n // bb15: { // to pre_binding4"}, {"sha": "e49b992139e02a92324066dda62180f5a55fd606", "filename": "src/test/ui/error-codes/E0030-teach.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Ftest%2Fui%2Ferror-codes%2FE0030-teach.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d98a2b90b2043e8b25701841c10e4598a3da2845/src%2Ftest%2Fui%2Ferror-codes%2FE0030-teach.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0030-teach.rs?ref=d98a2b90b2043e8b25701841c10e4598a3da2845", "patch": "@@ -11,7 +11,7 @@\n // compile-flags: -Z teach\n \n fn main() {\n-    match 5u32 {\n+    match 5u32 { //~ERROR non-exhaustive patterns: `_` not covered\n         1000 ... 5 => {}\n         //~^ ERROR lower range bound must be less than or equal to upper\n     }"}]}