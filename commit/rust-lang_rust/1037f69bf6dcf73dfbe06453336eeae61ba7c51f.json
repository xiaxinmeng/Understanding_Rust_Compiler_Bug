{"sha": "1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMzdmNjliZjZkY2Y3M2RmYmUwNjQ1MzMzNmVlYWU2MWJhN2M1MWY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-01T15:33:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-10-01T15:33:09Z"}, "message": "Auto merge of #962 - christianpoveda:file-shim, r=oli-obk\n\nAdd shims for file handling\n\nThis adds the bare minimum to be able to do `File::open` and `File::read`. I also need some feedback about how to handle certain things", "tree": {"sha": "f3ff6beb756378efdc06efe3c0c95cc356861485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3ff6beb756378efdc06efe3c0c95cc356861485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "html_url": "https://github.com/rust-lang/rust/commit/1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07ac10277ea5ad42efbb914da5844e0ab08efbf4", "url": "https://api.github.com/repos/rust-lang/rust/commits/07ac10277ea5ad42efbb914da5844e0ab08efbf4", "html_url": "https://github.com/rust-lang/rust/commit/07ac10277ea5ad42efbb914da5844e0ab08efbf4"}, {"sha": "d0509d719c27d95b5d0f8379d66f13b99b60c42e", "url": "https://api.github.com/repos/rust-lang/rust/commits/d0509d719c27d95b5d0f8379d66f13b99b60c42e", "html_url": "https://github.com/rust-lang/rust/commit/d0509d719c27d95b5d0f8379d66f13b99b60c42e"}], "stats": {"total": 260, "additions": 260, "deletions": 0}, "files": [{"sha": "9f4e605b6c9416f0ee2401278feb32b2a1307ab1", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "patch": "@@ -34,6 +34,7 @@ pub use crate::shims::intrinsics::EvalContextExt as IntrinsicsEvalContextExt;\n pub use crate::shims::tls::{EvalContextExt as TlsEvalContextExt, TlsData};\n pub use crate::shims::dlsym::{Dlsym, EvalContextExt as DlsymEvalContextExt};\n pub use crate::shims::env::{EnvVars, EvalContextExt as EnvEvalContextExt};\n+pub use crate::shims::io::{FileHandler, EvalContextExt as FileEvalContextExt};\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::helpers::{EvalContextExt as HelpersEvalContextExt};"}, {"sha": "19be5b547ba846da42ed48bf0fec31da207b610e", "filename": "src/machine.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "patch": "@@ -96,6 +96,8 @@ pub struct Evaluator<'tcx> {\n     /// If enabled, the `env_vars` field is populated with the host env vars during initialization\n     /// and random number generation is delegated to the host.\n     pub(crate) communicate: bool,\n+\n+    pub(crate) file_handler: FileHandler,\n }\n \n impl<'tcx> Evaluator<'tcx> {\n@@ -110,6 +112,7 @@ impl<'tcx> Evaluator<'tcx> {\n             last_error: 0,\n             tls: TlsData::default(),\n             communicate,\n+            file_handler: Default::default(),\n         }\n     }\n }"}, {"sha": "b8609fd2ef092e3e4aece4ea13d2ad65265898dc", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "patch": "@@ -446,6 +446,26 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n             }\n \n+            \"open\" | \"open64\" => {\n+                let result = this.open(args[0], args[1])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"fcntl\" => {\n+                let result = this.fcntl(args[0], args[1], args.get(2).cloned())?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"close\" | \"close$NOCANCEL\" => {\n+                let result = this.close(args[0])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n+            \"read\" => {\n+                let result = this.read(args[0], args[1], args[2])?;\n+                this.write_scalar(Scalar::from_int(result, dest.layout.size), dest)?;\n+            }\n+\n             \"write\" => {\n                 let fd = this.read_scalar(args[0])?.to_i32()?;\n                 let buf = this.read_scalar(args[1])?.not_undef()?;\n@@ -929,6 +949,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n         return Ok(None);\n     }\n+\n+    fn eval_libc_i32(&mut self, name: &str) -> InterpResult<'tcx, i32> {\n+        self\n+            .eval_context_mut()\n+            .eval_path_scalar(&[\"libc\", name])?\n+            .ok_or_else(|| err_unsup_format!(\"Path libc::{} cannot be resolved.\", name).into())\n+            .and_then(|scalar| scalar.to_i32())\n+    }\n }\n \n // Shims the linux 'getrandom()' syscall."}, {"sha": "0d1adcce6526d139e713df28747212d39fc7ed70", "filename": "src/shims/io.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Fshims%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Fshims%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fio.rs?ref=1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "patch": "@@ -0,0 +1,213 @@\n+use std::collections::HashMap;\n+use std::fs::File;\n+use std::io::Read;\n+\n+use rustc::ty::layout::Size;\n+\n+use crate::stacked_borrows::Tag;\n+use crate::*;\n+\n+pub struct FileHandle {\n+    file: File,\n+    flag: i32,\n+}\n+\n+pub struct FileHandler {\n+    handles: HashMap<i32, FileHandle>,\n+    low: i32,\n+}\n+\n+impl Default for FileHandler {\n+    fn default() -> Self {\n+        FileHandler {\n+            handles: Default::default(),\n+            // 0, 1 and 2 are reserved for stdin, stdout and stderr\n+            low: 3,\n+        }\n+    }\n+}\n+\n+impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n+    fn open(\n+        &mut self,\n+        path_op: OpTy<'tcx, Tag>,\n+        flag_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        if !this.machine.communicate {\n+            throw_unsup_format!(\"`open` not available when isolation is enabled\")\n+        }\n+\n+        let flag = this.read_scalar(flag_op)?.to_i32()?;\n+\n+        if flag != this.eval_libc_i32(\"O_RDONLY\")? && flag != this.eval_libc_i32(\"O_CLOEXEC\")? {\n+            throw_unsup_format!(\"Unsupported flag {:#x}\", flag);\n+        }\n+\n+        let path_bytes = this\n+            .memory()\n+            .read_c_str(this.read_scalar(path_op)?.not_undef()?)?;\n+        let path = std::str::from_utf8(path_bytes)\n+            .map_err(|_| err_unsup_format!(\"{:?} is not a valid utf-8 string\", path_bytes))?;\n+        let fd = File::open(path).map(|file| {\n+            let mut fh = &mut this.machine.file_handler;\n+            fh.low += 1;\n+            fh.handles.insert(fh.low, FileHandle { file, flag });\n+            fh.low\n+        });\n+\n+        this.consume_result(fd)\n+    }\n+\n+    fn fcntl(\n+        &mut self,\n+        fd_op: OpTy<'tcx, Tag>,\n+        cmd_op: OpTy<'tcx, Tag>,\n+        arg_op: Option<OpTy<'tcx, Tag>>,\n+    ) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        if !this.machine.communicate {\n+            throw_unsup_format!(\"`open` not available when isolation is enabled\")\n+        }\n+\n+        let fd = this.read_scalar(fd_op)?.to_i32()?;\n+        let cmd = this.read_scalar(cmd_op)?.to_i32()?;\n+\n+        if cmd == this.eval_libc_i32(\"F_SETFD\")? {\n+            // This does not affect the file itself. Certain flags might require changing the file\n+            // or the way it is accessed somehow.\n+            let flag = this.read_scalar(arg_op.unwrap())?.to_i32()?;\n+            // The only usage of this in stdlib at the moment is to enable the `FD_CLOEXEC` flag.\n+            let fd_cloexec = this.eval_libc_i32(\"FD_CLOEXEC\")?;\n+            if let Some(FileHandle { flag: old_flag, .. }) =\n+                this.machine.file_handler.handles.get_mut(&fd)\n+            {\n+                if flag ^ *old_flag == fd_cloexec {\n+                    *old_flag = flag;\n+                } else {\n+                    throw_unsup_format!(\"Unsupported arg {:#x} for `F_SETFD`\", flag);\n+                }\n+            }\n+            Ok(0)\n+        } else if cmd == this.eval_libc_i32(\"F_GETFD\")? {\n+            this.get_handle_and(fd, |handle| Ok(handle.flag))\n+        } else {\n+            throw_unsup_format!(\"Unsupported command {:#x}\", cmd);\n+        }\n+    }\n+\n+    fn close(&mut self, fd_op: OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+        let this = self.eval_context_mut();\n+\n+        if !this.machine.communicate {\n+            throw_unsup_format!(\"`open` not available when isolation is enabled\")\n+        }\n+\n+        let fd = this.read_scalar(fd_op)?.to_i32()?;\n+\n+        this.remove_handle_and(\n+            fd,\n+            |handle, this| this.consume_result(handle.file.sync_all().map(|_| 0i32)),\n+        )\n+    }\n+\n+    fn read(\n+        &mut self,\n+        fd_op: OpTy<'tcx, Tag>,\n+        buf_op: OpTy<'tcx, Tag>,\n+        count_op: OpTy<'tcx, Tag>,\n+    ) -> InterpResult<'tcx, i64> {\n+        let this = self.eval_context_mut();\n+\n+        if !this.machine.communicate {\n+            throw_unsup_format!(\"`open` not available when isolation is enabled\")\n+        }\n+\n+        let tcx = &{ this.tcx.tcx };\n+\n+        let fd = this.read_scalar(fd_op)?.to_i32()?;\n+        let buf = this.force_ptr(this.read_scalar(buf_op)?.not_undef()?)?;\n+        let count = this.read_scalar(count_op)?.to_usize(&*this.tcx)?;\n+\n+        // Remove the file handle to avoid borrowing issues\n+        this.remove_handle_and(\n+            fd,\n+            |mut handle, this| {\n+                let bytes = handle\n+                    .file\n+                    .read(this.memory_mut().get_mut(buf.alloc_id)?.get_bytes_mut(\n+                        tcx,\n+                        buf,\n+                        Size::from_bytes(count),\n+                    )?)\n+                    .map(|bytes| bytes as i64);\n+                // Reinsert the file handle\n+                this.machine.file_handler.handles.insert(fd, handle);\n+                this.consume_result(bytes)\n+            },\n+        )\n+    }\n+\n+    /// Helper function that gets a `FileHandle` immutable reference and allows to manipulate it\n+    /// using `f`.\n+    ///\n+    /// If the `fd` file descriptor does not corresponds to a file, this functions returns `Ok(-1)`\n+    /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n+    ///\n+    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n+    /// functions return different integer types (like `read`, that returns an `i64`)\n+    fn get_handle_and<F, T: From<i32>>(&mut self, fd: i32, f: F) -> InterpResult<'tcx, T>\n+    where\n+        F: Fn(&FileHandle) -> InterpResult<'tcx, T>,\n+    {\n+        let this = self.eval_context_mut();\n+        if let Some(handle) = this.machine.file_handler.handles.get(&fd) {\n+            f(handle)\n+        } else {\n+            this.machine.last_error = this.eval_libc_i32(\"EBADF\")? as u32;\n+            Ok((-1).into())\n+        }\n+    }\n+\n+    /// Helper function that removes a `FileHandle` and allows to manipulate it using the `f`\n+    /// closure. This function is quite useful when you need to modify a `FileHandle` but you need\n+    /// to modify `MiriEvalContext` at the same time, so you can modify the handle and reinsert it\n+    /// using `f`.\n+    ///\n+    /// If the `fd` file descriptor does not corresponds to a file, this functions returns `Ok(-1)`\n+    /// and sets `Evaluator::last_error` to `libc::EBADF` (invalid file descriptor).\n+    ///\n+    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n+    /// functions return different integer types (like `read`, that returns an `i64`)\n+    fn remove_handle_and<F, T: From<i32>>(&mut self, fd: i32, mut f: F) -> InterpResult<'tcx, T>\n+    where\n+        F: FnMut(FileHandle, &mut MiriEvalContext<'mir, 'tcx>) -> InterpResult<'tcx, T>,\n+    {\n+        let this = self.eval_context_mut();\n+        if let Some(handle) = this.machine.file_handler.handles.remove(&fd) {\n+            f(handle, this)\n+        } else {\n+            this.machine.last_error = this.eval_libc_i32(\"EBADF\")? as u32;\n+            Ok((-1).into())\n+        }\n+    }\n+\n+    /// Helper function that consumes an `std::io::Result<T>` and returns an\n+    /// `InterpResult<'tcx,T>::Ok` instead. It is expected that the result can be converted to an\n+    /// OS error using `std::io::Error::raw_os_error`.\n+    ///\n+    /// This function uses `T: From<i32>` instead of `i32` directly because some IO related\n+    /// functions return different integer types (like `read`, that returns an `i64`)\n+    fn consume_result<T: From<i32>>(&mut self, result: std::io::Result<T>) -> InterpResult<'tcx, T> {\n+        match result {\n+            Ok(ok) => Ok(ok),\n+            Err(e) => {\n+                self.eval_context_mut().machine.last_error = e.raw_os_error().unwrap() as u32;\n+                Ok((-1).into())\n+            }\n+        }\n+    }\n+}"}, {"sha": "3df5b839e5d782d11d517630aedb4ac10c75dac7", "filename": "src/shims/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "patch": "@@ -3,6 +3,7 @@ pub mod env;\n pub mod foreign_items;\n pub mod intrinsics;\n pub mod tls;\n+pub mod io;\n \n use rustc::{mir, ty};\n "}, {"sha": "8ab686eafeb1f44702738c8b0f24f2567c36da6d", "filename": "tests/hello.txt", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/tests%2Fhello.txt", "raw_url": "https://github.com/rust-lang/rust/raw/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/tests%2Fhello.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fhello.txt?ref=1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "patch": "@@ -0,0 +1 @@\n+Hello, World!"}, {"sha": "a60640d1b3c3400850ec6fed42ea2fcd0d9150cd", "filename": "tests/run-pass/file_read.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/tests%2Frun-pass%2Ffile_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1037f69bf6dcf73dfbe06453336eeae61ba7c51f/tests%2Frun-pass%2Ffile_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Ffile_read.rs?ref=1037f69bf6dcf73dfbe06453336eeae61ba7c51f", "patch": "@@ -0,0 +1,13 @@\n+// ignore-windows: File handling is not implemented yet\n+// compile-flags: -Zmiri-disable-isolation\n+\n+use std::fs::File;\n+use std::io::Read;\n+\n+fn main() {\n+    // FIXME: create the file and delete it when `rm` is implemented.\n+    let mut file = File::open(\"./tests/hello.txt\").unwrap();\n+    let mut contents = String::new();\n+    file.read_to_string(&mut contents).unwrap();\n+    assert_eq!(\"Hello, World!\\n\", contents);\n+}"}]}