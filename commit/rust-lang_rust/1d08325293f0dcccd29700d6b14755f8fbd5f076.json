{"sha": "1d08325293f0dcccd29700d6b14755f8fbd5f076", "node_id": "C_kwDOAAsO6NoAKDFkMDgzMjUyOTNmMGRjY2NkMjk3MDBkNmIxNDc1NWY4ZmJkNWYwNzY", "commit": {"author": {"name": "y21", "email": "30553356+y21@users.noreply.github.com", "date": "2023-04-17T22:14:56Z"}, "committer": {"name": "y21", "email": "30553356+y21@users.noreply.github.com", "date": "2023-04-29T16:59:07Z"}, "message": "move lint to loops, emit proper suggestion, more tests", "tree": {"sha": "0bd4b576864abb349a9f408a6b742bbb665a112f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bd4b576864abb349a9f408a6b742bbb665a112f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d08325293f0dcccd29700d6b14755f8fbd5f076", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d08325293f0dcccd29700d6b14755f8fbd5f076", "html_url": "https://github.com/rust-lang/rust/commit/1d08325293f0dcccd29700d6b14755f8fbd5f076", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d08325293f0dcccd29700d6b14755f8fbd5f076/comments", "author": {"login": "y21", "id": 30553356, "node_id": "MDQ6VXNlcjMwNTUzMzU2", "avatar_url": "https://avatars.githubusercontent.com/u/30553356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/y21", "html_url": "https://github.com/y21", "followers_url": "https://api.github.com/users/y21/followers", "following_url": "https://api.github.com/users/y21/following{/other_user}", "gists_url": "https://api.github.com/users/y21/gists{/gist_id}", "starred_url": "https://api.github.com/users/y21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/y21/subscriptions", "organizations_url": "https://api.github.com/users/y21/orgs", "repos_url": "https://api.github.com/users/y21/repos", "events_url": "https://api.github.com/users/y21/events{/privacy}", "received_events_url": "https://api.github.com/users/y21/received_events", "type": "User", "site_admin": false}, "committer": {"login": "y21", "id": 30553356, "node_id": "MDQ6VXNlcjMwNTUzMzU2", "avatar_url": "https://avatars.githubusercontent.com/u/30553356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/y21", "html_url": "https://github.com/y21", "followers_url": "https://api.github.com/users/y21/followers", "following_url": "https://api.github.com/users/y21/following{/other_user}", "gists_url": "https://api.github.com/users/y21/gists{/gist_id}", "starred_url": "https://api.github.com/users/y21/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/y21/subscriptions", "organizations_url": "https://api.github.com/users/y21/orgs", "repos_url": "https://api.github.com/users/y21/repos", "events_url": "https://api.github.com/users/y21/events{/privacy}", "received_events_url": "https://api.github.com/users/y21/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcdcc34ba95cd27cab6da68fcac820ca6968d3e2", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcdcc34ba95cd27cab6da68fcac820ca6968d3e2", "html_url": "https://github.com/rust-lang/rust/commit/bcdcc34ba95cd27cab6da68fcac820ca6968d3e2"}], "stats": {"total": 501, "additions": 351, "deletions": 150}, "files": [{"sha": "ff418092e4bfd73fd4ba5198a09c880a73cb3a79", "filename": "clippy_lints/src/declared_lints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Fdeclared_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdeclared_lints.rs?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -258,6 +258,7 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::loops::WHILE_IMMUTABLE_CONDITION_INFO,\n     crate::loops::WHILE_LET_LOOP_INFO,\n     crate::loops::WHILE_LET_ON_ITERATOR_INFO,\n+    crate::loops::WHILE_POP_UNWRAP_INFO,\n     crate::macro_use::MACRO_USE_IMPORTS_INFO,\n     crate::main_recursion::MAIN_RECURSION_INFO,\n     crate::manual_assert::MANUAL_ASSERT_INFO,\n@@ -645,7 +646,6 @@ pub(crate) static LINTS: &[&crate::LintInfo] = &[\n     crate::useless_conversion::USELESS_CONVERSION_INFO,\n     crate::vec::USELESS_VEC_INFO,\n     crate::vec_init_then_push::VEC_INIT_THEN_PUSH_INFO,\n-    crate::while_pop_unwrap::WHILE_POP_UNWRAP_INFO,\n     crate::wildcard_imports::ENUM_GLOB_USE_INFO,\n     crate::wildcard_imports::WILDCARD_IMPORTS_INFO,\n     crate::write::PRINTLN_EMPTY_STRING_INFO,"}, {"sha": "48dbecc9f6aa2dec52e09d23e52222030d4f08ff", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -324,7 +324,6 @@ mod use_self;\n mod useless_conversion;\n mod vec;\n mod vec_init_then_push;\n-mod while_pop_unwrap;\n mod wildcard_imports;\n mod write;\n mod zero_div_zero;"}, {"sha": "02197e9c187e769b3c33da9a6a0cf658092a8eac", "filename": "clippy_lints/src/loops/mod.rs", "status": "modified", "additions": 34, "deletions": 4, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Floops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fmod.rs?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -17,6 +17,7 @@ mod utils;\n mod while_immutable_condition;\n mod while_let_loop;\n mod while_let_on_iterator;\n+mod while_pop_unwrap;\n \n use clippy_utils::higher;\n use rustc_hir::{Expr, ExprKind, LoopSource, Pat};\n@@ -25,8 +26,6 @@ use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n use utils::{make_iterator_snippet, IncrementVisitor, InitializeVisitor};\n \n-use crate::while_pop_unwrap;\n-\n declare_clippy_lint! {\n     /// ### What it does\n     /// Checks for for-loops that manually copy items between\n@@ -577,6 +576,36 @@ declare_clippy_lint! {\n     \"manual implementation of `Iterator::find`\"\n }\n \n+declare_clippy_lint! {\n+    /// ### What it does\n+    /// Looks for loops that check for emptiness of a `Vec` in the condition and pop an element\n+    /// in the body as a separate operation.\n+    ///\n+    /// ### Why is this bad?\n+    /// Such loops can be written in a more idiomatic way by using a while..let loop and directly\n+    /// pattern matching on the return value of `Vec::pop()`.\n+    ///\n+    /// ### Example\n+    /// ```rust\n+    /// let mut numbers = vec![1, 2, 3, 4, 5];\n+    /// while !numbers.is_empty() {\n+    ///     let number = numbers.pop().unwrap();\n+    ///     // use `number`\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let mut numbers = vec![1, 2, 3, 4, 5];\n+    /// while let Some(number) = numbers.pop() {\n+    ///     // use `number`\n+    /// }\n+    /// ```\n+    #[clippy::version = \"1.70.0\"]\n+    pub WHILE_POP_UNWRAP,\n+    style,\n+    \"checking for emptiness of a `Vec` in the loop condition and popping an element in the body\"\n+}\n+\n declare_lint_pass!(Loops => [\n     MANUAL_MEMCPY,\n     MANUAL_FLATTEN,\n@@ -596,6 +625,7 @@ declare_lint_pass!(Loops => [\n     SINGLE_ELEMENT_LOOP,\n     MISSING_SPIN_LOOP,\n     MANUAL_FIND,\n+    WHILE_POP_UNWRAP\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Loops {\n@@ -642,10 +672,10 @@ impl<'tcx> LateLintPass<'tcx> for Loops {\n \n         while_let_on_iterator::check(cx, expr);\n \n-        if let Some(higher::While { condition, body }) = higher::While::hir(expr) {\n+        if let Some(higher::While { condition, body, span }) = higher::While::hir(expr) {\n             while_immutable_condition::check(cx, condition, body);\n             missing_spin_loop::check(cx, condition, body);\n-            while_pop_unwrap::check(cx, condition, body);\n+            while_pop_unwrap::check(cx, condition, body, span);\n         }\n     }\n }"}, {"sha": "1e31184b34d635d70b106c712d76ea96c0203d9b", "filename": "clippy_lints/src/loops/while_pop_unwrap.rs", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Floops%2Fwhile_pop_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Floops%2Fwhile_pop_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops%2Fwhile_pop_unwrap.rs?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -0,0 +1,109 @@\n+use clippy_utils::{\n+    diagnostics::{multispan_sugg_with_applicability, span_lint_and_then},\n+    match_def_path, paths,\n+    source::snippet,\n+    SpanlessEq,\n+};\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind, Pat, Stmt, StmtKind, UnOp};\n+use rustc_lint::LateContext;\n+use rustc_span::Span;\n+use std::borrow::Cow;\n+\n+use super::WHILE_POP_UNWRAP;\n+\n+/// The kind of statement that the `pop()` call appeared in.\n+///\n+/// Depending on whether the value was assigned to a variable or not changes what pattern\n+/// we use for the suggestion.\n+enum PopStmt<'hir> {\n+    /// `x.pop().unwrap()` was and assigned to a variable.\n+    /// The pattern of this local variable will be used and the local statement\n+    /// is deleted in the suggestion.\n+    Local(&'hir Pat<'hir>),\n+    /// `x.pop().unwrap()` appeared in an arbitrary expression and was not assigned to a variable.\n+    /// The suggestion will use some placeholder identifier and the `x.pop().unwrap()` expression\n+    /// is replaced with that identifier.\n+    Anonymous,\n+}\n+\n+fn report_lint(cx: &LateContext<'_>, pop_span: Span, pop_stmt_kind: PopStmt<'_>, loop_span: Span, receiver_span: Span) {\n+    span_lint_and_then(\n+        cx,\n+        WHILE_POP_UNWRAP,\n+        pop_span,\n+        \"you seem to be trying to pop elements from a `Vec` in a loop\",\n+        |diag| {\n+            let (pat, pop_replacement) = match &pop_stmt_kind {\n+                PopStmt::Local(pat) => (snippet(cx, pat.span, \"..\"), String::new()),\n+                PopStmt::Anonymous => (Cow::Borrowed(\"element\"), \"element\".into()),\n+            };\n+\n+            let loop_replacement = format!(\"while let Some({}) = {}.pop()\", pat, snippet(cx, receiver_span, \"..\"));\n+            multispan_sugg_with_applicability(\n+                diag,\n+                \"consider using a `while..let` loop\",\n+                Applicability::MachineApplicable,\n+                [(loop_span, loop_replacement), (pop_span, pop_replacement)],\n+            );\n+        },\n+    );\n+}\n+\n+fn match_method_call(cx: &LateContext<'_>, expr: &Expr<'_>, method: &[&str]) -> bool {\n+    if let ExprKind::MethodCall(..) = expr.kind\n+        && let Some(id) = cx.typeck_results().type_dependent_def_id(expr.hir_id)\n+    {\n+        match_def_path(cx, id, method)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn is_vec_pop_unwrap(cx: &LateContext<'_>, expr: &Expr<'_>, is_empty_recv: &Expr<'_>) -> bool {\n+    if (match_method_call(cx, expr, &paths::OPTION_UNWRAP) || match_method_call(cx, expr, &paths::OPTION_EXPECT))\n+        && let ExprKind::MethodCall(_, unwrap_recv, ..) = expr.kind\n+        && match_method_call(cx, unwrap_recv, &paths::VEC_POP)\n+        && let ExprKind::MethodCall(_, pop_recv, ..) = unwrap_recv.kind\n+    {\n+        // make sure they're the same `Vec`\n+        SpanlessEq::new(cx).eq_expr(pop_recv, is_empty_recv)\n+    } else {\n+        false\n+    }\n+}\n+\n+fn check_local(cx: &LateContext<'_>, stmt: &Stmt<'_>, is_empty_recv: &Expr<'_>, loop_span: Span) {\n+    if let StmtKind::Local(local) = stmt.kind\n+        && let Some(init) = local.init\n+        && is_vec_pop_unwrap(cx, init, is_empty_recv)\n+    {\n+        report_lint(cx, stmt.span, PopStmt::Local(&local.pat), loop_span, is_empty_recv.span);\n+    }\n+}\n+\n+fn check_call_arguments(cx: &LateContext<'_>, stmt: &Stmt<'_>, is_empty_recv: &Expr<'_>, loop_span: Span) {\n+    if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = stmt.kind {\n+        if let ExprKind::MethodCall(.., args, _) | ExprKind::Call(_, args) = expr.kind {\n+            let offending_arg = args\n+                .iter()\n+                .find_map(|arg| is_vec_pop_unwrap(cx, arg, is_empty_recv).then_some(arg.span));\n+\n+            if let Some(offending_arg) = offending_arg {\n+                report_lint(cx, offending_arg, PopStmt::Anonymous, loop_span, is_empty_recv.span);\n+            }\n+        }\n+    }\n+}\n+\n+pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, full_cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>, loop_span: Span) {\n+    if let ExprKind::Unary(UnOp::Not, cond) = full_cond.kind\n+        && let ExprKind::MethodCall(_, is_empty_recv, _, _) = cond.kind\n+        && match_method_call(cx, cond, &paths::VEC_IS_EMPTY)\n+        && let ExprKind::Block(body, _) = body.kind\n+        && let Some(stmt) = body.stmts.first()\n+    {\n+        check_local(cx, stmt, is_empty_recv, loop_span);\n+        check_call_arguments(cx, stmt, is_empty_recv, loop_span);\n+    }\n+}"}, {"sha": "108077b9d1588420d3cbeacc7f2e9d8be075d571", "filename": "clippy_lints/src/utils/author.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_lints%2Fsrc%2Futils%2Fauthor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fauthor.rs?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -333,7 +333,7 @@ impl<'a, 'tcx> PrintVisitor<'a, 'tcx> {\n \n     #[allow(clippy::too_many_lines)]\n     fn expr(&self, expr: &Binding<&hir::Expr<'_>>) {\n-        if let Some(higher::While { condition, body }) = higher::While::hir(expr.value) {\n+        if let Some(higher::While { condition, body, .. }) = higher::While::hir(expr.value) {\n             bind!(self, condition, body);\n             chain!(\n                 self,"}, {"sha": "0a3f08888a3bfbf5294070358619572eedd12d48", "filename": "clippy_lints/src/while_pop_unwrap.rs", "status": "removed", "additions": 0, "deletions": 122, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bcdcc34ba95cd27cab6da68fcac820ca6968d3e2/clippy_lints%2Fsrc%2Fwhile_pop_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcdcc34ba95cd27cab6da68fcac820ca6968d3e2/clippy_lints%2Fsrc%2Fwhile_pop_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fwhile_pop_unwrap.rs?ref=bcdcc34ba95cd27cab6da68fcac820ca6968d3e2", "patch": "@@ -1,122 +0,0 @@\n-use clippy_utils::{diagnostics::span_lint_and_then, match_def_path, paths, source::snippet};\n-use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind, PatKind, Stmt, StmtKind, UnOp};\n-use rustc_lint::LateContext;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::{symbol::Ident, Span};\n-\n-declare_clippy_lint! {\n-    /// ### What it does\n-    /// Looks for loops that check for emptiness of a `Vec` in the condition and pop an element\n-    /// in the body as a separate operation.\n-    ///\n-    /// ### Why is this bad?\n-    /// Such loops can be written in a more idiomatic way by using a while..let loop and directly\n-    /// pattern matching on the return value of `Vec::pop()`.\n-    ///\n-    /// ### Example\n-    /// ```rust\n-    /// let mut numbers = vec![1, 2, 3, 4, 5];\n-    /// while !numbers.is_empty() {\n-    ///     let number = numbers.pop().unwrap();\n-    ///     // use `number`\n-    /// }\n-    /// ```\n-    /// Use instead:\n-    /// ```rust\n-    /// let mut numbers = vec![1, 2, 3, 4, 5];\n-    /// while let Some(number) = numbers.pop() {\n-    ///     // use `number`\n-    /// }\n-    /// ```\n-    #[clippy::version = \"1.70.0\"]\n-    pub WHILE_POP_UNWRAP,\n-    style,\n-    \"checking for emptiness of a `Vec` in the loop condition and popping an element in the body\"\n-}\n-declare_lint_pass!(WhilePopUnwrap => [WHILE_POP_UNWRAP]);\n-\n-fn report_lint(cx: &LateContext<'_>, pop_span: Span, ident: Option<Ident>, loop_span: Span, receiver_span: Span) {\n-    span_lint_and_then(\n-        cx,\n-        WHILE_POP_UNWRAP,\n-        pop_span,\n-        \"you seem to be trying to pop elements from a `Vec` in a loop\",\n-        |diag| {\n-            diag.span_suggestion(\n-                loop_span,\n-                \"try\",\n-                format!(\n-                    \"while let Some({}) = {}.pop()\",\n-                    ident.as_ref().map_or(\"element\", Ident::as_str),\n-                    snippet(cx, receiver_span, \"..\")\n-                ),\n-                Applicability::MaybeIncorrect,\n-            )\n-            .note(\"this while loop can be written in a more idiomatic way\");\n-        },\n-    );\n-}\n-\n-fn match_method_call(cx: &LateContext<'_>, expr: &Expr<'_>, method: &[&str]) -> bool {\n-    if let ExprKind::MethodCall(..) = expr.kind\n-        && let Some(id) = cx.typeck_results().type_dependent_def_id(expr.hir_id)\n-        && match_def_path(cx, id, method)\n-    {\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n-fn is_vec_pop(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    match_method_call(cx, expr, &paths::VEC_POP)\n-}\n-\n-fn is_vec_pop_unwrap(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let ExprKind::MethodCall(_, inner, ..) = expr.kind\n-        && (match_method_call(cx, expr, &paths::OPTION_UNWRAP) || match_method_call(cx, expr, &paths::OPTION_EXPECT))\n-        && is_vec_pop(cx, inner)\n-    {\n-        true\n-    } else {\n-        false\n-    }\n-}\n-\n-fn check_local(cx: &LateContext<'_>, stmt: &Stmt<'_>, loop_span: Span, recv_span: Span) {\n-    if let StmtKind::Local(local) = stmt.kind\n-        && let PatKind::Binding(.., ident, _) = local.pat.kind\n-        && let Some(init) = local.init\n-        && let ExprKind::MethodCall(_, inner, ..) = init.kind\n-        && is_vec_pop_unwrap(cx, init)\n-    {\n-        report_lint(cx, init.span.to(inner.span), Some(ident), loop_span, recv_span);\n-    }\n-}\n-\n-fn check_call_arguments(cx: &LateContext<'_>, stmt: &Stmt<'_>, loop_span: Span, recv_span: Span) {\n-    if let StmtKind::Semi(expr) | StmtKind::Expr(expr) = stmt.kind {\n-        if let ExprKind::MethodCall(_, _, args, _) | ExprKind::Call(_, args) = expr.kind {\n-            let offending_arg = args\n-                .iter()\n-                .find_map(|arg| is_vec_pop_unwrap(cx, arg).then_some(arg.span));\n-\n-            if let Some(offending_arg) = offending_arg {\n-                report_lint(cx, offending_arg, None, loop_span, recv_span);\n-            }\n-        }\n-    }\n-}\n-\n-pub(super) fn check<'tcx>(cx: &LateContext<'tcx>, cond: &'tcx Expr<'_>, body: &'tcx Expr<'_>) {\n-    if let ExprKind::Unary(UnOp::Not, cond) = cond.kind\n-        && let ExprKind::MethodCall(_, Expr { span: recv_span, .. }, _, _) = cond.kind\n-        && match_method_call(cx, cond, &paths::VEC_IS_EMPTY)\n-        && let ExprKind::Block(body, _) = body.kind\n-        && let Some(stmt) = body.stmts.first()\n-    {\n-        check_local(cx, stmt, cond.span, *recv_span);\n-        check_call_arguments(cx, stmt, cond.span, *recv_span);\n-    }\n-}"}, {"sha": "a61e4c380886d3401267bfbc7bf94479a00c5a0c", "filename": "clippy_utils/src/higher.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_utils%2Fsrc%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/clippy_utils%2Fsrc%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fhigher.rs?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -311,6 +311,8 @@ pub struct While<'hir> {\n     pub condition: &'hir Expr<'hir>,\n     /// `while` loop body\n     pub body: &'hir Expr<'hir>,\n+    /// Span of the loop header\n+    pub span: Span,\n }\n \n impl<'hir> While<'hir> {\n@@ -336,10 +338,10 @@ impl<'hir> While<'hir> {\n             },\n             _,\n             LoopSource::While,\n-            _,\n+            span,\n         ) = expr.kind\n         {\n-            return Some(Self { condition, body });\n+            return Some(Self { condition, body, span });\n         }\n         None\n     }"}, {"sha": "a635e054e6ecae2b3bafd238047899a9f691d398", "filename": "tests/ui/while_pop_unwrap.fixed", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/tests%2Fui%2Fwhile_pop_unwrap.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/tests%2Fui%2Fwhile_pop_unwrap.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_pop_unwrap.fixed?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+\n+#![allow(unused)]\n+#![warn(clippy::while_pop_unwrap)]\n+\n+struct VecInStruct {\n+    numbers: Vec<i32>,\n+    unrelated: String,\n+}\n+\n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n+fn accept_i32(_: i32) {}\n+fn accept_optional_i32(_: Option<i32>) {}\n+fn accept_i32_tuple(_: (i32, i32)) {}\n+\n+fn main() {\n+    let mut numbers = vec![1, 2, 3, 4, 5];\n+    while let Some(number) = numbers.pop() {\n+        \n+    }\n+\n+    let mut val = VecInStruct {\n+        numbers: vec![1, 2, 3, 4, 5],\n+        unrelated: String::new(),\n+    };\n+    while let Some(number) = val.numbers.pop() {\n+        \n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32(element);\n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32(element);\n+    }\n+\n+    // This should not warn. It \"conditionally\" pops elements.\n+    while !numbers.is_empty() {\n+        if true {\n+            accept_i32(numbers.pop().unwrap());\n+        }\n+    }\n+\n+    // This should also not warn. It conditionally pops elements.\n+    while !numbers.is_empty() {\n+        if false {\n+            continue;\n+        }\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    // This should not warn. It pops elements, but does not unwrap it.\n+    // Might handle the Option in some other arbitrary way.\n+    while !numbers.is_empty() {\n+        accept_optional_i32(numbers.pop());\n+    }\n+\n+    let unrelated_vec: Vec<String> = Vec::new();\n+    // This should not warn. It pops elements from a different vector.\n+    while !unrelated_vec.is_empty() {\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    macro_rules! generate_loop {\n+        () => {\n+            while !numbers.is_empty() {\n+                accept_i32(numbers.pop().unwrap());\n+            }\n+        };\n+    }\n+    // Do not warn if the loop is in a macro.\n+    generate_loop!();\n+\n+    // Try other kinds of patterns\n+    let mut numbers = vec![(0, 0), (1, 1), (2, 2)];\n+    while let Some((a, b)) = numbers.pop() {\n+        \n+    }\n+\n+    while let Some(element) = numbers.pop() {\n+        accept_i32_tuple(element);\n+    }\n+\n+    let mut results = vec![Foo { a: 1, b: 2 }, Foo { a: 3, b: 4 }];\n+    while let Some(Foo { a, b }) = results.pop() {\n+        \n+    }\n+}"}, {"sha": "820ff211086c133ac63c59664d47ca61362e36be", "filename": "tests/ui/while_pop_unwrap.rs", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/tests%2Fui%2Fwhile_pop_unwrap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/tests%2Fui%2Fwhile_pop_unwrap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_pop_unwrap.rs?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![allow(unused)]\n #![warn(clippy::while_pop_unwrap)]\n \n@@ -6,7 +8,14 @@ struct VecInStruct {\n     unrelated: String,\n }\n \n+struct Foo {\n+    a: i32,\n+    b: i32,\n+}\n+\n fn accept_i32(_: i32) {}\n+fn accept_optional_i32(_: Option<i32>) {}\n+fn accept_i32_tuple(_: (i32, i32)) {}\n \n fn main() {\n     let mut numbers = vec![1, 2, 3, 4, 5];\n@@ -44,4 +53,41 @@ fn main() {\n         }\n         accept_i32(numbers.pop().unwrap());\n     }\n+\n+    // This should not warn. It pops elements, but does not unwrap it.\n+    // Might handle the Option in some other arbitrary way.\n+    while !numbers.is_empty() {\n+        accept_optional_i32(numbers.pop());\n+    }\n+\n+    let unrelated_vec: Vec<String> = Vec::new();\n+    // This should not warn. It pops elements from a different vector.\n+    while !unrelated_vec.is_empty() {\n+        accept_i32(numbers.pop().unwrap());\n+    }\n+\n+    macro_rules! generate_loop {\n+        () => {\n+            while !numbers.is_empty() {\n+                accept_i32(numbers.pop().unwrap());\n+            }\n+        };\n+    }\n+    // Do not warn if the loop is in a macro.\n+    generate_loop!();\n+\n+    // Try other kinds of patterns\n+    let mut numbers = vec![(0, 0), (1, 1), (2, 2)];\n+    while !numbers.is_empty() {\n+        let (a, b) = numbers.pop().unwrap();\n+    }\n+\n+    while !numbers.is_empty() {\n+        accept_i32_tuple(numbers.pop().unwrap());\n+    }\n+\n+    let mut results = vec![Foo { a: 1, b: 2 }, Foo { a: 3, b: 4 }];\n+    while !results.is_empty() {\n+        let Foo { a, b } = results.pop().unwrap();\n+    }\n }"}, {"sha": "f8a6cfcda0ea1e891262709f523f6b70e0a9319b", "filename": "tests/ui/while_pop_unwrap.stderr", "status": "modified", "additions": 63, "deletions": 19, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/1d08325293f0dcccd29700d6b14755f8fbd5f076/tests%2Fui%2Fwhile_pop_unwrap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d08325293f0dcccd29700d6b14755f8fbd5f076/tests%2Fui%2Fwhile_pop_unwrap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fwhile_pop_unwrap.stderr?ref=1d08325293f0dcccd29700d6b14755f8fbd5f076", "patch": "@@ -1,43 +1,87 @@\n error: you seem to be trying to pop elements from a `Vec` in a loop\n-  --> $DIR/while_pop_unwrap.rs:14:22\n+  --> $DIR/while_pop_unwrap.rs:23:9\n    |\n-LL |     while !numbers.is_empty() {\n-   |            ------------------ help: try: `while let Some(number) = numbers.pop()`\n LL |         let number = numbers.pop().unwrap();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: this while loop can be written in a more idiomatic way\n    = note: `-D clippy::while-pop-unwrap` implied by `-D warnings`\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(number) = numbers.pop() {\n+LL ~         \n+   |\n \n error: you seem to be trying to pop elements from a `Vec` in a loop\n-  --> $DIR/while_pop_unwrap.rs:22:22\n+  --> $DIR/while_pop_unwrap.rs:31:9\n    |\n-LL |     while !val.numbers.is_empty() {\n-   |            ---------------------- help: try: `while let Some(number) = val.numbers.pop()`\n LL |         let number = val.numbers.pop().unwrap();\n-   |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(number) = val.numbers.pop() {\n+LL ~         \n    |\n-   = note: this while loop can be written in a more idiomatic way\n \n error: you seem to be trying to pop elements from a `Vec` in a loop\n-  --> $DIR/while_pop_unwrap.rs:26:20\n+  --> $DIR/while_pop_unwrap.rs:35:20\n    |\n-LL |     while !numbers.is_empty() {\n-   |            ------------------ help: try: `while let Some(element) = numbers.pop()`\n LL |         accept_i32(numbers.pop().unwrap());\n    |                    ^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: this while loop can be written in a more idiomatic way\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32(element);\n+   |\n \n error: you seem to be trying to pop elements from a `Vec` in a loop\n-  --> $DIR/while_pop_unwrap.rs:30:20\n+  --> $DIR/while_pop_unwrap.rs:39:20\n    |\n-LL |     while !numbers.is_empty() {\n-   |            ------------------ help: try: `while let Some(element) = numbers.pop()`\n LL |         accept_i32(numbers.pop().expect(\"\"));\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: this while loop can be written in a more idiomatic way\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32(element);\n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/while_pop_unwrap.rs:82:9\n+   |\n+LL |         let (a, b) = numbers.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some((a, b)) = numbers.pop() {\n+LL ~         \n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/while_pop_unwrap.rs:86:26\n+   |\n+LL |         accept_i32_tuple(numbers.pop().unwrap());\n+   |                          ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(element) = numbers.pop() {\n+LL ~         accept_i32_tuple(element);\n+   |\n+\n+error: you seem to be trying to pop elements from a `Vec` in a loop\n+  --> $DIR/while_pop_unwrap.rs:91:9\n+   |\n+LL |         let Foo { a, b } = results.pop().unwrap();\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+help: consider using a `while..let` loop\n+   |\n+LL ~     while let Some(Foo { a, b }) = results.pop() {\n+LL ~         \n+   |\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 7 previous errors\n "}]}