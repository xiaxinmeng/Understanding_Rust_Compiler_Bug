{"sha": "7f469ba6c5b0167949540d6c2afe51a0454767f5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNDY5YmE2YzViMDE2Nzk0OTU0MGQ2YzJhZmU1MWEwNDU0NzY3ZjU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-09-29T00:17:46Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-10-08T22:53:41Z"}, "message": "Move placement in desugaring to lowering", "tree": {"sha": "78d9173f74811c35171f87550b43482da389b0e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/78d9173f74811c35171f87550b43482da389b0e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f469ba6c5b0167949540d6c2afe51a0454767f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f469ba6c5b0167949540d6c2afe51a0454767f5", "html_url": "https://github.com/rust-lang/rust/commit/7f469ba6c5b0167949540d6c2afe51a0454767f5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f469ba6c5b0167949540d6c2afe51a0454767f5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc364b4a0d678b29cba92ce948d948aee9d76b25", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc364b4a0d678b29cba92ce948d948aee9d76b25", "html_url": "https://github.com/rust-lang/rust/commit/bc364b4a0d678b29cba92ce948d948aee9d76b25"}], "stats": {"total": 263, "additions": 106, "deletions": 157}, "files": [{"sha": "8a8620cbcca24d4a5b05ecfea87f3661895cc979", "filename": "src/librustc_front/lowering.rs", "status": "modified", "additions": 103, "deletions": 3, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/7f469ba6c5b0167949540d6c2afe51a0454767f5/src%2Flibrustc_front%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f469ba6c5b0167949540d6c2afe51a0454767f5/src%2Flibrustc_front%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_front%2Flowering.rs?ref=7f469ba6c5b0167949540d6c2afe51a0454767f5", "patch": "@@ -752,6 +752,83 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 ExprBox(ref e) => {\n                     hir::ExprBox(lower_expr(lctx, e))\n                 }\n+\n+                // Desugar ExprBox: `in (PLACE) EXPR`\n+                ExprInPlace(Some(ref placer), ref value_expr) => {\n+                    // to:\n+                    //\n+                    // let p = PLACE;\n+                    // let mut place = Placer::make_place(p);\n+                    // let raw_place = Place::pointer(&mut place);\n+                    // push_unsafe!({\n+                    //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n+                    //     InPlace::finalize(place)\n+                    // })\n+\n+                    // TODO\n+                    println!(\"{}\", lctx.foo);\n+\n+                    let placer_expr = lower_expr(lctx, placer);\n+                    let value_expr = lower_expr(lctx, value_expr);\n+\n+                    let placer_ident = token::gensym_ident(\"placer\");\n+                    let agent_ident = token::gensym_ident(\"place\");\n+                    let p_ptr_ident = token::gensym_ident(\"p_ptr\");\n+\n+                    let make_place = [\"ops\", \"Placer\", \"make_place\"];\n+                    let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n+                    let move_val_init = [\"intrinsics\", \"move_val_init\"];\n+                    let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n+\n+                    let make_call = |lctx, p, args| {\n+                        let path = core_path(lctx, e.span, p);\n+                        let path = expr_path(lctx, path);\n+                        expr_call(lctx, e.span, path, args)\n+                    };\n+\n+                    let mk_stmt_let = |lctx, bind, expr| {\n+                        stmt_let(lctx, e.span, false, bind, expr)\n+                    };\n+                    let mk_stmt_let_mut = |lctx, bind, expr| {\n+                        stmt_let(lctx, e.span, true, bind, expr)\n+                    };\n+\n+                    // let placer = <placer_expr> ;\n+                    let s1 = mk_stmt_let(lctx, placer_ident, placer_expr);\n+\n+                    // let mut place = Placer::make_place(placer);\n+                    let s2 = {\n+                        let call = make_call(lctx, &make_place, vec![expr_ident(lctx, e.span, placer_ident)]);\n+                        mk_stmt_let_mut(lctx, agent_ident, call)\n+                    };\n+\n+                    // let p_ptr = Place::pointer(&mut place);\n+                    let s3 = {\n+                        let args = vec![expr_mut_addr_of(lctx, e.span, expr_ident(lctx, e.span, agent_ident))];\n+                        let call = make_call(lctx, &place_pointer, args);\n+                        mk_stmt_let(lctx, p_ptr_ident, call)\n+                    };\n+\n+                    // pop_unsafe!(EXPR));\n+                    let pop_unsafe_expr = pop_unsafe_expr(lctx, value_expr, e.span);\n+\n+                    // push_unsafe!({\n+                    //     ptr::write(p_ptr, pop_unsafe!(<value_expr>));\n+                    //     InPlace::finalize(place)\n+                    // })\n+                    let expr = {\n+                        let call_move_val_init = hir::StmtSemi(make_call(\n+                            lctx, &move_val_init, vec![expr_ident(lctx, e.span, p_ptr_ident), pop_unsafe_expr]), lctx.next_id());\n+                        let call_move_val_init = respan(e.span, call_move_val_init);\n+\n+                        let call = make_call(lctx, &inplace_finalize, vec![expr_ident(lctx, e.span, agent_ident)]);\n+                        Some(push_unsafe_expr(lctx, vec![P(call_move_val_init)], call, e.span))\n+                    };\n+\n+                    let block = block_all(lctx, e.span, vec![s1, s2, s3], expr);\n+                    return expr_block(lctx, block);\n+                }\n+                \n                 ExprVec(ref exprs) => {\n                     hir::ExprVec(exprs.iter().map(|x| lower_expr(lctx, x)).collect())\n                 }\n@@ -895,9 +972,6 @@ pub fn lower_expr(lctx: &LoweringContext, e: &Expr) -> P<hir::Expr> {\n                 ExprParen(ref ex) => {\n                     return lower_expr(lctx, ex);\n                 }\n-                ExprInPlace(..) => {\n-                    panic!(\"todo\");\n-                }\n \n                 // Desugar ExprIfLet\n                 // From: `if let <pat> = <sub_expr> <body> [<else_opt>]`\n@@ -1393,3 +1467,29 @@ fn std_path(lctx: &LoweringContext, components: &[&str]) -> Vec<Ident> {\n     v.extend(components.iter().map(|s| str_to_ident(s)));\n     return v\n }\n+\n+// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n+// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n+fn core_path(lctx: &LoweringContext, span: Span, components: &[&str]) -> hir::Path {\n+    let idents = std_path(lctx, components);\n+    path_global(span, idents)\n+}\n+\n+fn push_unsafe_expr(lctx: &LoweringContext, stmts: Vec<P<hir::Stmt>>,\n+                    expr: P<hir::Expr>, span: Span)\n+                    -> P<hir::Expr> {\n+    let rules = hir::PushUnsafeBlock(hir::CompilerGenerated);\n+    expr_block(lctx, P(hir::Block {\n+        rules: rules, span: span, id: lctx.next_id(),\n+        stmts: stmts, expr: Some(expr),\n+    }))\n+}\n+\n+fn pop_unsafe_expr(lctx: &LoweringContext, expr: P<hir::Expr>, span: Span)\n+                   -> P<hir::Expr> {\n+    let rules = hir::PopUnsafeBlock(hir::CompilerGenerated);\n+    expr_block(lctx, P(hir::Block {\n+        rules: rules, span: span, id: lctx.next_id(),\n+        stmts: vec![], expr: Some(expr),\n+    }))\n+}"}, {"sha": "abda406dcc8b2c83f86fa28049f7a1e8caf25ee5", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 154, "changes": 157, "blob_url": "https://github.com/rust-lang/rust/blob/7f469ba6c5b0167949540d6c2afe51a0454767f5/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f469ba6c5b0167949540d6c2afe51a0454767f5/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7f469ba6c5b0167949540d6c2afe51a0454767f5", "patch": "@@ -20,53 +20,20 @@ use attr;\n use attr::AttrMetaMethods;\n use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n-use codemap::{CompilerExpansion, CompilerExpansionFormat};\n use ext::base::*;\n use feature_gate::{self, Features, GatedCfg};\n use fold;\n use fold::*;\n use parse;\n use parse::token::{fresh_mark, fresh_name, intern};\n-use parse::token;\n use ptr::P;\n use util::small_vector::SmallVector;\n use visit;\n use visit::Visitor;\n use std_inject;\n \n-// Given suffix [\"b\",\"c\",\"d\"], returns path `::std::b::c::d` when\n-// `fld.cx.use_std`, and `::core::b::c::d` otherwise.\n-fn mk_core_path(fld: &mut MacroExpander,\n-                span: Span,\n-                suffix: &[&'static str]) -> ast::Path {\n-    let idents = fld.cx.std_path(suffix);\n-    fld.cx.path_global(span, idents)\n-}\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n-    fn push_compiler_expansion(fld: &mut MacroExpander, span: Span,\n-                               expansion_type: CompilerExpansionFormat) {\n-        fld.cx.bt_push(ExpnInfo {\n-            call_site: span,\n-            callee: NameAndSpan {\n-                format: CompilerExpansion(expansion_type),\n-\n-                // This does *not* mean code generated after\n-                // `push_compiler_expansion` is automatically exempt\n-                // from stability lints; must also tag such code with\n-                // an appropriate span from `fld.cx.backtrace()`.\n-                allow_internal_unstable: true,\n-\n-                span: None,\n-            },\n-        });\n-    }\n-\n-    // Sets the expn_id so that we can use unstable methods.\n-    fn allow_unstable(fld: &mut MacroExpander, span: Span) -> Span {\n-        Span { expn_id: fld.cx.backtrace(), ..span }\n-    }\n-\n     let expr_span = e.span;\n     return e.and_then(|ast::Expr {id, node, span}| match node {\n \n@@ -94,118 +61,18 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             })\n         }\n \n-        // Desugar ExprInPlace: `in PLACE { EXPR }`\n         ast::ExprInPlace(placer, value_expr) => {\n-            // to:\n-            //\n-            // let p = PLACE;\n-            // let mut place = Placer::make_place(p);\n-            // let raw_place = Place::pointer(&mut place);\n-            // push_unsafe!({\n-            //     std::intrinsics::move_val_init(raw_place, pop_unsafe!( EXPR ));\n-            //     InPlace::finalize(place)\n-            // })\n-\n             // Ensure feature-gate is enabled\n             feature_gate::check_for_placement_in(\n                 fld.cx.ecfg.features,\n                 &fld.cx.parse_sess.span_diagnostic,\n                 expr_span);\n \n-            push_compiler_expansion(fld, expr_span, CompilerExpansionFormat::PlacementIn);\n-\n-            let value_span = value_expr.span;\n-            let placer_span = placer.span;\n-\n-            let placer_expr = fld.fold_expr(placer);\n+            let placer = fld.fold_expr(placer);\n             let value_expr = fld.fold_expr(value_expr);\n-\n-            let placer_ident = token::gensym_ident(\"placer\");\n-            let agent_ident = token::gensym_ident(\"place\");\n-            let p_ptr_ident = token::gensym_ident(\"p_ptr\");\n-\n-            let placer = fld.cx.expr_ident(span, placer_ident);\n-            let agent = fld.cx.expr_ident(span, agent_ident);\n-            let p_ptr = fld.cx.expr_ident(span, p_ptr_ident);\n-\n-            let make_place = [\"ops\", \"Placer\", \"make_place\"];\n-            let place_pointer = [\"ops\", \"Place\", \"pointer\"];\n-            let move_val_init = [\"intrinsics\", \"move_val_init\"];\n-            let inplace_finalize = [\"ops\", \"InPlace\", \"finalize\"];\n-\n-            let make_call = |fld: &mut MacroExpander, p, args| {\n-                // We feed in the `expr_span` because codemap's span_allows_unstable\n-                // allows the call_site span to inherit the `allow_internal_unstable`\n-                // setting.\n-                let span_unstable = allow_unstable(fld, expr_span);\n-                let path = mk_core_path(fld, span_unstable, p);\n-                let path = fld.cx.expr_path(path);\n-                let expr_span_unstable = allow_unstable(fld, span);\n-                fld.cx.expr_call(expr_span_unstable, path, args)\n-            };\n-\n-            let stmt_let = |fld: &mut MacroExpander, bind, expr| {\n-                fld.cx.stmt_let(placer_span, false, bind, expr)\n-            };\n-            let stmt_let_mut = |fld: &mut MacroExpander, bind, expr| {\n-                fld.cx.stmt_let(placer_span, true, bind, expr)\n-            };\n-\n-            // let placer = <placer_expr> ;\n-            let s1 = stmt_let(fld, placer_ident, placer_expr);\n-\n-            // let mut place = Placer::make_place(placer);\n-            let s2 = {\n-                let call = make_call(fld, &make_place, vec![placer]);\n-                stmt_let_mut(fld, agent_ident, call)\n-            };\n-\n-            // let p_ptr = Place::pointer(&mut place);\n-            let s3 = {\n-                let args = vec![fld.cx.expr_mut_addr_of(placer_span, agent.clone())];\n-                let call = make_call(fld, &place_pointer, args);\n-                stmt_let(fld, p_ptr_ident, call)\n-            };\n-\n-            // pop_unsafe!(EXPR));\n-            let pop_unsafe_expr = pop_unsafe_expr(fld.cx, value_expr, value_span);\n-\n-            // push_unsafe!({\n-            //     ptr::write(p_ptr, pop_unsafe!(<value_expr>));\n-            //     InPlace::finalize(place)\n-            // })\n-            let expr = {\n-                let call_move_val_init = StmtSemi(make_call(\n-                    fld, &move_val_init, vec![p_ptr, pop_unsafe_expr]), ast::DUMMY_NODE_ID);\n-                let call_move_val_init = codemap::respan(value_span, call_move_val_init);\n-\n-                let call = make_call(fld, &inplace_finalize, vec![agent]);\n-                Some(push_unsafe_expr(fld.cx, vec![P(call_move_val_init)], call, span))\n-            };\n-\n-            let block = fld.cx.block_all(span, vec![s1, s2, s3], expr);\n-            let result = fld.cx.expr_block(block);\n-            fld.cx.bt_pop();\n-            result\n+            fld.cx.expr(span, ast::ExprBox(Some(placer), value_expr))\n         }\n \n-        // Issue #22181:\n-        // Eventually a desugaring for `box EXPR`\n-        // (similar to the desugaring above for `in PLACE BLOCK`)\n-        // should go here, desugaring\n-        //\n-        // to:\n-        //\n-        // let mut place = BoxPlace::make_place();\n-        // let raw_place = Place::pointer(&mut place);\n-        // let value = $value;\n-        // unsafe {\n-        //     ::std::ptr::write(raw_place, value);\n-        //     Boxed::finalize(place)\n-        // }\n-        //\n-        // But for now there are type-inference issues doing that.\n-\n         ast::ExprWhile(cond, body, opt_ident) => {\n             let cond = fld.fold_expr(cond);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n@@ -225,6 +92,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n         }\n \n         ast::ExprForLoop(pat, head, body, opt_ident) => {\n+            let pat = fld.fold_pat(pat);\n             let head = fld.fold_expr(head);\n             let (body, opt_ident) = expand_loop_block(body, opt_ident, fld);\n             fld.cx.expr(span, ast::ExprForLoop(pat, head, body, opt_ident))\n@@ -247,25 +115,6 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             }, fld))\n         }\n     });\n-\n-    fn push_unsafe_expr(cx: &mut ExtCtxt, stmts: Vec<P<ast::Stmt>>,\n-                        expr: P<ast::Expr>, span: Span)\n-                        -> P<ast::Expr> {\n-        let rules = ast::PushUnsafeBlock(ast::CompilerGenerated);\n-        cx.expr_block(P(ast::Block {\n-            rules: rules, span: span, id: ast::DUMMY_NODE_ID,\n-            stmts: stmts, expr: Some(expr),\n-        }))\n-    }\n-\n-    fn pop_unsafe_expr(cx: &mut ExtCtxt, expr: P<ast::Expr>, span: Span)\n-                       -> P<ast::Expr> {\n-        let rules = ast::PopUnsafeBlock(ast::CompilerGenerated);\n-        cx.expr_block(P(ast::Block {\n-            rules: rules, span: span, id: ast::DUMMY_NODE_ID,\n-            stmts: vec![], expr: Some(expr),\n-        }))\n-    }\n }\n \n /// Expand a (not-ident-style) macro invocation. Returns the result"}]}