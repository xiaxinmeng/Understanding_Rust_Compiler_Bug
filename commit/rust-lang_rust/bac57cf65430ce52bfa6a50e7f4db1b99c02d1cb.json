{"sha": "bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhYzU3Y2Y2NTQzMGNlNTJiZmE2YTUwZTdmNGRiMWI5OWMwMmQxY2I=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-24T11:54:18Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2017-07-31T13:13:10Z"}, "message": "async-llvm(3): Make write::CodegenContext Clone and Send.", "tree": {"sha": "2def5d20726f8bd6d469bc8df0a2f14e11b876fd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2def5d20726f8bd6d469bc8df0a2f14e11b876fd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb", "html_url": "https://github.com/rust-lang/rust/commit/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "29d4725b31bee27f025c17320f0eb59c5fc7af3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/29d4725b31bee27f025c17320f0eb59c5fc7af3b", "html_url": "https://github.com/rust-lang/rust/commit/29d4725b31bee27f025c17320f0eb59c5fc7af3b"}], "stats": {"total": 160, "additions": 78, "deletions": 82}, "files": [{"sha": "e160d6b6c6ab32d0140416054456f826b5e6657f", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb", "patch": "@@ -12,7 +12,7 @@ use back::link;\n use back::write;\n use back::symbol_export;\n use rustc::session::config;\n-use errors::FatalError;\n+use errors::{FatalError, Handler};\n use llvm;\n use llvm::archive_ro::ArchiveRO;\n use llvm::{ModuleRef, TargetMachineRef, True, False};\n@@ -41,24 +41,24 @@ pub fn crate_type_allows_lto(crate_type: config::CrateType) -> bool {\n }\n \n pub fn run(cgcx: &CodegenContext,\n+           diag_handler: &Handler,\n            llmod: ModuleRef,\n            tm: TargetMachineRef,\n            config: &ModuleConfig,\n            temp_no_opt_bc_filename: &Path) -> Result<(), FatalError> {\n-    let handler = cgcx.handler;\n     if cgcx.opts.cg.prefer_dynamic {\n-        handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n-            .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n-                   supported with LTO\")\n-            .emit();\n+        diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n+                    .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n+                           supported with LTO\")\n+                    .emit();\n         return Err(FatalError)\n     }\n \n     // Make sure we actually can run LTO\n     for crate_type in cgcx.crate_types.iter() {\n         if !crate_type_allows_lto(*crate_type) {\n-            let e = handler.fatal(\"lto can only be run for executables, cdylibs and \\\n-                                   static library outputs\");\n+            let e = diag_handler.fatal(\"lto can only be run for executables, cdylibs and \\\n+                                        static library outputs\");\n             return Err(e)\n         }\n     }\n@@ -116,13 +116,13 @@ pub fn run(cgcx: &CodegenContext,\n                         if res.is_err() {\n                             let msg = format!(\"failed to decompress bc of `{}`\",\n                                               name);\n-                            Err(handler.fatal(&msg))\n+                            Err(diag_handler.fatal(&msg))\n                         } else {\n                             Ok(inflated)\n                         }\n                     } else {\n-                        Err(handler.fatal(&format!(\"Unsupported bytecode format version {}\",\n-                                                   version)))\n+                        Err(diag_handler.fatal(&format!(\"Unsupported bytecode format version {}\",\n+                                                        version)))\n                     }\n                 })?\n             } else {\n@@ -136,7 +136,7 @@ pub fn run(cgcx: &CodegenContext,\n                     if res.is_err() {\n                         let msg = format!(\"failed to decompress bc of `{}`\",\n                                           name);\n-                        Err(handler.fatal(&msg))\n+                        Err(diag_handler.fatal(&msg))\n                     } else {\n                         Ok(inflated)\n                     }\n@@ -152,7 +152,7 @@ pub fn run(cgcx: &CodegenContext,\n                     Ok(())\n                 } else {\n                     let msg = format!(\"failed to load bc of `{}`\", name);\n-                    Err(write::llvm_err(handler, msg))\n+                    Err(write::llvm_err(&diag_handler, msg))\n                 }\n             })?;\n         }"}, {"sha": "d2fc96828527035d9b5c4d08d6c1a52f38f361f2", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 65, "deletions": 69, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=bac57cf65430ce52bfa6a50e7f4db1b99c02d1cb", "patch": "@@ -282,6 +282,7 @@ impl ModuleConfig {\n }\n \n /// Additional resources used by optimize_and_codegen (not module specific)\n+#[derive(Clone)]\n pub struct CodegenContext<'a> {\n     // Resouces needed when running LTO\n     pub time_passes: bool,\n@@ -292,7 +293,7 @@ pub struct CodegenContext<'a> {\n     pub crate_types: Vec<config::CrateType>,\n     pub each_linked_rlib_for_lto: Vec<(CrateNum, PathBuf)>,\n     // Handler to use for diagnostics produced during codegen.\n-    pub handler: &'a Handler,\n+    pub diag_emitter: SharedEmitter,\n     // LLVM passes added by plugins.\n     pub plugin_passes: Vec<String>,\n     // LLVM optimizations for which we want to print remarks.\n@@ -303,20 +304,24 @@ pub struct CodegenContext<'a> {\n     // compiling incrementally\n     pub incr_comp_session_dir: Option<PathBuf>,\n     // Channel back to the main control thread to send messages to\n-    pub tx: Sender<Message>,\n+    pub coordinator_send: Sender<Message>,\n+}\n \n-    // Error messages...\n-    pub shared_emitter: SharedEmitter,\n+impl<'a> CodegenContext<'a> {\n+    fn create_diag_handler(&self) -> Handler {\n+        Handler::with_emitter(true, false, Box::new(self.diag_emitter.clone()))\n+    }\n }\n \n struct HandlerFreeVars<'a> {\n     cgcx: &'a CodegenContext<'a>,\n+    diag_handler: &'a Handler,\n }\n \n unsafe extern \"C\" fn report_inline_asm<'a, 'b>(cgcx: &'a CodegenContext<'a>,\n                                                msg: &'b str,\n                                                cookie: c_uint) {\n-    cgcx.shared_emitter.inline_asm_error(cookie as u32, msg.to_string());\n+    cgcx.diag_emitter.inline_asm_error(cookie as u32, msg.to_string());\n }\n \n unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n@@ -331,7 +336,7 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n }\n \n unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_void) {\n-    let HandlerFreeVars { cgcx, .. } = *(user as *const HandlerFreeVars);\n+    let HandlerFreeVars { cgcx, diag_handler, .. } = *(user as *const HandlerFreeVars);\n \n     match llvm::diagnostic::Diagnostic::unpack(info) {\n         llvm::diagnostic::InlineAsm(inline) => {\n@@ -347,7 +352,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n             };\n \n             if enabled {\n-                cgcx.handler.note_without_error(&format!(\"optimization {} for {} at {}:{}:{}: {}\",\n+                diag_handler.note_without_error(&format!(\"optimization {} for {} at {}:{}:{}: {}\",\n                                                 opt.kind.describe(),\n                                                 opt.pass_name,\n                                                 opt.filename,\n@@ -363,6 +368,7 @@ unsafe extern \"C\" fn diagnostic_handler(info: DiagnosticInfoRef, user: *mut c_vo\n \n // Unsafe due to LLVM calls.\n unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n+                               diag_handler: &Handler,\n                                mtrans: ModuleTranslation,\n                                mllvm: ModuleLlvm,\n                                config: ModuleConfig,\n@@ -375,6 +381,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n     let fv = HandlerFreeVars {\n         cgcx: cgcx,\n+        diag_handler: diag_handler,\n     };\n     let fv = &fv as *const HandlerFreeVars as *mut c_void;\n \n@@ -409,7 +416,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 llvm::PassKind::Function => fpm,\n                 llvm::PassKind::Module => mpm,\n                 llvm::PassKind::Other => {\n-                    cgcx.handler.err(\"Encountered LLVM pass kind we can't handle\");\n+                    diag_handler.err(\"Encountered LLVM pass kind we can't handle\");\n                     return true\n                 },\n             };\n@@ -429,20 +436,20 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         for pass in &config.passes {\n             if !addpass(pass) {\n-                cgcx.handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n+                diag_handler.warn(&format!(\"unknown pass `{}`, ignoring\",\n                                            pass));\n             }\n         }\n \n         for pass in &cgcx.plugin_passes {\n             if !addpass(pass) {\n-                cgcx.handler.err(&format!(\"a plugin asked for LLVM pass \\\n+                diag_handler.err(&format!(\"a plugin asked for LLVM pass \\\n                                            `{}` but LLVM does not \\\n                                            recognize it\", pass));\n             }\n         }\n \n-        cgcx.handler.abort_if_errors();\n+        diag_handler.abort_if_errors();\n \n         // Finally, run the actual optimization passes\n         time(config.time_passes, &format!(\"llvm function passes [{}]\", cgcx.worker), ||\n@@ -459,6 +466,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 let temp_no_opt_bc_filename =\n                     output_names.temp_path_ext(\"no-opt.lto.bc\", module_name);\n                 lto::run(cgcx,\n+                         diag_handler,\n                          llmod,\n                          tm,\n                          &config,\n@@ -564,7 +572,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n                 llmod\n             };\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &path,\n+                write_output_file(diag_handler, tm, cpm, llmod, &path,\n                                   llvm::FileType::AssemblyFile)\n             })?;\n             if config.emit_obj {\n@@ -574,7 +582,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n         if write_obj {\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n-                write_output_file(cgcx.handler, tm, cpm, llmod, &obj_out,\n+                write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                   llvm::FileType::ObjectFile)\n             })?;\n         }\n@@ -585,14 +593,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n     if copy_bc_to_obj {\n         debug!(\"copying bitcode {:?} to obj {:?}\", bc_out, obj_out);\n         if let Err(e) = link_or_copy(&bc_out, &obj_out) {\n-            cgcx.handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n+            diag_handler.err(&format!(\"failed to copy bitcode to object file: {}\", e));\n         }\n     }\n \n     if rm_bc {\n         debug!(\"removing_bitcode {:?}\", bc_out);\n         if let Err(e) = fs::remove_file(&bc_out) {\n-            cgcx.handler.err(&format!(\"failed to remove bitcode: {}\", e));\n+            diag_handler.err(&format!(\"failed to remove bitcode: {}\", e));\n         }\n     }\n \n@@ -991,11 +999,13 @@ fn build_work_item(sess: &Session,\n fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n     -> Result<(), FatalError>\n {\n+    let diag_handler = cgcx.create_diag_handler();\n     unsafe {\n         match work_item.mtrans.source {\n             ModuleSource::Translated(mllvm) => {\n                 debug!(\"llvm-optimizing {:?}\", work_item.mtrans.name);\n                 optimize_and_codegen(cgcx,\n+                                     &diag_handler,\n                                      work_item.mtrans,\n                                      mllvm,\n                                      work_item.config,\n@@ -1017,7 +1027,7 @@ fn execute_work_item(cgcx: &CodegenContext, work_item: WorkItem)\n                     match link_or_copy(&source_file, &obj_out) {\n                         Ok(_) => { }\n                         Err(err) => {\n-                            cgcx.handler.err(&format!(\"unable to copy {} to {}: {}\",\n+                            diag_handler.err(&format!(\"unable to copy {} to {}: {}\",\n                                                       source_file.display(),\n                                                       obj_out.display(),\n                                                       err));\n@@ -1069,6 +1079,30 @@ fn execute_work<'a>(sess: &'a Session,\n \n     let (shared_emitter, shared_emitter_main) = SharedEmitter::new();\n \n+    let mut each_linked_rlib_for_lto = Vec::new();\n+    drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n+        if link::ignored_for_lto(sess, cnum) {\n+            return\n+        }\n+        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n+    }));\n+\n+    let cgcx = CodegenContext {\n+        crate_types: sess.crate_types.borrow().clone(),\n+        each_linked_rlib_for_lto: each_linked_rlib_for_lto,\n+        lto: sess.lto(),\n+        no_landing_pads: sess.no_landing_pads(),\n+        opts: &sess.opts,\n+        time_passes: sess.time_passes(),\n+        exported_symbols: exported_symbols,\n+        plugin_passes: sess.plugin_llvm_passes.borrow().clone(),\n+        remark: sess.opts.cg.remark.clone(),\n+        worker: 0,\n+        incr_comp_session_dir: sess.incr_comp_session_dir_opt().map(|r| r.clone()),\n+        coordinator_send: tx.clone(),\n+        diag_emitter: shared_emitter.clone(),\n+    };\n+\n     // This is the \"main loop\" of parallel work happening for parallel codegen.\n     // It's here that we manage parallelism, schedule work, and work with\n     // messages coming from clients.\n@@ -1132,14 +1166,16 @@ fn execute_work<'a>(sess: &'a Session,\n         // parallelism slots and work left to spawn.\n         while work_items.len() > 0 && running < tokens.len() + 1 {\n             let item = work_items.pop().unwrap();\n-            let index = work_items.len();\n-            spawn_work(sess,\n-                       exported_symbols,\n+            let worker_index = work_items.len();\n+\n+            let cgcx = CodegenContext {\n+                worker: worker_index,\n+                .. cgcx.clone()\n+            };\n+\n+            spawn_work(cgcx,\n                        scope,\n-                       tx.clone(),\n-                       shared_emitter.clone(),\n-                       item,\n-                       index);\n+                       item);\n             running += 1;\n         }\n \n@@ -1178,71 +1214,31 @@ fn execute_work<'a>(sess: &'a Session,\n     sess.diagnostic().abort_if_errors();\n }\n \n-fn spawn_work<'a>(sess: &'a Session,\n-                  exported_symbols: &'a ExportedSymbols,\n+fn spawn_work<'a>(cgcx: CodegenContext<'a>,\n                   scope: &Scope<'a>,\n-                  tx: Sender<Message>,\n-                  emitter: SharedEmitter,\n-                  work: WorkItem,\n-                  idx: usize) {\n-    let plugin_passes = sess.plugin_llvm_passes.borrow().clone();\n-    let remark = sess.opts.cg.remark.clone();\n-    let incr_comp_session_dir = sess.incr_comp_session_dir_opt().map(|r| r.clone());\n+                  work: WorkItem) {\n     let depth = time_depth();\n-    let lto = sess.lto();\n-    let crate_types = sess.crate_types.borrow().clone();\n-    let mut each_linked_rlib_for_lto = Vec::new();\n-    drop(link::each_linked_rlib(sess, &mut |cnum, path| {\n-        if link::ignored_for_lto(sess, cnum) {\n-            return\n-        }\n-        each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n-    }));\n-    let time_passes = sess.time_passes();\n-    let no_landing_pads = sess.no_landing_pads();\n-    let opts = &sess.opts;\n \n     scope.spawn(move || {\n         set_time_depth(depth);\n \n         // Set up a destructor which will fire off a message that we're done as\n         // we exit.\n         struct Bomb {\n-            tx: Sender<Message>,\n+            coordinator_send: Sender<Message>,\n             success: bool,\n         }\n         impl Drop for Bomb {\n             fn drop(&mut self) {\n-                drop(self.tx.send(Message::Done { success: self.success }));\n+                drop(self.coordinator_send.send(Message::Done { success: self.success }));\n             }\n         }\n+\n         let mut bomb = Bomb {\n-            tx: tx.clone(),\n+            coordinator_send: cgcx.coordinator_send.clone(),\n             success: false,\n         };\n \n-        // Set up our non-`Send` `CodegenContext` now that we're in a helper\n-        // thread and have all our info available to us.\n-        // let emitter = SharedEmitter { tx: tx.clone() };\n-        let diag_handler = Handler::with_emitter(true, false, Box::new(emitter.clone()));\n-\n-        let cgcx = CodegenContext {\n-            crate_types: crate_types,\n-            each_linked_rlib_for_lto: each_linked_rlib_for_lto,\n-            lto: lto,\n-            no_landing_pads: no_landing_pads,\n-            opts: opts,\n-            time_passes: time_passes,\n-            exported_symbols: exported_symbols,\n-            handler: &diag_handler,\n-            plugin_passes: plugin_passes,\n-            remark: remark,\n-            worker: idx,\n-            incr_comp_session_dir: incr_comp_session_dir,\n-            tx: tx.clone(),\n-            shared_emitter: emitter,\n-        };\n-\n         // Execute the work itself, and if it finishes successfully then flag\n         // ourselves as a success as well.\n         //"}]}