{"sha": "6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiOTlhZGViMTEzMTMxOTdmNDA5YjRmN2M0MDgzYzJjZWNhOGE0ZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-27T10:56:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-01-27T10:56:56Z"}, "message": "Auto merge of #46450 - Gilnaa:libtest_json_output, r=nrc\n\nLibtest json output\n\nA revisit to my [last PR](https://github.com/rust-lang/rust/pull/45923).\n\nEvents are now more atomic, printed in a flat hierarchy.\n\nFor the normal test output:\n```\nrunning 1 test\ntest f ... FAILED\n\nfailures:\n\n---- f stdout ----\n\tthread 'f' panicked at 'assertion failed: `(left == right)`\n  left: `3`,\n right: `4`', f.rs:3:1\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\nfailures:\n    f\n\ntest result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out\n```\n\nThe JSON equivalent is:\n```\n{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"1\" }\n{ \"type\": \"test\", \"event\": \"started\", \"name\": \"f\" }\n{ \"type\": \"test\", \"event\": \"failed\", \"name\": \"f\" }\n{ \"type\": \"suite\", \"event\": \"failed\", \"passed\": 0, \"failed\": 1, \"allowed_fail\": 0, \"ignored\": 0,  \"measured\": 0, \"filtered_out\": \"0\" }\n{ \"type\": \"test_output\", \"name\": \"f\", \"output\": \"thread 'f' panicked at 'assertion failed: `(left == right)`\n  left: `3`,\n right: `4`', f.rs:3:1\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\n\" }\n```", "tree": {"sha": "fa4cadc9518948a7d9f643f55585eb5f2ffa5f40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa4cadc9518948a7d9f643f55585eb5f2ffa5f40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "html_url": "https://github.com/rust-lang/rust/commit/6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6272b60dcaae2e69c991fc64cfb2e403c8a616a3", "url": "https://api.github.com/repos/rust-lang/rust/commits/6272b60dcaae2e69c991fc64cfb2e403c8a616a3", "html_url": "https://github.com/rust-lang/rust/commit/6272b60dcaae2e69c991fc64cfb2e403c8a616a3"}, {"sha": "8b7f1d0cec3884e07e2dd9ea4d0d4faeda5b95ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b7f1d0cec3884e07e2dd9ea4d0d4faeda5b95ed", "html_url": "https://github.com/rust-lang/rust/commit/8b7f1d0cec3884e07e2dd9ea4d0d4faeda5b95ed"}], "stats": {"total": 2465, "additions": 1711, "deletions": 754}, "files": [{"sha": "d323d50f702ba9d3d16c5a2869f76d14c8ff5ba8", "filename": "src/libtest/formatters/json.rs", "status": "added", "additions": 229, "deletions": 0, "changes": 229, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -0,0 +1,229 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub(crate) struct JsonFormatter<T> {\n+    out: OutputLocation<T>,\n+}\n+\n+impl<T: Write> JsonFormatter<T> {\n+    pub fn new(out: OutputLocation<T>) -> Self {\n+        Self { out }\n+    }\n+\n+    fn write_message(&mut self, s: &str) -> io::Result<()> {\n+        assert!(!s.contains('\\n'));\n+\n+        self.out.write_all(s.as_ref())?;\n+        self.out.write_all(b\"\\n\")\n+    }\n+\n+    fn write_event(\n+        &mut self,\n+        ty: &str,\n+        name: &str,\n+        evt: &str,\n+        extra: Option<String>,\n+    ) -> io::Result<()> {\n+        if let Some(extras) = extra {\n+            self.write_message(&*format!(\n+                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n+                ty,\n+                name,\n+                evt,\n+                extras\n+            ))\n+        } else {\n+            self.write_message(&*format!(\n+                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n+                ty,\n+                name,\n+                evt\n+            ))\n+        }\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for JsonFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"{}\" }}\"#,\n+            test_count\n+        ))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n+            desc.name\n+        ))\n+    }\n+\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        stdout: &[u8],\n+    ) -> io::Result<()> {\n+        match *result {\n+            TrOk => self.write_event(\"test\", desc.name.as_slice(), \"ok\", None),\n+\n+            TrFailed => {\n+                let extra_data = if stdout.len() > 0 {\n+                    Some(format!(\n+                        r#\"\"stdout\": \"{}\"\"#,\n+                        EscapedString(String::from_utf8_lossy(stdout))\n+                    ))\n+                } else {\n+                    None\n+                };\n+\n+                self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n+            }\n+\n+            TrFailedMsg(ref m) => {\n+                self.write_event(\n+                    \"test\",\n+                    desc.name.as_slice(),\n+                    \"failed\",\n+                    Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n+                )\n+            }\n+\n+            TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None),\n+\n+            TrAllowedFail => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", None)\n+            }\n+\n+            TrBench(ref bs) => {\n+                let median = bs.ns_iter_summ.median as usize;\n+                let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n+\n+                let mbps = if bs.mb_s == 0 {\n+                    \"\".into()\n+                } else {\n+                    format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n+                };\n+\n+                let line = format!(\n+                    \"{{ \\\"type\\\": \\\"bench\\\", \\\n+                                \\\"name\\\": \\\"{}\\\", \\\n+                                \\\"median\\\": {}, \\\n+                                \\\"deviation\\\": {}{} }}\",\n+                    desc.name,\n+                    median,\n+                    deviation,\n+                    mbps\n+                );\n+\n+                self.write_message(&*line)\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n+            desc.name\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+\n+        self.write_message(&*format!(\n+            \"{{ \\\"type\\\": \\\"suite\\\", \\\n+            \\\"event\\\": \\\"{}\\\", \\\n+            \\\"passed\\\": {}, \\\n+            \\\"failed\\\": {}, \\\n+            \\\"allowed_fail\\\": {}, \\\n+            \\\"ignored\\\": {}, \\\n+            \\\"measured\\\": {}, \\\n+            \\\"filtered_out\\\": \\\"{}\\\" }}\",\n+            if state.failed == 0 { \"ok\" } else { \"failed\" },\n+            state.passed,\n+            state.failed + state.allowed_fail,\n+            state.allowed_fail,\n+            state.ignored,\n+            state.measured,\n+            state.filtered_out\n+        ))?;\n+\n+        Ok(state.failed == 0)\n+    }\n+}\n+\n+/// A formatting utility used to print strings with characters in need of escaping.\n+/// Base code taken form `libserialize::json::escape_str`\n+struct EscapedString<S: AsRef<str>>(S);\n+\n+impl<S: AsRef<str>> ::std::fmt::Display for EscapedString<S> {\n+    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+        let mut start = 0;\n+\n+        for (i, byte) in self.0.as_ref().bytes().enumerate() {\n+            let escaped = match byte {\n+                b'\"' => \"\\\\\\\"\",\n+                b'\\\\' => \"\\\\\\\\\",\n+                b'\\x00' => \"\\\\u0000\",\n+                b'\\x01' => \"\\\\u0001\",\n+                b'\\x02' => \"\\\\u0002\",\n+                b'\\x03' => \"\\\\u0003\",\n+                b'\\x04' => \"\\\\u0004\",\n+                b'\\x05' => \"\\\\u0005\",\n+                b'\\x06' => \"\\\\u0006\",\n+                b'\\x07' => \"\\\\u0007\",\n+                b'\\x08' => \"\\\\b\",\n+                b'\\t' => \"\\\\t\",\n+                b'\\n' => \"\\\\n\",\n+                b'\\x0b' => \"\\\\u000b\",\n+                b'\\x0c' => \"\\\\f\",\n+                b'\\r' => \"\\\\r\",\n+                b'\\x0e' => \"\\\\u000e\",\n+                b'\\x0f' => \"\\\\u000f\",\n+                b'\\x10' => \"\\\\u0010\",\n+                b'\\x11' => \"\\\\u0011\",\n+                b'\\x12' => \"\\\\u0012\",\n+                b'\\x13' => \"\\\\u0013\",\n+                b'\\x14' => \"\\\\u0014\",\n+                b'\\x15' => \"\\\\u0015\",\n+                b'\\x16' => \"\\\\u0016\",\n+                b'\\x17' => \"\\\\u0017\",\n+                b'\\x18' => \"\\\\u0018\",\n+                b'\\x19' => \"\\\\u0019\",\n+                b'\\x1a' => \"\\\\u001a\",\n+                b'\\x1b' => \"\\\\u001b\",\n+                b'\\x1c' => \"\\\\u001c\",\n+                b'\\x1d' => \"\\\\u001d\",\n+                b'\\x1e' => \"\\\\u001e\",\n+                b'\\x1f' => \"\\\\u001f\",\n+                b'\\x7f' => \"\\\\u007f\",\n+                _ => {\n+                    continue;\n+                }\n+            };\n+\n+            if start < i {\n+                f.write_str(&self.0.as_ref()[start..i])?;\n+            }\n+\n+            f.write_str(escaped)?;\n+\n+            start = i + 1;\n+        }\n+\n+        if start != self.0.as_ref().len() {\n+            f.write_str(&self.0.as_ref()[start..])?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "24c7929076c1db4a6579b1b7cceda93b9dcf4b46", "filename": "src/libtest/formatters/mod.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+mod pretty;\n+mod json;\n+mod terse;\n+\n+pub(crate) use self::pretty::PrettyFormatter;\n+pub(crate) use self::json::JsonFormatter;\n+pub(crate) use self::terse::TerseFormatter;\n+\n+pub(crate) trait OutputFormatter {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()>;\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        stdout: &[u8],\n+    ) -> io::Result<()>;\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n+}"}, {"sha": "f2064deefce621f2ffa7945244e89b3905b1e443", "filename": "src/libtest/formatters/pretty.rs", "status": "added", "additions": 247, "deletions": 0, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -0,0 +1,247 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub(crate) struct PrettyFormatter<T> {\n+    out: OutputLocation<T>,\n+    use_color: bool,\n+\n+    /// Number of columns to fill when aligning names\n+    max_name_len: usize,\n+\n+    is_multithreaded: bool,\n+}\n+\n+impl<T: Write> PrettyFormatter<T> {\n+    pub fn new(\n+        out: OutputLocation<T>,\n+        use_color: bool,\n+        max_name_len: usize,\n+        is_multithreaded: bool,\n+    ) -> Self {\n+        PrettyFormatter {\n+            out,\n+            use_color,\n+            max_name_len,\n+            is_multithreaded,\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    pub fn output_location(&self) -> &OutputLocation<T> {\n+        &self.out\n+    }\n+\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ok\", term::color::GREEN)\n+    }\n+\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED\", term::color::RED)\n+    }\n+\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ignored\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_bench(&mut self) -> io::Result<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n+    }\n+\n+    pub fn write_short_result(\n+        &mut self,\n+        result: &str,\n+        color: term::color::Color,\n+    ) -> io::Result<()> {\n+        self.write_pretty(result, color)?;\n+        self.write_plain(\"\\n\")\n+    }\n+\n+    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n+        match self.out {\n+            Pretty(ref mut term) => {\n+                if self.use_color {\n+                    term.fg(color)?;\n+                }\n+                term.write_all(word.as_bytes())?;\n+                if self.use_color {\n+                    term.reset()?;\n+                }\n+                term.flush()\n+            }\n+            Raw(ref mut stdout) => {\n+                stdout.write_all(word.as_bytes())?;\n+                stdout.flush()\n+            }\n+        }\n+    }\n+\n+    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n+        let s = s.as_ref();\n+        self.out.write_all(s.as_bytes())?;\n+        self.out.flush()\n+    }\n+\n+    pub fn write_successes(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &state.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        let mut failures = Vec::new();\n+        let mut fail_out = String::new();\n+        for &(ref f, ref stdout) in &state.failures {\n+            failures.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                fail_out.push_str(&output);\n+                fail_out.push_str(\"\\n\");\n+            }\n+        }\n+        if !fail_out.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&fail_out)?;\n+        }\n+\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        failures.sort();\n+        for name in &failures {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n+        self.write_plain(&format!(\"test {} ... \", name))?;\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        // When running tests concurrently, we should not print\n+        // the test's name as the result will be mis-aligned.\n+        // When running the tests serially, we print the name here so\n+        // that the user can see which test hangs.\n+        if !self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+        if self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        match *result {\n+            TrOk => self.write_ok(),\n+            TrFailed | TrFailedMsg(_) => self.write_failed(),\n+            TrIgnored => self.write_ignored(),\n+            TrAllowedFail => self.write_allowed_fail(),\n+            TrBench(ref bs) => {\n+                self.write_bench()?;\n+                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        if self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        self.write_plain(&format!(\n+            \"test {} has been running for over {} seconds\\n\",\n+            desc.name,\n+            TEST_WARN_TIMEOUT_S\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        if state.options.display_output {\n+            self.write_successes(state)?;\n+        }\n+        let success = state.failed == 0;\n+        if !success {\n+            self.write_failures(state)?;\n+        }\n+\n+        self.write_plain(\"\\ntest result: \")?;\n+\n+        if success {\n+            // There's no parallelism at this point so it's safe to use color\n+            self.write_pretty(\"ok\", term::color::GREEN)?;\n+        } else {\n+            self.write_pretty(\"FAILED\", term::color::RED)?;\n+        }\n+\n+        let s = if state.allowed_fail > 0 {\n+            format!(\n+                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed + state.allowed_fail,\n+                state.allowed_fail,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        } else {\n+            format!(\n+                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        };\n+\n+        self.write_plain(&s)?;\n+\n+        Ok(success)\n+    }\n+}"}, {"sha": "88689485144c0d9a9968486ee23076313d1c07e0", "filename": "src/libtest/formatters/terse.rs", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -0,0 +1,246 @@\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use super::*;\n+\n+pub(crate) struct TerseFormatter<T> {\n+    out: OutputLocation<T>,\n+    use_color: bool,\n+    is_multithreaded: bool,\n+    /// Number of columns to fill when aligning names\n+    max_name_len: usize,\n+\n+    test_count: usize,\n+}\n+\n+impl<T: Write> TerseFormatter<T> {\n+    pub fn new(\n+        out: OutputLocation<T>,\n+        use_color: bool,\n+        max_name_len: usize,\n+        is_multithreaded: bool,\n+    ) -> Self {\n+        TerseFormatter {\n+            out,\n+            use_color,\n+            max_name_len,\n+            is_multithreaded,\n+            test_count: 0,\n+        }\n+    }\n+\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n+        self.write_short_result(\".\", term::color::GREEN)\n+    }\n+\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"F\", term::color::RED)\n+    }\n+\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"i\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"a\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_bench(&mut self) -> io::Result<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n+    }\n+\n+    pub fn write_short_result(\n+        &mut self,\n+        result: &str,\n+        color: term::color::Color,\n+    ) -> io::Result<()> {\n+        self.write_pretty(result, color)?;\n+        if self.test_count % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n+            // we insert a new line every 100 dots in order to flush the\n+            // screen when dealing with line-buffered output (e.g. piping to\n+            // `stamp` in the rust CI).\n+            self.write_plain(\"\\n\")?;\n+        }\n+\n+        self.test_count += 1;\n+        Ok(())\n+    }\n+\n+    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n+        match self.out {\n+            Pretty(ref mut term) => {\n+                if self.use_color {\n+                    term.fg(color)?;\n+                }\n+                term.write_all(word.as_bytes())?;\n+                if self.use_color {\n+                    term.reset()?;\n+                }\n+                term.flush()\n+            }\n+            Raw(ref mut stdout) => {\n+                stdout.write_all(word.as_bytes())?;\n+                stdout.flush()\n+            }\n+        }\n+    }\n+\n+    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n+        let s = s.as_ref();\n+        self.out.write_all(s.as_bytes())?;\n+        self.out.flush()\n+    }\n+\n+    pub fn write_outputs(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &state.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        let mut failures = Vec::new();\n+        let mut fail_out = String::new();\n+        for &(ref f, ref stdout) in &state.failures {\n+            failures.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                fail_out.push_str(&output);\n+                fail_out.push_str(\"\\n\");\n+            }\n+        }\n+        if !fail_out.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&fail_out)?;\n+        }\n+\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        failures.sort();\n+        for name in &failures {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n+        self.write_plain(&format!(\"test {} ... \", name))?;\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for TerseFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        // Remnants from old libtest code that used the padding value\n+        // in order to indicate benchmarks.\n+        // When running benchmarks, terse-mode should still print their name as if\n+        // it is the Pretty formatter.\n+        if !self.is_multithreaded && desc.name.padding() == PadOnRight {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+        match *result {\n+            TrOk => self.write_ok(),\n+            TrFailed | TrFailedMsg(_) => self.write_failed(),\n+            TrIgnored => self.write_ignored(),\n+            TrAllowedFail => self.write_allowed_fail(),\n+            TrBench(ref bs) => {\n+                if self.is_multithreaded {\n+                    self.write_test_name(desc)?;\n+                }\n+                self.write_bench()?;\n+                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_plain(&format!(\n+            \"test {} has been running for over {} seconds\\n\",\n+            desc.name,\n+            TEST_WARN_TIMEOUT_S\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        if state.options.display_output {\n+            self.write_outputs(state)?;\n+        }\n+        let success = state.failed == 0;\n+        if !success {\n+            self.write_failures(state)?;\n+        }\n+\n+        self.write_plain(\"\\ntest result: \")?;\n+\n+        if success {\n+            // There's no parallelism at this point so it's safe to use color\n+            self.write_pretty(\"ok\", term::color::GREEN)?;\n+        } else {\n+            self.write_pretty(\"FAILED\", term::color::RED)?;\n+        }\n+\n+        let s = if state.allowed_fail > 0 {\n+            format!(\n+                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed + state.allowed_fail,\n+                state.allowed_fail,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        } else {\n+            format!(\n+                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        };\n+\n+        self.write_plain(&s)?;\n+\n+        Ok(success)\n+    }\n+}"}, {"sha": "ffa27688cf1a70d4ac71face0478209e5736bb82", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 618, "deletions": 511, "changes": 1129, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2017 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -71,6 +71,7 @@ use std::sync::mpsc::{channel, Sender};\n use std::sync::{Arc, Mutex};\n use std::thread;\n use std::time::{Instant, Duration};\n+use std::borrow::Cow;\n \n const TEST_WARN_TIMEOUT_S: u64 = 60;\n const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n@@ -84,6 +85,9 @@ pub mod test {\n }\n \n pub mod stats;\n+mod formatters;\n+\n+use formatters::{OutputFormatter, PrettyFormatter, TerseFormatter, JsonFormatter};\n \n // The name of a test. By convention this follows the rules for rust\n // paths; i.e. it should be a series of identifiers separated by double\n@@ -94,22 +98,41 @@ pub mod stats;\n pub enum TestName {\n     StaticTestName(&'static str),\n     DynTestName(String),\n+    AlignedTestName(Cow<'static, str>, NamePadding),\n }\n impl TestName {\n     fn as_slice(&self) -> &str {\n         match *self {\n             StaticTestName(s) => s,\n             DynTestName(ref s) => s,\n+            AlignedTestName(ref s, _) => &*s,\n         }\n     }\n+\n+    fn padding(&self) -> NamePadding {\n+        match self {\n+            &AlignedTestName(_, p) => p,\n+            _ => PadNone,\n+        }\n+    }\n+\n+    fn with_padding(&self, padding: NamePadding) -> TestName {\n+        let name = match self {\n+            &TestName::StaticTestName(name) => Cow::Borrowed(name),\n+            &TestName::DynTestName(ref name) => Cow::Owned(name.clone()),\n+            &TestName::AlignedTestName(ref name, _) => name.clone(),\n+        };\n+\n+        TestName::AlignedTestName(name, padding)\n+    }\n }\n impl fmt::Display for TestName {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(self.as_slice(), f)\n     }\n }\n \n-#[derive(Clone, Copy, PartialEq, Eq)]\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n pub enum NamePadding {\n     PadNone,\n     PadOnRight,\n@@ -217,10 +240,7 @@ pub struct Metric {\n \n impl Metric {\n     pub fn new(value: f64, noise: f64) -> Metric {\n-        Metric {\n-            value,\n-            noise,\n-        }\n+        Metric { value, noise }\n     }\n }\n \n@@ -232,9 +252,7 @@ pub struct Options {\n \n impl Options {\n     pub fn new() -> Options {\n-        Options {\n-            display_output: false,\n-        }\n+        Options { display_output: false }\n     }\n \n     pub fn display_output(mut self, display_output: bool) -> Options {\n@@ -274,25 +292,24 @@ pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n // rather than a &[].\n pub fn test_main_static(tests: &[TestDescAndFn]) {\n     let args = env::args().collect::<Vec<_>>();\n-    let owned_tests = tests.iter()\n-                           .map(|t| {\n-                               match t.testfn {\n-                                   StaticTestFn(f) => {\n-                                       TestDescAndFn {\n-                                           testfn: StaticTestFn(f),\n-                                           desc: t.desc.clone(),\n-                                       }\n-                                   }\n-                                   StaticBenchFn(f) => {\n-                                       TestDescAndFn {\n-                                           testfn: StaticBenchFn(f),\n-                                           desc: t.desc.clone(),\n-                                       }\n-                                   }\n-                                   _ => panic!(\"non-static tests passed to test::test_main_static\"),\n-                               }\n-                           })\n-                           .collect();\n+    let owned_tests = tests\n+        .iter()\n+        .map(|t| match t.testfn {\n+            StaticTestFn(f) => {\n+                TestDescAndFn {\n+                    testfn: StaticTestFn(f),\n+                    desc: t.desc.clone(),\n+                }\n+            }\n+            StaticBenchFn(f) => {\n+                TestDescAndFn {\n+                    testfn: StaticBenchFn(f),\n+                    desc: t.desc.clone(),\n+                }\n+            }\n+            _ => panic!(\"non-static tests passed to test::test_main_static\"),\n+        })\n+        .collect();\n     test_main(&args, owned_tests, Options::new())\n }\n \n@@ -303,6 +320,13 @@ pub enum ColorConfig {\n     NeverColor,\n }\n \n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum OutputFormat {\n+    Pretty,\n+    Terse,\n+    Json,\n+}\n+\n #[derive(Debug)]\n pub struct TestOpts {\n     pub list: bool,\n@@ -314,7 +338,7 @@ pub struct TestOpts {\n     pub logfile: Option<PathBuf>,\n     pub nocapture: bool,\n     pub color: ColorConfig,\n-    pub quiet: bool,\n+    pub format: OutputFormat,\n     pub test_threads: Option<usize>,\n     pub skip: Vec<String>,\n     pub options: Options,\n@@ -333,7 +357,7 @@ impl TestOpts {\n             logfile: None,\n             nocapture: false,\n             color: AutoColor,\n-            quiet: false,\n+            format: OutputFormat::Pretty,\n             test_threads: None,\n             skip: vec![],\n             options: Options::new(),\n@@ -351,26 +375,76 @@ fn optgroups() -> getopts::Options {\n         .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n         .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n         .optflag(\"h\", \"help\", \"Display this message (longer with --help)\")\n-        .optopt(\"\", \"logfile\", \"Write logs to the specified file instead \\\n-                                of stdout\", \"PATH\")\n-        .optflag(\"\", \"nocapture\", \"don't capture stdout/stderr of each \\\n-                                   task, allow printing directly\")\n-        .optopt(\"\", \"test-threads\", \"Number of threads used for running tests \\\n-                                     in parallel\", \"n_threads\")\n-        .optmulti(\"\", \"skip\", \"Skip tests whose names contain FILTER (this flag can \\\n-                               be used multiple times)\",\"FILTER\")\n-        .optflag(\"q\", \"quiet\", \"Display one character per test instead of one line\")\n-        .optflag(\"\", \"exact\", \"Exactly match filters rather than by substring\")\n-        .optopt(\"\", \"color\", \"Configure coloring of output:\n+        .optopt(\n+            \"\",\n+            \"logfile\",\n+            \"Write logs to the specified file instead \\\n+                                of stdout\",\n+            \"PATH\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"nocapture\",\n+            \"don't capture stdout/stderr of each \\\n+                                   task, allow printing directly\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"test-threads\",\n+            \"Number of threads used for running tests \\\n+                                     in parallel\",\n+            \"n_threads\",\n+        )\n+        .optmulti(\n+            \"\",\n+            \"skip\",\n+            \"Skip tests whose names contain FILTER (this flag can \\\n+                               be used multiple times)\",\n+            \"FILTER\",\n+        )\n+        .optflag(\n+            \"q\",\n+            \"quiet\",\n+            \"Display one character per test instead of one line. \\\n+                                Alias to --format=terse\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"exact\",\n+            \"Exactly match filters rather than by substring\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"color\",\n+            \"Configure coloring of output:\n             auto   = colorize if stdout is a tty and tests are run on serially (default);\n             always = always colorize output;\n-            never  = never colorize output;\", \"auto|always|never\");\n-    return opts\n+            never  = never colorize output;\",\n+            \"auto|always|never\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"format\",\n+            \"Configure formatting of output:\n+            pretty = Print verbose output;\n+            terse  = Display one character per test;\n+            json   = Output a json document\",\n+            \"pretty|terse|json\",\n+        )\n+        .optopt(\n+            \"Z\",\n+            \"\",\n+            \"Enable nightly-only flags:\n+            unstable-options = Allow use of experimental features\",\n+            \"unstable-options\",\n+        );\n+    return opts;\n }\n \n fn usage(binary: &str, options: &getopts::Options) {\n     let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n-    println!(r#\"{usage}\n+    println!(\n+        r#\"{usage}\n \n The FILTER string is tested against the name of all tests, and only those\n tests whose names contain the filter are run.\n@@ -397,18 +471,48 @@ Test Attributes:\n                      test, then the test runner will ignore these tests during\n                      normal test runs. Running with --ignored will run these\n                      tests.\"#,\n-             usage = options.usage(&message));\n+        usage = options.usage(&message)\n+    );\n+}\n+\n+// FIXME: Copied from libsyntax until linkage errors are resolved. Issue #47566\n+fn is_nightly() -> bool {\n+    // Whether this is a feature-staged build, i.e. on the beta or stable channel\n+    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+    // Whether we should enable unstable features for bootstrapping\n+    let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+\n+    bootstrap || !disable_unstable_features\n }\n \n // Parses command line arguments into test options\n pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n+    let mut allow_unstable = false;\n     let opts = optgroups();\n     let args = args.get(1..).unwrap_or(args);\n     let matches = match opts.parse(args) {\n         Ok(m) => m,\n         Err(f) => return Some(Err(f.to_string())),\n     };\n \n+    if let Some(opt) = matches.opt_str(\"Z\") {\n+        if !is_nightly() {\n+            return Some(Err(\n+                \"the option `Z` is only accepted on the nightly compiler\"\n+                    .into(),\n+            ));\n+        }\n+\n+        match &*opt {\n+            \"unstable-options\" => {\n+                allow_unstable = true;\n+            }\n+            _ => {\n+                return Some(Err(\"Unrecognized option to `Z`\".into()));\n+            }\n+        }\n+    };\n+\n     if matches.opt_present(\"h\") {\n         usage(&args[0], &opts);\n         return None;\n@@ -435,22 +539,25 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n     if !nocapture {\n         nocapture = match env::var(\"RUST_TEST_NOCAPTURE\") {\n             Ok(val) => &val != \"0\",\n-            Err(_) => false\n+            Err(_) => false,\n         };\n     }\n \n     let test_threads = match matches.opt_str(\"test-threads\") {\n-        Some(n_str) =>\n+        Some(n_str) => {\n             match n_str.parse::<usize>() {\n-                Ok(0) =>\n-                    return Some(Err(format!(\"argument for --test-threads must not be 0\"))),\n+                Ok(0) => return Some(Err(format!(\"argument for --test-threads must not be 0\"))),\n                 Ok(n) => Some(n),\n-                Err(e) =>\n-                    return Some(Err(format!(\"argument for --test-threads must be a number > 0 \\\n-                                             (error: {})\", e)))\n-            },\n-        None =>\n-            None,\n+                Err(e) => {\n+                    return Some(Err(format!(\n+                        \"argument for --test-threads must be a number > 0 \\\n+                                             (error: {})\",\n+                        e\n+                    )))\n+                }\n+            }\n+        }\n+        None => None,\n     };\n \n     let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n@@ -459,9 +566,34 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         Some(\"never\") => NeverColor,\n \n         Some(v) => {\n-            return Some(Err(format!(\"argument for --color must be auto, always, or never (was \\\n+            return Some(Err(format!(\n+                \"argument for --color must be auto, always, or never (was \\\n+                                     {})\",\n+                v\n+            )))\n+        }\n+    };\n+\n+    let format = match matches.opt_str(\"format\").as_ref().map(|s| &**s) {\n+        None if quiet => OutputFormat::Terse,\n+        Some(\"pretty\") | None => OutputFormat::Pretty,\n+        Some(\"terse\") => OutputFormat::Terse,\n+        Some(\"json\") => {\n+            if !allow_unstable {\n+                return Some(Err(\n+                    \"The \\\"json\\\" format is only accepted on the nightly compiler\"\n+                        .into(),\n+                ));\n+            }\n+            OutputFormat::Json\n+        }\n+\n+        Some(v) => {\n+            return Some(Err(format!(\n+                \"argument for --format must be pretty, terse, or json (was \\\n                                      {})\",\n-                                    v)))\n+                v\n+            )))\n         }\n     };\n \n@@ -475,7 +607,7 @@ pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n         logfile,\n         nocapture,\n         color,\n-        quiet,\n+        format,\n         test_threads,\n         skip: matches.opt_strs(\"skip\"),\n         options: Options::new(),\n@@ -507,11 +639,24 @@ enum OutputLocation<T> {\n     Raw(T),\n }\n \n-struct ConsoleTestState<T> {\n+impl<T: Write> Write for OutputLocation<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        match *self {\n+            Pretty(ref mut term) => term.write(buf),\n+            Raw(ref mut stdout) => stdout.write(buf),\n+        }\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        match *self {\n+            Pretty(ref mut term) => term.flush(),\n+            Raw(ref mut stdout) => stdout.flush(),\n+        }\n+    }\n+}\n+\n+struct ConsoleTestState {\n     log_out: Option<File>,\n-    out: OutputLocation<T>,\n-    use_color: bool,\n-    quiet: bool,\n     total: usize,\n     passed: usize,\n     failed: usize,\n@@ -522,26 +667,18 @@ struct ConsoleTestState<T> {\n     metrics: MetricMap,\n     failures: Vec<(TestDesc, Vec<u8>)>,\n     not_failures: Vec<(TestDesc, Vec<u8>)>,\n-    max_name_len: usize, // number of columns to fill when aligning names\n     options: Options,\n }\n \n-impl<T: Write> ConsoleTestState<T> {\n-    pub fn new(opts: &TestOpts, _: Option<T>) -> io::Result<ConsoleTestState<io::Stdout>> {\n+impl ConsoleTestState {\n+    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n         let log_out = match opts.logfile {\n             Some(ref path) => Some(File::create(path)?),\n             None => None,\n         };\n-        let out = match term::stdout() {\n-            None => Raw(io::stdout()),\n-            Some(t) => Pretty(t),\n-        };\n \n         Ok(ConsoleTestState {\n-            out,\n             log_out,\n-            use_color: use_color(opts),\n-            quiet: opts.quiet,\n             total: 0,\n             passed: 0,\n             failed: 0,\n@@ -552,119 +689,10 @@ impl<T: Write> ConsoleTestState<T> {\n             metrics: MetricMap::new(),\n             failures: Vec::new(),\n             not_failures: Vec::new(),\n-            max_name_len: 0,\n             options: opts.options,\n         })\n     }\n \n-    pub fn write_ok(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"ok\", \".\", term::color::GREEN)\n-    }\n-\n-    pub fn write_failed(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"FAILED\", \"F\", term::color::RED)\n-    }\n-\n-    pub fn write_ignored(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"ignored\", \"i\", term::color::YELLOW)\n-    }\n-\n-    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n-        self.write_short_result(\"FAILED (allowed)\", \"a\", term::color::YELLOW)\n-    }\n-\n-    pub fn write_bench(&mut self) -> io::Result<()> {\n-        self.write_pretty(\"bench\", term::color::CYAN)\n-    }\n-\n-    pub fn write_short_result(&mut self, verbose: &str, quiet: &str, color: term::color::Color)\n-                              -> io::Result<()> {\n-        if self.quiet {\n-            self.write_pretty(quiet, color)?;\n-            if self.current_test_count() % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n-                // we insert a new line every 100 dots in order to flush the\n-                // screen when dealing with line-buffered output (e.g. piping to\n-                // `stamp` in the rust CI).\n-                self.write_plain(\"\\n\")?;\n-            }\n-            Ok(())\n-        } else {\n-            self.write_pretty(verbose, color)?;\n-            self.write_plain(\"\\n\")\n-        }\n-    }\n-\n-    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n-        match self.out {\n-            Pretty(ref mut term) => {\n-                if self.use_color {\n-                    term.fg(color)?;\n-                }\n-                term.write_all(word.as_bytes())?;\n-                if self.use_color {\n-                    term.reset()?;\n-                }\n-                term.flush()\n-            }\n-            Raw(ref mut stdout) => {\n-                stdout.write_all(word.as_bytes())?;\n-                stdout.flush()\n-            }\n-        }\n-    }\n-\n-    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n-        let s = s.as_ref();\n-        match self.out {\n-            Pretty(ref mut term) => {\n-                term.write_all(s.as_bytes())?;\n-                term.flush()\n-            }\n-            Raw(ref mut stdout) => {\n-                stdout.write_all(s.as_bytes())?;\n-                stdout.flush()\n-            }\n-        }\n-    }\n-\n-    pub fn write_run_start(&mut self, len: usize) -> io::Result<()> {\n-        self.total = len;\n-        let noun = if len != 1 {\n-            \"tests\"\n-        } else {\n-            \"test\"\n-        };\n-        self.write_plain(&format!(\"\\nrunning {} {}\\n\", len, noun))\n-    }\n-\n-    pub fn write_test_start(&mut self, test: &TestDesc, align: NamePadding) -> io::Result<()> {\n-        if self.quiet && align != PadOnRight {\n-            Ok(())\n-        } else {\n-            let name = test.padded_name(self.max_name_len, align);\n-            self.write_plain(&format!(\"test {} ... \", name))\n-        }\n-    }\n-\n-    pub fn write_result(&mut self, result: &TestResult) -> io::Result<()> {\n-        match *result {\n-            TrOk => self.write_ok(),\n-            TrFailed | TrFailedMsg(_) => self.write_failed(),\n-            TrIgnored => self.write_ignored(),\n-            TrAllowedFail => self.write_allowed_fail(),\n-            TrBench(ref bs) => {\n-                self.write_bench()?;\n-                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n-            }\n-        }\n-    }\n-\n-    pub fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n-        self.write_plain(&format!(\"test {} has been running for over {} seconds\\n\",\n-                                  desc.name,\n-                                  TEST_WARN_TIMEOUT_S))\n-    }\n-\n     pub fn write_log<S: AsRef<str>>(&mut self, msg: S) -> io::Result<()> {\n         let msg = msg.as_ref();\n         match self.log_out {\n@@ -674,114 +702,23 @@ impl<T: Write> ConsoleTestState<T> {\n     }\n \n     pub fn write_log_result(&mut self, test: &TestDesc, result: &TestResult) -> io::Result<()> {\n-        self.write_log(\n-            format!(\"{} {}\\n\",\n-                    match *result {\n-                        TrOk => \"ok\".to_owned(),\n-                        TrFailed => \"failed\".to_owned(),\n-                        TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n-                        TrIgnored => \"ignored\".to_owned(),\n-                        TrAllowedFail => \"failed (allowed)\".to_owned(),\n-                        TrBench(ref bs) => fmt_bench_samples(bs),\n-                    },\n-                    test.name))\n-    }\n-\n-    pub fn write_failures(&mut self) -> io::Result<()> {\n-        self.write_plain(\"\\nfailures:\\n\")?;\n-        let mut failures = Vec::new();\n-        let mut fail_out = String::new();\n-        for &(ref f, ref stdout) in &self.failures {\n-            failures.push(f.name.to_string());\n-            if !stdout.is_empty() {\n-                fail_out.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n-                let output = String::from_utf8_lossy(stdout);\n-                fail_out.push_str(&output);\n-                fail_out.push_str(\"\\n\");\n-            }\n-        }\n-        if !fail_out.is_empty() {\n-            self.write_plain(\"\\n\")?;\n-            self.write_plain(&fail_out)?;\n-        }\n-\n-        self.write_plain(\"\\nfailures:\\n\")?;\n-        failures.sort();\n-        for name in &failures {\n-            self.write_plain(&format!(\"    {}\\n\", name))?;\n-        }\n-        Ok(())\n-    }\n-\n-    pub fn write_outputs(&mut self) -> io::Result<()> {\n-        self.write_plain(\"\\nsuccesses:\\n\")?;\n-        let mut successes = Vec::new();\n-        let mut stdouts = String::new();\n-        for &(ref f, ref stdout) in &self.not_failures {\n-            successes.push(f.name.to_string());\n-            if !stdout.is_empty() {\n-                stdouts.push_str(&format!(\"---- {} stdout ----\\n\\t\", f.name));\n-                let output = String::from_utf8_lossy(stdout);\n-                stdouts.push_str(&output);\n-                stdouts.push_str(\"\\n\");\n-            }\n-        }\n-        if !stdouts.is_empty() {\n-            self.write_plain(\"\\n\")?;\n-            self.write_plain(&stdouts)?;\n-        }\n-\n-        self.write_plain(\"\\nsuccesses:\\n\")?;\n-        successes.sort();\n-        for name in &successes {\n-            self.write_plain(&format!(\"    {}\\n\", name))?;\n-        }\n-        Ok(())\n+        self.write_log(format!(\n+            \"{} {}\\n\",\n+            match *result {\n+                TrOk => \"ok\".to_owned(),\n+                TrFailed => \"failed\".to_owned(),\n+                TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n+                TrIgnored => \"ignored\".to_owned(),\n+                TrAllowedFail => \"failed (allowed)\".to_owned(),\n+                TrBench(ref bs) => fmt_bench_samples(bs),\n+            },\n+            test.name\n+        ))\n     }\n \n     fn current_test_count(&self) -> usize {\n         self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n     }\n-\n-    pub fn write_run_finish(&mut self) -> io::Result<bool> {\n-        assert!(self.current_test_count() == self.total);\n-\n-        if self.options.display_output {\n-            self.write_outputs()?;\n-        }\n-        let success = self.failed == 0;\n-        if !success {\n-            self.write_failures()?;\n-        }\n-\n-        self.write_plain(\"\\ntest result: \")?;\n-        if success {\n-            // There's no parallelism at this point so it's safe to use color\n-            self.write_pretty(\"ok\", term::color::GREEN)?;\n-        } else {\n-            self.write_pretty(\"FAILED\", term::color::RED)?;\n-        }\n-        let s = if self.allowed_fail > 0 {\n-            format!(\n-                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n-                self.passed,\n-                self.failed + self.allowed_fail,\n-                self.allowed_fail,\n-                self.ignored,\n-                self.measured,\n-                self.filtered_out)\n-        } else {\n-            format!(\n-                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n-                self.passed,\n-                self.failed,\n-                self.ignored,\n-                self.measured,\n-                self.filtered_out)\n-        };\n-        self.write_plain(&s)?;\n-        return Ok(success);\n-    }\n }\n \n // Format a number with thousands separators\n@@ -815,34 +752,55 @@ pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n     let median = bs.ns_iter_summ.median as usize;\n     let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n \n-    output.write_fmt(format_args!(\"{:>11} ns/iter (+/- {})\",\n-                                  fmt_thousands_sep(median, ','),\n-                                  fmt_thousands_sep(deviation, ',')))\n-          .unwrap();\n+    output\n+        .write_fmt(format_args!(\n+            \"{:>11} ns/iter (+/- {})\",\n+            fmt_thousands_sep(median, ','),\n+            fmt_thousands_sep(deviation, ',')\n+        ))\n+        .unwrap();\n     if bs.mb_s != 0 {\n-        output.write_fmt(format_args!(\" = {} MB/s\", bs.mb_s)).unwrap();\n+        output\n+            .write_fmt(format_args!(\" = {} MB/s\", bs.mb_s))\n+            .unwrap();\n     }\n     output\n }\n \n // List the tests to console, and optionally to logfile. Filters are honored.\n pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n-    let mut st = ConsoleTestState::new(opts, None::<io::Stdout>)?;\n+    let mut output = match term::stdout() {\n+        None => Raw(io::stdout()),\n+        Some(t) => Pretty(t),\n+    };\n+\n+    let quiet = opts.format == OutputFormat::Terse;\n+    let mut st = ConsoleTestState::new(opts)?;\n \n     let mut ntest = 0;\n     let mut nbench = 0;\n \n     for test in filter_tests(&opts, tests) {\n         use TestFn::*;\n \n-        let TestDescAndFn { desc: TestDesc { name, .. }, testfn } = test;\n+        let TestDescAndFn {\n+            desc: TestDesc { name, .. },\n+            testfn,\n+        } = test;\n \n         let fntype = match testfn {\n-            StaticTestFn(..) | DynTestFn(..) => { ntest += 1; \"test\" },\n-            StaticBenchFn(..) | DynBenchFn(..) => { nbench += 1; \"benchmark\" },\n+            StaticTestFn(..) | DynTestFn(..) => {\n+                ntest += 1;\n+                \"test\"\n+            }\n+            StaticBenchFn(..) |\n+            DynBenchFn(..) => {\n+                nbench += 1;\n+                \"benchmark\"\n+            }\n         };\n \n-        st.write_plain(format!(\"{}: {}\\n\", name, fntype))?;\n+        writeln!(output, \"{}: {}\", name, fntype)?;\n         st.write_log(format!(\"{} {}\\n\", fntype, name))?;\n     }\n \n@@ -853,30 +811,40 @@ pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Res\n         }\n     }\n \n-    if !opts.quiet {\n+    if !quiet {\n         if ntest != 0 || nbench != 0 {\n-            st.write_plain(\"\\n\")?;\n+            writeln!(output, \"\")?;\n         }\n-        st.write_plain(format!(\"{}, {}\\n\",\n+\n+        writeln!(output,\n+            \"{}, {}\",\n             plural(ntest, \"test\"),\n-            plural(nbench, \"benchmark\")))?;\n+            plural(nbench, \"benchmark\")\n+        )?;\n     }\n \n     Ok(())\n }\n \n // A simple console test runner\n pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n+    fn callback(\n+        event: &TestEvent,\n+        st: &mut ConsoleTestState,\n+        out: &mut OutputFormatter,\n+    ) -> io::Result<()> {\n \n-    fn callback<T: Write>(event: &TestEvent, st: &mut ConsoleTestState<T>) -> io::Result<()> {\n         match (*event).clone() {\n-            TeFiltered(ref filtered_tests) => st.write_run_start(filtered_tests.len()),\n+            TeFiltered(ref filtered_tests) => {\n+                st.total = filtered_tests.len();\n+                out.write_run_start(filtered_tests.len())\n+            }\n             TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n-            TeWait(ref test, padding) => st.write_test_start(test, padding),\n-            TeTimeout(ref test) => st.write_timeout(test),\n+            TeWait(ref test) => out.write_test_start(test),\n+            TeTimeout(ref test) => out.write_timeout(test),\n             TeResult(test, result, stdout) => {\n                 st.write_log_result(&test, &result)?;\n-                st.write_result(&result)?;\n+                out.write_result(&test, &result, &*stdout)?;\n                 match result {\n                     TrOk => {\n                         st.passed += 1;\n@@ -885,9 +853,11 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                     TrIgnored => st.ignored += 1,\n                     TrAllowedFail => st.allowed_fail += 1,\n                     TrBench(bs) => {\n-                        st.metrics.insert_metric(test.name.as_slice(),\n-                                                 bs.ns_iter_summ.median,\n-                                                 bs.ns_iter_summ.max - bs.ns_iter_summ.min);\n+                        st.metrics.insert_metric(\n+                            test.name.as_slice(),\n+                            bs.ns_iter_summ.median,\n+                            bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n+                        );\n                         st.measured += 1\n                     }\n                     TrFailed => {\n@@ -897,9 +867,7 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n                     TrFailedMsg(msg) => {\n                         st.failed += 1;\n                         let mut stdout = stdout;\n-                        stdout.extend_from_slice(\n-                            format!(\"note: {}\", msg).as_bytes()\n-                        );\n+                        stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n                         st.failures.push((test, stdout));\n                     }\n                 }\n@@ -908,19 +876,47 @@ pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Resu\n         }\n     }\n \n-    let mut st = ConsoleTestState::new(opts, None::<io::Stdout>)?;\n+    let output = match term::stdout() {\n+        None => Raw(io::stdout()),\n+        Some(t) => Pretty(t),\n+    };\n+\n+    let max_name_len = tests\n+        .iter()\n+        .max_by_key(|t| len_if_padded(*t))\n+        .map(|t| t.desc.name.as_slice().len())\n+        .unwrap_or(0);\n+\n+    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n+\n+    let mut out: Box<OutputFormatter> = match opts.format {\n+        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n+            output,\n+            use_color(opts),\n+            max_name_len,\n+            is_multithreaded,\n+        )),\n+        OutputFormat::Terse => Box::new(TerseFormatter::new(\n+            output,\n+            use_color(opts),\n+            max_name_len,\n+            is_multithreaded,\n+        )),\n+        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n+    };\n+    let mut st = ConsoleTestState::new(opts)?;\n     fn len_if_padded(t: &TestDescAndFn) -> usize {\n         match t.testfn.padding() {\n             PadNone => 0,\n             PadOnRight => t.desc.name.as_slice().len(),\n         }\n     }\n-    if let Some(t) = tests.iter().max_by_key(|t| len_if_padded(*t)) {\n-        let n = t.desc.name.as_slice();\n-        st.max_name_len = n.len();\n-    }\n-    run_tests(opts, tests, |x| callback(&x, &mut st))?;\n-    return st.write_run_finish();\n+\n+    run_tests(opts, tests, |x| callback(&x, &mut st, &mut *out))?;\n+\n+    assert!(st.current_test_count() == st.total);\n+\n+    return out.write_run_finish(&st);\n }\n \n #[test]\n@@ -939,29 +935,27 @@ fn should_sort_failures_before_printing_them() {\n         allow_fail: false,\n     };\n \n-    let mut st = ConsoleTestState {\n+    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false);\n+\n+    let st = ConsoleTestState {\n         log_out: None,\n-        out: Raw(Vec::new()),\n-        use_color: false,\n-        quiet: false,\n         total: 0,\n         passed: 0,\n         failed: 0,\n         ignored: 0,\n         allowed_fail: 0,\n         filtered_out: 0,\n         measured: 0,\n-        max_name_len: 10,\n         metrics: MetricMap::new(),\n         failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n         options: Options::new(),\n         not_failures: Vec::new(),\n     };\n \n-    st.write_failures().unwrap();\n-    let s = match st.out {\n-        Raw(ref m) => String::from_utf8_lossy(&m[..]),\n-        Pretty(_) => unreachable!(),\n+    out.write_failures(&st).unwrap();\n+    let s = match out.output_location() {\n+        &Raw(ref m) => String::from_utf8_lossy(&m[..]),\n+        &Pretty(_) => unreachable!(),\n     };\n \n     let apos = s.find(\"a\").unwrap();\n@@ -1009,17 +1003,27 @@ fn stdout_isatty() -> bool {\n #[derive(Clone)]\n pub enum TestEvent {\n     TeFiltered(Vec<TestDesc>),\n-    TeWait(TestDesc, NamePadding),\n+    TeWait(TestDesc),\n     TeResult(TestDesc, TestResult, Vec<u8>),\n     TeTimeout(TestDesc),\n     TeFilteredOut(usize),\n }\n \n pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n \n+struct Sink(Arc<Mutex<Vec<u8>>>);\n+impl Write for Sink {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Write::write(&mut *self.0.lock().unwrap(), data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n \n pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n-    where F: FnMut(TestEvent) -> io::Result<()>\n+where\n+    F: FnMut(TestEvent) -> io::Result<()>,\n {\n     use std::collections::HashMap;\n     use std::sync::mpsc::RecvTimeoutError;\n@@ -1031,27 +1035,29 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n         filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n     }\n \n+    let filtered_tests = {\n+        let mut filtered_tests = filtered_tests;\n+        for test in filtered_tests.iter_mut() {\n+            test.desc.name = test.desc.name.with_padding(test.testfn.padding());\n+        }\n+\n+        filtered_tests\n+    };\n+\n     let filtered_out = tests_len - filtered_tests.len();\n     callback(TeFilteredOut(filtered_out))?;\n \n-    let filtered_descs = filtered_tests.iter()\n-                                       .map(|t| t.desc.clone())\n-                                       .collect();\n+    let filtered_descs = filtered_tests.iter().map(|t| t.desc.clone()).collect();\n \n     callback(TeFiltered(filtered_descs))?;\n \n     let (filtered_tests, filtered_benchs): (Vec<_>, _) =\n-        filtered_tests.into_iter().partition(|e| {\n-            match e.testfn {\n-                StaticTestFn(_) | DynTestFn(_) => true,\n-                _ => false,\n-            }\n+        filtered_tests.into_iter().partition(|e| match e.testfn {\n+            StaticTestFn(_) | DynTestFn(_) => true,\n+            _ => false,\n         });\n \n-    let concurrency = match opts.test_threads {\n-        Some(n) => n,\n-        None => get_concurrency(),\n-    };\n+    let concurrency = opts.test_threads.unwrap_or_else(get_concurrency);\n \n     let mut remaining = filtered_tests;\n     remaining.reverse();\n@@ -1063,8 +1069,13 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n \n     fn get_timed_out_tests(running_tests: &mut HashMap<TestDesc, Instant>) -> Vec<TestDesc> {\n         let now = Instant::now();\n-        let timed_out = running_tests.iter()\n-            .filter_map(|(desc, timeout)| if &now >= timeout { Some(desc.clone())} else { None })\n+        let timed_out = running_tests\n+            .iter()\n+            .filter_map(|(desc, timeout)| if &now >= timeout {\n+                Some(desc.clone())\n+            } else {\n+                None\n+            })\n             .collect();\n         for test in &timed_out {\n             running_tests.remove(test);\n@@ -1079,13 +1090,14 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n                 *next_timeout - now\n             } else {\n                 Duration::new(0, 0)\n-            }})\n+            }\n+        })\n     };\n \n     if concurrency == 1 {\n         while !remaining.is_empty() {\n             let test = remaining.pop().unwrap();\n-            callback(TeWait(test.desc.clone(), test.testfn.padding()))?;\n+            callback(TeWait(test.desc.clone()))?;\n             run_test(opts, !opts.run_tests, test, tx.clone());\n             let (test, result, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, stdout))?;\n@@ -1096,6 +1108,7 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n                 let test = remaining.pop().unwrap();\n                 let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n                 running_tests.insert(test.desc.clone(), timeout);\n+                callback(TeWait(test.desc.clone()))?; //here no pad\n                 run_test(opts, !opts.run_tests, test, tx.clone());\n                 pending += 1;\n             }\n@@ -1119,7 +1132,6 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n             let (desc, result, stdout) = res.unwrap();\n             running_tests.remove(&desc);\n \n-            callback(TeWait(desc.clone(), PadNone))?;\n             callback(TeResult(desc, result, stdout))?;\n             pending -= 1;\n         }\n@@ -1128,7 +1140,7 @@ pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F)\n     if opts.bench_benchmarks {\n         // All benchmarks run at the end, in serial.\n         for b in filtered_benchs {\n-            callback(TeWait(b.desc.clone(), b.testfn.padding()))?;\n+            callback(TeWait(b.desc.clone()))?;\n             run_test(opts, false, b, tx.clone());\n             let (test, result, stdout) = rx.recv().unwrap();\n             callback(TeResult(test, result, stdout))?;\n@@ -1145,8 +1157,10 @@ fn get_concurrency() -> usize {\n             match opt_n {\n                 Some(n) if n > 0 => n,\n                 _ => {\n-                    panic!(\"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n-                           s)\n+                    panic!(\n+                        \"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n+                        s\n+                    )\n                 }\n             }\n         }\n@@ -1203,10 +1217,8 @@ fn get_concurrency() -> usize {\n         unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n     }\n \n-    #[cfg(any(target_os = \"freebsd\",\n-              target_os = \"dragonfly\",\n-              target_os = \"bitrig\",\n-              target_os = \"netbsd\"))]\n+    #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\", target_os = \"bitrig\",\n+                target_os = \"netbsd\"))]\n     fn num_cpus() -> usize {\n         use std::ptr;\n \n@@ -1219,12 +1231,14 @@ fn get_concurrency() -> usize {\n         if cpus < 1 {\n             let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n             unsafe {\n-                libc::sysctl(mib.as_mut_ptr(),\n-                             2,\n-                             &mut cpus as *mut _ as *mut _,\n-                             &mut cpus_size as *mut _ as *mut _,\n-                             ptr::null_mut(),\n-                             0);\n+                libc::sysctl(\n+                    mib.as_mut_ptr(),\n+                    2,\n+                    &mut cpus as *mut _ as *mut _,\n+                    &mut cpus_size as *mut _ as *mut _,\n+                    ptr::null_mut(),\n+                    0,\n+                );\n             }\n             if cpus < 1 {\n                 cpus = 1;\n@@ -1242,12 +1256,14 @@ fn get_concurrency() -> usize {\n         let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n \n         unsafe {\n-            libc::sysctl(mib.as_mut_ptr(),\n-                         2,\n-                         &mut cpus as *mut _ as *mut _,\n-                         &mut cpus_size as *mut _ as *mut _,\n-                         ptr::null_mut(),\n-                         0);\n+            libc::sysctl(\n+                mib.as_mut_ptr(),\n+                2,\n+                &mut cpus as *mut _ as *mut _,\n+                &mut cpus_size as *mut _ as *mut _,\n+                ptr::null_mut(),\n+                0,\n+            );\n         }\n         if cpus < 1 {\n             cpus = 1;\n@@ -1269,27 +1285,27 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     filtered = match opts.filter {\n         None => filtered,\n         Some(ref filter) => {\n-            filtered.into_iter()\n-                    .filter(|test| {\n-                        if opts.filter_exact {\n-                            test.desc.name.as_slice() == &filter[..]\n-                        } else {\n-                            test.desc.name.as_slice().contains(&filter[..])\n-                        }\n-                    })\n-                    .collect()\n+            filtered\n+                .into_iter()\n+                .filter(|test| if opts.filter_exact {\n+                    test.desc.name.as_slice() == &filter[..]\n+                } else {\n+                    test.desc.name.as_slice().contains(&filter[..])\n+                })\n+                .collect()\n         }\n     };\n \n     // Skip tests that match any of the skip filters\n-    filtered = filtered.into_iter()\n-        .filter(|t| !opts.skip.iter().any(|sf| {\n-                if opts.filter_exact {\n-                    t.desc.name.as_slice() == &sf[..]\n-                } else {\n-                    t.desc.name.as_slice().contains(&sf[..])\n-                }\n-            }))\n+    filtered = filtered\n+        .into_iter()\n+        .filter(|t| {\n+            !opts.skip.iter().any(|sf| if opts.filter_exact {\n+                t.desc.name.as_slice() == &sf[..]\n+            } else {\n+                t.desc.name.as_slice().contains(&sf[..])\n+            })\n+        })\n         .collect();\n \n     // Maybe pull out the ignored test and unignore them\n@@ -1298,9 +1314,12 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     } else {\n         fn filter(test: TestDescAndFn) -> Option<TestDescAndFn> {\n             if test.desc.ignore {\n-                let TestDescAndFn {desc, testfn} = test;\n+                let TestDescAndFn { desc, testfn } = test;\n                 Some(TestDescAndFn {\n-                    desc: TestDesc { ignore: false, ..desc },\n+                    desc: TestDesc {\n+                        ignore: false,\n+                        ..desc\n+                    },\n                     testfn,\n                 })\n             } else {\n@@ -1311,7 +1330,9 @@ pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescA\n     };\n \n     // Sort the tests alphabetically\n-    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n+    filtered.sort_by(|t1, t2| {\n+        t1.desc.name.as_slice().cmp(t2.desc.name.as_slice())\n+    });\n \n     filtered\n }\n@@ -1334,24 +1355,26 @@ pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAnd\n                     })\n                 }))\n             }\n-            f => f,\n-        };\n-        TestDescAndFn {\n-            desc: x.desc,\n-            testfn,\n-        }\n-    }).collect()\n+                f => f,\n+            };\n+            TestDescAndFn {\n+                desc: x.desc,\n+                testfn,\n+            }\n+        })\n+        .collect()\n }\n \n-pub fn run_test(opts: &TestOpts,\n-                force_ignore: bool,\n-                test: TestDescAndFn,\n-                monitor_ch: Sender<MonitorMsg>) {\n+pub fn run_test(\n+    opts: &TestOpts,\n+    force_ignore: bool,\n+    test: TestDescAndFn,\n+    monitor_ch: Sender<MonitorMsg>,\n+) {\n \n-    let TestDescAndFn {desc, testfn} = test;\n+    let TestDescAndFn { desc, testfn } = test;\n \n-    let ignore_because_panic_abort =\n-        cfg!(target_arch = \"wasm32\") &&\n+    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\") &&\n         !cfg!(target_os = \"emscripten\") &&\n         desc.should_panic != ShouldPanic::No;\n \n@@ -1364,16 +1387,6 @@ pub fn run_test(opts: &TestOpts,\n                       monitor_ch: Sender<MonitorMsg>,\n                       nocapture: bool,\n                       testfn: Box<FnBox() + Send>) {\n-        struct Sink(Arc<Mutex<Vec<u8>>>);\n-        impl Write for Sink {\n-            fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n-                Write::write(&mut *self.0.lock().unwrap(), data)\n-            }\n-            fn flush(&mut self) -> io::Result<()> {\n-                Ok(())\n-            }\n-        }\n-\n         // Buffer for capturing standard I/O\n         let data = Arc::new(Mutex::new(Vec::new()));\n         let data2 = data.clone();\n@@ -1383,7 +1396,7 @@ pub fn run_test(opts: &TestOpts,\n             let oldio = if !nocapture {\n                 Some((\n                     io::set_print(Some(Box::new(Sink(data2.clone())))),\n-                    io::set_panic(Some(Box::new(Sink(data2))))\n+                    io::set_panic(Some(Box::new(Sink(data2)))),\n                 ))\n             } else {\n                 None\n@@ -1398,21 +1411,18 @@ pub fn run_test(opts: &TestOpts,\n \n             let test_result = calc_result(&desc, result);\n             let stdout = data.lock().unwrap().to_vec();\n-            monitor_ch.send((desc.clone(), test_result, stdout)).unwrap();\n+            monitor_ch\n+                .send((desc.clone(), test_result, stdout))\n+                .unwrap();\n         };\n \n \n         // If the platform is single-threaded we're just going to run\n         // the test synchronously, regardless of the concurrency\n         // level.\n-        let supports_threads =\n-            !cfg!(target_os = \"emscripten\") &&\n-            !cfg!(target_arch = \"wasm32\");\n+        let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n         if supports_threads {\n-            let cfg = thread::Builder::new().name(match name {\n-                DynTestName(ref name) => name.clone(),\n-                StaticTestName(name) => name.to_owned(),\n-            });\n+            let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n             cfg.spawn(runtest).unwrap();\n         } else {\n             runtest();\n@@ -1421,24 +1431,27 @@ pub fn run_test(opts: &TestOpts,\n \n     match testfn {\n         DynBenchFn(bencher) => {\n-            let bs = ::bench::benchmark(|harness| bencher.run(harness));\n-            monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n-            return;\n+            ::bench::benchmark(desc,\n+                                monitor_ch,\n+                                opts.nocapture,\n+                                |harness| bencher.run(harness));\n         }\n         StaticBenchFn(benchfn) => {\n-            let bs = ::bench::benchmark(|harness| (benchfn.clone())(harness));\n-            monitor_ch.send((desc, TrBench(bs), Vec::new())).unwrap();\n-            return;\n+            ::bench::benchmark(desc,\n+                                monitor_ch,\n+                                opts.nocapture,\n+                                |harness| (benchfn.clone())(harness));\n         }\n         DynTestFn(f) => {\n             let cb = move || {\n                 __rust_begin_short_backtrace(f)\n             };\n             run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb))\n         }\n-        StaticTestFn(f) =>\n+        StaticTestFn(f) => {\n             run_test_inner(desc, monitor_ch, opts.nocapture,\n-                           Box::new(move || __rust_begin_short_backtrace(f))),\n+                           Box::new(move || __rust_begin_short_backtrace(f)))\n+        }\n     }\n }\n \n@@ -1452,20 +1465,22 @@ fn calc_result(desc: &TestDesc, task_result: Result<(), Box<Any + Send>>) -> Tes\n     match (&desc.should_panic, task_result) {\n         (&ShouldPanic::No, Ok(())) |\n         (&ShouldPanic::Yes, Err(_)) => TrOk,\n-        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) =>\n+        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n             if err.downcast_ref::<String>()\n-                  .map(|e| &**e)\n-                  .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n-                  .map(|e| e.contains(msg))\n-                  .unwrap_or(false) {\n+                .map(|e| &**e)\n+                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n+                .map(|e| e.contains(msg))\n+                .unwrap_or(false)\n+            {\n                 TrOk\n             } else {\n                 if desc.allow_fail {\n                     TrAllowedFail\n                 } else {\n                     TrFailedMsg(format!(\"Panic did not include expected string '{}'\", msg))\n                 }\n-            },\n+            }\n+        }\n         _ if desc.allow_fail => TrAllowedFail,\n         _ => TrFailed,\n     }\n@@ -1493,18 +1508,15 @@ impl MetricMap {\n     /// you want to see grow larger, so a change larger than `noise` in the\n     /// negative direction represents a regression.\n     pub fn insert_metric(&mut self, name: &str, value: f64, noise: f64) {\n-        let m = Metric {\n-            value,\n-            noise,\n-        };\n+        let m = Metric { value, noise };\n         self.0.insert(name.to_owned(), m);\n     }\n \n     pub fn fmt_metrics(&self) -> String {\n         let v = self.0\n-                   .iter()\n-                   .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n-                   .collect::<Vec<_>>();\n+            .iter()\n+            .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n+            .collect::<Vec<_>>();\n         v.join(\", \")\n     }\n }\n@@ -1534,7 +1546,8 @@ pub fn black_box<T>(dummy: T) -> T {\n impl Bencher {\n     /// Callback for benchmark functions to run in their body.\n     pub fn iter<T, F>(&mut self, mut inner: F)\n-        where F: FnMut() -> T\n+    where\n+        F: FnMut() -> T,\n     {\n         if self.mode == BenchMode::Single {\n             ns_iter_inner(&mut inner, 1);\n@@ -1545,7 +1558,8 @@ impl Bencher {\n     }\n \n     pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n-        where F: FnMut(&mut Bencher)\n+    where\n+        F: FnMut(&mut Bencher),\n     {\n         f(self);\n         return self.summary;\n@@ -1557,7 +1571,8 @@ fn ns_from_dur(dur: Duration) -> u64 {\n }\n \n fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n-    where F: FnMut() -> T\n+where\n+    F: FnMut() -> T,\n {\n     let start = Instant::now();\n     for _ in 0..k {\n@@ -1568,7 +1583,8 @@ fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n \n \n pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n-    where F: FnMut() -> T\n+where\n+    F: FnMut() -> T,\n {\n     // Initial bench run to get ballpark figure.\n     let ns_single = ns_iter_inner(inner, 1);\n@@ -1610,7 +1626,8 @@ pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n         // If we've run for 100ms and seem to have converged to a\n         // stable median.\n         if loop_run > Duration::from_millis(100) && summ.median_abs_dev_pct < 1.0 &&\n-           summ.median - summ5.median < summ5.median_abs_dev {\n+            summ.median - summ5.median < summ5.median_abs_dev\n+        {\n             return summ5;\n         }\n \n@@ -1634,43 +1651,75 @@ pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n }\n \n pub mod bench {\n+    use std::panic::{catch_unwind, AssertUnwindSafe};\n     use std::cmp;\n+    use std::io;\n+    use std::sync::{Arc, Mutex};\n     use stats;\n-    use super::{Bencher, BenchSamples, BenchMode};\n+    use super::{Bencher, BenchSamples, BenchMode, Sink, MonitorMsg, TestDesc, Sender, TestResult};\n \n-    pub fn benchmark<F>(f: F) -> BenchSamples\n-        where F: FnMut(&mut Bencher)\n+    pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<MonitorMsg>, nocapture: bool, f: F)\n+    where\n+        F: FnMut(&mut Bencher),\n     {\n         let mut bs = Bencher {\n             mode: BenchMode::Auto,\n             summary: None,\n             bytes: 0,\n         };\n \n-        return match bs.bench(f) {\n-            Some(ns_iter_summ) => {\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let data2 = data.clone();\n+\n+        let oldio = if !nocapture {\n+            Some((\n+                io::set_print(Some(Box::new(Sink(data2.clone())))),\n+                io::set_panic(Some(Box::new(Sink(data2)))),\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n+\n+        if let Some((printio, panicio)) = oldio {\n+            io::set_print(printio);\n+            io::set_panic(panicio);\n+        };\n+\n+        let test_result = match result { //bs.bench(f) {\n+            Ok(Some(ns_iter_summ)) => {\n                 let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n                 let mb_s = bs.bytes * 1000 / ns_iter;\n \n-                BenchSamples {\n+                let bs = BenchSamples {\n                     ns_iter_summ,\n                     mb_s: mb_s as usize,\n-                }\n+                };\n+                TestResult::TrBench(bs)\n             }\n-            None => {\n+            Ok(None) => {\n                 // iter not called, so no data.\n                 // FIXME: error in this case?\n                 let samples: &mut [f64] = &mut [0.0_f64; 1];\n-                BenchSamples {\n+                let bs = BenchSamples {\n                     ns_iter_summ: stats::Summary::new(samples),\n                     mb_s: 0,\n-                }\n+                };\n+                TestResult::TrBench(bs)\n+            }\n+            Err(_) => {\n+                TestResult::TrFailed\n             }\n         };\n+\n+        let stdout = data.lock().unwrap().to_vec();\n+        monitor_ch.send((desc, test_result, stdout)).unwrap();\n     }\n \n     pub fn run_once<F>(f: F)\n-        where F: FnMut(&mut Bencher)\n+    where\n+        F: FnMut(&mut Bencher),\n     {\n         let mut bs = Bencher {\n             mode: BenchMode::Single,\n@@ -1810,7 +1859,11 @@ mod tests {\n \n     #[test]\n     fn parse_ignored_flag() {\n-        let args = vec![\"progname\".to_string(), \"filter\".to_string(), \"--ignored\".to_string()];\n+        let args = vec![\n+            \"progname\".to_string(),\n+            \"filter\".to_string(),\n+            \"--ignored\".to_string(),\n+        ];\n         let opts = match parse_opts(&args) {\n             Some(Ok(o)) => o,\n             _ => panic!(\"Malformed arg in parse_ignored_flag\"),\n@@ -1827,7 +1880,8 @@ mod tests {\n         opts.run_tests = true;\n         opts.run_ignored = true;\n \n-        let tests = vec![TestDescAndFn {\n+        let tests =\n+            vec![TestDescAndFn {\n                              desc: TestDesc {\n                                  name: StaticTestName(\"1\"),\n                                  ignore: true,\n@@ -1855,72 +1909,95 @@ mod tests {\n     #[test]\n     pub fn exact_filter_match() {\n         fn tests() -> Vec<TestDescAndFn> {\n-            vec![\"base\",\n-                 \"base::test\",\n-                 \"base::test1\",\n-                 \"base::test2\",\n-            ].into_iter()\n-            .map(|name| TestDescAndFn {\n-                desc: TestDesc {\n-                    name: StaticTestName(name),\n-                    ignore: false,\n-                    should_panic: ShouldPanic::No,\n-                    allow_fail: false,\n-                },\n-                testfn: DynTestFn(Box::new(move || {}))\n-            })\n-            .collect()\n+            vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n+                .into_iter()\n+                .map(|name| {\n+                    TestDescAndFn {\n+                        desc: TestDesc {\n+                            name: StaticTestName(name),\n+                            ignore: false,\n+                            should_panic: ShouldPanic::No,\n+                            allow_fail: false,\n+                        },\n+                        testfn: DynTestFn(Box::new(move || {}))\n+                    }\n+                }).collect()\n         }\n \n-        let substr = filter_tests(&TestOpts {\n+        let substr = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"base\".into()),\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(substr.len(), 4);\n \n-        let substr = filter_tests(&TestOpts {\n+        let substr = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"bas\".into()),\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(substr.len(), 4);\n \n-        let substr = filter_tests(&TestOpts {\n+        let substr = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"::test\".into()),\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(substr.len(), 3);\n \n-        let substr = filter_tests(&TestOpts {\n+        let substr = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"base::test\".into()),\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(substr.len(), 3);\n \n-        let exact = filter_tests(&TestOpts {\n+        let exact = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"base\".into()),\n-                filter_exact: true, ..TestOpts::new()\n-            }, tests());\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n         assert_eq!(exact.len(), 1);\n \n-        let exact = filter_tests(&TestOpts {\n+        let exact = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"bas\".into()),\n                 filter_exact: true,\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(exact.len(), 0);\n \n-        let exact = filter_tests(&TestOpts {\n+        let exact = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"::test\".into()),\n                 filter_exact: true,\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(exact.len(), 0);\n \n-        let exact = filter_tests(&TestOpts {\n+        let exact = filter_tests(\n+            &TestOpts {\n                 filter: Some(\"base::test\".into()),\n                 filter_exact: true,\n                 ..TestOpts::new()\n-            }, tests());\n+            },\n+            tests(),\n+        );\n         assert_eq!(exact.len(), 1);\n     }\n \n@@ -1929,15 +2006,17 @@ mod tests {\n         let mut opts = TestOpts::new();\n         opts.run_tests = true;\n \n-        let names = vec![\"sha1::test\".to_string(),\n-                         \"isize::test_to_str\".to_string(),\n-                         \"isize::test_pow\".to_string(),\n-                         \"test::do_not_run_ignored_tests\".to_string(),\n-                         \"test::ignored_tests_result_in_ignored\".to_string(),\n-                         \"test::first_free_arg_should_be_a_filter\".to_string(),\n-                         \"test::parse_ignored_flag\".to_string(),\n-                         \"test::filter_for_ignored_option\".to_string(),\n-                         \"test::sort_tests\".to_string()];\n+        let names = vec![\n+            \"sha1::test\".to_string(),\n+            \"isize::test_to_str\".to_string(),\n+            \"isize::test_pow\".to_string(),\n+            \"test::do_not_run_ignored_tests\".to_string(),\n+            \"test::ignored_tests_result_in_ignored\".to_string(),\n+            \"test::first_free_arg_should_be_a_filter\".to_string(),\n+            \"test::parse_ignored_flag\".to_string(),\n+            \"test::filter_for_ignored_option\".to_string(),\n+            \"test::sort_tests\".to_string(),\n+        ];\n         let tests = {\n             fn testfn() {}\n             let mut tests = Vec::new();\n@@ -1957,15 +2036,17 @@ mod tests {\n         };\n         let filtered = filter_tests(&opts, tests);\n \n-        let expected = vec![\"isize::test_pow\".to_string(),\n-                            \"isize::test_to_str\".to_string(),\n-                            \"sha1::test\".to_string(),\n-                            \"test::do_not_run_ignored_tests\".to_string(),\n-                            \"test::filter_for_ignored_option\".to_string(),\n-                            \"test::first_free_arg_should_be_a_filter\".to_string(),\n-                            \"test::ignored_tests_result_in_ignored\".to_string(),\n-                            \"test::parse_ignored_flag\".to_string(),\n-                            \"test::sort_tests\".to_string()];\n+        let expected = vec![\n+            \"isize::test_pow\".to_string(),\n+            \"isize::test_to_str\".to_string(),\n+            \"sha1::test\".to_string(),\n+            \"test::do_not_run_ignored_tests\".to_string(),\n+            \"test::filter_for_ignored_option\".to_string(),\n+            \"test::first_free_arg_should_be_a_filter\".to_string(),\n+            \"test::ignored_tests_result_in_ignored\".to_string(),\n+            \"test::parse_ignored_flag\".to_string(),\n+            \"test::sort_tests\".to_string(),\n+        ];\n \n         for (a, b) in expected.iter().zip(filtered) {\n             assert!(*a == b.desc.name.to_string());\n@@ -2004,24 +2085,50 @@ mod tests {\n     #[test]\n     pub fn test_bench_once_iter() {\n         fn f(b: &mut Bencher) {\n-            b.iter(|| {\n-            })\n+            b.iter(|| {})\n         }\n         bench::run_once(f);\n     }\n \n     #[test]\n     pub fn test_bench_no_iter() {\n         fn f(_: &mut Bencher) {}\n-        bench::benchmark(f);\n+\n+        let (tx, rx) = channel();\n+\n+        let desc = TestDesc {\n+            name: StaticTestName(\"f\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        };\n+\n+        ::bench::benchmark(desc,\n+                            tx,\n+                            true,\n+                            f);\n+        rx.recv().unwrap();\n     }\n \n     #[test]\n     pub fn test_bench_iter() {\n         fn f(b: &mut Bencher) {\n-            b.iter(|| {\n-            })\n+            b.iter(|| {})\n         }\n-        bench::benchmark(f);\n+\n+        let (tx, rx) = channel();\n+\n+        let desc = TestDesc {\n+            name: StaticTestName(\"f\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        };\n+\n+        ::bench::benchmark(desc,\n+                            tx,\n+                            true,\n+                            f);\n+        rx.recv().unwrap();\n     }\n }"}, {"sha": "e22fdf77fc171e4ad06596947dc1493c8bcae063", "filename": "src/libtest/stats.rs", "status": "modified", "additions": 263, "deletions": 241, "changes": 504, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -400,16 +400,18 @@ mod tests {\n     }\n     #[test]\n     fn test_norm10narrow() {\n-        let val = &[966.0000000000,\n-                    985.0000000000,\n-                    1110.0000000000,\n-                    848.0000000000,\n-                    821.0000000000,\n-                    975.0000000000,\n-                    962.0000000000,\n-                    1157.0000000000,\n-                    1217.0000000000,\n-                    955.0000000000];\n+        let val = &[\n+            966.0000000000,\n+            985.0000000000,\n+            1110.0000000000,\n+            848.0000000000,\n+            821.0000000000,\n+            975.0000000000,\n+            962.0000000000,\n+            1157.0000000000,\n+            1217.0000000000,\n+            955.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 9996.0000000000,\n             min: 821.0000000000,\n@@ -428,16 +430,18 @@ mod tests {\n     }\n     #[test]\n     fn test_norm10medium() {\n-        let val = &[954.0000000000,\n-                    1064.0000000000,\n-                    855.0000000000,\n-                    1000.0000000000,\n-                    743.0000000000,\n-                    1084.0000000000,\n-                    704.0000000000,\n-                    1023.0000000000,\n-                    357.0000000000,\n-                    869.0000000000];\n+        let val = &[\n+            954.0000000000,\n+            1064.0000000000,\n+            855.0000000000,\n+            1000.0000000000,\n+            743.0000000000,\n+            1084.0000000000,\n+            704.0000000000,\n+            1023.0000000000,\n+            357.0000000000,\n+            869.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 8653.0000000000,\n             min: 357.0000000000,\n@@ -456,16 +460,18 @@ mod tests {\n     }\n     #[test]\n     fn test_norm10wide() {\n-        let val = &[505.0000000000,\n-                    497.0000000000,\n-                    1591.0000000000,\n-                    887.0000000000,\n-                    1026.0000000000,\n-                    136.0000000000,\n-                    1580.0000000000,\n-                    940.0000000000,\n-                    754.0000000000,\n-                    1433.0000000000];\n+        let val = &[\n+            505.0000000000,\n+            497.0000000000,\n+            1591.0000000000,\n+            887.0000000000,\n+            1026.0000000000,\n+            136.0000000000,\n+            1580.0000000000,\n+            940.0000000000,\n+            754.0000000000,\n+            1433.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 9349.0000000000,\n             min: 136.0000000000,\n@@ -484,31 +490,33 @@ mod tests {\n     }\n     #[test]\n     fn test_norm25verynarrow() {\n-        let val = &[991.0000000000,\n-                    1018.0000000000,\n-                    998.0000000000,\n-                    1013.0000000000,\n-                    974.0000000000,\n-                    1007.0000000000,\n-                    1014.0000000000,\n-                    999.0000000000,\n-                    1011.0000000000,\n-                    978.0000000000,\n-                    985.0000000000,\n-                    999.0000000000,\n-                    983.0000000000,\n-                    982.0000000000,\n-                    1015.0000000000,\n-                    1002.0000000000,\n-                    977.0000000000,\n-                    948.0000000000,\n-                    1040.0000000000,\n-                    974.0000000000,\n-                    996.0000000000,\n-                    989.0000000000,\n-                    1015.0000000000,\n-                    994.0000000000,\n-                    1024.0000000000];\n+        let val = &[\n+            991.0000000000,\n+            1018.0000000000,\n+            998.0000000000,\n+            1013.0000000000,\n+            974.0000000000,\n+            1007.0000000000,\n+            1014.0000000000,\n+            999.0000000000,\n+            1011.0000000000,\n+            978.0000000000,\n+            985.0000000000,\n+            999.0000000000,\n+            983.0000000000,\n+            982.0000000000,\n+            1015.0000000000,\n+            1002.0000000000,\n+            977.0000000000,\n+            948.0000000000,\n+            1040.0000000000,\n+            974.0000000000,\n+            996.0000000000,\n+            989.0000000000,\n+            1015.0000000000,\n+            994.0000000000,\n+            1024.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 24926.0000000000,\n             min: 948.0000000000,\n@@ -527,16 +535,18 @@ mod tests {\n     }\n     #[test]\n     fn test_exp10a() {\n-        let val = &[23.0000000000,\n-                    11.0000000000,\n-                    2.0000000000,\n-                    57.0000000000,\n-                    4.0000000000,\n-                    12.0000000000,\n-                    5.0000000000,\n-                    29.0000000000,\n-                    3.0000000000,\n-                    21.0000000000];\n+        let val = &[\n+            23.0000000000,\n+            11.0000000000,\n+            2.0000000000,\n+            57.0000000000,\n+            4.0000000000,\n+            12.0000000000,\n+            5.0000000000,\n+            29.0000000000,\n+            3.0000000000,\n+            21.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 167.0000000000,\n             min: 2.0000000000,\n@@ -555,16 +565,18 @@ mod tests {\n     }\n     #[test]\n     fn test_exp10b() {\n-        let val = &[24.0000000000,\n-                    17.0000000000,\n-                    6.0000000000,\n-                    38.0000000000,\n-                    25.0000000000,\n-                    7.0000000000,\n-                    51.0000000000,\n-                    2.0000000000,\n-                    61.0000000000,\n-                    32.0000000000];\n+        let val = &[\n+            24.0000000000,\n+            17.0000000000,\n+            6.0000000000,\n+            38.0000000000,\n+            25.0000000000,\n+            7.0000000000,\n+            51.0000000000,\n+            2.0000000000,\n+            61.0000000000,\n+            32.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 263.0000000000,\n             min: 2.0000000000,\n@@ -583,16 +595,18 @@ mod tests {\n     }\n     #[test]\n     fn test_exp10c() {\n-        let val = &[71.0000000000,\n-                    2.0000000000,\n-                    32.0000000000,\n-                    1.0000000000,\n-                    6.0000000000,\n-                    28.0000000000,\n-                    13.0000000000,\n-                    37.0000000000,\n-                    16.0000000000,\n-                    36.0000000000];\n+        let val = &[\n+            71.0000000000,\n+            2.0000000000,\n+            32.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            28.0000000000,\n+            13.0000000000,\n+            37.0000000000,\n+            16.0000000000,\n+            36.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 242.0000000000,\n             min: 1.0000000000,\n@@ -611,31 +625,33 @@ mod tests {\n     }\n     #[test]\n     fn test_exp25() {\n-        let val = &[3.0000000000,\n-                    24.0000000000,\n-                    1.0000000000,\n-                    19.0000000000,\n-                    7.0000000000,\n-                    5.0000000000,\n-                    30.0000000000,\n-                    39.0000000000,\n-                    31.0000000000,\n-                    13.0000000000,\n-                    25.0000000000,\n-                    48.0000000000,\n-                    1.0000000000,\n-                    6.0000000000,\n-                    42.0000000000,\n-                    63.0000000000,\n-                    2.0000000000,\n-                    12.0000000000,\n-                    108.0000000000,\n-                    26.0000000000,\n-                    1.0000000000,\n-                    7.0000000000,\n-                    44.0000000000,\n-                    25.0000000000,\n-                    11.0000000000];\n+        let val = &[\n+            3.0000000000,\n+            24.0000000000,\n+            1.0000000000,\n+            19.0000000000,\n+            7.0000000000,\n+            5.0000000000,\n+            30.0000000000,\n+            39.0000000000,\n+            31.0000000000,\n+            13.0000000000,\n+            25.0000000000,\n+            48.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            42.0000000000,\n+            63.0000000000,\n+            2.0000000000,\n+            12.0000000000,\n+            108.0000000000,\n+            26.0000000000,\n+            1.0000000000,\n+            7.0000000000,\n+            44.0000000000,\n+            25.0000000000,\n+            11.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 593.0000000000,\n             min: 1.0000000000,\n@@ -654,31 +670,33 @@ mod tests {\n     }\n     #[test]\n     fn test_binom25() {\n-        let val = &[18.0000000000,\n-                    17.0000000000,\n-                    27.0000000000,\n-                    15.0000000000,\n-                    21.0000000000,\n-                    25.0000000000,\n-                    17.0000000000,\n-                    24.0000000000,\n-                    25.0000000000,\n-                    24.0000000000,\n-                    26.0000000000,\n-                    26.0000000000,\n-                    23.0000000000,\n-                    15.0000000000,\n-                    23.0000000000,\n-                    17.0000000000,\n-                    18.0000000000,\n-                    18.0000000000,\n-                    21.0000000000,\n-                    16.0000000000,\n-                    15.0000000000,\n-                    31.0000000000,\n-                    20.0000000000,\n-                    17.0000000000,\n-                    15.0000000000];\n+        let val = &[\n+            18.0000000000,\n+            17.0000000000,\n+            27.0000000000,\n+            15.0000000000,\n+            21.0000000000,\n+            25.0000000000,\n+            17.0000000000,\n+            24.0000000000,\n+            25.0000000000,\n+            24.0000000000,\n+            26.0000000000,\n+            26.0000000000,\n+            23.0000000000,\n+            15.0000000000,\n+            23.0000000000,\n+            17.0000000000,\n+            18.0000000000,\n+            18.0000000000,\n+            21.0000000000,\n+            16.0000000000,\n+            15.0000000000,\n+            31.0000000000,\n+            20.0000000000,\n+            17.0000000000,\n+            15.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 514.0000000000,\n             min: 15.0000000000,\n@@ -697,31 +715,33 @@ mod tests {\n     }\n     #[test]\n     fn test_pois25lambda30() {\n-        let val = &[27.0000000000,\n-                    33.0000000000,\n-                    34.0000000000,\n-                    34.0000000000,\n-                    24.0000000000,\n-                    39.0000000000,\n-                    28.0000000000,\n-                    27.0000000000,\n-                    31.0000000000,\n-                    28.0000000000,\n-                    38.0000000000,\n-                    21.0000000000,\n-                    33.0000000000,\n-                    36.0000000000,\n-                    29.0000000000,\n-                    37.0000000000,\n-                    32.0000000000,\n-                    34.0000000000,\n-                    31.0000000000,\n-                    39.0000000000,\n-                    25.0000000000,\n-                    31.0000000000,\n-                    32.0000000000,\n-                    40.0000000000,\n-                    24.0000000000];\n+        let val = &[\n+            27.0000000000,\n+            33.0000000000,\n+            34.0000000000,\n+            34.0000000000,\n+            24.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            27.0000000000,\n+            31.0000000000,\n+            28.0000000000,\n+            38.0000000000,\n+            21.0000000000,\n+            33.0000000000,\n+            36.0000000000,\n+            29.0000000000,\n+            37.0000000000,\n+            32.0000000000,\n+            34.0000000000,\n+            31.0000000000,\n+            39.0000000000,\n+            25.0000000000,\n+            31.0000000000,\n+            32.0000000000,\n+            40.0000000000,\n+            24.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 787.0000000000,\n             min: 21.0000000000,\n@@ -740,31 +760,33 @@ mod tests {\n     }\n     #[test]\n     fn test_pois25lambda40() {\n-        let val = &[42.0000000000,\n-                    50.0000000000,\n-                    42.0000000000,\n-                    46.0000000000,\n-                    34.0000000000,\n-                    45.0000000000,\n-                    34.0000000000,\n-                    49.0000000000,\n-                    39.0000000000,\n-                    28.0000000000,\n-                    40.0000000000,\n-                    35.0000000000,\n-                    37.0000000000,\n-                    39.0000000000,\n-                    46.0000000000,\n-                    44.0000000000,\n-                    32.0000000000,\n-                    45.0000000000,\n-                    42.0000000000,\n-                    37.0000000000,\n-                    48.0000000000,\n-                    42.0000000000,\n-                    33.0000000000,\n-                    42.0000000000,\n-                    48.0000000000];\n+        let val = &[\n+            42.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            46.0000000000,\n+            34.0000000000,\n+            45.0000000000,\n+            34.0000000000,\n+            49.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            40.0000000000,\n+            35.0000000000,\n+            37.0000000000,\n+            39.0000000000,\n+            46.0000000000,\n+            44.0000000000,\n+            32.0000000000,\n+            45.0000000000,\n+            42.0000000000,\n+            37.0000000000,\n+            48.0000000000,\n+            42.0000000000,\n+            33.0000000000,\n+            42.0000000000,\n+            48.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 1019.0000000000,\n             min: 28.0000000000,\n@@ -783,31 +805,33 @@ mod tests {\n     }\n     #[test]\n     fn test_pois25lambda50() {\n-        let val = &[45.0000000000,\n-                    43.0000000000,\n-                    44.0000000000,\n-                    61.0000000000,\n-                    51.0000000000,\n-                    53.0000000000,\n-                    59.0000000000,\n-                    52.0000000000,\n-                    49.0000000000,\n-                    51.0000000000,\n-                    51.0000000000,\n-                    50.0000000000,\n-                    49.0000000000,\n-                    56.0000000000,\n-                    42.0000000000,\n-                    52.0000000000,\n-                    51.0000000000,\n-                    43.0000000000,\n-                    48.0000000000,\n-                    48.0000000000,\n-                    50.0000000000,\n-                    42.0000000000,\n-                    43.0000000000,\n-                    42.0000000000,\n-                    60.0000000000];\n+        let val = &[\n+            45.0000000000,\n+            43.0000000000,\n+            44.0000000000,\n+            61.0000000000,\n+            51.0000000000,\n+            53.0000000000,\n+            59.0000000000,\n+            52.0000000000,\n+            49.0000000000,\n+            51.0000000000,\n+            51.0000000000,\n+            50.0000000000,\n+            49.0000000000,\n+            56.0000000000,\n+            42.0000000000,\n+            52.0000000000,\n+            51.0000000000,\n+            43.0000000000,\n+            48.0000000000,\n+            48.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            43.0000000000,\n+            42.0000000000,\n+            60.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 1235.0000000000,\n             min: 42.0000000000,\n@@ -826,31 +850,33 @@ mod tests {\n     }\n     #[test]\n     fn test_unif25() {\n-        let val = &[99.0000000000,\n-                    55.0000000000,\n-                    92.0000000000,\n-                    79.0000000000,\n-                    14.0000000000,\n-                    2.0000000000,\n-                    33.0000000000,\n-                    49.0000000000,\n-                    3.0000000000,\n-                    32.0000000000,\n-                    84.0000000000,\n-                    59.0000000000,\n-                    22.0000000000,\n-                    86.0000000000,\n-                    76.0000000000,\n-                    31.0000000000,\n-                    29.0000000000,\n-                    11.0000000000,\n-                    41.0000000000,\n-                    53.0000000000,\n-                    45.0000000000,\n-                    44.0000000000,\n-                    98.0000000000,\n-                    98.0000000000,\n-                    7.0000000000];\n+        let val = &[\n+            99.0000000000,\n+            55.0000000000,\n+            92.0000000000,\n+            79.0000000000,\n+            14.0000000000,\n+            2.0000000000,\n+            33.0000000000,\n+            49.0000000000,\n+            3.0000000000,\n+            32.0000000000,\n+            84.0000000000,\n+            59.0000000000,\n+            22.0000000000,\n+            86.0000000000,\n+            76.0000000000,\n+            31.0000000000,\n+            29.0000000000,\n+            11.0000000000,\n+            41.0000000000,\n+            53.0000000000,\n+            45.0000000000,\n+            44.0000000000,\n+            98.0000000000,\n+            98.0000000000,\n+            7.0000000000,\n+        ];\n         let summ = &Summary {\n             sum: 1242.0000000000,\n             min: 2.0000000000,\n@@ -885,18 +911,14 @@ mod bench {\n \n     #[bench]\n     pub fn sum_three_items(b: &mut Bencher) {\n-        b.iter(|| {\n-            [1e20f64, 1.5f64, -1e20f64].sum();\n-        })\n+        b.iter(|| { [1e20f64, 1.5f64, -1e20f64].sum(); })\n     }\n     #[bench]\n     pub fn sum_many_f64(b: &mut Bencher) {\n         let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n         let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n \n-        b.iter(|| {\n-            v.sum();\n-        })\n+        b.iter(|| { v.sum(); })\n     }\n \n     #[bench]"}, {"sha": "ec91ddfb9f917d85e2efd26bd22b9adff36ebb1d", "filename": "src/test/run-make/libtest-json/Makefile", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftest%2Frun-make%2Flibtest-json%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftest%2Frun-make%2Flibtest-json%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-json%2FMakefile?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -0,0 +1,14 @@\n+-include ../tools.mk\n+\n+# Test expected libtest's JSON output\n+\n+OUTPUT_FILE := $(TMPDIR)/libtest-json-output.json\n+\n+all:\n+\t$(RUSTC) --test f.rs\n+\t$(call RUN,f) -Z unstable-options --test-threads=1 --format=json > $(OUTPUT_FILE) || true\n+\n+\tcat $(OUTPUT_FILE) | \"$(PYTHON)\" validate_json.py\n+\n+\t# Compare to output file\n+\tdiff output.json $(OUTPUT_FILE)"}, {"sha": "5cff1f1a5b1af37f1f312ac1fe6bc574a80ebbd3", "filename": "src/test/run-make/libtest-json/f.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftest%2Frun-make%2Flibtest-json%2Ff.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftest%2Frun-make%2Flibtest-json%2Ff.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-json%2Ff.rs?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#[test]\n+fn a() {\n+    // Should pass\n+}\n+\n+#[test]\n+fn b() {\n+    assert!(false)\n+}\n+\n+#[test]\n+#[should_panic]\n+fn c() {\n+    assert!(false);\n+}\n+\n+#[test]\n+#[ignore]\n+fn d() {\n+    assert!(false);\n+}\n+"}, {"sha": "235f8cd7c725744d6f95f89b751ee7847e9e60e5", "filename": "src/test/run-make/libtest-json/output.json", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftest%2Frun-make%2Flibtest-json%2Foutput.json", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftest%2Frun-make%2Flibtest-json%2Foutput.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-json%2Foutput.json?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -0,0 +1,10 @@\n+{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": \"4\" }\n+{ \"type\": \"test\", \"event\": \"started\", \"name\": \"a\" }\n+{ \"type\": \"test\", \"name\": \"a\", \"event\": \"ok\" }\n+{ \"type\": \"test\", \"event\": \"started\", \"name\": \"b\" }\n+{ \"type\": \"test\", \"name\": \"b\", \"event\": \"failed\", \"stdout\": \"thread 'b' panicked at 'assertion failed: false', f.rs:18:5\\nnote: Run with `RUST_BACKTRACE=1` for a backtrace.\\n\" }\n+{ \"type\": \"test\", \"event\": \"started\", \"name\": \"c\" }\n+{ \"type\": \"test\", \"name\": \"c\", \"event\": \"ok\" }\n+{ \"type\": \"test\", \"event\": \"started\", \"name\": \"d\" }\n+{ \"type\": \"test\", \"name\": \"d\", \"event\": \"ignored\" }\n+{ \"type\": \"suite\", \"event\": \"failed\", \"passed\": 2, \"failed\": 1, \"allowed_fail\": 0, \"ignored\": 1, \"measured\": 0, \"filtered_out\": \"0\" }"}, {"sha": "1e97639b524e8bd9f95658e34362f805b3c94c8a", "filename": "src/test/run-make/libtest-json/validate_json.py", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftest%2Frun-make%2Flibtest-json%2Fvalidate_json.py", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftest%2Frun-make%2Flibtest-json%2Fvalidate_json.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Flibtest-json%2Fvalidate_json.py?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -0,0 +1,18 @@\n+#!/usr/bin/env python\n+\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+import sys\n+import json\n+\n+# Try to decode line in order to ensure it is a valid JSON document\n+for line in sys.stdin:\n+    json.loads(line)"}, {"sha": "1d6dfea44f97199d5d5c177c7dadcde393eaff9a", "filename": "src/tools/cargo", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargo?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -1 +1 @@\n-Subproject commit 91e36aa86c7037de50642f2fec1cf47c3d18af02\n+Subproject commit 1d6dfea44f97199d5d5c177c7dadcde393eaff9a"}, {"sha": "1c52ebd7dc54e4fed51141cef0ae0539f62f1c42", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6b99adeb11313197f409b4f7c4083c2ceca8a4fe/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=6b99adeb11313197f409b4f7c4083c2ceca8a4fe", "patch": "@@ -485,7 +485,7 @@ pub fn test_opts(config: &Config) -> test::TestOpts {\n         filter: config.filter.clone(),\n         filter_exact: config.filter_exact,\n         run_ignored: config.run_ignored,\n-        quiet: config.quiet,\n+        format: if config.quiet { test::OutputFormat::Terse } else { test::OutputFormat::Pretty },\n         logfile: config.logfile.clone(),\n         run_tests: true,\n         bench_benchmarks: true,"}]}