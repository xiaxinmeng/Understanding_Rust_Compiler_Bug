{"sha": "15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE1YzRiM2ZhN2Y5ZDk3MDI5ZDY0YTdlMTNhMTJhYTFlZTQyMzE2ZDc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-18T19:10:29Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-18T19:10:52Z"}, "message": "internal: add Copy to minicore", "tree": {"sha": "5f4156b8691e5ea0c7b46b66e5075da3473e178c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f4156b8691e5ea0c7b46b66e5075da3473e178c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7", "html_url": "https://github.com/rust-lang/rust/commit/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a08339e4211cfd0dc448a8f39d83561ad8754f7a", "url": "https://api.github.com/repos/rust-lang/rust/commits/a08339e4211cfd0dc448a8f39d83561ad8754f7a", "html_url": "https://github.com/rust-lang/rust/commit/a08339e4211cfd0dc448a8f39d83561ad8754f7a"}], "stats": {"total": 772, "additions": 465, "deletions": 307}, "files": [{"sha": "4705fae08da9044a53eea9b6c058f13a6261c57d", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7", "patch": "@@ -3014,8 +3014,8 @@ fn foo() {\n                                     file_id: FileId(\n                                         1,\n                                     ),\n-                                    full_range: 248..430,\n-                                    focus_range: 287..293,\n+                                    full_range: 250..432,\n+                                    focus_range: 289..295,\n                                     name: \"Future\",\n                                     kind: Trait,\n                                     description: \"pub trait Future\","}, {"sha": "43e83d683d89de0d0abf702d9c68ccca2997f42e", "filename": "crates/ide_assists/src/handlers/extract_function.rs", "status": "modified", "additions": 409, "deletions": 302, "changes": 711, "blob_url": "https://github.com/rust-lang/rust/blob/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7", "patch": "@@ -831,6 +831,7 @@ fn path_element_of_reference(\n     })?;\n     stdx::always!(\n         matches!(path, ast::Expr::PathExpr(_) | ast::Expr::MacroCall(_)),\n+\n         \"unexpected expression type for variable usage: {:?}\",\n         path\n     );\n@@ -1501,15 +1502,17 @@ mod tests {\n             r#\"\n fn foo() {\n     foo($01 + 1$0);\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     foo(fun_name());\n }\n \n fn $0fun_name() -> i32 {\n     1 + 1\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1522,7 +1525,8 @@ mod bar {\n     fn foo() {\n         foo($01 + 1$0);\n     }\n-}\"#,\n+}\n+\"#,\n             r#\"\n mod bar {\n     fn foo() {\n@@ -1532,7 +1536,8 @@ mod bar {\n     fn $0fun_name() -> i32 {\n         1 + 1\n     }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1543,15 +1548,17 @@ mod bar {\n             r#\"\n fn foo() {\n     $0{ 1 + 1 }$0;\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     fun_name();\n }\n \n fn $0fun_name() -> i32 {\n     1 + 1\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1564,7 +1571,8 @@ fn foo() -> i32 {\n     let k = 1;\n     $0let m = 1;\n     m + 1$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() -> i32 {\n     let k = 1;\n@@ -1574,7 +1582,8 @@ fn foo() -> i32 {\n fn $0fun_name() -> i32 {\n     let m = 1;\n     m + 1\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1588,7 +1597,8 @@ fn foo() {\n     $0let m = 1;\n     let n = m + 1;$0\n     let g = 5;\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     let k = 3;\n@@ -1599,7 +1609,8 @@ fn foo() {\n fn $0fun_name() {\n     let m = 1;\n     let n = m + 1;\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1610,15 +1621,17 @@ fn $0fun_name() {\n             r#\"\n fn foo() {\n     $0if true { }$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     fun_name();\n }\n \n fn $0fun_name() {\n     if true { }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1629,15 +1642,17 @@ fn $0fun_name() {\n             r#\"\n fn foo() -> i32 {\n     $0if true { 1 } else { 2 }$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() -> i32 {\n     fun_name()\n }\n \n fn $0fun_name() -> i32 {\n     if true { 1 } else { 2 }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1648,15 +1663,17 @@ fn $0fun_name() -> i32 {\n             r#\"\n fn foo() -> i32 {\n     $0if let true = false { 1 } else { 2 }$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() -> i32 {\n     fun_name()\n }\n \n fn $0fun_name() -> i32 {\n     if let true = false { 1 } else { 2 }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1670,7 +1687,8 @@ fn foo() -> i32 {\n         true => 1,\n         false => 2,\n     }$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() -> i32 {\n     fun_name()\n@@ -1681,7 +1699,8 @@ fn $0fun_name() -> i32 {\n         true => 1,\n         false => 2,\n     }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1692,15 +1711,17 @@ fn $0fun_name() -> i32 {\n             r#\"\n fn foo() {\n     $0while true { }$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     fun_name();\n }\n \n fn $0fun_name() {\n     while true { }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1711,15 +1732,17 @@ fn $0fun_name() {\n             r#\"\n fn foo() {\n     $0for v in &[0, 1] { }$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     fun_name();\n }\n \n fn $0fun_name() {\n     for v in &[0, 1] { }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1732,7 +1755,8 @@ fn foo() {\n     $0loop {\n         let m = 1;\n     }$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     fun_name()\n@@ -1742,7 +1766,8 @@ fn $0fun_name() -> ! {\n     loop {\n         let m = 1;\n     }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1756,7 +1781,8 @@ fn foo() {\n         let m = 1;\n         break m;\n     }$0;\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     let v = fun_name();\n@@ -1767,7 +1793,8 @@ fn $0fun_name() -> i32 {\n         let m = 1;\n         break m;\n     }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1781,7 +1808,8 @@ fn foo() {\n         Some(x) => x,\n         None => 0,\n     }$0;\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     let v: i32 = fun_name();\n@@ -1792,7 +1820,8 @@ fn $0fun_name() -> i32 {\n         Some(x) => x,\n         None => 0,\n     }\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1805,7 +1834,8 @@ fn foo() {\n     let n = 1;\n     let mut v = $0n * n;$0\n     v += 1;\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     let n = 1;\n@@ -1816,7 +1846,8 @@ fn foo() {\n fn $0fun_name(n: i32) -> i32 {\n     let mut v = n * n;\n     v\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n@@ -1832,7 +1863,8 @@ fn foo() {\n     let mut w = 3;$0\n     v += 1;\n     w += 1;\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     let m = 2;\n@@ -1846,63 +1878,69 @@ fn $0fun_name(m: i32, n: i32) -> (i32, i32) {\n     let mut v = m * n;\n     let mut w = 3;\n     (v, w)\n-}\"#,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn argument_form_expr() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() -> u32 {\n     let n = 2;\n     $0n+2$0\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() -> u32 {\n     let n = 2;\n     fun_name(n)\n }\n \n fn $0fun_name(n: u32) -> u32 {\n     n+2\n-}\",\n+}\n+\"#,\n         )\n     }\n \n     #[test]\n     fn argument_used_twice_form_expr() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() -> u32 {\n     let n = 2;\n     $0n+n$0\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() -> u32 {\n     let n = 2;\n     fun_name(n)\n }\n \n fn $0fun_name(n: u32) -> u32 {\n     n+n\n-}\",\n+}\n+\"#,\n         )\n     }\n \n     #[test]\n     fn two_arguments_form_expr() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() -> u32 {\n     let n = 2;\n     let m = 3;\n     $0n+n*m$0\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() -> u32 {\n     let n = 2;\n     let m = 3;\n@@ -1911,21 +1949,23 @@ fn foo() -> u32 {\n \n fn $0fun_name(n: u32, m: u32) -> u32 {\n     n+n*m\n-}\",\n+}\n+\"#,\n         )\n     }\n \n     #[test]\n     fn argument_and_locals() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() -> u32 {\n     let n = 2;\n     $0let m = 1;\n     n + m$0\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() -> u32 {\n     let n = 2;\n     fun_name(n)\n@@ -1934,7 +1974,8 @@ fn foo() -> u32 {\n fn $0fun_name(n: u32) -> u32 {\n     let m = 1;\n     n + m\n-}\",\n+}\n+\"#,\n         )\n     }\n \n@@ -1948,18 +1989,20 @@ fn $0fun_name(n: u32) -> u32 {\n     fn part_of_expr_stmt() {\n         check_assist(\n             extract_function,\n-            \"\n+            r#\"\n fn foo() {\n     $01$0 + 1;\n-}\",\n-            \"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     fun_name() + 1;\n }\n \n fn $0fun_name() -> i32 {\n     1\n-}\",\n+}\n+\"#,\n         );\n     }\n \n@@ -1970,31 +2013,34 @@ fn $0fun_name() -> i32 {\n             r#\"\n fn foo() {\n     $0bar(1 + 1)$0\n-}\"#,\n+}\n+\"#,\n             r#\"\n fn foo() {\n     fun_name();\n }\n \n fn $0fun_name() {\n     bar(1 + 1)\n-}\"#,\n+}\n+\"#,\n         )\n     }\n \n     #[test]\n     fn extract_from_nested() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn main() {\n     let x = true;\n     let tuple = match x {\n         true => ($02 + 2$0, true)\n         _ => (0, false)\n     };\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn main() {\n     let x = true;\n     let tuple = match x {\n@@ -2005,59 +2051,65 @@ fn main() {\n \n fn $0fun_name() -> i32 {\n     2 + 2\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn param_from_closure() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn main() {\n     let lambda = |x: u32| $0x * 2$0;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn main() {\n     let lambda = |x: u32| fun_name(x);\n }\n \n fn $0fun_name(x: u32) -> u32 {\n     x * 2\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn extract_return_stmt() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() -> u32 {\n     $0return 2 + 2$0;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() -> u32 {\n     return fun_name();\n }\n \n fn $0fun_name() -> u32 {\n     2 + 2\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn does_not_add_extra_whitespace() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() -> u32 {\n \n \n     $0return 2 + 2$0;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() -> u32 {\n \n \n@@ -2066,21 +2118,23 @@ fn foo() -> u32 {\n \n fn $0fun_name() -> u32 {\n     2 + 2\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn break_stmt() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn main() {\n     let result = loop {\n         $0break 2 + 2$0;\n     };\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn main() {\n     let result = loop {\n         break fun_name();\n@@ -2089,26 +2143,29 @@ fn main() {\n \n fn $0fun_name() -> i32 {\n     2 + 2\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn extract_cast() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn main() {\n     let v = $00f32 as u32$0;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn main() {\n     let v = fun_name();\n }\n \n fn $0fun_name() -> u32 {\n     0f32 as u32\n-}\",\n+}\n+\"#,\n         );\n     }\n \n@@ -2121,15 +2178,16 @@ fn $0fun_name() -> u32 {\n     fn method_to_freestanding() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n struct S;\n \n impl S {\n     fn foo(&self) -> i32 {\n         $01+1$0\n     }\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n struct S;\n \n impl S {\n@@ -2140,23 +2198,25 @@ impl S {\n \n fn $0fun_name() -> i32 {\n     1+1\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn method_with_reference() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n struct S { f: i32 };\n \n impl S {\n     fn foo(&self) -> i32 {\n         $01+self.f$0\n     }\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n struct S { f: i32 };\n \n impl S {\n@@ -2167,23 +2227,25 @@ impl S {\n     fn $0fun_name(&self) -> i32 {\n         1+self.f\n     }\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn method_with_mut() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n struct S { f: i32 };\n \n impl S {\n     fn foo(&mut self) {\n         $0self.f += 1;$0\n     }\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n struct S { f: i32 };\n \n impl S {\n@@ -2194,21 +2256,23 @@ impl S {\n     fn $0fun_name(&mut self) {\n         self.f += 1;\n     }\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn variable_defined_inside_and_used_after_no_ret() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() {\n     let n = 1;\n     $0let k = n * n;$0\n     let m = k + 1;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     let n = 1;\n     let k = fun_name(n);\n@@ -2218,21 +2282,23 @@ fn foo() {\n fn $0fun_name(n: i32) -> i32 {\n     let k = n * n;\n     k\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn variable_defined_inside_and_used_after_mutably_no_ret() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() {\n     let n = 1;\n     $0let mut k = n * n;$0\n     k += 1;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     let n = 1;\n     let mut k = fun_name(n);\n@@ -2242,22 +2308,24 @@ fn foo() {\n fn $0fun_name(n: i32) -> i32 {\n     let mut k = n * n;\n     k\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn two_variables_defined_inside_and_used_after_no_ret() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() {\n     let n = 1;\n     $0let k = n * n;\n     let m = k + 2;$0\n     let h = k + m;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     let n = 1;\n     let (k, m) = fun_name(n);\n@@ -2268,15 +2336,16 @@ fn $0fun_name(n: i32) -> (i32, i32) {\n     let k = n * n;\n     let m = k + 2;\n     (k, m)\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn multi_variables_defined_inside_and_used_after_mutably_no_ret() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() {\n     let n = 1;\n     $0let mut k = n * n;\n@@ -2285,8 +2354,9 @@ fn foo() {\n     o += 1;$0\n     k += o;\n     m = 1;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     let n = 1;\n     let (mut k, mut m, o) = fun_name(n);\n@@ -2300,21 +2370,23 @@ fn $0fun_name(n: i32) -> (i32, i32, i32) {\n     let mut o = m + 3;\n     o += 1;\n     (k, m, o)\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn nontrivial_patterns_define_variables() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n struct Counter(i32);\n fn foo() {\n     $0let Counter(n) = Counter(0);$0\n     let m = n;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n struct Counter(i32);\n fn foo() {\n     let n = fun_name();\n@@ -2324,21 +2396,23 @@ fn foo() {\n fn $0fun_name() -> i32 {\n     let Counter(n) = Counter(0);\n     n\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn struct_with_two_fields_pattern_define_variables() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n struct Counter { n: i32, m: i32 };\n fn foo() {\n     $0let Counter { n, m: k } = Counter { n: 1, m: 2 };$0\n     let h = n + k;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n struct Counter { n: i32, m: i32 };\n fn foo() {\n     let (n, k) = fun_name();\n@@ -2348,21 +2422,23 @@ fn foo() {\n fn $0fun_name() -> (i32, i32) {\n     let Counter { n, m: k } = Counter { n: 1, m: 2 };\n     (n, k)\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn mut_var_from_outer_scope() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() {\n     let mut n = 1;\n     $0n += 1;$0\n     let m = n + 1;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     let mut n = 1;\n     fun_name(&mut n);\n@@ -2371,22 +2447,24 @@ fn foo() {\n \n fn $0fun_name(n: &mut i32) {\n     *n += 1;\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn mut_field_from_outer_scope() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n struct C { n: i32 }\n fn foo() {\n     let mut c = C { n: 0 };\n     $0c.n += 1;$0\n     let m = c.n + 1;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n struct C { n: i32 }\n fn foo() {\n     let mut c = C { n: 0 };\n@@ -2396,15 +2474,16 @@ fn foo() {\n \n fn $0fun_name(c: &mut C) {\n     c.n += 1;\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn mut_nested_field_from_outer_scope() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n struct P { n: i32}\n struct C { p: P }\n fn foo() {\n@@ -2414,8 +2493,9 @@ fn foo() {\n     $0c.p.n += u.p.n;\n     let r = &mut v.p.n;$0\n     let m = c.p.n + v.p.n + u.p.n;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n struct P { n: i32}\n struct C { p: P }\n fn foo() {\n@@ -2429,15 +2509,16 @@ fn foo() {\n fn $0fun_name(c: &mut C, u: &C, v: &mut C) {\n     c.p.n += u.p.n;\n     let r = &mut v.p.n;\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn mut_param_many_usages_stmt() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn bar(k: i32) {}\n trait I: Copy {\n     fn succ(&self) -> Self;\n@@ -2458,8 +2539,9 @@ fn foo() {\n     *v = v.succ();\n     n.succ();$0\n     let m = n + 1;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn bar(k: i32) {}\n trait I: Copy {\n     fn succ(&self) -> Self;\n@@ -2484,15 +2566,16 @@ fn $0fun_name(n: &mut i32) {\n     let v = n;\n     *v = v.succ();\n     n.succ();\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn mut_param_many_usages_expr() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn bar(k: i32) {}\n trait I: Copy {\n     fn succ(&self) -> Self;\n@@ -2515,8 +2598,9 @@ fn foo() {\n         n.succ();\n     }$0\n     let m = n + 1;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn bar(k: i32) {}\n trait I: Copy {\n     fn succ(&self) -> Self;\n@@ -2541,19 +2625,21 @@ fn $0fun_name(n: &mut i32) {\n     let v = n;\n     *v = v.succ();\n     n.succ();\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn mut_param_by_value() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() {\n     let mut n = 1;\n     $0n += 1;$0\n-}\",\n+}\n+\"#,\n             r\"\n fn foo() {\n     let mut n = 1;\n@@ -2562,22 +2648,24 @@ fn foo() {\n \n fn $0fun_name(mut n: i32) {\n     n += 1;\n-}\",\n+}\n+\",\n         );\n     }\n \n     #[test]\n     fn mut_param_because_of_mut_ref() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() {\n     let mut n = 1;\n     $0let v = &mut n;\n     *v += 1;$0\n     let k = n;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     let mut n = 1;\n     fun_name(&mut n);\n@@ -2587,7 +2675,8 @@ fn foo() {\n fn $0fun_name(n: &mut i32) {\n     let v = n;\n     *v += 1;\n-}\",\n+}\n+\"#,\n         );\n     }\n \n@@ -2600,8 +2689,9 @@ fn foo() {\n     let mut n = 1;\n     $0let v = &mut n;\n     *v += 1;$0\n-}\",\n-            r\"\n+}\n+\",\n+            r#\"\n fn foo() {\n     let mut n = 1;\n     fun_name(n);\n@@ -2610,15 +2700,16 @@ fn foo() {\n fn $0fun_name(mut n: i32) {\n     let v = &mut n;\n     *v += 1;\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn mut_method_call() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n trait I {\n     fn inc(&mut self);\n }\n@@ -2628,8 +2719,9 @@ impl I for i32 {\n fn foo() {\n     let mut n = 1;\n     $0n.inc();$0\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n trait I {\n     fn inc(&mut self);\n }\n@@ -2643,15 +2735,16 @@ fn foo() {\n \n fn $0fun_name(mut n: i32) {\n     n.inc();\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn shared_method_call() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n trait I {\n     fn succ(&self);\n }\n@@ -2661,7 +2754,8 @@ impl I for i32 {\n fn foo() {\n     let mut n = 1;\n     $0n.succ();$0\n-}\",\n+}\n+\"#,\n             r\"\n trait I {\n     fn succ(&self);\n@@ -2676,15 +2770,16 @@ fn foo() {\n \n fn $0fun_name(n: i32) {\n     n.succ();\n-}\",\n+}\n+\",\n         );\n     }\n \n     #[test]\n     fn mut_method_call_with_other_receiver() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n trait I {\n     fn inc(&mut self, n: i32);\n }\n@@ -2695,7 +2790,8 @@ fn foo() {\n     let mut n = 1;\n     $0let mut m = 2;\n     m.inc(n);$0\n-}\",\n+}\n+\"#,\n             r\"\n trait I {\n     fn inc(&mut self, n: i32);\n@@ -2711,20 +2807,22 @@ fn foo() {\n fn $0fun_name(n: i32) {\n     let mut m = 2;\n     m.inc(n);\n-}\",\n+}\n+\",\n         );\n     }\n \n     #[test]\n     fn non_copy_without_usages_after() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n struct Counter(i32);\n fn foo() {\n     let c = Counter(0);\n     $0let n = c.0;$0\n-}\",\n+}\n+\"#,\n             r\"\n struct Counter(i32);\n fn foo() {\n@@ -2734,7 +2832,8 @@ fn foo() {\n \n fn $0fun_name(c: Counter) {\n     let n = c.0;\n-}\",\n+}\n+\",\n         );\n     }\n \n@@ -2748,8 +2847,9 @@ fn foo() {\n     let c = Counter(0);\n     $0let n = c.0;$0\n     let m = c.0;\n-}\",\n-            r\"\n+}\n+\",\n+            r#\"\n struct Counter(i32);\n fn foo() {\n     let c = Counter(0);\n@@ -2759,27 +2859,24 @@ fn foo() {\n \n fn $0fun_name(c: &Counter) {\n     let n = c.0;\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn copy_used_after() {\n         check_assist(\n             extract_function,\n-            r##\"\n-#[lang = \"copy\"]\n-pub trait Copy {}\n-impl Copy for i32 {}\n+            r#\"\n+//- minicore: copy\n fn foo() {\n     let n = 0;\n     $0let m = n;$0\n     let k = n;\n-}\"##,\n-            r##\"\n-#[lang = \"copy\"]\n-pub trait Copy {}\n-impl Copy for i32 {}\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     let n = 0;\n     fun_name(n);\n@@ -2788,29 +2885,28 @@ fn foo() {\n \n fn $0fun_name(n: i32) {\n     let m = n;\n-}\"##,\n+}\n+\"#,\n         )\n     }\n \n     #[test]\n     fn copy_custom_used_after() {\n         check_assist(\n             extract_function,\n-            r##\"\n-#[lang = \"copy\"]\n-pub trait Copy {}\n+            r#\"\n+//- minicore: copy, derive\n+#[derive(Clone, Copy)]\n struct Counter(i32);\n-impl Copy for Counter {}\n fn foo() {\n     let c = Counter(0);\n     $0let n = c.0;$0\n     let m = c.0;\n-}\"##,\n-            r##\"\n-#[lang = \"copy\"]\n-pub trait Copy {}\n+}\n+\"#,\n+            r#\"\n+#[derive(Clone, Copy)]\n struct Counter(i32);\n-impl Copy for Counter {}\n fn foo() {\n     let c = Counter(0);\n     fun_name(c);\n@@ -2819,24 +2915,26 @@ fn foo() {\n \n fn $0fun_name(c: Counter) {\n     let n = c.0;\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn indented_stmts() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n fn foo() {\n     if true {\n         loop {\n             $0let n = 1;\n             let m = 2;$0\n         }\n     }\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     if true {\n         loop {\n@@ -2848,15 +2946,16 @@ fn foo() {\n fn $0fun_name() {\n     let n = 1;\n     let m = 2;\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn indented_stmts_inside_mod() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n mod bar {\n     fn foo() {\n         if true {\n@@ -2866,8 +2965,9 @@ mod bar {\n             }\n         }\n     }\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n mod bar {\n     fn foo() {\n         if true {\n@@ -2881,15 +2981,16 @@ mod bar {\n         let n = 1;\n         let m = 2;\n     }\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn break_loop() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n enum Option<T> {\n     #[lang = \"None\"] None,\n     #[lang = \"Some\"] Some(T),\n@@ -2903,8 +3004,9 @@ fn foo() {\n         let k = 2;$0\n         let h = 1 + k;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n enum Option<T> {\n     #[lang = \"None\"] None,\n     #[lang = \"Some\"] Some(T),\n@@ -2926,39 +3028,26 @@ fn $0fun_name(n: i32) -> Option<i32> {\n     return None;\n     let k = 2;\n     Some(k)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn return_to_parent() {\n         check_assist(\n             extract_function,\n-            r##\"\n-#[lang = \"copy\"]\n-pub trait Copy {}\n-impl Copy for i32 {}\n-enum Result<T, E> {\n-    #[lang = \"Ok\"] Ok(T),\n-    #[lang = \"Err\"] Err(E),\n-}\n-use Result::*;\n+            r#\"\n+//- minicore: copy, result\n fn foo() -> i64 {\n     let n = 1;\n     $0let m = n + 1;\n     return 1;\n     let k = 2;$0\n     (n + k) as i64\n-}\"##,\n-            r##\"\n-#[lang = \"copy\"]\n-pub trait Copy {}\n-impl Copy for i32 {}\n-enum Result<T, E> {\n-    #[lang = \"Ok\"] Ok(T),\n-    #[lang = \"Err\"] Err(E),\n-}\n-use Result::*;\n+}\n+\"#,\n+            r#\"\n fn foo() -> i64 {\n     let n = 1;\n     let k = match fun_name(n) {\n@@ -2973,7 +3062,8 @@ fn $0fun_name(n: i32) -> Result<i32, i64> {\n     return Err(1);\n     let k = 2;\n     Ok(k)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n@@ -2982,7 +3072,7 @@ fn $0fun_name(n: i32) -> Result<i32, i64> {\n         cov_mark::check!(external_control_flow_break_and_continue);\n         check_assist_not_applicable(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -2993,7 +3083,8 @@ fn foo() {\n         let k = k + 1;$0\n         let r = n + k;\n     }\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n@@ -3002,7 +3093,7 @@ fn foo() {\n         cov_mark::check!(external_control_flow_return_and_bc);\n         check_assist_not_applicable(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3013,15 +3104,16 @@ fn foo() {\n         let k = k + 1;$0\n         let r = n + k;\n     }\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn break_loop_with_if() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() {\n     loop {\n         let mut n = 1;\n@@ -3030,8 +3122,9 @@ fn foo() {\n         n += m;$0\n         let h = 1 + n;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     loop {\n         let mut n = 1;\n@@ -3047,15 +3140,16 @@ fn $0fun_name(n: &mut i32) -> bool {\n     return true;\n     *n += m;\n     false\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn break_loop_nested() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() {\n     loop {\n         let mut n = 1;\n@@ -3065,8 +3159,9 @@ fn foo() {\n         }$0\n         let h = 1;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     loop {\n         let mut n = 1;\n@@ -3083,15 +3178,16 @@ fn $0fun_name(n: i32) -> bool {\n         return true;\n     }\n     false\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn return_from_nested_loop() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3103,8 +3199,9 @@ fn foo() {\n         let m = k + 1;$0\n         let h = 1 + m;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3123,15 +3220,16 @@ fn $0fun_name() -> Option<i32> {\n     }\n     let m = k + 1;\n     Some(m)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn break_from_nested_loop() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3142,8 +3240,9 @@ fn foo() {\n         let m = k + 1;$0\n         let h = 1 + m;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3159,15 +3258,16 @@ fn $0fun_name() -> i32 {\n     }\n     let m = k + 1;\n     m\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn break_from_nested_and_outer_loops() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3181,8 +3281,9 @@ fn foo() {\n         let m = k + 1;$0\n         let h = 1 + m;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3204,15 +3305,16 @@ fn $0fun_name() -> Option<i32> {\n     }\n     let m = k + 1;\n     Some(m)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn return_from_nested_fn() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3223,8 +3325,9 @@ fn foo() {\n         let m = k + 1;$0\n         let h = 1 + m;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n fn foo() {\n     loop {\n         let n = 1;\n@@ -3240,15 +3343,16 @@ fn $0fun_name() -> i32 {\n     }\n     let m = k + 1;\n     m\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn break_with_value() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() -> i32 {\n     loop {\n         let n = 1;\n@@ -3259,8 +3363,9 @@ fn foo() -> i32 {\n         let m = k + 1;$0\n         let h = 1;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n fn foo() -> i32 {\n     loop {\n         let n = 1;\n@@ -3278,15 +3383,16 @@ fn $0fun_name() -> Option<i32> {\n     }\n     let m = k + 1;\n     None\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn break_with_value_and_return() {\n         check_assist(\n             extract_function,\n-            r##\"\n+            r#\"\n fn foo() -> i64 {\n     loop {\n         let n = 1;\n@@ -3298,8 +3404,9 @@ fn foo() -> i64 {\n         let m = k + 1;$0\n         let h = 1 + m;\n     }\n-}\"##,\n-            r##\"\n+}\n+\"#,\n+            r#\"\n fn foo() -> i64 {\n     loop {\n         let n = 1;\n@@ -3318,28 +3425,27 @@ fn $0fun_name() -> Result<i32, i64> {\n     }\n     let m = k + 1;\n     Ok(m)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn try_option() {\n         check_assist(\n             extract_function,\n-            r##\"\n-enum Option<T> { None, Some(T), }\n-use Option::*;\n+            r#\"\n+//- minicore: option\n fn bar() -> Option<i32> { None }\n fn foo() -> Option<()> {\n     let n = bar()?;\n     $0let k = foo()?;\n     let m = k + 1;$0\n     let h = 1 + m;\n     Some(())\n-}\"##,\n-            r##\"\n-enum Option<T> { None, Some(T), }\n-use Option::*;\n+}\n+\"#,\n+            r#\"\n fn bar() -> Option<i32> { None }\n fn foo() -> Option<()> {\n     let n = bar()?;\n@@ -3352,27 +3458,26 @@ fn $0fun_name() -> Option<i32> {\n     let k = foo()?;\n     let m = k + 1;\n     Some(m)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn try_option_unit() {\n         check_assist(\n             extract_function,\n-            r##\"\n-enum Option<T> { None, Some(T), }\n-use Option::*;\n+            r#\"\n+//- minicore: option\n fn foo() -> Option<()> {\n     let n = 1;\n     $0let k = foo()?;\n     let m = k + 1;$0\n     let h = 1 + n;\n     Some(())\n-}\"##,\n-            r##\"\n-enum Option<T> { None, Some(T), }\n-use Option::*;\n+}\n+\"#,\n+            r#\"\n fn foo() -> Option<()> {\n     let n = 1;\n     fun_name()?;\n@@ -3384,27 +3489,26 @@ fn $0fun_name() -> Option<()> {\n     let k = foo()?;\n     let m = k + 1;\n     Some(())\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn try_result() {\n         check_assist(\n             extract_function,\n-            r##\"\n-enum Result<T, E> { Ok(T), Err(E), }\n-use Result::*;\n+            r#\"\n+//- minicore: result\n fn foo() -> Result<(), i64> {\n     let n = 1;\n     $0let k = foo()?;\n     let m = k + 1;$0\n     let h = 1 + m;\n     Ok(())\n-}\"##,\n-            r##\"\n-enum Result<T, E> { Ok(T), Err(E), }\n-use Result::*;\n+}\n+\"#,\n+            r#\"\n fn foo() -> Result<(), i64> {\n     let n = 1;\n     let m = fun_name()?;\n@@ -3416,17 +3520,17 @@ fn $0fun_name() -> Result<i32, i64> {\n     let k = foo()?;\n     let m = k + 1;\n     Ok(m)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn try_option_with_return() {\n         check_assist(\n             extract_function,\n-            r##\"\n-enum Option<T> { None, Some(T) }\n-use Option::*;\n+            r#\"\n+//- minicore: option\n fn foo() -> Option<()> {\n     let n = 1;\n     $0let k = foo()?;\n@@ -3436,10 +3540,9 @@ fn foo() -> Option<()> {\n     let m = k + 1;$0\n     let h = 1 + m;\n     Some(())\n-}\"##,\n-            r##\"\n-enum Option<T> { None, Some(T) }\n-use Option::*;\n+}\n+\"#,\n+            r#\"\n fn foo() -> Option<()> {\n     let n = 1;\n     let m = fun_name()?;\n@@ -3454,17 +3557,17 @@ fn $0fun_name() -> Option<i32> {\n     }\n     let m = k + 1;\n     Some(m)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn try_result_with_return() {\n         check_assist(\n             extract_function,\n-            r##\"\n-enum Result<T, E> { Ok(T), Err(E), }\n-use Result::*;\n+            r#\"\n+//- minicore: result\n fn foo() -> Result<(), i64> {\n     let n = 1;\n     $0let k = foo()?;\n@@ -3474,10 +3577,9 @@ fn foo() -> Result<(), i64> {\n     let m = k + 1;$0\n     let h = 1 + m;\n     Ok(())\n-}\"##,\n-            r##\"\n-enum Result<T, E> { Ok(T), Err(E), }\n-use Result::*;\n+}\n+\"#,\n+            r#\"\n fn foo() -> Result<(), i64> {\n     let n = 1;\n     let m = fun_name()?;\n@@ -3492,7 +3594,8 @@ fn $0fun_name() -> Result<i32, i64> {\n     }\n     let m = k + 1;\n     Ok(m)\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n@@ -3501,9 +3604,8 @@ fn $0fun_name() -> Result<i32, i64> {\n         cov_mark::check!(external_control_flow_try_and_bc);\n         check_assist_not_applicable(\n             extract_function,\n-            r##\"\n-enum Option<T> { None, Some(T) }\n-use Option::*;\n+            r#\"\n+//- minicore: option\n fn foo() -> Option<()> {\n     loop {\n         let n = Some(1);\n@@ -3514,7 +3616,8 @@ fn foo() -> Option<()> {\n         let r = n + k;\n     }\n     Some(())\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n@@ -3523,9 +3626,8 @@ fn foo() -> Option<()> {\n         cov_mark::check!(external_control_flow_try_and_return_non_err);\n         check_assist_not_applicable(\n             extract_function,\n-            r##\"\n-enum Result<T, E> { Ok(T), Err(E), }\n-use Result::*;\n+            r#\"\n+//- minicore: result\n fn foo() -> Result<(), i64> {\n     let n = 1;\n     $0let k = foo()?;\n@@ -3535,15 +3637,16 @@ fn foo() -> Result<(), i64> {\n     let m = k + 1;$0\n     let h = 1 + m;\n     Ok(())\n-}\"##,\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn param_usage_in_macro() {\n         check_assist(\n             extract_function,\n-            r\"\n+            r#\"\n macro_rules! m {\n     ($val:expr) => { $val };\n }\n@@ -3552,8 +3655,9 @@ fn foo() {\n     let n = 1;\n     $0let k = n * m!(n);$0\n     let m = k + 1;\n-}\",\n-            r\"\n+}\n+\"#,\n+            r#\"\n macro_rules! m {\n     ($val:expr) => { $val };\n }\n@@ -3567,15 +3671,17 @@ fn foo() {\n fn $0fun_name(n: i32) -> i32 {\n     let k = n * m!(n);\n     k\n-}\",\n+}\n+\"#,\n         );\n     }\n \n     #[test]\n     fn extract_with_await() {\n         check_assist(\n             extract_function,\n-            r#\"fn main() {\n+            r#\"\n+fn main() {\n     $0some_function().await;$0\n }\n \n@@ -3603,7 +3709,8 @@ async fn some_function() {\n     fn extract_with_await_in_args() {\n         check_assist(\n             extract_function,\n-            r#\"fn main() {\n+            r#\"\n+fn main() {\n     $0function_call(\"a\", some_function().await);$0\n }\n "}, {"sha": "76902858088a05e036e99770f99146b15dde56a2", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=15c4b3fa7f9d97029d64a7e13a12aa1ee42316d7", "patch": "@@ -23,6 +23,8 @@\n //!     iterator: option\n //!     iterators: iterator\n //!     default: sized\n+//!     clone: sized\n+//!     copy: clone\n //!     from: sized\n //!     eq: sized\n //!     ord: eq, option\n@@ -40,6 +42,38 @@ pub mod marker {\n     #[lang = \"unsize\"]\n     pub trait Unsize<T: ?Sized> {}\n     // endregion:unsize\n+\n+    // region:copy\n+    #[lang = \"copy\"]\n+    pub trait Copy: Clone {}\n+    // region:derive\n+    #[rustc_builtin_macro]\n+    pub macro Copy($item:item) {}\n+    // endregion:derive\n+\n+    mod copy_impls {\n+        use super::Copy;\n+\n+        macro_rules! impl_copy {\n+            ($($t:ty)*) => {\n+                $(\n+                    impl Copy for $t {}\n+                )*\n+            }\n+        }\n+\n+        impl_copy! {\n+            usize u8 u16 u32 u64 u128\n+            isize i8 i16 i32 i64 i128\n+            f32 f64\n+            bool char\n+        }\n+\n+        impl<T: ?Sized> Copy for *const T {}\n+        impl<T: ?Sized> Copy for *mut T {}\n+        impl<T: ?Sized> Copy for &T {}\n+    }\n+    // endregion:copy\n }\n \n // region:default\n@@ -50,6 +84,19 @@ pub mod default {\n }\n // endregion:default\n \n+// region:clone\n+pub mod clone {\n+    #[lang = \"clone\"]\n+    pub trait Clone: Sized {\n+        fn clone(&self) -> Self;\n+    }\n+    // region:derive\n+    #[rustc_builtin_macro]\n+    pub macro Clone($item:item) {}\n+    // endregion:derive\n+}\n+// endregion:clone\n+\n // region:from\n pub mod convert {\n     pub trait From<T>: Sized {\n@@ -114,9 +161,11 @@ pub mod ops {\n         }\n         // endregion:deref_mut\n     }\n-    pub use self::deref::Deref;\n-    pub use self::deref::DerefMut; //:deref_mut\n-                                   // endregion:deref\n+    pub use self::deref::{\n+        Deref,\n+        DerefMut, // :deref_mut\n+    };\n+    // endregion:deref\n \n     // region:range\n     mod range {\n@@ -402,12 +451,14 @@ mod macros {\n pub mod prelude {\n     pub mod v1 {\n         pub use crate::{\n+            clone::Clone,                       // :clone\n             cmp::{Eq, PartialEq},               // :eq\n             cmp::{Ord, PartialOrd},             // :ord\n             convert::{From, Into},              // :from\n             default::Default,                   // :default\n             iter::{IntoIterator, Iterator},     // :iterator\n             macros::builtin::derive,            // :derive\n+            marker::Copy,                       // :copy\n             marker::Sized,                      // :sized\n             ops::{Fn, FnMut, FnOnce},           // :fn\n             option::Option::{self, None, Some}, // :option"}]}