{"sha": "6bf7faf315c57dbec6cb3d5a7c7089016603b309", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZiZjdmYWYzMTVjNTdkYmVjNmNiM2Q1YTdjNzA4OTAxNjYwM2IzMDk=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-29T12:11:42Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-10-29T12:11:42Z"}, "message": "flatten hir_expand", "tree": {"sha": "15bf7df06a6ebf8e59b466b8877214ac5aa9c98b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/15bf7df06a6ebf8e59b466b8877214ac5aa9c98b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6bf7faf315c57dbec6cb3d5a7c7089016603b309", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6bf7faf315c57dbec6cb3d5a7c7089016603b309", "html_url": "https://github.com/rust-lang/rust/commit/6bf7faf315c57dbec6cb3d5a7c7089016603b309", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6bf7faf315c57dbec6cb3d5a7c7089016603b309/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dba767802d05c493b7798b0173a2d102dcc73a95", "url": "https://api.github.com/repos/rust-lang/rust/commits/dba767802d05c493b7798b0173a2d102dcc73a95", "html_url": "https://github.com/rust-lang/rust/commit/dba767802d05c493b7798b0173a2d102dcc73a95"}], "stats": {"total": 504, "additions": 243, "deletions": 261}, "files": [{"sha": "dea288eb7bc974898fd43dbdfa21e2c5278c0c01", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6bf7faf315c57dbec6cb3d5a7c7089016603b309/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf7faf315c57dbec6cb3d5a7c7089016603b309/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=6bf7faf315c57dbec6cb3d5a7c7089016603b309", "patch": "@@ -15,9 +15,7 @@ use crate::{\n     AstId, FileAstId, Module, Source,\n };\n \n-pub use hir_expand::expand::{\n-    HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, MacroFileKind,\n-};\n+pub use hir_expand::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, MacroFileKind};\n \n macro_rules! impl_intern_key {\n     ($name:ident) => {"}, {"sha": "c69a2afeb6834d391afb850450b1115bec095c16", "filename": "crates/ra_hir/src/source_id.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6bf7faf315c57dbec6cb3d5a7c7089016603b309/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf7faf315c57dbec6cb3d5a7c7089016603b309/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=6bf7faf315c57dbec6cb3d5a7c7089016603b309", "patch": "@@ -2,5 +2,5 @@\n \n pub use hir_expand::{\n     ast_id_map::{AstIdMap, ErasedFileAstId, FileAstId},\n-    expand::AstId,\n+    AstId,\n };"}, {"sha": "912599e5716617597a26a35afbf78490f01efc97", "filename": "crates/ra_hir_expand/src/db.rs", "status": "modified", "additions": 73, "deletions": 7, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/6bf7faf315c57dbec6cb3d5a7c7089016603b309/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf7faf315c57dbec6cb3d5a7c7089016603b309/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fdb.rs?ref=6bf7faf315c57dbec6cb3d5a7c7089016603b309", "patch": "@@ -1,11 +1,13 @@\n use std::sync::Arc;\n \n+use mbe::MacroRules;\n use ra_db::{salsa, SourceDatabase};\n-use ra_syntax::{Parse, SyntaxNode};\n+use ra_prof::profile;\n+use ra_syntax::{AstNode, Parse, SyntaxNode};\n \n use crate::{\n     ast_id_map::{AstIdMap, ErasedFileAstId},\n-    expand::{HirFileId, MacroCallId, MacroCallLoc, MacroDefId, MacroFile},\n+    HirFileId, HirFileIdRepr, MacroCallId, MacroCallLoc, MacroDefId, MacroFile, MacroFileKind,\n };\n \n #[salsa::query_group(AstDatabaseStorage)]\n@@ -15,18 +17,13 @@ pub trait AstDatabase: SourceDatabase {\n     fn ast_id_to_node(&self, file_id: HirFileId, ast_id: ErasedFileAstId) -> SyntaxNode;\n \n     #[salsa::transparent]\n-    #[salsa::invoke(crate::expand::parse_or_expand_query)]\n     fn parse_or_expand(&self, file_id: HirFileId) -> Option<SyntaxNode>;\n \n     #[salsa::interned]\n     fn intern_macro(&self, macro_call: MacroCallLoc) -> MacroCallId;\n-    #[salsa::invoke(crate::expand::macro_arg_query)]\n     fn macro_arg(&self, id: MacroCallId) -> Option<Arc<tt::Subtree>>;\n-    #[salsa::invoke(crate::expand::macro_def_query)]\n     fn macro_def(&self, id: MacroDefId) -> Option<Arc<mbe::MacroRules>>;\n-    #[salsa::invoke(crate::expand::parse_macro_query)]\n     fn parse_macro(&self, macro_file: MacroFile) -> Option<Parse<SyntaxNode>>;\n-    #[salsa::invoke(crate::expand::macro_expand_query)]\n     fn macro_expand(&self, macro_call: MacroCallId) -> Result<Arc<tt::Subtree>, String>;\n }\n \n@@ -44,3 +41,72 @@ pub(crate) fn ast_id_to_node(\n     let node = db.parse_or_expand(file_id).unwrap();\n     db.ast_id_map(file_id)[ast_id].to_node(&node)\n }\n+\n+pub(crate) fn macro_def(db: &impl AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n+    let macro_call = id.ast_id.to_node(db);\n+    let arg = macro_call.token_tree()?;\n+    let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n+        log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n+        None\n+    })?;\n+    let rules = MacroRules::parse(&tt).ok().or_else(|| {\n+        log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n+        None\n+    })?;\n+    Some(Arc::new(rules))\n+}\n+\n+pub(crate) fn macro_arg(db: &impl AstDatabase, id: MacroCallId) -> Option<Arc<tt::Subtree>> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_call = loc.ast_id.to_node(db);\n+    let arg = macro_call.token_tree()?;\n+    let (tt, _) = mbe::ast_to_token_tree(&arg)?;\n+    Some(Arc::new(tt))\n+}\n+\n+pub(crate) fn macro_expand(\n+    db: &impl AstDatabase,\n+    id: MacroCallId,\n+) -> Result<Arc<tt::Subtree>, String> {\n+    let loc = db.lookup_intern_macro(id);\n+    let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n+\n+    let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n+    let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n+    // Set a hard limit for the expanded tt\n+    let count = tt.count();\n+    if count > 65536 {\n+        return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n+    }\n+    Ok(Arc::new(tt))\n+}\n+\n+pub(crate) fn parse_or_expand(db: &impl AstDatabase, file_id: HirFileId) -> Option<SyntaxNode> {\n+    match file_id.0 {\n+        HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n+        HirFileIdRepr::MacroFile(macro_file) => {\n+            db.parse_macro(macro_file).map(|it| it.syntax_node())\n+        }\n+    }\n+}\n+\n+pub(crate) fn parse_macro(\n+    db: &impl AstDatabase,\n+    macro_file: MacroFile,\n+) -> Option<Parse<SyntaxNode>> {\n+    let _p = profile(\"parse_macro_query\");\n+    let macro_call_id = macro_file.macro_call_id;\n+    let tt = db\n+        .macro_expand(macro_call_id)\n+        .map_err(|err| {\n+            // Note:\n+            // The final goal we would like to make all parse_macro success,\n+            // such that the following log will not call anyway.\n+            log::warn!(\"fail on macro_parse: (reason: {})\", err,);\n+        })\n+        .ok()?;\n+    match macro_file.macro_file_kind {\n+        MacroFileKind::Items => mbe::token_tree_to_items(&tt).ok().map(Parse::to_syntax),\n+        MacroFileKind::Expr => mbe::token_tree_to_expr(&tt).ok().map(Parse::to_syntax),\n+    }\n+}"}, {"sha": "3921175cb0de64156acea2009a0ac652d60da1dd", "filename": "crates/ra_hir_expand/src/expand.rs", "status": "removed", "additions": 0, "deletions": 248, "changes": 248, "blob_url": "https://github.com/rust-lang/rust/blob/dba767802d05c493b7798b0173a2d102dcc73a95/crates%2Fra_hir_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dba767802d05c493b7798b0173a2d102dcc73a95/crates%2Fra_hir_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Fexpand.rs?ref=dba767802d05c493b7798b0173a2d102dcc73a95", "patch": "@@ -1,248 +0,0 @@\n-use std::{\n-    hash::{Hash, Hasher},\n-    sync::Arc,\n-};\n-\n-use mbe::MacroRules;\n-use ra_db::{salsa, CrateId, FileId};\n-use ra_prof::profile;\n-use ra_syntax::{\n-    ast::{self, AstNode},\n-    Parse, SyntaxNode,\n-};\n-\n-use crate::{ast_id_map::FileAstId, db::AstDatabase};\n-\n-macro_rules! impl_intern_key {\n-    ($name:ident) => {\n-        impl salsa::InternKey for $name {\n-            fn from_intern_id(v: salsa::InternId) -> Self {\n-                $name(v)\n-            }\n-            fn as_intern_id(&self) -> salsa::InternId {\n-                self.0\n-            }\n-        }\n-    };\n-}\n-\n-/// Input to the analyzer is a set of files, where each file is identified by\n-/// `FileId` and contains source code. However, another source of source code in\n-/// Rust are macros: each macro can be thought of as producing a \"temporary\n-/// file\". To assign an id to such a file, we use the id of the macro call that\n-/// produced the file. So, a `HirFileId` is either a `FileId` (source code\n-/// written by user), or a `MacroCallId` (source code produced by macro).\n-///\n-/// What is a `MacroCallId`? Simplifying, it's a `HirFileId` of a file\n-/// containing the call plus the offset of the macro call in the file. Note that\n-/// this is a recursive definition! However, the size_of of `HirFileId` is\n-/// finite (because everything bottoms out at the real `FileId`) and small\n-/// (`MacroCallId` uses the location interner).\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct HirFileId(HirFileIdRepr);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-enum HirFileIdRepr {\n-    FileId(FileId),\n-    MacroFile(MacroFile),\n-}\n-\n-impl From<FileId> for HirFileId {\n-    fn from(id: FileId) -> Self {\n-        HirFileId(HirFileIdRepr::FileId(id))\n-    }\n-}\n-\n-impl From<MacroFile> for HirFileId {\n-    fn from(id: MacroFile) -> Self {\n-        HirFileId(HirFileIdRepr::MacroFile(id))\n-    }\n-}\n-\n-impl HirFileId {\n-    /// For macro-expansion files, returns the file original source file the\n-    /// expansion originated from.\n-    pub fn original_file(self, db: &impl AstDatabase) -> FileId {\n-        match self.0 {\n-            HirFileIdRepr::FileId(file_id) => file_id,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                loc.ast_id.file_id().original_file(db)\n-            }\n-        }\n-    }\n-\n-    /// Get the crate which the macro lives in, if it is a macro file.\n-    pub fn macro_crate(self, db: &impl AstDatabase) -> Option<CrateId> {\n-        match self.0 {\n-            HirFileIdRepr::FileId(_) => None,\n-            HirFileIdRepr::MacroFile(macro_file) => {\n-                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n-                Some(loc.def.krate)\n-            }\n-        }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroFile {\n-    macro_call_id: MacroCallId,\n-    macro_file_kind: MacroFileKind,\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum MacroFileKind {\n-    Items,\n-    Expr,\n-}\n-\n-/// `MacroCallId` identifies a particular macro invocation, like\n-/// `println!(\"Hello, {}\", world)`.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroCallId(salsa::InternId);\n-impl_intern_key!(MacroCallId);\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct MacroDefId {\n-    pub krate: CrateId,\n-    pub ast_id: AstId<ast::MacroCall>,\n-}\n-\n-#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n-pub struct MacroCallLoc {\n-    pub def: MacroDefId,\n-    pub ast_id: AstId<ast::MacroCall>,\n-}\n-\n-impl MacroCallId {\n-    pub fn loc(self, db: &impl AstDatabase) -> MacroCallLoc {\n-        db.lookup_intern_macro(self)\n-    }\n-\n-    pub fn as_file(self, kind: MacroFileKind) -> HirFileId {\n-        let macro_file = MacroFile { macro_call_id: self, macro_file_kind: kind };\n-        macro_file.into()\n-    }\n-}\n-\n-impl MacroCallLoc {\n-    pub fn id(self, db: &impl AstDatabase) -> MacroCallId {\n-        db.intern_macro(self)\n-    }\n-}\n-\n-/// `AstId` points to an AST node in any file.\n-///\n-/// It is stable across reparses, and can be used as salsa key/value.\n-// FIXME: isn't this just a `Source<FileAstId<N>>` ?\n-#[derive(Debug)]\n-pub struct AstId<N: AstNode> {\n-    file_id: HirFileId,\n-    file_ast_id: FileAstId<N>,\n-}\n-\n-impl<N: AstNode> Clone for AstId<N> {\n-    fn clone(&self) -> AstId<N> {\n-        *self\n-    }\n-}\n-impl<N: AstNode> Copy for AstId<N> {}\n-\n-impl<N: AstNode> PartialEq for AstId<N> {\n-    fn eq(&self, other: &Self) -> bool {\n-        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n-    }\n-}\n-impl<N: AstNode> Eq for AstId<N> {}\n-impl<N: AstNode> Hash for AstId<N> {\n-    fn hash<H: Hasher>(&self, hasher: &mut H) {\n-        (self.file_id, self.file_ast_id).hash(hasher);\n-    }\n-}\n-\n-impl<N: AstNode> AstId<N> {\n-    pub fn new(file_id: HirFileId, file_ast_id: FileAstId<N>) -> AstId<N> {\n-        AstId { file_id, file_ast_id }\n-    }\n-\n-    pub fn file_id(&self) -> HirFileId {\n-        self.file_id\n-    }\n-\n-    pub fn to_node(&self, db: &impl AstDatabase) -> N {\n-        let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.into());\n-        N::cast(syntax_node).unwrap()\n-    }\n-}\n-\n-pub(crate) fn macro_def_query(db: &impl AstDatabase, id: MacroDefId) -> Option<Arc<MacroRules>> {\n-    let macro_call = id.ast_id.to_node(db);\n-    let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(&arg).or_else(|| {\n-        log::warn!(\"fail on macro_def to token tree: {:#?}\", arg);\n-        None\n-    })?;\n-    let rules = MacroRules::parse(&tt).ok().or_else(|| {\n-        log::warn!(\"fail on macro_def parse: {:#?}\", tt);\n-        None\n-    })?;\n-    Some(Arc::new(rules))\n-}\n-\n-pub(crate) fn macro_arg_query(db: &impl AstDatabase, id: MacroCallId) -> Option<Arc<tt::Subtree>> {\n-    let loc = db.lookup_intern_macro(id);\n-    let macro_call = loc.ast_id.to_node(db);\n-    let arg = macro_call.token_tree()?;\n-    let (tt, _) = mbe::ast_to_token_tree(&arg)?;\n-    Some(Arc::new(tt))\n-}\n-\n-pub(crate) fn macro_expand_query(\n-    db: &impl AstDatabase,\n-    id: MacroCallId,\n-) -> Result<Arc<tt::Subtree>, String> {\n-    let loc = db.lookup_intern_macro(id);\n-    let macro_arg = db.macro_arg(id).ok_or(\"Fail to args in to tt::TokenTree\")?;\n-\n-    let macro_rules = db.macro_def(loc.def).ok_or(\"Fail to find macro definition\")?;\n-    let tt = macro_rules.expand(&macro_arg).map_err(|err| format!(\"{:?}\", err))?;\n-    // Set a hard limit for the expanded tt\n-    let count = tt.count();\n-    if count > 65536 {\n-        return Err(format!(\"Total tokens count exceed limit : count = {}\", count));\n-    }\n-    Ok(Arc::new(tt))\n-}\n-\n-pub(crate) fn parse_or_expand_query(\n-    db: &impl AstDatabase,\n-    file_id: HirFileId,\n-) -> Option<SyntaxNode> {\n-    match file_id.0 {\n-        HirFileIdRepr::FileId(file_id) => Some(db.parse(file_id).tree().syntax().clone()),\n-        HirFileIdRepr::MacroFile(macro_file) => {\n-            db.parse_macro(macro_file).map(|it| it.syntax_node())\n-        }\n-    }\n-}\n-\n-pub(crate) fn parse_macro_query(\n-    db: &impl AstDatabase,\n-    macro_file: MacroFile,\n-) -> Option<Parse<SyntaxNode>> {\n-    let _p = profile(\"parse_macro_query\");\n-    let macro_call_id = macro_file.macro_call_id;\n-    let tt = db\n-        .macro_expand(macro_call_id)\n-        .map_err(|err| {\n-            // Note:\n-            // The final goal we would like to make all parse_macro success,\n-            // such that the following log will not call anyway.\n-            log::warn!(\"fail on macro_parse: (reason: {})\", err,);\n-        })\n-        .ok()?;\n-    match macro_file.macro_file_kind {\n-        MacroFileKind::Items => mbe::token_tree_to_items(&tt).ok().map(Parse::to_syntax),\n-        MacroFileKind::Expr => mbe::token_tree_to_expr(&tt).ok().map(Parse::to_syntax),\n-    }\n-}"}, {"sha": "002a5b45a4b20c4fdb64f00e34cd5e4541cdfaa7", "filename": "crates/ra_hir_expand/src/lib.rs", "status": "modified", "additions": 168, "deletions": 2, "changes": 170, "blob_url": "https://github.com/rust-lang/rust/blob/6bf7faf315c57dbec6cb3d5a7c7089016603b309/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6bf7faf315c57dbec6cb3d5a7c7089016603b309/crates%2Fra_hir_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_expand%2Fsrc%2Flib.rs?ref=6bf7faf315c57dbec6cb3d5a7c7089016603b309", "patch": "@@ -5,7 +5,173 @@\n //! `ra_hir_def`, so this crates doesn't contain a lot at the moment.\n \n pub mod db;\n-\n pub mod ast_id_map;\n \n-pub mod expand;\n+use std::hash::{Hash, Hasher};\n+\n+use ra_db::{salsa, CrateId, FileId};\n+use ra_syntax::ast::{self, AstNode};\n+\n+use crate::{ast_id_map::FileAstId, db::AstDatabase};\n+\n+macro_rules! impl_intern_key {\n+    ($name:ident) => {\n+        impl salsa::InternKey for $name {\n+            fn from_intern_id(v: salsa::InternId) -> Self {\n+                $name(v)\n+            }\n+            fn as_intern_id(&self) -> salsa::InternId {\n+                self.0\n+            }\n+        }\n+    };\n+}\n+\n+/// Input to the analyzer is a set of files, where each file is identified by\n+/// `FileId` and contains source code. However, another source of source code in\n+/// Rust are macros: each macro can be thought of as producing a \"temporary\n+/// file\". To assign an id to such a file, we use the id of the macro call that\n+/// produced the file. So, a `HirFileId` is either a `FileId` (source code\n+/// written by user), or a `MacroCallId` (source code produced by macro).\n+///\n+/// What is a `MacroCallId`? Simplifying, it's a `HirFileId` of a file\n+/// containing the call plus the offset of the macro call in the file. Note that\n+/// this is a recursive definition! However, the size_of of `HirFileId` is\n+/// finite (because everything bottoms out at the real `FileId`) and small\n+/// (`MacroCallId` uses the location interner).\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct HirFileId(HirFileIdRepr);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+enum HirFileIdRepr {\n+    FileId(FileId),\n+    MacroFile(MacroFile),\n+}\n+\n+impl From<FileId> for HirFileId {\n+    fn from(id: FileId) -> Self {\n+        HirFileId(HirFileIdRepr::FileId(id))\n+    }\n+}\n+\n+impl From<MacroFile> for HirFileId {\n+    fn from(id: MacroFile) -> Self {\n+        HirFileId(HirFileIdRepr::MacroFile(id))\n+    }\n+}\n+\n+impl HirFileId {\n+    /// For macro-expansion files, returns the file original source file the\n+    /// expansion originated from.\n+    pub fn original_file(self, db: &impl AstDatabase) -> FileId {\n+        match self.0 {\n+            HirFileIdRepr::FileId(file_id) => file_id,\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                loc.ast_id.file_id().original_file(db)\n+            }\n+        }\n+    }\n+\n+    /// Get the crate which the macro lives in, if it is a macro file.\n+    pub fn macro_crate(self, db: &impl AstDatabase) -> Option<CrateId> {\n+        match self.0 {\n+            HirFileIdRepr::FileId(_) => None,\n+            HirFileIdRepr::MacroFile(macro_file) => {\n+                let loc = db.lookup_intern_macro(macro_file.macro_call_id);\n+                Some(loc.def.krate)\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroFile {\n+    macro_call_id: MacroCallId,\n+    macro_file_kind: MacroFileKind,\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum MacroFileKind {\n+    Items,\n+    Expr,\n+}\n+\n+/// `MacroCallId` identifies a particular macro invocation, like\n+/// `println!(\"Hello, {}\", world)`.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroCallId(salsa::InternId);\n+impl_intern_key!(MacroCallId);\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct MacroDefId {\n+    pub krate: CrateId,\n+    pub ast_id: AstId<ast::MacroCall>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, Hash)]\n+pub struct MacroCallLoc {\n+    pub def: MacroDefId,\n+    pub ast_id: AstId<ast::MacroCall>,\n+}\n+\n+impl MacroCallId {\n+    pub fn loc(self, db: &impl AstDatabase) -> MacroCallLoc {\n+        db.lookup_intern_macro(self)\n+    }\n+\n+    pub fn as_file(self, kind: MacroFileKind) -> HirFileId {\n+        let macro_file = MacroFile { macro_call_id: self, macro_file_kind: kind };\n+        macro_file.into()\n+    }\n+}\n+\n+impl MacroCallLoc {\n+    pub fn id(self, db: &impl AstDatabase) -> MacroCallId {\n+        db.intern_macro(self)\n+    }\n+}\n+\n+/// `AstId` points to an AST node in any file.\n+///\n+/// It is stable across reparses, and can be used as salsa key/value.\n+// FIXME: isn't this just a `Source<FileAstId<N>>` ?\n+#[derive(Debug)]\n+pub struct AstId<N: AstNode> {\n+    file_id: HirFileId,\n+    file_ast_id: FileAstId<N>,\n+}\n+\n+impl<N: AstNode> Clone for AstId<N> {\n+    fn clone(&self) -> AstId<N> {\n+        *self\n+    }\n+}\n+impl<N: AstNode> Copy for AstId<N> {}\n+\n+impl<N: AstNode> PartialEq for AstId<N> {\n+    fn eq(&self, other: &Self) -> bool {\n+        (self.file_id, self.file_ast_id) == (other.file_id, other.file_ast_id)\n+    }\n+}\n+impl<N: AstNode> Eq for AstId<N> {}\n+impl<N: AstNode> Hash for AstId<N> {\n+    fn hash<H: Hasher>(&self, hasher: &mut H) {\n+        (self.file_id, self.file_ast_id).hash(hasher);\n+    }\n+}\n+\n+impl<N: AstNode> AstId<N> {\n+    pub fn new(file_id: HirFileId, file_ast_id: FileAstId<N>) -> AstId<N> {\n+        AstId { file_id, file_ast_id }\n+    }\n+\n+    pub fn file_id(&self) -> HirFileId {\n+        self.file_id\n+    }\n+\n+    pub fn to_node(&self, db: &impl AstDatabase) -> N {\n+        let syntax_node = db.ast_id_to_node(self.file_id, self.file_ast_id.into());\n+        N::cast(syntax_node).unwrap()\n+    }\n+}"}]}