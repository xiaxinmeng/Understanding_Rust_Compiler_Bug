{"sha": "bcf2169e7d7c46276214cac627a70673b7676567", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjZjIxNjllN2Q3YzQ2Mjc2MjE0Y2FjNjI3YTcwNjczYjc2NzY1Njc=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-03-13T15:18:38Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-03-13T15:18:38Z"}, "message": "Merge #7996\n\n7996: Separate `Ty` and `TyKind` like in Chalk r=flodiebold a=flodiebold\n\nCurrently `Ty` just wraps `TyKind`, but this allows us to change most\r\nplaces to already use `intern` / `interned`.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "f81c7438f67de3c292a233887e56c7e99bcc0a01", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f81c7438f67de3c292a233887e56c7e99bcc0a01"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bcf2169e7d7c46276214cac627a70673b7676567", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgTNfOCRBK7hj4Ov3rIwAAdHIIACMFnxpn8u1nUHD9yEJoO+x0\nWh8Uf349E2uAIq8qlM804Vaq16o3qD0PjsHOkkF/5LK3IakTZN9EY7uZEWwSpEUs\n2PWb2vG+vjVKYzRazxhzIkZPCmGhvDl52mVwMLSIJHObiV3dx58i3gosW2s38EOQ\n6Hp6bXLPIIOpkoF6pECos6QDQzCzux9rTcjbdQPzdkPoxZg84MzZQt34Hur8JwaL\nKXxIXNSLZAhlu+uZKUio6YMKu4BigCuDVXLZXmL7iiIL17Qh7Gfgzs+c/w+dt0SB\nMLLlpaUzUqpWoUIk3X7E1BXV97BV6wmGmNqKuH2yOx/Uk/CKEsVjGjjS+o703kc=\n=RYB6\n-----END PGP SIGNATURE-----\n", "payload": "tree f81c7438f67de3c292a233887e56c7e99bcc0a01\nparent 7accf6bc37c059a83a58c82f463f02a02ed2226f\nparent 6c32bbf3ca5980fb33c1ea28dd1c5a1524ce81cb\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1615648718 +0000\ncommitter GitHub <noreply@github.com> 1615648718 +0000\n\nMerge #7996\n\n7996: Separate `Ty` and `TyKind` like in Chalk r=flodiebold a=flodiebold\n\nCurrently `Ty` just wraps `TyKind`, but this allows us to change most\r\nplaces to already use `intern` / `interned`.\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf2169e7d7c46276214cac627a70673b7676567", "html_url": "https://github.com/rust-lang/rust/commit/bcf2169e7d7c46276214cac627a70673b7676567", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bcf2169e7d7c46276214cac627a70673b7676567/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7accf6bc37c059a83a58c82f463f02a02ed2226f", "url": "https://api.github.com/repos/rust-lang/rust/commits/7accf6bc37c059a83a58c82f463f02a02ed2226f", "html_url": "https://github.com/rust-lang/rust/commit/7accf6bc37c059a83a58c82f463f02a02ed2226f"}, {"sha": "6c32bbf3ca5980fb33c1ea28dd1c5a1524ce81cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/6c32bbf3ca5980fb33c1ea28dd1c5a1524ce81cb", "html_url": "https://github.com/rust-lang/rust/commit/6c32bbf3ca5980fb33c1ea28dd1c5a1524ce81cb"}], "stats": {"total": 1374, "additions": 755, "deletions": 619}, "files": [{"sha": "7b9de11eddccb3ef801d5ae9abc155276149fb8c", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 34, "deletions": 33, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -54,8 +54,8 @@ use hir_ty::{\n     method_resolution,\n     traits::{FnTrait, Solution, SolutionVariables},\n     AliasTy, BoundVar, CallableDefId, CallableSig, Canonical, DebruijnIndex, GenericPredicate,\n-    InEnvironment, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs, TraitEnvironment,\n-    Ty, TyDefId, TyVariableKind,\n+    InEnvironment, Interner, Obligation, ProjectionPredicate, ProjectionTy, Scalar, Substs,\n+    TraitEnvironment, Ty, TyDefId, TyKind, TyVariableKind,\n };\n use rustc_hash::FxHashSet;\n use stdx::{format_to, impl_from};\n@@ -677,7 +677,7 @@ impl_from!(Struct, Union, Enum for Adt);\n impl Adt {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.into());\n-        subst.iter().any(|ty| &ty.value == &Ty::Unknown)\n+        subst.iter().any(|ty| ty.value.is_unknown())\n     }\n \n     /// Turns this ADT into a type. Any type parameters of the ADT will be\n@@ -1012,7 +1012,7 @@ pub struct TypeAlias {\n impl TypeAlias {\n     pub fn has_non_default_type_params(self, db: &dyn HirDatabase) -> bool {\n         let subst = db.generic_defaults(self.id.into());\n-        subst.iter().any(|ty| &ty.value == &Ty::Unknown)\n+        subst.iter().any(|ty| ty.value.is_unknown())\n     }\n \n     pub fn module(self, db: &dyn HirDatabase) -> Module {\n@@ -1384,7 +1384,7 @@ impl TypeParam {\n     pub fn ty(self, db: &dyn HirDatabase) -> Type {\n         let resolver = self.id.parent.resolver(db.upcast());\n         let krate = self.id.parent.module(db.upcast()).krate();\n-        let ty = Ty::Placeholder(self.id);\n+        let ty = TyKind::Placeholder(self.id).intern(&Interner);\n         Type::new_with_resolver_inner(db, krate, &resolver, ty)\n     }\n \n@@ -1584,25 +1584,25 @@ impl Type {\n     }\n \n     pub fn is_unit(&self) -> bool {\n-        matches!(self.ty.value, Ty::Tuple(0, ..))\n+        matches!(self.ty.value.interned(&Interner), TyKind::Tuple(0, ..))\n     }\n     pub fn is_bool(&self) -> bool {\n-        matches!(self.ty.value, Ty::Scalar(Scalar::Bool))\n+        matches!(self.ty.value.interned(&Interner), TyKind::Scalar(Scalar::Bool))\n     }\n \n     pub fn is_mutable_reference(&self) -> bool {\n-        matches!(self.ty.value, Ty::Ref(hir_ty::Mutability::Mut, ..))\n+        matches!(self.ty.value.interned(&Interner), TyKind::Ref(hir_ty::Mutability::Mut, ..))\n     }\n \n     pub fn remove_ref(&self) -> Option<Type> {\n-        match &self.ty.value {\n-            Ty::Ref(.., substs) => Some(self.derived(substs[0].clone())),\n+        match &self.ty.value.interned(&Interner) {\n+            TyKind::Ref(.., substs) => Some(self.derived(substs[0].clone())),\n             _ => None,\n         }\n     }\n \n     pub fn is_unknown(&self) -> bool {\n-        matches!(self.ty.value, Ty::Unknown)\n+        self.ty.value.is_unknown()\n     }\n \n     /// Checks that particular type `ty` implements `std::future::Future`.\n@@ -1684,7 +1684,7 @@ impl Type {\n             .build();\n         let predicate = ProjectionPredicate {\n             projection_ty: ProjectionTy { associated_ty: alias.id, parameters: subst },\n-            ty: Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)),\n+            ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner),\n         };\n         let goal = Canonical {\n             value: InEnvironment::new(\n@@ -1712,8 +1712,8 @@ impl Type {\n     }\n \n     pub fn as_callable(&self, db: &dyn HirDatabase) -> Option<Callable> {\n-        let def = match self.ty.value {\n-            Ty::FnDef(def, _) => Some(def),\n+        let def = match self.ty.value.interned(&Interner) {\n+            &TyKind::FnDef(def, _) => Some(def),\n             _ => None,\n         };\n \n@@ -1722,16 +1722,16 @@ impl Type {\n     }\n \n     pub fn is_closure(&self) -> bool {\n-        matches!(&self.ty.value, Ty::Closure { .. })\n+        matches!(&self.ty.value.interned(&Interner), TyKind::Closure { .. })\n     }\n \n     pub fn is_fn(&self) -> bool {\n-        matches!(&self.ty.value, Ty::FnDef(..) | Ty::Function { .. })\n+        matches!(&self.ty.value.interned(&Interner), TyKind::FnDef(..) | TyKind::Function { .. })\n     }\n \n     pub fn is_packed(&self, db: &dyn HirDatabase) -> bool {\n-        let adt_id = match self.ty.value {\n-            Ty::Adt(hir_ty::AdtId(adt_id), ..) => adt_id,\n+        let adt_id = match self.ty.value.interned(&Interner) {\n+            &TyKind::Adt(hir_ty::AdtId(adt_id), ..) => adt_id,\n             _ => return false,\n         };\n \n@@ -1743,24 +1743,25 @@ impl Type {\n     }\n \n     pub fn is_raw_ptr(&self) -> bool {\n-        matches!(&self.ty.value, Ty::Raw(..))\n+        matches!(&self.ty.value.interned(&Interner), TyKind::Raw(..))\n     }\n \n     pub fn contains_unknown(&self) -> bool {\n         return go(&self.ty.value);\n \n         fn go(ty: &Ty) -> bool {\n-            match ty {\n-                Ty::Unknown => true,\n-                _ => ty.substs().map_or(false, |substs| substs.iter().any(go)),\n+            if ty.is_unknown() {\n+                true\n+            } else {\n+                ty.substs().map_or(false, |substs| substs.iter().any(go))\n             }\n         }\n     }\n \n     pub fn fields(&self, db: &dyn HirDatabase) -> Vec<(Field, Type)> {\n-        let (variant_id, substs) = match self.ty.value {\n-            Ty::Adt(hir_ty::AdtId(AdtId::StructId(s)), ref substs) => (s.into(), substs),\n-            Ty::Adt(hir_ty::AdtId(AdtId::UnionId(u)), ref substs) => (u.into(), substs),\n+        let (variant_id, substs) = match self.ty.value.interned(&Interner) {\n+            &TyKind::Adt(hir_ty::AdtId(AdtId::StructId(s)), ref substs) => (s.into(), substs),\n+            &TyKind::Adt(hir_ty::AdtId(AdtId::UnionId(u)), ref substs) => (u.into(), substs),\n             _ => return Vec::new(),\n         };\n \n@@ -1775,7 +1776,7 @@ impl Type {\n     }\n \n     pub fn tuple_fields(&self, _db: &dyn HirDatabase) -> Vec<Type> {\n-        if let Ty::Tuple(_, substs) = &self.ty.value {\n+        if let TyKind::Tuple(_, substs) = &self.ty.value.interned(&Interner) {\n             substs.iter().map(|ty| self.derived(ty.clone())).collect()\n         } else {\n             Vec::new()\n@@ -1957,33 +1958,33 @@ impl Type {\n \n         fn walk_type(db: &dyn HirDatabase, type_: &Type, cb: &mut impl FnMut(Type)) {\n             let ty = type_.ty.value.strip_references();\n-            match ty {\n-                Ty::Adt(..) => {\n+            match ty.interned(&Interner) {\n+                TyKind::Adt(..) => {\n                     cb(type_.derived(ty.clone()));\n                 }\n-                Ty::AssociatedType(..) => {\n+                TyKind::AssociatedType(..) => {\n                     if let Some(_) = ty.associated_type_parent_trait(db) {\n                         cb(type_.derived(ty.clone()));\n                     }\n                 }\n-                Ty::OpaqueType(..) => {\n+                TyKind::OpaqueType(..) => {\n                     if let Some(bounds) = ty.impl_trait_bounds(db) {\n                         walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }\n                 }\n-                Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n+                TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n                     if let Some(bounds) = ty.impl_trait_bounds(db) {\n                         walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }\n \n                     walk_substs(db, type_, &opaque_ty.parameters, cb);\n                 }\n-                Ty::Placeholder(_) => {\n+                TyKind::Placeholder(_) => {\n                     if let Some(bounds) = ty.impl_trait_bounds(db) {\n                         walk_bounds(db, &type_.derived(ty.clone()), &bounds, cb);\n                     }\n                 }\n-                Ty::Dyn(bounds) => {\n+                TyKind::Dyn(bounds) => {\n                     walk_bounds(db, &type_.derived(ty.clone()), bounds.as_ref(), cb);\n                 }\n "}, {"sha": "09009a3d8c54faa6169394abbec1180bf4da9301", "filename": "crates/hir_ty/src/autoderef.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fautoderef.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -14,7 +14,7 @@ use crate::{\n     db::HirDatabase,\n     traits::{InEnvironment, Solution},\n     utils::generics,\n-    BoundVar, Canonical, DebruijnIndex, Obligation, Substs, TraitRef, Ty,\n+    BoundVar, Canonical, DebruijnIndex, Interner, Obligation, Substs, TraitRef, Ty, TyKind,\n };\n \n const AUTODEREF_RECURSION_LIMIT: usize = 10;\n@@ -81,7 +81,8 @@ fn deref_by_trait(\n \n     // Now do the assoc type projection\n     let projection = super::traits::ProjectionPredicate {\n-        ty: Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len())),\n+        ty: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, ty.value.kinds.len()))\n+            .intern(&Interner),\n         projection_ty: super::ProjectionTy { associated_ty: target, parameters },\n     };\n \n@@ -114,8 +115,8 @@ fn deref_by_trait(\n             // new variables in that case\n \n             for i in 1..vars.0.kinds.len() {\n-                if vars.0.value[i - 1]\n-                    != Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n+                if vars.0.value[i - 1].interned(&Interner)\n+                    != &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i - 1))\n                 {\n                     warn!(\"complex solution for derefing {:?}: {:?}, ignoring\", ty.value, solution);\n                     return None;"}, {"sha": "b2bfd68d4e5c2ea833b492f7819570c6b0b8f7a6", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -15,7 +15,7 @@ use crate::{\n         MissingPatFields, RemoveThisSemicolon,\n     },\n     utils::variant_data,\n-    AdtId, InferenceResult, Ty,\n+    AdtId, InferenceResult, Interner, Ty, TyKind,\n };\n \n pub(crate) use hir_def::{\n@@ -289,11 +289,10 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n         let (body, source_map): (Arc<Body>, Arc<BodySourceMap>) =\n             db.body_with_source_map(self.owner.into());\n \n-        let match_expr_ty = match infer.type_of_expr.get(match_expr) {\n-            // If we can't resolve the type of the match expression\n-            // we cannot perform exhaustiveness checks.\n-            None | Some(Ty::Unknown) => return,\n-            Some(ty) => ty,\n+        let match_expr_ty = if infer.type_of_expr[match_expr].is_unknown() {\n+            return;\n+        } else {\n+            &infer.type_of_expr[match_expr]\n         };\n \n         let cx = MatchCheckCtx { match_expr, body, infer: infer.clone(), db };\n@@ -379,14 +378,14 @@ impl<'a, 'b> ExprValidator<'a, 'b> {\n             _ => return,\n         };\n \n-        let (params, required) = match mismatch.expected {\n-            Ty::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref parameters)\n-                if enum_id == core_result_enum =>\n+        let (params, required) = match mismatch.expected.interned(&Interner) {\n+            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref parameters)\n+                if *enum_id == core_result_enum =>\n             {\n                 (parameters, \"Ok\".to_string())\n             }\n-            Ty::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref parameters)\n-                if enum_id == core_option_enum =>\n+            TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ref parameters)\n+                if *enum_id == core_option_enum =>\n             {\n                 (parameters, \"Some\".to_string())\n             }"}, {"sha": "5a5cdcbf3a5557710bfd9055b9cb1818ecb1ee94", "filename": "crates/hir_ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -227,7 +227,7 @@ use hir_def::{\n use la_arena::Idx;\n use smallvec::{smallvec, SmallVec};\n \n-use crate::{db::HirDatabase, AdtId, InferenceResult, Ty};\n+use crate::{db::HirDatabase, AdtId, InferenceResult, Interner, TyKind};\n \n #[derive(Debug, Clone, Copy)]\n /// Either a pattern from the source code being analyzed, represented as\n@@ -626,13 +626,13 @@ pub(super) fn is_useful(\n     // - enum with no variants\n     // - `!` type\n     // In those cases, no match arm is useful.\n-    match cx.infer[cx.match_expr].strip_references() {\n-        Ty::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n+    match cx.infer[cx.match_expr].strip_references().interned(&Interner) {\n+        TyKind::Adt(AdtId(hir_def::AdtId::EnumId(enum_id)), ..) => {\n             if cx.db.enum_data(*enum_id).variants.is_empty() {\n                 return Ok(Usefulness::NotUseful);\n             }\n         }\n-        Ty::Never => return Ok(Usefulness::NotUseful),\n+        TyKind::Never => return Ok(Usefulness::NotUseful),\n         _ => (),\n     }\n "}, {"sha": "e095bee28265753ebdf42f06eb52e5722fb21799", "filename": "crates/hir_ty/src/diagnostics/unsafe_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Funsafe_check.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -11,7 +11,7 @@ use hir_def::{\n };\n use hir_expand::diagnostics::DiagnosticSink;\n \n-use crate::{db::HirDatabase, diagnostics::MissingUnsafe, InferenceResult, Ty};\n+use crate::{db::HirDatabase, diagnostics::MissingUnsafe, InferenceResult, Interner, TyKind};\n \n pub(super) struct UnsafeValidator<'a, 'b: 'a> {\n     owner: DefWithBodyId,\n@@ -110,7 +110,7 @@ fn walk_unsafe(\n             }\n         }\n         Expr::UnaryOp { expr, op: UnaryOp::Deref } => {\n-            if let Ty::Raw(..) = &infer[*expr] {\n+            if let TyKind::Raw(..) = &infer[*expr].interned(&Interner) {\n                 unsafe_exprs.push(UnsafeExpr { expr: current, inside_unsafe_block });\n             }\n         }"}, {"sha": "ee15f4f52a7d79cdbd83ab57ea5e62c81268eb66", "filename": "crates/hir_ty/src/display.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdisplay.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -12,8 +12,8 @@ use hir_expand::name::Name;\n \n use crate::{\n     db::HirDatabase, primitive, utils::generics, AdtId, AliasTy, CallableDefId, CallableSig,\n-    GenericPredicate, Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Scalar, Substs,\n-    TraitRef, Ty,\n+    GenericPredicate, Interner, Lifetime, Obligation, OpaqueTy, OpaqueTyId, ProjectionTy, Scalar,\n+    Substs, TraitRef, Ty, TyKind,\n };\n \n pub struct HirFormatter<'a> {\n@@ -267,32 +267,32 @@ impl HirDisplay for Ty {\n             return write!(f, \"{}\", TYPE_HINT_TRUNCATION);\n         }\n \n-        match self {\n-            Ty::Never => write!(f, \"!\")?,\n-            Ty::Str => write!(f, \"str\")?,\n-            Ty::Scalar(Scalar::Bool) => write!(f, \"bool\")?,\n-            Ty::Scalar(Scalar::Char) => write!(f, \"char\")?,\n-            &Ty::Scalar(Scalar::Float(t)) => write!(f, \"{}\", primitive::float_ty_to_string(t))?,\n-            &Ty::Scalar(Scalar::Int(t)) => write!(f, \"{}\", primitive::int_ty_to_string(t))?,\n-            &Ty::Scalar(Scalar::Uint(t)) => write!(f, \"{}\", primitive::uint_ty_to_string(t))?,\n-            Ty::Slice(parameters) => {\n+        match self.interned(&Interner) {\n+            TyKind::Never => write!(f, \"!\")?,\n+            TyKind::Str => write!(f, \"str\")?,\n+            TyKind::Scalar(Scalar::Bool) => write!(f, \"bool\")?,\n+            TyKind::Scalar(Scalar::Char) => write!(f, \"char\")?,\n+            &TyKind::Scalar(Scalar::Float(t)) => write!(f, \"{}\", primitive::float_ty_to_string(t))?,\n+            &TyKind::Scalar(Scalar::Int(t)) => write!(f, \"{}\", primitive::int_ty_to_string(t))?,\n+            &TyKind::Scalar(Scalar::Uint(t)) => write!(f, \"{}\", primitive::uint_ty_to_string(t))?,\n+            TyKind::Slice(parameters) => {\n                 let t = parameters.as_single();\n                 write!(f, \"[\")?;\n                 t.hir_fmt(f)?;\n                 write!(f, \"]\")?;\n             }\n-            Ty::Array(parameters) => {\n+            TyKind::Array(parameters) => {\n                 let t = parameters.as_single();\n                 write!(f, \"[\")?;\n                 t.hir_fmt(f)?;\n                 write!(f, \"; _]\")?;\n             }\n-            Ty::Raw(m, parameters) | Ty::Ref(m, parameters) => {\n+            TyKind::Raw(m, parameters) | TyKind::Ref(m, parameters) => {\n                 let t = parameters.as_single();\n                 let ty_display =\n                     t.into_displayable(f.db, f.max_size, f.omit_verbose_types, f.display_target);\n \n-                if matches!(self, Ty::Raw(..)) {\n+                if matches!(self.interned(&Interner), TyKind::Raw(..)) {\n                     write!(\n                         f,\n                         \"*{}\",\n@@ -313,11 +313,11 @@ impl HirDisplay for Ty {\n                 }\n \n                 let datas;\n-                let predicates = match t {\n-                    Ty::Dyn(predicates) if predicates.len() > 1 => {\n+                let predicates = match t.interned(&Interner) {\n+                    TyKind::Dyn(predicates) if predicates.len() > 1 => {\n                         Cow::Borrowed(predicates.as_ref())\n                     }\n-                    &Ty::Alias(AliasTy::Opaque(OpaqueTy {\n+                    &TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n                         opaque_ty_id: OpaqueTyId::ReturnTypeImplTrait(func, idx),\n                         ref parameters,\n                     })) => {\n@@ -347,7 +347,7 @@ impl HirDisplay for Ty {\n                     write!(f, \"{}\", ty_display)?;\n                 }\n             }\n-            Ty::Tuple(_, substs) => {\n+            TyKind::Tuple(_, substs) => {\n                 if substs.len() == 1 {\n                     write!(f, \"(\")?;\n                     substs[0].hir_fmt(f)?;\n@@ -358,11 +358,11 @@ impl HirDisplay for Ty {\n                     write!(f, \")\")?;\n                 }\n             }\n-            Ty::Function(fn_ptr) => {\n+            TyKind::Function(fn_ptr) => {\n                 let sig = CallableSig::from_fn_ptr(fn_ptr);\n                 sig.hir_fmt(f)?;\n             }\n-            Ty::FnDef(def, parameters) => {\n+            TyKind::FnDef(def, parameters) => {\n                 let def = *def;\n                 let sig = f.db.callable_item_signature(def).subst(parameters);\n                 match def {\n@@ -401,7 +401,7 @@ impl HirDisplay for Ty {\n                     write!(f, \" -> {}\", ret_display)?;\n                 }\n             }\n-            Ty::Adt(AdtId(def_id), parameters) => {\n+            TyKind::Adt(AdtId(def_id), parameters) => {\n                 match f.display_target {\n                     DisplayTarget::Diagnostics | DisplayTarget::Test => {\n                         let name = match *def_id {\n@@ -427,45 +427,47 @@ impl HirDisplay for Ty {\n                 }\n \n                 if parameters.len() > 0 {\n-                    let parameters_to_write =\n-                        if f.display_target.is_source_code() || f.omit_verbose_types() {\n-                            match self\n-                                .as_generic_def()\n-                                .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n-                                .filter(|defaults| !defaults.is_empty())\n-                            {\n-                                None => parameters.0.as_ref(),\n-                                Some(default_parameters) => {\n-                                    let mut default_from = 0;\n-                                    for (i, parameter) in parameters.iter().enumerate() {\n-                                        match (parameter, default_parameters.get(i)) {\n-                                            (&Ty::Unknown, _) | (_, None) => {\n+                    let parameters_to_write = if f.display_target.is_source_code()\n+                        || f.omit_verbose_types()\n+                    {\n+                        match self\n+                            .as_generic_def()\n+                            .map(|generic_def_id| f.db.generic_defaults(generic_def_id))\n+                            .filter(|defaults| !defaults.is_empty())\n+                        {\n+                            None => parameters.0.as_ref(),\n+                            Some(default_parameters) => {\n+                                let mut default_from = 0;\n+                                for (i, parameter) in parameters.iter().enumerate() {\n+                                    match (parameter.interned(&Interner), default_parameters.get(i))\n+                                    {\n+                                        (&TyKind::Unknown, _) | (_, None) => {\n+                                            default_from = i + 1;\n+                                        }\n+                                        (_, Some(default_parameter)) => {\n+                                            let actual_default = default_parameter\n+                                                .clone()\n+                                                .subst(&parameters.prefix(i));\n+                                            if parameter != &actual_default {\n                                                 default_from = i + 1;\n                                             }\n-                                            (_, Some(default_parameter)) => {\n-                                                let actual_default = default_parameter\n-                                                    .clone()\n-                                                    .subst(&parameters.prefix(i));\n-                                                if parameter != &actual_default {\n-                                                    default_from = i + 1;\n-                                                }\n-                                            }\n                                         }\n                                     }\n-                                    &parameters.0[0..default_from]\n                                 }\n+                                &parameters.0[0..default_from]\n                             }\n-                        } else {\n-                            parameters.0.as_ref()\n-                        };\n+                        }\n+                    } else {\n+                        parameters.0.as_ref()\n+                    };\n                     if !parameters_to_write.is_empty() {\n                         write!(f, \"<\")?;\n                         f.write_joined(parameters_to_write, \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 }\n             }\n-            Ty::AssociatedType(type_alias, parameters) => {\n+            TyKind::AssociatedType(type_alias, parameters) => {\n                 let trait_ = match type_alias.lookup(f.db.upcast()).container {\n                     AssocContainerId::TraitId(it) => it,\n                     _ => panic!(\"not an associated type\"),\n@@ -488,11 +490,11 @@ impl HirDisplay for Ty {\n                     projection_ty.hir_fmt(f)?;\n                 }\n             }\n-            Ty::ForeignType(type_alias) => {\n+            TyKind::ForeignType(type_alias) => {\n                 let type_alias = f.db.type_alias_data(*type_alias);\n                 write!(f, \"{}\", type_alias.name)?;\n             }\n-            Ty::OpaqueType(opaque_ty_id, parameters) => {\n+            TyKind::OpaqueType(opaque_ty_id, parameters) => {\n                 match opaque_ty_id {\n                     &OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n@@ -511,7 +513,7 @@ impl HirDisplay for Ty {\n                     }\n                 }\n             }\n-            Ty::Closure(.., substs) => {\n+            TyKind::Closure(.., substs) => {\n                 let sig = substs[0].callable_sig(f.db);\n                 if let Some(sig) = sig {\n                     if sig.params().is_empty() {\n@@ -535,7 +537,7 @@ impl HirDisplay for Ty {\n                     write!(f, \"{{closure}}\")?;\n                 }\n             }\n-            Ty::Placeholder(id) => {\n+            TyKind::Placeholder(id) => {\n                 let generics = generics(f.db.upcast(), id.parent);\n                 let param_data = &generics.params.types[id.local_id];\n                 match param_data.provenance {\n@@ -553,12 +555,12 @@ impl HirDisplay for Ty {\n                     }\n                 }\n             }\n-            Ty::BoundVar(idx) => write!(f, \"?{}.{}\", idx.debruijn.depth(), idx.index)?,\n-            Ty::Dyn(predicates) => {\n+            TyKind::BoundVar(idx) => write!(f, \"?{}.{}\", idx.debruijn.depth(), idx.index)?,\n+            TyKind::Dyn(predicates) => {\n                 write_bounds_like_dyn_trait_with_prefix(\"dyn\", predicates, f)?;\n             }\n-            Ty::Alias(AliasTy::Projection(p_ty)) => p_ty.hir_fmt(f)?,\n-            Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n+            TyKind::Alias(AliasTy::Projection(p_ty)) => p_ty.hir_fmt(f)?,\n+            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n                 match opaque_ty.opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         let datas =\n@@ -574,15 +576,15 @@ impl HirDisplay for Ty {\n                     }\n                 };\n             }\n-            Ty::Unknown => {\n+            TyKind::Unknown => {\n                 if f.display_target.is_source_code() {\n                     return Err(HirDisplayError::DisplaySourceCodeError(\n                         DisplaySourceCodeError::UnknownType,\n                     ));\n                 }\n                 write!(f, \"{{unknown}}\")?;\n             }\n-            Ty::InferenceVar(..) => write!(f, \"_\")?,\n+            TyKind::InferenceVar(..) => write!(f, \"_\")?,\n         }\n         Ok(())\n     }"}, {"sha": "acde99b04c3800927a0e5fdc427a8fb362506a5e", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -41,7 +41,8 @@ use super::{\n     InEnvironment, ProjectionTy, Substs, TraitEnvironment, TraitRef, Ty, TypeWalk,\n };\n use crate::{\n-    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode, AliasTy,\n+    db::HirDatabase, infer::diagnostics::InferenceDiagnostic, lower::ImplTraitLoweringMode,\n+    AliasTy, Interner, TyKind,\n };\n \n pub(crate) use unify::unify;\n@@ -169,15 +170,15 @@ impl Index<ExprId> for InferenceResult {\n     type Output = Ty;\n \n     fn index(&self, expr: ExprId) -> &Ty {\n-        self.type_of_expr.get(expr).unwrap_or(&Ty::Unknown)\n+        self.type_of_expr.get(expr).unwrap_or(&Ty(TyKind::Unknown))\n     }\n }\n \n impl Index<PatId> for InferenceResult {\n     type Output = Ty;\n \n     fn index(&self, pat: PatId) -> &Ty {\n-        self.type_of_pat.get(pat).unwrap_or(&Ty::Unknown)\n+        self.type_of_pat.get(pat).unwrap_or(&Ty(TyKind::Unknown))\n     }\n }\n \n@@ -226,7 +227,7 @@ impl<'a> InferenceContext<'a> {\n             result: InferenceResult::default(),\n             table: unify::InferenceTable::new(),\n             obligations: Vec::default(),\n-            return_ty: Ty::Unknown, // set in collect_fn_signature\n+            return_ty: TyKind::Unknown.intern(&Interner), // set in collect_fn_signature\n             trait_env: TraitEnvironment::lower(db, &resolver),\n             db,\n             owner,\n@@ -237,15 +238,19 @@ impl<'a> InferenceContext<'a> {\n         }\n     }\n \n+    fn err_ty(&self) -> Ty {\n+        TyKind::Unknown.intern(&Interner)\n+    }\n+\n     fn resolve_all(mut self) -> InferenceResult {\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         let mut result = std::mem::take(&mut self.result);\n         for ty in result.type_of_expr.values_mut() {\n-            let resolved = self.table.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            let resolved = self.table.resolve_ty_completely(ty.clone());\n             *ty = resolved;\n         }\n         for ty in result.type_of_pat.values_mut() {\n-            let resolved = self.table.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            let resolved = self.table.resolve_ty_completely(ty.clone());\n             *ty = resolved;\n         }\n         result\n@@ -298,8 +303,8 @@ impl<'a> InferenceContext<'a> {\n \n     /// Replaces Ty::Unknown by a new type var, so we can maybe still infer it.\n     fn insert_type_vars_shallow(&mut self, ty: Ty) -> Ty {\n-        match ty {\n-            Ty::Unknown => self.table.new_type_var(),\n+        match ty.interned(&Interner) {\n+            TyKind::Unknown => self.table.new_type_var(),\n             _ => ty,\n         }\n     }\n@@ -383,7 +388,7 @@ impl<'a> InferenceContext<'a> {\n                 self.obligations.push(Obligation::Projection(projection));\n                 self.resolve_ty_as_possible(ty)\n             }\n-            None => Ty::Unknown,\n+            None => self.err_ty(),\n         }\n     }\n \n@@ -395,8 +400,10 @@ impl<'a> InferenceContext<'a> {\n     /// to do it as well.\n     fn normalize_associated_types_in(&mut self, ty: Ty) -> Ty {\n         let ty = self.resolve_ty_as_possible(ty);\n-        ty.fold(&mut |ty| match ty {\n-            Ty::Alias(AliasTy::Projection(proj_ty)) => self.normalize_projection_ty(proj_ty),\n+        ty.fold(&mut |ty| match ty.interned(&Interner) {\n+            TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n+                self.normalize_projection_ty(proj_ty.clone())\n+            }\n             _ => ty,\n         })\n     }\n@@ -412,7 +419,7 @@ impl<'a> InferenceContext<'a> {\n     fn resolve_variant(&mut self, path: Option<&Path>) -> (Ty, Option<VariantId>) {\n         let path = match path {\n             Some(path) => path,\n-            None => return (Ty::Unknown, None),\n+            None => return (self.err_ty(), None),\n         };\n         let resolver = &self.resolver;\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n@@ -421,7 +428,7 @@ impl<'a> InferenceContext<'a> {\n         let (resolution, unresolved) =\n             match resolver.resolve_path_in_type_ns(self.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n-                None => return (Ty::Unknown, None),\n+                None => return (self.err_ty(), None),\n             };\n         return match resolution {\n             TypeNs::AdtId(AdtId::StructId(strukt)) => {\n@@ -462,11 +469,11 @@ impl<'a> InferenceContext<'a> {\n                             }\n                         }\n                         // FIXME potentially resolve assoc type\n-                        (Ty::Unknown, None)\n+                        (self.err_ty(), None)\n                     }\n                     Some(_) => {\n                         // FIXME diagnostic\n-                        (Ty::Unknown, None)\n+                        (self.err_ty(), None)\n                     }\n                 }\n             }\n@@ -480,15 +487,15 @@ impl<'a> InferenceContext<'a> {\n             }\n             TypeNs::AdtSelfType(_) => {\n                 // FIXME this could happen in array size expressions, once we're checking them\n-                (Ty::Unknown, None)\n+                (self.err_ty(), None)\n             }\n             TypeNs::GenericParam(_) => {\n                 // FIXME potentially resolve assoc type\n-                (Ty::Unknown, None)\n+                (self.err_ty(), None)\n             }\n             TypeNs::AdtId(AdtId::EnumId(_)) | TypeNs::BuiltinType(_) | TypeNs::TraitId(_) => {\n                 // FIXME diagnostic\n-                (Ty::Unknown, None)\n+                (self.err_ty(), None)\n             }\n         };\n \n@@ -500,7 +507,7 @@ impl<'a> InferenceContext<'a> {\n                 result\n             } else {\n                 // FIXME diagnostic\n-                (Ty::Unknown, None)\n+                (TyKind::Unknown.intern(&Interner), None)\n             }\n         }\n \n@@ -711,12 +718,12 @@ impl Expectation {\n \n     /// This expresses no expectation on the type.\n     fn none() -> Self {\n-        Expectation { ty: Ty::Unknown, rvalue_hint: false }\n+        Expectation { ty: TyKind::Unknown.intern(&Interner), rvalue_hint: false }\n     }\n \n     fn coercion_target(&self) -> &Ty {\n         if self.rvalue_hint {\n-            &Ty::Unknown\n+            &Ty(TyKind::Unknown)\n         } else {\n             &self.ty\n         }"}, {"sha": "36670043aeaaa91eeffa0fe233e79034e3aad041", "filename": "crates/hir_ty/src/infer/coerce.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -7,7 +7,7 @@\n use chalk_ir::{Mutability, TyVariableKind};\n use hir_def::lang_item::LangItemTarget;\n \n-use crate::{autoderef, traits::Solution, Obligation, Substs, TraitRef, Ty};\n+use crate::{autoderef, traits::Solution, Interner, Obligation, Substs, TraitRef, Ty, TyKind};\n \n use super::{InEnvironment, InferenceContext};\n \n@@ -33,7 +33,9 @@ impl<'a> InferenceContext<'a> {\n         } else if self.coerce(ty2, ty1) {\n             ty1.clone()\n         } else {\n-            if let (Ty::FnDef(..), Ty::FnDef(..)) = (ty1, ty2) {\n+            if let (TyKind::FnDef(..), TyKind::FnDef(..)) =\n+                (ty1.interned(&Interner), ty2.interned(&Interner))\n+            {\n                 cov_mark::hit!(coerce_fn_reification);\n                 // Special case: two function types. Try to coerce both to\n                 // pointers to have a chance at getting a match. See\n@@ -51,13 +53,13 @@ impl<'a> InferenceContext<'a> {\n     }\n \n     fn coerce_inner(&mut self, mut from_ty: Ty, to_ty: &Ty) -> bool {\n-        match (&from_ty, to_ty) {\n+        match (from_ty.interned(&Interner), to_ty.interned(&Interner)) {\n             // Never type will make type variable to fallback to Never Type instead of Unknown.\n-            (Ty::Never, Ty::InferenceVar(tv, TyVariableKind::General)) => {\n+            (TyKind::Never, TyKind::InferenceVar(tv, TyVariableKind::General)) => {\n                 self.table.type_variable_table.set_diverging(*tv, true);\n                 return true;\n             }\n-            (Ty::Never, _) => return true,\n+            (TyKind::Never, _) => return true,\n \n             // Trivial cases, this should go after `never` check to\n             // avoid infer result type to be never\n@@ -69,33 +71,33 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Pointer weakening and function to pointer\n-        match (&mut from_ty, to_ty) {\n+        match (&mut from_ty.0, to_ty.interned(&Interner)) {\n             // `*mut T` -> `*const T`\n             // `&mut T` -> `&T`\n-            (Ty::Raw(m1, ..), Ty::Raw(m2 @ Mutability::Not, ..))\n-            | (Ty::Ref(m1, ..), Ty::Ref(m2 @ Mutability::Not, ..)) => {\n+            (TyKind::Raw(m1, ..), TyKind::Raw(m2 @ Mutability::Not, ..))\n+            | (TyKind::Ref(m1, ..), TyKind::Ref(m2 @ Mutability::Not, ..)) => {\n                 *m1 = *m2;\n             }\n             // `&T` -> `*const T`\n             // `&mut T` -> `*mut T`/`*const T`\n-            (Ty::Ref(.., substs), &Ty::Raw(m2 @ Mutability::Not, ..))\n-            | (Ty::Ref(Mutability::Mut, substs), &Ty::Raw(m2, ..)) => {\n-                from_ty = Ty::Raw(m2, substs.clone());\n+            (TyKind::Ref(.., substs), &TyKind::Raw(m2 @ Mutability::Not, ..))\n+            | (TyKind::Ref(Mutability::Mut, substs), &TyKind::Raw(m2, ..)) => {\n+                from_ty = TyKind::Raw(m2, substs.clone()).intern(&Interner);\n             }\n \n             // Illegal mutability conversion\n-            (Ty::Raw(Mutability::Not, ..), Ty::Raw(Mutability::Mut, ..))\n-            | (Ty::Ref(Mutability::Not, ..), Ty::Ref(Mutability::Mut, ..)) => return false,\n+            (TyKind::Raw(Mutability::Not, ..), TyKind::Raw(Mutability::Mut, ..))\n+            | (TyKind::Ref(Mutability::Not, ..), TyKind::Ref(Mutability::Mut, ..)) => return false,\n \n             // `{function_type}` -> `fn()`\n-            (Ty::FnDef(..), Ty::Function { .. }) => match from_ty.callable_sig(self.db) {\n+            (TyKind::FnDef(..), TyKind::Function { .. }) => match from_ty.callable_sig(self.db) {\n                 None => return false,\n                 Some(sig) => {\n                     from_ty = Ty::fn_ptr(sig);\n                 }\n             },\n \n-            (Ty::Closure(.., substs), Ty::Function { .. }) => {\n+            (TyKind::Closure(.., substs), TyKind::Function { .. }) => {\n                 from_ty = substs[0].clone();\n             }\n \n@@ -107,9 +109,11 @@ impl<'a> InferenceContext<'a> {\n         }\n \n         // Auto Deref if cannot coerce\n-        match (&from_ty, to_ty) {\n+        match (from_ty.interned(&Interner), to_ty.interned(&Interner)) {\n             // FIXME: DerefMut\n-            (Ty::Ref(_, st1), Ty::Ref(_, st2)) => self.unify_autoderef_behind_ref(&st1[0], &st2[0]),\n+            (TyKind::Ref(_, st1), TyKind::Ref(_, st2)) => {\n+                self.unify_autoderef_behind_ref(&st1[0], &st2[0])\n+            }\n \n             // Otherwise, normal unify\n             _ => self.unify(&from_ty, to_ty),"}, {"sha": "4e77f22fdc37e276904f79e6e1ed32196163ba00", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 133, "deletions": 102, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -20,8 +20,8 @@ use crate::{\n     primitive::{self, UintTy},\n     traits::{FnTrait, InEnvironment},\n     utils::{generics, variant_data, Generics},\n-    AdtId, Binders, CallableDefId, FnPointer, FnSig, Obligation, OpaqueTyId, Rawness, Scalar,\n-    Substs, TraitRef, Ty,\n+    AdtId, Binders, CallableDefId, FnPointer, FnSig, Interner, Obligation, OpaqueTyId, Rawness,\n+    Scalar, Substs, TraitRef, Ty, TyKind,\n };\n \n use super::{\n@@ -57,7 +57,7 @@ impl<'a> InferenceContext<'a> {\n             // Return actual type when type mismatch.\n             // This is needed for diagnostic when return type mismatch.\n             ty\n-        } else if expected.coercion_target() == &Ty::Unknown {\n+        } else if expected.coercion_target().is_unknown() {\n             ty\n         } else {\n             expected.ty.clone()\n@@ -84,7 +84,7 @@ impl<'a> InferenceContext<'a> {\n             arg_tys.push(arg);\n         }\n         let parameters = param_builder.build();\n-        let arg_ty = Ty::Tuple(num_args, parameters);\n+        let arg_ty = TyKind::Tuple(num_args, parameters).intern(&Interner);\n         let substs =\n             Substs::build_for_generics(&generic_params).push(ty.clone()).push(arg_ty).build();\n \n@@ -116,10 +116,13 @@ impl<'a> InferenceContext<'a> {\n     fn infer_expr_inner(&mut self, tgt_expr: ExprId, expected: &Expectation) -> Ty {\n         let body = Arc::clone(&self.body); // avoid borrow checker problem\n         let ty = match &body[tgt_expr] {\n-            Expr::Missing => Ty::Unknown,\n+            Expr::Missing => self.err_ty(),\n             Expr::If { condition, then_branch, else_branch } => {\n                 // if let is desugared to match, so this is always simple if\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Scalar(Scalar::Bool)));\n+                self.infer_expr(\n+                    *condition,\n+                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner)),\n+                );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut both_arms_diverge = Diverges::Always;\n@@ -167,14 +170,14 @@ impl<'a> InferenceContext<'a> {\n             Expr::TryBlock { body } => {\n                 let _inner = self.infer_expr(*body, expected);\n                 // FIXME should be std::result::Result<{inner}, _>\n-                Ty::Unknown\n+                self.err_ty()\n             }\n             Expr::Async { body } => {\n                 // Use the first type parameter as the output type of future.\n                 // existenail type AsyncBlockImplTrait<InnerType>: Future<Output = InnerType>\n                 let inner_ty = self.infer_expr(*body, &Expectation::none());\n                 let opaque_ty_id = OpaqueTyId::AsyncBlockTypeImplTrait(self.owner, *body);\n-                Ty::OpaqueType(opaque_ty_id, Substs::single(inner_ty))\n+                TyKind::OpaqueType(opaque_ty_id, Substs::single(inner_ty)).intern(&Interner)\n             }\n             Expr::Loop { body, label } => {\n                 self.breakables.push(BreakableContext {\n@@ -192,17 +195,20 @@ impl<'a> InferenceContext<'a> {\n                 if ctxt.may_break {\n                     ctxt.break_ty\n                 } else {\n-                    Ty::Never\n+                    TyKind::Never.intern(&Interner)\n                 }\n             }\n             Expr::While { condition, body, label } => {\n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n-                    break_ty: Ty::Unknown,\n+                    break_ty: self.err_ty(),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 // while let is desugared to a match loop, so this is always simple while\n-                self.infer_expr(*condition, &Expectation::has_type(Ty::Scalar(Scalar::Bool)));\n+                self.infer_expr(\n+                    *condition,\n+                    &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner)),\n+                );\n                 self.infer_expr(*body, &Expectation::has_type(Ty::unit()));\n                 let _ctxt = self.breakables.pop().expect(\"breakable stack broken\");\n                 // the body may not run, so it diverging doesn't mean we diverge\n@@ -214,7 +220,7 @@ impl<'a> InferenceContext<'a> {\n \n                 self.breakables.push(BreakableContext {\n                     may_break: false,\n-                    break_ty: Ty::Unknown,\n+                    break_ty: self.err_ty(),\n                     label: label.map(|label| self.body[label].name.clone()),\n                 });\n                 let pat_ty =\n@@ -249,12 +255,14 @@ impl<'a> InferenceContext<'a> {\n                     None => self.table.new_type_var(),\n                 };\n                 sig_tys.push(ret_ty.clone());\n-                let sig_ty = Ty::Function(FnPointer {\n+                let sig_ty = TyKind::Function(FnPointer {\n                     num_args: sig_tys.len() - 1,\n                     sig: FnSig { variadic: false },\n                     substs: Substs(sig_tys.clone().into()),\n-                });\n-                let closure_ty = Ty::Closure(self.owner, tgt_expr, Substs::single(sig_ty));\n+                })\n+                .intern(&Interner);\n+                let closure_ty =\n+                    TyKind::Closure(self.owner, tgt_expr, Substs::single(sig_ty)).intern(&Interner);\n \n                 // Eagerly try to relate the closure type with the expected\n                 // type, otherwise we often won't have enough information to\n@@ -295,7 +303,7 @@ impl<'a> InferenceContext<'a> {\n                             args.len(),\n                         )\n                     })\n-                    .unwrap_or((Vec::new(), Ty::Unknown));\n+                    .unwrap_or((Vec::new(), self.err_ty()));\n                 self.register_obligations_for_call(&callee_ty);\n                 self.check_call_arguments(args, &param_tys);\n                 self.normalize_associated_types_in(ret_ty)\n@@ -305,8 +313,11 @@ impl<'a> InferenceContext<'a> {\n             Expr::Match { expr, arms } => {\n                 let input_ty = self.infer_expr(*expr, &Expectation::none());\n \n-                let mut result_ty =\n-                    if arms.is_empty() { Ty::Never } else { self.table.new_type_var() };\n+                let mut result_ty = if arms.is_empty() {\n+                    TyKind::Never.intern(&Interner)\n+                } else {\n+                    self.table.new_type_var()\n+                };\n \n                 let matchee_diverges = self.diverges;\n                 let mut all_arms_diverge = Diverges::Always;\n@@ -317,7 +328,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(guard_expr) = arm.guard {\n                         self.infer_expr(\n                             guard_expr,\n-                            &Expectation::has_type(Ty::Scalar(Scalar::Bool)),\n+                            &Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner)),\n                         );\n                     }\n \n@@ -333,9 +344,9 @@ impl<'a> InferenceContext<'a> {\n             Expr::Path(p) => {\n                 // FIXME this could be more efficient...\n                 let resolver = resolver_for_expr(self.db.upcast(), self.owner, tgt_expr);\n-                self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(Ty::Unknown)\n+                self.infer_path(&resolver, p, tgt_expr.into()).unwrap_or(self.err_ty())\n             }\n-            Expr::Continue { .. } => Ty::Never,\n+            Expr::Continue { .. } => TyKind::Never.intern(&Interner),\n             Expr::Break { expr, label } => {\n                 let val_ty = if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none())\n@@ -347,7 +358,7 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(ctxt) = find_breakable(&mut self.breakables, label.as_ref()) {\n                         ctxt.break_ty.clone()\n                     } else {\n-                        Ty::Unknown\n+                        self.err_ty()\n                     };\n \n                 let merged_type = self.coerce_merge_branch(&last_ty, &val_ty);\n@@ -360,7 +371,7 @@ impl<'a> InferenceContext<'a> {\n                         expr: tgt_expr,\n                     });\n                 }\n-                Ty::Never\n+                TyKind::Never.intern(&Interner)\n             }\n             Expr::Return { expr } => {\n                 if let Some(expr) = expr {\n@@ -369,14 +380,14 @@ impl<'a> InferenceContext<'a> {\n                     let unit = Ty::unit();\n                     self.coerce(&unit, &self.return_ty.clone());\n                 }\n-                Ty::Never\n+                TyKind::Never.intern(&Interner)\n             }\n             Expr::Yield { expr } => {\n                 // FIXME: track yield type for coercion\n                 if let Some(expr) = expr {\n                     self.infer_expr(*expr, &Expectation::none());\n                 }\n-                Ty::Never\n+                TyKind::Never.intern(&Interner)\n             }\n             Expr::RecordLit { path, fields, spread } => {\n                 let (ty, def_id) = self.resolve_variant(path.as_ref());\n@@ -404,8 +415,9 @@ impl<'a> InferenceContext<'a> {\n                     if let Some(field_def) = field_def {\n                         self.result.record_field_resolutions.insert(field.expr, field_def);\n                     }\n-                    let field_ty = field_def\n-                        .map_or(Ty::Unknown, |it| field_types[it.local_id].clone().subst(&substs));\n+                    let field_ty = field_def.map_or(self.err_ty(), |it| {\n+                        field_types[it.local_id].clone().subst(&substs)\n+                    });\n                     self.infer_expr_coerce(field.expr, &Expectation::has_type(field_ty));\n                 }\n                 if let Some(expr) = spread {\n@@ -424,27 +436,33 @@ impl<'a> InferenceContext<'a> {\n                         environment: self.trait_env.clone(),\n                     },\n                 )\n-                .find_map(|derefed_ty| match canonicalized.decanonicalize_ty(derefed_ty.value) {\n-                    Ty::Tuple(_, substs) => {\n-                        name.as_tuple_index().and_then(|idx| substs.0.get(idx).cloned())\n-                    }\n-                    Ty::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n-                        self.db.struct_data(s).variant_data.field(name).map(|local_id| {\n-                            let field = FieldId { parent: s.into(), local_id };\n-                            self.write_field_resolution(tgt_expr, field);\n-                            self.db.field_types(s.into())[field.local_id].clone().subst(&parameters)\n-                        })\n-                    }\n-                    Ty::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n-                        self.db.union_data(u).variant_data.field(name).map(|local_id| {\n-                            let field = FieldId { parent: u.into(), local_id };\n-                            self.write_field_resolution(tgt_expr, field);\n-                            self.db.field_types(u.into())[field.local_id].clone().subst(&parameters)\n-                        })\n+                .find_map(|derefed_ty| {\n+                    match canonicalized.decanonicalize_ty(derefed_ty.value).interned(&Interner) {\n+                        TyKind::Tuple(_, substs) => {\n+                            name.as_tuple_index().and_then(|idx| substs.0.get(idx).cloned())\n+                        }\n+                        TyKind::Adt(AdtId(hir_def::AdtId::StructId(s)), parameters) => {\n+                            self.db.struct_data(*s).variant_data.field(name).map(|local_id| {\n+                                let field = FieldId { parent: (*s).into(), local_id };\n+                                self.write_field_resolution(tgt_expr, field);\n+                                self.db.field_types((*s).into())[field.local_id]\n+                                    .clone()\n+                                    .subst(&parameters)\n+                            })\n+                        }\n+                        TyKind::Adt(AdtId(hir_def::AdtId::UnionId(u)), parameters) => {\n+                            self.db.union_data(*u).variant_data.field(name).map(|local_id| {\n+                                let field = FieldId { parent: (*u).into(), local_id };\n+                                self.write_field_resolution(tgt_expr, field);\n+                                self.db.field_types((*u).into())[field.local_id]\n+                                    .clone()\n+                                    .subst(&parameters)\n+                            })\n+                        }\n+                        _ => None,\n                     }\n-                    _ => None,\n                 })\n-                .unwrap_or(Ty::Unknown);\n+                .unwrap_or(self.err_ty());\n                 let ty = self.insert_type_vars(ty);\n                 self.normalize_associated_types_in(ty)\n             }\n@@ -481,9 +499,10 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let inner_ty = self.infer_expr_inner(*expr, &expectation);\n                 match rawness {\n-                    Rawness::RawPtr => Ty::Raw(mutability, Substs::single(inner_ty)),\n-                    Rawness::Ref => Ty::Ref(mutability, Substs::single(inner_ty)),\n+                    Rawness::RawPtr => TyKind::Raw(mutability, Substs::single(inner_ty)),\n+                    Rawness::Ref => TyKind::Ref(mutability, Substs::single(inner_ty)),\n                 }\n+                .intern(&Interner)\n             }\n             Expr::Box { expr } => {\n                 let inner_ty = self.infer_expr_inner(*expr, &Expectation::none());\n@@ -499,7 +518,7 @@ impl<'a> InferenceContext<'a> {\n                     sb = sb.fill(repeat_with(|| self.table.new_type_var()));\n                     Ty::adt_ty(box_, sb.build())\n                 } else {\n-                    Ty::Unknown\n+                    self.err_ty()\n                 }\n             }\n             Expr::UnaryOp { expr, op } => {\n@@ -519,31 +538,31 @@ impl<'a> InferenceContext<'a> {\n                                 Some(derefed_ty) => {\n                                     canonicalized.decanonicalize_ty(derefed_ty.value)\n                                 }\n-                                None => Ty::Unknown,\n+                                None => self.err_ty(),\n                             }\n                         }\n-                        None => Ty::Unknown,\n+                        None => self.err_ty(),\n                     },\n                     UnaryOp::Neg => {\n-                        match &inner_ty {\n+                        match inner_ty.interned(&Interner) {\n                             // Fast path for builtins\n-                            Ty::Scalar(Scalar::Int(_))\n-                            | Ty::Scalar(Scalar::Uint(_))\n-                            | Ty::Scalar(Scalar::Float(_))\n-                            | Ty::InferenceVar(_, TyVariableKind::Integer)\n-                            | Ty::InferenceVar(_, TyVariableKind::Float) => inner_ty,\n+                            TyKind::Scalar(Scalar::Int(_))\n+                            | TyKind::Scalar(Scalar::Uint(_))\n+                            | TyKind::Scalar(Scalar::Float(_))\n+                            | TyKind::InferenceVar(_, TyVariableKind::Integer)\n+                            | TyKind::InferenceVar(_, TyVariableKind::Float) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Neg trait\n                             _ => self\n                                 .resolve_associated_type(inner_ty, self.resolve_ops_neg_output()),\n                         }\n                     }\n                     UnaryOp::Not => {\n-                        match &inner_ty {\n+                        match inner_ty.interned(&Interner) {\n                             // Fast path for builtins\n-                            Ty::Scalar(Scalar::Bool)\n-                            | Ty::Scalar(Scalar::Int(_))\n-                            | Ty::Scalar(Scalar::Uint(_))\n-                            | Ty::InferenceVar(_, TyVariableKind::Integer) => inner_ty,\n+                            TyKind::Scalar(Scalar::Bool)\n+                            | TyKind::Scalar(Scalar::Int(_))\n+                            | TyKind::Scalar(Scalar::Uint(_))\n+                            | TyKind::InferenceVar(_, TyVariableKind::Integer) => inner_ty,\n                             // Otherwise we resolve via the std::ops::Not trait\n                             _ => self\n                                 .resolve_associated_type(inner_ty, self.resolve_ops_not_output()),\n@@ -554,7 +573,9 @@ impl<'a> InferenceContext<'a> {\n             Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(op) => {\n                     let lhs_expectation = match op {\n-                        BinaryOp::LogicOp(..) => Expectation::has_type(Ty::Scalar(Scalar::Bool)),\n+                        BinaryOp::LogicOp(..) => {\n+                            Expectation::has_type(TyKind::Scalar(Scalar::Bool).intern(&Interner))\n+                        }\n                         _ => Expectation::none(),\n                     };\n                     let lhs_ty = self.infer_expr(*lhs, &lhs_expectation);\n@@ -563,7 +584,7 @@ impl<'a> InferenceContext<'a> {\n \n                     let ret = op::binary_op_return_ty(*op, lhs_ty.clone(), rhs_ty.clone());\n \n-                    if ret == Ty::Unknown {\n+                    if ret.is_unknown() {\n                         cov_mark::hit!(infer_expr_inner_binary_operator_overload);\n \n                         self.resolve_associated_type_with_params(\n@@ -575,7 +596,7 @@ impl<'a> InferenceContext<'a> {\n                         ret\n                     }\n                 }\n-                _ => Ty::Unknown,\n+                _ => self.err_ty(),\n             },\n             Expr::Range { lhs, rhs, range_type } => {\n                 let lhs_ty = lhs.map(|e| self.infer_expr_inner(e, &Expectation::none()));\n@@ -586,33 +607,33 @@ impl<'a> InferenceContext<'a> {\n                 match (range_type, lhs_ty, rhs_ty) {\n                     (RangeOp::Exclusive, None, None) => match self.resolve_range_full() {\n                         Some(adt) => Ty::adt_ty(adt, Substs::empty()),\n-                        None => Ty::Unknown,\n+                        None => self.err_ty(),\n                     },\n                     (RangeOp::Exclusive, None, Some(ty)) => match self.resolve_range_to() {\n                         Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n-                        None => Ty::Unknown,\n+                        None => self.err_ty(),\n                     },\n                     (RangeOp::Inclusive, None, Some(ty)) => {\n                         match self.resolve_range_to_inclusive() {\n                             Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n-                            None => Ty::Unknown,\n+                            None => self.err_ty(),\n                         }\n                     }\n                     (RangeOp::Exclusive, Some(_), Some(ty)) => match self.resolve_range() {\n                         Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n-                        None => Ty::Unknown,\n+                        None => self.err_ty(),\n                     },\n                     (RangeOp::Inclusive, Some(_), Some(ty)) => {\n                         match self.resolve_range_inclusive() {\n                             Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n-                            None => Ty::Unknown,\n+                            None => self.err_ty(),\n                         }\n                     }\n                     (RangeOp::Exclusive, Some(ty), None) => match self.resolve_range_from() {\n                         Some(adt) => Ty::adt_ty(adt, Substs::single(ty)),\n-                        None => Ty::Unknown,\n+                        None => self.err_ty(),\n                     },\n-                    (RangeOp::Inclusive, _, None) => Ty::Unknown,\n+                    (RangeOp::Inclusive, _, None) => self.err_ty(),\n                 }\n             }\n             Expr::Index { base, index } => {\n@@ -631,19 +652,19 @@ impl<'a> InferenceContext<'a> {\n                         index_trait,\n                     );\n                     let self_ty =\n-                        self_ty.map_or(Ty::Unknown, |t| canonicalized.decanonicalize_ty(t.value));\n+                        self_ty.map_or(self.err_ty(), |t| canonicalized.decanonicalize_ty(t.value));\n                     self.resolve_associated_type_with_params(\n                         self_ty,\n                         self.resolve_ops_index_output(),\n                         &[index_ty],\n                     )\n                 } else {\n-                    Ty::Unknown\n+                    self.err_ty()\n                 }\n             }\n             Expr::Tuple { exprs } => {\n-                let mut tys = match &expected.ty {\n-                    Ty::Tuple(_, substs) => substs\n+                let mut tys = match expected.ty.interned(&Interner) {\n+                    TyKind::Tuple(_, substs) => substs\n                         .iter()\n                         .cloned()\n                         .chain(repeat_with(|| self.table.new_type_var()))\n@@ -656,11 +677,11 @@ impl<'a> InferenceContext<'a> {\n                     self.infer_expr_coerce(*expr, &Expectation::has_type(ty.clone()));\n                 }\n \n-                Ty::Tuple(tys.len(), Substs(tys.into()))\n+                TyKind::Tuple(tys.len(), Substs(tys.into())).intern(&Interner)\n             }\n             Expr::Array(array) => {\n-                let elem_ty = match &expected.ty {\n-                    Ty::Array(st) | Ty::Slice(st) => st.as_single().clone(),\n+                let elem_ty = match expected.ty.interned(&Interner) {\n+                    TyKind::Array(st) | TyKind::Slice(st) => st.as_single().clone(),\n                     _ => self.table.new_type_var(),\n                 };\n \n@@ -677,43 +698,51 @@ impl<'a> InferenceContext<'a> {\n                         );\n                         self.infer_expr(\n                             *repeat,\n-                            &Expectation::has_type(Ty::Scalar(Scalar::Uint(UintTy::Usize))),\n+                            &Expectation::has_type(\n+                                TyKind::Scalar(Scalar::Uint(UintTy::Usize)).intern(&Interner),\n+                            ),\n                         );\n                     }\n                 }\n \n-                Ty::Array(Substs::single(elem_ty))\n+                TyKind::Array(Substs::single(elem_ty)).intern(&Interner)\n             }\n             Expr::Literal(lit) => match lit {\n-                Literal::Bool(..) => Ty::Scalar(Scalar::Bool),\n-                Literal::String(..) => Ty::Ref(Mutability::Not, Substs::single(Ty::Str)),\n+                Literal::Bool(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+                Literal::String(..) => {\n+                    TyKind::Ref(Mutability::Not, Substs::single(TyKind::Str.intern(&Interner)))\n+                        .intern(&Interner)\n+                }\n                 Literal::ByteString(..) => {\n-                    let byte_type = Ty::Scalar(Scalar::Uint(UintTy::U8));\n-                    let array_type = Ty::Array(Substs::single(byte_type));\n-                    Ty::Ref(Mutability::Not, Substs::single(array_type))\n+                    let byte_type = TyKind::Scalar(Scalar::Uint(UintTy::U8)).intern(&Interner);\n+                    let array_type = TyKind::Array(Substs::single(byte_type)).intern(&Interner);\n+                    TyKind::Ref(Mutability::Not, Substs::single(array_type)).intern(&Interner)\n                 }\n-                Literal::Char(..) => Ty::Scalar(Scalar::Char),\n+                Literal::Char(..) => TyKind::Scalar(Scalar::Char).intern(&Interner),\n                 Literal::Int(_v, ty) => match ty {\n                     Some(int_ty) => {\n-                        Ty::Scalar(Scalar::Int(primitive::int_ty_from_builtin(*int_ty)))\n+                        TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(*int_ty)))\n+                            .intern(&Interner)\n                     }\n                     None => self.table.new_integer_var(),\n                 },\n                 Literal::Uint(_v, ty) => match ty {\n                     Some(int_ty) => {\n-                        Ty::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(*int_ty)))\n+                        TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(*int_ty)))\n+                            .intern(&Interner)\n                     }\n                     None => self.table.new_integer_var(),\n                 },\n                 Literal::Float(_v, ty) => match ty {\n                     Some(float_ty) => {\n-                        Ty::Scalar(Scalar::Float(primitive::float_ty_from_builtin(*float_ty)))\n+                        TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(*float_ty)))\n+                            .intern(&Interner)\n                     }\n                     None => self.table.new_float_var(),\n                 },\n             },\n         };\n-        // use a new type variable if we got Ty::Unknown here\n+        // use a new type variable if we got unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         let ty = self.resolve_ty_as_possible(ty);\n         self.write_expr_ty(tgt_expr, ty.clone());\n@@ -730,15 +759,15 @@ impl<'a> InferenceContext<'a> {\n             match stmt {\n                 Statement::Let { pat, type_ref, initializer } => {\n                     let decl_ty =\n-                        type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(Ty::Unknown);\n+                        type_ref.as_ref().map(|tr| self.make_ty(tr)).unwrap_or(self.err_ty());\n \n                     // Always use the declared type when specified\n                     let mut ty = decl_ty.clone();\n \n                     if let Some(expr) = initializer {\n                         let actual_ty =\n                             self.infer_expr_coerce(*expr, &Expectation::has_type(decl_ty.clone()));\n-                        if decl_ty == Ty::Unknown {\n+                        if decl_ty.is_unknown() {\n                             ty = actual_ty;\n                         }\n                     }\n@@ -802,7 +831,7 @@ impl<'a> InferenceContext<'a> {\n                 self.write_method_resolution(tgt_expr, func);\n                 (ty, self.db.value_ty(func.into()), Some(generics(self.db.upcast(), func.into())))\n             }\n-            None => (receiver_ty, Binders::new(0, Ty::Unknown), None),\n+            None => (receiver_ty, Binders::new(0, self.err_ty()), None),\n         };\n         let substs = self.substs_for_method_call(def_generics, generic_args, &derefed_receiver_ty);\n         let method_ty = method_ty.subst(&substs);\n@@ -813,15 +842,17 @@ impl<'a> InferenceContext<'a> {\n                 if !sig.params().is_empty() {\n                     (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n                 } else {\n-                    (Ty::Unknown, Vec::new(), sig.ret().clone())\n+                    (self.err_ty(), Vec::new(), sig.ret().clone())\n                 }\n             }\n-            None => (Ty::Unknown, Vec::new(), Ty::Unknown),\n+            None => (self.err_ty(), Vec::new(), self.err_ty()),\n         };\n         // Apply autoref so the below unification works correctly\n         // FIXME: return correct autorefs from lookup_method\n         let actual_receiver_ty = match expected_receiver_ty.as_reference() {\n-            Some((_, mutability)) => Ty::Ref(mutability, Substs::single(derefed_receiver_ty)),\n+            Some((_, mutability)) => {\n+                TyKind::Ref(mutability, Substs::single(derefed_receiver_ty)).intern(&Interner)\n+            }\n             _ => derefed_receiver_ty,\n         };\n         self.unify(&expected_receiver_ty, &actual_receiver_ty);\n@@ -837,7 +868,7 @@ impl<'a> InferenceContext<'a> {\n         // that we have more information about the types of arguments when we\n         // type-check the functions. This isn't really the right way to do this.\n         for &check_closures in &[false, true] {\n-            let param_iter = param_tys.iter().cloned().chain(repeat(Ty::Unknown));\n+            let param_iter = param_tys.iter().cloned().chain(repeat(self.err_ty()));\n             for (&arg, param_ty) in args.iter().zip(param_iter) {\n                 let is_closure = matches!(&self.body[arg], Expr::Lambda { .. });\n                 if is_closure != check_closures {\n@@ -867,7 +898,7 @@ impl<'a> InferenceContext<'a> {\n                 if param.provenance == hir_def::generics::TypeParamProvenance::TraitSelf {\n                     substs.push(receiver_ty.clone());\n                 } else {\n-                    substs.push(Ty::Unknown);\n+                    substs.push(self.err_ty());\n                 }\n             }\n         }\n@@ -891,15 +922,15 @@ impl<'a> InferenceContext<'a> {\n         };\n         let supplied_params = substs.len();\n         for _ in supplied_params..total_len {\n-            substs.push(Ty::Unknown);\n+            substs.push(self.err_ty());\n         }\n         assert_eq!(substs.len(), total_len);\n         Substs(substs.into())\n     }\n \n     fn register_obligations_for_call(&mut self, callable_ty: &Ty) {\n-        if let &Ty::FnDef(def, ref parameters) = callable_ty {\n-            let generic_predicates = self.db.generic_predicates(def.into());\n+        if let TyKind::FnDef(def, parameters) = callable_ty.interned(&Interner) {\n+            let generic_predicates = self.db.generic_predicates((*def).into());\n             for predicate in generic_predicates.iter() {\n                 let predicate = predicate.clone().subst(parameters);\n                 if let Some(obligation) = Obligation::from_predicate(predicate) {"}, {"sha": "a16755cda89bee40768494e6b4a199be72fda187", "filename": "crates/hir_ty/src/infer/pat.rs", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpat.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -12,7 +12,7 @@ use hir_def::{\n use hir_expand::name::Name;\n \n use super::{BindingMode, Expectation, InferenceContext};\n-use crate::{lower::lower_to_chalk_mutability, utils::variant_data, Substs, Ty};\n+use crate::{lower::lower_to_chalk_mutability, utils::variant_data, Interner, Substs, Ty, TyKind};\n \n impl<'a> InferenceContext<'a> {\n     fn infer_tuple_struct_pat(\n@@ -46,7 +46,7 @@ impl<'a> InferenceContext<'a> {\n             let expected_ty = var_data\n                 .as_ref()\n                 .and_then(|d| d.field(&Name::new_tuple_field(i)))\n-                .map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n+                .map_or(self.err_ty(), |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat, &expected_ty, default_bm);\n         }\n@@ -80,8 +80,8 @@ impl<'a> InferenceContext<'a> {\n                 self.result.record_pat_field_resolutions.insert(subpat.pat, field_def);\n             }\n \n-            let expected_ty =\n-                matching_field.map_or(Ty::Unknown, |field| field_tys[field].clone().subst(&substs));\n+            let expected_ty = matching_field\n+                .map_or(self.err_ty(), |field| field_tys[field].clone().subst(&substs));\n             let expected_ty = self.normalize_associated_types_in(expected_ty);\n             self.infer_pat(subpat.pat, &expected_ty, default_bm);\n         }\n@@ -129,15 +129,16 @@ impl<'a> InferenceContext<'a> {\n                     None => (&args[..], &[][..]),\n                 };\n                 let n_uncovered_patterns = expectations.len().saturating_sub(args.len());\n-                let mut expectations_iter = expectations.iter().chain(repeat(&Ty::Unknown));\n+                let err_ty = self.err_ty();\n+                let mut expectations_iter = expectations.iter().chain(repeat(&err_ty));\n                 let mut infer_pat = |(&pat, ty)| self.infer_pat(pat, ty, default_bm);\n \n                 let mut inner_tys = Vec::with_capacity(n_uncovered_patterns + args.len());\n                 inner_tys.extend(pre.iter().zip(expectations_iter.by_ref()).map(&mut infer_pat));\n                 inner_tys.extend(expectations_iter.by_ref().take(n_uncovered_patterns).cloned());\n                 inner_tys.extend(post.iter().zip(expectations_iter).map(infer_pat));\n \n-                Ty::Tuple(inner_tys.len(), Substs(inner_tys.into()))\n+                TyKind::Tuple(inner_tys.len(), Substs(inner_tys.into())).intern(&Interner)\n             }\n             Pat::Or(ref pats) => {\n                 if let Some((first_pat, rest)) = pats.split_first() {\n@@ -147,7 +148,7 @@ impl<'a> InferenceContext<'a> {\n                     }\n                     ty\n                 } else {\n-                    Ty::Unknown\n+                    self.err_ty()\n                 }\n             }\n             Pat::Ref { pat, mutability } => {\n@@ -159,10 +160,10 @@ impl<'a> InferenceContext<'a> {\n                         }\n                         inner_ty\n                     }\n-                    _ => &Ty::Unknown,\n+                    _ => &Ty(TyKind::Unknown),\n                 };\n                 let subty = self.infer_pat(*pat, expectation, default_bm);\n-                Ty::Ref(mutability, Substs::single(subty))\n+                TyKind::Ref(mutability, Substs::single(subty)).intern(&Interner)\n             }\n             Pat::TupleStruct { path: p, args: subpats, ellipsis } => self.infer_tuple_struct_pat(\n                 p.as_ref(),\n@@ -178,7 +179,7 @@ impl<'a> InferenceContext<'a> {\n             Pat::Path(path) => {\n                 // FIXME use correct resolver for the surrounding expression\n                 let resolver = self.resolver.clone();\n-                self.infer_path(&resolver, &path, pat.into()).unwrap_or(Ty::Unknown)\n+                self.infer_path(&resolver, &path, pat.into()).unwrap_or(self.err_ty())\n             }\n             Pat::Bind { mode, name: _, subpat } => {\n                 let mode = if mode == &BindingAnnotation::Unannotated {\n@@ -195,7 +196,7 @@ impl<'a> InferenceContext<'a> {\n \n                 let bound_ty = match mode {\n                     BindingMode::Ref(mutability) => {\n-                        Ty::Ref(mutability, Substs::single(inner_ty.clone()))\n+                        TyKind::Ref(mutability, Substs::single(inner_ty.clone())).intern(&Interner)\n                     }\n                     BindingMode::Move => inner_ty.clone(),\n                 };\n@@ -204,17 +205,17 @@ impl<'a> InferenceContext<'a> {\n                 return inner_ty;\n             }\n             Pat::Slice { prefix, slice, suffix } => {\n-                let (container_ty, elem_ty): (fn(_) -> _, _) = match &expected {\n-                    Ty::Array(st) => (Ty::Array, st.as_single().clone()),\n-                    Ty::Slice(st) => (Ty::Slice, st.as_single().clone()),\n-                    _ => (Ty::Slice, Ty::Unknown),\n+                let (container_ty, elem_ty): (fn(_) -> _, _) = match expected.interned(&Interner) {\n+                    TyKind::Array(st) => (TyKind::Array, st.as_single().clone()),\n+                    TyKind::Slice(st) => (TyKind::Slice, st.as_single().clone()),\n+                    _ => (TyKind::Slice, self.err_ty()),\n                 };\n \n                 for pat_id in prefix.iter().chain(suffix) {\n                     self.infer_pat(*pat_id, &elem_ty, default_bm);\n                 }\n \n-                let pat_ty = container_ty(Substs::single(elem_ty));\n+                let pat_ty = container_ty(Substs::single(elem_ty)).intern(&Interner);\n                 if let Some(slice_pat_id) = slice {\n                     self.infer_pat(*slice_pat_id, &pat_ty, default_bm);\n                 }\n@@ -232,20 +233,20 @@ impl<'a> InferenceContext<'a> {\n                 Some(box_adt) => {\n                     let inner_expected = match expected.as_adt() {\n                         Some((adt, substs)) if adt == box_adt => substs.as_single(),\n-                        _ => &Ty::Unknown,\n+                        _ => &Ty(TyKind::Unknown),\n                     };\n \n                     let inner_ty = self.infer_pat(*inner, inner_expected, default_bm);\n                     Ty::adt_ty(box_adt, Substs::single(inner_ty))\n                 }\n-                None => Ty::Unknown,\n+                None => self.err_ty(),\n             },\n             Pat::ConstBlock(expr) => {\n                 self.infer_expr(*expr, &Expectation::has_type(expected.clone()))\n             }\n-            Pat::Missing => Ty::Unknown,\n+            Pat::Missing => self.err_ty(),\n         };\n-        // use a new type variable if we got Ty::Unknown here\n+        // use a new type variable if we got error type here\n         let ty = self.insert_type_vars_shallow(ty);\n         if !self.unify(&ty, expected) {\n             // FIXME record mismatch, we need to change the type of self.type_mismatches for that"}, {"sha": "3929521785801cc9595a5fe1a73cd24923a1eada", "filename": "crates/hir_ty/src/infer/path.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fpath.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -9,7 +9,7 @@ use hir_def::{\n };\n use hir_expand::name::Name;\n \n-use crate::{method_resolution, Substs, Ty, ValueTyDefId};\n+use crate::{method_resolution, Interner, Substs, Ty, TyKind, ValueTyDefId};\n \n use super::{ExprOrPatId, InferenceContext, TraitRef};\n \n@@ -144,7 +144,7 @@ impl<'a> InferenceContext<'a> {\n                     remaining_segments_for_ty,\n                     true,\n                 );\n-                if let Ty::Unknown = ty {\n+                if let TyKind::Unknown = ty.interned(&Interner) {\n                     return None;\n                 }\n \n@@ -209,7 +209,7 @@ impl<'a> InferenceContext<'a> {\n         name: &Name,\n         id: ExprOrPatId,\n     ) -> Option<(ValueNs, Option<Substs>)> {\n-        if let Ty::Unknown = ty {\n+        if let TyKind::Unknown = ty.interned(&Interner) {\n             return None;\n         }\n "}, {"sha": "16d89ed1bff7a909bacfefdd29bb0cad15d2fc1c", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 61, "deletions": 44, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -7,8 +7,8 @@ use ena::unify::{InPlaceUnificationTable, NoError, UnifyKey, UnifyValue};\n \n use super::{InferenceContext, Obligation};\n use crate::{\n-    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferenceVar, Scalar,\n-    Substs, Ty, TypeWalk,\n+    BoundVar, Canonical, DebruijnIndex, GenericPredicate, InEnvironment, InferenceVar, Interner,\n+    Scalar, Substs, Ty, TyKind, TypeWalk,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -49,8 +49,8 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n \n     fn do_canonicalize<T: TypeWalk>(&mut self, t: T, binders: DebruijnIndex) -> T {\n         t.fold_binders(\n-            &mut |ty, binders| match ty {\n-                Ty::InferenceVar(var, kind) => {\n+            &mut |ty, binders| match ty.interned(&Interner) {\n+                &TyKind::InferenceVar(var, kind) => {\n                     let inner = var.to_inner();\n                     if self.var_stack.contains(&inner) {\n                         // recursive type\n@@ -66,7 +66,7 @@ impl<'a, 'b> Canonicalizer<'a, 'b> {\n                     } else {\n                         let root = self.ctx.table.var_unification_table.find(inner);\n                         let position = self.add(InferenceVar::from_inner(root), kind);\n-                        Ty::BoundVar(BoundVar::new(binders, position))\n+                        TyKind::BoundVar(BoundVar::new(binders, position)).intern(&Interner)\n                     }\n                 }\n                 _ => ty,\n@@ -108,10 +108,10 @@ impl<T> Canonicalized<T> {\n     pub(super) fn decanonicalize_ty(&self, mut ty: Ty) -> Ty {\n         ty.walk_mut_binders(\n             &mut |ty, binders| {\n-                if let &mut Ty::BoundVar(bound) = ty {\n+                if let &mut TyKind::BoundVar(bound) = &mut ty.0 {\n                     if bound.debruijn >= binders {\n                         let (v, k) = self.free_vars[bound.index];\n-                        *ty = Ty::InferenceVar(v, k);\n+                        *ty = TyKind::InferenceVar(v, k).intern(&Interner);\n                     }\n                 }\n             },\n@@ -142,7 +142,7 @@ impl<T> Canonicalized<T> {\n             // eagerly replace projections in the type; we may be getting types\n             // e.g. from where clauses where this hasn't happened yet\n             let ty = ctx.normalize_associated_types_in(ty.clone().subst_bound_vars(&new_vars));\n-            ctx.table.unify(&Ty::InferenceVar(v, k), &ty);\n+            ctx.table.unify(&TyKind::InferenceVar(v, k).intern(&Interner), &ty);\n         }\n     }\n }\n@@ -166,7 +166,10 @@ pub(crate) fn unify(tys: &Canonical<(Ty, Ty)>) -> Option<Substs> {\n     // (kind of hacky)\n     for (i, var) in vars.iter().enumerate() {\n         if &*table.resolve_ty_shallow(var) == var {\n-            table.unify(var, &Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i)));\n+            table.unify(\n+                var,\n+                &TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, i)).intern(&Interner),\n+            );\n         }\n     }\n     Some(\n@@ -196,11 +199,12 @@ impl TypeVariableTable {\n \n     fn fallback_value(&self, iv: InferenceVar, kind: TyVariableKind) -> Ty {\n         match kind {\n-            _ if self.inner[iv.to_inner().0 as usize].diverging => Ty::Never,\n-            TyVariableKind::General => Ty::Unknown,\n-            TyVariableKind::Integer => Ty::Scalar(Scalar::Int(IntTy::I32)),\n-            TyVariableKind::Float => Ty::Scalar(Scalar::Float(FloatTy::F64)),\n+            _ if self.inner[iv.to_inner().0 as usize].diverging => TyKind::Never,\n+            TyVariableKind::General => TyKind::Unknown,\n+            TyVariableKind::Integer => TyKind::Scalar(Scalar::Int(IntTy::I32)),\n+            TyVariableKind::Float => TyKind::Scalar(Scalar::Float(FloatTy::F64)),\n         }\n+        .intern(&Interner)\n     }\n }\n \n@@ -227,7 +231,7 @@ impl InferenceTable {\n         self.type_variable_table.push(TypeVariableData { diverging });\n         let key = self.var_unification_table.new_key(TypeVarValue::Unknown);\n         assert_eq!(key.0 as usize, self.type_variable_table.inner.len() - 1);\n-        Ty::InferenceVar(InferenceVar::from_inner(key), kind)\n+        TyKind::InferenceVar(InferenceVar::from_inner(key), kind).intern(&Interner)\n     }\n \n     pub(crate) fn new_type_var(&mut self) -> Ty {\n@@ -290,12 +294,12 @@ impl InferenceTable {\n     }\n \n     pub(super) fn unify_inner_trivial(&mut self, ty1: &Ty, ty2: &Ty, depth: usize) -> bool {\n-        match (ty1, ty2) {\n-            (Ty::Unknown, _) | (_, Ty::Unknown) => true,\n+        match (ty1.interned(&Interner), ty2.interned(&Interner)) {\n+            (TyKind::Unknown, _) | (_, TyKind::Unknown) => true,\n \n-            (Ty::Placeholder(p1), Ty::Placeholder(p2)) if *p1 == *p2 => true,\n+            (TyKind::Placeholder(p1), TyKind::Placeholder(p2)) if *p1 == *p2 => true,\n \n-            (Ty::Dyn(dyn1), Ty::Dyn(dyn2)) if dyn1.len() == dyn2.len() => {\n+            (TyKind::Dyn(dyn1), TyKind::Dyn(dyn2)) if dyn1.len() == dyn2.len() => {\n                 for (pred1, pred2) in dyn1.iter().zip(dyn2.iter()) {\n                     if !self.unify_preds(pred1, pred2, depth + 1) {\n                         return false;\n@@ -305,16 +309,16 @@ impl InferenceTable {\n             }\n \n             (\n-                Ty::InferenceVar(tv1, TyVariableKind::General),\n-                Ty::InferenceVar(tv2, TyVariableKind::General),\n+                TyKind::InferenceVar(tv1, TyVariableKind::General),\n+                TyKind::InferenceVar(tv2, TyVariableKind::General),\n             )\n             | (\n-                Ty::InferenceVar(tv1, TyVariableKind::Integer),\n-                Ty::InferenceVar(tv2, TyVariableKind::Integer),\n+                TyKind::InferenceVar(tv1, TyVariableKind::Integer),\n+                TyKind::InferenceVar(tv2, TyVariableKind::Integer),\n             )\n             | (\n-                Ty::InferenceVar(tv1, TyVariableKind::Float),\n-                Ty::InferenceVar(tv2, TyVariableKind::Float),\n+                TyKind::InferenceVar(tv1, TyVariableKind::Float),\n+                TyKind::InferenceVar(tv2, TyVariableKind::Float),\n             ) if self.type_variable_table.is_diverging(*tv1)\n                 == self.type_variable_table.is_diverging(*tv2) =>\n             {\n@@ -326,24 +330,37 @@ impl InferenceTable {\n             // The order of MaybeNeverTypeVar matters here.\n             // Unifying MaybeNeverTypeVar and TypeVar will let the latter become MaybeNeverTypeVar.\n             // Unifying MaybeNeverTypeVar and other concrete type will let the former become it.\n-            (Ty::InferenceVar(tv, TyVariableKind::General), other)\n-            | (other, Ty::InferenceVar(tv, TyVariableKind::General))\n-            | (Ty::InferenceVar(tv, TyVariableKind::Integer), other @ Ty::Scalar(Scalar::Int(_)))\n-            | (other @ Ty::Scalar(Scalar::Int(_)), Ty::InferenceVar(tv, TyVariableKind::Integer))\n+            (TyKind::InferenceVar(tv, TyVariableKind::General), other)\n+            | (other, TyKind::InferenceVar(tv, TyVariableKind::General))\n             | (\n-                Ty::InferenceVar(tv, TyVariableKind::Integer),\n-                other @ Ty::Scalar(Scalar::Uint(_)),\n+                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n+                other @ TyKind::Scalar(Scalar::Int(_)),\n             )\n             | (\n-                other @ Ty::Scalar(Scalar::Uint(_)),\n-                Ty::InferenceVar(tv, TyVariableKind::Integer),\n+                other @ TyKind::Scalar(Scalar::Int(_)),\n+                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n             )\n-            | (Ty::InferenceVar(tv, TyVariableKind::Float), other @ Ty::Scalar(Scalar::Float(_)))\n-            | (other @ Ty::Scalar(Scalar::Float(_)), Ty::InferenceVar(tv, TyVariableKind::Float)) =>\n-            {\n+            | (\n+                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n+                other @ TyKind::Scalar(Scalar::Uint(_)),\n+            )\n+            | (\n+                other @ TyKind::Scalar(Scalar::Uint(_)),\n+                TyKind::InferenceVar(tv, TyVariableKind::Integer),\n+            )\n+            | (\n+                TyKind::InferenceVar(tv, TyVariableKind::Float),\n+                other @ TyKind::Scalar(Scalar::Float(_)),\n+            )\n+            | (\n+                other @ TyKind::Scalar(Scalar::Float(_)),\n+                TyKind::InferenceVar(tv, TyVariableKind::Float),\n+            ) => {\n                 // the type var is unknown since we tried to resolve it\n-                self.var_unification_table\n-                    .union_value(tv.to_inner(), TypeVarValue::Known(other.clone()));\n+                self.var_unification_table.union_value(\n+                    tv.to_inner(),\n+                    TypeVarValue::Known(other.clone().intern(&Interner)),\n+                );\n                 true\n             }\n \n@@ -387,8 +404,8 @@ impl InferenceTable {\n             if i > 0 {\n                 cov_mark::hit!(type_var_resolves_to_int_var);\n             }\n-            match &*ty {\n-                Ty::InferenceVar(tv, _) => {\n+            match &ty.0 {\n+                TyKind::InferenceVar(tv, _) => {\n                     let inner = tv.to_inner();\n                     match self.var_unification_table.inlined_probe_value(inner).known() {\n                         Some(known_ty) => {\n@@ -410,8 +427,8 @@ impl InferenceTable {\n     /// be resolved as far as possible, i.e. contain no type variables with\n     /// known type.\n     fn resolve_ty_as_possible_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::InferenceVar(tv, kind) => {\n+        ty.fold(&mut |ty| match ty.interned(&Interner) {\n+            &TyKind::InferenceVar(tv, kind) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n                     cov_mark::hit!(type_var_cycles_resolve_as_possible);\n@@ -435,10 +452,10 @@ impl InferenceTable {\n     }\n \n     /// Resolves the type completely; type variables without known type are\n-    /// replaced by Ty::Unknown.\n+    /// replaced by TyKind::Unknown.\n     fn resolve_ty_completely_inner(&mut self, tv_stack: &mut Vec<TypeVarId>, ty: Ty) -> Ty {\n-        ty.fold(&mut |ty| match ty {\n-            Ty::InferenceVar(tv, kind) => {\n+        ty.fold(&mut |ty| match ty.interned(&Interner) {\n+            &TyKind::InferenceVar(tv, kind) => {\n                 let inner = tv.to_inner();\n                 if tv_stack.contains(&inner) {\n                     cov_mark::hit!(type_var_cycles_resolve_completely);"}, {"sha": "2309db4922d1656770698a6101511a72d4aa06fa", "filename": "crates/hir_ty/src/lib.rs", "status": "modified", "additions": 155, "deletions": 121, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flib.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -49,7 +49,7 @@ pub use traits::{InEnvironment, Obligation, ProjectionPredicate, TraitEnvironmen\n \n pub use chalk_ir::{AdtId, BoundVar, DebruijnIndex, Mutability, Scalar, TyVariableKind};\n \n-pub(crate) use crate::traits::chalk::Interner;\n+pub use crate::traits::chalk::Interner;\n \n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub enum Lifetime {\n@@ -131,7 +131,7 @@ pub enum AliasTy {\n ///\n /// This should be cheap to clone.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n-pub enum Ty {\n+pub enum TyKind {\n     /// Structures, enumerations and unions.\n     Adt(AdtId<Interner>, Substs),\n \n@@ -244,6 +244,21 @@ pub enum Ty {\n     Unknown,\n }\n \n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub struct Ty(TyKind);\n+\n+impl TyKind {\n+    pub fn intern(self, _interner: &Interner) -> Ty {\n+        Ty(self)\n+    }\n+}\n+\n+impl Ty {\n+    pub fn interned(&self, _interner: &Interner) -> &TyKind {\n+        &self.0\n+    }\n+}\n+\n /// A list of substitutions for generic parameters.\n #[derive(Clone, PartialEq, Eq, Debug, Hash)]\n pub struct Substs(Arc<[Ty]>);\n@@ -292,7 +307,12 @@ impl Substs {\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n     pub(crate) fn type_params_for_generics(generic_params: &Generics) -> Substs {\n-        Substs(generic_params.iter().map(|(id, _)| Ty::Placeholder(id)).collect())\n+        Substs(\n+            generic_params\n+                .iter()\n+                .map(|(id, _)| TyKind::Placeholder(id).intern(&Interner))\n+                .collect(),\n+        )\n     }\n \n     /// Return Substs that replace each parameter by itself (i.e. `Ty::Param`).\n@@ -307,7 +327,7 @@ impl Substs {\n             generic_params\n                 .iter()\n                 .enumerate()\n-                .map(|(idx, _)| Ty::BoundVar(BoundVar::new(debruijn, idx)))\n+                .map(|(idx, _)| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner))\n                 .collect(),\n         )\n     }\n@@ -355,11 +375,14 @@ impl SubstsBuilder {\n     }\n \n     pub fn fill_with_bound_vars(self, debruijn: DebruijnIndex, starting_from: usize) -> Self {\n-        self.fill((starting_from..).map(|idx| Ty::BoundVar(BoundVar::new(debruijn, idx))))\n+        self.fill(\n+            (starting_from..)\n+                .map(|idx| TyKind::BoundVar(BoundVar::new(debruijn, idx)).intern(&Interner)),\n+        )\n     }\n \n     pub fn fill_with_unknown(self) -> Self {\n-        self.fill(iter::repeat(Ty::Unknown))\n+        self.fill(iter::repeat(TyKind::Unknown.intern(&Interner)))\n     }\n \n     pub fn fill(mut self, filler: impl Iterator<Item = Ty>) -> Self {\n@@ -601,45 +624,52 @@ impl TypeWalk for CallableSig {\n \n impl Ty {\n     pub fn unit() -> Self {\n-        Ty::Tuple(0, Substs::empty())\n+        TyKind::Tuple(0, Substs::empty()).intern(&Interner)\n     }\n \n     pub fn adt_ty(adt: hir_def::AdtId, substs: Substs) -> Ty {\n-        Ty::Adt(AdtId(adt), substs)\n+        TyKind::Adt(AdtId(adt), substs).intern(&Interner)\n     }\n \n     pub fn fn_ptr(sig: CallableSig) -> Self {\n-        Ty::Function(FnPointer {\n+        TyKind::Function(FnPointer {\n             num_args: sig.params().len(),\n             sig: FnSig { variadic: sig.is_varargs },\n             substs: Substs(sig.params_and_return),\n         })\n+        .intern(&Interner)\n     }\n \n     pub fn builtin(builtin: BuiltinType) -> Self {\n         match builtin {\n-            BuiltinType::Char => Ty::Scalar(Scalar::Char),\n-            BuiltinType::Bool => Ty::Scalar(Scalar::Bool),\n-            BuiltinType::Str => Ty::Str,\n-            BuiltinType::Int(t) => Ty::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))),\n-            BuiltinType::Uint(t) => Ty::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))),\n-            BuiltinType::Float(t) => Ty::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))),\n+            BuiltinType::Char => TyKind::Scalar(Scalar::Char).intern(&Interner),\n+            BuiltinType::Bool => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n+            BuiltinType::Str => TyKind::Str.intern(&Interner),\n+            BuiltinType::Int(t) => {\n+                TyKind::Scalar(Scalar::Int(primitive::int_ty_from_builtin(t))).intern(&Interner)\n+            }\n+            BuiltinType::Uint(t) => {\n+                TyKind::Scalar(Scalar::Uint(primitive::uint_ty_from_builtin(t))).intern(&Interner)\n+            }\n+            BuiltinType::Float(t) => {\n+                TyKind::Scalar(Scalar::Float(primitive::float_ty_from_builtin(t))).intern(&Interner)\n+            }\n         }\n     }\n \n     pub fn as_reference(&self) -> Option<(&Ty, Mutability)> {\n-        match self {\n-            Ty::Ref(mutability, parameters) => Some((parameters.as_single(), *mutability)),\n+        match self.interned(&Interner) {\n+            TyKind::Ref(mutability, parameters) => Some((parameters.as_single(), *mutability)),\n             _ => None,\n         }\n     }\n \n     pub fn as_reference_or_ptr(&self) -> Option<(&Ty, Rawness, Mutability)> {\n-        match self {\n-            Ty::Ref(mutability, parameters) => {\n+        match self.interned(&Interner) {\n+            TyKind::Ref(mutability, parameters) => {\n                 Some((parameters.as_single(), Rawness::Ref, *mutability))\n             }\n-            Ty::Raw(mutability, parameters) => {\n+            TyKind::Raw(mutability, parameters) => {\n                 Some((parameters.as_single(), Rawness::RawPtr, *mutability))\n             }\n             _ => None,\n@@ -649,73 +679,77 @@ impl Ty {\n     pub fn strip_references(&self) -> &Ty {\n         let mut t: &Ty = self;\n \n-        while let Ty::Ref(_mutability, parameters) = t {\n+        while let TyKind::Ref(_mutability, parameters) = t.interned(&Interner) {\n             t = parameters.as_single();\n         }\n \n         t\n     }\n \n     pub fn as_adt(&self) -> Option<(hir_def::AdtId, &Substs)> {\n-        match self {\n-            Ty::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),\n+        match self.interned(&Interner) {\n+            TyKind::Adt(AdtId(adt), parameters) => Some((*adt, parameters)),\n             _ => None,\n         }\n     }\n \n     pub fn as_tuple(&self) -> Option<&Substs> {\n-        match self {\n-            Ty::Tuple(_, substs) => Some(substs),\n+        match self.interned(&Interner) {\n+            TyKind::Tuple(_, substs) => Some(substs),\n             _ => None,\n         }\n     }\n \n     pub fn as_generic_def(&self) -> Option<GenericDefId> {\n-        match *self {\n-            Ty::Adt(AdtId(adt), ..) => Some(adt.into()),\n-            Ty::FnDef(callable, ..) => Some(callable.into()),\n-            Ty::AssociatedType(type_alias, ..) => Some(type_alias.into()),\n-            Ty::ForeignType(type_alias, ..) => Some(type_alias.into()),\n+        match *self.interned(&Interner) {\n+            TyKind::Adt(AdtId(adt), ..) => Some(adt.into()),\n+            TyKind::FnDef(callable, ..) => Some(callable.into()),\n+            TyKind::AssociatedType(type_alias, ..) => Some(type_alias.into()),\n+            TyKind::ForeignType(type_alias, ..) => Some(type_alias.into()),\n             _ => None,\n         }\n     }\n \n     pub fn is_never(&self) -> bool {\n-        matches!(self, Ty::Never)\n+        matches!(self.interned(&Interner), TyKind::Never)\n     }\n \n     pub fn is_unknown(&self) -> bool {\n-        matches!(self, Ty::Unknown)\n+        matches!(self.interned(&Interner), TyKind::Unknown)\n     }\n \n     pub fn equals_ctor(&self, other: &Ty) -> bool {\n-        match (self, other) {\n-            (Ty::Adt(adt, ..), Ty::Adt(adt2, ..)) => adt == adt2,\n-            (Ty::Slice(_), Ty::Slice(_)) | (Ty::Array(_), Ty::Array(_)) => true,\n-            (Ty::FnDef(def_id, ..), Ty::FnDef(def_id2, ..)) => def_id == def_id2,\n-            (Ty::OpaqueType(ty_id, ..), Ty::OpaqueType(ty_id2, ..)) => ty_id == ty_id2,\n-            (Ty::AssociatedType(ty_id, ..), Ty::AssociatedType(ty_id2, ..))\n-            | (Ty::ForeignType(ty_id, ..), Ty::ForeignType(ty_id2, ..)) => ty_id == ty_id2,\n-            (Ty::Closure(def, expr, _), Ty::Closure(def2, expr2, _)) => {\n+        match (self.interned(&Interner), other.interned(&Interner)) {\n+            (TyKind::Adt(adt, ..), TyKind::Adt(adt2, ..)) => adt == adt2,\n+            (TyKind::Slice(_), TyKind::Slice(_)) | (TyKind::Array(_), TyKind::Array(_)) => true,\n+            (TyKind::FnDef(def_id, ..), TyKind::FnDef(def_id2, ..)) => def_id == def_id2,\n+            (TyKind::OpaqueType(ty_id, ..), TyKind::OpaqueType(ty_id2, ..)) => ty_id == ty_id2,\n+            (TyKind::AssociatedType(ty_id, ..), TyKind::AssociatedType(ty_id2, ..))\n+            | (TyKind::ForeignType(ty_id, ..), TyKind::ForeignType(ty_id2, ..)) => ty_id == ty_id2,\n+            (TyKind::Closure(def, expr, _), TyKind::Closure(def2, expr2, _)) => {\n                 expr == expr2 && def == def2\n             }\n-            (Ty::Ref(mutability, ..), Ty::Ref(mutability2, ..))\n-            | (Ty::Raw(mutability, ..), Ty::Raw(mutability2, ..)) => mutability == mutability2,\n+            (TyKind::Ref(mutability, ..), TyKind::Ref(mutability2, ..))\n+            | (TyKind::Raw(mutability, ..), TyKind::Raw(mutability2, ..)) => {\n+                mutability == mutability2\n+            }\n             (\n-                Ty::Function(FnPointer { num_args, sig, .. }),\n-                Ty::Function(FnPointer { num_args: num_args2, sig: sig2, .. }),\n+                TyKind::Function(FnPointer { num_args, sig, .. }),\n+                TyKind::Function(FnPointer { num_args: num_args2, sig: sig2, .. }),\n             ) => num_args == num_args2 && sig == sig2,\n-            (Ty::Tuple(cardinality, _), Ty::Tuple(cardinality2, _)) => cardinality == cardinality2,\n-            (Ty::Str, Ty::Str) | (Ty::Never, Ty::Never) => true,\n-            (Ty::Scalar(scalar), Ty::Scalar(scalar2)) => scalar == scalar2,\n+            (TyKind::Tuple(cardinality, _), TyKind::Tuple(cardinality2, _)) => {\n+                cardinality == cardinality2\n+            }\n+            (TyKind::Str, TyKind::Str) | (TyKind::Never, TyKind::Never) => true,\n+            (TyKind::Scalar(scalar), TyKind::Scalar(scalar2)) => scalar == scalar2,\n             _ => false,\n         }\n     }\n \n     /// If this is a `dyn Trait` type, this returns the `Trait` part.\n     pub fn dyn_trait_ref(&self) -> Option<&TraitRef> {\n-        match self {\n-            Ty::Dyn(bounds) => bounds.get(0).and_then(|b| match b {\n+        match self.interned(&Interner) {\n+            TyKind::Dyn(bounds) => bounds.get(0).and_then(|b| match b {\n                 GenericPredicate::Implemented(trait_ref) => Some(trait_ref),\n                 _ => None,\n             }),\n@@ -729,28 +763,28 @@ impl Ty {\n     }\n \n     fn builtin_deref(&self) -> Option<Ty> {\n-        match self {\n-            Ty::Ref(.., parameters) => Some(Ty::clone(parameters.as_single())),\n-            Ty::Raw(.., parameters) => Some(Ty::clone(parameters.as_single())),\n+        match self.interned(&Interner) {\n+            TyKind::Ref(.., parameters) => Some(Ty::clone(parameters.as_single())),\n+            TyKind::Raw(.., parameters) => Some(Ty::clone(parameters.as_single())),\n             _ => None,\n         }\n     }\n \n     pub fn as_fn_def(&self) -> Option<FunctionId> {\n-        match self {\n-            &Ty::FnDef(CallableDefId::FunctionId(func), ..) => Some(func),\n+        match self.interned(&Interner) {\n+            &TyKind::FnDef(CallableDefId::FunctionId(func), ..) => Some(func),\n             _ => None,\n         }\n     }\n \n     pub fn callable_sig(&self, db: &dyn HirDatabase) -> Option<CallableSig> {\n-        match self {\n-            Ty::Function(fn_ptr) => Some(CallableSig::from_fn_ptr(fn_ptr)),\n-            Ty::FnDef(def, parameters) => {\n+        match self.interned(&Interner) {\n+            TyKind::Function(fn_ptr) => Some(CallableSig::from_fn_ptr(fn_ptr)),\n+            TyKind::FnDef(def, parameters) => {\n                 let sig = db.callable_item_signature(*def);\n                 Some(sig.subst(&parameters))\n             }\n-            Ty::Closure(.., substs) => {\n+            TyKind::Closure(.., substs) => {\n                 let sig_param = &substs[0];\n                 sig_param.callable_sig(db)\n             }\n@@ -763,18 +797,18 @@ impl Ty {\n     /// `self` is `Option<_>` and the substs contain `u32`, we'll have\n     /// `Option<u32>` afterwards.)\n     pub fn apply_substs(mut self, new_substs: Substs) -> Ty {\n-        match &mut self {\n-            Ty::Adt(_, substs)\n-            | Ty::Slice(substs)\n-            | Ty::Array(substs)\n-            | Ty::Raw(_, substs)\n-            | Ty::Ref(_, substs)\n-            | Ty::FnDef(_, substs)\n-            | Ty::Function(FnPointer { substs, .. })\n-            | Ty::Tuple(_, substs)\n-            | Ty::OpaqueType(_, substs)\n-            | Ty::AssociatedType(_, substs)\n-            | Ty::Closure(.., substs) => {\n+        match &mut self.0 {\n+            TyKind::Adt(_, substs)\n+            | TyKind::Slice(substs)\n+            | TyKind::Array(substs)\n+            | TyKind::Raw(_, substs)\n+            | TyKind::Ref(_, substs)\n+            | TyKind::FnDef(_, substs)\n+            | TyKind::Function(FnPointer { substs, .. })\n+            | TyKind::Tuple(_, substs)\n+            | TyKind::OpaqueType(_, substs)\n+            | TyKind::AssociatedType(_, substs)\n+            | TyKind::Closure(.., substs) => {\n                 assert_eq!(substs.len(), new_substs.len());\n                 *substs = new_substs;\n             }\n@@ -786,42 +820,42 @@ impl Ty {\n     /// Returns the type parameters of this type if it has some (i.e. is an ADT\n     /// or function); so if `self` is `Option<u32>`, this returns the `u32`.\n     pub fn substs(&self) -> Option<&Substs> {\n-        match self {\n-            Ty::Adt(_, substs)\n-            | Ty::Slice(substs)\n-            | Ty::Array(substs)\n-            | Ty::Raw(_, substs)\n-            | Ty::Ref(_, substs)\n-            | Ty::FnDef(_, substs)\n-            | Ty::Function(FnPointer { substs, .. })\n-            | Ty::Tuple(_, substs)\n-            | Ty::OpaqueType(_, substs)\n-            | Ty::AssociatedType(_, substs)\n-            | Ty::Closure(.., substs) => Some(substs),\n+        match self.interned(&Interner) {\n+            TyKind::Adt(_, substs)\n+            | TyKind::Slice(substs)\n+            | TyKind::Array(substs)\n+            | TyKind::Raw(_, substs)\n+            | TyKind::Ref(_, substs)\n+            | TyKind::FnDef(_, substs)\n+            | TyKind::Function(FnPointer { substs, .. })\n+            | TyKind::Tuple(_, substs)\n+            | TyKind::OpaqueType(_, substs)\n+            | TyKind::AssociatedType(_, substs)\n+            | TyKind::Closure(.., substs) => Some(substs),\n             _ => None,\n         }\n     }\n \n     pub fn substs_mut(&mut self) -> Option<&mut Substs> {\n-        match self {\n-            Ty::Adt(_, substs)\n-            | Ty::Slice(substs)\n-            | Ty::Array(substs)\n-            | Ty::Raw(_, substs)\n-            | Ty::Ref(_, substs)\n-            | Ty::FnDef(_, substs)\n-            | Ty::Function(FnPointer { substs, .. })\n-            | Ty::Tuple(_, substs)\n-            | Ty::OpaqueType(_, substs)\n-            | Ty::AssociatedType(_, substs)\n-            | Ty::Closure(.., substs) => Some(substs),\n+        match &mut self.0 {\n+            TyKind::Adt(_, substs)\n+            | TyKind::Slice(substs)\n+            | TyKind::Array(substs)\n+            | TyKind::Raw(_, substs)\n+            | TyKind::Ref(_, substs)\n+            | TyKind::FnDef(_, substs)\n+            | TyKind::Function(FnPointer { substs, .. })\n+            | TyKind::Tuple(_, substs)\n+            | TyKind::OpaqueType(_, substs)\n+            | TyKind::AssociatedType(_, substs)\n+            | TyKind::Closure(.., substs) => Some(substs),\n             _ => None,\n         }\n     }\n \n     pub fn impl_trait_bounds(&self, db: &dyn HirDatabase) -> Option<Vec<GenericPredicate>> {\n-        match self {\n-            Ty::OpaqueType(opaque_ty_id, ..) => {\n+        match self.interned(&Interner) {\n+            TyKind::OpaqueType(opaque_ty_id, ..) => {\n                 match opaque_ty_id {\n                     OpaqueTyId::AsyncBlockTypeImplTrait(def, _expr) => {\n                         let krate = def.module(db.upcast()).krate();\n@@ -844,7 +878,7 @@ impl Ty {\n                     OpaqueTyId::ReturnTypeImplTrait(..) => None,\n                 }\n             }\n-            Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n+            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n                 let predicates = match opaque_ty.opaque_ty_id {\n                     OpaqueTyId::ReturnTypeImplTrait(func, idx) => {\n                         db.return_type_impl_traits(func).map(|it| {\n@@ -860,7 +894,7 @@ impl Ty {\n \n                 predicates.map(|it| it.value)\n             }\n-            Ty::Placeholder(id) => {\n+            TyKind::Placeholder(id) => {\n                 let generic_params = db.generic_params(id.parent);\n                 let param_data = &generic_params.types[id.local_id];\n                 match param_data.provenance {\n@@ -881,14 +915,14 @@ impl Ty {\n     }\n \n     pub fn associated_type_parent_trait(&self, db: &dyn HirDatabase) -> Option<TraitId> {\n-        match self {\n-            Ty::AssociatedType(type_alias_id, ..) => {\n+        match self.interned(&Interner) {\n+            TyKind::AssociatedType(type_alias_id, ..) => {\n                 match type_alias_id.lookup(db.upcast()).container {\n                     AssocContainerId::TraitId(trait_id) => Some(trait_id),\n                     _ => None,\n                 }\n             }\n-            Ty::Alias(AliasTy::Projection(projection_ty)) => {\n+            TyKind::Alias(AliasTy::Projection(projection_ty)) => {\n                 match projection_ty.associated_ty.lookup(db.upcast()).container {\n                     AssocContainerId::TraitId(trait_id) => Some(trait_id),\n                     _ => None,\n@@ -908,13 +942,13 @@ pub trait TypeWalk {\n     }\n     /// Walk the type, counting entered binders.\n     ///\n-    /// `Ty::Bound` variables use DeBruijn indexing, which means that 0 refers\n+    /// `TyKind::Bound` variables use DeBruijn indexing, which means that 0 refers\n     /// to the innermost binder, 1 to the next, etc.. So when we want to\n     /// substitute a certain bound variable, we can't just walk the whole type\n     /// and blindly replace each instance of a certain index; when we 'enter'\n     /// things that introduce new bound variables, we have to keep track of\n     /// that. Currently, the only thing that introduces bound variables on our\n-    /// side are `Ty::Dyn` and `Ty::Opaque`, which each introduce a bound\n+    /// side are `TyKind::Dyn` and `TyKind::Opaque`, which each introduce a bound\n     /// variable for the self type.\n     fn walk_mut_binders(\n         &mut self,\n@@ -932,7 +966,7 @@ pub trait TypeWalk {\n     {\n         self.walk_mut_binders(\n             &mut |ty_mut, binders| {\n-                let ty = mem::replace(ty_mut, Ty::Unknown);\n+                let ty = mem::replace(ty_mut, Ty(TyKind::Unknown));\n                 *ty_mut = f(ty, binders);\n             },\n             binders,\n@@ -945,28 +979,28 @@ pub trait TypeWalk {\n         Self: Sized,\n     {\n         self.walk_mut(&mut |ty_mut| {\n-            let ty = mem::replace(ty_mut, Ty::Unknown);\n+            let ty = mem::replace(ty_mut, Ty(TyKind::Unknown));\n             *ty_mut = f(ty);\n         });\n         self\n     }\n \n-    /// Substitutes `Ty::Bound` vars with the given substitution.\n+    /// Substitutes `TyKind::Bound` vars with the given substitution.\n     fn subst_bound_vars(self, substs: &Substs) -> Self\n     where\n         Self: Sized,\n     {\n         self.subst_bound_vars_at_depth(substs, DebruijnIndex::INNERMOST)\n     }\n \n-    /// Substitutes `Ty::Bound` vars with the given substitution.\n+    /// Substitutes `TyKind::Bound` vars with the given substitution.\n     fn subst_bound_vars_at_depth(mut self, substs: &Substs, depth: DebruijnIndex) -> Self\n     where\n         Self: Sized,\n     {\n         self.walk_mut_binders(\n             &mut |ty, binders| {\n-                if let &mut Ty::BoundVar(bound) = ty {\n+                if let &mut TyKind::BoundVar(bound) = &mut ty.0 {\n                     if bound.debruijn >= binders {\n                         *ty = substs.0[bound.index].clone().shift_bound_vars(binders);\n                     }\n@@ -977,17 +1011,17 @@ pub trait TypeWalk {\n         self\n     }\n \n-    /// Shifts up debruijn indices of `Ty::Bound` vars by `n`.\n+    /// Shifts up debruijn indices of `TyKind::Bound` vars by `n`.\n     fn shift_bound_vars(self, n: DebruijnIndex) -> Self\n     where\n         Self: Sized,\n     {\n         self.fold_binders(\n-            &mut |ty, binders| match ty {\n-                Ty::BoundVar(bound) if bound.debruijn >= binders => {\n-                    Ty::BoundVar(bound.shifted_in_from(n))\n+            &mut |ty, binders| match &ty.0 {\n+                TyKind::BoundVar(bound) if bound.debruijn >= binders => {\n+                    TyKind::BoundVar(bound.shifted_in_from(n)).intern(&Interner)\n                 }\n-                ty => ty,\n+                _ => ty,\n             },\n             DebruijnIndex::INNERMOST,\n         )\n@@ -996,18 +1030,18 @@ pub trait TypeWalk {\n \n impl TypeWalk for Ty {\n     fn walk(&self, f: &mut impl FnMut(&Ty)) {\n-        match self {\n-            Ty::Alias(AliasTy::Projection(p_ty)) => {\n+        match self.interned(&Interner) {\n+            TyKind::Alias(AliasTy::Projection(p_ty)) => {\n                 for t in p_ty.parameters.iter() {\n                     t.walk(f);\n                 }\n             }\n-            Ty::Alias(AliasTy::Opaque(o_ty)) => {\n+            TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n                 for t in o_ty.parameters.iter() {\n                     t.walk(f);\n                 }\n             }\n-            Ty::Dyn(predicates) => {\n+            TyKind::Dyn(predicates) => {\n                 for p in predicates.iter() {\n                     p.walk(f);\n                 }\n@@ -1028,16 +1062,16 @@ impl TypeWalk for Ty {\n         f: &mut impl FnMut(&mut Ty, DebruijnIndex),\n         binders: DebruijnIndex,\n     ) {\n-        match self {\n-            Ty::Alias(AliasTy::Projection(p_ty)) => {\n+        match &mut self.0 {\n+            TyKind::Alias(AliasTy::Projection(p_ty)) => {\n                 p_ty.parameters.walk_mut_binders(f, binders);\n             }\n-            Ty::Dyn(predicates) => {\n+            TyKind::Dyn(predicates) => {\n                 for p in make_mut_slice(predicates) {\n                     p.walk_mut_binders(f, binders.shifted_in());\n                 }\n             }\n-            Ty::Alias(AliasTy::Opaque(o_ty)) => {\n+            TyKind::Alias(AliasTy::Opaque(o_ty)) => {\n                 o_ty.parameters.walk_mut_binders(f, binders);\n             }\n             _ => {"}, {"sha": "9fe7e3dce28aa146548e63d5ffc54a1632652f50", "filename": "crates/hir_ty/src/lower.rs", "status": "modified", "additions": 71, "deletions": 51, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Flower.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -34,7 +34,7 @@ use crate::{\n     },\n     AliasTy, Binders, BoundVar, CallableSig, DebruijnIndex, FnPointer, FnSig, GenericPredicate,\n     OpaqueTy, OpaqueTyId, PolyFnSig, ProjectionPredicate, ProjectionTy, ReturnTypeImplTrait,\n-    ReturnTypeImplTraits, Substs, TraitEnvironment, TraitRef, Ty, TypeWalk,\n+    ReturnTypeImplTraits, Substs, TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk,\n };\n \n #[derive(Debug)]\n@@ -146,10 +146,10 @@ impl Ty {\n     pub fn from_hir_ext(ctx: &TyLoweringContext<'_>, type_ref: &TypeRef) -> (Self, Option<TypeNs>) {\n         let mut res = None;\n         let ty = match type_ref {\n-            TypeRef::Never => Ty::Never,\n+            TypeRef::Never => TyKind::Never.intern(&Interner),\n             TypeRef::Tuple(inner) => {\n                 let inner_tys: Arc<[Ty]> = inner.iter().map(|tr| Ty::from_hir(ctx, tr)).collect();\n-                Ty::Tuple(inner_tys.len(), Substs(inner_tys))\n+                TyKind::Tuple(inner_tys.len(), Substs(inner_tys)).intern(&Interner)\n             }\n             TypeRef::Path(path) => {\n                 let (ty, res_) = Ty::from_hir_path(ctx, path);\n@@ -158,38 +158,42 @@ impl Ty {\n             }\n             TypeRef::RawPtr(inner, mutability) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::Raw(lower_to_chalk_mutability(*mutability), Substs::single(inner_ty))\n+                TyKind::Raw(lower_to_chalk_mutability(*mutability), Substs::single(inner_ty))\n+                    .intern(&Interner)\n             }\n             TypeRef::Array(inner) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::Array(Substs::single(inner_ty))\n+                TyKind::Array(Substs::single(inner_ty)).intern(&Interner)\n             }\n             TypeRef::Slice(inner) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::Slice(Substs::single(inner_ty))\n+                TyKind::Slice(Substs::single(inner_ty)).intern(&Interner)\n             }\n             TypeRef::Reference(inner, _, mutability) => {\n                 let inner_ty = Ty::from_hir(ctx, inner);\n-                Ty::Ref(lower_to_chalk_mutability(*mutability), Substs::single(inner_ty))\n+                TyKind::Ref(lower_to_chalk_mutability(*mutability), Substs::single(inner_ty))\n+                    .intern(&Interner)\n             }\n-            TypeRef::Placeholder => Ty::Unknown,\n+            TypeRef::Placeholder => TyKind::Unknown.intern(&Interner),\n             TypeRef::Fn(params, is_varargs) => {\n                 let substs = Substs(params.iter().map(|tr| Ty::from_hir(ctx, tr)).collect());\n-                Ty::Function(FnPointer {\n+                TyKind::Function(FnPointer {\n                     num_args: substs.len() - 1,\n                     sig: FnSig { variadic: *is_varargs },\n                     substs,\n                 })\n+                .intern(&Interner)\n             }\n             TypeRef::DynTrait(bounds) => {\n-                let self_ty = Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n+                let self_ty =\n+                    TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n                 let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n                     bounds\n                         .iter()\n                         .flat_map(|b| GenericPredicate::from_type_bound(ctx, b, self_ty.clone()))\n                         .collect()\n                 });\n-                Ty::Dyn(predicates)\n+                TyKind::Dyn(predicates).intern(&Interner)\n             }\n             TypeRef::ImplTrait(bounds) => {\n                 match ctx.impl_trait_mode {\n@@ -226,10 +230,11 @@ impl Ty {\n                         let impl_trait_id = OpaqueTyId::ReturnTypeImplTrait(func, idx);\n                         let generics = generics(ctx.db.upcast(), func.into());\n                         let parameters = Substs::bound_vars(&generics, ctx.in_binders);\n-                        Ty::Alias(AliasTy::Opaque(OpaqueTy {\n+                        TyKind::Alias(AliasTy::Opaque(OpaqueTy {\n                             opaque_ty_id: impl_trait_id,\n                             parameters,\n                         }))\n+                        .intern(&Interner)\n                     }\n                     ImplTraitLoweringMode::Param => {\n                         let idx = ctx.impl_trait_counter.get();\n@@ -243,10 +248,10 @@ impl Ty {\n                                     data.provenance == TypeParamProvenance::ArgumentImplTrait\n                                 })\n                                 .nth(idx as usize)\n-                                .map_or(Ty::Unknown, |(id, _)| Ty::Placeholder(id));\n-                            param\n+                                .map_or(TyKind::Unknown, |(id, _)| TyKind::Placeholder(id));\n+                            param.intern(&Interner)\n                         } else {\n-                            Ty::Unknown\n+                            TyKind::Unknown.intern(&Interner)\n                         }\n                     }\n                     ImplTraitLoweringMode::Variable => {\n@@ -260,18 +265,19 @@ impl Ty {\n                             } else {\n                                 (0, 0, 0, 0)\n                             };\n-                        Ty::BoundVar(BoundVar::new(\n+                        TyKind::BoundVar(BoundVar::new(\n                             ctx.in_binders,\n                             idx as usize + parent_params + self_params + list_params,\n                         ))\n+                        .intern(&Interner)\n                     }\n                     ImplTraitLoweringMode::Disallowed => {\n                         // FIXME: report error\n-                        Ty::Unknown\n+                        TyKind::Unknown.intern(&Interner)\n                     }\n                 }\n             }\n-            TypeRef::Error => Ty::Unknown,\n+            TypeRef::Error => TyKind::Unknown.intern(&Interner),\n         };\n         (ty, res)\n     }\n@@ -315,7 +321,7 @@ impl Ty {\n             (Ty::select_associated_type(ctx, res, segment), None)\n         } else if remaining_segments.len() > 1 {\n             // FIXME report error (ambiguous associated type)\n-            (Ty::Unknown, None)\n+            (TyKind::Unknown.intern(&Interner), None)\n         } else {\n             (ty, res)\n         }\n@@ -332,7 +338,10 @@ impl Ty {\n             TypeNs::TraitId(trait_) => {\n                 // if this is a bare dyn Trait, we'll directly put the required ^0 for the self type in there\n                 let self_ty = if remaining_segments.len() == 0 {\n-                    Some(Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)))\n+                    Some(\n+                        TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n+                            .intern(&Interner),\n+                    )\n                 } else {\n                     None\n                 };\n@@ -348,21 +357,23 @@ impl Ty {\n                     match found {\n                         Some((super_trait_ref, associated_ty)) => {\n                             // FIXME handle type parameters on the segment\n-                            Ty::Alias(AliasTy::Projection(ProjectionTy {\n+                            TyKind::Alias(AliasTy::Projection(ProjectionTy {\n                                 associated_ty,\n                                 parameters: super_trait_ref.substs,\n                             }))\n+                            .intern(&Interner)\n                         }\n                         None => {\n                             // FIXME: report error (associated type not found)\n-                            Ty::Unknown\n+                            TyKind::Unknown.intern(&Interner)\n                         }\n                     }\n                 } else if remaining_segments.len() > 1 {\n                     // FIXME report error (ambiguous associated type)\n-                    Ty::Unknown\n+                    TyKind::Unknown.intern(&Interner)\n                 } else {\n-                    Ty::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n+                    TyKind::Dyn(Arc::new([GenericPredicate::Implemented(trait_ref)]))\n+                        .intern(&Interner)\n                 };\n                 return (ty, None);\n             }\n@@ -372,12 +383,13 @@ impl Ty {\n                     ctx.resolver.generic_def().expect(\"generics in scope\"),\n                 );\n                 match ctx.type_param_mode {\n-                    TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n+                    TypeParamLoweringMode::Placeholder => TyKind::Placeholder(param_id),\n                     TypeParamLoweringMode::Variable => {\n                         let idx = generics.param_idx(param_id).expect(\"matching generics\");\n-                        Ty::BoundVar(BoundVar::new(ctx.in_binders, idx))\n+                        TyKind::BoundVar(BoundVar::new(ctx.in_binders, idx))\n                     }\n                 }\n+                .intern(&Interner)\n             }\n             TypeNs::SelfType(impl_id) => {\n                 let generics = generics(ctx.db.upcast(), impl_id.into());\n@@ -414,7 +426,7 @@ impl Ty {\n                 Ty::from_hir_path_inner(ctx, resolved_segment, it.into(), infer_args)\n             }\n             // FIXME: report error\n-            TypeNs::EnumVariantId(_) => return (Ty::Unknown, None),\n+            TypeNs::EnumVariantId(_) => return (TyKind::Unknown.intern(&Interner), None),\n         };\n         Ty::from_type_relative_path(ctx, ty, Some(resolution), remaining_segments)\n     }\n@@ -428,7 +440,7 @@ impl Ty {\n         let (resolution, remaining_index) =\n             match ctx.resolver.resolve_path_in_type_ns(ctx.db.upcast(), path.mod_path()) {\n                 Some(it) => it,\n-                None => return (Ty::Unknown, None),\n+                None => return (TyKind::Unknown.intern(&Interner), None),\n             };\n         let (resolved_segment, remaining_segments) = match remaining_index {\n             None => (\n@@ -473,18 +485,21 @@ impl Ty {\n                         // associated_type_shorthand_candidates does not do that\n                         let substs = substs.shift_bound_vars(ctx.in_binders);\n                         // FIXME handle type parameters on the segment\n-                        return Some(Ty::Alias(AliasTy::Projection(ProjectionTy {\n-                            associated_ty,\n-                            parameters: substs,\n-                        })));\n+                        return Some(\n+                            TyKind::Alias(AliasTy::Projection(ProjectionTy {\n+                                associated_ty,\n+                                parameters: substs,\n+                            }))\n+                            .intern(&Interner),\n+                        );\n                     }\n \n                     None\n                 });\n \n-            ty.unwrap_or(Ty::Unknown)\n+            ty.unwrap_or(TyKind::Unknown.intern(&Interner))\n         } else {\n-            Ty::Unknown\n+            TyKind::Unknown.intern(&Interner)\n         }\n     }\n \n@@ -553,13 +568,13 @@ fn substs_from_path_segment(\n         def_generics.map_or((0, 0, 0, 0), |g| g.provenance_split());\n     let total_len = parent_params + self_params + type_params + impl_trait_params;\n \n-    substs.extend(iter::repeat(Ty::Unknown).take(parent_params));\n+    substs.extend(iter::repeat(TyKind::Unknown.intern(&Interner)).take(parent_params));\n \n     let mut had_explicit_type_args = false;\n \n     if let Some(generic_args) = &segment.args_and_bindings {\n         if !generic_args.has_self_type {\n-            substs.extend(iter::repeat(Ty::Unknown).take(self_params));\n+            substs.extend(iter::repeat(TyKind::Unknown.intern(&Interner)).take(self_params));\n         }\n         let expected_num =\n             if generic_args.has_self_type { self_params + type_params } else { type_params };\n@@ -602,7 +617,7 @@ fn substs_from_path_segment(\n     // add placeholders for args that were not provided\n     // FIXME: emit diagnostics in contexts where this is not allowed\n     for _ in substs.len()..total_len {\n-        substs.push(Ty::Unknown);\n+        substs.push(TyKind::Unknown.intern(&Interner));\n     }\n     assert_eq!(substs.len(), total_len);\n \n@@ -674,12 +689,13 @@ impl GenericPredicate {\n                         let param_id =\n                             hir_def::TypeParamId { parent: generic_def, local_id: *param_id };\n                         match ctx.type_param_mode {\n-                            TypeParamLoweringMode::Placeholder => Ty::Placeholder(param_id),\n+                            TypeParamLoweringMode::Placeholder => TyKind::Placeholder(param_id),\n                             TypeParamLoweringMode::Variable => {\n                                 let idx = generics.param_idx(param_id).expect(\"matching generics\");\n-                                Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n+                                TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, idx))\n                             }\n                         }\n+                        .intern(&Interner)\n                     }\n                 };\n                 GenericPredicate::from_type_bound(ctx, bound, self_ty)\n@@ -751,7 +767,7 @@ fn assoc_type_bindings_from_type_bound<'a>(\n                 preds.extend(GenericPredicate::from_type_bound(\n                     ctx,\n                     bound,\n-                    Ty::Alias(AliasTy::Projection(projection_ty.clone())),\n+                    TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(&Interner),\n                 ));\n             }\n             preds\n@@ -761,7 +777,8 @@ fn assoc_type_bindings_from_type_bound<'a>(\n impl ReturnTypeImplTrait {\n     fn from_hir(ctx: &TyLoweringContext, bounds: &[TypeBound]) -> Self {\n         cov_mark::hit!(lower_rpit);\n-        let self_ty = Ty::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n+        let self_ty =\n+            TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n         let predicates = ctx.with_shifted_in(DebruijnIndex::ONE, |ctx| {\n             bounds\n                 .iter()\n@@ -994,17 +1011,20 @@ pub(crate) fn generic_defaults_query(\n         .iter()\n         .enumerate()\n         .map(|(idx, (_, p))| {\n-            let mut ty = p.default.as_ref().map_or(Ty::Unknown, |t| Ty::from_hir(&ctx, t));\n+            let mut ty = p\n+                .default\n+                .as_ref()\n+                .map_or(TyKind::Unknown.intern(&Interner), |t| Ty::from_hir(&ctx, t));\n \n             // Each default can only refer to previous parameters.\n             ty.walk_mut_binders(\n-                &mut |ty, binders| match ty {\n-                    Ty::BoundVar(BoundVar { debruijn, index }) if *debruijn == binders => {\n+                &mut |ty, binders| match &mut ty.0 {\n+                    TyKind::BoundVar(BoundVar { debruijn, index }) if *debruijn == binders => {\n                         if *index >= idx {\n                             // type variable default referring to parameter coming\n                             // after it. This is forbidden (FIXME: report\n                             // diagnostic)\n-                            *ty = Ty::Unknown;\n+                            *ty = TyKind::Unknown.intern(&Interner);\n                         }\n                     }\n                     _ => {}\n@@ -1040,7 +1060,7 @@ fn fn_sig_for_fn(db: &dyn HirDatabase, def: FunctionId) -> PolyFnSig {\n fn type_for_fn(db: &dyn HirDatabase, def: FunctionId) -> Binders<Ty> {\n     let generics = generics(db.upcast(), def.into());\n     let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(), Ty::FnDef(def.into(), substs))\n+    Binders::new(substs.len(), TyKind::FnDef(def.into(), substs).intern(&Interner))\n }\n \n /// Build the declared type of a const.\n@@ -1083,7 +1103,7 @@ fn type_for_struct_constructor(db: &dyn HirDatabase, def: StructId) -> Binders<T\n     }\n     let generics = generics(db.upcast(), def.into());\n     let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(), Ty::FnDef(def.into(), substs))\n+    Binders::new(substs.len(), TyKind::FnDef(def.into(), substs).intern(&Interner))\n }\n \n fn fn_sig_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -> PolyFnSig {\n@@ -1108,7 +1128,7 @@ fn type_for_enum_variant_constructor(db: &dyn HirDatabase, def: EnumVariantId) -\n     }\n     let generics = generics(db.upcast(), def.parent.into());\n     let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n-    Binders::new(substs.len(), Ty::FnDef(def.into(), substs))\n+    Binders::new(substs.len(), TyKind::FnDef(def.into(), substs).intern(&Interner))\n }\n \n fn type_for_adt(db: &dyn HirDatabase, adt: AdtId) -> Binders<Ty> {\n@@ -1123,7 +1143,7 @@ fn type_for_type_alias(db: &dyn HirDatabase, t: TypeAliasId) -> Binders<Ty> {\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(TypeParamLoweringMode::Variable);\n     if db.type_alias_data(t).is_extern {\n-        Binders::new(0, Ty::ForeignType(t))\n+        Binders::new(0, TyKind::ForeignType(t).intern(&Interner))\n     } else {\n         let substs = Substs::bound_vars(&generics, DebruijnIndex::INNERMOST);\n         let type_ref = &db.type_alias_data(t).type_ref;\n@@ -1199,7 +1219,7 @@ pub(crate) fn ty_recover(db: &dyn HirDatabase, _cycle: &[String], def: &TyDefId)\n         TyDefId::AdtId(it) => generics(db.upcast(), it.into()).len(),\n         TyDefId::TypeAliasId(it) => generics(db.upcast(), it.into()).len(),\n     };\n-    Binders::new(num_binders, Ty::Unknown)\n+    Binders::new(num_binders, TyKind::Unknown.intern(&Interner))\n }\n \n pub(crate) fn value_ty_query(db: &dyn HirDatabase, def: ValueTyDefId) -> Binders<Ty> {\n@@ -1237,7 +1257,7 @@ pub(crate) fn impl_self_ty_recover(\n     impl_id: &ImplId,\n ) -> Binders<Ty> {\n     let generics = generics(db.upcast(), (*impl_id).into());\n-    Binders::new(generics.len(), Ty::Unknown)\n+    Binders::new(generics.len(), TyKind::Unknown.intern(&Interner))\n }\n \n pub(crate) fn impl_trait_query(db: &dyn HirDatabase, impl_id: ImplId) -> Option<Binders<TraitRef>> {"}, {"sha": "f9877e760764969d746a08745fdc79a4a91a9f9d", "filename": "crates/hir_ty/src/method_resolution.rs", "status": "modified", "additions": 41, "deletions": 35, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fmethod_resolution.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -19,8 +19,8 @@ use crate::{\n     db::HirDatabase,\n     primitive::{self, FloatTy, IntTy, UintTy},\n     utils::all_super_traits,\n-    AdtId, Canonical, DebruijnIndex, FnPointer, FnSig, InEnvironment, Scalar, Substs,\n-    TraitEnvironment, TraitRef, Ty, TypeWalk,\n+    AdtId, Canonical, DebruijnIndex, FnPointer, FnSig, InEnvironment, Interner, Scalar, Substs,\n+    TraitEnvironment, TraitRef, Ty, TyKind, TypeWalk,\n };\n \n /// This is used as a key for indexing impls.\n@@ -44,18 +44,20 @@ impl TyFingerprint {\n     /// have impls: if we have some `struct S`, we can have an `impl S`, but not\n     /// `impl &S`. Hence, this will return `None` for reference types and such.\n     pub(crate) fn for_impl(ty: &Ty) -> Option<TyFingerprint> {\n-        let fp = match ty {\n-            &Ty::Str => TyFingerprint::Str,\n-            &Ty::Never => TyFingerprint::Never,\n-            &Ty::Slice(..) => TyFingerprint::Slice,\n-            &Ty::Array(..) => TyFingerprint::Array,\n-            &Ty::Scalar(scalar) => TyFingerprint::Scalar(scalar),\n-            &Ty::Adt(AdtId(adt), _) => TyFingerprint::Adt(adt),\n-            &Ty::Tuple(cardinality, _) => TyFingerprint::Tuple(cardinality),\n-            &Ty::Raw(mutability, ..) => TyFingerprint::RawPtr(mutability),\n-            &Ty::ForeignType(alias_id, ..) => TyFingerprint::ForeignType(alias_id),\n-            &Ty::Function(FnPointer { num_args, sig, .. }) => TyFingerprint::FnPtr(num_args, sig),\n-            Ty::Dyn(_) => ty.dyn_trait().map(|trait_| TyFingerprint::Dyn(trait_))?,\n+        let fp = match *ty.interned(&Interner) {\n+            TyKind::Str => TyFingerprint::Str,\n+            TyKind::Never => TyFingerprint::Never,\n+            TyKind::Slice(..) => TyFingerprint::Slice,\n+            TyKind::Array(..) => TyFingerprint::Array,\n+            TyKind::Scalar(scalar) => TyFingerprint::Scalar(scalar),\n+            TyKind::Adt(AdtId(adt), _) => TyFingerprint::Adt(adt),\n+            TyKind::Tuple(cardinality, _) => TyFingerprint::Tuple(cardinality),\n+            TyKind::Raw(mutability, ..) => TyFingerprint::RawPtr(mutability),\n+            TyKind::ForeignType(alias_id, ..) => TyFingerprint::ForeignType(alias_id),\n+            TyKind::Function(FnPointer { num_args, sig, .. }) => {\n+                TyFingerprint::FnPtr(num_args, sig)\n+            }\n+            TyKind::Dyn(_) => ty.dyn_trait().map(|trait_| TyFingerprint::Dyn(trait_))?,\n             _ => return None,\n         };\n         Some(fp)\n@@ -230,31 +232,31 @@ impl Ty {\n \n         let mod_to_crate_ids = |module: ModuleId| Some(std::iter::once(module.krate()).collect());\n \n-        let lang_item_targets = match self {\n-            Ty::Adt(AdtId(def_id), _) => {\n+        let lang_item_targets = match self.interned(&Interner) {\n+            TyKind::Adt(AdtId(def_id), _) => {\n                 return mod_to_crate_ids(def_id.module(db.upcast()));\n             }\n-            Ty::ForeignType(type_alias_id) => {\n+            TyKind::ForeignType(type_alias_id) => {\n                 return mod_to_crate_ids(type_alias_id.lookup(db.upcast()).module(db.upcast()));\n             }\n-            Ty::Scalar(Scalar::Bool) => lang_item_crate!(\"bool\"),\n-            Ty::Scalar(Scalar::Char) => lang_item_crate!(\"char\"),\n-            Ty::Scalar(Scalar::Float(f)) => match f {\n+            TyKind::Scalar(Scalar::Bool) => lang_item_crate!(\"bool\"),\n+            TyKind::Scalar(Scalar::Char) => lang_item_crate!(\"char\"),\n+            TyKind::Scalar(Scalar::Float(f)) => match f {\n                 // There are two lang items: one in libcore (fXX) and one in libstd (fXX_runtime)\n                 FloatTy::F32 => lang_item_crate!(\"f32\", \"f32_runtime\"),\n                 FloatTy::F64 => lang_item_crate!(\"f64\", \"f64_runtime\"),\n             },\n-            &Ty::Scalar(Scalar::Int(t)) => {\n+            &TyKind::Scalar(Scalar::Int(t)) => {\n                 lang_item_crate!(primitive::int_ty_to_string(t))\n             }\n-            &Ty::Scalar(Scalar::Uint(t)) => {\n+            &TyKind::Scalar(Scalar::Uint(t)) => {\n                 lang_item_crate!(primitive::uint_ty_to_string(t))\n             }\n-            Ty::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n-            Ty::Slice(_) => lang_item_crate!(\"slice_alloc\", \"slice\"),\n-            Ty::Raw(Mutability::Not, _) => lang_item_crate!(\"const_ptr\"),\n-            Ty::Raw(Mutability::Mut, _) => lang_item_crate!(\"mut_ptr\"),\n-            Ty::Dyn(_) => {\n+            TyKind::Str => lang_item_crate!(\"str_alloc\", \"str\"),\n+            TyKind::Slice(_) => lang_item_crate!(\"slice_alloc\", \"slice\"),\n+            TyKind::Raw(Mutability::Not, _) => lang_item_crate!(\"const_ptr\"),\n+            TyKind::Raw(Mutability::Mut, _) => lang_item_crate!(\"mut_ptr\"),\n+            TyKind::Dyn(_) => {\n                 return self.dyn_trait().and_then(|trait_| {\n                     mod_to_crate_ids(GenericDefId::TraitId(trait_).module(db.upcast()))\n                 });\n@@ -430,7 +432,8 @@ fn iterate_method_candidates_with_autoref(\n     }\n     let refed = Canonical {\n         kinds: deref_chain[0].kinds.clone(),\n-        value: Ty::Ref(Mutability::Not, Substs::single(deref_chain[0].value.clone())),\n+        value: TyKind::Ref(Mutability::Not, Substs::single(deref_chain[0].value.clone()))\n+            .intern(&Interner),\n     };\n     if iterate_method_candidates_by_receiver(\n         &refed,\n@@ -446,7 +449,8 @@ fn iterate_method_candidates_with_autoref(\n     }\n     let ref_muted = Canonical {\n         kinds: deref_chain[0].kinds.clone(),\n-        value: Ty::Ref(Mutability::Mut, Substs::single(deref_chain[0].value.clone())),\n+        value: TyKind::Ref(Mutability::Mut, Substs::single(deref_chain[0].value.clone()))\n+            .intern(&Interner),\n     };\n     if iterate_method_candidates_by_receiver(\n         &ref_muted,\n@@ -526,7 +530,7 @@ fn iterate_trait_method_candidates(\n     // if ty is `dyn Trait`, the trait doesn't need to be in scope\n     let inherent_trait =\n         self_ty.value.dyn_trait().into_iter().flat_map(|t| all_super_traits(db.upcast(), t));\n-    let env_traits = if let Ty::Placeholder(_) = self_ty.value {\n+    let env_traits = if let TyKind::Placeholder(_) = self_ty.value.interned(&Interner) {\n         // if we have `T: Trait` in the param env, the trait doesn't need to be in scope\n         env.traits_in_scope_from_clauses(&self_ty.value)\n             .flat_map(|t| all_super_traits(db.upcast(), t))\n@@ -679,13 +683,13 @@ pub(crate) fn inherent_impl_substs(\n }\n \n /// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n-/// num_vars_to_keep) by `Ty::Unknown`.\n+/// num_vars_to_keep) by `TyKind::Unknown`.\n fn fallback_bound_vars(s: Substs, num_vars_to_keep: usize) -> Substs {\n     s.fold_binders(\n         &mut |ty, binders| {\n-            if let Ty::BoundVar(bound) = &ty {\n+            if let TyKind::BoundVar(bound) = ty.interned(&Interner) {\n                 if bound.index >= num_vars_to_keep && bound.debruijn >= binders {\n-                    Ty::Unknown\n+                    TyKind::Unknown.intern(&Interner)\n                 } else {\n                     ty\n                 }\n@@ -772,9 +776,11 @@ fn autoderef_method_receiver(\n ) -> Vec<Canonical<Ty>> {\n     let mut deref_chain: Vec<_> = autoderef::autoderef(db, Some(krate), ty).collect();\n     // As a last step, we can do array unsizing (that's the only unsizing that rustc does for method receivers!)\n-    if let Some(Ty::Array(parameters)) = deref_chain.last().map(|ty| &ty.value) {\n+    if let Some(TyKind::Array(parameters)) =\n+        deref_chain.last().map(|ty| ty.value.interned(&Interner))\n+    {\n         let kinds = deref_chain.last().unwrap().kinds.clone();\n-        let unsized_ty = Ty::Slice(parameters.clone());\n+        let unsized_ty = TyKind::Slice(parameters.clone()).intern(&Interner);\n         deref_chain.push(Canonical { value: unsized_ty, kinds })\n     }\n     deref_chain"}, {"sha": "527c5cbbd26bc3d58ac439c1ff6b2ae01747cc6b", "filename": "crates/hir_ty/src/op.rs", "status": "modified", "additions": 35, "deletions": 31, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fop.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -2,51 +2,55 @@\n use chalk_ir::TyVariableKind;\n use hir_def::expr::{ArithOp, BinaryOp, CmpOp};\n \n-use crate::{Scalar, Ty};\n+use crate::{Interner, Scalar, Ty, TyKind};\n \n pub(super) fn binary_op_return_ty(op: BinaryOp, lhs_ty: Ty, rhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => Ty::Scalar(Scalar::Bool),\n+        BinaryOp::LogicOp(_) | BinaryOp::CmpOp(_) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n         BinaryOp::Assignment { .. } => Ty::unit(),\n-        BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => match lhs_ty {\n-            Ty::Scalar(Scalar::Int(_))\n-            | Ty::Scalar(Scalar::Uint(_))\n-            | Ty::Scalar(Scalar::Float(_)) => lhs_ty,\n-            Ty::InferenceVar(_, TyVariableKind::Integer)\n-            | Ty::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n-            _ => Ty::Unknown,\n-        },\n-        BinaryOp::ArithOp(_) => match rhs_ty {\n-            Ty::Scalar(Scalar::Int(_))\n-            | Ty::Scalar(Scalar::Uint(_))\n-            | Ty::Scalar(Scalar::Float(_)) => rhs_ty,\n-            Ty::InferenceVar(_, TyVariableKind::Integer)\n-            | Ty::InferenceVar(_, TyVariableKind::Float) => rhs_ty,\n-            _ => Ty::Unknown,\n+        BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => {\n+            match lhs_ty.interned(&Interner) {\n+                TyKind::Scalar(Scalar::Int(_))\n+                | TyKind::Scalar(Scalar::Uint(_))\n+                | TyKind::Scalar(Scalar::Float(_)) => lhs_ty,\n+                TyKind::InferenceVar(_, TyVariableKind::Integer)\n+                | TyKind::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n+                _ => TyKind::Unknown.intern(&Interner),\n+            }\n+        }\n+        BinaryOp::ArithOp(_) => match rhs_ty.interned(&Interner) {\n+            TyKind::Scalar(Scalar::Int(_))\n+            | TyKind::Scalar(Scalar::Uint(_))\n+            | TyKind::Scalar(Scalar::Float(_)) => rhs_ty,\n+            TyKind::InferenceVar(_, TyVariableKind::Integer)\n+            | TyKind::InferenceVar(_, TyVariableKind::Float) => rhs_ty,\n+            _ => TyKind::Unknown.intern(&Interner),\n         },\n     }\n }\n \n pub(super) fn binary_op_rhs_expectation(op: BinaryOp, lhs_ty: Ty) -> Ty {\n     match op {\n-        BinaryOp::LogicOp(..) => Ty::Scalar(Scalar::Bool),\n+        BinaryOp::LogicOp(..) => TyKind::Scalar(Scalar::Bool).intern(&Interner),\n         BinaryOp::Assignment { op: None } => lhs_ty,\n-        BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty {\n-            Ty::Scalar(_) | Ty::Str => lhs_ty,\n-            Ty::InferenceVar(_, TyVariableKind::Integer)\n-            | Ty::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n-            _ => Ty::Unknown,\n+        BinaryOp::CmpOp(CmpOp::Eq { .. }) => match lhs_ty.interned(&Interner) {\n+            TyKind::Scalar(_) | TyKind::Str => lhs_ty,\n+            TyKind::InferenceVar(_, TyVariableKind::Integer)\n+            | TyKind::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n+            _ => TyKind::Unknown.intern(&Interner),\n         },\n-        BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => Ty::Unknown,\n+        BinaryOp::ArithOp(ArithOp::Shl) | BinaryOp::ArithOp(ArithOp::Shr) => {\n+            TyKind::Unknown.intern(&Interner)\n+        }\n         BinaryOp::CmpOp(CmpOp::Ord { .. })\n         | BinaryOp::Assignment { op: Some(_) }\n-        | BinaryOp::ArithOp(_) => match lhs_ty {\n-            Ty::Scalar(Scalar::Int(_))\n-            | Ty::Scalar(Scalar::Uint(_))\n-            | Ty::Scalar(Scalar::Float(_)) => lhs_ty,\n-            Ty::InferenceVar(_, TyVariableKind::Integer)\n-            | Ty::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n-            _ => Ty::Unknown,\n+        | BinaryOp::ArithOp(_) => match lhs_ty.interned(&Interner) {\n+            TyKind::Scalar(Scalar::Int(_))\n+            | TyKind::Scalar(Scalar::Uint(_))\n+            | TyKind::Scalar(Scalar::Float(_)) => lhs_ty,\n+            TyKind::InferenceVar(_, TyVariableKind::Integer)\n+            | TyKind::InferenceVar(_, TyVariableKind::Float) => lhs_ty,\n+            _ => TyKind::Unknown.intern(&Interner),\n         },\n     }\n }"}, {"sha": "500d1781c93eb755ba2bcbd2759659fe03dc61a6", "filename": "crates/hir_ty/src/traits.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -10,7 +10,9 @@ use stdx::panic_context;\n \n use crate::{db::HirDatabase, DebruijnIndex, Substs};\n \n-use super::{Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TypeWalk};\n+use super::{\n+    Canonical, GenericPredicate, HirDisplay, ProjectionTy, TraitRef, Ty, TyKind, TypeWalk,\n+};\n \n use self::chalk::{from_chalk, Interner, ToChalk};\n \n@@ -132,7 +134,7 @@ pub(crate) fn trait_solve_query(\n     log::info!(\"trait_solve_query({})\", goal.value.value.display(db));\n \n     if let Obligation::Projection(pred) = &goal.value.value {\n-        if let Ty::BoundVar(_) = &pred.projection_ty.parameters[0] {\n+        if let TyKind::BoundVar(_) = &pred.projection_ty.parameters[0].interned(&Interner) {\n             // Hack: don't ask Chalk to normalize with an unknown self type, it'll say that's impossible\n             return Some(Solution::Ambig(Guidance::Unknown));\n         }"}, {"sha": "55181cc494f305dec9d91934d551c970e8f47031", "filename": "crates/hir_ty/src/traits/chalk.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -20,13 +20,14 @@ use crate::{\n     method_resolution::{TyFingerprint, ALL_FLOAT_FPS, ALL_INT_FPS},\n     utils::generics,\n     BoundVar, CallableDefId, CallableSig, DebruijnIndex, GenericPredicate, ProjectionPredicate,\n-    ProjectionTy, Substs, TraitRef, Ty,\n+    ProjectionTy, Substs, TraitRef, Ty, TyKind,\n };\n use mapping::{\n     convert_where_clauses, generic_predicate_to_inline_bound, make_binders, TypeAliasAsAssocType,\n     TypeAliasAsValue,\n };\n \n+pub use self::interner::Interner;\n pub(crate) use self::interner::*;\n \n pub(super) mod tls;\n@@ -90,7 +91,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n             ty: &Ty,\n             binders: &CanonicalVarKinds<Interner>,\n         ) -> Option<chalk_ir::TyVariableKind> {\n-            if let Ty::BoundVar(bv) = ty {\n+            if let TyKind::BoundVar(bv) = ty.interned(&Interner) {\n                 let binders = binders.as_slice(&Interner);\n                 if bv.debruijn == DebruijnIndex::INNERMOST {\n                     if let chalk_ir::VariableKind::Ty(tk) = binders[bv.index].kind {\n@@ -220,21 +221,25 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n                     let impl_bound = GenericPredicate::Implemented(TraitRef {\n                         trait_: future_trait,\n                         // Self type as the first parameter.\n-                        substs: Substs::single(Ty::BoundVar(BoundVar {\n-                            debruijn: DebruijnIndex::INNERMOST,\n-                            index: 0,\n-                        })),\n+                        substs: Substs::single(\n+                            TyKind::BoundVar(BoundVar {\n+                                debruijn: DebruijnIndex::INNERMOST,\n+                                index: 0,\n+                            })\n+                            .intern(&Interner),\n+                        ),\n                     });\n                     let proj_bound = GenericPredicate::Projection(ProjectionPredicate {\n                         // The parameter of the opaque type.\n-                        ty: Ty::BoundVar(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 }),\n+                        ty: TyKind::BoundVar(BoundVar { debruijn: DebruijnIndex::ONE, index: 0 })\n+                            .intern(&Interner),\n                         projection_ty: ProjectionTy {\n                             associated_ty: future_output,\n                             // Self type as the first parameter.\n-                            parameters: Substs::single(Ty::BoundVar(BoundVar::new(\n-                                DebruijnIndex::INNERMOST,\n-                                0,\n-                            ))),\n+                            parameters: Substs::single(\n+                                TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n+                                    .intern(&Interner),\n+                            ),\n                         },\n                     });\n                     let bound = OpaqueTyDatumBound {\n@@ -263,7 +268,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n     fn hidden_opaque_type(&self, _id: chalk_ir::OpaqueTyId<Interner>) -> chalk_ir::Ty<Interner> {\n         // FIXME: actually provide the hidden type; it is relevant for auto traits\n-        Ty::Unknown.to_chalk(self.db)\n+        TyKind::Unknown.intern(&Interner).to_chalk(self.db)\n     }\n \n     fn is_object_safe(&self, _trait_id: chalk_ir::TraitId<Interner>) -> bool {\n@@ -391,7 +396,8 @@ pub(crate) fn associated_ty_data_query(\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::TypeParamLoweringMode::Variable);\n-    let self_ty = Ty::BoundVar(crate::BoundVar::new(crate::DebruijnIndex::INNERMOST, 0));\n+    let self_ty =\n+        TyKind::BoundVar(BoundVar::new(crate::DebruijnIndex::INNERMOST, 0)).intern(&Interner);\n     let bounds = type_alias_data\n         .bounds\n         .iter()"}, {"sha": "44cfb93596a6a307c847a966401d2fd4ff464d23", "filename": "crates/hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 46, "deletions": 45, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -26,10 +26,10 @@ use super::*;\n impl ToChalk for Ty {\n     type Chalk = chalk_ir::Ty<Interner>;\n     fn to_chalk(self, db: &dyn HirDatabase) -> chalk_ir::Ty<Interner> {\n-        match self {\n-            Ty::Ref(m, parameters) => ref_to_chalk(db, m, parameters),\n-            Ty::Array(parameters) => array_to_chalk(db, parameters),\n-            Ty::Function(FnPointer { sig: FnSig { variadic }, substs, .. }) => {\n+        match self.0 {\n+            TyKind::Ref(m, parameters) => ref_to_chalk(db, m, parameters),\n+            TyKind::Array(parameters) => array_to_chalk(db, parameters),\n+            TyKind::Function(FnPointer { sig: FnSig { variadic }, substs, .. }) => {\n                 let substitution = chalk_ir::FnSubst(substs.to_chalk(db).shifted_in(&Interner));\n                 chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                     num_binders: 0,\n@@ -38,57 +38,57 @@ impl ToChalk for Ty {\n                 })\n                 .intern(&Interner)\n             }\n-            Ty::AssociatedType(type_alias, substs) => {\n+            TyKind::AssociatedType(type_alias, substs) => {\n                 let assoc_type = TypeAliasAsAssocType(type_alias);\n                 let assoc_type_id = assoc_type.to_chalk(db);\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::AssociatedType(assoc_type_id, substitution).intern(&Interner)\n             }\n \n-            Ty::OpaqueType(impl_trait_id, substs) => {\n+            TyKind::OpaqueType(impl_trait_id, substs) => {\n                 let id = impl_trait_id.to_chalk(db);\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::OpaqueType(id, substitution).intern(&Interner)\n             }\n \n-            Ty::ForeignType(type_alias) => {\n+            TyKind::ForeignType(type_alias) => {\n                 let foreign_type = TypeAliasAsForeignType(type_alias);\n                 let foreign_type_id = foreign_type.to_chalk(db);\n                 chalk_ir::TyKind::Foreign(foreign_type_id).intern(&Interner)\n             }\n \n-            Ty::Scalar(scalar) => chalk_ir::TyKind::Scalar(scalar).intern(&Interner),\n+            TyKind::Scalar(scalar) => chalk_ir::TyKind::Scalar(scalar).intern(&Interner),\n \n-            Ty::Tuple(cardinality, substs) => {\n+            TyKind::Tuple(cardinality, substs) => {\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::Tuple(cardinality.into(), substitution).intern(&Interner)\n             }\n-            Ty::Raw(mutability, substs) => {\n+            TyKind::Raw(mutability, substs) => {\n                 let ty = substs[0].clone().to_chalk(db);\n                 chalk_ir::TyKind::Raw(mutability, ty).intern(&Interner)\n             }\n-            Ty::Slice(substs) => {\n+            TyKind::Slice(substs) => {\n                 chalk_ir::TyKind::Slice(substs[0].clone().to_chalk(db)).intern(&Interner)\n             }\n-            Ty::Str => chalk_ir::TyKind::Str.intern(&Interner),\n-            Ty::FnDef(callable_def, substs) => {\n+            TyKind::Str => chalk_ir::TyKind::Str.intern(&Interner),\n+            TyKind::FnDef(callable_def, substs) => {\n                 let id = callable_def.to_chalk(db);\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::FnDef(id, substitution).intern(&Interner)\n             }\n-            Ty::Never => chalk_ir::TyKind::Never.intern(&Interner),\n+            TyKind::Never => chalk_ir::TyKind::Never.intern(&Interner),\n \n-            Ty::Closure(def, expr, substs) => {\n+            TyKind::Closure(def, expr, substs) => {\n                 let closure_id = db.intern_closure((def, expr));\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::Closure(closure_id.into(), substitution).intern(&Interner)\n             }\n \n-            Ty::Adt(adt_id, substs) => {\n+            TyKind::Adt(adt_id, substs) => {\n                 let substitution = substs.to_chalk(db);\n                 chalk_ir::TyKind::Adt(adt_id, substitution).intern(&Interner)\n             }\n-            Ty::Alias(AliasTy::Projection(proj_ty)) => {\n+            TyKind::Alias(AliasTy::Projection(proj_ty)) => {\n                 let associated_ty_id = TypeAliasAsAssocType(proj_ty.associated_ty).to_chalk(db);\n                 let substitution = proj_ty.parameters.to_chalk(db);\n                 chalk_ir::AliasTy::Projection(chalk_ir::ProjectionTy {\n@@ -98,17 +98,17 @@ impl ToChalk for Ty {\n                 .cast(&Interner)\n                 .intern(&Interner)\n             }\n-            Ty::Placeholder(id) => {\n+            TyKind::Placeholder(id) => {\n                 let interned_id = db.intern_type_param_id(id);\n                 PlaceholderIndex {\n                     ui: UniverseIndex::ROOT,\n                     idx: interned_id.as_intern_id().as_usize(),\n                 }\n                 .to_ty::<Interner>(&Interner)\n             }\n-            Ty::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n-            Ty::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n-            Ty::Dyn(predicates) => {\n+            TyKind::BoundVar(idx) => chalk_ir::TyKind::BoundVar(idx).intern(&Interner),\n+            TyKind::InferenceVar(..) => panic!(\"uncanonicalized infer ty\"),\n+            TyKind::Dyn(predicates) => {\n                 let where_clauses = chalk_ir::QuantifiedWhereClauses::from_iter(\n                     &Interner,\n                     predicates.iter().filter(|p| !p.is_error()).cloned().map(|p| p.to_chalk(db)),\n@@ -119,7 +119,7 @@ impl ToChalk for Ty {\n                 };\n                 chalk_ir::TyKind::Dyn(bounded_ty).intern(&Interner)\n             }\n-            Ty::Alias(AliasTy::Opaque(opaque_ty)) => {\n+            TyKind::Alias(AliasTy::Opaque(opaque_ty)) => {\n                 let opaque_ty_id = opaque_ty.opaque_ty_id.to_chalk(db);\n                 let substitution = opaque_ty.parameters.to_chalk(db);\n                 chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(chalk_ir::OpaqueTy {\n@@ -128,30 +128,30 @@ impl ToChalk for Ty {\n                 }))\n                 .intern(&Interner)\n             }\n-            Ty::Unknown => chalk_ir::TyKind::Error.intern(&Interner),\n+            TyKind::Unknown => chalk_ir::TyKind::Error.intern(&Interner),\n         }\n     }\n     fn from_chalk(db: &dyn HirDatabase, chalk: chalk_ir::Ty<Interner>) -> Self {\n         match chalk.data(&Interner).kind.clone() {\n-            chalk_ir::TyKind::Error => Ty::Unknown,\n-            chalk_ir::TyKind::Array(ty, _size) => Ty::Array(Substs::single(from_chalk(db, ty))),\n+            chalk_ir::TyKind::Error => TyKind::Unknown,\n+            chalk_ir::TyKind::Array(ty, _size) => TyKind::Array(Substs::single(from_chalk(db, ty))),\n             chalk_ir::TyKind::Placeholder(idx) => {\n                 assert_eq!(idx.ui, UniverseIndex::ROOT);\n                 let interned_id = crate::db::GlobalTypeParamId::from_intern_id(\n                     crate::salsa::InternId::from(idx.idx),\n                 );\n-                Ty::Placeholder(db.lookup_intern_type_param_id(interned_id))\n+                TyKind::Placeholder(db.lookup_intern_type_param_id(interned_id))\n             }\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Projection(proj)) => {\n                 let associated_ty =\n                     from_chalk::<TypeAliasAsAssocType, _>(db, proj.associated_ty_id).0;\n                 let parameters = from_chalk(db, proj.substitution);\n-                Ty::Alias(AliasTy::Projection(ProjectionTy { associated_ty, parameters }))\n+                TyKind::Alias(AliasTy::Projection(ProjectionTy { associated_ty, parameters }))\n             }\n             chalk_ir::TyKind::Alias(chalk_ir::AliasTy::Opaque(opaque_ty)) => {\n                 let impl_trait_id = from_chalk(db, opaque_ty.opaque_ty_id);\n                 let parameters = from_chalk(db, opaque_ty.substitution);\n-                Ty::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters }))\n+                TyKind::Alias(AliasTy::Opaque(OpaqueTy { opaque_ty_id: impl_trait_id, parameters }))\n             }\n             chalk_ir::TyKind::Function(chalk_ir::FnPointer {\n                 num_binders,\n@@ -164,14 +164,14 @@ impl ToChalk for Ty {\n                     db,\n                     substitution.0.shifted_out(&Interner).expect(\"fn ptr should have no binders\"),\n                 );\n-                Ty::Function(FnPointer {\n+                TyKind::Function(FnPointer {\n                     num_args: (substs.len() - 1),\n                     sig: FnSig { variadic },\n                     substs,\n                 })\n             }\n-            chalk_ir::TyKind::BoundVar(idx) => Ty::BoundVar(idx),\n-            chalk_ir::TyKind::InferenceVar(_iv, _kind) => Ty::Unknown,\n+            chalk_ir::TyKind::BoundVar(idx) => TyKind::BoundVar(idx),\n+            chalk_ir::TyKind::InferenceVar(_iv, _kind) => TyKind::Unknown,\n             chalk_ir::TyKind::Dyn(where_clauses) => {\n                 assert_eq!(where_clauses.bounds.binders.len(&Interner), 1);\n                 let predicates = where_clauses\n@@ -180,49 +180,50 @@ impl ToChalk for Ty {\n                     .iter(&Interner)\n                     .map(|c| from_chalk(db, c.clone()))\n                     .collect();\n-                Ty::Dyn(predicates)\n+                TyKind::Dyn(predicates)\n             }\n \n-            chalk_ir::TyKind::Adt(adt_id, subst) => Ty::Adt(adt_id, from_chalk(db, subst)),\n-            chalk_ir::TyKind::AssociatedType(type_id, subst) => Ty::AssociatedType(\n+            chalk_ir::TyKind::Adt(adt_id, subst) => TyKind::Adt(adt_id, from_chalk(db, subst)),\n+            chalk_ir::TyKind::AssociatedType(type_id, subst) => TyKind::AssociatedType(\n                 from_chalk::<TypeAliasAsAssocType, _>(db, type_id).0,\n                 from_chalk(db, subst),\n             ),\n \n             chalk_ir::TyKind::OpaqueType(opaque_type_id, subst) => {\n-                Ty::OpaqueType(from_chalk(db, opaque_type_id), from_chalk(db, subst))\n+                TyKind::OpaqueType(from_chalk(db, opaque_type_id), from_chalk(db, subst))\n             }\n \n-            chalk_ir::TyKind::Scalar(scalar) => Ty::Scalar(scalar),\n+            chalk_ir::TyKind::Scalar(scalar) => TyKind::Scalar(scalar),\n             chalk_ir::TyKind::Tuple(cardinality, subst) => {\n-                Ty::Tuple(cardinality, from_chalk(db, subst))\n+                TyKind::Tuple(cardinality, from_chalk(db, subst))\n             }\n             chalk_ir::TyKind::Raw(mutability, ty) => {\n-                Ty::Raw(mutability, Substs::single(from_chalk(db, ty)))\n+                TyKind::Raw(mutability, Substs::single(from_chalk(db, ty)))\n             }\n-            chalk_ir::TyKind::Slice(ty) => Ty::Slice(Substs::single(from_chalk(db, ty))),\n+            chalk_ir::TyKind::Slice(ty) => TyKind::Slice(Substs::single(from_chalk(db, ty))),\n             chalk_ir::TyKind::Ref(mutability, _lifetime, ty) => {\n-                Ty::Ref(mutability, Substs::single(from_chalk(db, ty)))\n+                TyKind::Ref(mutability, Substs::single(from_chalk(db, ty)))\n             }\n-            chalk_ir::TyKind::Str => Ty::Str,\n-            chalk_ir::TyKind::Never => Ty::Never,\n+            chalk_ir::TyKind::Str => TyKind::Str,\n+            chalk_ir::TyKind::Never => TyKind::Never,\n \n             chalk_ir::TyKind::FnDef(fn_def_id, subst) => {\n-                Ty::FnDef(from_chalk(db, fn_def_id), from_chalk(db, subst))\n+                TyKind::FnDef(from_chalk(db, fn_def_id), from_chalk(db, subst))\n             }\n \n             chalk_ir::TyKind::Closure(id, subst) => {\n                 let id: crate::db::ClosureId = id.into();\n                 let (def, expr) = db.lookup_intern_closure(id);\n-                Ty::Closure(def, expr, from_chalk(db, subst))\n+                TyKind::Closure(def, expr, from_chalk(db, subst))\n             }\n \n             chalk_ir::TyKind::Foreign(foreign_def_id) => {\n-                Ty::ForeignType(from_chalk::<TypeAliasAsForeignType, _>(db, foreign_def_id).0)\n+                TyKind::ForeignType(from_chalk::<TypeAliasAsForeignType, _>(db, foreign_def_id).0)\n             }\n             chalk_ir::TyKind::Generator(_, _) => unimplemented!(), // FIXME\n             chalk_ir::TyKind::GeneratorWitness(_, _) => unimplemented!(), // FIXME\n         }\n+        .intern(&Interner)\n     }\n }\n "}, {"sha": "c81c1d26eff4c1d0bb5de8508de987e0afca4aa9", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bcf2169e7d7c46276214cac627a70673b7676567/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=bcf2169e7d7c46276214cac627a70673b7676567", "patch": "@@ -12,7 +12,7 @@ use hir::{\n     AssocItem, Crate, HasSource, HirDisplay, ModuleDef,\n };\n use hir_def::FunctionId;\n-use hir_ty::{Ty, TypeWalk};\n+use hir_ty::TypeWalk;\n use ide_db::base_db::{\n     salsa::{self, ParallelDatabase},\n     SourceDatabaseExt,\n@@ -187,12 +187,12 @@ impl AnalysisStatsCmd {\n             for (expr_id, _) in body.exprs.iter() {\n                 let ty = &inference_result[expr_id];\n                 num_exprs += 1;\n-                if let Ty::Unknown = ty {\n+                if ty.is_unknown() {\n                     num_exprs_unknown += 1;\n                 } else {\n                     let mut is_partially_unknown = false;\n                     ty.walk(&mut |ty| {\n-                        if let Ty::Unknown = ty {\n+                        if ty.is_unknown() {\n                             is_partially_unknown = true;\n                         }\n                     });"}]}