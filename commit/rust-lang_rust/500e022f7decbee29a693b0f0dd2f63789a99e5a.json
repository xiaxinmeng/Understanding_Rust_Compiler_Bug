{"sha": "500e022f7decbee29a693b0f0dd2f63789a99e5a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUwMGUwMjJmN2RlY2JlZTI5YTY5M2IwZjBkZDJmNjM3ODlhOTllNWE=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-11-26T11:05:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-26T11:05:05Z"}, "message": "Merge #2398\n\n2398: WIP: introduce hir::Type r=matklad a=matklad\n\nThis introduces `hir::Type` wrapper over `hir::Ty`, with two purposes:\r\n\r\n* bind `Ty` and it's corresponding environment\r\n  * Am I correct that `Ty` without an env doesn't make much sense, because the meaning of type parameters is unclear\r\n  * Am I correct that we can safely re-use the same environment for all types derived from the given type? \r\n* hide representation defails of `Ty`. Specifically, I want to change `Ty::Adt` to use `hir_def::AdtId` instead of `hir::Adt`, but IDE doesn't know about underlying IDs. More generally, I feel like IDE shouldn't know that `Ty` is enum.\r\n\r\n@flodiebold what do you think about this?\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "2f7839288ce5676a89c6d6062cbaf70544e0beed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f7839288ce5676a89c6d6062cbaf70544e0beed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/500e022f7decbee29a693b0f0dd2f63789a99e5a", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd3QbhCRBK7hj4Ov3rIwAAdHIIAJtz54XI9Q0AS3YAYY5/FCZZ\nbdKLjwTksVa6DHChXpu+UBq3nogPvL/zhPWlySN2EJrrRuO+z71QcrKWMlNjICXZ\nCO8N4lA2T2mFJ9fPqctJ3QnnO9i92w4/LUPC1S1Cum9fVZE0F8Xikvjat6j/Vg0d\nVubbUrDcthbo3bzpmbTS/dey2oPxL+XJnbm34InFm+7filYVu7FTIT561vsmxjmp\n0C1zc1pzIuCrBBCHKMUAJ3UJI6EfhZmAkGeKrvMNMTkxUdxNWlyv3y/ogihY+mZB\nSuXct4+37S8fqupANJVNmh3edPXQ0HZYSUlHXqeJ71woRRBNvWG9oCsrX9evSHM=\n=iNFm\n-----END PGP SIGNATURE-----\n", "payload": "tree 2f7839288ce5676a89c6d6062cbaf70544e0beed\nparent 5901cc736074bbc4d780a8e45079d405ab2cec4b\nparent e5eadb339039e21718d382c0b3d02a4bf053b3f4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1574766305 +0000\ncommitter GitHub <noreply@github.com> 1574766305 +0000\n\nMerge #2398\n\n2398: WIP: introduce hir::Type r=matklad a=matklad\n\nThis introduces `hir::Type` wrapper over `hir::Ty`, with two purposes:\r\n\r\n* bind `Ty` and it's corresponding environment\r\n  * Am I correct that `Ty` without an env doesn't make much sense, because the meaning of type parameters is unclear\r\n  * Am I correct that we can safely re-use the same environment for all types derived from the given type? \r\n* hide representation defails of `Ty`. Specifically, I want to change `Ty::Adt` to use `hir_def::AdtId` instead of `hir::Adt`, but IDE doesn't know about underlying IDs. More generally, I feel like IDE shouldn't know that `Ty` is enum.\r\n\r\n@flodiebold what do you think about this?\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/500e022f7decbee29a693b0f0dd2f63789a99e5a", "html_url": "https://github.com/rust-lang/rust/commit/500e022f7decbee29a693b0f0dd2f63789a99e5a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/500e022f7decbee29a693b0f0dd2f63789a99e5a/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5901cc736074bbc4d780a8e45079d405ab2cec4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5901cc736074bbc4d780a8e45079d405ab2cec4b", "html_url": "https://github.com/rust-lang/rust/commit/5901cc736074bbc4d780a8e45079d405ab2cec4b"}, {"sha": "e5eadb339039e21718d382c0b3d02a4bf053b3f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/e5eadb339039e21718d382c0b3d02a4bf053b3f4", "html_url": "https://github.com/rust-lang/rust/commit/e5eadb339039e21718d382c0b3d02a4bf053b3f4"}], "stats": {"total": 389, "additions": 253, "deletions": 136}, "files": [{"sha": "eeb4ff39f4c27842ffafa43d53ee5fe618b2b069", "filename": "crates/ra_assists/src/assists/add_explicit_type.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Fadd_explicit_type.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -1,4 +1,4 @@\n-use hir::{db::HirDatabase, HirDisplay, Ty};\n+use hir::{db::HirDatabase, HirDisplay};\n use ra_syntax::{\n     ast::{self, AstNode, LetStmt, NameOwner},\n     T,\n@@ -43,7 +43,7 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n     let analyzer = ctx.source_analyzer(stmt.syntax(), None);\n     let ty = analyzer.type_of(db, &expr)?;\n     // Assist not applicable if the type is unknown\n-    if is_unknown(&ty) {\n+    if ty.contains_unknown() {\n         return None;\n     }\n \n@@ -53,15 +53,6 @@ pub(crate) fn add_explicit_type(ctx: AssistCtx<impl HirDatabase>) -> Option<Assi\n     })\n }\n \n-/// Returns true if any type parameter is unknown\n-fn is_unknown(ty: &Ty) -> bool {\n-    match ty {\n-        Ty::Unknown => true,\n-        Ty::Apply(a_ty) => a_ty.parameters.iter().any(is_unknown),\n-        _ => false,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use super::*;"}, {"sha": "b75bd44ebeb00076c6ee9b263876a2348796a2ad", "filename": "crates/ra_assists/src/assists/fill_match_arms.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fassists%2Ffill_match_arms.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -83,10 +83,11 @@ fn resolve_enum_def(\n ) -> Option<ast::EnumDef> {\n     let expr_ty = analyzer.type_of(db, &expr)?;\n \n-    analyzer.autoderef(db, expr_ty).find_map(|ty| match ty.as_adt() {\n-        Some((Adt::Enum(e), _)) => Some(e.source(db).value),\n+    let res = expr_ty.autoderef(db).find_map(|ty| match ty.as_adt() {\n+        Some(Adt::Enum(e)) => Some(e.source(db).value),\n         _ => None,\n-    })\n+    });\n+    res\n }\n \n fn build_pat(var: ast::EnumVariant) -> Option<ast::Pat> {"}, {"sha": "a7bba85e14f065a34454c9983bedbfa2c5963127", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 159, "deletions": 7, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -10,9 +10,9 @@ use hir_def::{\n     docs::Documentation,\n     per_ns::PerNs,\n     resolver::{HasResolver, TypeNs},\n-    type_ref::TypeRef,\n-    AstItemDef, ConstId, ContainerId, EnumId, FunctionId, GenericDefId, HasModule, ImplId,\n-    LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId, Lookup, ModuleId,\n+    type_ref::{Mutability, TypeRef},\n+    AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId, HasModule,\n+    ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId, Lookup, ModuleId,\n     StaticId, StructId, TraitId, TypeAliasId, UnionId,\n };\n use hir_expand::{\n@@ -26,8 +26,12 @@ use ra_syntax::{ast, AstNode, SyntaxNode};\n use crate::{\n     db::{DefDatabase, HirDatabase},\n     expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n-    ty::{InferenceResult, Namespace, TraitRef},\n-    Either, Name, Source, Ty,\n+    ty::display::HirFormatter,\n+    ty::{\n+        self, InEnvironment, InferenceResult, Namespace, TraitEnvironment, TraitRef, Ty, TypeCtor,\n+        TypeWalk,\n+    },\n+    CallableDef, Either, HirDisplay, Name, Source,\n };\n \n /// hir::Crate describes a single crate. It's the main interface with which\n@@ -469,6 +473,10 @@ pub enum Adt {\n impl_froms!(Adt: Struct, Union, Enum);\n \n impl Adt {\n+    pub fn has_non_default_type_params(self, db: &impl HirDatabase) -> bool {\n+        let subst = db.generic_defaults(self.into());\n+        subst.iter().any(|ty| ty == &Ty::Unknown)\n+    }\n     pub fn ty(self, db: &impl HirDatabase) -> Ty {\n         match self {\n             Adt::Struct(it) => it.ty(db),\n@@ -777,6 +785,11 @@ pub struct TypeAlias {\n }\n \n impl TypeAlias {\n+    pub fn has_non_default_type_params(self, db: &impl HirDatabase) -> bool {\n+        let subst = db.generic_defaults(self.id.into());\n+        subst.iter().any(|ty| ty == &Ty::Unknown)\n+    }\n+\n     pub fn module(self, db: &impl DefDatabase) -> Module {\n         Module { id: self.id.lookup(db).module(db) }\n     }\n@@ -927,9 +940,14 @@ impl Local {\n         self.parent.module(db)\n     }\n \n-    pub fn ty(self, db: &impl HirDatabase) -> Ty {\n+    pub fn ty(self, db: &impl HirDatabase) -> Type {\n         let infer = db.infer(self.parent);\n-        infer[self.pat_id].clone()\n+        let ty = infer[self.pat_id].clone();\n+        let def = DefWithBodyId::from(self.parent);\n+        let resolver = def.resolver(db);\n+        let krate = def.module(db).krate;\n+        let environment = TraitEnvironment::lower(db, &resolver);\n+        Type { krate, ty: InEnvironment { value: ty, environment } }\n     }\n \n     pub fn source(self, db: &impl HirDatabase) -> Source<Either<ast::BindPat, ast::SelfParam>> {\n@@ -986,6 +1004,140 @@ impl ImplBlock {\n     }\n }\n \n+#[derive(Clone, PartialEq, Eq)]\n+pub struct Type {\n+    pub(crate) krate: CrateId,\n+    pub(crate) ty: InEnvironment<Ty>,\n+}\n+\n+impl Type {\n+    pub fn is_bool(&self) -> bool {\n+        match &self.ty.value {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Bool => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_mutable_reference(&self) -> bool {\n+        match &self.ty.value {\n+            Ty::Apply(a_ty) => match a_ty.ctor {\n+                TypeCtor::Ref(Mutability::Mut) => true,\n+                _ => false,\n+            },\n+            _ => false,\n+        }\n+    }\n+\n+    pub fn is_unknown(&self) -> bool {\n+        match &self.ty.value {\n+            Ty::Unknown => true,\n+            _ => false,\n+        }\n+    }\n+\n+    // FIXME: this method is broken, as it doesn't take closures into account.\n+    pub fn as_callable(&self) -> Option<CallableDef> {\n+        Some(self.ty.value.as_callable()?.0)\n+    }\n+\n+    pub fn contains_unknown(&self) -> bool {\n+        return go(&self.ty.value);\n+\n+        fn go(ty: &Ty) -> bool {\n+            match ty {\n+                Ty::Unknown => true,\n+                Ty::Apply(a_ty) => a_ty.parameters.iter().any(go),\n+                _ => false,\n+            }\n+        }\n+    }\n+\n+    pub fn fields(&self, db: &impl HirDatabase) -> Vec<(StructField, Type)> {\n+        let mut res = Vec::new();\n+        if let Ty::Apply(a_ty) = &self.ty.value {\n+            match a_ty.ctor {\n+                ty::TypeCtor::Adt(Adt::Struct(s)) => {\n+                    for field in s.fields(db) {\n+                        let ty = field.ty(db).subst(&a_ty.parameters);\n+                        res.push((field, self.derived(ty)));\n+                    }\n+                }\n+                _ => {}\n+            }\n+        };\n+        res\n+    }\n+\n+    pub fn tuple_fields(&self, _db: &impl HirDatabase) -> Vec<Type> {\n+        let mut res = Vec::new();\n+        if let Ty::Apply(a_ty) = &self.ty.value {\n+            match a_ty.ctor {\n+                ty::TypeCtor::Tuple { .. } => {\n+                    for ty in a_ty.parameters.iter() {\n+                        let ty = ty.clone().subst(&a_ty.parameters);\n+                        res.push(self.derived(ty));\n+                    }\n+                }\n+                _ => {}\n+            }\n+        };\n+        res\n+    }\n+\n+    pub fn variant_fields(\n+        &self,\n+        db: &impl HirDatabase,\n+        def: VariantDef,\n+    ) -> Vec<(StructField, Type)> {\n+        // FIXME: check that ty and def match\n+        match &self.ty.value {\n+            Ty::Apply(a_ty) => def\n+                .fields(db)\n+                .into_iter()\n+                .map(|it| (it, self.derived(it.ty(db).subst(&a_ty.parameters))))\n+                .collect(),\n+            _ => Vec::new(),\n+        }\n+    }\n+\n+    pub fn autoderef<'a>(&'a self, db: &'a impl HirDatabase) -> impl Iterator<Item = Type> + 'a {\n+        // There should be no inference vars in types passed here\n+        // FIXME check that?\n+        let canonical = crate::ty::Canonical { value: self.ty.value.clone(), num_vars: 0 };\n+        let environment = self.ty.environment.clone();\n+        let ty = InEnvironment { value: canonical, environment: environment.clone() };\n+        ty::autoderef(db, Some(self.krate), ty)\n+            .map(|canonical| canonical.value)\n+            .map(move |ty| self.derived(ty))\n+    }\n+\n+    // FIXME: remove\n+    pub fn into_ty(self) -> Ty {\n+        self.ty.value\n+    }\n+\n+    pub fn as_adt(&self) -> Option<Adt> {\n+        let (adt, _subst) = self.ty.value.as_adt()?;\n+        Some(adt)\n+    }\n+\n+    fn derived(&self, ty: Ty) -> Type {\n+        Type {\n+            krate: self.krate,\n+            ty: InEnvironment { value: ty, environment: self.ty.environment.clone() },\n+        }\n+    }\n+}\n+\n+impl HirDisplay for Type {\n+    fn hir_fmt(&self, f: &mut HirFormatter<impl HirDatabase>) -> std::fmt::Result {\n+        self.ty.value.hir_fmt(f)\n+    }\n+}\n+\n /// For IDE only\n pub enum ScopeDef {\n     ModuleDef(ModuleDef),"}, {"sha": "b88e4c745a230e29fd769bf079c8666a53f4c5b3", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -51,7 +51,7 @@ pub use crate::{\n         src::HasSource, Adt, AssocItem, AttrDef, Const, Container, Crate, CrateDependency,\n         DefWithBody, Docs, Enum, EnumVariant, FieldSource, Function, GenericDef, GenericParam,\n         HasAttrs, ImplBlock, Import, Local, MacroDef, Module, ModuleDef, ModuleSource, ScopeDef,\n-        Static, Struct, StructField, Trait, TypeAlias, Union, VariantDef,\n+        Static, Struct, StructField, Trait, Type, TypeAlias, Union, VariantDef,\n     },\n     expr::ExprScopes,\n     from_source::FromSource,"}, {"sha": "95a94c3f021f46d16b3cffb3edf59f38e364c175", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 25, "deletions": 21, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -28,10 +28,10 @@ use crate::{\n     expr::{BodySourceMap, ExprScopes, ScopeId},\n     ty::{\n         method_resolution::{self, implements_trait},\n-        TraitEnvironment,\n+        InEnvironment, TraitEnvironment, Ty,\n     },\n     Adt, AssocItem, Const, DefWithBody, Either, Enum, EnumVariant, FromSource, Function,\n-    GenericParam, Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Ty, TypeAlias,\n+    GenericParam, Local, MacroDef, Name, Path, ScopeDef, Static, Struct, Trait, Type, TypeAlias,\n };\n \n fn try_get_resolver_for_node(db: &impl HirDatabase, node: Source<&SyntaxNode>) -> Option<Resolver> {\n@@ -198,14 +198,18 @@ impl SourceAnalyzer {\n         self.body_source_map.as_ref()?.node_pat(src)\n     }\n \n-    pub fn type_of(&self, _db: &impl HirDatabase, expr: &ast::Expr) -> Option<crate::Ty> {\n+    pub fn type_of(&self, db: &impl HirDatabase, expr: &ast::Expr) -> Option<Type> {\n         let expr_id = self.expr_id(expr)?;\n-        Some(self.infer.as_ref()?[expr_id].clone())\n+        let ty = self.infer.as_ref()?[expr_id].clone();\n+        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n \n-    pub fn type_of_pat(&self, _db: &impl HirDatabase, pat: &ast::Pat) -> Option<crate::Ty> {\n+    pub fn type_of_pat(&self, db: &impl HirDatabase, pat: &ast::Pat) -> Option<Type> {\n         let pat_id = self.pat_id(pat)?;\n-        Some(self.infer.as_ref()?[pat_id].clone())\n+        let ty = self.infer.as_ref()?[pat_id].clone();\n+        let environment = TraitEnvironment::lower(db, &self.resolver);\n+        Some(Type { krate: self.resolver.krate()?, ty: InEnvironment { value: ty, environment } })\n     }\n \n     pub fn resolve_method_call(&self, call: &ast::MethodCallExpr) -> Option<Function> {\n@@ -361,14 +365,14 @@ impl SourceAnalyzer {\n     pub fn iterate_method_candidates<T>(\n         &self,\n         db: &impl HirDatabase,\n-        ty: Ty,\n+        ty: &Type,\n         name: Option<&Name>,\n         mut callback: impl FnMut(&Ty, Function) -> Option<T>,\n     ) -> Option<T> {\n         // There should be no inference vars in types passed here\n         // FIXME check that?\n         // FIXME replace Unknown by bound vars here\n-        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        let canonical = crate::ty::Canonical { value: ty.ty.value.clone(), num_vars: 0 };\n         method_resolution::iterate_method_candidates(\n             &canonical,\n             db,\n@@ -403,19 +407,19 @@ impl SourceAnalyzer {\n         )\n     }\n \n-    pub fn autoderef<'a>(\n-        &'a self,\n-        db: &'a impl HirDatabase,\n-        ty: Ty,\n-    ) -> impl Iterator<Item = Ty> + 'a {\n-        // There should be no inference vars in types passed here\n-        // FIXME check that?\n-        let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n-        let krate = self.resolver.krate();\n-        let environment = TraitEnvironment::lower(db, &self.resolver);\n-        let ty = crate::ty::InEnvironment { value: canonical, environment };\n-        crate::ty::autoderef(db, krate, ty).map(|canonical| canonical.value)\n-    }\n+    // pub fn autoderef<'a>(\n+    //     &'a self,\n+    //     db: &'a impl HirDatabase,\n+    //     ty: Ty,\n+    // ) -> impl Iterator<Item = Ty> + 'a {\n+    //     // There should be no inference vars in types passed here\n+    //     // FIXME check that?\n+    //     let canonical = crate::ty::Canonical { value: ty, num_vars: 0 };\n+    //     let krate = self.resolver.krate();\n+    //     let environment = TraitEnvironment::lower(db, &self.resolver);\n+    //     let ty = crate::ty::InEnvironment { value: canonical, environment };\n+    //     crate::ty::autoderef(db, krate, ty).map(|canonical| canonical.value)\n+    // }\n \n     /// Checks that particular type `ty` implements `std::future::Future`.\n     /// This function is used in `.await` syntax completion."}, {"sha": "274dd1467ef1625cfb280d7ce9d07f3e35fba94d", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -489,6 +489,16 @@ impl HasModule for AdtId {\n     }\n }\n \n+impl HasModule for DefWithBodyId {\n+    fn module(&self, db: &impl db::DefDatabase) -> ModuleId {\n+        match self {\n+            DefWithBodyId::FunctionId(it) => it.lookup(db).module(db),\n+            DefWithBodyId::StaticId(it) => it.lookup(db).module(db),\n+            DefWithBodyId::ConstId(it) => it.lookup(db).module(db),\n+        }\n+    }\n+}\n+\n impl HasModule for StaticLoc {\n     fn module(&self, _db: &impl db::DefDatabase) -> ModuleId {\n         self.container"}, {"sha": "d0283e4103373ff067150fc53ae92a077468f7fc", "filename": "crates/ra_ide_api/src/call_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcall_info.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -26,8 +26,8 @@ pub(crate) fn call_info(db: &RootDatabase, position: FilePosition) -> Option<Cal\n     );\n     let (mut call_info, has_self) = match &calling_node {\n         FnCallNode::CallExpr(expr) => {\n-            //FIXME: don't poke into Ty\n-            let (callable_def, _subst) = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n+            //FIXME: Type::as_callable is broken\n+            let callable_def = analyzer.type_of(db, &expr.expr()?)?.as_callable()?;\n             match callable_def {\n                 hir::CallableDef::FunctionId(it) => {\n                     let fn_def = it.into();"}, {"sha": "b6fe486270169cfcd7c68540158cfb535df44760", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 13, "deletions": 23, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -1,6 +1,6 @@\n //! FIXME: write short doc here\n \n-use hir::{Adt, Ty, TypeCtor};\n+use hir::Type;\n \n use crate::completion::completion_item::CompletionKind;\n use crate::{\n@@ -22,41 +22,31 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n     };\n \n     if !ctx.is_call {\n-        complete_fields(acc, ctx, receiver_ty.clone());\n+        complete_fields(acc, ctx, &receiver_ty);\n     }\n-    complete_methods(acc, ctx, receiver_ty.clone());\n+    complete_methods(acc, ctx, &receiver_ty);\n \n     // Suggest .await syntax for types that implement Future trait\n-    if ctx.analyzer.impls_future(ctx.db, receiver_ty) {\n+    if ctx.analyzer.impls_future(ctx.db, receiver_ty.into_ty()) {\n         CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\")\n             .detail(\"expr.await\")\n             .insert_text(\"await\")\n             .add_to(acc);\n     }\n }\n \n-fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n-    for receiver in ctx.analyzer.autoderef(ctx.db, receiver) {\n-        if let Ty::Apply(a_ty) = receiver {\n-            match a_ty.ctor {\n-                TypeCtor::Adt(Adt::Struct(s)) => {\n-                    for field in s.fields(ctx.db) {\n-                        acc.add_field(ctx, field, &a_ty.parameters);\n-                    }\n-                }\n-                // FIXME unions\n-                TypeCtor::Tuple { .. } => {\n-                    for (i, ty) in a_ty.parameters.iter().enumerate() {\n-                        acc.add_tuple_field(ctx, i, ty);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        };\n+fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n+    for receiver in receiver.autoderef(ctx.db) {\n+        for (field, ty) in receiver.fields(ctx.db) {\n+            acc.add_field(ctx, field, &ty);\n+        }\n+        for (i, ty) in receiver.tuple_fields(ctx.db).into_iter().enumerate() {\n+            acc.add_tuple_field(ctx, i, &ty);\n+        }\n     }\n }\n \n-fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n+fn complete_methods(acc: &mut Completions, ctx: &CompletionContext, receiver: &Type) {\n     let mut seen_methods = FxHashSet::default();\n     ctx.analyzer.iterate_method_candidates(ctx.db, receiver, None, |_ty, func| {\n         if func.has_self_param(ctx.db) && seen_methods.insert(func.name(ctx.db)) {"}, {"sha": "646a30c76efa0004dfe06221c7c32d748db25c4d", "filename": "crates/ra_ide_api/src/completion/complete_postfix.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -1,6 +1,5 @@\n //! FIXME: write short doc here\n \n-use hir::{Ty, TypeCtor};\n use ra_syntax::{ast::AstNode, TextRange, TextUnit};\n use ra_text_edit::TextEdit;\n \n@@ -30,9 +29,12 @@ pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n         dot_receiver.syntax().text().to_string()\n     };\n \n-    let receiver_ty = ctx.analyzer.type_of(ctx.db, &dot_receiver);\n+    let receiver_ty = match ctx.analyzer.type_of(ctx.db, &dot_receiver) {\n+        Some(it) => it,\n+        None => return,\n+    };\n \n-    if is_bool_or_unknown(receiver_ty) {\n+    if receiver_ty.is_bool() || receiver_ty.is_unknown() {\n         postfix_snippet(ctx, \"if\", \"if expr {}\", &format!(\"if {} {{$0}}\", receiver_text))\n             .add_to(acc);\n         postfix_snippet(\n@@ -75,14 +77,6 @@ fn postfix_snippet(ctx: &CompletionContext, label: &str, detail: &str, snippet:\n         .snippet_edit(edit)\n }\n \n-fn is_bool_or_unknown(ty: Option<Ty>) -> bool {\n-    match &ty {\n-        Some(Ty::Apply(app)) if app.ctor == TypeCtor::Bool => true,\n-        Some(Ty::Unknown) | None => true,\n-        Some(_) => false,\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;"}, {"sha": "577c394d22e645de841b00904e2ca58864a8e2ea", "filename": "crates/ra_ide_api/src/completion/complete_record_literal.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_literal.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -1,7 +1,5 @@\n //! FIXME: write short doc here\n \n-use hir::Substs;\n-\n use crate::completion::{CompletionContext, Completions};\n \n /// Complete fields in fields literals.\n@@ -15,10 +13,9 @@ pub(super) fn complete_record_literal(acc: &mut Completions, ctx: &CompletionCon\n         Some(it) => it,\n         _ => return,\n     };\n-    let substs = &ty.substs().unwrap_or_else(Substs::empty);\n \n-    for field in variant.fields(ctx.db) {\n-        acc.add_field(ctx, field, substs);\n+    for (field, field_ty) in ty.variant_fields(ctx.db, variant) {\n+        acc.add_field(ctx, field, &field_ty);\n     }\n }\n "}, {"sha": "a56c7e3a1fca7b2c7bc08822bf78d16aafb6c955", "filename": "crates/ra_ide_api/src/completion/complete_record_pattern.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_record_pattern.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -1,7 +1,5 @@\n //! FIXME: write short doc here\n \n-use hir::Substs;\n-\n use crate::completion::{CompletionContext, Completions};\n \n pub(super) fn complete_record_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n@@ -14,10 +12,9 @@ pub(super) fn complete_record_pattern(acc: &mut Completions, ctx: &CompletionCon\n         Some(it) => it,\n         _ => return,\n     };\n-    let substs = &ty.substs().unwrap_or_else(Substs::empty);\n \n-    for field in variant.fields(ctx.db) {\n-        acc.add_field(ctx, field, substs);\n+    for (field, field_ty) in ty.variant_fields(ctx.db, variant) {\n+        acc.add_field(ctx, field, &field_ty);\n     }\n }\n "}, {"sha": "5f056730ac74345a1be57384cd0466022e629613", "filename": "crates/ra_ide_api/src/completion/presentation.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -1,12 +1,12 @@\n //! This modules takes care of rendering various definitions as completion items.\n \n-use hir::{db::HirDatabase, Docs, HasAttrs, HasSource, HirDisplay, ScopeDef, Ty, TypeWalk};\n+use hir::{db::HirDatabase, Docs, HasAttrs, HasSource, HirDisplay, ScopeDef, Type};\n use join_to_string::join;\n use ra_syntax::ast::NameOwner;\n use test_utils::tested_by;\n \n use crate::completion::{\n-    db, CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n+    CompletionContext, CompletionItem, CompletionItemKind, CompletionKind, Completions,\n };\n \n use crate::display::{const_label, function_label, macro_label, type_label};\n@@ -16,7 +16,7 @@ impl Completions {\n         &mut self,\n         ctx: &CompletionContext,\n         field: hir::StructField,\n-        substs: &hir::Substs,\n+        ty: &Type,\n     ) {\n         let is_deprecated = is_deprecated(field, ctx.db);\n         CompletionItem::new(\n@@ -25,13 +25,13 @@ impl Completions {\n             field.name(ctx.db).to_string(),\n         )\n         .kind(CompletionItemKind::Field)\n-        .detail(field.ty(ctx.db).subst(substs).display(ctx.db).to_string())\n+        .detail(ty.display(ctx.db).to_string())\n         .set_documentation(field.docs(ctx.db))\n         .set_deprecated(is_deprecated)\n         .add_to(self);\n     }\n \n-    pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &hir::Ty) {\n+    pub(crate) fn add_tuple_field(&mut self, ctx: &CompletionContext, field: usize, ty: &Type) {\n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), field.to_string())\n             .kind(CompletionItemKind::Field)\n             .detail(ty.display(ctx.db).to_string())\n@@ -98,7 +98,7 @@ impl Completions {\n             CompletionItem::new(completion_kind, ctx.source_range(), local_name.clone());\n         if let ScopeDef::Local(local) = resolution {\n             let ty = local.ty(ctx.db);\n-            if ty != Ty::Unknown {\n+            if !ty.is_unknown() {\n                 completion_item = completion_item.detail(ty.display(ctx.db).to_string());\n             }\n         };\n@@ -108,19 +108,17 @@ impl Completions {\n             && !ctx.has_type_args\n             && ctx.db.feature_flags.get(\"completion.insertion.add-call-parenthesis\")\n         {\n-            let generic_def: Option<hir::GenericDef> = match resolution {\n-                ScopeDef::ModuleDef(Adt(it)) => Some((*it).into()),\n-                ScopeDef::ModuleDef(TypeAlias(it)) => Some((*it).into()),\n-                _ => None,\n+            let has_non_default_type_params = match resolution {\n+                ScopeDef::ModuleDef(Adt(it)) => it.has_non_default_type_params(ctx.db),\n+                ScopeDef::ModuleDef(TypeAlias(it)) => it.has_non_default_type_params(ctx.db),\n+                _ => false,\n             };\n-            if let Some(def) = generic_def {\n-                if has_non_default_type_params(def, ctx.db) {\n-                    tested_by!(inserts_angle_brackets_for_generics);\n-                    completion_item = completion_item\n-                        .lookup_by(local_name.clone())\n-                        .label(format!(\"{}<\u2026>\", local_name))\n-                        .insert_snippet(format!(\"{}<$0>\", local_name));\n-                }\n+            if has_non_default_type_params {\n+                tested_by!(inserts_angle_brackets_for_generics);\n+                completion_item = completion_item\n+                    .lookup_by(local_name.clone())\n+                    .label(format!(\"{}<\u2026>\", local_name))\n+                    .insert_snippet(format!(\"{}<$0>\", local_name));\n             }\n         }\n \n@@ -291,11 +289,6 @@ fn is_deprecated(node: impl HasAttrs, db: &impl HirDatabase) -> bool {\n     node.attrs(db).by_key(\"deprecated\").exists()\n }\n \n-fn has_non_default_type_params(def: hir::GenericDef, db: &db::RootDatabase) -> bool {\n-    let subst = db.generic_defaults(def.into());\n-    subst.iter().any(|ty| ty == &Ty::Unknown)\n-}\n-\n #[cfg(test)]\n mod tests {\n     use insta::assert_debug_snapshot;"}, {"sha": "992a088090126c07364348ba6b76a28f8c7e2dc9", "filename": "crates/ra_ide_api/src/goto_type_definition.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_type_definition.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -24,7 +24,7 @@ pub(crate) fn goto_type_definition(\n \n     let analyzer = hir::SourceAnalyzer::new(db, token.with_value(&node), None);\n \n-    let ty: hir::Ty = if let Some(ty) =\n+    let ty: hir::Type = if let Some(ty) =\n         ast::Expr::cast(node.clone()).and_then(|e| analyzer.type_of(db, &e))\n     {\n         ty\n@@ -35,7 +35,7 @@ pub(crate) fn goto_type_definition(\n         return None;\n     };\n \n-    let adt_def = analyzer.autoderef(db, ty).find_map(|ty| ty.as_adt().map(|adt| adt.0))?;\n+    let adt_def = ty.autoderef(db).find_map(|ty| ty.as_adt())?;\n \n     let nav = adt_def.to_nav(db);\n     Some(RangeInfo::new(node.text_range(), vec![nav]))"}, {"sha": "45149bf0cc10537cdab6ebe7177b8c938fb1f219", "filename": "crates/ra_ide_api/src/inlay_hints.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Finlay_hints.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -1,7 +1,7 @@\n //! FIXME: write short doc here\n \n use crate::{db::RootDatabase, FileId};\n-use hir::{HirDisplay, SourceAnalyzer, Ty};\n+use hir::{HirDisplay, SourceAnalyzer};\n use ra_syntax::{\n     ast::{self, AstNode, TypeAscriptionOwner},\n     match_ast, SmolStr, SourceFile, SyntaxKind, SyntaxNode, TextRange,\n@@ -100,8 +100,11 @@ fn get_pat_type_hints(\n         .into_iter()\n         .filter(|pat| !skip_root_pat_hint || pat != original_pat)\n         .filter_map(|pat| {\n-            get_node_displayable_type(db, &analyzer, &pat)\n-                .map(|pat_type| (pat.syntax().text_range(), pat_type))\n+            let ty = analyzer.type_of_pat(db, &pat)?;\n+            if ty.is_unknown() {\n+                return None;\n+            }\n+            Some((pat.syntax().text_range(), ty))\n         })\n         .map(|(range, pat_type)| InlayHint {\n             range,\n@@ -158,20 +161,6 @@ fn get_leaf_pats(root_pat: ast::Pat) -> Vec<ast::Pat> {\n     leaf_pats\n }\n \n-fn get_node_displayable_type(\n-    db: &RootDatabase,\n-    analyzer: &SourceAnalyzer,\n-    node_pat: &ast::Pat,\n-) -> Option<Ty> {\n-    analyzer.type_of_pat(db, node_pat).and_then(|resolved_type| {\n-        if let Ty::Apply(_) = resolved_type {\n-            Some(resolved_type)\n-        } else {\n-            None\n-        }\n-    })\n-}\n-\n #[cfg(test)]\n mod tests {\n     use crate::mock_analysis::single_file;"}, {"sha": "10165a9bbc9a71c8cc1647991767155caa7c8002", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/500e022f7decbee29a693b0f0dd2f63789a99e5a/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=500e022f7decbee29a693b0f0dd2f63789a99e5a", "patch": "@@ -2,7 +2,7 @@\n \n use rustc_hash::{FxHashMap, FxHashSet};\n \n-use hir::{Mutability, Name, Source};\n+use hir::{Name, Source};\n use ra_db::SourceDatabase;\n use ra_prof::profile;\n use ra_syntax::{ast, AstNode, Direction, SyntaxElement, SyntaxKind, SyntaxKind::*, TextRange, T};\n@@ -230,11 +230,10 @@ fn highlight_name(db: &RootDatabase, name_kind: NameKind) -> &'static str {\n         Local(local) => {\n             if local.is_mut(db) {\n                 \"variable.mut\"\n+            } else if local.ty(db).is_mutable_reference() {\n+                \"variable.mut\"\n             } else {\n-                match local.ty(db).as_reference() {\n-                    Some((_, Mutability::Mut)) => \"variable.mut\",\n-                    _ => \"variable\",\n-                }\n+                \"variable\"\n             }\n         }\n     }"}]}