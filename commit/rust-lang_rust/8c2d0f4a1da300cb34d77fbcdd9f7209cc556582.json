{"sha": "8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjMmQwZjRhMWRhMzAwY2IzNGQ3N2ZiY2RkOWY3MjA5Y2M1NTY1ODI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-05T14:58:57Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-01-05T14:58:57Z"}, "message": "Auto merge of #57145 - RalfJung:panic-if-uninhabited, r=alexcrichton\n\npanic when calling MaybeUninhabited::into_inner on uninhabited type\n\nI do this by adding an internal-only intrinsic `panic_if_uninhabited`. I have no idea what I am doing here, just mindlessly copying code around, so please review carefully!", "tree": {"sha": "0401cf1c7bb2474333a26b2d22c5b28fe52d3dae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0401cf1c7bb2474333a26b2d22c5b28fe52d3dae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "html_url": "https://github.com/rust-lang/rust/commit/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68614265d312fc2cbe8a696f7dabb9416eb6f221", "url": "https://api.github.com/repos/rust-lang/rust/commits/68614265d312fc2cbe8a696f7dabb9416eb6f221", "html_url": "https://github.com/rust-lang/rust/commit/68614265d312fc2cbe8a696f7dabb9416eb6f221"}, {"sha": "c118b17953a8e29b850b8ed8fe0d3aaf2917a9da", "url": "https://api.github.com/repos/rust-lang/rust/commits/c118b17953a8e29b850b8ed8fe0d3aaf2917a9da", "html_url": "https://github.com/rust-lang/rust/commit/c118b17953a8e29b850b8ed8fe0d3aaf2917a9da"}], "stats": {"total": 149, "additions": 96, "deletions": 53}, "files": [{"sha": "4f5310f5285c9956207887de18ae22a5126053bf", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "patch": "@@ -690,6 +690,11 @@ extern \"rust-intrinsic\" {\n     /// crate it is invoked in.\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n+    /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n+    /// This will statically either panic, or do nothing.\n+    #[cfg(not(stage0))]\n+    pub fn panic_if_uninhabited<T>();\n+\n     /// Creates a value initialized to zero.\n     ///\n     /// `init` is unsafe because it returns a zeroed-out datum,"}, {"sha": "8fcbb73d9ce462eaa0090ccf9d11ff9a6dba59cd", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "patch": "@@ -492,6 +492,8 @@ pub const fn needs_drop<T>() -> bool {\n #[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::zeroed` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn zeroed<T>() -> T {\n+    #[cfg(not(stage0))]\n+    intrinsics::panic_if_uninhabited::<T>();\n     intrinsics::init()\n }\n \n@@ -624,6 +626,8 @@ pub unsafe fn zeroed<T>() -> T {\n #[rustc_deprecated(since = \"2.0.0\", reason = \"use `mem::MaybeUninit::uninitialized` instead\")]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn uninitialized<T>() -> T {\n+    #[cfg(not(stage0))]\n+    intrinsics::panic_if_uninhabited::<T>();\n     intrinsics::uninit()\n }\n \n@@ -1128,6 +1132,8 @@ impl<T> MaybeUninit<T> {\n     #[unstable(feature = \"maybe_uninit\", issue = \"53491\")]\n     #[inline(always)]\n     pub unsafe fn into_inner(self) -> T {\n+        #[cfg(not(stage0))]\n+        intrinsics::panic_if_uninhabited::<T>();\n         ManuallyDrop::into_inner(self.value)\n     }\n "}, {"sha": "aa82c853257a3f0d45c2e8e490f030e80a879be1", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 50, "deletions": 46, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "patch": "@@ -500,53 +500,57 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     _ => bx.new_fn_type(sig, &extra_args)\n                 };\n \n-                // emit a panic instead of instantiating an uninhabited type\n-                if (intrinsic == Some(\"init\") || intrinsic == Some(\"uninit\")) &&\n-                    fn_ty.ret.layout.abi.is_uninhabited()\n-                {\n-                    let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n-                    let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n-                    let filename = bx.const_str_slice(filename);\n-                    let line = bx.const_u32(loc.line as u32);\n-                    let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n-                    let align = tcx.data_layout.aggregate_align.abi\n-                        .max(tcx.data_layout.i32_align.abi)\n-                        .max(tcx.data_layout.pointer_align.abi);\n-\n-                    let str = format!(\n-                        \"Attempted to instantiate uninhabited type {} using mem::{}\",\n-                        sig.output(),\n-                        if intrinsic == Some(\"init\") { \"zeroed\" } else { \"uninitialized\" }\n-                    );\n-                    let msg_str = Symbol::intern(&str).as_str();\n-                    let msg_str = bx.const_str_slice(msg_str);\n-                    let msg_file_line_col = bx.const_struct(\n-                        &[msg_str, filename, line, col],\n-                        false,\n-                    );\n-                    let msg_file_line_col = bx.static_addr_of(\n-                        msg_file_line_col,\n-                        align,\n-                        Some(\"panic_loc\"),\n-                    );\n+                // emit a panic or a NOP for `panic_if_uninhabited`\n+                if intrinsic == Some(\"panic_if_uninhabited\") {\n+                    let ty = instance.unwrap().substs.type_at(0);\n+                    let layout = bx.layout_of(ty);\n+                    if layout.abi.is_uninhabited() {\n+                        let loc = bx.sess().source_map().lookup_char_pos(span.lo());\n+                        let filename = Symbol::intern(&loc.file.name.to_string()).as_str();\n+                        let filename = bx.const_str_slice(filename);\n+                        let line = bx.const_u32(loc.line as u32);\n+                        let col = bx.const_u32(loc.col.to_usize() as u32 + 1);\n+                        let align = tcx.data_layout.aggregate_align.abi\n+                            .max(tcx.data_layout.i32_align.abi)\n+                            .max(tcx.data_layout.pointer_align.abi);\n+\n+                        let str = format!(\n+                            \"Attempted to instantiate uninhabited type {}\",\n+                            ty\n+                        );\n+                        let msg_str = Symbol::intern(&str).as_str();\n+                        let msg_str = bx.const_str_slice(msg_str);\n+                        let msg_file_line_col = bx.const_struct(\n+                            &[msg_str, filename, line, col],\n+                            false,\n+                        );\n+                        let msg_file_line_col = bx.static_addr_of(\n+                            msg_file_line_col,\n+                            align,\n+                            Some(\"panic_loc\"),\n+                        );\n \n-                    // Obtain the panic entry point.\n-                    let def_id =\n-                        common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n-                    let instance = ty::Instance::mono(bx.tcx(), def_id);\n-                    let fn_ty = bx.fn_type_of_instance(&instance);\n-                    let llfn = bx.get_fn(instance);\n-\n-                    // Codegen the actual panic invoke/call.\n-                    do_call(\n-                        self,\n-                        &mut bx,\n-                        fn_ty,\n-                        llfn,\n-                        &[msg_file_line_col],\n-                        destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n-                        cleanup,\n-                    );\n+                        // Obtain the panic entry point.\n+                        let def_id =\n+                            common::langcall(bx.tcx(), Some(span), \"\", lang_items::PanicFnLangItem);\n+                        let instance = ty::Instance::mono(bx.tcx(), def_id);\n+                        let fn_ty = bx.fn_type_of_instance(&instance);\n+                        let llfn = bx.get_fn(instance);\n+\n+                        // Codegen the actual panic invoke/call.\n+                        do_call(\n+                            self,\n+                            &mut bx,\n+                            fn_ty,\n+                            llfn,\n+                            &[msg_file_line_col],\n+                            destination.as_ref().map(|(_, bb)| (ReturnDest::Nothing, *bb)),\n+                            cleanup,\n+                        );\n+                    } else {\n+                        // a NOP\n+                        funclet_br(self, &mut bx, destination.as_ref().unwrap().1);\n+                    }\n                     return;\n                 }\n "}, {"sha": "821c30b4fa7090b9596fb376d29b7c664dd9fa66", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "patch": "@@ -133,6 +133,7 @@ pub fn check_intrinsic_type<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                  ], tcx.types.usize)\n             }\n             \"rustc_peek\" => (1, vec![param(0)], param(0)),\n+            \"panic_if_uninhabited\" => (1, Vec::new(), tcx.mk_unit()),\n             \"init\" => (1, Vec::new(), param(0)),\n             \"uninit\" => (1, Vec::new(), param(0)),\n             \"forget\" => (1, vec![param(0)], tcx.mk_unit()),"}, {"sha": "d47ff6c630d1194abebf6ef7ddd6f78bec9992ea", "filename": "src/test/run-pass/panic-uninitialized-zeroed.rs", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8c2d0f4a1da300cb34d77fbcdd9f7209cc556582/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fpanic-uninitialized-zeroed.rs?ref=8c2d0f4a1da300cb34d77fbcdd9f7209cc556582", "patch": "@@ -2,7 +2,7 @@\n // This test checks that instantiating an uninhabited type via `mem::{uninitialized,zeroed}` results\n // in a runtime panic.\n \n-#![feature(never_type)]\n+#![feature(never_type, maybe_uninit)]\n \n use std::{mem, panic};\n \n@@ -20,7 +20,7 @@ fn main() {\n             panic::catch_unwind(|| {\n                 mem::uninitialized::<!>()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type ! using mem::uninitialized\"\n+                s == \"Attempted to instantiate uninhabited type !\"\n             })),\n             Some(true)\n         );\n@@ -29,7 +29,16 @@ fn main() {\n             panic::catch_unwind(|| {\n                 mem::zeroed::<!>()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type ! using mem::zeroed\"\n+                s == \"Attempted to instantiate uninhabited type !\"\n+            })),\n+            Some(true)\n+        );\n+\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::MaybeUninit::<!>::uninitialized().into_inner()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type !\"\n             })),\n             Some(true)\n         );\n@@ -38,7 +47,7 @@ fn main() {\n             panic::catch_unwind(|| {\n                 mem::uninitialized::<Foo>()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type Foo using mem::uninitialized\"\n+                s == \"Attempted to instantiate uninhabited type Foo\"\n             })),\n             Some(true)\n         );\n@@ -47,7 +56,16 @@ fn main() {\n             panic::catch_unwind(|| {\n                 mem::zeroed::<Foo>()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type Foo using mem::zeroed\"\n+                s == \"Attempted to instantiate uninhabited type Foo\"\n+            })),\n+            Some(true)\n+        );\n+\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::MaybeUninit::<Foo>::uninitialized().into_inner()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type Foo\"\n             })),\n             Some(true)\n         );\n@@ -56,7 +74,7 @@ fn main() {\n             panic::catch_unwind(|| {\n                 mem::uninitialized::<Bar>()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type Bar using mem::uninitialized\"\n+                s == \"Attempted to instantiate uninhabited type Bar\"\n             })),\n             Some(true)\n         );\n@@ -65,7 +83,16 @@ fn main() {\n             panic::catch_unwind(|| {\n                 mem::zeroed::<Bar>()\n             }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n-                s == \"Attempted to instantiate uninhabited type Bar using mem::zeroed\"\n+                s == \"Attempted to instantiate uninhabited type Bar\"\n+            })),\n+            Some(true)\n+        );\n+\n+        assert_eq!(\n+            panic::catch_unwind(|| {\n+                mem::MaybeUninit::<Bar>::uninitialized().into_inner()\n+            }).err().and_then(|a| a.downcast_ref::<String>().map(|s| {\n+                s == \"Attempted to instantiate uninhabited type Bar\"\n             })),\n             Some(true)\n         );"}]}