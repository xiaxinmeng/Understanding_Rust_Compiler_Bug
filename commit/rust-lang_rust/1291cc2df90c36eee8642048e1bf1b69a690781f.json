{"sha": "1291cc2df90c36eee8642048e1bf1b69a690781f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyOTFjYzJkZjkwYzM2ZWVlODY0MjA0OGUxYmYxYjY5YTY5MDc4MWY=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-01T00:36:08Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-03-01T00:36:14Z"}, "message": "Groundwork for structural comparison. Still lacking the actual loop that does it.", "tree": {"sha": "bfa8087261a509a81cce8edaebcee4afd170a01f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bfa8087261a509a81cce8edaebcee4afd170a01f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1291cc2df90c36eee8642048e1bf1b69a690781f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1291cc2df90c36eee8642048e1bf1b69a690781f", "html_url": "https://github.com/rust-lang/rust/commit/1291cc2df90c36eee8642048e1bf1b69a690781f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1291cc2df90c36eee8642048e1bf1b69a690781f/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86309ed3ea896473641c9cdeadf16b02931b8ac8", "url": "https://api.github.com/repos/rust-lang/rust/commits/86309ed3ea896473641c9cdeadf16b02931b8ac8", "html_url": "https://github.com/rust-lang/rust/commit/86309ed3ea896473641c9cdeadf16b02931b8ac8"}], "stats": {"total": 144, "additions": 118, "deletions": 26}, "files": [{"sha": "f75bdbe1ce8bef333069d6cd2a24ff4154de3610", "filename": "src/comp/lib/llvm.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1291cc2df90c36eee8642048e1bf1b69a690781f/src%2Fcomp%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1291cc2df90c36eee8642048e1bf1b69a690781f/src%2Fcomp%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Flib%2Fllvm.rs?ref=1291cc2df90c36eee8642048e1bf1b69a690781f", "patch": "@@ -76,6 +76,25 @@ const uint LLVMIntSLT = 40u;\n const uint LLVMIntSLE = 41u;\n \n \n+// Consts for the LLVM RealPredicate type, pre-case to uint.\n+// FIXME: as above.\n+\n+const uint LLVMRealOEQ = 1u;\n+const uint LLVMRealOGT = 2u;\n+const uint LLVMRealOGE = 3u;\n+const uint LLVMRealOLT = 4u;\n+const uint LLVMRealOLE = 5u;\n+const uint LLVMRealONE = 6u;\n+\n+const uint LLVMRealORD = 7u;\n+const uint LLVMRealUNO = 8u;\n+const uint LLVMRealUEQ = 9u;\n+const uint LLVMRealUGT = 10u;\n+const uint LLVMRealUGE = 11u;\n+const uint LLVMRealULT = 12u;\n+const uint LLVMRealULE = 13u;\n+const uint LLVMRealUNE = 14u;\n+\n native mod llvm = llvm_lib {\n \n     type ModuleRef;\n@@ -657,7 +676,7 @@ native mod llvm = llvm_lib {\n     fn LLVMBuildICmp(BuilderRef B, uint Op,\n                      ValueRef LHS, ValueRef RHS,\n                      sbuf Name) -> ValueRef;\n-    fn LLVMBuildFCmp(BuilderRef B, RealPredicate Op,\n+    fn LLVMBuildFCmp(BuilderRef B, uint Op,\n                      ValueRef LHS, ValueRef RHS,\n                      sbuf Name) -> ValueRef;\n \n@@ -1034,7 +1053,7 @@ obj builder(BuilderRef B) {\n         ret llvm.LLVMBuildICmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n \n-    fn FCmp(RealPredicate Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n+    fn FCmp(uint Op, ValueRef LHS, ValueRef RHS) -> ValueRef {\n         ret llvm.LLVMBuildFCmp(B, Op, LHS, RHS, _str.buf(\"\"));\n     }\n "}, {"sha": "4a45beea1b0c10324207dc2d153124a51d6bce3e", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 97, "deletions": 24, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/1291cc2df90c36eee8642048e1bf1b69a690781f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1291cc2df90c36eee8642048e1bf1b69a690781f/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=1291cc2df90c36eee8642048e1bf1b69a690781f", "patch": "@@ -1958,10 +1958,66 @@ fn trans_unary(@block_ctxt cx, ast.unop op,\n     fail;\n }\n \n-// FIXME: implement proper structural comparison.\n+fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n+                 ValueRef lhs, ValueRef rhs) -> result {\n+\n+    if (ty.type_is_scalar(t)) {\n+        ret res(cx, trans_scalar_compare(cx, op, t, lhs, rhs));\n+\n+    } else if (ty.type_is_structural(t)) {\n+        auto scx = new_sub_block_ctxt(cx, \"structural compare body\");\n+        auto next = new_sub_block_ctxt(cx, \"structural compare completion\");\n+        cx.build.Br(scx.llbb);\n+\n+        // Start with the assumptioin that our predicate holds.\n+        auto flag = scx.build.Alloca(T_i1());\n+        scx.build.Store(C_integral(1, T_i1()), flag);\n+\n+        // Attempt to prove otherwise by inverting the sense of the comparison\n+        // on each inner element and bailing if any succeed.\n+\n+        // FIXME: finish this.\n+\n+        auto v = scx.build.Load(flag);\n+        scx.build.Br(next.llbb);\n+        ret res(next, v);\n+\n+    } else {\n+        // FIXME: compare vec, str, box?\n+        cx.fcx.ccx.sess.unimpl(\"type in trans_compare\");\n+        ret res(cx, C_bool(false));\n+    }\n+}\n+\n+fn trans_scalar_compare(@block_ctxt cx, ast.binop op, @ty.t t,\n+                        ValueRef lhs, ValueRef rhs) -> ValueRef {\n+    if (ty.type_is_fp(t)) {\n+        ret trans_fp_compare(cx, op, t, lhs, rhs);\n+    } else {\n+        ret trans_integral_compare(cx, op, t, lhs, rhs);\n+    }\n+}\n+\n+fn trans_fp_compare(@block_ctxt cx, ast.binop op, @ty.t fptype,\n+                    ValueRef lhs, ValueRef rhs) -> ValueRef {\n \n-fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t intype,\n-                 ValueRef lhs, ValueRef rhs) -> ValueRef {\n+    auto cmp = lib.llvm.LLVMIntEQ;\n+    alt (op) {\n+        // FIXME: possibly use the unordered-or-< predicates here,\n+        // for now we're only going with ordered-and-< style (no NaNs).\n+        case (ast.eq) { cmp = lib.llvm.LLVMRealOEQ; }\n+        case (ast.ne) { cmp = lib.llvm.LLVMRealONE; }\n+        case (ast.lt) { cmp = lib.llvm.LLVMRealOLT; }\n+        case (ast.gt) { cmp = lib.llvm.LLVMRealOGT; }\n+        case (ast.le) { cmp = lib.llvm.LLVMRealOLE; }\n+        case (ast.ge) { cmp = lib.llvm.LLVMRealOGE; }\n+    }\n+\n+    ret cx.build.FCmp(cmp, lhs, rhs);\n+}\n+\n+fn trans_integral_compare(@block_ctxt cx, ast.binop op, @ty.t intype,\n+                          ValueRef lhs, ValueRef rhs) -> ValueRef {\n     auto cmp = lib.llvm.LLVMIntEQ;\n     alt (op) {\n         case (ast.eq) { cmp = lib.llvm.LLVMIntEQ; }\n@@ -2000,34 +2056,34 @@ fn trans_compare(@block_ctxt cx, ast.binop op, @ty.t intype,\n }\n \n fn trans_eager_binop(@block_ctxt cx, ast.binop op, @ty.t intype,\n-                     ValueRef lhs, ValueRef rhs) -> ValueRef {\n+                     ValueRef lhs, ValueRef rhs) -> result {\n \n     alt (op) {\n-        case (ast.add) { ret cx.build.Add(lhs, rhs); }\n-        case (ast.sub) { ret cx.build.Sub(lhs, rhs); }\n+        case (ast.add) { ret res(cx, cx.build.Add(lhs, rhs)); }\n+        case (ast.sub) { ret res(cx, cx.build.Sub(lhs, rhs)); }\n \n-        case (ast.mul) { ret cx.build.Mul(lhs, rhs); }\n+        case (ast.mul) { ret res(cx, cx.build.Mul(lhs, rhs)); }\n         case (ast.div) {\n             if (ty.type_is_signed(intype)) {\n-                ret cx.build.SDiv(lhs, rhs);\n+                ret res(cx, cx.build.SDiv(lhs, rhs));\n             } else {\n-                ret cx.build.UDiv(lhs, rhs);\n+                ret res(cx, cx.build.UDiv(lhs, rhs));\n             }\n         }\n         case (ast.rem) {\n             if (ty.type_is_signed(intype)) {\n-                ret cx.build.SRem(lhs, rhs);\n+                ret res(cx, cx.build.SRem(lhs, rhs));\n             } else {\n-                ret cx.build.URem(lhs, rhs);\n+                ret res(cx, cx.build.URem(lhs, rhs));\n             }\n         }\n \n-        case (ast.bitor) { ret cx.build.Or(lhs, rhs); }\n-        case (ast.bitand) { ret cx.build.And(lhs, rhs); }\n-        case (ast.bitxor) { ret cx.build.Xor(lhs, rhs); }\n-        case (ast.lsl) { ret cx.build.Shl(lhs, rhs); }\n-        case (ast.lsr) { ret cx.build.LShr(lhs, rhs); }\n-        case (ast.asr) { ret cx.build.AShr(lhs, rhs); }\n+        case (ast.bitor) { ret res(cx, cx.build.Or(lhs, rhs)); }\n+        case (ast.bitand) { ret res(cx, cx.build.And(lhs, rhs)); }\n+        case (ast.bitxor) { ret res(cx, cx.build.Xor(lhs, rhs)); }\n+        case (ast.lsl) { ret res(cx, cx.build.Shl(lhs, rhs)); }\n+        case (ast.lsr) { ret res(cx, cx.build.LShr(lhs, rhs)); }\n+        case (ast.asr) { ret res(cx, cx.build.AShr(lhs, rhs)); }\n         case (_) {\n             ret trans_compare(cx, op, intype, lhs, rhs);\n         }\n@@ -2055,6 +2111,21 @@ fn autoderef(@block_ctxt cx, ValueRef v, @ty.t t) -> result {\n     }\n }\n \n+fn autoderefed_ty(@ty.t t) -> @ty.t {\n+    let @ty.t t1 = t;\n+\n+    while (true) {\n+        alt (t1.struct) {\n+            case (ty.ty_box(?inner)) {\n+                t1 = inner;\n+            }\n+            case (_) {\n+                ret t1;\n+            }\n+        }\n+    }\n+}\n+\n fn trans_binary(@block_ctxt cx, ast.binop op,\n                 @ast.expr a, @ast.expr b) -> result {\n \n@@ -2109,8 +2180,9 @@ fn trans_binary(@block_ctxt cx, ast.binop op,\n             auto rhs = trans_expr(lhs.bcx, b);\n             auto rhty = ty.expr_ty(b);\n             rhs = autoderef(rhs.bcx, rhs.val, rhty);\n-            ret res(rhs.bcx, trans_eager_binop(rhs.bcx, op, lhty,\n-                                               lhs.val, rhs.val));\n+            ret trans_eager_binop(rhs.bcx, op,\n+                                  autoderefed_ty(lhty),\n+                                  lhs.val, rhs.val);\n         }\n     }\n     fail;\n@@ -2399,8 +2471,8 @@ fn trans_pat_match(@block_ctxt cx, @ast.pat pat, ValueRef llval,\n             auto lltype = ty.ann_to_type(ann);\n             auto lleq = trans_compare(cx, ast.eq, lltype, llval, lllit);\n \n-            auto matched_cx = new_sub_block_ctxt(cx, \"matched_cx\");\n-            cx.build.CondBr(lleq, matched_cx.llbb, next_cx.llbb);\n+            auto matched_cx = new_sub_block_ctxt(lleq.bcx, \"matched_cx\");\n+            lleq.bcx.build.CondBr(lleq.val, matched_cx.llbb, next_cx.llbb);\n             ret res(matched_cx, llval);\n         }\n \n@@ -2656,8 +2728,9 @@ fn trans_path(@block_ctxt cx, &ast.path p, &option.t[ast.def] dopt,\n fn trans_field(@block_ctxt cx, &ast.span sp, @ast.expr base,\n                &ast.ident field, &ast.ann ann) -> lval_result {\n     auto r = trans_expr(cx, base);\n-    r = autoderef(r.bcx, r.val, ty.expr_ty(base));\n     auto t = ty.expr_ty(base);\n+    r = autoderef(r.bcx, r.val, t);\n+    t = autoderefed_ty(t);\n     alt (t.struct) {\n         case (ty.ty_tup(?fields)) {\n             let uint ix = ty.field_num(cx.fcx.ccx.sess, sp, field);\n@@ -3439,8 +3512,8 @@ fn trans_expr(@block_ctxt cx, @ast.expr e) -> result {\n             auto v = trans_eager_binop(rhs_res.bcx, op, t,\n                                        lhs_val, rhs_res.val);\n             // FIXME: calculate copy init-ness in typestate.\n-            ret copy_ty(rhs_res.bcx, DROP_EXISTING,\n-                        lhs_res.res.val, v, t);\n+            ret copy_ty(v.bcx, DROP_EXISTING,\n+                        lhs_res.res.val, v.val, t);\n         }\n \n         case (ast.expr_bind(?f, ?args, ?ann)) {"}]}