{"sha": "78977cd86cd17e008f94f8579d6a5aaebe46e69b", "node_id": "C_kwDOAAsO6NoAKDc4OTc3Y2Q4NmNkMTdlMDA4Zjk0Zjg1NzlkNmE1YWFlYmU0NmU2OWI", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-10-02T13:15:57Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2022-10-02T17:40:07Z"}, "message": "Adapt to the new generic parameter/argument order", "tree": {"sha": "8c61f3261cea31b3c8ba1afea9903070c58d72bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c61f3261cea31b3c8ba1afea9903070c58d72bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78977cd86cd17e008f94f8579d6a5aaebe46e69b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmM5zPcACgkQ4laYqTBY\nYXH8GA//UPwnb5KqV+tGyPoS2cu02Ct+Eq4lrpliZ/BCc2r/csKo2lPU0nBmV8tP\nLDdRqLbnv9zpxgUt9KX5ZNs/PPL4T1OcW2e22yePzStYNi3TRPEgEmIpjRmNNrBu\nLlcJxTjQTjPYLxTUHGlD+Bd3WXdZlBQ5AmOjdTFVAYcIjpx8exonyFjOMzhlvZVH\nkLBE2sDhQ9r4TsscznsCeEJX9s1tm5SzMzKcPmc6XeF9yQfN0GYNOAObe3C7dR4u\nhhWtwrWaCzI4VKNsjHZ3dsIk2w74pvRJLa7Q87pULypzqz07SoWb79HojVWzspTq\ntRruAOgPq2zvd9tToawN+GAnXz9UxxfMtthx41WR/78zN60liHD/LHmNYvsGj4sM\nusKtiuH9SkHH2aVz6WjLY/bOduwosu5Cq1o/W9Sf2OOrq97E/dhLXx8E9JSjZ8ky\nbS+cTvONrMEHUKaHJMe52xp3reE8lPCOkOGITWVULeBqAFmdIu2EOEoD16vuVZ4x\nJ7AdqCDtVHykDTd4AS5mvsmThCUTZcbYtz+pcw2wvPhquuUZppLrop9Kk8QqpzZT\nwRnKHGY6AXgkukRrSYt5bXvzI07OOvQ6C4POYNe9CDG3f/RmJkyPuNGczIqpzOnU\nRGhyXx1z/VhJDWklxUXw3LBG6eLNCtlF4LPBSc7E1XmAmZAMC74=\n=mYEp\n-----END PGP SIGNATURE-----", "payload": "tree 8c61f3261cea31b3c8ba1afea9903070c58d72bd\nparent 4385d3dcd0df7713b3a35f31f11034f0a570adbd\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1664716557 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1664732407 +0900\n\nAdapt to the new generic parameter/argument order\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78977cd86cd17e008f94f8579d6a5aaebe46e69b", "html_url": "https://github.com/rust-lang/rust/commit/78977cd86cd17e008f94f8579d6a5aaebe46e69b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78977cd86cd17e008f94f8579d6a5aaebe46e69b/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4385d3dcd0df7713b3a35f31f11034f0a570adbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4385d3dcd0df7713b3a35f31f11034f0a570adbd", "html_url": "https://github.com/rust-lang/rust/commit/4385d3dcd0df7713b3a35f31f11034f0a570adbd"}], "stats": {"total": 420, "additions": 259, "deletions": 161}, "files": [{"sha": "02332ea80d883f1ed9a036750a2305387ca464b5", "filename": "crates/hir-ty/src/autoderef.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fautoderef.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -123,13 +123,14 @@ fn deref_by_trait(table: &mut InferenceTable<'_>, ty: Ty) -> Option<Ty> {\n     let target = db.trait_data(deref_trait).associated_type_by_name(&name![Target])?;\n \n     let projection = {\n-        let b = TyBuilder::assoc_type_projection(db, target);\n+        let b = TyBuilder::subst_for_def(db, deref_trait, None);\n         if b.remaining() != 1 {\n             // the Target type + Deref trait should only have one generic parameter,\n             // namely Deref's Self type\n             return None;\n         }\n-        b.push(ty).build()\n+        let deref_subst = b.push(ty).build();\n+        TyBuilder::assoc_type_projection(db, target, Some(deref_subst)).build()\n     };\n \n     // Check that the type implements Deref at all"}, {"sha": "3f3f8f7d0f2a2ac9d82b02fdb0439dd978713f0c", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -382,13 +382,12 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n         // `resume_type`, `yield_type`, and `return_type` of the generator in question.\n         let subst = TyBuilder::subst_for_generator(self.db, parent).fill_with_unknown().build();\n \n-        let len = subst.len(Interner);\n         let input_output = rust_ir::GeneratorInputOutputDatum {\n-            resume_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 3))\n+            resume_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 0))\n                 .intern(Interner),\n-            yield_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 2))\n+            yield_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 1))\n                 .intern(Interner),\n-            return_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, len - 1))\n+            return_type: TyKind::BoundVar(BoundVar::new(DebruijnIndex::INNERMOST, 2))\n                 .intern(Interner),\n             // FIXME: calculate upvars\n             upvars: vec![],\n@@ -476,10 +475,15 @@ pub(crate) fn associated_ty_data_query(\n     let resolver = hir_def::resolver::HasResolver::resolver(type_alias, db.upcast());\n     let ctx = crate::TyLoweringContext::new(db, &resolver)\n         .with_type_param_mode(crate::lower::ParamLoweringMode::Variable);\n-    let pro_ty = TyBuilder::assoc_type_projection(db, type_alias)\n+\n+    let trait_subst = TyBuilder::subst_for_def(db, trait_, None)\n+        .fill_with_bound_vars(crate::DebruijnIndex::INNERMOST, generic_params.len_self())\n+        .build();\n+    let pro_ty = TyBuilder::assoc_type_projection(db, type_alias, Some(trait_subst))\n         .fill_with_bound_vars(crate::DebruijnIndex::INNERMOST, 0)\n         .build();\n     let self_ty = TyKind::Alias(AliasTy::Projection(pro_ty)).intern(Interner);\n+\n     let mut bounds: Vec<_> = type_alias_data\n         .bounds\n         .iter()"}, {"sha": "7f0baf49dadce9e510a0b133d811b2fde49ff19c", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -27,7 +27,7 @@ use crate::{\n     db::HirDatabase,\n     from_assoc_type_id, from_foreign_def_id, from_placeholder_idx, lt_from_placeholder_idx,\n     mapping::from_chalk,\n-    primitive, subst_prefix, to_assoc_type_id,\n+    primitive, to_assoc_type_id,\n     utils::{self, generics},\n     AdtId, AliasEq, AliasTy, Binders, CallableDefId, CallableSig, Const, ConstValue, DomainGoal,\n     GenericArg, ImplTraitId, Interner, Lifetime, LifetimeData, LifetimeOutlives, Mutability,\n@@ -506,8 +506,15 @@ impl HirDisplay for Ty {\n                     let total_len = parent_params + self_param + type_params + const_params;\n                     // We print all params except implicit impl Trait params. Still a bit weird; should we leave out parent and self?\n                     if total_len > 0 {\n+                        // `parameters` are in the order of fn's params (including impl traits),\n+                        // parent's params (those from enclosing impl or trait, if any).\n+                        let parameters = parameters.as_slice(Interner);\n+                        let fn_params_len = self_param + type_params + const_params;\n+                        let fn_params = parameters.get(..fn_params_len);\n+                        let parent_params = parameters.get(parameters.len() - parent_params..);\n+                        let params = parent_params.into_iter().chain(fn_params).flatten();\n                         write!(f, \"<\")?;\n-                        f.write_joined(&parameters.as_slice(Interner)[..total_len], \", \")?;\n+                        f.write_joined(params, \", \")?;\n                         write!(f, \">\")?;\n                     }\n                 }\n@@ -579,9 +586,8 @@ impl HirDisplay for Ty {\n                                         Some(x) => x,\n                                         None => return true,\n                                     };\n-                                    let actual_default = default_parameter\n-                                        .clone()\n-                                        .substitute(Interner, &subst_prefix(parameters, i));\n+                                    let actual_default =\n+                                        default_parameter.clone().substitute(Interner, &parameters);\n                                     parameter != &actual_default\n                                 }\n                                 let mut default_from = 0;"}, {"sha": "31e56dec62593770bb938e2ddaa7dc7f6b39731c", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -26,8 +26,8 @@ use hir_def::{\n     path::{path, Path},\n     resolver::{HasResolver, ResolveValueResult, Resolver, TypeNs, ValueNs},\n     type_ref::TypeRef,\n-    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule, Lookup,\n-    TraitId, TypeAliasId, VariantId,\n+    AdtId, AssocItemId, DefWithBodyId, EnumVariantId, FieldId, FunctionId, HasModule,\n+    ItemContainerId, Lookup, TraitId, TypeAliasId, VariantId,\n };\n use hir_expand::name::{name, Name};\n use itertools::Either;\n@@ -713,6 +713,8 @@ impl<'a> InferenceContext<'a> {\n         &mut self,\n         inner_ty: Ty,\n         assoc_ty: Option<TypeAliasId>,\n+        // FIXME(GATs): these are args for the trait ref, args for assoc type itself should be\n+        // handled when we support them.\n         params: &[GenericArg],\n     ) -> Ty {\n         match assoc_ty {\n@@ -804,7 +806,18 @@ impl<'a> InferenceContext<'a> {\n                 self.resolve_variant_on_alias(ty, unresolved, path)\n             }\n             TypeNs::TypeAliasId(it) => {\n-                let ty = TyBuilder::def_ty(self.db, it.into())\n+                let container = it.lookup(self.db.upcast()).container;\n+                let parent_subst = match container {\n+                    ItemContainerId::TraitId(id) => {\n+                        let subst = TyBuilder::subst_for_def(self.db, id, None)\n+                            .fill_with_inference_vars(&mut self.table)\n+                            .build();\n+                        Some(subst)\n+                    }\n+                    // Type aliases do not exist in impls.\n+                    _ => None,\n+                };\n+                let ty = TyBuilder::def_ty(self.db, it.into(), parent_subst)\n                     .fill_with_inference_vars(&mut self.table)\n                     .build();\n                 self.resolve_variant_on_alias(ty, unresolved, path)"}, {"sha": "f56108b26c45bdaea3096f4616828c28ba260d12", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 21, "deletions": 22, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -987,11 +987,13 @@ impl<'a> InferenceContext<'a> {\n         let lhs_ty = self.infer_expr(lhs, &lhs_expectation);\n         let rhs_ty = self.table.new_type_var();\n \n-        let func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n-            self.db.trait_data(self.resolve_lang_item(lang_item)?.as_trait()?).method_by_name(&name)\n+        let trait_func = lang_names_for_bin_op(op).and_then(|(name, lang_item)| {\n+            let trait_id = self.resolve_lang_item(lang_item)?.as_trait()?;\n+            let func = self.db.trait_data(trait_id).method_by_name(&name)?;\n+            Some((trait_id, func))\n         });\n-        let func = match func {\n-            Some(func) => func,\n+        let (trait_, func) = match trait_func {\n+            Some(it) => it,\n             None => {\n                 let rhs_ty = self.builtin_binary_op_rhs_expectation(op, lhs_ty.clone());\n                 let rhs_ty = self.infer_expr_coerce(rhs, &Expectation::from_option(rhs_ty));\n@@ -1001,7 +1003,9 @@ impl<'a> InferenceContext<'a> {\n             }\n         };\n \n-        let subst = TyBuilder::subst_for_def(self.db, func)\n+        // HACK: We can use this substitution for the function because the function itself doesn't\n+        // have its own generic parameters.\n+        let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n             .push(lhs_ty.clone())\n             .push(rhs_ty.clone())\n             .build();\n@@ -1280,19 +1284,7 @@ impl<'a> InferenceContext<'a> {\n         assert_eq!(self_params, 0); // method shouldn't have another Self param\n         let total_len = parent_params + type_params + const_params + impl_trait_params;\n         let mut substs = Vec::with_capacity(total_len);\n-        // Parent arguments are unknown\n-        for (id, param) in def_generics.iter_parent() {\n-            match param {\n-                TypeOrConstParamData::TypeParamData(_) => {\n-                    substs.push(GenericArgData::Ty(self.table.new_type_var()).intern(Interner));\n-                }\n-                TypeOrConstParamData::ConstParamData(_) => {\n-                    let ty = self.db.const_param_ty(ConstParamId::from_unchecked(id));\n-                    substs\n-                        .push(GenericArgData::Const(self.table.new_const_var(ty)).intern(Interner));\n-                }\n-            }\n-        }\n+\n         // handle provided arguments\n         if let Some(generic_args) = generic_args {\n             // if args are provided, it should be all of them, but we can't rely on that\n@@ -1301,7 +1293,7 @@ impl<'a> InferenceContext<'a> {\n                 .iter()\n                 .filter(|arg| !matches!(arg, GenericArg::Lifetime(_)))\n                 .take(type_params + const_params)\n-                .zip(def_generics.iter_id().skip(parent_params))\n+                .zip(def_generics.iter_id())\n             {\n                 if let Some(g) = generic_arg_to_chalk(\n                     self.db,\n@@ -1325,6 +1317,9 @@ impl<'a> InferenceContext<'a> {\n                 }\n             }\n         };\n+\n+        // Handle everything else as unknown. This also handles generic arguments for the method's\n+        // parent (impl or trait), which should come after those for the method.\n         for (id, data) in def_generics.iter().skip(substs.len()) {\n             match data {\n                 TypeOrConstParamData::TypeParamData(_) => {\n@@ -1362,9 +1357,13 @@ impl<'a> InferenceContext<'a> {\n                 CallableDefId::FunctionId(f) => {\n                     if let ItemContainerId::TraitId(trait_) = f.lookup(self.db.upcast()).container {\n                         // construct a TraitRef\n-                        let substs = crate::subst_prefix(\n-                            &*parameters,\n-                            generics(self.db.upcast(), trait_.into()).len(),\n+                        let params_len = parameters.len(Interner);\n+                        let trait_params_len = generics(self.db.upcast(), trait_.into()).len();\n+                        let substs = Substitution::from_iter(\n+                            Interner,\n+                            // The generic parameters for the trait come after those for the\n+                            // function.\n+                            &parameters.as_slice(Interner)[params_len - trait_params_len..],\n                         );\n                         self.push_obligation(\n                             TraitRef { trait_id: to_chalk_trait_id(trait_), substitution: substs }"}, {"sha": "7a4754cdc7bb899848ea9b032825945407e13850", "filename": "crates/hir-ty/src/infer/path.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fpath.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -12,6 +12,7 @@ use crate::{\n     builder::ParamKind,\n     consteval,\n     method_resolution::{self, VisibleFromModule},\n+    utils::generics,\n     Interner, Substitution, TraitRefExt, Ty, TyBuilder, TyExt, TyKind, ValueTyDefId,\n };\n \n@@ -95,12 +96,18 @@ impl<'a> InferenceContext<'a> {\n             ValueNs::GenericParam(it) => return Some(self.db.const_param_ty(it)),\n         };\n \n-        let parent_substs = self_subst.unwrap_or_else(|| Substitution::empty(Interner));\n         let ctx = crate::lower::TyLoweringContext::new(self.db, &self.resolver);\n         let substs = ctx.substs_from_path(path, typable, true);\n-        let mut it = substs.as_slice(Interner)[parent_substs.len(Interner)..].iter().cloned();\n-        let ty = TyBuilder::value_ty(self.db, typable)\n-            .use_parent_substs(&parent_substs)\n+        let substs = substs.as_slice(Interner);\n+        let parent_substs = self_subst.or_else(|| {\n+            let generics = generics(self.db.upcast(), typable.to_generic_def_id()?);\n+            let parent_params_len = generics.parent_generics()?.len();\n+            let parent_args = &substs[substs.len() - parent_params_len..];\n+            Some(Substitution::from_iter(Interner, parent_args))\n+        });\n+        let parent_substs_len = parent_substs.as_ref().map_or(0, |s| s.len(Interner));\n+        let mut it = substs.iter().take(substs.len() - parent_substs_len).cloned();\n+        let ty = TyBuilder::value_ty(self.db, typable, parent_substs)\n             .fill(|x| {\n                 it.next().unwrap_or_else(|| match x {\n                     ParamKind::Type => TyKind::Error.intern(Interner).cast(Interner),\n@@ -246,7 +253,7 @@ impl<'a> InferenceContext<'a> {\n                 };\n                 let substs = match container {\n                     ItemContainerId::ImplId(impl_id) => {\n-                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id)\n+                        let impl_substs = TyBuilder::subst_for_def(self.db, impl_id, None)\n                             .fill_with_inference_vars(&mut self.table)\n                             .build();\n                         let impl_self_ty ="}, {"sha": "6ccd0b215c6e480e72e17ed62a663ffc2d02ad9c", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -598,11 +598,14 @@ impl<'a> InferenceTable<'a> {\n             .build();\n \n         let projection = {\n-            let b = TyBuilder::assoc_type_projection(self.db, output_assoc_type);\n+            let b = TyBuilder::subst_for_def(self.db, fn_once_trait, None);\n             if b.remaining() != 2 {\n                 return None;\n             }\n-            b.push(ty.clone()).push(arg_ty).build()\n+            let fn_once_subst = b.push(ty.clone()).push(arg_ty).build();\n+\n+            TyBuilder::assoc_type_projection(self.db, output_assoc_type, Some(fn_once_subst))\n+                .build()\n         };\n \n         let trait_env = self.trait_env.env.clone();"}, {"sha": "0a4b1dfda105555888fbcc9248101e241d379236", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 114, "deletions": 79, "changes": 193, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -306,7 +306,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // FIXME we're probably doing something wrong here\n                         self.impl_trait_counter.set(idx + count_impl_traits(type_ref) as u16);\n                         let (\n-                            parent_params,\n+                            _parent_params,\n                             self_params,\n                             list_params,\n                             const_params,\n@@ -319,7 +319,7 @@ impl<'a> TyLoweringContext<'a> {\n                         };\n                         TyKind::BoundVar(BoundVar::new(\n                             self.in_binders,\n-                            idx as usize + parent_params + self_params + list_params + const_params,\n+                            idx as usize + self_params + list_params + const_params,\n                         ))\n                         .intern(Interner)\n                     }\n@@ -499,14 +499,31 @@ impl<'a> TyLoweringContext<'a> {\n                 .intern(Interner)\n             }\n             TypeNs::SelfType(impl_id) => {\n-                let generics = generics(self.db.upcast(), impl_id.into());\n-                let substs = match self.type_param_mode {\n-                    ParamLoweringMode::Placeholder => generics.placeholder_subst(self.db),\n+                let def =\n+                    self.resolver.generic_def().expect(\"impl should have generic param scope\");\n+                let generics = generics(self.db.upcast(), def);\n+\n+                match self.type_param_mode {\n+                    ParamLoweringMode::Placeholder => {\n+                        // `def` can be either impl itself or item within, and we need impl itself\n+                        // now.\n+                        let generics = generics.parent_generics().unwrap_or(&generics);\n+                        let subst = generics.placeholder_subst(self.db);\n+                        self.db.impl_self_ty(impl_id).substitute(Interner, &subst)\n+                    }\n                     ParamLoweringMode::Variable => {\n-                        generics.bound_vars_subst(self.db, self.in_binders)\n+                        let starting_from = match def {\n+                            GenericDefId::ImplId(_) => 0,\n+                            // `def` is an item within impl. We need to substitute `BoundVar`s but\n+                            // remember that they are for parent (i.e. impl) generic params so they\n+                            // come after our own params.\n+                            _ => generics.len_self(),\n+                        };\n+                        TyBuilder::impl_self_ty(self.db, impl_id)\n+                            .fill_with_bound_vars(self.in_binders, starting_from)\n+                            .build()\n                     }\n-                };\n-                self.db.impl_self_ty(impl_id).substitute(Interner, &substs)\n+                }\n             }\n             TypeNs::AdtSelfType(adt) => {\n                 let generics = generics(self.db.upcast(), adt.into());\n@@ -636,63 +653,50 @@ impl<'a> TyLoweringContext<'a> {\n         infer_args: bool,\n     ) -> Substitution {\n         let last = path.segments().last().expect(\"path should have at least one segment\");\n-        let (segment, generic_def) = match resolved {\n-            ValueTyDefId::FunctionId(it) => (last, Some(it.into())),\n-            ValueTyDefId::StructId(it) => (last, Some(it.into())),\n-            ValueTyDefId::UnionId(it) => (last, Some(it.into())),\n-            ValueTyDefId::ConstId(it) => (last, Some(it.into())),\n-            ValueTyDefId::StaticId(_) => (last, None),\n-            ValueTyDefId::EnumVariantId(var) => {\n+        let generic_def = resolved.to_generic_def_id();\n+        let segment = match resolved {\n+            ValueTyDefId::EnumVariantId(_) => {\n                 // the generic args for an enum variant may be either specified\n                 // on the segment referring to the enum, or on the segment\n                 // referring to the variant. So `Option::<T>::None` and\n                 // `Option::None::<T>` are both allowed (though the former is\n                 // preferred). See also `def_ids_for_path_segments` in rustc.\n                 let len = path.segments().len();\n                 let penultimate = len.checked_sub(2).and_then(|idx| path.segments().get(idx));\n-                let segment = match penultimate {\n+                match penultimate {\n                     Some(segment) if segment.args_and_bindings.is_some() => segment,\n                     _ => last,\n-                };\n-                (segment, Some(var.parent.into()))\n+                }\n             }\n+            _ => last,\n         };\n         self.substs_from_path_segment(segment, generic_def, infer_args, None)\n     }\n \n     fn substs_from_path_segment(\n         &self,\n         segment: PathSegment<'_>,\n-        def_generic: Option<GenericDefId>,\n+        def: Option<GenericDefId>,\n         infer_args: bool,\n         explicit_self_ty: Option<Ty>,\n     ) -> Substitution {\n+        // Remember that the item's own generic args come before its parent's.\n         let mut substs = Vec::new();\n-        let def_generics = if let Some(def) = def_generic {\n-            generics(self.db.upcast(), def)\n+        let def = if let Some(d) = def {\n+            d\n         } else {\n             return Substitution::empty(Interner);\n         };\n+        let def_generics = generics(self.db.upcast(), def);\n         let (parent_params, self_params, type_params, const_params, impl_trait_params) =\n             def_generics.provenance_split();\n-        let total_len =\n-            parent_params + self_params + type_params + const_params + impl_trait_params;\n+        let item_len = self_params + type_params + const_params + impl_trait_params;\n+        let total_len = parent_params + item_len;\n \n         let ty_error = TyKind::Error.intern(Interner).cast(Interner);\n \n         let mut def_generic_iter = def_generics.iter_id();\n \n-        for _ in 0..parent_params {\n-            if let Some(eid) = def_generic_iter.next() {\n-                match eid {\n-                    Either::Left(_) => substs.push(ty_error.clone()),\n-                    Either::Right(x) => {\n-                        substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n-                    }\n-                }\n-            }\n-        }\n-\n         let fill_self_params = || {\n             for x in explicit_self_ty\n                 .into_iter()\n@@ -757,37 +761,40 @@ impl<'a> TyLoweringContext<'a> {\n             fill_self_params();\n         }\n \n+        // These params include those of parent.\n+        let remaining_params: SmallVec<[_; 2]> = def_generic_iter\n+            .map(|eid| match eid {\n+                Either::Left(_) => ty_error.clone(),\n+                Either::Right(x) => unknown_const_as_generic(self.db.const_param_ty(x)),\n+            })\n+            .collect();\n+        assert_eq!(remaining_params.len() + substs.len(), total_len);\n+\n         // handle defaults. In expression or pattern path segments without\n         // explicitly specified type arguments, missing type arguments are inferred\n         // (i.e. defaults aren't used).\n         if !infer_args || had_explicit_args {\n-            if let Some(def_generic) = def_generic {\n-                let defaults = self.db.generic_defaults(def_generic);\n-                assert_eq!(total_len, defaults.len());\n-\n-                for default_ty in defaults.iter().skip(substs.len()) {\n-                    // each default can depend on the previous parameters\n-                    let substs_so_far = Substitution::from_iter(Interner, substs.clone());\n-                    if let Some(_id) = def_generic_iter.next() {\n-                        substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n-                    }\n-                }\n+            let defaults = self.db.generic_defaults(def);\n+            assert_eq!(total_len, defaults.len());\n+            let parent_from = item_len - substs.len();\n+\n+            for (idx, default_ty) in defaults[substs.len()..item_len].iter().enumerate() {\n+                // each default can depend on the previous parameters\n+                let substs_so_far = Substitution::from_iter(\n+                    Interner,\n+                    substs.iter().cloned().chain(remaining_params[idx..].iter().cloned()),\n+                );\n+                substs.push(default_ty.clone().substitute(Interner, &substs_so_far));\n             }\n-        }\n \n-        // add placeholders for args that were not provided\n-        // FIXME: emit diagnostics in contexts where this is not allowed\n-        for eid in def_generic_iter {\n-            match eid {\n-                Either::Left(_) => substs.push(ty_error.clone()),\n-                Either::Right(x) => {\n-                    substs.push(unknown_const_as_generic(self.db.const_param_ty(x)))\n-                }\n-            }\n+            // Keep parent's params as unknown.\n+            let mut remaining_params = remaining_params;\n+            substs.extend(remaining_params.drain(parent_from..));\n+        } else {\n+            substs.extend(remaining_params);\n         }\n-        // If this assert fails, it means you pushed into subst but didn't call .next() of def_generic_iter\n-        assert_eq!(substs.len(), total_len);\n \n+        assert_eq!(substs.len(), total_len);\n         Substitution::from_iter(Interner, substs)\n     }\n \n@@ -1168,10 +1175,18 @@ fn named_associated_type_shorthand_candidates<R>(\n             }\n             // Handle `Self::Type` referring to own associated type in trait definitions\n             if let GenericDefId::TraitId(trait_id) = param_id.parent() {\n-                let generics = generics(db.upcast(), trait_id.into());\n-                if generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n+                let trait_generics = generics(db.upcast(), trait_id.into());\n+                if trait_generics.params.type_or_consts[param_id.local_id()].is_trait_self() {\n+                    let def_generics = generics(db.upcast(), def);\n+                    let starting_idx = match def {\n+                        GenericDefId::TraitId(_) => 0,\n+                        // `def` is an item within trait. We need to substitute `BoundVar`s but\n+                        // remember that they are for parent (i.e. trait) generic params so they\n+                        // come after our own params.\n+                        _ => def_generics.len_self(),\n+                    };\n                     let trait_ref = TyBuilder::trait_ref(db, trait_id)\n-                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n+                        .fill_with_bound_vars(DebruijnIndex::INNERMOST, starting_idx)\n                         .build();\n                     return search(trait_ref);\n                 }\n@@ -1413,6 +1428,7 @@ pub(crate) fn generic_defaults_query(\n     let ctx =\n         TyLoweringContext::new(db, &resolver).with_type_param_mode(ParamLoweringMode::Variable);\n     let generic_params = generics(db.upcast(), def);\n+    let parent_start_idx = generic_params.len_self();\n \n     let defaults = generic_params\n         .iter()\n@@ -1425,19 +1441,17 @@ pub(crate) fn generic_defaults_query(\n                     let val = unknown_const_as_generic(\n                         db.const_param_ty(ConstParamId::from_unchecked(id)),\n                     );\n-                    return crate::make_binders_with_count(db, idx, &generic_params, val);\n+                    return make_binders(db, &generic_params, val);\n                 }\n             };\n             let mut ty =\n                 p.default.as_ref().map_or(TyKind::Error.intern(Interner), |t| ctx.lower_ty(t));\n \n             // Each default can only refer to previous parameters.\n-            // type variable default referring to parameter coming\n-            // after it. This is forbidden (FIXME: report\n-            // diagnostic)\n-            ty = fallback_bound_vars(ty, idx);\n-            let val = GenericArgData::Ty(ty).intern(Interner);\n-            crate::make_binders_with_count(db, idx, &generic_params, val)\n+            // Type variable default referring to parameter coming\n+            // after it is forbidden (FIXME: report diagnostic)\n+            ty = fallback_bound_vars(ty, idx, parent_start_idx);\n+            crate::make_binders(db, &generic_params, ty.cast(Interner))\n         })\n         .collect();\n \n@@ -1454,15 +1468,14 @@ pub(crate) fn generic_defaults_recover(\n     // we still need one default per parameter\n     let defaults = generic_params\n         .iter_id()\n-        .enumerate()\n-        .map(|(count, id)| {\n+        .map(|id| {\n             let val = match id {\n                 itertools::Either::Left(_) => {\n                     GenericArgData::Ty(TyKind::Error.intern(Interner)).intern(Interner)\n                 }\n                 itertools::Either::Right(id) => unknown_const_as_generic(db.const_param_ty(id)),\n             };\n-            crate::make_binders_with_count(db, count, &generic_params, val)\n+            crate::make_binders(db, &generic_params, val)\n         })\n         .collect();\n \n@@ -1837,26 +1850,48 @@ pub(crate) fn const_or_path_to_chalk(\n     }\n }\n \n-/// This replaces any 'free' Bound vars in `s` (i.e. those with indices past\n-/// num_vars_to_keep) by `TyKind::Unknown`.\n+/// Replaces any 'free' `BoundVar`s in `s` by `TyKind::Error` from the perspective of generic\n+/// parameter whose index is `param_index`. A `BoundVar` is free when it is or (syntactically)\n+/// appears after the generic parameter of `param_index`.\n fn fallback_bound_vars<T: TypeFoldable<Interner> + HasInterner<Interner = Interner>>(\n     s: T,\n-    num_vars_to_keep: usize,\n+    param_index: usize,\n+    parent_start: usize,\n ) -> T {\n+    // Keep in mind that parent generic parameters, if any, come *after* those of the item in\n+    // question. In the diagrams below, `c*` and `p*` represent generic parameters of the item and\n+    // its parent respectively.\n+    let is_allowed = |index| {\n+        if param_index < parent_start {\n+            // The parameter of `param_index` is one from the item in question. Any parent generic\n+            // parameters or the item's generic parameters that come before `param_index` is\n+            // allowed.\n+            // [c1, .., cj, .., ck, p1, .., pl] where cj is `param_index`\n+            //  ^^^^^^              ^^^^^^^^^^ these are allowed\n+            !(param_index..parent_start).contains(&index)\n+        } else {\n+            // The parameter of `param_index` is one from the parent generics. Only parent generic\n+            // parameters that come before `param_index` are allowed.\n+            // [c1, .., ck, p1, .., pj, .., pl] where pj is `param_index`\n+            //              ^^^^^^ these are allowed\n+            (parent_start..param_index).contains(&index)\n+        }\n+    };\n+\n     crate::fold_free_vars(\n         s,\n         |bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                TyKind::Error.intern(Interner)\n-            } else {\n+            if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_ty(Interner)\n+            } else {\n+                TyKind::Error.intern(Interner)\n             }\n         },\n         |ty, bound, binders| {\n-            if bound.index >= num_vars_to_keep && bound.debruijn == DebruijnIndex::INNERMOST {\n-                unknown_const(ty.clone())\n-            } else {\n+            if bound.index_if_innermost().map_or(true, is_allowed) {\n                 bound.shifted_in_from(binders).to_const(Interner, ty)\n+            } else {\n+                unknown_const(ty.clone())\n             }\n         },\n     )"}, {"sha": "5998680dcd395390dcee0197baf6c8b6052a8acb", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -654,7 +654,7 @@ fn find_matching_impl(\n         let r = table.run_in_snapshot(|table| {\n             let impl_data = db.impl_data(impl_);\n             let substs =\n-                TyBuilder::subst_for_def(db, impl_).fill_with_inference_vars(table).build();\n+                TyBuilder::subst_for_def(db, impl_, None).fill_with_inference_vars(table).build();\n             let impl_ty = db.impl_self_ty(impl_).substitute(Interner, &substs);\n \n             table\n@@ -1147,10 +1147,9 @@ fn is_valid_candidate(\n             }));\n             if let ItemContainerId::ImplId(impl_id) = c.lookup(db.upcast()).container {\n                 let self_ty_matches = table.run_in_snapshot(|table| {\n-                    let subst =\n-                        TyBuilder::subst_for_def(db, c).fill_with_inference_vars(table).build();\n-                    let expected_self_ty =\n-                        subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner);\n+                    let expected_self_ty = TyBuilder::impl_self_ty(db, impl_id)\n+                        .fill_with_inference_vars(table)\n+                        .build();\n                     table.unify(&expected_self_ty, &self_ty)\n                 });\n                 if !self_ty_matches {\n@@ -1186,31 +1185,26 @@ fn is_valid_fn_candidate(\n \n     table.run_in_snapshot(|table| {\n         let container = fn_id.lookup(db.upcast()).container;\n-        let impl_subst = match container {\n+        let (impl_subst, expect_self_ty) = match container {\n             ItemContainerId::ImplId(it) => {\n-                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+                let subst =\n+                    TyBuilder::subst_for_def(db, it, None).fill_with_inference_vars(table).build();\n+                let self_ty = db.impl_self_ty(it).substitute(Interner, &subst);\n+                (subst, self_ty)\n             }\n             ItemContainerId::TraitId(it) => {\n-                TyBuilder::subst_for_def(db, it).fill_with_inference_vars(table).build()\n+                let subst =\n+                    TyBuilder::subst_for_def(db, it, None).fill_with_inference_vars(table).build();\n+                let self_ty = subst.at(Interner, 0).assert_ty_ref(Interner).clone();\n+                (subst, self_ty)\n             }\n             _ => unreachable!(),\n         };\n \n-        let fn_subst = TyBuilder::subst_for_def(db, fn_id)\n-            .use_parent_substs(&impl_subst)\n+        let fn_subst = TyBuilder::subst_for_def(db, fn_id, Some(impl_subst.clone()))\n             .fill_with_inference_vars(table)\n             .build();\n \n-        let expect_self_ty = match container {\n-            ItemContainerId::TraitId(_) => fn_subst.at(Interner, 0).assert_ty_ref(Interner).clone(),\n-            ItemContainerId::ImplId(impl_id) => {\n-                fn_subst.apply(db.impl_self_ty(impl_id).skip_binders().clone(), Interner)\n-            }\n-            // We should only get called for associated items (impl/trait)\n-            ItemContainerId::ModuleId(_) | ItemContainerId::ExternBlockId(_) => {\n-                unreachable!()\n-            }\n-        };\n         check_that!(table.unify(&expect_self_ty, self_ty));\n \n         if let Some(receiver_ty) = receiver_ty {"}, {"sha": "e08dd8dadebc5759dd38fc4ae061933712caf718", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -61,7 +61,6 @@ use hir_ty::{\n     diagnostics::BodyValidationDiagnostic,\n     method_resolution::{self, TyFingerprint},\n     primitive::UintTy,\n-    subst_prefix,\n     traits::FnTrait,\n     AliasTy, CallableDefId, CallableSig, Canonical, CanonicalVarKinds, Cast, ClosureId,\n     GenericArgData, Interner, ParamKind, QuantifiedWhereClause, Scalar, Substitution,\n@@ -1090,7 +1089,7 @@ impl Adt {\n     pub fn ty_with_args(self, db: &dyn HirDatabase, args: &[Type]) -> Type {\n         let id = AdtId::from(self);\n         let mut it = args.iter().map(|t| t.ty.clone());\n-        let ty = TyBuilder::def_ty(db, id.into())\n+        let ty = TyBuilder::def_ty(db, id.into(), None)\n             .fill(|x| {\n                 let r = it.next().unwrap_or_else(|| TyKind::Error.intern(Interner));\n                 match x {\n@@ -2547,7 +2546,7 @@ impl TypeParam {\n         let resolver = self.id.parent().resolver(db.upcast());\n         let ty = params.get(local_idx)?.clone();\n         let subst = TyBuilder::placeholder_subst(db, self.id.parent());\n-        let ty = ty.substitute(Interner, &subst_prefix(&subst, local_idx));\n+        let ty = ty.substitute(Interner, &subst);\n         match ty.data(Interner) {\n             GenericArgData::Ty(x) => Some(Type::new_with_resolver_inner(db, &resolver, x.clone())),\n             _ => None,\n@@ -2801,7 +2800,18 @@ impl Type {\n     }\n \n     fn from_def(db: &dyn HirDatabase, def: impl HasResolver + Into<TyDefId>) -> Type {\n-        let ty = TyBuilder::def_ty(db, def.into()).fill_with_unknown().build();\n+        let ty_def = def.into();\n+        let parent_subst = match ty_def {\n+            TyDefId::TypeAliasId(id) => match id.lookup(db.upcast()).container {\n+                ItemContainerId::TraitId(id) => {\n+                    let subst = TyBuilder::subst_for_def(db, id, None).fill_with_unknown().build();\n+                    Some(subst)\n+                }\n+                _ => None,\n+            },\n+            _ => None,\n+        };\n+        let ty = TyBuilder::def_ty(db, ty_def, parent_subst).fill_with_unknown().build();\n         Type::new(db, def, ty)\n     }\n \n@@ -2941,7 +2951,11 @@ impl Type {\n         alias: TypeAlias,\n     ) -> Option<Type> {\n         let mut args = args.iter();\n-        let projection = TyBuilder::assoc_type_projection(db, alias.id)\n+        let trait_id = match alias.id.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(id) => id,\n+            _ => unreachable!(\"non assoc type alias reached in normalize_trait_assoc_type()\"),\n+        };\n+        let parent_subst = TyBuilder::subst_for_def(db, trait_id, None)\n             .push(self.ty.clone())\n             .fill(|x| {\n                 // FIXME: this code is not covered in tests.\n@@ -2953,6 +2967,8 @@ impl Type {\n                 }\n             })\n             .build();\n+        // FIXME: We don't handle GATs yet.\n+        let projection = TyBuilder::assoc_type_projection(db, alias.id, Some(parent_subst)).build();\n \n         let ty = db.normalize_projection(projection, self.env.clone());\n         if ty.is_unknown() {"}, {"sha": "07bae2b38c796b3ee6698ae09785e61e71bcf7a9", "filename": "crates/hir/src/source_analyzer.rs", "status": "modified", "additions": 33, "deletions": 13, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78977cd86cd17e008f94f8579d6a5aaebe46e69b/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsource_analyzer.rs?ref=78977cd86cd17e008f94f8579d6a5aaebe46e69b", "patch": "@@ -22,7 +22,7 @@ use hir_def::{\n     resolver::{resolver_for_scope, Resolver, TypeNs, ValueNs},\n     type_ref::Mutability,\n     AsMacroCall, AssocItemId, DefWithBodyId, FieldId, FunctionId, ItemContainerId, LocalFieldId,\n-    Lookup, ModuleDefId, VariantId,\n+    Lookup, ModuleDefId, TraitId, VariantId,\n };\n use hir_expand::{\n     builtin_fn_macro::BuiltinFnLikeExpander,\n@@ -302,10 +302,15 @@ impl SourceAnalyzer {\n             }\n         }\n \n+        let future_trait = db\n+            .lang_item(self.resolver.krate(), hir_expand::name![future_trait].to_smol_str())?\n+            .as_trait()?;\n         let poll_fn = db\n             .lang_item(self.resolver.krate(), hir_expand::name![poll].to_smol_str())?\n             .as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, poll_fn).push(ty.clone()).build();\n+        // HACK: subst for `poll()` coincides with that for `Future` because `poll()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `poll()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, future_trait, None).push(ty).build();\n         Some(self.resolve_impl_method_or_trait_def(db, poll_fn, &substs))\n     }\n \n@@ -321,8 +326,10 @@ impl SourceAnalyzer {\n         };\n         let ty = self.ty_of_expr(db, &prefix_expr.expr()?.into())?;\n \n-        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        // HACK: subst for all methods coincides with that for their trait because the methods\n+        // don't have any generic parameters, so we skip building another subst for the methods.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -337,8 +344,10 @@ impl SourceAnalyzer {\n \n         let lang_item_name = name![index];\n \n-        let op_fn = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn)\n+        let (op_trait, op_fn) = self.lang_trait_fn(db, &lang_item_name, &lang_item_name)?;\n+        // HACK: subst for all methods coincides with that for their trait because the methods\n+        // don't have any generic parameters, so we skip building another subst for the methods.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n             .push(base_ty.clone())\n             .push(index_ty.clone())\n             .build();\n@@ -354,10 +363,14 @@ impl SourceAnalyzer {\n         let lhs = self.ty_of_expr(db, &binop_expr.lhs()?.into())?;\n         let rhs = self.ty_of_expr(db, &binop_expr.rhs()?.into())?;\n \n-        let op_fn = lang_names_for_bin_op(op)\n+        let (op_trait, op_fn) = lang_names_for_bin_op(op)\n             .and_then(|(name, lang_item)| self.lang_trait_fn(db, &lang_item, &name))?;\n-        let substs =\n-            hir_ty::TyBuilder::subst_for_def(db, op_fn).push(lhs.clone()).push(rhs.clone()).build();\n+        // HACK: subst for `index()` coincides with that for `Index` because `index()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `index()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None)\n+            .push(lhs.clone())\n+            .push(rhs.clone())\n+            .build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -371,7 +384,13 @@ impl SourceAnalyzer {\n \n         let op_fn =\n             db.lang_item(self.resolver.krate(), name![branch].to_smol_str())?.as_function()?;\n-        let substs = hir_ty::TyBuilder::subst_for_def(db, op_fn).push(ty.clone()).build();\n+        let op_trait = match op_fn.lookup(db.upcast()).container {\n+            ItemContainerId::TraitId(id) => id,\n+            _ => return None,\n+        };\n+        // HACK: subst for `branch()` coincides with that for `Try` because `branch()` itself\n+        // doesn't have any generic parameters, so we skip building another subst for `branch()`.\n+        let substs = hir_ty::TyBuilder::subst_for_def(db, op_trait, None).push(ty.clone()).build();\n \n         Some(self.resolve_impl_method_or_trait_def(db, op_fn, &substs))\n     }\n@@ -799,9 +818,10 @@ impl SourceAnalyzer {\n         db: &dyn HirDatabase,\n         lang_trait: &Name,\n         method_name: &Name,\n-    ) -> Option<FunctionId> {\n-        db.trait_data(db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?)\n-            .method_by_name(method_name)\n+    ) -> Option<(TraitId, FunctionId)> {\n+        let trait_id = db.lang_item(self.resolver.krate(), lang_trait.to_smol_str())?.as_trait()?;\n+        let fn_id = db.trait_data(trait_id).method_by_name(method_name)?;\n+        Some((trait_id, fn_id))\n     }\n \n     fn ty_of_expr(&self, db: &dyn HirDatabase, expr: &ast::Expr) -> Option<&Ty> {"}]}