{"sha": "ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMDIyN2ZmZjdlZjg2YmYyMGY3OTQyYmI5YjdkMDYyYTExYzNkOTk=", "commit": {"author": {"name": "Martin Carton", "email": "cartonmartin+github@gmail.com", "date": "2016-12-17T00:35:37Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-12-17T00:35:37Z"}, "message": "Merge pull request #1373 from Manishearth/rustup\n\nWIP: rustup", "tree": {"sha": "8f14373a5136a1d6821ed8bd8072d69f7eea1f36", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f14373a5136a1d6821ed8bd8072d69f7eea1f36"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "html_url": "https://github.com/rust-lang/rust/commit/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/comments", "author": {"login": "mcarton", "id": 3751788, "node_id": "MDQ6VXNlcjM3NTE3ODg=", "avatar_url": "https://avatars.githubusercontent.com/u/3751788?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mcarton", "html_url": "https://github.com/mcarton", "followers_url": "https://api.github.com/users/mcarton/followers", "following_url": "https://api.github.com/users/mcarton/following{/other_user}", "gists_url": "https://api.github.com/users/mcarton/gists{/gist_id}", "starred_url": "https://api.github.com/users/mcarton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mcarton/subscriptions", "organizations_url": "https://api.github.com/users/mcarton/orgs", "repos_url": "https://api.github.com/users/mcarton/repos", "events_url": "https://api.github.com/users/mcarton/events{/privacy}", "received_events_url": "https://api.github.com/users/mcarton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f9fe50da1ed24fc02da84d526d8d2b9ba91682cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9fe50da1ed24fc02da84d526d8d2b9ba91682cb", "html_url": "https://github.com/rust-lang/rust/commit/f9fe50da1ed24fc02da84d526d8d2b9ba91682cb"}, {"sha": "4fcefe2a9e38d3fa8e57c58d78328e23de54757f", "url": "https://api.github.com/repos/rust-lang/rust/commits/4fcefe2a9e38d3fa8e57c58d78328e23de54757f", "html_url": "https://github.com/rust-lang/rust/commit/4fcefe2a9e38d3fa8e57c58d78328e23de54757f"}], "stats": {"total": 1835, "additions": 1038, "deletions": 797}, "files": [{"sha": "952532a3d7cf9e639d975e3e906d8759fcf6c3c3", "filename": "CHANGELOG.md", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,6 +1,9 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n+## 0.0.104 \u2014 2016-12-15\n+* Update to *rustc 1.15.0-nightly (8f02c429a 2016-12-15)*\n+\n ## 0.0.103 \u2014 2016-11-25\n * Update to *rustc 1.15.0-nightly (d5814b03e 2016-11-23)*\n "}, {"sha": "5167218ff4a84cb0f0aaad4d3b79ac5f8ba407b3", "filename": "Cargo.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,6 +1,6 @@\n [package]\n name = \"clippy\"\n-version = \"0.0.103\"\n+version = \"0.0.104\"\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\",\n \t\"Andre Bogus <bogusandre@gmail.com>\",\n@@ -25,7 +25,7 @@ test = false\n \n [dependencies]\n # begin automatic update\n-clippy_lints = { version = \"0.0.103\", path = \"clippy_lints\" }\n+clippy_lints = { version = \"0.0.104\", path = \"clippy_lints\" }\n # end automatic update\n \n [dev-dependencies]"}, {"sha": "faf86875f40d493994c608fc6f2b4d45b85fc900", "filename": "clippy_lints/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2FCargo.toml?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,7 +1,7 @@\n [package]\n name = \"clippy_lints\"\n # begin automatic update\n-version = \"0.0.103\"\n+version = \"0.0.104\"\n # end automatic update\n authors = [\n \t\"Manish Goregaokar <manishsmail@gmail.com>\","}, {"sha": "3ccb5f6ef2a00ff110d059739434f838e394615c", "filename": "clippy_lints/src/approx_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fapprox_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fapprox_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fapprox_const.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -59,8 +59,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprLit(ref lit) = e.node {\n             check_lit(cx, lit, e);\n         }"}, {"sha": "5020295e20c96f85c52172d1759303f95651c106", "filename": "clippy_lints/src/arithmetic.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Farithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Farithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farithmetic.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -47,8 +47,8 @@ impl LintPass for Arithmetic {\n     }\n }\n \n-impl LateLintPass for Arithmetic {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Arithmetic {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if self.span.is_some() {\n             return;\n         }\n@@ -82,7 +82,7 @@ impl LateLintPass for Arithmetic {\n         }\n     }\n \n-    fn check_expr_post(&mut self, _: &LateContext, expr: &hir::Expr) {\n+    fn check_expr_post(&mut self, _: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if Some(expr.span) == self.span {\n             self.span = None;\n         }"}, {"sha": "399f93d08c7cd419641f715efa4e534db03fe83b", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -55,8 +55,8 @@ impl LintPass for ArrayIndexing {\n     }\n }\n \n-impl LateLintPass for ArrayIndexing {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ArrayIndexing {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx hir::Expr) {\n         if let hir::ExprIndex(ref array, ref index) = e.node {\n             // Array with known size can be checked statically\n             let ty = cx.tcx.tables().expr_ty(array);"}, {"sha": "ef6898cef885611182d3a68c03f52b624593271f", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -66,8 +66,8 @@ impl LintPass for AssignOps {\n     }\n }\n \n-impl LateLintPass for AssignOps {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AssignOps {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n                 span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {"}, {"sha": "a37b08363957494e1ab72e3b67303b1b88a57163", "filename": "clippy_lints/src/attrs.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fattrs.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -81,8 +81,8 @@ impl LintPass for AttrPass {\n     }\n }\n \n-impl LateLintPass for AttrPass {\n-    fn check_attribute(&mut self, cx: &LateContext, attr: &Attribute) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AttrPass {\n+    fn check_attribute(&mut self, cx: &LateContext<'a, 'tcx>, attr: &'tcx Attribute) {\n         if let MetaItemKind::List(ref items) = attr.value.node {\n             if items.is_empty() || attr.name() != \"deprecated\" {\n                 return;\n@@ -99,21 +99,21 @@ impl LateLintPass for AttrPass {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if is_relevant_item(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n         match item.node {\n             ItemExternCrate(_) |\n-            ItemUse(_) => {\n+            ItemUse(_, _) => {\n                 for attr in &item.attrs {\n                     if let MetaItemKind::List(ref lint_list) = attr.value.node {\n                         match &*attr.name().as_str() {\n                             \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n                                 // whitelist `unused_imports`\n                                 for lint in lint_list {\n                                     if is_word(lint, \"unused_imports\") {\n-                                        if let ItemUse(_) = item.node {\n+                                        if let ItemUse(_, _) = item.node {\n                                             return;\n                                         }\n                                     }\n@@ -138,38 +138,38 @@ impl LateLintPass for AttrPass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if is_relevant_impl(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if is_relevant_trait(cx, item) {\n             check_attrs(cx, item.span, &item.name, &item.attrs)\n         }\n     }\n }\n \n fn is_relevant_item(cx: &LateContext, item: &Item) -> bool {\n-    if let ItemFn(_, _, _, _, _, ref expr) = item.node {\n-        is_relevant_expr(cx, expr)\n+    if let ItemFn(_, _, _, _, _, eid) = item.node {\n+        is_relevant_expr(cx, cx.tcx.map.expr(eid))\n     } else {\n         false\n     }\n }\n \n fn is_relevant_impl(cx: &LateContext, item: &ImplItem) -> bool {\n     match item.node {\n-        ImplItemKind::Method(_, ref expr) => is_relevant_expr(cx, expr),\n+        ImplItemKind::Method(_, eid) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n         _ => false,\n     }\n }\n \n fn is_relevant_trait(cx: &LateContext, item: &TraitItem) -> bool {\n     match item.node {\n         MethodTraitItem(_, None) => true,\n-        MethodTraitItem(_, Some(ref expr)) => is_relevant_expr(cx, expr),\n+        MethodTraitItem(_, Some(eid)) => is_relevant_expr(cx, cx.tcx.map.expr(eid)),\n         _ => false,\n     }\n }\n@@ -193,8 +193,8 @@ fn is_relevant_expr(cx: &LateContext, expr: &Expr) -> bool {\n         ExprRet(Some(ref e)) => is_relevant_expr(cx, e),\n         ExprRet(None) | ExprBreak(_, None) => false,\n         ExprCall(ref path_expr, _) => {\n-            if let ExprPath(..) = path_expr.node {\n-                let fun_id = resolve_node(cx, path_expr.id).expect(\"function should be resolved\").def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let fun_id = resolve_node(cx, qpath, path_expr.id).def_id();\n                 !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n             } else {\n                 true"}, {"sha": "0e569bc76f7b5cf22f07cf42dd3382e593560835", "filename": "clippy_lints/src/bit_mask.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fbit_mask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fbit_mask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbit_mask.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::*;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc::lint::*;\n use rustc_const_eval::lookup_const_by_id;\n use syntax::ast::LitKind;\n@@ -79,8 +79,8 @@ impl LintPass for BitMask {\n     }\n }\n \n-impl LateLintPass for BitMask {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BitMask {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = e.node {\n             if cmp.node.is_comparison() {\n                 if let Some(cmp_opt) = fetch_int_literal(cx, right) {\n@@ -245,18 +245,13 @@ fn fetch_int_literal(cx: &LateContext, lit: &Expr) -> Option<u64> {\n                 None\n             }\n         }\n-        ExprPath(_, _) => {\n-            {\n-                // Important to let the borrow expire before the const lookup to avoid double\n-                // borrowing.\n-                let def_map = cx.tcx.def_map.borrow();\n-                match def_map.get(&lit.id) {\n-                    Some(&PathResolution { base_def: Def::Const(def_id), .. }) => Some(def_id),\n-                    _ => None,\n-                }\n+        ExprPath(ref qpath) => {\n+            let def = cx.tcx.tables().qpath_def(qpath, lit.id);\n+            if let Def::Const(def_id) = def {\n+                lookup_const_by_id(cx.tcx, def_id, None).and_then(|(l, _ty)| fetch_int_literal(cx, l))\n+            } else {\n+                None\n             }\n-            .and_then(|def_id| lookup_const_by_id(cx.tcx, def_id, None))\n-            .and_then(|(l, _ty)| fetch_int_literal(cx, l))\n         }\n         _ => None,\n     }"}, {"sha": "2f9a50fe3dac84d16e833278e9691de53982b0ca", "filename": "clippy_lints/src/blacklisted_name.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fblacklisted_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblacklisted_name.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -37,9 +37,9 @@ impl LintPass for BlackListedName {\n     }\n }\n \n-impl LateLintPass for BlackListedName {\n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatKind::Binding(_, ref ident, _) = pat.node {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlackListedName {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n+        if let PatKind::Binding(_, _, ref ident, _) = pat.node {\n             if self.blacklist.iter().any(|s| s == &*ident.node.as_str()) {\n                 span_lint(cx,\n                           BLACKLISTED_NAME,"}, {"sha": "de004afa1a6c8eabd74442f564b62b7cb24f20f2", "filename": "clippy_lints/src/block_in_if_condition.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fblock_in_if_condition.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::{LateLintPass, LateContext, LintArray, LintPass};\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use utils::*;\n \n /// **What it does:** Checks for `if` conditions that use blocks to contain an\n@@ -49,28 +49,33 @@ impl LintPass for BlockInIfCondition {\n     }\n }\n \n-struct ExVisitor<'v> {\n-    found_block: Option<&'v Expr>,\n+struct ExVisitor<'a, 'tcx: 'a> {\n+    found_block: Option<&'tcx Expr>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for ExVisitor<'v> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n-        if let ExprClosure(_, _, ref expr, _) = expr.node {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ExVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprClosure(_, _, eid, _) = expr.node {\n+            let expr = self.cx.tcx.map.expr(eid);\n             if matches!(expr.node, ExprBlock(_)) {\n                 self.found_block = Some(expr);\n                 return;\n             }\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n const BRACED_EXPR_MESSAGE: &'static str = \"omit braces around single expression condition\";\n const COMPLEX_BLOCK_MESSAGE: &'static str = \"in an 'if' condition, avoid complex blocks or closures with blocks; \\\n                                              instead, move the block or closure higher and bind it with a 'let'\";\n \n-impl LateLintPass for BlockInIfCondition {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BlockInIfCondition {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprIf(ref check, ref then, _) = expr.node {\n             if let ExprBlock(ref block) = check.node {\n                 if block.rules == DefaultBlock {\n@@ -105,7 +110,7 @@ impl LateLintPass for BlockInIfCondition {\n                     }\n                 }\n             } else {\n-                let mut visitor = ExVisitor { found_block: None };\n+                let mut visitor = ExVisitor { found_block: None, cx: cx };\n                 walk_expr(&mut visitor, check);\n                 if let Some(block) = visitor.found_block {\n                     span_lint(cx, BLOCK_IN_IF_CONDITION_STMT, block.span, COMPLEX_BLOCK_MESSAGE);"}, {"sha": "bd5657483112e5a89005a057cf1d3da322121ed6", "filename": "clippy_lints/src/booleans.rs", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fbooleans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fbooleans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fbooleans.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -53,13 +53,15 @@ impl LintPass for NonminimalBool {\n     }\n }\n \n-impl LateLintPass for NonminimalBool {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        NonminimalBoolVisitor(cx).visit_item(item)\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonminimalBool {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        NonminimalBoolVisitor { cx: cx }.visit_item(item)\n     }\n }\n \n-struct NonminimalBoolVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+struct NonminimalBoolVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n \n use quine_mc_cluskey::Bool;\n struct Hir2Qmm<'a, 'tcx: 'a, 'v> {\n@@ -308,7 +310,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n     fn bool_expr(&self, e: &Expr) {\n         let mut h2q = Hir2Qmm {\n             terminals: Vec::new(),\n-            cx: self.0,\n+            cx: self.cx,\n         };\n         if let Ok(expr) = h2q.run(e) {\n \n@@ -343,7 +345,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                         continue 'simplified;\n                     }\n                     if stats.terminals[i] != 0 && simplified_stats.terminals[i] == 0 {\n-                        span_lint_and_then(self.0,\n+                        span_lint_and_then(self.cx,\n                                            LOGIC_BUG,\n                                            e.span,\n                                            \"this boolean expression contains a logic bug\",\n@@ -353,7 +355,7 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                                           outer expression\");\n                             db.span_suggestion(e.span,\n                                                \"it would look like the following\",\n-                                               suggest(self.0, suggestion, &h2q.terminals));\n+                                               suggest(self.cx, suggestion, &h2q.terminals));\n                         });\n                         // don't also lint `NONMINIMAL_BOOL`\n                         return;\n@@ -370,29 +372,29 @@ impl<'a, 'tcx> NonminimalBoolVisitor<'a, 'tcx> {\n                 }\n             }\n             if !improvements.is_empty() {\n-                span_lint_and_then(self.0,\n+                span_lint_and_then(self.cx,\n                                    NONMINIMAL_BOOL,\n                                    e.span,\n                                    \"this boolean expression can be simplified\",\n                                    |db| {\n                     for suggestion in &improvements {\n-                        db.span_suggestion(e.span, \"try\", suggest(self.0, suggestion, &h2q.terminals));\n+                        db.span_suggestion(e.span, \"try\", suggest(self.cx, suggestion, &h2q.terminals));\n                     }\n                 });\n             }\n         }\n     }\n }\n \n-impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, e: &'v Expr) {\n-        if in_macro(self.0, e.span) {\n+impl<'a, 'tcx> Visitor<'tcx> for NonminimalBoolVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n+        if in_macro(self.cx, e.span) {\n             return;\n         }\n         match e.node {\n             ExprBinary(binop, _, _) if binop.node == BiOr || binop.node == BiAnd => self.bool_expr(e),\n             ExprUnary(UnNot, ref inner) => {\n-                if self.0.tcx.tables.borrow().node_types[&inner.id].is_bool() {\n+                if self.cx.tcx.tables.borrow().node_types[&inner.id].is_bool() {\n                     self.bool_expr(e);\n                 } else {\n                     walk_expr(self, e);\n@@ -401,4 +403,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for NonminimalBoolVisitor<'a, 'tcx> {\n             _ => walk_expr(self, e),\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "afbf9666b10a49b09b388c26d3642b1a173b4698", "filename": "clippy_lints/src/consts.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fconsts.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,7 +1,7 @@\n #![allow(cast_possible_truncation)]\n \n use rustc::lint::LateContext;\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc_const_eval::lookup_const_by_id;\n use rustc_const_math::{ConstInt, ConstUsize, ConstIsize};\n use rustc::hir::*;\n@@ -10,7 +10,7 @@ use std::cmp::PartialOrd;\n use std::hash::{Hash, Hasher};\n use std::mem;\n use std::rc::Rc;\n-use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy};\n+use syntax::ast::{FloatTy, LitIntType, LitKind, StrStyle, UintTy, IntTy, NodeId};\n use syntax::ptr::P;\n \n #[derive(Debug, Copy, Clone)]\n@@ -252,7 +252,7 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     /// simple constant folding: Insert an expression, get a constant or none.\n     fn expr(&mut self, e: &Expr) -> Option<Constant> {\n         match e.node {\n-            ExprPath(_, _) => self.fetch_path(e),\n+            ExprPath(ref qpath) => self.fetch_path(qpath, e.id),\n             ExprBlock(ref block) => self.block(block),\n             ExprIf(ref cond, ref then, ref otherwise) => self.ifthenelse(cond, then, otherwise),\n             ExprLit(ref lit) => Some(lit_to_constant(&lit.node)),\n@@ -285,21 +285,22 @@ impl<'c, 'cc> ConstEvalLateContext<'c, 'cc> {\n     }\n \n     /// lookup a possibly constant expression from a ExprPath\n-    fn fetch_path(&mut self, e: &Expr) -> Option<Constant> {\n+    fn fetch_path(&mut self, qpath: &QPath, id: NodeId) -> Option<Constant> {\n         if let Some(lcx) = self.lcx {\n-            let mut maybe_id = None;\n-            if let Some(&PathResolution { base_def: Def::Const(id), .. }) = lcx.tcx.def_map.borrow().get(&e.id) {\n-                maybe_id = Some(id);\n-            }\n-            // separate if lets to avoid double borrowing the def_map\n-            if let Some(id) = maybe_id {\n-                if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, id, None) {\n-                    let ret = self.expr(const_expr);\n-                    if ret.is_some() {\n-                        self.needed_resolution = true;\n+            let def = lcx.tcx.tables().qpath_def(qpath, id);\n+            match def {\n+                Def::Const(def_id) | Def::AssociatedConst(def_id) => {\n+                    let substs = Some(lcx.tcx.tables().node_id_item_substs(id)\n+                        .unwrap_or_else(|| lcx.tcx.intern_substs(&[])));\n+                    if let Some((const_expr, _ty)) = lookup_const_by_id(lcx.tcx, def_id, substs) {\n+                        let ret = self.expr(const_expr);\n+                        if ret.is_some() {\n+                            self.needed_resolution = true;\n+                        }\n+                        return ret;\n                     }\n-                    return ret;\n-                }\n+                },\n+                _ => {},\n             }\n         }\n         None"}, {"sha": "9fa38ad02b3eab4fa31c98df8eeba5fafff1f985", "filename": "clippy_lints/src/copies.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopies.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -109,8 +109,8 @@ impl LintPass for CopyAndPaste {\n     }\n }\n \n-impl LateLintPass for CopyAndPaste {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyAndPaste {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if !in_macro(cx, expr.span) {\n             // skip ifs directly in else, it will be checked in the parent if\n             if let Some(&Expr { node: ExprIf(_, _, Some(ref else_expr)), .. }) = get_parent_expr(cx, expr) {\n@@ -254,7 +254,7 @@ fn bindings<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, pat: &Pat) -> HashMap<Interned\n                     bindings_impl(cx, pat, map);\n                 }\n             }\n-            PatKind::Binding(_, ref ident, ref as_pat) => {\n+            PatKind::Binding(_, _, ref ident, ref as_pat) => {\n                 if let Entry::Vacant(v) = map.entry(ident.node.as_str()) {\n                     v.insert(cx.tcx.tables().pat_ty(pat));\n                 }"}, {"sha": "fc9e25c7707ef7fbc07f12e51ce1bd3b5e0d0198", "filename": "clippy_lints/src/cyclomatic_complexity.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcyclomatic_complexity.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -4,7 +4,7 @@ use rustc::cfg::CFG;\n use rustc::lint::*;\n use rustc::ty;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use syntax::ast::Attribute;\n use syntax::attr;\n use syntax::codemap::Span;\n@@ -42,7 +42,7 @@ impl LintPass for CyclomaticComplexity {\n }\n \n impl CyclomaticComplexity {\n-    fn check<'a, 'tcx>(&mut self, cx: &'a LateContext<'a, 'tcx>, expr: &Expr, span: Span) {\n+    fn check<'a, 'tcx: 'a>(&mut self, cx: &'a LateContext<'a, 'tcx>, expr: &'tcx Expr, span: Span) {\n         if in_macro(cx, span) {\n             return;\n         }\n@@ -60,7 +60,7 @@ impl CyclomaticComplexity {\n             divergence: 0,\n             short_circuits: 0,\n             returns: 0,\n-            tcx: &cx.tcx,\n+            cx: cx,\n         };\n         helper.visit_expr(expr);\n         let CCHelper { match_arms, divergence, short_circuits, returns, .. } = helper;\n@@ -90,45 +90,45 @@ impl CyclomaticComplexity {\n     }\n }\n \n-impl LateLintPass for CyclomaticComplexity {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if let ItemFn(_, _, _, _, _, ref expr) = item.node {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CyclomaticComplexity {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n+        if let ItemFn(_, _, _, _, _, eid) = item.node {\n             if !attr::contains_name(&item.attrs, \"test\") {\n-                self.check(cx, expr, item.span);\n+                self.check(cx, cx.tcx.map.expr(eid), item.span);\n             }\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n-        if let ImplItemKind::Method(_, ref expr) = item.node {\n-            self.check(cx, expr, item.span);\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n+        if let ImplItemKind::Method(_, eid) = item.node {\n+            self.check(cx, cx.tcx.map.expr(eid), item.span);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n-        if let MethodTraitItem(_, Some(ref expr)) = item.node {\n-            self.check(cx, expr, item.span);\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n+        if let MethodTraitItem(_, Some(eid)) = item.node {\n+            self.check(cx, cx.tcx.map.expr(eid), item.span);\n         }\n     }\n \n-    fn enter_lint_attrs(&mut self, cx: &LateContext, attrs: &[Attribute]) {\n+    fn enter_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n         self.limit.push_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n-    fn exit_lint_attrs(&mut self, cx: &LateContext, attrs: &[Attribute]) {\n+    fn exit_lint_attrs(&mut self, cx: &LateContext<'a, 'tcx>, attrs: &'tcx [Attribute]) {\n         self.limit.pop_attrs(cx.sess(), attrs, \"cyclomatic_complexity\");\n     }\n }\n \n-struct CCHelper<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+struct CCHelper<'a, 'tcx: 'a> {\n     match_arms: u64,\n     divergence: u64,\n     returns: u64,\n     short_circuits: u64, // && and ||\n-    tcx: &'a ty::TyCtxt<'a, 'gcx, 'tcx>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n-    fn visit_expr(&mut self, e: &'a Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for CCHelper<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n             ExprMatch(_, ref arms, _) => {\n                 walk_expr(self, e);\n@@ -139,10 +139,10 @@ impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n             }\n             ExprCall(ref callee, _) => {\n                 walk_expr(self, e);\n-                let ty = self.tcx.tables().node_id_to_type(callee.id);\n+                let ty = self.cx.tcx.tables().node_id_to_type(callee.id);\n                 match ty.sty {\n                     ty::TyFnDef(_, _, ty) |\n-                    ty::TyFnPtr(ty) if ty.sig.skip_binder().output.sty == ty::TyNever => {\n+                    ty::TyFnPtr(ty) if ty.sig.skip_binder().output().sty == ty::TyNever => {\n                         self.divergence += 1;\n                     }\n                     _ => (),\n@@ -160,6 +160,9 @@ impl<'a, 'b, 'tcx, 'gcx> Visitor<'a> for CCHelper<'b, 'gcx, 'tcx> {\n             _ => walk_expr(self, e),\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n #[cfg(feature=\"debugging\")]"}, {"sha": "449227c9767972600bf4d26f1063d67e8503e64d", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -5,7 +5,7 @@ use rustc::ty;\n use rustc::hir::*;\n use syntax::codemap::Span;\n use utils::paths;\n-use utils::{is_automatically_derived, match_path, span_lint_and_then};\n+use utils::{is_automatically_derived, span_lint_and_then, match_path_old};\n \n /// **What it does:** Checks for deriving `Hash` but implementing `PartialEq`\n /// explicitly.\n@@ -70,8 +70,8 @@ impl LintPass for Derive {\n     }\n }\n \n-impl LateLintPass for Derive {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemImpl(_, _, _, Some(ref trait_ref), _, _) = item.node {\n             let ty = cx.tcx.item_type(cx.tcx.map.local_def_id(item.id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n@@ -86,10 +86,10 @@ impl LateLintPass for Derive {\n }\n \n /// Implementation of the `DERIVE_HASH_XOR_EQ` lint.\n-fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>,\n+fn check_hash_peq<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, span: Span, trait_ref: &TraitRef, ty: ty::Ty<'tcx>,\n                                 hash_is_automatically_derived: bool) {\n     if_let_chain! {[\n-        match_path(&trait_ref.path, &paths::HASH),\n+        match_path_old(&trait_ref.path, &paths::HASH),\n         let Some(peq_trait_def_id) = cx.tcx.lang_items.eq_trait()\n     ], {\n         let peq_trait_def = cx.tcx.lookup_trait_def(peq_trait_def_id);\n@@ -131,7 +131,7 @@ fn check_hash_peq<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, span: Span, trait_re\n \n /// Implementation of the `EXPL_IMPL_CLONE_ON_COPY` lint.\n fn check_copy_clone<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, item: &Item, trait_ref: &TraitRef, ty: ty::Ty<'tcx>) {\n-    if match_path(&trait_ref.path, &paths::CLONE_TRAIT) {\n+    if match_path_old(&trait_ref.path, &paths::CLONE_TRAIT) {\n         let parameter_environment = ty::ParameterEnvironment::for_item(cx.tcx, item.id);\n         let subst_ty = ty.subst(cx.tcx, parameter_environment.free_substs);\n "}, {"sha": "106e43e1b6f570a29f0427fb127e5ad24589d2f4", "filename": "clippy_lints/src/drop_ref.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fdrop_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fdrop_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdrop_ref.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -35,11 +35,11 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprCall(ref path, ref args) = expr.node {\n-            if let ExprPath(None, _) = path.node {\n-                let def_id = cx.tcx.expect_def(path.id).def_id();\n+            if let ExprPath(ref qpath) = path.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();\n                 if match_def_path(cx, def_id, &paths::DROP) {\n                     if args.len() != 1 {\n                         return;"}, {"sha": "00a41c2e986cf60ffba1323f67c4fab7e75d5e40", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block};\n+use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, NestedVisitorMap};\n use rustc::lint::*;\n use syntax::codemap::Span;\n use utils::SpanlessEq;\n@@ -39,8 +39,8 @@ impl LintPass for HashMapLint {\n     }\n }\n \n-impl LateLintPass for HashMapLint {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for HashMapLint {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprIf(ref check, ref then_block, ref else_block) = expr.node {\n             if let ExprUnary(UnOp::UnNot, ref check) = check.node {\n                 if let Some((ty, map, key)) = check_cond(cx, check) {\n@@ -111,8 +111,8 @@ struct InsertVisitor<'a, 'tcx: 'a, 'b> {\n     sole_expr: bool,\n }\n \n-impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx, 'b> Visitor<'tcx> for InsertVisitor<'a, 'tcx, 'b> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprMethodCall(ref name, _, ref params) = expr.node,\n             params.len() == 3,\n@@ -144,4 +144,7 @@ impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n             walk_expr(self, expr);\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "f4181da3c2b704b42ceecc201c00cafc640bf76e", "filename": "clippy_lints/src/enum_clike.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fenum_clike.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fenum_clike.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_clike.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -36,9 +36,9 @@ impl LintPass for UnportableVariant {\n     }\n }\n \n-impl LateLintPass for UnportableVariant {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnportableVariant {\n     #[allow(cast_possible_truncation, cast_sign_loss)]\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemEnum(ref def, _) = item.node {\n             for var in &def.variants {\n                 let variant = &var.node;"}, {"sha": "4dafcf365a6c6b4ffe69b0bec724531fad9913cf", "filename": "clippy_lints/src/enum_glob_use.rs", "status": "modified", "additions": 9, "deletions": 23, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fenum_glob_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fenum_glob_use.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,9 +1,7 @@\n //! lint on `use`ing all variants of an enum\n \n use rustc::hir::*;\n-use rustc::hir::def::Def;\n-use rustc::hir::map::Node::NodeItem;\n-use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray, LintContext};\n+use rustc::lint::{LateLintPass, LintPass, LateContext, LintArray};\n use syntax::ast::NodeId;\n use syntax::codemap::Span;\n use utils::span_lint;\n@@ -34,8 +32,8 @@ impl LintPass for EnumGlobUse {\n     }\n }\n \n-impl LateLintPass for EnumGlobUse {\n-    fn check_mod(&mut self, cx: &LateContext, m: &Mod, _: Span, _: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EnumGlobUse {\n+    fn check_mod(&mut self, cx: &LateContext<'a, 'tcx>, m: &'tcx Mod, _: Span, _: NodeId) {\n         // only check top level `use` statements\n         for item in &m.item_ids {\n             self.lint_item(cx, cx.krate.item(item.id));\n@@ -48,24 +46,12 @@ impl EnumGlobUse {\n         if item.vis == Visibility::Public {\n             return; // re-exports are fine\n         }\n-        if let ItemUse(ref item_use) = item.node {\n-            if let ViewPath_::ViewPathGlob(_) = item_use.node {\n-                if let Some(def) = cx.tcx.def_map.borrow().get(&item.id) {\n-                    if let Some(node_id) = cx.tcx.map.as_local_node_id(def.full_def().def_id()) {\n-                        if let Some(NodeItem(it)) = cx.tcx.map.find(node_id) {\n-                            if let ItemEnum(..) = it.node {\n-                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n-                            }\n-                        }\n-                    } else {\n-                        let child = cx.sess().cstore.item_children(def.full_def().def_id());\n-                        if let Some(child) = child.first() {\n-                            if let Def::Variant(..) = child.def {\n-                                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n-                            }\n-                        }\n-                    }\n-                }\n+        if let ItemUse(ref path, UseKind::Glob) = item.node {\n+            // FIXME: ask jseyfried why the qpath.def for `use std::cmp::Ordering::*;`\n+            // extracted through `ItemUse(ref qpath, UseKind::Glob)` is a `Mod` and not an `Enum`\n+            //if let Def::Enum(_) = path.def {\n+            if path.segments.last().and_then(|seg| seg.name.as_str().chars().next()).map_or(false, char::is_uppercase) {\n+                span_lint(cx, ENUM_GLOB_USE, item.span, \"don't use glob imports for enum variants\");\n             }\n         }\n     }"}, {"sha": "c43dfe6e27ca260a49f69e6fd331ce4f74af8c14", "filename": "clippy_lints/src/eq_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feq_op.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -32,8 +32,8 @@ impl LintPass for EqOp {\n     }\n }\n \n-impl LateLintPass for EqOp {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EqOp {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(ref op, ref left, ref right) = e.node {\n             if is_valid_operator(op) && SpanlessEq::new(cx).ignore_fn().eq_expr(left, right) {\n                 span_lint(cx,"}, {"sha": "0ca1f143b16471be926fe2a4b493bf710a7c86d0", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -60,8 +60,16 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, _: visit::FnKind, decl: &FnDecl, body: &Expr, _: Span, id: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: visit::FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        body: &'tcx Expr,\n+        _: Span,\n+        id: NodeId,\n+    ) {\n         let param_env = ty::ParameterEnvironment::for_item(cx.tcx, id);\n \n         let infcx = cx.tcx.borrowck_fake_infer_ctxt(param_env);"}, {"sha": "2bf91f8d1bce109a836dd830935ce6fd099e53ae", "filename": "clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feta_reduction.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -33,8 +33,8 @@ impl LintPass for EtaPass {\n     }\n }\n \n-impl LateLintPass for EtaPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EtaPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         match expr.node {\n             ExprCall(_, ref args) |\n             ExprMethodCall(_, _, ref args) => {\n@@ -48,7 +48,8 @@ impl LateLintPass for EtaPass {\n }\n \n fn check_closure(cx: &LateContext, expr: &Expr) {\n-    if let ExprClosure(_, ref decl, ref ex, _) = expr.node {\n+    if let ExprClosure(_, ref decl, eid, _) = expr.node {\n+        let ex = cx.tcx.map.expr(eid);\n         if let ExprCall(ref caller, ref args) = ex.node {\n             if args.len() != decl.inputs.len() {\n                 // Not the same number of arguments, there\n@@ -65,16 +66,16 @@ fn check_closure(cx: &LateContext, expr: &Expr) {\n                 ty::TyFnDef(_, _, fn_ty) |\n                 ty::TyFnPtr(fn_ty) => {\n                     if fn_ty.unsafety == Unsafety::Unsafe ||\n-                       fn_ty.sig.skip_binder().output.sty == ty::TyNever {\n+                       fn_ty.sig.skip_binder().output().sty == ty::TyNever {\n                         return;\n                     }\n                 }\n                 _ => (),\n             }\n             for (a1, a2) in decl.inputs.iter().zip(args) {\n-                if let PatKind::Binding(_, ident, _) = a1.pat.node {\n+                if let PatKind::Binding(_, _, ident, _) = a1.pat.node {\n                     // XXXManishearth Should I be checking the binding mode here?\n-                    if let ExprPath(None, ref p) = a2.node {\n+                    if let ExprPath(QPath::Resolved(None, ref p)) = a2.node {\n                         if p.segments.len() != 1 {\n                             // If it's a proper path, it can't be a local variable\n                             return;"}, {"sha": "88e1180067a754aa3c90b65497c1e1359a2a7760", "filename": "clippy_lints/src/eval_order_dependence.rs", "status": "modified", "additions": 59, "deletions": 47, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Feval_order_dependence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Feval_order_dependence.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,5 +1,5 @@\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use rustc::hir::*;\n use rustc::ty;\n use rustc::lint::*;\n@@ -56,45 +56,49 @@ impl LintPass for EvalOrderDependence {\n     }\n }\n \n-impl LateLintPass for EvalOrderDependence {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EvalOrderDependence {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // Find a write to a local variable.\n         match expr.node {\n             ExprAssign(ref lhs, _) | ExprAssignOp(_, ref lhs, _) => {\n-                if let ExprPath(None, ref path) = lhs.node {\n-                    if path.segments.len() == 1 {\n-                        let var = cx.tcx.expect_def(lhs.id).def_id();\n-                        let mut visitor = ReadVisitor {\n-                            cx: cx,\n-                            var: var,\n-                            write_expr: expr,\n-                            last_expr: expr,\n-                        };\n-                        check_for_unsequenced_reads(&mut visitor);\n+                if let ExprPath(ref qpath) = lhs.node {\n+                    if let QPath::Resolved(_, ref path) = *qpath {\n+                        if path.segments.len() == 1 {\n+                            let var = cx.tcx.tables().qpath_def(qpath, lhs.id).def_id();\n+                            let mut visitor = ReadVisitor {\n+                                cx: cx,\n+                                var: var,\n+                                write_expr: expr,\n+                                last_expr: expr,\n+                            };\n+                            check_for_unsequenced_reads(&mut visitor);\n+                        }\n                     }\n                 }\n             }\n             _ => {}\n         }\n     }\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         match stmt.node {\n-            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor(cx).maybe_walk_expr(e),\n+            StmtExpr(ref e, _) | StmtSemi(ref e, _) => DivergenceVisitor { cx: cx }.maybe_walk_expr(e),\n             StmtDecl(ref d, _) => {\n                 if let DeclLocal(ref local) = d.node {\n                     if let Local { init: Some(ref e), .. } = **local {\n-                        DivergenceVisitor(cx).visit_expr(e);\n+                        DivergenceVisitor { cx: cx }.visit_expr(e);\n                     }\n                 }\n             },\n         }\n     }\n }\n \n-struct DivergenceVisitor<'a, 'tcx: 'a>(&'a LateContext<'a, 'tcx>);\n+struct DivergenceVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n+}\n \n impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n-    fn maybe_walk_expr(&mut self, e: &Expr) {\n+    fn maybe_walk_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n             ExprClosure(..) => {},\n             ExprMatch(ref e, ref arms, _) => {\n@@ -112,33 +116,33 @@ impl<'a, 'tcx> DivergenceVisitor<'a, 'tcx> {\n     }\n     fn report_diverging_sub_expr(&mut self, e: &Expr) {\n         span_lint(\n-            self.0,\n+            self.cx,\n             DIVERGING_SUB_EXPRESSION,\n             e.span,\n             \"sub-expression diverges\",\n         );\n     }\n }\n \n-impl<'a, 'tcx, 'v> Visitor<'v> for DivergenceVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, e: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for DivergenceVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, e: &'tcx Expr) {\n         match e.node {\n             ExprAgain(_) |\n             ExprBreak(_, _) |\n             ExprRet(_) => self.report_diverging_sub_expr(e),\n-            ExprCall(ref func, _) => match self.0.tcx.tables().expr_ty(func).sty {\n+            ExprCall(ref func, _) => match self.cx.tcx.tables().expr_ty(func).sty {\n                 ty::TyFnDef(_, _, fn_ty) |\n-                ty::TyFnPtr(fn_ty) => if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&fn_ty.sig).output.sty {\n+                ty::TyFnPtr(fn_ty) => if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&fn_ty.sig).output().sty {\n                     self.report_diverging_sub_expr(e);\n                 },\n                 _ => {},\n             },\n             ExprMethodCall(..) => {\n                 let method_call = ty::MethodCall::expr(e.id);\n-                let borrowed_table = self.0.tcx.tables.borrow();\n+                let borrowed_table = self.cx.tcx.tables.borrow();\n                 let method_type = borrowed_table.method_map.get(&method_call).expect(\"This should never happen.\");\n                 let result_ty = method_type.ty.fn_ret();\n-                if let ty::TyNever = self.0.tcx.erase_late_bound_regions(&result_ty).sty {\n+                if let ty::TyNever = self.cx.tcx.erase_late_bound_regions(&result_ty).sty {\n                     self.report_diverging_sub_expr(e);\n                 }\n             },\n@@ -148,9 +152,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DivergenceVisitor<'a, 'tcx> {\n         }\n         self.maybe_walk_expr(e);\n     }\n-    fn visit_block(&mut self, _: &'v Block) {\n+    fn visit_block(&mut self, _: &'tcx Block) {\n         // don't continue over blocks, LateLintPass already does that\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Walks up the AST from the the given write expression (`vis.write_expr`)\n@@ -207,7 +214,7 @@ enum StopEarly {\n     Stop,\n }\n \n-fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEarly {\n+fn check_expr<'a, 'tcx>(vis: & mut ReadVisitor<'a, 'tcx>, expr: &'tcx Expr) -> StopEarly {\n     if expr.id == vis.last_expr.id {\n         return StopEarly::KeepGoing;\n     }\n@@ -256,7 +263,7 @@ fn check_expr<'v, 't>(vis: & mut ReadVisitor<'v, 't>, expr: &'v Expr) -> StopEar\n     StopEarly::KeepGoing\n }\n \n-fn check_stmt<'v, 't>(vis: &mut ReadVisitor<'v, 't>, stmt: &'v Stmt) -> StopEarly {\n+fn check_stmt<'a, 'tcx>(vis: &mut ReadVisitor<'a, 'tcx>, stmt: &'tcx Stmt) -> StopEarly {\n     match stmt.node {\n         StmtExpr(ref expr, _) |\n         StmtSemi(ref expr, _) => check_expr(vis, expr),\n@@ -274,38 +281,40 @@ fn check_stmt<'v, 't>(vis: &mut ReadVisitor<'v, 't>, stmt: &'v Stmt) -> StopEarl\n }\n \n /// A visitor that looks for reads from a variable.\n-struct ReadVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct ReadVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     /// The id of the variable we're looking for.\n     var: DefId,\n     /// The expressions where the write to the variable occurred (for reporting\n     /// in the lint).\n-    write_expr: &'v Expr,\n+    write_expr: &'tcx Expr,\n     /// The last (highest in the AST) expression we've checked, so we know not\n     /// to recheck it.\n-    last_expr: &'v Expr,\n+    last_expr: &'tcx Expr,\n }\n \n-impl<'v, 't> Visitor<'v> for ReadVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for ReadVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if expr.id == self.last_expr.id {\n             return;\n         }\n \n         match expr.node {\n-            ExprPath(None, ref path) => {\n-                if path.segments.len() == 1 && self.cx.tcx.expect_def(expr.id).def_id() == self.var {\n-                    if is_in_assignment_position(self.cx, expr) {\n-                        // This is a write, not a read.\n-                    } else {\n-                        span_note_and_lint(\n-                            self.cx,\n-                            EVAL_ORDER_DEPENDENCE,\n-                            expr.span,\n-                            \"unsequenced read of a variable\",\n-                            self.write_expr.span,\n-                            \"whether read occurs before this write depends on evaluation order\"\n-                        );\n+            ExprPath(ref qpath) => {\n+                if let QPath::Resolved(None, ref path) = *qpath {\n+                    if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n+                        if is_in_assignment_position(self.cx, expr) {\n+                            // This is a write, not a read.\n+                        } else {\n+                            span_note_and_lint(\n+                                self.cx,\n+                                EVAL_ORDER_DEPENDENCE,\n+                                expr.span,\n+                                \"unsequenced read of a variable\",\n+                                self.write_expr.span,\n+                                \"whether read occurs before this write depends on evaluation order\"\n+                            );\n+                        }\n                     }\n                 }\n             }\n@@ -332,6 +341,9 @@ impl<'v, 't> Visitor<'v> for ReadVisitor<'v, 't> {\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Returns true if `expr` is the LHS of an assignment, like `expr = ...`."}, {"sha": "0cf4762364ba27fe7de31039ef6631fa71a5dc87", "filename": "clippy_lints/src/format.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformat.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -38,17 +38,16 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some(span) = is_expn_of(cx, expr.span, \"format\") {\n             match expr.node {\n                 // `format!(\"{}\", foo)` expansion\n                 ExprCall(ref fun, ref args) => {\n                     if_let_chain!{[\n-                        let ExprPath(..) = fun.node,\n+                        let ExprPath(ref qpath) = fun.node,\n                         args.len() == 2,\n-                        let Some(fun) = resolve_node(cx, fun.id),\n-                        match_def_path(cx, fun.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        match_def_path(cx, resolve_node(cx, qpath, fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         // ensure the format string is `\"{..}\"` with only one argument and no text\n                         check_static_str(cx, &args[0]),\n                         // ensure the format argument is `{}` ie. Display with no fancy option\n@@ -129,9 +128,8 @@ fn check_arg_is_display(cx: &LateContext, expr: &Expr) -> bool {\n         exprs.len() == 1,\n         let ExprCall(_, ref args) = exprs[0].node,\n         args.len() == 2,\n-        let ExprPath(None, _) = args[1].node,\n-        let Some(fun) = resolve_node(cx, args[1].id),\n-        match_def_path(cx, fun.def_id(), &paths::DISPLAY_FMT_METHOD),\n+        let ExprPath(ref qpath) = args[1].node,\n+        match_def_path(cx, resolve_node(cx, qpath, args[1].id).def_id(), &paths::DISPLAY_FMT_METHOD),\n     ], {\n         let ty = walk_ptrs_ty(cx.tcx.tables().pat_ty(&pat[0]));\n "}, {"sha": "52461d08ee8d721a3350ae0048eedecb6440a073", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -68,8 +68,16 @@ impl LintPass for Functions {\n     }\n }\n \n-impl LateLintPass for Functions {\n-    fn check_fn(&mut self, cx: &LateContext, kind: intravisit::FnKind, decl: &hir::FnDecl, expr: &hir::Expr, span: Span, nodeid: ast::NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: intravisit::FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        expr: &'tcx hir::Expr,\n+        span: Span,\n+        nodeid: ast::NodeId,\n+    ) {\n         use rustc::hir::map::Node::*;\n \n         let is_impl = if let Some(NodeItem(item)) = cx.tcx.map.find(cx.tcx.map.get_parent_node(nodeid)) {\n@@ -97,21 +105,22 @@ impl LateLintPass for Functions {\n         self.check_raw_ptr(cx, unsafety, decl, expr, nodeid);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n-        if let hir::MethodTraitItem(ref sig, ref expr) = item.node {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n+        if let hir::MethodTraitItem(ref sig, eid) = item.node {\n             // don't lint extern functions decls, it's not their fault\n             if sig.abi == Abi::Rust {\n                 self.check_arg_number(cx, &sig.decl, item.span);\n             }\n \n-            if let Some(ref expr) = *expr {\n+            if let Some(eid) = eid {\n+                let expr = cx.tcx.map.expr(eid);\n                 self.check_raw_ptr(cx, sig.unsafety, &sig.decl, expr, item.id);\n             }\n         }\n     }\n }\n \n-impl Functions {\n+impl<'a, 'tcx> Functions {\n     fn check_arg_number(&self, cx: &LateContext, decl: &hir::FnDecl, span: Span) {\n         let args = decl.inputs.len() as u64;\n         if args > self.threshold {\n@@ -122,7 +131,14 @@ impl Functions {\n         }\n     }\n \n-    fn check_raw_ptr(&self, cx: &LateContext, unsafety: hir::Unsafety, decl: &hir::FnDecl, expr: &hir::Expr, nodeid: ast::NodeId) {\n+    fn check_raw_ptr(\n+        &self,\n+        cx: &LateContext<'a, 'tcx>,\n+        unsafety: hir::Unsafety,\n+        decl: &'tcx hir::FnDecl,\n+        expr: &'tcx hir::Expr,\n+        nodeid: ast::NodeId,\n+    ) {\n         if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n             let raw_ptrs = decl.inputs.iter().filter_map(|arg| raw_ptr_arg(cx, arg)).collect::<HashSet<_>>();\n \n@@ -138,9 +154,9 @@ impl Functions {\n     }\n }\n \n-fn raw_ptr_arg(cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n-    if let (&hir::PatKind::Binding(_, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n-        cx.tcx.def_map.borrow().get(&arg.pat.id).map(|pr| pr.full_def().def_id())\n+fn raw_ptr_arg(_cx: &LateContext, arg: &hir::Arg) -> Option<hir::def_id::DefId> {\n+    if let (&hir::PatKind::Binding(_, def_id, _, _), &hir::TyPtr(_)) = (&arg.pat.node, &arg.ty.node) {\n+        Some(def_id)\n     } else {\n         None\n     }\n@@ -151,8 +167,8 @@ struct DerefVisitor<'a, 'tcx: 'a> {\n     ptrs: HashSet<hir::def_id::DefId>,\n }\n \n-impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for DerefVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprCall(ref f, ref args) => {\n                 let ty = self.cx.tcx.tables().expr_ty(f);\n@@ -179,12 +195,16 @@ impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for DerefVisitor<'a, 'tcx> {\n \n         hir::intravisit::walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n impl<'a, 'tcx: 'a> DerefVisitor<'a, 'tcx> {\n     fn check_arg(&self, ptr: &hir::Expr) {\n-        if let Some(def) = self.cx.tcx.def_map.borrow().get(&ptr.id) {\n-            if self.ptrs.contains(&def.full_def().def_id()) {\n+        if let hir::ExprPath(ref qpath) = ptr.node {\n+            let def = self.cx.tcx.tables().qpath_def(qpath, ptr.id);\n+            if self.ptrs.contains(&def.def_id()) {\n                 span_lint(self.cx,\n                           NOT_UNSAFE_PTR_ARG_DEREF,\n                           ptr.span,"}, {"sha": "547aa23f0de8405bd78da2cd356b8f6420711da0", "filename": "clippy_lints/src/identity_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fidentity_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fidentity_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fidentity_op.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -31,8 +31,8 @@ impl LintPass for IdentityOp {\n     }\n }\n \n-impl LateLintPass for IdentityOp {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for IdentityOp {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if in_macro(cx, e.span) {\n             return;\n         }"}, {"sha": "399b58956bd6334b49dddcc7f67cf4aa588d9de4", "filename": "clippy_lints/src/if_let_redundant_pattern_matching.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fif_let_redundant_pattern_matching.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -42,8 +42,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n \n         if let ExprMatch(ref op, ref arms, MatchSource::IfLetDesugar{..}) = expr.node {\n \n@@ -63,7 +63,7 @@ impl LateLintPass for Pass {\n                         }\n                     }\n \n-                    PatKind::Path(_, ref path) if match_path(path, &paths::OPTION_NONE) => {\n+                    PatKind::Path(ref path) if match_path(path, &paths::OPTION_NONE) => {\n                         \"is_none()\"\n                     }\n "}, {"sha": "0242fb523ee57aa3d1f78a61aeb11b012fa26102", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -59,8 +59,8 @@ impl LintPass for LenZero {\n     }\n }\n \n-impl LateLintPass for LenZero {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LenZero {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if in_macro(cx, item.span) {\n             return;\n         }\n@@ -72,7 +72,7 @@ impl LateLintPass for LenZero {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -188,7 +188,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n         if let ty::AssociatedKind::Method = item.kind {\n             if &*item.name.as_str() == \"is_empty\" {\n                 let ty = cx.tcx.item_type(item.def_id).fn_sig().skip_binder();\n-                ty.inputs.len() == 1\n+                ty.inputs().len() == 1\n             } else {\n                 false\n             }\n@@ -208,7 +208,7 @@ fn has_is_empty(cx: &LateContext, expr: &Expr) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tcx.tables().expr_ty(expr));\n     match ty.sty {\n-        ty::TyTrait(_) => {\n+        ty::TyDynamic(..) => {\n             cx.tcx\n               .associated_items(ty.ty_to_def_id().expect(\"trait impl not found\"))\n               .any(|item| is_is_empty(cx, &item))"}, {"sha": "474a86cdb7884a8c5322aff42edc193e83c9a10e", "filename": "clippy_lints/src/let_if_seq.rs", "status": "modified", "additions": 26, "deletions": 18, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Flet_if_seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Flet_if_seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flet_if_seq.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -57,27 +57,26 @@ impl LintPass for LetIfSeq {\n     }\n }\n \n-impl LateLintPass for LetIfSeq {\n-    fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetIfSeq {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n         let mut it = block.stmts.iter().peekable();\n         while let Some(stmt) = it.next() {\n             if_let_chain! {[\n                 let Some(expr) = it.peek(),\n                 let hir::StmtDecl(ref decl, _) = stmt.node,\n                 let hir::DeclLocal(ref decl) = decl.node,\n-                let hir::PatKind::Binding(mode, ref name, None) = decl.pat.node,\n-                let Some(def) = cx.tcx.def_map.borrow().get(&decl.pat.id),\n+                let hir::PatKind::Binding(mode, def_id, ref name, None) = decl.pat.node,\n                 let hir::StmtExpr(ref if_, _) = expr.node,\n                 let hir::ExprIf(ref cond, ref then, ref else_) = if_.node,\n-                !used_in_expr(cx, def.full_def().def_id(), cond),\n-                let Some(value) = check_assign(cx, def.full_def().def_id(), then),\n-                !used_in_expr(cx, def.full_def().def_id(), value),\n+                !used_in_expr(cx, def_id, cond),\n+                let Some(value) = check_assign(cx, def_id, then),\n+                !used_in_expr(cx, def_id, value),\n             ], {\n                 let span = codemap::mk_sp(stmt.span.lo, if_.span.hi);\n \n                 let (default_multi_stmts, default) = if let Some(ref else_) = *else_ {\n                     if let hir::ExprBlock(ref else_) = else_.node {\n-                        if let Some(default) = check_assign(cx, def.full_def().def_id(), else_) {\n+                        if let Some(default) = check_assign(cx, def_id, else_) {\n                             (else_.stmts.len() > 1, default)\n                         } else if let Some(ref default) = decl.init {\n                             (true, &**default)\n@@ -134,29 +133,34 @@ struct UsedVisitor<'a, 'tcx: 'a> {\n     used: bool,\n }\n \n-impl<'a, 'tcx, 'v> hir::intravisit::Visitor<'v> for UsedVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> hir::intravisit::Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if_let_chain! {[\n-            let hir::ExprPath(None, _) = expr.node,\n-            let Some(def) = self.cx.tcx.def_map.borrow().get(&expr.id),\n-            self.id == def.full_def().def_id(),\n+            let hir::ExprPath(ref qpath) = expr.node,\n+            self.id == self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id(),\n         ], {\n             self.used = true;\n             return;\n         }}\n         hir::intravisit::walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> hir::intravisit::NestedVisitorMap<'this, 'tcx> {\n+        hir::intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn check_assign<'e>(cx: &LateContext, decl: hir::def_id::DefId, block: &'e hir::Block) -> Option<&'e hir::Expr> {\n+fn check_assign<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: hir::def_id::DefId,\n+    block: &'tcx hir::Block,\n+) -> Option<&'tcx hir::Expr> {\n     if_let_chain! {[\n         block.expr.is_none(),\n         let Some(expr) = block.stmts.iter().last(),\n         let hir::StmtSemi(ref expr, _) = expr.node,\n         let hir::ExprAssign(ref var, ref value) = expr.node,\n-        let hir::ExprPath(None, _) = var.node,\n-        let Some(def) = cx.tcx.def_map.borrow().get(&var.id),\n-        decl == def.full_def().def_id(),\n+        let hir::ExprPath(ref qpath) = var.node,\n+        decl == cx.tcx.tables().qpath_def(qpath, var.id).def_id(),\n     ], {\n         let mut v = UsedVisitor {\n             cx: cx,\n@@ -178,7 +182,11 @@ fn check_assign<'e>(cx: &LateContext, decl: hir::def_id::DefId, block: &'e hir::\n     None\n }\n \n-fn used_in_expr(cx: &LateContext, id: hir::def_id::DefId, expr: &hir::Expr) -> bool {\n+fn used_in_expr<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    id: hir::def_id::DefId,\n+    expr: &'tcx hir::Expr,\n+) -> bool {\n     let mut v = UsedVisitor {\n         cx: cx,\n         id: id,"}, {"sha": "b28c78f29d1c43f30e5ba55f485e3364c04b0048", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -9,6 +9,7 @@\n #![feature(repeat_str)]\n \n #![allow(indexing_slicing, shadow_reuse, unknown_lints, missing_docs_in_private_items)]\n+#![allow(needless_lifetimes)]\n \n #[macro_use]\n extern crate syntax;\n@@ -256,7 +257,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box functions::Functions::new(conf.too_many_arguments_threshold));\n     reg.register_early_lint_pass(box doc::Doc::new(conf.doc_valid_idents));\n     reg.register_late_lint_pass(box neg_multiply::NegMultiply);\n-    reg.register_late_lint_pass(box unsafe_removed_from_name::UnsafeNameRemoval);\n+    reg.register_early_lint_pass(box unsafe_removed_from_name::UnsafeNameRemoval);\n     reg.register_late_lint_pass(box mem_forget::MemForget);\n     reg.register_late_lint_pass(box arithmetic::Arithmetic::default());\n     reg.register_late_lint_pass(box assign_ops::AssignOps);"}, {"sha": "60132ad9161c4f6738cd363a7ee56555a3bb7353", "filename": "clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 60, "deletions": 42, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flifetimes.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -2,10 +2,10 @@ use reexport::*;\n use rustc::lint::*;\n use rustc::hir::def::Def;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics};\n+use rustc::hir::intravisit::{Visitor, walk_ty, walk_ty_param_bound, walk_fn_decl, walk_generics, NestedVisitorMap};\n use std::collections::{HashSet, HashMap};\n use syntax::codemap::Span;\n-use utils::{in_external_macro, span_lint};\n+use utils::{in_external_macro, span_lint, last_path_segment};\n \n /// **What it does:** Checks for lifetime annotations which can be removed by\n /// relying on lifetime elision.\n@@ -56,20 +56,20 @@ impl LintPass for LifetimePass {\n     }\n }\n \n-impl LateLintPass for LifetimePass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LifetimePass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemFn(ref decl, _, _, _, ref generics, _) = item.node {\n             check_fn_inner(cx, decl, generics, item.span);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn_inner(cx, &sig.decl, &sig.generics, item.span);\n         }\n@@ -98,7 +98,12 @@ fn bound_lifetimes(bound: &TyParamBound) -> HirVec<&Lifetime> {\n     }\n }\n \n-fn check_fn_inner(cx: &LateContext, decl: &FnDecl, generics: &Generics, span: Span) {\n+fn check_fn_inner<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    decl: &'tcx FnDecl,\n+    generics: &'tcx Generics,\n+    span: Span,\n+) {\n     if in_external_macro(cx, span) || has_where_lifetimes(cx, &generics.where_clause) {\n         return;\n     }\n@@ -116,9 +121,16 @@ fn check_fn_inner(cx: &LateContext, decl: &FnDecl, generics: &Generics, span: Sp\n     report_extra_lifetimes(cx, decl, generics);\n }\n \n-fn could_use_elision<'a, T: Iterator<Item = &'a Lifetime>>(cx: &LateContext, func: &FnDecl,\n-                                                           named_lts: &[LifetimeDef], bounds_lts: T)\n-                                                           -> bool {\n+fn could_use_elision<\n+    'a,\n+    'tcx: 'a,\n+    T: Iterator<Item = &'tcx Lifetime>\n+>(\n+    cx: &LateContext<'a, 'tcx>,\n+    func: &'tcx FnDecl,\n+    named_lts: &'tcx [LifetimeDef],\n+    bounds_lts: T,\n+) -> bool {\n     // There are two scenarios where elision works:\n     // * no output references, all input references have different LT\n     // * output references, exactly one input reference with same LT\n@@ -210,8 +222,8 @@ fn unique_lifetimes(lts: &[RefLt]) -> usize {\n }\n \n /// A visitor usable for `rustc_front::visit::walk_ty()`.\n-struct RefVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct RefVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     lts: Vec<RefLt>,\n }\n \n@@ -239,56 +251,57 @@ impl<'v, 't> RefVisitor<'v, 't> {\n         self.lts\n     }\n \n-    fn collect_anonymous_lifetimes(&mut self, path: &Path, ty: &Ty) {\n-        let last_path_segment = path.segments.last().map(|s| &s.parameters);\n-        if let Some(&AngleBracketedParameters(ref params)) = last_path_segment {\n+    fn collect_anonymous_lifetimes(&mut self, qpath: &QPath, ty: &Ty) {\n+        let last_path_segment = &last_path_segment(qpath).parameters;\n+        if let AngleBracketedParameters(ref params) = *last_path_segment {\n             if params.lifetimes.is_empty() {\n-                if let Some(def) = self.cx.tcx.def_map.borrow().get(&ty.id).map(|r| r.full_def()) {\n-                    match def {\n-                        Def::TyAlias(def_id) |\n-                        Def::Struct(def_id) => {\n-                            let generics = self.cx.tcx.item_generics(def_id);\n-                            for _ in generics.regions.as_slice() {\n-                                self.record(&None);\n-                            }\n+                match self.cx.tcx.tables().qpath_def(qpath, ty.id) {\n+                    Def::TyAlias(def_id) |\n+                    Def::Struct(def_id) => {\n+                        let generics = self.cx.tcx.item_generics(def_id);\n+                        for _ in generics.regions.as_slice() {\n+                            self.record(&None);\n                         }\n-                        Def::Trait(def_id) => {\n-                            let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n-                            for _ in &trait_def.generics.regions {\n-                                self.record(&None);\n-                            }\n+                    }\n+                    Def::Trait(def_id) => {\n+                        let trait_def = self.cx.tcx.trait_defs.borrow()[&def_id];\n+                        for _ in &self.cx.tcx.item_generics(trait_def.def_id).regions {\n+                            self.record(&None);\n                         }\n-                        _ => (),\n                     }\n+                    _ => (),\n                 }\n             }\n         }\n     }\n }\n \n-impl<'v, 't> Visitor<'v> for RefVisitor<'v, 't> {\n+impl<'a, 'tcx> Visitor<'tcx> for RefVisitor<'a, 'tcx> {\n     // for lifetimes as parameters of generics\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n+    fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n         self.record(&Some(*lifetime));\n     }\n \n-    fn visit_ty(&mut self, ty: &'v Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n         match ty.node {\n             TyRptr(None, _) => {\n                 self.record(&None);\n             }\n-            TyPath(_, ref path) => {\n+            TyPath(ref path) => {\n                 self.collect_anonymous_lifetimes(path, ty);\n             }\n             _ => (),\n         }\n         walk_ty(self, ty);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n /// Are any lifetimes mentioned in the `where` clause? If yes, we don't try to\n /// reason about elision.\n-fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n+fn has_where_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, where_clause: &'tcx WhereClause) -> bool {\n     for predicate in &where_clause.predicates {\n         match *predicate {\n             WherePredicate::RegionPredicate(..) => return true,\n@@ -325,34 +338,39 @@ fn has_where_lifetimes(cx: &LateContext, where_clause: &WhereClause) -> bool {\n     false\n }\n \n-struct LifetimeChecker(HashMap<Name, Span>);\n+struct LifetimeChecker {\n+    map: HashMap<Name, Span>,\n+}\n \n-impl<'v> Visitor<'v> for LifetimeChecker {\n+impl<'tcx> Visitor<'tcx> for LifetimeChecker {\n     // for lifetimes as parameters of generics\n-    fn visit_lifetime(&mut self, lifetime: &'v Lifetime) {\n-        self.0.remove(&lifetime.name);\n+    fn visit_lifetime(&mut self, lifetime: &'tcx Lifetime) {\n+        self.map.remove(&lifetime.name);\n     }\n \n-    fn visit_lifetime_def(&mut self, _: &'v LifetimeDef) {\n+    fn visit_lifetime_def(&mut self, _: &'tcx LifetimeDef) {\n         // don't actually visit `<'a>` or `<'a: 'b>`\n         // we've already visited the `'a` declarations and\n         // don't want to spuriously remove them\n         // `'b` in `'a: 'b` is useless unless used elsewhere in\n         // a non-lifetime bound\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::None\n+    }\n }\n \n-fn report_extra_lifetimes(cx: &LateContext, func: &FnDecl, generics: &Generics) {\n+fn report_extra_lifetimes<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, func: &'tcx FnDecl, generics: &'tcx Generics) {\n     let hs = generics.lifetimes\n                      .iter()\n                      .map(|lt| (lt.lifetime.name, lt.lifetime.span))\n                      .collect();\n-    let mut checker = LifetimeChecker(hs);\n+    let mut checker = LifetimeChecker { map: hs };\n \n     walk_generics(&mut checker, generics);\n     walk_fn_decl(&mut checker, func);\n \n-    for &v in checker.0.values() {\n+    for &v in checker.map.values() {\n         span_lint(cx, UNUSED_LIFETIMES, v, \"this lifetime isn't used in the function definition\");\n     }\n }"}, {"sha": "77f2df03a6a405fce66d06fea8592d1d2eb8506b", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 124, "deletions": 79, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -2,7 +2,7 @@ use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n-use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl};\n+use rustc::hir::intravisit::{Visitor, walk_expr, walk_block, walk_decl, NestedVisitorMap};\n use rustc::hir::map::Node::NodeBlock;\n use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n@@ -16,7 +16,7 @@ use utils::sugg;\n \n use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg,\n             in_external_macro, is_refutable, span_help_and_lint, is_integer_literal,\n-            get_enclosing_block, span_lint_and_then, higher, walk_ptrs_ty};\n+            get_enclosing_block, span_lint_and_then, higher, walk_ptrs_ty, last_path_segment};\n use utils::paths;\n \n /// **What it does:** Checks for looping over the range of `0..len` of some\n@@ -307,8 +307,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some((pat, arg, body)) = higher::for_loop(expr) {\n             check_for_loop(cx, pat, arg, body, expr);\n         }\n@@ -366,33 +366,32 @@ impl LateLintPass for Pass {\n         }\n         if let ExprMatch(ref match_expr, ref arms, MatchSource::WhileLetDesugar) = expr.node {\n             let pat = &arms[0].pats[0].node;\n-            if let (&PatKind::TupleStruct(ref path, ref pat_args, _),\n+            if let (&PatKind::TupleStruct(ref qpath, ref pat_args, _),\n                     &ExprMethodCall(method_name, _, ref method_args)) = (pat, &match_expr.node) {\n                 let iter_expr = &method_args[0];\n-                if let Some(lhs_constructor) = path.segments.last() {\n-                    if &*method_name.node.as_str() == \"next\" &&\n-                       match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n-                       &*lhs_constructor.name.as_str() == \"Some\" &&\n-                       !is_refutable(cx, &pat_args[0]) &&\n-                       !is_iterator_used_after_while_let(cx, iter_expr) {\n-                        let iterator = snippet(cx, method_args[0].span, \"_\");\n-                        let loop_var = snippet(cx, pat_args[0].span, \"_\");\n-                        span_lint_and_then(cx,\n-                                           WHILE_LET_ON_ITERATOR,\n-                                           expr.span,\n-                                           \"this loop could be written as a `for` loop\",\n-                                           |db| {\n-                        db.span_suggestion(expr.span,\n-                                           \"try\",\n-                                           format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n-                        });\n-                    }\n+                let lhs_constructor = last_path_segment(qpath);\n+                if &*method_name.node.as_str() == \"next\" &&\n+                   match_trait_method(cx, match_expr, &paths::ITERATOR) &&\n+                   &*lhs_constructor.name.as_str() == \"Some\" &&\n+                   !is_refutable(cx, &pat_args[0]) &&\n+                   !is_iterator_used_after_while_let(cx, iter_expr) {\n+                    let iterator = snippet(cx, method_args[0].span, \"_\");\n+                    let loop_var = snippet(cx, pat_args[0].span, \"_\");\n+                    span_lint_and_then(cx,\n+                                       WHILE_LET_ON_ITERATOR,\n+                                       expr.span,\n+                                       \"this loop could be written as a `for` loop\",\n+                                       |db| {\n+                    db.span_suggestion(expr.span,\n+                                       \"try\",\n+                                       format!(\"for {} in {} {{ .. }}\", loop_var, iterator));\n+                    });\n                 }\n             }\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if let ExprMethodCall(ref method, _, ref args) = expr.node {\n                 if args.len() == 1 && &*method.node.as_str() == \"collect\" &&\n@@ -408,7 +407,13 @@ impl LateLintPass for Pass {\n     }\n }\n \n-fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n     check_for_loop_range(cx, pat, arg, body, expr);\n     check_for_loop_reverse_range(cx, arg, expr);\n     check_for_loop_arg(cx, pat, arg, expr);\n@@ -418,13 +423,19 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n \n /// Check for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n-fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_range<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n     if let Some(higher::Range { start: Some(start), ref end, limits }) = higher::range(arg) {\n         // the var must be a single name\n-        if let PatKind::Binding(_, ref ident, _) = pat.node {\n+        if let PatKind::Binding(_, def_id, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n                 cx: cx,\n-                var: cx.tcx.expect_def(pat.id).def_id(),\n+                var: def_id,\n                 indexed: HashMap::new(),\n                 nonindex: false,\n             };\n@@ -510,7 +521,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n         let ExprMethodCall(method, _, ref len_args) = expr.node,\n         len_args.len() == 1,\n         &*method.node.as_str() == \"len\",\n-        let ExprPath(_, ref path) = len_args[0].node,\n+        let ExprPath(QPath::Resolved(_, ref path)) = len_args[0].node,\n         path.segments.len() == 1,\n         &path.segments[0].name == var\n     ], {\n@@ -647,7 +658,12 @@ fn check_arg_type(cx: &LateContext, pat: &Pat, arg: &Expr) {\n     }\n }\n \n-fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_explicit_counter<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n     // Look for variables that are incremented once per loop iteration.\n     let mut visitor = IncrementVisitor {\n         cx: cx,\n@@ -692,14 +708,20 @@ fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, ex\n }\n \n /// Check for the `FOR_KV_MAP` lint.\n-fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+fn check_for_loop_over_map_kv<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    arg: &'tcx Expr,\n+    body: &'tcx Expr,\n+    expr: &'tcx Expr,\n+) {\n     let pat_span = pat.span;\n \n     if let PatKind::Tuple(ref pat, _) = pat.node {\n         if pat.len() == 2 {\n             let (new_pat_span, kind) = match (&pat[0].node, &pat[1].node) {\n-                (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\"),\n-                (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\"),\n+                (key, _) if pat_is_wild(cx, key, body) => (pat[1].span, \"value\"),\n+                (_, value) if pat_is_wild(cx, value, body) => (pat[0].span, \"key\"),\n                 _ => return,\n             };\n \n@@ -729,13 +751,18 @@ fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Ex\n }\n \n /// Return true if the pattern is a `PatWild` or an ident prefixed with `'_'`.\n-fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n+fn pat_is_wild<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx PatKind,\n+    body: &'tcx Expr,\n+) -> bool {\n     match *pat {\n         PatKind::Wild => true,\n-        PatKind::Binding(_, ident, None) if ident.node.as_str().starts_with('_') => {\n+        PatKind::Binding(_, _, ident, None) if ident.node.as_str().starts_with('_') => {\n             let mut visitor = UsedVisitor {\n                 var: ident.node,\n                 used: false,\n+                cx: cx,\n             };\n             walk_expr(&mut visitor, body);\n             !visitor.used\n@@ -744,14 +771,15 @@ fn pat_is_wild(pat: &PatKind, body: &Expr) -> bool {\n     }\n }\n \n-struct UsedVisitor {\n+struct UsedVisitor<'a, 'tcx: 'a> {\n     var: ast::Name, // var to look for\n     used: bool, // has the var been used otherwise?\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a> Visitor<'a> for UsedVisitor {\n-    fn visit_expr(&mut self, expr: &Expr) {\n-        if let ExprPath(None, ref path) = expr.node {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UsedVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprPath(QPath::Resolved(None, ref path)) = expr.node {\n             if path.segments.len() == 1 && path.segments[0].name == self.var {\n                 self.used = true;\n                 return;\n@@ -760,31 +788,35 @@ impl<'a> Visitor<'a> for UsedVisitor {\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-struct VarVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n+struct VarVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n     var: DefId, // var name to look for as index\n     indexed: HashMap<Name, Option<CodeExtent>>, // indexed variables, the extent is None for global\n     nonindex: bool, // has the var been used otherwise?\n }\n \n-impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n-        if let ExprPath(None, ref path) = expr.node {\n-            if path.segments.len() == 1 && self.cx.tcx.expect_def(expr.id).def_id() == self.var {\n-                // we are referencing our variable! now check if it's as an index\n-                if_let_chain! {[\n-                    let Some(parexpr) = get_parent_expr(self.cx, expr),\n-                    let ExprIndex(ref seqexpr, _) = parexpr.node,\n-                    let ExprPath(None, ref seqvar) = seqexpr.node,\n-                    seqvar.segments.len() == 1\n-                ], {\n-                    let def_map = self.cx.tcx.def_map.borrow();\n-                    if let Some(def) = def_map.get(&seqexpr.id) {\n-                        match def.base_def {\n+impl<'a, 'tcx> Visitor<'tcx> for VarVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n+        if let ExprPath(ref qpath) = expr.node {\n+            if let QPath::Resolved(None, ref path) = *qpath {\n+                if path.segments.len() == 1 && self.cx.tcx.tables().qpath_def(qpath, expr.id).def_id() == self.var {\n+                    // we are referencing our variable! now check if it's as an index\n+                    if_let_chain! {[\n+                        let Some(parexpr) = get_parent_expr(self.cx, expr),\n+                        let ExprIndex(ref seqexpr, _) = parexpr.node,\n+                        let ExprPath(ref seqpath) = seqexpr.node,\n+                        let QPath::Resolved(None, ref seqvar) = *seqpath,\n+                        seqvar.segments.len() == 1\n+                    ], {\n+                        let def = self.cx.tcx.tables().qpath_def(seqpath, seqexpr.id);\n+                        match def {\n                             Def::Local(..) | Def::Upvar(..) => {\n-                                let def_id = def.base_def.def_id();\n+                                let def_id = def.def_id();\n                                 let node_id = self.cx.tcx.map.as_local_node_id(def_id).unwrap();\n \n                                 let extent = self.cx.tcx.region_maps.var_scope(node_id);\n@@ -797,18 +829,21 @@ impl<'v, 't> Visitor<'v> for VarVisitor<'v, 't> {\n                             }\n                             _ => (),\n                         }\n-                    }\n-                }}\n-                // we are not indexing anything, record that\n-                self.nonindex = true;\n-                return;\n+                    }}\n+                    // we are not indexing anything, record that\n+                    self.nonindex = true;\n+                    return;\n+                }\n             }\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn is_iterator_used_after_while_let(cx: &LateContext, iter_expr: &Expr) -> bool {\n+fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, iter_expr: &'tcx Expr) -> bool {\n     let def_id = match var_def_id(cx, iter_expr) {\n         Some(id) => id,\n         None => return false,\n@@ -826,16 +861,16 @@ fn is_iterator_used_after_while_let(cx: &LateContext, iter_expr: &Expr) -> bool\n     visitor.var_used_after_while_let\n }\n \n-struct VarUsedAfterLoopVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>,\n+struct VarUsedAfterLoopVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>,\n     def_id: NodeId,\n     iter_expr_id: NodeId,\n     past_while_let: bool,\n     var_used_after_while_let: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for VarUsedAfterLoopVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.past_while_let {\n             if Some(self.def_id) == var_def_id(self.cx, expr) {\n                 self.var_used_after_while_let = true;\n@@ -845,6 +880,9 @@ impl<'v, 't> Visitor<'v> for VarUsedAfterLoopVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n \n@@ -935,15 +973,15 @@ enum VarState {\n }\n \n /// Scan a for loop for variables that are incremented exactly once.\n-struct IncrementVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n+struct IncrementVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n     states: HashMap<NodeId, VarState>, // incremented variables\n     depth: u32, // depth of conditional expressions\n     done: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.done {\n             return;\n         }\n@@ -984,25 +1022,28 @@ impl<'v, 't> Visitor<'v> for IncrementVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// Check whether a variable is initialized to zero at the start of a loop.\n-struct InitializeVisitor<'v, 't: 'v> {\n-    cx: &'v LateContext<'v, 't>, // context reference\n-    end_expr: &'v Expr, // the for loop. Stop scanning here.\n+struct InitializeVisitor<'a, 'tcx: 'a> {\n+    cx: &'a LateContext<'a, 'tcx>, // context reference\n+    end_expr: &'tcx Expr, // the for loop. Stop scanning here.\n     var_id: NodeId,\n     state: VarState,\n     name: Option<Name>,\n     depth: u32, // depth of conditional expressions\n     past_loop: bool,\n }\n \n-impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n-    fn visit_decl(&mut self, decl: &'v Decl) {\n+impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n+    fn visit_decl(&mut self, decl: &'tcx Decl) {\n         // Look for declarations of the variable\n         if let DeclLocal(ref local) = decl.node {\n             if local.pat.id == self.var_id {\n-                if let PatKind::Binding(_, ref ident, _) = local.pat.node {\n+                if let PatKind::Binding(_, _, ref ident, _) = local.pat.node {\n                     self.name = Some(ident.node);\n \n                     self.state = if let Some(ref init) = local.init {\n@@ -1020,7 +1061,7 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         walk_decl(self, decl);\n     }\n \n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         if self.state == VarState::DontWarn {\n             return;\n         }\n@@ -1068,11 +1109,15 @@ impl<'v, 't> Visitor<'v> for InitializeVisitor<'v, 't> {\n         }\n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n fn var_def_id(cx: &LateContext, expr: &Expr) -> Option<NodeId> {\n-    if let Some(path_res) = cx.tcx.def_map.borrow().get(&expr.id) {\n-        if let Def::Local(def_id) = path_res.base_def {\n+    if let ExprPath(ref qpath) = expr.node {\n+        let path_res = cx.tcx.tables().qpath_def(qpath, expr.id);\n+        if let Def::Local(def_id) = path_res {\n             let node_id = cx.tcx.map.as_local_node_id(def_id).expect(\"That DefId should be valid\");\n             return Some(node_id);\n         }"}, {"sha": "4539c3c8c1054cd64d86fbebc2c04d684cf14984", "filename": "clippy_lints/src/map_clone.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmap_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmap_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmap_clone.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -24,14 +24,14 @@ declare_lint! {\n #[derive(Copy, Clone)]\n pub struct Pass;\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // call to .map()\n         if let ExprMethodCall(name, _, ref args) = expr.node {\n             if &*name.node.as_str() == \"map\" && args.len() == 2 {\n                 match args[1].node {\n-                    ExprClosure(_, ref decl, ref closure_expr, _) => {\n-                        let closure_expr = remove_blocks(closure_expr);\n+                    ExprClosure(_, ref decl, closure_eid, _) => {\n+                        let closure_expr = remove_blocks(cx.tcx.map.expr(closure_eid));\n                         if_let_chain! {[\n                             // nothing special in the argument, besides reference bindings\n                             // (e.g. .map(|&x| x) )\n@@ -64,7 +64,7 @@ impl LateLintPass for Pass {\n                             }\n                         }}\n                     }\n-                    ExprPath(_, ref path) => {\n+                    ExprPath(ref path) => {\n                         if match_path(path, &paths::CLONE) {\n                             let type_name = get_type_name(cx, expr, &args[0]).unwrap_or(\"_\");\n                             span_help_and_lint(cx,\n@@ -85,7 +85,7 @@ impl LateLintPass for Pass {\n \n fn expr_eq_name(expr: &Expr, id: ast::Name) -> bool {\n     match expr.node {\n-        ExprPath(None, ref path) => {\n+        ExprPath(QPath::Resolved(None, ref path)) => {\n             let arg_segment = [PathSegment {\n                                    name: id,\n                                    parameters: PathParameters::none(),\n@@ -108,7 +108,7 @@ fn get_type_name(cx: &LateContext, expr: &Expr, arg: &Expr) -> Option<&'static s\n \n fn get_arg_name(pat: &Pat) -> Option<ast::Name> {\n     match pat.node {\n-        PatKind::Binding(_, name, None) => Some(name.node),\n+        PatKind::Binding(_, _, name, None) => Some(name.node),\n         PatKind::Ref(ref subpat, _) => get_arg_name(subpat),\n         _ => None,\n     }"}, {"sha": "1d59afd9eace101015018c70da50fab46eccfce7", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -129,8 +129,8 @@ impl LintPass for MatchPass {\n     }\n }\n \n-impl LateLintPass for MatchPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MatchPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n@@ -210,8 +210,8 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n             }\n             path.to_string()\n         }\n-        PatKind::Binding(BindByValue(MutImmutable), ident, None) => ident.node.to_string(),\n-        PatKind::Path(None, ref path) => path.to_string(),\n+        PatKind::Binding(BindByValue(MutImmutable), _, ident, None) => ident.node.to_string(),\n+        PatKind::Path(ref path) => path.to_string(),\n         _ => return,\n     };\n "}, {"sha": "55654a7de43b772a1b809f7ef9af0fb7e6f66d04", "filename": "clippy_lints/src/mem_forget.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmem_forget.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmem_forget.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmem_forget.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -27,11 +27,11 @@ impl LintPass for MemForget {\n     }\n }\n \n-impl LateLintPass for MemForget {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MemForget {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(None, _) = path_expr.node {\n-                let def_id = cx.tcx.expect_def(path_expr.id).def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();\n                 if match_def_path(cx, def_id, &paths::MEM_FORGET) {\n                     let forgot_ty = cx.tcx.tables().expr_ty(&args[0]);\n "}, {"sha": "cb8fd62961d86c552de5d5ac51625068baf342be", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -3,14 +3,16 @@ use rustc::lint::*;\n use rustc::middle::const_val::ConstVal;\n use rustc::middle::const_qualif::ConstQualif;\n use rustc::ty;\n+use rustc::hir::def::Def;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use std::borrow::Cow;\n use std::fmt;\n use syntax::codemap::Span;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, is_copy, match_path,\n             match_trait_method, match_type, method_chain_args, return_ty, same_tys, snippet,\n-            span_lint, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n+            span_lint, span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth,\n+            last_path_segment, single_segment_path, match_def_path};\n use utils::paths;\n use utils::sugg;\n \n@@ -547,11 +549,11 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n     #[allow(unused_attributes)]\n     // ^ required because `cyclomatic_complexity` attribute shows up as unused\n     #[cyclomatic_complexity = \"30\"]\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -627,7 +629,7 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, implitem: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, implitem: &'tcx hir::ImplItem) {\n         if in_external_macro(cx, implitem.span) {\n             return;\n         }\n@@ -701,12 +703,8 @@ fn lint_or_fun_call(cx: &LateContext, expr: &hir::Expr, name: &str, args: &[hir:\n         }\n \n         if name == \"unwrap_or\" {\n-            if let hir::ExprPath(_, ref path) = fun.node {\n-                let path: &str = &path.segments\n-                                      .last()\n-                                      .expect(\"A path must have at least one segment\")\n-                                      .name\n-                                      .as_str();\n+            if let hir::ExprPath(ref qpath) = fun.node {\n+                let path: &str = &*last_path_segment(qpath).name.as_str();\n \n                 if [\"default\", \"new\"].contains(&path) {\n                     let arg_ty = cx.tcx.tables().expr_ty(arg);\n@@ -877,8 +875,9 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = new.node,\n         args.len() == 1,\n-        let hir::ExprPath(None, ref path) = fun.node,\n-        match_path(path, &paths::CSTRING_NEW),\n+        let hir::ExprPath(ref path) = fun.node,\n+        let Def::Method(did) = cx.tcx.tables().qpath_def(path, fun.id),\n+        match_def_path(cx, did, &paths::CSTRING_NEW)\n     ], {\n         span_lint_and_then(cx, TEMPORARY_CSTRING_AS_PTR, expr.span,\n                            \"you are getting the inner pointer of a temporary `CString`\",\n@@ -1188,8 +1187,9 @@ fn lint_chars_next(cx: &LateContext, expr: &hir::Expr, chain: &hir::Expr, other:\n         let Some(args) = method_chain_args(chain, &[\"chars\", \"next\"]),\n         let hir::ExprCall(ref fun, ref arg_char) = other.node,\n         arg_char.len() == 1,\n-        let hir::ExprPath(None, ref path) = fun.node,\n-        path.segments.len() == 1 && &*path.segments[0].name.as_str() == \"Some\"\n+        let hir::ExprPath(ref qpath) = fun.node,\n+        let Some(segment) = single_segment_path(qpath),\n+        &*segment.name.as_str() == \"Some\"\n     ], {\n         let self_ty = walk_ptrs_ty(cx.tcx.tables().expr_ty_adjusted(&args[0][0]));\n \n@@ -1408,7 +1408,7 @@ impl OutType {\n }\n \n fn is_bool(ty: &hir::Ty) -> bool {\n-    if let hir::TyPath(None, ref p) = ty.node {\n+    if let hir::TyPath(ref p) = ty.node {\n         match_path(p, &[\"bool\"])\n     } else {\n         false"}, {"sha": "ccfc01a0003089b9b7c55bae9d64c41d39c5f593", "filename": "clippy_lints/src/minmax.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fminmax.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -33,8 +33,8 @@ impl LintPass for MinMaxPass {\n     }\n }\n \n-impl LateLintPass for MinMaxPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MinMaxPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let Some((outer_max, outer_c, oe)) = min_max(cx, expr) {\n             if let Some((inner_max, inner_c, _)) = min_max(cx, oe) {\n                 if outer_max == inner_max {\n@@ -61,8 +61,8 @@ enum MinMax {\n \n fn min_max<'a>(cx: &LateContext, expr: &'a Expr) -> Option<(MinMax, Constant, &'a Expr)> {\n     if let ExprCall(ref path, ref args) = expr.node {\n-        if let ExprPath(None, _) = path.node {\n-            let def_id = cx.tcx.expect_def(path.id).def_id();\n+        if let ExprPath(ref qpath) = path.node {\n+            let def_id = cx.tcx.tables().qpath_def(qpath, path.id).def_id();\n \n             if match_def_path(cx, def_id, &paths::CMP_MIN) {\n                 fetch_const(args, MinMax::Min)"}, {"sha": "0680f6b41a16257185a23ace4b2dac94e7cc5c17", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -10,7 +10,7 @@ use rustc_const_math::ConstFloat;\n use syntax::codemap::{Span, Spanned, ExpnFormat};\n use utils::{\n     get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path,\n-    snippet, span_lint, span_lint_and_then, walk_ptrs_ty\n+    snippet, span_lint, span_lint_and_then, walk_ptrs_ty, last_path_segment\n };\n use utils::sugg::Sugg;\n \n@@ -166,14 +166,14 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, k: FnKind, decl: &FnDecl, _: &Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_fn(&mut self, cx: &LateContext<'a, 'tcx>, k: FnKind<'tcx>, decl: &'tcx FnDecl, _: &'tcx Expr, _: Span, _: NodeId) {\n         if let FnKind::Closure(_) = k {\n             // Does not apply to closures\n             return;\n         }\n         for arg in &decl.inputs {\n-            if let PatKind::Binding(BindByRef(_), _, _) = arg.pat.node {\n+            if let PatKind::Binding(BindByRef(_), _, _, _) = arg.pat.node {\n                 span_lint(cx,\n                           TOPLEVEL_REF_ARG,\n                           arg.pat.span,\n@@ -182,11 +182,11 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, s: &Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, s: &'tcx Stmt) {\n         if_let_chain! {[\n             let StmtDecl(ref d, _) = s.node,\n             let DeclLocal(ref l) = d.node,\n-            let PatKind::Binding(BindByRef(mt), i, None) = l.pat.node,\n+            let PatKind::Binding(BindByRef(mt), _, i, None) = l.pat.node,\n             let Some(ref init) = l.init\n         ], {\n             let init = Sugg::hir(cx, init, \"..\");\n@@ -216,14 +216,14 @@ impl LateLintPass for Pass {\n         }}\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref left, ref right) = expr.node {\n             let op = cmp.node;\n             if op.is_comparison() {\n-                if let ExprPath(_, ref path) = left.node {\n+                if let ExprPath(QPath::Resolved(_, ref path)) = left.node {\n                     check_nan(cx, path, expr.span);\n                 }\n-                if let ExprPath(_, ref path) = right.node {\n+                if let ExprPath(QPath::Resolved(_, ref path)) = right.node {\n                     check_nan(cx, path, expr.span);\n                 }\n                 check_to_owned(cx, left, right, true, cmp.span);\n@@ -262,18 +262,14 @@ impl LateLintPass for Pass {\n             return;\n         }\n         let binding = match expr.node {\n-            ExprPath(_, ref path) => {\n-                let binding = path.segments\n-                    .last()\n-                    .expect(\"path should always have at least one segment\")\n-                    .name\n-                    .as_str();\n+            ExprPath(ref qpath) => {\n+                let binding = last_path_segment(qpath).name.as_str();\n                 if binding.starts_with('_') &&\n                     !binding.starts_with(\"__\") &&\n                     &*binding != \"_result\" && // FIXME: #944\n                     is_used(cx, expr) &&\n                     // don't lint if the declaration is in a macro\n-                    non_macro_local(cx, &cx.tcx.expect_def(expr.id)) {\n+                    non_macro_local(cx, &cx.tcx.tables().qpath_def(qpath, expr.id)) {\n                     Some(binding)\n                 } else {\n                     None\n@@ -298,8 +294,8 @@ impl LateLintPass for Pass {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n-        if let PatKind::Binding(_, ref ident, Some(ref right)) = pat.node {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n+        if let PatKind::Binding(_, _, ref ident, Some(ref right)) = pat.node {\n             if right.node == PatKind::Wild {\n                 span_lint(cx,\n                           REDUNDANT_PATTERN,\n@@ -366,7 +362,7 @@ fn check_to_owned(cx: &LateContext, expr: &Expr, other: &Expr, left: bool, op: S\n             }\n         }\n         ExprCall(ref path, ref v) if v.len() == 1 => {\n-            if let ExprPath(None, ref path) = path.node {\n+            if let ExprPath(ref path) = path.node {\n                 if match_path(path, &[\"String\", \"from_str\"]) || match_path(path, &[\"String\", \"from\"]) {\n                     (cx.tcx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n@@ -444,9 +440,7 @@ fn in_attributes_expansion(cx: &LateContext, expr: &Expr) -> bool {\n fn non_macro_local(cx: &LateContext, def: &def::Def) -> bool {\n     match *def {\n         def::Def::Local(id) | def::Def::Upvar(id, _, _) => {\n-            let id = cx.tcx.map.as_local_node_id(id).expect(\"That DefId should be valid\");\n-\n-            if let Some(span) = cx.tcx.map.opt_span(id) {\n+            if let Some(span) = cx.tcx.map.span_if_local(id) {\n                 !in_macro(cx, span)\n             } else {\n                 true"}, {"sha": "2f3bdeb053c8fe3406f72939fe5215efbd54e8a9", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -94,8 +94,8 @@ impl LintPass for MissingDoc {\n     }\n }\n \n-impl LateLintPass for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n+    fn enter_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, attrs: &'tcx [ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n@@ -105,15 +105,15 @@ impl LateLintPass for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &LateContext, _: &[ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx [ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext<'a, 'tcx>, krate: &'tcx hir::Crate) {\n         self.check_missing_docs_attrs(cx, &krate.attrs, krate.span, \"crate\");\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, it: &'tcx hir::Item) {\n         let desc = match it.node {\n             hir::ItemConst(..) => \"a constant\",\n             hir::ItemEnum(..) => \"an enum\",\n@@ -134,7 +134,7 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, trait_item: &'tcx hir::TraitItem) {\n         let desc = match trait_item.node {\n             hir::ConstTraitItem(..) => \"an associated constant\",\n             hir::MethodTraitItem(..) => \"a trait method\",\n@@ -144,7 +144,7 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &trait_item.attrs, trait_item.span, desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n         let def_id = cx.tcx.map.local_def_id(impl_item.id);\n         match cx.tcx.associated_item(def_id).container {\n@@ -164,13 +164,13 @@ impl LateLintPass for MissingDoc {\n         self.check_missing_docs_attrs(cx, &impl_item.attrs, impl_item.span, desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, sf: &'tcx hir::StructField) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(cx, &sf.attrs, sf.span, \"a struct field\");\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, v: &'tcx hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx, &v.node.attrs, v.span, \"a variant\");\n     }\n }"}, {"sha": "40bb77871dbc641caaa23351c44474c078261507", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -31,12 +31,12 @@ impl LintPass for MutMut {\n     }\n }\n \n-impl LateLintPass for MutMut {\n-    fn check_block(&mut self, cx: &LateContext, block: &hir::Block) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutMut {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx hir::Block) {\n         intravisit::walk_block(&mut MutVisitor { cx: cx }, block);\n     }\n \n-    fn check_ty(&mut self, cx: &LateContext, ty: &hir::Ty) {\n+    fn check_ty(&mut self, cx: &LateContext<'a, 'tcx>, ty: &'tcx hir::Ty) {\n         use rustc::hir::intravisit::Visitor;\n \n         MutVisitor { cx: cx }.visit_ty(ty);\n@@ -47,8 +47,8 @@ pub struct MutVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n-    fn visit_expr(&mut self, expr: &'v hir::Expr) {\n+impl<'a, 'tcx> intravisit::Visitor<'tcx> for MutVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         if in_external_macro(self.cx, expr.span) {\n             return;\n         }\n@@ -74,7 +74,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_ty(&mut self, ty: &hir::Ty) {\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty) {\n         if let hir::TyRptr(_, hir::MutTy { ty: ref pty, mutbl: hir::MutMutable }) = ty.node {\n             if let hir::TyRptr(_, hir::MutTy { mutbl: hir::MutMutable, .. }) = pty.node {\n                 span_lint(self.cx, MUT_MUT, ty.span, \"generally you want to avoid `&mut &mut _` if possible\");\n@@ -84,4 +84,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n \n         intravisit::walk_ty(self, ty);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> intravisit::NestedVisitorMap<'this, 'tcx> {\n+        intravisit::NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "d2cd0a329143d8aac88c8de403c9972699c0bd81", "filename": "clippy_lints/src/mut_reference.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmut_reference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmut_reference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_reference.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -32,8 +32,8 @@ impl LintPass for UnnecessaryMutPassed {\n     }\n }\n \n-impl LateLintPass for UnnecessaryMutPassed {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnecessaryMutPassed {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         let borrowed_table = cx.tcx.tables.borrow();\n         match e.node {\n             ExprCall(ref fn_expr, ref arguments) => {\n@@ -42,7 +42,7 @@ impl LateLintPass for UnnecessaryMutPassed {\n                                                   .expect(\"A function with an unknown type is called. \\\n                                                            If this happened, the compiler would have \\\n                                                            aborted the compilation long ago\");\n-                if let ExprPath(_, ref path) = fn_expr.node {\n+                if let ExprPath(ref path) = fn_expr.node {\n                     check_arguments(cx, arguments, function_type, &path.to_string());\n                 }\n             }\n@@ -60,7 +60,7 @@ fn check_arguments(cx: &LateContext, arguments: &[Expr], type_definition: &TyS,\n     match type_definition.sty {\n         TypeVariants::TyFnDef(_, _, fn_type) |\n         TypeVariants::TyFnPtr(fn_type) => {\n-            let parameters = &fn_type.sig.skip_binder().inputs;\n+            let parameters = fn_type.sig.skip_binder().inputs();\n             for (argument, parameter) in arguments.iter().zip(parameters.iter()) {\n                 match parameter.sty {\n                     TypeVariants::TyRef(_, TypeAndMut { mutbl: MutImmutable, .. }) |"}, {"sha": "8d927110b9d22494495c35ed84660e256a1e2c1b", "filename": "clippy_lints/src/mutex_atomic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fmutex_atomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmutex_atomic.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -54,8 +54,8 @@ impl LintPass for MutexAtomic {\n \n pub struct MutexAtomic;\n \n-impl LateLintPass for MutexAtomic {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutexAtomic {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         let ty = cx.tcx.tables().expr_ty(expr);\n         if let ty::TyAdt(_, subst) = ty.sty {\n             if match_type(cx, ty, &paths::MUTEX) {"}, {"sha": "3b08ebdbc8e04d03f252e6e17b1470afe4caa5ba", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -56,8 +56,8 @@ impl LintPass for NeedlessBool {\n     }\n }\n \n-impl LateLintPass for NeedlessBool {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBool {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n             let reduce = |ret, not| {\n@@ -116,8 +116,8 @@ impl LintPass for BoolComparison {\n     }\n }\n \n-impl LateLintPass for BoolComparison {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoolComparison {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use self::Expression::*;\n         if let ExprBinary(Spanned { node: BiEq, .. }, ref left_side, ref right_side) = e.node {\n             match (fetch_bool_expr(left_side), fetch_bool_expr(right_side)) {"}, {"sha": "935e0da8c3edcd43c7e3ae595aa5b974d56945ca", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -34,8 +34,8 @@ impl LintPass for NeedlessBorrow {\n     }\n }\n \n-impl LateLintPass for NeedlessBorrow {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if in_macro(cx, e.span) {\n             return;\n         }\n@@ -53,11 +53,11 @@ impl LateLintPass for NeedlessBorrow {\n             }\n         }\n     }\n-    fn check_pat(&mut self, cx: &LateContext, pat: &Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'a, 'tcx>, pat: &'tcx Pat) {\n         if in_macro(cx, pat.span) {\n             return;\n         }\n-        if let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _) = pat.node {\n+        if let PatKind::Binding(BindingMode::BindByRef(MutImmutable), _, _, _) = pat.node {\n             if let ty::TyRef(_, ref tam) = cx.tcx.tables().pat_ty(pat).sty {\n                 if tam.mutbl == MutImmutable {\n                     if let ty::TyRef(..) = tam.ty.sty {"}, {"sha": "de6277aa0ee5c8cefc6daaa9b8b019dff197ca4c", "filename": "clippy_lints/src/needless_update.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fneedless_update.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fneedless_update.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_update.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -30,8 +30,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprStruct(_, ref fields, Some(ref base)) = expr.node {\n             let ty = cx.tcx.tables().expr_ty(expr);\n             if let TyAdt(def, _) = ty.sty {"}, {"sha": "05a6a92c9e9da5a76e359fd72f6cebc66b931854", "filename": "clippy_lints/src/neg_multiply.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fneg_multiply.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fneg_multiply.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneg_multiply.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -31,8 +31,8 @@ impl LintPass for NegMultiply {\n }\n \n #[allow(match_same_arms)]\n-impl LateLintPass for NegMultiply {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NegMultiply {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(Spanned { node: BiMul, .. }, ref l, ref r) = e.node {\n             match (&l.node, &r.node) {\n                 (&ExprUnary(..), &ExprUnary(..)) => (),"}, {"sha": "f4a7ebee590f9f91cb0cc7e38ecf09a81e7c5168", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -89,8 +89,16 @@ impl LintPass for NewWithoutDefault {\n     }\n }\n \n-impl LateLintPass for NewWithoutDefault {\n-    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, _: &hir::Expr, span: Span, id: ast::NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        _: &'tcx hir::Expr,\n+        span: Span,\n+        id: ast::NodeId,\n+    ) {\n         if in_external_macro(cx, span) {\n             return;\n         }"}, {"sha": "4a4b73b697f82cee0e8e9fa9225f149e5fed786f", "filename": "clippy_lints/src/no_effect.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fno_effect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fno_effect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fno_effect.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,5 +1,5 @@\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n-use rustc::hir::def::{Def, PathResolution};\n+use rustc::hir::def::Def;\n use rustc::hir::{Expr, Expr_, Stmt, StmtSemi, BlockCheckMode, UnsafeSource};\n use utils::{in_macro, span_lint, snippet_opt, span_lint_and_then};\n use std::ops::Deref;\n@@ -68,13 +68,17 @@ fn has_no_effect(cx: &LateContext, expr: &Expr) -> bool {\n             }\n         }\n         Expr_::ExprCall(ref callee, ref args) => {\n-            let def = cx.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-            match def {\n-                Some(Def::Struct(..)) |\n-                Some(Def::Variant(..)) |\n-                Some(Def::StructCtor(..)) |\n-                Some(Def::VariantCtor(..)) => args.iter().all(|arg| has_no_effect(cx, arg)),\n-                _ => false,\n+            if let Expr_::ExprPath(ref qpath) = callee.node {\n+                let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n+                match def {\n+                    Def::Struct(..) |\n+                    Def::Variant(..) |\n+                    Def::StructCtor(..) |\n+                    Def::VariantCtor(..) => args.iter().all(|arg| has_no_effect(cx, arg)),\n+                    _ => false,\n+                }\n+            } else {\n+                false\n             }\n         }\n         Expr_::ExprBlock(ref block) => {\n@@ -98,8 +102,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &Stmt) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx Stmt) {\n         if let StmtSemi(ref expr, _) = stmt.node {\n             if has_no_effect(cx, expr) {\n                 span_lint(cx, NO_EFFECT, stmt.span, \"statement with no effect\");\n@@ -146,12 +150,17 @@ fn reduce_expression<'a>(cx: &LateContext, expr: &'a Expr) -> Option<Vec<&'a Exp\n             Some(fields.iter().map(|f| &f.expr).chain(base).map(Deref::deref).collect())\n         }\n         Expr_::ExprCall(ref callee, ref args) => {\n-            match cx.tcx.def_map.borrow().get(&callee.id).map(PathResolution::full_def) {\n-                Some(Def::Struct(..)) |\n-                Some(Def::Variant(..)) |\n-                Some(Def::StructCtor(..)) |\n-                Some(Def::VariantCtor(..)) => Some(args.iter().collect()),\n-                _ => None,\n+            if let Expr_::ExprPath(ref qpath) = callee.node {\n+                let def = cx.tcx.tables().qpath_def(qpath, callee.id);\n+                match def {\n+                    Def::Struct(..) |\n+                    Def::Variant(..) |\n+                    Def::StructCtor(..) |\n+                    Def::VariantCtor(..) => Some(args.iter().collect()),\n+                    _ => None,\n+                }\n+            } else {\n+                None\n             }\n         }\n         Expr_::ExprBlock(ref block) => {"}, {"sha": "6ccdb6ee14593ff481c1f8ca8389a41f482681b5", "filename": "clippy_lints/src/non_expressive_names.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fnon_expressive_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_expressive_names.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -59,9 +59,9 @@ struct ExistingName {\n     whitelist: &'static [&'static str],\n }\n \n-struct SimilarNamesLocalVisitor<'a, 'b: 'a> {\n+struct SimilarNamesLocalVisitor<'a, 'tcx: 'a> {\n     names: Vec<ExistingName>,\n-    cx: &'a EarlyContext<'b>,\n+    cx: &'a EarlyContext<'tcx>,\n     lint: &'a NonExpressiveNames,\n     single_char_names: Vec<char>,\n }\n@@ -76,10 +76,10 @@ const WHITELIST: &'static [&'static [&'static str]] = &[\n     &[\"set\", \"get\"],\n ];\n \n-struct SimilarNamesNameVisitor<'a, 'b: 'a, 'c: 'b>(&'a mut SimilarNamesLocalVisitor<'b, 'c>);\n+struct SimilarNamesNameVisitor<'a: 'b, 'tcx: 'a, 'b>(&'b mut SimilarNamesLocalVisitor<'a, 'tcx>);\n \n-impl<'a, 'b, 'c> Visitor for SimilarNamesNameVisitor<'a, 'b, 'c> {\n-    fn visit_pat(&mut self, pat: &Pat) {\n+impl<'a, 'tcx: 'a, 'b> Visitor<'tcx> for SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n+    fn visit_pat(&mut self, pat: &'tcx Pat) {\n         match pat.node {\n             PatKind::Ident(_, id, _) => self.check_name(id.span, id.node.name),\n             PatKind::Struct(_, ref fields, _) => {\n@@ -120,7 +120,7 @@ fn whitelisted(interned_name: &str, list: &[&str]) -> bool {\n     false\n }\n \n-impl<'a, 'b, 'c> SimilarNamesNameVisitor<'a, 'b, 'c> {\n+impl<'a, 'tcx, 'b> SimilarNamesNameVisitor<'a, 'tcx, 'b> {\n     fn check_short_name(&mut self, c: char, span: Span) {\n         // make sure we ignore shadowing\n         if self.0.single_char_names.contains(&c) {\n@@ -236,18 +236,18 @@ impl<'a, 'b> SimilarNamesLocalVisitor<'a, 'b> {\n     }\n }\n \n-impl<'a, 'b> Visitor for SimilarNamesLocalVisitor<'a, 'b> {\n-    fn visit_local(&mut self, local: &Local) {\n+impl<'a, 'tcx> Visitor<'tcx> for SimilarNamesLocalVisitor<'a, 'tcx> {\n+    fn visit_local(&mut self, local: &'tcx Local) {\n         if let Some(ref init) = local.init {\n             self.apply(|this| walk_expr(this, &**init));\n         }\n         // add the pattern after the expression because the bindings aren't available yet in the init expression\n         SimilarNamesNameVisitor(self).visit_pat(&*local.pat);\n     }\n-    fn visit_block(&mut self, blk: &Block) {\n+    fn visit_block(&mut self, blk: &'tcx Block) {\n         self.apply(|this| walk_block(this, blk));\n     }\n-    fn visit_arm(&mut self, arm: &Arm) {\n+    fn visit_arm(&mut self, arm: &'tcx Arm) {\n         self.apply(|this| {\n             // just go through the first pattern, as either all patterns bind the same bindings or rustc would have errored much earlier\n             SimilarNamesNameVisitor(this).visit_pat(&arm.pats[0]);"}, {"sha": "6ac49c1f575d0886c23ae6141396f28d00140120", "filename": "clippy_lints/src/ok_if_let.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fok_if_let.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fok_if_let.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fok_if_let.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -40,13 +40,13 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[ //begin checking variables\n             let ExprMatch(ref op, ref body, ref source) = expr.node, //test if expr is a match\n             let MatchSource::IfLetDesugar { .. } = *source, //test if it is an If Let\n             let ExprMethodCall(_, _, ref result_types) = op.node, //check is expr.ok() has type Result<T,E>.ok()\n-            let PatKind::TupleStruct(ref x, ref y, _)  = body[0].pats[0].node, //get operation\n+            let PatKind::TupleStruct(QPath::Resolved(_, ref x), ref y, _)  = body[0].pats[0].node, //get operation\n             method_chain_args(op, &[\"ok\"]).is_some() //test to see if using ok() methoduse std::marker::Sized;\n \n         ], {"}, {"sha": "f102bdcab33d7bf77e1dd983666c8a1b7e44e2a5", "filename": "clippy_lints/src/open_options.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fopen_options.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fopen_options.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fopen_options.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -32,8 +32,8 @@ impl LintPass for NonSensical {\n     }\n }\n \n-impl LateLintPass for NonSensical {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSensical {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprMethodCall(ref name, _, ref arguments) = e.node {\n             let (obj_ty, _) = walk_ptrs_ty_depth(cx.tcx.tables().expr_ty(&arguments[0]));\n             if &*name.node.as_str() == \"open\" && match_type(cx, obj_ty, &paths::OPEN_OPTIONS) {"}, {"sha": "a09ff3bebf6837d86ea4d524beee09775b8b7ec9", "filename": "clippy_lints/src/overflow_check_conditional.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Foverflow_check_conditional.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -29,15 +29,15 @@ impl LintPass for OverflowCheckConditional {\n     }\n }\n \n-impl LateLintPass for OverflowCheckConditional {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for OverflowCheckConditional {\n     // a + b < a, a > a + b, a < a - b, a - b > a\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n             let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = first.node,\n-            let Expr_::ExprPath(_,ref path1) = ident1.node,\n-            let Expr_::ExprPath(_, ref path2) = ident2.node,\n-            let Expr_::ExprPath(_, ref path3) = second.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = second.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n             cx.tcx.tables().expr_ty(ident1).is_integral(),\n             cx.tcx.tables().expr_ty(ident2).is_integral()\n@@ -57,9 +57,9 @@ impl LateLintPass for OverflowCheckConditional {\n         if_let_chain! {[\n             let Expr_::ExprBinary(ref op, ref first, ref second) = expr.node,\n             let Expr_::ExprBinary(ref op2, ref ident1, ref ident2) = second.node,\n-            let Expr_::ExprPath(_,ref path1) = ident1.node,\n-            let Expr_::ExprPath(_, ref path2) = ident2.node,\n-            let Expr_::ExprPath(_, ref path3) = first.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path1)) = ident1.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path2)) = ident2.node,\n+            let Expr_::ExprPath(QPath::Resolved(_, ref path3)) = first.node,\n             &path1.segments[0] == &path3.segments[0] || &path2.segments[0] == &path3.segments[0],\n             cx.tcx.tables().expr_ty(ident1).is_integral(),\n             cx.tcx.tables().expr_ty(ident2).is_integral()"}, {"sha": "3b4fbb3ab1b6da937baaeb9cf2739dd64f3542a2", "filename": "clippy_lints/src/panic.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpanic.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -32,16 +32,15 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprBlock(ref block) = expr.node,\n             let Some(ref ex) = block.expr,\n             let ExprCall(ref fun, ref params) = ex.node,\n             params.len() == 2,\n-            let ExprPath(None, _) = fun.node,\n-            let Some(fun) = resolve_node(cx, fun.id),\n-            match_def_path(cx, fun.def_id(), &paths::BEGIN_PANIC),\n+            let ExprPath(ref qpath) = fun.node,\n+            match_def_path(cx, resolve_node(cx, qpath, fun.id).def_id(), &paths::BEGIN_PANIC),\n             let ExprLit(ref lit) = params[0].node,\n             is_direct_expn_of(cx, params[0].span, \"panic\").is_some(),\n             let LitKind::Str(ref string, _) = lit.node,"}, {"sha": "2677b40f757a9d4d57ce363d9d1b44ae28760321", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -35,12 +35,12 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if_let_chain! {[\n             let ItemImpl(_, _, _, Some(ref trait_ref), _, ref impl_items) = item.node,\n             !is_automatically_derived(&*item.attrs),\n-            cx.tcx.expect_def(trait_ref.ref_id).def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n+            trait_ref.path.def.def_id() == cx.tcx.lang_items.eq_trait().unwrap(),\n         ], {\n             for impl_item in impl_items {\n                 if &*impl_item.name.as_str() == \"ne\" {"}, {"sha": "daa55c9675fcb029b6427384ab2bffe37d042b77", "filename": "clippy_lints/src/print.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fprint.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -2,7 +2,7 @@ use rustc::hir::*;\n use rustc::hir::map::Node::{NodeItem, NodeImplItem};\n use rustc::lint::*;\n use utils::paths;\n-use utils::{is_expn_of, match_path, match_def_path, resolve_node, span_lint};\n+use utils::{is_expn_of, match_def_path, resolve_node, span_lint, match_path_old};\n use format::get_argument_fmtstr_parts;\n \n /// **What it does:** This lint warns when you using `print!()` with a format string that\n@@ -65,13 +65,13 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain! {[\n             let ExprCall(ref fun, ref args) = expr.node,\n-            let ExprPath(..) = fun.node,\n-            let Some(fun) = resolve_node(cx, fun.id),\n+            let ExprPath(ref qpath) = fun.node,\n         ], {\n+            let fun = resolve_node(cx, qpath, fun.id);\n             let fun_id = fun.def_id();\n \n             // Search for `std::io::_print(..)` which is unique in a\n@@ -93,9 +93,8 @@ impl LateLintPass for Pass {\n                         // ensure we're calling Arguments::new_v1\n                         args.len() == 1,\n                         let ExprCall(ref args_fun, ref args_args) = args[0].node,\n-                        let ExprPath(..) = args_fun.node,\n-                        let Some(def) = resolve_node(cx, args_fun.id),\n-                        match_def_path(cx, def.def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n+                        let ExprPath(ref qpath) = args_fun.node,\n+                        match_def_path(cx, resolve_node(cx, qpath, args_fun.id).def_id(), &paths::FMT_ARGUMENTS_NEWV1),\n                         args_args.len() == 2,\n                         let ExprAddrOf(_, ref match_expr) = args_args[1].node,\n                         let ExprMatch(ref args, _, _) = match_expr.node,\n@@ -121,8 +120,8 @@ impl LateLintPass for Pass {\n             // Search for something like\n             // `::std::fmt::ArgumentV1::new(__arg0, ::std::fmt::Debug::fmt)`\n             else if args.len() == 2 && match_def_path(cx, fun_id, &paths::FMT_ARGUMENTV1_NEW) {\n-                if let ExprPath(None, _) = args[1].node {\n-                    let def_id = resolve_node(cx, args[1].id).unwrap().def_id();\n+                if let ExprPath(ref qpath) = args[1].node {\n+                    let def_id = cx.tcx.tables().qpath_def(qpath, args[1].id).def_id();\n                     if match_def_path(cx, def_id, &paths::DEBUG_FMT_METHOD) && !is_in_debug_impl(cx, expr) &&\n                        is_expn_of(cx, expr.span, \"panic\").is_none() {\n                         span_lint(cx, USE_DEBUG, args[0].span, \"use of `Debug`-based formatting\");\n@@ -141,7 +140,7 @@ fn is_in_debug_impl(cx: &LateContext, expr: &Expr) -> bool {\n         // `Debug` impl\n         if let Some(NodeItem(item)) = map.find(map.get_parent(item.id)) {\n             if let ItemImpl(_, _, _, Some(ref tr), _, _) = item.node {\n-                return match_path(&tr.path, &[\"Debug\"]);\n+                return match_path_old(&tr.path, &[\"Debug\"]);\n             }\n         }\n     }"}, {"sha": "1461189946c15005f63413258675265e8141795c", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -54,14 +54,14 @@ impl LintPass for PointerPass {\n     }\n }\n \n-impl LateLintPass for PointerPass {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemFn(ref decl, _, _, _, _, _) = item.node {\n             check_fn(cx, decl, item.id);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, _) = item.node {\n             if let Some(NodeItem(it)) = cx.tcx.map.find(cx.tcx.map.get_parent(item.id)) {\n                 if let ItemImpl(_, _, _, Some(_), _, _) = it.node {\n@@ -72,13 +72,13 @@ impl LateLintPass for PointerPass {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         if let MethodTraitItem(ref sig, _) = item.node {\n             check_fn(cx, &sig.decl, item.id);\n         }\n     }\n-    \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref op, ref l, ref r) = expr.node {\n             if (op.node == BiEq || op.node == BiNe) && (is_null_path(l) || is_null_path(r)) {\n                 span_lint(cx,\n@@ -94,7 +94,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n     let fn_def_id = cx.tcx.map.local_def_id(fn_id);\n     let fn_ty = cx.tcx.item_type(fn_def_id).fn_sig().skip_binder();\n \n-    for (arg, ty) in decl.inputs.iter().zip(&fn_ty.inputs) {\n+    for (arg, ty) in decl.inputs.iter().zip(fn_ty.inputs()) {\n         if let ty::TyRef(_, ty::TypeAndMut { ty, mutbl: MutImmutable }) = ty.sty {\n             if match_type(cx, ty, &paths::VEC) {\n                 span_lint(cx,\n@@ -116,7 +116,7 @@ fn check_fn(cx: &LateContext, decl: &FnDecl, fn_id: NodeId) {\n fn is_null_path(expr: &Expr) -> bool {\n     if let ExprCall(ref pathexp, ref args) = expr.node {\n         if args.is_empty() {\n-            if let ExprPath(_, ref path) = pathexp.node {\n+            if let ExprPath(ref path) = pathexp.node {\n                 return match_path(path, &paths::PTR_NULL) || match_path(path, &paths::PTR_NULL_MUT)\n             }\n         }"}, {"sha": "78f09700203982fa56262f149ce758aab426774f", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -46,8 +46,8 @@ impl LintPass for StepByZero {\n     }\n }\n \n-impl LateLintPass for StepByZero {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StepByZero {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprMethodCall(Spanned { node: ref name, .. }, _, ref args) = expr.node {\n             let name = &*name.as_str();\n \n@@ -73,15 +73,15 @@ impl LateLintPass for StepByZero {\n                     let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,\n                     &*len_name.as_str() == \"len\" && len_args.len() == 1,\n                     // .iter() and .len() called on same Path\n-                    let ExprPath(_, Path { segments: ref iter_path, .. }) = iter_args[0].node,\n-                    let ExprPath(_, Path { segments: ref len_path, .. }) = len_args[0].node,\n-                    iter_path == len_path\n+                    let ExprPath(QPath::Resolved(_, ref iter_path)) = iter_args[0].node,\n+                    let ExprPath(QPath::Resolved(_, ref len_path)) = len_args[0].node,\n+                    iter_path.segments == len_path.segments\n                  ], {\n-                    span_lint(cx,\n-                              RANGE_ZIP_WITH_LEN,\n-                              expr.span,\n-                              &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n-                                       snippet(cx, iter_args[0].span, \"_\")));\n+                     span_lint(cx,\n+                               RANGE_ZIP_WITH_LEN,\n+                               expr.span,\n+                               &format!(\"It is more idiomatic to use {}.iter().enumerate()\",\n+                                        snippet(cx, iter_args[0].span, \"_\")));\n                 }}\n             }\n         }"}, {"sha": "6e6b6156d6e69e47c6f7a32879764704b1745fed", "filename": "clippy_lints/src/regex.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fregex.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -82,12 +82,12 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_crate(&mut self, _: &LateContext, _: &Crate) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_crate(&mut self, _: &LateContext<'a, 'tcx>, _: &'tcx Crate) {\n         self.spans.clear();\n     }\n \n-    fn check_block(&mut self, cx: &LateContext, block: &Block) {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         if_let_chain!{[\n             self.last.is_none(),\n             let Some(ref expr) = block.expr,\n@@ -106,19 +106,19 @@ impl LateLintPass for Pass {\n         }}\n     }\n \n-    fn check_block_post(&mut self, _: &LateContext, block: &Block) {\n+    fn check_block_post(&mut self, _: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         if self.last.map_or(false, |id| block.id == id) {\n             self.last = None;\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if_let_chain!{[\n             let ExprCall(ref fun, ref args) = expr.node,\n+            let ExprPath(ref qpath) = fun.node,\n             args.len() == 1,\n-            let Some(def) = cx.tcx.def_map.borrow().get(&fun.id),\n         ], {\n-            let def_id = def.full_def().def_id();\n+            let def_id = cx.tcx.tables().qpath_def(qpath, fun.id).def_id();\n             if match_def_path(cx, def_id, &paths::REGEX_NEW) ||\n                match_def_path(cx, def_id, &paths::REGEX_BUILDER_NEW) {\n                 check_regex(cx, &args[0], true);"}, {"sha": "ec4bce5570618a8db30f26c05e55f739627cf724", "filename": "clippy_lints/src/serde.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fserde.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fserde.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fserde.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -26,10 +26,10 @@ impl LintPass for Serde {\n     }\n }\n \n-impl LateLintPass for Serde {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Serde {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemImpl(_, _, _, Some(ref trait_ref), _, ref items) = item.node {\n-            let did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n+            let did = trait_ref.path.def.def_id();\n             if let Some(visit_did) = get_trait_def_id(cx, &paths::SERDE_DE_VISITOR) {\n                 if did == visit_did {\n                     let mut seen_str = None;"}, {"sha": "2d32a87927415bf97028c25a65d45877005badcd", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 61, "deletions": 38, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,9 +1,8 @@\n use reexport::*;\n use rustc::lint::*;\n-use rustc::hir::def::Def;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, FnKind};\n-use std::ops::Deref;\n+use rustc::hir::intravisit::{Visitor, FnKind, NestedVisitorMap};\n+use rustc::ty;\n use syntax::codemap::Span;\n use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n \n@@ -80,26 +79,34 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, expr: &Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        _: FnKind<'tcx>,\n+        decl: &'tcx FnDecl,\n+        expr: &'tcx Expr,\n+        _: Span,\n+        _: NodeId,\n+    ) {\n         if in_external_macro(cx, expr.span) {\n             return;\n         }\n         check_fn(cx, decl, expr);\n     }\n }\n \n-fn check_fn(cx: &LateContext, decl: &FnDecl, expr: &Expr) {\n+fn check_fn<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl, expr: &'tcx Expr) {\n     let mut bindings = Vec::new();\n     for arg in &decl.inputs {\n-        if let PatKind::Binding(_, ident, _) = arg.pat.node {\n+        if let PatKind::Binding(_, _, ident, _) = arg.pat.node {\n             bindings.push((ident.node, ident.span))\n         }\n     }\n     check_expr(cx, expr, &mut bindings);\n }\n \n-fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>) {\n+fn check_block<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, block: &'tcx Block, bindings: &mut Vec<(Name, Span)>) {\n     let len = bindings.len();\n     for stmt in &block.stmts {\n         match stmt.node {\n@@ -114,7 +121,7 @@ fn check_block(cx: &LateContext, block: &Block, bindings: &mut Vec<(Name, Span)>\n     bindings.truncate(len);\n }\n \n-fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n+fn check_decl<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, decl.span) {\n         return;\n     }\n@@ -128,27 +135,33 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n         }\n         if let Some(ref o) = *init {\n             check_expr(cx, o, bindings);\n-            check_pat(cx, pat, &Some(o), span, bindings);\n+            check_pat(cx, pat, Some(o), span, bindings);\n         } else {\n-            check_pat(cx, pat, &None, span, bindings);\n+            check_pat(cx, pat, None, span, bindings);\n         }\n     }\n }\n \n-fn is_binding(cx: &LateContext, pat: &Pat) -> bool {\n-    match cx.tcx.def_map.borrow().get(&pat.id).map(|d| d.full_def()) {\n-        Some(Def::Variant(..)) |\n-        Some(Def::Struct(..)) => false,\n+fn is_binding(cx: &LateContext, pat_id: NodeId) -> bool {\n+    let var_ty = cx.tcx.tables().node_id_to_type(pat_id);\n+    match var_ty.sty {\n+        ty::TyAdt(..) => false,\n         _ => true,\n     }\n }\n \n-fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bindings: &mut Vec<(Name, Span)>) {\n+fn check_pat<'a, 'tcx>(\n+    cx: &LateContext<'a, 'tcx>,\n+    pat: &'tcx Pat,\n+    init: Option<&'tcx Expr>,\n+    span: Span,\n+    bindings: &mut Vec<(Name, Span)>,\n+) {\n     // TODO: match more stuff / destructuring\n     match pat.node {\n-        PatKind::Binding(_, ref ident, ref inner) => {\n+        PatKind::Binding(_, _, ref ident, ref inner) => {\n             let name = ident.node;\n-            if is_binding(cx, pat) {\n+            if is_binding(cx, pat.id) {\n                 let mut new_binding = true;\n                 for tup in bindings.iter_mut() {\n                     if tup.0 == name {\n@@ -167,14 +180,14 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n             }\n         }\n         PatKind::Struct(_, ref pfields, _) => {\n-            if let Some(init_struct) = *init {\n+            if let Some(init_struct) = init {\n                 if let ExprStruct(_, ref efields, _) = init_struct.node {\n                     for field in pfields {\n                         let name = field.node.name;\n                         let efield = efields.iter()\n                                             .find(|f| f.name.node == name)\n                                             .map(|f| &*f.expr);\n-                        check_pat(cx, &field.node.pat, &efield, span, bindings);\n+                        check_pat(cx, &field.node.pat, efield, span, bindings);\n                     }\n                 } else {\n                     for field in pfields {\n@@ -183,15 +196,15 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 }\n             } else {\n                 for field in pfields {\n-                    check_pat(cx, &field.node.pat, &None, span, bindings);\n+                    check_pat(cx, &field.node.pat, None, span, bindings);\n                 }\n             }\n         }\n         PatKind::Tuple(ref inner, _) => {\n-            if let Some(init_tup) = *init {\n+            if let Some(init_tup) = init {\n                 if let ExprTup(ref tup) = init_tup.node {\n                     for (i, p) in inner.iter().enumerate() {\n-                        check_pat(cx, p, &Some(&tup[i]), p.span, bindings);\n+                        check_pat(cx, p, Some(&tup[i]), p.span, bindings);\n                     }\n                 } else {\n                     for p in inner {\n@@ -200,14 +213,14 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n                 }\n             } else {\n                 for p in inner {\n-                    check_pat(cx, p, &None, span, bindings);\n+                    check_pat(cx, p, None, span, bindings);\n                 }\n             }\n         }\n         PatKind::Box(ref inner) => {\n-            if let Some(initp) = *init {\n+            if let Some(initp) = init {\n                 if let ExprBox(ref inner_init) = initp.node {\n-                    check_pat(cx, inner, &Some(&**inner_init), span, bindings);\n+                    check_pat(cx, inner, Some(&**inner_init), span, bindings);\n                 } else {\n                     check_pat(cx, inner, init, span, bindings);\n                 }\n@@ -221,10 +234,15 @@ fn check_pat(cx: &LateContext, pat: &Pat, init: &Option<&Expr>, span: Span, bind\n     }\n }\n \n-fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span, init: &Option<T>, prev_span: Span)\n-    where T: Deref<Target = Expr>\n-{\n-    if let Some(ref expr) = *init {\n+fn lint_shadow<'a, 'tcx: 'a>(\n+    cx: &LateContext<'a, 'tcx>,\n+    name: Name,\n+    span: Span,\n+    pattern_span: Span,\n+    init: Option<&'tcx Expr>,\n+    prev_span: Span,\n+) {\n+    if let Some(expr) = init {\n         if is_self_shadow(name, expr) {\n             span_lint_and_then(cx,\n                                SHADOW_SAME,\n@@ -234,7 +252,7 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span,\n                                         snippet(cx, expr.span, \"..\")),\n                                |db| { db.span_note(prev_span, \"previous binding is here\"); },\n             );\n-        } else if contains_self(name, expr) {\n+        } else if contains_self(cx, name, expr) {\n             span_lint_and_then(cx,\n                                SHADOW_REUSE,\n                                pattern_span,\n@@ -267,7 +285,7 @@ fn lint_shadow<T>(cx: &LateContext, name: Name, span: Span, pattern_span: Span,\n     }\n }\n \n-fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n+fn check_expr<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, expr.span) {\n         return;\n     }\n@@ -302,7 +320,7 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n             let len = bindings.len();\n             for arm in arms {\n                 for pat in &arm.pats {\n-                    check_pat(cx, pat, &Some(&**init), pat.span, bindings);\n+                    check_pat(cx, pat, Some(&**init), pat.span, bindings);\n                     // This is ugly, but needed to get the right type\n                     if let Some(ref guard) = arm.guard {\n                         check_expr(cx, guard, bindings);\n@@ -316,7 +334,7 @@ fn check_expr(cx: &LateContext, expr: &Expr, bindings: &mut Vec<(Name, Span)>) {\n     }\n }\n \n-fn check_ty(cx: &LateContext, ty: &Ty, bindings: &mut Vec<(Name, Span)>) {\n+fn check_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty, bindings: &mut Vec<(Name, Span)>) {\n     match ty.node {\n         TyObjectSum(ref sty, _) |\n         TySlice(ref sty) => check_ty(cx, sty, bindings),\n@@ -344,7 +362,7 @@ fn is_self_shadow(name: Name, expr: &Expr) -> bool {\n             block.stmts.is_empty() && block.expr.as_ref().map_or(false, |e| is_self_shadow(name, e))\n         }\n         ExprUnary(op, ref inner) => (UnDeref == op) && is_self_shadow(name, inner),\n-        ExprPath(_, ref path) => path_eq_name(name, path),\n+        ExprPath(QPath::Resolved(_, ref path)) => path_eq_name(name, path),\n         _ => false,\n     }\n }\n@@ -353,23 +371,28 @@ fn path_eq_name(name: Name, path: &Path) -> bool {\n     !path.global && path.segments.len() == 1 && path.segments[0].name.as_str() == name.as_str()\n }\n \n-struct ContainsSelf {\n+struct ContainsSelf<'a, 'tcx: 'a> {\n     name: Name,\n     result: bool,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for ContainsSelf {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for ContainsSelf<'a, 'tcx> {\n     fn visit_name(&mut self, _: Span, name: Name) {\n         if self.name == name {\n             self.result = true;\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n-fn contains_self(name: Name, expr: &Expr) -> bool {\n+fn contains_self<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, name: Name, expr: &'tcx Expr) -> bool {\n     let mut cs = ContainsSelf {\n         name: name,\n         result: false,\n+        cx: cx,\n     };\n     cs.visit_expr(expr);\n     cs.result"}, {"sha": "01f2f66c2fdebd640475fc79779aece980c56375", "filename": "clippy_lints/src/strings.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fstrings.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -79,8 +79,8 @@ impl LintPass for StringAdd {\n     }\n }\n \n-impl LateLintPass for StringAdd {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringAdd {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprBinary(Spanned { node: BiAdd, .. }, ref left, _) = e.node {\n             if is_string(cx, left) {\n                 if let Allow = cx.current_level(STRING_ADD_ASSIGN) {\n@@ -136,8 +136,8 @@ impl LintPass for StringLitAsBytes {\n     }\n }\n \n-impl LateLintPass for StringLitAsBytes {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for StringLitAsBytes {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         use std::ascii::AsciiExt;\n         use syntax::ast::LitKind;\n         use utils::{snippet, in_macro};"}, {"sha": "7393ee3890e5cf35670c6f1836edaa757dbecf9b", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -50,8 +50,8 @@ impl LintPass for Swap {\n     }\n }\n \n-impl LateLintPass for Swap {\n-    fn check_block(&mut self, cx: &LateContext, block: &Block) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Swap {\n+    fn check_block(&mut self, cx: &LateContext<'a, 'tcx>, block: &'tcx Block) {\n         check_manual_swap(cx, block);\n         check_suspicious_swap(cx, block);\n     }\n@@ -65,7 +65,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             let StmtDecl(ref tmp, _) = w[0].node,\n             let DeclLocal(ref tmp) = tmp.node,\n             let Some(ref tmp_init) = tmp.init,\n-            let PatKind::Binding(_, ref tmp_name, None) = tmp.pat.node,\n+            let PatKind::Binding(_, _, ref tmp_name, None) = tmp.pat.node,\n \n             // foo() = bar();\n             let StmtSemi(ref first, _) = w[1].node,\n@@ -74,7 +74,7 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             // bar() = t;\n             let StmtSemi(ref second, _) = w[2].node,\n             let ExprAssign(ref lhs2, ref rhs2) = second.node,\n-            let ExprPath(None, ref rhs2) = rhs2.node,\n+            let ExprPath(QPath::Resolved(None, ref rhs2)) = rhs2.node,\n             rhs2.segments.len() == 1,\n \n             tmp_name.node.as_str() == rhs2.segments[0].name.as_str(),"}, {"sha": "2f6e6d97fbf7ef5566354397905c3adecd802f70", "filename": "clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -37,8 +37,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprAssign(ref target, _) = expr.node {\n             match target.node {\n                 ExprField(ref base, _) |"}, {"sha": "b6731db93839cac2aab4823a9e3d5f6a5ffd4e4a", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -2,7 +2,7 @@ use rustc::lint::*;\n use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet};\n+use utils::{match_def_path, paths, span_lint, span_lint_and_then, snippet, last_path_segment};\n use utils::sugg;\n \n /// **What it does:** Checks for transmutes that can't ever be correct on any\n@@ -84,11 +84,11 @@ impl LintPass for Transmute {\n     }\n }\n \n-impl LateLintPass for Transmute {\n-    fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Transmute {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, e: &'tcx Expr) {\n         if let ExprCall(ref path_expr, ref args) = e.node {\n-            if let ExprPath(None, ref path) = path_expr.node {\n-                let def_id = cx.tcx.expect_def(path_expr.id).def_id();\n+            if let ExprPath(ref qpath) = path_expr.node {\n+                let def_id = cx.tcx.tables().qpath_def(qpath, path_expr.id).def_id();\n \n                 if match_def_path(cx, def_id, &paths::TRANSMUTE) {\n                     let from_ty = cx.tcx.tables().expr_ty(&args[0]);\n@@ -173,7 +173,7 @@ impl LateLintPass for Transmute {\n                                 let arg = if from_pty.ty == to_rty.ty {\n                                     arg\n                                 } else {\n-                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, path, to_rty.ty)))\n+                                    arg.as_ty(&format!(\"{} {}\", cast, get_type_snippet(cx, qpath, to_rty.ty)))\n                                 };\n \n                                 db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n@@ -190,9 +190,9 @@ impl LateLintPass for Transmute {\n /// Get the snippet of `Bar` in `\u2026::transmute<Foo, &Bar>`. If that snippet is not available , use\n /// the type's `ToString` implementation. In weird cases it could lead to types with invalid `'_`\n /// lifetime, but it should be rare.\n-fn get_type_snippet(cx: &LateContext, path: &Path, to_rty: ty::Ty) -> String {\n+fn get_type_snippet(cx: &LateContext, path: &QPath, to_rty: ty::Ty) -> String {\n+    let seg = last_path_segment(path);\n     if_let_chain!{[\n-        let Some(seg) = path.segments.last(),\n         let PathParameters::AngleBracketedParameters(ref ang) = seg.parameters,\n         let Some(to_ty) = ang.types.get(1),\n         let TyRptr(_, ref to_ty) = to_ty.node,"}, {"sha": "d2bc850e2078ddc217e935894334c26dd20c51ee", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 48, "deletions": 42, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,13 +1,13 @@\n use reexport::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{FnKind, Visitor, walk_ty};\n+use rustc::hir::intravisit::{FnKind, Visitor, walk_ty, NestedVisitorMap};\n use rustc::lint::*;\n use rustc::ty;\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet,\n-            span_help_and_lint, span_lint};\n+            span_help_and_lint, span_lint, opt_def_id, last_path_segment};\n use utils::paths;\n \n /// Handles all the linting of funky types\n@@ -69,35 +69,36 @@ impl LintPass for TypePass {\n     }\n }\n \n-impl LateLintPass for TypePass {\n-    fn check_ty(&mut self, cx: &LateContext, ast_ty: &Ty) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypePass {\n+    fn check_ty(&mut self, cx: &LateContext<'a, 'tcx>, ast_ty: &'tcx Ty) {\n         if in_macro(cx, ast_ty.span) {\n             return;\n         }\n-        if let Some(did) = cx.tcx.def_map.borrow().get(&ast_ty.id) {\n-            if let def::Def::Struct(..) = did.full_def() {\n-                if Some(did.full_def().def_id()) == cx.tcx.lang_items.owned_box() {\n+        if let TyPath(ref qpath) = ast_ty.node {\n+            let def = cx.tcx.tables().qpath_def(qpath, ast_ty.id);\n+            if let Some(def_id) = opt_def_id(def) {\n+                if Some(def_id) == cx.tcx.lang_items.owned_box() {\n+                    let last = last_path_segment(qpath);\n                     if_let_chain! {[\n-                        let TyPath(_, ref path) = ast_ty.node,\n-                        let Some(ref last) = path.segments.last(),\n                         let PathParameters::AngleBracketedParameters(ref ag) = last.parameters,\n                         let Some(ref vec) = ag.types.get(0),\n-                        let Some(did) = cx.tcx.def_map.borrow().get(&vec.id),\n-                        let def::Def::Struct(..) = did.full_def(),\n-                        match_def_path(cx, did.full_def().def_id(), &paths::VEC),\n+                        let TyPath(ref qpath) = vec.node,\n+                        let def::Def::Struct(..) = cx.tcx.tables().qpath_def(qpath, vec.id),\n+                        let Some(did) = opt_def_id(cx.tcx.tables().qpath_def(qpath, vec.id)),\n+                        match_def_path(cx, did, &paths::VEC),\n                     ], {\n                         span_help_and_lint(cx,\n                                            BOX_VEC,\n                                            ast_ty.span,\n                                            \"you seem to be trying to use `Box<Vec<T>>`. Consider using just `Vec<T>`\",\n                                            \"`Vec<T>` is already on the heap, `Box<Vec<T>>` makes an extra allocation.\");\n                     }}\n-                } else if match_def_path(cx, did.full_def().def_id(), &paths::LINKED_LIST) {\n+                } else if match_def_path(cx, def_id, &paths::LINKED_LIST) {\n                     span_help_and_lint(cx,\n-                                       LINKEDLIST,\n-                                       ast_ty.span,\n-                                       \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n-                                       \"a VecDeque might work\");\n+                                        LINKEDLIST,\n+                                        ast_ty.span,\n+                                        \"I see you're using a LinkedList! Perhaps you meant some other data structure?\",\n+                                        \"a VecDeque might work\");\n                 }\n             }\n         }\n@@ -152,8 +153,8 @@ impl LintPass for LetPass {\n     }\n }\n \n-impl LateLintPass for LetPass {\n-    fn check_decl(&mut self, cx: &LateContext, decl: &Decl) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LetPass {\n+    fn check_decl(&mut self, cx: &LateContext<'a, 'tcx>, decl: &'tcx Decl) {\n         check_let_unit(cx, decl)\n     }\n }\n@@ -189,8 +190,8 @@ impl LintPass for UnitCmp {\n     }\n }\n \n-impl LateLintPass for UnitCmp {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnitCmp {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if in_macro(cx, expr.span) {\n             return;\n         }\n@@ -446,8 +447,8 @@ impl LintPass for CastPass {\n     }\n }\n \n-impl LateLintPass for CastPass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CastPass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprCast(ref ex, _) = expr.node {\n             let (cast_from, cast_to) = (cx.tcx.tables().expr_ty(ex), cx.tcx.tables().expr_ty(expr));\n             if cast_from.is_numeric() && cast_to.is_numeric() && !in_external_macro(cx, expr.span) {\n@@ -534,17 +535,17 @@ impl LintPass for TypeComplexityPass {\n     }\n }\n \n-impl LateLintPass for TypeComplexityPass {\n-    fn check_fn(&mut self, cx: &LateContext, _: FnKind, decl: &FnDecl, _: &Expr, _: Span, _: NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeComplexityPass {\n+    fn check_fn(&mut self, cx: &LateContext<'a, 'tcx>, _: FnKind<'tcx>, decl: &'tcx FnDecl, _: &'tcx Expr, _: Span, _: NodeId) {\n         self.check_fndecl(cx, decl);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx StructField) {\n         // enum variants are also struct fields now\n         self.check_type(cx, &field.ty);\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         match item.node {\n             ItemStatic(ref ty, _, _) |\n             ItemConst(ref ty, _) => self.check_type(cx, ty),\n@@ -553,7 +554,7 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx TraitItem) {\n         match item.node {\n             ConstTraitItem(ref ty, _) |\n             TypeTraitItem(_, Some(ref ty)) => self.check_type(cx, ty),\n@@ -563,7 +564,7 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         match item.node {\n             ImplItemKind::Const(ref ty, _) |\n             ImplItemKind::Type(ref ty) => self.check_type(cx, ty),\n@@ -572,15 +573,15 @@ impl LateLintPass for TypeComplexityPass {\n         }\n     }\n \n-    fn check_local(&mut self, cx: &LateContext, local: &Local) {\n+    fn check_local(&mut self, cx: &LateContext<'a, 'tcx>, local: &'tcx Local) {\n         if let Some(ref ty) = local.ty {\n             self.check_type(cx, ty);\n         }\n     }\n }\n \n-impl TypeComplexityPass {\n-    fn check_fndecl(&self, cx: &LateContext, decl: &FnDecl) {\n+impl<'a, 'tcx> TypeComplexityPass {\n+    fn check_fndecl(&self, cx: &LateContext<'a, 'tcx>, decl: &'tcx FnDecl) {\n         for arg in &decl.inputs {\n             self.check_type(cx, &arg.ty);\n         }\n@@ -589,14 +590,15 @@ impl TypeComplexityPass {\n         }\n     }\n \n-    fn check_type(&self, cx: &LateContext, ty: &Ty) {\n+    fn check_type(&self, cx: &LateContext<'a, 'tcx>, ty: &'tcx Ty) {\n         if in_macro(cx, ty.span) {\n             return;\n         }\n         let score = {\n             let mut visitor = TypeComplexityVisitor {\n                 score: 0,\n                 nest: 1,\n+                cx: cx,\n             };\n             visitor.visit_ty(ty);\n             visitor.score\n@@ -612,15 +614,16 @@ impl TypeComplexityPass {\n }\n \n /// Walks a type and assigns a complexity score to it.\n-struct TypeComplexityVisitor {\n+struct TypeComplexityVisitor<'a, 'tcx: 'a> {\n     /// total complexity score of the type\n     score: u64,\n     /// current nesting level\n     nest: u64,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v> Visitor<'v> for TypeComplexityVisitor {\n-    fn visit_ty(&mut self, ty: &'v Ty) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for TypeComplexityVisitor<'a, 'tcx> {\n+    fn visit_ty(&mut self, ty: &'tcx Ty) {\n         let (add_score, sub_nest) = match ty.node {\n             // _, &x and *x have only small overhead; don't mess with nesting level\n             TyInfer | TyPtr(..) | TyRptr(..) => (1, 0),\n@@ -645,6 +648,9 @@ impl<'v> Visitor<'v> for TypeComplexityVisitor {\n         walk_ty(self, ty);\n         self.nest -= sub_nest;\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }\n \n /// **What it does:** Checks for expressions where a character literal is cast\n@@ -676,8 +682,8 @@ impl LintPass for CharLitAsU8 {\n     }\n }\n \n-impl LateLintPass for CharLitAsU8 {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CharLitAsU8 {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use syntax::ast::{LitKind, UintTy};\n \n         if let ExprCast(ref e, _) = expr.node {\n@@ -840,8 +846,8 @@ fn detect_extreme_expr<'a>(cx: &LateContext, expr: &'a Expr) -> Option<ExtremeEx\n     })\n }\n \n-impl LateLintPass for AbsurdExtremeComparisons {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for AbsurdExtremeComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         use types::ExtremeType::*;\n         use types::AbsurdComparisonResult::*;\n \n@@ -1065,8 +1071,8 @@ fn upcast_comparison_bounds_err(cx: &LateContext, span: &Span, rel: comparisons:\n     }\n }\n \n-impl LateLintPass for InvalidUpcastComparisons {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidUpcastComparisons {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprBinary(ref cmp, ref lhs, ref rhs) = expr.node {\n \n             let normalized = comparisons::normalize_comparison(cmp.node, lhs, rhs);"}, {"sha": "1d5ab7db3461c2749f857305df20031303125150", "filename": "clippy_lints/src/unicode.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funicode.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -68,8 +68,8 @@ impl LintPass for Unicode {\n     }\n }\n \n-impl LateLintPass for Unicode {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Unicode {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         if let ExprLit(ref lit) = expr.node {\n             if let LitKind::Str(_, _) = lit.node {\n                 check_str(cx, lit.span)"}, {"sha": "341848a868cd6fb344d3661452e0ab7706c1882a", "filename": "clippy_lints/src/unsafe_removed_from_name.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funsafe_removed_from_name.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,6 +1,5 @@\n-use rustc::hir::*;\n use rustc::lint::*;\n-use syntax::ast::Name;\n+use syntax::ast::*;\n use syntax::codemap::Span;\n use syntax::symbol::InternedString;\n use utils::span_lint;\n@@ -34,16 +33,16 @@ impl LintPass for UnsafeNameRemoval {\n     }\n }\n \n-impl LateLintPass for UnsafeNameRemoval {\n-    fn check_item(&mut self, cx: &LateContext, item: &Item) {\n-        if let ItemUse(ref item_use) = item.node {\n+impl EarlyLintPass for UnsafeNameRemoval {\n+    fn check_item(&mut self, cx: &EarlyContext, item: &Item) {\n+        if let ItemKind::Use(ref item_use) = item.node {\n             match item_use.node {\n                 ViewPath_::ViewPathSimple(ref name, ref path) => {\n                     unsafe_to_safe_check(\n                         path.segments\n                             .last()\n                             .expect(\"use paths cannot be empty\")\n-                            .name,\n+                            .identifier,\n                         *name,\n                         cx, &item.span\n                         );\n@@ -62,9 +61,9 @@ impl LateLintPass for UnsafeNameRemoval {\n     }\n }\n \n-fn unsafe_to_safe_check(old_name: Name, new_name: Name, cx: &LateContext, span: &Span) {\n-    let old_str = old_name.as_str();\n-    let new_str = new_name.as_str();\n+fn unsafe_to_safe_check(old_name: Ident, new_name: Ident, cx: &EarlyContext, span: &Span) {\n+    let old_str = old_name.name.as_str();\n+    let new_str = new_name.name.as_str();\n     if contains_unsafe(&old_str) && !contains_unsafe(&new_str) {\n         span_lint(cx,\n                   UNSAFE_REMOVED_FROM_NAME,"}, {"sha": "4f1e01af6e9f1e0458269a4c17f977a4fbb8a858", "filename": "clippy_lints/src/unused_label.rs", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Funused_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Funused_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Funused_label.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir;\n-use rustc::hir::intravisit::{FnKind, Visitor, walk_expr, walk_fn};\n+use rustc::hir::intravisit::{FnKind, Visitor, walk_expr, walk_fn, NestedVisitorMap};\n use std::collections::HashMap;\n use syntax::ast;\n use syntax::codemap::Span;\n@@ -29,15 +29,9 @@ declare_lint! {\n \n pub struct UnusedLabel;\n \n-#[derive(Default)]\n-struct UnusedLabelVisitor {\n+struct UnusedLabelVisitor<'a, 'tcx: 'a> {\n     labels: HashMap<InternedString, Span>,\n-}\n-\n-impl UnusedLabelVisitor {\n-    pub fn new() -> UnusedLabelVisitor {\n-        ::std::default::Default::default()\n-    }\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n impl LintPass for UnusedLabel {\n@@ -46,27 +40,38 @@ impl LintPass for UnusedLabel {\n     }\n }\n \n-impl LateLintPass for UnusedLabel {\n-    fn check_fn(&mut self, cx: &LateContext, kind: FnKind, decl: &hir::FnDecl, body: &hir::Expr, span: Span, fn_id: ast::NodeId) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedLabel {\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'a, 'tcx>,\n+        kind: FnKind<'tcx>,\n+        decl: &'tcx hir::FnDecl,\n+        body: &'tcx hir::Expr,\n+        span: Span,\n+        fn_id: ast::NodeId,\n+    ) {\n         if in_macro(cx, span) {\n             return;\n         }\n \n-        let mut v = UnusedLabelVisitor::new();\n-        walk_fn(&mut v, kind, decl, body, span, fn_id);\n+        let mut v = UnusedLabelVisitor {\n+            cx: cx,\n+            labels: HashMap::new(),\n+        };\n+        walk_fn(&mut v, kind, decl, body.expr_id(), span, fn_id);\n \n         for (label, span) in v.labels {\n             span_lint(cx, UNUSED_LABEL, span, &format!(\"unused label `{}`\", label));\n         }\n     }\n }\n \n-impl<'v> Visitor<'v> for UnusedLabelVisitor {\n-    fn visit_expr(&mut self, expr: &hir::Expr) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for UnusedLabelVisitor<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx hir::Expr) {\n         match expr.node {\n             hir::ExprBreak(Some(label), _) |\n             hir::ExprAgain(Some(label)) => {\n-                self.labels.remove(&label.node.as_str());\n+                self.labels.remove(&label.name.as_str());\n             }\n             hir::ExprLoop(_, Some(label), _) |\n             hir::ExprWhile(_, _, Some(label)) => {\n@@ -77,4 +82,7 @@ impl<'v> Visitor<'v> for UnusedLabelVisitor {\n \n         walk_expr(self, expr);\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "6ae4743a368cc8178216af9f1c48d4e8b67a679a", "filename": "clippy_lints/src/utils/higher.rs", "status": "modified", "additions": 6, "deletions": 19, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -44,34 +44,21 @@ pub struct Range<'a> {\n \n /// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n pub fn range(expr: &hir::Expr) -> Option<Range> {\n-    /// Skip unstable blocks. To be removed when ranges get stable.\n-    fn unwrap_unstable(expr: &hir::Expr) -> &hir::Expr {\n-        if let hir::ExprBlock(ref block) = expr.node {\n-            if block.rules == hir::BlockCheckMode::PushUnstableBlock || block.rules == hir::BlockCheckMode::PopUnstableBlock {\n-                if let Some(ref expr) = block.expr {\n-                    return expr;\n-                }\n-            }\n-        }\n-\n-        expr\n-    }\n-\n     /// Find the field named `name` in the field. Always return `Some` for convenience.\n     fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n         let expr = &fields.iter()\n                           .find(|field| field.name.node == name)\n                           .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n                           .expr;\n \n-        Some(unwrap_unstable(expr))\n+        Some(expr)\n     }\n \n     // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n     // `#[no_std]`. Testing both instead of resolving the paths.\n \n-    match unwrap_unstable(expr).node {\n-        hir::ExprPath(None, ref path) => {\n+    match expr.node {\n+        hir::ExprPath(ref path) => {\n             if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n                 Some(Range {\n                     start: None,\n@@ -168,15 +155,15 @@ pub enum VecArgs<'a> {\n pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n     if_let_chain!{[\n         let hir::ExprCall(ref fun, ref args) = expr.node,\n-        let hir::ExprPath(_, ref path) = fun.node,\n-        let Some(fun_def) = resolve_node(cx, fun.id),\n+        let hir::ExprPath(ref path) = fun.node,\n         is_expn_of(cx, fun.span, \"vec\").is_some(),\n     ], {\n+        let fun_def = resolve_node(cx, path, fun.id);\n         return if match_def_path(cx, fun_def.def_id(), &paths::VEC_FROM_ELEM) && args.len() == 2 {\n             // `vec![elem; size]` case\n             Some(VecArgs::Repeat(&args[0], &args[1]))\n         }\n-        else if match_path(path, &[\"into_vec\"]) && args.len() == 1 {\n+        else if match_def_path(cx, fun_def.def_id(), &paths::SLICE_INTO_VEC) && args.len() == 1 {\n             // `vec![a, b, c]` case\n             if_let_chain!{[\n                 let hir::ExprBox(ref boxed) = args[0].node,"}, {"sha": "e01feb3fcae22dedc0b99f1b03ef532f04b54489", "filename": "clippy_lints/src/utils/hir.rs", "status": "modified", "additions": 44, "deletions": 30, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n \n         match (&left.node, &right.node) {\n             (&ExprAddrOf(l_mut, ref le), &ExprAddrOf(r_mut, ref re)) => l_mut == r_mut && self.eq_expr(le, re),\n-            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str()),\n+            (&ExprAgain(li), &ExprAgain(ri)) => both(&li, &ri, |l, r| l.name.as_str() == r.name.as_str()),\n             (&ExprAssign(ref ll, ref lr), &ExprAssign(ref rl, ref rr)) => self.eq_expr(ll, rl) && self.eq_expr(lr, rr),\n             (&ExprAssignOp(ref lo, ref ll, ref lr), &ExprAssignOp(ref ro, ref rl, ref rr)) => {\n                 lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n@@ -82,7 +82,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n                 })\n             }\n             (&ExprBreak(li, ref le), &ExprBreak(ri, ref re)) =>\n-                both(&li, &ri, |l, r| l.node.as_str() == r.node.as_str())\n+                both(&li, &ri, |l, r| l.name.as_str() == r.name.as_str())\n                 && both(le, re, |l, r| self.eq_expr(l, r)),\n             (&ExprBox(ref l), &ExprBox(ref r)) => self.eq_expr(l, r),\n             (&ExprCall(ref l_fun, ref l_args), &ExprCall(ref r_fun, ref r_args)) => {\n@@ -101,12 +101,13 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             }\n             (&ExprLit(ref l), &ExprLit(ref r)) => l.node == r.node,\n             (&ExprLoop(ref lb, ref ll, ref lls), &ExprLoop(ref rb, ref rl, ref rls)) => {\n-                self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str()) && lls == rls\n+                lls == rls && self.eq_block(lb, rb) && both(ll, rl, |l, r| l.node.as_str() == r.node.as_str())\n             }\n             (&ExprMatch(ref le, ref la, ref ls), &ExprMatch(ref re, ref ra, ref rs)) => {\n                 ls == rs && self.eq_expr(le, re) &&\n                 over(la, ra, |l, r| {\n-                    self.eq_expr(&l.body, &r.body) && both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n+                    self.eq_expr(&l.body, &r.body) &&\n+                    both(&l.guard, &r.guard, |l, r| self.eq_expr(l, r)) &&\n                     over(&l.pats, &r.pats, |l, r| self.eq_pat(l, r))\n                 })\n             }\n@@ -118,11 +119,9 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             }\n             (&ExprRepeat(ref le, ref ll), &ExprRepeat(ref re, ref rl)) => self.eq_expr(le, re) && self.eq_expr(ll, rl),\n             (&ExprRet(ref l), &ExprRet(ref r)) => both(l, r, |l, r| self.eq_expr(l, r)),\n-            (&ExprPath(ref l_qself, ref l_subpath), &ExprPath(ref r_qself, ref r_subpath)) => {\n-                both(l_qself, r_qself, |l, r| self.eq_qself(l, r)) && self.eq_path(l_subpath, r_subpath)\n-            }\n+            (&ExprPath(ref l), &ExprPath(ref r)) => self.eq_qpath(l, r),\n             (&ExprStruct(ref l_path, ref lf, ref lo), &ExprStruct(ref r_path, ref rf, ref ro)) => {\n-                self.eq_path(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n+                self.eq_qpath(l_path, r_path) && both(lo, ro, |l, r| self.eq_expr(l, r)) &&\n                 over(lf, rf, |l, r| self.eq_field(l, r))\n             }\n             (&ExprTup(ref l_tup), &ExprTup(ref r_tup)) => self.eq_exprs(l_tup, r_tup),\n@@ -153,14 +152,12 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         match (&left.node, &right.node) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n-                self.eq_path(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n+                self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             }\n-            (&PatKind::Binding(ref lb, ref li, ref lp), &PatKind::Binding(ref rb, ref ri, ref rp)) => {\n+            (&PatKind::Binding(ref lb, _, ref li, ref lp), &PatKind::Binding(ref rb, _, ref ri, ref rp)) => {\n                 lb == rb && li.node.as_str() == ri.node.as_str() && both(lp, rp, |l, r| self.eq_pat(l, r))\n             }\n-            (&PatKind::Path(ref ql, ref l), &PatKind::Path(ref qr, ref r)) => {\n-                both(ql, qr, |ql, qr| self.eq_qself(ql, qr)) && self.eq_path(l, r)\n-            }\n+            (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n             (&PatKind::Tuple(ref l, ls), &PatKind::Tuple(ref r, rs)) => {\n                 ls == rs && over(l, r, |l, r| self.eq_pat(l, r))\n@@ -178,6 +175,18 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n+    fn eq_qpath(&self, left: &QPath, right: &QPath) -> bool {\n+        match (left, right) {\n+            (&QPath::Resolved(ref lty, ref lpath), &QPath::Resolved(ref rty, ref rpath)) => {\n+                both(lty, rty, |l, r| self.eq_ty(l, r)) && self.eq_path(lpath, rpath)\n+            },\n+            (&QPath::TypeRelative(ref lty, ref lseg), &QPath::TypeRelative(ref rty, ref rseg)) => {\n+                self.eq_ty(lty, rty) && self.eq_path_segment(lseg, rseg)\n+            },\n+            _ => false,\n+        }\n+    }\n+\n     fn eq_path(&self, left: &Path, right: &Path) -> bool {\n         left.global == right.global &&\n         over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n@@ -208,10 +217,6 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n         self.eq_path_parameters(&left.parameters, &right.parameters)\n     }\n \n-    fn eq_qself(&self, left: &QSelf, right: &QSelf) -> bool {\n-        left.ty.node == right.ty.node && left.position == right.position\n-    }\n-\n     fn eq_ty(&self, left: &Ty, right: &Ty) -> bool {\n         match (&left.node, &right.node) {\n             (&TySlice(ref l_vec), &TySlice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n@@ -222,9 +227,7 @@ impl<'a, 'tcx: 'a> SpanlessEq<'a, 'tcx> {\n             (&TyRptr(_, ref l_rmut), &TyRptr(_, ref r_rmut)) => {\n                 l_rmut.mutbl == r_rmut.mutbl && self.eq_ty(&*l_rmut.ty, &*r_rmut.ty)\n             }\n-            (&TyPath(ref lq, ref l_path), &TyPath(ref rq, ref r_path)) => {\n-                both(lq, rq, |l, r| self.eq_qself(l, r)) && self.eq_path(l_path, r_path)\n-            }\n+            (&TyPath(ref l), &TyPath(ref r)) => self.eq_qpath(l, r),\n             (&TyTup(ref l), &TyTup(ref r)) => over(l, r, |l, r| self.eq_ty(l, r)),\n             (&TyInfer, &TyInfer) => true,\n             _ => false,\n@@ -318,7 +321,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_) -> _ = ExprAgain;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node);\n+                    self.hash_name(&i.name);\n                 }\n             }\n             ExprAssign(ref l, ref r) => {\n@@ -350,7 +353,7 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 let c: fn(_, _) -> _ = ExprBreak;\n                 c.hash(&mut self.s);\n                 if let Some(i) = i {\n-                    self.hash_name(&i.node);\n+                    self.hash_name(&i.name);\n                 }\n                 if let Some(ref j) = *j {\n                     self.hash_expr(&*j);\n@@ -373,11 +376,11 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 self.hash_expr(e);\n                 // TODO: _ty\n             }\n-            ExprClosure(cap, _, ref e, _) => {\n+            ExprClosure(cap, _, eid, _) => {\n                 let c: fn(_, _, _, _) -> _ = ExprClosure;\n                 c.hash(&mut self.s);\n                 cap.hash(&mut self.s);\n-                self.hash_expr(e);\n+                self.hash_expr(self.cx.tcx.map.expr(eid));\n             }\n             ExprField(ref e, ref f) => {\n                 let c: fn(_, _) -> _ = ExprField;\n@@ -409,14 +412,13 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                 c.hash(&mut self.s);\n                 l.hash(&mut self.s);\n             }\n-            ExprLoop(ref b, ref i, ref j) => {\n+            ExprLoop(ref b, ref i, _) => {\n                 let c: fn(_, _, _) -> _ = ExprLoop;\n                 c.hash(&mut self.s);\n                 self.hash_block(b);\n                 if let Some(i) = *i {\n                     self.hash_name(&i.node);\n                 }\n-                j.hash(&mut self.s);\n             }\n             ExprMatch(ref e, ref arms, ref s) => {\n                 let c: fn(_, _, _) -> _ = ExprMatch;\n@@ -452,16 +454,16 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n                     self.hash_expr(e);\n                 }\n             }\n-            ExprPath(ref _qself, ref subpath) => {\n-                let c: fn(_, _) -> _ = ExprPath;\n+            ExprPath(ref qpath) => {\n+                let c: fn(_) -> _ = ExprPath;\n                 c.hash(&mut self.s);\n-                self.hash_path(subpath);\n+                self.hash_qpath(qpath);\n             }\n             ExprStruct(ref path, ref fields, ref expr) => {\n                 let c: fn(_, _, _) -> _ = ExprStruct;\n                 c.hash(&mut self.s);\n \n-                self.hash_path(path);\n+                self.hash_qpath(path);\n \n                 for f in fields {\n                     self.hash_name(&f.name.node);\n@@ -526,6 +528,18 @@ impl<'a, 'tcx: 'a> SpanlessHash<'a, 'tcx> {\n         n.as_str().hash(&mut self.s);\n     }\n \n+    pub fn hash_qpath(&mut self, p: &QPath) {\n+        match *p {\n+            QPath::Resolved(_, ref path) => {\n+                self.hash_path(path);\n+            }\n+            QPath::TypeRelative(_, ref path) => {\n+                self.hash_name(&path.name);\n+            }\n+        }\n+        //self.cx.tcx.tables().qpath_def(p, id).hash(&mut self.s);\n+    }\n+\n     pub fn hash_path(&mut self, p: &Path) {\n         p.global.hash(&mut self.s);\n         for p in &p.segments {"}, {"sha": "b2900c5691c7caa838785565fb27a724f0349586", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -36,15 +36,15 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n         print_item(cx, item);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ImplItem) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n@@ -68,33 +68,33 @@ impl LateLintPass for Pass {\n         }\n     }\n /*\n-    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::TraitItem) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext, var: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext<'a, 'tcx>, var: &'tcx hir::Variant, _: &hir::Generics) {\n         if !has_attr(&var.node.attrs) {\n             return;\n         }\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'a, 'tcx>, field: &'tcx hir::StructField) {\n         if !has_attr(&field.attrs) {\n             return;\n         }\n     }\n */\n \n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx hir::Expr) {\n         if !has_attr(&expr.attrs) {\n             return;\n         }\n         print_expr(cx, expr, 0);\n     }\n \n-    fn check_arm(&mut self, cx: &LateContext, arm: &hir::Arm) {\n+    fn check_arm(&mut self, cx: &LateContext<'a, 'tcx>, arm: &'tcx hir::Arm) {\n         if !has_attr(&arm.attrs) {\n             return;\n         }\n@@ -109,7 +109,7 @@ impl LateLintPass for Pass {\n         print_expr(cx, &arm.body, 1);\n     }\n \n-    fn check_stmt(&mut self, cx: &LateContext, stmt: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'a, 'tcx>, stmt: &'tcx hir::Stmt) {\n         if !has_attr(stmt.node.attrs()) {\n             return;\n         }\n@@ -120,7 +120,7 @@ impl LateLintPass for Pass {\n     }\n /*\n \n-    fn check_foreign_item(&mut self, cx: &LateContext, item: &hir::ForeignItem) {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::ForeignItem) {\n         if !has_attr(&item.attrs) {\n             return;\n         }\n@@ -275,11 +275,14 @@ fn print_expr(cx: &LateContext, expr: &hir::Expr, indent: usize) {\n             println!(\"{}index expr:\", ind);\n             print_expr(cx, idx, indent + 1);\n         },\n-        hir::ExprPath(ref sel, ref path) => {\n-            println!(\"{}Path, {}\", ind, ty);\n-            println!(\"{}self: {:?}\", ind, sel);\n+        hir::ExprPath(hir::QPath::Resolved(ref ty, ref path)) => {\n+            println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n+        hir::ExprPath(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+            println!(\"{}Relative Path, {:?}\", ind, ty);\n+            println!(\"{}seg: {:?}\", ind, seg);\n+        }\n         hir::ExprAddrOf(ref muta, ref e) => {\n             println!(\"{}AddrOf, {}\", ind, ty);\n             println!(\"mutability: {:?}\", muta);\n@@ -354,7 +357,7 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n                 println!(\"weird extern crate without a crate id\");\n             }\n         }\n-        hir::ItemUse(ref path) => println!(\"{:?}\", path.node),\n+        hir::ItemUse(ref path, ref kind) => println!(\"{:?}, {:?}\", path, kind),\n         hir::ItemStatic(..) => println!(\"static item of type {:#?}\", cx.tcx.item_type(did)),\n         hir::ItemConst(..) => println!(\"const item of type {:#?}\", cx.tcx.item_type(did)),\n         hir::ItemFn(..) => {\n@@ -383,13 +386,11 @@ fn print_item(cx: &LateContext, item: &hir::Item) {\n                 println!(\"trait has no default impl\");\n             }\n         },\n-        hir::ItemDefaultImpl(_, ref trait_ref) => {\n-            let trait_did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n-            println!(\"default impl for `{}`\", cx.tcx.item_path_str(trait_did));\n+        hir::ItemDefaultImpl(_, ref _trait_ref) => {\n+            println!(\"default impl\");\n         },\n-        hir::ItemImpl(_, _, _, Some(ref trait_ref), _, _) => {\n-            let trait_did = cx.tcx.expect_def(trait_ref.ref_id).def_id();\n-            println!(\"impl of trait `{}`\", cx.tcx.item_path_str(trait_did));\n+        hir::ItemImpl(_, _, _, Some(ref _trait_ref), _, _) => {\n+            println!(\"trait impl\");\n         },\n         hir::ItemImpl(_, _, _, None, _, _) => {\n             println!(\"impl\");\n@@ -402,7 +403,7 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n     println!(\"{}+\", ind);\n     match pat.node {\n         hir::PatKind::Wild => println!(\"{}Wild\", ind),\n-        hir::PatKind::Binding(ref mode, ref name, ref inner) => {\n+        hir::PatKind::Binding(ref mode, _, ref name, ref inner) => {\n             println!(\"{}Binding\", ind);\n             println!(\"{}mode: {:?}\", ind, mode);\n             println!(\"{}name: {}\", ind, name.node);\n@@ -434,11 +435,14 @@ fn print_pat(cx: &LateContext, pat: &hir::Pat, indent: usize) {\n                 print_pat(cx, field, indent + 1);\n             }\n         },\n-        hir::PatKind::Path(ref sel, ref path) => {\n-            println!(\"{}Path\", ind);\n-            println!(\"{}self: {:?}\", ind, sel);\n+        hir::PatKind::Path(hir::QPath::Resolved(ref ty, ref path)) => {\n+            println!(\"{}Resolved Path, {:?}\", ind, ty);\n             println!(\"{}path: {:?}\", ind, path);\n         },\n+        hir::PatKind::Path(hir::QPath::TypeRelative(ref ty, ref seg)) => {\n+            println!(\"{}Relative Path, {:?}\", ind, ty);\n+            println!(\"{}seg: {:?}\", ind, seg);\n+        },\n         hir::PatKind::Tuple(ref pats, opt_dots_position) => {\n             println!(\"{}Tuple\", ind);\n             if let Some(dot_position) = opt_dots_position {"}, {"sha": "91961f90691952afad20a7e7b3161283dfd0105a", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,6 +1,6 @@\n use rustc::lint::*;\n use rustc::hir::*;\n-use rustc::hir::intravisit::{Visitor, walk_expr};\n+use rustc::hir::intravisit::{Visitor, walk_expr, NestedVisitorMap};\n use utils::{paths, match_path, span_lint};\n use syntax::symbol::InternedString;\n use syntax::ast::{Name, NodeId, ItemKind, Crate as AstCrate};\n@@ -104,19 +104,19 @@ impl LintPass for LintWithoutLintPass {\n }\n \n \n-impl LateLintPass for LintWithoutLintPass {\n-    fn check_item(&mut self, _: &LateContext, item: &Item) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n+    fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemStatic(ref ty, MutImmutable, ref expr) = item.node {\n             if is_lint_ref_type(ty) {\n                 self.declared_lints.insert(item.name, item.span);\n             } else if is_lint_array_type(ty) && item.vis == Visibility::Inherited && item.name == \"ARRAY\" {\n-                let mut collector = LintCollector { output: &mut self.registered_lints };\n+                let mut collector = LintCollector { output: &mut self.registered_lints, cx: cx };\n                 collector.visit_expr(expr);\n             }\n         }\n     }\n \n-    fn check_crate_post(&mut self, cx: &LateContext, _: &Crate) {\n+    fn check_crate_post(&mut self, cx: &LateContext<'a, 'tcx>, _: &'tcx Crate) {\n         for (lint_name, &lint_span) in &self.declared_lints {\n             // When using the `declare_lint!` macro, the original `lint_span`'s\n             // file points to \"<rustc macros>\".\n@@ -140,7 +140,7 @@ impl LateLintPass for LintWithoutLintPass {\n \n fn is_lint_ref_type(ty: &Ty) -> bool {\n     if let TyRptr(Some(_), MutTy { ty: ref inner, mutbl: MutImmutable }) = ty.node {\n-        if let TyPath(None, ref path) = inner.node {\n+        if let TyPath(ref path) = inner.node {\n             return match_path(path, &paths::LINT);\n         }\n     }\n@@ -149,25 +149,29 @@ fn is_lint_ref_type(ty: &Ty) -> bool {\n \n \n fn is_lint_array_type(ty: &Ty) -> bool {\n-    if let TyPath(None, ref path) = ty.node {\n+    if let TyPath(ref path) = ty.node {\n         match_path(path, &paths::LINT_ARRAY)\n     } else {\n         false\n     }\n }\n \n-struct LintCollector<'a> {\n+struct LintCollector<'a, 'tcx: 'a> {\n     output: &'a mut HashSet<Name>,\n+    cx: &'a LateContext<'a, 'tcx>,\n }\n \n-impl<'v, 'a: 'v> Visitor<'v> for LintCollector<'a> {\n-    fn visit_expr(&mut self, expr: &'v Expr) {\n+impl<'a, 'tcx: 'a> Visitor<'tcx> for LintCollector<'a, 'tcx> {\n+    fn visit_expr(&mut self, expr: &'tcx Expr) {\n         walk_expr(self, expr);\n     }\n \n-    fn visit_path(&mut self, path: &'v Path, _: NodeId) {\n+    fn visit_path(&mut self, path: &'tcx Path, _: NodeId) {\n         if path.segments.len() == 1 {\n             self.output.insert(path.segments[0].name);\n         }\n     }\n+    fn nested_visit_map<'this>(&'this mut self) -> NestedVisitorMap<'this, 'tcx> {\n+        NestedVisitorMap::All(&self.cx.tcx.map)\n+    }\n }"}, {"sha": "d8afb96298d4bf9e4c07ffeae338d4e27f52f09b", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 92, "deletions": 29, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -1,6 +1,7 @@\n use reexport::*;\n use rustc::hir::*;\n use rustc::hir::def_id::{DefId, CRATE_DEF_INDEX};\n+use rustc::hir::def::Def;\n use rustc::hir::map::Node;\n use rustc::lint::{LintContext, LateContext, Level, Lint};\n use rustc::session::Session;\n@@ -93,16 +94,25 @@ pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n     rhs.expn_id != lhs.expn_id\n }\n /// Returns true if this `expn_info` was expanded by any macro.\n-pub fn in_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n-    cx.sess().codemap().with_expn_info(span.expn_id, |info| info.is_some())\n+pub fn in_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n+    cx.sess().codemap().with_expn_info(span.expn_id, |info| match info {\n+        Some(info) => {\n+            match info.callee.format {\n+                // don't treat range expressions desugared to structs as \"in_macro\"\n+                ExpnFormat::CompilerDesugaring(name) => name != \"...\",\n+                _ => true,\n+            }\n+        },\n+        None => false,\n+    })\n }\n \n /// Returns true if the macro that expanded the crate was outside of the current crate or was a\n /// compiler plugin.\n-pub fn in_external_macro<T: LintContext>(cx: &T, span: Span) -> bool {\n+pub fn in_external_macro<'a, T: LintContext<'a>>(cx: &T, span: Span) -> bool {\n     /// Invokes `in_macro` with the expansion info of the given span slightly heavy, try to use\n     /// this after other checks have already happened.\n-    fn in_macro_ext<T: LintContext>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n+    fn in_macro_ext<'a, T: LintContext<'a>>(cx: &T, opt_info: Option<&ExpnInfo>) -> bool {\n         // no ExpnInfo = no macro\n         opt_info.map_or(false, |info| {\n             if let ExpnFormat::MacroAttribute(..) = info.callee.format {\n@@ -196,13 +206,44 @@ pub fn match_trait_method(cx: &LateContext, expr: &Expr, path: &[&str]) -> bool\n     }\n }\n \n+pub fn last_path_segment(path: &QPath) -> &PathSegment {\n+    match *path {\n+        QPath::Resolved(_, ref path) => path.segments\n+                                            .last()\n+                                            .expect(\"A path must have at least one segment\"),\n+        QPath::TypeRelative(_, ref seg) => seg,\n+    }\n+}\n+\n+pub fn single_segment_path(path: &QPath) -> Option<&PathSegment> {\n+    match *path {\n+        QPath::Resolved(_, ref path) if path.segments.len() == 1 => Some(&path.segments[0]),\n+        QPath::Resolved(..) => None,\n+        QPath::TypeRelative(_, ref seg) => Some(seg),\n+    }\n+}\n+\n /// Match a `Path` against a slice of segment string literals.\n ///\n /// # Examples\n /// ```\n /// match_path(path, &[\"std\", \"rt\", \"begin_unwind\"])\n /// ```\n-pub fn match_path(path: &Path, segments: &[&str]) -> bool {\n+pub fn match_path(path: &QPath, segments: &[&str]) -> bool {\n+    match *path {\n+        QPath::Resolved(_, ref path) => match_path_old(path, segments),\n+        QPath::TypeRelative(ref ty, ref segment) => match ty.node {\n+            TyPath(ref inner_path) => {\n+                segments.len() > 0 &&\n+                match_path(inner_path, &segments[..(segments.len() - 1)]) &&\n+                segment.name == segments[segments.len() - 1]\n+            },\n+            _ => false,\n+        },\n+    }\n+}\n+\n+pub fn match_path_old(path: &Path, segments: &[&str]) -> bool {\n     path.segments.iter().rev().zip(segments.iter().rev()).all(|(a, b)| a.name == *b)\n }\n \n@@ -283,8 +324,8 @@ pub fn implements_trait<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>,\n }\n \n /// Resolve the definition of a node from its `NodeId`.\n-pub fn resolve_node(cx: &LateContext, id: NodeId) -> Option<def::Def> {\n-    cx.tcx.def_map.borrow().get(&id).map(|d| d.full_def())\n+pub fn resolve_node(cx: &LateContext, qpath: &QPath, id: NodeId) -> def::Def {\n+    cx.tcx.tables().qpath_def(qpath, id)\n }\n \n /// Match an `Expr` against a chain of methods, and return the matched `Expr`s.\n@@ -330,12 +371,12 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n /// ```\n /// snippet(cx, expr.span, \"..\")\n /// ```\n-pub fn snippet<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     cx.sess().codemap().span_to_snippet(span).map(From::from).unwrap_or_else(|_| Cow::Borrowed(default))\n }\n \n /// Convert a span to a code snippet. Returns `None` if not available.\n-pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+pub fn snippet_opt<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     cx.sess().codemap().span_to_snippet(span).ok()\n }\n \n@@ -347,14 +388,14 @@ pub fn snippet_opt<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n /// ```\n /// snippet(cx, expr.span, \"..\")\n /// ```\n-pub fn snippet_block<'a, T: LintContext>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n+pub fn snippet_block<'a, 'b, T: LintContext<'b>>(cx: &T, span: Span, default: &'a str) -> Cow<'a, str> {\n     let snip = snippet(cx, span, default);\n     trim_multiline(snip, true)\n }\n \n /// Like `snippet_block`, but add braces if the expr is not an `ExprBlock`.\n /// Also takes an `Option<String>` which can be put inside the braces.\n-pub fn expr_block<'a, T: LintContext>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n+pub fn expr_block<'a, 'b, T: LintContext<'b>>(cx: &T, expr: &Expr, option: Option<String>, default: &'a str) -> Cow<'a, str> {\n     let code = snippet_block(cx, expr.span, default);\n     let string = option.unwrap_or_default();\n     if let ExprBlock(_) = expr.node {\n@@ -423,15 +464,15 @@ pub fn get_parent_expr<'c>(cx: &'c LateContext, e: &Expr) -> Option<&'c Expr> {\n     })\n }\n \n-pub fn get_enclosing_block<'c>(cx: &'c LateContext, node: NodeId) -> Option<&'c Block> {\n+pub fn get_enclosing_block<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, node: NodeId) -> Option<&'tcx Block> {\n     let map = &cx.tcx.map;\n     let enclosing_node = map.get_enclosing_scope(node)\n                             .and_then(|enclosing_id| map.find(enclosing_id));\n     if let Some(node) = enclosing_node {\n         match node {\n             Node::NodeBlock(block) => Some(block),\n-            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, ref expr), .. }) => {\n-                match expr.node {\n+            Node::NodeItem(&Item { node: ItemFn(_, _, _, _, _, eid), .. }) => {\n+                match cx.tcx.map.expr(eid).node {\n                     ExprBlock(ref block) => Some(block),\n                     _ => None,\n                 }\n@@ -460,24 +501,29 @@ impl<'a> DiagnosticWrapper<'a> {\n     }\n }\n \n-pub fn span_lint<T: LintContext>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n+pub fn span_lint<'a, T: LintContext<'a>>(cx: &T, lint: &'static Lint, sp: Span, msg: &str) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n         db.wiki_link(lint);\n     }\n }\n \n-// FIXME: needless lifetime doesn't trigger here\n-pub fn span_help_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n+pub fn span_help_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, help: &str) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n         db.0.help(help);\n         db.wiki_link(lint);\n     }\n }\n \n-pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, span: Span, msg: &str, note_span: Span,\n-                                              note: &str) {\n+pub fn span_note_and_lint<'a, 'tcx: 'a, T: LintContext<'tcx>>(\n+    cx: &'a T,\n+    lint: &'static Lint,\n+    span: Span,\n+    msg: &str,\n+    note_span: Span,\n+    note: &str,\n+) {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, span, msg));\n     if cx.current_level(lint) != Level::Allow {\n         if note_span == span {\n@@ -489,8 +535,8 @@ pub fn span_note_and_lint<'a, T: LintContext>(cx: &'a T, lint: &'static Lint, sp\n     }\n }\n \n-pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n-    where F: FnOnce(&mut DiagnosticBuilder<'a>)\n+pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(cx: &'a T, lint: &'static Lint, sp: Span, msg: &str, f: F)\n+    where F: for<'b> FnOnce(&mut DiagnosticBuilder<'b>)\n {\n     let mut db = DiagnosticWrapper(cx.struct_span_lint(lint, sp, msg));\n     if cx.current_level(lint) != Level::Allow {\n@@ -705,7 +751,7 @@ pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> ty::T\n     let fn_def_id = cx.tcx.map.local_def_id(fn_item);\n     let fn_sig = cx.tcx.item_type(fn_def_id).fn_sig();\n     let fn_sig = cx.tcx.liberate_late_bound_regions(parameter_env.free_id_outlive, fn_sig);\n-    fn_sig.output\n+    fn_sig.output()\n }\n \n /// Check if two types are the same.\n@@ -736,8 +782,8 @@ pub fn is_copy<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, ty: ty::Ty<'tcx>, env: Node\n \n /// Return whether a pattern is refutable.\n pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n-    fn is_enum_variant(cx: &LateContext, did: NodeId) -> bool {\n-        matches!(cx.tcx.def_map.borrow().get(&did).map(|d| d.full_def()), Some(def::Def::Variant(..)) | Some(def::Def::VariantCtor(..)))\n+    fn is_enum_variant(cx: &LateContext, qpath: &QPath, did: NodeId) -> bool {\n+        matches!(cx.tcx.tables().qpath_def(qpath, did), def::Def::Variant(..) | def::Def::VariantCtor(..))\n     }\n \n     fn are_refutable<'a, I: Iterator<Item=&'a Pat>>(cx: &LateContext, mut i: I) -> bool {\n@@ -748,17 +794,17 @@ pub fn is_refutable(cx: &LateContext, pat: &Pat) -> bool {\n         PatKind::Binding(..) | PatKind::Wild => false,\n         PatKind::Box(ref pat) | PatKind::Ref(ref pat, _) => is_refutable(cx, pat),\n         PatKind::Lit(..) | PatKind::Range(..) => true,\n-        PatKind::Path(..) => is_enum_variant(cx, pat.id),\n+        PatKind::Path(ref qpath) => is_enum_variant(cx, qpath, pat.id),\n         PatKind::Tuple(ref pats, _) => are_refutable(cx, pats.iter().map(|pat| &**pat)),\n-        PatKind::Struct(_, ref fields, _) => {\n-            if is_enum_variant(cx, pat.id) {\n+        PatKind::Struct(ref qpath, ref fields, _) => {\n+            if is_enum_variant(cx, qpath, pat.id) {\n                 true\n             } else {\n                 are_refutable(cx, fields.iter().map(|field| &*field.node.pat))\n             }\n         }\n-        PatKind::TupleStruct(_, ref pats, _) => {\n-            if is_enum_variant(cx, pat.id) {\n+        PatKind::TupleStruct(ref qpath, ref pats, _) => {\n+            if is_enum_variant(cx, qpath, pat.id) {\n                 true\n             } else {\n                 are_refutable(cx, pats.iter().map(|pat| &**pat))\n@@ -793,3 +839,20 @@ pub fn remove_blocks(expr: &Expr) -> &Expr {\n         expr\n     }\n }\n+\n+pub fn opt_def_id(def: Def) -> Option<DefId> {\n+    match def {\n+        Def::Fn(id) | Def::Mod(id) | Def::Static(id, _) |\n+        Def::Variant(id) | Def::VariantCtor(id, ..) | Def::Enum(id) | Def::TyAlias(id) |\n+        Def::AssociatedTy(id) | Def::TyParam(id) | Def::Struct(id) | Def::StructCtor(id, ..) |\n+        Def::Union(id) | Def::Trait(id) | Def::Method(id) | Def::Const(id) |\n+        Def::AssociatedConst(id) | Def::Local(id) | Def::Upvar(id, ..) | Def::Macro(id) => {\n+            Some(id)\n+        }\n+\n+        Def::Label(..)  |\n+        Def::PrimTy(..) |\n+        Def::SelfTy(..) |\n+        Def::Err => None,\n+    }\n+}"}, {"sha": "402985613aeb8c0fbecb5a5b9c02d572c800ff13", "filename": "clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -12,7 +12,7 @@ pub const CLONE_TRAIT: [&'static str; 3] = [\"core\", \"clone\", \"Clone\"];\n pub const CMP_MAX: [&'static str; 3] = [\"core\", \"cmp\", \"max\"];\n pub const CMP_MIN: [&'static str; 3] = [\"core\", \"cmp\", \"min\"];\n pub const COW: [&'static str; 3] = [\"collections\", \"borrow\", \"Cow\"];\n-pub const CSTRING_NEW: [&'static str; 4] = [\"std\", \"ffi\", \"CString\", \"new\"];\n+pub const CSTRING_NEW: [&'static str; 5] = [\"std\", \"ffi\", \"c_str\", \"CString\", \"new\"];\n pub const DEBUG_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Debug\", \"fmt\"];\n pub const DEFAULT_TRAIT: [&'static str; 3] = [\"core\", \"default\", \"Default\"];\n pub const DISPLAY_FMT_METHOD: [&'static str; 4] = [\"core\", \"fmt\", \"Display\", \"fmt\"];\n@@ -64,6 +64,7 @@ pub const RESULT: [&'static str; 3] = [\"core\", \"result\", \"Result\"];\n pub const RESULT_ERR: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Err\"];\n pub const RESULT_OK: [&'static str; 4] = [\"core\", \"result\", \"Result\", \"Ok\"];\n pub const SERDE_DE_VISITOR: [&'static str; 3] = [\"serde\", \"de\", \"Visitor\"];\n+pub const SLICE_INTO_VEC: [&'static str; 4] = [\"collections\", \"slice\", \"<impl [T]>\", \"into_vec\"];\n pub const STRING: [&'static str; 3] = [\"collections\", \"string\", \"String\"];\n pub const TRANSMUTE: [&'static str; 4] = [\"core\", \"intrinsics\", \"\", \"transmute\"];\n pub const VEC: [&'static str; 3] = [\"collections\", \"vec\", \"Vec\"];"}, {"sha": "347834a062a7ae45e77d5541510e125bc414b794", "filename": "clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -384,7 +384,7 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n }\n \n /// Return the indentation before `span` if there are nothing but `[ \\t]` before it on its line.\n-fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n+fn indentation<'a, T: LintContext<'a>>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().codemap().lookup_char_pos(span.lo);\n     if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n         if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n@@ -403,7 +403,7 @@ fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n }\n \n /// Convenience extension trait for `DiagnosticBuilder`.\n-pub trait DiagnosticBuilderExt<T: LintContext> {\n+pub trait DiagnosticBuilderExt<'a, T: LintContext<'a>> {\n     /// Suggests to add an attribute to an item.\n     ///\n     /// Correctly handles indentation of the attribute and item.\n@@ -430,7 +430,7 @@ pub trait DiagnosticBuilderExt<T: LintContext> {\n     fn suggest_prepend_item(&mut self, cx: &T, item: Span, msg: &str, new_item: &str);\n }\n \n-impl<'a, 'b, T: LintContext> DiagnosticBuilderExt<T> for rustc_errors::DiagnosticBuilder<'b> {\n+impl<'a, 'b, 'c, T: LintContext<'c>> DiagnosticBuilderExt<'c, T> for rustc_errors::DiagnosticBuilder<'b> {\n     fn suggest_item_with_attr<D: Display+?Sized>(&mut self, cx: &T, item: Span, msg: &str, attr: &D) {\n         if let Some(indent) = indentation(cx, item) {\n             let span = Span {"}, {"sha": "1cfb57496f7ab22963d15fca46b29658ed1332ef", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -32,8 +32,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // search for `&vec![_]` expressions where the adjusted type is `&[_]`\n         if_let_chain!{[\n             let ty::TypeVariants::TyRef(_, ref ty) = cx.tcx.tables().expr_ty_adjusted(expr).sty,"}, {"sha": "daf0721af05aed7fd62358e08ba760b0d778a307", "filename": "clippy_lints/src/zero_div_zero.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/clippy_lints%2Fsrc%2Fzero_div_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fzero_div_zero.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -27,8 +27,8 @@ impl LintPass for Pass {\n     }\n }\n \n-impl LateLintPass for Pass {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n+impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n+    fn check_expr(&mut self, cx: &LateContext<'a, 'tcx>, expr: &'tcx Expr) {\n         // check for instances of 0.0/0.0\n         if_let_chain! {[\n             let ExprBinary(ref op, ref left, ref right) = expr.node,"}, {"sha": "9b1e1ec801ec92670b399b557d9ceeca46d08bc5", "filename": "tests/compile-fail/copies.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/tests%2Fcompile-fail%2Fcopies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/tests%2Fcompile-fail%2Fcopies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcopies.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -9,6 +9,7 @@\n #![allow(blacklisted_name)]\n #![allow(collapsible_if)]\n #![allow(zero_divided_by_zero, eq_op)]\n+#![allow(path_statements)]\n \n fn bar<T>(_: T) {}\n fn foo() -> bool { unimplemented!() }\n@@ -236,6 +237,13 @@ fn if_same_then_else() -> Result<&'static str, ()> {\n         if let Some(42) = None {}\n     }\n \n+    if true {\n+        if let Some(42) = None::<u8> {}\n+    }\n+    else {\n+        if let Some(42) = None::<u32> {}\n+    }\n+\n     if true {\n         if let Some(a) = Some(42) {}\n     }"}, {"sha": "525c166e62afdcaaa8eb932adf4b45d8712ae420", "filename": "tests/compile-fail/dlist.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/tests%2Fcompile-fail%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0227fff7ef86bf20f7942bb9b7d062a11c3d99/tests%2Fcompile-fail%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fdlist.rs?ref=ea0227fff7ef86bf20f7942bb9b7d062a11c3d99", "patch": "@@ -10,5 +10,5 @@ pub fn test(_: LinkedList<u8>) {  //~ ERROR I see you're using a LinkedList!\n }\n \n fn main(){\n-    test(LinkedList::new());\n+    test(LinkedList::new()); //~ ERROR I see you're using a LinkedList!\n }"}]}