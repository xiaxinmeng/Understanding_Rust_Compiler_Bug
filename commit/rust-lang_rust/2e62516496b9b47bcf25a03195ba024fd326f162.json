{"sha": "2e62516496b9b47bcf25a03195ba024fd326f162", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlNjI1MTY0OTZiOWI0N2JjZjI1YTAzMTk1YmEwMjRmZDMyNmYxNjI=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-28T15:30:39Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-07-28T15:30:39Z"}, "message": "Remove workarounds for things unimplemented in Cranelift\n\nMany are now implemented, so it is much nicer to directly use the\nrespective Cranelift instructions", "tree": {"sha": "7307fa29d1489649a49c4449e08f1af8104327ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7307fa29d1489649a49c4449e08f1af8104327ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e62516496b9b47bcf25a03195ba024fd326f162", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e62516496b9b47bcf25a03195ba024fd326f162", "html_url": "https://github.com/rust-lang/rust/commit/2e62516496b9b47bcf25a03195ba024fd326f162", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e62516496b9b47bcf25a03195ba024fd326f162/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a6ff90a3a41e6ace18aeb089ea0a0eb3726dd08", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a6ff90a3a41e6ace18aeb089ea0a0eb3726dd08", "html_url": "https://github.com/rust-lang/rust/commit/8a6ff90a3a41e6ace18aeb089ea0a0eb3726dd08"}], "stats": {"total": 118, "additions": 5, "deletions": 113}, "files": [{"sha": "e99a227a3a6eafc49b7156bc0fd0582e00ab8ff8", "filename": "src/base.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbase.rs?ref=2e62516496b9b47bcf25a03195ba024fd326f162", "patch": "@@ -334,8 +334,6 @@ fn codegen_fn_content(fx: &mut FunctionCx<'_, '_, '_>) {\n                         crate::optimize::peephole::maybe_unwrap_bool_not(&mut fx.bcx, discr);\n                     let test_zero = if is_inverted { !test_zero } else { test_zero };\n                     let discr = crate::optimize::peephole::maybe_unwrap_bint(&mut fx.bcx, discr);\n-                    let discr =\n-                        crate::optimize::peephole::make_branchable_value(&mut fx.bcx, discr);\n                     if let Some(taken) = crate::optimize::peephole::maybe_known_branch_taken(\n                         &fx.bcx, discr, test_zero,\n                     ) {"}, {"sha": "e7e6afeb865bb005bf436b7ec6e2802930dc7fe2", "filename": "src/cast.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=2e62516496b9b47bcf25a03195ba024fd326f162", "patch": "@@ -14,21 +14,6 @@ pub(crate) fn clif_intcast(\n         (_, _) if from == to => val,\n \n         // extend\n-        (_, types::I128) => {\n-            let lo = if from == types::I64 {\n-                val\n-            } else if signed {\n-                fx.bcx.ins().sextend(types::I64, val)\n-            } else {\n-                fx.bcx.ins().uextend(types::I64, val)\n-            };\n-            let hi = if signed {\n-                fx.bcx.ins().sshr_imm(lo, 63)\n-            } else {\n-                fx.bcx.ins().iconst(types::I64, 0)\n-            };\n-            fx.bcx.ins().iconcat(lo, hi)\n-        }\n         (_, _) if to.wider_or_equal(from) => {\n             if signed {\n                 fx.bcx.ins().sextend(to, val)\n@@ -38,10 +23,6 @@ pub(crate) fn clif_intcast(\n         }\n \n         // reduce\n-        (types::I128, _) => {\n-            let (lsb, _msb) = fx.bcx.ins().isplit(val);\n-            if to == types::I64 { lsb } else { fx.bcx.ins().ireduce(to, lsb) }\n-        }\n         (_, _) => fx.bcx.ins().ireduce(to, val),\n     }\n }"}, {"sha": "fb6ccd7c535845b85d9582de3d82f4638bc1cbe4", "filename": "src/debuginfo/emit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fdebuginfo%2Femit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fdebuginfo%2Femit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Femit.rs?ref=2e62516496b9b47bcf25a03195ba024fd326f162", "patch": "@@ -160,7 +160,7 @@ impl Writer for WriterRelocate {\n                 let val = match eh_pe.application() {\n                     gimli::DW_EH_PE_absptr => val,\n                     gimli::DW_EH_PE_pcrel => {\n-                        // TODO: better handling of sign\n+                        // FIXME better handling of sign\n                         let offset = self.len() as u64;\n                         offset.wrapping_sub(val)\n                     }"}, {"sha": "ceef65d54785fc92338045dd7e40cd9af627fa72", "filename": "src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdebuginfo%2Fmod.rs?ref=2e62516496b9b47bcf25a03195ba024fd326f162", "patch": "@@ -46,7 +46,7 @@ impl<'tcx> DebugContext<'tcx> {\n     pub(crate) fn new(tcx: TyCtxt<'tcx>, isa: &dyn TargetIsa) -> Self {\n         let encoding = Encoding {\n             format: Format::Dwarf32,\n-            // TODO: this should be configurable\n+            // FIXME this should be configurable\n             // macOS doesn't seem to support DWARF > 3\n             // 5 version is required for md5 file hash\n             version: if tcx.sess.target.is_like_osx {"}, {"sha": "4f7f8e7ef6d7517b63a0b7648fe8d8bc20db376e", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 2, "deletions": 37, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=2e62516496b9b47bcf25a03195ba024fd326f162", "patch": "@@ -611,9 +611,6 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n             let (val, has_overflow) = checked_res.load_scalar_pair(fx);\n             let clif_ty = fx.clif_type(T).unwrap();\n \n-            // `select.i8` is not implemented by Cranelift.\n-            let has_overflow = fx.bcx.ins().uextend(types::I32, has_overflow);\n-\n             let (min, max) = type_min_max_value(&mut fx.bcx, clif_ty, signed);\n \n             let val = match (intrinsic, signed) {\n@@ -640,21 +637,11 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         rotate_left, <T>(v x, v y) {\n             let layout = fx.layout_of(T);\n-            let y = if fx.bcx.func.dfg.value_type(y) == types::I128 {\n-                fx.bcx.ins().ireduce(types::I64, y)\n-            } else {\n-                y\n-            };\n             let res = fx.bcx.ins().rotl(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n         rotate_right, <T>(v x, v y) {\n             let layout = fx.layout_of(T);\n-            let y = if fx.bcx.func.dfg.value_type(y) == types::I128 {\n-                fx.bcx.ins().ireduce(types::I64, y)\n-            } else {\n-                y\n-            };\n             let res = fx.bcx.ins().rotr(x, y);\n             ret.write_cvalue(fx, CValue::by_val(res, layout));\n         };\n@@ -692,35 +679,13 @@ pub(crate) fn codegen_intrinsic_call<'tcx>(\n         };\n         ctlz | ctlz_nonzero, <T> (v arg) {\n             // FIXME trap on `ctlz_nonzero` with zero arg.\n-            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n-                // FIXME verify this algorithm is correct\n-                let (lsb, msb) = fx.bcx.ins().isplit(arg);\n-                let lsb_lz = fx.bcx.ins().clz(lsb);\n-                let msb_lz = fx.bcx.ins().clz(msb);\n-                let msb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, msb, 0);\n-                let lsb_lz_plus_64 = fx.bcx.ins().iadd_imm(lsb_lz, 64);\n-                let res = fx.bcx.ins().select(msb_is_zero, lsb_lz_plus_64, msb_lz);\n-                fx.bcx.ins().uextend(types::I128, res)\n-            } else {\n-                fx.bcx.ins().clz(arg)\n-            };\n+            let res = fx.bcx.ins().clz(arg);\n             let res = CValue::by_val(res, fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };\n         cttz | cttz_nonzero, <T> (v arg) {\n             // FIXME trap on `cttz_nonzero` with zero arg.\n-            let res = if T == fx.tcx.types.u128 || T == fx.tcx.types.i128 {\n-                // FIXME verify this algorithm is correct\n-                let (lsb, msb) = fx.bcx.ins().isplit(arg);\n-                let lsb_tz = fx.bcx.ins().ctz(lsb);\n-                let msb_tz = fx.bcx.ins().ctz(msb);\n-                let lsb_is_zero = fx.bcx.ins().icmp_imm(IntCC::Equal, lsb, 0);\n-                let msb_tz_plus_64 = fx.bcx.ins().iadd_imm(msb_tz, 64);\n-                let res = fx.bcx.ins().select(lsb_is_zero, msb_tz_plus_64, lsb_tz);\n-                fx.bcx.ins().uextend(types::I128, res)\n-            } else {\n-                fx.bcx.ins().ctz(arg)\n-            };\n+            let res = fx.bcx.ins().ctz(arg);\n             let res = CValue::by_val(res, fx.layout_of(T));\n             ret.write_cvalue(fx, res);\n         };"}, {"sha": "545d390e269957f1ef94c48b83d2c1e10b5f953f", "filename": "src/num.rs", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=2e62516496b9b47bcf25a03195ba024fd326f162", "patch": "@@ -67,19 +67,6 @@ pub(crate) fn codegen_binop<'tcx>(\n                     let lhs = in_lhs.load_scalar(fx);\n                     let rhs = in_rhs.load_scalar(fx);\n \n-                    let (lhs, rhs) = if (bin_op == BinOp::Eq || bin_op == BinOp::Ne)\n-                        && (in_lhs.layout().ty.kind() == fx.tcx.types.i8.kind()\n-                            || in_lhs.layout().ty.kind() == fx.tcx.types.i16.kind())\n-                    {\n-                        // FIXME(CraneStation/cranelift#896) icmp_imm.i8/i16 with eq/ne for signed ints is implemented wrong.\n-                        (\n-                            fx.bcx.ins().sextend(types::I32, lhs),\n-                            fx.bcx.ins().sextend(types::I32, rhs),\n-                        )\n-                    } else {\n-                        (lhs, rhs)\n-                    };\n-\n                     return codegen_compare_bin_op(fx, bin_op, signed, lhs, rhs);\n                 }\n                 _ => {}"}, {"sha": "d637b4d89293cea0a0a855ebb97378b111c3789b", "filename": "src/optimize/peephole.rs", "status": "modified", "additions": 1, "deletions": 40, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Foptimize%2Fpeephole.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e62516496b9b47bcf25a03195ba024fd326f162/src%2Foptimize%2Fpeephole.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foptimize%2Fpeephole.rs?ref=2e62516496b9b47bcf25a03195ba024fd326f162", "patch": "@@ -1,8 +1,6 @@\n //! Peephole optimizations that can be performed while creating clif ir.\n \n-use cranelift_codegen::ir::{\n-    condcodes::IntCC, types, InstBuilder, InstructionData, Opcode, Value, ValueDef,\n-};\n+use cranelift_codegen::ir::{condcodes::IntCC, InstructionData, Opcode, Value, ValueDef};\n use cranelift_frontend::FunctionBuilder;\n \n /// If the given value was produced by a `bint` instruction, return it's input, otherwise return the\n@@ -37,43 +35,6 @@ pub(crate) fn maybe_unwrap_bool_not(bcx: &mut FunctionBuilder<'_>, arg: Value) -\n     }\n }\n \n-pub(crate) fn make_branchable_value(bcx: &mut FunctionBuilder<'_>, arg: Value) -> Value {\n-    if bcx.func.dfg.value_type(arg).is_bool() {\n-        return arg;\n-    }\n-\n-    (|| {\n-        let arg_inst = if let ValueDef::Result(arg_inst, 0) = bcx.func.dfg.value_def(arg) {\n-            arg_inst\n-        } else {\n-            return None;\n-        };\n-\n-        match bcx.func.dfg[arg_inst] {\n-            // This is the lowering of Rvalue::Not\n-            InstructionData::Load { opcode: Opcode::Load, arg: ptr, flags, offset } => {\n-                // Using `load.i8 + uextend.i32` would legalize to `uload8 + ireduce.i8 +\n-                // uextend.i32`. Just `uload8` is much faster.\n-                match bcx.func.dfg.ctrl_typevar(arg_inst) {\n-                    types::I8 => Some(bcx.ins().uload8(types::I32, flags, ptr, offset)),\n-                    types::I16 => Some(bcx.ins().uload16(types::I32, flags, ptr, offset)),\n-                    _ => None,\n-                }\n-            }\n-            _ => None,\n-        }\n-    })()\n-    .unwrap_or_else(|| {\n-        match bcx.func.dfg.value_type(arg) {\n-            types::I8 | types::I16 => {\n-                // WORKAROUND for brz.i8 and brnz.i8 not yet being implemented\n-                bcx.ins().uextend(types::I32, arg)\n-            }\n-            _ => arg,\n-        }\n-    })\n-}\n-\n /// Returns whether the branch is statically known to be taken or `None` if it isn't statically known.\n pub(crate) fn maybe_known_branch_taken(\n     bcx: &FunctionBuilder<'_>,"}]}