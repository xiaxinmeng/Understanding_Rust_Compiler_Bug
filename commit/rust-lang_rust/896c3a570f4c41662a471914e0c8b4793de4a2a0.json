{"sha": "896c3a570f4c41662a471914e0c8b4793de4a2a0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg5NmMzYTU3MGY0YzQxNjYyYTQ3MTkxNGUwYzhiNDc5M2RlNGEyYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-13T11:54:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-04-13T11:54:26Z"}, "message": "Auto merge of #59515 - wesleywiser:measureme, r=michaelwoerister\n\nUse measureme in self profiler\n\nr? @michaelwoerister\n\n~Changes are still very rough.~\n\n~I'm not sure what the right way to add the `measureme` dependency is. Currently it's just added with a relative path which Works On My Machine \u2122\ufe0f.~\n\nI'm also not sure what to do with the category data.", "tree": {"sha": "34867721625454f7f3ec195266b3678ac51cbd24", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34867721625454f7f3ec195266b3678ac51cbd24"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/896c3a570f4c41662a471914e0c8b4793de4a2a0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/896c3a570f4c41662a471914e0c8b4793de4a2a0", "html_url": "https://github.com/rust-lang/rust/commit/896c3a570f4c41662a471914e0c8b4793de4a2a0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/896c3a570f4c41662a471914e0c8b4793de4a2a0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aa35e73b258789d93b080e361542d7aa99e7fcd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa35e73b258789d93b080e361542d7aa99e7fcd6", "html_url": "https://github.com/rust-lang/rust/commit/aa35e73b258789d93b080e361542d7aa99e7fcd6"}, {"sha": "56e434d84d8fc7f9a67c19294206c733f25b890b", "url": "https://api.github.com/repos/rust-lang/rust/commits/56e434d84d8fc7f9a67c19294206c733f25b890b", "html_url": "https://github.com/rust-lang/rust/commit/56e434d84d8fc7f9a67c19294206c733f25b890b"}], "stats": {"total": 662, "additions": 198, "deletions": 464}, "files": [{"sha": "9841f9d502cf8d8f9c15664a0c1821d467a651ad", "filename": "Cargo.lock", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -1474,6 +1474,16 @@ dependencies = [\n  \"toml-query 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"measureme\"\n+version = \"0.2.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+dependencies = [\n+ \"byteorder 1.2.7 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"rustc-hash 1.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+]\n+\n [[package]]\n name = \"memchr\"\n version = \"2.1.1\"\n@@ -2326,6 +2336,7 @@ dependencies = [\n  \"jobserver 0.1.13 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"lazy_static 1.2.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"measureme 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"num_cpus 1.8.0 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"parking_lot 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"polonius-engine 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n@@ -4106,6 +4117,7 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum matches 0.1.8 (registry+https://github.com/rust-lang/crates.io-index)\" = \"7ffc5c5338469d4d3ea17d269fa8ea3512ad247247c30bd2df69e68309ed0a08\"\n \"checksum mdbook 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)\" = \"90b5a8d7e341ceee5db3882a06078d42661ddcfa2b3687319cc5da76ec4e782f\"\n \"checksum mdbook 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0ba0d44cb4089c741b9a91f3e5218298a40699c2f3a070a85014eed290c60819\"\n+\"checksum measureme 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"36bb2b263a6795d352035024d6b30ce465bb79a5e5280d74c3b5f8464c657bcc\"\n \"checksum memchr 2.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0a3eb002f0535929f1199681417029ebea04aadc0c7a4224b46be99c7f5d6a16\"\n \"checksum memmap 0.6.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"e2ffa2c986de11a9df78620c01eeaaf27d94d3ff02bf81bfcca953102dd0c6ff\"\n \"checksum memoffset 0.2.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"0f9dc261e2b62d7a622bf416ea3c5245cdd5d9a7fcc428c0d06804dfce1775b3\""}, {"sha": "a668ebacabfd5a9768f06eb08cd4f3273a08ae27", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -36,6 +36,7 @@ byteorder = { version = \"1.1\", features = [\"i128\"]}\n chalk-engine = { version = \"0.9.0\", default-features=false }\n rustc_fs_util = { path = \"../librustc_fs_util\" }\n smallvec = { version = \"0.6.7\", features = [\"union\", \"may_dangle\"] }\n+measureme = \"0.2.1\"\n \n # Note that these dependencies are a lie, they're just here to get linkage to\n # work."}, {"sha": "a1966c02683e982c296df9c3ec01db40f4eb9f3a", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -46,8 +46,6 @@ use std::path::PathBuf;\n use std::time::Duration;\n use std::sync::{Arc, mpsc};\n \n-use parking_lot::Mutex as PlMutex;\n-\n mod code_stats;\n pub mod config;\n pub mod filesearch;\n@@ -130,7 +128,7 @@ pub struct Session {\n     pub profile_channel: Lock<Option<mpsc::Sender<ProfileQueriesMsg>>>,\n \n     /// Used by -Z self-profile\n-    pub self_profiling: Option<Arc<PlMutex<SelfProfiler>>>,\n+    pub self_profiling: Option<Arc<SelfProfiler>>,\n \n     /// Some measurements that are being gathered during compilation.\n     pub perf_stats: PerfStats,\n@@ -838,19 +836,17 @@ impl Session {\n \n     #[inline(never)]\n     #[cold]\n-    fn profiler_active<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+    fn profiler_active<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n         match &self.self_profiling {\n             None => bug!(\"profiler_active() called but there was no profiler active\"),\n             Some(profiler) => {\n-                let mut p = profiler.lock();\n-\n-                f(&mut p);\n+                f(&profiler);\n             }\n         }\n     }\n \n     #[inline(always)]\n-    pub fn profiler<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+    pub fn profiler<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n         if unlikely!(self.self_profiling.is_some()) {\n             self.profiler_active(f)\n         }\n@@ -1138,7 +1134,19 @@ fn build_session_(\n     driver_lint_caps: FxHashMap<lint::LintId, lint::Level>,\n ) -> Session {\n     let self_profiler =\n-        if sopts.debugging_opts.self_profile { Some(Arc::new(PlMutex::new(SelfProfiler::new()))) }\n+        if sopts.debugging_opts.self_profile {\n+            let profiler = SelfProfiler::new();\n+            match profiler {\n+                Ok(profiler) => {\n+                    crate::ty::query::QueryName::register_with_profiler(&profiler);\n+                    Some(Arc::new(profiler))\n+                },\n+                Err(e) => {\n+                    early_warn(sopts.error_format, &format!(\"failed to create profiler: {}\", e));\n+                    None\n+                }\n+            }\n+        }\n         else { None };\n \n     let host_triple = TargetTriple::from_triple(config::host_triple());"}, {"sha": "0eda92ea8b822b6816d6fdce975e0d42e6809830", "filename": "src/librustc/ty/query/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fconfig.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -3,7 +3,7 @@ use crate::dep_graph::DepNode;\n use crate::hir::def_id::{CrateNum, DefId};\n use crate::ty::TyCtxt;\n use crate::ty::query::queries;\n-use crate::ty::query::Query;\n+use crate::ty::query::{Query, QueryName};\n use crate::ty::query::QueryCache;\n use crate::ty::query::plumbing::CycleError;\n use crate::util::profiling::ProfileCategory;\n@@ -18,7 +18,7 @@ use crate::ich::StableHashingContext;\n // Query configuration and description traits.\n \n pub trait QueryConfig<'tcx> {\n-    const NAME: &'static str;\n+    const NAME: QueryName;\n     const CATEGORY: ProfileCategory;\n \n     type Key: Eq + Hash + Clone + Debug;"}, {"sha": "cd29ca818908ca988882bf9ee257ef2ae3e3f0a3", "filename": "src/librustc/ty/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fmod.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -41,7 +41,6 @@ use crate::ty::subst::SubstsRef;\n use crate::util::nodemap::{DefIdSet, DefIdMap, ItemLocalSet};\n use crate::util::common::{ErrorReported};\n use crate::util::profiling::ProfileCategory::*;\n-use crate::session::Session;\n \n use rustc_data_structures::svh::Svh;\n use rustc_data_structures::bit_set::BitSet;"}, {"sha": "d671b58470c6a5736cd322ab16923fa687145329", "filename": "src/librustc/ty/query/plumbing.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fquery%2Fplumbing.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -114,7 +114,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             let mut lock = cache.borrow_mut();\n             if let Some(value) = lock.results.get(key) {\n                 profq_msg!(tcx, ProfileQueriesMsg::CacheHit);\n-                tcx.sess.profiler(|p| p.record_query_hit(Q::NAME, Q::CATEGORY));\n+                tcx.sess.profiler(|p| p.record_query_hit(Q::NAME));\n                 let result = (value.value.clone(), value.index);\n                 #[cfg(debug_assertions)]\n                 {\n@@ -130,7 +130,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n                             //in another thread has completed. Record how long we wait in the\n                             //self-profiler\n                             #[cfg(parallel_compiler)]\n-                            tcx.sess.profiler(|p| p.query_blocked_start(Q::NAME, Q::CATEGORY));\n+                            tcx.sess.profiler(|p| p.query_blocked_start(Q::NAME));\n \n                             job.clone()\n                         },\n@@ -172,7 +172,7 @@ impl<'a, 'tcx, Q: QueryDescription<'tcx>> JobOwner<'a, 'tcx, Q> {\n             #[cfg(parallel_compiler)]\n             {\n                 let result = job.r#await(tcx, span);\n-                tcx.sess.profiler(|p| p.query_blocked_end(Q::NAME, Q::CATEGORY));\n+                tcx.sess.profiler(|p| p.query_blocked_end(Q::NAME));\n \n                 if let Err(cycle) = result {\n                     return TryGetJob::Cycle(Q::handle_cycle_error(tcx, cycle));\n@@ -358,14 +358,14 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n         key: Q::Key)\n     -> Q::Value {\n         debug!(\"ty::query::get_query<{}>(key={:?}, span={:?})\",\n-               Q::NAME,\n+               Q::NAME.as_str(),\n                key,\n                span);\n \n         profq_msg!(self,\n             ProfileQueriesMsg::QueryBegin(\n                 span.data(),\n-                profq_query_msg!(Q::NAME, self, key),\n+                profq_query_msg!(Q::NAME.as_str(), self, key),\n             )\n         );\n \n@@ -389,7 +389,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         if dep_node.kind.is_anon() {\n             profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n-            self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n+            self.sess.profiler(|p| p.start_query(Q::NAME));\n \n             let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n                 self.start_query(job.job.clone(), diagnostics, |tcx| {\n@@ -399,7 +399,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 })\n             });\n \n-            self.sess.profiler(|p| p.end_query(Q::NAME, Q::CATEGORY));\n+            self.sess.profiler(|p| p.end_query(Q::NAME));\n             profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n             self.dep_graph.read_index(dep_node_index);\n@@ -474,22 +474,22 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n \n         let result = if let Some(result) = result {\n             profq_msg!(self, ProfileQueriesMsg::CacheHit);\n-            self.sess.profiler(|p| p.record_query_hit(Q::NAME, Q::CATEGORY));\n+            self.sess.profiler(|p| p.record_query_hit(Q::NAME));\n \n             result\n         } else {\n             // We could not load a result from the on-disk cache, so\n             // recompute.\n \n-            self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n+            self.sess.profiler(|p| p.start_query(Q::NAME));\n \n             // The dep-graph for this computation is already in\n             // place\n             let result = self.dep_graph.with_ignore(|| {\n                 Q::compute(self, key)\n             });\n \n-            self.sess.profiler(|p| p.end_query(Q::NAME, Q::CATEGORY));\n+            self.sess.profiler(|p| p.end_query(Q::NAME));\n             result\n         };\n \n@@ -552,7 +552,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 key, dep_node);\n \n         profq_msg!(self, ProfileQueriesMsg::ProviderBegin);\n-        self.sess.profiler(|p| p.start_query(Q::NAME, Q::CATEGORY));\n+        self.sess.profiler(|p| p.start_query(Q::NAME));\n \n         let ((result, dep_node_index), diagnostics) = with_diagnostics(|diagnostics| {\n             self.start_query(job.job.clone(), diagnostics, |tcx| {\n@@ -572,7 +572,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             })\n         });\n \n-        self.sess.profiler(|p| p.end_query(Q::NAME, Q::CATEGORY));\n+        self.sess.profiler(|p| p.end_query(Q::NAME));\n         profq_msg!(self, ProfileQueriesMsg::ProviderEnd);\n \n         if unlikely!(self.sess.opts.debugging_opts.query_dep_graph) {\n@@ -619,7 +619,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             let _ = self.get_query::<Q>(DUMMY_SP, key);\n         } else {\n             profq_msg!(self, ProfileQueriesMsg::CacheHit);\n-            self.sess.profiler(|p| p.record_query_hit(Q::NAME, Q::CATEGORY));\n+            self.sess.profiler(|p| p.record_query_hit(Q::NAME));\n         }\n     }\n \n@@ -632,7 +632,8 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     ) {\n         profq_msg!(\n             self,\n-            ProfileQueriesMsg::QueryBegin(span.data(), profq_query_msg!(Q::NAME, self, key))\n+            ProfileQueriesMsg::QueryBegin(span.data(),\n+                                          profq_query_msg!(Q::NAME.as_str(), self, key))\n         );\n \n         // We may be concurrently trying both execute and force a query\n@@ -725,18 +726,6 @@ macro_rules! define_queries_inner {\n                 }\n             }\n \n-            pub fn record_computed_queries(&self, sess: &Session) {\n-                sess.profiler(|p| {\n-                    $(\n-                        p.record_computed_queries(\n-                            <queries::$name<'_> as QueryConfig<'_>>::NAME,\n-                            <queries::$name<'_> as QueryConfig<'_>>::CATEGORY,\n-                            self.$name.lock().results.len()\n-                        );\n-                    )*\n-                });\n-            }\n-\n             #[cfg(parallel_compiler)]\n             pub fn collect_active_jobs(&self) -> Vec<Lrc<QueryJob<$tcx>>> {\n                 let mut jobs = Vec::new();\n@@ -854,6 +843,24 @@ macro_rules! define_queries_inner {\n             }\n         }\n \n+        #[allow(nonstandard_style)]\n+        #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n+        pub enum QueryName {\n+            $($name),*\n+        }\n+\n+        impl QueryName {\n+            pub fn register_with_profiler(profiler: &crate::util::profiling::SelfProfiler) {\n+                $(profiler.register_query_name(QueryName::$name);)*\n+            }\n+\n+            pub fn as_str(&self) -> &'static str {\n+                match self {\n+                    $(QueryName::$name => stringify!($name),)*\n+                }\n+            }\n+        }\n+\n         #[allow(nonstandard_style)]\n         #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n         pub enum Query<$tcx> {\n@@ -894,6 +901,12 @@ macro_rules! define_queries_inner {\n                     $(Query::$name(key) => key.default_span(tcx),)*\n                 }\n             }\n+\n+            pub fn query_name(&self) -> QueryName {\n+                match self {\n+                    $(Query::$name(_) => QueryName::$name,)*\n+                }\n+            }\n         }\n \n         impl<'a, $tcx> HashStable<StableHashingContext<'a>> for Query<$tcx> {\n@@ -930,7 +943,7 @@ macro_rules! define_queries_inner {\n             type Key = $K;\n             type Value = $V;\n \n-            const NAME: &'static str = stringify!($name);\n+            const NAME: QueryName = QueryName::$name;\n             const CATEGORY: ProfileCategory = $category;\n         }\n "}, {"sha": "aabf9a401c690e7998d547634fda5d01e35945d3", "filename": "src/librustc/util/profiling.rs", "status": "modified", "additions": 83, "deletions": 357, "changes": 440, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Futil%2Fprofiling.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc%2Futil%2Fprofiling.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fprofiling.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -1,14 +1,20 @@\n use std::borrow::Cow;\n-use std::fs;\n-use std::io::{BufWriter, Write};\n-use std::mem;\n+use std::error::Error;\n+use std::mem::{self, Discriminant};\n use std::process;\n use std::thread::ThreadId;\n-use std::time::{Duration, Instant, SystemTime};\n+use std::u32;\n \n-use crate::session::config::Options;\n+use crate::ty::query::QueryName;\n \n-use rustc_data_structures::fx::FxHashMap;\n+use measureme::{StringId, TimestampKind};\n+\n+/// MmapSerializatioSink is faster on macOS and Linux\n+/// but FileSerializationSink is faster on Windows\n+#[cfg(not(windows))]\n+type Profiler = measureme::Profiler<measureme::MmapSerializationSink>;\n+#[cfg(windows)]\n+type Profiler = measureme::Profiler<measureme::FileSerializationSink>;\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, Ord, PartialOrd)]\n pub enum ProfileCategory {\n@@ -35,409 +41,129 @@ pub enum ProfilerEvent {\n     QueryBlockedEnd { query_name: &'static str, category: ProfileCategory, time: u64 },\n }\n \n-impl ProfilerEvent {\n-    fn timestamp(&self) -> u64 {\n-        use self::ProfilerEvent::*;\n-\n-        match self {\n-            QueryStart { time, .. } |\n-            QueryEnd { time, .. } |\n-            GenericActivityStart { time, .. } |\n-            GenericActivityEnd { time, .. } |\n-            QueryCacheHit { time, .. } |\n-            QueryCount { time, .. } |\n-            IncrementalLoadResultStart { time, .. } |\n-            IncrementalLoadResultEnd { time, .. } |\n-            QueryBlockedStart { time, .. } |\n-            QueryBlockedEnd { time, .. } => *time\n-        }\n-    }\n-}\n-\n fn thread_id_to_u64(tid: ThreadId) -> u64 {\n     unsafe { mem::transmute::<ThreadId, u64>(tid) }\n }\n \n pub struct SelfProfiler {\n-    events: FxHashMap<ThreadId, Vec<ProfilerEvent>>,\n-    start_time: SystemTime,\n-    start_instant: Instant,\n+    profiler: Profiler,\n+    query_event_kind: StringId,\n+    generic_activity_event_kind: StringId,\n+    incremental_load_result_event_kind: StringId,\n+    query_blocked_event_kind: StringId,\n+    query_cache_hit_event_kind: StringId,\n }\n \n impl SelfProfiler {\n-    pub fn new() -> SelfProfiler {\n-        let profiler = SelfProfiler {\n-            events: Default::default(),\n-            start_time: SystemTime::now(),\n-            start_instant: Instant::now(),\n+    pub fn new() -> Result<SelfProfiler, Box<dyn Error>> {\n+        let filename = format!(\"pid-{}.rustc_profile\", process::id());\n+        let path = std::path::Path::new(&filename);\n+        let profiler = Profiler::new(path)?;\n+\n+        let query_event_kind = profiler.alloc_string(\"Query\");\n+        let generic_activity_event_kind = profiler.alloc_string(\"GenericActivity\");\n+        let incremental_load_result_event_kind = profiler.alloc_string(\"IncrementalLoadResult\");\n+        let query_blocked_event_kind = profiler.alloc_string(\"QueryBlocked\");\n+        let query_cache_hit_event_kind = profiler.alloc_string(\"QueryCacheHit\");\n+\n+        Ok(SelfProfiler {\n+            profiler,\n+            query_event_kind,\n+            generic_activity_event_kind,\n+            incremental_load_result_event_kind,\n+            query_blocked_event_kind,\n+            query_cache_hit_event_kind,\n+        })\n+    }\n+\n+    fn get_query_name_string_id(query_name: QueryName) -> StringId {\n+        let discriminant = unsafe {\n+            mem::transmute::<Discriminant<QueryName>, u64>(mem::discriminant(&query_name))\n         };\n \n-        profiler\n+        StringId::reserved(discriminant as u32)\n+    }\n+\n+    pub fn register_query_name(&self, query_name: QueryName) {\n+        let id = SelfProfiler::get_query_name_string_id(query_name);\n+\n+        self.profiler.alloc_string_with_reserved_id(id, query_name.as_str());\n     }\n \n     #[inline]\n     pub fn start_activity(\n-        &mut self,\n-        category: ProfileCategory,\n+        &self,\n         label: impl Into<Cow<'static, str>>,\n     ) {\n-        self.record(ProfilerEvent::GenericActivityStart {\n-            category,\n-            label: label.into(),\n-            time: self.get_time_from_start(),\n-        })\n+        self.record(&label.into(), self.generic_activity_event_kind, TimestampKind::Start);\n     }\n \n     #[inline]\n     pub fn end_activity(\n-        &mut self,\n-        category: ProfileCategory,\n+        &self,\n         label: impl Into<Cow<'static, str>>,\n     ) {\n-        self.record(ProfilerEvent::GenericActivityEnd {\n-            category,\n-            label: label.into(),\n-            time: self.get_time_from_start(),\n-        })\n+        self.record(&label.into(), self.generic_activity_event_kind, TimestampKind::End);\n     }\n \n     #[inline]\n-    pub fn record_computed_queries(\n-        &mut self,\n-        query_name: &'static str,\n-        category: ProfileCategory,\n-        count: usize)\n-        {\n-        self.record(ProfilerEvent::QueryCount {\n-            query_name,\n-            category,\n-            count,\n-            time: self.get_time_from_start(),\n-        })\n+    pub fn record_query_hit(&self, query_name: QueryName) {\n+        self.record_query(query_name, self.query_cache_hit_event_kind, TimestampKind::Instant);\n     }\n \n     #[inline]\n-    pub fn record_query_hit(&mut self, query_name: &'static str, category: ProfileCategory) {\n-        self.record(ProfilerEvent::QueryCacheHit {\n-            query_name,\n-            category,\n-            time: self.get_time_from_start(),\n-        })\n+    pub fn start_query(&self, query_name: QueryName) {\n+        self.record_query(query_name, self.query_event_kind, TimestampKind::Start);\n     }\n \n     #[inline]\n-    pub fn start_query(&mut self, query_name: &'static str, category: ProfileCategory) {\n-        self.record(ProfilerEvent::QueryStart {\n-            query_name,\n-            category,\n-            time: self.get_time_from_start(),\n-        });\n+    pub fn end_query(&self, query_name: QueryName) {\n+        self.record_query(query_name, self.query_event_kind, TimestampKind::End);\n     }\n \n     #[inline]\n-    pub fn end_query(&mut self, query_name: &'static str, category: ProfileCategory) {\n-        self.record(ProfilerEvent::QueryEnd {\n+    pub fn incremental_load_result_start(&self, query_name: QueryName) {\n+        self.record_query(\n             query_name,\n-            category,\n-            time: self.get_time_from_start(),\n-        })\n+            self.incremental_load_result_event_kind,\n+            TimestampKind::Start\n+        );\n     }\n \n     #[inline]\n-    pub fn incremental_load_result_start(&mut self, query_name: &'static str) {\n-        self.record(ProfilerEvent::IncrementalLoadResultStart {\n-            query_name,\n-            time: self.get_time_from_start(),\n-        })\n+    pub fn incremental_load_result_end(&self, query_name: QueryName) {\n+        self.record_query(query_name, self.incremental_load_result_event_kind, TimestampKind::End);\n     }\n \n     #[inline]\n-    pub fn incremental_load_result_end(&mut self, query_name: &'static str) {\n-        self.record(ProfilerEvent::IncrementalLoadResultEnd {\n-            query_name,\n-            time: self.get_time_from_start(),\n-        })\n-    }\n-\n-    #[inline]\n-    pub fn query_blocked_start(&mut self, query_name: &'static str, category: ProfileCategory) {\n-        self.record(ProfilerEvent::QueryBlockedStart {\n-            query_name,\n-            category,\n-            time: self.get_time_from_start(),\n-        })\n+    pub fn query_blocked_start(&self, query_name: QueryName) {\n+        self.record_query(query_name, self.query_blocked_event_kind, TimestampKind::Start);\n     }\n \n     #[inline]\n-    pub fn query_blocked_end(&mut self, query_name: &'static str, category: ProfileCategory) {\n-        self.record(ProfilerEvent::QueryBlockedEnd {\n-            query_name,\n-            category,\n-            time: self.get_time_from_start(),\n-        })\n+    pub fn query_blocked_end(&self, query_name: QueryName) {\n+        self.record_query(query_name, self.query_blocked_event_kind, TimestampKind::End);\n     }\n \n     #[inline]\n-    fn record(&mut self, event: ProfilerEvent) {\n-        let thread_id = std::thread::current().id();\n-        let events = self.events.entry(thread_id).or_default();\n+    fn record(&self, event_id: &str, event_kind: StringId, timestamp_kind: TimestampKind) {\n+        let thread_id = thread_id_to_u64(std::thread::current().id());\n \n-        events.push(event);\n+        let event_id = self.profiler.alloc_string(event_id);\n+        self.profiler.record_event(event_kind, event_id, thread_id, timestamp_kind);\n     }\n \n     #[inline]\n-    fn get_time_from_start(&self) -> u64 {\n-        let duration = Instant::now() - self.start_instant;\n-        duration.as_nanos() as u64\n-    }\n-\n-    pub fn dump_raw_events(&self, opts: &Options) {\n-        use self::ProfilerEvent::*;\n-\n-        let pid = process::id();\n-\n-        let filename =\n-            format!(\"{}.profile_events.json\", opts.crate_name.clone().unwrap_or_default());\n-\n-        let mut file = BufWriter::new(fs::File::create(filename).unwrap());\n-\n-        let threads: Vec<_> =\n-            self.events\n-                .keys()\n-                .into_iter()\n-                .map(|tid| format!(\"{}\", thread_id_to_u64(*tid)))\n-                .collect();\n-\n-        write!(file,\n-            \"{{\\\n-                \\\"processes\\\": {{\\\n-                    \\\"{}\\\": {{\\\n-                        \\\"threads\\\": [{}],\\\n-                        \\\"crate_name\\\": \\\"{}\\\",\\\n-                        \\\"opt_level\\\": \\\"{:?}\\\",\\\n-                        \\\"incremental\\\": {}\\\n-                    }}\\\n-                }},\\\n-                \\\"events\\\": [\\\n-             \",\n-            pid,\n-            threads.join(\",\"),\n-            opts.crate_name.clone().unwrap_or_default(),\n-            opts.optimize,\n-            if opts.incremental.is_some() { \"true\" } else { \"false\" },\n-        ).unwrap();\n-\n-        let mut is_first = true;\n-        for (thread_id, events) in &self.events {\n-            let thread_id = thread_id_to_u64(*thread_id);\n-\n-            for event in events {\n-                if is_first {\n-                    is_first = false;\n-                } else {\n-                    writeln!(file, \",\").unwrap();\n-                }\n-\n-                let (secs, nanos) = {\n-                    let time = self.start_time + Duration::from_nanos(event.timestamp());\n-                    let time_since_unix =\n-                        time.duration_since(SystemTime::UNIX_EPOCH).unwrap_or_default();\n-                    (time_since_unix.as_secs(), time_since_unix.subsec_nanos())\n-                };\n+    fn record_query(\n+        &self,\n+        query_name: QueryName,\n+        event_kind: StringId,\n+        timestamp_kind: TimestampKind,\n+    ) {\n+        let dep_node_name = SelfProfiler::get_query_name_string_id(query_name);\n \n-                match event {\n-                    QueryStart { query_name, category, time: _ } =>\n-                        write!(file,\n-                            \"{{ \\\n-                                \\\"QueryStart\\\": {{ \\\n-                                    \\\"query_name\\\": \\\"{}\\\",\\\n-                                    \\\"category\\\": \\\"{:?}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            query_name,\n-                            category,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    QueryEnd { query_name, category, time: _ } =>\n-                        write!(file,\n-                            \"{{\\\n-                                \\\"QueryEnd\\\": {{\\\n-                                    \\\"query_name\\\": \\\"{}\\\",\\\n-                                    \\\"category\\\": \\\"{:?}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            query_name,\n-                            category,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    GenericActivityStart { category, label, time: _ } =>\n-                        write!(file,\n-                            \"{{\n-                                \\\"GenericActivityStart\\\": {{\\\n-                                    \\\"category\\\": \\\"{:?}\\\",\\\n-                                    \\\"label\\\": \\\"{}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            category,\n-                            label,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    GenericActivityEnd { category, label, time: _ } =>\n-                        write!(file,\n-                            \"{{\\\n-                                \\\"GenericActivityEnd\\\": {{\\\n-                                    \\\"category\\\": \\\"{:?}\\\",\\\n-                                    \\\"label\\\": \\\"{}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            category,\n-                            label,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    QueryCacheHit { query_name, category, time: _ } =>\n-                        write!(file,\n-                            \"{{\\\n-                                \\\"QueryCacheHit\\\": {{\\\n-                                    \\\"query_name\\\": \\\"{}\\\",\\\n-                                    \\\"category\\\": \\\"{:?}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            query_name,\n-                            category,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    QueryCount { query_name, category, count, time: _ } =>\n-                        write!(file,\n-                            \"{{\\\n-                                \\\"QueryCount\\\": {{\\\n-                                    \\\"query_name\\\": \\\"{}\\\",\\\n-                                    \\\"category\\\": \\\"{:?}\\\",\\\n-                                    \\\"count\\\": {},\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            query_name,\n-                            category,\n-                            count,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    IncrementalLoadResultStart { query_name, time: _ } =>\n-                        write!(file,\n-                            \"{{\\\n-                                \\\"IncrementalLoadResultStart\\\": {{\\\n-                                    \\\"query_name\\\": \\\"{}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            query_name,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    IncrementalLoadResultEnd { query_name, time: _ } =>\n-                        write!(file,\n-                            \"{{\\\n-                                \\\"IncrementalLoadResultEnd\\\": {{\\\n-                                    \\\"query_name\\\": \\\"{}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            query_name,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    QueryBlockedStart { query_name, category, time: _ } =>\n-                        write!(file,\n-                            \"{{\\\n-                                \\\"QueryBlockedStart\\\": {{\\\n-                                    \\\"query_name\\\": \\\"{}\\\",\\\n-                                    \\\"category\\\": \\\"{:?}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            query_name,\n-                            category,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                    QueryBlockedEnd { query_name, category, time: _ } =>\n-                        write!(file,\n-                            \"{{\\\n-                                \\\"QueryBlockedEnd\\\": {{\\\n-                                    \\\"query_name\\\": \\\"{}\\\",\\\n-                                    \\\"category\\\": \\\"{:?}\\\",\\\n-                                    \\\"time\\\": {{\\\n-                                        \\\"secs\\\": {},\\\n-                                        \\\"nanos\\\": {}\\\n-                                    }},\\\n-                                    \\\"thread_id\\\": {}\\\n-                                }}\\\n-                            }}\",\n-                            query_name,\n-                            category,\n-                            secs,\n-                            nanos,\n-                            thread_id,\n-                        ).unwrap(),\n-                }\n-            }\n-        }\n+        let thread_id = thread_id_to_u64(std::thread::current().id());\n \n-        write!(file, \"] }}\").unwrap();\n+        self.profiler.record_event(event_kind, dep_node_name, thread_id, timestamp_kind);\n     }\n }"}, {"sha": "348f1a121269ed965413ec39e6396c9e93c7e888", "filename": "src/librustc_codegen_llvm/back/lto.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Flto.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -15,7 +15,6 @@ use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n use rustc::session::config::{self, Lto};\n use rustc::util::common::time_ext;\n-use rustc::util::profiling::ProfileCategory;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_codegen_ssa::{ModuleCodegen, ModuleKind};\n \n@@ -67,8 +66,7 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         .iter()\n         .filter_map(symbol_filter)\n         .collect::<Vec<CString>>();\n-    let _timer = cgcx.profile_activity(ProfileCategory::Codegen,\n-                                       \"generate_symbol_white_list_for_thinlto\");\n+    let _timer = cgcx.profile_activity(\"generate_symbol_white_list_for_thinlto\");\n     info!(\"{} symbols to preserve in this crate\", symbol_white_list.len());\n \n     // If we're performing LTO for the entire crate graph, then for each of our\n@@ -97,8 +95,7 @@ fn prepare_lto(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         }\n \n         for &(cnum, ref path) in cgcx.each_linked_rlib_for_lto.iter() {\n-            let _timer = cgcx.profile_activity(ProfileCategory::Codegen,\n-                                               format!(\"load: {}\", path.display()));\n+            let _timer = cgcx.profile_activity(format!(\"load: {}\", path.display()));\n             let exported_symbols = cgcx.exported_symbols\n                 .as_ref().expect(\"needs exported symbols for LTO\");\n             symbol_white_list.extend(\n@@ -727,8 +724,7 @@ pub unsafe fn optimize_thin_module(\n         // Like with \"fat\" LTO, get some better optimizations if landing pads\n         // are disabled by removing all landing pads.\n         if cgcx.no_landing_pads {\n-            let _timer = cgcx.profile_activity(ProfileCategory::Codegen,\n-                                               \"LLVM_remove_landing_pads\");\n+            let _timer = cgcx.profile_activity(\"LLVM_remove_landing_pads\");\n             llvm::LLVMRustMarkAllFunctionsNounwind(llmod);\n             save_temp_bitcode(&cgcx, &module, \"thin-lto-after-nounwind\");\n         }"}, {"sha": "4d52df91a8d91b16303dc4d45beffb13c97e31dc", "filename": "src/librustc_codegen_llvm/back/write.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fback%2Fwrite.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -18,7 +18,6 @@ use rustc::session::Session;\n use rustc::ty::TyCtxt;\n use rustc_codegen_ssa::{ModuleCodegen, CompiledModule};\n use rustc::util::common::time_ext;\n-use rustc::util::profiling::ProfileCategory;\n use rustc_fs_util::{path_to_c_string, link_or_copy};\n use rustc_data_structures::small_c_str::SmallCStr;\n use errors::{Handler, FatalError};\n@@ -414,7 +413,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n         // Finally, run the actual optimization passes\n         {\n-            let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_function_passes\");\n+            let _timer = cgcx.profile_activity(\"LLVM_function_passes\");\n             time_ext(config.time_passes,\n                         None,\n                         &format!(\"llvm function passes [{}]\", module_name.unwrap()),\n@@ -423,7 +422,7 @@ pub(crate) unsafe fn optimize(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             });\n         }\n         {\n-            let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_module_passes\");\n+            let _timer = cgcx.profile_activity(\"LLVM_module_passes\");\n             time_ext(config.time_passes,\n                     None,\n                     &format!(\"llvm module passes [{}]\", module_name.unwrap()),\n@@ -445,7 +444,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n                   config: &ModuleConfig)\n     -> Result<CompiledModule, FatalError>\n {\n-    let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"codegen\");\n+    let _timer = cgcx.profile_activity(\"codegen\");\n     {\n         let llmod = module.module_llvm.llmod();\n         let llcx = &*module.module_llvm.llcx;\n@@ -496,26 +495,25 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n \n \n         if write_bc || config.emit_bc_compressed || config.embed_bitcode {\n-            let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_make_bitcode\");\n+            let _timer = cgcx.profile_activity(\"LLVM_make_bitcode\");\n             let thin = ThinBuffer::new(llmod);\n             let data = thin.data();\n \n             if write_bc {\n-                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_emit_bitcode\");\n+                let _timer = cgcx.profile_activity(\"LLVM_emit_bitcode\");\n                 if let Err(e) = fs::write(&bc_out, data) {\n                     let msg = format!(\"failed to write bytecode to {}: {}\", bc_out.display(), e);\n                     diag_handler.err(&msg);\n                 }\n             }\n \n             if config.embed_bitcode {\n-                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_embed_bitcode\");\n+                let _timer = cgcx.profile_activity(\"LLVM_embed_bitcode\");\n                 embed_bitcode(cgcx, llcx, llmod, Some(data));\n             }\n \n             if config.emit_bc_compressed {\n-                let _timer = cgcx.profile_activity(ProfileCategory::Codegen,\n-                                                   \"LLVM_compress_bitcode\");\n+                let _timer = cgcx.profile_activity(\"LLVM_compress_bitcode\");\n                 let dst = bc_out.with_extension(RLIB_BYTECODE_EXTENSION);\n                 let data = bytecode::encode(&module.name, data);\n                 if let Err(e) = fs::write(&dst, data) {\n@@ -530,7 +528,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n         time_ext(config.time_passes, None, &format!(\"codegen passes [{}]\", module_name.unwrap()),\n             || -> Result<(), FatalError> {\n             if config.emit_ir {\n-                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_emit_ir\");\n+                let _timer = cgcx.profile_activity(\"LLVM_emit_ir\");\n                 let out = cgcx.output_filenames.temp_path(OutputType::LlvmAssembly, module_name);\n                 let out_c = path_to_c_string(&out);\n \n@@ -577,7 +575,7 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }\n \n             if config.emit_asm || asm_to_obj {\n-                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_emit_asm\");\n+                let _timer = cgcx.profile_activity(\"LLVM_emit_asm\");\n                 let path = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n \n                 // We can't use the same module for asm and binary output, because that triggers\n@@ -595,13 +593,13 @@ pub(crate) unsafe fn codegen(cgcx: &CodegenContext<LlvmCodegenBackend>,\n             }\n \n             if write_obj {\n-                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_emit_obj\");\n+                let _timer = cgcx.profile_activity(\"LLVM_emit_obj\");\n                 with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                     write_output_file(diag_handler, tm, cpm, llmod, &obj_out,\n                                       llvm::FileType::ObjectFile)\n                 })?;\n             } else if asm_to_obj {\n-                let _timer = cgcx.profile_activity(ProfileCategory::Codegen, \"LLVM_asm_to_obj\");\n+                let _timer = cgcx.profile_activity(\"LLVM_asm_to_obj\");\n                 let assembly = cgcx.output_filenames.temp_path(OutputType::Assembly, module_name);\n                 run_assembler(cgcx, diag_handler, &assembly, &obj_out);\n "}, {"sha": "da91217e95e3d80522a81ed18ed4d426c30609ab", "filename": "src/librustc_codegen_llvm/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Flib.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -65,7 +65,6 @@ use rustc::middle::cstore::{EncodedMetadata, MetadataLoader};\n use rustc::session::Session;\n use rustc::session::config::{OutputFilenames, OutputType, PrintRequest, OptLevel};\n use rustc::ty::{self, TyCtxt};\n-use rustc::util::profiling::ProfileCategory;\n use rustc::util::common::ErrorReported;\n use rustc_mir::monomorphize;\n use rustc_codegen_ssa::ModuleCodegen;\n@@ -330,12 +329,12 @@ impl CodegenBackend for LlvmCodegenBackend {\n \n         // Run the linker on any artifacts that resulted from the LLVM run.\n         // This should produce either a finished executable or library.\n-        sess.profiler(|p| p.start_activity(ProfileCategory::Linking, \"link_crate\"));\n+        sess.profiler(|p| p.start_activity(\"link_crate\"));\n         time(sess, \"linking\", || {\n             back::link::link_binary(sess, &codegen_results,\n                                     outputs, &codegen_results.crate_name.as_str());\n         });\n-        sess.profiler(|p| p.end_activity(ProfileCategory::Linking, \"link_crate\"));\n+        sess.profiler(|p| p.end_activity(\"link_crate\"));\n \n         // Now that we won't touch anything in the incremental compilation directory\n         // any more, we can finalize it (which involves renaming it)"}, {"sha": "f5affad4cce0c8f22c90c242bb50d05721bf40f5", "filename": "src/librustc_codegen_ssa/back/write.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fwrite.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -18,7 +18,7 @@ use rustc::util::nodemap::FxHashMap;\n use rustc::hir::def_id::{CrateNum, LOCAL_CRATE};\n use rustc::ty::TyCtxt;\n use rustc::util::common::{time_depth, set_time_depth, print_time_passes_entry};\n-use rustc::util::profiling::{ProfileCategory, SelfProfiler};\n+use rustc::util::profiling::SelfProfiler;\n use rustc_fs_util::link_or_copy;\n use rustc_data_structures::svh::Svh;\n use rustc_errors::{Handler, Level, DiagnosticBuilder, FatalError, DiagnosticId};\n@@ -29,7 +29,6 @@ use syntax::ext::hygiene::Mark;\n use syntax_pos::MultiSpan;\n use syntax_pos::symbol::Symbol;\n use jobserver::{Client, Acquired};\n-use parking_lot::Mutex as PlMutex;\n \n use std::any::Any;\n use std::borrow::Cow;\n@@ -198,25 +197,21 @@ impl<B: WriteBackendMethods> Clone for TargetMachineFactory<B> {\n }\n \n pub struct ProfileGenericActivityTimer {\n-    profiler: Option<Arc<PlMutex<SelfProfiler>>>,\n-    category: ProfileCategory,\n+    profiler: Option<Arc<SelfProfiler>>,\n     label: Cow<'static, str>,\n }\n \n impl ProfileGenericActivityTimer {\n     pub fn start(\n-        profiler: Option<Arc<PlMutex<SelfProfiler>>>,\n-        category: ProfileCategory,\n+        profiler: Option<Arc<SelfProfiler>>,\n         label: Cow<'static, str>,\n     ) -> ProfileGenericActivityTimer {\n         if let Some(profiler) = &profiler {\n-            let mut p = profiler.lock();\n-            p.start_activity(category, label.clone());\n+            profiler.start_activity(label.clone());\n         }\n \n         ProfileGenericActivityTimer {\n             profiler,\n-            category,\n             label,\n         }\n     }\n@@ -225,8 +220,7 @@ impl ProfileGenericActivityTimer {\n impl Drop for ProfileGenericActivityTimer {\n     fn drop(&mut self) {\n         if let Some(profiler) = &self.profiler {\n-            let mut p = profiler.lock();\n-            p.end_activity(self.category, self.label.clone());\n+            profiler.end_activity(self.label.clone());\n         }\n     }\n }\n@@ -237,7 +231,7 @@ pub struct CodegenContext<B: WriteBackendMethods> {\n     // Resources needed when running LTO\n     pub backend: B,\n     pub time_passes: bool,\n-    pub profiler: Option<Arc<PlMutex<SelfProfiler>>>,\n+    pub profiler: Option<Arc<SelfProfiler>>,\n     pub lto: Lto,\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n@@ -291,30 +285,27 @@ impl<B: WriteBackendMethods> CodegenContext<B> {\n \n     #[inline(never)]\n     #[cold]\n-    fn profiler_active<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+    fn profiler_active<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n         match &self.profiler {\n             None => bug!(\"profiler_active() called but there was no profiler active\"),\n             Some(profiler) => {\n-                let mut p = profiler.lock();\n-\n-                f(&mut p);\n+                f(&*profiler);\n             }\n         }\n     }\n \n     #[inline(always)]\n-    pub fn profile<F: FnOnce(&mut SelfProfiler) -> ()>(&self, f: F) {\n+    pub fn profile<F: FnOnce(&SelfProfiler) -> ()>(&self, f: F) {\n         if unlikely!(self.profiler.is_some()) {\n             self.profiler_active(f)\n         }\n     }\n \n     pub fn profile_activity(\n         &self,\n-        category: ProfileCategory,\n         label: impl Into<Cow<'static, str>>,\n     ) -> ProfileGenericActivityTimer {\n-        ProfileGenericActivityTimer::start(self.profiler.clone(), category, label.into())\n+        ProfileGenericActivityTimer::start(self.profiler.clone(), label.into())\n     }\n }\n \n@@ -324,7 +315,7 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n     needs_thin_lto: Vec<(String, B::ThinBuffer)>,\n     import_only_modules: Vec<(SerializedModule<B::ModuleBuffer>, WorkProduct)>\n ) -> Vec<(WorkItem<B>, u64)> {\n-    cgcx.profile(|p| p.start_activity(ProfileCategory::Linking, \"codegen_run_lto\"));\n+    cgcx.profile(|p| p.start_activity(\"codegen_run_lto\"));\n \n     let (lto_modules, copy_jobs) = if !needs_fat_lto.is_empty() {\n         assert!(needs_thin_lto.is_empty());\n@@ -351,7 +342,7 @@ fn generate_lto_work<B: ExtraBackendMethods>(\n         }), 0)\n     })).collect();\n \n-    cgcx.profile(|p| p.end_activity(ProfileCategory::Linking, \"codegen_run_lto\"));\n+    cgcx.profile(|p| p.end_activity(\"codegen_run_lto\"));\n \n     result\n }\n@@ -1655,9 +1646,9 @@ fn spawn_work<B: ExtraBackendMethods>(\n         // surface that there was an error in this worker.\n         bomb.result = {\n             let label = work.name();\n-            cgcx.profile(|p| p.start_activity(ProfileCategory::Codegen, label.clone()));\n+            cgcx.profile(|p| p.start_activity(label.clone()));\n             let result = execute_work_item(&cgcx, work).ok();\n-            cgcx.profile(|p| p.end_activity(ProfileCategory::Codegen, label));\n+            cgcx.profile(|p| p.end_activity(label));\n \n             result\n         };"}, {"sha": "6cb54831a074368b2a8d9ef98dcbfdb837cde457", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -25,7 +25,6 @@ use rustc::ty::layout::{self, Align, TyLayout, LayoutOf, VariantIdx, HasTyCtxt};\n use rustc::ty::query::Providers;\n use rustc::middle::cstore::{self, LinkagePreference};\n use rustc::util::common::{time, print_time_passes_entry};\n-use rustc::util::profiling::ProfileCategory;\n use rustc::session::config::{self, EntryFnType, Lto};\n use rustc::session::Session;\n use rustc_mir::monomorphize::item::DefPathBasedNames;\n@@ -539,7 +538,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     let cgu_name_builder = &mut CodegenUnitNameBuilder::new(tcx);\n \n     // Codegen the metadata.\n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen, \"codegen crate metadata\"));\n+    tcx.sess.profiler(|p| p.start_activity(\"codegen crate metadata\"));\n \n     let metadata_cgu_name = cgu_name_builder.build_cgu_name(LOCAL_CRATE,\n                                                             &[\"crate\"],\n@@ -549,7 +548,7 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n     let metadata = time(tcx.sess, \"write metadata\", || {\n         backend.write_metadata(tcx, &mut metadata_llvm_module)\n     });\n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen, \"codegen crate metadata\"));\n+    tcx.sess.profiler(|p| p.end_activity(\"codegen crate metadata\"));\n \n     let metadata_module = ModuleCodegen {\n         name: metadata_cgu_name,\n@@ -662,14 +661,12 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen,\n-                                                       format!(\"codegen {}\", cgu.name())));\n+                tcx.sess.profiler(|p| p.start_activity(format!(\"codegen {}\", cgu.name())));\n                 let start_time = Instant::now();\n                 let stats = backend.compile_codegen_unit(tcx, *cgu.name());\n                 all_stats.extend(stats);\n                 total_codegen_time += start_time.elapsed();\n-                tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen,\n-                                                     format!(\"codegen {}\", cgu.name())));\n+                tcx.sess.profiler(|p| p.end_activity(format!(\"codegen {}\", cgu.name())));\n                 false\n             }\n             CguReuse::PreLto => {"}, {"sha": "23575e51dfcd9c52d75b76eb067dc6070d9b242a", "filename": "src/librustc_interface/interface.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_interface%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_interface%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Finterface.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -123,10 +123,6 @@ where\n         profile::dump(&compiler.sess, \"profile_queries\".to_string())\n     }\n \n-    if compiler.sess.opts.debugging_opts.self_profile {\n-        compiler.sess.profiler(|p| p.dump_raw_events(&compiler.sess.opts));\n-    }\n-\n     r\n }\n "}, {"sha": "3fd684f5d97e99e5f3f6ab38bd2fd8661e6ed8b3", "filename": "src/librustc_interface/passes.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_interface%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_interface%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_interface%2Fpasses.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -69,15 +69,15 @@ pub fn parse<'a>(sess: &'a Session, input: &Input) -> PResult<'a, ast::Crate> {\n         .set_continue_after_error(sess.opts.debugging_opts.continue_parse_after_error);\n     hygiene::set_default_edition(sess.edition());\n \n-    sess.profiler(|p| p.start_activity(ProfileCategory::Parsing, \"parsing\"));\n+    sess.profiler(|p| p.start_activity(\"parsing\"));\n     let krate = time(sess, \"parsing\", || match *input {\n         Input::File(ref file) => parse::parse_crate_from_file(file, &sess.parse_sess),\n         Input::Str {\n             ref input,\n             ref name,\n         } => parse::parse_crate_from_source_str(name.clone(), input.clone(), &sess.parse_sess),\n     })?;\n-    sess.profiler(|p| p.end_activity(ProfileCategory::Parsing, \"parsing\"));\n+    sess.profiler(|p| p.end_activity(\"parsing\"));\n \n     sess.diagnostic().set_continue_after_error(true);\n \n@@ -375,7 +375,7 @@ fn configure_and_expand_inner<'a>(\n     syntax_ext::register_builtins(&mut resolver, plugin_info.syntax_exts);\n \n     // Expand all macros\n-    sess.profiler(|p| p.start_activity(ProfileCategory::Expansion, \"macro expansion\"));\n+    sess.profiler(|p| p.start_activity(\"macro expansion\"));\n     krate = time(sess, \"expansion\", || {\n         // Windows dlls do not have rpaths, so they don't know how to find their\n         // dependencies. It's up to us to tell the system where to find all the\n@@ -450,7 +450,7 @@ fn configure_and_expand_inner<'a>(\n         }\n         krate\n     });\n-    sess.profiler(|p| p.end_activity(ProfileCategory::Expansion, \"macro expansion\"));\n+    sess.profiler(|p| p.end_activity(\"macro expansion\"));\n \n     time(sess, \"maybe building test harness\", || {\n         syntax::test::modify_for_testing(\n@@ -869,8 +869,6 @@ pub fn create_global_ctxt(\n         yield BoxedGlobalCtxt::initial_yield(());\n         box_region_allow_access!(for('gcx), (&'gcx GlobalCtxt<'gcx>), (gcx));\n \n-        gcx.queries.record_computed_queries(sess);\n-\n         if sess.opts.debugging_opts.query_stats {\n             gcx.queries.print_stats();\n         }\n@@ -1022,9 +1020,9 @@ pub fn start_codegen<'tcx>(\n         ::rustc::middle::dependency_format::calculate(tcx)\n     });\n \n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::Codegen, \"codegen crate\"));\n+    tcx.sess.profiler(|p| p.start_activity(\"codegen crate\"));\n     let codegen = time(tcx.sess, \"codegen\", move || codegen_backend.codegen_crate(tcx, rx));\n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::Codegen, \"codegen crate\"));\n+    tcx.sess.profiler(|p| p.end_activity(\"codegen crate\"));\n \n     if log_enabled!(::log::Level::Info) {\n         println!(\"Post-codegen\");"}, {"sha": "21d1af229ddc2815a4536ed9499cff0adf4378e6", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -109,7 +109,6 @@ use rustc::ty::subst::SubstsRef;\n use rustc::ty::{self, Ty, TyCtxt};\n use rustc::ty::query::Providers;\n use rustc::util;\n-use rustc::util::profiling::ProfileCategory;\n use syntax_pos::Span;\n use util::common::time;\n \n@@ -319,7 +318,7 @@ pub fn provide(providers: &mut Providers<'_>) {\n pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n                              -> Result<(), ErrorReported>\n {\n-    tcx.sess.profiler(|p| p.start_activity(ProfileCategory::TypeChecking, \"type-check crate\"));\n+    tcx.sess.profiler(|p| p.start_activity(\"type-check crate\"));\n \n     // this ensures that later parts of type checking can assume that items\n     // have valid types and not error\n@@ -370,7 +369,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n     check_unused::check_crate(tcx);\n     check_for_entry_fn(tcx);\n \n-    tcx.sess.profiler(|p| p.end_activity(ProfileCategory::TypeChecking, \"type-check crate\"));\n+    tcx.sess.profiler(|p| p.end_activity(\"type-check crate\"));\n \n     if tcx.sess.err_count() == 0 {\n         Ok(())"}, {"sha": "411961d70bf88afb30cd59583e3a541a16c40719", "filename": "src/tools/tidy/src/deps.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/896c3a570f4c41662a471914e0c8b4793de4a2a0/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fdeps.rs?ref=896c3a570f4c41662a471914e0c8b4793de4a2a0", "patch": "@@ -96,6 +96,7 @@ const WHITELIST: &[Crate<'_>] = &[\n     Crate(\"lock_api\"),\n     Crate(\"log\"),\n     Crate(\"log_settings\"),\n+    Crate(\"measureme\"),\n     Crate(\"memchr\"),\n     Crate(\"memmap\"),\n     Crate(\"memoffset\"),"}]}