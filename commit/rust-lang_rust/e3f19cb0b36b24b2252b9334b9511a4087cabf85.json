{"sha": "e3f19cb0b36b24b2252b9334b9511a4087cabf85", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZjE5Y2IwYjM2YjI0YjIyNTJiOTMzNGI5NTExYTQwODdjYWJmODU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-09T17:37:14Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-05-11T17:49:44Z"}, "message": "trans: Move TransItem to its own module.", "tree": {"sha": "69e23eb32c9d0fd93fd70c70a6844bcdca31bb05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69e23eb32c9d0fd93fd70c70a6844bcdca31bb05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3f19cb0b36b24b2252b9334b9511a4087cabf85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f19cb0b36b24b2252b9334b9511a4087cabf85", "html_url": "https://github.com/rust-lang/rust/commit/e3f19cb0b36b24b2252b9334b9511a4087cabf85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3f19cb0b36b24b2252b9334b9511a4087cabf85/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c0495417416c8e0687bc6a997507c403627f6568", "url": "https://api.github.com/repos/rust-lang/rust/commits/c0495417416c8e0687bc6a997507c403627f6568", "html_url": "https://github.com/rust-lang/rust/commit/c0495417416c8e0687bc6a997507c403627f6568"}], "stats": {"total": 750, "additions": 383, "deletions": 367}, "files": [{"sha": "99c059d0b5376f6abed5e00ed3fa6b3320f8b8d6", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=e3f19cb0b36b24b2252b9334b9511a4087cabf85", "patch": "@@ -59,7 +59,7 @@ use callee::{Callee, CallArgs, ArgExprs, ArgVals};\n use cleanup::{self, CleanupMethods, DropHint};\n use closure;\n use common::{Block, C_bool, C_bytes_in_context, C_i32, C_int, C_uint, C_integral};\n-use collector::{self, TransItem, TransItemState, TransItemCollectionMode};\n+use collector::{self, TransItemState, TransItemCollectionMode};\n use common::{C_null, C_struct_in_context, C_u64, C_u8, C_undef};\n use common::{CrateContext, DropFlagHintsMap, Field, FunctionContext};\n use common::{Result, NodeIdAndSpan, VariantInfo};\n@@ -82,6 +82,7 @@ use mir;\n use monomorphize::{self, Instance};\n use partitioning::{self, PartitioningStrategy, InstantiationMode, CodegenUnit};\n use symbol_names_test;\n+use trans_item::TransItem;\n use tvec;\n use type_::Type;\n use type_of;"}, {"sha": "a6efc9030bfa639b92662238389d436469f94fd4", "filename": "src/librustc_trans/collector.rs", "status": "modified", "additions": 4, "deletions": 361, "changes": 365, "blob_url": "https://github.com/rust-lang/rust/blob/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcollector.rs?ref=e3f19cb0b36b24b2252b9334b9511a4087cabf85", "patch": "@@ -198,61 +198,32 @@ use rustc::hir::def_id::DefId;\n use rustc::middle::lang_items::{ExchangeFreeFnLangItem, ExchangeMallocFnLangItem};\n use rustc::traits;\n use rustc::ty::subst::{self, Substs, Subst};\n-use rustc::ty::{self, Ty, TypeFoldable, TyCtxt};\n+use rustc::ty::{self, TypeFoldable, TyCtxt};\n use rustc::ty::adjustment::CustomCoerceUnsized;\n use rustc::mir::repr as mir;\n use rustc::mir::visit as mir_visit;\n use rustc::mir::visit::Visitor as MirVisitor;\n \n-use syntax::ast::{self, NodeId};\n use syntax::codemap::DUMMY_SP;\n-use syntax::{attr, errors};\n-use syntax::parse::token;\n+use syntax::errors;\n \n-use base::{custom_coerce_unsize_info, llvm_linkage_by_name};\n+use base::custom_coerce_unsize_info;\n use context::SharedCrateContext;\n use common::{fulfill_obligation, normalize_and_test_predicates, type_is_sized};\n use glue::{self, DropGlueKind};\n-use llvm;\n use meth;\n use monomorphize::{self, Instance};\n use util::nodemap::{FnvHashSet, FnvHashMap, DefIdMap};\n \n use std::hash::{Hash, Hasher};\n+use trans_item::{TransItem, type_to_string, def_id_to_string};\n \n #[derive(PartialEq, Eq, Hash, Clone, Copy, Debug)]\n pub enum TransItemCollectionMode {\n     Eager,\n     Lazy\n }\n \n-#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n-pub enum TransItem<'tcx> {\n-    DropGlue(DropGlueKind<'tcx>),\n-    Fn(Instance<'tcx>),\n-    Static(NodeId)\n-}\n-\n-impl<'tcx> Hash for TransItem<'tcx> {\n-    fn hash<H: Hasher>(&self, s: &mut H) {\n-        match *self {\n-            TransItem::DropGlue(t) => {\n-                0u8.hash(s);\n-                t.hash(s);\n-            },\n-            TransItem::Fn(instance) => {\n-                1u8.hash(s);\n-                instance.def.hash(s);\n-                (instance.substs as *const _ as usize).hash(s);\n-            }\n-            TransItem::Static(node_id) => {\n-                2u8.hash(s);\n-                node_id.hash(s);\n-            }\n-        };\n-    }\n-}\n-\n /// Maps every translation item to all translation items it references in its\n /// body.\n pub struct ReferenceMap<'tcx> {\n@@ -1210,334 +1181,6 @@ fn create_trans_items_for_default_impls<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     }\n }\n \n-//=-----------------------------------------------------------------------------\n-// TransItem String Keys\n-//=-----------------------------------------------------------------------------\n-\n-// The code below allows for producing a unique string key for a trans item.\n-// These keys are used by the handwritten auto-tests, so they need to be\n-// predictable and human-readable.\n-//\n-// Note: A lot of this could looks very similar to what's already in the\n-//       ppaux module. It would be good to refactor things so we only have one\n-//       parameterizable implementation for printing types.\n-\n-/// Same as `unique_type_name()` but with the result pushed onto the given\n-/// `output` parameter.\n-pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                       t: ty::Ty<'tcx>,\n-                                       output: &mut String) {\n-    match t.sty {\n-        ty::TyBool              => output.push_str(\"bool\"),\n-        ty::TyChar              => output.push_str(\"char\"),\n-        ty::TyStr               => output.push_str(\"str\"),\n-        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n-        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n-        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n-        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n-        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n-        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n-        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n-        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n-        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n-        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n-        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n-        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n-        ty::TyStruct(adt_def, substs) |\n-        ty::TyEnum(adt_def, substs) => {\n-            push_item_name(tcx, adt_def.did, output);\n-            push_type_params(tcx, &substs.types, &[], output);\n-        },\n-        ty::TyTuple(component_types) => {\n-            output.push('(');\n-            for &component_type in component_types {\n-                push_unique_type_name(tcx, component_type, output);\n-                output.push_str(\", \");\n-            }\n-            if !component_types.is_empty() {\n-                output.pop();\n-                output.pop();\n-            }\n-            output.push(')');\n-        },\n-        ty::TyBox(inner_type) => {\n-            output.push_str(\"Box<\");\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push('>');\n-        },\n-        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n-            output.push('*');\n-            match mutbl {\n-                hir::MutImmutable => output.push_str(\"const \"),\n-                hir::MutMutable => output.push_str(\"mut \"),\n-            }\n-\n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n-            output.push('&');\n-            if mutbl == hir::MutMutable {\n-                output.push_str(\"mut \");\n-            }\n-\n-            push_unique_type_name(tcx, inner_type, output);\n-        },\n-        ty::TyArray(inner_type, len) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push_str(&format!(\"; {}\", len));\n-            output.push(']');\n-        },\n-        ty::TySlice(inner_type) => {\n-            output.push('[');\n-            push_unique_type_name(tcx, inner_type, output);\n-            output.push(']');\n-        },\n-        ty::TyTrait(ref trait_data) => {\n-            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n-            push_type_params(tcx,\n-                             &trait_data.principal.skip_binder().substs.types,\n-                             &trait_data.bounds.projection_bounds,\n-                             output);\n-        },\n-        ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n-        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n-            if unsafety == hir::Unsafety::Unsafe {\n-                output.push_str(\"unsafe \");\n-            }\n-\n-            if abi != ::abi::Abi::Rust {\n-                output.push_str(\"extern \\\"\");\n-                output.push_str(abi.name());\n-                output.push_str(\"\\\" \");\n-            }\n-\n-            output.push_str(\"fn(\");\n-\n-            let sig = tcx.erase_late_bound_regions(sig);\n-            if !sig.inputs.is_empty() {\n-                for &parameter_type in &sig.inputs {\n-                    push_unique_type_name(tcx, parameter_type, output);\n-                    output.push_str(\", \");\n-                }\n-                output.pop();\n-                output.pop();\n-            }\n-\n-            if sig.variadic {\n-                if !sig.inputs.is_empty() {\n-                    output.push_str(\", ...\");\n-                } else {\n-                    output.push_str(\"...\");\n-                }\n-            }\n-\n-            output.push(')');\n-\n-            match sig.output {\n-                ty::FnConverging(result_type) if result_type.is_nil() => {}\n-                ty::FnConverging(result_type) => {\n-                    output.push_str(\" -> \");\n-                    push_unique_type_name(tcx, result_type, output);\n-                }\n-                ty::FnDiverging => {\n-                    output.push_str(\" -> !\");\n-                }\n-            }\n-        },\n-        ty::TyClosure(def_id, ref closure_substs) => {\n-            push_item_name(tcx, def_id, output);\n-            output.push_str(\"{\");\n-            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n-            output.push_str(\"}\");\n-            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n-        }\n-        ty::TyError |\n-        ty::TyInfer(_) |\n-        ty::TyProjection(..) |\n-        ty::TyParam(_) => {\n-            bug!(\"debuginfo: Trying to create type name for \\\n-                  unexpected type: {:?}\", t);\n-        }\n-    }\n-}\n-\n-fn push_item_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            def_id: DefId,\n-                            output: &mut String) {\n-    let def_path = tcx.def_path(def_id);\n-\n-    // some_crate::\n-    output.push_str(&tcx.crate_name(def_path.krate));\n-    output.push_str(\"::\");\n-\n-    // foo::bar::ItemName::\n-    for part in tcx.def_path(def_id).data {\n-        output.push_str(&format!(\"{}[{}]::\",\n-                        part.data.as_interned_str(),\n-                        part.disambiguator));\n-    }\n-\n-    // remove final \"::\"\n-    output.pop();\n-    output.pop();\n-}\n-\n-fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n-                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n-                              output: &mut String) {\n-    if types.is_empty() && projections.is_empty() {\n-        return;\n-    }\n-\n-    output.push('<');\n-\n-    for &type_parameter in types {\n-        push_unique_type_name(tcx, type_parameter, output);\n-        output.push_str(\", \");\n-    }\n-\n-    for projection in projections {\n-        let projection = projection.skip_binder();\n-        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n-        output.push_str(&name[..]);\n-        output.push_str(\"=\");\n-        push_unique_type_name(tcx, projection.ty, output);\n-        output.push_str(\", \");\n-    }\n-\n-    output.pop();\n-    output.pop();\n-\n-    output.push('>');\n-}\n-\n-fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     instance: Instance<'tcx>,\n-                                     output: &mut String) {\n-    push_item_name(tcx, instance.def, output);\n-    push_type_params(tcx, &instance.substs.types, &[], output);\n-}\n-\n-pub fn def_id_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                  def_id: DefId) -> String {\n-    let mut output = String::new();\n-    push_item_name(tcx, def_id, &mut output);\n-    output\n-}\n-\n-fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                            ty: ty::Ty<'tcx>)\n-                            -> String {\n-    let mut output = String::new();\n-    push_unique_type_name(tcx, ty, &mut output);\n-    output\n-}\n-\n-impl<'a, 'tcx> TransItem<'tcx> {\n-    pub fn requests_inline(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => {\n-                let attributes = tcx.get_attrs(instance.def);\n-                attr::requests_inline(&attributes[..])\n-            }\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_from_extern_crate(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.def.is_local(),\n-            TransItem::DropGlue(..) |\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn is_lazily_instantiated(&self) -> bool {\n-        match *self {\n-            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n-            TransItem::DropGlue(..) => true,\n-            TransItem::Static(..)   => false,\n-        }\n-    }\n-\n-    pub fn explicit_linkage(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n-        let def_id = match *self {\n-            TransItem::Fn(ref instance) => instance.def,\n-            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n-            TransItem::DropGlue(..) => return None,\n-        };\n-\n-        let attributes = tcx.get_attrs(def_id);\n-        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n-            if let Some(linkage) = llvm_linkage_by_name(&name) {\n-                Some(linkage)\n-            } else {\n-                let span = tcx.map.span_if_local(def_id);\n-                if let Some(span) = span {\n-                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n-                } else {\n-                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n-                }\n-            }\n-        } else {\n-            None\n-        }\n-    }\n-\n-    pub fn to_string(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n-        let hir_map = &tcx.map;\n-\n-        return match *self {\n-            TransItem::DropGlue(dg) => {\n-                let mut s = String::with_capacity(32);\n-                match dg {\n-                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n-                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n-                };\n-                push_unique_type_name(tcx, dg.ty(), &mut s);\n-                s\n-            }\n-            TransItem::Fn(instance) => {\n-                to_string_internal(tcx, \"fn \", instance)\n-            },\n-            TransItem::Static(node_id) => {\n-                let def_id = hir_map.local_def_id(node_id);\n-                let instance = Instance::mono(tcx, def_id);\n-                to_string_internal(tcx, \"static \", instance)\n-            },\n-        };\n-\n-        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                        prefix: &str,\n-                                        instance: Instance<'tcx>)\n-                                        -> String {\n-            let mut result = String::with_capacity(32);\n-            result.push_str(prefix);\n-            push_instance_as_string(tcx, instance, &mut result);\n-            result\n-        }\n-    }\n-\n-    fn to_raw_string(&self) -> String {\n-        match *self {\n-            TransItem::DropGlue(dg) => {\n-                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n-            }\n-            TransItem::Fn(instance) => {\n-                format!(\"Fn({:?}, {})\",\n-                         instance.def,\n-                         instance.substs as *const _ as usize)\n-            }\n-            TransItem::Static(id) => {\n-                format!(\"Static({:?})\", id)\n-            }\n-        }\n-    }\n-}\n-\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n pub enum TransItemState {\n     PredictedAndGenerated,"}, {"sha": "b175f638b9ea224294a186dbf8411982fd9689e8", "filename": "src/librustc_trans/consts.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fconsts.rs?ref=e3f19cb0b36b24b2252b9334b9511a4087cabf85", "patch": "@@ -21,7 +21,8 @@ use rustc::hir::map as hir_map;\n use {abi, adt, closure, debuginfo, expr, machine};\n use base::{self, exported_name, imported_name, push_ctxt};\n use callee::Callee;\n-use collector::{self, TransItem};\n+use collector;\n+use trans_item::TransItem;\n use common::{type_is_sized, C_nil, const_get_elt};\n use common::{CrateContext, C_integral, C_floating, C_bool, C_str_slice, C_bytes, val_ty};\n use common::{C_struct, C_undef, const_to_opt_int, const_to_opt_uint, VariantInfo, C_uint};"}, {"sha": "f5d943db25d6437ef5ee3479ac0641c845c70476", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=e3f19cb0b36b24b2252b9334b9511a4087cabf85", "patch": "@@ -27,8 +27,9 @@ use glue::DropGlueKind;\n use mir::CachedMir;\n use monomorphize::Instance;\n \n-use collector::{TransItem, TransItemState};\n use partitioning::CodegenUnit;\n+use collector::TransItemState;\n+use trans_item::TransItem;\n use type_::{Type, TypeNames};\n use rustc::ty::subst::{Substs, VecPerParamSpace};\n use rustc::ty::{self, Ty, TyCtxt};"}, {"sha": "10e33195305f616bfbf29975417b028ae413d9d4", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=e3f19cb0b36b24b2252b9334b9511a4087cabf85", "patch": "@@ -29,13 +29,14 @@ use build::*;\n use callee::{Callee, ArgVals};\n use cleanup;\n use cleanup::CleanupMethods;\n-use collector::{self, TransItem};\n+use collector;\n use common::*;\n use debuginfo::DebugLoc;\n use declare;\n use expr;\n use machine::*;\n use monomorphize;\n+use trans_item::TransItem;\n use type_of::{type_of, sizing_type_of, align_of};\n use type_::Type;\n use value::Value;"}, {"sha": "bccb5aa050b511c60ffe7356efd6d3fd47b4d6c3", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=e3f19cb0b36b24b2252b9334b9511a4087cabf85", "patch": "@@ -123,6 +123,7 @@ mod mir;\n mod monomorphize;\n mod partitioning;\n mod symbol_names_test;\n+mod trans_item;\n mod tvec;\n mod type_;\n mod type_of;"}, {"sha": "eeff280a7d6b09be859d21f043b679d45309ea7a", "filename": "src/librustc_trans/partitioning.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fpartitioning.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Fpartitioning.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fpartitioning.rs?ref=e3f19cb0b36b24b2252b9334b9511a4087cabf85", "patch": "@@ -116,14 +116,15 @@\n //! source-level module, functions from the same module will be available for\n //! inlining, even when they are not marked #[inline].\n \n-use collector::{TransItem, ReferenceMap};\n+use collector::ReferenceMap;\n+use llvm;\n use monomorphize;\n use rustc::hir::def_id::DefId;\n use rustc::hir::map::DefPathData;\n use rustc::ty::TyCtxt;\n use rustc::ty::item_path::characteristic_def_id_of_type;\n-use llvm;\n use syntax::parse::token::{self, InternedString};\n+use trans_item::TransItem;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n #[derive(Clone, Copy, Eq, PartialEq, Debug)]"}, {"sha": "b0acd535182e4e2ba98e837784b7ff7996a5963a", "filename": "src/librustc_trans/trans_item.rs", "status": "added", "additions": 367, "deletions": 0, "changes": 367, "blob_url": "https://github.com/rust-lang/rust/blob/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f19cb0b36b24b2252b9334b9511a4087cabf85/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=e3f19cb0b36b24b2252b9334b9511a4087cabf85", "patch": "@@ -0,0 +1,367 @@\n+use base::llvm_linkage_by_name;\n+use glue::DropGlueKind;\n+use llvm;\n+use monomorphize::Instance;\n+use rustc::hir;\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::subst;\n+use std::hash::{Hash, Hasher};\n+use syntax::ast::{self, NodeId};\n+use syntax::attr;\n+use syntax::parse::token;\n+\n+#[derive(PartialEq, Eq, Clone, Copy, Debug)]\n+pub enum TransItem<'tcx> {\n+    DropGlue(DropGlueKind<'tcx>),\n+    Fn(Instance<'tcx>),\n+    Static(NodeId)\n+}\n+\n+impl<'tcx> Hash for TransItem<'tcx> {\n+    fn hash<H: Hasher>(&self, s: &mut H) {\n+        match *self {\n+            TransItem::DropGlue(t) => {\n+                0u8.hash(s);\n+                t.hash(s);\n+            },\n+            TransItem::Fn(instance) => {\n+                1u8.hash(s);\n+                instance.def.hash(s);\n+                (instance.substs as *const _ as usize).hash(s);\n+            }\n+            TransItem::Static(node_id) => {\n+                2u8.hash(s);\n+                node_id.hash(s);\n+            }\n+        };\n+    }\n+}\n+\n+//=-----------------------------------------------------------------------------\n+// TransItem String Keys\n+//=-----------------------------------------------------------------------------\n+\n+// The code below allows for producing a unique string key for a trans item.\n+// These keys are used by the handwritten auto-tests, so they need to be\n+// predictable and human-readable.\n+//\n+// Note: A lot of this could looks very similar to what's already in the\n+//       ppaux module. It would be good to refactor things so we only have one\n+//       parameterizable implementation for printing types.\n+\n+/// Same as `unique_type_name()` but with the result pushed onto the given\n+/// `output` parameter.\n+pub fn push_unique_type_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                       t: ty::Ty<'tcx>,\n+                                       output: &mut String) {\n+    match t.sty {\n+        ty::TyBool              => output.push_str(\"bool\"),\n+        ty::TyChar              => output.push_str(\"char\"),\n+        ty::TyStr               => output.push_str(\"str\"),\n+        ty::TyInt(ast::IntTy::Is)    => output.push_str(\"isize\"),\n+        ty::TyInt(ast::IntTy::I8)    => output.push_str(\"i8\"),\n+        ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n+        ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n+        ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+        ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n+        ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n+        ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n+        ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n+        ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+        ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n+        ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n+        ty::TyStruct(adt_def, substs) |\n+        ty::TyEnum(adt_def, substs) => {\n+            push_item_name(tcx, adt_def.did, output);\n+            push_type_params(tcx, &substs.types, &[], output);\n+        },\n+        ty::TyTuple(component_types) => {\n+            output.push('(');\n+            for &component_type in component_types {\n+                push_unique_type_name(tcx, component_type, output);\n+                output.push_str(\", \");\n+            }\n+            if !component_types.is_empty() {\n+                output.pop();\n+                output.pop();\n+            }\n+            output.push(')');\n+        },\n+        ty::TyBox(inner_type) => {\n+            output.push_str(\"Box<\");\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push('>');\n+        },\n+        ty::TyRawPtr(ty::TypeAndMut { ty: inner_type, mutbl } ) => {\n+            output.push('*');\n+            match mutbl {\n+                hir::MutImmutable => output.push_str(\"const \"),\n+                hir::MutMutable => output.push_str(\"mut \"),\n+            }\n+\n+            push_unique_type_name(tcx, inner_type, output);\n+        },\n+        ty::TyRef(_, ty::TypeAndMut { ty: inner_type, mutbl }) => {\n+            output.push('&');\n+            if mutbl == hir::MutMutable {\n+                output.push_str(\"mut \");\n+            }\n+\n+            push_unique_type_name(tcx, inner_type, output);\n+        },\n+        ty::TyArray(inner_type, len) => {\n+            output.push('[');\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push_str(&format!(\"; {}\", len));\n+            output.push(']');\n+        },\n+        ty::TySlice(inner_type) => {\n+            output.push('[');\n+            push_unique_type_name(tcx, inner_type, output);\n+            output.push(']');\n+        },\n+        ty::TyTrait(ref trait_data) => {\n+            push_item_name(tcx, trait_data.principal.skip_binder().def_id, output);\n+            push_type_params(tcx,\n+                             &trait_data.principal.skip_binder().substs.types,\n+                             &trait_data.bounds.projection_bounds,\n+                             output);\n+        },\n+        ty::TyFnDef(_, _, &ty::BareFnTy{ unsafety, abi, ref sig } ) |\n+        ty::TyFnPtr(&ty::BareFnTy{ unsafety, abi, ref sig } ) => {\n+            if unsafety == hir::Unsafety::Unsafe {\n+                output.push_str(\"unsafe \");\n+            }\n+\n+            if abi != ::abi::Abi::Rust {\n+                output.push_str(\"extern \\\"\");\n+                output.push_str(abi.name());\n+                output.push_str(\"\\\" \");\n+            }\n+\n+            output.push_str(\"fn(\");\n+\n+            let sig = tcx.erase_late_bound_regions(sig);\n+            if !sig.inputs.is_empty() {\n+                for &parameter_type in &sig.inputs {\n+                    push_unique_type_name(tcx, parameter_type, output);\n+                    output.push_str(\", \");\n+                }\n+                output.pop();\n+                output.pop();\n+            }\n+\n+            if sig.variadic {\n+                if !sig.inputs.is_empty() {\n+                    output.push_str(\", ...\");\n+                } else {\n+                    output.push_str(\"...\");\n+                }\n+            }\n+\n+            output.push(')');\n+\n+            match sig.output {\n+                ty::FnConverging(result_type) if result_type.is_nil() => {}\n+                ty::FnConverging(result_type) => {\n+                    output.push_str(\" -> \");\n+                    push_unique_type_name(tcx, result_type, output);\n+                }\n+                ty::FnDiverging => {\n+                    output.push_str(\" -> !\");\n+                }\n+            }\n+        },\n+        ty::TyClosure(def_id, ref closure_substs) => {\n+            push_item_name(tcx, def_id, output);\n+            output.push_str(\"{\");\n+            output.push_str(&format!(\"{}:{}\", def_id.krate, def_id.index.as_usize()));\n+            output.push_str(\"}\");\n+            push_type_params(tcx, &closure_substs.func_substs.types, &[], output);\n+        }\n+        ty::TyError |\n+        ty::TyInfer(_) |\n+        ty::TyProjection(..) |\n+        ty::TyParam(_) => {\n+            bug!(\"debuginfo: Trying to create type name for \\\n+                  unexpected type: {:?}\", t);\n+        }\n+    }\n+}\n+\n+fn push_item_name(tcx: TyCtxt,\n+                  def_id: DefId,\n+                  output: &mut String) {\n+    let def_path = tcx.def_path(def_id);\n+\n+    // some_crate::\n+    output.push_str(&tcx.crate_name(def_path.krate));\n+    output.push_str(\"::\");\n+\n+    // foo::bar::ItemName::\n+    for part in tcx.def_path(def_id).data {\n+        output.push_str(&format!(\"{}[{}]::\",\n+                        part.data.as_interned_str(),\n+                        part.disambiguator));\n+    }\n+\n+    // remove final \"::\"\n+    output.pop();\n+    output.pop();\n+}\n+\n+fn push_type_params<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                              types: &'tcx subst::VecPerParamSpace<Ty<'tcx>>,\n+                              projections: &[ty::PolyProjectionPredicate<'tcx>],\n+                              output: &mut String) {\n+    if types.is_empty() && projections.is_empty() {\n+        return;\n+    }\n+\n+    output.push('<');\n+\n+    for &type_parameter in types {\n+        push_unique_type_name(tcx, type_parameter, output);\n+        output.push_str(\", \");\n+    }\n+\n+    for projection in projections {\n+        let projection = projection.skip_binder();\n+        let name = token::get_ident_interner().get(projection.projection_ty.item_name);\n+        output.push_str(&name[..]);\n+        output.push_str(\"=\");\n+        push_unique_type_name(tcx, projection.ty, output);\n+        output.push_str(\", \");\n+    }\n+\n+    output.pop();\n+    output.pop();\n+\n+    output.push('>');\n+}\n+\n+fn push_instance_as_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                     instance: Instance<'tcx>,\n+                                     output: &mut String) {\n+    push_item_name(tcx, instance.def, output);\n+    push_type_params(tcx, &instance.substs.types, &[], output);\n+}\n+\n+pub fn def_id_to_string(tcx: TyCtxt, def_id: DefId) -> String {\n+    let mut output = String::new();\n+    push_item_name(tcx, def_id, &mut output);\n+    output\n+}\n+\n+pub fn type_to_string<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                ty: ty::Ty<'tcx>)\n+                                -> String {\n+    let mut output = String::new();\n+    push_unique_type_name(tcx, ty, &mut output);\n+    output\n+}\n+\n+impl<'tcx> TransItem<'tcx> {\n+\n+    pub fn requests_inline<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => {\n+                let attributes = tcx.get_attrs(instance.def);\n+                attr::requests_inline(&attributes[..])\n+            }\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_from_extern_crate(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.def.is_local(),\n+            TransItem::DropGlue(..) |\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn is_lazily_instantiated(&self) -> bool {\n+        match *self {\n+            TransItem::Fn(ref instance) => !instance.substs.types.is_empty(),\n+            TransItem::DropGlue(..) => true,\n+            TransItem::Static(..)   => false,\n+        }\n+    }\n+\n+    pub fn explicit_linkage<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> Option<llvm::Linkage> {\n+        let def_id = match *self {\n+            TransItem::Fn(ref instance) => instance.def,\n+            TransItem::Static(node_id) => tcx.map.local_def_id(node_id),\n+            TransItem::DropGlue(..) => return None,\n+        };\n+\n+        let attributes = tcx.get_attrs(def_id);\n+        if let Some(name) = attr::first_attr_value_str_by_name(&attributes, \"linkage\") {\n+            if let Some(linkage) = llvm_linkage_by_name(&name) {\n+                Some(linkage)\n+            } else {\n+                let span = tcx.map.span_if_local(def_id);\n+                if let Some(span) = span {\n+                    tcx.sess.span_fatal(span, \"invalid linkage specified\")\n+                } else {\n+                    tcx.sess.fatal(&format!(\"invalid linkage specified: {}\", name))\n+                }\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    pub fn to_string<'a>(&self, tcx: TyCtxt<'a, 'tcx, 'tcx>) -> String {\n+        let hir_map = &tcx.map;\n+\n+        return match *self {\n+            TransItem::DropGlue(dg) => {\n+                let mut s = String::with_capacity(32);\n+                match dg {\n+                    DropGlueKind::Ty(_) => s.push_str(\"drop-glue \"),\n+                    DropGlueKind::TyContents(_) => s.push_str(\"drop-glue-contents \"),\n+                };\n+                push_unique_type_name(tcx, dg.ty(), &mut s);\n+                s\n+            }\n+            TransItem::Fn(instance) => {\n+                to_string_internal(tcx, \"fn \", instance)\n+            },\n+            TransItem::Static(node_id) => {\n+                let def_id = hir_map.local_def_id(node_id);\n+                let instance = Instance::mono(tcx, def_id);\n+                to_string_internal(tcx, \"static \", instance)\n+            },\n+        };\n+\n+        fn to_string_internal<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+                                        prefix: &str,\n+                                        instance: Instance<'tcx>)\n+                                        -> String {\n+            let mut result = String::with_capacity(32);\n+            result.push_str(prefix);\n+            push_instance_as_string(tcx, instance, &mut result);\n+            result\n+        }\n+    }\n+\n+    pub fn to_raw_string(&self) -> String {\n+        match *self {\n+            TransItem::DropGlue(dg) => {\n+                format!(\"DropGlue({})\", dg.ty() as *const _ as usize)\n+            }\n+            TransItem::Fn(instance) => {\n+                format!(\"Fn({:?}, {})\",\n+                         instance.def,\n+                         instance.substs as *const _ as usize)\n+            }\n+            TransItem::Static(id) => {\n+                format!(\"Static({:?})\", id)\n+            }\n+        }\n+    }\n+}"}]}