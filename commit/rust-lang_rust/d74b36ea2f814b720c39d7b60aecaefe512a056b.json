{"sha": "d74b36ea2f814b720c39d7b60aecaefe512a056b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ3NGIzNmVhMmY4MTRiNzIwYzM5ZDdiNjBhZWNhZWZlNTEyYTA1NmI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-15T00:13:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-15T00:13:53Z"}, "message": "Auto merge of #84867 - pnkfelix:rustdoc-revert-deref-recur, r=jyn514\n\nrustdoc: revert deref recur to resume inclusion of impl ExtTrait<Local> for ExtType\n\nAs discussed here: https://github.com/rust-lang/rust/issues/82465#issuecomment-829290384, Revert PR #80653 to resolve issue #82465.\n\nIssue #82465 was we had stopped including certain trait implementations, namely implementations on an imported type of an imported trait *instantiated on a local type*. That bug was injected by PR #80653.\n\nReverting #80653 means we don't list all the methods that you have accessible via recursively applying `Deref`.\n\n[Discussion in last week's rustc triage meeting](https://zulip-archive.rust-lang.org/238009tcompilermeetings/19557weekly2021042954818.html#236680594) led us to conclude that the bug was worse than the enhancement, and there was not an obvious fix for the bug itself. So for the short term we  remove the enhancement, while in the long term we will work on figuring out a way to have our imported trait implementation cake and eat it too.", "tree": {"sha": "2908602c5e23fa8673acc34b358f6cc61d034ab2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2908602c5e23fa8673acc34b358f6cc61d034ab2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d74b36ea2f814b720c39d7b60aecaefe512a056b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d74b36ea2f814b720c39d7b60aecaefe512a056b", "html_url": "https://github.com/rust-lang/rust/commit/d74b36ea2f814b720c39d7b60aecaefe512a056b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d74b36ea2f814b720c39d7b60aecaefe512a056b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "539d7bd3998d9bfed14c264eacda30097a4ea768", "url": "https://api.github.com/repos/rust-lang/rust/commits/539d7bd3998d9bfed14c264eacda30097a4ea768", "html_url": "https://github.com/rust-lang/rust/commit/539d7bd3998d9bfed14c264eacda30097a4ea768"}, {"sha": "b894f75594fbf44bf6a4d504e604c4b2762a2a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/b894f75594fbf44bf6a4d504e604c4b2762a2a69", "html_url": "https://github.com/rust-lang/rust/commit/b894f75594fbf44bf6a4d504e604c4b2762a2a69"}], "stats": {"total": 233, "additions": 61, "deletions": 172}, "files": [{"sha": "1898f5feed2cd13dc55ce3b4e16bf810c337cb0e", "filename": "src/librustdoc/html/render/context.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcontext.rs?ref=d74b36ea2f814b720c39d7b60aecaefe512a056b", "patch": "@@ -6,7 +6,7 @@ use std::rc::Rc;\n use std::sync::mpsc::{channel, Receiver};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n+use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n use rustc_session::Session;\n use rustc_span::edition::Edition;\n@@ -51,9 +51,6 @@ crate struct Context<'tcx> {\n     pub(super) render_redirect_pages: bool,\n     /// The map used to ensure all generated 'id=' attributes are unique.\n     pub(super) id_map: RefCell<IdMap>,\n-    /// Tracks section IDs for `Deref` targets so they match in both the main\n-    /// body and the sidebar.\n-    pub(super) deref_id_map: RefCell<FxHashMap<DefId, String>>,\n     /// Shared mutable state.\n     ///\n     /// Issue for improving the situation: [#82381][]\n@@ -74,7 +71,7 @@ crate struct Context<'tcx> {\n \n // `Context` is cloned a lot, so we don't want the size to grow unexpectedly.\n #[cfg(target_arch = \"x86_64\")]\n-rustc_data_structures::static_assert_size!(Context<'_>, 152);\n+rustc_data_structures::static_assert_size!(Context<'_>, 112);\n \n /// Shared mutable state used in [`Context`] and elsewhere.\n crate struct SharedContext<'tcx> {\n@@ -486,7 +483,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             dst,\n             render_redirect_pages: false,\n             id_map: RefCell::new(id_map),\n-            deref_id_map: RefCell::new(FxHashMap::default()),\n             shared: Rc::new(scx),\n             cache: Rc::new(cache),\n         };\n@@ -504,7 +500,6 @@ impl<'tcx> FormatRenderer<'tcx> for Context<'tcx> {\n             dst: self.dst.clone(),\n             render_redirect_pages: self.render_redirect_pages,\n             id_map: RefCell::new(IdMap::new()),\n-            deref_id_map: RefCell::new(FxHashMap::default()),\n             shared: Rc::clone(&self.shared),\n             cache: Rc::clone(&self.cache),\n         }"}, {"sha": "ebb4cfb7d48bd50901416b4d5590cda94b9777d5", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 6, "deletions": 20, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d74b36ea2f814b720c39d7b60aecaefe512a056b", "patch": "@@ -1045,17 +1045,12 @@ fn render_assoc_items(\n                 RenderMode::Normal\n             }\n             AssocItemRender::DerefFor { trait_, type_, deref_mut_ } => {\n-                let id =\n-                    cx.derive_id(small_url_encode(format!(\"deref-methods-{:#}\", type_.print(cx))));\n-                debug!(\"Adding {} to deref id map\", type_.print(cx));\n-                cx.deref_id_map.borrow_mut().insert(type_.def_id_full(cache).unwrap(), id.clone());\n                 write!(\n                     w,\n-                    \"<h2 id=\\\"{id}\\\" class=\\\"small-section-header\\\">\\\n+                    \"<h2 id=\\\"deref-methods\\\" class=\\\"small-section-header\\\">\\\n                          Methods from {trait_}&lt;Target = {type_}&gt;\\\n-                         <a href=\\\"#{id}\\\" class=\\\"anchor\\\"></a>\\\n+                         <a href=\\\"#deref-methods\\\" class=\\\"anchor\\\"></a>\\\n                      </h2>\",\n-                    id = id,\n                     trait_ = trait_.print(cx),\n                     type_ = type_.print(cx),\n                 );\n@@ -1080,6 +1075,9 @@ fn render_assoc_items(\n             );\n         }\n     }\n+    if let AssocItemRender::DerefFor { .. } = what {\n+        return;\n+    }\n     if !traits.is_empty() {\n         let deref_impl = traits\n             .iter()\n@@ -1090,13 +1088,6 @@ fn render_assoc_items(\n                 .any(|t| t.inner_impl().trait_.def_id_full(cache) == cx.cache.deref_mut_trait_did);\n             render_deref_methods(w, cx, impl_, containing_item, has_deref_mut);\n         }\n-\n-        // If we were already one level into rendering deref methods, we don't want to render\n-        // anything after recursing into any further deref methods above.\n-        if let AssocItemRender::DerefFor { .. } = what {\n-            return;\n-        }\n-\n         let (synthetic, concrete): (Vec<&&Impl>, Vec<&&Impl>) =\n             traits.iter().partition(|t| t.inner_impl().synthetic);\n         let (blanket_impl, concrete): (Vec<&&Impl>, _) =\n@@ -2017,14 +2008,9 @@ fn sidebar_deref_methods(cx: &Context<'_>, out: &mut Buffer, impl_: &Impl, v: &V\n                 .flat_map(|i| get_methods(i.inner_impl(), true, &mut used_links, deref_mut, c))\n                 .collect::<Vec<_>>();\n             if !ret.is_empty() {\n-                let deref_id_map = cx.deref_id_map.borrow();\n-                let id = deref_id_map\n-                    .get(&real_target.def_id_full(c).unwrap())\n-                    .expect(\"Deref section without derived id\");\n                 write!(\n                     out,\n-                    \"<a class=\\\"sidebar-title\\\" href=\\\"#{}\\\">Methods from {}&lt;Target={}&gt;</a>\",\n-                    id,\n+                    \"<a class=\\\"sidebar-title\\\" href=\\\"#deref-methods\\\">Methods from {}&lt;Target={}&gt;</a>\",\n                     Escape(&format!(\"{:#}\", impl_.inner_impl().trait_.as_ref().unwrap().print(cx))),\n                     Escape(&format!(\"{:#}\", real_target.print(cx))),\n                 );"}, {"sha": "6d7c45f6eeacbb0bb944bd1f9acfe0e8fd25dcec", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 35, "deletions": 62, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=d74b36ea2f814b720c39d7b60aecaefe512a056b", "patch": "@@ -3,8 +3,7 @@ use crate::clean::*;\n use crate::core::DocContext;\n use crate::fold::DocFolder;\n \n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_hir::def_id::DefId;\n+use rustc_data_structures::fx::FxHashSet;\n use rustc_middle::ty::DefIdTree;\n use rustc_span::symbol::sym;\n \n@@ -53,6 +52,39 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n         }\n     }\n \n+    let mut cleaner = BadImplStripper { prims, items: crate_items };\n+\n+    // scan through included items ahead of time to splice in Deref targets to the \"valid\" sets\n+    for it in &new_items {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n+            if cleaner.keep_impl(for_) && trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n+                let target = items\n+                    .iter()\n+                    .find_map(|item| match *item.kind {\n+                        TypedefItem(ref t, true) => Some(&t.type_),\n+                        _ => None,\n+                    })\n+                    .expect(\"Deref impl without Target type\");\n+\n+                if let Some(prim) = target.primitive_type() {\n+                    cleaner.prims.insert(prim);\n+                } else if let Some(did) = target.def_id() {\n+                    cleaner.items.insert(did.into());\n+                }\n+            }\n+        }\n+    }\n+\n+    new_items.retain(|it| {\n+        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n+            cleaner.keep_impl(for_)\n+                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t))\n+                || blanket_impl.is_some()\n+        } else {\n+            true\n+        }\n+    });\n+\n     // `tcx.crates()` doesn't include the local crate, and `tcx.all_trait_implementations`\n     // doesn't work with it anyway, so pull them from the HIR map instead\n     let mut extra_attrs = Vec::new();\n@@ -84,73 +116,14 @@ crate fn collect_trait_impls(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n         }\n     }\n \n-    let mut cleaner = BadImplStripper { prims, items: crate_items };\n-\n-    let mut type_did_to_deref_target: FxHashMap<DefId, &Type> = FxHashMap::default();\n-    // Gather all type to `Deref` target edges.\n-    for it in &new_items {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref items, .. }) = *it.kind {\n-            if trait_.def_id() == cx.tcx.lang_items().deref_trait() {\n-                let target = items.iter().find_map(|item| match *item.kind {\n-                    TypedefItem(ref t, true) => Some(&t.type_),\n-                    _ => None,\n-                });\n-                if let (Some(for_did), Some(target)) = (for_.def_id(), target) {\n-                    type_did_to_deref_target.insert(for_did, target);\n-                }\n-            }\n-        }\n-    }\n-    // Follow all `Deref` targets of included items and recursively add them as valid\n-    fn add_deref_target(\n-        map: &FxHashMap<DefId, &Type>,\n-        cleaner: &mut BadImplStripper,\n-        type_did: &DefId,\n-    ) {\n-        if let Some(target) = map.get(type_did) {\n-            debug!(\"add_deref_target: type {:?}, target {:?}\", type_did, target);\n-            if let Some(target_prim) = target.primitive_type() {\n-                cleaner.prims.insert(target_prim);\n-            } else if let Some(target_did) = target.def_id() {\n-                // `impl Deref<Target = S> for S`\n-                if target_did == *type_did {\n-                    // Avoid infinite cycles\n-                    return;\n-                }\n-                cleaner.items.insert(target_did.into());\n-                add_deref_target(map, cleaner, &target_did.into());\n-            }\n-        }\n-    }\n-    for type_did in type_did_to_deref_target.keys() {\n-        // Since only the `DefId` portion of the `Type` instances is known to be same for both the\n-        // `Deref` target type and the impl for type positions, this map of types is keyed by\n-        // `DefId` and for convenience uses a special cleaner that accepts `DefId`s directly.\n-        if cleaner.keep_impl_with_def_id(FakeDefId::Real(*type_did)) {\n-            add_deref_target(&type_did_to_deref_target, &mut cleaner, type_did);\n-        }\n-    }\n-\n     let items = if let ModuleItem(Module { ref mut items, .. }) = *krate.module.kind {\n         items\n     } else {\n         panic!(\"collect-trait-impls can't run\");\n     };\n \n     items.extend(synth_impls);\n-    for it in new_items.drain(..) {\n-        if let ImplItem(Impl { ref for_, ref trait_, ref blanket_impl, .. }) = *it.kind {\n-            if !(cleaner.keep_impl(for_)\n-                || trait_.as_ref().map_or(false, |t| cleaner.keep_impl(t))\n-                || blanket_impl.is_some())\n-            {\n-                continue;\n-            }\n-        }\n-\n-        items.push(it);\n-    }\n-\n+    items.extend(new_items);\n     krate\n }\n "}, {"sha": "4cb518cbbbd5c14fd0057c91a03a71b0ffe0f582", "filename": "src/test/rustdoc-ui/deref-recursive-cycle.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/539d7bd3998d9bfed14c264eacda30097a4ea768/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d7bd3998d9bfed14c264eacda30097a4ea768/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fderef-recursive-cycle.rs?ref=539d7bd3998d9bfed14c264eacda30097a4ea768", "patch": "@@ -1,17 +0,0 @@\n-// check-pass\n-// #26207: Ensure `Deref` cycles are properly handled without errors.\n-\n-#[derive(Copy, Clone)]\n-struct S;\n-\n-impl std::ops::Deref for S {\n-    type Target = S;\n-\n-    fn deref(&self) -> &S {\n-        self\n-    }\n-}\n-\n-fn main() {\n-    let s: S = *******S;\n-}"}, {"sha": "459a30060c6233ac331075a62229c3e5a45be01a", "filename": "src/test/rustdoc/deref-recursive-pathbuf.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/539d7bd3998d9bfed14c264eacda30097a4ea768/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d7bd3998d9bfed14c264eacda30097a4ea768/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive-pathbuf.rs?ref=539d7bd3998d9bfed14c264eacda30097a4ea768", "patch": "@@ -1,24 +0,0 @@\n-// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n-// levels and across multiple crates.\n-\n-// @has 'foo/struct.Foo.html'\n-// @has '-' '//*[@id=\"deref-methods-PathBuf\"]' 'Methods from Deref<Target = PathBuf>'\n-// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.as_path\"]' 'pub fn as_path(&self)'\n-// @has '-' '//*[@id=\"deref-methods-Path\"]' 'Methods from Deref<Target = Path>'\n-// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.exists\"]' 'pub fn exists(&self)'\n-// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-PathBuf\"]' 'Methods from Deref<Target=PathBuf>'\n-// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.as_path\"]' 'as_path'\n-// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-Path\"]' 'Methods from Deref<Target=Path>'\n-// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.exists\"]' 'exists'\n-\n-#![crate_name = \"foo\"]\n-\n-use std::ops::Deref;\n-use std::path::PathBuf;\n-\n-pub struct Foo(PathBuf);\n-\n-impl Deref for Foo {\n-    type Target = PathBuf;\n-    fn deref(&self) -> &PathBuf { &self.0 }\n-}"}, {"sha": "b96b5397ad78b45189bb919ea5cf71600112c5f5", "filename": "src/test/rustdoc/deref-recursive.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/539d7bd3998d9bfed14c264eacda30097a4ea768/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d7bd3998d9bfed14c264eacda30097a4ea768/src%2Ftest%2Frustdoc%2Fderef-recursive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-recursive.rs?ref=539d7bd3998d9bfed14c264eacda30097a4ea768", "patch": "@@ -1,40 +0,0 @@\n-// #26207: Show all methods reachable via Deref impls, recursing through multiple dereferencing\n-// levels if needed.\n-\n-// @has 'foo/struct.Foo.html'\n-// @has '-' '//*[@id=\"deref-methods-Bar\"]' 'Methods from Deref<Target = Bar>'\n-// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.bar\"]' 'pub fn bar(&self)'\n-// @has '-' '//*[@id=\"deref-methods-Baz\"]' 'Methods from Deref<Target = Baz>'\n-// @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.baz\"]' 'pub fn baz(&self)'\n-// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-Bar\"]' 'Methods from Deref<Target=Bar>'\n-// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.bar\"]' 'bar'\n-// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-Baz\"]' 'Methods from Deref<Target=Baz>'\n-// @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.baz\"]' 'baz'\n-\n-#![crate_name = \"foo\"]\n-\n-use std::ops::Deref;\n-\n-pub struct Foo(Bar);\n-pub struct Bar(Baz);\n-pub struct Baz;\n-\n-impl Deref for Foo {\n-    type Target = Bar;\n-    fn deref(&self) -> &Bar { &self.0 }\n-}\n-\n-impl Deref for Bar {\n-    type Target = Baz;\n-    fn deref(&self) -> &Baz { &self.0 }\n-}\n-\n-impl Bar {\n-    /// This appears under `Foo` methods\n-    pub fn bar(&self) {}\n-}\n-\n-impl Baz {\n-    /// This should also appear in `Foo` methods when recursing\n-    pub fn baz(&self) {}\n-}"}, {"sha": "3fc48b46d7410f1a83e3dfab2c1140e4907005a9", "filename": "src/test/rustdoc/deref-typedef.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Ftest%2Frustdoc%2Fderef-typedef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fderef-typedef.rs?ref=d74b36ea2f814b720c39d7b60aecaefe512a056b", "patch": "@@ -1,12 +1,12 @@\n #![crate_name = \"foo\"]\n \n // @has 'foo/struct.Bar.html'\n-// @has '-' '//*[@id=\"deref-methods-FooJ\"]' 'Methods from Deref<Target = FooJ>'\n+// @has '-' '//*[@id=\"deref-methods\"]' 'Methods from Deref<Target = FooJ>'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_a\"]' 'pub fn foo_a(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_b\"]' 'pub fn foo_b(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_c\"]' 'pub fn foo_c(&self)'\n // @has '-' '//*[@class=\"impl-items\"]//*[@id=\"method.foo_j\"]' 'pub fn foo_j(&self)'\n-// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods-FooJ\"]' 'Methods from Deref<Target=FooJ>'\n+// @has '-' '//*[@class=\"sidebar-title\"][@href=\"#deref-methods\"]' 'Methods from Deref<Target=FooJ>'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_a\"]' 'foo_a'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_b\"]' 'foo_b'\n // @has '-' '//*[@class=\"sidebar-links\"]/a[@href=\"#method.foo_c\"]' 'foo_c'"}, {"sha": "618ac20ac487d99ba7a25774124b1679e2f57ad7", "filename": "src/test/rustdoc/issue-82465-asref-for-and-of-local.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Ftest%2Frustdoc%2Fissue-82465-asref-for-and-of-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d74b36ea2f814b720c39d7b60aecaefe512a056b/src%2Ftest%2Frustdoc%2Fissue-82465-asref-for-and-of-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-82465-asref-for-and-of-local.rs?ref=d74b36ea2f814b720c39d7b60aecaefe512a056b", "patch": "@@ -0,0 +1,16 @@\n+use std::convert::AsRef;\n+pub struct Local;\n+\n+// @has issue_82465_asref_for_and_of_local/struct.Local.html '//code' 'impl AsRef<str> for Local'\n+impl AsRef<str> for Local {\n+    fn as_ref(&self) -> &str {\n+        todo!()\n+    }\n+}\n+\n+// @has - '//code' 'impl AsRef<Local> for str'\n+impl AsRef<Local> for str {\n+    fn as_ref(&self) -> &Local {\n+        todo!()\n+    }\n+}"}]}