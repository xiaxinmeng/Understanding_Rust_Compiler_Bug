{"sha": "75eface16d55984c402ef6e6f131801a70939660", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc1ZWZhY2UxNmQ1NTk4NGM0MDJlZjZlNmYxMzE4MDFhNzA5Mzk2NjA=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-02-10T01:54:56Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2017-03-06T03:20:26Z"}, "message": "Clean up \"pattern doesn't bind x\" messages\n\nGroup \"missing variable bind\" spans in `or` matches and clarify wording\nfor the two possible cases: when a variable from the first pattern is\nnot in any of the subsequent patterns, and when a variable in any of the\nother patterns is not in the first one.\n\nBefore:\n\n```\nerror[E0408]: variable `a` from pattern #1 is not bound in pattern #2\n  --> file.rs:10:23\n   |\n10 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n   |                       ^^^^^^^^^^^ pattern doesn't bind `a`\n\nerror[E0408]: variable `b` from pattern #2 is not bound in pattern #1\n  --> file.rs:10:32\n   |\n10 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n   |                                ^ pattern doesn't bind `b`\n\nerror[E0408]: variable `a` from pattern #1 is not bound in pattern #3\n  --> file.rs:10:37\n   |\n10 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n   |                                     ^^^^^^^^ pattern doesn't bind `a`\n\nerror[E0408]: variable `d` from pattern #1 is not bound in pattern #3\n  --> file.rs:10:37\n   |\n10 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n   |                                     ^^^^^^^^ pattern doesn't bind `d`\n\nerror[E0408]: variable `c` from pattern #3 is not bound in pattern #1\n  --> file.rs:10:43\n   |\n10 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n   |                                           ^ pattern doesn't bind `c`\n\nerror[E0408]: variable `d` from pattern #1 is not bound in pattern #4\n  --> file.rs:10:48\n   |\n10 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n   |                                                ^^^^^^^^ pattern doesn't bind `d`\n\nerror: aborting due to 6 previous errors\n```\n\nAfter:\n\n```\nerror[E0408]: variable `a` is not bound in all patterns\n  --> file.rs:20:37\n   |\n20 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => {\nintln!(\"{:?}\", a); }\n   |               -       ^^^^^^^^^^^   ^^^^^^^^         - variable\nt in all patterns\n   |               |       |             |\n   |               |       |             pattern doesn't bind `a`\n   |               |       pattern doesn't bind `a`\n   |               variable not in all patterns\n\nerror[E0408]: variable `d` is not bound in all patterns\n  --> file.rs:20:37\n   |\n20 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => {\nintln!(\"{:?}\", a); }\n   |                  -          -       ^^^^^^^^   ^^^^^^^^ pattern\nesn't bind `d`\n   |                  |          |       |\n   |                  |          |       pattern doesn't bind `d`\n   |                  |          variable not in all patterns\n   |                  variable not in all patterns\n\nerror[E0408]: variable `b` is not bound in all patterns\n  --> file.rs:20:37\n   |\n20 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => {\nintln!(\"{:?}\", a); }\n   |         ^^^^^^^^^^^            -    ^^^^^^^^   ^^^^^^^^ pattern\nesn't bind `b`\n   |         |                      |    |\n   |         |                      |    pattern doesn't bind `b`\n   |         |                      variable not in all patterns\n   |         pattern doesn't bind `b`\n\nerror[E0408]: variable `c` is not bound in all patterns\n  --> file.rs:20:48\n   |\n20 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => {\nintln!(\"{:?}\", a); }\n   |         ^^^^^^^^^^^   ^^^^^^^^^^^         -    ^^^^^^^^ pattern\nesn't bind `c`\n   |         |             |                   |\n   |         |             |                   variable not in all\ntterns\n   |         |             pattern doesn't bind `c`\n   |         pattern doesn't bind `c`\n\nerror: aborting due to 4 previous errors\n```\n\n* Have only one presentation for binding consistency errors\n* Point to same binding in multiple patterns when possible\n* Check inconsistent bindings in all arms\n* Simplify wording of diagnostic message\n* Sort emition and spans of binding errors for deterministic output", "tree": {"sha": "eee3ec44565db0bf4052b7bfc78be721e5a0bec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eee3ec44565db0bf4052b7bfc78be721e5a0bec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/75eface16d55984c402ef6e6f131801a70939660", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/75eface16d55984c402ef6e6f131801a70939660", "html_url": "https://github.com/rust-lang/rust/commit/75eface16d55984c402ef6e6f131801a70939660", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/75eface16d55984c402ef6e6f131801a70939660/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65e2a1454f86f759bca475b0956b8e60bf86cabd", "url": "https://api.github.com/repos/rust-lang/rust/commits/65e2a1454f86f759bca475b0956b8e60bf86cabd", "html_url": "https://github.com/rust-lang/rust/commit/65e2a1454f86f759bca475b0956b8e60bf86cabd"}], "stats": {"total": 226, "additions": 176, "deletions": 50}, "files": [{"sha": "adb0eee652bd0888e995e0f4184f4cb560f45c7b", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 99, "deletions": 41, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -97,6 +97,31 @@ enum AssocSuggestion {\n     AssocItem,\n }\n \n+#[derive(Eq)]\n+struct BindingError {\n+    name: Name,\n+    origin: FxHashSet<Span>,\n+    target: FxHashSet<Span>,\n+}\n+\n+impl PartialOrd for BindingError {\n+    fn partial_cmp(&self, other: &BindingError) -> Option<cmp::Ordering> {\n+        Some(self.cmp(other))\n+    }\n+}\n+\n+impl PartialEq for BindingError {\n+    fn eq(&self, other: &BindingError) -> bool {\n+        self.name == other.name\n+    }\n+}\n+\n+impl Ord for BindingError {\n+    fn cmp(&self, other: &BindingError) -> cmp::Ordering {\n+        self.name.cmp(&other.name)\n+    }\n+}\n+\n enum ResolutionError<'a> {\n     /// error E0401: can't use type parameters from outer function\n     TypeParametersFromOuterFunction,\n@@ -110,10 +135,10 @@ enum ResolutionError<'a> {\n     TypeNotMemberOfTrait(Name, &'a str),\n     /// error E0438: const is not a member of trait\n     ConstNotMemberOfTrait(Name, &'a str),\n-    /// error E0408: variable `{}` from pattern #{} is not bound in pattern #{}\n-    VariableNotBoundInPattern(Name, usize, usize),\n-    /// error E0409: variable is bound with different mode in pattern #{} than in pattern #1\n-    VariableBoundWithDifferentMode(Name, usize, Span),\n+    /// error E0408: variable `{}` is not bound in all patterns\n+    VariableNotBoundInPattern(&'a BindingError),\n+    /// error E0409: variable `{}` is bound in inconsistent ways within the same match arm\n+    VariableBoundWithDifferentMode(Name, Span),\n     /// error E0415: identifier is bound more than once in this parameter list\n     IdentifierBoundMoreThanOnceInParameterList(&'a str),\n     /// error E0416: identifier is bound more than once in the same pattern\n@@ -207,27 +232,30 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n             err.span_label(span, &format!(\"not a member of trait `{}`\", trait_));\n             err\n         }\n-        ResolutionError::VariableNotBoundInPattern(variable_name, from, to) => {\n-            let mut err = struct_span_err!(resolver.session,\n-                             span,\n-                             E0408,\n-                             \"variable `{}` from pattern #{} is not bound in pattern #{}\",\n-                             variable_name,\n-                             from,\n-                             to);\n-            err.span_label(span, &format!(\"pattern doesn't bind `{}`\", variable_name));\n+        ResolutionError::VariableNotBoundInPattern(binding_error) => {\n+            let mut target_sp = binding_error.target.iter().map(|x| *x).collect::<Vec<_>>();\n+            target_sp.sort();\n+            let msp = MultiSpan::from_spans(target_sp.clone());\n+            let msg = format!(\"variable `{}` is not bound in all patterns\", binding_error.name);\n+            let mut err = resolver.session.struct_span_err_with_code(msp, &msg, \"E0408\");\n+            for sp in target_sp {\n+                err.span_label(sp, &format!(\"pattern doesn't bind `{}`\", binding_error.name));\n+            }\n+            let mut origin_sp = binding_error.origin.iter().map(|x| *x).collect::<Vec<_>>();\n+            origin_sp.sort();\n+            for sp in origin_sp {\n+                err.span_label(sp, &\"variable not in all patterns\");\n+            }\n             err\n         }\n         ResolutionError::VariableBoundWithDifferentMode(variable_name,\n-                                                        pattern_number,\n                                                         first_binding_span) => {\n             let mut err = struct_span_err!(resolver.session,\n                              span,\n                              E0409,\n-                             \"variable `{}` is bound with different mode in pattern #{} than in \\\n-                              pattern #1\",\n-                             variable_name,\n-                             pattern_number);\n+                             \"variable `{}` is bound in inconsistent \\\n+                             ways within the same match arm\",\n+                             variable_name);\n             err.span_label(span, &format!(\"bound in different ways\"));\n             err.span_label(first_binding_span, &format!(\"first binding\"));\n             err\n@@ -335,7 +363,7 @@ fn resolve_struct_error<'sess, 'a>(resolver: &'sess Resolver,\n     }\n }\n \n-#[derive(Copy, Clone)]\n+#[derive(Copy, Clone, Debug)]\n struct BindingInfo {\n     span: Span,\n     binding_mode: BindingMode,\n@@ -1904,36 +1932,66 @@ impl<'a> Resolver<'a> {\n         if arm.pats.is_empty() {\n             return;\n         }\n-        let map_0 = self.binding_mode_map(&arm.pats[0]);\n+\n+        let mut missing_vars = FxHashMap();\n+        let mut inconsistent_vars = FxHashMap();\n         for (i, p) in arm.pats.iter().enumerate() {\n             let map_i = self.binding_mode_map(&p);\n \n-            for (&key, &binding_0) in &map_0 {\n-                match map_i.get(&key) {\n-                    None => {\n-                        let error = ResolutionError::VariableNotBoundInPattern(key.name, 1, i + 1);\n-                        resolve_error(self, p.span, error);\n+            for (j, q) in arm.pats.iter().enumerate() {\n+                if i == j {\n+                    continue;\n+                }\n+\n+                let map_j = self.binding_mode_map(&q);\n+                for (&key, &binding_i) in &map_i {\n+                    if map_j.len() == 0 {                   // Account for missing bindings when\n+                        let binding_error = missing_vars    // map_j has none.\n+                            .entry(key.name)\n+                            .or_insert(BindingError {\n+                                name: key.name,\n+                                origin: FxHashSet(),\n+                                target: FxHashSet(),\n+                            });\n+                        binding_error.origin.insert(binding_i.span);\n+                        binding_error.target.insert(q.span);\n                     }\n-                    Some(binding_i) => {\n-                        if binding_0.binding_mode != binding_i.binding_mode {\n-                            resolve_error(self,\n-                                          binding_i.span,\n-                                          ResolutionError::VariableBoundWithDifferentMode(\n-                                              key.name,\n-                                              i + 1,\n-                                              binding_0.span));\n+                    for (&key_j, &binding_j) in &map_j {\n+                        match map_i.get(&key_j) {\n+                            None => {  // missing binding\n+                                let binding_error = missing_vars\n+                                    .entry(key_j.name)\n+                                    .or_insert(BindingError {\n+                                        name: key_j.name,\n+                                        origin: FxHashSet(),\n+                                        target: FxHashSet(),\n+                                    });\n+                                binding_error.origin.insert(binding_j.span);\n+                                binding_error.target.insert(p.span);\n+                            }\n+                            Some(binding_i) => {  // check consistent binding\n+                                if binding_i.binding_mode != binding_j.binding_mode {\n+                                    inconsistent_vars\n+                                        .entry(key.name)\n+                                        .or_insert((binding_j.span, binding_i.span));\n+                                }\n+                            }\n                         }\n                     }\n                 }\n             }\n-\n-            for (&key, &binding) in &map_i {\n-                if !map_0.contains_key(&key) {\n-                    resolve_error(self,\n-                                  binding.span,\n-                                  ResolutionError::VariableNotBoundInPattern(key.name, i + 1, 1));\n-                }\n-            }\n+        }\n+        let mut missing_vars = missing_vars.iter().collect::<Vec<_>>();\n+        missing_vars.sort();\n+        for (_, v) in missing_vars {\n+            resolve_error(self,\n+                          *v.origin.iter().next().unwrap(),\n+                          ResolutionError::VariableNotBoundInPattern(v));\n+        }\n+        let mut inconsistent_vars = inconsistent_vars.iter().collect::<Vec<_>>();\n+        inconsistent_vars.sort();\n+        for (name, v) in inconsistent_vars {\n+            resolve_error(self, v.0, ResolutionError::VariableBoundWithDifferentMode(*name, v.1));\n         }\n     }\n "}, {"sha": "ce77a537e263ddd220e52ec75b8b74a38a88f99e", "filename": "src/test/compile-fail/E0408.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2FE0408.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2FE0408.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2FE0408.rs?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -12,7 +12,8 @@ fn main() {\n     let x = Some(0);\n \n     match x {\n-        Some(y) | None => {} //~  ERROR variable `y` from pattern #1 is not bound in pattern #2\n+        Some(y) | None => {} //~  ERROR variable `y` is not bound in all patterns\n         _ => ()              //~| NOTE pattern doesn't bind `y`\n+                             //~| NOTE variable not in all patterns\n     }\n }"}, {"sha": "38bd7adefd91f758c024dbfa41f12ab9c48034a5", "filename": "src/test/compile-fail/issue-2848.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2848.rs?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -19,7 +19,8 @@ mod bar {\n fn main() {\n     use bar::foo::{alpha, charlie};\n     match alpha {\n-      alpha | beta => {} //~  ERROR variable `beta` from pattern #2 is not bound in pattern #1\n+      alpha | beta => {} //~  ERROR variable `beta` is not bound in all patterns\n       charlie => {}      //~| NOTE pattern doesn't bind `beta`\n+                         //~| NOTE variable not in all patterns\n     }\n }"}, {"sha": "203b28bd5e417afedf09433a232b95291e48ecc7", "filename": "src/test/compile-fail/issue-2849.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2849.rs?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -13,6 +13,6 @@ enum foo { alpha, beta(isize) }\n fn main() {\n     match foo::alpha {\n       foo::alpha | foo::beta(i) => {}\n-      //~^ ERROR variable `i` from pattern #2 is not bound in pattern #1\n+      //~^ ERROR variable `i` is not bound in all patterns\n     }\n }"}, {"sha": "63d33a9e5fa6f9a6125a5736293b6a4add8240c9", "filename": "src/test/compile-fail/resolve-inconsistent-binding-mode.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-binding-mode.rs?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -15,7 +15,7 @@ enum opts {\n fn matcher1(x: opts) {\n     match x {\n       opts::a(ref i) | opts::b(i) => {}\n-      //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^ ERROR variable `i` is bound in inconsistent ways within the same match arm\n       //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }\n@@ -24,7 +24,7 @@ fn matcher1(x: opts) {\n fn matcher2(x: opts) {\n     match x {\n       opts::a(ref i) | opts::b(i) => {}\n-      //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^ ERROR variable `i` is bound in inconsistent ways within the same match arm\n       //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }\n@@ -33,7 +33,7 @@ fn matcher2(x: opts) {\n fn matcher4(x: opts) {\n     match x {\n       opts::a(ref mut i) | opts::b(ref i) => {}\n-      //~^ ERROR variable `i` is bound with different mode in pattern #2 than in pattern #1\n+      //~^ ERROR variable `i` is bound in inconsistent ways within the same match arm\n       //~^^ ERROR mismatched types\n       opts::c(_) => {}\n     }"}, {"sha": "7fee5aedb06ed33eb1b159b8cfa11c8eab963c79", "filename": "src/test/compile-fail/resolve-inconsistent-names.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fresolve-inconsistent-names.rs?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -11,9 +11,11 @@\n fn main() {\n     let y = 1;\n     match y {\n-       a | b => {} //~  ERROR variable `a` from pattern #1 is not bound in pattern #2\n-                   //~^ ERROR variable `b` from pattern #2 is not bound in pattern #1\n+       a | b => {} //~  ERROR variable `a` is not bound in all patterns\n+                   //~^ ERROR variable `b` is not bound in all patterns\n                    //~| NOTE pattern doesn't bind `a`\n                    //~| NOTE pattern doesn't bind `b`\n+                   //~| NOTE variable not in all patterns\n+                   //~| NOTE variable not in all patterns\n     }\n }"}, {"sha": "45a42b1c271f8678920ca841580d814aa62f6498", "filename": "src/test/ui/mismatched_types/E0409.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0409.stderr?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -1,4 +1,4 @@\n-error[E0409]: variable `y` is bound with different mode in pattern #2 than in pattern #1\n+error[E0409]: variable `y` is bound in inconsistent ways within the same match arm\n   --> $DIR/E0409.rs:15:23\n    |\n 15 |         (0, ref y) | (y, 0) => {} //~ ERROR E0409"}, {"sha": "17b3f1c5a885e4fe4d5a0a6dd9af10f06f9c6e6e", "filename": "src/test/ui/span/issue-39698.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fui%2Fspan%2Fissue-39698.rs", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fui%2Fspan%2Fissue-39698.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39698.rs?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum T {\n+    T1(i32, i32),\n+    T2(i32, i32),\n+    T3(i32),\n+    T4(i32),\n+}\n+\n+fn main() {\n+    match T::T1(123, 456) {\n+        T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n+    }\n+}"}, {"sha": "97d802f8398311fa3930f046e903224063e1d87e", "filename": "src/test/ui/span/issue-39698.stderr", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fui%2Fspan%2Fissue-39698.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/75eface16d55984c402ef6e6f131801a70939660/src%2Ftest%2Fui%2Fspan%2Fissue-39698.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-39698.stderr?ref=75eface16d55984c402ef6e6f131801a70939660", "patch": "@@ -0,0 +1,42 @@\n+error[E0408]: variable `a` is not bound in all patterns\n+  --> $DIR/issue-39698.rs:20:23\n+   |\n+20 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n+   |               -       ^^^^^^^^^^^   ^^^^^^^^         - variable not in all patterns\n+   |               |       |             |\n+   |               |       |             pattern doesn't bind `a`\n+   |               |       pattern doesn't bind `a`\n+   |               variable not in all patterns\n+\n+error[E0408]: variable `d` is not bound in all patterns\n+  --> $DIR/issue-39698.rs:20:37\n+   |\n+20 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n+   |                  -          -       ^^^^^^^^   ^^^^^^^^ pattern doesn't bind `d`\n+   |                  |          |       |\n+   |                  |          |       pattern doesn't bind `d`\n+   |                  |          variable not in all patterns\n+   |                  variable not in all patterns\n+\n+error[E0408]: variable `b` is not bound in all patterns\n+  --> $DIR/issue-39698.rs:20:9\n+   |\n+20 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n+   |         ^^^^^^^^^^^            -    ^^^^^^^^   ^^^^^^^^ pattern doesn't bind `b`\n+   |         |                      |    |\n+   |         |                      |    pattern doesn't bind `b`\n+   |         |                      variable not in all patterns\n+   |         pattern doesn't bind `b`\n+\n+error[E0408]: variable `c` is not bound in all patterns\n+  --> $DIR/issue-39698.rs:20:9\n+   |\n+20 |         T::T1(a, d) | T::T2(d, b) | T::T3(c) | T::T4(a) => { println!(\"{:?}\", a); }\n+   |         ^^^^^^^^^^^   ^^^^^^^^^^^         -    ^^^^^^^^ pattern doesn't bind `c`\n+   |         |             |                   |\n+   |         |             |                   variable not in all patterns\n+   |         |             pattern doesn't bind `c`\n+   |         pattern doesn't bind `c`\n+\n+error: aborting due to 4 previous errors\n+"}]}