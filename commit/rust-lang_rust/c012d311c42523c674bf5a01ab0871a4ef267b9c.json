{"sha": "c012d311c42523c674bf5a01ab0871a4ef267b9c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMwMTJkMzExYzQyNTIzYzY3NGJmNWEwMWFiMDg3MWE0ZWYyNjdiOWM=", "commit": {"author": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-06-16T15:29:05Z"}, "committer": {"name": "Ga\u00ebtan Cassiers", "email": "gaetan.cassiers@gmail.com", "date": "2015-06-23T00:15:46Z"}, "message": "A basic impl of Rewrite for ast::Expr", "tree": {"sha": "0b28e06ef6e5be9a1350ca187368402dda16af38", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0b28e06ef6e5be9a1350ca187368402dda16af38"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c012d311c42523c674bf5a01ab0871a4ef267b9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c012d311c42523c674bf5a01ab0871a4ef267b9c", "html_url": "https://github.com/rust-lang/rust/commit/c012d311c42523c674bf5a01ab0871a4ef267b9c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c012d311c42523c674bf5a01ab0871a4ef267b9c/comments", "author": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cassiersg", "id": 9348542, "node_id": "MDQ6VXNlcjkzNDg1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/9348542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cassiersg", "html_url": "https://github.com/cassiersg", "followers_url": "https://api.github.com/users/cassiersg/followers", "following_url": "https://api.github.com/users/cassiersg/following{/other_user}", "gists_url": "https://api.github.com/users/cassiersg/gists{/gist_id}", "starred_url": "https://api.github.com/users/cassiersg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cassiersg/subscriptions", "organizations_url": "https://api.github.com/users/cassiersg/orgs", "repos_url": "https://api.github.com/users/cassiersg/repos", "events_url": "https://api.github.com/users/cassiersg/events{/privacy}", "received_events_url": "https://api.github.com/users/cassiersg/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c10bfecdc2869df8b42675c395b6c1e33ef674e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c10bfecdc2869df8b42675c395b6c1e33ef674e7", "html_url": "https://github.com/rust-lang/rust/commit/c10bfecdc2869df8b42675c395b6c1e33ef674e7"}], "stats": {"total": 406, "additions": 225, "deletions": 181}, "files": [{"sha": "9bf68eb7c12562c738cd24ce3990a42c6c2f3f08", "filename": "src/expr.rs", "status": "modified", "additions": 194, "deletions": 178, "changes": 372, "blob_url": "https://github.com/rust-lang/rust/blob/c012d311c42523c674bf5a01ab0871a4ef267b9c/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c012d311c42523c674bf5a01ab0871a4ef267b9c/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=c012d311c42523c674bf5a01ab0871a4ef267b9c", "patch": "@@ -8,9 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use visitor::FmtVisitor;\n use utils::*;\n use lists::{write_list, ListFormatting, SeparatorTactic, ListTactic};\n+use rewrite::{Rewrite, RewriteContext};\n \n use syntax::{ast, ptr};\n use syntax::codemap::{Pos, Span};\n@@ -19,194 +19,246 @@ use syntax::print::pprust;\n \n use MIN_STRING;\n \n-impl<'a> FmtVisitor<'a> {\n-    fn rewrite_string_lit(&mut self, s: &str, span: Span, width: usize, offset: usize) -> String {\n-        // FIXME I bet this stomps unicode escapes in the source string\n-\n-        // Check if there is anything to fix: we always try to fixup multi-line\n-        // strings, or if the string is too long for the line.\n-        let l_loc = self.codemap.lookup_char_pos(span.lo);\n-        let r_loc = self.codemap.lookup_char_pos(span.hi);\n-        if l_loc.line == r_loc.line && r_loc.col.to_usize() <= config!(max_width) {\n-            return self.snippet(span);\n+impl Rewrite for ast::Expr {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n+        match self.node {\n+            ast::Expr_::ExprLit(ref l) => {\n+                match l.node {\n+                    ast::Lit_::LitStr(ref is, _) => {\n+                        let result = rewrite_string_lit(context, &is, l.span, width, offset);\n+                        debug!(\"string lit: `{:?}`\", result);\n+                        return result;\n+                    }\n+                    _ => {}\n+                }\n+            }\n+            ast::Expr_::ExprCall(ref callee, ref args) => {\n+                return rewrite_call(context, callee, args, width, offset);\n+            }\n+            ast::Expr_::ExprParen(ref subexpr) => {\n+                return rewrite_paren(context, subexpr, width, offset);\n+            }\n+            ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n+                return rewrite_struct_lit(context, path,\n+                                               fields,\n+                                               base.as_ref().map(|e| &**e),\n+                                               width,\n+                                               offset);\n+            }\n+            ast::Expr_::ExprTup(ref items) => {\n+                return rewrite_tuple_lit(context, items, width, offset);\n+            }\n+            _ => {}\n         }\n \n-        // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n+        context.codemap.span_to_snippet(self.span).ok()\n+    }\n+}\n \n-        let s = s.escape_default();\n+fn rewrite_string_lit(context: &RewriteContext, s: &str, span: Span, width: usize, offset: usize) -> Option<String> {\n+    // FIXME I bet this stomps unicode escapes in the source string\n \n-        let offset = offset + 1;\n-        let indent = make_indent(offset);\n-        let indent = &indent;\n+    // Check if there is anything to fix: we always try to fixup multi-line\n+    // strings, or if the string is too long for the line.\n+    let l_loc = context.codemap.lookup_char_pos(span.lo);\n+    let r_loc = context.codemap.lookup_char_pos(span.hi);\n+    if l_loc.line == r_loc.line && r_loc.col.to_usize() <= config!(max_width) {\n+        return context.codemap.span_to_snippet(span).ok();\n+    }\n \n-        let mut cur_start = 0;\n-        let mut result = String::with_capacity(round_up_to_power_of_two(s.len()));\n-        result.push('\"');\n-        loop {\n-            let max_chars = if cur_start == 0 {\n-                // First line.\n-                width - 2 // 2 = \" + \\\n-            } else {\n-                config!(max_width) - offset - 1 // 1 = either \\ or ;\n-            };\n+    // TODO if lo.col > IDEAL - 10, start a new line (need cur indent for that)\n \n-            let mut cur_end = cur_start + max_chars;\n+    let s = s.escape_default();\n \n-            if cur_end >= s.len() {\n-                result.push_str(&s[cur_start..]);\n-                break;\n-            }\n+    let offset = offset + 1;\n+    let indent = make_indent(offset);\n+    let indent = &indent;\n+\n+    let mut cur_start = 0;\n+    let mut result = String::with_capacity(round_up_to_power_of_two(s.len()));\n+    result.push('\"');\n+    loop {\n+        let max_chars = if cur_start == 0 {\n+            // First line.\n+            width - 2 // 2 = \" + \\\n+        } else {\n+            config!(max_width) - offset - 1 // 1 = either \\ or ;\n+        };\n \n-            // Make sure we're on a char boundary.\n-            cur_end = next_char(&s, cur_end);\n+        let mut cur_end = cur_start + max_chars;\n \n-            // Push cur_end left until we reach whitespace\n-            while !s.char_at(cur_end-1).is_whitespace() {\n-                cur_end = prev_char(&s, cur_end);\n+        if cur_end >= s.len() {\n+            result.push_str(&s[cur_start..]);\n+            break;\n+        }\n \n-                if cur_end - cur_start < MIN_STRING {\n-                    // We can't break at whitespace, fall back to splitting\n-                    // anywhere that doesn't break an escape sequence\n-                    cur_end = next_char(&s, cur_start + max_chars);\n-                    while s.char_at(prev_char(&s, cur_end)) == '\\\\' {\n-                        cur_end = prev_char(&s, cur_end);\n-                    }\n-                    break;\n+        // Make sure we're on a char boundary.\n+        cur_end = next_char(&s, cur_end);\n+\n+        // Push cur_end left until we reach whitespace\n+        while !s.char_at(cur_end-1).is_whitespace() {\n+            cur_end = prev_char(&s, cur_end);\n+\n+            if cur_end - cur_start < MIN_STRING {\n+                // We can't break at whitespace, fall back to splitting\n+                // anywhere that doesn't break an escape sequence\n+                cur_end = next_char(&s, cur_start + max_chars);\n+                while s.char_at(prev_char(&s, cur_end)) == '\\\\' {\n+                    cur_end = prev_char(&s, cur_end);\n                 }\n+                break;\n             }\n-            // Make sure there is no whitespace to the right of the break.\n-            while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n-                cur_end = next_char(&s, cur_end+1);\n-            }\n-            result.push_str(&s[cur_start..cur_end]);\n-            result.push_str(\"\\\\\\n\");\n-            result.push_str(indent);\n-\n-            cur_start = cur_end;\n         }\n-        result.push('\"');\n+        // Make sure there is no whitespace to the right of the break.\n+        while cur_end < s.len() && s.char_at(cur_end).is_whitespace() {\n+            cur_end = next_char(&s, cur_end+1);\n+        }\n+        result.push_str(&s[cur_start..cur_end]);\n+        result.push_str(\"\\\\\\n\");\n+        result.push_str(indent);\n \n-        result\n+        cur_start = cur_end;\n     }\n+    result.push('\"');\n \n-    fn rewrite_call(&mut self,\n+    Some(result)\n+}\n+\n+fn rewrite_call(context: &RewriteContext,\n                     callee: &ast::Expr,\n                     args: &[ptr::P<ast::Expr>],\n                     width: usize,\n                     offset: usize)\n-        -> String\n-    {\n-        debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n+        -> Option<String>\n+{\n+    debug!(\"rewrite_call, width: {}, offset: {}\", width, offset);\n \n-        // TODO using byte lens instead of char lens (and probably all over the place too)\n-        let callee_str = self.rewrite_expr(callee, width, offset);\n-        debug!(\"rewrite_call, callee_str: `{}`\", callee_str);\n-        // 2 is for parens.\n-        let remaining_width = width - callee_str.len() - 2;\n-        let offset = callee_str.len() + 1 + offset;\n-        let arg_count = args.len();\n+    // TODO using byte lens instead of char lens (and probably all over the place too)\n+    let callee_str = match callee.rewrite(context, width, offset) {\n+        Some(s) => s,\n+        None => { return None; }\n+    };\n+    debug!(\"rewrite_call, callee_str: `{:?}`\", callee_str);\n+    // 2 is for parens.\n+    let remaining_width = width - callee_str.len() - 2;\n+    let offset = callee_str.len() + 1 + offset;\n+    let arg_count = args.len();\n \n-        let args_str = if arg_count > 0 {\n-            let args: Vec<_> = args.iter().map(|e| (self.rewrite_expr(e,\n-                                                                      remaining_width,\n-                                                                      offset), String::new())).collect();\n-            let fmt = ListFormatting {\n-                tactic: ListTactic::HorizontalVertical,\n-                separator: \",\",\n-                trailing_separator: SeparatorTactic::Never,\n-                indent: offset,\n-                h_width: remaining_width,\n-                v_width: remaining_width,\n-            };\n-            write_list(&args, &fmt)\n-        } else {\n-            String::new()\n+    let args_str = if arg_count > 0 {\n+        let mut args_rewritten = Vec::with_capacity(args.len());\n+        for arg in args.iter() {\n+            match arg.rewrite(context, remaining_width, offset) {\n+                Some(s) => { args_rewritten.push((s, String::new())); }\n+                None => { return None; }\n+            }\n+        }\n+        let fmt = ListFormatting {\n+            tactic: ListTactic::HorizontalVertical,\n+            separator: \",\",\n+            trailing_separator: SeparatorTactic::Never,\n+            indent: offset,\n+            h_width: remaining_width,\n+            v_width: remaining_width,\n         };\n+        write_list(&args_rewritten, &fmt)\n+    } else {\n+        String::new()\n+    };\n \n-        format!(\"{}({})\", callee_str, args_str)\n-    }\n+    Some(format!(\"{}({})\", callee_str, args_str))\n+}\n \n-    fn rewrite_paren(&mut self, subexpr: &ast::Expr, width: usize, offset: usize) -> String {\n-        debug!(\"rewrite_paren, width: {}, offset: {}\", width, offset);\n-        // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n-        // paren on the same line as the subexpr\n-        let subexpr_str = self.rewrite_expr(subexpr, width-2, offset+1);\n-        debug!(\"rewrite_paren, subexpr_str: `{}`\", subexpr_str);\n-        format!(\"({})\", subexpr_str)\n-    }\n+fn rewrite_paren(context: &RewriteContext, subexpr: &ast::Expr, width: usize, offset: usize) -> Option<String> {\n+    debug!(\"rewrite_paren, width: {}, offset: {}\", width, offset);\n+    // 1 is for opening paren, 2 is for opening+closing, we want to keep the closing\n+    // paren on the same line as the subexpr\n+    let subexpr_str = subexpr.rewrite(context, width-2, offset+1);\n+    debug!(\"rewrite_paren, subexpr_str: `{:?}`\", subexpr_str);\n+    subexpr_str.map(|s| format!(\"({})\", s))\n+}\n \n-    fn rewrite_struct_lit(&mut self,\n+fn rewrite_struct_lit(context: &RewriteContext,\n                           path: &ast::Path,\n                           fields: &[ast::Field],\n                           base: Option<&ast::Expr>,\n                           width: usize,\n                           offset: usize)\n-        -> String\n-    {\n-        debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n-        assert!(fields.len() > 0 || base.is_some());\n+        -> Option<String>\n+{\n+    debug!(\"rewrite_struct_lit: width {}, offset {}\", width, offset);\n+    assert!(fields.len() > 0 || base.is_some());\n \n-        let path_str = pprust::path_to_string(path);\n-        // Foo { a: Foo } - indent is +3, width is -5.\n-        let indent = offset + path_str.len() + 3;\n-        let budget = width - (path_str.len() + 5);\n+    let path_str = pprust::path_to_string(path);\n+    // Foo { a: Foo } - indent is +3, width is -5.\n+    let indent = offset + path_str.len() + 3;\n+    let budget = width - (path_str.len() + 5);\n \n-        let mut field_strs: Vec<_> =\n-            fields.iter().map(|f| self.rewrite_field(f, budget, indent)).collect();\n-        if let Some(expr) = base {\n-            // Another 2 on the width/indent for the ..\n-            field_strs.push(format!(\"..{}\", self.rewrite_expr(expr, budget - 2, indent + 2)))\n+    let mut field_strs = Vec::with_capacity(fields.len());\n+    for field in fields.iter() {\n+        match rewrite_field(context, field, budget, indent) {\n+            Some(s) => { field_strs.push(s); }\n+            None => { return None; }\n         }\n+    }\n+    if let Some(expr) = base {\n+        // Another 2 on the width/indent for the ..\n+        field_strs.push(match expr.rewrite(context, budget - 2, indent + 2) {\n+            Some(s) => format!(\"..{}\", s),\n+            None => { return None; }\n+        });\n+    }\n \n-        // FIXME comments\n-        let field_strs: Vec<_> = field_strs.into_iter().map(|s| (s, String::new())).collect();\n-        let fmt = ListFormatting {\n-            tactic: ListTactic::HorizontalVertical,\n-            separator: \",\",\n-            trailing_separator: if base.is_some() {\n-                    SeparatorTactic::Never\n-                } else {\n-                    config!(struct_lit_trailing_comma)\n-                },\n-            indent: indent,\n-            h_width: budget,\n-            v_width: budget,\n-        };\n-        let fields_str = write_list(&field_strs, &fmt);\n-        format!(\"{} {{ {} }}\", path_str, fields_str)\n+    // FIXME comments\n+    let field_strs: Vec<_> = field_strs.into_iter().map(|s| (s, String::new())).collect();\n+    let fmt = ListFormatting {\n+        tactic: ListTactic::HorizontalVertical,\n+        separator: \",\",\n+        trailing_separator: if base.is_some() {\n+            SeparatorTactic::Never\n+        } else {\n+            config!(struct_lit_trailing_comma)\n+        },\n+        indent: indent,\n+        h_width: budget,\n+        v_width: budget,\n+    };\n+    let fields_str = write_list(&field_strs, &fmt);\n+    Some(format!(\"{} {{ {} }}\", path_str, fields_str))\n \n         // FIXME if the usual multi-line layout is too wide, we should fall back to\n         // Foo {\n         //     a: ...,\n         // }\n-    }\n+}\n \n-    fn rewrite_field(&mut self, field: &ast::Field, width: usize, offset: usize) -> String {\n-        let name = &token::get_ident(field.ident.node);\n-        let overhead = name.len() + 2;\n-        let expr = self.rewrite_expr(&field.expr, width - overhead, offset + overhead);\n-        format!(\"{}: {}\", name, expr)\n-    }\n+fn rewrite_field(context: &RewriteContext, field: &ast::Field, width: usize, offset: usize) -> Option<String> {\n+    let name = &token::get_ident(field.ident.node);\n+    let overhead = name.len() + 2;\n+    let expr = field.expr.rewrite(context, width - overhead, offset + overhead);\n+    expr.map(|s| format!(\"{}: {}\", name, s))\n+}\n \n-    fn rewrite_tuple_lit(&mut self, items: &[ptr::P<ast::Expr>], width: usize, offset: usize)\n-        -> String {\n+fn rewrite_tuple_lit(context: &RewriteContext, items: &[ptr::P<ast::Expr>], width: usize, offset: usize)\n+    -> Option<String> {\n         // opening paren\n         let indent = offset + 1;\n         // In case of length 1, need a trailing comma\n         if items.len() == 1 {\n-            return format!(\"({},)\", self.rewrite_expr(&*items[0], width - 3, indent));\n+            return items[0].rewrite(context, width - 3, indent).map(|s| format!(\"({},)\", s));\n         }\n         // Only last line has width-1 as budget, other may take max_width\n-        let item_strs: Vec<_> =\n-            items.iter()\n-                 .enumerate()\n-                 .map(|(i, item)| self.rewrite_expr(\n-                    item,\n-                    // last line : given width (minus \"(\"+\")\"), other lines : max_width\n-                    // (minus \"(\"+\",\"))\n-                    if i == items.len() - 1 { width - 2 } else { config!(max_width) - indent - 2 },\n-                    indent))\n-                 .collect();\n+        let mut item_strs = Vec::with_capacity(items.len());\n+        for (i, item) in items.iter().enumerate() {\n+            let rem_width = if i == items.len() - 1 {\n+                width - 2\n+            } else {\n+                config!(max_width) - indent - 2\n+            };\n+            match item.rewrite(context, rem_width, indent) {\n+                Some(s) => { item_strs.push(s); }\n+                None => {return None; }\n+            }\n+        }\n         let tactics = if item_strs.iter().any(|s| s.contains('\\n')) {\n             ListTactic::Vertical\n         } else {\n@@ -223,41 +275,5 @@ impl<'a> FmtVisitor<'a> {\n             v_width: width - 2,\n         };\n         let item_str = write_list(&item_strs, &fmt);\n-        format!(\"({})\", item_str)\n-    }\n-\n-\n-    pub fn rewrite_expr(&mut self, expr: &ast::Expr, width: usize, offset: usize) -> String {\n-        match expr.node {\n-            ast::Expr_::ExprLit(ref l) => {\n-                match l.node {\n-                    ast::Lit_::LitStr(ref is, _) => {\n-                        let result = self.rewrite_string_lit(&is, l.span, width, offset);\n-                        debug!(\"string lit: `{}`\", result);\n-                        return result;\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            ast::Expr_::ExprCall(ref callee, ref args) => {\n-                return self.rewrite_call(callee, args, width, offset);\n-            }\n-            ast::Expr_::ExprParen(ref subexpr) => {\n-                return self.rewrite_paren(subexpr, width, offset);\n-            }\n-            ast::Expr_::ExprStruct(ref path, ref fields, ref base) => {\n-                return self.rewrite_struct_lit(path,\n-                                               fields,\n-                                               base.as_ref().map(|e| &**e),\n-                                               width,\n-                                               offset);\n-            }\n-            ast::Expr_::ExprTup(ref items) => {\n-                return self.rewrite_tuple_lit(items, width, offset);\n-            }\n-            _ => {}\n-        }\n-\n-        self.snippet(expr.span)\n+        Some(format!(\"({})\", item_str))\n     }\n-}"}, {"sha": "1b360433e94b2a8a4826b2ea45321ffd0101b485", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c012d311c42523c674bf5a01ab0871a4ef267b9c/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c012d311c42523c674bf5a01ab0871a4ef267b9c/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=c012d311c42523c674bf5a01ab0871a4ef267b9c", "patch": "@@ -59,6 +59,7 @@ mod types;\n mod expr;\n mod imports;\n mod issues;\n+mod rewrite;\n \n const MIN_STRING: usize = 10;\n // When we get scoped annotations, we should have rustfmt::skip."}, {"sha": "4eed7421ff0a927d677523a93284e310f433a79c", "filename": "src/rewrite.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c012d311c42523c674bf5a01ab0871a4ef267b9c/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c012d311c42523c674bf5a01ab0871a4ef267b9c/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=c012d311c42523c674bf5a01ab0871a4ef267b9c", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use syntax::codemap::CodeMap;\n+\n+pub trait Rewrite {\n+    fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String>;\n+}\n+\n+pub struct RewriteContext<'a> {\n+    pub codemap: &'a CodeMap,\n+}"}, {"sha": "1f8e0d5fa2e9a676e89734a7fa8b269f4793f4f8", "filename": "src/visitor.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c012d311c42523c674bf5a01ab0871a4ef267b9c/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c012d311c42523c674bf5a01ab0871a4ef267b9c/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=c012d311c42523c674bf5a01ab0871a4ef267b9c", "patch": "@@ -16,6 +16,7 @@ use utils;\n \n use SKIP_ANNOTATION;\n use changes::ChangeSet;\n+use rewrite::{Rewrite, RewriteContext};\n \n pub struct FmtVisitor<'a> {\n     pub codemap: &'a CodeMap,\n@@ -32,9 +33,16 @@ impl<'a, 'v> visit::Visitor<'v> for FmtVisitor<'a> {\n                self.codemap.lookup_char_pos(ex.span.hi));\n         self.format_missing(ex.span.lo);\n         let offset = self.changes.cur_offset_span(ex.span);\n-        let new_str = self.rewrite_expr(ex, config!(max_width) - offset, offset);\n-        self.changes.push_str_span(ex.span, &new_str);\n-        self.last_pos = ex.span.hi;\n+        match ex.rewrite(&RewriteContext { codemap: self.codemap },\n+                         config!(max_width) - offset,\n+                         offset) {\n+            Some(new_str) => {\n+                //let new_str = self.rewrite_expr(ex, config!(max_width) - offset, offset);\n+                self.changes.push_str_span(ex.span, &new_str);\n+                self.last_pos = ex.span.hi;\n+            }\n+            None => { self.last_pos = ex.span.lo; }\n+        }\n     }\n \n     fn visit_stmt(&mut self, stmt: &'v ast::Stmt) {"}]}