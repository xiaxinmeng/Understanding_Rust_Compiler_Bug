{"sha": "33f8ce287a62d8c76c7cea11c5cf67f53d5b8f40", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzZjhjZTI4N2E2MmQ4Yzc2YzdjZWExMWM1Y2Y2N2Y1M2Q1YjhmNDA=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2020-07-01T14:42:32Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-07-01T14:42:32Z"}, "message": "Rollup merge of #72369 - Lucretiel:socketaddr-parse, r=dtolnay\n\nBring net/parser.rs up to modern up to date with modern rust patterns\n\nThe current implementation of IP address parsing is very unidiomatic; it's full of `if` / `return` / `is_some` / `is_none` instead of `?`, `loop` with manual index tracking; etc. Went through and did and cleanup to try to bring it in line with modern sensibilities.\n\nThe obvious concern with making changes like this is \"make sure you understand why it's written that way before changing it\". Looking through the commit history for this file, there are several much smaller commits that make similar changes (For instance, https://github.com/rust-lang/rust/commit/3024c1434a667425d30e4b0785857381323712aa, https://github.com/rust-lang/rust/commit/4f3ab4986ec96d9c93f34dc53d0a4a1279288451, https://github.com/rust-lang/rust/commit/79f876495b2853d1b78ba953ceb3114b8019100f), and there don't seem to be any commits in the history that indicate that this lack of idiomaticity is related to specific performance needs (ie, there aren't any commits that replace a `for` loop with a `loop` and a manual index count). In fact, the basic shape of the file is essentially unchanged from its initial commit back in 2015.\n\nMade the following changes throughout the IP address parser:\n- Replaced all uses of `is_some()` / `is_none()` with `?`.\n- \"Upgraded\" loops wherever possible; ie, replace `while` with `for`, etc.\n    - Removed all cases of manual index tracking / incrementing.\n- Renamed several single-character variables with more expressive names.\n- Replaced several manual control flow segments with equivalent adapters (such as `Option::filter`).\n- Removed `read_seq_3`; replaced with simple sequences of `?`.\n- Parser now reslices its state when consuming, rather than carrying a separate state and index variable.\n- `read_digit` now uses `char::to_digit`.\n- Added comments throughout, especially in the complex IPv6 parsing logic.\n- Added comprehensive local unit tests for the parser to validate these changes.", "tree": {"sha": "2b82f104eac6919fc2043d9ad92b044936533312", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b82f104eac6919fc2043d9ad92b044936533312"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33f8ce287a62d8c76c7cea11c5cf67f53d5b8f40", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe/KDYCRBK7hj4Ov3rIwAAdHIIAF374KrzpS68tZ+GKt6qZXmx\nUYMNwi4ZFG/kd/SZ8CPX6Hyqajo5RmBQ/yQ3wPuTwjHcv3R9w0GweU2GUvRR0qKE\nsQa3WmNGv9CFrWCUHcTWyDg9pfVzUJTgLclnxRnYjR0ZOdQb1ikRpg9Yn0Fm2OHD\nrFOLwjzYG9KQ1eAUyZTtDSMZOFY/QvsANAlajB5k3kh0m6VYhva4Jyh0TY/Ail/E\naw4gi6KQ08V3JTTg+C8fGfbaQzADUNGTAiOA7s6hE17qiM6AJfT8DWzRwuFqr7Yv\n9TYZLrIxqazGAEJvhucVpNo+ariLOlN7V4emRQ9/tpk0ci0dz6dyBcUF4pP2E0g=\n=GlIO\n-----END PGP SIGNATURE-----\n", "payload": "tree 2b82f104eac6919fc2043d9ad92b044936533312\nparent 128fa2b981454ca2b72750ee22699780d5421153\nparent 3ab7ae39ec77a39df27ac6c3fbde03cd3b763542\nauthor Manish Goregaokar <manishsmail@gmail.com> 1593614552 -0700\ncommitter GitHub <noreply@github.com> 1593614552 -0700\n\nRollup merge of #72369 - Lucretiel:socketaddr-parse, r=dtolnay\n\nBring net/parser.rs up to modern up to date with modern rust patterns\n\nThe current implementation of IP address parsing is very unidiomatic; it's full of `if` / `return` / `is_some` / `is_none` instead of `?`, `loop` with manual index tracking; etc. Went through and did and cleanup to try to bring it in line with modern sensibilities.\n\nThe obvious concern with making changes like this is \"make sure you understand why it's written that way before changing it\". Looking through the commit history for this file, there are several much smaller commits that make similar changes (For instance, https://github.com/rust-lang/rust/commit/3024c1434a667425d30e4b0785857381323712aa, https://github.com/rust-lang/rust/commit/4f3ab4986ec96d9c93f34dc53d0a4a1279288451, https://github.com/rust-lang/rust/commit/79f876495b2853d1b78ba953ceb3114b8019100f), and there don't seem to be any commits in the history that indicate that this lack of idiomaticity is related to specific performance needs (ie, there aren't any commits that replace a `for` loop with a `loop` and a manual index count). In fact, the basic shape of the file is essentially unchanged from its initial commit back in 2015.\n\nMade the following changes throughout the IP address parser:\n- Replaced all uses of `is_some()` / `is_none()` with `?`.\n- \"Upgraded\" loops wherever possible; ie, replace `while` with `for`, etc.\n    - Removed all cases of manual index tracking / incrementing.\n- Renamed several single-character variables with more expressive names.\n- Replaced several manual control flow segments with equivalent adapters (such as `Option::filter`).\n- Removed `read_seq_3`; replaced with simple sequences of `?`.\n- Parser now reslices its state when consuming, rather than carrying a separate state and index variable.\n- `read_digit` now uses `char::to_digit`.\n- Added comments throughout, especially in the complex IPv6 parsing logic.\n- Added comprehensive local unit tests for the parser to validate these changes.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33f8ce287a62d8c76c7cea11c5cf67f53d5b8f40", "html_url": "https://github.com/rust-lang/rust/commit/33f8ce287a62d8c76c7cea11c5cf67f53d5b8f40", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33f8ce287a62d8c76c7cea11c5cf67f53d5b8f40/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "128fa2b981454ca2b72750ee22699780d5421153", "url": "https://api.github.com/repos/rust-lang/rust/commits/128fa2b981454ca2b72750ee22699780d5421153", "html_url": "https://github.com/rust-lang/rust/commit/128fa2b981454ca2b72750ee22699780d5421153"}, {"sha": "3ab7ae39ec77a39df27ac6c3fbde03cd3b763542", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ab7ae39ec77a39df27ac6c3fbde03cd3b763542", "html_url": "https://github.com/rust-lang/rust/commit/3ab7ae39ec77a39df27ac6c3fbde03cd3b763542"}], "stats": {"total": 482, "additions": 289, "deletions": 193}, "files": [{"sha": "12d3baf633362b55369139d1ba86c9cf27ddc2cf", "filename": "src/libstd/net/parser.rs", "status": "modified", "additions": 289, "deletions": 193, "changes": 482, "blob_url": "https://github.com/rust-lang/rust/blob/33f8ce287a62d8c76c7cea11c5cf67f53d5b8f40/src%2Flibstd%2Fnet%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33f8ce287a62d8c76c7cea11c5cf67f53d5b8f40/src%2Flibstd%2Fnet%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fparser.rs?ref=33f8ce287a62d8c76c7cea11c5cf67f53d5b8f40", "patch": "@@ -10,163 +10,132 @@ use crate::str::FromStr;\n \n struct Parser<'a> {\n     // parsing as ASCII, so can use byte array\n-    s: &'a [u8],\n-    pos: usize,\n+    state: &'a [u8],\n }\n \n impl<'a> Parser<'a> {\n-    fn new(s: &'a str) -> Parser<'a> {\n-        Parser { s: s.as_bytes(), pos: 0 }\n+    fn new(input: &'a str) -> Parser<'a> {\n+        Parser { state: input.as_bytes() }\n     }\n \n     fn is_eof(&self) -> bool {\n-        self.pos == self.s.len()\n+        self.state.is_empty()\n     }\n \n-    // Commit only if parser returns Some\n-    fn read_atomically<T, F>(&mut self, cb: F) -> Option<T>\n+    /// Run a parser, and restore the pre-parse state if it fails\n+    fn read_atomically<T, F>(&mut self, inner: F) -> Option<T>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        let pos = self.pos;\n-        let r = cb(self);\n-        if r.is_none() {\n-            self.pos = pos;\n+        let state = self.state;\n+        let result = inner(self);\n+        if result.is_none() {\n+            self.state = state;\n         }\n-        r\n+        result\n     }\n \n-    // Commit only if parser read till EOF\n-    fn read_till_eof<T, F>(&mut self, cb: F) -> Option<T>\n+    /// Run a parser, but fail if the entire input wasn't consumed.\n+    /// Doesn't run atomically.\n+    fn read_till_eof<T, F>(&mut self, inner: F) -> Option<T>\n     where\n         F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_atomically(move |p| cb(p).filter(|_| p.is_eof()))\n+        inner(self).filter(|_| self.is_eof())\n     }\n \n-    // Apply 3 parsers sequentially\n-    fn read_seq_3<A, B, C, PA, PB, PC>(&mut self, pa: PA, pb: PB, pc: PC) -> Option<(A, B, C)>\n+    /// Same as read_till_eof, but returns a Result<AddrParseError> on failure\n+    fn parse_with<T, F>(&mut self, inner: F) -> Result<T, AddrParseError>\n     where\n-        PA: FnOnce(&mut Parser<'_>) -> Option<A>,\n-        PB: FnOnce(&mut Parser<'_>) -> Option<B>,\n-        PC: FnOnce(&mut Parser<'_>) -> Option<C>,\n+        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n     {\n-        self.read_atomically(move |p| {\n-            let a = pa(p);\n-            let b = if a.is_some() { pb(p) } else { None };\n-            let c = if b.is_some() { pc(p) } else { None };\n-            match (a, b, c) {\n-                (Some(a), Some(b), Some(c)) => Some((a, b, c)),\n-                _ => None,\n-            }\n-        })\n+        self.read_till_eof(inner).ok_or(AddrParseError(()))\n     }\n \n-    // Read next char\n+    /// Read the next character from the input\n     fn read_char(&mut self) -> Option<char> {\n-        if self.is_eof() {\n-            None\n-        } else {\n-            let r = self.s[self.pos] as char;\n-            self.pos += 1;\n-            Some(r)\n-        }\n-    }\n-\n-    // Return char and advance iff next char is equal to requested\n-    fn read_given_char(&mut self, c: char) -> Option<char> {\n-        self.read_atomically(|p| match p.read_char() {\n-            Some(next) if next == c => Some(next),\n-            _ => None,\n+        self.state.split_first().map(|(&b, tail)| {\n+            self.state = tail;\n+            b as char\n         })\n     }\n \n-    // Read digit\n-    fn read_digit(&mut self, radix: u8) -> Option<u8> {\n-        fn parse_digit(c: char, radix: u8) -> Option<u8> {\n-            let c = c as u8;\n-            // assuming radix is either 10 or 16\n-            if c >= b'0' && c <= b'9' {\n-                Some(c - b'0')\n-            } else if radix > 10 && c >= b'a' && c < b'a' + (radix - 10) {\n-                Some(c - b'a' + 10)\n-            } else if radix > 10 && c >= b'A' && c < b'A' + (radix - 10) {\n-                Some(c - b'A' + 10)\n-            } else {\n-                None\n-            }\n-        }\n-\n-        self.read_atomically(|p| p.read_char().and_then(|c| parse_digit(c, radix)))\n+    /// Read the next character from the input if it matches the target\n+    fn read_given_char(&mut self, target: char) -> Option<char> {\n+        self.read_atomically(|p| p.read_char().filter(|&c| c == target))\n     }\n \n-    fn read_number_impl(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        let mut r = 0;\n-        let mut digit_count = 0;\n-        loop {\n-            match self.read_digit(radix) {\n-                Some(d) => {\n-                    r = r * (radix as u32) + (d as u32);\n-                    digit_count += 1;\n-                    if digit_count > max_digits || r >= upto {\n-                        return None;\n-                    }\n-                }\n-                None => {\n-                    if digit_count == 0 {\n-                        return None;\n-                    } else {\n-                        return Some(r);\n-                    }\n-                }\n-            };\n-        }\n+    /// Helper for reading separators in an indexed loop. Reads the separator\n+    /// character iff index > 0, then runs the parser. When used in a loop,\n+    /// the separator character will only be read on index > 0 (see\n+    /// read_ipv4_addr for an example)\n+    fn read_separator<T, F>(&mut self, sep: char, index: usize, inner: F) -> Option<T>\n+    where\n+        F: FnOnce(&mut Parser<'_>) -> Option<T>,\n+    {\n+        self.read_atomically(move |p| {\n+            if index > 0 {\n+                let _ = p.read_given_char(sep)?;\n+            }\n+            inner(p)\n+        })\n     }\n \n-    // Read number, failing if max_digits of number value exceeded\n-    fn read_number(&mut self, radix: u8, max_digits: u32, upto: u32) -> Option<u32> {\n-        self.read_atomically(|p| p.read_number_impl(radix, max_digits, upto))\n+    // Read a single digit in the given radix. For instance, 0-9 in radix 10;\n+    // 0-9A-F in radix 16.\n+    fn read_digit(&mut self, radix: u32) -> Option<u32> {\n+        self.read_atomically(move |p| p.read_char()?.to_digit(radix))\n     }\n \n-    fn read_ipv4_addr_impl(&mut self) -> Option<Ipv4Addr> {\n-        let mut bs = [0; 4];\n-        let mut i = 0;\n-        while i < 4 {\n-            if i != 0 && self.read_given_char('.').is_none() {\n-                return None;\n+    // Read a number off the front of the input in the given radix, stopping\n+    // at the first non-digit character or eof. Fails if the number has more\n+    // digits than max_digits, or the value is >= upto, or if there is no number.\n+    fn read_number(&mut self, radix: u32, max_digits: u32, upto: u32) -> Option<u32> {\n+        self.read_atomically(move |p| {\n+            let mut result = 0;\n+            let mut digit_count = 0;\n+\n+            while let Some(digit) = p.read_digit(radix) {\n+                result = (result * radix) + digit;\n+                digit_count += 1;\n+                if digit_count > max_digits || result >= upto {\n+                    return None;\n+                }\n             }\n \n-            bs[i] = self.read_number(10, 3, 0x100).map(|n| n as u8)?;\n-            i += 1;\n-        }\n-        Some(Ipv4Addr::new(bs[0], bs[1], bs[2], bs[3]))\n+            if digit_count == 0 { None } else { Some(result) }\n+        })\n     }\n \n-    // Read IPv4 address\n+    /// Read an IPv4 address\n     fn read_ipv4_addr(&mut self) -> Option<Ipv4Addr> {\n-        self.read_atomically(|p| p.read_ipv4_addr_impl())\n-    }\n+        self.read_atomically(|p| {\n+            let mut groups = [0; 4];\n \n-    fn read_ipv6_addr_impl(&mut self) -> Option<Ipv6Addr> {\n-        fn ipv6_addr_from_head_tail(head: &[u16], tail: &[u16]) -> Ipv6Addr {\n-            assert!(head.len() + tail.len() <= 8);\n-            let mut gs = [0; 8];\n-            gs[..head.len()].copy_from_slice(head);\n-            gs[(8 - tail.len())..8].copy_from_slice(tail);\n-            Ipv6Addr::new(gs[0], gs[1], gs[2], gs[3], gs[4], gs[5], gs[6], gs[7])\n-        }\n+            for (i, slot) in groups.iter_mut().enumerate() {\n+                *slot = p.read_separator('.', i, |p| p.read_number(10, 3, 0x100))? as u8;\n+            }\n+\n+            Some(groups.into())\n+        })\n+    }\n \n-        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16; 8], limit: usize) -> (usize, bool) {\n-            let mut i = 0;\n-            while i < limit {\n+    /// Read an IPV6 Address\n+    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n+        /// Read a chunk of an ipv6 address into `groups`. Returns the number\n+        /// of groups read, along with a bool indicating if an embedded\n+        /// trailing ipv4 address was read. Specifically, read a series of\n+        /// colon-separated ipv6 groups (0x0000 - 0xFFFF), with an optional\n+        /// trailing embedded ipv4 address.\n+        fn read_groups(p: &mut Parser<'_>, groups: &mut [u16]) -> (usize, bool) {\n+            let limit = groups.len();\n+\n+            for (i, slot) in groups.iter_mut().enumerate() {\n+                // Try to read a trailing embedded ipv4 address. There must be\n+                // at least two groups left.\n                 if i < limit - 1 {\n-                    let ipv4 = p.read_atomically(|p| {\n-                        if i == 0 || p.read_given_char(':').is_some() {\n-                            p.read_ipv4_addr()\n-                        } else {\n-                            None\n-                        }\n-                    });\n+                    let ipv4 = p.read_separator(':', i, |p| p.read_ipv4_addr());\n+\n                     if let Some(v4_addr) = ipv4 {\n                         let octets = v4_addr.octets();\n                         groups[i + 0] = ((octets[0] as u16) << 8) | (octets[1] as u16);\n@@ -175,83 +144,85 @@ impl<'a> Parser<'a> {\n                     }\n                 }\n \n-                let group = p.read_atomically(|p| {\n-                    if i == 0 || p.read_given_char(':').is_some() {\n-                        p.read_number(16, 4, 0x10000).map(|n| n as u16)\n-                    } else {\n-                        None\n-                    }\n-                });\n+                let group = p.read_separator(':', i, |p| p.read_number(16, 4, 0x10000));\n+\n                 match group {\n-                    Some(g) => groups[i] = g,\n+                    Some(g) => *slot = g as u16,\n                     None => return (i, false),\n                 }\n-                i += 1;\n             }\n-            (i, false)\n+            (groups.len(), false)\n         }\n \n-        let mut head = [0; 8];\n-        let (head_size, head_ipv4) = read_groups(self, &mut head, 8);\n+        self.read_atomically(|p| {\n+            // Read the front part of the address; either the whole thing, or up\n+            // to the first ::\n+            let mut head = [0; 8];\n+            let (head_size, head_ipv4) = read_groups(p, &mut head);\n \n-        if head_size == 8 {\n-            return Some(Ipv6Addr::new(\n-                head[0], head[1], head[2], head[3], head[4], head[5], head[6], head[7],\n-            ));\n-        }\n+            if head_size == 8 {\n+                return Some(head.into());\n+            }\n \n-        // IPv4 part is not allowed before `::`\n-        if head_ipv4 {\n-            return None;\n-        }\n+            // IPv4 part is not allowed before `::`\n+            if head_ipv4 {\n+                return None;\n+            }\n \n-        // read `::` if previous code parsed less than 8 groups\n-        if self.read_given_char(':').is_none() || self.read_given_char(':').is_none() {\n-            return None;\n-        }\n+            // read `::` if previous code parsed less than 8 groups\n+            // `::` indicates one or more groups of 16 bits of zeros\n+            let _ = p.read_given_char(':')?;\n+            let _ = p.read_given_char(':')?;\n \n-        let mut tail = [0; 8];\n-        // `::` indicates one or more groups of 16 bits of zeros\n-        let limit = 8 - (head_size + 1);\n-        let (tail_size, _) = read_groups(self, &mut tail, limit);\n-        Some(ipv6_addr_from_head_tail(&head[..head_size], &tail[..tail_size]))\n-    }\n+            // Read the back part of the address. The :: must contain at least one\n+            // set of zeroes, so our max length is 7.\n+            let mut tail = [0; 7];\n+            let limit = 8 - (head_size + 1);\n+            let (tail_size, _) = read_groups(p, &mut tail[..limit]);\n \n-    fn read_ipv6_addr(&mut self) -> Option<Ipv6Addr> {\n-        self.read_atomically(|p| p.read_ipv6_addr_impl())\n+            // Concat the head and tail of the IP address\n+            head[(8 - tail_size)..8].copy_from_slice(&tail[..tail_size]);\n+\n+            Some(head.into())\n+        })\n     }\n \n+    /// Read an IP Address, either IPV4 or IPV6.\n     fn read_ip_addr(&mut self) -> Option<IpAddr> {\n-        self.read_ipv4_addr().map(IpAddr::V4).or_else(|| self.read_ipv6_addr().map(IpAddr::V6))\n+        self.read_ipv4_addr().map(IpAddr::V4).or_else(move || self.read_ipv6_addr().map(IpAddr::V6))\n     }\n \n-    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n-        let ip_addr = |p: &mut Parser<'_>| p.read_ipv4_addr();\n-        let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n+    /// Read a : followed by a port in base 10\n+    fn read_port(&mut self) -> Option<u16> {\n+        self.read_atomically(|p| {\n+            let _ = p.read_given_char(':')?;\n+            let port = p.read_number(10, 5, 0x10000)?;\n+            Some(port as u16)\n+        })\n+    }\n \n-        self.read_seq_3(ip_addr, colon, port).map(|t| {\n-            let (ip, _, port): (Ipv4Addr, char, u16) = t;\n-            SocketAddrV4::new(ip, port)\n+    /// Read an IPV4 address with a port\n+    fn read_socket_addr_v4(&mut self) -> Option<SocketAddrV4> {\n+        self.read_atomically(|p| {\n+            let ip = p.read_ipv4_addr()?;\n+            let port = p.read_port()?;\n+            Some(SocketAddrV4::new(ip, port))\n         })\n     }\n \n+    /// Read an IPV6 address with a port\n     fn read_socket_addr_v6(&mut self) -> Option<SocketAddrV6> {\n-        let ip_addr = |p: &mut Parser<'_>| {\n-            let open_br = |p: &mut Parser<'_>| p.read_given_char('[');\n-            let ip_addr = |p: &mut Parser<'_>| p.read_ipv6_addr();\n-            let clos_br = |p: &mut Parser<'_>| p.read_given_char(']');\n-            p.read_seq_3(open_br, ip_addr, clos_br).map(|t| t.1)\n-        };\n-        let colon = |p: &mut Parser<'_>| p.read_given_char(':');\n-        let port = |p: &mut Parser<'_>| p.read_number(10, 5, 0x10000).map(|n| n as u16);\n-\n-        self.read_seq_3(ip_addr, colon, port).map(|t| {\n-            let (ip, _, port): (Ipv6Addr, char, u16) = t;\n-            SocketAddrV6::new(ip, port, 0, 0)\n+        self.read_atomically(|p| {\n+            let _ = p.read_given_char('[')?;\n+            let ip = p.read_ipv6_addr()?;\n+            let _ = p.read_given_char(']')?;\n+\n+            let port = p.read_port()?;\n+            Some(SocketAddrV6::new(ip, port, 0, 0))\n         })\n     }\n \n+    /// Read an IP address with a port\n     fn read_socket_addr(&mut self) -> Option<SocketAddr> {\n         self.read_socket_addr_v4()\n             .map(SocketAddr::V4)\n@@ -263,65 +234,47 @@ impl<'a> Parser<'a> {\n impl FromStr for IpAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<IpAddr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ip_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ip_addr())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv4Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv4Addr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ipv4_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ipv4_addr())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for Ipv6Addr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<Ipv6Addr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_ipv6_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_ipv6_addr())\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV4 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV4, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr_v4()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr_v4())\n     }\n }\n \n #[stable(feature = \"socket_addr_from_str\", since = \"1.5.0\")]\n impl FromStr for SocketAddrV6 {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddrV6, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr_v6()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr_v6())\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl FromStr for SocketAddr {\n     type Err = AddrParseError;\n     fn from_str(s: &str) -> Result<SocketAddr, AddrParseError> {\n-        match Parser::new(s).read_till_eof(|p| p.read_socket_addr()) {\n-            Some(s) => Ok(s),\n-            None => Err(AddrParseError(())),\n-        }\n+        Parser::new(s).parse_with(|p| p.read_socket_addr())\n     }\n }\n \n@@ -376,3 +329,146 @@ impl Error for AddrParseError {\n         \"invalid IP address syntax\"\n     }\n }\n+\n+#[cfg(test)]\n+mod tests {\n+    // FIXME: These tests are all excellent candidates for AFL fuzz testing\n+    use crate::net::{IpAddr, Ipv4Addr, Ipv6Addr, SocketAddr, SocketAddrV4, SocketAddrV6};\n+    use crate::str::FromStr;\n+\n+    const PORT: u16 = 8080;\n+\n+    const IPV4: Ipv4Addr = Ipv4Addr::new(192, 168, 0, 1);\n+    const IPV4_STR: &str = \"192.168.0.1\";\n+    const IPV4_STR_PORT: &str = \"192.168.0.1:8080\";\n+\n+    const IPV6: Ipv6Addr = Ipv6Addr::new(0x2001, 0xdb8, 0, 0, 0, 0, 0xc0a8, 0x1);\n+    const IPV6_STR_FULL: &str = \"2001:db8:0:0:0:0:c0a8:1\";\n+    const IPV6_STR_COMPRESS: &str = \"2001:db8::c0a8:1\";\n+    const IPV6_STR_V4: &str = \"2001:db8::192.168.0.1\";\n+    const IPV6_STR_PORT: &str = \"[2001:db8::c0a8:1]:8080\";\n+\n+    #[test]\n+    fn parse_ipv4() {\n+        let result: Ipv4Addr = IPV4_STR.parse().unwrap();\n+        assert_eq!(result, IPV4);\n+\n+        assert!(Ipv4Addr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_FULL).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_V4).is_err());\n+        assert!(Ipv4Addr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_ipv6() {\n+        let result: Ipv6Addr = IPV6_STR_FULL.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        let result: Ipv6Addr = IPV6_STR_COMPRESS.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        let result: Ipv6Addr = IPV6_STR_V4.parse().unwrap();\n+        assert_eq!(result, IPV6);\n+\n+        assert!(Ipv6Addr::from_str(IPV4_STR).is_err());\n+        assert!(Ipv6Addr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(Ipv6Addr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_ip() {\n+        let result: IpAddr = IPV4_STR.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV4));\n+\n+        let result: IpAddr = IPV6_STR_FULL.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        let result: IpAddr = IPV6_STR_COMPRESS.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        let result: IpAddr = IPV6_STR_V4.parse().unwrap();\n+        assert_eq!(result, IpAddr::from(IPV6));\n+\n+        assert!(IpAddr::from_str(IPV4_STR_PORT).is_err());\n+        assert!(IpAddr::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket_v4() {\n+        let result: SocketAddrV4 = IPV4_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddrV4::new(IPV4, PORT));\n+\n+        assert!(SocketAddrV4::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_V4).is_err());\n+        assert!(SocketAddrV4::from_str(IPV6_STR_PORT).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket_v6() {\n+        let result: SocketAddrV6 = IPV6_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddrV6::new(IPV6, PORT, 0, 0));\n+\n+        assert!(SocketAddrV6::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddrV6::from_str(IPV4_STR_PORT).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddrV6::from_str(IPV6_STR_V4).is_err());\n+    }\n+\n+    #[test]\n+    fn parse_socket() {\n+        let result: SocketAddr = IPV4_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddr::from((IPV4, PORT)));\n+\n+        let result: SocketAddr = IPV6_STR_PORT.parse().unwrap();\n+        assert_eq!(result, SocketAddr::from((IPV6, PORT)));\n+\n+        assert!(SocketAddr::from_str(IPV4_STR).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_FULL).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_COMPRESS).is_err());\n+        assert!(SocketAddr::from_str(IPV6_STR_V4).is_err());\n+    }\n+\n+    #[test]\n+    fn ipv6_corner_cases() {\n+        let result: Ipv6Addr = \"1::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 0, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"1:1::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 1, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"::1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 1));\n+\n+        let result: Ipv6Addr = \"::1:1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 1, 1));\n+\n+        let result: Ipv6Addr = \"::\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0, 0));\n+\n+        let result: Ipv6Addr = \"::192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 0, 0xc0a8, 0x1));\n+\n+        let result: Ipv6Addr = \"::1:192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(0, 0, 0, 0, 0, 1, 0xc0a8, 0x1));\n+\n+        let result: Ipv6Addr = \"1:1:1:1:1:1:192.168.0.1\".parse().unwrap();\n+        assert_eq!(result, Ipv6Addr::new(1, 1, 1, 1, 1, 1, 0xc0a8, 0x1));\n+    }\n+\n+    // Things that might not seem like failures but are\n+    #[test]\n+    fn ipv6_corner_failures() {\n+        // No IP address before the ::\n+        assert!(Ipv6Addr::from_str(\"1:192.168.0.1::\").is_err());\n+\n+        // :: must have at least 1 set of zeroes\n+        assert!(Ipv6Addr::from_str(\"1:1:1:1::1:1:1:1\").is_err());\n+\n+        // Need brackets for a port\n+        assert!(SocketAddrV6::from_str(\"1:1:1:1:1:1:1:1:8080\").is_err());\n+    }\n+}"}]}