{"sha": "37d9ea745b358a5b9f48560600841fc6619e545d", "node_id": "C_kwDOAAsO6NoAKDM3ZDllYTc0NWIzNThhNWI5ZjQ4NTYwNjAwODQxZmM2NjE5ZTU0NWQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-24T05:10:36Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-02-24T06:01:01Z"}, "message": "Improve `scan_escape`.\n\n`scan_escape` currently has a fast path (for when the first char isn't\n'\\\\') and a slow path.\n\nThis commit changes `scan_escape` so it only handles the slow path, i.e.\nthe actual escaping code. The fast path is inlined into the two call\nsites.\n\nThis change makes the code faster, because there is no function call\noverhead on the fast path. (`scan_escape` is a big function and doesn't\nget inlined.)\n\nThis change also improves readability, because it removes a bunch of\nmode checks on the the fast paths.", "tree": {"sha": "67197e18b9807b94a12ae26be99f197c94e88b78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67197e18b9807b94a12ae26be99f197c94e88b78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/37d9ea745b358a5b9f48560600841fc6619e545d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/37d9ea745b358a5b9f48560600841fc6619e545d", "html_url": "https://github.com/rust-lang/rust/commit/37d9ea745b358a5b9f48560600841fc6619e545d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/37d9ea745b358a5b9f48560600841fc6619e545d/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "532d3cda90b8a729cd982548649d32803d265052", "url": "https://api.github.com/repos/rust-lang/rust/commits/532d3cda90b8a729cd982548649d32803d265052", "html_url": "https://github.com/rust-lang/rust/commit/532d3cda90b8a729cd982548649d32803d265052"}], "stats": {"total": 45, "additions": 22, "deletions": 23}, "files": [{"sha": "97f9588ae1ef557a280a1cf1c93234c8d3b0c2ee", "filename": "compiler/rustc_lexer/src/unescape.rs", "status": "modified", "additions": 22, "deletions": 23, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/37d9ea745b358a5b9f48560600841fc6619e545d/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/37d9ea745b358a5b9f48560600841fc6619e545d/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lexer%2Fsrc%2Funescape.rs?ref=37d9ea745b358a5b9f48560600841fc6619e545d", "patch": "@@ -159,26 +159,8 @@ impl Mode {\n     }\n }\n \n-fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n-    if first_char != '\\\\' {\n-        // Previous character was not a slash, and we don't expect it to be\n-        // an escape-only character.\n-        return match first_char {\n-            '\\t' | '\\n' => Err(EscapeError::EscapeOnlyChar),\n-            '\\r' => Err(EscapeError::BareCarriageReturn),\n-            '\\'' if mode.in_single_quotes() => Err(EscapeError::EscapeOnlyChar),\n-            '\"' if mode.in_double_quotes() => Err(EscapeError::EscapeOnlyChar),\n-            _ => {\n-                if mode.is_bytes() && !first_char.is_ascii() {\n-                    // Byte literal can't be a non-ascii character.\n-                    return Err(EscapeError::NonAsciiCharInByte);\n-                }\n-                Ok(first_char)\n-            }\n-        };\n-    }\n-\n-    // Previous character is '\\\\', try to unescape it.\n+fn scan_escape(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n+    // Previous character was '\\\\', unescape what follows.\n \n     let second_char = chars.next().ok_or(EscapeError::LoneSlash)?;\n \n@@ -270,9 +252,24 @@ fn scan_escape(first_char: char, chars: &mut Chars<'_>, mode: Mode) -> Result<ch\n     Ok(res)\n }\n \n+#[inline]\n+fn ascii_check(first_char: char, mode: Mode) -> Result<char, EscapeError> {\n+    if mode.is_bytes() && !first_char.is_ascii() {\n+        // Byte literal can't be a non-ascii character.\n+        Err(EscapeError::NonAsciiCharInByte)\n+    } else {\n+        Ok(first_char)\n+    }\n+}\n+\n fn unescape_char_or_byte(chars: &mut Chars<'_>, mode: Mode) -> Result<char, EscapeError> {\n     let first_char = chars.next().ok_or(EscapeError::ZeroChars)?;\n-    let res = scan_escape(first_char, chars, mode)?;\n+    let res = match first_char {\n+        '\\\\' => scan_escape(chars, mode),\n+        '\\n' | '\\t' | '\\'' => Err(EscapeError::EscapeOnlyChar),\n+        '\\r' => Err(EscapeError::BareCarriageReturn),\n+        _ => ascii_check(first_char, mode),\n+    }?;\n     if chars.next().is_some() {\n         return Err(EscapeError::MoreThanOneChar);\n     }\n@@ -303,12 +300,14 @@ where\n                         skip_ascii_whitespace(&mut chars, start, callback);\n                         continue;\n                     }\n-                    _ => scan_escape(first_char, &mut chars, mode),\n+                    _ => scan_escape(&mut chars, mode),\n                 }\n             }\n             '\\n' => Ok('\\n'),\n             '\\t' => Ok('\\t'),\n-            _ => scan_escape(first_char, &mut chars, mode),\n+            '\"' => Err(EscapeError::EscapeOnlyChar),\n+            '\\r' => Err(EscapeError::BareCarriageReturn),\n+            _ => ascii_check(first_char, mode),\n         };\n         let end = initial_len - chars.as_str().len();\n         callback(start..end, unescaped_char);"}]}