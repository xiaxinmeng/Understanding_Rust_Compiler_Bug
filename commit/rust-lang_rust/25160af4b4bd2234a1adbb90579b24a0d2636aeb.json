{"sha": "25160af4b4bd2234a1adbb90579b24a0d2636aeb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1MTYwYWY0YjRiZDIyMzRhMWFkYmI5MDU3OWIyNGEwZDI2MzZhZWI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-01T22:53:24Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2016-05-03T22:29:58Z"}, "message": "rustdoc: refactor rustdoc syntax highlighting for a more flexible API\n\nClients can now use the rustdoc syntax highlighter to classify tokens, then use that info to put together there own HTML (or whatever), rather than just having static HTML output.", "tree": {"sha": "d7b60ef59456a063e1acbbe24154f48a1ae2949e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d7b60ef59456a063e1acbbe24154f48a1ae2949e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25160af4b4bd2234a1adbb90579b24a0d2636aeb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25160af4b4bd2234a1adbb90579b24a0d2636aeb", "html_url": "https://github.com/rust-lang/rust/commit/25160af4b4bd2234a1adbb90579b24a0d2636aeb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25160af4b4bd2234a1adbb90579b24a0d2636aeb/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a4b0481d1c21be290f587a85e8bb342b6d0b7093", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4b0481d1c21be290f587a85e8bb342b6d0b7093", "html_url": "https://github.com/rust-lang/rust/commit/a4b0481d1c21be290f587a85e8bb342b6d0b7093"}], "stats": {"total": 350, "additions": 245, "deletions": 105}, "files": [{"sha": "7ccf51a46295385258f63af2bf372ac2ed5abbcf", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 245, "deletions": 105, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/25160af4b4bd2234a1adbb90579b24a0d2636aeb/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25160af4b4bd2234a1adbb90579b24a0d2636aeb/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=25160af4b4bd2234a1adbb90579b24a0d2636aeb", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,16 +8,26 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Basic html highlighting functionality\n+//! Basic syntax highlighting functionality.\n //!\n //! This module uses libsyntax's lexer to provide token-based highlighting for\n //! the HTML documentation generated by rustdoc.\n+//!\n+//! If you just want to syntax highlighting for a Rust program, then you can use\n+//! the `render_inner_with_highlighting` or `render_with_highlighting`\n+//! functions. For more advanced use cases (if you want to supply your own css\n+//! classes or control how the HTML is generated, or even generate something\n+//! other then HTML), then you should implement the the `Writer` trait and use a\n+//! `Classifier`.\n \n use html::escape::Escape;\n \n+use std::fmt::Display;\n use std::io;\n use std::io::prelude::*;\n-use syntax::parse::lexer::{self, Reader};\n+\n+use syntax::codemap::{CodeMap, Span};\n+use syntax::parse::lexer::{self, Reader, TokenAndSpan};\n use syntax::parse::token;\n use syntax::parse;\n \n@@ -29,11 +39,13 @@ pub fn render_with_highlighting(src: &str, class: Option<&str>, id: Option<&str>\n \n     let mut out = Vec::new();\n     write_header(class, id, &mut out).unwrap();\n-    if let Err(_) = write_source(&sess,\n-                                 lexer::StringReader::new(&sess.span_diagnostic, fm),\n-                                 &mut out) {\n-        return format!(\"<pre>{}</pre>\", src)\n+\n+    let mut classifier = Classifier::new(lexer::StringReader::new(&sess.span_diagnostic, fm),\n+                                         sess.codemap());\n+    if let Err(_) = classifier.write_source(&mut out) {\n+        return format!(\"<pre>{}</pre>\", src);\n     }\n+\n     write_footer(&mut out).unwrap();\n     String::from_utf8_lossy(&out[..]).into_owned()\n }\n@@ -46,84 +58,187 @@ pub fn render_inner_with_highlighting(src: &str) -> io::Result<String> {\n     let fm = sess.codemap().new_filemap(\"<stdin>\".to_string(), src.to_string());\n \n     let mut out = Vec::new();\n-    write_source(&sess,\n-                 lexer::StringReader::new(&sess.span_diagnostic, fm),\n-                 &mut out)?;\n-    Ok(String::from_utf8_lossy(&out[..]).into_owned())\n+    let mut classifier = Classifier::new(lexer::StringReader::new(&sess.span_diagnostic, fm),\n+                                         sess.codemap());\n+    classifier.write_source(&mut out)?;\n+\n+    Ok(String::from_utf8_lossy(&out).into_owned())\n+}\n+\n+/// Processes a program (nested in the internal `lexer`), classifying strings of\n+/// text by highlighting category (`Class`). Calls out to a `Writer` to write\n+/// each span of text in sequence.\n+pub struct Classifier<'a> {\n+    lexer: lexer::StringReader<'a>,\n+    codemap: &'a CodeMap,\n+\n+    // State of the classifier.\n+    in_attribute: bool,\n+    in_macro: bool,\n+    in_macro_nonterminal: bool,\n+}\n+\n+/// How a span of text is classified. Mostly corresponds to token kinds.\n+#[derive(Clone, Copy, Debug, Eq, PartialEq)]\n+pub enum Class {\n+    None,\n+    Comment,\n+    DocComment,\n+    Attribute,\n+    KeyWord,\n+    // Keywords that do pointer/reference stuff.\n+    RefKeyWord,\n+    Self_,\n+    Op,\n+    Macro,\n+    MacroNonTerminal,\n+    String,\n+    Number,\n+    Bool,\n+    Ident,\n+    Lifetime,\n+    PreludeTy,\n+    PreludeVal,\n }\n \n-/// Exhausts the `lexer` writing the output into `out`.\n+/// Trait that controls writing the output of syntax highlighting. Users should\n+/// implement this trait to customise writing output.\n ///\n-/// The general structure for this method is to iterate over each token,\n-/// possibly giving it an HTML span with a class specifying what flavor of token\n-/// it's used. All source code emission is done as slices from the source map,\n-/// not from the tokens themselves, in order to stay true to the original\n-/// source.\n-fn write_source(sess: &parse::ParseSess,\n-                mut lexer: lexer::StringReader,\n-                out: &mut Write)\n-                -> io::Result<()> {\n-    let mut is_attribute = false;\n-    let mut is_macro = false;\n-    let mut is_macro_nonterminal = false;\n-    loop {\n-        let next = match lexer.try_next_token() {\n-            Ok(tok) => tok,\n-            Err(_) => {\n-                lexer.emit_fatal_errors();\n-                lexer.span_diagnostic.struct_warn(\"Backing out of syntax highlighting\")\n-                                     .note(\"You probably did not intend to render this \\\n-                                            as a rust code-block\")\n-                                     .emit();\n-                return Err(io::Error::new(io::ErrorKind::Other, \"\"))\n-            },\n-        };\n+/// The classifier will call into the `Writer` implementation as it finds spans\n+/// of text to highlight. Exactly how that text should be highlighted is up to\n+/// the implemention.\n+pub trait Writer {\n+    /// Called when we start processing a span of text that should be highlighted.\n+    /// The `Class` argument specifies how it should be highlighted.\n+    fn enter_span(&mut self, Class) -> io::Result<()>;\n \n-        let snip = |sp| sess.codemap().span_to_snippet(sp).unwrap();\n+    /// Called at the end of a span of highlighted text.\n+    fn exit_span(&mut self) -> io::Result<()>;\n \n-        if next.tok == token::Eof { break }\n+    /// Called for a span of text, usually, but not always, a single token. If\n+    /// the string of text (`T`) does correspond to a token, then the token will\n+    /// also be passed. If the text should be highlighted differently from the\n+    /// surrounding text, then the `Class` argument will be a value other than\n+    /// `None`.\n+    /// The following sequences of callbacks are equivalent:\n+    /// ```plain\n+    ///     enter_span(Foo), string(\"text\", None), exit_span()\n+    ///     string(\"text\", Foo)\n+    /// ```\n+    /// The latter can be thought of as a shorthand for the former, which is\n+    /// more flexible.\n+    fn string<T: Display>(&mut self, T, Class, Option<&TokenAndSpan>) -> io::Result<()>;\n+}\n \n-        let klass = match next.tok {\n-            token::Whitespace => {\n-                write!(out, \"{}\", Escape(&snip(next.sp)))?;\n-                continue\n-            },\n-            token::Comment => {\n-                write!(out, \"<span class='comment'>{}</span>\",\n-                       Escape(&snip(next.sp)))?;\n-                continue\n-            },\n+// Implement `Writer` for anthing that can be written to, this just implements\n+// the default rustdoc behaviour.\n+impl<U: Write> Writer for U {\n+    fn string<T: Display>(&mut self,\n+                          text: T,\n+                          klass: Class,\n+                          _tas: Option<&TokenAndSpan>)\n+                          -> io::Result<()> {\n+        match klass {\n+            Class::None => write!(self, \"{}\", text),\n+            klass => write!(self, \"<span class='{}'>{}</span>\", klass.rustdoc_class(), text),\n+        }\n+    }\n+\n+    fn enter_span(&mut self, klass: Class) -> io::Result<()> {\n+        write!(self, \"<span class='{}'>\", klass.rustdoc_class())\n+    }\n+\n+    fn exit_span(&mut self) -> io::Result<()> {\n+        write!(self, \"</span>\")\n+    }\n+}\n+\n+impl<'a> Classifier<'a> {\n+    pub fn new(lexer: lexer::StringReader<'a>, codemap: &'a CodeMap) -> Classifier<'a> {\n+        Classifier {\n+            lexer: lexer,\n+            codemap: codemap,\n+            in_attribute: false,\n+            in_macro: false,\n+            in_macro_nonterminal: false,\n+        }\n+    }\n+\n+    /// Exhausts the `lexer` writing the output into `out`.\n+    ///\n+    /// The general structure for this method is to iterate over each token,\n+    /// possibly giving it an HTML span with a class specifying what flavor of token\n+    /// is used. All source code emission is done as slices from the source map,\n+    /// not from the tokens themselves, in order to stay true to the original\n+    /// source.\n+    pub fn write_source<W: Writer>(&mut self,\n+                                   out: &mut W)\n+                                   -> io::Result<()> {\n+        loop {\n+            let next = match self.lexer.try_next_token() {\n+                Ok(tas) => tas,\n+                Err(_) => {\n+                    self.lexer.emit_fatal_errors();\n+                    self.lexer.span_diagnostic.struct_warn(\"Backing out of syntax highlighting\")\n+                                              .note(\"You probably did not intend to render this \\\n+                                                     as a rust code-block\")\n+                                              .emit();\n+                    return Err(io::Error::new(io::ErrorKind::Other, \"\"));\n+                }\n+            };\n+\n+            if next.tok == token::Eof {\n+                break;\n+            }\n+\n+            self.write_token(out, next)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    // Handles an individual token from the lexer.\n+    fn write_token<W: Writer>(&mut self,\n+                              out: &mut W,\n+                              tas: TokenAndSpan)\n+                              -> io::Result<()> {\n+        let klass = match tas.tok {\n             token::Shebang(s) => {\n-                write!(out, \"{}\", Escape(&s.as_str()))?;\n-                continue\n+                out.string(Escape(&s.as_str()), Class::None, Some(&tas))?;\n+                return Ok(());\n             },\n+\n+            token::Whitespace => Class::None,\n+            token::Comment => Class::Comment,\n+            token::DocComment(..) => Class::DocComment,\n+\n             // If this '&' token is directly adjacent to another token, assume\n             // that it's the address-of operator instead of the and-operator.\n-            // This allows us to give all pointers their own class (`Box` and\n-            // `@` are below).\n-            token::BinOp(token::And) if lexer.peek().sp.lo == next.sp.hi => \"kw-2\",\n-            token::At | token::Tilde => \"kw-2\",\n+            token::BinOp(token::And) if self.lexer.peek().sp.lo == tas.sp.hi => Class::RefKeyWord,\n \n-            // consider this as part of a macro invocation if there was a\n-            // leading identifier\n-            token::Not if is_macro => { is_macro = false; \"macro\" }\n+            // Consider this as part of a macro invocation if there was a\n+            // leading identifier.\n+            token::Not if self.in_macro => {\n+                self.in_macro = false;\n+                Class::Macro\n+            }\n \n-            // operators\n+            // Operators.\n             token::Eq | token::Lt | token::Le | token::EqEq | token::Ne | token::Ge | token::Gt |\n                 token::AndAnd | token::OrOr | token::Not | token::BinOp(..) | token::RArrow |\n-                token::BinOpEq(..) | token::FatArrow => \"op\",\n+                token::BinOpEq(..) | token::FatArrow => Class::Op,\n \n-            // miscellaneous, no highlighting\n+            // Miscellaneous, no highlighting.\n             token::Dot | token::DotDot | token::DotDotDot | token::Comma | token::Semi |\n                 token::Colon | token::ModSep | token::LArrow | token::OpenDelim(_) |\n                 token::CloseDelim(token::Brace) | token::CloseDelim(token::Paren) |\n-                token::Question => \"\",\n+                token::Question => Class::None,\n             token::Dollar => {\n-                if lexer.peek().tok.is_ident() {\n-                    is_macro_nonterminal = true;\n-                    \"macro-nonterminal\"\n+                if self.lexer.peek().tok.is_ident() {\n+                    self.in_macro_nonterminal = true;\n+                    Class::MacroNonTerminal\n                 } else {\n-                    \"\"\n+                    Class::None\n                 }\n             }\n \n@@ -132,78 +247,103 @@ fn write_source(sess: &parse::ParseSess,\n             // seen, so skip out early. Down below we terminate the attribute\n             // span when we see the ']'.\n             token::Pound => {\n-                is_attribute = true;\n-                write!(out, r\"<span class='attribute'>#\")?;\n-                continue\n+                self.in_attribute = true;\n+                out.enter_span(Class::Attribute)?;\n+                out.string(\"#\", Class::None, None)?;\n+                return Ok(());\n             }\n             token::CloseDelim(token::Bracket) => {\n-                if is_attribute {\n-                    is_attribute = false;\n-                    write!(out, \"]</span>\")?;\n-                    continue\n+                if self.in_attribute {\n+                    self.in_attribute = false;\n+                    out.string(\"]\", Class::None, None)?;\n+                    out.exit_span()?;\n+                    return Ok(());\n                 } else {\n-                    \"\"\n+                    Class::None\n                 }\n             }\n \n             token::Literal(lit, _suf) => {\n                 match lit {\n-                    // text literals\n+                    // Text literals.\n                     token::Byte(..) | token::Char(..) |\n                         token::ByteStr(..) | token::ByteStrRaw(..) |\n-                        token::Str_(..) | token::StrRaw(..) => \"string\",\n+                        token::Str_(..) | token::StrRaw(..) => Class::String,\n \n-                    // number literals\n-                    token::Integer(..) | token::Float(..) => \"number\",\n+                    // Number literals.\n+                    token::Integer(..) | token::Float(..) => Class::Number,\n                 }\n             }\n \n-            // keywords are also included in the identifier set\n+            // Keywords are also included in the identifier set.\n             token::Ident(ident) => {\n                 match &*ident.name.as_str() {\n-                    \"ref\" | \"mut\" => \"kw-2\",\n+                    \"ref\" | \"mut\" => Class::RefKeyWord,\n \n-                    \"self\" => \"self\",\n-                    \"false\" | \"true\" => \"boolval\",\n+                    \"self\" |\"Self\" => Class::Self_,\n+                    \"false\" | \"true\" => Class::Bool,\n \n-                    \"Option\" | \"Result\" => \"prelude-ty\",\n-                    \"Some\" | \"None\" | \"Ok\" | \"Err\" => \"prelude-val\",\n+                    \"Option\" | \"Result\" => Class::PreludeTy,\n+                    \"Some\" | \"None\" | \"Ok\" | \"Err\" => Class::PreludeVal,\n \n-                    _ if next.tok.is_any_keyword() => \"kw\",\n+                    _ if tas.tok.is_any_keyword() => Class::KeyWord,\n                     _ => {\n-                        if is_macro_nonterminal {\n-                            is_macro_nonterminal = false;\n-                            \"macro-nonterminal\"\n-                        } else if lexer.peek().tok == token::Not {\n-                            is_macro = true;\n-                            \"macro\"\n+                        if self.in_macro_nonterminal {\n+                            self.in_macro_nonterminal = false;\n+                            Class::MacroNonTerminal\n+                        } else if self.lexer.peek().tok == token::Not {\n+                            self.in_macro = true;\n+                            Class::Macro\n                         } else {\n-                            \"ident\"\n+                            Class::Ident\n                         }\n                     }\n                 }\n             }\n \n-            // Special macro vars are like keywords\n-            token::SpecialVarNt(_) => \"kw-2\",\n+            // Special macro vars are like keywords.\n+            token::SpecialVarNt(_) => Class::KeyWord,\n+\n+            token::Lifetime(..) => Class::Lifetime,\n \n-            token::Lifetime(..) => \"lifetime\",\n-            token::DocComment(..) => \"doccomment\",\n             token::Underscore | token::Eof | token::Interpolated(..) |\n-                token::MatchNt(..) | token::SubstNt(..) => \"\",\n+            token::MatchNt(..) | token::SubstNt(..) | token::Tilde | token::At => Class::None,\n         };\n \n-        // as mentioned above, use the original source code instead of\n-        // stringifying this token\n-        let snip = sess.codemap().span_to_snippet(next.sp).unwrap();\n-        if klass == \"\" {\n-            write!(out, \"{}\", Escape(&snip))?;\n-        } else {\n-            write!(out, \"<span class='{}'>{}</span>\", klass, Escape(&snip))?;\n-        }\n+        // Anything that didn't return above is the simple case where we the\n+        // class just spans a single token, so we can use the `string` method.\n+        out.string(Escape(&self.snip(tas.sp)), klass, Some(&tas))\n     }\n \n-    Ok(())\n+    // Helper function to get a snippet from the codemap.\n+    fn snip(&self, sp: Span) -> String {\n+        self.codemap.span_to_snippet(sp).unwrap()\n+    }\n+}\n+\n+impl Class {\n+    /// Returns the css class expected by rustdoc for each `Class`.\n+    pub fn rustdoc_class(self) -> &'static str {\n+        match self {\n+            Class::None => \"\",\n+            Class::Comment => \"comment\",\n+            Class::DocComment => \"doccomment\",\n+            Class::Attribute => \"attribute\",\n+            Class::KeyWord => \"kw\",\n+            Class::RefKeyWord => \"kw-2\",\n+            Class::Self_ => \"self\",\n+            Class::Op => \"op\",\n+            Class::Macro => \"macro\",\n+            Class::MacroNonTerminal => \"macro-nonterminal\",\n+            Class::String => \"string\",\n+            Class::Number => \"number\",\n+            Class::Bool => \"boolvalue\",\n+            Class::Ident => \"ident\",\n+            Class::Lifetime => \"lifetime\",\n+            Class::PreludeTy => \"prelude-ty\",\n+            Class::PreludeVal => \"prelude-val\",\n+        }\n+    }\n }\n \n fn write_header(class: Option<&str>,"}]}