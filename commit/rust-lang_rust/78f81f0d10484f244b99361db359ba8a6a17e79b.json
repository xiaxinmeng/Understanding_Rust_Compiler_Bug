{"sha": "78f81f0d10484f244b99361db359ba8a6a17e79b", "node_id": "C_kwDOAAsO6NoAKDc4ZjgxZjBkMTA0ODRmMjQ0Yjk5MzYxZGIzNTliYThhNmExN2U3OWI", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2022-04-04T23:53:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-04T23:53:33Z"}, "message": "Rollup merge of #95620 - RalfJung:memory-no-extras, r=oli-obk\n\ninterpret: remove MemoryExtra in favor of giving access to the Machine\n\nThe Miri PR for this is upcoming.\n\nr? ``@oli-obk``", "tree": {"sha": "5610c2d4d9c7a26f587c1d37b019b0be2b7d1e4a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5610c2d4d9c7a26f587c1d37b019b0be2b7d1e4a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/78f81f0d10484f244b99361db359ba8a6a17e79b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiS4T9CRBK7hj4Ov3rIwAAuogIAFO/KyLz/7uj9T97wzhul5mW\nuASEp754LD6tfsqOfu4Qv/incHZubqnnTgxe0Hirdsl6LyfB/iP+lyEVsZbnP7LN\nikhsDH/lJqeo4U+yI+EQ0jrdNVEK7ridLbi6JB0b7ivcggDM5VQIOSLUUN8m1wgE\numVuF21APPjj98YA6h3dMaJvvAMjaeUcJ9vS2CQC7vMYvqn6js8xCBvDhKOqdNWv\ngVTrK4+LSZeko7qFYPnZ0/gVaiHCQ9OCHqY8H6vRMcgX0SYJfjTfMbs9Cvg9tubZ\n51Ly4DJJVEcmHzq/1FLa/5eCZpz5nDPiymajWSr+9vyvuafmg8kjv7AqabyTm1Y=\n=CAu8\n-----END PGP SIGNATURE-----\n", "payload": "tree 5610c2d4d9c7a26f587c1d37b019b0be2b7d1e4a\nparent 92e53f5cc9216f019bc732741d13086f29855dc1\nparent 84a343d1b5f4064863a1a4a83782454cf6c2ab37\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1649116413 +0200\ncommitter GitHub <noreply@github.com> 1649116413 +0200\n\nRollup merge of #95620 - RalfJung:memory-no-extras, r=oli-obk\n\ninterpret: remove MemoryExtra in favor of giving access to the Machine\n\nThe Miri PR for this is upcoming.\n\nr? ``@oli-obk``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/78f81f0d10484f244b99361db359ba8a6a17e79b", "html_url": "https://github.com/rust-lang/rust/commit/78f81f0d10484f244b99361db359ba8a6a17e79b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/78f81f0d10484f244b99361db359ba8a6a17e79b/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92e53f5cc9216f019bc732741d13086f29855dc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/92e53f5cc9216f019bc732741d13086f29855dc1", "html_url": "https://github.com/rust-lang/rust/commit/92e53f5cc9216f019bc732741d13086f29855dc1"}, {"sha": "84a343d1b5f4064863a1a4a83782454cf6c2ab37", "url": "https://api.github.com/repos/rust-lang/rust/commits/84a343d1b5f4064863a1a4a83782454cf6c2ab37", "html_url": "https://github.com/rust-lang/rust/commit/84a343d1b5f4064863a1a4a83782454cf6c2ab37"}], "stats": {"total": 454, "additions": 201, "deletions": 253}, "files": [{"sha": "b81a4bfe149dc3e03507e41ea53df7f44ef8a72e", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -1,4 +1,4 @@\n-use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr, MemoryExtra};\n+use super::{CompileTimeEvalContext, CompileTimeInterpreter, ConstEvalErr};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n     intern_const_alloc_recursive, Allocation, ConstAlloc, ConstValue, CtfeValidationMode, GlobalId,\n@@ -100,8 +100,7 @@ pub(super) fn mk_eval_cx<'mir, 'tcx>(\n         tcx,\n         root_span,\n         param_env,\n-        CompileTimeInterpreter::new(tcx.const_eval_limit()),\n-        MemoryExtra { can_access_statics },\n+        CompileTimeInterpreter::new(tcx.const_eval_limit(), can_access_statics),\n     )\n }\n \n@@ -285,10 +284,9 @@ pub fn eval_to_allocation_raw_provider<'tcx>(\n         tcx,\n         tcx.def_span(def.did),\n         key.param_env,\n-        CompileTimeInterpreter::new(tcx.const_eval_limit()),\n         // Statics (and promoteds inside statics) may access other statics, because unlike consts\n         // they do not have to behave \"as if\" they were evaluated at runtime.\n-        MemoryExtra { can_access_statics: is_static },\n+        CompileTimeInterpreter::new(tcx.const_eval_limit(), /*can_access_statics:*/ is_static),\n     );\n \n     let res = ecx.load_mir(cid.instance.def, cid.promoted);"}, {"sha": "5aae4a90960048f7f15796378ee03d29ae39f530", "filename": "compiler/rustc_const_eval/src/const_eval/machine.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Fmachine.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -93,10 +93,7 @@ pub struct CompileTimeInterpreter<'mir, 'tcx> {\n \n     /// The virtual call stack.\n     pub(crate) stack: Vec<Frame<'mir, 'tcx, AllocId, ()>>,\n-}\n \n-#[derive(Copy, Clone, Debug)]\n-pub struct MemoryExtra {\n     /// We need to make sure consts never point to anything mutable, even recursively. That is\n     /// relied on for pattern matching on consts with references.\n     /// To achieve this, two pieces have to work together:\n@@ -107,8 +104,12 @@ pub struct MemoryExtra {\n }\n \n impl<'mir, 'tcx> CompileTimeInterpreter<'mir, 'tcx> {\n-    pub(super) fn new(const_eval_limit: Limit) -> Self {\n-        CompileTimeInterpreter { steps_remaining: const_eval_limit.0, stack: Vec::new() }\n+    pub(super) fn new(const_eval_limit: Limit, can_access_statics: bool) -> Self {\n+        CompileTimeInterpreter {\n+            steps_remaining: const_eval_limit.0,\n+            stack: Vec::new(),\n+            can_access_statics,\n+        }\n     }\n }\n \n@@ -233,8 +234,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n     type MemoryKind = MemoryKind;\n \n-    type MemoryExtra = MemoryExtra;\n-\n     const PANIC_ON_ALLOC_FAIL: bool = false; // will be raised as a proper error\n \n     fn load_mir(\n@@ -345,7 +344,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     Err(err) => throw_ub_format!(\"align has to be a power of 2, {}\", err),\n                 };\n \n-                let ptr = ecx.memory.allocate(\n+                let ptr = ecx.allocate_ptr(\n                     Size::from_bytes(size as u64),\n                     align,\n                     interpret::MemoryKind::Machine(MemoryKind::Heap),\n@@ -365,14 +364,14 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n \n                 // If an allocation is created in an another const,\n                 // we don't deallocate it.\n-                let (alloc_id, _, _) = ecx.memory.ptr_get_alloc(ptr)?;\n+                let (alloc_id, _, _) = ecx.ptr_get_alloc_id(ptr)?;\n                 let is_allocated_in_another_const = matches!(\n                     ecx.tcx.get_global_alloc(alloc_id),\n                     Some(interpret::GlobalAlloc::Memory(_))\n                 );\n \n                 if !is_allocated_in_another_const {\n-                    ecx.memory.deallocate(\n+                    ecx.deallocate_ptr(\n                         ptr,\n                         Some((size, align)),\n                         interpret::MemoryKind::Machine(MemoryKind::Heap),\n@@ -472,7 +471,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n     }\n \n     fn before_access_global(\n-        memory_extra: &MemoryExtra,\n+        machine: &Self,\n         alloc_id: AllocId,\n         alloc: ConstAllocation<'tcx>,\n         static_def_id: Option<DefId>,\n@@ -488,7 +487,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n             }\n         } else {\n             // Read access. These are usually allowed, with some exceptions.\n-            if memory_extra.can_access_statics {\n+            if machine.can_access_statics {\n                 // Machine configuration allows us read from anything (e.g., `static` initializer).\n                 Ok(())\n             } else if static_def_id.is_some() {"}, {"sha": "a244b79ed075406498e591469536ebb92f704b77", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -56,7 +56,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         )\n                         .ok_or_else(|| err_inval!(TooGeneric))?;\n \n-                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n+                        let fn_ptr = self.create_fn_alloc_ptr(FnVal::Instance(instance));\n                         self.write_pointer(fn_ptr, dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"reify fn pointer on {:?}\", src.layout.ty),\n@@ -87,7 +87,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             substs,\n                             ty::ClosureKind::FnOnce,\n                         );\n-                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n+                        let fn_ptr = self.create_fn_alloc_ptr(FnVal::Instance(instance));\n                         self.write_pointer(fn_ptr, dest)?;\n                     }\n                     _ => span_bug!(self.cur_span(), \"closure fn pointer on {:?}\", src.layout.ty),\n@@ -153,8 +153,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 return Ok(**src);\n             } else {\n                 // Casting the metadata away from a fat ptr.\n-                assert_eq!(src.layout.size, 2 * self.memory.pointer_size());\n-                assert_eq!(dest_layout.size, self.memory.pointer_size());\n+                assert_eq!(src.layout.size, 2 * self.pointer_size());\n+                assert_eq!(dest_layout.size, self.pointer_size());\n                 assert!(src.layout.ty.is_unsafe_ptr());\n                 return match **src {\n                     Immediate::ScalarPair(data, _) => Ok(data.into()),"}, {"sha": "a2ea0f516bfa4dccda68c163bd66b9048d667d1d", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 8, "deletions": 52, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -22,9 +22,9 @@ use rustc_span::{Pos, Span};\n use rustc_target::abi::{call::FnAbi, Align, HasDataLayout, Size, TargetDataLayout};\n \n use super::{\n-    AllocCheck, AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine,\n-    MemPlace, MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, Pointer,\n-    PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit, StackPopJump,\n+    AllocId, GlobalId, Immediate, InterpErrorInfo, InterpResult, MPlaceTy, Machine, MemPlace,\n+    MemPlaceMeta, Memory, MemoryKind, Operand, Place, PlaceTy, PointerArithmetic, Provenance,\n+    Scalar, ScalarMaybeUninit, StackPopJump,\n };\n use crate::transform::validate::equal_up_to_regions;\n \n@@ -413,13 +413,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         root_span: Span,\n         param_env: ty::ParamEnv<'tcx>,\n         machine: M,\n-        memory_extra: M::MemoryExtra,\n     ) -> Self {\n         InterpCx {\n             machine,\n             tcx: tcx.at(root_span),\n             param_env,\n-            memory: Memory::new(tcx, memory_extra),\n+            memory: Memory::new(),\n             recursion_limit: tcx.recursion_limit(),\n         }\n     }\n@@ -433,49 +432,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .map_or(self.tcx.span, |f| f.current_span())\n     }\n \n-    #[inline(always)]\n-    pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n-        self.memory.scalar_to_ptr(scalar)\n-    }\n-\n-    /// Test if this value might be null.\n-    /// If the machine does not support ptr-to-int casts, this is conservative.\n-    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> bool {\n-        match scalar.try_to_int() {\n-            Ok(int) => int.is_null(),\n-            Err(_) => {\n-                // Can only happen during CTFE.\n-                let ptr = self.scalar_to_ptr(scalar);\n-                match self.memory.ptr_try_get_alloc(ptr) {\n-                    Ok((alloc_id, offset, _)) => {\n-                        let (size, _align) = self\n-                            .memory\n-                            .get_size_and_align(alloc_id, AllocCheck::MaybeDead)\n-                            .expect(\"alloc info with MaybeDead cannot fail\");\n-                        // If the pointer is out-of-bounds, it may be null.\n-                        // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n-                        offset > size\n-                    }\n-                    Err(_offset) => bug!(\"a non-int scalar is always a pointer\"),\n-                }\n-            }\n-        }\n-    }\n-\n-    /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n-    /// the machine pointer to the allocation.  Must never be used\n-    /// for any other pointers, nor for TLS statics.\n-    ///\n-    /// Using the resulting pointer represents a *direct* access to that memory\n-    /// (e.g. by directly using a `static`),\n-    /// as opposed to access through a pointer that was created by the program.\n-    ///\n-    /// This function can fail only if `ptr` points to an `extern static`.\n-    #[inline(always)]\n-    pub fn global_base_pointer(&self, ptr: Pointer) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        self.memory.global_base_pointer(ptr)\n-    }\n-\n     #[inline(always)]\n     pub(crate) fn stack(&self) -> &[Frame<'mir, 'tcx, M::PointerTag, M::FrameExtra>] {\n         M::stack(self)\n@@ -949,9 +905,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             trace!(\n                 \"deallocating local {:?}: {:?}\",\n                 local,\n-                self.memory.dump_alloc(ptr.provenance.unwrap().get_alloc_id())\n+                self.dump_alloc(ptr.provenance.unwrap().get_alloc_id())\n             );\n-            self.memory.deallocate(ptr, None, MemoryKind::Stack)?;\n+            self.deallocate_ptr(ptr, None, MemoryKind::Stack)?;\n         };\n         Ok(())\n     }\n@@ -1057,15 +1013,15 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> std::fmt::Debug\n                     }\n                 }\n \n-                write!(fmt, \": {:?}\", self.ecx.memory.dump_allocs(allocs))\n+                write!(fmt, \": {:?}\", self.ecx.dump_allocs(allocs))\n             }\n             Place::Ptr(mplace) => match mplace.ptr.provenance.map(Provenance::get_alloc_id) {\n                 Some(alloc_id) => write!(\n                     fmt,\n                     \"by align({}) ref {:?}: {:?}\",\n                     mplace.align.bytes(),\n                     mplace.ptr,\n-                    self.ecx.memory.dump_alloc(alloc_id)\n+                    self.ecx.dump_alloc(alloc_id)\n                 ),\n                 ptr => write!(fmt, \" integral by ref: {:?}\", ptr),\n             },"}, {"sha": "a956a478cef9ee63e6240694d5c2c701f8bfb230", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -318,7 +318,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 // exception from the exception.)\n                 // This is the dual to the special exception for offset-by-0\n                 // in the inbounds pointer offset operation (see `ptr_offset_inbounds` below).\n-                match (self.memory.ptr_try_get_alloc(a), self.memory.ptr_try_get_alloc(b)) {\n+                match (self.ptr_try_get_alloc_id(a), self.ptr_try_get_alloc_id(b)) {\n                     (Err(a), Err(b)) if a == b && a != 0 => {\n                         // Both are the same non-null integer.\n                         self.write_scalar(Scalar::from_machine_isize(0, self), dest)?;\n@@ -335,13 +335,13 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             );\n                         }\n                         // And they must both be valid for zero-sized accesses (\"in-bounds or one past the end\").\n-                        self.memory.check_ptr_access_align(\n+                        self.check_ptr_access_align(\n                             a,\n                             Size::ZERO,\n                             Align::ONE,\n                             CheckInAllocMsg::OffsetFromTest,\n                         )?;\n-                        self.memory.check_ptr_access_align(\n+                        self.check_ptr_access_align(\n                             b,\n                             Size::ZERO,\n                             Align::ONE,\n@@ -545,7 +545,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let min_ptr = if offset_bytes >= 0 { ptr } else { offset_ptr };\n         let size = offset_bytes.unsigned_abs();\n         // This call handles checking for integer/null pointers.\n-        self.memory.check_ptr_access_align(\n+        self.check_ptr_access_align(\n             min_ptr,\n             Size::from_bytes(size),\n             Align::ONE,\n@@ -577,7 +577,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let src = self.read_pointer(&src)?;\n         let dst = self.read_pointer(&dst)?;\n \n-        self.memory.copy(src, align, dst, align, size, nonoverlapping)\n+        self.mem_copy(src, align, dst, align, size, nonoverlapping)\n     }\n \n     pub(crate) fn write_bytes_intrinsic(\n@@ -600,7 +600,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .ok_or_else(|| err_ub_format!(\"overflow computing total size of `write_bytes`\"))?;\n \n         let bytes = std::iter::repeat(byte).take(len.bytes_usize());\n-        self.memory.write_bytes(dst, bytes)\n+        self.write_bytes_ptr(dst, bytes)\n     }\n \n     pub(crate) fn raw_eq_intrinsic(\n@@ -613,8 +613,8 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let lhs = self.read_pointer(lhs)?;\n         let rhs = self.read_pointer(rhs)?;\n-        let lhs_bytes = self.memory.read_bytes(lhs, layout.size)?;\n-        let rhs_bytes = self.memory.read_bytes(rhs, layout.size)?;\n+        let lhs_bytes = self.read_bytes_ptr(lhs, layout.size)?;\n+        let rhs_bytes = self.read_bytes_ptr(rhs, layout.size)?;\n         Ok(Scalar::from_bool(lhs_bytes == rhs_bytes))\n     }\n }"}, {"sha": "39aec33819ce8411b1c9db9560296a343ea23fc1", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -14,7 +14,7 @@ use rustc_target::spec::abi::Abi;\n \n use super::{\n     AllocId, AllocRange, Allocation, ConstAllocation, Frame, ImmTy, InterpCx, InterpResult,\n-    LocalValue, MemPlace, Memory, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n+    LocalValue, MemPlace, MemoryKind, OpTy, Operand, PlaceTy, Pointer, Provenance, Scalar,\n     StackPopUnwind,\n };\n \n@@ -96,11 +96,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Extra data stored in every call frame.\n     type FrameExtra;\n \n-    /// Extra data stored in memory. A reference to this is available when `AllocExtra`\n-    /// gets initialized, so you can e.g., have an `Rc` here if there is global state you\n-    /// need access to in the `AllocExtra` hooks.\n-    type MemoryExtra;\n-\n     /// Extra data stored in every allocation.\n     type AllocExtra: Debug + Clone + 'static;\n \n@@ -123,11 +118,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     const PANIC_ON_ALLOC_FAIL: bool;\n \n     /// Whether memory accesses should be alignment-checked.\n-    fn enforce_alignment(memory_extra: &Self::MemoryExtra) -> bool;\n+    fn enforce_alignment(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether, when checking alignment, we should `force_int` and thus support\n     /// custom alignment logic based on whatever the integer address happens to be.\n-    fn force_int_for_alignment_check(memory_extra: &Self::MemoryExtra) -> bool;\n+    fn force_int_for_alignment_check(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n     /// Whether to enforce the validity invariant\n     fn enforce_validity(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n@@ -251,7 +246,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// `def_id` is `Some` if this is the \"lazy\" allocation of a static.\n     #[inline]\n     fn before_access_global(\n-        _memory_extra: &Self::MemoryExtra,\n+        _machine: &Self,\n         _alloc_id: AllocId,\n         _allocation: ConstAllocation<'tcx>,\n         _static_def_id: Option<DefId>,\n@@ -270,7 +265,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n \n     /// Return the root pointer for the given `extern static`.\n     fn extern_static_base_pointer(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         def_id: DefId,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>>;\n \n@@ -279,19 +274,19 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     ///\n     /// Not called on `extern` or thread-local statics (those use the methods above).\n     fn tag_alloc_base_pointer(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer,\n     ) -> Pointer<Self::PointerTag>;\n \n     /// \"Int-to-pointer cast\"\n     fn ptr_from_addr(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         addr: u64,\n     ) -> Pointer<Option<Self::PointerTag>>;\n \n     /// Convert a pointer with provenance into an allocation-offset pair.\n     fn ptr_get_alloc(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer<Self::PointerTag>,\n     ) -> (AllocId, Size);\n \n@@ -309,7 +304,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// cache the result. (This relies on `AllocMap::get_or` being able to add the\n     /// owned allocation to the map even when the map is shared.)\n     fn init_allocation_extra<'b>(\n-        mem: &Memory<'mir, 'tcx, Self>,\n+        ecx: &InterpCx<'mir, 'tcx, Self>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n@@ -322,7 +317,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// need to mutate.\n     #[inline(always)]\n     fn memory_read(\n-        _memory_extra: &Self::MemoryExtra,\n+        _machine: &Self,\n         _alloc_extra: &Self::AllocExtra,\n         _tag: Self::PointerTag,\n         _range: AllocRange,\n@@ -333,7 +328,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Hook for performing extra checks on a memory write access.\n     #[inline(always)]\n     fn memory_written(\n-        _memory_extra: &mut Self::MemoryExtra,\n+        _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n         _tag: Self::PointerTag,\n         _range: AllocRange,\n@@ -344,7 +339,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Hook for performing extra operations on a memory deallocation.\n     #[inline(always)]\n     fn memory_deallocated(\n-        _memory_extra: &mut Self::MemoryExtra,\n+        _machine: &mut Self,\n         _alloc_extra: &mut Self::AllocExtra,\n         _tag: Self::PointerTag,\n         _range: AllocRange,\n@@ -408,14 +403,14 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     type FrameExtra = ();\n \n     #[inline(always)]\n-    fn enforce_alignment(_memory_extra: &Self::MemoryExtra) -> bool {\n+    fn enforce_alignment(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         // We do not check for alignment to avoid having to carry an `Align`\n         // in `ConstValue::ByRef`.\n         false\n     }\n \n     #[inline(always)]\n-    fn force_int_for_alignment_check(_memory_extra: &Self::MemoryExtra) -> bool {\n+    fn force_int_for_alignment_check(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         // We do not support `force_int`.\n         false\n     }\n@@ -444,7 +439,7 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n \n     #[inline(always)]\n     fn init_allocation_extra<'b>(\n-        _mem: &Memory<$mir, $tcx, Self>,\n+        _ecx: &InterpCx<$mir, $tcx, Self>,\n         _id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         _kind: Option<MemoryKind<Self::MemoryKind>>,\n@@ -454,28 +449,28 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     }\n \n     fn extern_static_base_pointer(\n-        mem: &Memory<$mir, $tcx, Self>,\n+        ecx: &InterpCx<$mir, $tcx, Self>,\n         def_id: DefId,\n     ) -> InterpResult<$tcx, Pointer> {\n         // Use the `AllocId` associated with the `DefId`. Any actual *access* will fail.\n-        Ok(Pointer::new(mem.tcx.create_static_alloc(def_id), Size::ZERO))\n+        Ok(Pointer::new(ecx.tcx.create_static_alloc(def_id), Size::ZERO))\n     }\n \n     #[inline(always)]\n     fn tag_alloc_base_pointer(\n-        _mem: &Memory<$mir, $tcx, Self>,\n+        _ecx: &InterpCx<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n     ) -> Pointer<AllocId> {\n         ptr\n     }\n \n     #[inline(always)]\n-    fn ptr_from_addr(_mem: &Memory<$mir, $tcx, Self>, addr: u64) -> Pointer<Option<AllocId>> {\n+    fn ptr_from_addr(_ecx: &InterpCx<$mir, $tcx, Self>, addr: u64) -> Pointer<Option<AllocId>> {\n         Pointer::new(None, Size::from_bytes(addr))\n     }\n \n     #[inline(always)]\n-    fn ptr_get_alloc(_mem: &Memory<$mir, $tcx, Self>, ptr: Pointer<AllocId>) -> (AllocId, Size) {\n+    fn ptr_get_alloc(_ecx: &InterpCx<$mir, $tcx, Self>, ptr: Pointer<AllocId>) -> (AllocId, Size) {\n         // We know `offset` is relative to the allocation, so we can use `into_parts`.\n         let (alloc_id, offset) = ptr.into_parts();\n         (alloc_id, offset)"}, {"sha": "fcfcd5d8989f5706523c81cc750b25f2412d57d9", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 116, "deletions": 105, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -17,10 +17,10 @@ use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_middle::mir::display_allocation;\n use rustc_middle::ty::{Instance, ParamEnv, TyCtxt};\n-use rustc_target::abi::{Align, HasDataLayout, Size, TargetDataLayout};\n+use rustc_target::abi::{Align, HasDataLayout, Size};\n \n use super::{\n-    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc,\n+    alloc_range, AllocId, AllocMap, AllocRange, Allocation, CheckInAllocMsg, GlobalAlloc, InterpCx,\n     InterpResult, Machine, MayLeak, Pointer, PointerArithmetic, Provenance, Scalar,\n     ScalarMaybeUninit,\n };\n@@ -108,19 +108,6 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     /// that do not exist any more.\n     // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n-\n-    /// Extra data added by the machine.\n-    pub extra: M::MemoryExtra,\n-\n-    /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n-    #[inline]\n-    fn data_layout(&self) -> &TargetDataLayout {\n-        &self.tcx.data_layout\n-    }\n }\n \n /// A reference to some allocation that was already bounds-checked for the given region\n@@ -142,16 +129,21 @@ pub struct AllocRefMut<'a, 'tcx, Tag, Extra> {\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n-    pub fn new(tcx: TyCtxt<'tcx>, extra: M::MemoryExtra) -> Self {\n+    pub fn new() -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n             extra_fn_ptr_map: FxHashMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n-            extra,\n-            tcx,\n         }\n     }\n \n+    /// This is used by [priroda](https://github.com/oli-obk/priroda)\n+    pub fn alloc_map(&self) -> &M::MemoryMap {\n+        &self.alloc_map\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Call this to turn untagged \"global\" pointers (obtained via `tcx`) into\n     /// the machine pointer to the allocation.  Must never be used\n     /// for any other pointers, nor for TLS statics.\n@@ -182,7 +174,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(M::tag_alloc_base_pointer(self, Pointer::new(alloc_id, offset)))\n     }\n \n-    pub fn create_fn_alloc(\n+    pub fn create_fn_alloc_ptr(\n         &mut self,\n         fn_val: FnVal<'tcx, M::ExtraFnVal>,\n     ) -> Pointer<M::PointerTag> {\n@@ -191,7 +183,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             FnVal::Other(extra) => {\n                 // FIXME(RalfJung): Should we have a cache here?\n                 let id = self.tcx.reserve_alloc_id();\n-                let old = self.extra_fn_ptr_map.insert(id, extra);\n+                let old = self.memory.extra_fn_ptr_map.insert(id, extra);\n                 assert!(old.is_none());\n                 id\n             }\n@@ -201,28 +193,28 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         self.global_base_pointer(Pointer::from(id)).unwrap()\n     }\n \n-    pub fn allocate(\n+    pub fn allocate_ptr(\n         &mut self,\n         size: Size,\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'static, Pointer<M::PointerTag>> {\n         let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n-        Ok(self.allocate_with(alloc, kind))\n+        Ok(self.allocate_raw_ptr(alloc, kind))\n     }\n \n-    pub fn allocate_bytes(\n+    pub fn allocate_bytes_ptr(\n         &mut self,\n         bytes: &[u8],\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n         mutability: Mutability,\n     ) -> Pointer<M::PointerTag> {\n         let alloc = Allocation::from_bytes(bytes, align, mutability);\n-        self.allocate_with(alloc, kind)\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n-    pub fn allocate_with(\n+    pub fn allocate_raw_ptr(\n         &mut self,\n         alloc: Allocation,\n         kind: MemoryKind<M::MemoryKind>,\n@@ -234,19 +226,19 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             \"dynamically allocating global memory\"\n         );\n         let alloc = M::init_allocation_extra(self, id, Cow::Owned(alloc), Some(kind));\n-        self.alloc_map.insert(id, (kind, alloc.into_owned()));\n+        self.memory.alloc_map.insert(id, (kind, alloc.into_owned()));\n         M::tag_alloc_base_pointer(self, Pointer::from(id))\n     }\n \n-    pub fn reallocate(\n+    pub fn reallocate_ptr(\n         &mut self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         old_size_and_align: Option<(Size, Align)>,\n         new_size: Size,\n         new_align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub_format!(\n                 \"reallocating {:?} which does not point to the beginning of an object\",\n@@ -256,33 +248,33 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n         // This happens so rarely, the perf advantage is outweighed by the maintenance cost.\n-        let new_ptr = self.allocate(new_size, new_align, kind)?;\n+        let new_ptr = self.allocate_ptr(new_size, new_align, kind)?;\n         let old_size = match old_size_and_align {\n             Some((size, _align)) => size,\n-            None => self.get_raw(alloc_id)?.size(),\n+            None => self.get_alloc_raw(alloc_id)?.size(),\n         };\n         // This will also call the access hooks.\n-        self.copy(\n+        self.mem_copy(\n             ptr.into(),\n             Align::ONE,\n             new_ptr.into(),\n             Align::ONE,\n             old_size.min(new_size),\n             /*nonoverlapping*/ true,\n         )?;\n-        self.deallocate(ptr.into(), old_size_and_align, kind)?;\n+        self.deallocate_ptr(ptr.into(), old_size_and_align, kind)?;\n \n         Ok(new_ptr)\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n-    pub fn deallocate(\n+    pub fn deallocate_ptr(\n         &mut self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         old_size_and_align: Option<(Size, Align)>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx> {\n-        let (alloc_id, offset, ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, ptr) = self.ptr_get_alloc_id(ptr)?;\n         trace!(\"deallocating: {}\", alloc_id);\n \n         if offset.bytes() != 0 {\n@@ -292,7 +284,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             );\n         }\n \n-        let Some((alloc_kind, mut alloc)) = self.alloc_map.remove(&alloc_id) else {\n+        let Some((alloc_kind, mut alloc)) = self.memory.alloc_map.remove(&alloc_id) else {\n             // Deallocating global memory -- always an error\n             return Err(match self.tcx.get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Function(..)) => {\n@@ -335,14 +327,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // Let the machine take some extra action\n         let size = alloc.size();\n         M::memory_deallocated(\n-            &mut self.extra,\n+            &mut self.machine,\n             &mut alloc.extra,\n             ptr.provenance,\n             alloc_range(Size::ZERO, size),\n         )?;\n \n         // Don't forget to remember size and align of this now-dead allocation\n-        let old = self.dead_alloc_map.insert(alloc_id, (size, alloc.align));\n+        let old = self.memory.dead_alloc_map.insert(alloc_id, (size, alloc.align));\n         if old.is_some() {\n             bug!(\"Nothing can be deallocated twice\");\n         }\n@@ -358,15 +350,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<(AllocId, Size, Pointer<M::PointerTag>)>> {\n-        let align = M::enforce_alignment(&self.extra).then_some(align);\n+        let align = M::enforce_alignment(&self).then_some(align);\n         self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, ptr| {\n                 let (size, align) =\n-                    self.get_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n+                    self.get_alloc_size_and_align(alloc_id, AllocCheck::Dereferenceable)?;\n                 Ok((size, align, (alloc_id, offset, ptr)))\n             },\n         )\n@@ -392,7 +384,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 | CheckInAllocMsg::OffsetFromTest\n                 | CheckInAllocMsg::InboundsTest => AllocCheck::Live,\n             };\n-            let (size, align) = self.get_size_and_align(alloc_id, check)?;\n+            let (size, align) = self.get_alloc_size_and_align(alloc_id, check)?;\n             Ok((size, align, ()))\n         })?;\n         Ok(())\n@@ -427,7 +419,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             }\n         }\n \n-        Ok(match self.ptr_try_get_alloc(ptr) {\n+        Ok(match self.ptr_try_get_alloc_id(ptr) {\n             Err(addr) => {\n                 // We couldn't get a proper allocation. This is only okay if the access size is 0,\n                 // and the address is not null.\n@@ -456,7 +448,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 // Test align. Check this last; if both bounds and alignment are violated\n                 // we want the error to be about the bounds.\n                 if let Some(align) = align {\n-                    if M::force_int_for_alignment_check(&self.extra) {\n+                    if M::force_int_for_alignment_check(self) {\n                         let addr = Scalar::from_pointer(ptr, &self.tcx)\n                             .to_machine_usize(&self.tcx)\n                             .expect(\"ptr-to-int cast for align check should never fail\");\n@@ -479,7 +471,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n }\n \n /// Allocation accessors\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Helper function to obtain a global (tcx) allocation.\n     /// This attempts to return a reference to an existing allocation if\n     /// one can be found in `tcx`. That, however, is only possible if `tcx` and\n@@ -517,7 +509,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 (self.tcx.eval_static_initializer(def_id)?, Some(def_id))\n             }\n         };\n-        M::before_access_global(&self.extra, id, alloc, def_id, is_write)?;\n+        M::before_access_global(&self.machine, id, alloc, def_id, is_write)?;\n         // We got tcx memory. Let the machine initialize its \"extra\" stuff.\n         let alloc = M::init_allocation_extra(\n             self,\n@@ -530,15 +522,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     /// Gives raw access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n-    fn get_raw(\n+    fn get_alloc_raw(\n         &self,\n         id: AllocId,\n     ) -> InterpResult<'tcx, &Allocation<M::PointerTag, M::AllocExtra>> {\n         // The error type of the inner closure here is somewhat funny.  We have two\n         // ways of \"erroring\": An actual error, or because we got a reference from\n         // `get_global_alloc` that we can actually use directly without inserting anything anywhere.\n         // So the error type is `InterpResult<'tcx, &Allocation<M::PointerTag>>`.\n-        let a = self.alloc_map.get_or(id, || {\n+        let a = self.memory.alloc_map.get_or(id, || {\n             let alloc = self.get_global_alloc(id, /*is_write*/ false).map_err(Err)?;\n             match alloc {\n                 Cow::Borrowed(alloc) => {\n@@ -564,27 +556,27 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     /// \"Safe\" (bounds and align-checked) allocation access.\n-    pub fn get<'a>(\n+    pub fn get_ptr_alloc<'a>(\n         &'a self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRef<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n-        let align = M::enforce_alignment(&self.extra).then_some(align);\n+        let align = M::enforce_alignment(self).then_some(align);\n         let ptr_and_alloc = self.check_and_deref_ptr(\n             ptr,\n             size,\n             align,\n             CheckInAllocMsg::MemoryAccessTest,\n             |alloc_id, offset, ptr| {\n-                let alloc = self.get_raw(alloc_id)?;\n+                let alloc = self.get_alloc_raw(alloc_id)?;\n                 Ok((alloc.size(), alloc.align, (alloc_id, offset, ptr, alloc)))\n             },\n         )?;\n         if let Some((alloc_id, offset, ptr, alloc)) = ptr_and_alloc {\n             let range = alloc_range(offset, size);\n-            M::memory_read(&self.extra, &alloc.extra, ptr.provenance, range)?;\n-            Ok(Some(AllocRef { alloc, range, tcx: self.tcx, alloc_id }))\n+            M::memory_read(&self.machine, &alloc.extra, ptr.provenance, range)?;\n+            Ok(Some(AllocRef { alloc, range, tcx: *self.tcx, alloc_id }))\n         } else {\n             // Even in this branch we have to be sure that we actually access the allocation, in\n             // order to ensure that `static FOO: Type = FOO;` causes a cycle error instead of\n@@ -596,56 +588,55 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     /// Return the `extra` field of the given allocation.\n     pub fn get_alloc_extra<'a>(&'a self, id: AllocId) -> InterpResult<'tcx, &'a M::AllocExtra> {\n-        Ok(&self.get_raw(id)?.extra)\n+        Ok(&self.get_alloc_raw(id)?.extra)\n     }\n \n     /// Gives raw mutable access to the `Allocation`, without bounds or alignment checks.\n     /// The caller is responsible for calling the access hooks!\n     ///\n     /// Also returns a ptr to `self.extra` so that the caller can use it in parallel with the\n     /// allocation.\n-    fn get_raw_mut(\n+    fn get_alloc_raw_mut(\n         &mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&mut Allocation<M::PointerTag, M::AllocExtra>, &mut M::MemoryExtra)>\n-    {\n+    ) -> InterpResult<'tcx, (&mut Allocation<M::PointerTag, M::AllocExtra>, &mut M)> {\n         // We have \"NLL problem case #3\" here, which cannot be worked around without loss of\n         // efficiency even for the common case where the key is in the map.\n         // <https://rust-lang.github.io/rfcs/2094-nll.html#problem-case-3-conditional-control-flow-across-functions>\n         // (Cannot use `get_mut_or` since `get_global_alloc` needs `&self`.)\n-        if self.alloc_map.get_mut(id).is_none() {\n+        if self.memory.alloc_map.get_mut(id).is_none() {\n             // Slow path.\n             // Allocation not found locally, go look global.\n             let alloc = self.get_global_alloc(id, /*is_write*/ true)?;\n             let kind = M::GLOBAL_KIND.expect(\n                 \"I got a global allocation that I have to copy but the machine does \\\n                     not expect that to happen\",\n             );\n-            self.alloc_map.insert(id, (MemoryKind::Machine(kind), alloc.into_owned()));\n+            self.memory.alloc_map.insert(id, (MemoryKind::Machine(kind), alloc.into_owned()));\n         }\n \n-        let (_kind, alloc) = self.alloc_map.get_mut(id).unwrap();\n+        let (_kind, alloc) = self.memory.alloc_map.get_mut(id).unwrap();\n         if alloc.mutability == Mutability::Not {\n             throw_ub!(WriteToReadOnly(id))\n         }\n-        Ok((alloc, &mut self.extra))\n+        Ok((alloc, &mut self.machine))\n     }\n \n     /// \"Safe\" (bounds and align-checked) allocation access.\n-    pub fn get_mut<'a>(\n+    pub fn get_ptr_alloc_mut<'a>(\n         &'a mut self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n         align: Align,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'a, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         let parts = self.get_ptr_access(ptr, size, align)?;\n         if let Some((alloc_id, offset, ptr)) = parts {\n-            let tcx = self.tcx;\n+            let tcx = *self.tcx;\n             // FIXME: can we somehow avoid looking up the allocation twice here?\n             // We cannot call `get_raw_mut` inside `check_and_deref_ptr` as that would duplicate `&mut self`.\n-            let (alloc, extra) = self.get_raw_mut(alloc_id)?;\n+            let (alloc, machine) = self.get_alloc_raw_mut(alloc_id)?;\n             let range = alloc_range(offset, size);\n-            M::memory_written(extra, &mut alloc.extra, ptr.provenance, range)?;\n+            M::memory_written(machine, &mut alloc.extra, ptr.provenance, range)?;\n             Ok(Some(AllocRefMut { alloc, range, tcx, alloc_id }))\n         } else {\n             Ok(None)\n@@ -656,16 +647,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn get_alloc_extra_mut<'a>(\n         &'a mut self,\n         id: AllocId,\n-    ) -> InterpResult<'tcx, (&'a mut M::AllocExtra, &'a mut M::MemoryExtra)> {\n-        let (alloc, memory_extra) = self.get_raw_mut(id)?;\n-        Ok((&mut alloc.extra, memory_extra))\n+    ) -> InterpResult<'tcx, (&'a mut M::AllocExtra, &'a mut M)> {\n+        let (alloc, machine) = self.get_alloc_raw_mut(id)?;\n+        Ok((&mut alloc.extra, machine))\n     }\n \n     /// Obtain the size and alignment of an allocation, even if that allocation has\n     /// been deallocated.\n     ///\n     /// If `liveness` is `AllocCheck::MaybeDead`, this function always returns `Ok`.\n-    pub fn get_size_and_align(\n+    pub fn get_alloc_size_and_align(\n         &self,\n         id: AllocId,\n         liveness: AllocCheck,\n@@ -674,7 +665,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         // Don't use `self.get_raw` here as that will\n         // a) cause cycles in case `id` refers to a static\n         // b) duplicate a global's allocation in miri\n-        if let Some((_, alloc)) = self.alloc_map.get(id) {\n+        if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n             return Ok((alloc.size(), alloc.align));\n         }\n \n@@ -713,6 +704,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // Deallocated pointers are allowed, we should be able to find\n                     // them in the map.\n                     Ok(*self\n+                        .memory\n                         .dead_alloc_map\n                         .get(&id)\n                         .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n@@ -724,7 +716,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     }\n \n     fn get_fn_alloc(&self, id: AllocId) -> Option<FnVal<'tcx, M::ExtraFnVal>> {\n-        if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n+        if let Some(extra) = self.memory.extra_fn_ptr_map.get(&id) {\n             Some(FnVal::Other(*extra))\n         } else {\n             match self.tcx.get_global_alloc(id) {\n@@ -734,21 +726,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n-    pub fn get_fn(\n+    pub fn get_ptr_fn(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         trace!(\"get_fn({:?})\", ptr);\n-        let (alloc_id, offset, _ptr) = self.ptr_get_alloc(ptr)?;\n+        let (alloc_id, offset, _ptr) = self.ptr_get_alloc_id(ptr)?;\n         if offset.bytes() != 0 {\n             throw_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset)))\n         }\n         self.get_fn_alloc(alloc_id)\n             .ok_or_else(|| err_ub!(InvalidFunctionPointer(Pointer::new(alloc_id, offset))).into())\n     }\n \n-    pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n-        self.get_raw_mut(id)?.0.mutability = Mutability::Not;\n+    pub fn alloc_mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {\n+        self.get_alloc_raw_mut(id)?.0.mutability = Mutability::Not;\n         Ok(())\n     }\n \n@@ -765,7 +757,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn dump_allocs<'a>(&'a self, mut allocs: Vec<AllocId>) -> DumpAllocs<'a, 'mir, 'tcx, M> {\n         allocs.sort();\n         allocs.dedup();\n-        DumpAllocs { mem: self, allocs }\n+        DumpAllocs { ecx: self, allocs }\n     }\n \n     /// Print leaked memory. Allocations reachable from `static_roots` or a `Global` allocation\n@@ -775,14 +767,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let reachable = {\n             let mut reachable = FxHashSet::default();\n             let global_kind = M::GLOBAL_KIND.map(MemoryKind::Machine);\n-            let mut todo: Vec<_> = self.alloc_map.filter_map_collect(move |&id, &(kind, _)| {\n-                if Some(kind) == global_kind { Some(id) } else { None }\n-            });\n+            let mut todo: Vec<_> =\n+                self.memory.alloc_map.filter_map_collect(move |&id, &(kind, _)| {\n+                    if Some(kind) == global_kind { Some(id) } else { None }\n+                });\n             todo.extend(static_roots);\n             while let Some(id) = todo.pop() {\n                 if reachable.insert(id) {\n                     // This is a new allocation, add its relocations to `todo`.\n-                    if let Some((_, alloc)) = self.alloc_map.get(id) {\n+                    if let Some((_, alloc)) = self.memory.alloc_map.get(id) {\n                         todo.extend(alloc.relocations().values().map(|tag| tag.get_alloc_id()));\n                     }\n                 }\n@@ -791,7 +784,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         };\n \n         // All allocations that are *not* `reachable` and *not* `may_leak` are considered leaking.\n-        let leaks: Vec<_> = self.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n+        let leaks: Vec<_> = self.memory.alloc_map.filter_map_collect(|&id, &(kind, _)| {\n             if kind.may_leak() || reachable.contains(&id) { None } else { Some(id) }\n         });\n         let n = leaks.len();\n@@ -800,17 +793,12 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n         n\n     }\n-\n-    /// This is used by [priroda](https://github.com/oli-obk/priroda)\n-    pub fn alloc_map(&self) -> &M::MemoryMap {\n-        &self.alloc_map\n-    }\n }\n \n #[doc(hidden)]\n /// There's no way to use this directly, it's just a helper struct for the `dump_alloc(s)` methods.\n pub struct DumpAllocs<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n-    mem: &'a Memory<'mir, 'tcx, M>,\n+    ecx: &'a InterpCx<'mir, 'tcx, M>,\n     allocs: Vec<AllocId>,\n }\n \n@@ -840,25 +828,25 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n             }\n \n             write!(fmt, \"{}\", id)?;\n-            match self.mem.alloc_map.get(id) {\n+            match self.ecx.memory.alloc_map.get(id) {\n                 Some(&(kind, ref alloc)) => {\n                     // normal alloc\n                     write!(fmt, \" ({}, \", kind)?;\n                     write_allocation_track_relocs(\n                         &mut *fmt,\n-                        self.mem.tcx,\n+                        *self.ecx.tcx,\n                         &mut allocs_to_print,\n                         alloc,\n                     )?;\n                 }\n                 None => {\n                     // global alloc\n-                    match self.mem.tcx.get_global_alloc(id) {\n+                    match self.ecx.tcx.get_global_alloc(id) {\n                         Some(GlobalAlloc::Memory(alloc)) => {\n                             write!(fmt, \" (unchanged global, \")?;\n                             write_allocation_track_relocs(\n                                 &mut *fmt,\n-                                self.mem.tcx,\n+                                *self.ecx.tcx,\n                                 &mut allocs_to_print,\n                                 alloc.inner(),\n                             )?;\n@@ -867,7 +855,7 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> std::fmt::Debug for DumpAllocs<'a,\n                             write!(fmt, \" (fn: {})\", func)?;\n                         }\n                         Some(GlobalAlloc::Static(did)) => {\n-                            write!(fmt, \" (static: {})\", self.mem.tcx.def_path_str(did))?;\n+                            write!(fmt, \" (static: {})\", self.ecx.tcx.def_path_str(did))?;\n                         }\n                         None => {\n                             write!(fmt, \" (deallocated)\")?;\n@@ -923,16 +911,16 @@ impl<'tcx, 'a, Tag: Provenance, Extra> AllocRef<'a, 'tcx, Tag, Extra> {\n     }\n }\n \n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Reads the given number of bytes from memory. Returns them as a slice.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn read_bytes(\n+    pub fn read_bytes_ptr(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         size: Size,\n     ) -> InterpResult<'tcx, &[u8]> {\n-        let Some(alloc_ref) = self.get(ptr, size, Align::ONE)? else {\n+        let Some(alloc_ref) = self.get_ptr_alloc(ptr, size, Align::ONE)? else {\n             // zero-sized access\n             return Ok(&[]);\n         };\n@@ -947,7 +935,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     /// Writes the given stream of bytes into memory.\n     ///\n     /// Performs appropriate bounds checks.\n-    pub fn write_bytes(\n+    pub fn write_bytes_ptr(\n         &mut self,\n         ptr: Pointer<Option<M::PointerTag>>,\n         src: impl IntoIterator<Item = u8>,\n@@ -958,7 +946,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         assert_eq!(lower, len, \"can only write iterators with a precise length\");\n \n         let size = Size::from_bytes(len);\n-        let Some(alloc_ref) = self.get_mut(ptr, size, Align::ONE)? else {\n+        let Some(alloc_ref) = self.get_ptr_alloc_mut(ptr, size, Align::ONE)? else {\n             // zero-sized access\n             assert_matches!(\n                 src.next(),\n@@ -984,7 +972,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         Ok(())\n     }\n \n-    pub fn copy(\n+    pub fn mem_copy(\n         &mut self,\n         src: Pointer<Option<M::PointerTag>>,\n         src_align: Align,\n@@ -993,10 +981,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         size: Size,\n         nonoverlapping: bool,\n     ) -> InterpResult<'tcx> {\n-        self.copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n+        self.mem_copy_repeatedly(src, src_align, dest, dest_align, size, 1, nonoverlapping)\n     }\n \n-    pub fn copy_repeatedly(\n+    pub fn mem_copy_repeatedly(\n         &mut self,\n         src: Pointer<Option<M::PointerTag>>,\n         src_align: Align,\n@@ -1019,9 +1007,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // Zero-sized *source*, that means dst is also zero-sized and we have nothing to do.\n             return Ok(());\n         };\n-        let src_alloc = self.get_raw(src_alloc_id)?;\n+        let src_alloc = self.get_alloc_raw(src_alloc_id)?;\n         let src_range = alloc_range(src_offset, size);\n-        M::memory_read(&self.extra, &src_alloc.extra, src.provenance, src_range)?;\n+        M::memory_read(&self.machine, &src_alloc.extra, src.provenance, src_range)?;\n         // We need the `dest` ptr for the next operation, so we get it now.\n         // We already did the source checks and called the hooks so we are good to return early.\n         let Some((dest_alloc_id, dest_offset, dest)) = dest_parts else {\n@@ -1044,7 +1032,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         let compressed = src_alloc.compress_uninit_range(src_range);\n \n         // Destination alloc preparations and access hooks.\n-        let (dest_alloc, extra) = self.get_raw_mut(dest_alloc_id)?;\n+        let (dest_alloc, extra) = self.get_alloc_raw_mut(dest_alloc_id)?;\n         let dest_range = alloc_range(dest_offset, size * num_copies);\n         M::memory_written(extra, &mut dest_alloc.extra, dest.provenance, dest_range)?;\n         let dest_bytes = dest_alloc\n@@ -1112,7 +1100,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n }\n \n /// Machine pointer introspection.\n-impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n+impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     pub fn scalar_to_ptr(&self, scalar: Scalar<M::PointerTag>) -> Pointer<Option<M::PointerTag>> {\n         // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n         // call to force getting out a pointer.\n@@ -1129,9 +1117,32 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         }\n     }\n \n+    /// Test if this value might be null.\n+    /// If the machine does not support ptr-to-int casts, this is conservative.\n+    pub fn scalar_may_be_null(&self, scalar: Scalar<M::PointerTag>) -> bool {\n+        match scalar.try_to_int() {\n+            Ok(int) => int.is_null(),\n+            Err(_) => {\n+                // Can only happen during CTFE.\n+                let ptr = self.scalar_to_ptr(scalar);\n+                match self.ptr_try_get_alloc_id(ptr) {\n+                    Ok((alloc_id, offset, _)) => {\n+                        let (size, _align) = self\n+                            .get_alloc_size_and_align(alloc_id, AllocCheck::MaybeDead)\n+                            .expect(\"alloc info with MaybeDead cannot fail\");\n+                        // If the pointer is out-of-bounds, it may be null.\n+                        // Note that one-past-the-end (offset == size) is still inbounds, and never null.\n+                        offset > size\n+                    }\n+                    Err(_offset) => bug!(\"a non-int scalar is always a pointer\"),\n+                }\n+            }\n+        }\n+    }\n+\n     /// Turning a \"maybe pointer\" into a proper pointer (and some information\n     /// about where it points), or an absolute address.\n-    pub fn ptr_try_get_alloc(\n+    pub fn ptr_try_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> Result<(AllocId, Size, Pointer<M::PointerTag>), u64> {\n@@ -1146,11 +1157,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n \n     /// Turning a \"maybe pointer\" into a proper pointer (and some information about where it points).\n     #[inline(always)]\n-    pub fn ptr_get_alloc(\n+    pub fn ptr_get_alloc_id(\n         &self,\n         ptr: Pointer<Option<M::PointerTag>>,\n     ) -> InterpResult<'tcx, (AllocId, Size, Pointer<M::PointerTag>)> {\n-        self.ptr_try_get_alloc(ptr).map_err(|offset| {\n+        self.ptr_try_get_alloc_id(ptr).map_err(|offset| {\n             err_ub!(DanglingIntPointer(offset, CheckInAllocMsg::InboundsTest)).into()\n         })\n     }"}, {"sha": "3012f763b80c0c2e4f657fd8c7f18006f73ab4c5", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -257,7 +257,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(None);\n         }\n \n-        let Some(alloc) = self.get_alloc(mplace)? else {\n+        let Some(alloc) = self.get_place_alloc(mplace)? else {\n             return Ok(Some(ImmTy {\n                 // zero-sized type\n                 imm: Scalar::ZST.into(),\n@@ -340,7 +340,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     // Turn the wide MPlace into a string (must already be dereferenced!)\n     pub fn read_str(&self, mplace: &MPlaceTy<'tcx, M::PointerTag>) -> InterpResult<'tcx, &str> {\n         let len = mplace.len(self)?;\n-        let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len))?;\n+        let bytes = self.read_bytes_ptr(mplace.ptr, Size::from_bytes(len))?;\n         let str = std::str::from_utf8(bytes).map_err(|err| err_ub!(InvalidStr(err)))?;\n         Ok(str)\n     }"}, {"sha": "c37973bd1663c7a914db08aa29adf9155af4ff99", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -306,25 +306,25 @@ where\n     }\n \n     #[inline]\n-    pub(super) fn get_alloc(\n+    pub(super) fn get_place_alloc(\n         &self,\n         place: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<AllocRef<'_, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         assert!(!place.layout.is_unsized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n-        self.memory.get(place.ptr, size, place.align)\n+        self.get_ptr_alloc(place.ptr, size, place.align)\n     }\n \n     #[inline]\n-    pub(super) fn get_alloc_mut(\n+    pub(super) fn get_place_alloc_mut(\n         &mut self,\n         place: &MPlaceTy<'tcx, M::PointerTag>,\n     ) -> InterpResult<'tcx, Option<AllocRefMut<'_, 'tcx, M::PointerTag, M::AllocExtra>>> {\n         assert!(!place.layout.is_unsized());\n         assert!(!place.meta.has_meta());\n         let size = place.layout.size;\n-        self.memory.get_mut(place.ptr, size, place.align)\n+        self.get_ptr_alloc_mut(place.ptr, size, place.align)\n     }\n \n     /// Check if this mplace is dereferenceable and sufficiently aligned.\n@@ -337,8 +337,8 @@ where\n             .size_and_align_of_mplace(&mplace)?\n             .unwrap_or((mplace.layout.size, mplace.layout.align.abi));\n         assert!(mplace.mplace.align <= align, \"dynamic alignment less strict than static one?\");\n-        let align = M::enforce_alignment(&self.memory.extra).then_some(align);\n-        self.memory.check_ptr_access_align(mplace.ptr, size, align.unwrap_or(Align::ONE), msg)?;\n+        let align = M::enforce_alignment(self).then_some(align);\n+        self.check_ptr_access_align(mplace.ptr, size, align.unwrap_or(Align::ONE), msg)?;\n         Ok(())\n     }\n \n@@ -748,7 +748,7 @@ where\n \n         // Invalid places are a thing: the return place of a diverging function\n         let tcx = *self.tcx;\n-        let Some(mut alloc) = self.get_alloc_mut(dest)? else {\n+        let Some(mut alloc) = self.get_place_alloc_mut(dest)? else {\n             // zero-sized access\n             return Ok(());\n         };\n@@ -857,8 +857,7 @@ where\n         });\n         assert_eq!(src.meta, dest.meta, \"Can only copy between equally-sized instances\");\n \n-        self.memory\n-            .copy(src.ptr, src.align, dest.ptr, dest.align, size, /*nonoverlapping*/ true)\n+        self.mem_copy(src.ptr, src.align, dest.ptr, dest.align, size, /*nonoverlapping*/ true)\n     }\n \n     /// Copies the data from an operand to a place. The layouts may disagree, but they must\n@@ -942,7 +941,7 @@ where\n                         let (size, align) = self\n                             .size_and_align_of(&meta, &local_layout)?\n                             .expect(\"Cannot allocate for non-dyn-sized type\");\n-                        let ptr = self.memory.allocate(size, align, MemoryKind::Stack)?;\n+                        let ptr = self.allocate_ptr(size, align, MemoryKind::Stack)?;\n                         let mplace = MemPlace { ptr: ptr.into(), align, meta };\n                         if let LocalValue::Live(Operand::Immediate(value)) = local_val {\n                             // Preserve old value.\n@@ -979,7 +978,7 @@ where\n         layout: TyAndLayout<'tcx>,\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'static, MPlaceTy<'tcx, M::PointerTag>> {\n-        let ptr = self.memory.allocate(layout.size, layout.align.abi, kind)?;\n+        let ptr = self.allocate_ptr(layout.size, layout.align.abi, kind)?;\n         Ok(MPlaceTy::from_aligned_ptr(ptr.into(), layout))\n     }\n \n@@ -990,7 +989,7 @@ where\n         kind: MemoryKind<M::MemoryKind>,\n         mutbl: Mutability,\n     ) -> MPlaceTy<'tcx, M::PointerTag> {\n-        let ptr = self.memory.allocate_bytes(str.as_bytes(), Align::ONE, kind, mutbl);\n+        let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl);\n         let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace =\n             MemPlace { ptr: ptr.into(), align: Align::ONE, meta: MemPlaceMeta::Meta(meta) };"}, {"sha": "84563daa0880d64446739a509a16f9d86a81155e", "filename": "compiler/rustc_const_eval/src/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fstep.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -225,7 +225,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 if length == 0 {\n                     // Nothing to copy... but let's still make sure that `dest` as a place is valid.\n-                    self.get_alloc_mut(&dest)?;\n+                    self.get_place_alloc_mut(&dest)?;\n                 } else {\n                     // Write the src to the first element.\n                     let first = self.mplace_field(&dest, 0)?;\n@@ -241,7 +241,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // that place might be more aligned than its type mandates (a `u8` array could\n                     // be 4-aligned if it sits at the right spot in a struct). Instead we use\n                     // `first.layout.align`, i.e., the alignment given by the type.\n-                    self.memory.copy_repeatedly(\n+                    self.mem_copy_repeatedly(\n                         first_ptr,\n                         first.align,\n                         rest_ptr,"}, {"sha": "a7587652114bf92a520212ae1e18364a5d1f61d2", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -72,7 +72,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let (fn_val, fn_abi, with_caller_location) = match *func.layout.ty.kind() {\n                     ty::FnPtr(_sig) => {\n                         let fn_ptr = self.read_pointer(&func)?;\n-                        let fn_val = self.memory.get_fn(fn_ptr)?;\n+                        let fn_val = self.get_ptr_fn(fn_ptr)?;\n                         (fn_val, self.fn_abi_of_fn_ptr(fn_sig_binder, extra_args)?, false)\n                     }\n                     ty::FnDef(def_id, substs) => {"}, {"sha": "5cf3807faaa6d10922e721cfe5c8509ca4be7792", "filename": "compiler/rustc_const_eval/src/interpret/traits.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Ftraits.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -32,7 +32,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let vtable_allocation = self.tcx.vtable_allocation((ty, poly_trait_ref));\n \n-        let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_allocation))?;\n+        let vtable_ptr = self.global_base_pointer(Pointer::from(vtable_allocation))?;\n \n         Ok(vtable_ptr.into())\n     }\n@@ -48,11 +48,10 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let ptr_size = self.pointer_size();\n         let vtable_slot = vtable.offset(ptr_size * idx, self)?;\n         let vtable_slot = self\n-            .memory\n-            .get(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n+            .get_ptr_alloc(vtable_slot, ptr_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n         let fn_ptr = self.scalar_to_ptr(vtable_slot.read_ptr_sized(Size::ZERO)?.check_init()?);\n-        self.memory.get_fn(fn_ptr)\n+        self.get_ptr_fn(fn_ptr)\n     }\n \n     /// Returns the drop fn instance as well as the actual dynamic type.\n@@ -63,8 +62,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let pointer_size = self.pointer_size();\n         // We don't care about the pointee type; we just want a pointer.\n         let vtable = self\n-            .memory\n-            .get(\n+            .get_ptr_alloc(\n                 vtable,\n                 pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),\n                 self.tcx.data_layout.pointer_align.abi,\n@@ -77,7 +75,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .check_init()?;\n         // We *need* an instance here, no other kind of function value, to be able\n         // to determine the type.\n-        let drop_instance = self.memory.get_fn(self.scalar_to_ptr(drop_fn))?.as_instance()?;\n+        let drop_instance = self.get_ptr_fn(self.scalar_to_ptr(drop_fn))?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx, self.param_env).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, fn_sig);\n@@ -99,8 +97,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // We check for `size = 3 * ptr_size`, which covers the drop fn (unused here),\n         // the size, and the align (which we read below).\n         let vtable = self\n-            .memory\n-            .get(\n+            .get_ptr_alloc(\n                 vtable,\n                 pointer_size * u64::try_from(COMMON_VTABLE_ENTRIES.len()).unwrap(),\n                 self.tcx.data_layout.pointer_align.abi,\n@@ -132,8 +129,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         let vtable_slot = vtable.offset(pointer_size * idx, self)?;\n         let new_vtable = self\n-            .memory\n-            .get(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n+            .get_ptr_alloc(vtable_slot, pointer_size, self.tcx.data_layout.pointer_align.abi)?\n             .expect(\"cannot be a ZST\");\n \n         let new_vtable = self.scalar_to_ptr(new_vtable.read_ptr_sized(Size::ZERO)?.check_init()?);"}, {"sha": "42ff7b1945918280878019cc1133c30e5ee5a360", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -315,7 +315,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta());\n                 // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n                 try_validation!(\n-                    self.ecx.memory.check_ptr_access_align(\n+                    self.ecx.check_ptr_access_align(\n                         vtable,\n                         3 * self.ecx.tcx.data_layout.pointer_size, // drop, size, align\n                         self.ecx.tcx.data_layout.pointer_align.abi,\n@@ -403,7 +403,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n             .unwrap_or_else(|| (place.layout.size, place.layout.align.abi));\n         // Direct call to `check_ptr_access_align` checks alignment even on CTFE machines.\n         try_validation!(\n-            self.ecx.memory.check_ptr_access_align(\n+            self.ecx.check_ptr_access_align(\n                 place.ptr,\n                 size,\n                 align,\n@@ -432,7 +432,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         if let Some(ref mut ref_tracking) = self.ref_tracking {\n             // Proceed recursively even for ZST, no reason to skip them!\n             // `!` is a ZST and we want to validate it.\n-            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.memory.ptr_try_get_alloc(place.ptr) {\n+            if let Ok((alloc_id, _offset, _ptr)) = self.ecx.ptr_try_get_alloc_id(place.ptr) {\n                 // Special handling for pointers to statics (irrespective of their type).\n                 let alloc_kind = self.ecx.tcx.get_global_alloc(alloc_id);\n                 if let Some(GlobalAlloc::Static(did)) = alloc_kind {\n@@ -579,7 +579,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                 if let Some(_) = self.ref_tracking {\n                     let ptr = self.ecx.scalar_to_ptr(value);\n                     let _fn = try_validation!(\n-                        self.ecx.memory.get_fn(ptr),\n+                        self.ecx.get_ptr_fn(ptr),\n                         self.path,\n                         err_ub!(DanglingIntPointer(0, _)) =>\n                             { \"a null function pointer\" },\n@@ -825,7 +825,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 let mplace = op.assert_mem_place(); // strings are never immediate\n                 let len = mplace.len(self.ecx)?;\n                 try_validation!(\n-                    self.ecx.memory.read_bytes(mplace.ptr, Size::from_bytes(len)),\n+                    self.ecx.read_bytes_ptr(mplace.ptr, Size::from_bytes(len)),\n                     self.path,\n                     err_ub!(InvalidUninitBytes(..)) => { \"uninitialized data in `str`\" },\n                     err_unsup!(ReadPointerAsBytes) => { \"a pointer in `str`\" },\n@@ -861,7 +861,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 // to reject those pointers, we just do not have the machinery to\n                 // talk about parts of a pointer.\n                 // We also accept uninit, for consistency with the slow path.\n-                let Some(alloc) = self.ecx.memory.get(mplace.ptr, size, mplace.align)? else {\n+                let Some(alloc) = self.ecx.get_ptr_alloc(mplace.ptr, size, mplace.align)? else {\n                     // Size 0, nothing more to check.\n                     return Ok(());\n                 };"}, {"sha": "49ebdd302545aa184d279b313138852af2648547", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -184,8 +184,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n \n     type MemoryKind = !;\n \n-    type MemoryExtra = ();\n-\n     fn load_mir(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::InstanceDef<'tcx>,\n@@ -267,7 +265,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     }\n \n     fn before_access_global(\n-        _memory_extra: &(),\n+        _machine: &Self,\n         _alloc_id: AllocId,\n         alloc: ConstAllocation<'tcx, Self::PointerTag, Self::AllocExtra>,\n         _static_def_id: Option<DefId>,\n@@ -377,7 +375,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             span,\n             param_env,\n             ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n-            (),\n         );\n \n         let ret = ecx"}, {"sha": "602aa14b9e6c66db0a6cb0a44858cedfa0ea6ab4", "filename": "compiler/rustc_mir_transform/src/const_prop_lint.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/78f81f0d10484f244b99361db359ba8a6a17e79b/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop_lint.rs?ref=78f81f0d10484f244b99361db359ba8a6a17e79b", "patch": "@@ -180,8 +180,6 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n \n     type MemoryKind = !;\n \n-    type MemoryExtra = ();\n-\n     fn load_mir(\n         _ecx: &InterpCx<'mir, 'tcx, Self>,\n         _instance: ty::InstanceDef<'tcx>,\n@@ -263,7 +261,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for ConstPropMachine<'mir, 'tcx>\n     }\n \n     fn before_access_global(\n-        _memory_extra: &(),\n+        _machine: &Self,\n         _alloc_id: AllocId,\n         alloc: ConstAllocation<'tcx, Self::PointerTag, Self::AllocExtra>,\n         _static_def_id: Option<DefId>,\n@@ -374,7 +372,6 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             span,\n             param_env,\n             ConstPropMachine::new(only_propagate_inside_block_locals, can_const_prop),\n-            (),\n         );\n \n         let ret = ecx"}]}