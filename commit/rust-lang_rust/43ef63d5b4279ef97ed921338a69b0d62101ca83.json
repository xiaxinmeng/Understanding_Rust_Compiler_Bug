{"sha": "43ef63d5b4279ef97ed921338a69b0d62101ca83", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQzZWY2M2Q1YjQyNzllZjk3ZWQ5MjEzMzhhNjliMGQ2MjEwMWNhODM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-13T11:47:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-04-13T11:47:33Z"}, "message": "Auto merge of #40367 - eddyb:naked-cruft, r=nagisa\n\nImprove the LLVM IR we generate for trivial functions, especially #[naked] ones.\n\nThese two small changes fix edef1c/libfringe#68:\n* Don't emit ZST allocas, such as when returning `()`\n* Don't emit a branch from LLVM's entry block to MIR's `START_BLOCK` unless needed\n  * That is, if a loop branches back to it, although I'm not sure that's even valid MIR", "tree": {"sha": "7b09bb241ed5c8d7a95d6d7a5800cff62b5cfec8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7b09bb241ed5c8d7a95d6d7a5800cff62b5cfec8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/43ef63d5b4279ef97ed921338a69b0d62101ca83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/43ef63d5b4279ef97ed921338a69b0d62101ca83", "html_url": "https://github.com/rust-lang/rust/commit/43ef63d5b4279ef97ed921338a69b0d62101ca83", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/43ef63d5b4279ef97ed921338a69b0d62101ca83/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f59c7ebb170b1ca98bc1d620afb02f7b3ae3fa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f59c7ebb170b1ca98bc1d620afb02f7b3ae3fa7", "html_url": "https://github.com/rust-lang/rust/commit/1f59c7ebb170b1ca98bc1d620afb02f7b3ae3fa7"}, {"sha": "9b5c577dbd45ff3b11f9d7aab6990cc1ee9194fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b5c577dbd45ff3b11f9d7aab6990cc1ee9194fb", "html_url": "https://github.com/rust-lang/rust/commit/9b5c577dbd45ff3b11f9d7aab6990cc1ee9194fb"}], "stats": {"total": 157, "additions": 98, "deletions": 59}, "files": [{"sha": "2d1c95114ebd6f46cd8ec92559446793b0f21476", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=43ef63d5b4279ef97ed921338a69b0d62101ca83", "patch": "@@ -784,7 +784,8 @@ pub fn compile_unit_metadata(scc: &SharedCrateContext,\n     };\n \n     debug!(\"compile_unit_metadata: {:?}\", compile_unit_name);\n-    let producer = format!(\"rustc version {}\",\n+    // FIXME(#41252) Remove \"clang LLVM\" if we can get GDB and LLVM to play nice.\n+    let producer = format!(\"clang LLVM (rustc version {})\",\n                            (option_env!(\"CFG_VERSION\")).expect(\"CFG_VERSION\"));\n \n     let compile_unit_name = compile_unit_name.as_ptr();"}, {"sha": "889f9dc4cded5880f85a9c2171a7b24e708d350c", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=43ef63d5b4279ef97ed921338a69b0d62101ca83", "patch": "@@ -19,7 +19,6 @@ use rustc::mir::visit::{Visitor, LvalueContext};\n use rustc::mir::traversal;\n use common;\n use super::MirContext;\n-use super::rvalue;\n \n pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n     let mir = mircx.mir;\n@@ -93,7 +92,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n \n         if let mir::Lvalue::Local(index) = *lvalue {\n             self.mark_assigned(index);\n-            if !rvalue::rvalue_creates_operand(rvalue) {\n+            if !self.cx.rvalue_creates_operand(rvalue) {\n                 self.mark_as_lvalue(index);\n             }\n         } else {"}, {"sha": "3d8c5085462a8c55150feca10016cb3db3dccfe2", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=43ef63d5b4279ef97ed921338a69b0d62101ca83", "patch": "@@ -11,17 +11,16 @@\n use libc::c_uint;\n use llvm::{self, ValueRef, BasicBlockRef};\n use llvm::debuginfo::DIScope;\n-use rustc::ty;\n+use rustc::ty::{self, Ty, TypeFoldable};\n use rustc::ty::layout::{self, LayoutTyper};\n use rustc::mir::{self, Mir};\n use rustc::mir::tcx::LvalueTy;\n use rustc::ty::subst::Substs;\n use rustc::infer::TransNormalize;\n-use rustc::ty::TypeFoldable;\n use session::config::FullDebugInfo;\n use base;\n use builder::Builder;\n-use common::{self, CrateContext, C_null, Funclet};\n+use common::{self, CrateContext, Funclet};\n use debuginfo::{self, declare_local, VariableAccess, VariableKind, FunctionDebugContext};\n use monomorphize::{self, Instance};\n use abi::FnType;\n@@ -171,23 +170,12 @@ enum LocalRef<'tcx> {\n \n impl<'tcx> LocalRef<'tcx> {\n     fn new_operand<'a>(ccx: &CrateContext<'a, 'tcx>,\n-                         ty: ty::Ty<'tcx>) -> LocalRef<'tcx> {\n+                       ty: Ty<'tcx>) -> LocalRef<'tcx> {\n         if common::type_is_zero_size(ccx, ty) {\n             // Zero-size temporaries aren't always initialized, which\n             // doesn't matter because they don't contain data, but\n             // we need something in the operand.\n-            let llty = type_of::type_of(ccx, ty);\n-            let val = if common::type_is_imm_pair(ccx, ty) {\n-                let fields = llty.field_types();\n-                OperandValue::Pair(C_null(fields[0]), C_null(fields[1]))\n-            } else {\n-                OperandValue::Immediate(C_null(llty))\n-            };\n-            let op = OperandRef {\n-                val: val,\n-                ty: ty\n-            };\n-            LocalRef::Operand(Some(op))\n+            LocalRef::Operand(Some(OperandRef::new_zst(ccx, ty)))\n         } else {\n             LocalRef::Operand(None)\n         }\n@@ -207,15 +195,17 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n         debuginfo::create_function_debug_context(ccx, instance, sig, llfn, mir);\n-    let bcx = Builder::new_block(ccx, llfn, \"entry-block\");\n+    let bcx = Builder::new_block(ccx, llfn, \"start\");\n \n     let cleanup_kinds = analyze::cleanup_kinds(&mir);\n \n-    // Allocate a `Block` for every basic block\n+    // Allocate a `Block` for every basic block, except\n+    // the start block, if nothing loops back to it.\n+    let reentrant_start_block = !mir.predecessors_for(mir::START_BLOCK).is_empty();\n     let block_bcxs: IndexVec<mir::BasicBlock, BasicBlockRef> =\n         mir.basic_blocks().indices().map(|bb| {\n-            if bb == mir::START_BLOCK {\n-                bcx.build_sibling_block(\"start\").llbb()\n+            if bb == mir::START_BLOCK && !reentrant_start_block {\n+                bcx.llbb()\n             } else {\n                 bcx.build_sibling_block(&format!(\"{:?}\", bb)).llbb()\n             }\n@@ -301,9 +291,10 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n             .collect()\n     };\n \n-    // Branch to the START block\n-    let start_bcx = mircx.blocks[mir::START_BLOCK];\n-    bcx.br(start_bcx);\n+    // Branch to the START block, if it's not the entry block.\n+    if reentrant_start_block {\n+        bcx.br(mircx.blocks[mir::START_BLOCK]);\n+    }\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location"}, {"sha": "c31142323c85f56f8514978e701f82d548b85ee6", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=43ef63d5b4279ef97ed921338a69b0d62101ca83", "patch": "@@ -16,7 +16,7 @@ use rustc::mir::tcx::LvalueTy;\n use rustc_data_structures::indexed_vec::Idx;\n \n use base;\n-use common;\n+use common::{self, CrateContext, C_null};\n use builder::Builder;\n use value::Value;\n use type_of;\n@@ -79,6 +79,22 @@ impl<'tcx> fmt::Debug for OperandRef<'tcx> {\n }\n \n impl<'a, 'tcx> OperandRef<'tcx> {\n+    pub fn new_zst(ccx: &CrateContext<'a, 'tcx>,\n+                   ty: Ty<'tcx>) -> OperandRef<'tcx> {\n+        assert!(common::type_is_zero_size(ccx, ty));\n+        let llty = type_of::type_of(ccx, ty);\n+        let val = if common::type_is_imm_pair(ccx, ty) {\n+            let fields = llty.field_types();\n+            OperandValue::Pair(C_null(fields[0]), C_null(fields[1]))\n+        } else {\n+            OperandValue::Immediate(C_null(llty))\n+        };\n+        OperandRef {\n+            val: val,\n+            ty: ty\n+        }\n+    }\n+\n     /// Asserts that this operand refers to a scalar and returns\n     /// a reference to its value.\n     pub fn immediate(self) -> ValueRef {"}, {"sha": "aa41720d717a7268a979ccd7c8b3a955e6eae572", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=43ef63d5b4279ef97ed921338a69b0d62101ca83", "patch": "@@ -158,7 +158,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n \n             _ => {\n-                assert!(rvalue_creates_operand(rvalue));\n+                assert!(self.rvalue_creates_operand(rvalue));\n                 let (bcx, temp) = self.trans_rvalue_operand(bcx, rvalue);\n                 self.store_operand(&bcx, dest.llval, dest.alignment.to_align(), temp);\n                 bcx\n@@ -171,7 +171,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                                 rvalue: &mir::Rvalue<'tcx>)\n                                 -> (Builder<'a, 'tcx>, OperandRef<'tcx>)\n     {\n-        assert!(rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n+        assert!(self.rvalue_creates_operand(rvalue), \"cannot trans {:?} to operand\", rvalue);\n \n         match *rvalue {\n             mir::Rvalue::Cast(ref kind, ref source, cast_ty) => {\n@@ -466,8 +466,10 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             }\n             mir::Rvalue::Repeat(..) |\n             mir::Rvalue::Aggregate(..) => {\n-                bug!(\"cannot generate operand from rvalue {:?}\", rvalue);\n-\n+                // According to `rvalue_creates_operand`, only ZST\n+                // aggregate rvalues are allowed to be operands.\n+                let ty = rvalue.ty(self.mir, self.ccx.tcx());\n+                (bcx, OperandRef::new_zst(self.ccx, self.monomorphize(&ty)))\n             }\n         }\n     }\n@@ -650,26 +652,29 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n         OperandValue::Pair(val, of)\n     }\n-}\n \n-pub fn rvalue_creates_operand(rvalue: &mir::Rvalue) -> bool {\n-    match *rvalue {\n-        mir::Rvalue::Ref(..) |\n-        mir::Rvalue::Len(..) |\n-        mir::Rvalue::Cast(..) | // (*)\n-        mir::Rvalue::BinaryOp(..) |\n-        mir::Rvalue::CheckedBinaryOp(..) |\n-        mir::Rvalue::UnaryOp(..) |\n-        mir::Rvalue::Discriminant(..) |\n-        mir::Rvalue::Box(..) |\n-        mir::Rvalue::Use(..) => // (*)\n-            true,\n-        mir::Rvalue::Repeat(..) |\n-        mir::Rvalue::Aggregate(..) =>\n-            false,\n-    }\n+    pub fn rvalue_creates_operand(&self, rvalue: &mir::Rvalue<'tcx>) -> bool {\n+        match *rvalue {\n+            mir::Rvalue::Ref(..) |\n+            mir::Rvalue::Len(..) |\n+            mir::Rvalue::Cast(..) | // (*)\n+            mir::Rvalue::BinaryOp(..) |\n+            mir::Rvalue::CheckedBinaryOp(..) |\n+            mir::Rvalue::UnaryOp(..) |\n+            mir::Rvalue::Discriminant(..) |\n+            mir::Rvalue::Box(..) |\n+            mir::Rvalue::Use(..) => // (*)\n+                true,\n+            mir::Rvalue::Repeat(..) |\n+            mir::Rvalue::Aggregate(..) => {\n+                let ty = rvalue.ty(self.mir, self.ccx.tcx());\n+                let ty = self.monomorphize(&ty);\n+                common::type_is_zero_size(self.ccx, ty)\n+            }\n+        }\n \n-    // (*) this is only true if the type is suitable\n+        // (*) this is only true if the type is suitable\n+    }\n }\n \n #[derive(Copy, Clone)]"}, {"sha": "9883ca6b35d0497b297afff0da37e0f73582dd10", "filename": "src/test/codegen/naked-functions.rs", "status": "modified", "additions": 37, "deletions": 10, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/43ef63d5b4279ef97ed921338a69b0d62101ca83/src%2Ftest%2Fcodegen%2Fnaked-functions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fnaked-functions.rs?ref=43ef63d5b4279ef97ed921338a69b0d62101ca83", "patch": "@@ -20,25 +20,28 @@\n #[no_mangle]\n #[naked]\n fn naked_empty() {\n-    // CHECK: ret void\n+    // CHECK-NEXT: {{.+}}:\n+    // CHECK-NEXT: ret void\n }\n \n // CHECK: Function Attrs: naked uwtable\n #[no_mangle]\n #[naked]\n // CHECK-NEXT: define internal void @naked_with_args(i{{[0-9]+}})\n fn naked_with_args(a: isize) {\n-    // CHECK: %a = alloca i{{[0-9]+}}\n-    // CHECK: ret void\n+    // CHECK-NEXT: {{.+}}:\n+    // CHECK-NEXT: %a = alloca i{{[0-9]+}}\n     &a; // keep variable in an alloca\n+    // CHECK: ret void\n }\n \n // CHECK: Function Attrs: naked uwtable\n // CHECK-NEXT: define internal i{{[0-9]+}} @naked_with_return()\n #[no_mangle]\n #[naked]\n fn naked_with_return() -> isize {\n-    // CHECK: ret i{{[0-9]+}} 0\n+    // CHECK-NEXT: {{.+}}:\n+    // CHECK-NEXT: ret i{{[0-9]+}} 0\n     0\n }\n \n@@ -47,9 +50,10 @@ fn naked_with_return() -> isize {\n #[no_mangle]\n #[naked]\n fn naked_with_args_and_return(a: isize) -> isize {\n-    // CHECK: %a = alloca i{{[0-9]+}}\n-    // CHECK: ret i{{[0-9]+}} %{{[0-9]+}}\n+    // CHECK-NEXT: {{.+}}:\n+    // CHECK-NEXT: %a = alloca i{{[0-9]+}}\n     &a; // keep variable in an alloca\n+    // CHECK: ret i{{[0-9]+}} %{{[0-9]+}}\n     a\n }\n \n@@ -58,14 +62,37 @@ fn naked_with_args_and_return(a: isize) -> isize {\n #[no_mangle]\n #[naked]\n fn naked_recursive() {\n-    // CHECK: call void @naked_empty()\n+    // CHECK-NEXT: {{.+}}:\n+    // CHECK-NEXT: call void @naked_empty()\n+\n+    // FIXME(#39685) Avoid one block per call.\n+    // CHECK-NEXT: br label %bb1\n+    // CHECK: bb1:\n+\n     naked_empty();\n-    // CHECK: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_return()\n+\n+    // CHECK-NEXT: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_return()\n+\n+    // FIXME(#39685) Avoid one block per call.\n+    // CHECK-NEXT: br label %bb2\n+    // CHECK: bb2:\n+\n+    // CHECK-NEXT: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_args_and_return(i{{[0-9]+}} %{{[0-9]+}})\n+\n+    // FIXME(#39685) Avoid one block per call.\n+    // CHECK-NEXT: br label %bb3\n+    // CHECK: bb3:\n+\n+    // CHECK-NEXT: call void @naked_with_args(i{{[0-9]+}} %{{[0-9]+}})\n+\n+    // FIXME(#39685) Avoid one block per call.\n+    // CHECK-NEXT: br label %bb4\n+    // CHECK: bb4:\n+\n     naked_with_args(\n-        // CHECK: %{{[0-9]+}} = call i{{[0-9]+}} @naked_with_args_and_return(i{{[0-9]+}} %{{[0-9]+}})\n         naked_with_args_and_return(\n-            // CHECK: call void @naked_with_args(i{{[0-9]+}} %{{[0-9]+}})\n             naked_with_return()\n         )\n     );\n+    // CHECK-NEXT: ret void\n }"}]}