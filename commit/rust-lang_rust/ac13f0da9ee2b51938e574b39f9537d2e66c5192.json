{"sha": "ac13f0da9ee2b51938e574b39f9537d2e66c5192", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjMTNmMGRhOWVlMmI1MTkzOGU1NzRiMzlmOTUzN2QyZTY2YzUxOTI=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-24T02:48:08Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-12-24T02:48:08Z"}, "message": "Add support to libcore for encoded-in-rust unicode character properties, at least. Add script to compute them from unicode.org.", "tree": {"sha": "b3691b6ef2717c4f2438b78fc04c2424210e330b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b3691b6ef2717c4f2438b78fc04c2424210e330b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac13f0da9ee2b51938e574b39f9537d2e66c5192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac13f0da9ee2b51938e574b39f9537d2e66c5192", "html_url": "https://github.com/rust-lang/rust/commit/ac13f0da9ee2b51938e574b39f9537d2e66c5192", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac13f0da9ee2b51938e574b39f9537d2e66c5192/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88d74993d8609af50ad7b78d6ada17c9593e7c3b", "url": "https://api.github.com/repos/rust-lang/rust/commits/88d74993d8609af50ad7b78d6ada17c9593e7c3b", "html_url": "https://github.com/rust-lang/rust/commit/88d74993d8609af50ad7b78d6ada17c9593e7c3b"}], "stats": {"total": 5001, "additions": 4919, "deletions": 82}, "files": [{"sha": "f52335a9cabae7e32246fcb4f67cd0727ecfa3df", "filename": "src/etc/unicode.py", "status": "added", "additions": 172, "deletions": 0, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/ac13f0da9ee2b51938e574b39f9537d2e66c5192/src%2Fetc%2Funicode.py", "raw_url": "https://github.com/rust-lang/rust/raw/ac13f0da9ee2b51938e574b39f9537d2e66c5192/src%2Fetc%2Funicode.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Funicode.py?ref=ac13f0da9ee2b51938e574b39f9537d2e66c5192", "patch": "@@ -0,0 +1,172 @@\n+#!/usr/bin/env python\n+\n+# This digests UnicodeData.txt and DerivedCoreProperties.txt and emits rust\n+# code covering the core properties. Since this is a pretty rare event we\n+# just store this out-of-line and check the unicode.rs file into git.\n+#\n+# The emitted code is \"the minimum we think is necessary for libcore\", that\n+# is, to support basic operations of the compiler and \"most nontrivial rust\n+# programs\". It is not meant to be a complete implementation of unicode.\n+# For that we recommend you use a proper binding to libicu.\n+\n+import fileinput, re, os, sys\n+\n+\n+def fetch(f):\n+    if not os.path.exists(f):\n+        os.system(\"curl -O http://www.unicode.org/Public/UNIDATA/%s\"\n+                  % f)\n+\n+    if not os.path.exists(f):\n+        sys.stderr.write(\"cannot load %s\" % f)\n+        exit(1)\n+\n+\n+def load_general_categories(f):\n+    fetch(f)\n+    gencats = {}\n+    curr_cat = \"\"\n+    c_lo = 0\n+    c_hi = 0\n+    for line in fileinput.input(f):\n+        fields = line.split(\";\")\n+        if len(fields) != 15:\n+            continue\n+        [code, name, gencat, combine, bidi,\n+         decomp, deci, digit, num, mirror,\n+         old, iso, upcase, lowcsae, titlecase ] = fields\n+\n+        code = int(code, 16)\n+\n+        if curr_cat == \"\":\n+            curr_cat = gencat\n+            c_lo = code\n+            c_hi = code\n+\n+        if curr_cat == gencat:\n+            c_hi = code\n+        else:\n+            if curr_cat not in gencats:\n+                gencats[curr_cat] = []\n+\n+            gencats[curr_cat].append((c_lo, c_hi))\n+            curr_cat = gencat\n+            c_lo = code\n+            c_hi = code\n+    return gencats\n+\n+\n+def load_derived_core_properties(f):\n+    fetch(f)\n+    derivedprops = {}\n+    interestingprops = [\"XID_Start\", \"XID_Continue\", \"Alphabetic\"]\n+    re1 = re.compile(\"^([0-9A-F]+) +; (\\w+)\")\n+    re2 = re.compile(\"^([0-9A-F]+)\\.\\.([0-9A-F]+) +; (\\w+)\")\n+\n+    for line in fileinput.input(f):\n+        prop = None\n+        d_lo = 0\n+        d_hi = 0\n+        m = re1.match(line)\n+        if m:\n+            d_lo = m.group(1)\n+            d_hi = m.group(1)\n+            prop = m.group(2)\n+        else:\n+            m = re2.match(line)\n+            if m:\n+                d_lo = m.group(1)\n+                d_hi = m.group(2)\n+                prop = m.group(3)\n+            else:\n+                continue\n+        if prop not in interestingprops:\n+            continue\n+        d_lo = int(d_lo, 16)\n+        d_hi = int(d_hi, 16)\n+        if prop not in derivedprops:\n+            derivedprops[prop] = []\n+        derivedprops[prop].append((d_lo, d_hi))\n+    return derivedprops\n+\n+def escape_char(c):\n+    if c <= 0xff:\n+        return \"'\\\\x%2.2x'\" % c\n+    if c <= 0xffff:\n+        return \"'\\\\u%4.4x'\" % c\n+    return \"'\\\\U%8.8x'\" % c\n+\n+def emit_rust_module(f, mod, tbl):\n+    f.write(\"mod %s {\\n\" % mod)\n+    keys = tbl.keys()\n+    keys.sort()\n+    for cat in keys:\n+        f.write(\"    pure fn %s(c: char) -> bool {\\n\" % cat)\n+        f.write(\"        ret alt c {\\n\")\n+        prefix = ' '\n+        for pair in tbl[cat]:\n+            if pair[0] == pair[1]:\n+                f.write(\"            %c %s\\n\" %\n+                        (prefix, escape_char(pair[0])))\n+            else:\n+                f.write(\"            %c %s to %s\\n\" %\n+                        (prefix,\n+                         escape_char(pair[0]),\n+                         escape_char(pair[1])))\n+            prefix = '|'\n+        f.write(\"              { true }\\n\")\n+        f.write(\"            _ { false }\\n\")\n+        f.write(\"        };\\n\")\n+        f.write(\"    }\\n\\n\")\n+    f.write(\"}\\n\")\n+\n+\n+def emit_cpp_module(f, mod, tbl):\n+    keys = tbl.keys()\n+    keys.sort()\n+\n+    for cat in keys:\n+\n+        singles = []\n+        ranges = []\n+\n+        for pair in tbl[cat]:\n+            if pair[0] == pair[1]:\n+                singles.append(pair[0])\n+            else:\n+                ranges.append(pair)\n+\n+        f.write(\"bool %s_%s(unsigned c) {\\n\" % (mod, cat))\n+        for pair in ranges:\n+            f.write(\"    if (0x%x <= c && c <= 0x%x) { return true; }\\n\"\n+                    % pair)\n+        if len(singles) > 0:\n+            f.write(\"    switch (c) {\\n\");\n+            for single in singles:\n+                f.write(\"      case 0x%x:\\n\" % single)\n+            f.write(\"        return true;\\n\");\n+            f.write(\"      default:\\n\");\n+            f.write(\"        return false;\\n\");\n+            f.write(\"    }\\n\")\n+        f.write(\"return false;\\n\")\n+        f.write(\"}\\n\\n\")\n+\n+\n+def emit_module(rf, cf, mod, tbl):\n+    emit_rust_module(rf, mod, tbl)\n+    emit_cpp_module(cf, mod, tbl)\n+\n+r = \"unicode.rs\"\n+c = \"unicode.cpp\"\n+for i in [r, c]:\n+    if os.path.exists(i):\n+        os.remove(i);\n+\n+rf = open(r, \"w\")\n+cf = open(c, \"w\")\n+\n+emit_module(rf, cf, \"general_category\",\n+            load_general_categories(\"UnicodeData.txt\"))\n+\n+emit_module(rf, cf, \"derived_property\",\n+            load_derived_core_properties(\"DerivedCoreProperties.txt\"))"}, {"sha": "7d8ac4ba33a6983907c1761ff7c8676bdb1d7bb4", "filename": "src/libcore/char.rs", "status": "modified", "additions": 61, "deletions": 82, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/ac13f0da9ee2b51938e574b39f9537d2e66c5192/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac13f0da9ee2b51938e574b39f9537d2e66c5192/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=ac13f0da9ee2b51938e574b39f9537d2e66c5192", "patch": "@@ -4,96 +4,75 @@ Module: char\n Utilities for manipulating the char type\n */\n \n+/*\n+    Lu  Uppercase_Letter    an uppercase letter\n+    Ll  Lowercase_Letter    a lowercase letter\n+    Lt  Titlecase_Letter    a digraphic character, with first part uppercase\n+    Lm  Modifier_Letter     a modifier letter\n+    Lo  Other_Letter    other letters, including syllables and ideographs\n+    Mn  Nonspacing_Mark     a nonspacing combining mark (zero advance width)\n+    Mc  Spacing_Mark    a spacing combining mark (positive advance width)\n+    Me  Enclosing_Mark  an enclosing combining mark\n+    Nd  Decimal_Number  a decimal digit\n+    Nl  Letter_Number   a letterlike numeric character\n+    No  Other_Number    a numeric character of other type\n+    Pc  Connector_Punctuation   a connecting punctuation mark, like a tie\n+    Pd  Dash_Punctuation    a dash or hyphen punctuation mark\n+    Ps  Open_Punctuation    an opening punctuation mark (of a pair)\n+    Pe  Close_Punctuation   a closing punctuation mark (of a pair)\n+    Pi  Initial_Punctuation     an initial quotation mark\n+    Pf  Final_Punctuation   a final quotation mark\n+    Po  Other_Punctuation   a punctuation mark of other type\n+    Sm  Math_Symbol     a symbol of primarily mathematical use\n+    Sc  Currency_Symbol     a currency sign\n+    Sk  Modifier_Symbol     a non-letterlike modifier symbol\n+    So  Other_Symbol    a symbol of other type\n+    Zs  Space_Separator     a space character (of various non-zero widths)\n+    Zl  Line_Separator  U+2028 LINE SEPARATOR only\n+    Zp  Paragraph_Separator     U+2029 PARAGRAPH SEPARATOR only\n+    Cc  Control     a C0 or C1 control code\n+    Cf  Format  a format control character\n+    Cs  Surrogate   a surrogate code point\n+    Co  Private_Use     a private-use character\n+    Cn  Unassigned  a reserved unassigned code point or a noncharacter\n+*/\n+\n+import is_alphabetic = unicode::derived_property::Alphabetic;\n+import is_XID_start = unicode::derived_property::XID_Start;\n+import is_XID_continue = unicode::derived_property::XID_Continue;\n+\n /*\n Function: is_whitespace\n \n-Indicates whether a character is whitespace.\n+Indicates whether a character is whitespace, defined in terms of\n+the Unicode General Categories 'Zs', 'Zl', 'Zp' and the additional\n+'Cc'-category control codes in the range [0x09, 0x0d].\n \n-Whitespace characters include space (U+0020), tab (U+0009), line feed\n-(U+000A), carriage return (U+000D), and a number of less common\n-ASCII and unicode characters.\n */\n pure fn is_whitespace(c: char) -> bool {\n-    const ch_space: char = '\\u0020';\n-    const ch_ogham_space_mark: char = '\\u1680';\n-    const ch_mongolian_vowel_sep: char = '\\u180e';\n-    const ch_en_quad: char = '\\u2000';\n-    const ch_em_quad: char = '\\u2001';\n-    const ch_en_space: char = '\\u2002';\n-    const ch_em_space: char = '\\u2003';\n-    const ch_three_per_em_space: char = '\\u2004';\n-    const ch_four_per_em_space: char = '\\u2005';\n-    const ch_six_per_em_space: char = '\\u2006';\n-    const ch_figure_space: char = '\\u2007';\n-    const ch_punctuation_space: char = '\\u2008';\n-    const ch_thin_space: char = '\\u2009';\n-    const ch_hair_space: char = '\\u200a';\n-    const ch_narrow_no_break_space: char = '\\u202f';\n-    const ch_medium_mathematical_space: char = '\\u205f';\n-    const ch_ideographic_space: char = '\\u3000';\n-    const ch_line_separator: char = '\\u2028';\n-    const ch_paragraph_separator: char = '\\u2029';\n-    const ch_character_tabulation: char = '\\u0009';\n-    const ch_line_feed: char = '\\u000a';\n-    const ch_line_tabulation: char = '\\u000b';\n-    const ch_form_feed: char = '\\u000c';\n-    const ch_carriage_return: char = '\\u000d';\n-    const ch_next_line: char = '\\u0085';\n-    const ch_no_break_space: char = '\\u00a0';\n-\n-    if c == ch_space {\n-        true\n-    } else if c == ch_ogham_space_mark {\n-        true\n-    } else if c == ch_mongolian_vowel_sep {\n-        true\n-    } else if c == ch_en_quad {\n-        true\n-    } else if c == ch_em_quad {\n-        true\n-    } else if c == ch_en_space {\n-        true\n-    } else if c == ch_em_space {\n-        true\n-    } else if c == ch_three_per_em_space {\n-        true\n-    } else if c == ch_four_per_em_space {\n-        true\n-    } else if c == ch_six_per_em_space {\n-        true\n-    } else if c == ch_figure_space {\n-        true\n-    } else if c == ch_punctuation_space {\n-        true\n-    } else if c == ch_thin_space {\n-        true\n-    } else if c == ch_hair_space {\n-        true\n-    } else if c == ch_narrow_no_break_space {\n-        true\n-    } else if c == ch_medium_mathematical_space {\n-        true\n-    } else if c == ch_ideographic_space {\n-        true\n-    } else if c == ch_line_tabulation {\n-        true\n-    } else if c == ch_paragraph_separator {\n-        true\n-    } else if c == ch_character_tabulation {\n-        true\n-    } else if c == ch_line_feed {\n-        true\n-    } else if c == ch_line_tabulation {\n-        true\n-    } else if c == ch_form_feed {\n-        true\n-    } else if c == ch_carriage_return {\n-        true\n-    } else if c == ch_next_line {\n-        true\n-    } else if c == ch_no_break_space { true } else { false }\n+    ret ('\\x09' <= c && c <= '\\x0x0d')\n+        || unicode::general_category::Zs(c)\n+        || unicode::general_category::Zl(c)\n+        || unicode::general_category::Zp(c);\n+}\n+\n+/*\n+Function: is_alphanumeric\n+\n+Indicates whether a character is alphanumeric, defined in terms of\n+the Unicode General Categories 'Nd', 'Nl', 'No' and the Derived\n+Core Property 'Alphabetic'.\n+\n+*/\n+\n+pure fn is_alphanumeric(c: char) -> bool {\n+    ret unicode::derived_property::Alphabetic(c) ||\n+        unicode::general_category::Nd(c) ||\n+        unicode::general_category::Nl(c) ||\n+        unicode::general_category::No(c);\n }\n \n+\n /*\n  Function: to_digit\n "}, {"sha": "f0dc1cc4e0faea0f7690e3597933c156638969e9", "filename": "src/libcore/core.rc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ac13f0da9ee2b51938e574b39f9537d2e66c5192/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ac13f0da9ee2b51938e574b39f9537d2e66c5192/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ac13f0da9ee2b51938e574b39f9537d2e66c5192", "patch": "@@ -30,6 +30,9 @@ mod u64;\n mod vec;\n mod bool;\n \n+// For internal use by char, not exported\n+mod unicode;\n+\n \n // Ubiquitous-utility-type modules\n "}, {"sha": "aacf40d25489e61efe5f93ad45594a050152634c", "filename": "src/libcore/unicode.rs", "status": "added", "additions": 4683, "deletions": 0, "changes": 4683, "blob_url": "https://github.com/rust-lang/rust/blob/ac13f0da9ee2b51938e574b39f9537d2e66c5192/src%2Flibcore%2Funicode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac13f0da9ee2b51938e574b39f9537d2e66c5192/src%2Flibcore%2Funicode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode.rs?ref=ac13f0da9ee2b51938e574b39f9537d2e66c5192"}]}