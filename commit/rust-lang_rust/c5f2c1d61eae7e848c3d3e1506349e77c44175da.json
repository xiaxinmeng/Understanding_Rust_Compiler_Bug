{"sha": "c5f2c1d61eae7e848c3d3e1506349e77c44175da", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1ZjJjMWQ2MWVhZTdlODQ4YzNkM2UxNTA2MzQ5ZTc3YzQ0MTc1ZGE=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-05-25T15:14:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2012-06-02T17:08:00Z"}, "message": "add some purity annotations in core", "tree": {"sha": "d1a25741858e9f5a42edb923d60794fadbe97a31", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d1a25741858e9f5a42edb923d60794fadbe97a31"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c5f2c1d61eae7e848c3d3e1506349e77c44175da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c5f2c1d61eae7e848c3d3e1506349e77c44175da", "html_url": "https://github.com/rust-lang/rust/commit/c5f2c1d61eae7e848c3d3e1506349e77c44175da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c5f2c1d61eae7e848c3d3e1506349e77c44175da/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5d168c404e79b3ebfee974a6370ede6771bc906", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5d168c404e79b3ebfee974a6370ede6771bc906", "html_url": "https://github.com/rust-lang/rust/commit/c5d168c404e79b3ebfee974a6370ede6771bc906"}], "stats": {"total": 147, "additions": 72, "deletions": 75}, "files": [{"sha": "f9e147dbf1c9d03ca3cedd99568c850294553f31", "filename": "src/libcore/option.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5f2c1d61eae7e848c3d3e1506349e77c44175da/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f2c1d61eae7e848c3d3e1506349e77c44175da/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=c5f2c1d61eae7e848c3d3e1506349e77c44175da", "patch": "@@ -25,13 +25,13 @@ pure fn get<T: copy>(opt: option<T>) -> T {\n     alt opt { some(x) { ret x; } none { fail \"option none\"; } }\n }\n \n-fn map<T, U: copy>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n+pure fn map<T, U: copy>(opt: option<T>, f: fn(T) -> U) -> option<U> {\n     #[doc = \"Maps a `some` value from one type to another\"];\n \n     alt opt { some(x) { some(f(x)) } none { none } }\n }\n \n-fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n+pure fn chain<T, U>(opt: option<T>, f: fn(T) -> option<U>) -> option<U> {\n     #[doc = \"\n     Update an optional value by optionally running its content through a\n     function that returns an option.\n@@ -58,19 +58,19 @@ pure fn get_default<T: copy>(opt: option<T>, def: T) -> T {\n     alt opt { some(x) { x } none { def } }\n }\n \n-fn map_default<T, U: copy>(opt: option<T>, def: U, f: fn(T) -> U) -> U {\n+pure fn map_default<T, U: copy>(opt: option<T>, def: U, f: fn(T) -> U) -> U {\n     #[doc = \"Applies a function to the contained value or returns a default\"];\n \n     alt opt { none { def } some(t) { f(t) } }\n }\n \n-fn iter<T>(opt: option<T>, f: fn(T)) {\n+pure fn iter<T>(opt: option<T>, f: fn(T)) {\n     #[doc = \"Performs an operation on the contained value or does nothing\"];\n \n     alt opt { none { } some(t) { f(t); } }\n }\n \n-fn unwrap<T>(-opt: option<T>) -> T unsafe {\n+pure fn unwrap<T>(-opt: option<T>) -> T unsafe {\n     #[doc = \"\n     Moves a value out of an option type and returns it.\n "}, {"sha": "00471fdd8b8a5757ca8a8db448c8f1c19ad33e1c", "filename": "src/libcore/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c5f2c1d61eae7e848c3d3e1506349e77c44175da/src%2Flibcore%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f2c1d61eae7e848c3d3e1506349e77c44175da/src%2Flibcore%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr.rs?ref=c5f2c1d61eae7e848c3d3e1506349e77c44175da", "patch": "@@ -1619,7 +1619,7 @@ fn reserve_at_least(&s: str, n: uint) unsafe {\n Returns the number of single-byte characters the string can hold without\n reallocating\n \"]\n-fn capacity(&&s: str) -> uint unsafe {\n+pure fn capacity(&&s: str) -> uint unsafe {\n     as_bytes(s) {|buf|\n         let vcap = vec::capacity(buf);\n         assert vcap > 0u;"}, {"sha": "d818a9d7077a8dc1d6d5c2bfc2590888210ae9fb", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 66, "deletions": 69, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/c5f2c1d61eae7e848c3d3e1506349e77c44175da/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c5f2c1d61eae7e848c3d3e1506349e77c44175da/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=c5f2c1d61eae7e848c3d3e1506349e77c44175da", "patch": "@@ -146,7 +146,7 @@ fn reserve_at_least<T>(&v: [const T], n: uint) {\n Returns the number of elements the vector can hold without reallocating\n \"]\n #[inline(always)]\n-fn capacity<T>(&&v: [const T]) -> uint unsafe {\n+pure fn capacity<T>(&&v: [const T]) -> uint unsafe {\n     let repr: **unsafe::vec_repr = ::unsafe::reinterpret_cast(addr_of(v));\n     (**repr).alloc / sys::size_of::<T>()\n }\n@@ -163,9 +163,9 @@ Creates and initializes an immutable vector.\n Creates an immutable vector of size `n_elts` and initializes the elements\n to the value returned by the function `op`.\n \"]\n-fn from_fn<T>(n_elts: uint, op: init_op<T>) -> [T] {\n+pure fn from_fn<T>(n_elts: uint, op: init_op<T>) -> [T] {\n     let mut v = [];\n-    reserve(v, n_elts);\n+    unchecked{reserve(v, n_elts);}\n     let mut i: uint = 0u;\n     while i < n_elts { v += [op(i)]; i += 1u; }\n     ret v;\n@@ -177,9 +177,9 @@ Creates and initializes an immutable vector.\n Creates an immutable vector of size `n_elts` and initializes the elements\n to the value `t`.\n \"]\n-fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n+pure fn from_elem<T: copy>(n_elts: uint, t: T) -> [T] {\n     let mut v = [];\n-    reserve(v, n_elts);\n+    unchecked{reserve(v, n_elts)}\n     let mut i: uint = 0u;\n     while i < n_elts { v += [t]; i += 1u; }\n     ret v;\n@@ -238,18 +238,18 @@ pure fn last_opt<T: copy>(v: [const T]) -> option<T> {\n }\n \n #[doc = \"Returns a copy of the elements from [`start`..`end`) from `v`.\"]\n-fn slice<T: copy>(v: [const T], start: uint, end: uint) -> [T] {\n+pure fn slice<T: copy>(v: [const T], start: uint, end: uint) -> [T] {\n     assert (start <= end);\n     assert (end <= len(v));\n     let mut result = [];\n-    reserve(result, end - start);\n+    unchecked{reserve(result, end - start)}\n     let mut i = start;\n     while i < end { result += [v[i]]; i += 1u; }\n     ret result;\n }\n \n #[doc = \"Return a slice that points into another slice.\"]\n-fn view<T: copy>(v: [const T]/&, start: uint, end: uint) -> [T]/&a {\n+pure fn view<T: copy>(v: [const T]/&, start: uint, end: uint) -> [T]/&a {\n     assert (start <= end);\n     assert (end <= len(v));\n     unpack_slice(v) {|p, _len|\n@@ -447,19 +447,19 @@ fn grow_set<T: copy>(&v: [mut T], index: uint, initval: T, val: T) {\n #[doc = \"\n Apply a function to each element of a vector and return the results\n \"]\n-fn map<T, U>(v: [const T]/&, f: fn(T) -> U) -> [U] {\n+pure fn map<T, U>(v: [const T]/&, f: fn(T) -> U) -> [U] {\n     let mut result = [];\n-    reserve(result, len(v));\n+    unchecked{reserve(result, len(v));}\n     for each(v) {|elem| result += [f(elem)]; }\n     ret result;\n }\n \n #[doc = \"\n Apply a function to each element of a vector and return the results\n \"]\n-fn mapi<T, U>(v: [const T]/&, f: fn(uint, T) -> U) -> [U] {\n+pure fn mapi<T, U>(v: [const T]/&, f: fn(uint, T) -> U) -> [U] {\n     let mut result = [];\n-    reserve(result, len(v));\n+    unchecked{reserve(result, len(v));}\n     for eachi(v) {|i, elem| result += [f(i, elem)]; }\n     ret result;\n }\n@@ -468,7 +468,7 @@ fn mapi<T, U>(v: [const T]/&, f: fn(uint, T) -> U) -> [U] {\n Apply a function to each element of a vector and return a concatenation\n of each result vector\n \"]\n-fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {\n+pure fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {\n     let mut result = [];\n     for each(v) {|elem| result += f(elem); }\n     ret result;\n@@ -477,8 +477,8 @@ fn flat_map<T, U>(v: [T], f: fn(T) -> [U]) -> [U] {\n #[doc = \"\n Apply a function to each pair of elements and return the results\n \"]\n-fn map2<T: copy, U: copy, V>(v0: [const T], v1: [const U],\n-                             f: fn(T, U) -> V) -> [V] {\n+pure fn map2<T: copy, U: copy, V>(v0: [const T], v1: [const U],\n+                                  f: fn(T, U) -> V) -> [V] {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { fail; }\n     let mut u: [V] = [];\n@@ -493,7 +493,7 @@ Apply a function to each element of a vector and return the results\n If function `f` returns `none` then that element is excluded from\n the resulting vector.\n \"]\n-fn filter_map<T, U: copy>(v: [T], f: fn(T) -> option<U>)\n+pure fn filter_map<T, U: copy>(v: [T], f: fn(T) -> option<U>)\n     -> [U] {\n     let mut result = [];\n     for each(v) {|elem|\n@@ -512,7 +512,7 @@ holds.\n Apply function `f` to each element of `v` and return a vector containing\n only those elements for which `f` returned true.\n \"]\n-fn filter<T: copy>(v: [const T], f: fn(T) -> bool) -> [T] {\n+pure fn filter<T: copy>(v: [const T], f: fn(T) -> bool) -> [T] {\n     let mut result = [];\n     for each(v) {|elem|\n         if f(elem) { result += [elem]; }\n@@ -525,7 +525,7 @@ Concatenate a vector of vectors.\n \n Flattens a vector of vectors of T into a single vector of T.\n \"]\n-fn concat<T: copy>(v: [const [const T]]) -> [T] {\n+pure fn concat<T: copy>(v: [const [const T]]) -> [T] {\n     let mut r = [];\n     for each(v) {|inner| r += inner; }\n     ret r;\n@@ -534,18 +534,18 @@ fn concat<T: copy>(v: [const [const T]]) -> [T] {\n #[doc = \"\n Concatenate a vector of vectors, placing a given separator between each\n \"]\n-fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n+pure fn connect<T: copy>(v: [const [const T]], sep: T) -> [T] {\n     let mut r: [T] = [];\n     let mut first = true;\n     for each(v) {|inner|\n-        if first { first = false; } else { push(r, sep); }\n+        if first { first = false; } else { r += [sep]; }\n         r += inner;\n     }\n     ret r;\n }\n \n #[doc = \"Reduce a vector from left to right\"]\n-fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n+pure fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n     let mut accum = z;\n     iter(v) { |elt|\n         accum = p(accum, elt);\n@@ -554,7 +554,7 @@ fn foldl<T: copy, U>(z: T, v: [const U], p: fn(T, U) -> T) -> T {\n }\n \n #[doc = \"Reduce a vector from right to left\"]\n-fn foldr<T, U: copy>(v: [const T]/&, z: U, p: fn(T, U) -> U) -> U {\n+pure fn foldr<T, U: copy>(v: [const T]/&, z: U, p: fn(T, U) -> U) -> U {\n     let mut accum = z;\n     riter(v) { |elt|\n         accum = p(elt, accum);\n@@ -567,7 +567,7 @@ Return true if a predicate matches any elements\n \n If the vector contains no elements then false is returned.\n \"]\n-fn any<T>(v: [const T]/&, f: fn(T) -> bool) -> bool {\n+pure fn any<T>(v: [const T]/&, f: fn(T) -> bool) -> bool {\n     for each(v) {|elem| if f(elem) { ret true; } }\n     ret false;\n }\n@@ -577,7 +577,8 @@ Return true if a predicate matches any elements in both vectors.\n \n If the vectors contains no elements then false is returned.\n \"]\n-fn any2<T, U>(v0: [const T]/&, v1: [const U]/&, f: fn(T, U) -> bool) -> bool {\n+pure fn any2<T, U>(v0: [const T]/&, v1: [const U]/&,\n+                   f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     let v1_len = len(v1);\n     let mut i = 0u;\n@@ -593,7 +594,7 @@ Return true if a predicate matches all elements\n \n If the vector contains no elements then true is returned.\n \"]\n-fn all<T>(v: [const T]/&, f: fn(T) -> bool) -> bool {\n+pure fn all<T>(v: [const T]/&, f: fn(T) -> bool) -> bool {\n     for each(v) {|elem| if !f(elem) { ret false; } }\n     ret true;\n }\n@@ -603,7 +604,7 @@ Return true if a predicate matches all elements\n \n If the vector contains no elements then true is returned.\n \"]\n-fn alli<T>(v: [const T]/&, f: fn(uint, T) -> bool) -> bool {\n+pure fn alli<T>(v: [const T]/&, f: fn(uint, T) -> bool) -> bool {\n     for eachi(v) {|i, elem| if !f(i, elem) { ret false; } }\n     ret true;\n }\n@@ -613,7 +614,8 @@ Return true if a predicate matches all elements in both vectors.\n \n If the vectors are not the same size then false is returned.\n \"]\n-fn all2<T, U>(v0: [const T]/&, v1: [const U]/&, f: fn(T, U) -> bool) -> bool {\n+pure fn all2<T, U>(v0: [const T]/&, v1: [const U]/&,\n+                   f: fn(T, U) -> bool) -> bool {\n     let v0_len = len(v0);\n     if v0_len != len(v1) { ret false; }\n     let mut i = 0u;\n@@ -622,13 +624,13 @@ fn all2<T, U>(v0: [const T]/&, v1: [const U]/&, f: fn(T, U) -> bool) -> bool {\n }\n \n #[doc = \"Return true if a vector contains an element with the given value\"]\n-fn contains<T>(v: [const T], x: T) -> bool {\n+pure fn contains<T>(v: [const T], x: T) -> bool {\n     for each(v) {|elt| if x == elt { ret true; } }\n     ret false;\n }\n \n #[doc = \"Returns the number of elements that are equal to a given value\"]\n-fn count<T>(v: [const T], x: T) -> uint {\n+pure fn count<T>(v: [const T], x: T) -> uint {\n     let mut cnt = 0u;\n     for each(v) {|elt| if x == elt { cnt += 1u; } }\n     ret cnt;\n@@ -641,7 +643,7 @@ Apply function `f` to each element of `v`, starting from the first.\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n \"]\n-fn find<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n+pure fn find<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n     find_between(v, 0u, len(v), f)\n }\n \n@@ -652,7 +654,7 @@ Apply function `f` to each element of `v` within the range [`start`, `end`).\n When function `f` returns true then an option containing the element\n is returned. If `f` matches no elements then none is returned.\n \"]\n-fn find_between<T: copy>(v: [const T], start: uint, end: uint,\n+pure fn find_between<T: copy>(v: [const T], start: uint, end: uint,\n                       f: fn(T) -> bool) -> option<T> {\n     option::map(position_between(v, start, end, f)) { |i| v[i] }\n }\n@@ -664,7 +666,7 @@ Apply function `f` to each element of `v` in reverse order. When function `f`\n returns true then an option containing the element is returned. If `f`\n matches no elements then none is returned.\n \"]\n-fn rfind<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n+pure fn rfind<T: copy>(v: [const T], f: fn(T) -> bool) -> option<T> {\n     rfind_between(v, 0u, len(v), f)\n }\n \n@@ -675,13 +677,13 @@ Apply function `f` to each element of `v` in reverse order within the range\n [`start`, `end`). When function `f` returns true then an option containing\n the element is returned. If `f` matches no elements then none is returned.\n \"]\n-fn rfind_between<T: copy>(v: [const T], start: uint, end: uint,\n-                       f: fn(T) -> bool) -> option<T> {\n+pure fn rfind_between<T: copy>(v: [const T], start: uint, end: uint,\n+                               f: fn(T) -> bool) -> option<T> {\n     option::map(rposition_between(v, start, end, f)) { |i| v[i] }\n }\n \n #[doc = \"Find the first index containing a matching value\"]\n-fn position_elem<T>(v: [const T], x: T) -> option<uint> {\n+pure fn position_elem<T>(v: [const T], x: T) -> option<uint> {\n     position(v) { |y| x == y }\n }\n \n@@ -692,7 +694,7 @@ Apply function `f` to each element of `v`.  When function `f` returns true\n then an option containing the index is returned. If `f` matches no elements\n then none is returned.\n \"]\n-fn position<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n+pure fn position<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n     position_between(v, 0u, len(v), f)\n }\n \n@@ -703,8 +705,8 @@ Apply function `f` to each element of `v` between the range [`start`, `end`).\n When function `f` returns true then an option containing the index is\n returned. If `f` matches no elements then none is returned.\n \"]\n-fn position_between<T>(v: [const T], start: uint, end: uint,\n-                    f: fn(T) -> bool) -> option<uint> {\n+pure fn position_between<T>(v: [const T], start: uint, end: uint,\n+                            f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = start;\n@@ -713,7 +715,7 @@ fn position_between<T>(v: [const T], start: uint, end: uint,\n }\n \n #[doc = \"Find the last index containing a matching value\"]\n-fn rposition_elem<T>(v: [const T], x: T) -> option<uint> {\n+pure fn rposition_elem<T>(v: [const T], x: T) -> option<uint> {\n     rposition(v) { |y| x == y }\n }\n \n@@ -724,7 +726,7 @@ Apply function `f` to each element of `v` in reverse order.  When function\n `f` returns true then an option containing the index is returned. If `f`\n matches no elements then none is returned.\n \"]\n-fn rposition<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n+pure fn rposition<T>(v: [const T], f: fn(T) -> bool) -> option<uint> {\n     rposition_between(v, 0u, len(v), f)\n }\n \n@@ -735,8 +737,8 @@ Apply function `f` to each element of `v` in reverse order between the range\n [`start`, `end`). When function `f` returns true then an option containing\n the index is returned. If `f` matches no elements then none is returned.\n \"]\n-fn rposition_between<T>(v: [const T], start: uint, end: uint,\n-                     f: fn(T) -> bool) -> option<uint> {\n+pure fn rposition_between<T>(v: [const T], start: uint, end: uint,\n+                             f: fn(T) -> bool) -> option<uint> {\n     assert start <= end;\n     assert end <= len(v);\n     let mut i = end;\n@@ -759,7 +761,7 @@ vector contains the first element of the i-th tuple of the input vector,\n and the i-th element of the second vector contains the second element\n of the i-th tuple of the input vector.\n \"]\n-fn unzip<T: copy, U: copy>(v: [const (T, U)]) -> ([T], [U]) {\n+pure fn unzip<T: copy, U: copy>(v: [const (T, U)]) -> ([T], [U]) {\n     let mut as = [], bs = [];\n     for each(v) {|p| let (a, b) = p; as += [a]; bs += [b]; }\n     ret (as, bs);\n@@ -771,7 +773,7 @@ Convert two vectors to a vector of pairs\n Returns a vector of tuples, where the i-th tuple contains contains the\n i-th elements from each of the input vectors.\n \"]\n-fn zip<T: copy, U: copy>(v: [const T], u: [const U]) -> [(T, U)] {\n+pure fn zip<T: copy, U: copy>(v: [const T], u: [const U]) -> [(T, U)] {\n     let mut zipped = [];\n     let sz = len(v);\n     let mut i = 0u;\n@@ -818,7 +820,7 @@ Iterates over vector `v` and, for each element, calls function `f` with the\n element's value.\n \"]\n #[inline(always)]\n-fn iter<T>(v: [const T], f: fn(T)) {\n+pure fn iter<T>(v: [const T], f: fn(T)) {\n     iter_between(v, 0u, vec::len(v), f)\n }\n \n@@ -832,7 +834,7 @@ element's value.\n \n */\n #[inline(always)]\n-fn iter_between<T>(v: [const T], start: uint, end: uint, f: fn(T)) {\n+pure fn iter_between<T>(v: [const T], start: uint, end: uint, f: fn(T)) {\n     assert start <= end;\n     assert end <= vec::len(v);\n     unsafe {\n@@ -852,7 +854,7 @@ Iterates over a vector, with option to break\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-fn each<T>(v: [const T]/&, f: fn(T) -> bool) unsafe {\n+pure fn each<T>(v: [const T]/&, f: fn(T) -> bool) unsafe {\n     vec::unpack_slice(v) {|p, n|\n         let mut n = n;\n         let mut p = p;\n@@ -870,7 +872,7 @@ Iterates over a vector's elements and indices\n Return true to continue, false to break.\n \"]\n #[inline(always)]\n-fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) unsafe {\n+pure fn eachi<T>(v: [const T]/&, f: fn(uint, T) -> bool) unsafe {\n     vec::unpack_slice(v) {|p, n|\n         let mut i = 0u;\n         let mut p = p;\n@@ -904,7 +906,7 @@ Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n \"]\n #[inline(always)]\n-fn iteri<T>(v: [const T], f: fn(uint, T)) {\n+pure fn iteri<T>(v: [const T], f: fn(uint, T)) {\n     let mut i = 0u;\n     let l = len(v);\n     while i < l { f(i, v[i]); i += 1u; }\n@@ -916,7 +918,7 @@ Iterates over a vector in reverse\n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value.\n \"]\n-fn riter<T>(v: [const T]/&, f: fn(T)) {\n+pure fn riter<T>(v: [const T]/&, f: fn(T)) {\n     riteri(v) { |_i, v| f(v) }\n }\n \n@@ -926,7 +928,7 @@ Iterates over a vector's elements and indexes in reverse\n Iterates over vector `v` and, for each element, calls function `f` with the\n element's value and index.\n \"]\n-fn riteri<T>(v: [const T]/&, f: fn(uint, T)) {\n+pure fn riteri<T>(v: [const T]/&, f: fn(uint, T)) {\n     let mut i = len(v);\n     while 0u < i {\n         i -= 1u;\n@@ -944,7 +946,7 @@ lexicographically sorted).\n The total number of permutations produced is `len(v)!`.  If `v` contains\n repeated elements, then some permutations are repeated.\n \"]\n-fn permute<T: copy>(v: [T], put: fn([T])) {\n+pure fn permute<T: copy>(v: [T], put: fn([T])) {\n   let ln = len(v);\n   if ln == 0u {\n     put([]);\n@@ -959,21 +961,16 @@ fn permute<T: copy>(v: [T], put: fn([T])) {\n   }\n }\n \n-fn windowed <TT: copy> (nn: uint, xx: [const TT]) -> [[TT]] {\n-   let mut ww = [];\n-\n-   assert 1u <= nn;\n-\n-   vec::iteri (xx, {|ii, _x|\n-      let len = vec::len(xx);\n-\n-      if ii+nn <= len {\n-         let w = vec::slice ( xx, ii, ii+nn );\n-         vec::push (ww, w);\n-      }\n-   });\n-\n-   ret ww;\n+pure fn windowed<TT: copy>(nn: uint, xx: [const TT]) -> [[TT]] {\n+    let mut ww = [];\n+    assert 1u <= nn;\n+    vec::iteri (xx, {|ii, _x|\n+        let len = vec::len(xx);\n+        if ii+nn <= len {\n+            ww += [vec::slice(xx, ii, ii+nn)];\n+        }\n+    });\n+    ret ww;\n }\n \n #[doc = \"\n@@ -994,7 +991,7 @@ fn as_mut_buf<E,T>(v: [mut E], f: fn(*mut E) -> T) -> T unsafe {\n Work with the buffer and length of a slice.\n \"]\n #[inline(always)]\n-fn unpack_slice<T,U>(s: [const T]/&, f: fn(*T, uint) -> U) -> U unsafe {\n+pure fn unpack_slice<T,U>(s: [const T]/&, f: fn(*T, uint) -> U) -> U unsafe {\n     let v : *(*T,uint) = ::unsafe::reinterpret_cast(ptr::addr_of(s));\n     let (buf,len) = *v;\n     f(buf, len / sys::size_of::<T>())\n@@ -1137,7 +1134,7 @@ impl extensions<T> for [T] {\n     #[doc = \"Returns true if the function returns true for all elements.\n \n     If the vector is empty, true is returned.\"]\n-    fn alli(f: fn(uint, T) -> bool) -> bool {\n+    pure fn alli(f: fn(uint, T) -> bool) -> bool {\n         alli(self, f)\n     }\n     #[doc = \""}]}