{"sha": "92ff8ea52816982ad4cbfac8168e216d32d74c77", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZmY4ZWE1MjgxNjk4MmFkNGNiZmFjODE2OGUyMTZkMzJkNzRjNzc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-27T23:08:13Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-27T23:08:13Z"}, "message": "Auto merge of #21523 - nikomatsakis:issue-21245-japaric-ti-failure, r=eddyb\n\nThis also includes some miscellaneous cleanup. This is kind of a band-aid but it fixes the problems @japaric was encountering.\r\n\r\nr? @eddyb", "tree": {"sha": "3cff8fb99f4d3520fc6adfeebf3d50e44545e3e7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3cff8fb99f4d3520fc6adfeebf3d50e44545e3e7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92ff8ea52816982ad4cbfac8168e216d32d74c77", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92ff8ea52816982ad4cbfac8168e216d32d74c77", "html_url": "https://github.com/rust-lang/rust/commit/92ff8ea52816982ad4cbfac8168e216d32d74c77", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92ff8ea52816982ad4cbfac8168e216d32d74c77/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "777435990e0e91df6b72ce80c9b6fa485eeb5daa", "url": "https://api.github.com/repos/rust-lang/rust/commits/777435990e0e91df6b72ce80c9b6fa485eeb5daa", "html_url": "https://github.com/rust-lang/rust/commit/777435990e0e91df6b72ce80c9b6fa485eeb5daa"}, {"sha": "8d6786cd6c95b80dbca281953e4ea6db9e033af5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d6786cd6c95b80dbca281953e4ea6db9e033af5", "html_url": "https://github.com/rust-lang/rust/commit/8d6786cd6c95b80dbca281953e4ea6db9e033af5"}], "stats": {"total": 451, "additions": 326, "deletions": 125}, "files": [{"sha": "eaec4fac0a3f96ef66154b698d31102ea8815288", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -79,16 +79,13 @@ pub struct InferCtxt<'a, 'tcx: 'a> {\n     type_variables: RefCell<type_variable::TypeVariableTable<'tcx>>,\n \n     // Map from integral variable to the kind of integer it represents\n-    int_unification_table:\n-        RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>,\n+    int_unification_table: RefCell<UnificationTable<ty::IntVid>>,\n \n     // Map from floating variable to the kind of float it represents\n-    float_unification_table:\n-        RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>,\n+    float_unification_table: RefCell<UnificationTable<ty::FloatVid>>,\n \n     // For region variables.\n-    region_vars:\n-        RegionVarBindings<'a, 'tcx>,\n+    region_vars: RegionVarBindings<'a, 'tcx>,\n }\n \n /// A map returned by `skolemize_late_bound_regions()` indicating the skolemized"}, {"sha": "4bbc503579972593e39217b3077462ed9fb3784a", "filename": "src/librustc/middle/infer/type_variable.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ftype_variable.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -19,7 +19,7 @@ use std::u32;\n use util::snapshot_vec as sv;\n \n pub struct TypeVariableTable<'tcx> {\n-    values: sv::SnapshotVec<TypeVariableData<'tcx>,UndoEntry,Delegate>,\n+    values: sv::SnapshotVec<Delegate<'tcx>>,\n }\n \n struct TypeVariableData<'tcx> {\n@@ -42,7 +42,7 @@ enum UndoEntry {\n     Relate(ty::TyVid, ty::TyVid),\n }\n \n-struct Delegate;\n+struct Delegate<'tcx>;\n \n type Relation = (RelationDir, ty::TyVid);\n \n@@ -195,9 +195,12 @@ impl<'tcx> TypeVariableTable<'tcx> {\n     }\n }\n \n-impl<'tcx> sv::SnapshotVecDelegate<TypeVariableData<'tcx>,UndoEntry> for Delegate {\n+impl<'tcx> sv::SnapshotVecDelegate for Delegate<'tcx> {\n+    type Value = TypeVariableData<'tcx>;\n+    type Undo = UndoEntry;\n+\n     fn reverse(&mut self,\n-               values: &mut Vec<TypeVariableData>,\n+               values: &mut Vec<TypeVariableData<'tcx>>,\n                action: UndoEntry) {\n         match action {\n             SpecifyVar(vid, relations) => {"}, {"sha": "e15eb9c05766595424b88ca0e0c066ae2262de1e", "filename": "src/librustc/middle/infer/unify.rs", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Funify.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -19,7 +19,6 @@ use middle::infer::InferCtxt;\n use std::cell::RefCell;\n use std::fmt::Debug;\n use syntax::ast;\n-use util::ppaux::Repr;\n use util::snapshot_vec as sv;\n \n /// This trait is implemented by any type that can serve as a type\n@@ -32,15 +31,17 @@ use util::snapshot_vec as sv;\n /// (possibly not yet known) sort of integer.\n ///\n /// Implementations of this trait are at the end of this file.\n-pub trait UnifyKey<'tcx, V> : Clone + Debug + PartialEq + Repr<'tcx> {\n+pub trait UnifyKey : Clone + Debug + PartialEq {\n+    type Value : UnifyValue;\n+\n     fn index(&self) -> uint;\n \n     fn from_index(u: uint) -> Self;\n \n     // Given an inference context, returns the unification table\n     // appropriate to this key type.\n     fn unification_table<'v>(infcx: &'v InferCtxt)\n-                             -> &'v RefCell<UnificationTable<Self,V>>;\n+                             -> &'v RefCell<UnificationTable<Self>>;\n \n     fn tag(k: Option<Self>) -> &'static str;\n }\n@@ -51,7 +52,7 @@ pub trait UnifyKey<'tcx, V> : Clone + Debug + PartialEq + Repr<'tcx> {\n /// whose value is not yet set).\n ///\n /// Implementations of this trait are at the end of this file.\n-pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n+pub trait UnifyValue : Clone + PartialEq + Debug {\n }\n \n /// Value of a unification key. We implement Tarjan's union-find\n@@ -62,44 +63,44 @@ pub trait UnifyValue<'tcx> : Clone + Repr<'tcx> + PartialEq {\n /// to keep the DAG relatively balanced, which helps keep the running\n /// time of the algorithm under control. For more information, see\n /// <http://en.wikipedia.org/wiki/Disjoint-set_data_structure>.\n-#[derive(PartialEq,Clone)]\n-pub enum VarValue<K,V> {\n+#[derive(PartialEq,Clone,Show)]\n+pub enum VarValue<K:UnifyKey> {\n     Redirect(K),\n-    Root(V, uint),\n+    Root(K::Value, uint),\n }\n \n /// Table of unification keys and their values.\n-pub struct UnificationTable<K,V> {\n+pub struct UnificationTable<K:UnifyKey> {\n     /// Indicates the current value of each key.\n-    values: sv::SnapshotVec<VarValue<K,V>,(),Delegate>,\n+    values: sv::SnapshotVec<Delegate<K>>,\n }\n \n /// At any time, users may snapshot a unification table.  The changes\n /// made during the snapshot may either be *committed* or *rolled back*.\n-pub struct Snapshot<K> {\n+pub struct Snapshot<K:UnifyKey> {\n     // Link snapshot to the key type `K` of the table.\n     marker: marker::CovariantType<K>,\n     snapshot: sv::Snapshot,\n }\n \n /// Internal type used to represent the result of a `get()` operation.\n /// Conveys the current root and value of the key.\n-pub struct Node<K,V> {\n+pub struct Node<K:UnifyKey> {\n     pub key: K,\n-    pub value: V,\n+    pub value: K::Value,\n     pub rank: uint,\n }\n \n #[derive(Copy)]\n-pub struct Delegate;\n+pub struct Delegate<K>;\n \n // We can't use V:LatticeValue, much as I would like to,\n // because frequently the pattern is that V=Option<U> for some\n // other type parameter U, and we have no way to say\n // Option<U>:LatticeValue.\n \n-impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K,V> {\n-    pub fn new() -> UnificationTable<K,V> {\n+impl<K:UnifyKey> UnificationTable<K> {\n+    pub fn new() -> UnificationTable<K> {\n         UnificationTable {\n             values: sv::SnapshotVec::new(Delegate),\n         }\n@@ -126,7 +127,7 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n         self.values.commit(snapshot.snapshot);\n     }\n \n-    pub fn new_key(&mut self, value: V) -> K {\n+    pub fn new_key(&mut self, value: K::Value) -> K {\n         let index = self.values.push(Root(value, 0));\n         let k = UnifyKey::from_index(index);\n         debug!(\"{}: created new key: {:?}\",\n@@ -137,12 +138,12 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n \n     /// Find the root node for `vid`. This uses the standard union-find algorithm with path\n     /// compression: http://en.wikipedia.org/wiki/Disjoint-set_data_structure\n-    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K,V> {\n+    pub fn get(&mut self, tcx: &ty::ctxt, vid: K) -> Node<K> {\n         let index = vid.index();\n         let value = (*self.values.get(index)).clone();\n         match value {\n             Redirect(redirect) => {\n-                let node: Node<K,V> = self.get(tcx, redirect.clone());\n+                let node: Node<K> = self.get(tcx, redirect.clone());\n                 if node.key != redirect {\n                     // Path compression\n                     self.values.set(index, Redirect(node.key.clone()));\n@@ -164,33 +165,32 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n \n     /// Sets the value for `vid` to `new_value`. `vid` MUST be a root node! Also, we must be in the\n     /// middle of a snapshot.\n-    pub fn set(&mut self,\n-               tcx: &ty::ctxt<'tcx>,\n-               key: K,\n-               new_value: VarValue<K,V>)\n+    pub fn set<'tcx>(&mut self,\n+                     _tcx: &ty::ctxt<'tcx>,\n+                     key: K,\n+                     new_value: VarValue<K>)\n     {\n         assert!(self.is_root(&key));\n \n-        debug!(\"Updating variable {} to {}\",\n-               key.repr(tcx),\n-               new_value.repr(tcx));\n+        debug!(\"Updating variable {:?} to {:?}\",\n+               key, new_value);\n \n         self.values.set(key.index(), new_value);\n     }\n \n     /// Either redirects node_a to node_b or vice versa, depending on the relative rank. Returns\n     /// the new root and rank. You should then update the value of the new root to something\n     /// suitable.\n-    pub fn unify(&mut self,\n-                 tcx: &ty::ctxt<'tcx>,\n-                 node_a: &Node<K,V>,\n-                 node_b: &Node<K,V>)\n-                 -> (K, uint)\n+    pub fn unify<'tcx>(&mut self,\n+                       tcx: &ty::ctxt<'tcx>,\n+                       node_a: &Node<K>,\n+                       node_b: &Node<K>)\n+                       -> (K, uint)\n     {\n-        debug!(\"unify(node_a(id={}, rank={}), node_b(id={}, rank={}))\",\n-               node_a.key.repr(tcx),\n+        debug!(\"unify(node_a(id={:?}, rank={:?}), node_b(id={:?}, rank={:?}))\",\n+               node_a.key,\n                node_a.rank,\n-               node_b.key.repr(tcx),\n+               node_b.key,\n                node_b.rank);\n \n         if node_a.rank > node_b.rank {\n@@ -212,8 +212,11 @@ impl<'tcx, V:PartialEq+Clone+Repr<'tcx>, K:UnifyKey<'tcx, V>> UnificationTable<K\n     }\n }\n \n-impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n-    fn reverse(&mut self, _: &mut Vec<VarValue<K,V>>, _: ()) {\n+impl<K> sv::SnapshotVecDelegate for Delegate<K> {\n+    type Value = VarValue<K>;\n+    type Undo = ();\n+\n+    fn reverse(&mut self, _: &mut Vec<VarValue<K>>, _: ()) {\n         panic!(\"Nothing to reverse\");\n     }\n }\n@@ -224,7 +227,7 @@ impl<K,V> sv::SnapshotVecDelegate<VarValue<K,V>,()> for Delegate {\n \n /// Indicates a type that does not have any kind of subtyping\n /// relationship.\n-pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Repr<'tcx> {\n+pub trait SimplyUnifiable<'tcx> : Clone + PartialEq + Debug {\n     fn to_type(&self, tcx: &ty::ctxt<'tcx>) -> Ty<'tcx>;\n     fn to_type_err(expected_found<Self>) -> ty::type_err<'tcx>;\n }\n@@ -242,8 +245,11 @@ pub fn err<'tcx, V:SimplyUnifiable<'tcx>>(a_is_expected: bool,\n     }\n }\n \n-pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V:SimplyUnifiable<'tcx>,\n-                                                  K:UnifyKey<'tcx, Option<V>>> {\n+pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V>\n+    where K : UnifyKey<Value=Option<V>>,\n+          V : SimplyUnifiable<'tcx>,\n+          Option<V> : UnifyValue,\n+{\n     fn simple_vars(&self,\n                    a_is_expected: bool,\n                    a_id: K,\n@@ -257,8 +263,10 @@ pub trait InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V:SimplyUnifiable<'tcx>,\n     fn probe_var(&self, a_id: K) -> Option<Ty<'tcx>>;\n }\n \n-impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n-    InferCtxtMethodsForSimplyUnifiableTypes<'tcx, V, K> for InferCtxt<'a, 'tcx>\n+impl<'a,'tcx,V,K> InferCtxtMethodsForSimplyUnifiableTypes<'tcx,K,V> for InferCtxt<'a,'tcx>\n+    where K : UnifyKey<Value=Option<V>>,\n+          V : SimplyUnifiable<'tcx>,\n+          Option<V> : UnifyValue,\n {\n     /// Unifies two simple keys. Because simple keys do not have any subtyping relationships, if\n     /// both keys have already been associated with a value, then those two values must be the\n@@ -271,8 +279,8 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n     {\n         let tcx = self.tcx;\n         let table = UnifyKey::unification_table(self);\n-        let node_a = table.borrow_mut().get(tcx, a_id);\n-        let node_b = table.borrow_mut().get(tcx, b_id);\n+        let node_a: Node<K> = table.borrow_mut().get(tcx, a_id);\n+        let node_b: Node<K> = table.borrow_mut().get(tcx, b_id);\n         let a_id = node_a.key.clone();\n         let b_id = node_b.key.clone();\n \n@@ -346,14 +354,14 @@ impl<'a,'tcx,V:SimplyUnifiable<'tcx>,K:UnifyKey<'tcx, Option<V>>>\n \n // Integral type keys\n \n-impl<'tcx> UnifyKey<'tcx, Option<IntVarValue>> for ty::IntVid {\n+impl UnifyKey for ty::IntVid {\n+    type Value = Option<IntVarValue>;\n+\n     fn index(&self) -> uint { self.index as uint }\n \n     fn from_index(i: uint) -> ty::IntVid { ty::IntVid { index: i as u32 } }\n \n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<UnificationTable<ty::IntVid, Option<IntVarValue>>>\n-    {\n+    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::IntVid>> {\n         return &infcx.int_unification_table;\n     }\n \n@@ -375,18 +383,18 @@ impl<'tcx> SimplyUnifiable<'tcx> for IntVarValue {\n     }\n }\n \n-impl<'tcx> UnifyValue<'tcx> for Option<IntVarValue> { }\n+impl UnifyValue for Option<IntVarValue> { }\n \n // Floating point type keys\n \n-impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n+impl UnifyKey for ty::FloatVid {\n+    type Value = Option<ast::FloatTy>;\n+\n     fn index(&self) -> uint { self.index as uint }\n \n     fn from_index(i: uint) -> ty::FloatVid { ty::FloatVid { index: i as u32 } }\n \n-    fn unification_table<'v>(infcx: &'v InferCtxt)\n-        -> &'v RefCell<UnificationTable<ty::FloatVid, Option<ast::FloatTy>>>\n-    {\n+    fn unification_table<'v>(infcx: &'v InferCtxt) -> &'v RefCell<UnificationTable<ty::FloatVid>> {\n         return &infcx.float_unification_table;\n     }\n \n@@ -395,7 +403,7 @@ impl<'tcx> UnifyKey<'tcx, Option<ast::FloatTy>> for ty::FloatVid {\n     }\n }\n \n-impl<'tcx> UnifyValue<'tcx> for Option<ast::FloatTy> {\n+impl UnifyValue for Option<ast::FloatTy> {\n }\n \n impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n@@ -407,12 +415,3 @@ impl<'tcx> SimplyUnifiable<'tcx> for ast::FloatTy {\n         ty::terr_float_mismatch(err)\n     }\n }\n-\n-impl<'tcx, K:Repr<'tcx>, V:Repr<'tcx>> Repr<'tcx> for VarValue<K,V> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            Redirect(ref k) => format!(\"Redirect({})\", k.repr(tcx)),\n-            Root(ref v, r) => format!(\"Root({}, {})\", v.repr(tcx), r)\n-        }\n-    }\n-}"}, {"sha": "ed0582804831a3767882cb105d9278cb81c19416", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -394,7 +394,7 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n         ty::Predicate::Projection(ref data) => {\n             let project_obligation = obligation.with(data.clone());\n             let result = project::poly_project_and_unify_type(selcx, &project_obligation);\n-            debug!(\"poly_project_and_unify_type({}) = {}\",\n+            debug!(\"process_predicate: poly_project_and_unify_type({}) returned {}\",\n                    project_obligation.repr(tcx),\n                    result.repr(tcx));\n             match result {"}, {"sha": "c179153dbde0a737606f079cd1791d2ed6ff345b", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -65,7 +65,7 @@ pub fn poly_project_and_unify_type<'cx,'tcx>(\n     obligation: &PolyProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n-    debug!(\"poly_project(obligation={})\",\n+    debug!(\"poly_project_and_unify_type(obligation={})\",\n            obligation.repr(selcx.tcx()));\n \n     let infcx = selcx.infcx();\n@@ -109,7 +109,7 @@ fn project_and_unify_type<'cx,'tcx>(\n     obligation: &ProjectionObligation<'tcx>)\n     -> Result<Option<Vec<PredicateObligation<'tcx>>>, MismatchedProjectionTypes<'tcx>>\n {\n-    debug!(\"project_and_unify(obligation={})\",\n+    debug!(\"project_and_unify_type(obligation={})\",\n            obligation.repr(selcx.tcx()));\n \n     let Normalized { value: normalized_ty, obligations } ="}, {"sha": "b18cb86a2f4c38a391fe2e93bfb458bab2899759", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -526,9 +526,13 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         // If no match, compute result and insert into cache.\n         let candidate = self.candidate_from_obligation_no_cache(stack);\n-        debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n-               cache_fresh_trait_pred.repr(self.tcx()), candidate.repr(self.tcx()));\n-        self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n+\n+        if self.should_update_candidate_cache(&cache_fresh_trait_pred, &candidate) {\n+            debug!(\"CACHE MISS: cache_fresh_trait_pred={}, candidate={}\",\n+                   cache_fresh_trait_pred.repr(self.tcx()), candidate.repr(self.tcx()));\n+            self.insert_candidate_cache(cache_fresh_trait_pred, candidate.clone());\n+        }\n+\n         candidate\n     }\n \n@@ -705,6 +709,47 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         hashmap.insert(cache_fresh_trait_pred.0.trait_ref.clone(), candidate);\n     }\n \n+    fn should_update_candidate_cache(&mut self,\n+                                     cache_fresh_trait_pred: &ty::PolyTraitPredicate<'tcx>,\n+                                     candidate: &SelectionResult<'tcx, SelectionCandidate<'tcx>>)\n+                                     -> bool\n+    {\n+        // In general, it's a good idea to cache results, even\n+        // ambigious ones, to save us some trouble later. But we have\n+        // to be careful not to cache results that could be\n+        // invalidated later by advances in inference. Normally, this\n+        // is not an issue, because any inference variables whose\n+        // types are not yet bound are \"freshened\" in the cache key,\n+        // which means that if we later get the same request once that\n+        // type variable IS bound, we'll have a different cache key.\n+        // For example, if we have `Vec<_#0t> : Foo`, and `_#0t` is\n+        // not yet known, we may cache the result as `None`. But if\n+        // later `_#0t` is bound to `Bar`, then when we freshen we'll\n+        // have `Vec<Bar> : Foo` as the cache key.\n+        //\n+        // HOWEVER, it CAN happen that we get an ambiguity result in\n+        // one particular case around closures where the cache key\n+        // would not change. That is when the precise types of the\n+        // upvars that a closure references have not yet been figured\n+        // out (i.e., because it is not yet known if they are captured\n+        // by ref, and if by ref, what kind of ref). In these cases,\n+        // when matching a builtin bound, we will yield back an\n+        // ambiguous result. But the *cache key* is just the closure type,\n+        // it doesn't capture the state of the upvar computation.\n+        //\n+        // To avoid this trap, just don't cache ambiguous results if\n+        // the self-type contains no inference byproducts (that really\n+        // shouldn't happen in other circumstances anyway, given\n+        // coherence).\n+\n+        match *candidate {\n+            Ok(Some(_)) | Err(_) => true,\n+            Ok(None) => {\n+                cache_fresh_trait_pred.0.input_types().iter().any(|&t| ty::type_has_ty_infer(t))\n+            }\n+        }\n+    }\n+\n     fn assemble_candidates<'o>(&mut self,\n                                stack: &TraitObligationStack<'o, 'tcx>)\n                                -> Result<SelectionCandidateSet<'tcx>, SelectionError<'tcx>>\n@@ -788,6 +833,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // FIXME(#20297) -- being strict about this can cause\n                 // inference failures with BorrowFrom, which is\n                 // unfortunate. Can we do better here?\n+                debug!(\"assemble_candidates_for_projected_tys: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return;\n             }\n@@ -962,6 +1008,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let (closure_def_id, substs) = match self_ty.sty {\n             ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n             ty::ty_infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_unboxed_closure_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true;\n                 return Ok(());\n             }\n@@ -1000,6 +1047,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n         match self_ty.sty {\n             ty::ty_infer(ty::TyVar(_)) => {\n+                debug!(\"assemble_fn_pointer_candidates: ambiguous self-type\");\n                 candidates.ambiguous = true; // could wind up being a fn() type\n             }\n \n@@ -1270,7 +1318,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(())\n             }\n             Ok(ParameterBuiltin) => { Ok(()) }\n-            Ok(AmbiguousBuiltin) => { Ok(candidates.ambiguous = true) }\n+            Ok(AmbiguousBuiltin) => {\n+                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n+                Ok(candidates.ambiguous = true)\n+            }\n             Err(e) => { Err(e) }\n         }\n     }\n@@ -1476,6 +1527,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         Ok(If(upvars.iter().map(|c| c.ty).collect()))\n                     }\n                     None => {\n+                        debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n                         Ok(AmbiguousBuiltin)\n                     }\n                 }\n@@ -1512,6 +1564,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 // Unbound type variable. Might or might not have\n                 // applicable impls and so forth, depending on what\n                 // those type variables wind up being bound to.\n+                debug!(\"assemble_builtin_bound_candidates: ambiguous builtin\");\n                 Ok(AmbiguousBuiltin)\n             }\n "}, {"sha": "151173b3a40850b55df8a3a8b686cd27ee1a8e70", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -22,8 +22,7 @@ use self::UndoLog::*;\n \n use std::mem;\n \n-#[derive(PartialEq)]\n-pub enum UndoLog<T,U> {\n+pub enum UndoLog<D:SnapshotVecDelegate> {\n     /// Indicates where a snapshot started.\n     OpenSnapshot,\n \n@@ -34,15 +33,15 @@ pub enum UndoLog<T,U> {\n     NewElem(uint),\n \n     /// Variable with given index was changed *from* the given value.\n-    SetElem(uint, T),\n+    SetElem(uint, D::Value),\n \n     /// Extensible set of actions\n-    Other(U)\n+    Other(D::Undo)\n }\n \n-pub struct SnapshotVec<T,U,D> {\n-    values: Vec<T>,\n-    undo_log: Vec<UndoLog<T,U>>,\n+pub struct SnapshotVec<D:SnapshotVecDelegate> {\n+    values: Vec<D::Value>,\n+    undo_log: Vec<UndoLog<D>>,\n     delegate: D\n }\n \n@@ -53,12 +52,15 @@ pub struct Snapshot {\n     length: uint,\n }\n \n-pub trait SnapshotVecDelegate<T,U> {\n-    fn reverse(&mut self, values: &mut Vec<T>, action: U);\n+pub trait SnapshotVecDelegate {\n+    type Value;\n+    type Undo;\n+\n+    fn reverse(&mut self, values: &mut Vec<Self::Value>, action: Self::Undo);\n }\n \n-impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n-    pub fn new(delegate: D) -> SnapshotVec<T,U,D> {\n+impl<D:SnapshotVecDelegate> SnapshotVec<D> {\n+    pub fn new(delegate: D) -> SnapshotVec<D> {\n         SnapshotVec {\n             values: Vec::new(),\n             undo_log: Vec::new(),\n@@ -70,13 +72,13 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         !self.undo_log.is_empty()\n     }\n \n-    pub fn record(&mut self, action: U) {\n+    pub fn record(&mut self, action: D::Undo) {\n         if self.in_snapshot() {\n             self.undo_log.push(Other(action));\n         }\n     }\n \n-    pub fn push(&mut self, elem: T) -> uint {\n+    pub fn push(&mut self, elem: D::Value) -> uint {\n         let len = self.values.len();\n         self.values.push(elem);\n \n@@ -87,20 +89,20 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n         len\n     }\n \n-    pub fn get<'a>(&'a self, index: uint) -> &'a T {\n+    pub fn get<'a>(&'a self, index: uint) -> &'a D::Value {\n         &self.values[index]\n     }\n \n     /// Returns a mutable pointer into the vec; whatever changes you make here cannot be undone\n     /// automatically, so you should be sure call `record()` with some sort of suitable undo\n     /// action.\n-    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut T {\n+    pub fn get_mut<'a>(&'a mut self, index: uint) -> &'a mut D::Value {\n         &mut self.values[index]\n     }\n \n     /// Updates the element at the given index. The old value will saved (and perhaps restored) if\n     /// a snapshot is active.\n-    pub fn set(&mut self, index: uint, new_elem: T) {\n+    pub fn set(&mut self, index: uint, new_elem: D::Value) {\n         let old_elem = mem::replace(&mut self.values[index], new_elem);\n         if self.in_snapshot() {\n             self.undo_log.push(SetElem(index, old_elem));\n@@ -115,7 +117,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n \n     pub fn actions_since_snapshot(&self,\n                                   snapshot: &Snapshot)\n-                                  -> &[UndoLog<T,U>] {\n+                                  -> &[UndoLog<D>] {\n         &self.undo_log[snapshot.length..]\n     }\n "}, {"sha": "8188835718cd61456f7db35c5148b43dc8b7fc81", "filename": "src/librustc_typeck/check/demand.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdemand.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -60,7 +60,8 @@ pub fn coerce<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n     debug!(\"demand::coerce(expected = {}, expr_ty = {})\",\n            expected.repr(fcx.ccx.tcx),\n            expr_ty.repr(fcx.ccx.tcx));\n-    let expected = fcx.infcx().resolve_type_vars_if_possible(&expected);\n+    let expr_ty = fcx.resolve_type_vars_if_possible(expr_ty);\n+    let expected = fcx.resolve_type_vars_if_possible(expected);\n     match fcx.mk_assignty(expr, expr_ty, expected) {\n       Ok(()) => { /* ok */ }\n       Err(ref err) => {"}, {"sha": "09b65bcb1fc25d5fc2d232ee8c8c1bd77ab12702", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -1242,6 +1242,36 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.ccx.tcx.sess.err_count() - self.err_count_on_creation\n     }\n \n+    /// Resolves type variables in `ty` if possible. Unlike the infcx\n+    /// version, this version will also select obligations if it seems\n+    /// useful, in an effort to get more type information.\n+    fn resolve_type_vars_if_possible(&self, mut ty: Ty<'tcx>) -> Ty<'tcx> {\n+        // No ty::infer()? Nothing needs doing.\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If `ty` is a type variable, see whether we already know what it is.\n+        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If not, try resolving any new fcx obligations that have cropped up.\n+        vtable::select_new_fcx_obligations(self);\n+        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n+        if !ty::type_has_ty_infer(ty) {\n+            return ty;\n+        }\n+\n+        // If not, try resolving *all* pending obligations as much as\n+        // possible. This can help substantially when there are\n+        // indirect dependencies that don't seem worth tracking\n+        // precisely.\n+        vtable::select_fcx_obligations_where_possible(self);\n+        self.infcx().resolve_type_vars_if_possible(&ty)\n+    }\n+\n     /// Resolves all type variables in `t` and then, if any were left\n     /// unresolved, substitutes an error type. This is used after the\n     /// main checking when doing a second pass before writeback. The\n@@ -2333,9 +2363,9 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         let check_blocks = *check_blocks;\n         debug!(\"check_blocks={}\", check_blocks);\n \n-        // More awful hacks: before we check the blocks, try to do\n-        // an \"opportunistic\" vtable resolution of any trait\n-        // bounds on the call.\n+        // More awful hacks: before we check argument types, try to do\n+        // an \"opportunistic\" vtable resolution of any trait bounds on\n+        // the call. This helps coercions.\n         if check_blocks {\n             vtable::select_new_fcx_obligations(fcx);\n         }\n@@ -2875,7 +2905,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             // Shift is a special case: rhs must be uint, no matter what lhs is\n             check_expr(fcx, &**rhs);\n             let rhs_ty = fcx.expr_ty(&**rhs);\n-            let rhs_ty = fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+            let rhs_ty = structurally_resolved_type(fcx, rhs.span, rhs_ty);\n             if ty::type_is_integral(rhs_ty) {\n                 fcx.write_ty(expr.id, lhs_t);\n             } else {\n@@ -5127,21 +5157,12 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n // Resolves `typ` by a single level if `typ` is a type variable.  If no\n // resolution is possible, then an error is reported.\n-pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>, sp: Span,\n-                                            mut ty: Ty<'tcx>) -> Ty<'tcx> {\n-    // If `ty` is a type variable, see whether we already know what it is.\n-    ty = fcx.infcx().shallow_resolve(ty);\n-\n-    // If not, try resolve pending fcx obligations. Those can shed light.\n-    //\n-    // FIXME(#18391) -- This current strategy can lead to bad performance in\n-    // extreme cases.  We probably ought to smarter in general about\n-    // only resolving when we need help and only resolving obligations\n-    // will actually help.\n-    if ty::type_is_ty_var(ty) {\n-        vtable::select_fcx_obligations_where_possible(fcx);\n-        ty = fcx.infcx().shallow_resolve(ty);\n-    }\n+pub fn structurally_resolved_type<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                            sp: Span,\n+                                            ty: Ty<'tcx>)\n+                                            -> Ty<'tcx>\n+{\n+    let mut ty = fcx.resolve_type_vars_if_possible(ty);\n \n     // If not, error.\n     if ty::type_is_ty_var(ty) {"}, {"sha": "b388b6a28e340a30eb714d28ef0dc7757b1ed8e9", "filename": "src/test/compile-fail/associated-type-projection-from-supertrait.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-supertrait.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -40,8 +40,8 @@ impl Car for ModelU { }\n \n fn dent<C:Car>(c: C, color: C::Color) { c.chip_paint(color) }\n fn a() { dent(ModelT, Black); }\n-fn b() { dent(ModelT, Blue); } //~ ERROR type mismatch\n-fn c() { dent(ModelU, Black); } //~ ERROR type mismatch\n+fn b() { dent(ModelT, Blue); } //~ ERROR mismatched types\n+fn c() { dent(ModelU, Black); } //~ ERROR mismatched types\n fn d() { dent(ModelU, Blue); }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "55ba65d6102bee85f1d5c20db8fb9407c98598a2", "filename": "src/test/compile-fail/associated-types-path-2.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types-path-2.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -25,7 +25,7 @@ pub fn f2<T: Foo>(a: T) -> T::A {\n \n pub fn f1_int_int() {\n     f1(2is, 4is);\n-    //~^ ERROR type mismatch resolving\n+    //~^ ERROR mismatched types\n     //~| expected usize\n     //~| found isize\n }\n@@ -51,8 +51,6 @@ pub fn f2_int() {\n     //~^ ERROR mismatched types\n     //~| expected `isize`\n     //~| found `usize`\n-    //~| expected isize\n-    //~| found usize\n }\n \n pub fn main() { }"}, {"sha": "f3b2b3d5667a398bbb85b4f925fc56335770f475", "filename": "src/test/compile-fail/issue-18400.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-18400.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -32,5 +32,8 @@ fn main() {\n     let bits: &[_] = &[0, 1];\n \n     0.contains(bits);\n-//~^ ERROR the trait `Set<_>` is not implemented for the type `_`\n+    //~^ ERROR overflow\n+    //~| ERROR overflow\n+    //~| ERROR overflow\n+    //~| ERROR mismatched types\n }"}, {"sha": "45b7fbbd0b46a614b28d85b0292ea34911616d5e", "filename": "src/test/compile-fail/issue-21160.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-21160.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -16,6 +16,6 @@ impl Bar {\n \n #[derive(Hash)]\n struct Foo(Bar);\n-//~^ error: the trait `core::hash::Hash<__S>` is not implemented for the type `Bar`\n+//~^ error: the trait `core::hash::Hash<_>` is not implemented for the type `Bar`\n \n fn main() {}"}, {"sha": "901ae1d5e2ab1584e6d3053ee7d36942be4c019d", "filename": "src/test/compile-fail/shift-various-bad-types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fshift-various-bad-types.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -29,7 +29,7 @@ fn foo(p: &Panolpy) {\n     // known to be an integer, but meh.\n     let x;\n     22 >> x;\n-    //~^ ERROR right-hand-side of a shift operation must have integral type\n+    //~^ ERROR the type of this value must be known in this context\n \n     22 >> 1;\n     // Integer literal types are OK"}, {"sha": "e6acc32545178734bb080c908b3bca3b7c24de0d", "filename": "src/test/compile-fail/slice-mut.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fslice-mut.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -13,9 +13,10 @@\n fn main() {\n     let x: &[isize] = &[1, 2, 3, 4, 5];\n     // Immutable slices are not mutable.\n+\n     let y: &mut[_] = &x[2..4];\n     //~^ ERROR mismatched types\n     //~| expected `&mut [_]`\n-    //~| found `&_`\n+    //~| found `&[isize]`\n     //~| values differ in mutability\n }"}, {"sha": "2e29a61846edafaaaa3a39d267235564489860b3", "filename": "src/test/compile-fail/traits-multidispatch-bad.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftraits-multidispatch-bad.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -26,7 +26,7 @@ where T : Convert<U>\n }\n \n fn a() {\n-    test(22is, 44is); //~ ERROR not implemented\n+    test(22is, 44is); //~ ERROR mismatched types\n }\n \n fn main() {}"}, {"sha": "26a0abc76aee2a668fa4d38e4a801e2fdcc2adf2", "filename": "src/test/run-pass/into-iterator-type-inference-shift.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Finto-iterator-type-inference-shift.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -0,0 +1,41 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for type inference failure around shifting. In this\n+// case, the iteration yields an int, but we hadn't run the full type\n+// propagation yet, and so we just saw a type variable, yielding an\n+// error.\n+\n+use std::u8;\n+\n+trait IntoIterator {\n+    type Iter: Iterator;\n+\n+    fn into_iter(self) -> Self::Iter;\n+}\n+\n+impl<I> IntoIterator for I where I: Iterator {\n+    type Iter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+fn desugared_for_loop_bad(byte: u8) -> u8 {\n+    let mut result = 0;\n+    let mut x = IntoIterator::into_iter(range(0, u8::BITS));\n+    let mut y = Iterator::next(&mut x);\n+    let mut z = y.unwrap();\n+    byte >> z;\n+    1\n+}\n+\n+fn main() {}"}, {"sha": "04017da977535604c6ffcec7d462bc26fb54d069", "filename": "src/test/run-pass/issue-19499.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Frun-pass%2Fissue-19499.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Frun-pass%2Fissue-19499.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-19499.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #19499. Due to incorrect caching of trait\n+// results for closures with upvars whose types were not fully\n+// computed, this rather bizarre little program (along with many more\n+// reasonable examples) let to ambiguity errors about not being able\n+// to infer sufficient type information.\n+\n+fn main() {\n+    let n = 0;\n+    let it = Some(1_us).into_iter().inspect(|_| {n;});\n+}"}, {"sha": "9205b247e1352e0edcb5b85a69824000b0e3a776", "filename": "src/test/run-pass/issue-21245.rs", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Frun-pass%2Fissue-21245.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92ff8ea52816982ad4cbfac8168e216d32d74c77/src%2Ftest%2Frun-pass%2Fissue-21245.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-21245.rs?ref=92ff8ea52816982ad4cbfac8168e216d32d74c77", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #21245. Check that we are able to infer\n+// the types in these examples correctly. It used to be that\n+// insufficient type propagation caused the type of the iterator to be\n+// incorrectly unified with the `*const` type to which it is coerced.\n+\n+use std::ptr;\n+\n+trait IntoIterator {\n+    type Iter: Iterator;\n+\n+    fn into_iter(self) -> Self::Iter;\n+}\n+\n+impl<I> IntoIterator for I where I: Iterator {\n+    type Iter = I;\n+\n+    fn into_iter(self) -> I {\n+        self\n+    }\n+}\n+\n+fn desugared_for_loop_bad<T>(v: Vec<T>) {\n+    match IntoIterator::into_iter(v.iter()) {\n+        mut iter => {\n+            loop {\n+                match ::std::iter::Iterator::next(&mut iter) {\n+                    ::std::option::Option::Some(x) => {\n+                        unsafe { ptr::read(x); }\n+                    },\n+                    ::std::option::Option::None => break\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn desugared_for_loop_good<T>(v: Vec<T>) {\n+    match v.iter().into_iter() {\n+        mut iter => {\n+            loop {\n+                match ::std::iter::Iterator::next(&mut iter) {\n+                    ::std::option::Option::Some(x) => {\n+                        unsafe { ptr::read(x); }\n+                    },\n+                    ::std::option::Option::None => break\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn main() {}"}]}