{"sha": "2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "node_id": "C_kwDOAAsO6NoAKDJlN2UxN2E4NGFiZWE4ZjRjM2UyZDk1Y2U0MzJlZjc4NGFmMDZiZWY", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-03T17:12:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-03T17:12:17Z"}, "message": "Rollup merge of #102439 - fmease:rustdoc-simplify-cross-crate-trait-bounds, r=GuillaumeGomez\n\nrustdoc: re-sugar more cross-crate trait bounds\n\nPreviously, we would only ever re-sugar cross-crate predicates like `Type: Trait, <Type as Trait>::Name == Rhs` to `Type: Trait<Name = Rhs>` if the `Type` was a generic parameter like `Self` or `T`. With this PR, `Type` can be any type.\n\nMost notably, this means that we now re-sugar predicates involving associated types (where `Type` is of the form `Self::Name`) which are then picked up by the pre-existing logic that re-sugars them into bounds. As a result of that, the associated type `IntoIter` of `std`'s `IntoIterator` trait (re-exported from `core`) is no longer rendered as:\n\n```rust\ntype IntoIter: Iterator\nwhere\n    <Self::IntoIter as Iterator>::Item == Self::Item;\n```\n\nbut as one would expect: `type IntoIter: Iterator<Item = Self::Item>;`.\n\nCross-crate closure bounds like `F: Fn(i32) -> bool` are now also rendered properly (previously, the return type (`Self::Output`) would not be rendered and we would show the underlying equality predicate).\n\nFixes #77763.\nFixes #84579.\nFixes #102142.\n\n`@rustbot` label T-rustdoc A-cross-crate-reexports\nr? rustdoc", "tree": {"sha": "6ed48fc9816df9eee3bde078a2526d6100bb9365", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ed48fc9816df9eee3bde078a2526d6100bb9365"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjOxfxCRBK7hj4Ov3rIwAAqWEIAKw9wNni9dP51OhpjG7aC+e0\nmj2ZqPsk3qADSxdBxVbYaBe2nNoymORuY/EZAJafjfbLw27zoecf/7s0oQaar4+d\nlUWFYSONRO2GSHv48wkPUjAMAoFSNaT8g8BydehxA6p8AWeP7wJ8HCXjCnugOCKh\nKCfgNprzSNs+kM0LyEyR9BG5nt5V6AtVZhucFQS+PPRERSpcAStZlyAzui1DrEkR\nGv5SO2liBNAWtsc3QfqlRYy/K9d4WRTv0lnn6ZT7pBeI8ktpMyNuvGdAIE8riaXE\ndjM35oF8OG0zTK74vVMiU4EfxdalRe7inZ7v8bjaCUfFDoKihDu/t+9z8ptcbE0=\n=lHA3\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ed48fc9816df9eee3bde078a2526d6100bb9365\nparent 33d351972ad9c43bc30e87edd2765de9a4898629\nparent a5402343f60271c7e428bb6e6aac704bd88bb2bf\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1664817137 +0200\ncommitter GitHub <noreply@github.com> 1664817137 +0200\n\nRollup merge of #102439 - fmease:rustdoc-simplify-cross-crate-trait-bounds, r=GuillaumeGomez\n\nrustdoc: re-sugar more cross-crate trait bounds\n\nPreviously, we would only ever re-sugar cross-crate predicates like `Type: Trait, <Type as Trait>::Name == Rhs` to `Type: Trait<Name = Rhs>` if the `Type` was a generic parameter like `Self` or `T`. With this PR, `Type` can be any type.\n\nMost notably, this means that we now re-sugar predicates involving associated types (where `Type` is of the form `Self::Name`) which are then picked up by the pre-existing logic that re-sugars them into bounds. As a result of that, the associated type `IntoIter` of `std`'s `IntoIterator` trait (re-exported from `core`) is no longer rendered as:\n\n```rust\ntype IntoIter: Iterator\nwhere\n    <Self::IntoIter as Iterator>::Item == Self::Item;\n```\n\nbut as one would expect: `type IntoIter: Iterator<Item = Self::Item>;`.\n\nCross-crate closure bounds like `F: Fn(i32) -> bool` are now also rendered properly (previously, the return type (`Self::Output`) would not be rendered and we would show the underlying equality predicate).\n\nFixes #77763.\nFixes #84579.\nFixes #102142.\n\n`@rustbot` label T-rustdoc A-cross-crate-reexports\nr? rustdoc\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "html_url": "https://github.com/rust-lang/rust/commit/2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33d351972ad9c43bc30e87edd2765de9a4898629", "url": "https://api.github.com/repos/rust-lang/rust/commits/33d351972ad9c43bc30e87edd2765de9a4898629", "html_url": "https://github.com/rust-lang/rust/commit/33d351972ad9c43bc30e87edd2765de9a4898629"}, {"sha": "a5402343f60271c7e428bb6e6aac704bd88bb2bf", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5402343f60271c7e428bb6e6aac704bd88bb2bf", "html_url": "https://github.com/rust-lang/rust/commit/a5402343f60271c7e428bb6e6aac704bd88bb2bf"}], "stats": {"total": 130, "additions": 107, "deletions": 23}, "files": [{"sha": "c61175ecebf36ef8312d13634eb2585c466ecf2c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "patch": "@@ -1176,6 +1176,15 @@ pub(crate) fn clean_middle_assoc_item<'tcx>(\n             }\n \n             if let ty::TraitContainer = assoc_item.container {\n+                // FIXME(fmease): `tcx.explicit_item_bounds` does not contain the bounds of GATs,\n+                //                e.g. the bounds `Copy`, `Display` & (implicitly) `Sized` in\n+                //                `type Assoc<T: Copy> where T: Display`. This also means that we\n+                //                later incorrectly render `where T: ?Sized`.\n+                //\n+                //                The result of `tcx.explicit_predicates_of` *does* contain them but\n+                //                it does not contain the other bounds / predicates we need.\n+                //                Either merge those two interned lists somehow or refactor\n+                //                `clean_ty_generics` to call `explicit_item_bounds` by itself.\n                 let bounds = tcx.explicit_item_bounds(assoc_item.def_id);\n                 let predicates = ty::GenericPredicates { parent: None, predicates: bounds };\n                 let mut generics ="}, {"sha": "f82ea8969ab4461f296d2fd59f859b671cedd36b", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "patch": "@@ -14,7 +14,6 @@\n use rustc_data_structures::fx::FxIndexMap;\n use rustc_hir::def_id::DefId;\n use rustc_middle::ty;\n-use rustc_span::Symbol;\n \n use crate::clean;\n use crate::clean::GenericArgs as PP;\n@@ -26,21 +25,17 @@ pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     //\n     // We use `FxIndexMap` so that the insertion order is preserved to prevent messing up to\n     // the order of the generated bounds.\n-    let mut params: FxIndexMap<Symbol, (Vec<_>, Vec<_>)> = FxIndexMap::default();\n+    let mut tybounds = FxIndexMap::default();\n     let mut lifetimes = Vec::new();\n     let mut equalities = Vec::new();\n-    let mut tybounds = Vec::new();\n \n     for clause in clauses {\n         match clause {\n-            WP::BoundPredicate { ty, bounds, bound_params } => match ty {\n-                clean::Generic(s) => {\n-                    let (b, p) = params.entry(s).or_default();\n-                    b.extend(bounds);\n-                    p.extend(bound_params);\n-                }\n-                t => tybounds.push((t, (bounds, bound_params))),\n-            },\n+            WP::BoundPredicate { ty, bounds, bound_params } => {\n+                let (b, p): &mut (Vec<_>, Vec<_>) = tybounds.entry(ty).or_default();\n+                b.extend(bounds);\n+                p.extend(bound_params);\n+            }\n             WP::RegionPredicate { lifetime, bounds } => {\n                 lifetimes.push((lifetime, bounds));\n             }\n@@ -49,14 +44,17 @@ pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     }\n \n     // Look for equality predicates on associated types that can be merged into\n-    // general bound predicates\n+    // general bound predicates.\n     equalities.retain(|&(ref lhs, ref rhs)| {\n-        let Some((self_, trait_did, name)) = lhs.projection() else {\n-            return true;\n-        };\n-        let clean::Generic(generic) = self_ else { return true };\n-        let Some((bounds, _)) = params.get_mut(generic) else { return true };\n-\n+        let Some((ty, trait_did, name)) = lhs.projection() else { return true; };\n+        // FIXME(fmease): We don't handle HRTBs correctly here.\n+        //                Pass `_bound_params` (higher-rank lifetimes) to a modified version of\n+        //                `merge_bounds`. That vector is currently always empty though since we\n+        //                don't keep track of late-bound lifetimes when cleaning projection\n+        //                predicates to cleaned equality predicates while we should first query\n+        //                them with `collect_referenced_late_bound_regions` and then store them\n+        //                (or something similar). For prior art, see `clean::auto_trait`.\n+        let Some((bounds, _bound_params)) = tybounds.get_mut(ty) else { return true };\n         merge_bounds(cx, bounds, trait_did, name, rhs)\n     });\n \n@@ -65,11 +63,6 @@ pub(crate) fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses.extend(\n         lifetimes.into_iter().map(|(lt, bounds)| WP::RegionPredicate { lifetime: lt, bounds }),\n     );\n-    clauses.extend(params.into_iter().map(|(k, (bounds, params))| WP::BoundPredicate {\n-        ty: clean::Generic(k),\n-        bounds,\n-        bound_params: params,\n-    }));\n     clauses.extend(tybounds.into_iter().map(|(ty, (bounds, bound_params))| WP::BoundPredicate {\n         ty,\n         bounds,"}, {"sha": "927a1a42a1f784bf77870265537784d3c59284c2", "filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds_with_bindings.out0.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out0.html", "raw_url": "https://github.com/rust-lang/rust/raw/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out0.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out0.html?ref=2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "patch": "@@ -0,0 +1 @@\n+<h4 class=\"code-header\">type <a href=\"#associatedtype.Out0\" class=\"associatedtype\">Out0</a>: <a class=\"trait\" href=\"../assoc_item_trait_bounds_with_bindings/trait.Support.html\" title=\"trait assoc_item_trait_bounds_with_bindings::Support\">Support</a>&lt;Item = <a class=\"primitive\" href=\"{{channel}}/std/primitive.unit.html\">()</a>&gt;</h4>\n\\ No newline at end of file"}, {"sha": "69d84e1b2c14e88ab373bb4989caa78b30f5d209", "filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds_with_bindings.out9.html", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out9.html", "raw_url": "https://github.com/rust-lang/rust/raw/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out9.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.out9.html?ref=2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "patch": "@@ -0,0 +1 @@\n+<h4 class=\"code-header\">type <a href=\"#associatedtype.Out9\" class=\"associatedtype\">Out9</a>: <a class=\"trait\" href=\"{{channel}}/core/ops/function/trait.FnMut.html\" title=\"trait core::ops::function::FnMut\">FnMut</a>(<a class=\"primitive\" href=\"{{channel}}/std/primitive.i32.html\">i32</a>) -&gt; <a class=\"primitive\" href=\"{{channel}}/std/primitive.bool.html\">bool</a> + <a class=\"trait\" href=\"{{channel}}/core/clone/trait.Clone.html\" title=\"trait core::clone::Clone\">Clone</a></h4>\n\\ No newline at end of file"}, {"sha": "b026f399a56676617bd3f58fef3e614fb7313146", "filename": "src/test/rustdoc/inline_cross/assoc_item_trait_bounds_with_bindings.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fassoc_item_trait_bounds_with_bindings.rs?ref=2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "patch": "@@ -0,0 +1,40 @@\n+// Regression test for issues #77763, #84579 and #102142.\n+#![crate_name = \"main\"]\n+\n+// aux-build:assoc_item_trait_bounds_with_bindings.rs\n+// build-aux-docs\n+// ignore-cross-compile\n+extern crate assoc_item_trait_bounds_with_bindings as aux;\n+\n+// FIXME(fmease): Don't render an incorrect `T: ?Sized` where-clause for parameters\n+//                of GATs like `Main::Out{2,4}`. Add a snapshot test once it's fixed.\n+// FIXME(fmease): Print the `for<>` parameter list in the bounds of\n+//                `Main::Out{6,11,12}`.\n+\n+// @has main/trait.Main.html\n+// @has - '//*[@id=\"associatedtype.Out0\"]' 'type Out0: Support<Item = ()>'\n+// @has - '//*[@id=\"associatedtype.Out1\"]' 'type Out1: Support<Item = Self::Item>'\n+// @has - '//*[@id=\"associatedtype.Out2\"]' 'type Out2<T>: Support<Item = T>'\n+// @has - '//*[@id=\"associatedtype.Out3\"]' 'type Out3: Support<Produce<()> = bool>'\n+// @has - '//*[@id=\"associatedtype.Out4\"]' 'type Out4<T>: Support<Produce<T> = T>'\n+// @has - '//*[@id=\"associatedtype.Out5\"]' \"type Out5: Support<Output<'static> = &'static ()>\"\n+// @has - '//*[@id=\"associatedtype.Out6\"]' \"type Out6: Support<Output<'a> = &'a ()>\"\n+// @has - '//*[@id=\"associatedtype.Out7\"]' \"type Out7: Support<Item = String, Produce<i32> = u32> + Unrelated\"\n+// @has - '//*[@id=\"associatedtype.Out8\"]' \"type Out8: Unrelated + Protocol<i16, Q1 = u128, Q0 = ()>\"\n+// @has - '//*[@id=\"associatedtype.Out9\"]' \"type Out9: FnMut(i32) -> bool + Clone\"\n+// @has - '//*[@id=\"associatedtype.Out10\"]' \"type Out10<'q>: Support<Output<'q> = ()>\"\n+// @has - '//*[@id=\"associatedtype.Out11\"]' \"type Out11: Helper<A<'s> = &'s (), B<'r> = ()>\"\n+// @has - '//*[@id=\"associatedtype.Out12\"]' \"type Out12: Helper<B<'w> = Cow<'w, str>, A<'w> = bool>\"\n+//\n+// Snapshots: Check that we do not render any where-clauses for those associated types since all of\n+// the trait bounds contained within were moved to the bounds of the respective item.\n+//\n+// @snapshot out0 - '//*[@id=\"associatedtype.Out0\"]/*[@class=\"code-header\"]'\n+// @snapshot out9 - '//*[@id=\"associatedtype.Out9\"]/*[@class=\"code-header\"]'\n+//\n+// @has - '//*[@id=\"tymethod.make\"]' \\\n+// \"fn make<F>(F, impl FnMut(&str) -> bool)\\\n+// where \\\n+//     F: FnOnce(u32) -> String, \\\n+//     Self::Out2<()>: Protocol<u8, Q0 = Self::Item, Q1 = ()>\"\n+pub use aux::Main;"}, {"sha": "7225f2dca10dbb82445ed1ab0e911370c4a32ee3", "filename": "src/test/rustdoc/inline_cross/auxiliary/assoc_item_trait_bounds_with_bindings.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fassoc_item_trait_bounds_with_bindings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e7e17a84abea8f4c3e2d95ce432ef784af06bef/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fassoc_item_trait_bounds_with_bindings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Finline_cross%2Fauxiliary%2Fassoc_item_trait_bounds_with_bindings.rs?ref=2e7e17a84abea8f4c3e2d95ce432ef784af06bef", "patch": "@@ -0,0 +1,40 @@\n+pub trait Main {\n+    type Item;\n+\n+    type Out0: Support<Item = ()>;\n+    type Out1: Support<Item = Self::Item>;\n+    type Out2<T>: Support<Item = T>;\n+    type Out3: Support<Produce<()> = bool>;\n+    type Out4<T>: Support<Produce<T> = T>;\n+    type Out5: Support<Output<'static> = &'static ()>;\n+    type Out6: for<'a> Support<Output<'a> = &'a ()>;\n+    type Out7: Support<Item = String, Produce<i32> = u32> + Unrelated;\n+    type Out8: Unrelated + Protocol<i16, Q1 = u128, Q0 = ()>;\n+    type Out9: FnMut(i32) -> bool + Clone;\n+    type Out10<'q>: Support<Output<'q> = ()>;\n+    type Out11: for<'r, 's> Helper<A<'s> = &'s (), B<'r> = ()>;\n+    type Out12: for<'w> Helper<B<'w> = std::borrow::Cow<'w, str>, A<'w> = bool>;\n+\n+    fn make<F>(_: F, _: impl FnMut(&str) -> bool)\n+    where\n+        F: FnOnce(u32) -> String,\n+        Self::Out2<()>: Protocol<u8, Q0 = Self::Item, Q1 = ()>;\n+}\n+\n+pub trait Support {\n+    type Item;\n+    type Output<'a>;\n+    type Produce<T>;\n+}\n+\n+pub trait Protocol<K> {\n+    type Q0;\n+    type Q1;\n+}\n+\n+pub trait Unrelated {}\n+\n+pub trait Helper {\n+    type A<'q>;\n+    type B<'q>;\n+}"}]}