{"sha": "65a714a6a0848d5604e1d5f847a06e196951e669", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1YTcxNGE2YTA4NDhkNTYwNGUxZDVmODQ3YTA2ZTE5Njk1MWU2Njk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-13T16:11:07Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2019-07-15T09:42:07Z"}, "message": "pprust: Move some methods to the `PrintState` trait\n\nSo that path and macro argument printing code can be shared", "tree": {"sha": "3c8e7499bee15a77ac65d07e5a8dbca25cdca54b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3c8e7499bee15a77ac65d07e5a8dbca25cdca54b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/65a714a6a0848d5604e1d5f847a06e196951e669", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/65a714a6a0848d5604e1d5f847a06e196951e669", "html_url": "https://github.com/rust-lang/rust/commit/65a714a6a0848d5604e1d5f847a06e196951e669", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/65a714a6a0848d5604e1d5f847a06e196951e669/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9bb855cda0c5ae97faf5dbf1cd4935dd37fad066", "url": "https://api.github.com/repos/rust-lang/rust/commits/9bb855cda0c5ae97faf5dbf1cd4935dd37fad066", "html_url": "https://github.com/rust-lang/rust/commit/9bb855cda0c5ae97faf5dbf1cd4935dd37fad066"}], "stats": {"total": 291, "additions": 144, "deletions": 147}, "files": [{"sha": "3e571baaa4e518397c02e99ec985873466a39e00", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/65a714a6a0848d5604e1d5f847a06e196951e669/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a714a6a0848d5604e1d5f847a06e196951e669/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=65a714a6a0848d5604e1d5f847a06e196951e669", "patch": "@@ -4,7 +4,7 @@ use syntax::source_map::{SourceMap, Spanned};\n use syntax::parse::ParseSess;\n use syntax::print::pp::{self, Breaks};\n use syntax::print::pp::Breaks::{Consistent, Inconsistent};\n-use syntax::print::pprust::{Comments, PrintState};\n+use syntax::print::pprust::{self, Comments, PrintState};\n use syntax::symbol::kw;\n use syntax::util::parser::{self, AssocOp, Fixity};\n use syntax_pos::{self, BytePos, FileName};\n@@ -90,6 +90,15 @@ impl<'a> PrintState<'a> for State<'a> {\n     fn comments(&mut self) -> &mut Option<Comments<'a>> {\n         &mut self.comments\n     }\n+\n+    fn print_ident(&mut self, ident: ast::Ident) {\n+        self.s.word(pprust::ast_ident_to_string(ident, ident.is_raw_guess()));\n+        self.ann.post(self, AnnNode::Name(&ident.name))\n+    }\n+\n+    fn print_generic_args(&mut self, args: &ast::GenericArgs, _colons_before_params: bool) {\n+        span_bug!(args.span(), \"AST generic args printed by HIR pretty-printer\");\n+    }\n }\n \n pub const INDENT_UNIT: usize = 4;\n@@ -1442,15 +1451,6 @@ impl<'a> State<'a> {\n         self.s.word(i.to_string())\n     }\n \n-    pub fn print_ident(&mut self, ident: ast::Ident) {\n-        if ident.is_raw_guess() {\n-            self.s.word(format!(\"r#{}\", ident.name));\n-        } else {\n-            self.s.word(ident.as_str().to_string());\n-        }\n-        self.ann.post(self, AnnNode::Name(&ident.name))\n-    }\n-\n     pub fn print_name(&mut self, name: ast::Name) {\n         self.print_ident(ast::Ident::with_empty_ctxt(name))\n     }"}, {"sha": "5f3d691400bf2366b6c5751a5bc579d801b5f69a", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 132, "deletions": 135, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/65a714a6a0848d5604e1d5f847a06e196951e669/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/65a714a6a0848d5604e1d5f847a06e196951e669/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=65a714a6a0848d5604e1d5f847a06e196951e669", "patch": "@@ -188,7 +188,7 @@ pub fn literal_to_string(lit: token::Lit) -> String {\n }\n \n /// Print an ident from AST, `$crate` is converted into its respective crate name.\n-fn ast_ident_to_string(ident: ast::Ident, is_raw: bool) -> String {\n+pub fn ast_ident_to_string(ident: ast::Ident, is_raw: bool) -> String {\n     ident_to_string(ident.name, is_raw, Some(ident.span))\n }\n \n@@ -446,6 +446,8 @@ impl std::ops::DerefMut for State<'_> {\n \n pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefMut {\n     fn comments(&mut self) -> &mut Option<Comments<'a>>;\n+    fn print_ident(&mut self, ident: ast::Ident);\n+    fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool);\n \n     fn commasep<T, F>(&mut self, b: Breaks, elts: &[T], mut op: F)\n         where F: FnMut(&mut Self, &T),\n@@ -596,17 +598,6 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n         }\n     }\n \n-    fn print_attribute_path(&mut self, path: &ast::Path) {\n-        for (i, segment) in path.segments.iter().enumerate() {\n-            if i > 0 {\n-                self.word(\"::\");\n-            }\n-            if segment.ident.name != kw::PathRoot {\n-                self.word(ast_ident_to_string(segment.ident, segment.ident.is_raw_guess()));\n-            }\n-        }\n-    }\n-\n     fn print_attribute(&mut self, attr: &ast::Attribute) {\n         self.print_attribute_inline(attr, false)\n     }\n@@ -628,7 +619,7 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n             if let Some(mi) = attr.meta() {\n                 self.print_meta_item(&mi);\n             } else {\n-                self.print_attribute_path(&attr.path);\n+                self.print_path(&attr.path, false, 0);\n                 self.space();\n                 self.print_tts(attr.tokens.clone(), true);\n             }\n@@ -650,15 +641,15 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n     fn print_meta_item(&mut self, item: &ast::MetaItem) {\n         self.ibox(INDENT_UNIT);\n         match item.node {\n-            ast::MetaItemKind::Word => self.print_attribute_path(&item.path),\n+            ast::MetaItemKind::Word => self.print_path(&item.path, false, 0),\n             ast::MetaItemKind::NameValue(ref value) => {\n-                self.print_attribute_path(&item.path);\n+                self.print_path(&item.path, false, 0);\n                 self.space();\n                 self.word_space(\"=\");\n                 self.print_literal(value);\n             }\n             ast::MetaItemKind::List(ref items) => {\n-                self.print_attribute_path(&item.path);\n+                self.print_path(&item.path, false, 0);\n                 self.popen();\n                 self.commasep(Consistent,\n                               &items[..],\n@@ -707,16 +698,56 @@ pub trait PrintState<'a>: std::ops::Deref<Target=pp::Printer> + std::ops::DerefM\n         }\n         self.end();\n     }\n-}\n \n-impl<'a> PrintState<'a> for State<'a> {\n-    fn comments(&mut self) -> &mut Option<Comments<'a>> {\n-        &mut self.comments\n+    fn print_mac_common(\n+        &mut self,\n+        path: &ast::Path,\n+        has_bang: bool,\n+        tts: TokenStream,\n+        delim: MacDelimiter,\n+        span: Span,\n+    ) {\n+        self.print_path(path, false, 0);\n+        if has_bang {\n+            self.word(\"!\");\n+        }\n+        match delim {\n+            MacDelimiter::Parenthesis => self.popen(),\n+            MacDelimiter::Bracket => self.word(\"[\"),\n+            MacDelimiter::Brace => {\n+                self.head(\"\");\n+                self.bopen();\n+            }\n+        }\n+        self.print_tts(tts, true);\n+        match delim {\n+            MacDelimiter::Parenthesis => self.pclose(),\n+            MacDelimiter::Bracket => self.word(\"]\"),\n+            MacDelimiter::Brace => self.bclose(span),\n+        }\n     }\n-}\n \n-impl<'a> State<'a> {\n-    crate fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n+    fn print_path(&mut self, path: &ast::Path, colons_before_params: bool, depth: usize) {\n+        self.maybe_print_comment(path.span.lo());\n+\n+        for (i, segment) in path.segments[..path.segments.len() - depth].iter().enumerate() {\n+            if i > 0 {\n+                self.word(\"::\")\n+            }\n+            self.print_path_segment(segment, colons_before_params);\n+        }\n+    }\n+\n+    fn print_path_segment(&mut self, segment: &ast::PathSegment, colons_before_params: bool) {\n+        if segment.ident.name != kw::PathRoot {\n+            self.print_ident(segment.ident);\n+            if let Some(ref args) = segment.args {\n+                self.print_generic_args(args, colons_before_params);\n+            }\n+        }\n+    }\n+\n+    fn head<S: Into<Cow<'static, str>>>(&mut self, w: S) {\n         let w = w.into();\n         // outer-box is consistent\n         self.cbox(INDENT_UNIT);\n@@ -728,36 +759,103 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn bopen(&mut self) {\n-        self.s.word(\"{\");\n+    fn bopen(&mut self) {\n+        self.word(\"{\");\n         self.end(); // close the head-box\n     }\n \n-    crate fn bclose_maybe_open(&mut self, span: syntax_pos::Span, close_box: bool) {\n+    fn bclose_maybe_open(&mut self, span: syntax_pos::Span, close_box: bool) {\n         self.maybe_print_comment(span.hi());\n         self.break_offset_if_not_bol(1, -(INDENT_UNIT as isize));\n-        self.s.word(\"}\");\n+        self.word(\"}\");\n         if close_box {\n             self.end(); // close the outer-box\n         }\n     }\n-    crate fn bclose(&mut self, span: syntax_pos::Span) {\n+\n+    fn bclose(&mut self, span: syntax_pos::Span) {\n         self.bclose_maybe_open(span, true)\n     }\n \n-    crate fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n-        if !self.s.is_beginning_of_line() {\n-            self.s.break_offset(n, off)\n+    fn break_offset_if_not_bol(&mut self, n: usize, off: isize) {\n+        if !self.is_beginning_of_line() {\n+            self.break_offset(n, off)\n         } else {\n-            if off != 0 && self.s.last_token().is_hardbreak_tok() {\n+            if off != 0 && self.last_token().is_hardbreak_tok() {\n                 // We do something pretty sketchy here: tuck the nonzero\n                 // offset-adjustment we were going to deposit along with the\n                 // break into the previous hardbreak.\n-                self.s.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n+                self.replace_last_token(pp::Printer::hardbreak_tok_offset(off));\n             }\n         }\n     }\n+}\n \n+impl<'a> PrintState<'a> for State<'a> {\n+    fn comments(&mut self) -> &mut Option<Comments<'a>> {\n+        &mut self.comments\n+    }\n+\n+    fn print_ident(&mut self, ident: ast::Ident) {\n+        self.s.word(ast_ident_to_string(ident, ident.is_raw_guess()));\n+        self.ann.post(self, AnnNode::Ident(&ident))\n+    }\n+\n+    fn print_generic_args(&mut self, args: &ast::GenericArgs, colons_before_params: bool) {\n+        if colons_before_params {\n+            self.s.word(\"::\")\n+        }\n+\n+        match *args {\n+            ast::GenericArgs::AngleBracketed(ref data) => {\n+                self.s.word(\"<\");\n+\n+                self.commasep(Inconsistent, &data.args, |s, generic_arg| {\n+                    s.print_generic_arg(generic_arg)\n+                });\n+\n+                let mut comma = data.args.len() != 0;\n+\n+                for constraint in data.constraints.iter() {\n+                    if comma {\n+                        self.word_space(\",\")\n+                    }\n+                    self.print_ident(constraint.ident);\n+                    self.s.space();\n+                    match constraint.kind {\n+                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n+                            self.word_space(\"=\");\n+                            self.print_type(ty);\n+                        }\n+                        ast::AssocTyConstraintKind::Bound { ref bounds } => {\n+                            self.print_type_bounds(\":\", &*bounds);\n+                        }\n+                    }\n+                    comma = true;\n+                }\n+\n+                self.s.word(\">\")\n+            }\n+\n+            ast::GenericArgs::Parenthesized(ref data) => {\n+                self.s.word(\"(\");\n+                self.commasep(\n+                    Inconsistent,\n+                    &data.inputs,\n+                    |s, ty| s.print_type(ty));\n+                self.s.word(\")\");\n+\n+                if let Some(ref ty) = data.output {\n+                    self.space_if_not_bol();\n+                    self.word_space(\"->\");\n+                    self.print_type(ty);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl<'a> State<'a> {\n     // Synthesizes a comment that was not textually present in the original source\n     // file.\n     pub fn synth_comment(&mut self, text: String) {\n@@ -1645,22 +1743,7 @@ impl<'a> State<'a> {\n     }\n \n     crate fn print_mac(&mut self, m: &ast::Mac) {\n-        self.print_path(&m.node.path, false, 0);\n-        self.s.word(\"!\");\n-        match m.node.delim {\n-            MacDelimiter::Parenthesis => self.popen(),\n-            MacDelimiter::Bracket => self.s.word(\"[\"),\n-            MacDelimiter::Brace => {\n-                self.head(\"\");\n-                self.bopen();\n-            }\n-        }\n-        self.print_tts(m.node.stream(), true);\n-        match m.node.delim {\n-            MacDelimiter::Parenthesis => self.pclose(),\n-            MacDelimiter::Bracket => self.s.word(\"]\"),\n-            MacDelimiter::Brace => self.bclose(m.span),\n-        }\n+        self.print_mac_common(&m.node.path, true, m.node.stream(), m.node.delim, m.span);\n     }\n \n \n@@ -2204,11 +2287,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    crate fn print_ident(&mut self, ident: ast::Ident) {\n-        self.s.word(ast_ident_to_string(ident, ident.is_raw_guess()));\n-        self.ann.post(self, AnnNode::Ident(&ident))\n-    }\n-\n     crate fn print_usize(&mut self, i: usize) {\n         self.s.word(i.to_string())\n     }\n@@ -2218,31 +2296,6 @@ impl<'a> State<'a> {\n         self.ann.post(self, AnnNode::Name(&name))\n     }\n \n-    fn print_path(&mut self,\n-                  path: &ast::Path,\n-                  colons_before_params: bool,\n-                  depth: usize) {\n-        self.maybe_print_comment(path.span.lo());\n-\n-        for (i, segment) in path.segments[..path.segments.len() - depth].iter().enumerate() {\n-            if i > 0 {\n-                self.s.word(\"::\")\n-            }\n-            self.print_path_segment(segment, colons_before_params);\n-        }\n-    }\n-\n-    fn print_path_segment(&mut self,\n-                          segment: &ast::PathSegment,\n-                          colons_before_params: bool) {\n-        if segment.ident.name != kw::PathRoot {\n-            self.print_ident(segment.ident);\n-            if let Some(ref args) = segment.args {\n-                self.print_generic_args(args, colons_before_params);\n-            }\n-        }\n-    }\n-\n     fn print_qpath(&mut self,\n                    path: &ast::Path,\n                    qself: &ast::QSelf,\n@@ -2266,62 +2319,6 @@ impl<'a> State<'a> {\n         }\n     }\n \n-    fn print_generic_args(&mut self,\n-                          args: &ast::GenericArgs,\n-                          colons_before_params: bool)\n-    {\n-        if colons_before_params {\n-            self.s.word(\"::\")\n-        }\n-\n-        match *args {\n-            ast::GenericArgs::AngleBracketed(ref data) => {\n-                self.s.word(\"<\");\n-\n-                self.commasep(Inconsistent, &data.args, |s, generic_arg| {\n-                    s.print_generic_arg(generic_arg)\n-                });\n-\n-                let mut comma = data.args.len() != 0;\n-\n-                for constraint in data.constraints.iter() {\n-                    if comma {\n-                        self.word_space(\",\")\n-                    }\n-                    self.print_ident(constraint.ident);\n-                    self.s.space();\n-                    match constraint.kind {\n-                        ast::AssocTyConstraintKind::Equality { ref ty } => {\n-                            self.word_space(\"=\");\n-                            self.print_type(ty);\n-                        }\n-                        ast::AssocTyConstraintKind::Bound { ref bounds } => {\n-                            self.print_type_bounds(\":\", &*bounds);\n-                        }\n-                    }\n-                    comma = true;\n-                }\n-\n-                self.s.word(\">\")\n-            }\n-\n-            ast::GenericArgs::Parenthesized(ref data) => {\n-                self.s.word(\"(\");\n-                self.commasep(\n-                    Inconsistent,\n-                    &data.inputs,\n-                    |s, ty| s.print_type(ty));\n-                self.s.word(\")\");\n-\n-                if let Some(ref ty) = data.output {\n-                    self.space_if_not_bol();\n-                    self.word_space(\"->\");\n-                    self.print_type(ty);\n-                }\n-            }\n-        }\n-    }\n-\n     crate fn print_pat(&mut self, pat: &ast::Pat) {\n         self.maybe_print_comment(pat.span.lo());\n         self.ann.pre(self, AnnNode::Pat(pat));"}, {"sha": "bd839d35421993cec5cc6011d8c0a62bceb838a9", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/65a714a6a0848d5604e1d5f847a06e196951e669/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/65a714a6a0848d5604e1d5f847a06e196951e669/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=65a714a6a0848d5604e1d5f847a06e196951e669", "patch": "@@ -29,8 +29,8 @@\n \n \n \n-                  (($crate::fmt::format as\n-                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<$crate::fmt::Arguments>::new_v1\n+                  ((::alloc::fmt::format as\n+                       for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<::std::fmt::Arguments>::new_v1\n                                                                                                            as\n                                                                                                            fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n                                                                                                                                                                                                                             as"}]}