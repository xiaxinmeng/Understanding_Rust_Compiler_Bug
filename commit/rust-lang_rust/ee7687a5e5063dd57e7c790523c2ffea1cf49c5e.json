{"sha": "ee7687a5e5063dd57e7c790523c2ffea1cf49c5e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlNzY4N2E1ZTUwNjNkZDU3ZTdjNzkwNTIzYzJmZmVhMWNmNDljNWU=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-08T12:40:04Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2016-03-17T19:51:54Z"}, "message": "mir: Reintroduce the temporary block after invokes, to handle critical edges.", "tree": {"sha": "ea805e7ba0fa995106917d4728b6d47725d434a4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea805e7ba0fa995106917d4728b6d47725d434a4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee7687a5e5063dd57e7c790523c2ffea1cf49c5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7687a5e5063dd57e7c790523c2ffea1cf49c5e", "html_url": "https://github.com/rust-lang/rust/commit/ee7687a5e5063dd57e7c790523c2ffea1cf49c5e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee7687a5e5063dd57e7c790523c2ffea1cf49c5e/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41fc5f7c2a046952dc624c0617a73c14a37b5940", "url": "https://api.github.com/repos/rust-lang/rust/commits/41fc5f7c2a046952dc624c0617a73c14a37b5940", "html_url": "https://github.com/rust-lang/rust/commit/41fc5f7c2a046952dc624c0617a73c14a37b5940"}], "stats": {"total": 107, "additions": 59, "deletions": 48}, "files": [{"sha": "ac57cd843aab3d4f0c028e244643b66d6ed3825f", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 59, "deletions": 48, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ee7687a5e5063dd57e7c790523c2ffea1cf49c5e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee7687a5e5063dd57e7c790523c2ffea1cf49c5e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=ee7687a5e5063dd57e7c790523c2ffea1cf49c5e", "patch": "@@ -218,63 +218,74 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 let fn_ptr = callee.reify(bcx.ccx()).val;\n \n                 // Many different ways to call a function handled here\n-                match (cleanup, destination) {\n-                    // The two cases below are the only ones to use LLVM\u2019s `invoke`.\n-                    (&Some(cleanup), &None) => {\n-                        let cleanup = self.bcx(cleanup);\n-                        let landingpad = self.make_landing_pad(cleanup);\n-                        let unreachable_blk = self.unreachable_block();\n-                        let cs = bcx.invoke(fn_ptr,\n-                                            &llargs,\n-                                            unreachable_blk.llbb,\n-                                            landingpad.llbb(),\n-                                            cleanup_bundle.as_ref());\n-                        fn_ty.apply_attrs_callsite(cs);\n-                        landingpad.at_start(|bcx| for op in args {\n-                            self.set_operand_dropped(bcx, op);\n-                        });\n-                    },\n-                    (&Some(cleanup), &Some((_, success))) => {\n-                        let cleanup = self.bcx(cleanup);\n-                        let landingpad = self.make_landing_pad(cleanup);\n-                        let invokeret = bcx.invoke(fn_ptr,\n-                                                   &llargs,\n-                                                   self.llblock(success),\n-                                                   landingpad.llbb(),\n-                                                   cleanup_bundle.as_ref());\n-                        fn_ty.apply_attrs_callsite(invokeret);\n+                if let Some(cleanup) = cleanup.map(|bb| self.bcx(bb)) {\n+                    // We translate the copy into a temporary block. The temporary block is\n+                    // necessary because the current block has already been terminated (by\n+                    // `invoke`) and we cannot really translate into the target block\n+                    // because:\n+                    //  * The target block may have more than a single precedesor;\n+                    //  * Some LLVM insns cannot have a preceeding store insn (phi,\n+                    //    cleanuppad), and adding/prepending the store now may render\n+                    //    those other instructions invalid.\n+                    //\n+                    // NB: This approach still may break some LLVM code. For example if the\n+                    // target block starts with a `phi` (which may only match on immediate\n+                    // precedesors), it cannot know about this temporary block thus\n+                    // resulting in an invalid code:\n+                    //\n+                    // this:\n+                    //     \u2026\n+                    //     %0 = \u2026\n+                    //     %1 = invoke to label %temp \u2026\n+                    // temp:\n+                    //     store ty %1, ty* %dest\n+                    //     br label %actualtargetblock\n+                    // actualtargetblock:            ; preds: %temp, \u2026\n+                    //     phi \u2026 [%this, \u2026], [%0, \u2026] ; ERROR: phi requires to match only on\n+                    //                               ; immediate precedesors\n+\n+                    let ret_bcx = if destination.is_some() {\n+                        self.fcx.new_block(\"\", None)\n+                    } else {\n+                        self.unreachable_block()\n+                    };\n+                    let landingpad = self.make_landing_pad(cleanup);\n+\n+                    let invokeret = bcx.invoke(fn_ptr,\n+                                               &llargs,\n+                                               ret_bcx.llbb,\n+                                               landingpad.llbb(),\n+                                               cleanup_bundle.as_ref());\n+                    fn_ty.apply_attrs_callsite(invokeret);\n+\n+                    landingpad.at_start(|bcx| for op in args {\n+                        self.set_operand_dropped(bcx, op);\n+                    });\n+\n+                    if let Some((_, target)) = *destination {\n+                        let ret_bcx = ret_bcx.build();\n                         if let Some(ret_dest) = ret_dest {\n-                            // We translate the copy straight into the beginning of the target\n-                            // block.\n-                            self.bcx(success).at_start(|bcx| bcx.with_block( |bcx| {\n-                                fn_ty.ret.store(bcx, invokeret, ret_dest.llval);\n-                            }));\n+                            fn_ty.ret.store(&ret_bcx, invokeret, ret_dest.llval);\n                         }\n-                        self.bcx(success).at_start(|bcx| for op in args {\n-                            self.set_operand_dropped(bcx, op);\n-                        });\n-                        landingpad.at_start(|bcx| for op in args {\n-                            self.set_operand_dropped(bcx, op);\n-                        });\n-                    },\n-                    (&None, &None) => {\n-                        let cs = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n-                        fn_ty.apply_attrs_callsite(cs);\n-                        // no need to drop args, because the call never returns\n-                        bcx.unreachable();\n+                        for op in args {\n+                            self.set_operand_dropped(&ret_bcx, op);\n+                        }\n+                        ret_bcx.br(self.llblock(target));\n                     }\n-                    (&None, &Some((_, target))) => {\n-                        let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n-                        fn_ty.apply_attrs_callsite(llret);\n+                } else {\n+                    let llret = bcx.call(fn_ptr, &llargs, cleanup_bundle.as_ref());\n+                    fn_ty.apply_attrs_callsite(llret);\n+                    if let Some((_, target)) = *destination {\n                         if let Some(ret_dest) = ret_dest {\n-                            bcx.with_block(|bcx| {\n-                                fn_ty.ret.store(bcx, llret, ret_dest.llval);\n-                            });\n+                            fn_ty.ret.store(&bcx, llret, ret_dest.llval);\n                         }\n                         for op in args {\n                             self.set_operand_dropped(&bcx, op);\n                         }\n                         funclet_br(bcx, self.llblock(target));\n+                    } else {\n+                        // no need to drop args, because the call never returns\n+                        bcx.unreachable();\n                     }\n                 }\n             }"}]}