{"sha": "ecc18f34446cdecd42004be62805f84799733e72", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjYzE4ZjM0NDQ2Y2RlY2Q0MjAwNGJlNjI4MDVmODQ3OTk3MzNlNzI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-05T12:36:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-05-05T12:36:37Z"}, "message": "auto merge of #13749 : pnkfelix/rust/add-libgraphviz-crate, r=alexcrichton\n\nAdd a `graphviz` crate for making .dot files to layout and render graphs.\r\n\r\n(This is a precursor to other work to render control-flow graphs from within rustc itself; but this crate should be independently usable, since it abstracts over the client's graph-representation and labeling method.)", "tree": {"sha": "9812edf2ce8e24e2b772a45e0dc582c2487236d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9812edf2ce8e24e2b772a45e0dc582c2487236d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecc18f34446cdecd42004be62805f84799733e72", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecc18f34446cdecd42004be62805f84799733e72", "html_url": "https://github.com/rust-lang/rust/commit/ecc18f34446cdecd42004be62805f84799733e72", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecc18f34446cdecd42004be62805f84799733e72/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8895f252417495b423796807ba180eb59da5a1c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/8895f252417495b423796807ba180eb59da5a1c1", "html_url": "https://github.com/rust-lang/rust/commit/8895f252417495b423796807ba180eb59da5a1c1"}, {"sha": "67307d4e0864fa9a7de42e1d8bd55f67f251520b", "url": "https://api.github.com/repos/rust-lang/rust/commits/67307d4e0864fa9a7de42e1d8bd55f67f251520b", "html_url": "https://github.com/rust-lang/rust/commit/67307d4e0864fa9a7de42e1d8bd55f67f251520b"}], "stats": {"total": 890, "additions": 889, "deletions": 1}, "files": [{"sha": "bc8567d3c9565fe4936afffe04ffe59a1315e5f2", "filename": "mk/crates.mk", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecc18f34446cdecd42004be62805f84799733e72/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/ecc18f34446cdecd42004be62805f84799733e72/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=ecc18f34446cdecd42004be62805f84799733e72", "patch": "@@ -51,7 +51,7 @@\n \n TARGET_CRATES := libc std green rustuv native flate arena glob term semver \\\n                  uuid serialize sync getopts collections num test time rand \\\n-\t\t workcache url log regex\n+\t\t workcache url log regex graphviz\n HOST_CRATES := syntax rustc rustdoc fourcc hexfloat regex_macros\n CRATES := $(TARGET_CRATES) $(HOST_CRATES)\n TOOLS := compiletest rustdoc rustc\n@@ -67,6 +67,7 @@ DEPS_rustdoc := rustc native:sundown serialize sync getopts collections \\\n                 test time\n DEPS_flate := std native:miniz\n DEPS_arena := std collections\n+DEPS_graphviz := std\n DEPS_glob := std\n DEPS_serialize := std collections log\n DEPS_term := std collections"}, {"sha": "afe29ea2e070db19f8561807be706bccba63d989", "filename": "src/libgraphviz/lib.rs", "status": "added", "additions": 755, "deletions": 0, "changes": 755, "blob_url": "https://github.com/rust-lang/rust/blob/ecc18f34446cdecd42004be62805f84799733e72/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc18f34446cdecd42004be62805f84799733e72/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=ecc18f34446cdecd42004be62805f84799733e72", "patch": "@@ -0,0 +1,755 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*! Generate files suitable for use with [Graphviz](http://www.graphviz.org/)\n+\n+The `render` function generates output (e.g. an `output.dot` file) for\n+use with [Graphviz](http://www.graphviz.org/) by walking a labelled\n+graph. (Graphviz can then automatically lay out the nodes and edges\n+of the graph, and also optionally render the graph as an image or\n+other [output formats](\n+http://www.graphviz.org/content/output-formats), such as SVG.)\n+\n+Rather than impose some particular graph data structure on clients,\n+this library exposes two traits that clients can implement on their\n+own structs before handing them over to the rendering function.\n+\n+Note: This library does not yet provide access to the full\n+expressiveness of the [DOT language](\n+http://www.graphviz.org/doc/info/lang.html). For example, there are\n+many [attributes](http://www.graphviz.org/content/attrs) related to\n+providing layout hints (e.g. left-to-right versus top-down, which\n+algorithm to use, etc). The current intention of this library is to\n+emit a human-readable .dot file with very regular structure suitable\n+for easy post-processing.\n+\n+# Examples\n+\n+The first example uses a very simple graph representation: a list of\n+pairs of ints, representing the edges (the node set is implicit).\n+Each node label is derived directly from the int representing the node,\n+while the edge labels are all empty strings.\n+\n+This example also illustrates how to use `MaybeOwnedVector` to return\n+an owned vector or a borrowed slice as appropriate: we construct the\n+node vector from scratch, but borrow the edge list (rather than\n+constructing a copy of all the edges from scratch).\n+\n+The output from this example renders five nodes, with the first four\n+forming a diamond-shaped acyclic graph and then pointing to the fifth\n+which is cyclic.\n+\n+```rust\n+use dot = graphviz;\n+use graphviz::maybe_owned_vec::IntoMaybeOwnedVector;\n+\n+type Nd = int;\n+type Ed = (int,int);\n+struct Edges(Vec<Ed>);\n+\n+pub fn main() {\n+    use std::io::File;\n+    let edges = Edges(vec!((0,1), (0,2), (1,3), (2,3), (3,4), (4,4)));\n+    let mut f = File::create(&Path::new(\"example1.dot\"));\n+    dot::render(&edges, &mut f).unwrap()\n+}\n+\n+impl<'a> dot::Labeller<'a, Nd, Ed> for Edges {\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example1\") }\n+\n+    fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n+        dot::Id::new(format!(\"N{}\", *n))\n+    }\n+}\n+\n+impl<'a> dot::GraphWalk<'a, Nd, Ed> for Edges {\n+    fn nodes(&self) -> dot::Nodes<'a,Nd> {\n+        // (assumes that |N| \\approxeq |E|)\n+        let &Edges(ref v) = self;\n+        let mut nodes = Vec::with_capacity(v.len());\n+        for &(s,t) in v.iter() {\n+            nodes.push(s); nodes.push(t);\n+        }\n+        nodes.sort();\n+        nodes.dedup();\n+        nodes.into_maybe_owned()\n+    }\n+\n+    fn edges(&'a self) -> dot::Edges<'a,Ed> {\n+        let &Edges(ref edges) = self;\n+        edges.as_slice().into_maybe_owned()\n+    }\n+\n+    fn source(&self, e: &Ed) -> Nd { let &(s,_) = e; s }\n+\n+    fn target(&self, e: &Ed) -> Nd { let &(_,t) = e; t }\n+}\n+```\n+\n+Output from first example (in `example1.dot`):\n+\n+```ignore\n+digraph example1 {\n+    N0[label=\"N0\"];\n+    N1[label=\"N1\"];\n+    N2[label=\"N2\"];\n+    N3[label=\"N3\"];\n+    N4[label=\"N4\"];\n+    N0 -> N1[label=\"\"];\n+    N0 -> N2[label=\"\"];\n+    N1 -> N3[label=\"\"];\n+    N2 -> N3[label=\"\"];\n+    N3 -> N4[label=\"\"];\n+    N4 -> N4[label=\"\"];\n+}\n+```\n+\n+The second example illustrates using `node_label` and `edge_label` to\n+add labels to the nodes and edges in the rendered graph. The graph\n+here carries both `nodes` (the label text to use for rendering a\n+particular node), and `edges` (again a list of `(source,target)`\n+indices).\n+\n+This example also illustrates how to use a type (in this case the edge\n+type) that shares substructure with the graph: the edge type here is a\n+direct reference to the `(source,target)` pair stored in the graph's\n+internal vector (rather than passing around a copy of the pair\n+itself). Note that this implies that `fn edges(&'a self)` must\n+construct a fresh `Vec<&'a (uint,uint)>` from the `Vec<(uint,uint)>`\n+edges stored in `self`.\n+\n+Since both the set of nodes and the set of edges are always\n+constructed from scratch via iterators, we use the `collect()` method\n+from the `Iterator` trait to collect the nodes and edges into freshly\n+constructed growable `Vec` values (rather use the `into_maybe_owned`\n+from the `IntoMaybeOwnedVector` trait as was used in the first example\n+above).\n+\n+The output from this example renders four nodes that make up the\n+Hasse-diagram for the subsets of the set `{x, y}`. Each edge is\n+labelled with the &sube; character (specified using the HTML character\n+entity `&sube`).\n+\n+```rust\n+use dot = graphviz;\n+use std::str;\n+use std::io::File;\n+\n+type Nd = uint;\n+type Ed<'a> = &'a (uint, uint);\n+struct Graph { nodes: Vec<&'static str>, edges: Vec<(uint,uint)> }\n+\n+pub fn main() {\n+    let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n+    let edges = vec!((0,1), (0,2), (1,3), (2,3));\n+    let graph = Graph { nodes: nodes, edges: edges };\n+\n+    let mut f = File::create(&Path::new(\"example2.dot\"));\n+    dot::render(&graph, &mut f).unwrap()\n+}\n+\n+impl<'a> dot::Labeller<'a, Nd, Ed<'a>> for Graph {\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example2\") }\n+    fn node_id(&'a self, n: &Nd) -> dot::Id<'a> {\n+        dot::Id::new(format!(\"N{}\", n))\n+    }\n+    fn node_label<'a>(&'a self, n: &Nd) -> dot::LabelText<'a> {\n+        dot::LabelStr(str::Slice(self.nodes.get(*n).as_slice()))\n+    }\n+    fn edge_label<'a>(&'a self, _: &Ed) -> dot::LabelText<'a> {\n+        dot::LabelStr(str::Slice(\"&sube;\"))\n+    }\n+}\n+\n+impl<'a> dot::GraphWalk<'a, Nd, Ed<'a>> for Graph {\n+    fn nodes(&self) -> dot::Nodes<'a,Nd> { range(0,self.nodes.len()).collect() }\n+    fn edges(&'a self) -> dot::Edges<'a,Ed<'a>> { self.edges.iter().collect() }\n+    fn source(&self, e: &Ed) -> Nd { let & &(s,_) = e; s }\n+    fn target(&self, e: &Ed) -> Nd { let & &(_,t) = e; t }\n+}\n+```\n+\n+The third example is similar to the second, except now each node and\n+edge now carries a reference to the string label for each node as well\n+as that node's index. (This is another illustration of how to share\n+structure with the graph itself, and why one might want to do so.)\n+\n+The output from this example is the same as the second example: the\n+Hasse-diagram for the subsets of the set `{x, y}`.\n+\n+```rust\n+use dot = graphviz;\n+use std::str;\n+use std::io::File;\n+\n+type Nd<'a> = (uint, &'a str);\n+type Ed<'a> = (Nd<'a>, Nd<'a>);\n+struct Graph { nodes: Vec<&'static str>, edges: Vec<(uint,uint)> }\n+\n+pub fn main() {\n+    let nodes = vec!(\"{x,y}\",\"{x}\",\"{y}\",\"{}\");\n+    let edges = vec!((0,1), (0,2), (1,3), (2,3));\n+    let graph = Graph { nodes: nodes, edges: edges };\n+\n+    let mut f = File::create(&Path::new(\"example3.dot\"));\n+    dot::render(&graph, &mut f).unwrap()\n+}\n+\n+impl<'a> dot::Labeller<'a, Nd<'a>, Ed<'a>> for Graph {\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(\"example3\") }\n+    fn node_id(&'a self, n: &Nd<'a>) -> dot::Id<'a> {\n+        dot::Id::new(format!(\"N{:u}\", n.val0()))\n+    }\n+    fn node_label<'a>(&'a self, n: &Nd<'a>) -> dot::LabelText<'a> {\n+        let &(i, _) = n;\n+        dot::LabelStr(str::Slice(self.nodes.get(i).as_slice()))\n+    }\n+    fn edge_label<'a>(&'a self, _: &Ed<'a>) -> dot::LabelText<'a> {\n+        dot::LabelStr(str::Slice(\"&sube;\"))\n+    }\n+}\n+\n+impl<'a> dot::GraphWalk<'a, Nd<'a>, Ed<'a>> for Graph {\n+    fn nodes(&'a self) -> dot::Nodes<'a,Nd<'a>> {\n+        self.nodes.iter().map(|s|s.as_slice()).enumerate().collect()\n+    }\n+    fn edges(&'a self) -> dot::Edges<'a,Ed<'a>> {\n+        self.edges.iter()\n+            .map(|&(i,j)|((i, self.nodes.get(i).as_slice()),\n+                          (j, self.nodes.get(j).as_slice())))\n+            .collect()\n+    }\n+    fn source(&self, e: &Ed<'a>) -> Nd<'a> { let &(s,_) = e; s }\n+    fn target(&self, e: &Ed<'a>) -> Nd<'a> { let &(_,t) = e; t }\n+}\n+```\n+\n+# References\n+\n+* [Graphviz](http://www.graphviz.org/)\n+\n+* [DOT language](http://www.graphviz.org/doc/info/lang.html)\n+\n+*/\n+\n+#![crate_id = \"graphviz#0.11-pre\"]\n+#![crate_type = \"rlib\"]\n+#![crate_type = \"dylib\"]\n+#![license = \"MIT/ASL2\"]\n+#![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n+       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n+       html_root_url = \"http://static.rust-lang.org/doc/master\")]\n+\n+#![experimental]\n+\n+use std::io;\n+use std::str;\n+use self::maybe_owned_vec::MaybeOwnedVector;\n+\n+pub mod maybe_owned_vec;\n+\n+/// The text for a graphviz label on a node or edge.\n+pub enum LabelText<'a> {\n+    /// This kind of label preserves the text directly as is.\n+    ///\n+    /// Occurrences of backslashes (`\\`) are escaped, and thus appear\n+    /// as backslashes in the rendered label.\n+    LabelStr(str::MaybeOwned<'a>),\n+\n+    /// This kind of label uses the graphviz label escString type:\n+    /// http://www.graphviz.org/content/attrs#kescString\n+    ///\n+    /// Occurrences of backslashes (`\\`) are not escaped; instead they\n+    /// are interpreted as initiating an escString escape sequence.\n+    ///\n+    /// Escape sequences of particular interest: in addition to `\\n`\n+    /// to break a line (centering the line preceding the `\\n`), there\n+    /// are also the escape sequences `\\l` which left-justifies the\n+    /// preceding line and `\\r` which right-justifies it.\n+    EscStr(str::MaybeOwned<'a>),\n+}\n+\n+// There is a tension in the design of the labelling API.\n+//\n+// For example, I considered making a `Labeller<T>` trait that\n+// provides labels for `T`, and then making the graph type `G`\n+// implement `Labeller<Node>` and `Labeller<Edge>`. However, this is\n+// not possible without functional dependencies. (One could work\n+// around that, but I did not explore that avenue heavily.)\n+//\n+// Another approach that I actually used for a while was to make a\n+// `Label<Context>` trait that is implemented by the client-specific\n+// Node and Edge types (as well as an implementation on Graph itself\n+// for the overall name for the graph). The main disadvantage of this\n+// second approach (compared to having the `G` type parameter\n+// implement a Labelling service) that I have encountered is that it\n+// makes it impossible to use types outside of the current crate\n+// directly as Nodes/Edges; you need to wrap them in newtype'd\n+// structs. See e.g. the `No` and `Ed` structs in the examples. (In\n+// practice clients using a graph in some other crate would need to\n+// provide some sort of adapter shim over the graph anyway to\n+// interface with this library).\n+//\n+// Another approach would be to make a single `Labeller<N,E>` trait\n+// that provides three methods (graph_label, node_label, edge_label),\n+// and then make `G` implement `Labeller<N,E>`. At first this did not\n+// appeal to me, since I had thought I would need separate methods on\n+// each data variant for dot-internal identifiers versus user-visible\n+// labels. However, the identifier/label distinction only arises for\n+// nodes; graphs themselves only have identifiers, and edges only have\n+// labels.\n+//\n+// So in the end I decided to use the third approach described above.\n+\n+/// `Id` is a Graphviz `ID`.\n+pub struct Id<'a> {\n+    name: str::MaybeOwned<'a>,\n+}\n+\n+impl<'a> Id<'a> {\n+    /// Creates an `Id` named `name`.\n+    ///\n+    /// The caller must ensure that the input conforms to an\n+    /// identifier format: it must be a non-empty string made up of\n+    /// alphanumeric or underscore characters, not beginning with a\n+    /// digit (i.e. the regular expression `[a-zA-Z_][a-zA-Z_0-9]*`).\n+    ///\n+    /// (Note: this format is a strict subset of the `ID` format\n+    /// defined by the DOT language.  This function may change in the\n+    /// future to accept a broader subset, or the entirety, of DOT's\n+    /// `ID` format.)\n+    pub fn new<Name:str::IntoMaybeOwned<'a>>(name: Name) -> Id<'a> {\n+        let name = name.into_maybe_owned();\n+        {\n+            let mut chars = name.as_slice().chars();\n+            assert!(is_letter_or_underscore(chars.next().unwrap()));\n+            assert!(chars.all(is_constituent));\n+        }\n+        return Id{ name: name };\n+\n+        fn is_letter_or_underscore(c: char) -> bool {\n+            in_range('a', c, 'z') || in_range('A', c, 'Z') || c == '_'\n+        }\n+        fn is_constituent(c: char) -> bool {\n+            is_letter_or_underscore(c) || in_range('0', c, '9')\n+        }\n+        fn in_range(low: char, c: char, high: char) -> bool {\n+            low as uint <= c as uint && c as uint <= high as uint\n+        }\n+    }\n+\n+    pub fn as_slice(&'a self) -> &'a str {\n+        self.name.as_slice()\n+    }\n+\n+    pub fn name(self) -> str::MaybeOwned<'a> {\n+        self.name\n+    }\n+}\n+\n+/// Each instance of a type that implements `Label<C>` maps to a\n+/// unique identifier with respect to `C`, which is used to identify\n+/// it in the generated .dot file. They can also provide more\n+/// elaborate (and non-unique) label text that is used in the graphviz\n+/// rendered output.\n+\n+/// The graph instance is responsible for providing the DOT compatible\n+/// identifiers for the nodes and (optionally) rendered labels for the nodes and\n+/// edges, as well as an identifier for the graph itself.\n+pub trait Labeller<'a,N,E> {\n+    /// Must return a DOT compatible identifier naming the graph.\n+    fn graph_id(&'a self) -> Id<'a>;\n+\n+    /// Maps `n` to a unique identifier with respect to `self`. The\n+    /// implementor is responsible for ensuring that the returned name\n+    /// is a valid DOT identifier.\n+    fn node_id(&'a self, n: &N) -> Id<'a>;\n+\n+    /// Maps `n` to a label that will be used in the rendered output.\n+    /// The label need not be unique, and may be the empty string; the\n+    /// default is just the output from `node_id`.\n+    fn node_label(&'a self, n: &N) -> LabelText<'a> {\n+        LabelStr(self.node_id(n).name)\n+    }\n+\n+    /// Maps `e` to a label that will be used in the rendered output.\n+    /// The label need not be unique, and may be the empty string; the\n+    /// default is in fact the empty string.\n+    fn edge_label(&'a self, e: &E) -> LabelText<'a> {\n+        let _ignored = e;\n+        LabelStr(str::Slice(\"\"))\n+    }\n+}\n+\n+impl<'a> LabelText<'a> {\n+    fn escape_char(c: char, f: |char|) {\n+        match c {\n+            // not escaping \\\\, since Graphviz escString needs to\n+            // interpret backslashes; see EscStr above.\n+            '\\\\' => f(c),\n+            _ => c.escape_default(f)\n+        }\n+    }\n+    fn escape_str(s: &str) -> StrBuf {\n+        let mut out = StrBuf::with_capacity(s.len());\n+        for c in s.chars() {\n+            LabelText::escape_char(c, |c| out.push_char(c));\n+        }\n+        out\n+    }\n+\n+    /// Renders text as string suitable for a label in a .dot file.\n+    pub fn escape(&self) -> ~str {\n+        match self {\n+            &LabelStr(ref s) => s.as_slice().escape_default(),\n+            &EscStr(ref s) => LabelText::escape_str(s.as_slice()).into_owned(),\n+        }\n+    }\n+}\n+\n+pub type Nodes<'a,N> = MaybeOwnedVector<'a,N>;\n+pub type Edges<'a,E> = MaybeOwnedVector<'a,E>;\n+\n+// (The type parameters in GraphWalk should be associated items,\n+// when/if Rust supports such.)\n+\n+/// GraphWalk is an abstraction over a directed graph = (nodes,edges)\n+/// made up of node handles `N` and edge handles `E`, where each `E`\n+/// can be mapped to its source and target nodes.\n+///\n+/// The lifetime parameter `'a` is exposed in this trait (rather than\n+/// introduced as a generic parameter on each method declaration) so\n+/// that a client impl can choose `N` and `E` that have substructure\n+/// that is bound by the self lifetime `'a`.\n+///\n+/// The `nodes` and `edges` method each return instantiations of\n+/// `MaybeOwnedVector` to leave implementors the freedom to create\n+/// entirely new vectors or to pass back slices into internally owned\n+/// vectors.\n+pub trait GraphWalk<'a, N, E> {\n+    /// Returns all the nodes in this graph.\n+    fn nodes(&'a self) -> Nodes<'a, N>;\n+    /// Returns all of the edges in this graph.\n+    fn edges(&'a self) -> Edges<'a, E>;\n+    /// The source node for `edge`.\n+    fn source(&'a self, edge: &E) -> N;\n+    /// The target node for `edge`.\n+    fn target(&'a self, edge: &E) -> N;\n+}\n+\n+/// Renders directed graph `g` into the writer `w` in DOT syntax.\n+/// (Main entry point for the library.)\n+pub fn render<'a, N, E, G:Labeller<'a,N,E>+GraphWalk<'a,N,E>, W:Writer>(\n+              g: &'a G,\n+              w: &mut W) -> io::IoResult<()>\n+{\n+    fn writeln<W:Writer>(w: &mut W, arg: &[&str]) -> io::IoResult<()> {\n+        for &s in arg.iter() { try!(w.write_str(s)); }\n+        w.write_char('\\n')\n+    }\n+\n+    fn indent<W:Writer>(w: &mut W) -> io::IoResult<()> {\n+        w.write_str(\"    \")\n+    }\n+\n+    try!(writeln(w, [\"digraph \", g.graph_id().as_slice(), \" {\"]));\n+    for n in g.nodes().iter() {\n+        try!(indent(w));\n+        let id = g.node_id(n);\n+        let escaped = g.node_label(n).escape();\n+        try!(writeln(w, [id.as_slice(),\n+                         \"[label=\\\"\", escaped.as_slice(), \"\\\"];\"]));\n+    }\n+\n+    for e in g.edges().iter() {\n+        let escaped_label = g.edge_label(e).escape();\n+        try!(indent(w));\n+        let source = g.source(e);\n+        let target = g.target(e);\n+        let source_id = g.node_id(&source);\n+        let target_id = g.node_id(&target);\n+        try!(writeln(w, [source_id.as_slice(), \" -> \", target_id.as_slice(),\n+                         \"[label=\\\"\", escaped_label.as_slice(), \"\\\"];\"]));\n+    }\n+\n+    writeln(w, [\"}\"])\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::{Id, LabelText, LabelStr, EscStr, Labeller};\n+    use super::{Nodes, Edges, GraphWalk, render};\n+    use std::io::{MemWriter, BufReader, IoResult};\n+    use std::str;\n+\n+    /// each node is an index in a vector in the graph.\n+    type Node = uint;\n+    struct Edge {\n+        from: uint, to: uint, label: &'static str\n+    }\n+\n+    fn Edge(from: uint, to: uint, label: &'static str) -> Edge {\n+        Edge { from: from, to: to, label: label }\n+    }\n+\n+    struct LabelledGraph {\n+        /// The name for this graph. Used for labelling generated `digraph`.\n+        name: &'static str,\n+\n+        /// Each node is an index into `node_labels`; these labels are\n+        /// used as the label text for each node. (The node *names*,\n+        /// which are unique identifiers, are derived from their index\n+        /// in this array.)\n+        ///\n+        /// If a node maps to None here, then just use its name as its\n+        /// text.\n+        node_labels: Vec<Option<&'static str>>,\n+\n+        /// Each edge relates a from-index to a to-index along with a\n+        /// label; `edges` collects them.\n+        edges: Vec<Edge>,\n+    }\n+\n+    // A simple wrapper around LabelledGraph that forces the labels to\n+    // be emitted as EscStr.\n+    struct LabelledGraphWithEscStrs {\n+        graph: LabelledGraph\n+    }\n+\n+    enum NodeLabels<L> {\n+        AllNodesLabelled(Vec<L>),\n+        UnlabelledNodes(uint),\n+        SomeNodesLabelled(Vec<Option<L>>),\n+    }\n+\n+    type Trivial = NodeLabels<&'static str>;\n+\n+    impl NodeLabels<&'static str> {\n+        fn to_opt_strs(self) -> Vec<Option<&'static str>> {\n+            match self {\n+                UnlabelledNodes(len)\n+                    => Vec::from_elem(len, None).move_iter().collect(),\n+                AllNodesLabelled(lbls)\n+                    => lbls.move_iter().map(\n+                        |l|Some(l)).collect(),\n+                SomeNodesLabelled(lbls)\n+                    => lbls.move_iter().collect(),\n+            }\n+        }\n+    }\n+\n+    impl LabelledGraph {\n+        fn new(name: &'static str,\n+               node_labels: Trivial,\n+               edges: Vec<Edge>) -> LabelledGraph {\n+            LabelledGraph {\n+                name: name,\n+                node_labels: node_labels.to_opt_strs(),\n+                edges: edges\n+            }\n+        }\n+    }\n+\n+    impl LabelledGraphWithEscStrs {\n+        fn new(name: &'static str,\n+               node_labels: Trivial,\n+               edges: Vec<Edge>) -> LabelledGraphWithEscStrs {\n+            LabelledGraphWithEscStrs {\n+                graph: LabelledGraph::new(name, node_labels, edges)\n+            }\n+        }\n+    }\n+\n+    fn id_name<'a>(n: &Node) -> Id<'a> {\n+        Id::new(format!(\"N{:u}\", *n))\n+    }\n+\n+    impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n+        fn graph_id(&'a self) -> Id<'a> {\n+            Id::new(self.name.as_slice())\n+        }\n+        fn node_id(&'a self, n: &Node) -> Id<'a> {\n+            id_name(n)\n+        }\n+        fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n+            match self.node_labels.get(*n) {\n+                &Some(ref l) => LabelStr(str::Slice(l.as_slice())),\n+                &None        => LabelStr(id_name(n).name()),\n+            }\n+        }\n+        fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {\n+            LabelStr(str::Slice(e.label.as_slice()))\n+        }\n+    }\n+\n+    impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraphWithEscStrs {\n+        fn graph_id(&'a self) -> Id<'a> { self.graph.graph_id() }\n+        fn node_id(&'a self, n: &Node) -> Id<'a> { self.graph.node_id(n) }\n+        fn node_label(&'a self, n: &Node) -> LabelText<'a> {\n+            match self.graph.node_label(n) {\n+                LabelStr(s) | EscStr(s) => EscStr(s),\n+            }\n+        }\n+        fn edge_label(&'a self, e: & &'a Edge) -> LabelText<'a> {\n+            match self.graph.edge_label(e) {\n+                LabelStr(s) | EscStr(s) => EscStr(s),\n+            }\n+        }\n+    }\n+\n+    impl<'a> GraphWalk<'a, Node, &'a Edge> for LabelledGraph {\n+        fn nodes(&'a self) -> Nodes<'a,Node> {\n+            range(0u, self.node_labels.len()).collect()\n+        }\n+        fn edges(&'a self) -> Edges<'a,&'a Edge> {\n+            self.edges.iter().collect()\n+        }\n+        fn source(&'a self, edge: & &'a Edge) -> Node {\n+            edge.from\n+        }\n+        fn target(&'a self, edge: & &'a Edge) -> Node {\n+            edge.to\n+        }\n+    }\n+\n+    impl<'a> GraphWalk<'a, Node, &'a Edge> for LabelledGraphWithEscStrs {\n+        fn nodes(&'a self) -> Nodes<'a,Node> {\n+            self.graph.nodes()\n+        }\n+        fn edges(&'a self) -> Edges<'a,&'a Edge> {\n+            self.graph.edges()\n+        }\n+        fn source(&'a self, edge: & &'a Edge) -> Node {\n+            edge.from\n+        }\n+        fn target(&'a self, edge: & &'a Edge) -> Node {\n+            edge.to\n+        }\n+    }\n+\n+    fn test_input(g: LabelledGraph) -> IoResult<~str> {\n+        let mut writer = MemWriter::new();\n+        render(&g, &mut writer).unwrap();\n+        let mut r = BufReader::new(writer.get_ref());\n+        r.read_to_str()\n+    }\n+\n+    // All of the tests use raw-strings as the format for the expected outputs,\n+    // so that you can cut-and-paste the content into a .dot file yourself to\n+    // see what the graphviz visualizer would produce.\n+\n+    #[test]\n+    fn empty_graph() {\n+        let labels : Trivial = UnlabelledNodes(0);\n+        let r = test_input(LabelledGraph::new(\"empty_graph\", labels, vec!()));\n+        assert_eq!(r.unwrap().as_slice(),\n+r#\"digraph empty_graph {\n+}\n+\"#);\n+    }\n+\n+    #[test]\n+    fn single_node() {\n+        let labels : Trivial = UnlabelledNodes(1);\n+        let r = test_input(LabelledGraph::new(\"single_node\", labels, vec!()));\n+        assert_eq!(r.unwrap().as_slice(),\n+r#\"digraph single_node {\n+    N0[label=\"N0\"];\n+}\n+\"#);\n+    }\n+\n+    #[test]\n+    fn single_edge() {\n+        let labels : Trivial = UnlabelledNodes(2);\n+        let result = test_input(LabelledGraph::new(\"single_edge\", labels,\n+                                                   vec!(Edge(0, 1, \"E\"))));\n+        assert_eq!(result.unwrap().as_slice(),\n+r#\"digraph single_edge {\n+    N0[label=\"N0\"];\n+    N1[label=\"N1\"];\n+    N0 -> N1[label=\"E\"];\n+}\n+\"#);\n+    }\n+\n+    #[test]\n+    fn single_cyclic_node() {\n+        let labels : Trivial = UnlabelledNodes(1);\n+        let r = test_input(LabelledGraph::new(\"single_cyclic_node\", labels,\n+                                              vec!(Edge(0, 0, \"E\"))));\n+        assert_eq!(r.unwrap().as_slice(),\n+r#\"digraph single_cyclic_node {\n+    N0[label=\"N0\"];\n+    N0 -> N0[label=\"E\"];\n+}\n+\"#);\n+    }\n+\n+    #[test]\n+    fn hasse_diagram() {\n+        let labels = AllNodesLabelled(vec!(\"{x,y}\", \"{x}\", \"{y}\", \"{}\"));\n+        let r = test_input(LabelledGraph::new(\n+            \"hasse_diagram\", labels,\n+            vec!(Edge(0, 1, \"\"), Edge(0, 2, \"\"),\n+                 Edge(1, 3, \"\"), Edge(2, 3, \"\"))));\n+        assert_eq!(r.unwrap().as_slice(),\n+r#\"digraph hasse_diagram {\n+    N0[label=\"{x,y}\"];\n+    N1[label=\"{x}\"];\n+    N2[label=\"{y}\"];\n+    N3[label=\"{}\"];\n+    N0 -> N1[label=\"\"];\n+    N0 -> N2[label=\"\"];\n+    N1 -> N3[label=\"\"];\n+    N2 -> N3[label=\"\"];\n+}\n+\"#);\n+    }\n+\n+    #[test]\n+    fn left_aligned_text() {\n+        let labels = AllNodesLabelled(vec!(\n+            \"if test {\\\n+           \\\\l    branch1\\\n+           \\\\l} else {\\\n+           \\\\l    branch2\\\n+           \\\\l}\\\n+           \\\\lafterward\\\n+           \\\\l\",\n+            \"branch1\",\n+            \"branch2\",\n+            \"afterward\"));\n+\n+        let mut writer = MemWriter::new();\n+\n+        let g = LabelledGraphWithEscStrs::new(\n+            \"syntax_tree\", labels,\n+            vec!(Edge(0, 1, \"then\"), Edge(0, 2, \"else\"),\n+                 Edge(1, 3, \";\"),    Edge(2, 3, \";\"   )));\n+\n+        render(&g, &mut writer).unwrap();\n+        let mut r = BufReader::new(writer.get_ref());\n+        let r = r.read_to_str();\n+\n+        assert_eq!(r.unwrap().as_slice(),\n+r#\"digraph syntax_tree {\n+    N0[label=\"if test {\\l    branch1\\l} else {\\l    branch2\\l}\\lafterward\\l\"];\n+    N1[label=\"branch1\"];\n+    N2[label=\"branch2\"];\n+    N3[label=\"afterward\"];\n+    N0 -> N1[label=\"then\"];\n+    N0 -> N2[label=\"else\"];\n+    N1 -> N3[label=\";\"];\n+    N2 -> N3[label=\";\"];\n+}\n+\"#);\n+    }\n+}"}, {"sha": "649bad702eaefb34488463a492003a44622d74c9", "filename": "src/libgraphviz/maybe_owned_vec.rs", "status": "added", "additions": 132, "deletions": 0, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/ecc18f34446cdecd42004be62805f84799733e72/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecc18f34446cdecd42004be62805f84799733e72/src%2Flibgraphviz%2Fmaybe_owned_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Fmaybe_owned_vec.rs?ref=ecc18f34446cdecd42004be62805f84799733e72", "patch": "@@ -0,0 +1,132 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::fmt;\n+use std::iter::FromIterator;\n+use std::slice;\n+\n+// Note 1: It is not clear whether the flexibility of providing both\n+// the `Growable` and `FixedLen` variants is sufficiently useful.\n+// Consider restricting to just a two variant enum.\n+\n+// Note 2: Once Dynamically Sized Types (DST) lands, it might be\n+// reasonable to replace this with something like `enum MaybeOwned<'a,\n+// Sized? U>{ Owned(~U), Borrowed(&'a U) }`; and then `U` could be\n+// instantiated with `[T]` or `str`, etc.  Of course, that would imply\n+// removing the `Growable` variant, which relates to note 1 above.\n+// Alternatively, we might add `MaybeOwned` for the general case but\n+// keep some form of `MaybeOwnedVector` to avoid unnecessary copying\n+// of the contents of `Vec<T>`, since we anticipate that to be a\n+// frequent way to dynamically construct a vector.\n+\n+/// MaybeOwnedVector<'a,T> abstracts over `Vec<T>`, `~[T]`, `&'a [T]`.\n+///\n+/// Some clients will have a pre-allocated vector ready to hand off in\n+/// a slice; others will want to create the set on the fly and hand\n+/// off ownership, via either `Growable` or `FixedLen` depending on\n+/// which kind of vector they have constucted.  (The `FixedLen`\n+/// variant is provided for interoperability with `std::slice` methods\n+/// that return `~[T]`.)\n+pub enum MaybeOwnedVector<'a,T> {\n+    Growable(Vec<T>),\n+    FixedLen(~[T]),\n+    Borrowed(&'a [T]),\n+}\n+\n+/// Trait for moving into a `MaybeOwnedVector`\n+pub trait IntoMaybeOwnedVector<'a,T> {\n+    /// Moves self into a `MaybeOwnedVector`\n+    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T>;\n+}\n+\n+impl<'a,T> IntoMaybeOwnedVector<'a,T> for Vec<T> {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Growable(self) }\n+}\n+\n+impl<'a,T> IntoMaybeOwnedVector<'a,T> for ~[T] {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { FixedLen(self) }\n+}\n+\n+impl<'a,T> IntoMaybeOwnedVector<'a,T> for &'a [T] {\n+    #[inline]\n+    fn into_maybe_owned(self) -> MaybeOwnedVector<'a,T> { Borrowed(self) }\n+}\n+\n+impl<'a,T> MaybeOwnedVector<'a,T> {\n+    pub fn iter(&'a self) -> slice::Items<'a,T> {\n+        match self {\n+            &Growable(ref v) => v.iter(),\n+            &FixedLen(ref v) => v.iter(),\n+            &Borrowed(ref v) => v.iter(),\n+        }\n+    }\n+}\n+\n+// The `Vector` trait is provided in the prelude and is implemented on\n+// both `&'a [T]` and `Vec<T>`, so it makes sense to try to support it\n+// seamlessly.  The other vector related traits from the prelude do\n+// not appear to be implemented on both `&'a [T]` and `Vec<T>`.  (It\n+// is possible that this is an oversight in some cases.)\n+//\n+// In any case, with `Vector` in place, the client can just use\n+// `as_slice` if they prefer that over `match`.\n+\n+impl<'b,T> slice::Vector<T> for MaybeOwnedVector<'b,T> {\n+    fn as_slice<'a>(&'a self) -> &'a [T] {\n+        match self {\n+            &Growable(ref v) => v.as_slice(),\n+            &FixedLen(ref v) => v.as_slice(),\n+            &Borrowed(ref v) => v.as_slice(),\n+        }\n+    }\n+}\n+\n+impl<'a,T> FromIterator<T> for MaybeOwnedVector<'a,T> {\n+    fn from_iter<I:Iterator<T>>(iterator: I) -> MaybeOwnedVector<T> {\n+        // If we are building from scratch, might as well build the\n+        // most flexible variant.\n+        Growable(FromIterator::from_iter(iterator))\n+    }\n+}\n+\n+impl<'a,T:fmt::Show> fmt::Show for MaybeOwnedVector<'a,T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        self.as_slice().fmt(f)\n+    }\n+}\n+\n+impl<'a,T:Clone> CloneableVector<T> for MaybeOwnedVector<'a,T> {\n+    /// Returns a copy of `self`.\n+    fn to_owned(&self) -> ~[T] {\n+        self.as_slice().to_owned()\n+    }\n+\n+    /// Convert `self` into an owned slice, not making a copy if possible.\n+    fn into_owned(self) -> ~[T] {\n+        match self {\n+            Growable(v) => v.as_slice().to_owned(),\n+            FixedLen(v) => v,\n+            Borrowed(v) => v.to_owned(),\n+        }\n+    }\n+}\n+\n+impl<'a,T:Clone> MaybeOwnedVector<'a,T> {\n+    /// Convert `self` into a growable `Vec`, not making a copy if possible.\n+    pub fn into_vec(self) -> Vec<T> {\n+        match self {\n+            Growable(v) => v,\n+            FixedLen(v) => Vec::from_slice(v.as_slice()),\n+            Borrowed(v) => Vec::from_slice(v),\n+        }\n+    }\n+}"}]}