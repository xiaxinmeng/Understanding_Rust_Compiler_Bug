{"sha": "6210e82041849bad6129331b9e45ac0bae6fe569", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyMTBlODIwNDE4NDliYWQ2MTI5MzMxYjllNDVhYzBiYWU2ZmU1Njk=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-06T15:47:59Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2019-01-06T23:05:19Z"}, "message": "Use HIR Expr for type inference\n\nNow we can reuse the type inference inside a function when typing whitespace\netc. :)", "tree": {"sha": "43656452729519e45f4aa036372526b2934a230c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/43656452729519e45f4aa036372526b2934a230c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6210e82041849bad6129331b9e45ac0bae6fe569", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6210e82041849bad6129331b9e45ac0bae6fe569", "html_url": "https://github.com/rust-lang/rust/commit/6210e82041849bad6129331b9e45ac0bae6fe569", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6210e82041849bad6129331b9e45ac0bae6fe569/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3c945ceb5e0dc287139de0589cc9a4b285911f17", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c945ceb5e0dc287139de0589cc9a4b285911f17", "html_url": "https://github.com/rust-lang/rust/commit/3c945ceb5e0dc287139de0589cc9a4b285911f17"}], "stats": {"total": 650, "additions": 308, "deletions": 342}, "files": [{"sha": "ef3f4271baa746801b75c5d65af9d5279cdfab0a", "filename": "crates/ra_analysis/src/completion/complete_dot.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -1,3 +1,4 @@\n+use ra_db::LocalSyntaxPtr;\n use ra_syntax::ast::AstNode;\n use hir::{Ty, Def};\n \n@@ -11,11 +12,14 @@ pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) -> Ca\n         _ => return Ok(()),\n     };\n     let infer_result = function.infer(ctx.db)?;\n-    let receiver_ty = if let Some(ty) = infer_result.type_of_node(receiver.syntax()) {\n-        ty\n-    } else {\n-        return Ok(());\n-    };\n+    let syntax_mapping = function.body_syntax_mapping(ctx.db)?;\n+    let expr =\n+        if let Some(expr) = syntax_mapping.syntax_expr(LocalSyntaxPtr::new(receiver.syntax())) {\n+            expr\n+        } else {\n+            return Ok(());\n+        };\n+    let receiver_ty = infer_result[expr].clone();\n     if !ctx.is_method_call {\n         complete_fields(acc, ctx, receiver_ty)?;\n     }"}, {"sha": "067e5c12dd53a7a9ffd98ceeb9e0b72f69d8735f", "filename": "crates/ra_analysis/src/hover.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_analysis%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fhover.rs?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -64,7 +64,14 @@ pub(crate) fn type_of(db: &RootDatabase, frange: FileRange) -> Cancelable<Option\n         parent_fn\n     )?);\n     let infer = function.infer(db)?;\n-    Ok(infer.type_of_node(node).map(|t| t.to_string()))\n+    let syntax_mapping = function.body_syntax_mapping(db)?;\n+    if let Some(expr) = syntax_mapping.node_expr(node) {\n+        Ok(Some(infer[expr].to_string()))\n+    } else if let Some(pat) = syntax_mapping.node_pat(node) {\n+        Ok(Some(infer[pat].to_string()))\n+    } else {\n+        Ok(None)\n+    }\n }\n \n // FIXME: this should not really use navigation target. Rather, approximatelly"}, {"sha": "c87d767359a0eb1450a58e5819407963a12accc0", "filename": "crates/ra_hir/src/expr.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fexpr.rs?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -5,7 +5,7 @@ use rustc_hash::FxHashMap;\n \n use ra_arena::{Arena, RawId, impl_arena_id};\n use ra_db::{LocalSyntaxPtr, Cancelable};\n-use ra_syntax::ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner};\n+use ra_syntax::{SyntaxNodeRef, ast::{self, AstNode, LoopBodyOwner, ArgListOwner, NameOwner}};\n \n use crate::{Path, type_ref::{Mutability, TypeRef}, Name, HirDatabase, DefId, Def, name::AsName};\n \n@@ -77,12 +77,22 @@ impl BodySyntaxMapping {\n     pub fn syntax_expr(&self, ptr: LocalSyntaxPtr) -> Option<ExprId> {\n         self.expr_syntax_mapping.get(&ptr).cloned()\n     }\n+    pub fn node_expr(&self, node: SyntaxNodeRef) -> Option<ExprId> {\n+        self.expr_syntax_mapping\n+            .get(&LocalSyntaxPtr::new(node))\n+            .cloned()\n+    }\n     pub fn pat_syntax(&self, pat: PatId) -> Option<LocalSyntaxPtr> {\n         self.pat_syntax_mapping_back.get(&pat).cloned()\n     }\n     pub fn syntax_pat(&self, ptr: LocalSyntaxPtr) -> Option<PatId> {\n         self.pat_syntax_mapping.get(&ptr).cloned()\n     }\n+    pub fn node_pat(&self, node: SyntaxNodeRef) -> Option<PatId> {\n+        self.pat_syntax_mapping\n+            .get(&LocalSyntaxPtr::new(node))\n+            .cloned()\n+    }\n \n     pub fn body(&self) -> &Arc<Body> {\n         &self.body\n@@ -159,14 +169,20 @@ pub enum Expr {\n         expr: ExprId,\n         op: Option<UnaryOp>,\n     },\n+    BinaryOp {\n+        lhs: ExprId,\n+        rhs: ExprId,\n+        op: Option<BinaryOp>,\n+    },\n     Lambda {\n         args: Vec<PatId>,\n         arg_types: Vec<Option<TypeRef>>,\n         body: ExprId,\n     },\n }\n \n-pub type UnaryOp = ast::PrefixOp;\n+pub use ra_syntax::ast::PrefixOp as UnaryOp;\n+pub use ra_syntax::ast::BinOp as BinaryOp;\n \n #[derive(Debug, Clone, Eq, PartialEq)]\n pub struct MatchArm {\n@@ -266,6 +282,10 @@ impl Expr {\n             Expr::Lambda { body, .. } => {\n                 f(*body);\n             }\n+            Expr::BinaryOp { lhs, rhs, .. } => {\n+                f(*lhs);\n+                f(*rhs);\n+            }\n             Expr::Field { expr, .. }\n             | Expr::Try { expr }\n             | Expr::Cast { expr, .. }\n@@ -586,14 +606,19 @@ impl ExprCollector {\n                     syntax_ptr,\n                 )\n             }\n+            ast::Expr::BinExpr(e) => {\n+                let lhs = self.collect_expr_opt(e.lhs());\n+                let rhs = self.collect_expr_opt(e.rhs());\n+                let op = e.op();\n+                self.alloc_expr(Expr::BinaryOp { lhs, rhs, op }, syntax_ptr)\n+            }\n \n             // TODO implement HIR for these:\n             ast::Expr::Label(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::IndexExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::TupleExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::ArrayExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::RangeExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n-            ast::Expr::BinExpr(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n             ast::Expr::Literal(_e) => self.alloc_expr(Expr::Missing, syntax_ptr),\n         }\n     }"}, {"sha": "6bdfdd7b44f0c7caedc625210d2ab154bc641781", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 228, "deletions": 316, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -17,25 +17,23 @@ mod primitive;\n #[cfg(test)]\n mod tests;\n \n+use std::ops::Index;\n use std::sync::Arc;\n use std::{fmt, mem};\n \n use log;\n use rustc_hash::FxHashMap;\n use ena::unify::{InPlaceUnificationTable, UnifyKey, UnifyValue, NoError};\n \n-use ra_db::{LocalSyntaxPtr, Cancelable};\n-use ra_syntax::{\n-    ast::{self, AstNode, LoopBodyOwner, ArgListOwner, PrefixOp, BinOp},\n-    SyntaxNodeRef\n-};\n+use ra_db::Cancelable;\n \n use crate::{\n-    Def, DefId, Module, Function, Struct, Enum, Path, Name, AsName, ImplBlock,\n+    Def, DefId, Module, Function, Struct, Enum, Path, Name, ImplBlock,\n+    FnSignature, FnScopes,\n     db::HirDatabase,\n     type_ref::{TypeRef, Mutability},\n     name::KnownName,\n-    ScopesWithSyntaxMapping,\n+    expr::{Body, Expr, ExprId, PatId, UnaryOp, BinaryOp, Statement},\n };\n \n /// The ID of a type variable.\n@@ -82,9 +80,10 @@ impl UnifyValue for TypeVarValue {\n         match (value1, value2) {\n             // We should never equate two type variables, both of which have\n             // known types. Instead, we recursively equate those types.\n-            (TypeVarValue::Known(..), TypeVarValue::Known(..)) => {\n-                panic!(\"equating two type variables, both of which have known types\")\n-            }\n+            (TypeVarValue::Known(t1), TypeVarValue::Known(t2)) => panic!(\n+                \"equating two type variables, both of which have known types: {:?} and {:?}\",\n+                t1, t2\n+            ),\n \n             // If one side is known, prefer that one.\n             (TypeVarValue::Known(..), TypeVarValue::Unknown) => Ok(value1.clone()),\n@@ -321,26 +320,6 @@ impl Ty {\n         Ok(ty)\n     }\n \n-    // TODO: These should not be necessary long-term, since everything will work on HIR\n-    pub(crate) fn from_ast_opt(\n-        db: &impl HirDatabase,\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        node: Option<ast::TypeRef>,\n-    ) -> Cancelable<Self> {\n-        node.map(|n| Ty::from_ast(db, module, impl_block, n))\n-            .unwrap_or(Ok(Ty::Unknown))\n-    }\n-\n-    pub(crate) fn from_ast(\n-        db: &impl HirDatabase,\n-        module: &Module,\n-        impl_block: Option<&ImplBlock>,\n-        node: ast::TypeRef,\n-    ) -> Cancelable<Self> {\n-        Ty::from_hir(db, module, impl_block, &TypeRef::from_ast(node))\n-    }\n-\n     pub fn unit() -> Self {\n         Ty::Tuple(Arc::new([]))\n     }\n@@ -417,26 +396,18 @@ impl fmt::Display for Ty {\n // Functions returning declared types for items\n \n /// Compute the declared type of a function. This should not need to look at the\n-/// function body (but currently uses the function AST, so does anyway - TODO).\n+/// function body.\n fn type_for_fn(db: &impl HirDatabase, f: Function) -> Cancelable<Ty> {\n-    let syntax = f.syntax(db);\n+    let signature = f.signature(db);\n     let module = f.module(db)?;\n     let impl_block = f.impl_block(db)?;\n-    let node = syntax.borrowed();\n     // TODO we ignore type parameters for now\n-    let input = node\n-        .param_list()\n-        .map(|pl| {\n-            pl.params()\n-                .map(|p| Ty::from_ast_opt(db, &module, impl_block.as_ref(), p.type_ref()))\n-                .collect()\n-        })\n-        .unwrap_or_else(|| Ok(Vec::new()))?;\n-    let output = if let Some(type_ref) = node.ret_type().and_then(|rt| rt.type_ref()) {\n-        Ty::from_ast(db, &module, impl_block.as_ref(), type_ref)?\n-    } else {\n-        Ty::unit()\n-    };\n+    let input = signature\n+        .args()\n+        .iter()\n+        .map(|tr| Ty::from_hir(db, &module, impl_block.as_ref(), tr))\n+        .collect::<Cancelable<Vec<_>>>()?;\n+    let output = Ty::from_hir(db, &module, impl_block.as_ref(), signature.ret_type())?;\n     let sig = FnSig { input, output };\n     Ok(Ty::FnPtr(Arc::new(sig)))\n }\n@@ -499,86 +470,103 @@ pub(super) fn type_for_field(db: &impl HirDatabase, def_id: DefId, field: Name)\n /// The result of type inference: A mapping from expressions and patterns to types.\n #[derive(Clone, PartialEq, Eq, Debug)]\n pub struct InferenceResult {\n-    type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n+    type_of_expr: FxHashMap<ExprId, Ty>,\n+    type_of_pat: FxHashMap<PatId, Ty>,\n }\n \n-impl InferenceResult {\n-    /// Returns the type of the given syntax node, if it was inferred. Will\n-    /// return `None` for syntax nodes not in the inferred function or not\n-    /// pointing to an expression/pattern, `Some(Ty::Unknown)` for\n-    /// expressions/patterns that could not be inferred.\n-    pub fn type_of_node(&self, node: SyntaxNodeRef) -> Option<Ty> {\n-        self.type_of.get(&LocalSyntaxPtr::new(node)).cloned()\n+impl Index<ExprId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, expr: ExprId) -> &Ty {\n+        self.type_of_expr.get(&expr).unwrap_or(&Ty::Unknown)\n+    }\n+}\n+\n+impl Index<PatId> for InferenceResult {\n+    type Output = Ty;\n+\n+    fn index(&self, pat: PatId) -> &Ty {\n+        self.type_of_pat.get(&pat).unwrap_or(&Ty::Unknown)\n     }\n }\n \n /// The inference context contains all information needed during type inference.\n #[derive(Clone, Debug)]\n struct InferenceContext<'a, D: HirDatabase> {\n     db: &'a D,\n-    scopes: ScopesWithSyntaxMapping,\n-    /// The self param for the current method, if it exists.\n-    self_param: Option<LocalSyntaxPtr>,\n+    body: Arc<Body>,\n+    scopes: Arc<FnScopes>,\n     module: Module,\n     impl_block: Option<ImplBlock>,\n     var_unification_table: InPlaceUnificationTable<TypeVarId>,\n-    type_of: FxHashMap<LocalSyntaxPtr, Ty>,\n+    type_of_expr: FxHashMap<ExprId, Ty>,\n+    type_of_pat: FxHashMap<PatId, Ty>,\n     /// The return type of the function being inferred.\n     return_ty: Ty,\n }\n \n // helper function that determines whether a binary operator\n // always returns a boolean\n-fn is_boolean_operator(op: BinOp) -> bool {\n+fn is_boolean_operator(op: BinaryOp) -> bool {\n     match op {\n-        BinOp::BooleanOr\n-        | BinOp::BooleanAnd\n-        | BinOp::EqualityTest\n-        | BinOp::LesserEqualTest\n-        | BinOp::GreaterEqualTest\n-        | BinOp::LesserTest\n-        | BinOp::GreaterTest => true,\n+        BinaryOp::BooleanOr\n+        | BinaryOp::BooleanAnd\n+        | BinaryOp::EqualityTest\n+        | BinaryOp::LesserEqualTest\n+        | BinaryOp::GreaterEqualTest\n+        | BinaryOp::LesserTest\n+        | BinaryOp::GreaterTest => true,\n     }\n }\n \n impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n     fn new(\n         db: &'a D,\n-        scopes: ScopesWithSyntaxMapping,\n+        body: Arc<Body>,\n+        scopes: Arc<FnScopes>,\n         module: Module,\n         impl_block: Option<ImplBlock>,\n     ) -> Self {\n         InferenceContext {\n-            type_of: FxHashMap::default(),\n+            type_of_expr: FxHashMap::default(),\n+            type_of_pat: FxHashMap::default(),\n             var_unification_table: InPlaceUnificationTable::new(),\n-            self_param: None,       // set during parameter typing\n             return_ty: Ty::Unknown, // set in collect_fn_signature\n             db,\n+            body,\n             scopes,\n             module,\n             impl_block,\n         }\n     }\n \n     fn resolve_all(mut self) -> InferenceResult {\n-        let mut types = mem::replace(&mut self.type_of, FxHashMap::default());\n-        for ty in types.values_mut() {\n+        let mut expr_types = mem::replace(&mut self.type_of_expr, FxHashMap::default());\n+        for ty in expr_types.values_mut() {\n+            let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n+            *ty = resolved;\n+        }\n+        let mut pat_types = mem::replace(&mut self.type_of_pat, FxHashMap::default());\n+        for ty in pat_types.values_mut() {\n             let resolved = self.resolve_ty_completely(mem::replace(ty, Ty::Unknown));\n             *ty = resolved;\n         }\n-        InferenceResult { type_of: types }\n+        InferenceResult {\n+            type_of_expr: expr_types,\n+            type_of_pat: pat_types,\n+        }\n     }\n \n-    fn write_ty(&mut self, node: SyntaxNodeRef, ty: Ty) {\n-        self.type_of.insert(LocalSyntaxPtr::new(node), ty);\n+    fn write_expr_ty(&mut self, expr: ExprId, ty: Ty) {\n+        self.type_of_expr.insert(expr, ty);\n     }\n \n-    fn make_ty(&self, type_ref: &TypeRef) -> Cancelable<Ty> {\n-        Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    fn write_pat_ty(&mut self, pat: PatId, ty: Ty) {\n+        self.type_of_pat.insert(pat, ty);\n     }\n \n-    fn make_ty_opt(&self, type_ref: Option<&TypeRef>) -> Cancelable<Ty> {\n-        Ty::from_hir_opt(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n+    fn make_ty(&self, type_ref: &TypeRef) -> Cancelable<Ty> {\n+        Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)\n     }\n \n     fn unify(&mut self, ty1: &Ty, ty2: &Ty) -> bool {\n@@ -673,23 +661,15 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_path_expr(&mut self, expr: ast::PathExpr) -> Cancelable<Option<Ty>> {\n-        let ast_path = ctry!(expr.path());\n-        let path = ctry!(Path::from_ast(ast_path));\n-        if path.is_ident() {\n+    fn infer_path_expr(&mut self, expr: ExprId, path: &Path) -> Cancelable<Option<Ty>> {\n+        if path.is_ident() || path.is_self() {\n             // resolve locally\n-            let name = ctry!(ast_path.segment().and_then(|s| s.name_ref()));\n-            if let Some(scope_entry) = self.scopes.resolve_local_name(name) {\n-                let ty = ctry!(self.type_of.get(&scope_entry.ptr()));\n+            let name = path.as_ident().cloned().unwrap_or_else(Name::self_param);\n+            if let Some(scope_entry) = self.scopes.resolve_local_name(expr, name) {\n+                let ty = ctry!(self.type_of_pat.get(&scope_entry.pat()));\n                 let ty = self.resolve_ty_as_possible(ty.clone());\n                 return Ok(Some(ty));\n             };\n-        } else if path.is_self() {\n-            // resolve `self` param\n-            let self_param = ctry!(self.self_param);\n-            let ty = ctry!(self.type_of.get(&self_param));\n-            let ty = self.resolve_ty_as_possible(ty.clone());\n-            return Ok(Some(ty));\n         };\n \n         // resolve in module\n@@ -699,8 +679,8 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         Ok(Some(ty))\n     }\n \n-    fn resolve_variant(&self, path: Option<ast::Path>) -> Cancelable<(Ty, Option<DefId>)> {\n-        let path = if let Some(path) = path.and_then(Path::from_ast) {\n+    fn resolve_variant(&self, path: Option<&Path>) -> Cancelable<(Ty, Option<DefId>)> {\n+        let path = if let Some(path) = path {\n             path\n         } else {\n             return Ok((Ty::Unknown, None));\n@@ -719,74 +699,51 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n         })\n     }\n \n-    fn infer_expr_opt(\n-        &mut self,\n-        expr: Option<ast::Expr>,\n-        expected: &Expectation,\n-    ) -> Cancelable<Ty> {\n-        if let Some(e) = expr {\n-            self.infer_expr(e, expected)\n-        } else {\n-            Ok(Ty::Unknown)\n-        }\n-    }\n-\n-    fn infer_expr(&mut self, expr: ast::Expr, expected: &Expectation) -> Cancelable<Ty> {\n-        let ty = match expr {\n-            ast::Expr::IfExpr(e) => {\n-                if let Some(condition) = e.condition() {\n-                    let expected = if condition.pat().is_none() {\n-                        Expectation::has_type(Ty::Bool)\n-                    } else {\n-                        Expectation::none()\n-                    };\n-                    self.infer_expr_opt(condition.expr(), &expected)?;\n-                    // TODO write type for pat\n-                };\n-                let if_ty = self.infer_block_opt(e.then_branch(), expected)?;\n-                if let Some(else_branch) = e.else_branch() {\n-                    self.infer_block(else_branch, expected)?;\n+    fn infer_expr(&mut self, expr: ExprId, expected: &Expectation) -> Cancelable<Ty> {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        let ty = match &body[expr] {\n+            Expr::Missing => Ty::Unknown,\n+            Expr::If {\n+                condition,\n+                then_branch,\n+                else_branch,\n+            } => {\n+                // if let is desugared to match, so this is always simple if\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n+                let then_ty = self.infer_expr(*then_branch, expected)?;\n+                if let Some(else_branch) = else_branch {\n+                    self.infer_expr(*else_branch, expected)?;\n                 } else {\n                     // no else branch -> unit\n                     self.unify(&expected.ty, &Ty::unit()); // actually coerce\n                 }\n-                if_ty\n+                then_ty\n             }\n-            ast::Expr::BlockExpr(e) => self.infer_block_opt(e.block(), expected)?,\n-            ast::Expr::LoopExpr(e) => {\n-                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n-                // TODO never, or the type of the break param\n-                Ty::Unknown\n+            Expr::Block { statements, tail } => self.infer_block(statements, *tail, expected)?,\n+            Expr::Loop { body } => {\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n+                // TODO handle break with value\n+                Ty::Never\n             }\n-            ast::Expr::WhileExpr(e) => {\n-                if let Some(condition) = e.condition() {\n-                    let expected = if condition.pat().is_none() {\n-                        Expectation::has_type(Ty::Bool)\n-                    } else {\n-                        Expectation::none()\n-                    };\n-                    self.infer_expr_opt(condition.expr(), &expected)?;\n-                    // TODO write type for pat\n-                };\n-                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n-                // TODO always unit?\n+            Expr::While { condition, body } => {\n+                // while let is desugared to a match loop, so this is always simple while\n+                self.infer_expr(*condition, &Expectation::has_type(Ty::Bool))?;\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n                 Ty::unit()\n             }\n-            ast::Expr::ForExpr(e) => {\n-                let _iterable_ty = self.infer_expr_opt(e.iterable(), &Expectation::none());\n-                if let Some(_pat) = e.pat() {\n-                    // TODO write type for pat\n-                }\n-                self.infer_block_opt(e.loop_body(), &Expectation::has_type(Ty::unit()))?;\n-                // TODO always unit?\n+            Expr::For { iterable, body, .. } => {\n+                let _iterable_ty = self.infer_expr(*iterable, &Expectation::none());\n+                // TODO write type for pat\n+                self.infer_expr(*body, &Expectation::has_type(Ty::unit()))?;\n                 Ty::unit()\n             }\n-            ast::Expr::LambdaExpr(e) => {\n-                let _body_ty = self.infer_expr_opt(e.body(), &Expectation::none())?;\n+            Expr::Lambda { body, .. } => {\n+                // TODO write types for args, infer lambda type etc.\n+                let _body_ty = self.infer_expr(*body, &Expectation::none())?;\n                 Ty::Unknown\n             }\n-            ast::Expr::CallExpr(e) => {\n-                let callee_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n+            Expr::Call { callee, args } => {\n+                let callee_ty = self.infer_expr(*callee, &Expectation::none())?;\n                 let (arg_tys, ret_ty) = match &callee_ty {\n                     Ty::FnPtr(sig) => (&sig.input[..], sig.output.clone()),\n                     _ => {\n@@ -795,112 +752,102 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                         (&[][..], Ty::Unknown)\n                     }\n                 };\n-                if let Some(arg_list) = e.arg_list() {\n-                    for (i, arg) in arg_list.args().enumerate() {\n-                        self.infer_expr(\n-                            arg,\n-                            &Expectation::has_type(arg_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n-                        )?;\n-                    }\n+                for (i, arg) in args.iter().enumerate() {\n+                    self.infer_expr(\n+                        *arg,\n+                        &Expectation::has_type(arg_tys.get(i).cloned().unwrap_or(Ty::Unknown)),\n+                    )?;\n                 }\n                 ret_ty\n             }\n-            ast::Expr::MethodCallExpr(e) => {\n-                let _receiver_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                if let Some(arg_list) = e.arg_list() {\n-                    for arg in arg_list.args() {\n-                        // TODO unify / expect argument type\n-                        self.infer_expr(arg, &Expectation::none())?;\n-                    }\n+            Expr::MethodCall { receiver, args, .. } => {\n+                let _receiver_ty = self.infer_expr(*receiver, &Expectation::none())?;\n+                // TODO resolve method...\n+                for (_i, arg) in args.iter().enumerate() {\n+                    // TODO unify / expect argument type\n+                    self.infer_expr(*arg, &Expectation::none())?;\n                 }\n                 Ty::Unknown\n             }\n-            ast::Expr::MatchExpr(e) => {\n-                let _ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                if let Some(match_arm_list) = e.match_arm_list() {\n-                    for arm in match_arm_list.arms() {\n-                        // TODO type the bindings in pat\n-                        // TODO type the guard\n-                        let _ty = self.infer_expr_opt(arm.expr(), &Expectation::none())?;\n-                    }\n-                    // TODO unify all the match arm types\n-                    Ty::Unknown\n-                } else {\n-                    Ty::Unknown\n+            Expr::Match { expr, arms } => {\n+                let _ty = self.infer_expr(*expr, &Expectation::none())?;\n+                for arm in arms {\n+                    // TODO type the bindings in pats\n+                    // TODO type the guard\n+                    let _ty = self.infer_expr(arm.expr, &Expectation::none())?;\n                 }\n+                // TODO unify all the match arm types\n+                Ty::Unknown\n             }\n-            ast::Expr::TupleExpr(_e) => Ty::Unknown,\n-            ast::Expr::ArrayExpr(_e) => Ty::Unknown,\n-            ast::Expr::PathExpr(e) => self.infer_path_expr(e)?.unwrap_or(Ty::Unknown),\n-            ast::Expr::ContinueExpr(_e) => Ty::Never,\n-            ast::Expr::BreakExpr(_e) => Ty::Never,\n-            ast::Expr::ParenExpr(e) => self.infer_expr_opt(e.expr(), expected)?,\n-            ast::Expr::Label(_e) => Ty::Unknown,\n-            ast::Expr::ReturnExpr(e) => {\n-                // TODO expect return type of function\n-                self.infer_expr_opt(e.expr(), &Expectation::none())?;\n+            Expr::Path(p) => self.infer_path_expr(expr, p)?.unwrap_or(Ty::Unknown),\n+            Expr::Continue => Ty::Never,\n+            Expr::Break { expr } => {\n+                if let Some(expr) = expr {\n+                    // TODO handle break with value\n+                    self.infer_expr(*expr, &Expectation::none())?;\n+                }\n                 Ty::Never\n             }\n-            ast::Expr::StructLit(e) => {\n-                let (ty, def_id) = self.resolve_variant(e.path())?;\n-                if let Some(nfl) = e.named_field_list() {\n-                    for field in nfl.fields() {\n-                        let field_ty = if let (Some(def_id), Some(nr)) = (def_id, field.name_ref())\n-                        {\n-                            self.db.type_for_field(def_id, nr.as_name())?\n-                        } else {\n-                            Ty::Unknown\n-                        };\n-                        self.infer_expr_opt(field.expr(), &Expectation::has_type(field_ty))?;\n-                    }\n+            Expr::Return { expr } => {\n+                if let Some(expr) = expr {\n+                    self.infer_expr(*expr, &Expectation::has_type(self.return_ty.clone()))?;\n                 }\n-                ty\n+                Ty::Never\n             }\n-            ast::Expr::IndexExpr(_e) => Ty::Unknown,\n-            ast::Expr::FieldExpr(e) => {\n-                let receiver_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                if let Some(nr) = e.name_ref() {\n-                    let ty = match receiver_ty {\n-                        Ty::Tuple(fields) => {\n-                            let i = nr.text().parse::<usize>().ok();\n-                            i.and_then(|i| fields.get(i).cloned())\n-                                .unwrap_or(Ty::Unknown)\n-                        }\n-                        Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, nr.as_name())?,\n-                        _ => Ty::Unknown,\n+            Expr::StructLit {\n+                path,\n+                fields,\n+                spread,\n+            } => {\n+                let (ty, def_id) = self.resolve_variant(path.as_ref())?;\n+                for field in fields {\n+                    let field_ty = if let Some(def_id) = def_id {\n+                        self.db.type_for_field(def_id, field.name.clone())?\n+                    } else {\n+                        Ty::Unknown\n                     };\n-                    self.insert_type_vars(ty)\n-                } else {\n-                    Ty::Unknown\n+                    self.infer_expr(field.expr, &Expectation::has_type(field_ty))?;\n+                }\n+                if let Some(expr) = spread {\n+                    self.infer_expr(*expr, &Expectation::has_type(ty.clone()))?;\n                 }\n+                ty\n+            }\n+            Expr::Field { expr, name } => {\n+                let receiver_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let ty = match receiver_ty {\n+                    Ty::Tuple(fields) => {\n+                        let i = name.to_string().parse::<usize>().ok();\n+                        i.and_then(|i| fields.get(i).cloned())\n+                            .unwrap_or(Ty::Unknown)\n+                    }\n+                    Ty::Adt { def_id, .. } => self.db.type_for_field(def_id, name.clone())?,\n+                    _ => Ty::Unknown,\n+                };\n+                self.insert_type_vars(ty)\n             }\n-            ast::Expr::TryExpr(e) => {\n-                let _inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n+            Expr::Try { expr } => {\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n                 Ty::Unknown\n             }\n-            ast::Expr::CastExpr(e) => {\n-                let _inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                let cast_ty = Ty::from_ast_opt(\n-                    self.db,\n-                    &self.module,\n-                    self.impl_block.as_ref(),\n-                    e.type_ref(),\n-                )?;\n+            Expr::Cast { expr, type_ref } => {\n+                let _inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                let cast_ty =\n+                    Ty::from_hir(self.db, &self.module, self.impl_block.as_ref(), type_ref)?;\n                 let cast_ty = self.insert_type_vars(cast_ty);\n-                // TODO do the coercion...\n+                // TODO check the cast...\n                 cast_ty\n             }\n-            ast::Expr::RefExpr(e) => {\n+            Expr::Ref { expr, mutability } => {\n                 // TODO pass the expectation down\n-                let inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                let m = Mutability::from_mutable(e.is_mut());\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n                 // TODO reference coercions etc.\n-                Ty::Ref(Arc::new(inner_ty), m)\n+                Ty::Ref(Arc::new(inner_ty), *mutability)\n             }\n-            ast::Expr::PrefixExpr(e) => {\n-                let inner_ty = self.infer_expr_opt(e.expr(), &Expectation::none())?;\n-                match e.op() {\n-                    Some(PrefixOp::Deref) => {\n+            Expr::UnaryOp { expr, op } => {\n+                let inner_ty = self.infer_expr(*expr, &Expectation::none())?;\n+                match op {\n+                    Some(UnaryOp::Deref) => {\n                         match inner_ty {\n                             // builtin deref:\n                             Ty::Ref(ref_inner, _) => (*ref_inner).clone(),\n@@ -912,147 +859,112 @@ impl<'a, D: HirDatabase> InferenceContext<'a, D> {\n                     _ => Ty::Unknown,\n                 }\n             }\n-            ast::Expr::RangeExpr(_e) => Ty::Unknown,\n-            ast::Expr::BinExpr(e) => match e.op() {\n+            Expr::BinaryOp { lhs, rhs, op } => match op {\n                 Some(op) => {\n                     let subtype_expectation = match op {\n-                        BinOp::BooleanAnd | BinOp::BooleanOr => Expectation::has_type(Ty::Bool),\n+                        BinaryOp::BooleanAnd | BinaryOp::BooleanOr => {\n+                            Expectation::has_type(Ty::Bool)\n+                        }\n                         _ => Expectation::none(),\n                     };\n-                    let (lhs, rhs) = e.sub_exprs();\n-                    let _lhs_ty = self.infer_expr_opt(lhs, &subtype_expectation)?;\n-                    let _rhs_ty = self.infer_expr_opt(rhs, &subtype_expectation)?;\n+                    let _lhs_ty = self.infer_expr(*lhs, &subtype_expectation)?;\n+                    let _rhs_ty = self.infer_expr(*rhs, &subtype_expectation)?;\n \n-                    if is_boolean_operator(op) {\n+                    if is_boolean_operator(*op) {\n                         Ty::Bool\n                     } else {\n                         Ty::Unknown\n                     }\n                 }\n                 _ => Ty::Unknown,\n             },\n-            ast::Expr::Literal(_e) => Ty::Unknown,\n         };\n         // use a new type variable if we got Ty::Unknown here\n         let ty = self.insert_type_vars_shallow(ty);\n         self.unify(&ty, &expected.ty);\n-        self.write_ty(expr.syntax(), ty.clone());\n+        let ty = self.resolve_ty_as_possible(ty);\n+        self.write_expr_ty(expr, ty.clone());\n         Ok(ty)\n     }\n \n-    fn infer_block_opt(\n+    fn infer_block(\n         &mut self,\n-        node: Option<ast::Block>,\n+        statements: &[Statement],\n+        tail: Option<ExprId>,\n         expected: &Expectation,\n     ) -> Cancelable<Ty> {\n-        if let Some(b) = node {\n-            self.infer_block(b, expected)\n-        } else {\n-            Ok(Ty::Unknown)\n-        }\n-    }\n-\n-    fn infer_block(&mut self, node: ast::Block, expected: &Expectation) -> Cancelable<Ty> {\n-        for stmt in node.statements() {\n+        for stmt in statements {\n             match stmt {\n-                ast::Stmt::LetStmt(stmt) => {\n-                    let decl_ty = Ty::from_ast_opt(\n+                Statement::Let {\n+                    pat,\n+                    type_ref,\n+                    initializer,\n+                } => {\n+                    let decl_ty = Ty::from_hir_opt(\n                         self.db,\n                         &self.module,\n                         self.impl_block.as_ref(),\n-                        stmt.type_ref(),\n+                        type_ref.as_ref(),\n                     )?;\n                     let decl_ty = self.insert_type_vars(decl_ty);\n-                    let ty = if let Some(expr) = stmt.initializer() {\n-                        let expr_ty = self.infer_expr(expr, &Expectation::has_type(decl_ty))?;\n+                    let ty = if let Some(expr) = initializer {\n+                        let expr_ty = self.infer_expr(*expr, &Expectation::has_type(decl_ty))?;\n                         expr_ty\n                     } else {\n                         decl_ty\n                     };\n \n-                    if let Some(pat) = stmt.pat() {\n-                        self.write_ty(pat.syntax(), ty);\n-                    };\n+                    self.write_pat_ty(*pat, ty);\n                 }\n-                ast::Stmt::ExprStmt(expr_stmt) => {\n-                    self.infer_expr_opt(expr_stmt.expr(), &Expectation::none())?;\n+                Statement::Expr(expr) => {\n+                    self.infer_expr(*expr, &Expectation::none())?;\n                 }\n             }\n         }\n-        let ty = if let Some(expr) = node.expr() {\n+        let ty = if let Some(expr) = tail {\n             self.infer_expr(expr, expected)?\n         } else {\n             Ty::unit()\n         };\n-        self.write_ty(node.syntax(), ty.clone());\n         Ok(ty)\n     }\n \n-    fn collect_fn_signature(&mut self, node: ast::FnDef) -> Cancelable<()> {\n-        if let Some(param_list) = node.param_list() {\n-            if let Some(self_param) = param_list.self_param() {\n-                let self_type = if let Some(type_ref) = self_param.type_ref() {\n-                    let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n-                    self.insert_type_vars(ty)\n-                } else {\n-                    // TODO this should be handled by desugaring during HIR conversion\n-                    let ty = self.make_ty_opt(self.impl_block.as_ref().map(|i| i.target_type()))?;\n-                    let ty = match self_param.flavor() {\n-                        ast::SelfParamFlavor::Owned => ty,\n-                        ast::SelfParamFlavor::Ref => Ty::Ref(Arc::new(ty), Mutability::Shared),\n-                        ast::SelfParamFlavor::MutRef => Ty::Ref(Arc::new(ty), Mutability::Mut),\n-                    };\n-                    self.insert_type_vars(ty)\n-                };\n-                if let Some(self_kw) = self_param.self_kw() {\n-                    let self_param = LocalSyntaxPtr::new(self_kw.syntax());\n-                    self.self_param = Some(self_param);\n-                    self.type_of.insert(self_param, self_type);\n-                }\n-            }\n-            for param in param_list.params() {\n-                let pat = if let Some(pat) = param.pat() {\n-                    pat\n-                } else {\n-                    continue;\n-                };\n-                let ty = if let Some(type_ref) = param.type_ref() {\n-                    let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n-                    self.insert_type_vars(ty)\n-                } else {\n-                    // missing type annotation\n-                    self.new_type_var()\n-                };\n-                self.type_of.insert(LocalSyntaxPtr::new(pat.syntax()), ty);\n-            }\n+    fn collect_fn_signature(&mut self, signature: &FnSignature) -> Cancelable<()> {\n+        let body = Arc::clone(&self.body); // avoid borrow checker problem\n+        for (type_ref, pat) in signature.args().iter().zip(body.args()) {\n+            let ty = self.make_ty(type_ref)?;\n+            let ty = self.insert_type_vars(ty);\n+            self.write_pat_ty(*pat, ty);\n         }\n-\n-        self.return_ty = if let Some(type_ref) = node.ret_type().and_then(|n| n.type_ref()) {\n-            let ty = self.make_ty(&TypeRef::from_ast(type_ref))?;\n-            self.insert_type_vars(ty)\n-        } else {\n-            Ty::unit()\n+        self.return_ty = {\n+            let ty = self.make_ty(signature.ret_type())?;\n+            let ty = self.insert_type_vars(ty);\n+            ty\n         };\n+        Ok(())\n+    }\n \n+    fn infer_body(&mut self) -> Cancelable<()> {\n+        self.infer_expr(\n+            self.body.body_expr(),\n+            &Expectation::has_type(self.return_ty.clone()),\n+        )?;\n         Ok(())\n     }\n }\n \n pub fn infer(db: &impl HirDatabase, def_id: DefId) -> Cancelable<Arc<InferenceResult>> {\n     let function = Function::new(def_id); // TODO: consts also need inference\n-    let scopes = function.scopes(db)?;\n+    let body = function.body(db)?;\n+    let scopes = db.fn_scopes(def_id)?;\n     let module = function.module(db)?;\n     let impl_block = function.impl_block(db)?;\n-    let mut ctx = InferenceContext::new(db, scopes, module, impl_block);\n-\n-    let syntax = function.syntax(db);\n-    let node = syntax.borrowed();\n+    let mut ctx = InferenceContext::new(db, body, scopes, module, impl_block);\n \n-    ctx.collect_fn_signature(node)?;\n+    let signature = function.signature(db);\n+    ctx.collect_fn_signature(&signature)?;\n \n-    if let Some(block) = node.body() {\n-        ctx.infer_block(block, &Expectation::has_type(ctx.return_ty.clone()))?;\n-    }\n+    ctx.infer_body()?;\n \n     Ok(Arc::new(ctx.resolve_all()))\n }"}, {"sha": "e46f309ae03a75e74ae9c534468e3fb5a08dcfb3", "filename": "crates/ra_hir/src/ty/tests.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests.rs?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -4,8 +4,9 @@ use std::path::{PathBuf, Path};\n use std::fs;\n \n use salsa::Database;\n+use rustc_hash::FxHashMap;\n \n-use ra_db::{SyntaxDatabase};\n+use ra_db::SyntaxDatabase;\n use ra_syntax::ast::{self, AstNode};\n use test_utils::{project_dir, assert_eq_text, read_text};\n \n@@ -193,7 +194,25 @@ fn infer(content: &str) -> String {\n             .unwrap()\n             .unwrap();\n         let inference_result = func.infer(&db).unwrap();\n-        for (syntax_ptr, ty) in &inference_result.type_of {\n+        let body_syntax_mapping = func.body_syntax_mapping(&db).unwrap();\n+        let mut types = FxHashMap::default();\n+        for (pat, ty) in &inference_result.type_of_pat {\n+            let syntax_ptr = if let Some(sp) = body_syntax_mapping.pat_syntax(*pat) {\n+                sp\n+            } else {\n+                continue;\n+            };\n+            types.insert(syntax_ptr, ty);\n+        }\n+        for (expr, ty) in &inference_result.type_of_expr {\n+            let syntax_ptr = if let Some(sp) = body_syntax_mapping.expr_syntax(*expr) {\n+                sp\n+            } else {\n+                continue;\n+            };\n+            types.insert(syntax_ptr, ty);\n+        }\n+        for (syntax_ptr, ty) in &types {\n             let node = syntax_ptr.resolve(&source_file);\n             write!(\n                 acc,\n@@ -246,7 +265,6 @@ fn test_data_dir() -> PathBuf {\n }\n \n #[test]\n-#[should_panic] // TODO this should work once hir::Expr is used\n fn typing_whitespace_inside_a_function_should_not_invalidate_types() {\n     let (mut db, pos) = MockDatabase::with_position(\n         \""}, {"sha": "4df6b42c9a1b38b59b557475dd9512cc7b274621", "filename": "crates/ra_hir/src/ty/tests/data/0001_basics.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0001_basics.txt?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -8,6 +8,6 @@\n [27; 28) 'c': !\n [62; 63) 'c': !\n [17; 18) 'b': isize\n-[100; 106) '\"test\"': [unknown]\n [42; 121) '{     ...f32; }': ()\n+[100; 106) '\"test\"': [unknown]\n [69; 70) 'd': &[unknown]"}, {"sha": "6f919b332ff1ef6dd954e8991990db69b5cffd55", "filename": "crates/ra_hir/src/ty/tests/data/0004_struct.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0004_struct.txt?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -1,8 +1,8 @@\n [86; 90) 'C(1)': [unknown]\n [121; 122) 'B': B\n [86; 87) 'C': [unknown]\n-[129; 130) '1': [unknown]\n [107; 108) 'a': A\n+[129; 130) '1': [unknown]\n [127; 128) 'C': [unknown]\n [139; 142) 'a.b': B\n [114; 133) 'A { b:...C(1) }': A"}, {"sha": "cc32162a1e5370e3f3a693c9635b5f9a77941767", "filename": "crates/ra_hir/src/ty/tests/data/0005_refs.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0005_refs.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0005_refs.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0005_refs.txt?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -6,9 +6,9 @@\n [46; 47) 'd': *mut u32\n [59; 150) '{     ... *d; }': ()\n [116; 117) 'b': &mut u32\n+[72; 74) '*a': u32\n [131; 132) 'c': *const u32\n [130; 132) '*c': u32\n-[72; 74) '*a': u32\n [107; 109) '*b': u32\n [108; 109) 'b': &mut u32\n [9; 10) 'a': &u32\n@@ -17,7 +17,7 @@\n [100; 101) 'b': &mut u32\n [81; 82) 'a': &u32\n [80; 82) '&a': &&u32\n-[73; 74) 'a': &u32\n [123; 124) 'c': *const u32\n+[73; 74) 'a': &u32\n [31; 32) 'c': *const u32\n [138; 139) 'd': *mut u32"}, {"sha": "0efae598ec18c5c68387182289cfab8c957e41b8", "filename": "crates/ra_hir/src/ty/tests/data/0006_backwards.txt", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0006_backwards.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0006_backwards.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0006_backwards.txt?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -1,12 +1,12 @@\n [22; 24) '{}': ()\n [14; 15) 'x': u32\n [142; 158) 'unknow...nction': [unknown]\n-[126; 127) 'a': u32\n-[198; 216) 'unknow...tion()': f64\n [228; 229) 'c': f64\n+[198; 216) 'unknow...tion()': f64\n+[126; 127) 'a': u32\n [198; 214) 'unknow...nction': [unknown]\n-[166; 184) 'S { i3...d: b }': S\n [222; 229) '&mut &c': &mut &f64\n+[166; 184) 'S { i3...d: b }': S\n [194; 195) 'c': f64\n [92; 110) 'unknow...tion()': u32\n [142; 160) 'unknow...tion()': i32"}, {"sha": "0ae1729149f587e1440eebf86abbeb997e6fc982", "filename": "crates/ra_hir/src/ty/tests/data/0008_boolean_op.txt", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0008_boolean_op.txt", "raw_url": "https://github.com/rust-lang/rust/raw/6210e82041849bad6129331b9e45ac0bae6fe569/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0008_boolean_op.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Ftests%2Fdata%2F0008_boolean_op.txt?ref=6210e82041849bad6129331b9e45ac0bae6fe569", "patch": "@@ -1,31 +1,31 @@\n [28; 32) '0i32': i32\n [22; 34) '{     0i32 }': i32\n [6; 7) 'x': [unknown]\n-[127; 134) 'CONST_1': [unknown]\n [201; 205) '3i32': bool\n+[127; 134) 'CONST_1': [unknown]\n [76; 77) 'y': bool\n-[65; 66) 'b': bool\n [60; 66) 'a && b': bool\n+[65; 66) 'b': bool\n+[229; 231) '10': [unknown]\n [127; 145) 'CONST_...ONST_2': bool\n [182; 183) 'd': [unknown]\n-[229; 231) '10': [unknown]\n [209; 222) '\"hello world\"': bool\n [229; 235) '10 < 3': bool\n [186; 187) 'b': [unknown]\n-[159; 172) 'f(z || y) + 5': [unknown]\n [56; 57) 'x': bool\n+[159; 172) 'f(z || y) + 5': [unknown]\n [112; 113) 'y': bool\n-[201; 222) '3i32 &...world\"': bool\n [234; 235) '3': [unknown]\n+[201; 222) '3i32 &...world\"': bool\n [138; 145) 'CONST_2': [unknown]\n [80; 93) 'true || false': bool\n [46; 237) '{     ... < 3 }': bool\n [197; 198) 'e': bool\n [107; 113) 'x == y': bool\n [88; 93) 'false': bool\n-[80; 84) 'true': bool\n-[123; 124) 'h': bool\n [155; 156) 'c': [unknown]\n+[123; 124) 'h': bool\n+[80; 84) 'true': bool\n [103; 104) 'z': bool\n [60; 61) 'a': bool\n [107; 108) 'x': bool"}]}