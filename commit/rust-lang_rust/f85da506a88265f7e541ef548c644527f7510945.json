{"sha": "f85da506a88265f7e541ef548c644527f7510945", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY4NWRhNTA2YTg4MjY1ZjdlNTQxZWY1NDhjNjQ0NTI3Zjc1MTA5NDU=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-11T14:37:43Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@gmail", "date": "2013-09-15T10:28:25Z"}, "message": "debuginfo: Support for recursive types.", "tree": {"sha": "cd59766b28a7400689e2f92a3ea8711a52bc68a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd59766b28a7400689e2f92a3ea8711a52bc68a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f85da506a88265f7e541ef548c644527f7510945", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f85da506a88265f7e541ef548c644527f7510945", "html_url": "https://github.com/rust-lang/rust/commit/f85da506a88265f7e541ef548c644527f7510945", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f85da506a88265f7e541ef548c644527f7510945/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "206cc59f46f6e7b4f91ebe8fdfe4dae83a1fa703", "url": "https://api.github.com/repos/rust-lang/rust/commits/206cc59f46f6e7b4f91ebe8fdfe4dae83a1fa703", "html_url": "https://github.com/rust-lang/rust/commit/206cc59f46f6e7b4f91ebe8fdfe4dae83a1fa703"}], "stats": {"total": 590, "additions": 416, "deletions": 174}, "files": [{"sha": "9a9015179f6598bfd68de3a1474ab09b5e82b8ce", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f85da506a88265f7e541ef548c644527f7510945/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85da506a88265f7e541ef548c644527f7510945/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=f85da506a88265f7e541ef548c644527f7510945", "patch": "@@ -2117,6 +2117,10 @@ pub mod llvm {\n                                             LineNo: c_uint)\n                                             -> ValueRef;\n \n+        #[fast_ffi]\n+        pub fn LLVMDICompositeTypeSetTypeArray(CompositeType: ValueRef, TypeArray: ValueRef);\n+\n+\n         #[fast_ffi]\n         pub fn LLVMIsAArgument(value_ref: ValueRef) -> ValueRef;\n "}, {"sha": "f26d8365092d5bcd7c513e190b0638d16c9cd027", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 382, "deletions": 174, "changes": 556, "blob_url": "https://github.com/rust-lang/rust/blob/f85da506a88265f7e541ef548c644527f7510945/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f85da506a88265f7e541ef548c644527f7510945/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=f85da506a88265f7e541ef548c644527f7510945", "patch": "@@ -84,9 +84,6 @@ static DW_ATE_signed_char: c_uint = 0x06;\n static DW_ATE_unsigned: c_uint = 0x07;\n static DW_ATE_unsigned_char: c_uint = 0x08;\n \n-\n-\n-\n //=-------------------------------------------------------------------------------------------------\n //  Public Interface of debuginfo module\n //=-------------------------------------------------------------------------------------------------\n@@ -1058,80 +1055,176 @@ fn pointer_type_metadata(cx: &mut CrateContext,\n     return ptr_metadata;\n }\n \n-fn struct_metadata(cx: &mut CrateContext,\n-                   struct_type: ty::t,\n-                   def_id: ast::DefId,\n-                   substs: &ty::substs,\n-                   span: Span)\n-                -> DICompositeType {\n+fn prepare_struct_metadata(cx: &mut CrateContext,\n+                           struct_type: ty::t,\n+                           def_id: ast::DefId,\n+                           substs: &ty::substs,\n+                           span: Span)\n+                        -> RecursiveTypeDescription {\n     let struct_name = ppaux::ty_to_str(cx.tcx, struct_type);\n-    debug!(\"struct_metadata: %s\", struct_name);\n+    println(fmt!(\"struct_metadata: %s\", struct_name));\n \n     let struct_llvm_type = type_of::type_of(cx, struct_type);\n+    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id, span);\n+\n+    let file_name = span_start(cx, definition_span).file.name;\n+    let file_metadata = file_metadata(cx, file_name);\n+\n+    let loc = span_start(cx, definition_span);\n+\n+    let (composite_size, composite_align) = size_and_align_of(cx, struct_llvm_type);\n+\n+    let struct_metadata_stub = create_struct_stub(cx,\n+                                                  struct_llvm_type,\n+                                                  struct_name,\n+                                                  containing_scope,\n+                                                  file_metadata,\n+                                                  definition_span);\n+\n     let fields = ty::struct_fields(cx.tcx, def_id, substs);\n-    let field_descriptions = do fields.map |field| {\n-        let name = if field.ident.name == special_idents::unnamed_field.name {\n-            @\"\"\n-        } else {\n-            token::ident_to_str(&field.ident)\n-        };\n \n-        MemberDescription {\n-            name: name,\n-            llvm_type: type_of::type_of(cx, field.mt.ty),\n-            type_metadata: type_metadata(cx, field.mt.ty, span),\n+    UnfinishedMetadata {\n+        cache_id: cache_id_for_type(struct_type),\n+        metadata_stub: struct_metadata_stub,\n+        llvm_type: struct_llvm_type,\n+        file_metadata: file_metadata,\n+        member_description_factory: |cx| {\n+            do fields.map |field| {\n+                let name = if field.ident.name == special_idents::unnamed_field.name {\n+                    @\"\"\n+                } else {\n+                    token::ident_to_str(&field.ident)\n+                };\n+\n+                MemberDescription {\n+                    name: name,\n+                    llvm_type: type_of::type_of(cx, field.mt.ty),\n+                    type_metadata: type_metadata(cx, field.mt.ty, span),\n+                    offset: ComputedMemberOffset,\n+                }\n+            }\n         }\n-    };\n+    }\n+}\n \n-    let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, def_id, span);\n+enum RecursiveTypeDescription {\n+    UnfinishedMetadata {\n+        cache_id: uint,\n+        metadata_stub: DICompositeType,\n+        llvm_type: Type,\n+        file_metadata: DIFile,\n+        member_description_factory: @fn(cx: &mut CrateContext) -> ~[MemberDescription],\n+    },\n+    FinalMetadata(DICompositeType)\n+}\n \n-    let file_name = span_start(cx, definition_span).file.name;\n-    let file_metadata = file_metadata(cx, file_name);\n+impl RecursiveTypeDescription {\n \n-    return composite_type_metadata(\n-        cx,\n-        struct_llvm_type,\n-        struct_name,\n-        field_descriptions,\n-        containing_scope,\n-        file_metadata,\n-        definition_span);\n+    fn metadata(&self) -> DICompositeType {\n+        match *self {\n+            UnfinishedMetadata { metadata_stub, _ } => metadata_stub,\n+            FinalMetadata(metadata) => metadata\n+        }\n+    }\n+\n+    fn finalize(&self, cx: &mut CrateContext) -> DICompositeType {\n+        match *self {\n+            FinalMetadata(metadata) => metadata,\n+            UnfinishedMetadata {\n+                cache_id,\n+                metadata_stub,\n+                llvm_type,\n+                file_metadata,\n+                member_description_factory\n+            } => {\n+                // Insert the stub into the cache in order to allow recursive references ...\n+                debug_context(cx).created_types.insert(cache_id, metadata_stub);\n+\n+                // ... then create the member descriptions\n+                let member_descriptions = member_description_factory(cx);\n+                let member_metadata: ~[DIDescriptor] = member_descriptions\n+                    .iter()\n+                    .enumerate()\n+                    .map(|(i, member_description)| {\n+                        let (member_size,\n+                             member_align) = size_and_align_of(cx, member_description.llvm_type);\n+                        let member_offset = match member_description.offset {\n+                            FixedMemberOffset { bytes } => bytes,\n+                            ComputedMemberOffset => {\n+                                machine::llelement_offset(cx, llvm_type, i)\n+                            }\n+                        };\n+\n+                        do member_description.name.with_c_str |member_name| {\n+                            unsafe {\n+                                llvm::LLVMDIBuilderCreateMemberType(\n+                                    DIB(cx),\n+                                    metadata_stub,\n+                                    member_name,\n+                                    file_metadata,\n+                                    0 as c_uint,\n+                                    bytes_to_bits(member_size),\n+                                    bytes_to_bits(member_align),\n+                                    bytes_to_bits(member_offset),\n+                                    0,\n+                                    member_description.type_metadata)\n+                            }\n+                        }\n+                    })\n+                    .collect();\n+\n+                unsafe {\n+                    let type_array = create_DIArray(DIB(cx), member_metadata);\n+                    llvm::LLVMDICompositeTypeSetTypeArray(metadata_stub, type_array);\n+                }\n+\n+                metadata_stub\n+            }\n+        }\n+    }\n }\n \n-fn tuple_metadata(cx: &mut CrateContext,\n-                  tuple_type: ty::t,\n-                  component_types: &[ty::t],\n-                  span: Span)\n-               -> DICompositeType {\n+fn prepare_tuple_metadata(cx: &mut CrateContext,\n+                          tuple_type: ty::t,\n+                          component_types: &[ty::t],\n+                          span: Span)\n+                       -> RecursiveTypeDescription {\n     let tuple_name = ppaux::ty_to_str(cx.tcx, tuple_type);\n     let tuple_llvm_type = type_of::type_of(cx, tuple_type);\n \n-    let component_descriptions = do component_types.map |&component_type| {\n-        MemberDescription {\n-            name: @\"\",\n-            llvm_type: type_of::type_of(cx, component_type),\n-            type_metadata: type_metadata(cx, component_type, span),\n-        }\n-    };\n-\n     let loc = span_start(cx, span);\n     let file_metadata = file_metadata(cx, loc.file.name);\n-\n-    return composite_type_metadata(\n-        cx,\n-        tuple_llvm_type,\n-        tuple_name,\n-        component_descriptions,\n-        file_metadata,\n-        file_metadata,\n-        span);\n+    // Needs to be copied for closure below :(\n+    let component_types = component_types.to_owned();\n+\n+    UnfinishedMetadata {\n+        cache_id: cache_id_for_type(tuple_type),\n+        metadata_stub: create_struct_stub(cx,\n+                                          tuple_llvm_type,\n+                                          tuple_name,\n+                                          file_metadata,\n+                                          file_metadata,\n+                                          span),\n+        llvm_type: tuple_llvm_type,\n+        file_metadata: file_metadata,\n+        member_description_factory: |cx| {\n+            do component_types.map |&component_type| {\n+                MemberDescription {\n+                    name: @\"\",\n+                    llvm_type: type_of::type_of(cx, component_type),\n+                    type_metadata: type_metadata(cx, component_type, span),\n+                    offset: ComputedMemberOffset,\n+                }\n+            }\n+        }\n+    }\n }\n \n-fn enum_metadata(cx: &mut CrateContext,\n-                 enum_type: ty::t,\n-                 enum_def_id: ast::DefId,\n-                 span: Span)\n-              -> DIType {\n+fn prepare_enum_metadata(cx: &mut CrateContext,\n+                         enum_type: ty::t,\n+                         enum_def_id: ast::DefId,\n+                         span: Span)\n+                      -> RecursiveTypeDescription {\n     let enum_name = ppaux::ty_to_str(cx.tcx, enum_type);\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx,\n@@ -1143,24 +1236,26 @@ fn enum_metadata(cx: &mut CrateContext,\n     // For empty enums there is an early exit. Just describe it as an empty struct with the\n     // appropriate type name\n     if ty::type_is_empty(cx.tcx, enum_type) {\n-        return composite_type_metadata(cx,\n-                                       Type::nil(),\n-                                       enum_name,\n-                                       [],\n-                                       file_metadata,\n-                                       file_metadata,\n-                                       definition_span);\n+        let empty_type_metadata = composite_type_metadata(cx,\n+                                                          Type::nil(),\n+                                                          enum_name,\n+                                                          [],\n+                                                          containing_scope,\n+                                                          file_metadata,\n+                                                          definition_span);\n+\n+        return FinalMetadata(empty_type_metadata);\n     }\n \n-    // Prepare some data (llvm type, size, align, ...) about the discriminant. This data will be\n+    // Prepare some data (llvm type, size, align, etc) about the discriminant. This data will be\n     // needed in all of the following cases.\n     let discriminant_llvm_type = Type::enum_discrim(cx);\n     let (discriminant_size, discriminant_align) = size_and_align_of(cx, discriminant_llvm_type);\n \n     assert!(Type::enum_discrim(cx) == cx.int_type);\n     let discriminant_base_type_metadata = type_metadata(cx, ty::mk_int(), codemap::dummy_sp());\n \n-    let variants: &[@ty::VariantInfo] = *ty::enum_variants(cx.tcx, enum_def_id);\n+    let variants = ty::enum_variants(cx.tcx, enum_def_id);\n \n     let enumerators_metadata: ~[DIDescriptor] = variants\n         .iter()\n@@ -1196,55 +1291,34 @@ fn enum_metadata(cx: &mut CrateContext,\n \n     let type_rep = adt::represent_type(cx, enum_type);\n \n-    match *type_rep {\n+    return match *type_rep {\n         adt::CEnum(*) => {\n-            return discriminant_type_metadata;\n+            FinalMetadata(discriminant_type_metadata)\n         }\n         adt::Univariant(ref struct_def, _) => {\n             assert!(variants.len() == 1);\n-            return adt_struct_metadata(cx,\n-                                       struct_def,\n-                                       variants[0],\n-                                       None,\n-                                       containing_scope,\n-                                       file_metadata,\n-                                       span);\n+            let (metadata_stub,\n+                 variant_llvm_type,\n+                 member_description_factory) = describe_variant(cx,\n+                                                                struct_def,\n+                                                                variants[0],\n+                                                                None,\n+                                                                containing_scope,\n+                                                                file_metadata,\n+                                                                span);\n+            UnfinishedMetadata {\n+                cache_id: cache_id_for_type(enum_type),\n+                metadata_stub: metadata_stub,\n+                llvm_type: variant_llvm_type,\n+                file_metadata: file_metadata,\n+                member_description_factory: member_description_factory\n+            }\n         }\n-        adt::General(ref struct_defs) => {\n-            let variants_member_metadata: ~[DIDescriptor] = do struct_defs\n-                .iter()\n-                .enumerate()\n-                .map |(i, struct_def)| {\n-                    let variant_type_metadata = adt_struct_metadata(\n-                        cx,\n-                        struct_def,\n-                        variants[i],\n-                        Some(discriminant_type_metadata),\n-                        containing_scope,\n-                        file_metadata,\n-                        span);\n-\n-                    do \"\".with_c_str |name| {\n-                        unsafe {\n-                            llvm::LLVMDIBuilderCreateMemberType(\n-                                DIB(cx),\n-                                containing_scope,\n-                                name,\n-                                file_metadata,\n-                                loc.line as c_uint,\n-                                bytes_to_bits(struct_def.size as uint),\n-                                bytes_to_bits(struct_def.align as uint),\n-                                bytes_to_bits(0),\n-                                0,\n-                                variant_type_metadata)\n-                        }\n-                    }\n-            }.collect();\n-\n+        adt::General(_) => {\n             let enum_llvm_type = type_of::type_of(cx, enum_type);\n             let (enum_type_size, enum_type_align) = size_and_align_of(cx, enum_llvm_type);\n \n-            return do enum_name.with_c_str |enum_name| {\n+            let enum_metadata = do enum_name.with_c_str |enum_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateUnionType(\n                     DIB(cx),\n@@ -1255,55 +1329,85 @@ fn enum_metadata(cx: &mut CrateContext,\n                     bytes_to_bits(enum_type_size),\n                     bytes_to_bits(enum_type_align),\n                     0, // Flags\n-                    create_DIArray(DIB(cx), variants_member_metadata),\n+                    ptr::null(),\n                     0) // RuntimeLang\n             }};\n+\n+            UnfinishedMetadata {\n+                cache_id: cache_id_for_type(enum_type),\n+                metadata_stub: enum_metadata,\n+                llvm_type: enum_llvm_type,\n+                file_metadata: file_metadata,\n+                member_description_factory: |cx| {\n+                    // Capture type_rep, so we don't have to copy the struct_defs array\n+                    let struct_defs = match *type_rep {\n+                        adt::General(ref struct_defs) => struct_defs,\n+                        _ => cx.sess.bug(\"unreachable\")\n+                    };\n+\n+                    do struct_defs\n+                        .iter()\n+                        .enumerate()\n+                        .map |(i, struct_def)| {\n+                            let (variant_type_metadata, variant_llvm_type, member_desc_factory) =\n+                                describe_variant(cx,\n+                                                 struct_def,\n+                                                 variants[i],\n+                                                 Some(discriminant_type_metadata),\n+                                                 containing_scope,\n+                                                 file_metadata,\n+                                                 span);\n+\n+                            let member_descriptions = member_desc_factory(cx);\n+\n+                            set_members_of_composite_type(cx,\n+                                                          variant_type_metadata,\n+                                                          variant_llvm_type,\n+                                                          member_descriptions,\n+                                                          file_metadata,\n+                                                          codemap::dummy_sp());\n+                            MemberDescription {\n+                                name: @\"\",\n+                                llvm_type: variant_llvm_type,\n+                                type_metadata: variant_type_metadata,\n+                                offset: FixedMemberOffset { bytes: 0 },\n+                            }\n+                    }.collect()\n+                }\n+            }\n         }\n         adt::NullablePointer { nonnull: ref struct_def, nndiscr, _ } => {\n-            return adt_struct_metadata(cx,\n-                                       struct_def,\n-                                       variants[nndiscr],\n-                                       None,\n-                                       containing_scope,\n-                                       file_metadata,\n-                                       span);\n-        }\n-    }\n-\n-    fn adt_struct_metadata(cx: &mut CrateContext,\n-                                  struct_def: &adt::Struct,\n-                                  variant_info: &ty::VariantInfo,\n-                                  discriminant_type_metadata: Option<DIType>,\n-                                  containing_scope: DIScope,\n-                                  file_metadata: DIFile,\n-                                  span: Span)\n-                               -> DICompositeType {\n-        // Get the argument names from the enum variant info\n-        let mut arg_names = match variant_info.arg_names {\n-            Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n-            None => do variant_info.args.map |_| { @\"\" }\n-        };\n-\n-        // If this is not a univariant enum, there is also the (unnamed) discriminant field\n-        if discriminant_type_metadata.is_some() {\n-            arg_names.insert(0, @\"\");\n+            let (metadata_stub,\n+                 variant_llvm_type,\n+                 member_description_factory) = describe_variant(cx,\n+                                                                struct_def,\n+                                                                variants[nndiscr],\n+                                                                None,\n+                                                                containing_scope,\n+                                                                file_metadata,\n+                                                                span);\n+            UnfinishedMetadata {\n+                cache_id: cache_id_for_type(enum_type),\n+                metadata_stub: metadata_stub,\n+                llvm_type: variant_llvm_type,\n+                file_metadata: file_metadata,\n+                member_description_factory: member_description_factory\n+            }\n         }\n+    };\n \n-        let arg_descriptions : ~[MemberDescription] =\n-            do struct_def.fields.iter().enumerate().map |(i, &ty)| {\n-                MemberDescription {\n-                    name: arg_names[i].clone(),\n-                    llvm_type: type_of::type_of(cx, ty),\n-                    type_metadata: match discriminant_type_metadata {\n-                        Some(metadata) if i == 0 => metadata,\n-                        _                        => type_metadata(cx, ty, span)\n-                    }\n-                }\n-            }.collect();\n-\n+    fn describe_variant(cx: &mut CrateContext,\n+                        struct_def: &adt::Struct,\n+                        variant_info: &ty::VariantInfo,\n+                        discriminant_type_metadata: Option<DIType>,\n+                        containing_scope: DIScope,\n+                        file_metadata: DIFile,\n+                        span: Span)\n+                     -> (DICompositeType, Type, @fn(&mut CrateContext) -> ~[MemberDescription]) {\n         let variant_name = token::ident_to_str(&variant_info.name);\n-        let variant_llvm_type = Type::struct_(arg_descriptions.map(|d| d.llvm_type),\n+        let variant_llvm_type = Type::struct_(struct_def.fields.map(|&t| type_of::type_of(cx, t)),\n                                               struct_def.packed);\n+        // Could some consistency checks here: size, align, field count, discr type\n \n         // Find the source code location of the variant's definition\n         let variant_definition_span = if variant_info.id.crate == ast::LOCAL_CRATE {\n@@ -1321,21 +1425,58 @@ fn enum_metadata(cx: &mut CrateContext,\n             codemap::dummy_sp()\n         };\n \n-        return composite_type_metadata(\n-            cx,\n-            variant_llvm_type,\n-            variant_name,\n-            arg_descriptions,\n-            containing_scope,\n-            file_metadata,\n-            variant_definition_span);\n+        let metadata_stub = create_struct_stub(cx,\n+                                               variant_llvm_type,\n+                                               variant_name,\n+                                               containing_scope,\n+                                               file_metadata,\n+                                               variant_definition_span);\n+\n+        // Get the argument names from the enum variant info\n+        let mut arg_names = match variant_info.arg_names {\n+            Some(ref names) => do names.map |ident| { token::ident_to_str(ident) },\n+            None => do variant_info.args.map |_| { @\"\" }\n+        };\n+\n+        // If this is not a univariant enum, there is also the (unnamed) discriminant field\n+        if discriminant_type_metadata.is_some() {\n+            arg_names.insert(0, @\"\");\n+        }\n+\n+        // Build an array of (field name, field type) pairs to be captured in the factory closure.\n+        let args: ~[(@str, ty::t)] = arg_names.iter()\n+            .zip(struct_def.fields.iter())\n+            .map(|(&s, &t)| (s, t))\n+            .collect();\n+\n+        let member_description_factory: @fn(cx: &mut CrateContext) -> ~[MemberDescription] = |cx| {\n+            do args.iter().enumerate().map |(i, &(name, ty))| {\n+                MemberDescription {\n+                    name: name,\n+                    llvm_type: type_of::type_of(cx, ty),\n+                    type_metadata: match discriminant_type_metadata {\n+                        Some(metadata) if i == 0 => metadata,\n+                        _ => type_metadata(cx, ty, span)\n+                    },\n+                    offset: ComputedMemberOffset,\n+                }\n+            }.collect()\n+        };\n+\n+        (metadata_stub, variant_llvm_type, member_description_factory)\n     }\n }\n \n+enum MemberOffset {\n+    FixedMemberOffset{ bytes: uint },\n+    ComputedMemberOffset\n+}\n+\n struct MemberDescription {\n     name: @str,\n     llvm_type: Type,\n     type_metadata: DIType,\n+    offset: MemberOffset,\n }\n \n /// Creates debug information for a composite type, that is, anything that results in a LLVM struct.\n@@ -1350,21 +1491,58 @@ fn composite_type_metadata(cx: &mut CrateContext,\n                            definition_span: Span)\n                         -> DICompositeType {\n     let loc = span_start(cx, definition_span);\n-\n     let (composite_size, composite_align) = size_and_align_of(cx, composite_llvm_type);\n \n+    let composite_type_metadata = do composite_type_name.with_c_str |name| {\n+        unsafe {\n+            llvm::LLVMDIBuilderCreateStructType(\n+                DIB(cx),\n+                containing_scope,\n+                name,\n+                file_metadata,\n+                loc.line as c_uint,\n+                bytes_to_bits(composite_size),\n+                bytes_to_bits(composite_align),\n+                0,\n+                ptr::null(),\n+                ptr::null(),\n+                0,\n+                ptr::null())\n+    }};\n+\n+    set_members_of_composite_type(cx,\n+                                  composite_type_metadata,\n+                                  composite_llvm_type,\n+                                  member_descriptions,\n+                                  file_metadata,\n+                                  definition_span);\n+\n+    return composite_type_metadata;\n+}\n+\n+fn set_members_of_composite_type(cx: &mut CrateContext,\n+                                 composite_type_metadata: DICompositeType,\n+                                 composite_llvm_type: Type,\n+                                 member_descriptions: &[MemberDescription],\n+                                 file_metadata: DIFile,\n+                                 definition_span: Span) {\n+    let loc = span_start(cx, definition_span);\n+\n     let member_metadata: ~[DIDescriptor] = member_descriptions\n         .iter()\n         .enumerate()\n         .map(|(i, member_description)| {\n             let (member_size, member_align) = size_and_align_of(cx, member_description.llvm_type);\n-            let member_offset = machine::llelement_offset(cx, composite_llvm_type, i);\n+            let member_offset = match member_description.offset {\n+                FixedMemberOffset { bytes } => bytes,\n+                ComputedMemberOffset => machine::llelement_offset(cx, composite_llvm_type, i)\n+            };\n \n             do member_description.name.with_c_str |member_name| {\n                 unsafe {\n                     llvm::LLVMDIBuilderCreateMemberType(\n                         DIB(cx),\n-                        file_metadata,\n+                        composite_type_metadata,\n                         member_name,\n                         file_metadata,\n                         loc.line as c_uint,\n@@ -1378,19 +1556,37 @@ fn composite_type_metadata(cx: &mut CrateContext,\n         })\n         .collect();\n \n-    return do composite_type_name.with_c_str |name| {\n+    unsafe {\n+        let type_array = create_DIArray(DIB(cx), member_metadata);\n+        llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n+    }\n+}\n+\n+// A convenience wrapper around LLVMDIBuilderCreateStructType(). Does not do any caching, does not\n+// add any fields to the struct. This can be done later with LLVMDICompositeTypeSetTypeArray().\n+fn create_struct_stub(cx: &mut CrateContext,\n+                      struct_llvm_type: Type,\n+                      struct_type_name: &str,\n+                      containing_scope: DIScope,\n+                      file_metadata: DIFile,\n+                      definition_span: Span)\n+                   -> DICompositeType {\n+    let loc = span_start(cx, definition_span);\n+    let (struct_size, struct_align) = size_and_align_of(cx, struct_llvm_type);\n+\n+    return do struct_type_name.with_c_str |name| {\n         unsafe {\n             llvm::LLVMDIBuilderCreateStructType(\n                 DIB(cx),\n                 containing_scope,\n                 name,\n                 file_metadata,\n                 loc.line as c_uint,\n-                bytes_to_bits(composite_size),\n-                bytes_to_bits(composite_align),\n+                bytes_to_bits(struct_size),\n+                bytes_to_bits(struct_align),\n                 0,\n                 ptr::null(),\n-                create_DIArray(DIB(cx), member_metadata),\n+                ptr::null(),\n                 0,\n                 ptr::null())\n     }};\n@@ -1420,26 +1616,31 @@ fn boxed_type_metadata(cx: &mut CrateContext,\n             name: @\"refcnt\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: type_metadata(cx, int_type, codemap::dummy_sp()),\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"tydesc\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: nil_pointer_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"prev\",\n             llvm_type: member_llvm_types[2],\n             type_metadata: nil_pointer_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"next\",\n             llvm_type: member_llvm_types[3],\n             type_metadata: nil_pointer_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"val\",\n             llvm_type: member_llvm_types[4],\n-            type_metadata: content_type_metadata\n+            type_metadata: content_type_metadata,\n+            offset: ComputedMemberOffset,\n         }\n     ];\n \n@@ -1526,16 +1727,19 @@ fn vec_metadata(cx: &mut CrateContext,\n             name: @\"fill\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: int_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"alloc\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: int_type_metadata,\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"elements\",\n             llvm_type: member_llvm_types[2],\n             type_metadata: array_type_metadata,\n+            offset: ComputedMemberOffset,\n         }\n     ];\n \n@@ -1558,7 +1762,6 @@ fn boxed_vec_metadata(cx: &mut CrateContext,\n                       element_type: ty::t,\n                       span: Span)\n                    -> DICompositeType {\n-\n     let element_llvm_type = type_of::type_of(cx, element_type);\n     let vec_llvm_type = Type::vec(cx.sess.targ_cfg.arch, &element_llvm_type);\n     let vec_type_name: &str = fmt!(\"[%s]\", ppaux::ty_to_str(cx.tcx, element_type));\n@@ -1593,11 +1796,13 @@ fn vec_slice_metadata(cx: &mut CrateContext,\n             name: @\"data_ptr\",\n             llvm_type: member_llvm_types[0],\n             type_metadata: type_metadata(cx, data_ptr_type, span),\n+            offset: ComputedMemberOffset,\n         },\n         MemberDescription {\n             name: @\"size_in_bytes\",\n             llvm_type: member_llvm_types[1],\n             type_metadata: type_metadata(cx, ty::mk_uint(), span),\n+            offset: ComputedMemberOffset,\n         },\n     ];\n \n@@ -1708,12 +1913,16 @@ fn unimplemented_type_metadata(cx: &mut CrateContext, t: ty::t) -> DIType {\n     return metadata;\n }\n \n+fn cache_id_for_type(t: ty::t) -> uint {\n+    ty::type_id(t)\n+}\n+\n fn type_metadata(cx: &mut CrateContext,\n                  t: ty::t,\n                  usage_site_span: Span)\n               -> DIType {\n-    let type_id = ty::type_id(t);\n-    match debug_context(cx).created_types.find(&type_id) {\n+    let cache_id = cache_id_for_type(t);\n+    match debug_context(cx).created_types.find(&cache_id) {\n         Some(type_metadata) => return *type_metadata,\n         None => ()\n     }\n@@ -1722,7 +1931,6 @@ fn type_metadata(cx: &mut CrateContext,\n                                       pointer_type: ty::t,\n                                       type_in_box: ty::t)\n                                    -> DIType {\n-\n         let content_type_name: &str = ppaux::ty_to_str(cx.tcx, type_in_box);\n         let content_llvm_type = type_of::type_of(cx, type_in_box);\n         let content_type_metadata = type_metadata(\n@@ -1773,7 +1981,7 @@ fn type_metadata(cx: &mut CrateContext,\n             }\n         },\n         ty::ty_enum(def_id, _) => {\n-            enum_metadata(cx, t, def_id, usage_site_span)\n+            prepare_enum_metadata(cx, t, def_id, usage_site_span).finalize(cx)\n         },\n         ty::ty_box(ref mt) => {\n             create_pointer_to_box_metadata(cx, t, mt.ty)\n@@ -1819,18 +2027,18 @@ fn type_metadata(cx: &mut CrateContext,\n             trait_metadata(cx, def_id, t, substs, trait_store, mutability, bounds, usage_site_span)\n         },\n         ty::ty_struct(def_id, ref substs) => {\n-            struct_metadata(cx, t, def_id, substs, usage_site_span)\n+            prepare_struct_metadata(cx, t, def_id, substs, usage_site_span).finalize(cx)\n         },\n         ty::ty_tup(ref elements) => {\n-            tuple_metadata(cx, t, *elements, usage_site_span)\n+            prepare_tuple_metadata(cx, t, *elements, usage_site_span).finalize(cx)\n         },\n         ty::ty_opaque_box => {\n             create_pointer_to_box_metadata(cx, t, ty::mk_nil())\n         }\n         _ => cx.sess.bug(fmt!(\"debuginfo: unexpected type in type_metadata: %?\", sty))\n     };\n \n-    debug_context(cx).created_types.insert(type_id, type_metadata);\n+    debug_context(cx).created_types.insert(cache_id, type_metadata);\n     return type_metadata;\n }\n "}, {"sha": "9aca0705911125a5b4e016124ea0434805bdaf7c", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f85da506a88265f7e541ef548c644527f7510945/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/f85da506a88265f7e541ef548c644527f7510945/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=f85da506a88265f7e541ef548c644527f7510945", "patch": "@@ -789,3 +789,33 @@ extern \"C\" LLVMValueRef LLVMDIBuilderCreateNameSpace(\n         unwrapDI<DIFile>(File),\n         LineNo));\n }\n+\n+// extern \"C\" LLVMValueRef LLVMDIBuilderCreateForwardDecl(\n+//     DIBuilderRef Builder,\n+//     unsigned Tag,\n+//     const char* Name,\n+//     LLVMValueRef Scope,\n+//     LLVMValueRef File,\n+//     unsigned Line,\n+//     unsigned RuntimeLang,\n+//     uint64_t SizeInBits,\n+//     uint64_t AlignInBits)\n+// {\n+//     return wrap(Builder->createForwardDecl(\n+//         Tag,\n+//         Name,\n+//         unwrapDI<DIDescriptor>(Scope),\n+//         unwrapDI<DIFile>(File),\n+//         Line,\n+//         RuntimeLang,\n+//         SizeInBits,\n+//         AlignInBits\n+//     ));\n+// }\n+\n+extern \"C\" void LLVMDICompositeTypeSetTypeArray(\n+    LLVMValueRef CompositeType,\n+    LLVMValueRef TypeArray)\n+{\n+    unwrapDI<DICompositeType>(CompositeType).setTypeArray(unwrapDI<DIArray>(TypeArray));\n+}"}]}