{"sha": "ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlNWY3MjI0YjVlZTA4Zjk3NjJiZWZiMjZlY2NiOGFkMjZjZGJjYmM=", "commit": {"author": {"name": "Lucas Molas", "email": "schomatis@gmail.com", "date": "2019-02-15T05:01:29Z"}, "committer": {"name": "Lucas Molas", "email": "schomatis@gmail.com", "date": "2019-02-16T00:46:17Z"}, "message": "nll: remove `IdentityMap` and `LiveVariableMap`\n\nWith `NllLivenessMap` and `LiveVar` removed, the `IdentityMap` (remaining\nstructure implementing the `LiveVariableMap` trait) loses its meaning.\n\nSpecialize the `LiveVarSet` to a `BitSet<Local>` removing the `V` and related\nparameters. The `LiveVarSet<V>` was only being used as `LiveVarSet<Local>` so\nthis commit doesn't bring any change to the logic, it just removes an unused\nparameter (that without `LiveVar` now, it couldn't have been specialized to\nanything but `Local`).", "tree": {"sha": "691a91e4775de92ba5defa6906e7a4312dd26eff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/691a91e4775de92ba5defa6906e7a4312dd26eff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc", "html_url": "https://github.com/rust-lang/rust/commit/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc/comments", "author": {"login": "schomatis", "id": 10407385, "node_id": "MDQ6VXNlcjEwNDA3Mzg1", "avatar_url": "https://avatars.githubusercontent.com/u/10407385?v=4", "gravatar_id": "", "url": "https://api.github.com/users/schomatis", "html_url": "https://github.com/schomatis", "followers_url": "https://api.github.com/users/schomatis/followers", "following_url": "https://api.github.com/users/schomatis/following{/other_user}", "gists_url": "https://api.github.com/users/schomatis/gists{/gist_id}", "starred_url": "https://api.github.com/users/schomatis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/schomatis/subscriptions", "organizations_url": "https://api.github.com/users/schomatis/orgs", "repos_url": "https://api.github.com/users/schomatis/repos", "events_url": "https://api.github.com/users/schomatis/events{/privacy}", "received_events_url": "https://api.github.com/users/schomatis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "schomatis", "id": 10407385, "node_id": "MDQ6VXNlcjEwNDA3Mzg1", "avatar_url": "https://avatars.githubusercontent.com/u/10407385?v=4", "gravatar_id": "", "url": "https://api.github.com/users/schomatis", "html_url": "https://github.com/schomatis", "followers_url": "https://api.github.com/users/schomatis/followers", "following_url": "https://api.github.com/users/schomatis/following{/other_user}", "gists_url": "https://api.github.com/users/schomatis/gists{/gist_id}", "starred_url": "https://api.github.com/users/schomatis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/schomatis/subscriptions", "organizations_url": "https://api.github.com/users/schomatis/orgs", "repos_url": "https://api.github.com/users/schomatis/repos", "events_url": "https://api.github.com/users/schomatis/events{/privacy}", "received_events_url": "https://api.github.com/users/schomatis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6ede9192d520ffda332e337418b00d357082dd6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ede9192d520ffda332e337418b00d357082dd6", "html_url": "https://github.com/rust-lang/rust/commit/d6ede9192d520ffda332e337418b00d357082dd6"}], "stats": {"total": 138, "additions": 41, "deletions": 97}, "files": [{"sha": "2c305197328ad582f7a0615d12c9936357edd9e5", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc", "patch": "@@ -68,7 +68,7 @@ use crate::transform::no_landing_pads::no_landing_pads;\n use crate::dataflow::{do_dataflow, DebugFormatted, state_for_location};\n use crate::dataflow::{MaybeStorageLive, HaveBeenBorrowedLocals};\n use crate::util::dump_mir;\n-use crate::util::liveness::{self, IdentityMap};\n+use crate::util::liveness;\n \n pub struct StateTransform;\n \n@@ -148,7 +148,7 @@ struct SuspensionPoint {\n     state: u32,\n     resume: BasicBlock,\n     drop: Option<BasicBlock>,\n-    storage_liveness: liveness::LiveVarSet<Local>,\n+    storage_liveness: liveness::LiveVarSet,\n }\n \n struct TransformVisitor<'a, 'tcx: 'a> {\n@@ -165,7 +165,7 @@ struct TransformVisitor<'a, 'tcx: 'a> {\n \n     // A map from a suspension point in a block to the locals which have live storage at that point\n     // FIXME(eddyb) This should use `IndexVec<BasicBlock, Option<_>>`.\n-    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>,\n+    storage_liveness: FxHashMap<BasicBlock, liveness::LiveVarSet>,\n \n     // A list of suspension points, generated during the transform\n     suspension_points: Vec<SuspensionPoint>,\n@@ -358,7 +358,7 @@ fn replace_result_variable<'tcx>(\n     new_ret_local\n }\n \n-struct StorageIgnored(liveness::LiveVarSet<Local>);\n+struct StorageIgnored(liveness::LiveVarSet);\n \n impl<'tcx> Visitor<'tcx> for StorageIgnored {\n     fn visit_statement(&mut self,\n@@ -379,8 +379,8 @@ fn locals_live_across_suspend_points(\n     source: MirSource<'tcx>,\n     movable: bool,\n ) -> (\n-    liveness::LiveVarSet<Local>,\n-    FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>,\n+    liveness::LiveVarSet,\n+    FxHashMap<BasicBlock, liveness::LiveVarSet>,\n ) {\n     let dead_unwinds = BitSet::new_empty(mir.basic_blocks().len());\n     let node_id = tcx.hir().as_local_node_id(source.def_id()).unwrap();\n@@ -414,14 +414,12 @@ fn locals_live_across_suspend_points(\n     let mut set = liveness::LiveVarSet::new_empty(mir.local_decls.len());\n     let mut liveness = liveness::liveness_of_locals(\n         mir,\n-        &IdentityMap::new(mir),\n     );\n     liveness::dump_mir(\n         tcx,\n         \"generator_liveness\",\n         source,\n         mir,\n-        &IdentityMap::new(mir),\n         &liveness,\n     );\n \n@@ -491,7 +489,7 @@ fn compute_layout<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                             mir: &mut Mir<'tcx>)\n     -> (FxHashMap<Local, (Ty<'tcx>, usize)>,\n         GeneratorLayout<'tcx>,\n-        FxHashMap<BasicBlock, liveness::LiveVarSet<Local>>)\n+        FxHashMap<BasicBlock, liveness::LiveVarSet>)\n {\n     // Use a liveness analysis to compute locals which are live across a suspension point\n     let (live_locals, storage_liveness) = locals_live_across_suspend_points(tcx,"}, {"sha": "9cda6cfdacbe3eab231eaae1eb1922366ba37f7a", "filename": "src/librustc_mir/util/liveness.rs", "status": "modified", "additions": 34, "deletions": 88, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc/src%2Flibrustc_mir%2Futil%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fliveness.rs?ref=ae5f7224b5ee08f9762befb26eccb8ad26cdbcbc", "patch": "@@ -39,7 +39,7 @@ use std::path::{Path, PathBuf};\n use crate::transform::MirSource;\n use crate::util::pretty::{dump_enabled, write_basic_block, write_mir_intro};\n \n-pub type LiveVarSet<V> = BitSet<V>;\n+pub type LiveVarSet = BitSet<Local>;\n \n /// This gives the result of the liveness analysis at the boundary of\n /// basic blocks.\n@@ -48,66 +48,27 @@ pub type LiveVarSet<V> = BitSet<V>;\n /// liveness for. This is often `Local`, in which case we computed\n /// liveness for all variables -- but it can also be some other type,\n /// which indicates a subset of the variables within the graph.\n-pub struct LivenessResult<V: Idx> {\n+pub struct LivenessResult {\n     /// Live variables on exit to each basic block. This is equal to\n     /// the union of the `ins` for each successor.\n-    pub outs: IndexVec<BasicBlock, LiveVarSet<V>>,\n-}\n-\n-/// Defines the mapping to/from the MIR local variables (`Local`) to\n-/// the \"live variable indices\" we are using in a particular\n-/// computation.\n-pub trait LiveVariableMap {\n-    type LiveVar;\n-\n-    fn from_local(&self, local: Local) -> Option<Self::LiveVar>;\n-    fn from_live_var(&self, local: Self::LiveVar) -> Local;\n-    fn num_variables(&self) -> usize;\n-}\n-\n-#[derive(Debug)]\n-pub struct IdentityMap<'a, 'tcx: 'a> {\n-    mir: &'a Mir<'tcx>,\n-}\n-\n-impl<'a, 'tcx> IdentityMap<'a, 'tcx> {\n-    pub fn new(mir: &'a Mir<'tcx>) -> Self {\n-        Self { mir }\n-    }\n-}\n-\n-impl<'a, 'tcx> LiveVariableMap for IdentityMap<'a, 'tcx> {\n-    type LiveVar = Local;\n-\n-    fn from_local(&self, local: Local) -> Option<Self::LiveVar> {\n-        Some(local)\n-    }\n-\n-    fn from_live_var(&self, local: Self::LiveVar) -> Local {\n-        local\n-    }\n-\n-    fn num_variables(&self) -> usize {\n-        self.mir.local_decls.len()\n-    }\n+    pub outs: IndexVec<BasicBlock, LiveVarSet>,\n }\n \n /// Computes which local variables are live within the given function\n /// `mir`. The liveness mode `mode` determines what sorts of uses are\n /// considered to make a variable live (e.g., do drops count?).\n-pub fn liveness_of_locals<'tcx, V: Idx>(\n+pub fn liveness_of_locals<'tcx>(\n     mir: &Mir<'tcx>,\n-    map: &impl LiveVariableMap<LiveVar = V>,\n-) -> LivenessResult<V> {\n-    let num_live_vars = map.num_variables();\n+) -> LivenessResult {\n+    let num_live_vars = mir.local_decls.len();\n \n-    let def_use: IndexVec<_, DefsUses<V>> = mir\n+    let def_use: IndexVec<_, DefsUses> = mir\n         .basic_blocks()\n         .iter()\n-        .map(|b| block(map, b, num_live_vars))\n+        .map(|b| block(b, num_live_vars))\n         .collect();\n \n-    let mut outs: IndexVec<_, LiveVarSet<V>> = mir\n+    let mut outs: IndexVec<_, LiveVarSet> = mir\n         .basic_blocks()\n         .indices()\n         .map(|_| LiveVarSet::new_empty(num_live_vars))\n@@ -211,27 +172,23 @@ pub fn categorize<'tcx>(context: PlaceContext<'tcx>) -> Option<DefUse> {\n     }\n }\n \n-struct DefsUsesVisitor<'lv, V, M>\n-where\n-    V: Idx,\n-    M: LiveVariableMap<LiveVar = V> + 'lv,\n+struct DefsUsesVisitor\n {\n-    map: &'lv M,\n-    defs_uses: DefsUses<V>,\n+    defs_uses: DefsUses,\n }\n \n #[derive(Eq, PartialEq, Clone)]\n-struct DefsUses<V: Idx> {\n-    defs: LiveVarSet<V>,\n-    uses: LiveVarSet<V>,\n+struct DefsUses {\n+    defs: LiveVarSet,\n+    uses: LiveVarSet,\n }\n \n-impl<V: Idx> DefsUses<V> {\n-    fn apply(&self, bits: &mut LiveVarSet<V>) -> bool {\n+impl DefsUses {\n+    fn apply(&self, bits: &mut LiveVarSet) -> bool {\n         bits.subtract(&self.defs) | bits.union(&self.uses)\n     }\n \n-    fn add_def(&mut self, index: V) {\n+    fn add_def(&mut self, index: Local) {\n         // If it was used already in the block, remove that use\n         // now that we found a definition.\n         //\n@@ -245,7 +202,7 @@ impl<V: Idx> DefsUses<V> {\n         self.defs.insert(index);\n     }\n \n-    fn add_use(&mut self, index: V) {\n+    fn add_use(&mut self, index: Local) {\n         // Inverse of above.\n         //\n         // Example:\n@@ -261,29 +218,22 @@ impl<V: Idx> DefsUses<V> {\n     }\n }\n \n-impl<'tcx, 'lv, V, M> Visitor<'tcx> for DefsUsesVisitor<'lv, V, M>\n-where\n-    V: Idx,\n-    M: LiveVariableMap<LiveVar = V>,\n+impl<'tcx> Visitor<'tcx> for DefsUsesVisitor\n {\n     fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, _: Location) {\n-        if let Some(v_index) = self.map.from_local(local) {\n-            match categorize(context) {\n-                Some(DefUse::Def) => self.defs_uses.add_def(v_index),\n-                Some(DefUse::Use) | Some(DefUse::Drop) => self.defs_uses.add_use(v_index),\n-                _ => (),\n-            }\n+        match categorize(context) {\n+            Some(DefUse::Def) => self.defs_uses.add_def(local),\n+            Some(DefUse::Use) | Some(DefUse::Drop) => self.defs_uses.add_use(local),\n+            _ => (),\n         }\n     }\n }\n \n-fn block<'tcx, V: Idx>(\n-    map: &impl LiveVariableMap<LiveVar = V>,\n+fn block<'tcx>(\n     b: &BasicBlockData<'tcx>,\n     locals: usize,\n-) -> DefsUses<V> {\n+) -> DefsUses {\n     let mut visitor = DefsUsesVisitor {\n-        map,\n         defs_uses: DefsUses {\n             defs: LiveVarSet::new_empty(locals),\n             uses: LiveVarSet::new_empty(locals),\n@@ -305,13 +255,12 @@ fn block<'tcx, V: Idx>(\n     visitor.defs_uses\n }\n \n-pub fn dump_mir<'a, 'tcx, V: Idx>(\n+pub fn dump_mir<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     source: MirSource<'tcx>,\n     mir: &Mir<'tcx>,\n-    map: &impl LiveVariableMap<LiveVar = V>,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult,\n ) {\n     if !dump_enabled(tcx, pass_name, source) {\n         return;\n@@ -320,17 +269,16 @@ pub fn dump_mir<'a, 'tcx, V: Idx>(\n         // see notes on #41697 below\n         tcx.item_path_str(source.def_id())\n     });\n-    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, map, result);\n+    dump_matched_mir_node(tcx, pass_name, &node_path, source, mir, result);\n }\n \n-fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n+fn dump_matched_mir_node<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     pass_name: &str,\n     node_path: &str,\n     source: MirSource<'tcx>,\n     mir: &Mir<'tcx>,\n-    map: &dyn LiveVariableMap<LiveVar = V>,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult,\n ) {\n     let mut file_path = PathBuf::new();\n     file_path.push(Path::new(&tcx.sess.opts.debugging_opts.dump_mir_dir));\n@@ -342,25 +290,23 @@ fn dump_matched_mir_node<'a, 'tcx, V: Idx>(\n         writeln!(file, \"// source = {:?}\", source)?;\n         writeln!(file, \"// pass_name = {}\", pass_name)?;\n         writeln!(file, \"\")?;\n-        write_mir_fn(tcx, source, mir, map, &mut file, result)?;\n+        write_mir_fn(tcx, source, mir, &mut file, result)?;\n         Ok(())\n     });\n }\n \n-pub fn write_mir_fn<'a, 'tcx, V: Idx>(\n+pub fn write_mir_fn<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     src: MirSource<'tcx>,\n     mir: &Mir<'tcx>,\n-    map: &dyn LiveVariableMap<LiveVar = V>,\n     w: &mut dyn Write,\n-    result: &LivenessResult<V>,\n+    result: &LivenessResult,\n ) -> io::Result<()> {\n     write_mir_intro(tcx, src, mir, w)?;\n     for block in mir.basic_blocks().indices() {\n-        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet<V>>| {\n+        let print = |w: &mut dyn Write, prefix, result: &IndexVec<BasicBlock, LiveVarSet>| {\n             let live: Vec<String> = result[block]\n                 .iter()\n-                .map(|v| map.from_live_var(v))\n                 .map(|local| format!(\"{:?}\", local))\n                 .collect();\n             writeln!(w, \"{} {{{}}}\", prefix, live.join(\", \"))"}]}