{"sha": "3b40230a3220c33178dd797c7c6d0a75f9b67ef0", "node_id": "C_kwDOAAsO6NoAKDNiNDAyMzBhMzIyMGMzMzE3OGRkNzk3YzdjNmQwYTc1ZjliNjdlZjA", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-04-10T13:31:33Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-04-10T13:31:33Z"}, "message": "Merge #11953\n\n11953: fix: `extract_module` is too eager r=Veykril a=iDawer\n\nRefactored `extract_module`.\r\nSearching for usages and import resolving are done lazily.\r\n\r\nClose #11944 \n\nCo-authored-by: iDawer <ilnur.iskhakov.oss@outlook.com>", "tree": {"sha": "23540d08e1747f5e30751b6b713e120ce2685678", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/23540d08e1747f5e30751b6b713e120ce2685678"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b40230a3220c33178dd797c7c6d0a75f9b67ef0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiUtw1CRBK7hj4Ov3rIwAA2pcIAJKIvORJdfNhQVieP734Q2Iq\nFswC6iBZtqel9yPM5VyjW1gXH/KIV/Sxdhx02GEObp6m9MBFX7TTwu12ljMYBm2B\nPvA5A0ZY6BnIYo8gXkOW/2ad5qHNQ42EyOLV6BsD2ZYvk9vycZXCNtKFcRI7lI/v\nb/lrRTUG9AeWbGXDuDII2c6X5BbYjpSKzSAW6hMv+FRo6HTZjD799dlmo8Z0d3GG\nmdGpRCSqGaVYCeLDrWi9KRmGxxkUzUpFBAm/741kUF0dcUnYd4qxzLmSebPcOen0\nNKuqYOEoLIts4aptNTDtejqqYNcVECeMWjpUNBG0cOqKh/M4odTfrNrKzD5x/3E=\n=Hmpp\n-----END PGP SIGNATURE-----\n", "payload": "tree 23540d08e1747f5e30751b6b713e120ce2685678\nparent e691ae0ab287a77dcf42842d7c564362b45460eb\nparent 6fff2c17988eaa78a994becf46e49179692bbbaf\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1649597493 +0000\ncommitter GitHub <noreply@github.com> 1649597493 +0000\n\nMerge #11953\n\n11953: fix: `extract_module` is too eager r=Veykril a=iDawer\n\nRefactored `extract_module`.\r\nSearching for usages and import resolving are done lazily.\r\n\r\nClose #11944 \n\nCo-authored-by: iDawer <ilnur.iskhakov.oss@outlook.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b40230a3220c33178dd797c7c6d0a75f9b67ef0", "html_url": "https://github.com/rust-lang/rust/commit/3b40230a3220c33178dd797c7c6d0a75f9b67ef0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b40230a3220c33178dd797c7c6d0a75f9b67ef0/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e691ae0ab287a77dcf42842d7c564362b45460eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/e691ae0ab287a77dcf42842d7c564362b45460eb", "html_url": "https://github.com/rust-lang/rust/commit/e691ae0ab287a77dcf42842d7c564362b45460eb"}, {"sha": "6fff2c17988eaa78a994becf46e49179692bbbaf", "url": "https://api.github.com/repos/rust-lang/rust/commits/6fff2c17988eaa78a994becf46e49179692bbbaf", "html_url": "https://github.com/rust-lang/rust/commit/6fff2c17988eaa78a994becf46e49179692bbbaf"}], "stats": {"total": 261, "additions": 96, "deletions": 165}, "files": [{"sha": "b5ed5699c90c6c7cbab88aa218d104dd2db3f723", "filename": "crates/ide_assists/src/handlers/extract_module.rs", "status": "modified", "additions": 96, "deletions": 165, "changes": 261, "blob_url": "https://github.com/rust-lang/rust/blob/3b40230a3220c33178dd797c7c6d0a75f9b67ef0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b40230a3220c33178dd797c7c6d0a75f9b67ef0/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=3b40230a3220c33178dd797c7c6d0a75f9b67ef0", "patch": "@@ -1,4 +1,7 @@\n-use std::collections::{HashMap, HashSet};\n+use std::{\n+    collections::{HashMap, HashSet},\n+    iter,\n+};\n \n use hir::{HasSource, ModuleSource};\n use ide_db::{\n@@ -81,39 +84,36 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n     }\n \n     let mut module = extract_target(&node, ctx.selection_trimmed())?;\n-    if module.body_items.len() == 0 {\n+    if module.body_items.is_empty() {\n         return None;\n     }\n \n     let old_item_indent = module.body_items[0].indent_level();\n \n-    //This takes place in three steps:\n-    //\n-    //- Firstly, we will update the references(usages) e.g. converting a\n-    //  function call bar() to modname::bar(), and similarly for other items\n-    //\n-    //- Secondly, changing the visibility of each item inside the newly selected module\n-    //  i.e. making a fn a() {} to pub(crate) fn a() {}\n-    //\n-    //- Thirdly, resolving all the imports this includes removing paths from imports\n-    //  outside the module, shifting/cloning them inside new module, or shifting the imports, or making\n-    //  new import statemnts\n-\n-    //We are getting item usages and record_fields together, record_fields\n-    //for change_visibility and usages for first point mentioned above in the process\n-    let (usages_to_be_processed, record_fields) = module.get_usages_and_record_fields(ctx);\n-\n-    let import_paths_to_be_removed = module.resolve_imports(curr_parent_module, ctx);\n-    module.body_items = module.change_visibility(record_fields)?;\n-    if module.body_items.len() == 0 {\n-        return None;\n-    }\n-\n     acc.add(\n         AssistId(\"extract_module\", AssistKind::RefactorExtract),\n         \"Extract Module\",\n         module.text_range,\n         |builder| {\n+            //This takes place in three steps:\n+            //\n+            //- Firstly, we will update the references(usages) e.g. converting a\n+            //  function call bar() to modname::bar(), and similarly for other items\n+            //\n+            //- Secondly, changing the visibility of each item inside the newly selected module\n+            //  i.e. making a fn a() {} to pub(crate) fn a() {}\n+            //\n+            //- Thirdly, resolving all the imports this includes removing paths from imports\n+            //  outside the module, shifting/cloning them inside new module, or shifting the imports, or making\n+            //  new import statemnts\n+\n+            //We are getting item usages and record_fields together, record_fields\n+            //for change_visibility and usages for first point mentioned above in the process\n+            let (usages_to_be_processed, record_fields) = module.get_usages_and_record_fields(ctx);\n+\n+            let import_paths_to_be_removed = module.resolve_imports(curr_parent_module, ctx);\n+            module.change_visibility(record_fields);\n+\n             let mut body_items: Vec<String> = Vec::new();\n             let mut items_to_be_processed: Vec<ast::Item> = module.body_items.clone();\n             let mut new_item_indent = old_item_indent + 1;\n@@ -149,17 +149,11 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n                     body = impl_body_def;\n \n                     // Add the import for enum/struct corresponding to given impl block\n-                    if let Some(_) = module.make_use_stmt_of_node_with_super(self_ty.syntax()) {\n-                        for item in module.use_items {\n-                            let mut indented_item = String::new();\n-                            format_to!(\n-                                indented_item,\n-                                \"{}{}\",\n-                                old_item_indent + 1,\n-                                item.to_string()\n-                            );\n-                            body = format!(\"{}\\n\\n{}\", indented_item, body);\n-                        }\n+                    module.make_use_stmt_of_node_with_super(self_ty.syntax());\n+                    for item in module.use_items {\n+                        let mut indented_item = String::new();\n+                        format_to!(indented_item, \"{}{}\", old_item_indent + 1, item.to_string());\n+                        body = format!(\"{}\\n\\n{}\", indented_item, body);\n                     }\n                 }\n             }\n@@ -216,37 +210,25 @@ pub(crate) fn extract_module(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n #[derive(Debug)]\n struct Module {\n     text_range: TextRange,\n-    name: String,\n-    body_items: Vec<ast::Item>, // All items except use items\n-    use_items: Vec<ast::Item>, // Use items are kept separately as they help when the selection is inside an impl block, we can directly take these items and keep them outside generated impl block inside generated module\n+    name: &'static str,\n+    /// All items except use items.\n+    body_items: Vec<ast::Item>,\n+    /// Use items are kept separately as they help when the selection is inside an impl block,\n+    /// we can directly take these items and keep them outside generated impl block inside\n+    /// generated module.\n+    use_items: Vec<ast::Item>,\n }\n \n fn extract_target(node: &SyntaxNode, selection_range: TextRange) -> Option<Module> {\n-    let mut use_items = vec![];\n-\n-    let mut body_items: Vec<ast::Item> = node\n+    let selected_nodes = node\n         .children()\n-        .filter_map(|child| {\n-            if selection_range.contains_range(child.text_range()) {\n-                let child_kind = child.kind();\n-                if let Some(item) = ast::Item::cast(child) {\n-                    if ast::Use::can_cast(child_kind) {\n-                        use_items.push(item);\n-                    } else {\n-                        return Some(item);\n-                    }\n-                }\n-                return None;\n-            }\n-            None\n-        })\n-        .collect();\n+        .filter(|node| selection_range.contains_range(node.text_range()))\n+        .chain(iter::once(node.clone()));\n+    let (use_items, body_items) = selected_nodes\n+        .filter_map(ast::Item::cast)\n+        .partition(|item| matches!(item, ast::Item::Use(..)));\n \n-    if let Some(node_item) = ast::Item::cast(node.clone()) {\n-        body_items.push(node_item);\n-    }\n-\n-    Some(Module { text_range: selection_range, name: \"modname\".to_string(), body_items, use_items })\n+    Some(Module { text_range: selection_range, name: \"modname\", body_items, use_items })\n }\n \n impl Module {\n@@ -260,7 +242,7 @@ impl Module {\n         //Here impl is not included as each item inside impl will be tied to the parent of\n         //implementing block(a struct, enum, etc), if the parent is in selected module, it will\n         //get updated by ADT section given below or if it is not, then we dont need to do any operation\n-        self.body_items.iter().cloned().for_each(|item| {\n+        for item in &self.body_items {\n             match_ast! {\n                 match (item.syntax()) {\n                     ast::Adt(it) => {\n@@ -329,7 +311,7 @@ impl Module {\n                     _ => (),\n                 }\n             }\n-        });\n+        }\n \n         (refs, adt_fields)\n     }\n@@ -338,44 +320,23 @@ impl Module {\n         &self,\n         ctx: &AssistContext,\n         node_def: Definition,\n-        refs: &mut HashMap<FileId, Vec<(TextRange, String)>>,\n+        refs_in_files: &mut HashMap<FileId, Vec<(TextRange, String)>>,\n     ) {\n         for (file_id, references) in node_def.usages(&ctx.sema).all() {\n-            if let Some(file_refs) = refs.get_mut(&file_id) {\n-                let mut usages = self.expand_ref_to_usages(references, ctx, file_id);\n-                file_refs.append(&mut usages);\n-            } else {\n-                refs.insert(file_id, self.expand_ref_to_usages(references, ctx, file_id));\n-            }\n-        }\n-    }\n-\n-    fn expand_ref_to_usages(\n-        &self,\n-        refs: Vec<FileReference>,\n-        ctx: &AssistContext,\n-        file_id: FileId,\n-    ) -> Vec<(TextRange, String)> {\n-        let source_file = ctx.sema.parse(file_id);\n-\n-        let mut usages_to_be_processed_for_file = Vec::new();\n-        for usage in refs {\n-            if let Some(x) = self.get_usage_to_be_processed(&source_file, usage) {\n-                usages_to_be_processed_for_file.push(x);\n-            }\n+            let source_file = ctx.sema.parse(file_id);\n+            let usages_in_file = references\n+                .into_iter()\n+                .filter_map(|usage| self.get_usage_to_be_processed(&source_file, usage));\n+            refs_in_files.entry(file_id).or_default().extend(usages_in_file);\n         }\n-\n-        usages_to_be_processed_for_file\n     }\n \n     fn get_usage_to_be_processed(\n         &self,\n         source_file: &SourceFile,\n         FileReference { range, name, .. }: FileReference,\n     ) -> Option<(TextRange, String)> {\n-        let path: Option<ast::Path> = find_node_at_range(source_file.syntax(), range);\n-\n-        let path = path?;\n+        let path: ast::Path = find_node_at_range(source_file.syntax(), range)?;\n \n         for desc in path.syntax().descendants() {\n             if desc.to_string() == name.syntax().to_string()\n@@ -393,42 +354,34 @@ impl Module {\n         None\n     }\n \n-    fn change_visibility(&self, record_fields: Vec<SyntaxNode>) -> Option<Vec<ast::Item>> {\n-        let (body_items, mut replacements, record_field_parents, impls) =\n-            get_replacements_for_visibilty_change(self.body_items.clone(), false);\n+    fn change_visibility(&mut self, record_fields: Vec<SyntaxNode>) {\n+        let (mut replacements, record_field_parents, impls) =\n+            get_replacements_for_visibilty_change(&mut self.body_items, false);\n \n-        let mut impl_items = Vec::new();\n-        for impl_ in impls {\n-            let mut this_impl_items = Vec::new();\n-            for node in impl_.syntax().descendants() {\n-                if let Some(item) = ast::Item::cast(node) {\n-                    this_impl_items.push(item);\n-                }\n-            }\n+        let mut impl_items: Vec<ast::Item> = impls\n+            .into_iter()\n+            .flat_map(|impl_| impl_.syntax().descendants())\n+            .filter_map(ast::Item::cast)\n+            .collect();\n \n-            impl_items.append(&mut this_impl_items);\n-        }\n-\n-        let (_, mut impl_item_replacements, _, _) =\n-            get_replacements_for_visibilty_change(impl_items, true);\n+        let (mut impl_item_replacements, _, _) =\n+            get_replacements_for_visibilty_change(&mut impl_items, true);\n \n         replacements.append(&mut impl_item_replacements);\n \n-        record_field_parents.into_iter().for_each(|x| {\n-            x.1.descendants().filter_map(ast::RecordField::cast).for_each(|desc| {\n+        for (_, field_owner) in record_field_parents {\n+            for desc in field_owner.descendants().filter_map(ast::RecordField::cast) {\n                 let is_record_field_present =\n                     record_fields.clone().into_iter().any(|x| x.to_string() == desc.to_string());\n                 if is_record_field_present {\n                     replacements.push((desc.visibility(), desc.syntax().clone()));\n                 }\n-            });\n-        });\n+            }\n+        }\n \n-        replacements.into_iter().for_each(|(vis, syntax)| {\n+        for (vis, syntax) in replacements {\n             add_change_vis(vis, syntax.first_child_or_token());\n-        });\n-\n-        Some(body_items)\n+        }\n     }\n \n     fn resolve_imports(\n@@ -439,8 +392,8 @@ impl Module {\n         let mut import_paths_to_be_removed: Vec<TextRange> = vec![];\n         let mut node_set: HashSet<String> = HashSet::new();\n \n-        self.body_items.clone().into_iter().for_each(|item| {\n-            item.syntax().descendants().for_each(|x| {\n+        for item in self.body_items.clone() {\n+            for x in item.syntax().descendants() {\n                 if let Some(name) = ast::Name::cast(x.clone()) {\n                     if let Some(name_classify) = NameClass::classify(&ctx.sema, &name) {\n                         //Necessary to avoid two same names going through\n@@ -492,8 +445,8 @@ impl Module {\n                         }\n                     }\n                 }\n-            });\n-        });\n+            }\n+        }\n \n         import_paths_to_be_removed\n     }\n@@ -514,8 +467,8 @@ impl Module {\n \n         let mut exists_inside_sel = false;\n         let mut exists_outside_sel = false;\n-        usage_res.clone().into_iter().for_each(|x| {\n-            let mut non_use_nodes_itr = (&x.1).iter().filter_map(|x| {\n+        for (_, refs) in usage_res.iter() {\n+            let mut non_use_nodes_itr = refs.iter().filter_map(|x| {\n                 if find_node_at_range::<ast::Use>(file.syntax(), x.range).is_none() {\n                     let path_opt = find_node_at_range::<ast::Path>(file.syntax(), x.range);\n                     return path_opt;\n@@ -533,7 +486,7 @@ impl Module {\n             if non_use_nodes_itr.any(|x| selection_range.contains_range(x.syntax().text_range())) {\n                 exists_inside_sel = true;\n             }\n-        });\n+        }\n \n         let source_exists_outside_sel_in_same_mod = does_source_exists_outside_sel_in_same_mod(\n             def,\n@@ -543,18 +496,14 @@ impl Module {\n             curr_file_id,\n         );\n \n-        let use_stmt_opt: Option<ast::Use> = usage_res.into_iter().find_map(|x| {\n-            let file_id = x.0;\n-            let mut use_opt: Option<ast::Use> = None;\n+        let use_stmt_opt: Option<ast::Use> = usage_res.into_iter().find_map(|(file_id, refs)| {\n             if file_id == curr_file_id {\n-                (&x.1).iter().for_each(|x| {\n-                    let node_opt: Option<ast::Use> = find_node_at_range(file.syntax(), x.range);\n-                    if let Some(node) = node_opt {\n-                        use_opt = Some(node);\n-                    }\n-                });\n+                refs.into_iter()\n+                    .rev()\n+                    .find_map(|fref| find_node_at_range(file.syntax(), fref.range))\n+            } else {\n+                None\n             }\n-            use_opt\n         });\n \n         let mut use_tree_str_opt: Option<Vec<ast::Path>> = None;\n@@ -616,28 +565,24 @@ impl Module {\n \n             let use_ =\n                 make::use_(None, make::use_tree(make::join_paths(use_tree_str), None, None, false));\n-            if let Some(item) = ast::Item::cast(use_.syntax().clone()) {\n-                self.use_items.insert(0, item);\n-            }\n+            let item = ast::Item::from(use_);\n+            self.use_items.insert(0, item);\n         }\n \n         import_path_to_be_removed\n     }\n \n-    fn make_use_stmt_of_node_with_super(&mut self, node_syntax: &SyntaxNode) -> Option<ast::Item> {\n+    fn make_use_stmt_of_node_with_super(&mut self, node_syntax: &SyntaxNode) -> ast::Item {\n         let super_path = make::ext::ident_path(\"super\");\n         let node_path = make::ext::ident_path(&node_syntax.to_string());\n         let use_ = make::use_(\n             None,\n             make::use_tree(make::join_paths(vec![super_path, node_path]), None, None, false),\n         );\n \n-        if let Some(item) = ast::Item::cast(use_.syntax().clone()) {\n-            self.use_items.insert(0, item.clone());\n-            return Some(item);\n-        }\n-\n-        None\n+        let item = ast::Item::from(use_);\n+        self.use_items.insert(0, item.clone());\n+        item\n     }\n \n     fn process_use_stmt_for_import_resolve(\n@@ -823,33 +768,29 @@ fn does_source_exists_outside_sel_in_same_mod(\n }\n \n fn get_replacements_for_visibilty_change(\n-    items: Vec<ast::Item>,\n+    items: &mut [ast::Item],\n     is_clone_for_updated: bool,\n ) -> (\n-    Vec<ast::Item>,\n     Vec<(Option<ast::Visibility>, SyntaxNode)>,\n     Vec<(Option<ast::Visibility>, SyntaxNode)>,\n     Vec<ast::Impl>,\n ) {\n     let mut replacements = Vec::new();\n     let mut record_field_parents = Vec::new();\n     let mut impls = Vec::new();\n-    let mut body_items = Vec::new();\n \n-    items.into_iter().for_each(|item| {\n-        let mut item = item;\n+    for item in items {\n         if !is_clone_for_updated {\n-            item = item.clone_for_update();\n+            *item = item.clone_for_update();\n         }\n-        body_items.push(item.clone());\n         //Use stmts are ignored\n         match item {\n             ast::Item::Const(it) => replacements.push((it.visibility(), it.syntax().clone())),\n             ast::Item::Enum(it) => replacements.push((it.visibility(), it.syntax().clone())),\n             ast::Item::ExternCrate(it) => replacements.push((it.visibility(), it.syntax().clone())),\n             ast::Item::Fn(it) => replacements.push((it.visibility(), it.syntax().clone())),\n             //Associated item's visibility should not be changed\n-            ast::Item::Impl(it) if it.for_token().is_none() => impls.push(it),\n+            ast::Item::Impl(it) if it.for_token().is_none() => impls.push(it.clone()),\n             ast::Item::MacroDef(it) => replacements.push((it.visibility(), it.syntax().clone())),\n             ast::Item::Module(it) => replacements.push((it.visibility(), it.syntax().clone())),\n             ast::Item::Static(it) => replacements.push((it.visibility(), it.syntax().clone())),\n@@ -865,9 +806,9 @@ fn get_replacements_for_visibilty_change(\n             }\n             _ => (),\n         }\n-    });\n+    }\n \n-    (body_items, replacements, record_field_parents, impls)\n+    (replacements, record_field_parents, impls)\n }\n \n fn get_use_tree_paths_from_path(\n@@ -890,23 +831,13 @@ fn get_use_tree_paths_from_path(\n     Some(use_tree_str)\n }\n \n-fn add_change_vis(\n-    vis: Option<ast::Visibility>,\n-    node_or_token_opt: Option<syntax::SyntaxElement>,\n-) -> Option<()> {\n-    if let None = vis {\n+fn add_change_vis(vis: Option<ast::Visibility>, node_or_token_opt: Option<syntax::SyntaxElement>) {\n+    if vis.is_none() {\n         if let Some(node_or_token) = node_or_token_opt {\n             let pub_crate_vis = make::visibility_pub_crate().clone_for_update();\n-            if let Some(node) = node_or_token.as_node() {\n-                ted::insert(ted::Position::before(node), pub_crate_vis.syntax());\n-            }\n-            if let Some(token) = node_or_token.as_token() {\n-                ted::insert(ted::Position::before(token), pub_crate_vis.syntax());\n-            }\n+            ted::insert(ted::Position::before(node_or_token), pub_crate_vis.syntax());\n         }\n     }\n-\n-    Some(())\n }\n \n fn compare_hir_and_ast_module("}]}