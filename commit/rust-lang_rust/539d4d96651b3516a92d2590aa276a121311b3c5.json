{"sha": "539d4d96651b3516a92d2590aa276a121311b3c5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzOWQ0ZDk2NjUxYjM1MTZhOTJkMjU5MGFhMjc2YTEyMTMxMWIzYzU=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-05-20T23:16:05Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-05-20T23:27:25Z"}, "message": "Refactor CliOptions", "tree": {"sha": "92c26a2f7c2cefe1b6b60a85bf09bc3a2091b7db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92c26a2f7c2cefe1b6b60a85bf09bc3a2091b7db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/539d4d96651b3516a92d2590aa276a121311b3c5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/539d4d96651b3516a92d2590aa276a121311b3c5", "html_url": "https://github.com/rust-lang/rust/commit/539d4d96651b3516a92d2590aa276a121311b3c5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/539d4d96651b3516a92d2590aa276a121311b3c5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26586d9de80ceab49b13c4430a940f4837639eba", "url": "https://api.github.com/repos/rust-lang/rust/commits/26586d9de80ceab49b13c4430a940f4837639eba", "html_url": "https://github.com/rust-lang/rust/commit/26586d9de80ceab49b13c4430a940f4837639eba"}], "stats": {"total": 341, "additions": 180, "deletions": 161}, "files": [{"sha": "681e677488c2d8cd36ce964358244a0ab6839e87", "filename": "src/bin/main.rs", "status": "modified", "additions": 151, "deletions": 7, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbin%2Fmain.rs?ref=539d4d96651b3516a92d2590aa276a121311b3c5", "patch": "@@ -11,6 +11,7 @@\n #![cfg(not(test))]\n \n extern crate env_logger;\n+#[macro_use]\n extern crate failure;\n extern crate getopts;\n extern crate rustfmt_nightly as rustfmt;\n@@ -19,14 +20,15 @@ use std::env;\n use std::fs::File;\n use std::io::{self, stdout, Read, Write};\n use std::path::{Path, PathBuf};\n+use std::str::FromStr;\n \n use failure::err_msg;\n \n use getopts::{Matches, Options};\n \n use rustfmt::{\n-    emit_post_matter, emit_pre_matter, format_and_emit_report, load_config, CliOptions, Config,\n-    ErrorKind, FileName, Input, Summary, Verbosity, WriteMode,\n+    emit_post_matter, emit_pre_matter, format_and_emit_report, load_config, CliOptions, Color,\n+    Config, ErrorKind, FileLines, FileName, Input, Summary, Verbosity, WriteMode,\n };\n \n fn main() {\n@@ -172,7 +174,7 @@ fn is_nightly() -> bool {\n \n fn execute(opts: &Options) -> Result<(WriteMode, Summary), failure::Error> {\n     let matches = opts.parse(env::args().skip(1))?;\n-    let options = CliOptions::from_matches(&matches)?;\n+    let options = GetOptsOptions::from_matches(&matches)?;\n \n     match determine_operation(&matches)? {\n         Operation::Help(HelpOp::None) => {\n@@ -203,7 +205,7 @@ fn execute(opts: &Options) -> Result<(WriteMode, Summary), failure::Error> {\n         }\n         Operation::Stdin { input } => {\n             // try to read config from local directory\n-            let (mut config, _) = load_config(Some(Path::new(\".\")), Some(&options))?;\n+            let (mut config, _) = load_config(Some(Path::new(\".\")), Some(options.clone()))?;\n \n             // write_mode is always Display for Stdin.\n             config.set().write_mode(WriteMode::Display);\n@@ -238,10 +240,10 @@ fn execute(opts: &Options) -> Result<(WriteMode, Summary), failure::Error> {\n fn format(\n     files: Vec<PathBuf>,\n     minimal_config_path: Option<String>,\n-    options: CliOptions,\n+    options: GetOptsOptions,\n ) -> Result<(WriteMode, Summary), failure::Error> {\n     options.verify_file_lines(&files);\n-    let (config, config_path) = load_config(None, Some(&options))?;\n+    let (config, config_path) = load_config(None, Some(options.clone()))?;\n \n     if config.verbose() == Verbosity::Verbose {\n         if let Some(path) = config_path.as_ref() {\n@@ -263,7 +265,7 @@ fn format(\n             // Check the file directory if the config-path could not be read or not provided\n             let local_config = if config_path.is_none() {\n                 let (local_config, config_path) =\n-                    load_config(Some(file.parent().unwrap()), Some(&options))?;\n+                    load_config(Some(file.parent().unwrap()), Some(options.clone()))?;\n                 if local_config.verbose() == Verbosity::Verbose {\n                     if let Some(path) = config_path {\n                         println!(\n@@ -403,3 +405,145 @@ fn determine_operation(matches: &Matches) -> Result<Operation, ErrorKind> {\n         minimal_config_path,\n     })\n }\n+\n+const STABLE_WRITE_MODES: [WriteMode; 4] = [\n+    WriteMode::Replace,\n+    WriteMode::Overwrite,\n+    WriteMode::Display,\n+    WriteMode::Check,\n+];\n+\n+/// Parsed command line options.\n+#[derive(Clone, Debug, Default)]\n+struct GetOptsOptions {\n+    skip_children: Option<bool>,\n+    quiet: bool,\n+    verbose: bool,\n+    config_path: Option<PathBuf>,\n+    write_mode: WriteMode,\n+    check: bool,\n+    color: Option<Color>,\n+    file_lines: FileLines, // Default is all lines in all files.\n+    unstable_features: bool,\n+    error_on_unformatted: Option<bool>,\n+}\n+\n+impl GetOptsOptions {\n+    pub fn from_matches(matches: &Matches) -> Result<GetOptsOptions, failure::Error> {\n+        let mut options = GetOptsOptions::default();\n+        options.verbose = matches.opt_present(\"verbose\");\n+        options.quiet = matches.opt_present(\"quiet\");\n+        if options.verbose && options.quiet {\n+            return Err(format_err!(\"Can't use both `--verbose` and `--quiet`\"));\n+        }\n+\n+        let rust_nightly = option_env!(\"CFG_RELEASE_CHANNEL\")\n+            .map(|c| c == \"nightly\")\n+            .unwrap_or(false);\n+        if rust_nightly {\n+            options.unstable_features = matches.opt_present(\"unstable-features\");\n+        }\n+\n+        if options.unstable_features {\n+            if matches.opt_present(\"skip-children\") {\n+                options.skip_children = Some(true);\n+            }\n+            if matches.opt_present(\"error-on-unformatted\") {\n+                options.error_on_unformatted = Some(true);\n+            }\n+            if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n+                options.file_lines = file_lines.parse().map_err(err_msg)?;\n+            }\n+        }\n+\n+        options.config_path = matches.opt_str(\"config-path\").map(PathBuf::from);\n+\n+        options.check = matches.opt_present(\"check\");\n+        if let Some(ref emit_str) = matches.opt_str(\"emit\") {\n+            if options.check {\n+                return Err(format_err!(\"Invalid to use `--emit` and `--check`\"));\n+            }\n+            if let Ok(write_mode) = write_mode_from_emit_str(emit_str) {\n+                options.write_mode = write_mode;\n+            } else {\n+                return Err(format_err!(\"Invalid value for `--emit`\"));\n+            }\n+        }\n+\n+        if options.write_mode == WriteMode::Overwrite && matches.opt_present(\"backup\") {\n+            options.write_mode = WriteMode::Replace;\n+        }\n+\n+        if !rust_nightly {\n+            if !STABLE_WRITE_MODES.contains(&options.write_mode) {\n+                return Err(format_err!(\n+                    \"Invalid value for `--emit` - using an unstable \\\n+                     value without `--unstable-features`\",\n+                ));\n+            }\n+        }\n+\n+        if let Some(ref color) = matches.opt_str(\"color\") {\n+            match Color::from_str(color) {\n+                Ok(color) => options.color = Some(color),\n+                _ => return Err(format_err!(\"Invalid color: {}\", color)),\n+            }\n+        }\n+\n+        Ok(options)\n+    }\n+\n+    fn verify_file_lines(&self, files: &[PathBuf]) {\n+        for f in self.file_lines.files() {\n+            match *f {\n+                FileName::Real(ref f) if files.contains(f) => {}\n+                FileName::Real(_) => {\n+                    eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n+                }\n+                _ => eprintln!(\"Warning: Not a file '{}'\", f),\n+            }\n+        }\n+    }\n+}\n+\n+impl CliOptions for GetOptsOptions {\n+    fn apply_to(self, config: &mut Config) {\n+        if self.verbose {\n+            config.set().verbose(Verbosity::Verbose);\n+        } else if self.quiet {\n+            config.set().verbose(Verbosity::Quiet);\n+        } else {\n+            config.set().verbose(Verbosity::Normal);\n+        }\n+        config.set().file_lines(self.file_lines);\n+        config.set().unstable_features(self.unstable_features);\n+        if let Some(skip_children) = self.skip_children {\n+            config.set().skip_children(skip_children);\n+        }\n+        if let Some(error_on_unformatted) = self.error_on_unformatted {\n+            config.set().error_on_unformatted(error_on_unformatted);\n+        }\n+        if self.check {\n+            config.set().write_mode(WriteMode::Check);\n+        } else {\n+            config.set().write_mode(self.write_mode);\n+        }\n+        if let Some(color) = self.color {\n+            config.set().color(color);\n+        }\n+    }\n+\n+    fn config_path(&self) -> Option<&Path> {\n+        self.config_path.as_ref().map(|p| &**p)\n+    }\n+}\n+\n+fn write_mode_from_emit_str(emit_str: &str) -> Result<WriteMode, failure::Error> {\n+    match emit_str {\n+        \"files\" => Ok(WriteMode::Overwrite),\n+        \"stdout\" => Ok(WriteMode::Display),\n+        \"coverage\" => Ok(WriteMode::Coverage),\n+        \"checkstyle\" => Ok(WriteMode::Checkstyle),\n+        _ => Err(format_err!(\"Invalid value for `--emit`\")),\n+    }\n+}"}, {"sha": "6168c56ef38bfd611308e95619a766dbdb27445d", "filename": "src/config/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Fconfig%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Fconfig%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Fmod.rs?ref=539d4d96651b3516a92d2590aa276a121311b3c5", "patch": "@@ -17,7 +17,7 @@ use std::path::{Path, PathBuf};\n use std::{env, fs};\n \n use config::config_type::ConfigType;\n-use config::file_lines::FileLines;\n+pub use config::file_lines::FileLines;\n pub use config::lists::*;\n pub use config::options::*;\n \n@@ -146,12 +146,12 @@ create_config! {\n         \"'small' heuristic values\";\n }\n \n-pub fn load_config(\n+pub fn load_config<O: CliOptions>(\n     file_path: Option<&Path>,\n-    options: Option<&CliOptions>,\n+    options: Option<O>,\n ) -> Result<(Config, Option<PathBuf>), Error> {\n     let over_ride = match options {\n-        Some(opts) => config_path(opts)?,\n+        Some(ref opts) => config_path(opts)?,\n         None => None,\n     };\n \n@@ -165,7 +165,7 @@ pub fn load_config(\n \n     result.map(|(mut c, p)| {\n         if let Some(options) = options {\n-            options.clone().apply_to(&mut c);\n+            options.apply_to(&mut c);\n         }\n         (c, p)\n     })\n@@ -208,17 +208,17 @@ fn config_path(options: &CliOptions) -> Result<Option<PathBuf>, Error> {\n \n     // Read the config_path and convert to parent dir if a file is provided.\n     // If a config file cannot be found from the given path, return error.\n-    match options.config_path {\n-        Some(ref path) if !path.exists() => config_path_not_found(path.to_str().unwrap()),\n-        Some(ref path) if path.is_dir() => {\n+    match options.config_path() {\n+        Some(path) if !path.exists() => config_path_not_found(path.to_str().unwrap()),\n+        Some(path) if path.is_dir() => {\n             let config_file_path = get_toml_path(path)?;\n             if config_file_path.is_some() {\n                 Ok(config_file_path)\n             } else {\n                 config_path_not_found(path.to_str().unwrap())\n             }\n         }\n-        ref path => Ok(path.to_owned()),\n+        path => Ok(path.map(|p| p.to_owned())),\n     }\n }\n "}, {"sha": "9bf6c380919eb683afcf692dbbe10e7974cc534a", "filename": "src/config/options.rs", "status": "modified", "additions": 3, "deletions": 139, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Fconfig%2Foptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Fconfig%2Foptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig%2Foptions.rs?ref=539d4d96651b3516a92d2590aa276a121311b3c5", "patch": "@@ -11,16 +11,11 @@\n use syntax::codemap::FileName;\n \n use config::config_type::ConfigType;\n-use config::file_lines::FileLines;\n use config::lists::*;\n use config::Config;\n \n-use failure::{self, err_msg};\n-\n-use getopts::Matches;\n use std::collections::HashSet;\n use std::path::{Path, PathBuf};\n-use std::str::FromStr;\n \n /// Macro for deriving implementations of Serialize/Deserialize for enums\n #[macro_export]\n@@ -193,13 +188,6 @@ configuration_option_enum! { WriteMode:\n     None,\n }\n \n-const STABLE_WRITE_MODES: [WriteMode; 4] = [\n-    WriteMode::Replace,\n-    WriteMode::Overwrite,\n-    WriteMode::Display,\n-    WriteMode::Check,\n-];\n-\n configuration_option_enum! { Color:\n     // Always use color, whether it is a piped or terminal output\n     Always,\n@@ -328,131 +316,7 @@ impl ::std::str::FromStr for IgnoreList {\n     }\n }\n \n-/// Parsed command line options.\n-#[derive(Clone, Debug, Default)]\n-pub struct CliOptions {\n-    pub skip_children: Option<bool>,\n-    pub quiet: bool,\n-    pub verbose: bool,\n-    pub config_path: Option<PathBuf>,\n-    pub write_mode: WriteMode,\n-    pub check: bool,\n-    pub color: Option<Color>,\n-    pub file_lines: FileLines, // Default is all lines in all files.\n-    pub unstable_features: bool,\n-    pub error_on_unformatted: Option<bool>,\n-}\n-\n-impl CliOptions {\n-    pub fn from_matches(matches: &Matches) -> Result<CliOptions, failure::Error> {\n-        let mut options = CliOptions::default();\n-        options.verbose = matches.opt_present(\"verbose\");\n-        options.quiet = matches.opt_present(\"quiet\");\n-        if options.verbose && options.quiet {\n-            return Err(format_err!(\"Can't use both `--verbose` and `--quiet`\"));\n-        }\n-\n-        let rust_nightly = option_env!(\"CFG_RELEASE_CHANNEL\")\n-            .map(|c| c == \"nightly\")\n-            .unwrap_or(false);\n-        if rust_nightly {\n-            options.unstable_features = matches.opt_present(\"unstable-features\");\n-        }\n-\n-        if options.unstable_features {\n-            if matches.opt_present(\"skip-children\") {\n-                options.skip_children = Some(true);\n-            }\n-            if matches.opt_present(\"error-on-unformatted\") {\n-                options.error_on_unformatted = Some(true);\n-            }\n-            if let Some(ref file_lines) = matches.opt_str(\"file-lines\") {\n-                options.file_lines = file_lines.parse().map_err(err_msg)?;\n-            }\n-        }\n-\n-        options.config_path = matches.opt_str(\"config-path\").map(PathBuf::from);\n-\n-        options.check = matches.opt_present(\"check\");\n-        if let Some(ref emit_str) = matches.opt_str(\"emit\") {\n-            if options.check {\n-                return Err(format_err!(\"Invalid to use `--emit` and `--check`\"));\n-            }\n-            if let Ok(write_mode) = write_mode_from_emit_str(emit_str) {\n-                options.write_mode = write_mode;\n-            } else {\n-                return Err(format_err!(\"Invalid value for `--emit`\"));\n-            }\n-        }\n-\n-        if options.write_mode == WriteMode::Overwrite && matches.opt_present(\"backup\") {\n-            options.write_mode = WriteMode::Replace;\n-        }\n-\n-        if !rust_nightly {\n-            if !STABLE_WRITE_MODES.contains(&options.write_mode) {\n-                return Err(format_err!(\n-                    \"Invalid value for `--emit` - using an unstable \\\n-                     value without `--unstable-features`\",\n-                ));\n-            }\n-        }\n-\n-        if let Some(ref color) = matches.opt_str(\"color\") {\n-            match Color::from_str(color) {\n-                Ok(color) => options.color = Some(color),\n-                _ => return Err(format_err!(\"Invalid color: {}\", color)),\n-            }\n-        }\n-\n-        Ok(options)\n-    }\n-\n-    pub fn apply_to(self, config: &mut Config) {\n-        if self.verbose {\n-            config.set().verbose(Verbosity::Verbose);\n-        } else if self.quiet {\n-            config.set().verbose(Verbosity::Quiet);\n-        } else {\n-            config.set().verbose(Verbosity::Normal);\n-        }\n-        config.set().file_lines(self.file_lines);\n-        config.set().unstable_features(self.unstable_features);\n-        if let Some(skip_children) = self.skip_children {\n-            config.set().skip_children(skip_children);\n-        }\n-        if let Some(error_on_unformatted) = self.error_on_unformatted {\n-            config.set().error_on_unformatted(error_on_unformatted);\n-        }\n-        if self.check {\n-            config.set().write_mode(WriteMode::Check);\n-        } else {\n-            config.set().write_mode(self.write_mode);\n-        }\n-        if let Some(color) = self.color {\n-            config.set().color(color);\n-        }\n-    }\n-\n-    pub fn verify_file_lines(&self, files: &[PathBuf]) {\n-        for f in self.file_lines.files() {\n-            match *f {\n-                FileName::Real(ref f) if files.contains(f) => {}\n-                FileName::Real(_) => {\n-                    eprintln!(\"Warning: Extra file listed in file_lines option '{}'\", f)\n-                }\n-                _ => eprintln!(\"Warning: Not a file '{}'\", f),\n-            }\n-        }\n-    }\n-}\n-\n-fn write_mode_from_emit_str(emit_str: &str) -> Result<WriteMode, failure::Error> {\n-    match emit_str {\n-        \"files\" => Ok(WriteMode::Overwrite),\n-        \"stdout\" => Ok(WriteMode::Display),\n-        \"coverage\" => Ok(WriteMode::Coverage),\n-        \"checkstyle\" => Ok(WriteMode::Checkstyle),\n-        _ => Err(format_err!(\"Invalid value for `--emit`\")),\n-    }\n+pub trait CliOptions {\n+    fn apply_to(self, config: &mut Config);\n+    fn config_path(&self) -> Option<&Path>;\n }"}, {"sha": "3eae7cdeabd732f8190c3b5502acb3c399ef2905", "filename": "src/git-rustfmt/main.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Fgit-rustfmt%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Fgit-rustfmt%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgit-rustfmt%2Fmain.rs?ref=539d4d96651b3516a92d2590aa276a121311b3c5", "patch": "@@ -21,7 +21,7 @@ use std::str::FromStr;\n \n use getopts::{Matches, Options};\n \n-use rustfmt::{format_and_emit_report, load_config, Input};\n+use rustfmt::{format_and_emit_report, load_config, CliOptions, Input};\n \n fn prune_files(files: Vec<&str>) -> Vec<&str> {\n     let prefixes: Vec<_> = files\n@@ -68,7 +68,8 @@ fn get_files(input: &str) -> Vec<&str> {\n }\n \n fn fmt_files(files: &[&str]) -> i32 {\n-    let (config, _) = load_config(Some(Path::new(\".\")), None).expect(\"couldn't load config\");\n+    let (config, _) =\n+        load_config::<NullOptions>(Some(Path::new(\".\")), None).expect(\"couldn't load config\");\n \n     let mut exit_code = 0;\n     for file in files {\n@@ -80,6 +81,17 @@ fn fmt_files(files: &[&str]) -> i32 {\n     exit_code\n }\n \n+struct NullOptions;\n+\n+impl CliOptions for NullOptions {\n+    fn apply_to(self, _: &mut rustfmt::Config) {\n+        unreachable!();\n+    }\n+    fn config_path(&self) -> Option<&Path> {\n+        unreachable!();\n+    }\n+}\n+\n fn uncommitted_files() -> Vec<String> {\n     let mut cmd = Command::new(\"git\");\n     cmd.arg(\"ls-files\");"}, {"sha": "c3fe0db3155cd51fca6020bf2ec77cc99f0faad0", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=539d4d96651b3516a92d2590aa276a121311b3c5", "patch": "@@ -19,7 +19,6 @@ extern crate derive_new;\n extern crate diff;\n #[macro_use]\n extern crate failure;\n-extern crate getopts;\n extern crate itertools;\n #[cfg(test)]\n #[macro_use]\n@@ -62,7 +61,7 @@ use visitor::{FmtVisitor, SnippetProvider};\n \n pub use config::options::CliOptions;\n pub use config::summary::Summary;\n-pub use config::{file_lines, load_config, Config, Verbosity, WriteMode};\n+pub use config::{load_config, Color, Config, FileLines, Verbosity, WriteMode};\n \n #[macro_use]\n mod utils;"}, {"sha": "7507b2de9aaf5cf189425eb4af2c539f9c8e5e53", "filename": "src/test/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Ftest%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/539d4d96651b3516a92d2590aa276a121311b3c5/src%2Ftest%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmod.rs?ref=539d4d96651b3516a92d2590aa276a121311b3c5", "patch": "@@ -380,12 +380,12 @@ fn format_file<P: Into<PathBuf>>(filepath: P, config: &Config) -> (Summary, File\n     syntax::with_globals(|| format_input_inner::<io::Stdout>(input, config, None)).unwrap()\n }\n \n-pub enum IdempotentCheckError {\n+enum IdempotentCheckError {\n     Mismatch(HashMap<PathBuf, Vec<Mismatch>>),\n     Parse,\n }\n \n-pub fn idempotent_check(\n+fn idempotent_check(\n     filename: &PathBuf,\n     opt_config: &Option<PathBuf>,\n ) -> Result<FormatReport, IdempotentCheckError> {"}]}