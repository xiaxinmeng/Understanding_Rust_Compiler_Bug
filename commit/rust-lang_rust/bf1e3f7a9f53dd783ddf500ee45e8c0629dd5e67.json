{"sha": "bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJmMWUzZjdhOWY1M2RkNzgzZGRmNTAwZWU0NWU4YzA2MjlkZDVlNjc=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-14T01:22:28Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-31T15:05:42Z"}, "message": "Skip needless_for_each if an input stmt is local", "tree": {"sha": "c3e87176b178c65b89411f4709583d3a5ced2d5b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c3e87176b178c65b89411f4709583d3a5ced2d5b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67", "html_url": "https://github.com/rust-lang/rust/commit/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1109dc8838b8af0ad7e2b8eb3a7039c907188082", "url": "https://api.github.com/repos/rust-lang/rust/commits/1109dc8838b8af0ad7e2b8eb3a7039c907188082", "html_url": "https://github.com/rust-lang/rust/commit/1109dc8838b8af0ad7e2b8eb3a7039c907188082"}], "stats": {"total": 69, "additions": 37, "deletions": 32}, "files": [{"sha": "727937354d6289c84e9a0afbc7e86107b156357b", "filename": "clippy_lints/src/needless_for_each.rs", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/clippy_lints%2Fsrc%2Fneedless_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_for_each.rs?ref=bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67", "patch": "@@ -49,31 +49,28 @@ impl LateLintPass<'_> for NeedlessForEach {\n     fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n         let expr = match stmt.kind {\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => expr,\n-            StmtKind::Local(local) if local.init.is_some() => local.init.unwrap(),\n             _ => return,\n         };\n \n         if_chain! {\n             // Check the method name is `for_each`.\n-            if let ExprKind::MethodCall(method_name, _, for_each_args, _) = expr.kind;\n+            if let ExprKind::MethodCall(method_name, _, [for_each_recv, for_each_arg], _) = expr.kind;\n             if method_name.ident.name == Symbol::intern(\"for_each\");\n             // Check `for_each` is an associated function of `Iterator`.\n             if is_trait_method(cx, expr, sym::Iterator);\n             // Checks the receiver of `for_each` is also a method call.\n-            if let Some(for_each_receiver) = for_each_args.get(0);\n-            if let ExprKind::MethodCall(_, _, iter_args, _) = for_each_receiver.kind;\n+            if let ExprKind::MethodCall(_, _, [iter_recv], _) = for_each_recv.kind;\n             // Skip the lint if the call chain is too long. e.g. `v.field.iter().for_each()` or\n             // `v.foo().iter().for_each()` must be skipped.\n-            if let Some(iter_receiver) = iter_args.get(0);\n             if matches!(\n-                iter_receiver.kind,\n+                iter_recv.kind,\n                 ExprKind::Array(..) | ExprKind::Call(..) | ExprKind::Path(..)\n             );\n             // Checks the type of the `iter` method receiver is NOT a user defined type.\n-            if has_iter_method(cx, cx.typeck_results().expr_ty(&iter_receiver)).is_some();\n+            if has_iter_method(cx, cx.typeck_results().expr_ty(&iter_recv)).is_some();\n             // Skip the lint if the body is not block because this is simpler than `for` loop.\n             // e.g. `v.iter().for_each(f)` is simpler and clearer than using `for` loop.\n-            if let ExprKind::Closure(_, _, body_id, ..) = for_each_args[1].kind;\n+            if let ExprKind::Closure(_, _, body_id, ..) = for_each_arg.kind;\n             let body = cx.tcx.hir().body(body_id);\n             if let ExprKind::Block(..) = body.value.kind;\n             then {\n@@ -85,38 +82,37 @@ impl LateLintPass<'_> for NeedlessForEach {\n                     return;\n                 }\n \n-                // We can't use `Applicability::MachineApplicable` when the closure contains `return`\n-                // because `Diagnostic::multipart_suggestion` doesn't work with multiple overlapped\n-                // spans.\n-                let mut applicability = if ret_collector.spans.is_empty() {\n-                    Applicability::MachineApplicable\n+                let (mut applicability, ret_suggs) = if ret_collector.spans.is_empty() {\n+                    (Applicability::MachineApplicable, None)\n                 } else {\n-                    Applicability::MaybeIncorrect\n+                    (\n+                        Applicability::MaybeIncorrect,\n+                        Some(\n+                            ret_collector\n+                                .spans\n+                                .into_iter()\n+                                .map(|span| (span, \"continue\".to_string()))\n+                                .collect(),\n+                        ),\n+                    )\n                 };\n \n-                let mut suggs = vec![];\n-                suggs.push((stmt.span, format!(\n+                let sugg = format!(\n                     \"for {} in {} {}\",\n                     snippet_with_applicability(cx, body.params[0].pat.span, \"..\", &mut applicability),\n-                    snippet_with_applicability(cx, for_each_args[0].span, \"..\", &mut applicability),\n+                    snippet_with_applicability(cx, for_each_recv.span, \"..\", &mut applicability),\n                     snippet_with_applicability(cx, body.value.span, \"..\", &mut applicability),\n-                )));\n-\n-                for span in &ret_collector.spans {\n-                    suggs.push((*span, \"continue\".to_string()));\n-                }\n+                );\n \n                 span_lint_and_then(\n                     cx,\n                     NEEDLESS_FOR_EACH,\n                     stmt.span,\n                     \"needless use of `for_each`\",\n                     |diag| {\n-                        diag.multipart_suggestion(\"try\", suggs, applicability);\n-                        // `Diagnostic::multipart_suggestion` ignores the second and subsequent overlapped spans,\n-                        // so `span_note` is needed here even though `suggs` includes the replacements.\n-                        for span in ret_collector.spans {\n-                            diag.span_note(span, \"replace `return` with `continue`\");\n+                        diag.span_suggestion(stmt.span, \"try\", sugg, applicability);\n+                        if let Some(ret_suggs) = ret_suggs {\n+                            diag.multipart_suggestion(\"try replacing `return` with `continue`\", ret_suggs, applicability);\n                         }\n                     }\n                 )"}, {"sha": "f00f9ee4c331b716bd32ad7049f09968ebee88fa", "filename": "tests/ui/needless_for_each_fixable.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/tests%2Fui%2Fneedless_for_each_fixable.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/tests%2Fui%2Fneedless_for_each_fixable.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.fixed?ref=bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67", "patch": "@@ -103,6 +103,11 @@ fn should_not_lint() {\n             acc += elem;\n         }),\n     }\n+\n+    // `for_each` is in a let bingind.\n+    let _ = v.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n }\n \n fn main() {}"}, {"sha": "1bd400d348ba92ce635f45d8b2dea743cbf6918d", "filename": "tests/ui/needless_for_each_fixable.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/tests%2Fui%2Fneedless_for_each_fixable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/tests%2Fui%2Fneedless_for_each_fixable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_fixable.rs?ref=bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67", "patch": "@@ -103,6 +103,11 @@ fn should_not_lint() {\n             acc += elem;\n         }),\n     }\n+\n+    // `for_each` is in a let bingind.\n+    let _ = v.iter().for_each(|elem| {\n+        acc += elem;\n+    });\n }\n \n fn main() {}"}, {"sha": "bbb63fd8deb6d1ea51923f59a5b4440e30918d0d", "filename": "tests/ui/needless_for_each_unfixable.stderr", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/tests%2Fui%2Fneedless_for_each_unfixable.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67/tests%2Fui%2Fneedless_for_each_unfixable.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fneedless_for_each_unfixable.stderr?ref=bf1e3f7a9f53dd783ddf500ee45e8c0629dd5e67", "patch": "@@ -11,11 +11,6 @@ LL | |     });\n    | |_______^\n    |\n    = note: `-D clippy::needless-for-each` implied by `-D warnings`\n-note: replace `return` with `continue`\n-  --> $DIR/needless_for_each_unfixable.rs:9:13\n-   |\n-LL |             return;\n-   |             ^^^^^^\n help: try\n    |\n LL |     for v in v.iter() {\n@@ -25,6 +20,10 @@ LL |         } else {\n LL |             println!(\"{}\", v);\n LL |         }\n  ...\n+help: try replacing `return` with `continue`\n+   |\n+LL |             continue;\n+   |             ^^^^^^^^\n \n error: aborting due to previous error\n "}]}