{"sha": "76f76ae1d82fda88e5cf3e5900885496425722f8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2Zjc2YWUxZDgyZmRhODhlNWNmM2U1OTAwODg1NDk2NDI1NzIyZjg=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-09-26T20:05:01Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo.net", "date": "2016-09-26T20:05:01Z"}, "message": "incr.comp.: Add file header to on-disk artifacts for validation.", "tree": {"sha": "eee172701e8af6b0dd93a91e6cf5cda78d30c751", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eee172701e8af6b0dd93a91e6cf5cda78d30c751"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76f76ae1d82fda88e5cf3e5900885496425722f8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76f76ae1d82fda88e5cf3e5900885496425722f8", "html_url": "https://github.com/rust-lang/rust/commit/76f76ae1d82fda88e5cf3e5900885496425722f8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76f76ae1d82fda88e5cf3e5900885496425722f8/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bf4a7ad45bceef2e7ac666f4cbb41a37d6af763", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bf4a7ad45bceef2e7ac666f4cbb41a37d6af763", "html_url": "https://github.com/rust-lang/rust/commit/3bf4a7ad45bceef2e7ac666f4cbb41a37d6af763"}], "stats": {"total": 196, "additions": 156, "deletions": 40}, "files": [{"sha": "79971740f5dae0eef4bf0a611c277e9eb2d6d20a", "filename": "src/librustc_incremental/persist/file_format.rs", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffile_format.rs?ref=76f76ae1d82fda88e5cf3e5900885496425722f8", "patch": "@@ -0,0 +1,105 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module defines a generic file format that allows to check if a given\n+//! file generated by incremental compilation was generated by a compatible\n+//! compiler version. This file format is used for the on-disk version of the\n+//! dependency graph and the exported metadata hashes.\n+//!\n+//! In practice \"compatible compiler version\" means \"exactly the same compiler\n+//! version\", since the header encodes the git commit hash of the compiler.\n+//! Since we can always just ignore the incremental compilation cache and\n+//! compiler versions don't change frequently for the typical user, being\n+//! conservative here practically has no downside.\n+\n+use std::io::{self, Read};\n+use std::path::Path;\n+use std::fs::File;\n+\n+/// The first few bytes of files generated by incremental compilation\n+const FILE_MAGIC: &'static [u8] = b\"RSIC\";\n+\n+/// Change this if the header format changes\n+const HEADER_FORMAT_VERSION: u16 = 0;\n+\n+/// A version string that hopefully is always different for compiler versions\n+/// with different encodings of incremental compilation artifacts. Contains\n+/// the git commit hash.\n+const RUSTC_VERSION: &'static str = env!(\"CFG_VERSION\");\n+\n+pub fn write_file_header<W: io::Write>(stream: &mut W) -> io::Result<()> {\n+    stream.write_all(FILE_MAGIC)?;\n+    stream.write_all(&[(HEADER_FORMAT_VERSION >> 0) as u8,\n+                       (HEADER_FORMAT_VERSION >> 8) as u8])?;\n+    assert_eq!(RUSTC_VERSION.len(), (RUSTC_VERSION.len() as u8) as usize);\n+    stream.write_all(&[RUSTC_VERSION.len() as u8])?;\n+    stream.write_all(RUSTC_VERSION.as_bytes())?;\n+\n+    Ok(())\n+}\n+\n+/// Reads the contents of a file with a file header as defined in this module.\n+///\n+/// - Returns `Ok(Some(data))` if the file existed and was generated by a\n+///   compatible compiler version. `data` is the entire contents of the file\n+///   *after* the header.\n+/// - Returns `Ok(None)` if the file did not exist or was generated by an\n+///   incompatible version of the compiler.\n+/// - Returns `Err(..)` if some kind of IO error occurred while reading the\n+///   file.\n+pub fn read_file(path: &Path) -> io::Result<Option<Vec<u8>>> {\n+    if !path.exists() {\n+        return Ok(None);\n+    }\n+\n+    let mut file = File::open(path)?;\n+\n+    // Check FILE_MAGIC\n+    {\n+        debug_assert!(FILE_MAGIC.len() == 4);\n+        let mut file_magic = [0u8; 4];\n+        file.read_exact(&mut file_magic)?;\n+        if file_magic != FILE_MAGIC {\n+            return Ok(None)\n+        }\n+    }\n+\n+    // Check HEADER_FORMAT_VERSION\n+    {\n+        debug_assert!(::std::mem::size_of_val(&HEADER_FORMAT_VERSION) == 2);\n+        let mut header_format_version = [0u8; 2];\n+        file.read_exact(&mut header_format_version)?;\n+        let header_format_version = (header_format_version[0] as u16) |\n+                                    ((header_format_version[1] as u16) << 8);\n+\n+        if header_format_version != HEADER_FORMAT_VERSION {\n+            return Ok(None)\n+        }\n+    }\n+\n+    // Check RUSTC_VERSION\n+    {\n+        let mut rustc_version_str_len = [0u8; 1];\n+        file.read_exact(&mut rustc_version_str_len)?;\n+        let rustc_version_str_len = rustc_version_str_len[0] as usize;\n+        let mut buffer = Vec::with_capacity(rustc_version_str_len);\n+        buffer.resize(rustc_version_str_len, 0);\n+        file.read_exact(&mut buffer[..])?;\n+\n+        if &buffer[..] != RUSTC_VERSION.as_bytes() {\n+            return Ok(None);\n+        }\n+    }\n+\n+    let mut data = vec![];\n+    file.read_to_end(&mut data)?;\n+\n+    Ok(Some(data))\n+}"}, {"sha": "2d28afeaebf2d37aa5e7f43dfd8842d3099fda42", "filename": "src/librustc_incremental/persist/fs.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Ffs.rs?ref=76f76ae1d82fda88e5cf3e5900885496425722f8", "patch": "@@ -345,6 +345,15 @@ pub fn finalize_session_directory(sess: &Session, svh: Svh) {\n     let _ = garbage_collect_session_directories(sess);\n }\n \n+pub fn delete_all_session_dir_contents(sess: &Session) -> io::Result<()> {\n+    let sess_dir_iterator = sess.incr_comp_session_dir().read_dir()?;\n+    for entry in sess_dir_iterator {\n+        let entry = entry?;\n+        safe_remove_file(&entry.path())?\n+    }\n+    Ok(())\n+}\n+\n fn copy_files(target_dir: &Path,\n               source_dir: &Path,\n               print_stats_on_success: bool)"}, {"sha": "ca173db15fcac37e303aff0beb9b16bb3a29bfd5", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=76f76ae1d82fda88e5cf3e5900885496425722f8", "patch": "@@ -16,12 +16,11 @@ use rustc_data_structures::fnv::FnvHashMap;\n use rustc_data_structures::flock;\n use rustc_serialize::Decodable;\n use rustc_serialize::opaque::Decoder;\n-use std::io::{ErrorKind, Read};\n-use std::fs::File;\n \n use IncrementalHashesMap;\n use super::data::*;\n use super::fs::*;\n+use super::file_format;\n \n pub struct HashContext<'a, 'tcx: 'a> {\n     pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -153,12 +152,9 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n \n             let hashes_file_path = metadata_hash_import_path(&session_dir);\n \n-            let mut data = vec![];\n-            match\n-                File::open(&hashes_file_path)\n-                     .and_then(|mut file| file.read_to_end(&mut data))\n+            match file_format::read_file(&hashes_file_path)\n             {\n-                Ok(_) => {\n+                Ok(Some(data)) => {\n                     match self.load_from_data(cnum, &data, svh) {\n                         Ok(()) => { }\n                         Err(err) => {\n@@ -167,18 +163,13 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n                         }\n                     }\n                 }\n+                Ok(None) => {\n+                    // If the file is not found, that's ok.\n+                }\n                 Err(err) => {\n-                    match err.kind() {\n-                        ErrorKind::NotFound => {\n-                            // If the file is not found, that's ok.\n-                        }\n-                        _ => {\n-                            self.tcx.sess.err(\n-                                &format!(\"could not load dep information from `{}`: {}\",\n-                                         hashes_file_path.display(), err));\n-                            return;\n-                        }\n-                    }\n+                    self.tcx.sess.err(\n+                        &format!(\"could not load dep information from `{}`: {}\",\n+                                 hashes_file_path.display(), err));\n                 }\n             }\n         }"}, {"sha": "db8d3125e510bf3f388e90f7c9054058485d5be2", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 30, "deletions": 22, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=76f76ae1d82fda88e5cf3e5900885496425722f8", "patch": "@@ -18,8 +18,7 @@ use rustc::ty::TyCtxt;\n use rustc_data_structures::fnv::{FnvHashSet, FnvHashMap};\n use rustc_serialize::Decodable as RustcDecodable;\n use rustc_serialize::opaque::Decoder;\n-use std::io::Read;\n-use std::fs::{self, File};\n+use std::fs;\n use std::path::{Path};\n \n use IncrementalHashesMap;\n@@ -28,6 +27,7 @@ use super::directory::*;\n use super::dirty_clean;\n use super::hash::*;\n use super::fs::*;\n+use super::file_format;\n \n pub type DirtyNodes = FnvHashSet<DepNode<DefPathIndex>>;\n \n@@ -94,25 +94,26 @@ fn load_dep_graph_if_exists<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n }\n \n fn load_data(sess: &Session, path: &Path) -> Option<Vec<u8>> {\n-    if !path.exists() {\n-        return None;\n-    }\n-\n-    let mut data = vec![];\n-    match\n-        File::open(path)\n-        .and_then(|mut file| file.read_to_end(&mut data))\n-    {\n-        Ok(_) => {\n-            Some(data)\n+    match file_format::read_file(path) {\n+        Ok(Some(data)) => return Some(data),\n+        Ok(None) => {\n+            // The file either didn't exist or was produced by an incompatible\n+            // compiler version. Neither is an error.\n         }\n         Err(err) => {\n             sess.err(\n                 &format!(\"could not load dep-graph from `{}`: {}\",\n                          path.display(), err));\n-            None\n         }\n     }\n+\n+    if let Err(err) = delete_all_session_dir_contents(sess) {\n+        sess.err(&format!(\"could not clear incompatible incremental \\\n+                           compilation session directory `{}`: {}\",\n+                          path.display(), err));\n+    }\n+\n+    None\n }\n \n /// Decode the dep graph and load the edges/nodes that are still clean\n@@ -331,16 +332,22 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n \n     debug!(\"load_prev_metadata_hashes() - File: {}\", file_path.display());\n \n-    let mut data = vec![];\n-    if !File::open(&file_path)\n-             .and_then(|mut file| file.read_to_end(&mut data)).is_ok() {\n-        debug!(\"load_prev_metadata_hashes() - Couldn't read file containing \\\n-                hashes at `{}`\", file_path.display());\n-        return\n-    }\n+    let data = match file_format::read_file(&file_path) {\n+        Ok(Some(data)) => data,\n+        Ok(None) => {\n+            debug!(\"load_prev_metadata_hashes() - File produced by incompatible \\\n+                    compiler version: {}\", file_path.display());\n+            return\n+        }\n+        Err(err) => {\n+            debug!(\"load_prev_metadata_hashes() - Error reading file `{}`: {}\",\n+                   file_path.display(), err);\n+            return\n+        }\n+    };\n \n     debug!(\"load_prev_metadata_hashes() - Decoding hashes\");\n-    let mut decoder = Decoder::new(&mut data, 0);\n+    let mut decoder = Decoder::new(&data, 0);\n     let _ = Svh::decode(&mut decoder).unwrap();\n     let serialized_hashes = SerializedMetadataHashes::decode(&mut decoder).unwrap();\n \n@@ -358,3 +365,4 @@ fn load_prev_metadata_hashes(tcx: TyCtxt,\n     debug!(\"load_prev_metadata_hashes() - successfully loaded {} hashes\",\n            serialized_hashes.index_map.len());\n }\n+"}, {"sha": "26fcde05868b9e4ca4bdf02119104661429050c6", "filename": "src/librustc_incremental/persist/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fmod.rs?ref=76f76ae1d82fda88e5cf3e5900885496425722f8", "patch": "@@ -21,6 +21,7 @@ mod load;\n mod preds;\n mod save;\n mod work_product;\n+mod file_format;\n \n pub use self::fs::finalize_session_directory;\n pub use self::fs::in_incr_comp_dir;"}, {"sha": "e6fb1da1982c11a6de53f9709c194f07605184cc", "filename": "src/librustc_incremental/persist/save.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76f76ae1d82fda88e5cf3e5900885496425722f8/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fsave.rs?ref=76f76ae1d82fda88e5cf3e5900885496425722f8", "patch": "@@ -28,6 +28,7 @@ use super::hash::*;\n use super::preds::*;\n use super::fs::*;\n use super::dirty_clean;\n+use super::file_format;\n \n pub fn save_dep_graph<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                 incremental_hashes_map: &IncrementalHashesMap,\n@@ -102,6 +103,7 @@ fn save_in<F>(sess: &Session, path_buf: PathBuf, encode: F)\n \n     // generate the data in a memory buffer\n     let mut wr = Cursor::new(Vec::new());\n+    file_format::write_file_header(&mut wr).unwrap();\n     match encode(&mut Encoder::new(&mut wr)) {\n         Ok(()) => {}\n         Err(err) => {"}]}