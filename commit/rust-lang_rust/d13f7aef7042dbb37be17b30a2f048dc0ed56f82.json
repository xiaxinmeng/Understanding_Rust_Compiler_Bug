{"sha": "d13f7aef7042dbb37be17b30a2f048dc0ed56f82", "node_id": "C_kwDOAAsO6NoAKGQxM2Y3YWVmNzA0MmRiYjM3YmUxN2IzMGEyZjA0OGRjMGVkNTZmODI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-10-11T16:59:46Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-10-11T16:59:46Z"}, "message": "Rollup merge of #101774 - Riolku:atomic-update-aba, r=m-ou-se\n\nWarn about safety of `fetch_update`\n\nSpecifically as it relates to the ABA problem.\n\n`fetch_update` is a useful function, and one that isn't provided by, say, C++. However, this does not mean the function is magic. It is implemented in terms of `compare_exchange_weak`, and in particular, suffers from the ABA problem. See the following code, which is a naive implementation of `pop` in a lock-free queue:\n\n```rust\nfn pop(&self) -> Option<i32> {\n    self.front.fetch_update(Ordering::Relaxed, Ordering::Acquire, |front| {\n        if front == ptr::null_mut() {\n            None\n        }\n        else {\n            Some(unsafe { (*front).next })\n        }\n    }.ok()\n}\n```\n\nThis code is unsound if called from multiple threads because of the ABA problem. Specifically, suppose nodes are allocated with `Box`. Suppose the following sequence happens:\n\n```\nInitial: Queue is X -> Y.\n\nThread A: Starts popping, is pre-empted.\nThread B: Pops successfully, twice, leaving the queue empty.\nThread C: Pushes, and `Box` returns X (very common for allocators)\nThread A: Wakes up, sees the head is still X, and stores Y as the new head.\n```\n\nBut `Y` is deallocated. This is undefined behaviour.\n\nAdding a note about this problem to `fetch_update` should hopefully prevent users from being misled, and also, a link to this common problem is, in my opinion, an improvement to our docs on atomics.", "tree": {"sha": "60455cf48725932b51eec6deec6a6b1835ab31d2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60455cf48725932b51eec6deec6a6b1835ab31d2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d13f7aef7042dbb37be17b30a2f048dc0ed56f82", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjRaECCRBK7hj4Ov3rIwAAJqAIADTYxIf9EfemoI9Mi+8CoWoX\nLfYA5RgEPXZ8b9C0X3EjWJVsfwOdUo432ySxhjz5zRx0MyTZuhs5kXzridsE0MGo\nHUXbcBbvtEtBtOsA9ynII0ZuaWbQrLoR3gEN6yXrzQ2R8hQbJ/486sSYwsxJwA/i\ngD5MjDPH6Dlx8iMhlRzqe8ofCbQRN5AwCOB5mybGrtq7NcgfR1cOk4IqwyuNMDYy\nR0ab/9T9c2LiqwLih/LINo1rpqGU1KMUouCvZngV6ouAsgvGmxKmhJTfjBN09FI9\newEPg58QUDrEmxOrcobTGNjplaZ4hxdF1kBmwaa4Pp68GE9p7uKo60vK8kKDmE0=\n=JmCD\n-----END PGP SIGNATURE-----\n", "payload": "tree 60455cf48725932b51eec6deec6a6b1835ab31d2\nparent cadb37a8c7811773d2831b95f7554a36a52f53b0\nparent 3d28a1ad761f4106e62e90ceebb209af533a1f24\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1665507586 +0200\ncommitter GitHub <noreply@github.com> 1665507586 +0200\n\nRollup merge of #101774 - Riolku:atomic-update-aba, r=m-ou-se\n\nWarn about safety of `fetch_update`\n\nSpecifically as it relates to the ABA problem.\n\n`fetch_update` is a useful function, and one that isn't provided by, say, C++. However, this does not mean the function is magic. It is implemented in terms of `compare_exchange_weak`, and in particular, suffers from the ABA problem. See the following code, which is a naive implementation of `pop` in a lock-free queue:\n\n```rust\nfn pop(&self) -> Option<i32> {\n    self.front.fetch_update(Ordering::Relaxed, Ordering::Acquire, |front| {\n        if front == ptr::null_mut() {\n            None\n        }\n        else {\n            Some(unsafe { (*front).next })\n        }\n    }.ok()\n}\n```\n\nThis code is unsound if called from multiple threads because of the ABA problem. Specifically, suppose nodes are allocated with `Box`. Suppose the following sequence happens:\n\n```\nInitial: Queue is X -> Y.\n\nThread A: Starts popping, is pre-empted.\nThread B: Pops successfully, twice, leaving the queue empty.\nThread C: Pushes, and `Box` returns X (very common for allocators)\nThread A: Wakes up, sees the head is still X, and stores Y as the new head.\n```\n\nBut `Y` is deallocated. This is undefined behaviour.\n\nAdding a note about this problem to `fetch_update` should hopefully prevent users from being misled, and also, a link to this common problem is, in my opinion, an improvement to our docs on atomics.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d13f7aef7042dbb37be17b30a2f048dc0ed56f82", "html_url": "https://github.com/rust-lang/rust/commit/d13f7aef7042dbb37be17b30a2f048dc0ed56f82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d13f7aef7042dbb37be17b30a2f048dc0ed56f82/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cadb37a8c7811773d2831b95f7554a36a52f53b0", "url": "https://api.github.com/repos/rust-lang/rust/commits/cadb37a8c7811773d2831b95f7554a36a52f53b0", "html_url": "https://github.com/rust-lang/rust/commit/cadb37a8c7811773d2831b95f7554a36a52f53b0"}, {"sha": "3d28a1ad761f4106e62e90ceebb209af533a1f24", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d28a1ad761f4106e62e90ceebb209af533a1f24", "html_url": "https://github.com/rust-lang/rust/commit/3d28a1ad761f4106e62e90ceebb209af533a1f24"}], "stats": {"total": 26, "additions": 26, "deletions": 0}, "files": [{"sha": "6c70517d965b2b08aa6edd29726d3ec37f18b269", "filename": "library/core/src/sync/atomic.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d13f7aef7042dbb37be17b30a2f048dc0ed56f82/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d13f7aef7042dbb37be17b30a2f048dc0ed56f82/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fsync%2Fatomic.rs?ref=d13f7aef7042dbb37be17b30a2f048dc0ed56f82", "patch": "@@ -955,6 +955,14 @@ impl AtomicBool {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on `u8`.\n     ///\n+    /// # Considerations\n+    ///\n+    /// This method is not magic;  it is not provided by the hardware.\n+    /// It is implemented in terms of [`AtomicBool::compare_exchange_weak`], and suffers from the same drawbacks.\n+    /// In particular, this method will not circumvent the [ABA Problem].\n+    ///\n+    /// [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n+    ///\n     /// # Examples\n     ///\n     /// ```rust\n@@ -1422,6 +1430,14 @@ impl<T> AtomicPtr<T> {\n     /// **Note:** This method is only available on platforms that support atomic\n     /// operations on pointers.\n     ///\n+    /// # Considerations\n+    ///\n+    /// This method is not magic;  it is not provided by the hardware.\n+    /// It is implemented in terms of [`AtomicPtr::compare_exchange_weak`], and suffers from the same drawbacks.\n+    /// In particular, this method will not circumvent the [ABA Problem].\n+    ///\n+    /// [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n+    ///\n     /// # Examples\n     ///\n     /// ```rust\n@@ -2510,6 +2526,16 @@ macro_rules! atomic_int {\n             /// **Note**: This method is only available on platforms that support atomic operations on\n             #[doc = concat!(\"[`\", $s_int_type, \"`].\")]\n             ///\n+            /// # Considerations\n+            ///\n+            /// This method is not magic;  it is not provided by the hardware.\n+            /// It is implemented in terms of\n+            #[doc = concat!(\"[`\", stringify!($atomic_type), \"::compare_exchange_weak`],\")]\n+            /// and suffers from the same drawbacks.\n+            /// In particular, this method will not circumvent the [ABA Problem].\n+            ///\n+            /// [ABA Problem]: https://en.wikipedia.org/wiki/ABA_problem\n+            ///\n             /// # Examples\n             ///\n             /// ```rust"}]}