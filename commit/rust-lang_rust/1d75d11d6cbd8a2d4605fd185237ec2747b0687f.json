{"sha": "1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFkNzVkMTFkNmNiZDhhMmQ0NjA1ZmQxODUyMzdlYzI3NDdiMDY4N2Y=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-03-25T14:33:01Z"}, "committer": {"name": "Jonas Schievink", "email": "jonas.schievink@ferrous-systems.com", "date": "2020-06-24T14:52:37Z"}, "message": "Start item tree", "tree": {"sha": "4cd2db564113d58c9c32d73b80b31964f2bdd3f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4cd2db564113d58c9c32d73b80b31964f2bdd3f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "html_url": "https://github.com/rust-lang/rust/commit/1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1d75d11d6cbd8a2d4605fd185237ec2747b0687f/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a3b507a007d0373a83bde203d780b860ea55ce1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a3b507a007d0373a83bde203d780b860ea55ce1", "html_url": "https://github.com/rust-lang/rust/commit/1a3b507a007d0373a83bde203d780b860ea55ce1"}], "stats": {"total": 520, "additions": 517, "deletions": 3}, "files": [{"sha": "113ec2b78eb8b24489292c6074efbe02624555fa", "filename": "crates/ra_hir_def/src/body/lower.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1d75d11d6cbd8a2d4605fd185237ec2747b0687f/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d75d11d6cbd8a2d4605fd185237ec2747b0687f/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fbody%2Flower.rs?ref=1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "patch": "@@ -3,6 +3,7 @@\n \n use either::Either;\n use hir_expand::{\n+    db::AstDatabase,\n     hygiene::Hygiene,\n     name::{name, AsName, Name},\n     HirFileId, MacroDefId, MacroDefKind,\n@@ -41,8 +42,8 @@ pub(crate) struct LowerCtx {\n }\n \n impl LowerCtx {\n-    pub fn new(db: &dyn DefDatabase, file_id: HirFileId) -> Self {\n-        LowerCtx { hygiene: Hygiene::new(db.upcast(), file_id) }\n+    pub fn new(db: &dyn AstDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx { hygiene: Hygiene::new(db, file_id) }\n     }\n     pub fn with_hygiene(hygiene: &Hygiene) -> Self {\n         LowerCtx { hygiene: hygiene.clone() }\n@@ -119,7 +120,7 @@ impl ExprCollector<'_> {\n     }\n \n     fn ctx(&self) -> LowerCtx {\n-        LowerCtx::new(self.db, self.expander.current_file_id)\n+        LowerCtx::new(self.db.upcast(), self.expander.current_file_id)\n     }\n \n     fn alloc_expr(&mut self, expr: Expr, ptr: AstPtr<ast::Expr>) -> ExprId {"}, {"sha": "f4743f0f63d5c8f74b48dac155b8fa25c95f3f27", "filename": "crates/ra_hir_def/src/item_tree.rs", "status": "added", "additions": 511, "deletions": 0, "changes": 511, "blob_url": "https://github.com/rust-lang/rust/blob/1d75d11d6cbd8a2d4605fd185237ec2747b0687f/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d75d11d6cbd8a2d4605fd185237ec2747b0687f/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Fitem_tree.rs?ref=1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "patch": "@@ -0,0 +1,511 @@\n+//! A simplified AST that only contains items.\n+\n+use hir_expand::{\n+    ast_id_map::{AstIdMap, FileAstId},\n+    hygiene::Hygiene,\n+    name::{name, AsName, Name},\n+};\n+use ra_arena::{Arena, Idx, RawId};\n+use ra_syntax::ast;\n+\n+use crate::{\n+    attr::Attrs,\n+    generics::GenericParams,\n+    path::{path, AssociatedTypeBinding, GenericArgs, ImportAlias, ModPath, Path},\n+    type_ref::{Mutability, TypeBound, TypeRef},\n+    visibility::RawVisibility,\n+};\n+use ast::{NameOwner, StructKind, TypeAscriptionOwner};\n+use std::{\n+    ops::{Index, Range},\n+    sync::Arc,\n+};\n+\n+#[derive(Default)]\n+pub struct ItemTree {\n+    imports: Arena<Import>,\n+    functions: Arena<Function>,\n+    structs: Arena<Struct>,\n+    fields: Arena<Field>,\n+    unions: Arena<Union>,\n+    enums: Arena<Enum>,\n+    variants: Arena<Variant>,\n+    consts: Arena<Const>,\n+    statics: Arena<Static>,\n+    traits: Arena<Trait>,\n+    impls: Arena<Impl>,\n+    type_aliases: Arena<TypeAlias>,\n+    mods: Arena<Mod>,\n+    macro_calls: Arena<MacroCall>,\n+    exprs: Arena<Expr>,\n+}\n+\n+impl ItemTree {\n+    pub fn query(syntax: &ast::SourceFile) -> ItemTree {\n+        todo!()\n+    }\n+}\n+\n+macro_rules! impl_index {\n+    ( $($fld:ident: $t:ty),+ $(,)? ) => {\n+        $(\n+            impl Index<Idx<$t>> for ItemTree {\n+                type Output = $t;\n+\n+                fn index(&self, index: Idx<$t>) -> &Self::Output {\n+                    &self.$fld[index]\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+impl_index!(\n+    imports: Import,\n+    functions: Function,\n+    structs: Struct,\n+    fields: Field,\n+    unions: Union,\n+    enums: Enum,\n+    variants: Variant,\n+    consts: Const,\n+    statics: Static,\n+    traits: Trait,\n+    impls: Impl,\n+    type_aliases: TypeAlias,\n+    mods: Mod,\n+    macro_calls: MacroCall,\n+    exprs: Expr,\n+);\n+\n+pub struct Import {\n+    pub path: ModPath,\n+    pub alias: Option<ImportAlias>,\n+    pub visibility: RawVisibility,\n+    pub is_glob: bool,\n+    pub is_prelude: bool,\n+    pub is_extern_crate: bool,\n+    pub is_macro_use: bool,\n+}\n+\n+pub struct Function {\n+    pub name: Name,\n+    pub attrs: Attrs,\n+    pub visibility: RawVisibility,\n+    pub generic_params: GenericParams,\n+    pub has_self_param: bool,\n+    pub params: Vec<TypeRef>,\n+    pub ret_type: TypeRef,\n+    pub ast: FileAstId<ast::FnDef>,\n+}\n+\n+pub struct Struct {\n+    pub name: Name,\n+    pub attrs: Attrs,\n+    pub visibility: RawVisibility,\n+    pub generic_params: GenericParams,\n+    pub fields: Fields,\n+    pub ast: FileAstId<ast::StructDef>,\n+}\n+\n+pub struct Union {\n+    pub name: Name,\n+    pub attrs: Attrs,\n+    pub visibility: RawVisibility,\n+    pub generic_params: GenericParams,\n+    pub fields: Fields,\n+}\n+\n+pub struct Enum {\n+    pub name: Name,\n+    pub attrs: Attrs,\n+    pub visibility: RawVisibility,\n+    pub generic_params: GenericParams,\n+    pub variants: Range<Idx<Variant>>,\n+}\n+\n+pub struct Const {\n+    /// const _: () = ();\n+    pub name: Option<Name>,\n+    pub visibility: RawVisibility,\n+    pub type_ref: TypeRef,\n+}\n+\n+pub struct Static {\n+    pub name: Name,\n+    pub visibility: RawVisibility,\n+    pub type_ref: TypeRef,\n+}\n+\n+pub struct Trait {\n+    pub name: Name,\n+    pub visibility: RawVisibility,\n+    pub generic_params: GenericParams,\n+    pub auto: bool,\n+    pub items: Vec<AssocItem>,\n+}\n+\n+pub struct Impl {\n+    pub generic_params: GenericParams,\n+    pub target_trait: Option<TypeRef>,\n+    pub target_type: TypeRef,\n+    pub is_negative: bool,\n+    pub items: Vec<AssocItem>,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct TypeAlias {\n+    pub name: Name,\n+    pub visibility: RawVisibility,\n+    pub generic_params: GenericParams,\n+    pub type_ref: Option<TypeRef>,\n+}\n+\n+pub struct Mod {\n+    pub name: Name,\n+    pub visibility: RawVisibility,\n+    pub items: Vec<ModItem>,\n+}\n+\n+pub struct MacroCall {\n+    pub name: Option<Name>,\n+    pub path: ModPath,\n+    pub export: bool,\n+    pub builtin: bool,\n+    pub ast_id: FileAstId<ast::MacroCall>,\n+}\n+\n+// NB: There's no `FileAstId` for `Expr`. The only case where this would be useful is for array\n+// lengths, but we don't do much with them yet.\n+pub struct Expr;\n+\n+pub enum ModItem {\n+    Import(Idx<Import>),\n+    Function(Idx<Function>),\n+    Struct(Idx<Struct>),\n+    Union(Idx<Union>),\n+    Enum(Idx<Enum>),\n+    Const(Idx<Const>),\n+    Static(Idx<Static>),\n+    Trait(Idx<Trait>),\n+    Impl(Idx<Impl>),\n+    TypeAlias(Idx<TypeAlias>),\n+    Mod(Idx<Mod>),\n+    MacroCall(Idx<MacroCall>),\n+}\n+\n+pub enum AssocItem {\n+    Function(Idx<Function>),\n+    TypeAlias(Idx<TypeAlias>),\n+    Const(Idx<Const>),\n+    MacroCall(Idx<MacroCall>),\n+}\n+\n+pub struct Variant {\n+    pub name: Name,\n+    pub fields: Fields,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub enum Fields {\n+    Record(Range<Idx<Field>>),\n+    Tuple(Range<Idx<Field>>),\n+    Unit,\n+}\n+\n+/// A single field of an enum variant or struct\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct Field {\n+    pub name: Name,\n+    pub type_ref: TypeRef,\n+    pub visibility: RawVisibility,\n+}\n+\n+struct Ctx {\n+    tree: ItemTree,\n+    hygiene: Hygiene,\n+    source_ast_id_map: Arc<AstIdMap>,\n+    body_ctx: crate::body::LowerCtx,\n+}\n+\n+impl Ctx {\n+    fn lower(&mut self, item_owner: &dyn ast::ModuleItemOwner) {\n+        for item in item_owner.items() {\n+            self.lower_item(&item)\n+        }\n+    }\n+\n+    fn lower_item(&mut self, item: &ast::ModuleItem) {\n+        match item {\n+            ast::ModuleItem::StructDef(ast) => {\n+                if let Some(data) = self.lower_struct(ast) {\n+                    let idx = self.tree.structs.alloc(data);\n+                }\n+            }\n+            ast::ModuleItem::UnionDef(ast) => {\n+                if let Some(data) = self.lower_union(ast) {\n+                    let idx = self.tree.unions.alloc(data);\n+                }\n+            }\n+            ast::ModuleItem::EnumDef(ast) => {\n+                if let Some(data) = self.lower_enum(ast) {\n+                    let idx = self.tree.enums.alloc(data);\n+                }\n+            }\n+            ast::ModuleItem::FnDef(ast) => {\n+                if let Some(data) = self.lower_function(ast) {\n+                    let idx = self.tree.functions.alloc(data);\n+                }\n+            }\n+            ast::ModuleItem::TypeAliasDef(ast) => {\n+                if let Some(data) = self.lower_type_alias(ast) {\n+                    let idx = self.tree.type_aliases.alloc(data);\n+                }\n+            }\n+            ast::ModuleItem::StaticDef(ast) => {\n+                if let Some(data) = self.lower_static(ast) {\n+                    let idx = self.tree.statics.alloc(data);\n+                }\n+            }\n+            ast::ModuleItem::ConstDef(ast) => {\n+                let data = self.lower_const(ast);\n+                let idx = self.tree.consts.alloc(data);\n+            }\n+            ast::ModuleItem::Module(_) => {}\n+            ast::ModuleItem::TraitDef(_) => {}\n+            ast::ModuleItem::ImplDef(_) => {}\n+            ast::ModuleItem::UseItem(_) => {}\n+            ast::ModuleItem::ExternCrateItem(_) => {}\n+            ast::ModuleItem::MacroCall(_) => {}\n+            ast::ModuleItem::ExternBlock(_) => {}\n+        }\n+    }\n+\n+    fn lower_struct(&mut self, strukt: &ast::StructDef) -> Option<Struct> {\n+        let attrs = self.lower_attrs(strukt);\n+        let visibility = self.lower_visibility(strukt);\n+        let name = strukt.name()?.as_name();\n+        let generic_params = self.lower_generic_params(strukt);\n+        let fields = self.lower_fields(&strukt.kind());\n+        let ast = self.source_ast_id_map.ast_id(strukt);\n+        let res = Struct { name, attrs, visibility, generic_params, fields, ast };\n+        Some(res)\n+    }\n+\n+    fn lower_fields(&mut self, strukt_kind: &ast::StructKind) -> Fields {\n+        match strukt_kind {\n+            ast::StructKind::Record(it) => {\n+                let range = self.lower_record_fields(it);\n+                Fields::Record(range)\n+            }\n+            ast::StructKind::Tuple(it) => {\n+                let range = self.lower_tuple_fields(it);\n+                Fields::Tuple(range)\n+            }\n+            ast::StructKind::Unit => Fields::Unit,\n+        }\n+    }\n+\n+    fn lower_record_fields(&mut self, fields: &ast::RecordFieldDefList) -> Range<Idx<Field>> {\n+        let start = self.next_field_idx();\n+        for field in fields.fields() {\n+            if let Some(data) = self.lower_record_field(&field) {\n+                let idx = self.tree.fields.alloc(data);\n+            }\n+        }\n+        let end = self.next_field_idx();\n+        start..end\n+    }\n+\n+    fn lower_record_field(&self, field: &ast::RecordFieldDef) -> Option<Field> {\n+        let name = field.name()?.as_name();\n+        let visibility = self.lower_visibility(field);\n+        let type_ref = self.lower_type_ref(&field.ascribed_type()?);\n+        let res = Field { name, type_ref, visibility };\n+        Some(res)\n+    }\n+\n+    fn lower_tuple_fields(&mut self, fields: &ast::TupleFieldDefList) -> Range<Idx<Field>> {\n+        let start = self.next_field_idx();\n+        for (i, field) in fields.fields().enumerate() {\n+            if let Some(data) = self.lower_tuple_field(i, &field) {\n+                let idx = self.tree.fields.alloc(data);\n+            }\n+        }\n+        let end = self.next_field_idx();\n+        start..end\n+    }\n+\n+    fn lower_tuple_field(&self, idx: usize, field: &ast::TupleFieldDef) -> Option<Field> {\n+        let name = Name::new_tuple_field(idx);\n+        let visibility = self.lower_visibility(field);\n+        let type_ref = self.lower_type_ref(&field.type_ref()?);\n+        let res = Field { name, type_ref, visibility };\n+        Some(res)\n+    }\n+\n+    fn lower_union(&mut self, union: &ast::UnionDef) -> Option<Union> {\n+        let attrs = self.lower_attrs(union);\n+        let visibility = self.lower_visibility(union);\n+        let name = union.name()?.as_name();\n+        let generic_params = self.lower_generic_params(union);\n+        let fields = match union.record_field_def_list() {\n+            Some(record_field_def_list) => {\n+                self.lower_fields(&StructKind::Record(record_field_def_list))\n+            }\n+            None => Fields::Record(self.next_field_idx()..self.next_field_idx()),\n+        };\n+        let res = Union { name, attrs, visibility, generic_params, fields };\n+        Some(res)\n+    }\n+\n+    fn lower_enum(&mut self, enum_: &ast::EnumDef) -> Option<Enum> {\n+        let attrs = self.lower_attrs(enum_);\n+        let visibility = self.lower_visibility(enum_);\n+        let name = enum_.name()?.as_name();\n+        let generic_params = self.lower_generic_params(enum_);\n+        let variants = match &enum_.variant_list() {\n+            Some(variant_list) => self.lower_variants(variant_list),\n+            None => self.next_variant_idx()..self.next_variant_idx(),\n+        };\n+        let res = Enum { name, attrs, visibility, generic_params, variants };\n+        Some(res)\n+    }\n+\n+    fn lower_variants(&mut self, variants: &ast::EnumVariantList) -> Range<Idx<Variant>> {\n+        let start = self.next_variant_idx();\n+        for variant in variants.variants() {\n+            if let Some(data) = self.lower_variant(&variant) {\n+                let idx = self.tree.variants.alloc(data);\n+            }\n+        }\n+        let end = self.next_variant_idx();\n+        start..end\n+    }\n+\n+    fn lower_variant(&mut self, variant: &ast::EnumVariant) -> Option<Variant> {\n+        let name = variant.name()?.as_name();\n+        let fields = self.lower_fields(&variant.kind());\n+        let res = Variant { name, fields };\n+        Some(res)\n+    }\n+\n+    fn lower_function(&mut self, func: &ast::FnDef) -> Option<Function> {\n+        let attrs = self.lower_attrs(func);\n+        let visibility = self.lower_visibility(func);\n+        let name = func.name()?.as_name();\n+        let generic_params = self.lower_generic_params(func);\n+\n+        let mut params = Vec::new();\n+        let mut has_self_param = false;\n+        if let Some(param_list) = func.param_list() {\n+            if let Some(self_param) = param_list.self_param() {\n+                let self_type = if let Some(type_ref) = self_param.ascribed_type() {\n+                    TypeRef::from_ast(&self.body_ctx, type_ref)\n+                } else {\n+                    let self_type = TypeRef::Path(name![Self].into());\n+                    match self_param.kind() {\n+                        ast::SelfParamKind::Owned => self_type,\n+                        ast::SelfParamKind::Ref => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Shared)\n+                        }\n+                        ast::SelfParamKind::MutRef => {\n+                            TypeRef::Reference(Box::new(self_type), Mutability::Mut)\n+                        }\n+                    }\n+                };\n+                params.push(self_type);\n+                has_self_param = true;\n+            }\n+            for param in param_list.params() {\n+                let type_ref = TypeRef::from_ast_opt(&self.body_ctx, param.ascribed_type());\n+                params.push(type_ref);\n+            }\n+        }\n+        let ret_type = match func.ret_type().and_then(|rt| rt.type_ref()) {\n+            Some(type_ref) => TypeRef::from_ast(&self.body_ctx, type_ref),\n+            _ => TypeRef::unit(),\n+        };\n+\n+        let ret_type = if func.async_token().is_some() {\n+            let future_impl = desugar_future_path(ret_type);\n+            let ty_bound = TypeBound::Path(future_impl);\n+            TypeRef::ImplTrait(vec![ty_bound])\n+        } else {\n+            ret_type\n+        };\n+\n+        let ast = self.source_ast_id_map.ast_id(func);\n+        let res = Function {\n+            name,\n+            attrs,\n+            visibility,\n+            generic_params,\n+            has_self_param,\n+            params,\n+            ret_type,\n+            ast,\n+        };\n+        Some(res)\n+    }\n+\n+    fn lower_type_alias(&mut self, type_alias: &ast::TypeAliasDef) -> Option<TypeAlias> {\n+        let name = type_alias.name()?.as_name();\n+        let type_ref = type_alias.type_ref().map(|it| self.lower_type_ref(&it));\n+        let visibility = self.lower_visibility(type_alias);\n+        let generic_params = self.lower_generic_params(type_alias);\n+        let res = TypeAlias { name, visibility, generic_params, type_ref };\n+        Some(res)\n+    }\n+\n+    fn lower_static(&mut self, static_: &ast::StaticDef) -> Option<Static> {\n+        let name = static_.name()?.as_name();\n+        let type_ref = self.lower_type_ref_opt(static_.ascribed_type());\n+        let visibility = self.lower_visibility(static_);\n+        let res = Static { name, visibility, type_ref };\n+        Some(res)\n+    }\n+\n+    fn lower_const(&mut self, konst: &ast::ConstDef) -> Const {\n+        let name = konst.name().map(|it| it.as_name());\n+        let type_ref = self.lower_type_ref_opt(konst.ascribed_type());\n+        let visibility = self.lower_visibility(konst);\n+        Const { name, visibility, type_ref }\n+    }\n+\n+    fn lower_generic_params(&mut self, item: &impl ast::TypeParamsOwner) -> GenericParams {\n+        None.unwrap()\n+    }\n+\n+    fn lower_attrs(&self, item: &impl ast::AttrsOwner) -> Attrs {\n+        Attrs::new(item, &self.hygiene)\n+    }\n+    fn lower_visibility(&self, item: &impl ast::VisibilityOwner) -> RawVisibility {\n+        RawVisibility::from_ast_with_hygiene(item.visibility(), &self.hygiene)\n+    }\n+    fn lower_type_ref(&self, type_ref: &ast::TypeRef) -> TypeRef {\n+        TypeRef::from_ast(&self.body_ctx, type_ref.clone())\n+    }\n+    fn lower_type_ref_opt(&self, type_ref: Option<ast::TypeRef>) -> TypeRef {\n+        TypeRef::from_ast_opt(&self.body_ctx, type_ref)\n+    }\n+\n+    fn next_field_idx(&self) -> Idx<Field> {\n+        Idx::from_raw(RawId::from(self.tree.fields.len() as u32))\n+    }\n+    fn next_variant_idx(&self) -> Idx<Variant> {\n+        Idx::from_raw(RawId::from(self.tree.variants.len() as u32))\n+    }\n+}\n+\n+fn desugar_future_path(orig: TypeRef) -> Path {\n+    let path = path![std::future::Future];\n+    let mut generic_args: Vec<_> = std::iter::repeat(None).take(path.segments.len() - 1).collect();\n+    let mut last = GenericArgs::empty();\n+    let binding =\n+        AssociatedTypeBinding { name: name![Output], type_ref: Some(orig), bounds: Vec::new() };\n+    last.bindings.push(binding);\n+    generic_args.push(Some(Arc::new(last)));\n+\n+    Path::from_known_path(path, generic_args)\n+}"}, {"sha": "b5500f37070d37b5836ab752b4038004a9c81fa5", "filename": "crates/ra_hir_def/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1d75d11d6cbd8a2d4605fd185237ec2747b0687f/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d75d11d6cbd8a2d4605fd185237ec2747b0687f/crates%2Fra_hir_def%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_def%2Fsrc%2Flib.rs?ref=1d75d11d6cbd8a2d4605fd185237ec2747b0687f", "patch": "@@ -25,6 +25,8 @@ pub mod item_scope;\n pub mod dyn_map;\n pub mod keys;\n \n+pub mod item_tree;\n+\n pub mod adt;\n pub mod data;\n pub mod generics;"}]}