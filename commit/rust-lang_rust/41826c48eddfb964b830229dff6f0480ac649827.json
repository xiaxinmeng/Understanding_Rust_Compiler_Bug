{"sha": "41826c48eddfb964b830229dff6f0480ac649827", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQxODI2YzQ4ZWRkZmI5NjRiODMwMjI5ZGZmNmYwNDgwYWM2NDk4Mjc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-25T22:40:52Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-09-25T22:40:52Z"}, "message": "auto merge of #9475 : alexcrichton/rust/rustdoc++, r=cmr\n\nThe commit messages are a good technical summary, a good visual summary (contrib is this version):\r\n\r\nPub use statements now rendered. Notice how almost all components are also clickable!\r\n* http://static.rust-lang.org/doc/master/std/prelude/index.html\r\n* http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/prelude/index.html\r\n\r\nPrivate things hidden by default (for at least some approximation of privacy). I hope to improve this once privacy is totally ironed out.\r\n* http://static.rust-lang.org/doc/master/std/hashmap/struct.HashMap.html\r\n* http://www.contrib.andrew.cmu.edu/~acrichto/doc/std/hashmap/struct.HashMap.html\r\n\r\nUnindentation now works properly:\r\n* http://static.rust-lang.org/doc/master/extra/getopts/index.html\r\n* http://www.contrib.andrew.cmu.edu/~acrichto/doc/extra/getopts/index.html\r\n\r\nAlso sundown has massively reduced compilation time (of docs, not the of the crates)", "tree": {"sha": "b072ac06adc084acd477fb8f90971e79497313b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b072ac06adc084acd477fb8f90971e79497313b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/41826c48eddfb964b830229dff6f0480ac649827", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/41826c48eddfb964b830229dff6f0480ac649827", "html_url": "https://github.com/rust-lang/rust/commit/41826c48eddfb964b830229dff6f0480ac649827", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/41826c48eddfb964b830229dff6f0480ac649827/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24d46a0f45b4a0d6198b9d23dad2f7faa5a05d92", "url": "https://api.github.com/repos/rust-lang/rust/commits/24d46a0f45b4a0d6198b9d23dad2f7faa5a05d92", "html_url": "https://github.com/rust-lang/rust/commit/24d46a0f45b4a0d6198b9d23dad2f7faa5a05d92"}, {"sha": "3d5873fa421356ad936e6fc6ab61773c60646357", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d5873fa421356ad936e6fc6ab61773c60646357", "html_url": "https://github.com/rust-lang/rust/commit/3d5873fa421356ad936e6fc6ab61773c60646357"}], "stats": {"total": 7009, "additions": 6433, "deletions": 576}, "files": [{"sha": "70b2bb75a38fc57d34e5a3bd9d035aef483ffe9d", "filename": "configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/configure", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -684,7 +684,7 @@ do\n       isaac linenoise sync test \\\n       arch/i386 arch/x86_64 arch/arm arch/mips  \\\n       libuv libuv/src/ares libuv/src/eio libuv/src/ev \\\n-      jemalloc\n+      jemalloc sundown/src sundown/html\n     do\n       make_dir $t/rt/stage$s/$i\n     done"}, {"sha": "fb4d8f7c734e84d7c39d152178a1a7f5abbcf345", "filename": "mk/rt.mk", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/mk%2Frt.mk", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/mk%2Frt.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Frt.mk?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -82,7 +82,16 @@ RUNTIME_CXXS_$(1)_$(2) := \\\n               rt/rust_android_dummy.cpp \\\n               rt/rust_test_helpers.cpp\n \n-RUNTIME_CS_$(1)_$(2) := rt/linenoise/linenoise.c rt/linenoise/utf8.c\n+RUNTIME_CS_$(1)_$(2) := rt/linenoise/linenoise.c \\\n+\t\t\trt/linenoise/utf8.c \\\n+\t\t\trt/sundown/src/autolink.c \\\n+\t\t\trt/sundown/src/buffer.c \\\n+\t\t\trt/sundown/src/stack.c \\\n+\t\t\trt/sundown/src/markdown.c \\\n+\t\t\trt/sundown/html/houdini_href_e.c \\\n+\t\t\trt/sundown/html/houdini_html_e.c \\\n+\t\t\trt/sundown/html/html_smartypants.c \\\n+\t\t\trt/sundown/html/html.c\n \n RUNTIME_S_$(1)_$(2) := rt/arch/$$(HOST_$(1))/_context.S \\\n \t\t\trt/arch/$$(HOST_$(1))/ccall.S \\\n@@ -117,6 +126,8 @@ RUNTIME_DEF_$(1)_$(2) := $$(RT_OUTPUT_DIR_$(1))/rustrt$$(CFG_DEF_SUFFIX_$(1))\n RUNTIME_INCS_$(1)_$(2) := -I $$(S)src/rt -I $$(S)src/rt/isaac -I $$(S)src/rt/uthash \\\n                      -I $$(S)src/rt/arch/$$(HOST_$(1)) \\\n                      -I $$(S)src/rt/linenoise \\\n+                     -I $$(S)src/rt/sundown/src \\\n+                     -I $$(S)src/rt/sundown/html \\\n                      -I $$(S)src/libuv/include\n RUNTIME_OBJS_$(1)_$(2) := $$(RUNTIME_CXXS_$(1)_$(2):rt/%.cpp=$$(RT_BUILD_DIR_$(1)_$(2))/%.o) \\\n                      $$(RUNTIME_CS_$(1)_$(2):rt/%.c=$$(RT_BUILD_DIR_$(1)_$(2))/%.o) \\"}, {"sha": "be1d3ac057cd7bca6491c1561ab5a3c8c0473d67", "filename": "mk/tests.mk", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -227,8 +227,9 @@ ALL_CS := $(wildcard $(S)src/rt/*.cpp \\\n                      $(S)src/rt/*/*/*.cpp \\\n                      $(S)src/rustllvm/*.cpp)\n ALL_CS := $(filter-out $(S)src/rt/miniz.cpp \\\n-                       $(S)src/rt/linenoise/linenoise.c \\\n-                       $(S)src/rt/linenoise/utf8.c \\\n+\t\t       $(wildcard $(S)src/rt/linenoise/*.c) \\\n+\t\t       $(wildcard $(S)src/rt/sundown/src/*.c) \\\n+\t\t       $(wildcard $(S)src/rt/sundown/html/*.c) \\\n \t,$(ALL_CS))\n ALL_HS := $(wildcard $(S)src/rt/*.h \\\n                      $(S)src/rt/*/*.h \\\n@@ -241,6 +242,8 @@ ALL_HS := $(filter-out $(S)src/rt/vg/valgrind.h \\\n                        $(S)src/rt/msvc/inttypes.h \\\n                        $(S)src/rt/linenoise/linenoise.h \\\n                        $(S)src/rt/linenoise/utf8.h \\\n+\t\t       $(wildcard $(S)src/rt/sundown/src/*.h) \\\n+\t\t       $(wildcard $(S)src/rt/sundown/html/*.h) \\\n \t,$(ALL_HS))\n \n # Run the tidy script in multiple parts to avoid huge 'echo' commands"}, {"sha": "be55af697c66acc6ec4dd51ae8afe188d3ca6a26", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -17,7 +17,7 @@\n  * In this example, a large vector of floats is shared between several tasks.\n  * With simple pipes, without Arc, a copy would have to be made for each task.\n  *\n- * ~~~ {.rust}\n+ * ```rust\n  * extern mod std;\n  * use extra::arc;\n  * let numbers=vec::from_fn(100, |ind| (ind as float)*rand::random());\n@@ -34,7 +34,7 @@\n  *           // Work with the local numbers\n  *       }\n  *   }\n- * ~~~\n+ * ```\n  */\n \n #[allow(missing_doc)];\n@@ -440,7 +440,7 @@ impl<T:Freeze + Send> RWArc<T> {\n      *\n      * # Example\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * do arc.write_downgrade |mut write_token| {\n      *     do write_token.write_cond |state, condvar| {\n      *         ... exclusive access with mutable state ...\n@@ -450,7 +450,7 @@ impl<T:Freeze + Send> RWArc<T> {\n      *         ... shared access with immutable state ...\n      *     }\n      * }\n-     * ~~~\n+     * ```\n      */\n     pub fn write_downgrade<U>(&self, blk: &fn(v: RWWriteMode<T>) -> U) -> U {\n         unsafe {"}, {"sha": "f26554c42f4f9894b78dba7372b488cf574d7364", "filename": "src/libextra/base64.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fbase64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fbase64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbase64.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -62,15 +62,15 @@ impl<'self> ToBase64 for &'self [u8] {\n      *\n      * # Example\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * extern mod extra;\n      * use extra::base64::{ToBase64, standard};\n      *\n      * fn main () {\n      *     let str = [52,32].to_base64(standard);\n      *     printfln!(\"%s\", str);\n      * }\n-     * ~~~\n+     * ```\n      */\n     fn to_base64(&self, config: Config) -> ~str {\n         let bytes = match config.char_set {\n@@ -170,7 +170,7 @@ impl<'self> FromBase64 for &'self str {\n      *\n      * This converts a string literal to base64 and back.\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * extern mod extra;\n      * use extra::base64::{ToBase64, FromBase64, standard};\n      * use std::str;\n@@ -183,7 +183,7 @@ impl<'self> FromBase64 for &'self str {\n      *     let result_str = str::from_utf8(bytes);\n      *     printfln!(\"%s\", result_str);\n      * }\n-     * ~~~\n+     * ```\n      */\n     fn from_base64(&self) -> Result<~[u8], ~str> {\n         let mut r = ~[];"}, {"sha": "f55eff9360daec29421dba6ded9aed971405f528", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -26,8 +26,7 @@ Rust extras are part of the standard Rust distribution.\n        url = \"https://github.com/mozilla/rust/tree/master/src/libextra\")];\n \n #[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n-      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-      passes = \"strip-hidden\")];\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\")];\n \n #[comment = \"Rust extras\"];\n #[license = \"MIT/ASL2\"];"}, {"sha": "886a28ac9793f657478846e6aa700be4dc7534fa", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -25,7 +25,7 @@ ports and channels.\n \n This example sends boxed integers across tasks using serialization.\n \n-~~~ {.rust}\n+```rust\n let (port, chan) = serial::pipe_stream();\n \n do task::spawn || {\n@@ -37,7 +37,7 @@ do task::spawn || {\n for i in range(0, 10) {\n     assert @i == port.recv()\n }\n-~~~\n+ ```\n \n # Safety Note\n "}, {"sha": "72c6db6fb72daa667fb8a828295dbe75c0f1342f", "filename": "src/libextra/future.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -14,13 +14,13 @@\n  *\n  * # Example\n  *\n- * ~~~ {.rust}\n+ * ```rust\n  * # fn fib(n: uint) -> uint {42};\n  * # fn make_a_sandwich() {};\n  * let mut delayed_fib = extra::future::spawn (|| fib(5000) );\n  * make_a_sandwich();\n  * printfln!(\"fib(5000) = %?\", delayed_fib.get())\n- * ~~~\n+ * ```\n  */\n \n #[allow(missing_doc)];"}, {"sha": "f73c34224ee5fb0e9fadb4edde25393e01c407f7", "filename": "src/libextra/getopts.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fgetopts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fgetopts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fgetopts.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -29,7 +29,7 @@\n //! that requires an input file to be specified, accepts an optional output\n //! file name following -o, and accepts both -h and --help as optional flags.\n //!\n-//! ```\n+//! ~~~{.rust}\n //! exter mod extra;\n //! use extra::getopts::*;\n //! use std::os;\n@@ -75,7 +75,7 @@\n //!     };\n //!     do_work(input, output);\n //! }\n-//! ```\n+//! ~~~\n \n use std::cmp::Eq;\n use std::result::{Err, Ok};"}, {"sha": "76ac7c91832bd8acad8a1df455bff4c7deb5c98a", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -51,18 +51,18 @@ pub struct GlobIterator {\n  * Consider a directory `/media/pictures` containing only the files `kittens.jpg`,\n  * `puppies.jpg` and `hamsters.gif`:\n  *\n- * ~~~ {.rust}\n+ * ```rust\n  * for path in glob(\"/media/pictures/*.jpg\") {\n  *     println(path.to_str());\n  * }\n- * ~~~\n+ * ```\n  *\n  * The above code will print:\n  *\n- * ~~~\n+ * ```\n  * /media/pictures/kittens.jpg\n  * /media/pictures/puppies.jpg\n- * ~~~\n+ * ```\n  */\n pub fn glob(pattern: &str) -> GlobIterator {\n     glob_with(pattern, MatchOptions::new())\n@@ -270,11 +270,11 @@ impl Pattern {\n      *\n      * # Example\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * assert!(Pattern::new(\"c?t\").matches(\"cat\"));\n      * assert!(Pattern::new(\"k[!e]tteh\").matches(\"kitteh\"));\n      * assert!(Pattern::new(\"d*g\").matches(\"doog\"));\n-     * ~~~\n+     * ```\n      */\n     pub fn matches(&self, str: &str) -> bool {\n         self.matches_with(str, MatchOptions::new())\n@@ -492,13 +492,13 @@ impl MatchOptions {\n      *\n      * This function always returns this value:\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * MatchOptions {\n      *     case_sensitive: true,\n      *     require_literal_separator: false.\n      *     require_literal_leading_dot: false\n      * }\n-     * ~~~\n+     * ```\n      */\n     pub fn new() -> MatchOptions {\n         MatchOptions {"}, {"sha": "d5b89cafced9326c887576650218990750c35e1f", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -27,15 +27,15 @@ impl<'self> ToHex for &'self [u8] {\n      *\n      * # Example\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * extern mod extra;\n      * use extra::hex::ToHex;\n      *\n      * fn main () {\n      *     let str = [52,32].to_hex();\n      *     printfln!(\"%s\", str);\n      * }\n-     * ~~~\n+     * ```\n      */\n     fn to_hex(&self) -> ~str {\n         let mut v = vec::with_capacity(self.len() * 2);\n@@ -70,7 +70,7 @@ impl<'self> FromHex for &'self str {\n      *\n      * This converts a string literal to hexadecimal and back.\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * extern mod extra;\n      * use extra::hex::{FromHex, ToHex};\n      * use std::str;\n@@ -83,7 +83,7 @@ impl<'self> FromHex for &'self str {\n      *     let result_str = str::from_utf8(bytes);\n      *     printfln!(\"%s\", result_str);\n      * }\n-     * ~~~\n+     * ```\n      */\n     fn from_hex(&self) -> Result<~[u8], ~str> {\n         // This may be an overestimate if there is any whitespace"}, {"sha": "31ae5e70a9942136ea5f42485c63a837f71c6a4e", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -578,7 +578,7 @@ impl RWLock {\n      *\n      * # Example\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * do lock.write_downgrade |mut write_token| {\n      *     do write_token.write_cond |condvar| {\n      *         ... exclusive access ...\n@@ -588,7 +588,7 @@ impl RWLock {\n      *         ... shared access ...\n      *     }\n      * }\n-     * ~~~\n+     * ```\n      */\n     pub fn write_downgrade<U>(&self, blk: &fn(v: RWLockWriteMode) -> U) -> U {\n         // Implementation slightly different from the slicker 'write's above."}, {"sha": "77f8edc10aa5c679d868be2ba1b07b4ee1cf00ad", "filename": "src/libextra/uuid.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fuuid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibextra%2Fuuid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fuuid.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -28,15 +28,15 @@ unlikely.\n \n To create a new random (V4) UUID and print it out in hexadecimal form:\n \n-~~~ {.rust}\n+```rust\n extern mod extra;\n use extra::uuid::Uuid;\n \n fn main() {\n     let uuid1 = Uuid::new_v4();\n     println(uuid1.to_str());\n }\n-~~~\n+ ```\n \n # Strings\n "}, {"sha": "f4772d7adc3d38a45efbe14d82badde8ed34270f", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -2499,6 +2499,26 @@ impl Resolver {\n         assert!(import_resolution.outstanding_references >= 1);\n         import_resolution.outstanding_references -= 1;\n \n+        // record what this import resolves to for later uses in documentation,\n+        // this may resolve to either a value or a type, but for documentation\n+        // purposes it's good enough to just favor one over the other.\n+        match i.value_target {\n+            Some(target) => {\n+                self.def_map.insert(i.value_id,\n+                                    target.bindings.value_def.get_ref().def);\n+            }\n+            None => {}\n+        }\n+        match i.type_target {\n+            Some(target) => {\n+                match target.bindings.type_def.get_ref().type_def {\n+                    Some(def) => { self.def_map.insert(i.type_id, def); }\n+                    None => {}\n+                }\n+            }\n+            None => {}\n+        }\n+\n         debug!(\"(resolving single import) successfully resolved import\");\n         return Success(());\n     }\n@@ -2626,6 +2646,14 @@ impl Resolver {\n             merge_import_resolution(name, name_bindings);\n         }\n \n+        // Record the destination of this import\n+        match containing_module.def_id {\n+            Some(did) => {\n+                self.def_map.insert(id, DefMod(did));\n+            }\n+            None => {}\n+        }\n+\n         debug!(\"(resolving glob import) successfully resolved import\");\n         return Success(());\n     }"}, {"sha": "539418dbcb2282c9aac244bba4526c693f468efc", "filename": "src/librustc/middle/typeck/infer/doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fdoc.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -240,4 +240,4 @@ We make use of a trait-like impementation strategy to consolidate\n duplicated code between subtypes, GLB, and LUB computations.  See the\n section on \"Type Combining\" below for details.\n \n-*/\n\\ No newline at end of file\n+*/"}, {"sha": "ae7cbf76bcc83f85c560bdd4aabd998e374dbe60", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 58, "deletions": 32, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -15,6 +15,7 @@ use its = syntax::parse::token::ident_to_str;\n \n use syntax;\n use syntax::ast;\n+use syntax::ast_util;\n use syntax::attr::AttributeMethods;\n \n use std;\n@@ -283,7 +284,7 @@ impl Clean<Item> for ast::method {\n             attrs: self.attrs.clean(),\n             source: self.span.clean(),\n             id: self.self_id.clone(),\n-            visibility: None,\n+            visibility: self.vis.clean(),\n             inner: MethodItem(Method {\n                 generics: self.generics.clean(),\n                 self_: self.explicit_self.clean(),\n@@ -345,6 +346,7 @@ impl Clean<SelfTy> for ast::explicit_self {\n pub struct Function {\n     decl: FnDecl,\n     generics: Generics,\n+    purity: ast::purity,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -358,6 +360,7 @@ impl Clean<Item> for doctree::Function {\n             inner: FunctionItem(Function {\n                 decl: self.decl.clean(),\n                 generics: self.generics.clean(),\n+                purity: self.purity,\n             }),\n         }\n     }\n@@ -468,8 +471,7 @@ impl Clean<Item> for doctree::Trait {\n \n impl Clean<Type> for ast::trait_ref {\n     fn clean(&self) -> Type {\n-        let t = Unresolved(self.path.clean(), None, self.ref_id);\n-        resolve_type(&t)\n+        resolve_type(self.path.clean(), None, self.ref_id)\n     }\n }\n \n@@ -514,9 +516,6 @@ impl Clean<TraitMethod> for ast::trait_method {\n /// it does not preserve mutability or boxes.\n #[deriving(Clone, Encodable, Decodable)]\n pub enum Type {\n-    /// Most types start out as \"Unresolved\". It serves as an intermediate stage between cleaning\n-    /// and type resolution.\n-    Unresolved(Path, Option<~[TyParamBound]>, ast::NodeId),\n     /// structs/enums/traits (anything that'd be an ast::ty_path)\n     ResolvedPath { path: Path, typarams: Option<~[TyParamBound]>, id: ast::NodeId },\n     /// Reference to an item in an external crate (fully qualified path)\n@@ -555,25 +554,25 @@ impl Clean<Type> for ast::Ty {\n         debug!(\"cleaning type `%?`\", self);\n         let codemap = local_data::get(super::ctxtkey, |x| *x.unwrap()).sess.codemap;\n         debug!(\"span corresponds to `%s`\", codemap.span_to_str(self.span));\n-        let t = match self.node {\n+        match self.node {\n             ty_nil => Unit,\n-            ty_ptr(ref m) =>  RawPointer(m.mutbl.clean(), ~resolve_type(&m.ty.clean())),\n+            ty_ptr(ref m) => RawPointer(m.mutbl.clean(), ~m.ty.clean()),\n             ty_rptr(ref l, ref m) =>\n                 BorrowedRef {lifetime: l.clean(), mutability: m.mutbl.clean(),\n-                             type_: ~resolve_type(&m.ty.clean())},\n-            ty_box(ref m) => Managed(m.mutbl.clean(), ~resolve_type(&m.ty.clean())),\n-            ty_uniq(ref m) => Unique(~resolve_type(&m.ty.clean())),\n-            ty_vec(ref m) => Vector(~resolve_type(&m.ty.clean())),\n-            ty_fixed_length_vec(ref m, ref e) => FixedVector(~resolve_type(&m.ty.clean()),\n+                             type_: ~m.ty.clean()},\n+            ty_box(ref m) => Managed(m.mutbl.clean(), ~m.ty.clean()),\n+            ty_uniq(ref m) => Unique(~m.ty.clean()),\n+            ty_vec(ref m) => Vector(~m.ty.clean()),\n+            ty_fixed_length_vec(ref m, ref e) => FixedVector(~m.ty.clean(),\n                                                              e.span.to_src()),\n-            ty_tup(ref tys) => Tuple(tys.iter().map(|x| resolve_type(&x.clean())).collect()),\n-            ty_path(ref p, ref tpbs, id) => Unresolved(p.clean(), tpbs.clean(), id),\n+            ty_tup(ref tys) => Tuple(tys.iter().map(|x| x.clean()).collect()),\n+            ty_path(ref p, ref tpbs, id) =>\n+                resolve_type(p.clean(), tpbs.clean(), id),\n             ty_closure(ref c) => Closure(~c.clean()),\n             ty_bare_fn(ref barefn) => BareFunction(~barefn.clean()),\n             ty_bot => Bottom,\n             ref x => fail!(\"Unimplemented type %?\", x),\n-        };\n-        resolve_type(&t)\n+        }\n     }\n }\n \n@@ -927,26 +926,45 @@ impl Clean<ViewItemInner> for ast::view_item_ {\n \n #[deriving(Clone, Encodable, Decodable)]\n pub enum ViewPath {\n-    SimpleImport(~str, Path, ast::NodeId),\n-    GlobImport(Path, ast::NodeId),\n-    ImportList(Path, ~[ViewListIdent], ast::NodeId)\n+    // use str = source;\n+    SimpleImport(~str, ImportSource),\n+    // use source::*;\n+    GlobImport(ImportSource),\n+    // use source::{a, b, c};\n+    ImportList(ImportSource, ~[ViewListIdent]),\n+}\n+\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct ImportSource {\n+    path: Path,\n+    did: Option<ast::DefId>,\n }\n \n impl Clean<ViewPath> for ast::view_path {\n     fn clean(&self) -> ViewPath {\n         match self.node {\n-            ast::view_path_simple(ref i, ref p, ref id) => SimpleImport(i.clean(), p.clean(), *id),\n-            ast::view_path_glob(ref p, ref id) => GlobImport(p.clean(), *id),\n-            ast::view_path_list(ref p, ref pl, ref id) => ImportList(p.clean(), pl.clean(), *id),\n+            ast::view_path_simple(ref i, ref p, id) =>\n+                SimpleImport(i.clean(), resolve_use_source(p.clean(), id)),\n+            ast::view_path_glob(ref p, id) =>\n+                GlobImport(resolve_use_source(p.clean(), id)),\n+            ast::view_path_list(ref p, ref pl, id) =>\n+                ImportList(resolve_use_source(p.clean(), id), pl.clean()),\n         }\n     }\n }\n \n-pub type ViewListIdent = ~str;\n+#[deriving(Clone, Encodable, Decodable)]\n+pub struct ViewListIdent {\n+    name: ~str,\n+    source: Option<ast::DefId>,\n+}\n \n impl Clean<ViewListIdent> for ast::path_list_ident {\n     fn clean(&self) -> ViewListIdent {\n-        self.node.name.clean()\n+        ViewListIdent {\n+            name: self.node.name.clean(),\n+            source: resolve_def(self.node.id),\n+        }\n     }\n }\n \n@@ -1017,14 +1035,10 @@ fn remove_comment_tags(s: &str) -> ~str {\n }\n \n /// Given a Type, resolve it using the def_map\n-fn resolve_type(t: &Type) -> Type {\n+fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n+                id: ast::NodeId) -> Type {\n     use syntax::ast::*;\n \n-    let (path, tpbs, id) = match t {\n-        &Unresolved(ref path, ref tbps, id) => (path, tbps, id),\n-        _ => return (*t).clone(),\n-    };\n-\n     let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n     debug!(\"searching for %? in defmap\", id);\n     let d = match dm.find(&id) {\n@@ -1089,6 +1103,18 @@ fn resolve_type(t: &Type) -> Type {\n         let cname = cratedata.name.to_owned();\n         External(cname + \"::\" + path, ty)\n     } else {\n-        ResolvedPath {path: path.clone(), typarams: tpbs.clone(), id: def_id.node}\n+        ResolvedPath {path: path.clone(), typarams: tpbs, id: def_id.node}\n+    }\n+}\n+\n+fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n+    ImportSource {\n+        path: path,\n+        did: resolve_def(id),\n     }\n }\n+\n+fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n+    let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n+    dm.find(&id).map_move(|&d| ast_util::def_id_of_def(d))\n+}"}, {"sha": "a4e3f79549824bbd49326493d35860e89e446a00", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -107,6 +107,7 @@ pub struct Function {\n     id: NodeId,\n     name: Ident,\n     vis: ast::visibility,\n+    purity: ast::purity,\n     where: Span,\n     generics: ast::Generics,\n }"}, {"sha": "7010e7fa4eab6a51de94ba65a3ced8ce9d1f65cf", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 123, "deletions": 33, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -13,11 +13,13 @@ use std::local_data;\n use std::rt::io;\n \n use syntax::ast;\n+use syntax::ast_util;\n \n use clean;\n use html::render::{cache_key, current_location_key};\n \n pub struct VisSpace(Option<ast::visibility>);\n+pub struct PuritySpace(ast::purity);\n pub struct Method<'self>(&'self clean::SelfTy, &'self clean::FnDecl);\n \n impl fmt::Default for clean::Generics {\n@@ -95,7 +97,8 @@ impl fmt::Default for clean::Path {\n     }\n }\n \n-fn resolved_path(w: &mut io::Writer, id: ast::NodeId, path: &clean::Path) {\n+fn resolved_path(w: &mut io::Writer, id: ast::NodeId,\n+                 path: &clean::Path, print_all: bool) {\n     // The generics will get written to both the title and link\n     let mut generics = ~\"\";\n     let last = path.segments.last();\n@@ -117,47 +120,73 @@ fn resolved_path(w: &mut io::Writer, id: ast::NodeId, path: &clean::Path) {\n     // Did someone say rightward-drift?\n     do local_data::get(current_location_key) |loc| {\n         let loc = loc.unwrap();\n+\n+        if print_all {\n+            let mut root = match path.segments[0].name.as_slice() {\n+                \"super\" => ~\"../\",\n+                \"self\" => ~\"\",\n+                _ => \"../\".repeat(loc.len() - 1),\n+            };\n+            let amt = path.segments.len() - 1;\n+            for seg in path.segments.slice_to(amt).iter() {\n+                if \"super\" == seg.name || \"self\" == seg.name {\n+                    write!(w, \"{}::\", seg.name);\n+                } else {\n+                    root.push_str(seg.name);\n+                    root.push_str(\"/\");\n+                    write!(w, \"<a class='mod'\n+                                  href='{}index.html'>{}</a>::\",\n+                           root,\n+                           seg.name);\n+                }\n+            }\n+        }\n+\n         do local_data::get(cache_key) |cache| {\n             do cache.unwrap().read |cache| {\n                 match cache.paths.find(&id) {\n                     // This is a documented path, link to it!\n                     Some(&(ref fqp, shortty)) => {\n                         let fqn = fqp.connect(\"::\");\n-                        let mut same = 0;\n-                        for (a, b) in loc.iter().zip(fqp.iter()) {\n-                            if *a == *b {\n-                                same += 1;\n-                            } else {\n-                                break;\n-                            }\n-                        }\n+                        let same = loc.iter().zip(fqp.iter())\n+                                      .take_while(|&(a, b)| *a == *b).len();\n \n                         let mut url = ~\"\";\n-                        for _ in range(same, loc.len()) {\n+                        if \"super\" == path.segments[0].name {\n                             url.push_str(\"../\");\n+                        } else if \"self\" != path.segments[0].name {\n+                            url.push_str(\"../\".repeat(loc.len() - same));\n                         }\n-                        if same == fqp.len() {\n-                            url.push_str(shortty);\n-                            url.push_str(\".\");\n-                            url.push_str(*fqp.last());\n-                            url.push_str(\".html\");\n-                        } else {\n+                        if same < fqp.len() {\n                             let remaining = fqp.slice_from(same);\n                             let to_link = remaining.slice_to(remaining.len() - 1);\n                             for component in to_link.iter() {\n                                 url.push_str(*component);\n                                 url.push_str(\"/\");\n                             }\n-                            url.push_str(shortty);\n-                            url.push_str(\".\");\n-                            url.push_str(*remaining.last());\n-                            url.push_str(\".html\");\n                         }\n-\n+                        match shortty {\n+                            \"mod\" => {\n+                                url.push_str(*fqp.last());\n+                                url.push_str(\"/index.html\");\n+                            }\n+                            _ => {\n+                                url.push_str(shortty);\n+                                url.push_str(\".\");\n+                                url.push_str(*fqp.last());\n+                                url.push_str(\".html\");\n+                            }\n+                        }\n                         write!(w, \"<a class='{}' href='{}' title='{}'>{}</a>{}\",\n                                shortty, url, fqn, last.name, generics);\n                     }\n                     None => {\n+                        if print_all {\n+                            let amt = path.segments.len() - 1;\n+                            for seg in path.segments.iter().take(amt) {\n+                                write!(w, \"{}::\", seg.name);\n+                            }\n+                        }\n                         write!(w, \"{}{}\", last.name, generics);\n                     }\n                 };\n@@ -176,9 +205,8 @@ impl fmt::Default for clean::Type {\n                     }\n                 }\n             }\n-            clean::Unresolved(*) => unreachable!(),\n             clean::ResolvedPath{id, typarams: ref typarams, path: ref path} => {\n-                resolved_path(f.buf, id, path);\n+                resolved_path(f.buf, id, path, false);\n                 match *typarams {\n                     Some(ref params) => {\n                         f.buf.write(\"&lt;\".as_bytes());\n@@ -228,11 +256,7 @@ impl fmt::Default for clean::Type {\n                     None => {}\n                 }\n                 write!(f.buf, \"{}{}fn{}\",\n-                       match decl.purity {\n-                           ast::unsafe_fn => \"unsafe \",\n-                           ast::extern_fn => \"extern \",\n-                           ast::impure_fn => \"\"\n-                       },\n+                       PuritySpace(decl.purity),\n                        match decl.onceness {\n                            ast::Once => \"once \",\n                            ast::Many => \"\",\n@@ -242,11 +266,7 @@ impl fmt::Default for clean::Type {\n             }\n             clean::BareFunction(ref decl) => {\n                 write!(f.buf, \"{}{}fn{}{}\",\n-                       match decl.purity {\n-                           ast::unsafe_fn => \"unsafe \",\n-                           ast::extern_fn => \"extern \",\n-                           ast::impure_fn => \"\"\n-                       },\n+                       PuritySpace(decl.purity),\n                        match decl.abi {\n                            ~\"\" | ~\"\\\"Rust\\\"\" => ~\"\",\n                            ref s => \" \" + *s + \" \",\n@@ -362,3 +382,73 @@ impl fmt::Default for VisSpace {\n         }\n     }\n }\n+\n+impl fmt::Default for PuritySpace {\n+    fn fmt(p: &PuritySpace, f: &mut fmt::Formatter) {\n+        match **p {\n+            ast::unsafe_fn => write!(f.buf, \"unsafe \"),\n+            ast::extern_fn => write!(f.buf, \"extern \"),\n+            ast::impure_fn => {}\n+        }\n+    }\n+}\n+\n+impl fmt::Default for clean::ViewPath {\n+    fn fmt(v: &clean::ViewPath, f: &mut fmt::Formatter) {\n+        match *v {\n+            clean::SimpleImport(ref name, ref src) => {\n+                if *name == src.path.segments.last().name {\n+                    write!(f.buf, \"use {};\", *src);\n+                } else {\n+                    write!(f.buf, \"use {} = {};\", *name, *src);\n+                }\n+            }\n+            clean::GlobImport(ref src) => {\n+                write!(f.buf, \"use {}::*;\", *src);\n+            }\n+            clean::ImportList(ref src, ref names) => {\n+                write!(f.buf, \"use {}::\\\\{\", *src);\n+                for (i, n) in names.iter().enumerate() {\n+                    if i > 0 { write!(f.buf, \", \"); }\n+                    write!(f.buf, \"{}\", *n);\n+                }\n+                write!(f.buf, \"\\\\};\");\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Default for clean::ImportSource {\n+    fn fmt(v: &clean::ImportSource, f: &mut fmt::Formatter) {\n+        match v.did {\n+            Some(did) if ast_util::is_local(did) => {\n+                resolved_path(f.buf, did.node, &v.path, true);\n+            }\n+            _ => {\n+                for (i, seg) in v.path.segments.iter().enumerate() {\n+                    if i > 0 { write!(f.buf, \"::\") }\n+                    write!(f.buf, \"{}\", seg.name);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Default for clean::ViewListIdent {\n+    fn fmt(v: &clean::ViewListIdent, f: &mut fmt::Formatter) {\n+        match v.source {\n+            Some(did) if ast_util::is_local(did) => {\n+                let path = clean::Path {\n+                    global: false,\n+                    segments: ~[clean::PathSegment {\n+                        name: v.name.clone(),\n+                        lifetime: None,\n+                        types: ~[],\n+                    }]\n+                };\n+                resolved_path(f.buf, did.node, &path, false);\n+            }\n+            _ => write!(f.buf, \"{}\", v.name),\n+        }\n+    }\n+}"}, {"sha": "ce7e7f64dcc88de26f3ad965df831cb0717b2810", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 95, "deletions": 33, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -8,47 +8,109 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[allow(cstack)]; // each rendering task runs on a fixed stack segment.\n+\n use std::fmt;\n-use std::rt::io::Reader;\n-use std::rt::io::pipe::PipeStream;\n-use std::rt::io::process::{ProcessConfig, Process, CreatePipe};\n+use std::libc;\n use std::rt::io;\n+use std::vec;\n \n pub struct Markdown<'self>(&'self str);\n \n+static OUTPUT_UNIT: libc::size_t = 64;\n+static MKDEXT_NO_INTRA_EMPHASIS: libc::c_uint = 1 << 0;\n+static MKDEXT_TABLES: libc::c_uint = 1 << 1;\n+static MKDEXT_FENCED_CODE: libc::c_uint = 1 << 2;\n+static MKDEXT_AUTOLINK: libc::c_uint = 1 << 3;\n+static MKDEXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n+static MKDEXT_SPACE_HEADERS: libc::c_uint = 1 << 6;\n+static MKDEXT_SUPERSCRIPT: libc::c_uint = 1 << 7;\n+static MKDEXT_LAX_SPACING: libc::c_uint = 1 << 8;\n+\n+type sd_markdown = libc::c_void;  // this is opaque to us\n+\n+// this is a large struct of callbacks we don't use\n+type sd_callbacks = [libc::size_t, ..26];\n+\n+struct html_toc_data {\n+    header_count: libc::c_int,\n+    current_level: libc::c_int,\n+    level_offset: libc::c_int,\n+}\n+\n+struct html_renderopt {\n+    toc_data: html_toc_data,\n+    flags: libc::c_uint,\n+    link_attributes: Option<extern \"C\" fn(*buf, *buf, *libc::c_void)>,\n+}\n+\n+struct buf {\n+    data: *u8,\n+    size: libc::size_t,\n+    asize: libc::size_t,\n+    unit: libc::size_t,\n+}\n+\n+// sundown FFI\n+extern {\n+    fn sdhtml_renderer(callbacks: *sd_callbacks,\n+                       options_ptr: *html_renderopt,\n+                       render_flags: libc::c_uint);\n+    fn sd_markdown_new(extensions: libc::c_uint,\n+                       max_nesting: libc::size_t,\n+                       callbacks: *sd_callbacks,\n+                       opaque: *libc::c_void) -> *sd_markdown;\n+    fn sd_markdown_render(ob: *buf,\n+                          document: *u8,\n+                          doc_size: libc::size_t,\n+                          md: *sd_markdown);\n+    fn sd_markdown_free(md: *sd_markdown);\n+\n+    fn bufnew(unit: libc::size_t) -> *buf;\n+    fn bufrelease(b: *buf);\n+\n+}\n+\n+fn render(w: &mut io::Writer, s: &str) {\n+    // This code is all lifted from examples/sundown.c in the sundown repo\n+    unsafe {\n+        let ob = bufnew(OUTPUT_UNIT);\n+        let extensions = MKDEXT_NO_INTRA_EMPHASIS | MKDEXT_TABLES |\n+                         MKDEXT_FENCED_CODE | MKDEXT_AUTOLINK |\n+                         MKDEXT_STRIKETHROUGH;\n+        let options = html_renderopt {\n+            toc_data: html_toc_data {\n+                header_count: 0,\n+                current_level: 0,\n+                level_offset: 0,\n+            },\n+            flags: 0,\n+            link_attributes: None,\n+        };\n+        let callbacks: sd_callbacks = [0, ..26];\n+\n+        sdhtml_renderer(&callbacks, &options, 0);\n+        let markdown = sd_markdown_new(extensions, 16, &callbacks,\n+                                       &options as *html_renderopt as *libc::c_void);\n+\n+        do s.as_imm_buf |data, len| {\n+            sd_markdown_render(ob, data, len as libc::size_t, markdown);\n+        }\n+        sd_markdown_free(markdown);\n+\n+        do vec::raw::buf_as_slice((*ob).data, (*ob).size as uint) |buf| {\n+            w.write(buf);\n+        }\n+\n+        bufrelease(ob);\n+    }\n+}\n+\n impl<'self> fmt::Default for Markdown<'self> {\n     fn fmt(md: &Markdown<'self>, fmt: &mut fmt::Formatter) {\n+        // This is actually common enough to special-case\n         if md.len() == 0 { return; }\n \n-        // Create the pandoc process\n-        do io::io_error::cond.trap(|err| {\n-            fail2!(\"Error executing `pandoc`: {}\", err.desc);\n-        }).inside {\n-            let io = ~[CreatePipe(PipeStream::new().unwrap(), true, false),\n-                       CreatePipe(PipeStream::new().unwrap(), false, true)];\n-            let args = ProcessConfig {\n-                program: \"pandoc\",\n-                args: [],\n-                env: None,\n-                cwd: None,\n-                io: io,\n-            };\n-            let mut p = Process::new(args).expect(\"couldn't fork for pandoc\");\n-\n-            // Write the markdown to stdin and close it.\n-            p.io[0].get_mut_ref().write(md.as_bytes());\n-            p.io[0] = None;\n-\n-            // Ferry the output from pandoc over to the destination buffer.\n-            let mut buf = [0, ..1024];\n-            loop {\n-                match p.io[1].get_mut_ref().read(buf) {\n-                    None | Some(0) => { break }\n-                    Some(n) => {\n-                        fmt.buf.write(buf.slice_to(n));\n-                    }\n-                }\n-            }\n-        }\n+        render(fmt.buf, md.as_slice());\n     }\n }"}, {"sha": "4f8c11d828544f7af638cb489716a3e7163bac9d", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 99, "deletions": 30, "changes": 129, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -32,7 +32,7 @@ use syntax::ast;\n use clean;\n use doctree;\n use fold::DocFolder;\n-use html::format::{VisSpace, Method};\n+use html::format::{VisSpace, Method, PuritySpace};\n use html::layout;\n use html::markdown::Markdown;\n \n@@ -288,7 +288,9 @@ impl<'self> DocFolder for Cache {\n         } else { false };\n         match item.inner {\n             clean::StructItem(*) | clean::EnumItem(*) |\n-            clean::TypedefItem(*) | clean::TraitItem(*) => {\n+            clean::TypedefItem(*) | clean::TraitItem(*) |\n+            clean::FunctionItem(*) | clean::ModuleItem(*) |\n+            clean::VariantItem(*) => {\n                 self.paths.insert(item.id, (self.stack.clone(), shortty(&item)));\n             }\n             _ => {}\n@@ -401,8 +403,16 @@ impl Context {\n             let mut task = task::task();\n             task.unlinked(); // we kill things manually\n             task.name(format!(\"worker{}\", i));\n-            do task.spawn_with(cache.clone()) |cache| {\n+            task.spawn_with(cache.clone(),\n+                            |cache| worker(cache, &port, &chan, &prog_chan));\n+\n+            fn worker(cache: RWArc<Cache>,\n+                      port: &SharedPort<Work>,\n+                      chan: &SharedChan<Work>,\n+                      prog_chan: &SharedChan<Progress>) {\n+                #[fixed_stack_segment]; // we hit markdown FFI *a lot*\n                 local_data::set(cache_key, cache);\n+\n                 loop {\n                     match port.recv() {\n                         Process(cx, item) => {\n@@ -425,28 +435,20 @@ impl Context {\n             }\n         }\n \n-        let watcher_chan = chan.clone();\n-        let (done_port, done_chan) = comm::stream();\n-        do task::spawn {\n-            let mut jobs = 0;\n-            loop {\n-                match prog_port.recv() {\n-                    JobNew => jobs += 1,\n-                    JobDone => jobs -= 1,\n-                }\n-\n-                if jobs == 0 { break }\n+        chan.send(Process(self, item));\n+        let mut jobs = 1;\n+        loop {\n+            match prog_port.recv() {\n+                JobNew => jobs += 1,\n+                JobDone => jobs -= 1,\n             }\n \n-            for _ in range(0, WORKERS) {\n-                watcher_chan.send(Die);\n-            }\n-            done_chan.send(());\n+            if jobs == 0 { break }\n         }\n \n-        prog_chan.send(JobNew);\n-        chan.send(Process(self, item));\n-        done_port.recv();\n+        for _ in range(0, WORKERS) {\n+            chan.send(Die);\n+        }\n     }\n \n     fn item(&mut self, item: clean::Item, f: &fn(&mut Context, clean::Item)) {\n@@ -479,6 +481,8 @@ impl Context {\n         }\n \n         match item.inner {\n+            // modules are special because they add a namespace. We also need to\n+            // recurse into the items of the module as well.\n             clean::ModuleItem(*) => {\n                 let name = item.name.get_ref().to_owned();\n                 let item = Cell::new(item);\n@@ -498,11 +502,29 @@ impl Context {\n                     }\n                 }\n             }\n+\n+            // Things which don't have names (like impls) don't get special\n+            // pages dedicated to them.\n             _ if item.name.is_some() => {\n                 let dst = self.dst.push(item_path(&item));\n                 let writer = dst.open_writer(io::CreateOrTruncate);\n                 render(writer.unwrap(), self, &item, true);\n+\n+                // recurse if necessary\n+                let name = item.name.get_ref().clone();\n+                match item.inner {\n+                    clean::EnumItem(e) => {\n+                        let mut it = e.variants.move_iter();\n+                        do self.recurse(name) |this| {\n+                            for item in it {\n+                                f(this, item);\n+                            }\n+                        }\n+                    }\n+                    _ => {}\n+                }\n             }\n+\n             _ => {}\n         }\n     }\n@@ -567,6 +589,7 @@ impl<'self> fmt::Default for Item<'self> {\n             clean::StructItem(ref s) => item_struct(fmt.buf, it.item, s),\n             clean::EnumItem(ref e) => item_enum(fmt.buf, it.item, e),\n             clean::TypedefItem(ref t) => item_typedef(fmt.buf, it.item, t),\n+            clean::VariantItem(*) => item_variant(fmt.buf, it.cx, it.item),\n             _ => {}\n         }\n     }\n@@ -615,13 +638,21 @@ fn document(w: &mut io::Writer, item: &clean::Item) {\n fn item_module(w: &mut io::Writer, cx: &Context,\n                item: &clean::Item, items: &[clean::Item]) {\n     document(w, item);\n+    debug2!(\"{:?}\", items);\n     let mut indices = vec::from_fn(items.len(), |i| i);\n \n-    fn lt(i1: &clean::Item, i2: &clean::Item) -> bool {\n+    fn lt(i1: &clean::Item, i2: &clean::Item, idx1: uint, idx2: uint) -> bool {\n         if shortty(i1) == shortty(i2) {\n             return i1.name < i2.name;\n         }\n         match (&i1.inner, &i2.inner) {\n+            (&clean::ViewItemItem(ref a), &clean::ViewItemItem(ref b)) => {\n+                match (&a.inner, &b.inner) {\n+                    (&clean::ExternMod(*), _) => true,\n+                    (_, &clean::ExternMod(*)) => false,\n+                    _ => idx1 < idx2,\n+                }\n+            }\n             (&clean::ViewItemItem(*), _) => true,\n             (_, &clean::ViewItemItem(*)) => false,\n             (&clean::ModuleItem(*), _) => true,\n@@ -638,18 +669,19 @@ fn item_module(w: &mut io::Writer, cx: &Context,\n             (_, &clean::FunctionItem(*)) => false,\n             (&clean::TypedefItem(*), _) => true,\n             (_, &clean::TypedefItem(*)) => false,\n-            _ => false,\n+            _ => idx1 < idx2,\n         }\n     }\n \n+    debug2!(\"{:?}\", indices);\n     do sort::quick_sort(indices) |&i1, &i2| {\n-        lt(&items[i1], &items[i2])\n+        lt(&items[i1], &items[i2], i1, i2)\n     }\n \n+    debug2!(\"{:?}\", indices);\n     let mut curty = \"\";\n     for &idx in indices.iter() {\n         let myitem = &items[idx];\n-        if myitem.name.is_none() { loop }\n \n         let myty = shortty(myitem);\n         if myty != curty {\n@@ -687,17 +719,43 @@ fn item_module(w: &mut io::Writer, cx: &Context,\n \n                 write!(w, \"\n                     <tr>\n-                        <td><code>{}: {} = </code>{}</td>\n+                        <td><code>{}static {}: {} = </code>{}</td>\n                         <td class='docblock'>{}&nbsp;</td>\n                     </tr>\n                 \",\n+                VisSpace(myitem.visibility),\n                 *myitem.name.get_ref(),\n                 s.type_,\n                 Initializer(s.expr),\n                 Markdown(blank(myitem.doc_value())));\n             }\n \n+            clean::ViewItemItem(ref item) => {\n+                match item.inner {\n+                    clean::ExternMod(ref name, ref src, _, _) => {\n+                        write!(w, \"<tr><td><code>extern mod {}\",\n+                               name.as_slice());\n+                        match *src {\n+                            Some(ref src) => write!(w, \" = \\\"{}\\\"\",\n+                                                    src.as_slice()),\n+                            None => {}\n+                        }\n+                        write!(w, \";</code></td></tr>\");\n+                    }\n+\n+                    clean::Import(ref imports) => {\n+                        for import in imports.iter() {\n+                            write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n+                                   VisSpace(myitem.visibility),\n+                                   *import);\n+                        }\n+                    }\n+                }\n+\n+            }\n+\n             _ => {\n+                if myitem.name.is_none() { loop }\n                 write!(w, \"\n                     <tr>\n                         <td><a class='{class}' href='{href}'\n@@ -717,8 +775,9 @@ fn item_module(w: &mut io::Writer, cx: &Context,\n }\n \n fn item_function(w: &mut io::Writer, it: &clean::Item, f: &clean::Function) {\n-    write!(w, \"<pre class='fn'>{vis}fn {name}{generics}{decl}</pre>\",\n+    write!(w, \"<pre class='fn'>{vis}{purity}fn {name}{generics}{decl}</pre>\",\n            vis = VisSpace(it.visibility),\n+           purity = PuritySpace(f.purity),\n            name = it.name.get_ref().as_slice(),\n            generics = f.generics,\n            decl = f.decl);\n@@ -830,8 +889,8 @@ fn render_method(w: &mut io::Writer, meth: &clean::Item, withlink: bool) {\n            g: &clean::Generics, selfty: &clean::SelfTy, d: &clean::FnDecl,\n            withlink: bool) {\n         write!(w, \"{}fn {withlink, select,\n-                            true{<a href='\\\\#fn.{name}'>{name}</a>}\n-                            other{{name}}\n+                            true{<a href='\\\\#fn.{name}' class='fnname'>{name}</a>}\n+                            other{<span class='fnname'>{name}</span>}\n                         }{generics}{decl}\",\n                match purity {\n                    ast::unsafe_fn => \"unsafe \",\n@@ -872,7 +931,8 @@ fn item_enum(w: &mut io::Writer, it: &clean::Item, e: &clean::Enum) {\n     } else {\n         write!(w, \" \\\\{\\n\");\n         for v in e.variants.iter() {\n-            let name = v.name.get_ref().as_slice();\n+            let name = format!(\"<a name='variant.{0}'>{0}</a>\",\n+                               v.name.get_ref().as_slice());\n             match v.inner {\n                 clean::VariantItem(ref var) => {\n                     match var.kind {\n@@ -1101,3 +1161,12 @@ fn build_sidebar(m: &clean::Module) -> HashMap<~str, ~[~str]> {\n     }\n     return map;\n }\n+\n+fn item_variant(w: &mut io::Writer, cx: &Context, it: &clean::Item) {\n+    write!(w, \"<DOCTYPE html><html><head>\\\n+                <meta http-equiv='refresh' content='0; \\\n+                      url=../enum.{}.html\\\\#variant.{}'>\\\n+               </head><body></body></html>\",\n+           *cx.current.last(),\n+           it.name.get_ref().as_slice());\n+}"}, {"sha": "97f597982406bbd416967690fdf831ce561b0461", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -221,6 +221,7 @@ a {\n .content a.enum, .block a.current.enum { color: #5e9766; }\n .content a.struct, .block a.current.struct { color: #e53700; }\n .content a.fn, .block a.current.fn { color: #8c6067; }\n+.content .fnname { color: #8c6067; }\n \n .search-input {\n     border: 2px solid #f2f2f2;"}, {"sha": "91e2b3bfcf187c75fb80ba5af657d726e2d1b583", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 75, "deletions": 24, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -11,8 +11,9 @@\n use std::num;\n use std::uint;\n \n-use clean;\n use syntax::ast;\n+\n+use clean;\n use clean::Item;\n use plugins;\n use fold;\n@@ -47,6 +48,78 @@ pub fn strip_hidden(crate: clean::Crate) -> plugins::PluginResult {\n     (crate, None)\n }\n \n+/// Strip private items from the point of view of a crate or externally from a\n+/// crate, specified by the `xcrate` flag.\n+pub fn strip_private(crate: clean::Crate) -> plugins::PluginResult {\n+    struct Stripper;\n+    impl fold::DocFolder for Stripper {\n+        fn fold_item(&mut self, i: Item) -> Option<Item> {\n+            match i.inner {\n+                // These items can all get re-exported\n+                clean::TypedefItem(*) | clean::StaticItem(*) |\n+                clean::StructItem(*) | clean::EnumItem(*) |\n+                clean::TraitItem(*) | clean::FunctionItem(*) |\n+                clean::ViewItemItem(*) | clean::MethodItem(*) => {\n+                    // XXX: re-exported items should get surfaced in the docs as\n+                    //      well (using the output of resolve analysis)\n+                    if i.visibility != Some(ast::public) {\n+                        return None;\n+                    }\n+                }\n+\n+                // These are public-by-default (if the enum was public)\n+                clean::VariantItem(*) => {\n+                    if i.visibility == Some(ast::private) {\n+                        return None;\n+                    }\n+                }\n+\n+                // We show these regardless of whether they're public/private\n+                // because it's useful to see sometimes\n+                clean::StructFieldItem(*) => {}\n+\n+                // handled below\n+                clean::ModuleItem(*) => {}\n+\n+                // impls/tymethods have no control over privacy\n+                clean::ImplItem(*) | clean::TyMethodItem(*) => {}\n+            }\n+\n+            let fastreturn = match i.inner {\n+                // nothing left to do for traits (don't want to filter their\n+                // methods out, visibility controlled by the trait)\n+                clean::TraitItem(*) => true,\n+\n+                // implementations of traits are always public.\n+                clean::ImplItem(ref imp) if imp.trait_.is_some() => true,\n+\n+                _ => false,\n+            };\n+\n+            let i = if fastreturn {\n+                return Some(i);\n+            } else {\n+                self.fold_item_recur(i)\n+            };\n+\n+            match i {\n+                Some(i) => {\n+                    match i.inner {\n+                        // emptied modules/impls have no need to exist\n+                        clean::ModuleItem(ref m) if m.items.len() == 0 => None,\n+                        clean::ImplItem(ref i) if i.methods.len() == 0 => None,\n+                        _ => Some(i),\n+                    }\n+                }\n+                None => None,\n+            }\n+        }\n+    }\n+    let mut stripper = Stripper;\n+    let crate = stripper.fold_crate(crate);\n+    (crate, None)\n+}\n+\n pub fn unindent_comments(crate: clean::Crate) -> plugins::PluginResult {\n     struct CommentCleaner;\n     impl fold::DocFolder for CommentCleaner {\n@@ -69,27 +142,6 @@ pub fn unindent_comments(crate: clean::Crate) -> plugins::PluginResult {\n     (crate, None)\n }\n \n-pub fn collapse_privacy(crate: clean::Crate) -> plugins::PluginResult {\n-    struct PrivacyCollapser {\n-        stack: ~[clean::Visibility]\n-    }\n-    impl fold::DocFolder for PrivacyCollapser {\n-        fn fold_item(&mut self, mut i: Item) -> Option<Item> {\n-            if i.visibility.is_some() {\n-                if i.visibility == Some(ast::inherited) {\n-                    i.visibility = Some(self.stack.last().clone());\n-                } else {\n-                    self.stack.push(i.visibility.clone().unwrap());\n-                }\n-            }\n-            self.fold_item_recur(i)\n-        }\n-    }\n-    let mut privacy = PrivacyCollapser { stack: ~[] };\n-    let crate = privacy.fold_crate(crate);\n-    (crate, None)\n-}\n-\n pub fn collapse_docs(crate: clean::Crate) -> plugins::PluginResult {\n     struct Collapser;\n     impl fold::DocFolder for Collapser {\n@@ -110,7 +162,7 @@ pub fn collapse_docs(crate: clean::Crate) -> plugins::PluginResult {\n                 _ => true\n             }).map(|x| x.clone()).collect();\n             if \"\" != docstr {\n-                a.push(clean::NameValue(~\"doc\", docstr.trim().to_owned()));\n+                a.push(clean::NameValue(~\"doc\", docstr));\n             }\n             i.attrs = a;\n             self.fold_item_recur(i)\n@@ -121,7 +173,6 @@ pub fn collapse_docs(crate: clean::Crate) -> plugins::PluginResult {\n     (crate, None)\n }\n \n-// n.b. this is copied from src/librustdoc/unindent_pass.rs\n pub fn unindent(s: &str) -> ~str {\n     let lines = s.any_line_iter().collect::<~[&str]>();\n     let mut saw_first_line = false;"}, {"sha": "ccab6dad835ab129f212d6104ba1e93cab613c99", "filename": "src/librustdoc/rustdoc.rs", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -45,6 +45,28 @@ pub mod visit_ast;\n \n pub static SCHEMA_VERSION: &'static str = \"0.8.0\";\n \n+type Pass = (&'static str,                                      // name\n+             extern fn(clean::Crate) -> plugins::PluginResult,  // fn\n+             &'static str);                                     // description\n+\n+static PASSES: &'static [Pass] = &[\n+    (\"strip-hidden\", passes::strip_hidden,\n+     \"strips all doc(hidden) items from the output\"),\n+    (\"unindent-comments\", passes::unindent_comments,\n+     \"removes excess indentation on comments in order for markdown to like it\"),\n+    (\"collapse-docs\", passes::collapse_docs,\n+     \"concatenates all document attributes into one document attribute\"),\n+    (\"strip-private\", passes::strip_private,\n+     \"strips all private items from a crate which cannot be seen externally\"),\n+];\n+\n+static DEFAULT_PASSES: &'static [&'static str] = &[\n+    \"strip-hidden\",\n+    \"strip-private\",\n+    \"collapse-docs\",\n+    \"unindent-comments\",\n+];\n+\n local_data_key!(pub ctxtkey: @core::DocContext)\n \n enum OutputFormat {\n@@ -61,7 +83,8 @@ pub fn opts() -> ~[groups::OptGroup] {\n         optmulti(\"L\", \"library-path\", \"directory to add to crate search path\",\n                  \"DIR\"),\n         optmulti(\"\", \"plugin-path\", \"directory to load plugins from\", \"DIR\"),\n-        optmulti(\"\", \"passes\", \"space separated list of passes to also run\",\n+        optmulti(\"\", \"passes\", \"space separated list of passes to also run, a \\\n+                                value of `list` will print available passes\",\n                  \"PASSES\"),\n         optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n                  \"PLUGINS\"),\n@@ -86,6 +109,22 @@ pub fn main_args(args: &[~str]) -> int {\n         return 0;\n     }\n \n+    let mut default_passes = !matches.opt_present(\"nodefaults\");\n+    let mut passes = matches.opt_strs(\"passes\");\n+    let mut plugins = matches.opt_strs(\"plugins\");\n+\n+    if passes == ~[~\"list\"] {\n+        println(\"Available passes for running rustdoc:\");\n+        for &(name, _, description) in PASSES.iter() {\n+            println!(\"{:>20s} - {}\", name, description);\n+        }\n+        println(\"\\nDefault passes for rustdoc:\");\n+        for &name in DEFAULT_PASSES.iter() {\n+            println!(\"{:>20s}\", name);\n+        }\n+        return 0;\n+    }\n+\n     let (format, cratefile) = match matches.free.clone() {\n         [~\"json\", crate] => (JSON, crate),\n         [~\"html\", crate] => (HTML, crate),\n@@ -118,9 +157,6 @@ pub fn main_args(args: &[~str]) -> int {\n \n     // Process all of the crate attributes, extracting plugin metadata along\n     // with the passes which we are supposed to run.\n-    let mut default_passes = !matches.opt_present(\"nodefaults\");\n-    let mut passes = matches.opt_strs(\"passes\");\n-    let mut plugins = matches.opt_strs(\"plugins\");\n     match crate.module.get_ref().doc_list() {\n         Some(nested) => {\n             for inner in nested.iter() {\n@@ -145,19 +181,20 @@ pub fn main_args(args: &[~str]) -> int {\n         None => {}\n     }\n     if default_passes {\n-        passes.unshift(~\"collapse-docs\");\n-        passes.unshift(~\"unindent-comments\");\n+        for name in DEFAULT_PASSES.rev_iter() {\n+            passes.unshift(name.to_owned());\n+        }\n     }\n \n     // Load all plugins/passes into a PluginManager\n     let mut pm = plugins::PluginManager::new(Path(\"/tmp/rustdoc_ng/plugins\"));\n     for pass in passes.iter() {\n-        let plugin = match pass.as_slice() {\n-            \"strip-hidden\" => passes::strip_hidden,\n-            \"unindent-comments\" => passes::unindent_comments,\n-            \"collapse-docs\" => passes::collapse_docs,\n-            \"collapse-privacy\" => passes::collapse_privacy,\n-            s => { error!(\"unknown pass %s, skipping\", s); loop },\n+        let plugin = match PASSES.iter().position(|&(p, _, _)| p == *pass) {\n+            Some(i) => PASSES[i].n1(),\n+            None => {\n+                error2!(\"unknown pass {}, skipping\", *pass);\n+                loop\n+            },\n         };\n         pm.add_plugin(plugin);\n     }"}, {"sha": "c4b9b9efe566eb78a6e3c6e6792ae7e6303112bb", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -75,7 +75,7 @@ impl RustdocVisitor {\n             }\n         }\n \n-        fn visit_fn(item: &ast::item, fd: &ast::fn_decl, _purity: &ast::purity,\n+        fn visit_fn(item: &ast::item, fd: &ast::fn_decl, purity: &ast::purity,\n                      _abi: &AbiSet, gen: &ast::Generics) -> Function {\n             debug!(\"Visiting fn\");\n             Function {\n@@ -86,6 +86,7 @@ impl RustdocVisitor {\n                 name: item.ident,\n                 where: item.span,\n                 generics: gen.clone(),\n+                purity: *purity,\n             }\n         }\n "}, {"sha": "3b233c9f6a88ac9788d1a74a4b3dad26911fb7b6", "filename": "src/librustpkg/testsuite/pass/src/fancy-lib/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Ffancy-lib%2Ffoo.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n pub fn do_nothing() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3d22ddc57faa30021e03b924b1aed2e12798797a", "filename": "src/librustpkg/testsuite/pass/src/install-paths/bench.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Finstall-paths%2Fbench.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -14,4 +14,4 @@ fn g() {\n     while(x < 1000) {\n         x += 1;\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "3b233c9f6a88ac9788d1a74a4b3dad26911fb7b6", "filename": "src/librustpkg/testsuite/pass/src/simple-lib/src/foo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftestsuite%2Fpass%2Fsrc%2Fsimple-lib%2Fsrc%2Ffoo.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -9,4 +9,4 @@\n // except according to those terms.\n \n pub fn do_nothing() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "1d59e63e702f5be9f4bc9dfa382bc4391da5176a", "filename": "src/libstd/bool.rs", "status": "modified", "additions": 54, "deletions": 54, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fbool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fbool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbool.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -52,15 +52,15 @@ use to_str::ToStr;\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::not(true)\n * false\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::not(false)\n * true\n-* ~~~\n+* ```\n */\n pub fn not(v: bool) -> bool { !v }\n \n@@ -69,15 +69,15 @@ pub fn not(v: bool) -> bool { !v }\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::and(true, false)\n * false\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::and(true, true)\n * true\n-* ~~~\n+* ```\n */\n pub fn and(a: bool, b: bool) -> bool { a && b }\n \n@@ -86,15 +86,15 @@ pub fn and(a: bool, b: bool) -> bool { a && b }\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::or(true, false)\n * true\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::or(false, false)\n * false\n-* ~~~\n+* ```\n */\n pub fn or(a: bool, b: bool) -> bool { a || b }\n \n@@ -105,15 +105,15 @@ pub fn or(a: bool, b: bool) -> bool { a || b }\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::xor(true, false)\n * true\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::xor(true, true)\n * false\n-* ~~~\n+* ```\n */\n pub fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n \n@@ -126,15 +126,15 @@ pub fn xor(a: bool, b: bool) -> bool { (a && !b) || (!a && b) }\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::implies(true, true)\n * true\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::implies(true, false)\n * false\n-* ~~~\n+* ```\n */\n pub fn implies(a: bool, b: bool) -> bool { !a || b }\n \n@@ -143,15 +143,15 @@ pub fn implies(a: bool, b: bool) -> bool { !a || b }\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::is_true(true)\n * true\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::is_true(false)\n * false\n-* ~~~\n+* ```\n */\n pub fn is_true(v: bool) -> bool { v }\n \n@@ -160,15 +160,15 @@ pub fn is_true(v: bool) -> bool { v }\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::is_false(false)\n * true\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::is_false(true)\n * false\n-* ~~~\n+* ```\n */\n pub fn is_false(v: bool) -> bool { !v }\n \n@@ -179,20 +179,20 @@ pub fn is_false(v: bool) -> bool { !v }\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> FromStr::from_str::<bool>(\"true\")\n * Some(true)\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> FromStr::from_str::<bool>(\"false\")\n * Some(false)\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> FromStr::from_str::<bool>(\"not even a boolean\")\n * None\n-* ~~~\n+* ```\n */\n impl FromStr for bool {\n     fn from_str(s: &str) -> Option<bool> {\n@@ -209,15 +209,15 @@ impl FromStr for bool {\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> true.to_str()\n * \"true\"\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> false.to_str()\n * \"false\"\n-* ~~~\n+* ```\n */\n impl ToStr for bool {\n     #[inline]\n@@ -232,11 +232,11 @@ impl ToStr for bool {\n * There are no guarantees about the order values will be given.\n *\n * # Examples\n-* ~~~\n+* ```\n * do std::bool::all_values |x: bool| {\n *     println(x.to_str())\n * }\n-* ~~~\n+* ```\n */\n pub fn all_values(blk: &fn(v: bool)) {\n     blk(true);\n@@ -248,15 +248,15 @@ pub fn all_values(blk: &fn(v: bool)) {\n *\n * # Examples\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::to_bit(true)\n * 1\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> std::bool::to_bit(false)\n * 0\n-* ~~~\n+* ```\n */\n #[inline]\n pub fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n@@ -269,12 +269,12 @@ pub fn to_bit(v: bool) -> u8 { if v { 1u8 } else { 0u8 } }\n * ~~~rust\n * rusti> !true\n * false\n-* ~~~\n+* ```\n *\n * ~~~rust\n * rusti> !false\n * true\n-* ~~~\n+* ```\n */\n #[cfg(not(test))]\n impl Not<bool> for bool {\n@@ -299,25 +299,25 @@ impl TotalOrd for bool {\n *\n * Two booleans are equal if they have the same value.\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> false.eq(&true)\n * false\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> false == false\n * true\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> false != true\n * true\n-* ~~~\n+* ```\n *\n-* ~~~ {.rust}\n+* ```rust\n * rusti> false.ne(&false)\n * false\n-* ~~~\n+* ```\n */\n #[cfg(not(test))]\n impl Eq for bool {"}, {"sha": "823cc0db4b9b111b83778acf008cb3a852eb0dfd", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -38,7 +38,7 @@ unnecessary amounts of allocations.\n \n An example of creating and using a C string would be:\n \n-~~~{.rust}\n+```rust\n use std::libc;\n externfn!(fn puts(s: *libc::c_char))\n \n@@ -56,7 +56,7 @@ do my_c_string.with_ref |c_buffer| {\n do my_string.with_c_str |c_buffer| {\n     unsafe { puts(c_buffer); }\n }\n-~~~\n+ ```\n \n */\n \n@@ -204,9 +204,9 @@ pub trait ToCStr {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let s = \"PATH\".with_c_str(|path| libc::getenv(path))\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Failure\n     ///"}, {"sha": "e028bbeac68a122d26ca2c226166fb946283293b", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -67,10 +67,10 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  *\n  * # Example\n  *\n- * ~~~ {.rust}\n+ * ```rust\n  * let v: &[u8] = transmute(\"L\");\n  * assert!(v == [76u8]);\n- * ~~~\n+ * ```\n  */\n #[inline]\n pub unsafe fn transmute<L, G>(thing: L) -> G {"}, {"sha": "39db1df3df1c86ac74b9c0cb6a3b81427baa1f75", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -19,17 +19,17 @@ same manner.\n \n A condition is declared through the `condition!` macro provided by the compiler:\n \n-~~~{.rust}\n+```rust\n condition! {\n     pub my_error: int -> ~str;\n }\n-~~~\n+ ```\n \n This macro declares an inner module called `my_error` with one static variable,\n `cond` that is a static `Condition` instance. To help understand what the other\n parameters are used for, an example usage of this condition would be:\n \n-~~~{.rust}\n+```rust\n do my_error::cond.trap(|raised_int| {\n \n     // the condition `my_error` was raised on, and the value it raised is stored\n@@ -51,7 +51,7 @@ do my_error::cond.trap(|raised_int| {\n     println(my_error::cond.raise(4)); // prints \"oh well\"\n \n }\n-~~~\n+ ```\n \n Condition handling is useful in cases where propagating errors is either to\n cumbersome or just not necessary in the first place. It should also be noted,\n@@ -96,14 +96,14 @@ impl<T, U> Condition<T, U> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~{.rust}\n+    /// ```rust\n     /// condition! { my_error: int -> int; }\n     ///\n     /// let trap = my_error::cond.trap(|error| error + 3);\n     ///\n     /// // use `trap`'s inside method to register the handler and then run a\n     /// // block of code with the handler registered\n-    /// ~~~\n+    /// ```\n     pub fn trap<'a>(&'a self, h: &'a fn(T) -> U) -> Trap<'a, T, U> {\n         let h: Closure = unsafe { ::cast::transmute(h) };\n         let prev = local_data::get(self.key, |k| k.map(|&x| *x));\n@@ -173,14 +173,14 @@ impl<'self, T, U> Trap<'self, T, U> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~{.rust}\n+    /// ```rust\n     /// condition! { my_error: int -> int; }\n     ///\n     /// let result = do my_error::cond.trap(|error| error + 3).inside {\n     ///     my_error::cond.raise(4)\n     /// };\n     /// assert_eq!(result, 7);\n-    /// ~~~\n+    /// ```\n     pub fn inside<V>(&self, inner: &'self fn() -> V) -> V {\n         let _g = Guard { cond: self.cond };\n         debug!(\"Trap: pushing handler to TLS\");"}, {"sha": "f35a61677e80c0edef3e410d888efac05f9af806", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -33,14 +33,14 @@ arguments directly while performing minimal allocations.\n \n Some examples of the `format!` extension are:\n \n-~~~{.rust}\n+```rust\n format!(\"Hello\")                  // => ~\"Hello\"\n format!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n format!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n format!(\"{:?}\", ~[3, 4])          // => ~\"~[3, 4]\"\n format!(\"{value}\", value=4)       // => ~\"4\"\n format!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n-~~~\n+ ```\n \n From these, you can see that the first argument is a format string. It is\n required by the compiler for this to be a string literal; it cannot be a\n@@ -67,9 +67,9 @@ function, but the `format!` macro is a syntax extension which allows it to\n leverage named parameters. Named parameters are listed at the end of the\n argument list and have the syntax:\n \n-~~~\n+ ```\n identifier '=' expression\n-~~~\n+ ```\n \n It is illegal to put positional parameters (those without names) after arguments\n which have names. Like positional parameters, it is illegal to provided named\n@@ -84,9 +84,9 @@ and if all references to one argument do not provide a type, then the format `?`\n is used (the type's rust-representation is printed). For example, this is an\n invalid format string:\n \n-~~~\n+ ```\n {0:d} {0:s}\n-~~~\n+ ```\n \n Because the first argument is both referred to as an integer as well as a\n string.\n@@ -100,9 +100,9 @@ must have the type `uint`. Although a `uint` can be printed with `{:u}`, it is\n illegal to reference an argument as such. For example, this is another invalid\n format string:\n \n-~~~\n+ ```\n {:.*s} {0:u}\n-~~~\n+ ```\n \n ### Formatting traits\n \n@@ -134,9 +134,9 @@ is `?` which is defined for all types by default.\n When implementing a format trait for your own time, you will have to implement a\n method of the signature:\n \n-~~~{.rust}\n+```rust\n fn fmt(value: &T, f: &mut std::fmt::Formatter);\n-~~~\n+ ```\n \n Your type will be passed by-reference in `value`, and then the function should\n emit output into the `f.buf` stream. It is up to each format trait\n@@ -150,14 +150,14 @@ helper methods.\n There are a number of related macros in the `format!` family. The ones that are\n currently implemented are:\n \n-~~~{.rust}\n+```rust\n format!      // described above\n write!       // first argument is a &mut rt::io::Writer, the destination\n writeln!     // same as write but appends a newline\n print!       // the format string is printed to the standard output\n println!     // same as print but appends a newline\n format_args! // described below.\n-~~~\n+ ```\n \n \n #### `write!`\n@@ -167,23 +167,23 @@ specified stream. This is used to prevent intermediate allocations of format\n strings and instead directly write the output. Under the hood, this function is\n actually invoking the `write` function defined in this module. Example usage is:\n \n-~~~{.rust}\n+```rust\n use std::rt::io;\n \n let mut w = io::mem::MemWriter::new();\n write!(&mut w as &mut io::Writer, \"Hello {}!\", \"world\");\n-~~~\n+ ```\n \n #### `print!`\n \n This and `println` emit their output to stdout. Similarly to the `write!` macro,\n the goal of these macros is to avoid intermediate allocations when printing\n output. Example usage is:\n \n-~~~{.rust}\n+```rust\n print!(\"Hello {}!\", \"world\");\n println!(\"I have a newline {}\", \"character at the end\");\n-~~~\n+ ```\n \n #### `format_args!`\n This is a curious macro which is used to safely pass around\n@@ -193,13 +193,13 @@ references information on the stack. Under the hood, all of\n the related macros are implemented in terms of this. First\n off, some example usage is:\n \n-~~~{.rust}\n+```rust\n use std::fmt;\n \n format_args!(fmt::format, \"this returns {}\", \"~str\");\n format_args!(|args| { fmt::write(my_writer, args) }, \"some {}\", \"args\");\n format_args!(my_fn, \"format {}\", \"string\");\n-~~~\n+ ```\n \n The first argument of the `format_args!` macro is a function (or closure) which\n takes one argument of type `&fmt::Arguments`. This structure can then be\n@@ -236,9 +236,9 @@ Furthermore, whenever a case is running, the special character `#` can be used\n to reference the string value of the argument which was selected upon. As an\n example:\n \n-~~~{.rust}\n+```rust\n format!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n-~~~\n+ ```\n \n This example is the equivalent of `{0:s}` essentially.\n \n@@ -247,9 +247,9 @@ This example is the equivalent of `{0:s}` essentially.\n The select method is a switch over a `&str` parameter, and the parameter *must*\n be of the type `&str`. An example of the syntax is:\n \n-~~~\n+ ```\n {0, select, male{...} female{...} other{...}}\n-~~~\n+ ```\n \n Breaking this down, the `0`-th argument is selected upon with the `select`\n method, and then a number of cases follow. Each case is preceded by an\n@@ -266,9 +266,9 @@ The plural method is a switch statement over a `uint` parameter, and the\n parameter *must* be a `uint`. A plural method in its full glory can be specified\n as:\n \n-~~~\n+ ```\n {0, plural, offset=1 =1{...} two{...} many{...} other{...}}\n-~~~\n+ ```\n \n To break this down, the first `0` indicates that this method is selecting over\n the value of the first positional parameter to the format string. Next, the\n@@ -294,7 +294,7 @@ should not be too alien. Arguments are formatted with python-like syntax,\n meaning that arguments are surrounded by `{}` instead of the C-like `%`. The\n actual grammar for the formatting syntax is:\n \n-~~~\n+ ```\n format_string := <text> [ format <text> ] *\n format := '{' [ argument ] [ ':' format_spec ] [ ',' function_spec ] '}'\n argument := integer | identifier\n@@ -315,7 +315,7 @@ plural := 'plural' ',' [ 'offset:' integer ] ( selector arm ) *\n selector := '=' integer | keyword\n keyword := 'zero' | 'one' | 'two' | 'few' | 'many' | 'other'\n arm := '{' format_string '}'\n-~~~\n+ ```\n \n ## Formatting Parameters\n \n@@ -516,11 +516,11 @@ pub trait Float { fn fmt(&Self, &mut Formatter); }\n ///\n /// # Example\n ///\n-/// ~~~{.rust}\n+/// ```rust\n /// use std::fmt;\n /// let w: &mut io::Writer = ...;\n /// format_args!(|args| { fmt::write(w, args) }, \"Hello, {}!\", \"world\");\n-/// ~~~\n+/// ```\n pub fn write(output: &mut io::Writer, args: &Arguments) {\n     unsafe { write_unsafe(output, args.fmt, args.args) }\n }\n@@ -581,11 +581,11 @@ pub unsafe fn write_unsafe(output: &mut io::Writer,\n ///\n /// # Example\n ///\n-/// ~~~{.rust}\n+/// ```rust\n /// use std::fmt;\n /// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n /// assert_eq!(s, \"Hello, world!\");\n-/// ~~~\n+/// ```\n pub fn format(args: &Arguments) -> ~str {\n     unsafe { format_unsafe(args.fmt, args.args) }\n }"}, {"sha": "859cf20fa4184f95f2179417b0d3b7fc14fe4ffc", "filename": "src/libstd/io.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -1047,11 +1047,11 @@ pub fn FILE_reader(f: *libc::FILE, cleanup: bool) -> @Reader {\n *\n * # Example\n *\n-* ~~~ {.rust}\n+* ```rust\n * let stdin = std::io::stdin();\n * let line = stdin.read_line();\n * std::io::print(line);\n-* ~~~\n+* ```\n */\n pub fn stdin() -> @Reader {\n     #[fixed_stack_segment]; #[inline(never)];\n@@ -1650,10 +1650,10 @@ pub fn buffered_file_writer(path: &Path) -> Result<@Writer, ~str> {\n *\n * # Example\n *\n-* ~~~ {.rust}\n+* ```rust\n * let stdout = std::io::stdout();\n * stdout.write_str(\"hello\\n\");\n-* ~~~\n+* ```\n */\n pub fn stdout() -> @Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n \n@@ -1662,10 +1662,10 @@ pub fn stdout() -> @Writer { fd_writer(libc::STDOUT_FILENO as c_int, false) }\n *\n * # Example\n *\n-* ~~~ {.rust}\n+* ```rust\n * let stderr = std::io::stderr();\n * stderr.write_str(\"hello\\n\");\n-* ~~~\n+* ```\n */\n pub fn stderr() -> @Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n \n@@ -1677,10 +1677,10 @@ pub fn stderr() -> @Writer { fd_writer(libc::STDERR_FILENO as c_int, false) }\n *\n * # Example\n *\n-* ~~~ {.rust}\n+* ```rust\n * // print is imported into the prelude, and so is always available.\n * print(\"hello\");\n-* ~~~\n+* ```\n */\n pub fn print(s: &str) {\n     stdout().write_str(s);\n@@ -1693,10 +1693,10 @@ pub fn print(s: &str) {\n *\n * # Example\n *\n-* ~~~ {.rust}\n+* ```rust\n * // println is imported into the prelude, and so is always available.\n * println(\"hello\");\n-* ~~~\n+* ```\n */\n pub fn println(s: &str) {\n     stdout().write_line(s);"}, {"sha": "0e4cb895249a2430a631144ca4c0c5074c7e3b04", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -34,7 +34,7 @@ trait defined in this module. For loops can be viewed as a syntactical expansion\n into a `loop`, for example, the `for` loop in this example is essentially\n translated to the `loop` below.\n \n-~~~{.rust}\n+```rust\n let values = ~[1, 2, 3];\n \n // \"Syntactical sugar\" taking advantage of an iterator\n@@ -52,7 +52,7 @@ loop {\n         None => { break }\n     }\n }\n-~~~\n+ ```\n \n This `for` loop syntax can be applied to any iterator over any type.\n \n@@ -111,14 +111,14 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [0];\n     /// let b = [1];\n     /// let mut it = a.iter().chain(b.iter());\n     /// assert_eq!(it.next().get(), &0);\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn chain<U: Iterator<A>>(self, other: U) -> Chain<Self, U> {\n         Chain{a: self, b: other, flag: false}\n@@ -131,13 +131,13 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [0];\n     /// let b = [1];\n     /// let mut it = a.iter().zip(b.iter());\n     /// assert_eq!(it.next().get(), (&0, &1));\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> {\n         Zip{a: self, b: other}\n@@ -148,13 +148,13 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2];\n     /// let mut it = a.iter().map(|&x| 2 * x);\n     /// assert_eq!(it.next().get(), 2);\n     /// assert_eq!(it.next().get(), 4);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn map<'r, B>(self, f: &'r fn(A) -> B) -> Map<'r, A, B, Self> {\n         Map{iter: self, f: f}\n@@ -166,12 +166,12 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2];\n     /// let mut it = a.iter().filter(|&x| *x > 1);\n     /// assert_eq!(it.next().get(), &2);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> Filter<'r, A, Self> {\n         Filter{iter: self, predicate: predicate}\n@@ -183,12 +183,12 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2];\n     /// let mut it = a.iter().filter_map(|&x| if x > 1 {Some(2 * x)} else {None});\n     /// assert_eq!(it.next().get(), 4);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn filter_map<'r, B>(self, f: &'r fn(A) -> Option<B>) -> FilterMap<'r, A, B, Self> {\n         FilterMap { iter: self, f: f }\n@@ -199,13 +199,13 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [100, 200];\n     /// let mut it = a.iter().enumerate();\n     /// assert_eq!(it.next().get(), (0, &100));\n     /// assert_eq!(it.next().get(), (1, &200));\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn enumerate(self) -> Enumerate<Self> {\n         Enumerate{iter: self, count: 0}\n@@ -217,7 +217,7 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [100, 200, 300];\n     /// let mut it = xs.iter().map(|&x|x).peekable();\n     /// assert_eq!(it.peek().unwrap(), &100);\n@@ -228,7 +228,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(it.next().unwrap(), 300);\n     /// assert!(it.peek().is_none());\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn peekable(self) -> Peekable<A, Self> {\n         Peekable{iter: self, peeked: None}\n@@ -240,14 +240,14 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 2, 1];\n     /// let mut it = a.iter().skip_while(|&a| *a < 3);\n     /// assert_eq!(it.next().get(), &3);\n     /// assert_eq!(it.next().get(), &2);\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhile<'r, A, Self> {\n         SkipWhile{iter: self, flag: false, predicate: predicate}\n@@ -259,13 +259,13 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 2, 1];\n     /// let mut it = a.iter().take_while(|&a| *a < 3);\n     /// assert_eq!(it.next().get(), &1);\n     /// assert_eq!(it.next().get(), &2);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhile<'r, A, Self> {\n         TakeWhile{iter: self, flag: false, predicate: predicate}\n@@ -276,13 +276,13 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().skip(3);\n     /// assert_eq!(it.next().get(), &4);\n     /// assert_eq!(it.next().get(), &5);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn skip(self, n: uint) -> Skip<Self> {\n         Skip{iter: self, n: n}\n@@ -293,14 +293,14 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().take(3);\n     /// assert_eq!(it.next().get(), &1);\n     /// assert_eq!(it.next().get(), &2);\n     /// assert_eq!(it.next().get(), &3);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn take(self, n: uint) -> Take<Self> {\n         Take{iter: self, n: n}\n@@ -313,7 +313,7 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().scan(1, |fac, &x| {\n     ///   *fac = *fac * x;\n@@ -325,7 +325,7 @@ pub trait Iterator<A> {\n     /// assert_eq!(it.next().get(), 24);\n     /// assert_eq!(it.next().get(), 120);\n     /// assert!(it.next().is_none());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n         -> Scan<'r, A, B, Self, St> {\n@@ -337,7 +337,7 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let xs = [2u, 3];\n     /// let ys = [0u, 1, 0, 1, 2];\n     /// let mut it = xs.iter().flat_map(|&x| count(0u, 1).take(x));\n@@ -347,7 +347,7 @@ pub trait Iterator<A> {\n     ///     assert_eq!(x, ys[i]);\n     ///     i += 1;\n     /// }\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn flat_map<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n         -> FlatMap<'r, A, Self, U> {\n@@ -360,7 +360,7 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// fn process<U: Iterator<int>>(it: U) -> int {\n     ///     let mut it = it.fuse();\n     ///     let mut sum = 0;\n@@ -378,7 +378,7 @@ pub trait Iterator<A> {\n     /// }\n     /// let x = ~[1,2,3,7,8,9];\n     /// assert_eq!(process(x.move_iter()), 1006);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn fuse(self) -> Fuse<Self> {\n         Fuse{iter: self, done: false}\n@@ -390,7 +390,7 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     ///let xs = [1u, 4, 2, 3, 8, 9, 6];\n     ///let sum = xs.iter()\n     ///            .map(|&x| x)\n@@ -399,7 +399,7 @@ pub trait Iterator<A> {\n     ///            .inspect(|&x| debug!(\"%u made it through\", x))\n     ///            .sum();\n     ///println(sum.to_str());\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn inspect<'r>(self, f: &'r fn(&A)) -> Inspect<'r, A, Self> {\n         Inspect{iter: self, f: f}\n@@ -409,13 +409,13 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::iter::count;\n     ///\n     /// for i in count(0, 10) {\n     ///     printfln!(\"%d\", i);\n     /// }\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n         loop {\n@@ -433,11 +433,11 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let b: ~[int] = a.iter().map(|&x| x).collect();\n     /// assert!(a == b);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn collect<B: FromIterator<A>>(&mut self) -> B {\n         FromIterator::from_iterator(self)\n@@ -448,11 +448,11 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let b: ~[int] = a.iter().map(|&x| x).to_owned_vec();\n     /// assert!(a == b);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn to_owned_vec(&mut self) -> ~[A] {\n         self.collect()\n@@ -463,12 +463,12 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.nth(2).get() == &3);\n     /// assert!(it.nth(2) == None);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn nth(&mut self, mut n: uint) -> Option<A> {\n         loop {\n@@ -485,10 +485,10 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().last().get() == &5);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn last(&mut self) -> Option<A> {\n         let mut last = None;\n@@ -501,10 +501,10 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn fold<B>(&mut self, init: B, f: &fn(B, A) -> B) -> B {\n         let mut accum = init;\n@@ -521,12 +521,12 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.len() == 5);\n     /// assert!(it.len() == 0);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn len(&mut self) -> uint {\n         self.fold(0, |cnt, _x| cnt + 1)\n@@ -536,11 +536,11 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().all(|&x| *x > 0));\n     /// assert!(!a.iter().all(|&x| *x > 2));\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn all(&mut self, f: &fn(A) -> bool) -> bool {\n         for x in *self { if !f(x) { return false; } }\n@@ -552,12 +552,12 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n     /// assert!(it.any(|&x| *x == 3));\n     /// assert!(!it.any(|&x| *x == 3));\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn any(&mut self, f: &fn(A) -> bool) -> bool {\n         for x in *self { if f(x) { return true; } }\n@@ -601,10 +601,10 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let xs = [-3, 0, 1, 5, -10];\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn max_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n         self.fold(None, |max: Option<(A, B)>, x| {\n@@ -625,10 +625,10 @@ pub trait Iterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let xs = [-3, 0, 1, 5, -10];\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn min_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n         self.fold(None, |min: Option<(A, B)>, x| {\n@@ -777,11 +777,11 @@ pub trait AdditiveIterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().map(|&x| x);\n     /// assert!(it.sum() == 15);\n-    /// ~~~\n+    /// ```\n     fn sum(&mut self) -> A;\n }\n \n@@ -800,7 +800,7 @@ pub trait MultiplicativeIterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::iter::count;\n     ///\n     /// fn factorial(n: uint) -> uint {\n@@ -809,7 +809,7 @@ pub trait MultiplicativeIterator<A> {\n     /// assert!(factorial(0) == 1);\n     /// assert!(factorial(1) == 1);\n     /// assert!(factorial(5) == 120);\n-    /// ~~~\n+    /// ```\n     fn product(&mut self) -> A;\n }\n \n@@ -828,20 +828,20 @@ pub trait OrdIterator<A> {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().max().get() == &5);\n-    /// ~~~\n+    /// ```\n     fn max(&mut self) -> Option<A>;\n \n     /// Consumes the entire iterator to return the minimum element.\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().min().get() == &1);\n-    /// ~~~\n+    /// ```\n     fn min(&mut self) -> Option<A>;\n }\n \n@@ -873,12 +873,12 @@ pub trait ClonableIterator {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let a = count(1,1).take(1);\n     /// let mut cy = a.cycle();\n     /// assert_eq!(cy.next(), Some(1));\n     /// assert_eq!(cy.next(), Some(1));\n-    /// ~~~\n+    /// ```\n     fn cycle(self) -> Cycle<Self>;\n }\n "}, {"sha": "5058821d4568cec5bc8d7fc785291a75741af09e", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -22,7 +22,7 @@ To declare a new key for storing local data of a particular type, use the\n named and annotated. This name is then passed to the functions in this module to\n modify/read the slot specified by the key.\n \n-~~~{.rust}\n+```rust\n use std::local_data;\n \n local_data_key!(key_int: int)\n@@ -33,7 +33,7 @@ local_data::get(key_int, |opt| assert_eq!(opt, Some(&3)));\n \n local_data::set(key_vector, ~[4]);\n local_data::get(key_vector, |opt| assert_eq!(opt, Some(&~[4])));\n-~~~\n+ ```\n \n */\n "}, {"sha": "afa1acd08970ae3eedee9f0ad6b6e4adf1b8be79", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -346,9 +346,9 @@ impl Round for f32 {\n     ///\n     /// The fractional part of the number, satisfying:\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// assert!(x == trunc(x) + fract(x))\n-    /// ~~~\n+    /// ```\n     ///\n     #[inline]\n     fn fract(&self) -> f32 { *self - self.trunc() }"}, {"sha": "5dbeb6c298f8f97fd42b5ffe1119bba3282f42d1", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -364,9 +364,9 @@ impl Round for f64 {\n     ///\n     /// The fractional part of the number, satisfying:\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// assert!(x == trunc(x) + fract(x))\n-    /// ~~~\n+    /// ```\n     ///\n     #[inline]\n     fn fract(&self) -> f64 { *self - self.trunc() }"}, {"sha": "7af47355c8c44b00b69db64b8982811a11d9fca5", "filename": "src/libstd/num/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ffloat.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -414,9 +414,9 @@ impl Round for float {\n     ///\n     /// The fractional part of the number, satisfying:\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// assert!(x == trunc(x) + fract(x))\n-    /// ~~~\n+    /// ```\n     ///\n     #[inline]\n     fn fract(&self) -> float { *self - self.trunc() }"}, {"sha": "1070e8e592f0eaeb8990eb037aee58e4979bf0d9", "filename": "src/libstd/num/int_macros.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint_macros.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -118,7 +118,7 @@ impl Div<$T,$T> for $T {\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// assert!( 8 /  3 ==  2);\n     /// assert!( 8 / -3 == -2);\n     /// assert!(-8 /  3 == -2);\n@@ -128,7 +128,7 @@ impl Div<$T,$T> for $T {\n     /// assert!( 1 / -2 ==  0);\n     /// assert!(-1 /  2 ==  0);\n     /// assert!(-1 / -2 ==  0);\n-    /// ~~~\n+    /// ```\n     ///\n     #[inline]\n     fn div(&self, other: &$T) -> $T { *self / *other }\n@@ -139,13 +139,13 @@ impl Rem<$T,$T> for $T {\n     ///\n     /// Returns the integer remainder after division, satisfying:\n     ///\n-    /// ~~~\n+    /// ```\n     /// assert!((n / d) * d + (n % d) == n)\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// assert!( 8 %  3 ==  2);\n     /// assert!( 8 % -3 ==  2);\n     /// assert!(-8 %  3 == -2);\n@@ -155,7 +155,7 @@ impl Rem<$T,$T> for $T {\n     /// assert!( 1 % -2 ==  1);\n     /// assert!(-1 %  2 == -1);\n     /// assert!(-1 % -2 == -1);\n-    /// ~~~\n+    /// ```\n     ///\n     #[inline]\n     fn rem(&self, other: &$T) -> $T { *self % *other }\n@@ -214,7 +214,7 @@ impl Integer for $T {\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// assert!(( 8).div_floor( 3) ==  2);\n     /// assert!(( 8).div_floor(-3) == -3);\n     /// assert!((-8).div_floor( 3) == -3);\n@@ -224,7 +224,7 @@ impl Integer for $T {\n     /// assert!(( 1).div_floor(-2) == -1);\n     /// assert!((-1).div_floor( 2) == -1);\n     /// assert!((-1).div_floor(-2) ==  0);\n-    /// ~~~\n+    /// ```\n     ///\n     #[inline]\n     fn div_floor(&self, other: &$T) -> $T {\n@@ -240,13 +240,13 @@ impl Integer for $T {\n     ///\n     /// Integer modulo, satisfying:\n     ///\n-    /// ~~~\n+    /// ```\n     /// assert!(n.div_floor(d) * d + n.mod_floor(d) == n)\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Examples\n     ///\n-    /// ~~~\n+    /// ```\n     /// assert!(( 8).mod_floor( 3) ==  2);\n     /// assert!(( 8).mod_floor(-3) == -1);\n     /// assert!((-8).mod_floor( 3) ==  1);\n@@ -256,7 +256,7 @@ impl Integer for $T {\n     /// assert!(( 1).mod_floor(-2) == -1);\n     /// assert!((-1).mod_floor( 2) ==  1);\n     /// assert!((-1).mod_floor(-2) == -1);\n-    /// ~~~\n+    /// ```\n     ///\n     #[inline]\n     fn mod_floor(&self, other: &$T) -> $T {"}, {"sha": "a60bf2f33a99d9e2aa458ec230e0ca75bf578e94", "filename": "src/libstd/num/num.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fnum.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -82,12 +82,12 @@ pub trait Unsigned: Num {}\n \n /// Times trait\n ///\n-/// ~~~ {.rust}\n+/// ```rust\n /// use num::Times;\n /// let ten = 10 as uint;\n /// let mut accum = 0;\n /// do ten.times { accum += 1; }\n-/// ~~~\n+/// ```\n ///\n pub trait Times {\n     fn times(&self, it: &fn());\n@@ -357,10 +357,10 @@ pub trait Float: Real\n ///\n /// # Example\n ///\n-/// ~~~\n+/// ```\n /// let twenty: f32 = num::cast(0x14);\n /// assert_eq!(twenty, 20f32);\n-/// ~~~\n+/// ```\n ///\n #[inline]\n pub fn cast<T:NumCast,U:NumCast>(n: T) -> U {"}, {"sha": "a8d4cf541ceebcded311c9c332f94592ff6353ff", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -23,7 +23,7 @@ of a value and take action, always accounting for the `None` case.\n \n # Example\n \n-~~~\n+ ```\n let msg = Some(~\"howdy\");\n \n // Take a reference to the contained string\n@@ -37,7 +37,7 @@ let unwrapped_msg = match msg {\n     Some(m) => m,\n     None => ~\"default message\"\n };\n-~~~\n+ ```\n \n */\n "}, {"sha": "1cdf4d6da95101b1869d68fdf9e02c553ca1d8ca", "filename": "src/libstd/rand/distributions.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frand%2Fdistributions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frand%2Fdistributions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -65,14 +65,14 @@ fn ziggurat<R:Rng>(rng: &mut R,\n ///\n /// # Example\n ///\n-/// ~~~\n+/// ```\n /// use std::rand::distributions::StandardNormal;\n ///\n /// fn main() {\n ///     let normal = 2.0 + (*rand::random::<StandardNormal>()) * 3.0;\n ///     printfln!(\"%f is from a N(2, 9) distribution\", normal)\n /// }\n-/// ~~~\n+/// ```\n pub struct StandardNormal(f64);\n \n impl Rand for StandardNormal {\n@@ -119,14 +119,14 @@ impl Rand for StandardNormal {\n ///\n /// # Example\n ///\n-/// ~~~\n+/// ```\n /// use std::rand::distributions::Exp1;\n ///\n /// fn main() {\n ///     let exp2 = (*rand::random::<Exp1>()) * 0.5;\n ///     printfln!(\"%f is from a Exp(2) distribution\", exp2);\n /// }\n-/// ~~~\n+/// ```\n pub struct Exp1(f64);\n \n // This could be done via `-rng.gen::<f64>().ln()` but that is slower."}, {"sha": "832978a0f1064dbe95b5357528438dbeea095f55", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -21,7 +21,7 @@ distributions like normal and exponential.\n \n # Examples\n \n-~~~ {.rust}\n+```rust\n use std::rand;\n use std::rand::Rng;\n \n@@ -31,16 +31,16 @@ fn main() {\n         printfln!(\"int: %d, uint: %u\", rng.gen(), rng.gen())\n     }\n }\n-~~~\n+ ```\n \n-~~~ {.rust}\n+```rust\n use std::rand;\n \n fn main () {\n     let tuple_ptr = rand::random::<~(f64, char)>();\n     printfln!(tuple_ptr)\n }\n-~~~\n+ ```\n */\n \n use cast;\n@@ -264,7 +264,7 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     ///\n     /// fn main() {\n@@ -273,7 +273,7 @@ pub trait Rng {\n     ///    printfln!(x);\n     ///    printfln!(rng.gen::<(float, bool)>());\n     /// }\n-    /// ~~~\n+    /// ```\n     #[inline(always)]\n     fn gen<T: Rand>(&mut self) -> T {\n         Rand::rand(self)\n@@ -283,7 +283,7 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     ///\n     /// fn main() {\n@@ -292,7 +292,7 @@ pub trait Rng {\n     ///    printfln!(x);\n     ///    printfln!(rng.gen_vec::<(float, bool)>(5));\n     /// }\n-    /// ~~~\n+    /// ```\n     fn gen_vec<T: Rand>(&mut self, len: uint) -> ~[T] {\n         vec::from_fn(len, |_| self.gen())\n     }\n@@ -308,7 +308,7 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     ///\n     /// fn main() {\n@@ -318,7 +318,7 @@ pub trait Rng {\n     ///    let m: i16 = rng.gen_integer_range(-40, 400);\n     ///    printfln!(m);\n     /// }\n-    /// ~~~\n+    /// ```\n     fn gen_integer_range<T: Rand + Int>(&mut self, low: T, high: T) -> T {\n         assert!(low < high, \"RNG.gen_integer_range called with low >= high\");\n         let range = (high - low).to_u64();\n@@ -335,15 +335,15 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     /// use std::rand::Rng;\n     ///\n     /// fn main() {\n     ///     let mut rng = rand::rng();\n     ///     printfln!(\"%b\", rng.gen_weighted_bool(3));\n     /// }\n-    /// ~~~\n+    /// ```\n     fn gen_weighted_bool(&mut self, n: uint) -> bool {\n         n == 0 || self.gen_integer_range(0, n) == 0\n     }\n@@ -353,13 +353,13 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     ///\n     /// fn main() {\n     ///    println(rand::task_rng().gen_ascii_str(10));\n     /// }\n-    /// ~~~\n+    /// ```\n     fn gen_ascii_str(&mut self, len: uint) -> ~str {\n         static GEN_ASCII_STR_CHARSET: &'static [u8] = bytes!(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\\n                                                              abcdefghijklmnopqrstuvwxyz\\\n@@ -381,14 +381,14 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     ///\n     /// fn main() {\n     ///     printfln!(rand::task_rng().choose_option([1,2,4,8,16,32]));\n     ///     printfln!(rand::task_rng().choose_option([]));\n     /// }\n-    /// ~~~\n+    /// ```\n     fn choose_option<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {\n             None\n@@ -402,7 +402,7 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     /// use std::rand::Rng;\n     ///\n@@ -413,7 +413,7 @@ pub trait Rng {\n     ///              rand::Weighted {weight: 2, item: 'c'}];\n     ///     printfln!(\"%c\", rng.choose_weighted(x));\n     /// }\n-    /// ~~~\n+    /// ```\n     fn choose_weighted<T:Clone>(&mut self, v: &[Weighted<T>]) -> T {\n         self.choose_weighted_option(v).expect(\"Rng.choose_weighted: total weight is 0\")\n     }\n@@ -423,7 +423,7 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     /// use std::rand::Rng;\n     ///\n@@ -434,7 +434,7 @@ pub trait Rng {\n     ///              rand::Weighted {weight: 2, item: 'c'}];\n     ///     printfln!(rng.choose_weighted_option(x));\n     /// }\n-    /// ~~~\n+    /// ```\n     fn choose_weighted_option<T:Clone>(&mut self, v: &[Weighted<T>])\n                                        -> Option<T> {\n         let mut total = 0u;\n@@ -460,7 +460,7 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     /// use std::rand::Rng;\n     ///\n@@ -471,7 +471,7 @@ pub trait Rng {\n     ///              rand::Weighted {weight: 2, item: 'c'}];\n     ///     printfln!(rng.weighted_vec(x));\n     /// }\n-    /// ~~~\n+    /// ```\n     fn weighted_vec<T:Clone>(&mut self, v: &[Weighted<T>]) -> ~[T] {\n         let mut r = ~[];\n         for item in v.iter() {\n@@ -486,13 +486,13 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     ///\n     /// fn main() {\n     ///     printfln!(rand::task_rng().shuffle(~[1,2,3]));\n     /// }\n-    /// ~~~\n+    /// ```\n     fn shuffle<T>(&mut self, values: ~[T]) -> ~[T] {\n         let mut v = values;\n         self.shuffle_mut(v);\n@@ -503,7 +503,7 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     ///\n     /// fn main() {\n@@ -514,7 +514,7 @@ pub trait Rng {\n     ///    rng.shuffle_mut(y);\n     ///    printfln!(y);\n     /// }\n-    /// ~~~\n+    /// ```\n     fn shuffle_mut<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n         while i >= 2u {\n@@ -529,15 +529,15 @@ pub trait Rng {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// use std::rand;\n     ///\n     /// fn main() {\n     ///    let rng = rand::task_rng();\n     ///    let sample = rng.sample(range(1, 100), 5);\n     ///    printfln!(sample);\n     /// }\n-    /// ~~~\n+    /// ```\n     fn sample<A, T: Iterator<A>>(&mut self, iter: T, n: uint) -> ~[A] {\n         let mut reservoir : ~[A] = vec::with_capacity(n);\n         for (i, elem) in iter.enumerate() {"}, {"sha": "3e801f28991764715aee148334ac10a57cf66486", "filename": "src/libstd/rt/io/buffered.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fbuffered.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -17,7 +17,7 @@\n //!\n //! # Examples\n //!\n-//! ~~~\n+//! ```\n //! let tcp_stream = TcpStream::connect(addr);\n //! let reader = BufferedReader::new(tcp_stream);\n //!\n@@ -26,17 +26,17 @@\n //!     Some(nread) => println!(\"Read {} bytes\", nread),\n //!     None => println!(\"At the end of the stream!\")\n //! }\n-//! ~~~\n+//! ```\n //!\n-//! ~~~\n+//! ```\n //! let tcp_stream = TcpStream::connect(addr);\n //! let writer = BufferedWriter::new(tcp_stream);\n //!\n //! writer.write(\"hello, world\".as_bytes());\n //! writer.flush();\n-//! ~~~\n+//! ```\n //!\n-//! ~~~\n+//! ```\n //! let tcp_stream = TcpStream::connect(addr);\n //! let stream = BufferedStream::new(tcp_stream);\n //!\n@@ -48,7 +48,7 @@\n //!     Some(nread) => println!(\"Read {} bytes\", nread),\n //!     None => println!(\"At the end of the stream!\")\n //! }\n-//! ~~~\n+//! ```\n //!\n \n use prelude::*;"}, {"sha": "b11ee014af9fcc6d59c4d114db4177b42957cbfc", "filename": "src/libstd/rt/io/file.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frt%2Fio%2Ffile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Ffile.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -477,7 +477,7 @@ pub trait FileSystemInfo {\n ///\n /// * Check if a file exists, reading from it if so\n ///\n-/// ~~~{.rust}\n+/// ```rust\n /// use std;\n /// use std::path::Path;\n /// use std::rt::io::file::{FileInfo, FileReader};\n@@ -489,17 +489,17 @@ pub trait FileSystemInfo {\n ///     reader.read(mem);\n ///     // ...\n /// }\n-/// ~~~\n+/// ```\n ///\n /// * Is the given path a file?\n ///\n-/// ~~~{.rust}\n+/// ```rust\n /// let f = get_file_path_from_wherever();\n /// match f.is_file() {\n ///    true => doing_something_with_a_file(f),\n ///    _ => {}\n /// }\n-/// ~~~\n+/// ```\n pub trait FileInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) points at a \"regular file\" on the FS. Will return\n@@ -574,7 +574,7 @@ impl FileInfo for Path { }\n ///\n /// * Check if a directory exists, `mkdir`'ing it if not\n ///\n-/// ~~~{.rust}\n+/// ```rust\n /// use std;\n /// use std::path::Path;\n /// use std::rt::io::file::{DirectoryInfo};\n@@ -583,11 +583,11 @@ impl FileInfo for Path { }\n /// if !dir.exists() {\n ///     dir.mkdir();\n /// }\n-/// ~~~\n+/// ```\n ///\n /// * Is the given path a directory? If so, iterate on its contents\n ///\n-/// ~~~{.rust}\n+/// ```rust\n /// fn visit_dirs(dir: &Path, cb: &fn(&Path)) {\n ///     if dir.is_dir() {\n ///         let contents = dir.readdir();\n@@ -598,7 +598,7 @@ impl FileInfo for Path { }\n ///     }\n ///     else { fail!(\"nope\"); }\n /// }\n-/// ~~~\n+/// ```\n trait DirectoryInfo : FileSystemInfo {\n     /// Whether the underlying implemention (be it a file path,\n     /// or something else) is pointing at a directory in the underlying FS.\n@@ -971,4 +971,4 @@ mod test {\n             dir.rmdir();\n         }\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c46e1372c6414653190507e476ebcaa8cf5781a0", "filename": "src/libstd/rt/io/mock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frt%2Fio%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fio%2Fmock.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -47,4 +47,4 @@ impl MockWriter {\n impl Writer for MockWriter {\n     fn write(&mut self, buf: &[u8]) { (self.write)(buf) }\n     fn flush(&mut self) { (self.flush)() }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "6563ac2e96f9e0f13962610c222b9f46225e512b", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -71,14 +71,14 @@ before reporting whether it succeeded or failed. A watching parent will only\n report success if it succeeded and all its children also reported success;\n otherwise, it will report failure. This is most useful for writing test cases:\n \n-~~~\n+ ```\n #[test]\n fn test_something_in_another_task {\n     do spawn {\n         assert!(collatz_conjecture_is_false());\n     }\n }\n-~~~\n+ ```\n \n Here, as the child task will certainly outlive the parent task, we might miss\n the failure of the child when deciding whether or not the test case passed."}, {"sha": "46d655e6379f7840132d9cd3bb15d5af13208104", "filename": "src/libstd/std.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fstd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fstd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -58,8 +58,7 @@ they contained the following prologue:\n #[crate_type = \"lib\"];\n \n #[doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk.png\",\n-      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n-      passes = \"strip-hidden\")];\n+      html_favicon_url = \"http://www.rust-lang.org/favicon.ico\")];\n \n // Don't link to std. We are std.\n #[no_std];"}, {"sha": "8dc6f783fbea76235d5daf1249c0bfcfd0793bac", "filename": "src/libstd/str.rs", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -37,13 +37,13 @@ there are three common kinds of strings in rust:\n \n As an example, here's a few different kinds of strings.\n \n-~~~{.rust}\n+```rust\n let owned_string = ~\"I am an owned string\";\n let managed_string = @\"This string is garbage-collected\";\n let borrowed_string1 = \"This string is borrowed with the 'static lifetime\";\n let borrowed_string2: &str = owned_string;   // owned strings can be borrowed\n let borrowed_string3: &str = managed_string; // managed strings can also be borrowed\n-~~~\n+ ```\n \n From the example above, you can see that rust has 3 different kinds of string\n literals. The owned/managed literals correspond to the owned/managed string\n@@ -67,12 +67,12 @@ to that string. With these guarantees, strings can easily transition between\n being mutable/immutable with the same benefits of having mutable strings in\n other languages.\n \n-~~~{.rust}\n+```rust\n let mut buf = ~\"testing\";\n buf.push_char(' ');\n buf.push_str(\"123\");\n assert_eq!(buf, ~\"testing 123\");\n-~~~\n+ ```\n \n # Representation\n \n@@ -1513,10 +1513,10 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let v: ~[char] = \"abc \u00e5\u00e4\u00f6\".iter().collect();\n     /// assert_eq!(v, ~['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn iter(&self) -> CharIterator<'self> {\n         CharIterator{string: *self}\n@@ -1558,13 +1558,13 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let v: ~[&str] = \"Mary had a little lamb\".split_iter(' ').collect();\n     /// assert_eq!(v, ~[\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n     /// let v: ~[&str] = \"abc1def2ghi\".split_iter(|c: char| c.is_digit()).collect();\n     /// assert_eq!(v, ~[\"abc\", \"def\", \"ghi\"]);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn split_iter<Sep: CharEq>(&self, sep: Sep) -> CharSplitIterator<'self, Sep> {\n         CharSplitIterator {\n@@ -1597,10 +1597,10 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let v: ~[&str] = \"A.B.\".split_terminator_iter('.').collect();\n     /// assert_eq!(v, ~[\"A\", \"B\"]);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn split_terminator_iter<Sep: CharEq>(&self, sep: Sep)\n         -> CharSplitIterator<'self, Sep> {\n@@ -1615,10 +1615,10 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let v: ~[&str] = \"Mary had a little lamb\".rsplit_iter(' ').collect();\n     /// assert_eq!(v, ~[\"lamb\", \"little\", \"a\", \"had\", \"Mary\"]);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn rsplit_iter<Sep: CharEq>(&self, sep: Sep) -> CharRSplitIterator<'self, Sep> {\n         self.split_iter(sep).invert()\n@@ -1655,10 +1655,10 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let v: ~[&str] = \"abcXXXabcYYYabc\".split_str_iter(\"abc\").collect()\n     /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn split_str_iter(&self, sep: &'self str) -> StrSplitIterator<'self> {\n         StrSplitIterator {\n@@ -1853,11 +1853,11 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_chars(&'1'), \"foo1bar\")\n     /// assert_eq!(\"12foo1bar12\".trim_chars(& &['1', '2']), \"foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_chars(&|c: char| c.is_digit()), \"foo1bar\")\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn trim_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n         self.trim_left_chars(to_trim).trim_right_chars(to_trim)\n@@ -1871,11 +1871,11 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_left_chars(&'1'), \"foo1bar11\")\n     /// assert_eq!(\"12foo1bar12\".trim_left_chars(& &['1', '2']), \"foo1bar12\")\n     /// assert_eq!(\"123foo1bar123\".trim_left_chars(&|c: char| c.is_digit()), \"foo1bar123\")\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn trim_left_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n         match self.find(|c: char| !to_trim.matches(c)) {\n@@ -1892,11 +1892,11 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// assert_eq!(\"11foo1bar11\".trim_right_chars(&'1'), \"11foo1bar\")\n     /// assert_eq!(\"12foo1bar12\".trim_right_chars(& &['1', '2']), \"12foo1bar\")\n     /// assert_eq!(\"123foo1bar123\".trim_right_chars(&|c: char| c.is_digit()), \"123foo1bar\")\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn trim_right_chars<C: CharEq>(&self, to_trim: &C) -> &'self str {\n         match self.rfind(|c: char| !to_trim.matches(c)) {\n@@ -2000,19 +2000,19 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n     /// let i = 0u;\n     /// while i < s.len() {\n     ///     let CharRange {ch, next} = s.char_range_at(i);\n     ///     printfln!(\"%u: %c\", i, ch);\n     ///     i = next;\n     /// }\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Example output\n     ///\n-    /// ~~~\n+    /// ```\n     /// 0: \u4e2d\n     /// 3: \u534e\n     /// 6: V\n@@ -2023,7 +2023,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     /// 13: N\n     /// 14: a\n     /// 15: m\n-    /// ~~~\n+    /// ```\n     ///\n     /// # Arguments\n     ///\n@@ -2228,15 +2228,15 @@ impl<'self> StrSlice<'self> for &'self str {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let string = \"a\\nb\\nc\";\n     /// let mut lines = ~[];\n     /// for line in string.line_iter() { lines.push(line) }\n     ///\n     /// assert!(string.subslice_offset(lines[0]) == 0); // &\"a\"\n     /// assert!(string.subslice_offset(lines[1]) == 2); // &\"b\"\n     /// assert!(string.subslice_offset(lines[2]) == 4); // &\"c\"\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn subslice_offset(&self, inner: &str) -> uint {\n         do self.as_imm_buf |a, a_len| {"}, {"sha": "1dbc644c8e5ce165b46cc05aba6d977adb49fab4", "filename": "src/libstd/task/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Ftask%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Ftask%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Fmod.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -26,11 +26,11 @@\n  *\n  * # Example\n  *\n- * ~~~\n+ * ```\n  * do spawn {\n  *     log(error, \"Hello, World!\");\n  * }\n- * ~~~\n+ * ```\n  */\n \n #[allow(missing_doc)];\n@@ -565,15 +565,15 @@ pub fn failing() -> bool {\n  *\n  * # Example\n  *\n- * ~~~\n+ * ```\n  * do task::unkillable {\n  *     // detach / deschedule / destroy must all be called together\n  *     rustrt::rust_port_detach(po);\n  *     // This must not result in the current task being killed\n  *     task::deschedule();\n  *     rustrt::rust_port_destroy(po);\n  * }\n- * ~~~\n+ * ```\n  */\n pub fn unkillable<U>(f: &fn() -> U) -> U {\n     use rt::task::Task;\n@@ -602,7 +602,7 @@ pub fn unkillable<U>(f: &fn() -> U) -> U {\n  *\n  * # Example\n  *\n- * ~~~\n+ * ```\n  * do task::unkillable {\n  *     do task::rekillable {\n  *          // Task is killable"}, {"sha": "c1365a44bc913c8d19a6cc8cffcd206e4bcb1a5e", "filename": "src/libstd/unstable/finally.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Funstable%2Ffinally.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Funstable%2Ffinally.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Ffinally.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -14,13 +14,13 @@ stack closures that emulates Java-style try/finally blocks.\n \n # Example\n \n-~~~\n+ ```\n do || {\n     ...\n }.finally {\n     always_run_this();\n }\n-~~~\n+ ```\n */\n \n use ops::Drop;"}, {"sha": "e54717053e97ba2d402dec4214bdfb8c20e52d05", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -16,10 +16,10 @@ The `vec` module contains useful code to help work with vector values.\n Vectors are Rust's list type. Vectors contain zero or more values of\n homogeneous types:\n \n-~~~ {.rust}\n+```rust\n let int_vector = [1,2,3];\n let str_vector = [\"one\", \"two\", \"three\"];\n-~~~\n+ ```\n \n This is a big module, but for a high-level overview:\n \n@@ -40,11 +40,11 @@ case.\n An example is the method `.slice(a, b)` that returns an immutable \"view\" into\n a vector or a vector slice from the index interval `[a, b)`:\n \n-~~~ {.rust}\n+```rust\n let numbers = [0, 1, 2];\n let last_numbers = numbers.slice(1, 3);\n // last_numbers is now &[1, 2]\n-~~~\n+ ```\n \n Traits defined for the `~[T]` type, like `OwnedVector`, can only be called\n on such vectors. These methods deal with adding elements or otherwise changing\n@@ -53,11 +53,11 @@ the allocation of the vector.\n An example is the method `.push(element)` that will add an element at the end\n of the vector:\n \n-~~~ {.rust}\n+```rust\n let mut numbers = ~[0, 1, 2];\n numbers.push(7);\n // numbers is now ~[0, 1, 2, 7];\n-~~~\n+ ```\n \n ## Implementations of other traits\n \n@@ -74,12 +74,12 @@ The method `iter()` returns an iteration value for a vector or a vector slice.\n The iterator yields borrowed pointers to the vector's elements, so if the element\n type of the vector is `int`, the element type of the iterator is `&int`.\n \n-~~~ {.rust}\n+```rust\n let numbers = [0, 1, 2];\n for &x in numbers.iter() {\n     println!(\"{} is a number!\", x);\n }\n-~~~\n+ ```\n \n * `.rev_iter()` returns an iterator with the same values as `.iter()`,\n   but going in the reverse order, starting with the back element.\n@@ -1000,12 +1000,12 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      * Print the adjacent pairs of a vector (i.e. `[1,2]`, `[2,3]`,\n      * `[3,4]`):\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * let v = &[1,2,3,4];\n      * for win in v.window_iter() {\n      *     printfln!(win);\n      * }\n-     * ~~~\n+     * ```\n      *\n      */\n     fn window_iter(self, size: uint) -> WindowIter<'self, T> {\n@@ -1029,12 +1029,12 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n      * Print the vector two elements at a time (i.e. `[1,2]`,\n      * `[3,4]`, `[5]`):\n      *\n-     * ~~~ {.rust}\n+     * ```rust\n      * let v = &[1,2,3,4,5];\n      * for win in v.chunk_iter() {\n      *     printfln!(win);\n      * }\n-     * ~~~\n+     * ```\n      *\n      */\n     fn chunk_iter(self, size: uint) -> ChunkIter<'self, T> {\n@@ -1279,13 +1279,13 @@ impl<T> OwnedVector<T> for ~[T] {\n     ///\n     /// # Examples\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let v = ~[~\"a\", ~\"b\"];\n     /// for s in v.move_iter() {\n     ///   // s has type ~str, not &~str\n     ///   println(s);\n     /// }\n-    /// ~~~\n+    /// ```\n     fn move_iter(self) -> MoveIterator<T> {\n         MoveIterator { v: self, idx: 0 }\n     }\n@@ -1449,11 +1449,11 @@ impl<T> OwnedVector<T> for ~[T] {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let mut a = ~[~1];\n     /// a.push_all_move(~[~2, ~3, ~4]);\n     /// assert!(a == ~[~1, ~2, ~3, ~4]);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn push_all_move(&mut self, mut rhs: ~[T]) {\n         let self_len = self.len();\n@@ -1697,11 +1697,11 @@ impl<T:Clone> OwnedCopyableVector<T> for ~[T] {\n     ///\n     /// # Example\n     ///\n-    /// ~~~ {.rust}\n+    /// ```rust\n     /// let mut a = ~[1];\n     /// a.push_all([2, 3, 4]);\n     /// assert!(a == ~[1, 2, 3, 4]);\n-    /// ~~~\n+    /// ```\n     #[inline]\n     fn push_all(&mut self, rhs: &[T]) {\n         let new_len = self.len() + rhs.len();"}, {"sha": "646b65d080b470c327c08b64d5ea67760bd24042", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -59,7 +59,7 @@ associated with. It is only not `None` when the associated field has\n an identifier in the source code. For example, the `x`s in the\n following snippet\n \n-~~~\n+ ```\n struct A { x : int }\n \n struct B(int);\n@@ -82,7 +82,7 @@ represented as a count of 0.\n \n The following simplified `Eq` is used for in-code examples:\n \n-~~~\n+ ```\n trait Eq {\n     fn eq(&self, other: &Self);\n }\n@@ -91,7 +91,7 @@ impl Eq for int {\n         *self == *other\n     }\n }\n-~~~\n+ ```\n \n Some examples of the values of `SubstructureFields` follow, using the\n above `Eq`, `A`, `B` and `C`.\n@@ -100,50 +100,50 @@ above `Eq`, `A`, `B` and `C`.\n \n When generating the `expr` for the `A` impl, the `SubstructureFields` is\n \n-~~~\n+ ```\n Struct(~[(Some(<ident of x>),\n          <expr for &self.x>,\n          ~[<expr for &other.x])])\n-~~~\n+ ```\n \n For the `B` impl, called with `B(a)` and `B(b)`,\n \n-~~~\n+ ```\n Struct(~[(None,\n           <expr for &a>\n           ~[<expr for &b>])])\n-~~~\n+ ```\n \n ## Enums\n \n When generating the `expr` for a call with `self == C0(a)` and `other\n == C0(b)`, the SubstructureFields is\n \n-~~~\n+ ```\n EnumMatching(0, <ast::variant for C0>,\n              ~[None,\n                <expr for &a>,\n                ~[<expr for &b>]])\n-~~~\n+ ```\n \n For `C1 {x}` and `C1 {x}`,\n \n-~~~\n+ ```\n EnumMatching(1, <ast::variant for C1>,\n              ~[Some(<ident of x>),\n                <expr for &self.x>,\n                ~[<expr for &other.x>]])\n-~~~\n+ ```\n \n For `C0(a)` and `C1 {x}` ,\n \n-~~~\n+ ```\n EnumNonMatching(~[(0, <ast::variant for B0>,\n                    ~[(None, <expr for &a>)]),\n                   (1, <ast::variant for B1>,\n                    ~[(Some(<ident of x>),\n                       <expr for &other.x>)])])\n-~~~\n+ ```\n \n (and vice versa, but with the order of the outermost list flipped.)\n \n@@ -158,7 +158,7 @@ StaticStruct(<ast::struct_def of B>, Left(1))\n \n StaticEnum(<ast::enum_def of C>, ~[(<ident of C0>, Left(1)),\n                                    (<ident of C1>, Right(~[<ident of x>]))])\n-~~~\n+ ```\n \n */\n \n@@ -547,7 +547,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     /**\n-    ~~~\n+    ```\n     #[deriving(Eq)]\n     struct A { x: int, y: int }\n \n@@ -565,7 +565,7 @@ impl<'self> MethodDef<'self> {\n             }\n         }\n     }\n-    ~~~\n+    ```\n     */\n     fn expand_struct_method_body(&self,\n                                  cx: @ExtCtxt,\n@@ -638,7 +638,7 @@ impl<'self> MethodDef<'self> {\n     }\n \n     /**\n-    ~~~\n+    ```\n     #[deriving(Eq)]\n     enum A {\n         A1\n@@ -661,7 +661,7 @@ impl<'self> MethodDef<'self> {\n             }\n         }\n     }\n-    ~~~\n+    ```\n     */\n     fn expand_enum_method_body(&self,\n                                cx: @ExtCtxt,\n@@ -681,13 +681,13 @@ impl<'self> MethodDef<'self> {\n     /**\n     Creates the nested matches for an enum definition recursively, i.e.\n \n-    ~~~\n+    ```\n     match self {\n        Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n        Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },\n        ...\n     }\n-    ~~~\n+    ```\n \n     It acts in the most naive way, so every branch (and subbranch,\n     subsubbranch, etc) exists, not just the ones where all the variants in\n@@ -1058,10 +1058,10 @@ pub fn cs_fold(use_foldl: bool,\n Call the method that is being derived on all the fields, and then\n process the collected results. i.e.\n \n-~~~\n+ ```\n f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n               self_2.method(__arg_1_2, __arg_2_2)])\n-~~~\n+ ```\n */\n #[inline]\n pub fn cs_same_method(f: &fn(@ExtCtxt, Span, ~[@Expr]) -> @Expr,"}, {"sha": "61c9ea7be14a27c3c7008836957d461f32895c6d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -944,7 +944,7 @@ pub fn std_macros() -> @str {\n \n     # Example\n \n-    ~~~ {.rust}\n+    ```rust\n     fn choose_weighted_item(v: &[Item]) -> Item {\n         assert!(!v.is_empty());\n         let mut so_far = 0u;\n@@ -958,7 +958,7 @@ pub fn std_macros() -> @str {\n         // type checker that it isn't possible to get down here\n         unreachable!();\n     }\n-    ~~~\n+    ```\n \n     */\n     macro_rules! unreachable (() => ("}, {"sha": "88c9fc3e0f792917d812ae3f54cd7c63a88bef3e", "filename": "src/libsyntax/parse/comments.rs", "status": "modified", "additions": 40, "deletions": 15, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibsyntax%2Fparse%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Flibsyntax%2Fparse%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fcomments.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -59,11 +59,19 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n     fn vertical_trim(lines: ~[~str]) -> ~[~str] {\n         let mut i = 0u;\n         let mut j = lines.len();\n+        // first line of all-stars should be omitted\n+        if lines.len() > 0 && lines[0].iter().all(|c| c == '*') {\n+            i += 1;\n+        }\n         while i < j && lines[i].trim().is_empty() {\n-            i += 1u;\n+            i += 1;\n+        }\n+        // like the first, a last line of all stars should be omitted\n+        if j > i && lines[j - 1].iter().skip(1).all(|c| c == '*') {\n+            j -= 1;\n         }\n-        while j > i && lines[j - 1u].trim().is_empty() {\n-            j -= 1u;\n+        while j > i && lines[j - 1].trim().is_empty() {\n+            j -= 1;\n         }\n         return lines.slice(i, j).to_owned();\n     }\n@@ -106,8 +114,12 @@ pub fn strip_doc_comment_decoration(comment: &str) -> ~str {\n         }\n     }\n \n-    if comment.starts_with(\"//\") {\n-        return comment.slice(3u, comment.len()).to_owned();\n+    // one-line comments lose their prefix\n+    static ONLINERS: &'static [&'static str] = &[\"///!\", \"///\", \"//!\", \"//\"];\n+    for prefix in ONLINERS.iter() {\n+        if comment.starts_with(*prefix) {\n+            return comment.slice_from(prefix.len()).to_owned();\n+        }\n     }\n \n     if comment.starts_with(\"/*\") {\n@@ -384,29 +396,42 @@ mod test {\n \n     #[test] fn test_block_doc_comment_1() {\n         let comment = \"/**\\n * Test \\n **  Test\\n *   Test\\n*/\";\n-        let correct_stripped = \" Test \\n*  Test\\n   Test\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+        assert_eq!(stripped, ~\" Test \\n*  Test\\n   Test\");\n     }\n \n     #[test] fn test_block_doc_comment_2() {\n         let comment = \"/**\\n * Test\\n *  Test\\n*/\";\n-        let correct_stripped = \" Test\\n  Test\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+        assert_eq!(stripped, ~\" Test\\n  Test\");\n     }\n \n     #[test] fn test_block_doc_comment_3() {\n         let comment = \"/**\\n let a: *int;\\n *a = 5;\\n*/\";\n-        let correct_stripped = \" let a: *int;\\n *a = 5;\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+        assert_eq!(stripped, ~\" let a: *int;\\n *a = 5;\");\n     }\n \n-    #[test] fn test_line_doc_comment() {\n-        let comment = \"/// Test\";\n-        let correct_stripped = \" Test\";\n+    #[test] fn test_block_doc_comment_4() {\n+        let comment = \"/*******************\\n test\\n *********************/\";\n         let stripped = strip_doc_comment_decoration(comment);\n-        assert_eq!(stripped.slice(0, stripped.len()), correct_stripped);\n+        assert_eq!(stripped, ~\" test\");\n+    }\n+\n+    #[test] fn test_line_doc_comment() {\n+        let stripped = strip_doc_comment_decoration(\"/// test\");\n+        assert_eq!(stripped, ~\" test\");\n+        let stripped = strip_doc_comment_decoration(\"///! test\");\n+        assert_eq!(stripped, ~\" test\");\n+        let stripped = strip_doc_comment_decoration(\"// test\");\n+        assert_eq!(stripped, ~\" test\");\n+        let stripped = strip_doc_comment_decoration(\"// test\");\n+        assert_eq!(stripped, ~\" test\");\n+        let stripped = strip_doc_comment_decoration(\"///test\");\n+        assert_eq!(stripped, ~\"test\");\n+        let stripped = strip_doc_comment_decoration(\"///!test\");\n+        assert_eq!(stripped, ~\"test\");\n+        let stripped = strip_doc_comment_decoration(\"//test\");\n+        assert_eq!(stripped, ~\"test\");\n     }\n }"}, {"sha": "b87afab84eb1051832ed5e17fe08e8f234153f58", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -200,3 +200,9 @@ rust_set_stdio_container_fd\n rust_set_stdio_container_stream\n rust_uv_process_pid\n rust_uv_pipe_init\n+sdhtml_renderer\n+sd_markdown_new\n+sd_markdown_render\n+sd_markdown_free\n+bufrelease\n+bufnew"}, {"sha": "4415b7917358c302f23df42ea2f268b284f87d7f", "filename": "src/rt/sundown/.gitignore", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2F.gitignore?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,5 @@\n+*.o\n+libsundown.so*\n+sundown\n+smartypants\n+*.exe"}, {"sha": "7178d8cc99387962d36db46e6917943841c32241", "filename": "src/rt/sundown/CONTRIBUTING.md", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FCONTRIBUTING.md?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,10 @@\n+Contributing to Sundown\n+=======================\n+\n+Do not.\n+\n+Unfortunately, Sundown is currently frozen as we're working with the Reddit, StackOverflow and Meteor developers to design a formal Markdown standard and parser that will supersede Sundown in all these websites (and in GitHub, of course). Our goal is to deprecate Sundown altogether before the end of the year.\n+\n+The new parser will be smaller, faster, safer and most importantly, more consistent.\n+\n+Please stay tuned.\n\\ No newline at end of file"}, {"sha": "baca6875a20a8704d6defd6dddde39ad49d22725", "filename": "src/rt/sundown/Makefile", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FMakefile?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,83 @@\n+# Makefile\n+\n+# Copyright (c) 2009, Natacha Port\u00e9\n+#\n+# Permission to use, copy, modify, and distribute this software for any\n+# purpose with or without fee is hereby granted, provided that the above\n+# copyright notice and this permission notice appear in all copies.\n+#\n+# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+\n+DEPDIR=depends\n+\n+# \"Machine-dependant\" options\n+#MFLAGS=-fPIC\n+\n+CFLAGS=-c -g -O3 -fPIC -Wall -Werror -Wsign-compare -Isrc -Ihtml\n+LDFLAGS=-g -O3 -Wall -Werror \n+CC=gcc\n+\n+\n+SUNDOWN_SRC=\\\n+\tsrc/markdown.o \\\n+\tsrc/stack.o \\\n+\tsrc/buffer.o \\\n+\tsrc/autolink.o \\\n+\thtml/html.o \\\n+\thtml/html_smartypants.o \\\n+\thtml/houdini_html_e.o \\\n+\thtml/houdini_href_e.o\n+\n+all:\t\tlibsundown.so sundown smartypants html_blocks\n+\n+.PHONY:\t\tall clean\n+\n+# libraries\n+\n+libsundown.so:\tlibsundown.so.1\n+\tln -f -s $^ $@\n+\n+libsundown.so.1: $(SUNDOWN_SRC)\n+\t$(CC) $(LDFLAGS) -shared -Wl $^ -o $@\n+\n+# executables\n+\n+sundown:\texamples/sundown.o $(SUNDOWN_SRC)\n+\t$(CC) $(LDFLAGS) $^ -o $@\n+\n+smartypants: examples/smartypants.o $(SUNDOWN_SRC)\n+\t$(CC) $(LDFLAGS) $^ -o $@\n+\n+# perfect hashing\n+html_blocks: src/html_blocks.h\n+\n+src/html_blocks.h: html_block_names.txt\n+\tgperf -N find_block_tag -H hash_block_tag -C -c -E --ignore-case $^ > $@\n+\n+\n+# housekeeping\n+clean:\n+\trm -f src/*.o html/*.o examples/*.o\n+\trm -f libsundown.so libsundown.so.1 sundown smartypants\n+\trm -f sundown.exe smartypants.exe\n+\trm -rf $(DEPDIR)\n+\n+\n+# dependencies\n+\n+include $(wildcard $(DEPDIR)/*.d)\n+\n+\n+# generic object compilations\n+\n+%.o:\tsrc/%.c examples/%.c html/%.c\n+\t@mkdir -p $(DEPDIR)\n+\t@$(CC) -MM $< > $(DEPDIR)/$*.d\n+\t$(CC) $(CFLAGS) -o $@ $<\n+"}, {"sha": "ea668b2cdc1ecdd3ac95ec8e35192271a32cd8f0", "filename": "src/rt/sundown/Makefile.win", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2FMakefile.win", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2FMakefile.win", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FMakefile.win?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,33 @@\n+\n+CFLAGS=/O2 /EHsc /I\"src/\" /I\"examples\"/ /I\"html\"/\n+CC=cl\n+\n+SUNDOWN_SRC=\\\n+\tsrc\\markdown.obj \\\n+\tsrc\\stack.obj \\\n+\tsrc\\buffer.obj \\\n+\tsrc\\autolink.obj \\\n+\thtml\\html.obj \\\n+\thtml\\html_smartypants.obj \\\n+\thtml\\houdini_html_e.obj \\\n+\thtml\\houdini_href_e.obj\n+\n+all: sundown.dll sundown.exe\n+\n+sundown.dll: $(SUNDOWN_SRC) sundown.def\n+\t$(CC) $(SUNDOWN_SRC) sundown.def /link /DLL $(LDFLAGS) /out:$@\n+\n+sundown.exe: examples\\sundown.obj $(SUNDOWN_SRC)\n+\t$(CC) examples\\sundown.obj $(SUNDOWN_SRC) /link $(LDFLAGS) /out:$@\n+\n+# housekeeping\n+clean:\n+\tdel $(SUNDOWN_SRC)\n+\tdel sundown.dll sundown.exe\n+\tdel sundown.exp sundown.lib\n+\n+# generic object compilations\n+\n+.c.obj:\n+\t$(CC) $(CFLAGS) /c $< /Fo$@\n+"}, {"sha": "61736025ca92904488aea861725a56531d89edf7", "filename": "src/rt/sundown/README.markdown", "status": "added", "additions": 131, "deletions": 0, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2FREADME.markdown", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2FREADME.markdown", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2FREADME.markdown?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,131 @@\n+\ufeffSundown\n+=======\n+\n+`Sundown` is a Markdown parser based on the original code of the\n+[Upskirt library](http://fossil.instinctive.eu/libupskirt/index) by Natacha Port\u00e9.\n+\n+Features\n+--------\n+\n+*\t**Fully standards compliant**\n+\n+\t`Sundown` passes out of the box the official Markdown v1.0.0 and v1.0.3\n+\ttest suites, and has been extensively tested with additional corner cases\n+\tto make sure its output is as sane as possible at all times.\n+\n+*\t**Massive extension support**\n+\n+\t`Sundown` has optional support for several (unofficial) Markdown extensions,\n+\tsuch as non-strict emphasis, fenced code blocks, tables, autolinks,\n+\tstrikethrough and more.\n+\n+*\t**UTF-8 aware**\n+\n+\t`Sundown` is fully UTF-8 aware, both when parsing the source document and when\n+\tgenerating the resulting (X)HTML code.\n+\n+*\t**Tested & Ready to be used on production**\n+\n+\t`Sundown` has been extensively security audited, and includes protection against\n+\tall possible DOS attacks (stack overflows, out of memory situations, malformed\n+\tMarkdown syntax...) and against client attacks through malicious embedded HTML.\n+\n+\tWe've worked very hard to make `Sundown` never crash or run out of memory\n+\tunder *any* input. `Sundown` renders all the Markdown content in GitHub and so\n+\tfar hasn't crashed a single time.\n+\n+*\t**Customizable renderers**\n+\n+\t`Sundown` is not stuck with XHTML output: the Markdown parser of the library\n+\tis decoupled from the renderer, so it's trivial to extend the library with\n+\tcustom renderers. A fully functional (X)HTML renderer is included.\n+\n+*\t**Optimized for speed**\n+\n+\t`Sundown` is written in C, with a special emphasis on performance. When wrapped\n+\ton a dynamic language such as Python or Ruby, it has shown to be up to 40\n+\ttimes faster than other native alternatives.\n+\n+*\t**Zero-dependency**\n+\n+\t`Sundown` is a zero-dependency library composed of 3 `.c` files and their headers.\n+\tNo dependencies, no bullshit. Only standard C99 that builds everywhere.\n+\n+Credits\n+-------\n+\n+`Sundown` is based on the original Upskirt parser by Natacha Port\u00e9, with many additions\n+by Vicent Marti (@vmg) and contributions from the following authors:\n+\n+\tBen Noordhuis, Bruno Michel, Joseph Koshy, Krzysztof Kowalczyk, Samuel Bronson,\n+\tShuhei Tanuma\n+\n+Bindings\n+--------\n+\n+`Sundown` is available from other programming languages thanks to these bindings developed\n+by our awesome contributors.\n+\n+- [Redcarpet](https://github.com/vmg/redcarpet) (Ruby)\n+- [RobotSkirt](https://github.com/benmills/robotskirt) (Node.js)\n+- [Misaka](https://github.com/FSX/misaka) (Python)\n+- [ffi-sundown](https://github.com/postmodern/ffi-sundown) (Ruby FFI)\n+- [Sundown HS](https://github.com/bitonic/sundown) (Haskell)\n+- [Goskirt](https://github.com/madari/goskirt) (Go)\n+- [Upskirt.go](https://github.com/buu700/upskirt.go) (Go)\n+- [MoonShine](https://github.com/brandonc/moonshine) (.NET)\n+- [PHP-Sundown](https://github.com/chobie/php-sundown) (PHP)\n+- [Sundown.net](https://github.com/txdv/sundown.net) (.NET)\n+\n+Help us\n+-------\n+\n+`Sundown` is all about security. If you find a (potential) security vulnerability in the\n+library, or a way to make it crash through malicious input, please report it to us,\n+either directly via email or by opening an Issue on GitHub, and help make the web safer\n+for everybody.\n+\n+Unicode character handling\n+--------------------------\n+\n+Given that the Markdown spec makes no provision for Unicode character handling, `Sundown`\n+takes a conservative approach towards deciding which extended characters trigger Markdown\n+features:\n+\n+*\tPunctuation characters outside of the U+007F codepoint are not handled as punctuation.\n+\tThey are considered as normal, in-word characters for word-boundary checks.\n+\n+*\tWhitespace characters outside of the U+007F codepoint are not considered as\n+\twhitespace. They are considered as normal, in-word characters for word-boundary checks.\n+\n+Install\n+-------\n+\n+There is nothing to install. `Sundown` is composed of 3 `.c` files (`markdown.c`,\n+`buffer.c` and `array.c`), so just throw them in your project. Zero-dependency means\n+zero-dependency. You might want to include `render/html.c` if you want to use the\n+included XHTML renderer, or write your own renderer. Either way, it's all fun and joy.\n+\n+If you are hardcore, you can use the included `Makefile` to build `Sundown` into a dynamic\n+library, or to build the sample `sundown` executable, which is just a commandline\n+Markdown to XHTML parser. (If gcc gives you grief about `-fPIC`, e.g. with MinGW, try\n+`make MFLAGS=` instead of just `make`.)\n+\n+License\n+-------\n+\n+Permission to use, copy, modify, and distribute this software for any\n+purpose with or without fee is hereby granted, provided that the above\n+copyright notice and this permission notice appear in all copies.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+\n+<!-- Local Variables: -->\n+<!-- fill-column: 89 -->\n+<!-- End: -->"}, {"sha": "4840703bb12ecc67bc213b69d76268c1149bbf9c", "filename": "src/rt/sundown/examples/smartypants.c", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fexamples%2Fsmartypants.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fexamples%2Fsmartypants.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fexamples%2Fsmartypants.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"markdown.h\"\n+#include \"html.h\"\n+#include \"buffer.h\"\n+\n+#include <errno.h>\n+#include <getopt.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define READ_UNIT 1024\n+#define OUTPUT_UNIT 64\n+\n+int\n+main(int argc, char **argv)\n+{\n+\tstruct buf *ib, *ob;\n+\tsize_t ret;\n+\tFILE *in = stdin;\n+\n+\t/* opening the file if given from the command line */\n+\tif (argc > 1) {\n+\t\tin = fopen(argv[1], \"r\");\n+\t\tif (!in) {\n+\t\t\tfprintf(stderr, \"Unable to open input file \\\"%s\\\": %s\\n\", argv[0], strerror(errno));\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\n+\t/* reading everything */\n+\tib = bufnew(READ_UNIT);\n+\tbufgrow(ib, READ_UNIT);\n+\twhile ((ret = fread(ib->data + ib->size, 1, ib->asize - ib->size, in)) > 0) {\n+\t\tib->size += ret;\n+\t\tbufgrow(ib, ib->size + READ_UNIT);\n+\t}\n+\n+\tif (in != stdin)\n+\t\tfclose(in);\n+\n+\t/* performing markdown parsing */\n+\tob = bufnew(OUTPUT_UNIT);\n+\n+\tsdhtml_smartypants(ob, ib->data, ib->size);\n+\n+\t/* writing the result to stdout */\n+\t(void)fwrite(ob->data, 1, ob->size, stdout);\n+\n+\t/* cleanup */\n+\tbufrelease(ib);\n+\tbufrelease(ob);\n+\n+\treturn 0;\n+}\n+\n+/* vim: set filetype=c: */"}, {"sha": "8a475dcaa3d79ce117bc17b910ec975e57e680df", "filename": "src/rt/sundown/examples/sundown.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fexamples%2Fsundown.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fexamples%2Fsundown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fexamples%2Fsundown.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"markdown.h\"\n+#include \"html.h\"\n+#include \"buffer.h\"\n+\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#define READ_UNIT 1024\n+#define OUTPUT_UNIT 64\n+\n+/* main \u2022 main function, interfacing STDIO with the parser */\n+int\n+main(int argc, char **argv)\n+{\n+\tstruct buf *ib, *ob;\n+\tint ret;\n+\tFILE *in = stdin;\n+\n+\tstruct sd_callbacks callbacks;\n+\tstruct html_renderopt options;\n+\tstruct sd_markdown *markdown;\n+\n+\t/* opening the file if given from the command line */\n+\tif (argc > 1) {\n+\t\tin = fopen(argv[1], \"r\");\n+\t\tif (!in) {\n+\t\t\tfprintf(stderr,\"Unable to open input file \\\"%s\\\": %s\\n\", argv[1], strerror(errno));\n+\t\t\treturn 1;\n+\t\t}\n+\t}\n+\n+\t/* reading everything */\n+\tib = bufnew(READ_UNIT);\n+\tbufgrow(ib, READ_UNIT);\n+\twhile ((ret = fread(ib->data + ib->size, 1, ib->asize - ib->size, in)) > 0) {\n+\t\tib->size += ret;\n+\t\tbufgrow(ib, ib->size + READ_UNIT);\n+\t}\n+\n+\tif (in != stdin)\n+\t\tfclose(in);\n+\n+\t/* performing markdown parsing */\n+\tob = bufnew(OUTPUT_UNIT);\n+\n+\tsdhtml_renderer(&callbacks, &options, 0);\n+\tmarkdown = sd_markdown_new(0, 16, &callbacks, &options);\n+\n+\tsd_markdown_render(ob, ib->data, ib->size, markdown);\n+\tsd_markdown_free(markdown);\n+\n+\t/* writing the result to stdout */\n+\tret = fwrite(ob->data, 1, ob->size, stdout);\n+\n+\t/* cleanup */\n+\tbufrelease(ib);\n+\tbufrelease(ob);\n+\n+\treturn (ret < 0) ? -1 : 0;\n+}\n+\n+/* vim: set filetype=c: */"}, {"sha": "b4954c02f67909ea3b57b73c56d5844981068000", "filename": "src/rt/sundown/html/houdini.h", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhoudini.h", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhoudini.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhoudini.h?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,37 @@\n+#ifndef HOUDINI_H__\n+#define HOUDINI_H__\n+\n+#include \"buffer.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#ifdef HOUDINI_USE_LOCALE\n+#\tdefine _isxdigit(c) isxdigit(c)\n+#\tdefine _isdigit(c) isdigit(c)\n+#else\n+/*\n+ * Helper _isdigit methods -- do not trust the current locale\n+ * */\n+#\tdefine _isxdigit(c) (strchr(\"0123456789ABCDEFabcdef\", (c)) != NULL)\n+#\tdefine _isdigit(c) ((c) >= '0' && (c) <= '9')\n+#endif\n+\n+extern void houdini_escape_html(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_html0(struct buf *ob, const uint8_t *src, size_t size, int secure);\n+extern void houdini_unescape_html(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_xml(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_uri(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_url(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_href(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_unescape_uri(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_unescape_url(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_escape_js(struct buf *ob, const uint8_t *src, size_t size);\n+extern void houdini_unescape_js(struct buf *ob, const uint8_t *src, size_t size);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "981b3b17e4153dce7cccaa7672471bb26280bde4", "filename": "src/rt/sundown/html/houdini_href_e.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_href_e.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_href_e.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_href_e.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,108 @@\n+#include <assert.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"houdini.h\"\n+\n+#define ESCAPE_GROW_FACTOR(x) (((x) * 12) / 10)\n+\n+/*\n+ * The following characters will not be escaped:\n+ *\n+ *\t\t-_.+!*'(),%#@?=;:/,+&$ alphanum\n+ *\n+ * Note that this character set is the addition of:\n+ *\n+ *\t- The characters which are safe to be in an URL\n+ *\t- The characters which are *not* safe to be in\n+ *\tan URL because they are RESERVED characters.\n+ *\n+ * We asume (lazily) that any RESERVED char that\n+ * appears inside an URL is actually meant to\n+ * have its native function (i.e. as an URL \n+ * component/separator) and hence needs no escaping.\n+ *\n+ * There are two exceptions: the chacters & (amp)\n+ * and ' (single quote) do not appear in the table.\n+ * They are meant to appear in the URL as components,\n+ * yet they require special HTML-entity escaping\n+ * to generate valid HTML markup.\n+ *\n+ * All other characters will be escaped to %XX.\n+ *\n+ */\n+static const char HREF_SAFE[] = {\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, \n+\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, \n+\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n+\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, \n+\t0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \n+\t1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+};\n+\n+void\n+houdini_escape_href(struct buf *ob, const uint8_t *src, size_t size)\n+{\n+\tstatic const char hex_chars[] = \"0123456789ABCDEF\";\n+\tsize_t  i = 0, org;\n+\tchar hex_str[3];\n+\n+\tbufgrow(ob, ESCAPE_GROW_FACTOR(size));\n+\thex_str[0] = '%';\n+\n+\twhile (i < size) {\n+\t\torg = i;\n+\t\twhile (i < size && HREF_SAFE[src[i]] != 0)\n+\t\t\ti++;\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, src + org, i - org);\n+\n+\t\t/* escaping */\n+\t\tif (i >= size)\n+\t\t\tbreak;\n+\n+\t\tswitch (src[i]) {\n+\t\t/* amp appears all the time in URLs, but needs\n+\t\t * HTML-entity escaping to be inside an href */\n+\t\tcase '&': \n+\t\t\tBUFPUTSL(ob, \"&amp;\");\n+\t\t\tbreak;\n+\n+\t\t/* the single quote is a valid URL character\n+\t\t * according to the standard; it needs HTML\n+\t\t * entity escaping too */\n+\t\tcase '\\'':\n+\t\t\tBUFPUTSL(ob, \"&#x27;\");\n+\t\t\tbreak;\n+\t\t\n+\t\t/* the space can be escaped to %20 or a plus\n+\t\t * sign. we're going with the generic escape\n+\t\t * for now. the plus thing is more commonly seen\n+\t\t * when building GET strings */\n+#if 0\n+\t\tcase ' ':\n+\t\t\tbufputc(ob, '+');\n+\t\t\tbreak;\n+#endif\n+\n+\t\t/* every other character goes with a %XX escaping */\n+\t\tdefault:\n+\t\t\thex_str[1] = hex_chars[(src[i] >> 4) & 0xF];\n+\t\t\thex_str[2] = hex_chars[src[i] & 0xF];\n+\t\t\tbufput(ob, hex_str, 3);\n+\t\t}\n+\n+\t\ti++;\n+\t}\n+}"}, {"sha": "d9bbf187d825cec7e1d339dbb2f5b01956359545", "filename": "src/rt/sundown/html/houdini_html_e.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_html_e.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_html_e.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhoudini_html_e.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,84 @@\n+#include <assert.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+#include \"houdini.h\"\n+\n+#define ESCAPE_GROW_FACTOR(x) (((x) * 12) / 10) /* this is very scientific, yes */\n+\n+/**\n+ * According to the OWASP rules:\n+ *\n+ * & --> &amp;\n+ * < --> &lt;\n+ * > --> &gt;\n+ * \" --> &quot;\n+ * ' --> &#x27;     &apos; is not recommended\n+ * / --> &#x2F;     forward slash is included as it helps end an HTML entity\n+ *\n+ */\n+static const char HTML_ESCAPE_TABLE[] = {\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 1, 0, 0, 0, 2, 3, 0, 0, 0, 0, 0, 0, 0, 4, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 0, 6, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+};\n+\n+static const char *HTML_ESCAPES[] = {\n+        \"\",\n+        \"&quot;\",\n+        \"&amp;\",\n+        \"&#39;\",\n+        \"&#47;\",\n+        \"&lt;\",\n+        \"&gt;\"\n+};\n+\n+void\n+houdini_escape_html0(struct buf *ob, const uint8_t *src, size_t size, int secure)\n+{\n+\tsize_t i = 0, org, esc = 0;\n+\n+\tbufgrow(ob, ESCAPE_GROW_FACTOR(size));\n+\n+\twhile (i < size) {\n+\t\torg = i;\n+\t\twhile (i < size && (esc = HTML_ESCAPE_TABLE[src[i]]) == 0)\n+\t\t\ti++;\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, src + org, i - org);\n+\n+\t\t/* escaping */\n+\t\tif (i >= size)\n+\t\t\tbreak;\n+\n+\t\t/* The forward slash is only escaped in secure mode */\n+\t\tif (src[i] == '/' && !secure) {\n+\t\t\tbufputc(ob, '/');\n+\t\t} else {\n+\t\t\tbufputs(ob, HTML_ESCAPES[esc]);\n+\t\t}\n+\n+\t\ti++;\n+\t}\n+}\n+\n+void\n+houdini_escape_html(struct buf *ob, const uint8_t *src, size_t size)\n+{\n+\thoudini_escape_html0(ob, src, size, 1);\n+}\n+"}, {"sha": "7f08ee8ef1b97387ab96ab9a66b11d57d62cd1c9", "filename": "src/rt/sundown/html/html.c", "status": "added", "additions": 635, "deletions": 0, "changes": 635, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhtml.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhtml.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhtml.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,635 @@\n+/*\n+ * Copyright (c) 2009, Natacha Port\u00e9\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"markdown.h\"\n+#include \"html.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+#include \"houdini.h\"\n+\n+#define USE_XHTML(opt) (opt->flags & HTML_USE_XHTML)\n+\n+int\n+sdhtml_is_tag(const uint8_t *tag_data, size_t tag_size, const char *tagname)\n+{\n+\tsize_t i;\n+\tint closed = 0;\n+\n+\tif (tag_size < 3 || tag_data[0] != '<')\n+\t\treturn HTML_TAG_NONE;\n+\n+\ti = 1;\n+\n+\tif (tag_data[i] == '/') {\n+\t\tclosed = 1;\n+\t\ti++;\n+\t}\n+\n+\tfor (; i < tag_size; ++i, ++tagname) {\n+\t\tif (*tagname == 0)\n+\t\t\tbreak;\n+\n+\t\tif (tag_data[i] != *tagname)\n+\t\t\treturn HTML_TAG_NONE;\n+\t}\n+\n+\tif (i == tag_size)\n+\t\treturn HTML_TAG_NONE;\n+\n+\tif (isspace(tag_data[i]) || tag_data[i] == '>')\n+\t\treturn closed ? HTML_TAG_CLOSE : HTML_TAG_OPEN;\n+\n+\treturn HTML_TAG_NONE;\n+}\n+\n+static inline void escape_html(struct buf *ob, const uint8_t *source, size_t length)\n+{\n+\thoudini_escape_html0(ob, source, length, 0);\n+}\n+\n+static inline void escape_href(struct buf *ob, const uint8_t *source, size_t length)\n+{\n+\thoudini_escape_href(ob, source, length);\n+}\n+\n+/********************\n+ * GENERIC RENDERER *\n+ ********************/\n+static int\n+rndr_autolink(struct buf *ob, const struct buf *link, enum mkd_autolink type, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\tif (!link || !link->size)\n+\t\treturn 0;\n+\n+\tif ((options->flags & HTML_SAFELINK) != 0 &&\n+\t\t!sd_autolink_issafe(link->data, link->size) &&\n+\t\ttype != MKDA_EMAIL)\n+\t\treturn 0;\n+\n+\tBUFPUTSL(ob, \"<a href=\\\"\");\n+\tif (type == MKDA_EMAIL)\n+\t\tBUFPUTSL(ob, \"mailto:\");\n+\tescape_href(ob, link->data, link->size);\n+\n+\tif (options->link_attributes) {\n+\t\tbufputc(ob, '\\\"');\n+\t\toptions->link_attributes(ob, link, opaque);\n+\t\tbufputc(ob, '>');\n+\t} else {\n+\t\tBUFPUTSL(ob, \"\\\">\");\n+\t}\n+\n+\t/*\n+\t * Pretty printing: if we get an email address as\n+\t * an actual URI, e.g. `mailto:foo@bar.com`, we don't\n+\t * want to print the `mailto:` prefix\n+\t */\n+\tif (bufprefix(link, \"mailto:\") == 0) {\n+\t\tescape_html(ob, link->data + 7, link->size - 7);\n+\t} else {\n+\t\tescape_html(ob, link->data, link->size);\n+\t}\n+\n+\tBUFPUTSL(ob, \"</a>\");\n+\n+\treturn 1;\n+}\n+\n+static void\n+rndr_blockcode(struct buf *ob, const struct buf *text, const struct buf *lang, void *opaque)\n+{\n+\tif (ob->size) bufputc(ob, '\\n');\n+\n+\tif (lang && lang->size) {\n+\t\tsize_t i, cls;\n+\t\tBUFPUTSL(ob, \"<pre><code class=\\\"\");\n+\n+\t\tfor (i = 0, cls = 0; i < lang->size; ++i, ++cls) {\n+\t\t\twhile (i < lang->size && isspace(lang->data[i]))\n+\t\t\t\ti++;\n+\n+\t\t\tif (i < lang->size) {\n+\t\t\t\tsize_t org = i;\n+\t\t\t\twhile (i < lang->size && !isspace(lang->data[i]))\n+\t\t\t\t\ti++;\n+\n+\t\t\t\tif (lang->data[org] == '.')\n+\t\t\t\t\torg++;\n+\n+\t\t\t\tif (cls) bufputc(ob, ' ');\n+\t\t\t\tescape_html(ob, lang->data + org, i - org);\n+\t\t\t}\n+\t\t}\n+\n+\t\tBUFPUTSL(ob, \"\\\">\");\n+\t} else\n+\t\tBUFPUTSL(ob, \"<pre><code>\");\n+\n+\tif (text)\n+\t\tescape_html(ob, text->data, text->size);\n+\n+\tBUFPUTSL(ob, \"</code></pre>\\n\");\n+}\n+\n+static void\n+rndr_blockquote(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tBUFPUTSL(ob, \"<blockquote>\\n\");\n+\tif (text) bufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</blockquote>\\n\");\n+}\n+\n+static int\n+rndr_codespan(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tBUFPUTSL(ob, \"<code>\");\n+\tif (text) escape_html(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</code>\");\n+\treturn 1;\n+}\n+\n+static int\n+rndr_strikethrough(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size)\n+\t\treturn 0;\n+\n+\tBUFPUTSL(ob, \"<del>\");\n+\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</del>\");\n+\treturn 1;\n+}\n+\n+static int\n+rndr_double_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size)\n+\t\treturn 0;\n+\n+\tBUFPUTSL(ob, \"<strong>\");\n+\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</strong>\");\n+\n+\treturn 1;\n+}\n+\n+static int\n+rndr_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size) return 0;\n+\tBUFPUTSL(ob, \"<em>\");\n+\tif (text) bufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</em>\");\n+\treturn 1;\n+}\n+\n+static int\n+rndr_linebreak(struct buf *ob, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\tbufputs(ob, USE_XHTML(options) ? \"<br/>\\n\" : \"<br>\\n\");\n+\treturn 1;\n+}\n+\n+static void\n+rndr_header(struct buf *ob, const struct buf *text, int level, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\tif (ob->size)\n+\t\tbufputc(ob, '\\n');\n+\n+\tif (options->flags & HTML_TOC)\n+\t\tbufprintf(ob, \"<h%d id=\\\"toc_%d\\\">\", level, options->toc_data.header_count++);\n+\telse\n+\t\tbufprintf(ob, \"<h%d>\", level);\n+\n+\tif (text) bufput(ob, text->data, text->size);\n+\tbufprintf(ob, \"</h%d>\\n\", level);\n+}\n+\n+static int\n+rndr_link(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *content, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\tif (link != NULL && (options->flags & HTML_SAFELINK) != 0 && !sd_autolink_issafe(link->data, link->size))\n+\t\treturn 0;\n+\n+\tBUFPUTSL(ob, \"<a href=\\\"\");\n+\n+\tif (link && link->size)\n+\t\tescape_href(ob, link->data, link->size);\n+\n+\tif (title && title->size) {\n+\t\tBUFPUTSL(ob, \"\\\" title=\\\"\");\n+\t\tescape_html(ob, title->data, title->size);\n+\t}\n+\n+\tif (options->link_attributes) {\n+\t\tbufputc(ob, '\\\"');\n+\t\toptions->link_attributes(ob, link, opaque);\n+\t\tbufputc(ob, '>');\n+\t} else {\n+\t\tBUFPUTSL(ob, \"\\\">\");\n+\t}\n+\n+\tif (content && content->size) bufput(ob, content->data, content->size);\n+\tBUFPUTSL(ob, \"</a>\");\n+\treturn 1;\n+}\n+\n+static void\n+rndr_list(struct buf *ob, const struct buf *text, int flags, void *opaque)\n+{\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tbufput(ob, flags & MKD_LIST_ORDERED ? \"<ol>\\n\" : \"<ul>\\n\", 5);\n+\tif (text) bufput(ob, text->data, text->size);\n+\tbufput(ob, flags & MKD_LIST_ORDERED ? \"</ol>\\n\" : \"</ul>\\n\", 6);\n+}\n+\n+static void\n+rndr_listitem(struct buf *ob, const struct buf *text, int flags, void *opaque)\n+{\n+\tBUFPUTSL(ob, \"<li>\");\n+\tif (text) {\n+\t\tsize_t size = text->size;\n+\t\twhile (size && text->data[size - 1] == '\\n')\n+\t\t\tsize--;\n+\n+\t\tbufput(ob, text->data, size);\n+\t}\n+\tBUFPUTSL(ob, \"</li>\\n\");\n+}\n+\n+static void\n+rndr_paragraph(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\tsize_t i = 0;\n+\n+\tif (ob->size) bufputc(ob, '\\n');\n+\n+\tif (!text || !text->size)\n+\t\treturn;\n+\n+\twhile (i < text->size && isspace(text->data[i])) i++;\n+\n+\tif (i == text->size)\n+\t\treturn;\n+\n+\tBUFPUTSL(ob, \"<p>\");\n+\tif (options->flags & HTML_HARD_WRAP) {\n+\t\tsize_t org;\n+\t\twhile (i < text->size) {\n+\t\t\torg = i;\n+\t\t\twhile (i < text->size && text->data[i] != '\\n')\n+\t\t\t\ti++;\n+\n+\t\t\tif (i > org)\n+\t\t\t\tbufput(ob, text->data + org, i - org);\n+\n+\t\t\t/*\n+\t\t\t * do not insert a line break if this newline\n+\t\t\t * is the last character on the paragraph\n+\t\t\t */\n+\t\t\tif (i >= text->size - 1)\n+\t\t\t\tbreak;\n+\n+\t\t\trndr_linebreak(ob, opaque);\n+\t\t\ti++;\n+\t\t}\n+\t} else {\n+\t\tbufput(ob, &text->data[i], text->size - i);\n+\t}\n+\tBUFPUTSL(ob, \"</p>\\n\");\n+}\n+\n+static void\n+rndr_raw_block(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tsize_t org, sz;\n+\tif (!text) return;\n+\tsz = text->size;\n+\twhile (sz > 0 && text->data[sz - 1] == '\\n') sz--;\n+\torg = 0;\n+\twhile (org < sz && text->data[org] == '\\n') org++;\n+\tif (org >= sz) return;\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tbufput(ob, text->data + org, sz - org);\n+\tbufputc(ob, '\\n');\n+}\n+\n+static int\n+rndr_triple_emphasis(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size) return 0;\n+\tBUFPUTSL(ob, \"<strong><em>\");\n+\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</em></strong>\");\n+\treturn 1;\n+}\n+\n+static void\n+rndr_hrule(struct buf *ob, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tbufputs(ob, USE_XHTML(options) ? \"<hr/>\\n\" : \"<hr>\\n\");\n+}\n+\n+static int\n+rndr_image(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *alt, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\tif (!link || !link->size) return 0;\n+\n+\tBUFPUTSL(ob, \"<img src=\\\"\");\n+\tescape_href(ob, link->data, link->size);\n+\tBUFPUTSL(ob, \"\\\" alt=\\\"\");\n+\n+\tif (alt && alt->size)\n+\t\tescape_html(ob, alt->data, alt->size);\n+\n+\tif (title && title->size) {\n+\t\tBUFPUTSL(ob, \"\\\" title=\\\"\");\n+\t\tescape_html(ob, title->data, title->size); }\n+\n+\tbufputs(ob, USE_XHTML(options) ? \"\\\"/>\" : \"\\\">\");\n+\treturn 1;\n+}\n+\n+static int\n+rndr_raw_html(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\t/* HTML_ESCAPE overrides SKIP_HTML, SKIP_STYLE, SKIP_LINKS and SKIP_IMAGES\n+\t* It doens't see if there are any valid tags, just escape all of them. */\n+\tif((options->flags & HTML_ESCAPE) != 0) {\n+\t\tescape_html(ob, text->data, text->size);\n+\t\treturn 1;\n+\t}\n+\n+\tif ((options->flags & HTML_SKIP_HTML) != 0)\n+\t\treturn 1;\n+\n+\tif ((options->flags & HTML_SKIP_STYLE) != 0 &&\n+\t\tsdhtml_is_tag(text->data, text->size, \"style\"))\n+\t\treturn 1;\n+\n+\tif ((options->flags & HTML_SKIP_LINKS) != 0 &&\n+\t\tsdhtml_is_tag(text->data, text->size, \"a\"))\n+\t\treturn 1;\n+\n+\tif ((options->flags & HTML_SKIP_IMAGES) != 0 &&\n+\t\tsdhtml_is_tag(text->data, text->size, \"img\"))\n+\t\treturn 1;\n+\n+\tbufput(ob, text->data, text->size);\n+\treturn 1;\n+}\n+\n+static void\n+rndr_table(struct buf *ob, const struct buf *header, const struct buf *body, void *opaque)\n+{\n+\tif (ob->size) bufputc(ob, '\\n');\n+\tBUFPUTSL(ob, \"<table><thead>\\n\");\n+\tif (header)\n+\t\tbufput(ob, header->data, header->size);\n+\tBUFPUTSL(ob, \"</thead><tbody>\\n\");\n+\tif (body)\n+\t\tbufput(ob, body->data, body->size);\n+\tBUFPUTSL(ob, \"</tbody></table>\\n\");\n+}\n+\n+static void\n+rndr_tablerow(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tBUFPUTSL(ob, \"<tr>\\n\");\n+\tif (text)\n+\t\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</tr>\\n\");\n+}\n+\n+static void\n+rndr_tablecell(struct buf *ob, const struct buf *text, int flags, void *opaque)\n+{\n+\tif (flags & MKD_TABLE_HEADER) {\n+\t\tBUFPUTSL(ob, \"<th\");\n+\t} else {\n+\t\tBUFPUTSL(ob, \"<td\");\n+\t}\n+\n+\tswitch (flags & MKD_TABLE_ALIGNMASK) {\n+\tcase MKD_TABLE_ALIGN_CENTER:\n+\t\tBUFPUTSL(ob, \" align=\\\"center\\\">\");\n+\t\tbreak;\n+\n+\tcase MKD_TABLE_ALIGN_L:\n+\t\tBUFPUTSL(ob, \" align=\\\"left\\\">\");\n+\t\tbreak;\n+\n+\tcase MKD_TABLE_ALIGN_R:\n+\t\tBUFPUTSL(ob, \" align=\\\"right\\\">\");\n+\t\tbreak;\n+\n+\tdefault:\n+\t\tBUFPUTSL(ob, \">\");\n+\t}\n+\n+\tif (text)\n+\t\tbufput(ob, text->data, text->size);\n+\n+\tif (flags & MKD_TABLE_HEADER) {\n+\t\tBUFPUTSL(ob, \"</th>\\n\");\n+\t} else {\n+\t\tBUFPUTSL(ob, \"</td>\\n\");\n+\t}\n+}\n+\n+static int\n+rndr_superscript(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (!text || !text->size) return 0;\n+\tBUFPUTSL(ob, \"<sup>\");\n+\tbufput(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</sup>\");\n+\treturn 1;\n+}\n+\n+static void\n+rndr_normal_text(struct buf *ob, const struct buf *text, void *opaque)\n+{\n+\tif (text)\n+\t\tescape_html(ob, text->data, text->size);\n+}\n+\n+static void\n+toc_header(struct buf *ob, const struct buf *text, int level, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\t/* set the level offset if this is the first header\n+\t * we're parsing for the document */\n+\tif (options->toc_data.current_level == 0) {\n+\t\toptions->toc_data.level_offset = level - 1;\n+\t}\n+\tlevel -= options->toc_data.level_offset;\n+\n+\tif (level > options->toc_data.current_level) {\n+\t\twhile (level > options->toc_data.current_level) {\n+\t\t\tBUFPUTSL(ob, \"<ul>\\n<li>\\n\");\n+\t\t\toptions->toc_data.current_level++;\n+\t\t}\n+\t} else if (level < options->toc_data.current_level) {\n+\t\tBUFPUTSL(ob, \"</li>\\n\");\n+\t\twhile (level < options->toc_data.current_level) {\n+\t\t\tBUFPUTSL(ob, \"</ul>\\n</li>\\n\");\n+\t\t\toptions->toc_data.current_level--;\n+\t\t}\n+\t\tBUFPUTSL(ob,\"<li>\\n\");\n+\t} else {\n+\t\tBUFPUTSL(ob,\"</li>\\n<li>\\n\");\n+\t}\n+\n+\tbufprintf(ob, \"<a href=\\\"#toc_%d\\\">\", options->toc_data.header_count++);\n+\tif (text)\n+\t\tescape_html(ob, text->data, text->size);\n+\tBUFPUTSL(ob, \"</a>\\n\");\n+}\n+\n+static int\n+toc_link(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *content, void *opaque)\n+{\n+\tif (content && content->size)\n+\t\tbufput(ob, content->data, content->size);\n+\treturn 1;\n+}\n+\n+static void\n+toc_finalize(struct buf *ob, void *opaque)\n+{\n+\tstruct html_renderopt *options = opaque;\n+\n+\twhile (options->toc_data.current_level > 0) {\n+\t\tBUFPUTSL(ob, \"</li>\\n</ul>\\n\");\n+\t\toptions->toc_data.current_level--;\n+\t}\n+}\n+\n+void\n+sdhtml_toc_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options)\n+{\n+\tstatic const struct sd_callbacks cb_default = {\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\ttoc_header,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\t\tNULL,\n+\n+\t\tNULL,\n+\t\trndr_codespan,\n+\t\trndr_double_emphasis,\n+\t\trndr_emphasis,\n+\t\tNULL,\n+\t\tNULL,\n+\t\ttoc_link,\n+\t\tNULL,\n+\t\trndr_triple_emphasis,\n+\t\trndr_strikethrough,\n+\t\trndr_superscript,\n+\n+\t\tNULL,\n+\t\tNULL,\n+\n+\t\tNULL,\n+\t\ttoc_finalize,\n+\t};\n+\n+\tmemset(options, 0x0, sizeof(struct html_renderopt));\n+\toptions->flags = HTML_TOC;\n+\n+\tmemcpy(callbacks, &cb_default, sizeof(struct sd_callbacks));\n+}\n+\n+void\n+sdhtml_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options, unsigned int render_flags)\n+{\n+\tstatic const struct sd_callbacks cb_default = {\n+\t\trndr_blockcode,\n+\t\trndr_blockquote,\n+\t\trndr_raw_block,\n+\t\trndr_header,\n+\t\trndr_hrule,\n+\t\trndr_list,\n+\t\trndr_listitem,\n+\t\trndr_paragraph,\n+\t\trndr_table,\n+\t\trndr_tablerow,\n+\t\trndr_tablecell,\n+\n+\t\trndr_autolink,\n+\t\trndr_codespan,\n+\t\trndr_double_emphasis,\n+\t\trndr_emphasis,\n+\t\trndr_image,\n+\t\trndr_linebreak,\n+\t\trndr_link,\n+\t\trndr_raw_html,\n+\t\trndr_triple_emphasis,\n+\t\trndr_strikethrough,\n+\t\trndr_superscript,\n+\n+\t\tNULL,\n+\t\trndr_normal_text,\n+\n+\t\tNULL,\n+\t\tNULL,\n+\t};\n+\n+\t/* Prepare the options pointer */\n+\tmemset(options, 0x0, sizeof(struct html_renderopt));\n+\toptions->flags = render_flags;\n+\n+\t/* Prepare the callbacks */\n+\tmemcpy(callbacks, &cb_default, sizeof(struct sd_callbacks));\n+\n+\tif (render_flags & HTML_SKIP_IMAGES)\n+\t\tcallbacks->image = NULL;\n+\n+\tif (render_flags & HTML_SKIP_LINKS) {\n+\t\tcallbacks->link = NULL;\n+\t\tcallbacks->autolink = NULL;\n+\t}\n+\n+\tif (render_flags & HTML_SKIP_HTML || render_flags & HTML_ESCAPE)\n+\t\tcallbacks->blockhtml = NULL;\n+}"}, {"sha": "4c8810d471c92b7edb592398a6b9bcaa99508f92", "filename": "src/rt/sundown/html/html.h", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhtml.h", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhtml.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhtml.h?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef UPSKIRT_HTML_H\n+#define UPSKIRT_HTML_H\n+\n+#include \"markdown.h\"\n+#include \"buffer.h\"\n+#include <stdlib.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+struct html_renderopt {\n+\tstruct {\n+\t\tint header_count;\n+\t\tint current_level;\n+\t\tint level_offset;\n+\t} toc_data;\n+\n+\tunsigned int flags;\n+\n+\t/* extra callbacks */\n+\tvoid (*link_attributes)(struct buf *ob, const struct buf *url, void *self);\n+};\n+\n+typedef enum {\n+\tHTML_SKIP_HTML = (1 << 0),\n+\tHTML_SKIP_STYLE = (1 << 1),\n+\tHTML_SKIP_IMAGES = (1 << 2),\n+\tHTML_SKIP_LINKS = (1 << 3),\n+\tHTML_EXPAND_TABS = (1 << 4),\n+\tHTML_SAFELINK = (1 << 5),\n+\tHTML_TOC = (1 << 6),\n+\tHTML_HARD_WRAP = (1 << 7),\n+\tHTML_USE_XHTML = (1 << 8),\n+\tHTML_ESCAPE = (1 << 9),\n+} html_render_mode;\n+\n+typedef enum {\n+\tHTML_TAG_NONE = 0,\n+\tHTML_TAG_OPEN,\n+\tHTML_TAG_CLOSE,\n+} html_tag;\n+\n+int\n+sdhtml_is_tag(const uint8_t *tag_data, size_t tag_size, const char *tagname);\n+\n+extern void\n+sdhtml_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options_ptr, unsigned int render_flags);\n+\n+extern void\n+sdhtml_toc_renderer(struct sd_callbacks *callbacks, struct html_renderopt *options_ptr);\n+\n+extern void\n+sdhtml_smartypants(struct buf *ob, const uint8_t *text, size_t size);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+"}, {"sha": "367c26aeb9cc9840f32bc0b1591224a4667c0544", "filename": "src/rt/sundown/html/html_smartypants.c", "status": "added", "additions": 389, "deletions": 0, "changes": 389, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhtml_smartypants.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml%2Fhtml_smartypants.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml%2Fhtml_smartypants.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,389 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"buffer.h\"\n+#include \"html.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+#if defined(_WIN32)\n+#define snprintf\t_snprintf\t\t\n+#endif\n+\n+struct smartypants_data {\n+\tint in_squote;\n+\tint in_dquote;\n+};\n+\n+static size_t smartypants_cb__ltag(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__dquote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__amp(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__period(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__number(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__dash(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__parens(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__squote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__backtick(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+static size_t smartypants_cb__escape(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size);\n+\n+static size_t (*smartypants_cb_ptrs[])\n+\t(struct buf *, struct smartypants_data *, uint8_t, const uint8_t *, size_t) =\n+{\n+\tNULL,\t\t\t\t\t/* 0 */\n+\tsmartypants_cb__dash,\t/* 1 */\n+\tsmartypants_cb__parens,\t/* 2 */\n+\tsmartypants_cb__squote, /* 3 */\n+\tsmartypants_cb__dquote, /* 4 */\n+\tsmartypants_cb__amp,\t/* 5 */\n+\tsmartypants_cb__period,\t/* 6 */\n+\tsmartypants_cb__number,\t/* 7 */\n+\tsmartypants_cb__ltag,\t/* 8 */\n+\tsmartypants_cb__backtick, /* 9 */\n+\tsmartypants_cb__escape, /* 10 */\n+};\n+\n+static const uint8_t smartypants_cb_chars[] = {\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 4, 0, 0, 0, 5, 3, 2, 0, 0, 0, 0, 1, 6, 0,\n+\t0, 7, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 8, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10, 0, 0, 0,\n+\t9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+\t0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+};\n+\n+static inline int\n+word_boundary(uint8_t c)\n+{\n+\treturn c == 0 || isspace(c) || ispunct(c);\n+}\n+\n+static int\n+smartypants_quotes(struct buf *ob, uint8_t previous_char, uint8_t next_char, uint8_t quote, int *is_open)\n+{\n+\tchar ent[8];\n+\n+\tif (*is_open && !word_boundary(next_char))\n+\t\treturn 0;\n+\n+\tif (!(*is_open) && !word_boundary(previous_char))\n+\t\treturn 0;\n+\n+\tsnprintf(ent, sizeof(ent), \"&%c%cquo;\", (*is_open) ? 'r' : 'l', quote);\n+\t*is_open = !(*is_open);\n+\tbufputs(ob, ent);\n+\treturn 1;\n+}\n+\n+static size_t\n+smartypants_cb__squote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 2) {\n+\t\tuint8_t t1 = tolower(text[1]);\n+\n+\t\tif (t1 == '\\'') {\n+\t\t\tif (smartypants_quotes(ob, previous_char, size >= 3 ? text[2] : 0, 'd', &smrt->in_dquote))\n+\t\t\t\treturn 1;\n+\t\t}\n+\n+\t\tif ((t1 == 's' || t1 == 't' || t1 == 'm' || t1 == 'd') &&\n+\t\t\t(size == 3 || word_boundary(text[2]))) {\n+\t\t\tBUFPUTSL(ob, \"&rsquo;\");\n+\t\t\treturn 0;\n+\t\t}\n+\n+\t\tif (size >= 3) {\n+\t\t\tuint8_t t2 = tolower(text[2]);\n+\n+\t\t\tif (((t1 == 'r' && t2 == 'e') ||\n+\t\t\t\t(t1 == 'l' && t2 == 'l') ||\n+\t\t\t\t(t1 == 'v' && t2 == 'e')) &&\n+\t\t\t\t(size == 4 || word_boundary(text[3]))) {\n+\t\t\t\tBUFPUTSL(ob, \"&rsquo;\");\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif (smartypants_quotes(ob, previous_char, size > 0 ? text[1] : 0, 's', &smrt->in_squote))\n+\t\treturn 0;\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__parens(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 3) {\n+\t\tuint8_t t1 = tolower(text[1]);\n+\t\tuint8_t t2 = tolower(text[2]);\n+\n+\t\tif (t1 == 'c' && t2 == ')') {\n+\t\t\tBUFPUTSL(ob, \"&copy;\");\n+\t\t\treturn 2;\n+\t\t}\n+\n+\t\tif (t1 == 'r' && t2 == ')') {\n+\t\t\tBUFPUTSL(ob, \"&reg;\");\n+\t\t\treturn 2;\n+\t\t}\n+\n+\t\tif (size >= 4 && t1 == 't' && t2 == 'm' && text[3] == ')') {\n+\t\t\tBUFPUTSL(ob, \"&trade;\");\n+\t\t\treturn 3;\n+\t\t}\n+\t}\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__dash(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 3 && text[1] == '-' && text[2] == '-') {\n+\t\tBUFPUTSL(ob, \"&mdash;\");\n+\t\treturn 2;\n+\t}\n+\n+\tif (size >= 2 && text[1] == '-') {\n+\t\tBUFPUTSL(ob, \"&ndash;\");\n+\t\treturn 1;\n+\t}\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__amp(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 6 && memcmp(text, \"&quot;\", 6) == 0) {\n+\t\tif (smartypants_quotes(ob, previous_char, size >= 7 ? text[6] : 0, 'd', &smrt->in_dquote))\n+\t\t\treturn 5;\n+\t}\n+\n+\tif (size >= 4 && memcmp(text, \"&#0;\", 4) == 0)\n+\t\treturn 3;\n+\n+\tbufputc(ob, '&');\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__period(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 3 && text[1] == '.' && text[2] == '.') {\n+\t\tBUFPUTSL(ob, \"&hellip;\");\n+\t\treturn 2;\n+\t}\n+\n+\tif (size >= 5 && text[1] == ' ' && text[2] == '.' && text[3] == ' ' && text[4] == '.') {\n+\t\tBUFPUTSL(ob, \"&hellip;\");\n+\t\treturn 4;\n+\t}\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__backtick(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size >= 2 && text[1] == '`') {\n+\t\tif (smartypants_quotes(ob, previous_char, size >= 3 ? text[2] : 0, 'd', &smrt->in_dquote))\n+\t\t\treturn 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__number(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (word_boundary(previous_char) && size >= 3) {\n+\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '2') {\n+\t\t\tif (size == 3 || word_boundary(text[3])) {\n+\t\t\t\tBUFPUTSL(ob, \"&frac12;\");\n+\t\t\t\treturn 2;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (text[0] == '1' && text[1] == '/' && text[2] == '4') {\n+\t\t\tif (size == 3 || word_boundary(text[3]) ||\n+\t\t\t\t(size >= 5 && tolower(text[3]) == 't' && tolower(text[4]) == 'h')) {\n+\t\t\t\tBUFPUTSL(ob, \"&frac14;\");\n+\t\t\t\treturn 2;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (text[0] == '3' && text[1] == '/' && text[2] == '4') {\n+\t\t\tif (size == 3 || word_boundary(text[3]) ||\n+\t\t\t\t(size >= 6 && tolower(text[3]) == 't' && tolower(text[4]) == 'h' && tolower(text[5]) == 's')) {\n+\t\t\t\tBUFPUTSL(ob, \"&frac34;\");\n+\t\t\t\treturn 2;\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tbufputc(ob, text[0]);\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__dquote(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (!smartypants_quotes(ob, previous_char, size > 0 ? text[1] : 0, 'd', &smrt->in_dquote))\n+\t\tBUFPUTSL(ob, \"&quot;\");\n+\n+\treturn 0;\n+}\n+\n+static size_t\n+smartypants_cb__ltag(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tstatic const char *skip_tags[] = {\n+\t  \"pre\", \"code\", \"var\", \"samp\", \"kbd\", \"math\", \"script\", \"style\"\n+\t};\n+\tstatic const size_t skip_tags_count = 8;\n+\n+\tsize_t tag, i = 0;\n+\n+\twhile (i < size && text[i] != '>')\n+\t\ti++;\n+\n+\tfor (tag = 0; tag < skip_tags_count; ++tag) {\n+\t\tif (sdhtml_is_tag(text, size, skip_tags[tag]) == HTML_TAG_OPEN)\n+\t\t\tbreak;\n+\t}\n+\n+\tif (tag < skip_tags_count) {\n+\t\tfor (;;) {\n+\t\t\twhile (i < size && text[i] != '<')\n+\t\t\t\ti++;\n+\n+\t\t\tif (i == size)\n+\t\t\t\tbreak;\n+\n+\t\t\tif (sdhtml_is_tag(text + i, size - i, skip_tags[tag]) == HTML_TAG_CLOSE)\n+\t\t\t\tbreak;\n+\n+\t\t\ti++;\n+\t\t}\n+\n+\t\twhile (i < size && text[i] != '>')\n+\t\t\ti++;\n+\t}\n+\n+\tbufput(ob, text, i + 1);\n+\treturn i;\n+}\n+\n+static size_t\n+smartypants_cb__escape(struct buf *ob, struct smartypants_data *smrt, uint8_t previous_char, const uint8_t *text, size_t size)\n+{\n+\tif (size < 2)\n+\t\treturn 0;\n+\n+\tswitch (text[1]) {\n+\tcase '\\\\':\n+\tcase '\"':\n+\tcase '\\'':\n+\tcase '.':\n+\tcase '-':\n+\tcase '`':\n+\t\tbufputc(ob, text[1]);\n+\t\treturn 1;\n+\n+\tdefault:\n+\t\tbufputc(ob, '\\\\');\n+\t\treturn 0;\n+\t}\n+}\n+\n+#if 0\n+static struct {\n+    uint8_t c0;\n+    const uint8_t *pattern;\n+    const uint8_t *entity;\n+    int skip;\n+} smartypants_subs[] = {\n+    { '\\'', \"'s>\",      \"&rsquo;\",  0 },\n+    { '\\'', \"'t>\",      \"&rsquo;\",  0 },\n+    { '\\'', \"'re>\",     \"&rsquo;\",  0 },\n+    { '\\'', \"'ll>\",     \"&rsquo;\",  0 },\n+    { '\\'', \"'ve>\",     \"&rsquo;\",  0 },\n+    { '\\'', \"'m>\",      \"&rsquo;\",  0 },\n+    { '\\'', \"'d>\",      \"&rsquo;\",  0 },\n+    { '-',  \"--\",       \"&mdash;\",  1 },\n+    { '-',  \"<->\",      \"&ndash;\",  0 },\n+    { '.',  \"...\",      \"&hellip;\", 2 },\n+    { '.',  \". . .\",    \"&hellip;\", 4 },\n+    { '(',  \"(c)\",      \"&copy;\",   2 },\n+    { '(',  \"(r)\",      \"&reg;\",    2 },\n+    { '(',  \"(tm)\",     \"&trade;\",  3 },\n+    { '3',  \"<3/4>\",    \"&frac34;\", 2 },\n+    { '3',  \"<3/4ths>\", \"&frac34;\", 2 },\n+    { '1',  \"<1/2>\",    \"&frac12;\", 2 },\n+    { '1',  \"<1/4>\",    \"&frac14;\", 2 },\n+    { '1',  \"<1/4th>\",  \"&frac14;\", 2 },\n+    { '&',  \"&#0;\",      0,       3 },\n+};\n+#endif\n+\n+void\n+sdhtml_smartypants(struct buf *ob, const uint8_t *text, size_t size)\n+{\n+\tsize_t i;\n+\tstruct smartypants_data smrt = {0, 0};\n+\n+\tif (!text)\n+\t\treturn;\n+\n+\tbufgrow(ob, size);\n+\n+\tfor (i = 0; i < size; ++i) {\n+\t\tsize_t org;\n+\t\tuint8_t action = 0;\n+\n+\t\torg = i;\n+\t\twhile (i < size && (action = smartypants_cb_chars[text[i]]) == 0)\n+\t\t\ti++;\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, text + org, i - org);\n+\n+\t\tif (i < size) {\n+\t\t\ti += smartypants_cb_ptrs[(int)action]\n+\t\t\t\t(ob, &smrt, i ? text[i - 1] : 0, text + i, size - i);\n+\t\t}\n+\t}\n+}\n+\n+"}, {"sha": "a41d7d1b335025bc65a56526f04ca42050e297ec", "filename": "src/rt/sundown/html_block_names.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml_block_names.txt", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fhtml_block_names.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fhtml_block_names.txt?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,25 @@\n+##\n+p\n+dl\n+h1\n+h2\n+h3\n+h4\n+h5\n+h6\n+ol\n+ul\n+del\n+div\n+ins\n+pre\n+form\n+math\n+table\n+figure\n+iframe\n+script\n+style\n+fieldset\n+noscript\n+blockquote"}, {"sha": "6f8d6ab9902b597f3acd68d8f11749f88689bd8c", "filename": "src/rt/sundown/src/autolink.c", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fautolink.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fautolink.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fautolink.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,297 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"buffer.h\"\n+#include \"autolink.h\"\n+\n+#include <string.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+#if defined(_WIN32)\n+#define strncasecmp\t_strnicmp\n+#endif\n+\n+int\n+sd_autolink_issafe(const uint8_t *link, size_t link_len)\n+{\n+\tstatic const size_t valid_uris_count = 5;\n+\tstatic const char *valid_uris[] = {\n+\t\t\"/\", \"http://\", \"https://\", \"ftp://\", \"mailto:\"\n+\t};\n+\n+\tsize_t i;\n+\n+\tfor (i = 0; i < valid_uris_count; ++i) {\n+\t\tsize_t len = strlen(valid_uris[i]);\n+\n+\t\tif (link_len > len &&\n+\t\t\tstrncasecmp((char *)link, valid_uris[i], len) == 0 &&\n+\t\t\tisalnum(link[len]))\n+\t\t\treturn 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static size_t\n+autolink_delim(uint8_t *data, size_t link_end, size_t max_rewind, size_t size)\n+{\n+\tuint8_t cclose, copen = 0;\n+\tsize_t i;\n+\n+\tfor (i = 0; i < link_end; ++i)\n+\t\tif (data[i] == '<') {\n+\t\t\tlink_end = i;\n+\t\t\tbreak;\n+\t\t}\n+\n+\twhile (link_end > 0) {\n+\t\tif (strchr(\"?!.,\", data[link_end - 1]) != NULL)\n+\t\t\tlink_end--;\n+\n+\t\telse if (data[link_end - 1] == ';') {\n+\t\t\tsize_t new_end = link_end - 2;\n+\n+\t\t\twhile (new_end > 0 && isalpha(data[new_end]))\n+\t\t\t\tnew_end--;\n+\n+\t\t\tif (new_end < link_end - 2 && data[new_end] == '&')\n+\t\t\t\tlink_end = new_end;\n+\t\t\telse\n+\t\t\t\tlink_end--;\n+\t\t}\n+\t\telse break;\n+\t}\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\tcclose = data[link_end - 1];\n+\n+\tswitch (cclose) {\n+\tcase '\"':\tcopen = '\"'; break;\n+\tcase '\\'':\tcopen = '\\''; break;\n+\tcase ')':\tcopen = '('; break;\n+\tcase ']':\tcopen = '['; break;\n+\tcase '}':\tcopen = '{'; break;\n+\t}\n+\n+\tif (copen != 0) {\n+\t\tsize_t closing = 0;\n+\t\tsize_t opening = 0;\n+\t\tsize_t i = 0;\n+\n+\t\t/* Try to close the final punctuation sign in this same line;\n+\t\t * if we managed to close it outside of the URL, that means that it's\n+\t\t * not part of the URL. If it closes inside the URL, that means it\n+\t\t * is part of the URL.\n+\t\t *\n+\t\t * Examples:\n+\t\t *\n+\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric) bar\n+\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n+\t\t *\n+\t\t *\tfoo (http://www.pokemon.com/Pikachu_(Electric)) bar\n+\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric)\n+\t\t *\n+\t\t *\tfoo http://www.pokemon.com/Pikachu_(Electric)) bar\n+\t\t *\t\t=> http://www.pokemon.com/Pikachu_(Electric))\n+\t\t *\n+\t\t *\t(foo http://www.pokemon.com/Pikachu_(Electric)) bar\n+\t\t *\t\t=> foo http://www.pokemon.com/Pikachu_(Electric)\n+\t\t */\n+\n+\t\twhile (i < link_end) {\n+\t\t\tif (data[i] == copen)\n+\t\t\t\topening++;\n+\t\t\telse if (data[i] == cclose)\n+\t\t\t\tclosing++;\n+\n+\t\t\ti++;\n+\t\t}\n+\n+\t\tif (closing != opening)\n+\t\t\tlink_end--;\n+\t}\n+\n+\treturn link_end;\n+}\n+\n+static size_t\n+check_domain(uint8_t *data, size_t size, int allow_short)\n+{\n+\tsize_t i, np = 0;\n+\n+\tif (!isalnum(data[0]))\n+\t\treturn 0;\n+\n+\tfor (i = 1; i < size - 1; ++i) {\n+\t\tif (data[i] == '.') np++;\n+\t\telse if (!isalnum(data[i]) && data[i] != '-') break;\n+\t}\n+\n+\tif (allow_short) {\n+\t\t/* We don't need a valid domain in the strict sense (with\n+\t\t * least one dot; so just make sure it's composed of valid\n+\t\t * domain characters and return the length of the the valid\n+\t\t * sequence. */\n+\t\treturn i;\n+\t} else {\n+\t\t/* a valid domain needs to have at least a dot.\n+\t\t * that's as far as we get */\n+\t\treturn np ? i : 0;\n+\t}\n+}\n+\n+size_t\n+sd_autolink__www(\n+\tsize_t *rewind_p,\n+\tstruct buf *link,\n+\tuint8_t *data,\n+\tsize_t max_rewind,\n+\tsize_t size,\n+\tunsigned int flags)\n+{\n+\tsize_t link_end;\n+\n+\tif (max_rewind > 0 && !ispunct(data[-1]) && !isspace(data[-1]))\n+\t\treturn 0;\n+\n+\tif (size < 4 || memcmp(data, \"www.\", strlen(\"www.\")) != 0)\n+\t\treturn 0;\n+\n+\tlink_end = check_domain(data, size, 0);\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\twhile (link_end < size && !isspace(data[link_end]))\n+\t\tlink_end++;\n+\n+\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\tbufput(link, data, link_end);\n+\t*rewind_p = 0;\n+\n+\treturn (int)link_end;\n+}\n+\n+size_t\n+sd_autolink__email(\n+\tsize_t *rewind_p,\n+\tstruct buf *link,\n+\tuint8_t *data,\n+\tsize_t max_rewind,\n+\tsize_t size,\n+\tunsigned int flags)\n+{\n+\tsize_t link_end, rewind;\n+\tint nb = 0, np = 0;\n+\n+\tfor (rewind = 0; rewind < max_rewind; ++rewind) {\n+\t\tuint8_t c = data[-rewind - 1];\n+\n+\t\tif (isalnum(c))\n+\t\t\tcontinue;\n+\n+\t\tif (strchr(\".+-_\", c) != NULL)\n+\t\t\tcontinue;\n+\n+\t\tbreak;\n+\t}\n+\n+\tif (rewind == 0)\n+\t\treturn 0;\n+\n+\tfor (link_end = 0; link_end < size; ++link_end) {\n+\t\tuint8_t c = data[link_end];\n+\n+\t\tif (isalnum(c))\n+\t\t\tcontinue;\n+\n+\t\tif (c == '@')\n+\t\t\tnb++;\n+\t\telse if (c == '.' && link_end < size - 1)\n+\t\t\tnp++;\n+\t\telse if (c != '-' && c != '_')\n+\t\t\tbreak;\n+\t}\n+\n+\tif (link_end < 2 || nb != 1 || np == 0 ||\n+\t\t!isalpha(data[link_end - 1]))\n+\t\treturn 0;\n+\n+\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\tbufput(link, data - rewind, link_end + rewind);\n+\t*rewind_p = rewind;\n+\n+\treturn link_end;\n+}\n+\n+size_t\n+sd_autolink__url(\n+\tsize_t *rewind_p,\n+\tstruct buf *link,\n+\tuint8_t *data,\n+\tsize_t max_rewind,\n+\tsize_t size,\n+\tunsigned int flags)\n+{\n+\tsize_t link_end, rewind = 0, domain_len;\n+\n+\tif (size < 4 || data[1] != '/' || data[2] != '/')\n+\t\treturn 0;\n+\n+\twhile (rewind < max_rewind && isalpha(data[-rewind - 1]))\n+\t\trewind++;\n+\n+\tif (!sd_autolink_issafe(data - rewind, size + rewind))\n+\t\treturn 0;\n+\n+\tlink_end = strlen(\"://\");\n+\n+\tdomain_len = check_domain(\n+\t\tdata + link_end,\n+\t\tsize - link_end,\n+\t\tflags & SD_AUTOLINK_SHORT_DOMAINS);\n+\n+\tif (domain_len == 0)\n+\t\treturn 0;\n+\n+\tlink_end += domain_len;\n+\twhile (link_end < size && !isspace(data[link_end]))\n+\t\tlink_end++;\n+\n+\tlink_end = autolink_delim(data, link_end, max_rewind, size);\n+\n+\tif (link_end == 0)\n+\t\treturn 0;\n+\n+\tbufput(link, data - rewind, link_end + rewind);\n+\t*rewind_p = rewind;\n+\n+\treturn link_end;\n+}\n+"}, {"sha": "65e0fe6f14489ae62085933d58ea6bec86f06e93", "filename": "src/rt/sundown/src/autolink.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fautolink.h", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fautolink.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fautolink.h?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef UPSKIRT_AUTOLINK_H\n+#define UPSKIRT_AUTOLINK_H\n+\n+#include \"buffer.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+enum {\n+\tSD_AUTOLINK_SHORT_DOMAINS = (1 << 0),\n+};\n+\n+int\n+sd_autolink_issafe(const uint8_t *link, size_t link_len);\n+\n+size_t\n+sd_autolink__www(size_t *rewind_p, struct buf *link,\n+\tuint8_t *data, size_t offset, size_t size, unsigned int flags);\n+\n+size_t\n+sd_autolink__email(size_t *rewind_p, struct buf *link,\n+\tuint8_t *data, size_t offset, size_t size, unsigned int flags);\n+\n+size_t\n+sd_autolink__url(size_t *rewind_p, struct buf *link,\n+\tuint8_t *data, size_t offset, size_t size, unsigned int flags);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+\n+/* vim: set filetype=c: */"}, {"sha": "47b40ce2f75e75d42756a386d29431b6de674b7a", "filename": "src/rt/sundown/src/buffer.c", "status": "added", "additions": 225, "deletions": 0, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright (c) 2008, Natacha Port\u00e9\n+ * Copyright (c) 2011, Vicent Mart\u00ed\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#define BUFFER_MAX_ALLOC_SIZE (1024 * 1024 * 16) //16mb\n+\n+#include \"buffer.h\"\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <string.h>\n+#include <assert.h>\n+\n+/* MSVC compat */\n+#if defined(_MSC_VER)\n+#\tdefine _buf_vsnprintf _vsnprintf\n+#else\n+#\tdefine _buf_vsnprintf vsnprintf\n+#endif\n+\n+int\n+bufprefix(const struct buf *buf, const char *prefix)\n+{\n+\tsize_t i;\n+\tassert(buf && buf->unit);\n+\n+\tfor (i = 0; i < buf->size; ++i) {\n+\t\tif (prefix[i] == 0)\n+\t\t\treturn 0;\n+\n+\t\tif (buf->data[i] != prefix[i])\n+\t\t\treturn buf->data[i] - prefix[i];\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* bufgrow: increasing the allocated size to the given value */\n+int\n+bufgrow(struct buf *buf, size_t neosz)\n+{\n+\tsize_t neoasz;\n+\tvoid *neodata;\n+\n+\tassert(buf && buf->unit);\n+\n+\tif (neosz > BUFFER_MAX_ALLOC_SIZE)\n+\t\treturn BUF_ENOMEM;\n+\n+\tif (buf->asize >= neosz)\n+\t\treturn BUF_OK;\n+\n+\tneoasz = buf->asize + buf->unit;\n+\twhile (neoasz < neosz)\n+\t\tneoasz += buf->unit;\n+\n+\tneodata = realloc(buf->data, neoasz);\n+\tif (!neodata)\n+\t\treturn BUF_ENOMEM;\n+\n+\tbuf->data = neodata;\n+\tbuf->asize = neoasz;\n+\treturn BUF_OK;\n+}\n+\n+\n+/* bufnew: allocation of a new buffer */\n+struct buf *\n+bufnew(size_t unit)\n+{\n+\tstruct buf *ret;\n+\tret = malloc(sizeof (struct buf));\n+\n+\tif (ret) {\n+\t\tret->data = 0;\n+\t\tret->size = ret->asize = 0;\n+\t\tret->unit = unit;\n+\t}\n+\treturn ret;\n+}\n+\n+/* bufnullterm: NULL-termination of the string array */\n+const char *\n+bufcstr(struct buf *buf)\n+{\n+\tassert(buf && buf->unit);\n+\n+\tif (buf->size < buf->asize && buf->data[buf->size] == 0)\n+\t\treturn (char *)buf->data;\n+\n+\tif (buf->size + 1 <= buf->asize || bufgrow(buf, buf->size + 1) == 0) {\n+\t\tbuf->data[buf->size] = 0;\n+\t\treturn (char *)buf->data;\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+/* bufprintf: formatted printing to a buffer */\n+void\n+bufprintf(struct buf *buf, const char *fmt, ...)\n+{\n+\tva_list ap;\n+\tint n;\n+\n+\tassert(buf && buf->unit);\n+\n+\tif (buf->size >= buf->asize && bufgrow(buf, buf->size + 1) < 0)\n+\t\treturn;\n+\t\n+\tva_start(ap, fmt);\n+\tn = _buf_vsnprintf((char *)buf->data + buf->size, buf->asize - buf->size, fmt, ap);\n+\tva_end(ap);\n+\n+\tif (n < 0) {\n+#ifdef _MSC_VER\n+\t\tva_start(ap, fmt);\n+\t\tn = _vscprintf(fmt, ap);\n+\t\tva_end(ap);\n+#else\n+\t\treturn;\n+#endif\n+\t}\n+\n+\tif ((size_t)n >= buf->asize - buf->size) {\n+\t\tif (bufgrow(buf, buf->size + n + 1) < 0)\n+\t\t\treturn;\n+\n+\t\tva_start(ap, fmt);\n+\t\tn = _buf_vsnprintf((char *)buf->data + buf->size, buf->asize - buf->size, fmt, ap);\n+\t\tva_end(ap);\n+\t}\n+\n+\tif (n < 0)\n+\t\treturn;\n+\n+\tbuf->size += n;\n+}\n+\n+/* bufput: appends raw data to a buffer */\n+void\n+bufput(struct buf *buf, const void *data, size_t len)\n+{\n+\tassert(buf && buf->unit);\n+\n+\tif (buf->size + len > buf->asize && bufgrow(buf, buf->size + len) < 0)\n+\t\treturn;\n+\n+\tmemcpy(buf->data + buf->size, data, len);\n+\tbuf->size += len;\n+}\n+\n+/* bufputs: appends a NUL-terminated string to a buffer */\n+void\n+bufputs(struct buf *buf, const char *str)\n+{\n+\tbufput(buf, str, strlen(str));\n+}\n+\n+\n+/* bufputc: appends a single uint8_t to a buffer */\n+void\n+bufputc(struct buf *buf, int c)\n+{\n+\tassert(buf && buf->unit);\n+\n+\tif (buf->size + 1 > buf->asize && bufgrow(buf, buf->size + 1) < 0)\n+\t\treturn;\n+\n+\tbuf->data[buf->size] = c;\n+\tbuf->size += 1;\n+}\n+\n+/* bufrelease: decrease the reference count and free the buffer if needed */\n+void\n+bufrelease(struct buf *buf)\n+{\n+\tif (!buf)\n+\t\treturn;\n+\n+\tfree(buf->data);\n+\tfree(buf);\n+}\n+\n+\n+/* bufreset: frees internal data of the buffer */\n+void\n+bufreset(struct buf *buf)\n+{\n+\tif (!buf)\n+\t\treturn;\n+\n+\tfree(buf->data);\n+\tbuf->data = NULL;\n+\tbuf->size = buf->asize = 0;\n+}\n+\n+/* bufslurp: removes a given number of bytes from the head of the array */\n+void\n+bufslurp(struct buf *buf, size_t len)\n+{\n+\tassert(buf && buf->unit);\n+\n+\tif (len >= buf->size) {\n+\t\tbuf->size = 0;\n+\t\treturn;\n+\t}\n+\n+\tbuf->size -= len;\n+\tmemmove(buf->data, buf->data + len, buf->size);\n+}\n+"}, {"sha": "221d142eda337547db55266e1705021964cdd4c9", "filename": "src/rt/sundown/src/buffer.h", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.h", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fbuffer.h?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright (c) 2008, Natacha Port\u00e9\n+ * Copyright (c) 2011, Vicent Mart\u00ed\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef BUFFER_H__\n+#define BUFFER_H__\n+\n+#include <stddef.h>\n+#include <stdarg.h>\n+#include <stdint.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#if defined(_MSC_VER)\n+#define __attribute__(x)\n+#define inline\n+#endif\n+\n+typedef enum {\n+\tBUF_OK = 0,\n+\tBUF_ENOMEM = -1,\n+} buferror_t;\n+\n+/* struct buf: character array buffer */\n+struct buf {\n+\tuint8_t *data;\t\t/* actual character data */\n+\tsize_t size;\t/* size of the string */\n+\tsize_t asize;\t/* allocated size (0 = volatile buffer) */\n+\tsize_t unit;\t/* reallocation unit size (0 = read-only buffer) */\n+};\n+\n+/* CONST_BUF: global buffer from a string litteral */\n+#define BUF_STATIC(string) \\\n+\t{ (uint8_t *)string, sizeof string -1, sizeof string, 0, 0 }\n+\n+/* VOLATILE_BUF: macro for creating a volatile buffer on the stack */\n+#define BUF_VOLATILE(strname) \\\n+\t{ (uint8_t *)strname, strlen(strname), 0, 0, 0 }\n+\n+/* BUFPUTSL: optimized bufputs of a string litteral */\n+#define BUFPUTSL(output, literal) \\\n+\tbufput(output, literal, sizeof literal - 1)\n+\n+/* bufgrow: increasing the allocated size to the given value */\n+int bufgrow(struct buf *, size_t);\n+\n+/* bufnew: allocation of a new buffer */\n+struct buf *bufnew(size_t) __attribute__ ((malloc));\n+\n+/* bufnullterm: NUL-termination of the string array (making a C-string) */\n+const char *bufcstr(struct buf *);\n+\n+/* bufprefix: compare the beginning of a buffer with a string */\n+int bufprefix(const struct buf *buf, const char *prefix);\n+\n+/* bufput: appends raw data to a buffer */\n+void bufput(struct buf *, const void *, size_t);\n+\n+/* bufputs: appends a NUL-terminated string to a buffer */\n+void bufputs(struct buf *, const char *);\n+\n+/* bufputc: appends a single char to a buffer */\n+void bufputc(struct buf *, int);\n+\n+/* bufrelease: decrease the reference count and free the buffer if needed */\n+void bufrelease(struct buf *);\n+\n+/* bufreset: frees internal data of the buffer */\n+void bufreset(struct buf *);\n+\n+/* bufslurp: removes a given number of bytes from the head of the array */\n+void bufslurp(struct buf *, size_t);\n+\n+/* bufprintf: formatted printing to a buffer */\n+void bufprintf(struct buf *, const char *, ...) __attribute__ ((format (printf, 2, 3)));\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "09a758fe275f701010582a44bbc01a1905554a98", "filename": "src/rt/sundown/src/html_blocks.h", "status": "added", "additions": 206, "deletions": 0, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fhtml_blocks.h", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fhtml_blocks.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fhtml_blocks.h?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,206 @@\n+/* C code produced by gperf version 3.0.3 */\n+/* Command-line: gperf -N find_block_tag -H hash_block_tag -C -c -E --ignore-case html_block_names.txt  */\n+/* Computed positions: -k'1-2' */\n+\n+#if !((' ' == 32) && ('!' == 33) && ('\"' == 34) && ('#' == 35) \\\n+      && ('%' == 37) && ('&' == 38) && ('\\'' == 39) && ('(' == 40) \\\n+      && (')' == 41) && ('*' == 42) && ('+' == 43) && (',' == 44) \\\n+      && ('-' == 45) && ('.' == 46) && ('/' == 47) && ('0' == 48) \\\n+      && ('1' == 49) && ('2' == 50) && ('3' == 51) && ('4' == 52) \\\n+      && ('5' == 53) && ('6' == 54) && ('7' == 55) && ('8' == 56) \\\n+      && ('9' == 57) && (':' == 58) && (';' == 59) && ('<' == 60) \\\n+      && ('=' == 61) && ('>' == 62) && ('?' == 63) && ('A' == 65) \\\n+      && ('B' == 66) && ('C' == 67) && ('D' == 68) && ('E' == 69) \\\n+      && ('F' == 70) && ('G' == 71) && ('H' == 72) && ('I' == 73) \\\n+      && ('J' == 74) && ('K' == 75) && ('L' == 76) && ('M' == 77) \\\n+      && ('N' == 78) && ('O' == 79) && ('P' == 80) && ('Q' == 81) \\\n+      && ('R' == 82) && ('S' == 83) && ('T' == 84) && ('U' == 85) \\\n+      && ('V' == 86) && ('W' == 87) && ('X' == 88) && ('Y' == 89) \\\n+      && ('Z' == 90) && ('[' == 91) && ('\\\\' == 92) && (']' == 93) \\\n+      && ('^' == 94) && ('_' == 95) && ('a' == 97) && ('b' == 98) \\\n+      && ('c' == 99) && ('d' == 100) && ('e' == 101) && ('f' == 102) \\\n+      && ('g' == 103) && ('h' == 104) && ('i' == 105) && ('j' == 106) \\\n+      && ('k' == 107) && ('l' == 108) && ('m' == 109) && ('n' == 110) \\\n+      && ('o' == 111) && ('p' == 112) && ('q' == 113) && ('r' == 114) \\\n+      && ('s' == 115) && ('t' == 116) && ('u' == 117) && ('v' == 118) \\\n+      && ('w' == 119) && ('x' == 120) && ('y' == 121) && ('z' == 122) \\\n+      && ('{' == 123) && ('|' == 124) && ('}' == 125) && ('~' == 126))\n+/* The character set is not based on ISO-646.  */\n+error \"gperf generated tables don't work with this execution character set. Please report a bug to <bug-gnu-gperf@gnu.org>.\"\n+#endif\n+\n+/* maximum key range = 37, duplicates = 0 */\n+\n+#ifndef GPERF_DOWNCASE\n+#define GPERF_DOWNCASE 1\n+static unsigned char gperf_downcase[256] =\n+  {\n+      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,\n+     15,  16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,\n+     30,  31,  32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,\n+     45,  46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,\n+     60,  61,  62,  63,  64,  97,  98,  99, 100, 101, 102, 103, 104, 105, 106,\n+    107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121,\n+    122,  91,  92,  93,  94,  95,  96,  97,  98,  99, 100, 101, 102, 103, 104,\n+    105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119,\n+    120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134,\n+    135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n+    150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164,\n+    165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179,\n+    180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194,\n+    195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,\n+    210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224,\n+    225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,\n+    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,\n+    255\n+  };\n+#endif\n+\n+#ifndef GPERF_CASE_STRNCMP\n+#define GPERF_CASE_STRNCMP 1\n+static int\n+gperf_case_strncmp (s1, s2, n)\n+     register const char *s1;\n+     register const char *s2;\n+     register unsigned int n;\n+{\n+  for (; n > 0;)\n+    {\n+      unsigned char c1 = gperf_downcase[(unsigned char)*s1++];\n+      unsigned char c2 = gperf_downcase[(unsigned char)*s2++];\n+      if (c1 != 0 && c1 == c2)\n+        {\n+          n--;\n+          continue;\n+        }\n+      return (int)c1 - (int)c2;\n+    }\n+  return 0;\n+}\n+#endif\n+\n+#ifdef __GNUC__\n+__inline\n+#else\n+#ifdef __cplusplus\n+inline\n+#endif\n+#endif\n+static unsigned int\n+hash_block_tag (str, len)\n+     register const char *str;\n+     register unsigned int len;\n+{\n+  static const unsigned char asso_values[] =\n+    {\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+       8, 30, 25, 20, 15, 10, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38,  0, 38,  0, 38,\n+       5,  5,  5, 15,  0, 38, 38,  0, 15, 10,\n+       0, 38, 38, 15,  0,  5, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38,  0, 38,\n+       0, 38,  5,  5,  5, 15,  0, 38, 38,  0,\n+      15, 10,  0, 38, 38, 15,  0,  5, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38, 38, 38, 38,\n+      38, 38, 38, 38, 38, 38, 38\n+    };\n+  register int hval = len;\n+\n+  switch (hval)\n+    {\n+      default:\n+        hval += asso_values[(unsigned char)str[1]+1];\n+      /*FALLTHROUGH*/\n+      case 1:\n+        hval += asso_values[(unsigned char)str[0]];\n+        break;\n+    }\n+  return hval;\n+}\n+\n+#ifdef __GNUC__\n+__inline\n+#ifdef __GNUC_STDC_INLINE__\n+__attribute__ ((__gnu_inline__))\n+#endif\n+#endif\n+const char *\n+find_block_tag (str, len)\n+     register const char *str;\n+     register unsigned int len;\n+{\n+  enum\n+    {\n+      TOTAL_KEYWORDS = 24,\n+      MIN_WORD_LENGTH = 1,\n+      MAX_WORD_LENGTH = 10,\n+      MIN_HASH_VALUE = 1,\n+      MAX_HASH_VALUE = 37\n+    };\n+\n+  static const char * const wordlist[] =\n+    {\n+      \"\",\n+      \"p\",\n+      \"dl\",\n+      \"div\",\n+      \"math\",\n+      \"table\",\n+      \"\",\n+      \"ul\",\n+      \"del\",\n+      \"form\",\n+      \"blockquote\",\n+      \"figure\",\n+      \"ol\",\n+      \"fieldset\",\n+      \"\",\n+      \"h1\",\n+      \"\",\n+      \"h6\",\n+      \"pre\",\n+      \"\", \"\",\n+      \"script\",\n+      \"h5\",\n+      \"noscript\",\n+      \"\",\n+      \"style\",\n+      \"iframe\",\n+      \"h4\",\n+      \"ins\",\n+      \"\", \"\", \"\",\n+      \"h3\",\n+      \"\", \"\", \"\", \"\",\n+      \"h2\"\n+    };\n+\n+  if (len <= MAX_WORD_LENGTH && len >= MIN_WORD_LENGTH)\n+    {\n+      register int key = hash_block_tag (str, len);\n+\n+      if (key <= MAX_HASH_VALUE && key >= 0)\n+        {\n+          register const char *s = wordlist[key];\n+\n+          if ((((unsigned char)*str ^ (unsigned char)*s) & ~32) == 0 && !gperf_case_strncmp (str, s, len) && s[len] == '\\0')\n+            return s;\n+        }\n+    }\n+  return 0;\n+}"}, {"sha": "ea3cf23253ad3fe07af31a047db75e4e4a1c017d", "filename": "src/rt/sundown/src/markdown.c", "status": "added", "additions": 2556, "deletions": 0, "changes": 2556, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,2556 @@\n+/* markdown.c - generic markdown parser */\n+\n+/*\n+ * Copyright (c) 2009, Natacha Port\u00e9\n+ * Copyright (c) 2011, Vicent Marti\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#include \"markdown.h\"\n+#include \"stack.h\"\n+\n+#include <assert.h>\n+#include <string.h>\n+#include <ctype.h>\n+#include <stdio.h>\n+\n+#if defined(_WIN32)\n+#define strncasecmp\t_strnicmp\n+#endif\n+\n+#define REF_TABLE_SIZE 8\n+\n+#define BUFFER_BLOCK 0\n+#define BUFFER_SPAN 1\n+\n+#define MKD_LI_END 8\t/* internal list flag */\n+\n+#define gperf_case_strncmp(s1, s2, n) strncasecmp(s1, s2, n)\n+#define GPERF_DOWNCASE 1\n+#define GPERF_CASE_STRNCMP 1\n+#include \"html_blocks.h\"\n+\n+/***************\n+ * LOCAL TYPES *\n+ ***************/\n+\n+/* link_ref: reference to a link */\n+struct link_ref {\n+\tunsigned int id;\n+\n+\tstruct buf *link;\n+\tstruct buf *title;\n+\n+\tstruct link_ref *next;\n+};\n+\n+/* char_trigger: function pointer to render active chars */\n+/*   returns the number of chars taken care of */\n+/*   data is the pointer of the beginning of the span */\n+/*   offset is the number of valid chars before data */\n+struct sd_markdown;\n+typedef size_t\n+(*char_trigger)(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+\n+static size_t char_emphasis(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_escape(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_autolink_url(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_autolink_email(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_autolink_www(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_link(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+static size_t char_superscript(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size);\n+\n+enum markdown_char_t {\n+\tMD_CHAR_NONE = 0,\n+\tMD_CHAR_EMPHASIS,\n+\tMD_CHAR_CODESPAN,\n+\tMD_CHAR_LINEBREAK,\n+\tMD_CHAR_LINK,\n+\tMD_CHAR_LANGLE,\n+\tMD_CHAR_ESCAPE,\n+\tMD_CHAR_ENTITITY,\n+\tMD_CHAR_AUTOLINK_URL,\n+\tMD_CHAR_AUTOLINK_EMAIL,\n+\tMD_CHAR_AUTOLINK_WWW,\n+\tMD_CHAR_SUPERSCRIPT,\n+};\n+\n+static char_trigger markdown_char_ptrs[] = {\n+\tNULL,\n+\t&char_emphasis,\n+\t&char_codespan,\n+\t&char_linebreak,\n+\t&char_link,\n+\t&char_langle_tag,\n+\t&char_escape,\n+\t&char_entity,\n+\t&char_autolink_url,\n+\t&char_autolink_email,\n+\t&char_autolink_www,\n+\t&char_superscript,\n+};\n+\n+/* render \u2022 structure containing one particular render */\n+struct sd_markdown {\n+\tstruct sd_callbacks\tcb;\n+\tvoid *opaque;\n+\n+\tstruct link_ref *refs[REF_TABLE_SIZE];\n+\tuint8_t active_char[256];\n+\tstruct stack work_bufs[2];\n+\tunsigned int ext_flags;\n+\tsize_t max_nesting;\n+\tint in_link_body;\n+};\n+\n+/***************************\n+ * HELPER FUNCTIONS *\n+ ***************************/\n+\n+static inline struct buf *\n+rndr_newbuf(struct sd_markdown *rndr, int type)\n+{\n+\tstatic const size_t buf_size[2] = {256, 64};\n+\tstruct buf *work = NULL;\n+\tstruct stack *pool = &rndr->work_bufs[type];\n+\n+\tif (pool->size < pool->asize &&\n+\t\tpool->item[pool->size] != NULL) {\n+\t\twork = pool->item[pool->size++];\n+\t\twork->size = 0;\n+\t} else {\n+\t\twork = bufnew(buf_size[type]);\n+\t\tstack_push(pool, work);\n+\t}\n+\n+\treturn work;\n+}\n+\n+static inline void\n+rndr_popbuf(struct sd_markdown *rndr, int type)\n+{\n+\trndr->work_bufs[type].size--;\n+}\n+\n+static void\n+unscape_text(struct buf *ob, struct buf *src)\n+{\n+\tsize_t i = 0, org;\n+\twhile (i < src->size) {\n+\t\torg = i;\n+\t\twhile (i < src->size && src->data[i] != '\\\\')\n+\t\t\ti++;\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, src->data + org, i - org);\n+\n+\t\tif (i + 1 >= src->size)\n+\t\t\tbreak;\n+\n+\t\tbufputc(ob, src->data[i + 1]);\n+\t\ti += 2;\n+\t}\n+}\n+\n+static unsigned int\n+hash_link_ref(const uint8_t *link_ref, size_t length)\n+{\n+\tsize_t i;\n+\tunsigned int hash = 0;\n+\n+\tfor (i = 0; i < length; ++i)\n+\t\thash = tolower(link_ref[i]) + (hash << 6) + (hash << 16) - hash;\n+\n+\treturn hash;\n+}\n+\n+static struct link_ref *\n+add_link_ref(\n+\tstruct link_ref **references,\n+\tconst uint8_t *name, size_t name_size)\n+{\n+\tstruct link_ref *ref = calloc(1, sizeof(struct link_ref));\n+\n+\tif (!ref)\n+\t\treturn NULL;\n+\n+\tref->id = hash_link_ref(name, name_size);\n+\tref->next = references[ref->id % REF_TABLE_SIZE];\n+\n+\treferences[ref->id % REF_TABLE_SIZE] = ref;\n+\treturn ref;\n+}\n+\n+static struct link_ref *\n+find_link_ref(struct link_ref **references, uint8_t *name, size_t length)\n+{\n+\tunsigned int hash = hash_link_ref(name, length);\n+\tstruct link_ref *ref = NULL;\n+\n+\tref = references[hash % REF_TABLE_SIZE];\n+\n+\twhile (ref != NULL) {\n+\t\tif (ref->id == hash)\n+\t\t\treturn ref;\n+\n+\t\tref = ref->next;\n+\t}\n+\n+\treturn NULL;\n+}\n+\n+static void\n+free_link_refs(struct link_ref **references)\n+{\n+\tsize_t i;\n+\n+\tfor (i = 0; i < REF_TABLE_SIZE; ++i) {\n+\t\tstruct link_ref *r = references[i];\n+\t\tstruct link_ref *next;\n+\n+\t\twhile (r) {\n+\t\t\tnext = r->next;\n+\t\t\tbufrelease(r->link);\n+\t\t\tbufrelease(r->title);\n+\t\t\tfree(r);\n+\t\t\tr = next;\n+\t\t}\n+\t}\n+}\n+\n+/*\n+ * Check whether a char is a Markdown space.\n+\n+ * Right now we only consider spaces the actual\n+ * space and a newline: tabs and carriage returns\n+ * are filtered out during the preprocessing phase.\n+ *\n+ * If we wanted to actually be UTF-8 compliant, we\n+ * should instead extract an Unicode codepoint from\n+ * this character and check for space properties.\n+ */\n+static inline int\n+_isspace(int c)\n+{\n+\treturn c == ' ' || c == '\\n';\n+}\n+\n+/****************************\n+ * INLINE PARSING FUNCTIONS *\n+ ****************************/\n+\n+/* is_mail_autolink \u2022 looks for the address part of a mail autolink and '>' */\n+/* this is less strict than the original markdown e-mail address matching */\n+static size_t\n+is_mail_autolink(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, nb = 0;\n+\n+\t/* address is assumed to be: [-@._a-zA-Z0-9]+ with exactly one '@' */\n+\tfor (i = 0; i < size; ++i) {\n+\t\tif (isalnum(data[i]))\n+\t\t\tcontinue;\n+\n+\t\tswitch (data[i]) {\n+\t\t\tcase '@':\n+\t\t\t\tnb++;\n+\n+\t\t\tcase '-':\n+\t\t\tcase '.':\n+\t\t\tcase '_':\n+\t\t\t\tbreak;\n+\n+\t\t\tcase '>':\n+\t\t\t\treturn (nb == 1) ? i + 1 : 0;\n+\n+\t\t\tdefault:\n+\t\t\t\treturn 0;\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* tag_length \u2022 returns the length of the given tag, or 0 is it's not valid */\n+static size_t\n+tag_length(uint8_t *data, size_t size, enum mkd_autolink *autolink)\n+{\n+\tsize_t i, j;\n+\n+\t/* a valid tag can't be shorter than 3 chars */\n+\tif (size < 3) return 0;\n+\n+\t/* begins with a '<' optionally followed by '/', followed by letter or number */\n+\tif (data[0] != '<') return 0;\n+\ti = (data[1] == '/') ? 2 : 1;\n+\n+\tif (!isalnum(data[i]))\n+\t\treturn 0;\n+\n+\t/* scheme test */\n+\t*autolink = MKDA_NOT_AUTOLINK;\n+\n+\t/* try to find the beginning of an URI */\n+\twhile (i < size && (isalnum(data[i]) || data[i] == '.' || data[i] == '+' || data[i] == '-'))\n+\t\ti++;\n+\n+\tif (i > 1 && data[i] == '@') {\n+\t\tif ((j = is_mail_autolink(data + i, size - i)) != 0) {\n+\t\t\t*autolink = MKDA_EMAIL;\n+\t\t\treturn i + j;\n+\t\t}\n+\t}\n+\n+\tif (i > 2 && data[i] == ':') {\n+\t\t*autolink = MKDA_NORMAL;\n+\t\ti++;\n+\t}\n+\n+\t/* completing autolink test: no whitespace or ' or \" */\n+\tif (i >= size)\n+\t\t*autolink = MKDA_NOT_AUTOLINK;\n+\n+\telse if (*autolink) {\n+\t\tj = i;\n+\n+\t\twhile (i < size) {\n+\t\t\tif (data[i] == '\\\\') i += 2;\n+\t\t\telse if (data[i] == '>' || data[i] == '\\'' ||\n+\t\t\t\t\tdata[i] == '\"' || data[i] == ' ' || data[i] == '\\n')\n+\t\t\t\t\tbreak;\n+\t\t\telse i++;\n+\t\t}\n+\n+\t\tif (i >= size) return 0;\n+\t\tif (i > j && data[i] == '>') return i + 1;\n+\t\t/* one of the forbidden chars has been found */\n+\t\t*autolink = MKDA_NOT_AUTOLINK;\n+\t}\n+\n+\t/* looking for sometinhg looking like a tag end */\n+\twhile (i < size && data[i] != '>') i++;\n+\tif (i >= size) return 0;\n+\treturn i + 1;\n+}\n+\n+/* parse_inline \u2022 parses inline markdown elements */\n+static void\n+parse_inline(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, end = 0;\n+\tuint8_t action = 0;\n+\tstruct buf work = { 0, 0, 0, 0 };\n+\n+\tif (rndr->work_bufs[BUFFER_SPAN].size +\n+\t\trndr->work_bufs[BUFFER_BLOCK].size > rndr->max_nesting)\n+\t\treturn;\n+\n+\twhile (i < size) {\n+\t\t/* copying inactive chars into the output */\n+\t\twhile (end < size && (action = rndr->active_char[data[end]]) == 0) {\n+\t\t\tend++;\n+\t\t}\n+\n+\t\tif (rndr->cb.normal_text) {\n+\t\t\twork.data = data + i;\n+\t\t\twork.size = end - i;\n+\t\t\trndr->cb.normal_text(ob, &work, rndr->opaque);\n+\t\t}\n+\t\telse\n+\t\t\tbufput(ob, data + i, end - i);\n+\n+\t\tif (end >= size) break;\n+\t\ti = end;\n+\n+\t\tend = markdown_char_ptrs[(int)action](ob, rndr, data + i, i, size - i);\n+\t\tif (!end) /* no action from the callback */\n+\t\t\tend = i + 1;\n+\t\telse {\n+\t\t\ti += end;\n+\t\t\tend = i;\n+\t\t}\n+\t}\n+}\n+\n+/* find_emph_char \u2022 looks for the next emph uint8_t, skipping other constructs */\n+static size_t\n+find_emph_char(uint8_t *data, size_t size, uint8_t c)\n+{\n+\tsize_t i = 1;\n+\n+\twhile (i < size) {\n+\t\twhile (i < size && data[i] != c && data[i] != '`' && data[i] != '[')\n+\t\t\ti++;\n+\n+\t\tif (i == size)\n+\t\t\treturn 0;\n+\n+\t\tif (data[i] == c)\n+\t\t\treturn i;\n+\n+\t\t/* not counting escaped chars */\n+\t\tif (i && data[i - 1] == '\\\\') {\n+\t\t\ti++; continue;\n+\t\t}\n+\n+\t\tif (data[i] == '`') {\n+\t\t\tsize_t span_nb = 0, bt;\n+\t\t\tsize_t tmp_i = 0;\n+\n+\t\t\t/* counting the number of opening backticks */\n+\t\t\twhile (i < size && data[i] == '`') {\n+\t\t\t\ti++; span_nb++;\n+\t\t\t}\n+\n+\t\t\tif (i >= size) return 0;\n+\n+\t\t\t/* finding the matching closing sequence */\n+\t\t\tbt = 0;\n+\t\t\twhile (i < size && bt < span_nb) {\n+\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n+\t\t\t\tif (data[i] == '`') bt++;\n+\t\t\t\telse bt = 0;\n+\t\t\t\ti++;\n+\t\t\t}\n+\n+\t\t\tif (i >= size) return tmp_i;\n+\t\t}\n+\t\t/* skipping a link */\n+\t\telse if (data[i] == '[') {\n+\t\t\tsize_t tmp_i = 0;\n+\t\t\tuint8_t cc;\n+\n+\t\t\ti++;\n+\t\t\twhile (i < size && data[i] != ']') {\n+\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n+\t\t\t\ti++;\n+\t\t\t}\n+\n+\t\t\ti++;\n+\t\t\twhile (i < size && (data[i] == ' ' || data[i] == '\\n'))\n+\t\t\t\ti++;\n+\n+\t\t\tif (i >= size)\n+\t\t\t\treturn tmp_i;\n+\n+\t\t\tswitch (data[i]) {\n+\t\t\tcase '[':\n+\t\t\t\tcc = ']'; break;\n+\n+\t\t\tcase '(':\n+\t\t\t\tcc = ')'; break;\n+\n+\t\t\tdefault:\n+\t\t\t\tif (tmp_i)\n+\t\t\t\t\treturn tmp_i;\n+\t\t\t\telse\n+\t\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\ti++;\n+\t\t\twhile (i < size && data[i] != cc) {\n+\t\t\t\tif (!tmp_i && data[i] == c) tmp_i = i;\n+\t\t\t\ti++;\n+\t\t\t}\n+\n+\t\t\tif (i >= size)\n+\t\t\t\treturn tmp_i;\n+\n+\t\t\ti++;\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* parse_emph1 \u2022 parsing single emphase */\n+/* closed by a symbol not preceded by whitespace and not followed by symbol */\n+static size_t\n+parse_emph1(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n+{\n+\tsize_t i = 0, len;\n+\tstruct buf *work = 0;\n+\tint r;\n+\n+\tif (!rndr->cb.emphasis) return 0;\n+\n+\t/* skipping one symbol if coming from emph3 */\n+\tif (size > 1 && data[0] == c && data[1] == c) i = 1;\n+\n+\twhile (i < size) {\n+\t\tlen = find_emph_char(data + i, size - i, c);\n+\t\tif (!len) return 0;\n+\t\ti += len;\n+\t\tif (i >= size) return 0;\n+\n+\t\tif (data[i] == c && !_isspace(data[i - 1])) {\n+\n+\t\t\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n+\t\t\t\tif (i + 1 < size && isalnum(data[i + 1]))\n+\t\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tparse_inline(work, rndr, data, i);\n+\t\t\tr = rndr->cb.emphasis(ob, work, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t\treturn r ? i + 1 : 0;\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* parse_emph2 \u2022 parsing single emphase */\n+static size_t\n+parse_emph2(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n+{\n+\tint (*render_method)(struct buf *ob, const struct buf *text, void *opaque);\n+\tsize_t i = 0, len;\n+\tstruct buf *work = 0;\n+\tint r;\n+\n+\trender_method = (c == '~') ? rndr->cb.strikethrough : rndr->cb.double_emphasis;\n+\n+\tif (!render_method)\n+\t\treturn 0;\n+\n+\twhile (i < size) {\n+\t\tlen = find_emph_char(data + i, size - i, c);\n+\t\tif (!len) return 0;\n+\t\ti += len;\n+\n+\t\tif (i + 1 < size && data[i] == c && data[i + 1] == c && i && !_isspace(data[i - 1])) {\n+\t\t\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tparse_inline(work, rndr, data, i);\n+\t\t\tr = render_method(ob, work, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t\treturn r ? i + 2 : 0;\n+\t\t}\n+\t\ti++;\n+\t}\n+\treturn 0;\n+}\n+\n+/* parse_emph3 \u2022 parsing single emphase */\n+/* finds the first closing tag, and delegates to the other emph */\n+static size_t\n+parse_emph3(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, uint8_t c)\n+{\n+\tsize_t i = 0, len;\n+\tint r;\n+\n+\twhile (i < size) {\n+\t\tlen = find_emph_char(data + i, size - i, c);\n+\t\tif (!len) return 0;\n+\t\ti += len;\n+\n+\t\t/* skip whitespace preceded symbols */\n+\t\tif (data[i] != c || _isspace(data[i - 1]))\n+\t\t\tcontinue;\n+\n+\t\tif (i + 2 < size && data[i + 1] == c && data[i + 2] == c && rndr->cb.triple_emphasis) {\n+\t\t\t/* triple symbol found */\n+\t\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\t\t\tparse_inline(work, rndr, data, i);\n+\t\t\tr = rndr->cb.triple_emphasis(ob, work, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t\treturn r ? i + 3 : 0;\n+\n+\t\t} else if (i + 1 < size && data[i + 1] == c) {\n+\t\t\t/* double symbol found, handing over to emph1 */\n+\t\t\tlen = parse_emph1(ob, rndr, data - 2, size + 2, c);\n+\t\t\tif (!len) return 0;\n+\t\t\telse return len - 2;\n+\n+\t\t} else {\n+\t\t\t/* single symbol found, handing over to emph2 */\n+\t\t\tlen = parse_emph2(ob, rndr, data - 1, size + 1, c);\n+\t\t\tif (!len) return 0;\n+\t\t\telse return len - 1;\n+\t\t}\n+\t}\n+\treturn 0;\n+}\n+\n+/* char_emphasis \u2022 single and double emphasis parsing */\n+static size_t\n+char_emphasis(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tuint8_t c = data[0];\n+\tsize_t ret;\n+\n+\tif (rndr->ext_flags & MKDEXT_NO_INTRA_EMPHASIS) {\n+\t\tif (offset > 0 && !_isspace(data[-1]) && data[-1] != '>')\n+\t\t\treturn 0;\n+\t}\n+\n+\tif (size > 2 && data[1] != c) {\n+\t\t/* whitespace cannot follow an opening emphasis;\n+\t\t * strikethrough only takes two characters '~~' */\n+\t\tif (c == '~' || _isspace(data[1]) || (ret = parse_emph1(ob, rndr, data + 1, size - 1, c)) == 0)\n+\t\t\treturn 0;\n+\n+\t\treturn ret + 1;\n+\t}\n+\n+\tif (size > 3 && data[1] == c && data[2] != c) {\n+\t\tif (_isspace(data[2]) || (ret = parse_emph2(ob, rndr, data + 2, size - 2, c)) == 0)\n+\t\t\treturn 0;\n+\n+\t\treturn ret + 2;\n+\t}\n+\n+\tif (size > 4 && data[1] == c && data[2] == c && data[3] != c) {\n+\t\tif (c == '~' || _isspace(data[3]) || (ret = parse_emph3(ob, rndr, data + 3, size - 3, c)) == 0)\n+\t\t\treturn 0;\n+\n+\t\treturn ret + 3;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+\n+/* char_linebreak \u2022 '\\n' preceded by two spaces (assuming linebreak != 0) */\n+static size_t\n+char_linebreak(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tif (offset < 2 || data[-1] != ' ' || data[-2] != ' ')\n+\t\treturn 0;\n+\n+\t/* removing the last space from ob and rendering */\n+\twhile (ob->size && ob->data[ob->size - 1] == ' ')\n+\t\tob->size--;\n+\n+\treturn rndr->cb.linebreak(ob, rndr->opaque) ? 1 : 0;\n+}\n+\n+\n+/* char_codespan \u2022 '`' parsing a code span (assuming codespan != 0) */\n+static size_t\n+char_codespan(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tsize_t end, nb = 0, i, f_begin, f_end;\n+\n+\t/* counting the number of backticks in the delimiter */\n+\twhile (nb < size && data[nb] == '`')\n+\t\tnb++;\n+\n+\t/* finding the next delimiter */\n+\ti = 0;\n+\tfor (end = nb; end < size && i < nb; end++) {\n+\t\tif (data[end] == '`') i++;\n+\t\telse i = 0;\n+\t}\n+\n+\tif (i < nb && end >= size)\n+\t\treturn 0; /* no matching delimiter */\n+\n+\t/* trimming outside whitespaces */\n+\tf_begin = nb;\n+\twhile (f_begin < end && data[f_begin] == ' ')\n+\t\tf_begin++;\n+\n+\tf_end = end - nb;\n+\twhile (f_end > nb && data[f_end-1] == ' ')\n+\t\tf_end--;\n+\n+\t/* real code span */\n+\tif (f_begin < f_end) {\n+\t\tstruct buf work = { data + f_begin, f_end - f_begin, 0, 0 };\n+\t\tif (!rndr->cb.codespan(ob, &work, rndr->opaque))\n+\t\t\tend = 0;\n+\t} else {\n+\t\tif (!rndr->cb.codespan(ob, 0, rndr->opaque))\n+\t\t\tend = 0;\n+\t}\n+\n+\treturn end;\n+}\n+\n+\n+/* char_escape \u2022 '\\\\' backslash escape */\n+static size_t\n+char_escape(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tstatic const char *escape_chars = \"\\\\`*_{}[]()#+-.!:|&<>^~\";\n+\tstruct buf work = { 0, 0, 0, 0 };\n+\n+\tif (size > 1) {\n+\t\tif (strchr(escape_chars, data[1]) == NULL)\n+\t\t\treturn 0;\n+\n+\t\tif (rndr->cb.normal_text) {\n+\t\t\twork.data = data + 1;\n+\t\t\twork.size = 1;\n+\t\t\trndr->cb.normal_text(ob, &work, rndr->opaque);\n+\t\t}\n+\t\telse bufputc(ob, data[1]);\n+\t} else if (size == 1) {\n+\t\tbufputc(ob, data[0]);\n+\t}\n+\n+\treturn 2;\n+}\n+\n+/* char_entity \u2022 '&' escaped when it doesn't belong to an entity */\n+/* valid entities are assumed to be anything matching &#?[A-Za-z0-9]+; */\n+static size_t\n+char_entity(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tsize_t end = 1;\n+\tstruct buf work = { 0, 0, 0, 0 };\n+\n+\tif (end < size && data[end] == '#')\n+\t\tend++;\n+\n+\twhile (end < size && isalnum(data[end]))\n+\t\tend++;\n+\n+\tif (end < size && data[end] == ';')\n+\t\tend++; /* real entity */\n+\telse\n+\t\treturn 0; /* lone '&' */\n+\n+\tif (rndr->cb.entity) {\n+\t\twork.data = data;\n+\t\twork.size = end;\n+\t\trndr->cb.entity(ob, &work, rndr->opaque);\n+\t}\n+\telse bufput(ob, data, end);\n+\n+\treturn end;\n+}\n+\n+/* char_langle_tag \u2022 '<' when tags or autolinks are allowed */\n+static size_t\n+char_langle_tag(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tenum mkd_autolink altype = MKDA_NOT_AUTOLINK;\n+\tsize_t end = tag_length(data, size, &altype);\n+\tstruct buf work = { data, end, 0, 0 };\n+\tint ret = 0;\n+\n+\tif (end > 2) {\n+\t\tif (rndr->cb.autolink && altype != MKDA_NOT_AUTOLINK) {\n+\t\t\tstruct buf *u_link = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\twork.data = data + 1;\n+\t\t\twork.size = end - 2;\n+\t\t\tunscape_text(u_link, &work);\n+\t\t\tret = rndr->cb.autolink(ob, u_link, altype, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t}\n+\t\telse if (rndr->cb.raw_html_tag)\n+\t\t\tret = rndr->cb.raw_html_tag(ob, &work, rndr->opaque);\n+\t}\n+\n+\tif (!ret) return 0;\n+\telse return end;\n+}\n+\n+static size_t\n+char_autolink_www(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tstruct buf *link, *link_url, *link_text;\n+\tsize_t link_len, rewind;\n+\n+\tif (!rndr->cb.link || rndr->in_link_body)\n+\t\treturn 0;\n+\n+\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\tif ((link_len = sd_autolink__www(&rewind, link, data, offset, size, 0)) > 0) {\n+\t\tlink_url = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\tBUFPUTSL(link_url, \"http://\");\n+\t\tbufput(link_url, link->data, link->size);\n+\n+\t\tob->size -= rewind;\n+\t\tif (rndr->cb.normal_text) {\n+\t\t\tlink_text = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\trndr->cb.normal_text(link_text, link, rndr->opaque);\n+\t\t\trndr->cb.link(ob, link_url, NULL, link_text, rndr->opaque);\n+\t\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\t} else {\n+\t\t\trndr->cb.link(ob, link_url, NULL, link, rndr->opaque);\n+\t\t}\n+\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t}\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\treturn link_len;\n+}\n+\n+static size_t\n+char_autolink_email(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tstruct buf *link;\n+\tsize_t link_len, rewind;\n+\n+\tif (!rndr->cb.autolink || rndr->in_link_body)\n+\t\treturn 0;\n+\n+\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\tif ((link_len = sd_autolink__email(&rewind, link, data, offset, size, 0)) > 0) {\n+\t\tob->size -= rewind;\n+\t\trndr->cb.autolink(ob, link, MKDA_EMAIL, rndr->opaque);\n+\t}\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\treturn link_len;\n+}\n+\n+static size_t\n+char_autolink_url(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tstruct buf *link;\n+\tsize_t link_len, rewind;\n+\n+\tif (!rndr->cb.autolink || rndr->in_link_body)\n+\t\treturn 0;\n+\n+\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\tif ((link_len = sd_autolink__url(&rewind, link, data, offset, size, 0)) > 0) {\n+\t\tob->size -= rewind;\n+\t\trndr->cb.autolink(ob, link, MKDA_NORMAL, rndr->opaque);\n+\t}\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\treturn link_len;\n+}\n+\n+/* char_link \u2022 '[': parsing a link or an image */\n+static size_t\n+char_link(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tint is_img = (offset && data[-1] == '!'), level;\n+\tsize_t i = 1, txt_e, link_b = 0, link_e = 0, title_b = 0, title_e = 0;\n+\tstruct buf *content = 0;\n+\tstruct buf *link = 0;\n+\tstruct buf *title = 0;\n+\tstruct buf *u_link = 0;\n+\tsize_t org_work_size = rndr->work_bufs[BUFFER_SPAN].size;\n+\tint text_has_nl = 0, ret = 0;\n+\tint in_title = 0, qtype = 0;\n+\n+\t/* checking whether the correct renderer exists */\n+\tif ((is_img && !rndr->cb.image) || (!is_img && !rndr->cb.link))\n+\t\tgoto cleanup;\n+\n+\t/* looking for the matching closing bracket */\n+\tfor (level = 1; i < size; i++) {\n+\t\tif (data[i] == '\\n')\n+\t\t\ttext_has_nl = 1;\n+\n+\t\telse if (data[i - 1] == '\\\\')\n+\t\t\tcontinue;\n+\n+\t\telse if (data[i] == '[')\n+\t\t\tlevel++;\n+\n+\t\telse if (data[i] == ']') {\n+\t\t\tlevel--;\n+\t\t\tif (level <= 0)\n+\t\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tif (i >= size)\n+\t\tgoto cleanup;\n+\n+\ttxt_e = i;\n+\ti++;\n+\n+\t/* skip any amount of whitespace or newline */\n+\t/* (this is much more laxist than original markdown syntax) */\n+\twhile (i < size && _isspace(data[i]))\n+\t\ti++;\n+\n+\t/* inline style link */\n+\tif (i < size && data[i] == '(') {\n+\t\t/* skipping initial whitespace */\n+\t\ti++;\n+\n+\t\twhile (i < size && _isspace(data[i]))\n+\t\t\ti++;\n+\n+\t\tlink_b = i;\n+\n+\t\t/* looking for link end: ' \" ) */\n+\t\twhile (i < size) {\n+\t\t\tif (data[i] == '\\\\') i += 2;\n+\t\t\telse if (data[i] == ')') break;\n+\t\t\telse if (i >= 1 && _isspace(data[i-1]) && (data[i] == '\\'' || data[i] == '\"')) break;\n+\t\t\telse i++;\n+\t\t}\n+\n+\t\tif (i >= size) goto cleanup;\n+\t\tlink_e = i;\n+\n+\t\t/* looking for title end if present */\n+\t\tif (data[i] == '\\'' || data[i] == '\"') {\n+\t\t\tqtype = data[i];\n+\t\t\tin_title = 1;\n+\t\t\ti++;\n+\t\t\ttitle_b = i;\n+\n+\t\t\twhile (i < size) {\n+\t\t\t\tif (data[i] == '\\\\') i += 2;\n+\t\t\t\telse if (data[i] == qtype) {in_title = 0; i++;}\n+\t\t\t\telse if ((data[i] == ')') && !in_title) break;\n+\t\t\t\telse i++;\n+\t\t\t}\n+\n+\t\t\tif (i >= size) goto cleanup;\n+\n+\t\t\t/* skipping whitespaces after title */\n+\t\t\ttitle_e = i - 1;\n+\t\t\twhile (title_e > title_b && _isspace(data[title_e]))\n+\t\t\t\ttitle_e--;\n+\n+\t\t\t/* checking for closing quote presence */\n+\t\t\tif (data[title_e] != '\\'' &&  data[title_e] != '\"') {\n+\t\t\t\ttitle_b = title_e = 0;\n+\t\t\t\tlink_e = i;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* remove whitespace at the end of the link */\n+\t\twhile (link_e > link_b && _isspace(data[link_e - 1]))\n+\t\t\tlink_e--;\n+\n+\t\t/* remove optional angle brackets around the link */\n+\t\tif (data[link_b] == '<') link_b++;\n+\t\tif (data[link_e - 1] == '>') link_e--;\n+\n+\t\t/* building escaped link and title */\n+\t\tif (link_e > link_b) {\n+\t\t\tlink = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tbufput(link, data + link_b, link_e - link_b);\n+\t\t}\n+\n+\t\tif (title_e > title_b) {\n+\t\t\ttitle = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tbufput(title, data + title_b, title_e - title_b);\n+\t\t}\n+\n+\t\ti++;\n+\t}\n+\n+\t/* reference style link */\n+\telse if (i < size && data[i] == '[') {\n+\t\tstruct buf id = { 0, 0, 0, 0 };\n+\t\tstruct link_ref *lr;\n+\n+\t\t/* looking for the id */\n+\t\ti++;\n+\t\tlink_b = i;\n+\t\twhile (i < size && data[i] != ']') i++;\n+\t\tif (i >= size) goto cleanup;\n+\t\tlink_e = i;\n+\n+\t\t/* finding the link_ref */\n+\t\tif (link_b == link_e) {\n+\t\t\tif (text_has_nl) {\n+\t\t\t\tstruct buf *b = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\t\tsize_t j;\n+\n+\t\t\t\tfor (j = 1; j < txt_e; j++) {\n+\t\t\t\t\tif (data[j] != '\\n')\n+\t\t\t\t\t\tbufputc(b, data[j]);\n+\t\t\t\t\telse if (data[j - 1] != ' ')\n+\t\t\t\t\t\tbufputc(b, ' ');\n+\t\t\t\t}\n+\n+\t\t\t\tid.data = b->data;\n+\t\t\t\tid.size = b->size;\n+\t\t\t} else {\n+\t\t\t\tid.data = data + 1;\n+\t\t\t\tid.size = txt_e - 1;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tid.data = data + link_b;\n+\t\t\tid.size = link_e - link_b;\n+\t\t}\n+\n+\t\tlr = find_link_ref(rndr->refs, id.data, id.size);\n+\t\tif (!lr)\n+\t\t\tgoto cleanup;\n+\n+\t\t/* keeping link and title from link_ref */\n+\t\tlink = lr->link;\n+\t\ttitle = lr->title;\n+\t\ti++;\n+\t}\n+\n+\t/* shortcut reference style link */\n+\telse {\n+\t\tstruct buf id = { 0, 0, 0, 0 };\n+\t\tstruct link_ref *lr;\n+\n+\t\t/* crafting the id */\n+\t\tif (text_has_nl) {\n+\t\t\tstruct buf *b = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\t\tsize_t j;\n+\n+\t\t\tfor (j = 1; j < txt_e; j++) {\n+\t\t\t\tif (data[j] != '\\n')\n+\t\t\t\t\tbufputc(b, data[j]);\n+\t\t\t\telse if (data[j - 1] != ' ')\n+\t\t\t\t\tbufputc(b, ' ');\n+\t\t\t}\n+\n+\t\t\tid.data = b->data;\n+\t\t\tid.size = b->size;\n+\t\t} else {\n+\t\t\tid.data = data + 1;\n+\t\t\tid.size = txt_e - 1;\n+\t\t}\n+\n+\t\t/* finding the link_ref */\n+\t\tlr = find_link_ref(rndr->refs, id.data, id.size);\n+\t\tif (!lr)\n+\t\t\tgoto cleanup;\n+\n+\t\t/* keeping link and title from link_ref */\n+\t\tlink = lr->link;\n+\t\ttitle = lr->title;\n+\n+\t\t/* rewinding the whitespace */\n+\t\ti = txt_e + 1;\n+\t}\n+\n+\t/* building content: img alt is escaped, link content is parsed */\n+\tif (txt_e > 1) {\n+\t\tcontent = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\tif (is_img) {\n+\t\t\tbufput(content, data + 1, txt_e - 1);\n+\t\t} else {\n+\t\t\t/* disable autolinking when parsing inline the\n+\t\t\t * content of a link */\n+\t\t\trndr->in_link_body = 1;\n+\t\t\tparse_inline(content, rndr, data + 1, txt_e - 1);\n+\t\t\trndr->in_link_body = 0;\n+\t\t}\n+\t}\n+\n+\tif (link) {\n+\t\tu_link = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\tunscape_text(u_link, link);\n+\t}\n+\n+\t/* calling the relevant rendering function */\n+\tif (is_img) {\n+\t\tif (ob->size && ob->data[ob->size - 1] == '!')\n+\t\t\tob->size -= 1;\n+\n+\t\tret = rndr->cb.image(ob, u_link, title, content, rndr->opaque);\n+\t} else {\n+\t\tret = rndr->cb.link(ob, u_link, title, content, rndr->opaque);\n+\t}\n+\n+\t/* cleanup */\n+cleanup:\n+\trndr->work_bufs[BUFFER_SPAN].size = (int)org_work_size;\n+\treturn ret ? i : 0;\n+}\n+\n+static size_t\n+char_superscript(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t offset, size_t size)\n+{\n+\tsize_t sup_start, sup_len;\n+\tstruct buf *sup;\n+\n+\tif (!rndr->cb.superscript)\n+\t\treturn 0;\n+\n+\tif (size < 2)\n+\t\treturn 0;\n+\n+\tif (data[1] == '(') {\n+\t\tsup_start = sup_len = 2;\n+\n+\t\twhile (sup_len < size && data[sup_len] != ')' && data[sup_len - 1] != '\\\\')\n+\t\t\tsup_len++;\n+\n+\t\tif (sup_len == size)\n+\t\t\treturn 0;\n+\t} else {\n+\t\tsup_start = sup_len = 1;\n+\n+\t\twhile (sup_len < size && !_isspace(data[sup_len]))\n+\t\t\tsup_len++;\n+\t}\n+\n+\tif (sup_len - sup_start == 0)\n+\t\treturn (sup_start == 2) ? 3 : 0;\n+\n+\tsup = rndr_newbuf(rndr, BUFFER_SPAN);\n+\tparse_inline(sup, rndr, data + sup_start, sup_len - sup_start);\n+\trndr->cb.superscript(ob, sup, rndr->opaque);\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\n+\treturn (sup_start == 2) ? sup_len + 1 : sup_len;\n+}\n+\n+/*********************************\n+ * BLOCK-LEVEL PARSING FUNCTIONS *\n+ *********************************/\n+\n+/* is_empty \u2022 returns the line length when it is empty, 0 otherwise */\n+static size_t\n+is_empty(uint8_t *data, size_t size)\n+{\n+\tsize_t i;\n+\n+\tfor (i = 0; i < size && data[i] != '\\n'; i++)\n+\t\tif (data[i] != ' ')\n+\t\t\treturn 0;\n+\n+\treturn i + 1;\n+}\n+\n+/* is_hrule \u2022 returns whether a line is a horizontal rule */\n+static int\n+is_hrule(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, n = 0;\n+\tuint8_t c;\n+\n+\t/* skipping initial spaces */\n+\tif (size < 3) return 0;\n+\tif (data[0] == ' ') { i++;\n+\tif (data[1] == ' ') { i++;\n+\tif (data[2] == ' ') { i++; } } }\n+\n+\t/* looking at the hrule uint8_t */\n+\tif (i + 2 >= size\n+\t|| (data[i] != '*' && data[i] != '-' && data[i] != '_'))\n+\t\treturn 0;\n+\tc = data[i];\n+\n+\t/* the whole line must be the char or whitespace */\n+\twhile (i < size && data[i] != '\\n') {\n+\t\tif (data[i] == c) n++;\n+\t\telse if (data[i] != ' ')\n+\t\t\treturn 0;\n+\n+\t\ti++;\n+\t}\n+\n+\treturn n >= 3;\n+}\n+\n+/* check if a line begins with a code fence; return the\n+ * width of the code fence */\n+static size_t\n+prefix_codefence(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, n = 0;\n+\tuint8_t c;\n+\n+\t/* skipping initial spaces */\n+\tif (size < 3) return 0;\n+\tif (data[0] == ' ') { i++;\n+\tif (data[1] == ' ') { i++;\n+\tif (data[2] == ' ') { i++; } } }\n+\n+\t/* looking at the hrule uint8_t */\n+\tif (i + 2 >= size || !(data[i] == '~' || data[i] == '`'))\n+\t\treturn 0;\n+\n+\tc = data[i];\n+\n+\t/* the whole line must be the uint8_t or whitespace */\n+\twhile (i < size && data[i] == c) {\n+\t\tn++; i++;\n+\t}\n+\n+\tif (n < 3)\n+\t\treturn 0;\n+\n+\treturn i;\n+}\n+\n+/* check if a line is a code fence; return its size if it is */\n+static size_t\n+is_codefence(uint8_t *data, size_t size, struct buf *syntax)\n+{\n+\tsize_t i = 0, syn_len = 0;\n+\tuint8_t *syn_start;\n+\n+\ti = prefix_codefence(data, size);\n+\tif (i == 0)\n+\t\treturn 0;\n+\n+\twhile (i < size && data[i] == ' ')\n+\t\ti++;\n+\n+\tsyn_start = data + i;\n+\n+\tif (i < size && data[i] == '{') {\n+\t\ti++; syn_start++;\n+\n+\t\twhile (i < size && data[i] != '}' && data[i] != '\\n') {\n+\t\t\tsyn_len++; i++;\n+\t\t}\n+\n+\t\tif (i == size || data[i] != '}')\n+\t\t\treturn 0;\n+\n+\t\t/* strip all whitespace at the beginning and the end\n+\t\t * of the {} block */\n+\t\twhile (syn_len > 0 && _isspace(syn_start[0])) {\n+\t\t\tsyn_start++; syn_len--;\n+\t\t}\n+\n+\t\twhile (syn_len > 0 && _isspace(syn_start[syn_len - 1]))\n+\t\t\tsyn_len--;\n+\n+\t\ti++;\n+\t} else {\n+\t\twhile (i < size && !_isspace(data[i])) {\n+\t\t\tsyn_len++; i++;\n+\t\t}\n+\t}\n+\n+\tif (syntax) {\n+\t\tsyntax->data = syn_start;\n+\t\tsyntax->size = syn_len;\n+\t}\n+\n+\twhile (i < size && data[i] != '\\n') {\n+\t\tif (!_isspace(data[i]))\n+\t\t\treturn 0;\n+\n+\t\ti++;\n+\t}\n+\n+\treturn i + 1;\n+}\n+\n+/* is_atxheader \u2022 returns whether the line is a hash-prefixed header */\n+static int\n+is_atxheader(struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tif (data[0] != '#')\n+\t\treturn 0;\n+\n+\tif (rndr->ext_flags & MKDEXT_SPACE_HEADERS) {\n+\t\tsize_t level = 0;\n+\n+\t\twhile (level < size && level < 6 && data[level] == '#')\n+\t\t\tlevel++;\n+\n+\t\tif (level < size && data[level] != ' ')\n+\t\t\treturn 0;\n+\t}\n+\n+\treturn 1;\n+}\n+\n+/* is_headerline \u2022 returns whether the line is a setext-style hdr underline */\n+static int\n+is_headerline(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\n+\t/* test of level 1 header */\n+\tif (data[i] == '=') {\n+\t\tfor (i = 1; i < size && data[i] == '='; i++);\n+\t\twhile (i < size && data[i] == ' ') i++;\n+\t\treturn (i >= size || data[i] == '\\n') ? 1 : 0; }\n+\n+\t/* test of level 2 header */\n+\tif (data[i] == '-') {\n+\t\tfor (i = 1; i < size && data[i] == '-'; i++);\n+\t\twhile (i < size && data[i] == ' ') i++;\n+\t\treturn (i >= size || data[i] == '\\n') ? 2 : 0; }\n+\n+\treturn 0;\n+}\n+\n+static int\n+is_next_headerline(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\n+\twhile (i < size && data[i] != '\\n')\n+\t\ti++;\n+\n+\tif (++i >= size)\n+\t\treturn 0;\n+\n+\treturn is_headerline(data + i, size - i);\n+}\n+\n+/* prefix_quote \u2022 returns blockquote prefix length */\n+static size_t\n+prefix_quote(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\n+\tif (i < size && data[i] == '>') {\n+\t\tif (i + 1 < size && data[i + 1] == ' ')\n+\t\t\treturn i + 2;\n+\n+\t\treturn i + 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+/* prefix_code \u2022 returns prefix length for block code*/\n+static size_t\n+prefix_code(uint8_t *data, size_t size)\n+{\n+\tif (size > 3 && data[0] == ' ' && data[1] == ' '\n+\t\t&& data[2] == ' ' && data[3] == ' ') return 4;\n+\n+\treturn 0;\n+}\n+\n+/* prefix_oli \u2022 returns ordered list item prefix */\n+static size_t\n+prefix_oli(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\n+\tif (i >= size || data[i] < '0' || data[i] > '9')\n+\t\treturn 0;\n+\n+\twhile (i < size && data[i] >= '0' && data[i] <= '9')\n+\t\ti++;\n+\n+\tif (i + 1 >= size || data[i] != '.' || data[i + 1] != ' ')\n+\t\treturn 0;\n+\n+\tif (is_next_headerline(data + i, size - i))\n+\t\treturn 0;\n+\n+\treturn i + 2;\n+}\n+\n+/* prefix_uli \u2022 returns ordered list item prefix */\n+static size_t\n+prefix_uli(uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0;\n+\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\tif (i < size && data[i] == ' ') i++;\n+\n+\tif (i + 1 >= size ||\n+\t\t(data[i] != '*' && data[i] != '+' && data[i] != '-') ||\n+\t\tdata[i + 1] != ' ')\n+\t\treturn 0;\n+\n+\tif (is_next_headerline(data + i, size - i))\n+\t\treturn 0;\n+\n+\treturn i + 2;\n+}\n+\n+\n+/* parse_block \u2022 parsing of one block, returning next uint8_t to parse */\n+static void parse_block(struct buf *ob, struct sd_markdown *rndr,\n+\t\t\tuint8_t *data, size_t size);\n+\n+\n+/* parse_blockquote \u2022 handles parsing of a blockquote fragment */\n+static size_t\n+parse_blockquote(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t beg, end = 0, pre, work_size = 0;\n+\tuint8_t *work_data = 0;\n+\tstruct buf *out = 0;\n+\n+\tout = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\tbeg = 0;\n+\twhile (beg < size) {\n+\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n+\n+\t\tpre = prefix_quote(data + beg, end - beg);\n+\n+\t\tif (pre)\n+\t\t\tbeg += pre; /* skipping prefix */\n+\n+\t\t/* empty line followed by non-quote line */\n+\t\telse if (is_empty(data + beg, end - beg) &&\n+\t\t\t\t(end >= size || (prefix_quote(data + end, size - end) == 0 &&\n+\t\t\t\t!is_empty(data + end, size - end))))\n+\t\t\tbreak;\n+\n+\t\tif (beg < end) { /* copy into the in-place working buffer */\n+\t\t\t/* bufput(work, data + beg, end - beg); */\n+\t\t\tif (!work_data)\n+\t\t\t\twork_data = data + beg;\n+\t\t\telse if (data + beg != work_data + work_size)\n+\t\t\t\tmemmove(work_data + work_size, data + beg, end - beg);\n+\t\t\twork_size += end - beg;\n+\t\t}\n+\t\tbeg = end;\n+\t}\n+\n+\tparse_block(out, rndr, work_data, work_size);\n+\tif (rndr->cb.blockquote)\n+\t\trndr->cb.blockquote(ob, out, rndr->opaque);\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn end;\n+}\n+\n+static size_t\n+parse_htmlblock(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int do_render);\n+\n+/* parse_blockquote \u2022 handles parsing of a regular paragraph */\n+static size_t\n+parse_paragraph(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t i = 0, end = 0;\n+\tint level = 0;\n+\tstruct buf work = { data, 0, 0, 0 };\n+\n+\twhile (i < size) {\n+\t\tfor (end = i + 1; end < size && data[end - 1] != '\\n'; end++) /* empty */;\n+\n+\t\tif (is_empty(data + i, size - i))\n+\t\t\tbreak;\n+\n+\t\tif ((level = is_headerline(data + i, size - i)) != 0)\n+\t\t\tbreak;\n+\n+\t\tif (is_atxheader(rndr, data + i, size - i) ||\n+\t\t\tis_hrule(data + i, size - i) ||\n+\t\t\tprefix_quote(data + i, size - i)) {\n+\t\t\tend = i;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\t/*\n+\t\t * Early termination of a paragraph with the same logic\n+\t\t * as Markdown 1.0.0. If this logic is applied, the\n+\t\t * Markdown 1.0.3 test suite won't pass cleanly\n+\t\t *\n+\t\t * :: If the first character in a new line is not a letter,\n+\t\t * let's check to see if there's some kind of block starting\n+\t\t * here\n+\t\t */\n+\t\tif ((rndr->ext_flags & MKDEXT_LAX_SPACING) && !isalnum(data[i])) {\n+\t\t\tif (prefix_oli(data + i, size - i) ||\n+\t\t\t\tprefix_uli(data + i, size - i)) {\n+\t\t\t\tend = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\t/* see if an html block starts here */\n+\t\t\tif (data[i] == '<' && rndr->cb.blockhtml &&\n+\t\t\t\tparse_htmlblock(ob, rndr, data + i, size - i, 0)) {\n+\t\t\t\tend = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\t/* see if a code fence starts here */\n+\t\t\tif ((rndr->ext_flags & MKDEXT_FENCED_CODE) != 0 &&\n+\t\t\t\tis_codefence(data + i, size - i, NULL) != 0) {\n+\t\t\t\tend = i;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\n+\t\ti = end;\n+\t}\n+\n+\twork.size = i;\n+\twhile (work.size && data[work.size - 1] == '\\n')\n+\t\twork.size--;\n+\n+\tif (!level) {\n+\t\tstruct buf *tmp = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\t\tparse_inline(tmp, rndr, work.data, work.size);\n+\t\tif (rndr->cb.paragraph)\n+\t\t\trndr->cb.paragraph(ob, tmp, rndr->opaque);\n+\t\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\t} else {\n+\t\tstruct buf *header_work;\n+\n+\t\tif (work.size) {\n+\t\t\tsize_t beg;\n+\t\t\ti = work.size;\n+\t\t\twork.size -= 1;\n+\n+\t\t\twhile (work.size && data[work.size] != '\\n')\n+\t\t\t\twork.size -= 1;\n+\n+\t\t\tbeg = work.size + 1;\n+\t\t\twhile (work.size && data[work.size - 1] == '\\n')\n+\t\t\t\twork.size -= 1;\n+\n+\t\t\tif (work.size > 0) {\n+\t\t\t\tstruct buf *tmp = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\t\t\t\tparse_inline(tmp, rndr, work.data, work.size);\n+\n+\t\t\t\tif (rndr->cb.paragraph)\n+\t\t\t\t\trndr->cb.paragraph(ob, tmp, rndr->opaque);\n+\n+\t\t\t\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\t\t\t\twork.data += beg;\n+\t\t\t\twork.size = i - beg;\n+\t\t\t}\n+\t\t\telse work.size = i;\n+\t\t}\n+\n+\t\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\t\tparse_inline(header_work, rndr, work.data, work.size);\n+\n+\t\tif (rndr->cb.header)\n+\t\t\trndr->cb.header(ob, header_work, (int)level, rndr->opaque);\n+\n+\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t}\n+\n+\treturn end;\n+}\n+\n+/* parse_fencedcode \u2022 handles parsing of a block-level code fragment */\n+static size_t\n+parse_fencedcode(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t beg, end;\n+\tstruct buf *work = 0;\n+\tstruct buf lang = { 0, 0, 0, 0 };\n+\n+\tbeg = is_codefence(data, size, &lang);\n+\tif (beg == 0) return 0;\n+\n+\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\n+\twhile (beg < size) {\n+\t\tsize_t fence_end;\n+\t\tstruct buf fence_trail = { 0, 0, 0, 0 };\n+\n+\t\tfence_end = is_codefence(data + beg, size - beg, &fence_trail);\n+\t\tif (fence_end != 0 && fence_trail.size == 0) {\n+\t\t\tbeg += fence_end;\n+\t\t\tbreak;\n+\t\t}\n+\n+\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++);\n+\n+\t\tif (beg < end) {\n+\t\t\t/* verbatim copy to the working buffer,\n+\t\t\t\tescaping entities */\n+\t\t\tif (is_empty(data + beg, end - beg))\n+\t\t\t\tbufputc(work, '\\n');\n+\t\t\telse bufput(work, data + beg, end - beg);\n+\t\t}\n+\t\tbeg = end;\n+\t}\n+\n+\tif (work->size && work->data[work->size - 1] != '\\n')\n+\t\tbufputc(work, '\\n');\n+\n+\tif (rndr->cb.blockcode)\n+\t\trndr->cb.blockcode(ob, work, lang.size ? &lang : NULL, rndr->opaque);\n+\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn beg;\n+}\n+\n+static size_t\n+parse_blockcode(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t beg, end, pre;\n+\tstruct buf *work = 0;\n+\n+\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\n+\tbeg = 0;\n+\twhile (beg < size) {\n+\t\tfor (end = beg + 1; end < size && data[end - 1] != '\\n'; end++) {};\n+\t\tpre = prefix_code(data + beg, end - beg);\n+\n+\t\tif (pre)\n+\t\t\tbeg += pre; /* skipping prefix */\n+\t\telse if (!is_empty(data + beg, end - beg))\n+\t\t\t/* non-empty non-prefixed line breaks the pre */\n+\t\t\tbreak;\n+\n+\t\tif (beg < end) {\n+\t\t\t/* verbatim copy to the working buffer,\n+\t\t\t\tescaping entities */\n+\t\t\tif (is_empty(data + beg, end - beg))\n+\t\t\t\tbufputc(work, '\\n');\n+\t\t\telse bufput(work, data + beg, end - beg);\n+\t\t}\n+\t\tbeg = end;\n+\t}\n+\n+\twhile (work->size && work->data[work->size - 1] == '\\n')\n+\t\twork->size -= 1;\n+\n+\tbufputc(work, '\\n');\n+\n+\tif (rndr->cb.blockcode)\n+\t\trndr->cb.blockcode(ob, work, NULL, rndr->opaque);\n+\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn beg;\n+}\n+\n+/* parse_listitem \u2022 parsing of a single list item */\n+/*\tassuming initial prefix is already removed */\n+static size_t\n+parse_listitem(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int *flags)\n+{\n+\tstruct buf *work = 0, *inter = 0;\n+\tsize_t beg = 0, end, pre, sublist = 0, orgpre = 0, i;\n+\tint in_empty = 0, has_inside_empty = 0, in_fence = 0;\n+\n+\t/* keeping track of the first indentation prefix */\n+\twhile (orgpre < 3 && orgpre < size && data[orgpre] == ' ')\n+\t\torgpre++;\n+\n+\tbeg = prefix_uli(data, size);\n+\tif (!beg)\n+\t\tbeg = prefix_oli(data, size);\n+\n+\tif (!beg)\n+\t\treturn 0;\n+\n+\t/* skipping to the beginning of the following line */\n+\tend = beg;\n+\twhile (end < size && data[end - 1] != '\\n')\n+\t\tend++;\n+\n+\t/* getting working buffers */\n+\twork = rndr_newbuf(rndr, BUFFER_SPAN);\n+\tinter = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\t/* putting the first line into the working buffer */\n+\tbufput(work, data + beg, end - beg);\n+\tbeg = end;\n+\n+\t/* process the following lines */\n+\twhile (beg < size) {\n+\t\tsize_t has_next_uli = 0, has_next_oli = 0;\n+\n+\t\tend++;\n+\n+\t\twhile (end < size && data[end - 1] != '\\n')\n+\t\t\tend++;\n+\n+\t\t/* process an empty line */\n+\t\tif (is_empty(data + beg, end - beg)) {\n+\t\t\tin_empty = 1;\n+\t\t\tbeg = end;\n+\t\t\tcontinue;\n+\t\t}\n+\n+\t\t/* calculating the indentation */\n+\t\ti = 0;\n+\t\twhile (i < 4 && beg + i < end && data[beg + i] == ' ')\n+\t\t\ti++;\n+\n+\t\tpre = i;\n+\n+\t\tif (rndr->ext_flags & MKDEXT_FENCED_CODE) {\n+\t\t\tif (is_codefence(data + beg + i, end - beg - i, NULL) != 0)\n+\t\t\t\tin_fence = !in_fence;\n+\t\t}\n+\n+\t\t/* Only check for new list items if we are **not** inside\n+\t\t * a fenced code block */\n+\t\tif (!in_fence) {\n+\t\t\thas_next_uli = prefix_uli(data + beg + i, end - beg - i);\n+\t\t\thas_next_oli = prefix_oli(data + beg + i, end - beg - i);\n+\t\t}\n+\n+\t\t/* checking for ul/ol switch */\n+\t\tif (in_empty && (\n+\t\t\t((*flags & MKD_LIST_ORDERED) && has_next_uli) ||\n+\t\t\t(!(*flags & MKD_LIST_ORDERED) && has_next_oli))){\n+\t\t\t*flags |= MKD_LI_END;\n+\t\t\tbreak; /* the following item must have same list type */\n+\t\t}\n+\n+\t\t/* checking for a new item */\n+\t\tif ((has_next_uli && !is_hrule(data + beg + i, end - beg - i)) || has_next_oli) {\n+\t\t\tif (in_empty)\n+\t\t\t\thas_inside_empty = 1;\n+\n+\t\t\tif (pre == orgpre) /* the following item must have */\n+\t\t\t\tbreak;             /* the same indentation */\n+\n+\t\t\tif (!sublist)\n+\t\t\t\tsublist = work->size;\n+\t\t}\n+\t\t/* joining only indented stuff after empty lines;\n+\t\t * note that now we only require 1 space of indentation\n+\t\t * to continue a list */\n+\t\telse if (in_empty && pre == 0) {\n+\t\t\t*flags |= MKD_LI_END;\n+\t\t\tbreak;\n+\t\t}\n+\t\telse if (in_empty) {\n+\t\t\tbufputc(work, '\\n');\n+\t\t\thas_inside_empty = 1;\n+\t\t}\n+\n+\t\tin_empty = 0;\n+\n+\t\t/* adding the line without prefix into the working buffer */\n+\t\tbufput(work, data + beg + i, end - beg - i);\n+\t\tbeg = end;\n+\t}\n+\n+\t/* render of li contents */\n+\tif (has_inside_empty)\n+\t\t*flags |= MKD_LI_BLOCK;\n+\n+\tif (*flags & MKD_LI_BLOCK) {\n+\t\t/* intermediate render of block li */\n+\t\tif (sublist && sublist < work->size) {\n+\t\t\tparse_block(inter, rndr, work->data, sublist);\n+\t\t\tparse_block(inter, rndr, work->data + sublist, work->size - sublist);\n+\t\t}\n+\t\telse\n+\t\t\tparse_block(inter, rndr, work->data, work->size);\n+\t} else {\n+\t\t/* intermediate render of inline li */\n+\t\tif (sublist && sublist < work->size) {\n+\t\t\tparse_inline(inter, rndr, work->data, sublist);\n+\t\t\tparse_block(inter, rndr, work->data + sublist, work->size - sublist);\n+\t\t}\n+\t\telse\n+\t\t\tparse_inline(inter, rndr, work->data, work->size);\n+\t}\n+\n+\t/* render of li itself */\n+\tif (rndr->cb.listitem)\n+\t\trndr->cb.listitem(ob, inter, *flags, rndr->opaque);\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\treturn beg;\n+}\n+\n+\n+/* parse_list \u2022 parsing ordered or unordered list block */\n+static size_t\n+parse_list(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int flags)\n+{\n+\tstruct buf *work = 0;\n+\tsize_t i = 0, j;\n+\n+\twork = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\n+\twhile (i < size) {\n+\t\tj = parse_listitem(work, rndr, data + i, size - i, &flags);\n+\t\ti += j;\n+\n+\t\tif (!j || (flags & MKD_LI_END))\n+\t\t\tbreak;\n+\t}\n+\n+\tif (rndr->cb.list)\n+\t\trndr->cb.list(ob, work, flags, rndr->opaque);\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn i;\n+}\n+\n+/* parse_atxheader \u2022 parsing of atx-style headers */\n+static size_t\n+parse_atxheader(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t level = 0;\n+\tsize_t i, end, skip;\n+\n+\twhile (level < size && level < 6 && data[level] == '#')\n+\t\tlevel++;\n+\n+\tfor (i = level; i < size && data[i] == ' '; i++);\n+\n+\tfor (end = i; end < size && data[end] != '\\n'; end++);\n+\tskip = end;\n+\n+\twhile (end && data[end - 1] == '#')\n+\t\tend--;\n+\n+\twhile (end && data[end - 1] == ' ')\n+\t\tend--;\n+\n+\tif (end > i) {\n+\t\tstruct buf *work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\t\tparse_inline(work, rndr, data + i, end - i);\n+\n+\t\tif (rndr->cb.header)\n+\t\t\trndr->cb.header(ob, work, (int)level, rndr->opaque);\n+\n+\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t}\n+\n+\treturn skip;\n+}\n+\n+\n+/* htmlblock_end \u2022 checking end of HTML block : </tag>[ \\t]*\\n[ \\t*]\\n */\n+/*\treturns the length on match, 0 otherwise */\n+static size_t\n+htmlblock_end_tag(\n+\tconst char *tag,\n+\tsize_t tag_len,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size)\n+{\n+\tsize_t i, w;\n+\n+\t/* checking if tag is a match */\n+\tif (tag_len + 3 >= size ||\n+\t\tstrncasecmp((char *)data + 2, tag, tag_len) != 0 ||\n+\t\tdata[tag_len + 2] != '>')\n+\t\treturn 0;\n+\n+\t/* checking white lines */\n+\ti = tag_len + 3;\n+\tw = 0;\n+\tif (i < size && (w = is_empty(data + i, size - i)) == 0)\n+\t\treturn 0; /* non-blank after tag */\n+\ti += w;\n+\tw = 0;\n+\n+\tif (i < size)\n+\t\tw = is_empty(data + i, size - i);\n+\n+\treturn i + w;\n+}\n+\n+static size_t\n+htmlblock_end(const char *curtag,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size,\n+\tint start_of_line)\n+{\n+\tsize_t tag_size = strlen(curtag);\n+\tsize_t i = 1, end_tag;\n+\tint block_lines = 0;\n+\n+\twhile (i < size) {\n+\t\ti++;\n+\t\twhile (i < size && !(data[i - 1] == '<' && data[i] == '/')) {\n+\t\t\tif (data[i] == '\\n')\n+\t\t\t\tblock_lines++;\n+\n+\t\t\ti++;\n+\t\t}\n+\n+\t\t/* If we are only looking for unindented tags, skip the tag\n+\t\t * if it doesn't follow a newline.\n+\t\t *\n+\t\t * The only exception to this is if the tag is still on the\n+\t\t * initial line; in that case it still counts as a closing\n+\t\t * tag\n+\t\t */\n+\t\tif (start_of_line && block_lines > 0 && data[i - 2] != '\\n')\n+\t\t\tcontinue;\n+\n+\t\tif (i + 2 + tag_size >= size)\n+\t\t\tbreak;\n+\n+\t\tend_tag = htmlblock_end_tag(curtag, tag_size, rndr, data + i - 1, size - i + 1);\n+\t\tif (end_tag)\n+\t\t\treturn i + end_tag - 1;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+\n+/* parse_htmlblock \u2022 parsing of inline HTML block */\n+static size_t\n+parse_htmlblock(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size, int do_render)\n+{\n+\tsize_t i, j = 0, tag_end;\n+\tconst char *curtag = NULL;\n+\tstruct buf work = { data, 0, 0, 0 };\n+\n+\t/* identification of the opening tag */\n+\tif (size < 2 || data[0] != '<')\n+\t\treturn 0;\n+\n+\ti = 1;\n+\twhile (i < size && data[i] != '>' && data[i] != ' ')\n+\t\ti++;\n+\n+\tif (i < size)\n+\t\tcurtag = find_block_tag((char *)data + 1, (int)i - 1);\n+\n+\t/* handling of special cases */\n+\tif (!curtag) {\n+\n+\t\t/* HTML comment, laxist form */\n+\t\tif (size > 5 && data[1] == '!' && data[2] == '-' && data[3] == '-') {\n+\t\t\ti = 5;\n+\n+\t\t\twhile (i < size && !(data[i - 2] == '-' && data[i - 1] == '-' && data[i] == '>'))\n+\t\t\t\ti++;\n+\n+\t\t\ti++;\n+\n+\t\t\tif (i < size)\n+\t\t\t\tj = is_empty(data + i, size - i);\n+\n+\t\t\tif (j) {\n+\t\t\t\twork.size = i + j;\n+\t\t\t\tif (do_render && rndr->cb.blockhtml)\n+\t\t\t\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n+\t\t\t\treturn work.size;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* HR, which is the only self-closing block tag considered */\n+\t\tif (size > 4 && (data[1] == 'h' || data[1] == 'H') && (data[2] == 'r' || data[2] == 'R')) {\n+\t\t\ti = 3;\n+\t\t\twhile (i < size && data[i] != '>')\n+\t\t\t\ti++;\n+\n+\t\t\tif (i + 1 < size) {\n+\t\t\t\ti++;\n+\t\t\t\tj = is_empty(data + i, size - i);\n+\t\t\t\tif (j) {\n+\t\t\t\t\twork.size = i + j;\n+\t\t\t\t\tif (do_render && rndr->cb.blockhtml)\n+\t\t\t\t\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n+\t\t\t\t\treturn work.size;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t/* no special case recognised */\n+\t\treturn 0;\n+\t}\n+\n+\t/* looking for an unindented matching closing tag */\n+\t/*\tfollowed by a blank line */\n+\ttag_end = htmlblock_end(curtag, rndr, data, size, 1);\n+\n+\t/* if not found, trying a second pass looking for indented match */\n+\t/* but not if tag is \"ins\" or \"del\" (following original Markdown.pl) */\n+\tif (!tag_end && strcmp(curtag, \"ins\") != 0 && strcmp(curtag, \"del\") != 0) {\n+\t\ttag_end = htmlblock_end(curtag, rndr, data, size, 0);\n+\t}\n+\n+\tif (!tag_end)\n+\t\treturn 0;\n+\n+\t/* the end of the block has been found */\n+\twork.size = tag_end;\n+\tif (do_render && rndr->cb.blockhtml)\n+\t\trndr->cb.blockhtml(ob, &work, rndr->opaque);\n+\n+\treturn tag_end;\n+}\n+\n+static void\n+parse_table_row(\n+\tstruct buf *ob,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size,\n+\tsize_t columns,\n+\tint *col_data,\n+\tint header_flag)\n+{\n+\tsize_t i = 0, col;\n+\tstruct buf *row_work = 0;\n+\n+\tif (!rndr->cb.table_cell || !rndr->cb.table_row)\n+\t\treturn;\n+\n+\trow_work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\tif (i < size && data[i] == '|')\n+\t\ti++;\n+\n+\tfor (col = 0; col < columns && i < size; ++col) {\n+\t\tsize_t cell_start, cell_end;\n+\t\tstruct buf *cell_work;\n+\n+\t\tcell_work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\n+\t\twhile (i < size && _isspace(data[i]))\n+\t\t\ti++;\n+\n+\t\tcell_start = i;\n+\n+\t\twhile (i < size && data[i] != '|')\n+\t\t\ti++;\n+\n+\t\tcell_end = i - 1;\n+\n+\t\twhile (cell_end > cell_start && _isspace(data[cell_end]))\n+\t\t\tcell_end--;\n+\n+\t\tparse_inline(cell_work, rndr, data + cell_start, 1 + cell_end - cell_start);\n+\t\trndr->cb.table_cell(row_work, cell_work, col_data[col] | header_flag, rndr->opaque);\n+\n+\t\trndr_popbuf(rndr, BUFFER_SPAN);\n+\t\ti++;\n+\t}\n+\n+\tfor (; col < columns; ++col) {\n+\t\tstruct buf empty_cell = { 0, 0, 0, 0 };\n+\t\trndr->cb.table_cell(row_work, &empty_cell, col_data[col] | header_flag, rndr->opaque);\n+\t}\n+\n+\trndr->cb.table_row(ob, row_work, rndr->opaque);\n+\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+}\n+\n+static size_t\n+parse_table_header(\n+\tstruct buf *ob,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size,\n+\tsize_t *columns,\n+\tint **column_data)\n+{\n+\tint pipes;\n+\tsize_t i = 0, col, header_end, under_end;\n+\n+\tpipes = 0;\n+\twhile (i < size && data[i] != '\\n')\n+\t\tif (data[i++] == '|')\n+\t\t\tpipes++;\n+\n+\tif (i == size || pipes == 0)\n+\t\treturn 0;\n+\n+\theader_end = i;\n+\n+\twhile (header_end > 0 && _isspace(data[header_end - 1]))\n+\t\theader_end--;\n+\n+\tif (data[0] == '|')\n+\t\tpipes--;\n+\n+\tif (header_end && data[header_end - 1] == '|')\n+\t\tpipes--;\n+\n+\t*columns = pipes + 1;\n+\t*column_data = calloc(*columns, sizeof(int));\n+\n+\t/* Parse the header underline */\n+\ti++;\n+\tif (i < size && data[i] == '|')\n+\t\ti++;\n+\n+\tunder_end = i;\n+\twhile (under_end < size && data[under_end] != '\\n')\n+\t\tunder_end++;\n+\n+\tfor (col = 0; col < *columns && i < under_end; ++col) {\n+\t\tsize_t dashes = 0;\n+\n+\t\twhile (i < under_end && data[i] == ' ')\n+\t\t\ti++;\n+\n+\t\tif (data[i] == ':') {\n+\t\t\ti++; (*column_data)[col] |= MKD_TABLE_ALIGN_L;\n+\t\t\tdashes++;\n+\t\t}\n+\n+\t\twhile (i < under_end && data[i] == '-') {\n+\t\t\ti++; dashes++;\n+\t\t}\n+\n+\t\tif (i < under_end && data[i] == ':') {\n+\t\t\ti++; (*column_data)[col] |= MKD_TABLE_ALIGN_R;\n+\t\t\tdashes++;\n+\t\t}\n+\n+\t\twhile (i < under_end && data[i] == ' ')\n+\t\t\ti++;\n+\n+\t\tif (i < under_end && data[i] != '|')\n+\t\t\tbreak;\n+\n+\t\tif (dashes < 3)\n+\t\t\tbreak;\n+\n+\t\ti++;\n+\t}\n+\n+\tif (col < *columns)\n+\t\treturn 0;\n+\n+\tparse_table_row(\n+\t\tob, rndr, data,\n+\t\theader_end,\n+\t\t*columns,\n+\t\t*column_data,\n+\t\tMKD_TABLE_HEADER\n+\t);\n+\n+\treturn under_end + 1;\n+}\n+\n+static size_t\n+parse_table(\n+\tstruct buf *ob,\n+\tstruct sd_markdown *rndr,\n+\tuint8_t *data,\n+\tsize_t size)\n+{\n+\tsize_t i;\n+\n+\tstruct buf *header_work = 0;\n+\tstruct buf *body_work = 0;\n+\n+\tsize_t columns;\n+\tint *col_data = NULL;\n+\n+\theader_work = rndr_newbuf(rndr, BUFFER_SPAN);\n+\tbody_work = rndr_newbuf(rndr, BUFFER_BLOCK);\n+\n+\ti = parse_table_header(header_work, rndr, data, size, &columns, &col_data);\n+\tif (i > 0) {\n+\n+\t\twhile (i < size) {\n+\t\t\tsize_t row_start;\n+\t\t\tint pipes = 0;\n+\n+\t\t\trow_start = i;\n+\n+\t\t\twhile (i < size && data[i] != '\\n')\n+\t\t\t\tif (data[i++] == '|')\n+\t\t\t\t\tpipes++;\n+\n+\t\t\tif (pipes == 0 || i == size) {\n+\t\t\t\ti = row_start;\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n+\t\t\tparse_table_row(\n+\t\t\t\tbody_work,\n+\t\t\t\trndr,\n+\t\t\t\tdata + row_start,\n+\t\t\t\ti - row_start,\n+\t\t\t\tcolumns,\n+\t\t\t\tcol_data, 0\n+\t\t\t);\n+\n+\t\t\ti++;\n+\t\t}\n+\n+\t\tif (rndr->cb.table)\n+\t\t\trndr->cb.table(ob, header_work, body_work, rndr->opaque);\n+\t}\n+\n+\tfree(col_data);\n+\trndr_popbuf(rndr, BUFFER_SPAN);\n+\trndr_popbuf(rndr, BUFFER_BLOCK);\n+\treturn i;\n+}\n+\n+/* parse_block \u2022 parsing of one block, returning next uint8_t to parse */\n+static void\n+parse_block(struct buf *ob, struct sd_markdown *rndr, uint8_t *data, size_t size)\n+{\n+\tsize_t beg, end, i;\n+\tuint8_t *txt_data;\n+\tbeg = 0;\n+\n+\tif (rndr->work_bufs[BUFFER_SPAN].size +\n+\t\trndr->work_bufs[BUFFER_BLOCK].size > rndr->max_nesting)\n+\t\treturn;\n+\n+\twhile (beg < size) {\n+\t\ttxt_data = data + beg;\n+\t\tend = size - beg;\n+\n+\t\tif (is_atxheader(rndr, txt_data, end))\n+\t\t\tbeg += parse_atxheader(ob, rndr, txt_data, end);\n+\n+\t\telse if (data[beg] == '<' && rndr->cb.blockhtml &&\n+\t\t\t\t(i = parse_htmlblock(ob, rndr, txt_data, end, 1)) != 0)\n+\t\t\tbeg += i;\n+\n+\t\telse if ((i = is_empty(txt_data, end)) != 0)\n+\t\t\tbeg += i;\n+\n+\t\telse if (is_hrule(txt_data, end)) {\n+\t\t\tif (rndr->cb.hrule)\n+\t\t\t\trndr->cb.hrule(ob, rndr->opaque);\n+\n+\t\t\twhile (beg < size && data[beg] != '\\n')\n+\t\t\t\tbeg++;\n+\n+\t\t\tbeg++;\n+\t\t}\n+\n+\t\telse if ((rndr->ext_flags & MKDEXT_FENCED_CODE) != 0 &&\n+\t\t\t(i = parse_fencedcode(ob, rndr, txt_data, end)) != 0)\n+\t\t\tbeg += i;\n+\n+\t\telse if ((rndr->ext_flags & MKDEXT_TABLES) != 0 &&\n+\t\t\t(i = parse_table(ob, rndr, txt_data, end)) != 0)\n+\t\t\tbeg += i;\n+\n+\t\telse if (prefix_quote(txt_data, end))\n+\t\t\tbeg += parse_blockquote(ob, rndr, txt_data, end);\n+\n+\t\telse if (prefix_code(txt_data, end))\n+\t\t\tbeg += parse_blockcode(ob, rndr, txt_data, end);\n+\n+\t\telse if (prefix_uli(txt_data, end))\n+\t\t\tbeg += parse_list(ob, rndr, txt_data, end, 0);\n+\n+\t\telse if (prefix_oli(txt_data, end))\n+\t\t\tbeg += parse_list(ob, rndr, txt_data, end, MKD_LIST_ORDERED);\n+\n+\t\telse\n+\t\t\tbeg += parse_paragraph(ob, rndr, txt_data, end);\n+\t}\n+}\n+\n+\n+\n+/*********************\n+ * REFERENCE PARSING *\n+ *********************/\n+\n+/* is_ref \u2022 returns whether a line is a reference or not */\n+static int\n+is_ref(const uint8_t *data, size_t beg, size_t end, size_t *last, struct link_ref **refs)\n+{\n+/*\tint n; */\n+\tsize_t i = 0;\n+\tsize_t id_offset, id_end;\n+\tsize_t link_offset, link_end;\n+\tsize_t title_offset, title_end;\n+\tsize_t line_end;\n+\n+\t/* up to 3 optional leading spaces */\n+\tif (beg + 3 >= end) return 0;\n+\tif (data[beg] == ' ') { i = 1;\n+\tif (data[beg + 1] == ' ') { i = 2;\n+\tif (data[beg + 2] == ' ') { i = 3;\n+\tif (data[beg + 3] == ' ') return 0; } } }\n+\ti += beg;\n+\n+\t/* id part: anything but a newline between brackets */\n+\tif (data[i] != '[') return 0;\n+\ti++;\n+\tid_offset = i;\n+\twhile (i < end && data[i] != '\\n' && data[i] != '\\r' && data[i] != ']')\n+\t\ti++;\n+\tif (i >= end || data[i] != ']') return 0;\n+\tid_end = i;\n+\n+\t/* spacer: colon (space | tab)* newline? (space | tab)* */\n+\ti++;\n+\tif (i >= end || data[i] != ':') return 0;\n+\ti++;\n+\twhile (i < end && data[i] == ' ') i++;\n+\tif (i < end && (data[i] == '\\n' || data[i] == '\\r')) {\n+\t\ti++;\n+\t\tif (i < end && data[i] == '\\r' && data[i - 1] == '\\n') i++; }\n+\twhile (i < end && data[i] == ' ') i++;\n+\tif (i >= end) return 0;\n+\n+\t/* link: whitespace-free sequence, optionally between angle brackets */\n+\tif (data[i] == '<')\n+\t\ti++;\n+\n+\tlink_offset = i;\n+\n+\twhile (i < end && data[i] != ' ' && data[i] != '\\n' && data[i] != '\\r')\n+\t\ti++;\n+\n+\tif (data[i - 1] == '>') link_end = i - 1;\n+\telse link_end = i;\n+\n+\t/* optional spacer: (space | tab)* (newline | '\\'' | '\"' | '(' ) */\n+\twhile (i < end && data[i] == ' ') i++;\n+\tif (i < end && data[i] != '\\n' && data[i] != '\\r'\n+\t\t\t&& data[i] != '\\'' && data[i] != '\"' && data[i] != '(')\n+\t\treturn 0;\n+\tline_end = 0;\n+\t/* computing end-of-line */\n+\tif (i >= end || data[i] == '\\r' || data[i] == '\\n') line_end = i;\n+\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n+\t\tline_end = i + 1;\n+\n+\t/* optional (space|tab)* spacer after a newline */\n+\tif (line_end) {\n+\t\ti = line_end + 1;\n+\t\twhile (i < end && data[i] == ' ') i++; }\n+\n+\t/* optional title: any non-newline sequence enclosed in '\"()\n+\t\t\t\t\talone on its line */\n+\ttitle_offset = title_end = 0;\n+\tif (i + 1 < end\n+\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == '(')) {\n+\t\ti++;\n+\t\ttitle_offset = i;\n+\t\t/* looking for EOL */\n+\t\twhile (i < end && data[i] != '\\n' && data[i] != '\\r') i++;\n+\t\tif (i + 1 < end && data[i] == '\\n' && data[i + 1] == '\\r')\n+\t\t\ttitle_end = i + 1;\n+\t\telse\ttitle_end = i;\n+\t\t/* stepping back */\n+\t\ti -= 1;\n+\t\twhile (i > title_offset && data[i] == ' ')\n+\t\t\ti -= 1;\n+\t\tif (i > title_offset\n+\t\t&& (data[i] == '\\'' || data[i] == '\"' || data[i] == ')')) {\n+\t\t\tline_end = title_end;\n+\t\t\ttitle_end = i; } }\n+\n+\tif (!line_end || link_end == link_offset)\n+\t\treturn 0; /* garbage after the link empty link */\n+\n+\t/* a valid ref has been found, filling-in return structures */\n+\tif (last)\n+\t\t*last = line_end;\n+\n+\tif (refs) {\n+\t\tstruct link_ref *ref;\n+\n+\t\tref = add_link_ref(refs, data + id_offset, id_end - id_offset);\n+\t\tif (!ref)\n+\t\t\treturn 0;\n+\n+\t\tref->link = bufnew(link_end - link_offset);\n+\t\tbufput(ref->link, data + link_offset, link_end - link_offset);\n+\n+\t\tif (title_end > title_offset) {\n+\t\t\tref->title = bufnew(title_end - title_offset);\n+\t\t\tbufput(ref->title, data + title_offset, title_end - title_offset);\n+\t\t}\n+\t}\n+\n+\treturn 1;\n+}\n+\n+static void expand_tabs(struct buf *ob, const uint8_t *line, size_t size)\n+{\n+\tsize_t  i = 0, tab = 0;\n+\n+\twhile (i < size) {\n+\t\tsize_t org = i;\n+\n+\t\twhile (i < size && line[i] != '\\t') {\n+\t\t\ti++; tab++;\n+\t\t}\n+\n+\t\tif (i > org)\n+\t\t\tbufput(ob, line + org, i - org);\n+\n+\t\tif (i >= size)\n+\t\t\tbreak;\n+\n+\t\tdo {\n+\t\t\tbufputc(ob, ' '); tab++;\n+\t\t} while (tab % 4);\n+\n+\t\ti++;\n+\t}\n+}\n+\n+/**********************\n+ * EXPORTED FUNCTIONS *\n+ **********************/\n+\n+struct sd_markdown *\n+sd_markdown_new(\n+\tunsigned int extensions,\n+\tsize_t max_nesting,\n+\tconst struct sd_callbacks *callbacks,\n+\tvoid *opaque)\n+{\n+\tstruct sd_markdown *md = NULL;\n+\n+\tassert(max_nesting > 0 && callbacks);\n+\n+\tmd = malloc(sizeof(struct sd_markdown));\n+\tif (!md)\n+\t\treturn NULL;\n+\n+\tmemcpy(&md->cb, callbacks, sizeof(struct sd_callbacks));\n+\n+\tstack_init(&md->work_bufs[BUFFER_BLOCK], 4);\n+\tstack_init(&md->work_bufs[BUFFER_SPAN], 8);\n+\n+\tmemset(md->active_char, 0x0, 256);\n+\n+\tif (md->cb.emphasis || md->cb.double_emphasis || md->cb.triple_emphasis) {\n+\t\tmd->active_char['*'] = MD_CHAR_EMPHASIS;\n+\t\tmd->active_char['_'] = MD_CHAR_EMPHASIS;\n+\t\tif (extensions & MKDEXT_STRIKETHROUGH)\n+\t\t\tmd->active_char['~'] = MD_CHAR_EMPHASIS;\n+\t}\n+\n+\tif (md->cb.codespan)\n+\t\tmd->active_char['`'] = MD_CHAR_CODESPAN;\n+\n+\tif (md->cb.linebreak)\n+\t\tmd->active_char['\\n'] = MD_CHAR_LINEBREAK;\n+\n+\tif (md->cb.image || md->cb.link)\n+\t\tmd->active_char['['] = MD_CHAR_LINK;\n+\n+\tmd->active_char['<'] = MD_CHAR_LANGLE;\n+\tmd->active_char['\\\\'] = MD_CHAR_ESCAPE;\n+\tmd->active_char['&'] = MD_CHAR_ENTITITY;\n+\n+\tif (extensions & MKDEXT_AUTOLINK) {\n+\t\tmd->active_char[':'] = MD_CHAR_AUTOLINK_URL;\n+\t\tmd->active_char['@'] = MD_CHAR_AUTOLINK_EMAIL;\n+\t\tmd->active_char['w'] = MD_CHAR_AUTOLINK_WWW;\n+\t}\n+\n+\tif (extensions & MKDEXT_SUPERSCRIPT)\n+\t\tmd->active_char['^'] = MD_CHAR_SUPERSCRIPT;\n+\n+\t/* Extension data */\n+\tmd->ext_flags = extensions;\n+\tmd->opaque = opaque;\n+\tmd->max_nesting = max_nesting;\n+\tmd->in_link_body = 0;\n+\n+\treturn md;\n+}\n+\n+void\n+sd_markdown_render(struct buf *ob, const uint8_t *document, size_t doc_size, struct sd_markdown *md)\n+{\n+#define MARKDOWN_GROW(x) ((x) + ((x) >> 1))\n+\tstatic const char UTF8_BOM[] = {0xEF, 0xBB, 0xBF};\n+\n+\tstruct buf *text;\n+\tsize_t beg, end;\n+\n+\ttext = bufnew(64);\n+\tif (!text)\n+\t\treturn;\n+\n+\t/* Preallocate enough space for our buffer to avoid expanding while copying */\n+\tbufgrow(text, doc_size);\n+\n+\t/* reset the references table */\n+\tmemset(&md->refs, 0x0, REF_TABLE_SIZE * sizeof(void *));\n+\n+\t/* first pass: looking for references, copying everything else */\n+\tbeg = 0;\n+\n+\t/* Skip a possible UTF-8 BOM, even though the Unicode standard\n+\t * discourages having these in UTF-8 documents */\n+\tif (doc_size >= 3 && memcmp(document, UTF8_BOM, 3) == 0)\n+\t\tbeg += 3;\n+\n+\twhile (beg < doc_size) /* iterating over lines */\n+\t\tif (is_ref(document, beg, doc_size, &end, md->refs))\n+\t\t\tbeg = end;\n+\t\telse { /* skipping to the next line */\n+\t\t\tend = beg;\n+\t\t\twhile (end < doc_size && document[end] != '\\n' && document[end] != '\\r')\n+\t\t\t\tend++;\n+\n+\t\t\t/* adding the line body if present */\n+\t\t\tif (end > beg)\n+\t\t\t\texpand_tabs(text, document + beg, end - beg);\n+\n+\t\t\twhile (end < doc_size && (document[end] == '\\n' || document[end] == '\\r')) {\n+\t\t\t\t/* add one \\n per newline */\n+\t\t\t\tif (document[end] == '\\n' || (end + 1 < doc_size && document[end + 1] != '\\n'))\n+\t\t\t\t\tbufputc(text, '\\n');\n+\t\t\t\tend++;\n+\t\t\t}\n+\n+\t\t\tbeg = end;\n+\t\t}\n+\n+\t/* pre-grow the output buffer to minimize allocations */\n+\tbufgrow(ob, MARKDOWN_GROW(text->size));\n+\n+\t/* second pass: actual rendering */\n+\tif (md->cb.doc_header)\n+\t\tmd->cb.doc_header(ob, md->opaque);\n+\n+\tif (text->size) {\n+\t\t/* adding a final newline if not already present */\n+\t\tif (text->data[text->size - 1] != '\\n' &&  text->data[text->size - 1] != '\\r')\n+\t\t\tbufputc(text, '\\n');\n+\n+\t\tparse_block(ob, md, text->data, text->size);\n+\t}\n+\n+\tif (md->cb.doc_footer)\n+\t\tmd->cb.doc_footer(ob, md->opaque);\n+\n+\t/* clean-up */\n+\tbufrelease(text);\n+\tfree_link_refs(md->refs);\n+\n+\tassert(md->work_bufs[BUFFER_SPAN].size == 0);\n+\tassert(md->work_bufs[BUFFER_BLOCK].size == 0);\n+}\n+\n+void\n+sd_markdown_free(struct sd_markdown *md)\n+{\n+\tsize_t i;\n+\n+\tfor (i = 0; i < (size_t)md->work_bufs[BUFFER_SPAN].asize; ++i)\n+\t\tbufrelease(md->work_bufs[BUFFER_SPAN].item[i]);\n+\n+\tfor (i = 0; i < (size_t)md->work_bufs[BUFFER_BLOCK].asize; ++i)\n+\t\tbufrelease(md->work_bufs[BUFFER_BLOCK].item[i]);\n+\n+\tstack_free(&md->work_bufs[BUFFER_SPAN]);\n+\tstack_free(&md->work_bufs[BUFFER_BLOCK]);\n+\n+\tfree(md);\n+}\n+\n+void\n+sd_version(int *ver_major, int *ver_minor, int *ver_revision)\n+{\n+\t*ver_major = SUNDOWN_VER_MAJOR;\n+\t*ver_minor = SUNDOWN_VER_MINOR;\n+\t*ver_revision = SUNDOWN_VER_REVISION;\n+}\n+\n+/* vim: set filetype=c: */"}, {"sha": "6f6553ec87df5ce680f476fce70db3ee5faeabac", "filename": "src/rt/sundown/src/markdown.h", "status": "added", "additions": 138, "deletions": 0, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.h", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fmarkdown.h?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,138 @@\n+/* markdown.h - generic markdown parser */\n+\n+/*\n+ * Copyright (c) 2009, Natacha Port\u00e9\n+ *\n+ * Permission to use, copy, modify, and distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ */\n+\n+#ifndef UPSKIRT_MARKDOWN_H\n+#define UPSKIRT_MARKDOWN_H\n+\n+#include \"buffer.h\"\n+#include \"autolink.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+#define SUNDOWN_VERSION \"1.16.0\"\n+#define SUNDOWN_VER_MAJOR 1\n+#define SUNDOWN_VER_MINOR 16\n+#define SUNDOWN_VER_REVISION 0\n+\n+/********************\n+ * TYPE DEFINITIONS *\n+ ********************/\n+\n+/* mkd_autolink - type of autolink */\n+enum mkd_autolink {\n+\tMKDA_NOT_AUTOLINK,\t/* used internally when it is not an autolink*/\n+\tMKDA_NORMAL,\t\t/* normal http/http/ftp/mailto/etc link */\n+\tMKDA_EMAIL,\t\t\t/* e-mail link without explit mailto: */\n+};\n+\n+enum mkd_tableflags {\n+\tMKD_TABLE_ALIGN_L = 1,\n+\tMKD_TABLE_ALIGN_R = 2,\n+\tMKD_TABLE_ALIGN_CENTER = 3,\n+\tMKD_TABLE_ALIGNMASK = 3,\n+\tMKD_TABLE_HEADER = 4\n+};\n+\n+enum mkd_extensions {\n+\tMKDEXT_NO_INTRA_EMPHASIS = (1 << 0),\n+\tMKDEXT_TABLES = (1 << 1),\n+\tMKDEXT_FENCED_CODE = (1 << 2),\n+\tMKDEXT_AUTOLINK = (1 << 3),\n+\tMKDEXT_STRIKETHROUGH = (1 << 4),\n+\tMKDEXT_SPACE_HEADERS = (1 << 6),\n+\tMKDEXT_SUPERSCRIPT = (1 << 7),\n+\tMKDEXT_LAX_SPACING = (1 << 8),\n+};\n+\n+/* sd_callbacks - functions for rendering parsed data */\n+struct sd_callbacks {\n+\t/* block level callbacks - NULL skips the block */\n+\tvoid (*blockcode)(struct buf *ob, const struct buf *text, const struct buf *lang, void *opaque);\n+\tvoid (*blockquote)(struct buf *ob, const struct buf *text, void *opaque);\n+\tvoid (*blockhtml)(struct buf *ob,const  struct buf *text, void *opaque);\n+\tvoid (*header)(struct buf *ob, const struct buf *text, int level, void *opaque);\n+\tvoid (*hrule)(struct buf *ob, void *opaque);\n+\tvoid (*list)(struct buf *ob, const struct buf *text, int flags, void *opaque);\n+\tvoid (*listitem)(struct buf *ob, const struct buf *text, int flags, void *opaque);\n+\tvoid (*paragraph)(struct buf *ob, const struct buf *text, void *opaque);\n+\tvoid (*table)(struct buf *ob, const struct buf *header, const struct buf *body, void *opaque);\n+\tvoid (*table_row)(struct buf *ob, const struct buf *text, void *opaque);\n+\tvoid (*table_cell)(struct buf *ob, const struct buf *text, int flags, void *opaque);\n+\n+\n+\t/* span level callbacks - NULL or return 0 prints the span verbatim */\n+\tint (*autolink)(struct buf *ob, const struct buf *link, enum mkd_autolink type, void *opaque);\n+\tint (*codespan)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*double_emphasis)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*emphasis)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*image)(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *alt, void *opaque);\n+\tint (*linebreak)(struct buf *ob, void *opaque);\n+\tint (*link)(struct buf *ob, const struct buf *link, const struct buf *title, const struct buf *content, void *opaque);\n+\tint (*raw_html_tag)(struct buf *ob, const struct buf *tag, void *opaque);\n+\tint (*triple_emphasis)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*strikethrough)(struct buf *ob, const struct buf *text, void *opaque);\n+\tint (*superscript)(struct buf *ob, const struct buf *text, void *opaque);\n+\n+\t/* low level callbacks - NULL copies input directly into the output */\n+\tvoid (*entity)(struct buf *ob, const struct buf *entity, void *opaque);\n+\tvoid (*normal_text)(struct buf *ob, const struct buf *text, void *opaque);\n+\n+\t/* header and footer */\n+\tvoid (*doc_header)(struct buf *ob, void *opaque);\n+\tvoid (*doc_footer)(struct buf *ob, void *opaque);\n+};\n+\n+struct sd_markdown;\n+\n+/*********\n+ * FLAGS *\n+ *********/\n+\n+/* list/listitem flags */\n+#define MKD_LIST_ORDERED\t1\n+#define MKD_LI_BLOCK\t\t2  /* <li> containing block data */\n+\n+/**********************\n+ * EXPORTED FUNCTIONS *\n+ **********************/\n+\n+extern struct sd_markdown *\n+sd_markdown_new(\n+\tunsigned int extensions,\n+\tsize_t max_nesting,\n+\tconst struct sd_callbacks *callbacks,\n+\tvoid *opaque);\n+\n+extern void\n+sd_markdown_render(struct buf *ob, const uint8_t *document, size_t doc_size, struct sd_markdown *md);\n+\n+extern void\n+sd_markdown_free(struct sd_markdown *md);\n+\n+extern void\n+sd_version(int *major, int *minor, int *revision);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif\n+\n+/* vim: set filetype=c: */"}, {"sha": "ce069ff3b9d09c2d56ffc88b10b9d1effb541221", "filename": "src/rt/sundown/src/stack.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fstack.c", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fstack.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fstack.c?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,81 @@\n+#include \"stack.h\"\n+#include <string.h>\n+\n+int\n+stack_grow(struct stack *st, size_t new_size)\n+{\n+\tvoid **new_st;\n+\n+\tif (st->asize >= new_size)\n+\t\treturn 0;\n+\n+\tnew_st = realloc(st->item, new_size * sizeof(void *));\n+\tif (new_st == NULL)\n+\t\treturn -1;\n+\n+\tmemset(new_st + st->asize, 0x0,\n+\t\t(new_size - st->asize) * sizeof(void *));\n+\n+\tst->item = new_st;\n+\tst->asize = new_size;\n+\n+\tif (st->size > new_size)\n+\t\tst->size = new_size;\n+\n+\treturn 0;\n+}\n+\n+void\n+stack_free(struct stack *st)\n+{\n+\tif (!st)\n+\t\treturn;\n+\n+\tfree(st->item);\n+\n+\tst->item = NULL;\n+\tst->size = 0;\n+\tst->asize = 0;\n+}\n+\n+int\n+stack_init(struct stack *st, size_t initial_size)\n+{\n+\tst->item = NULL;\n+\tst->size = 0;\n+\tst->asize = 0;\n+\n+\tif (!initial_size)\n+\t\tinitial_size = 8;\n+\n+\treturn stack_grow(st, initial_size);\n+}\n+\n+void *\n+stack_pop(struct stack *st)\n+{\n+\tif (!st->size)\n+\t\treturn NULL;\n+\n+\treturn st->item[--st->size];\n+}\n+\n+int\n+stack_push(struct stack *st, void *item)\n+{\n+\tif (stack_grow(st, st->size * 2) < 0)\n+\t\treturn -1;\n+\n+\tst->item[st->size++] = item;\n+\treturn 0;\n+}\n+\n+void *\n+stack_top(struct stack *st)\n+{\n+\tif (!st->size)\n+\t\treturn NULL;\n+\n+\treturn st->item[st->size - 1];\n+}\n+"}, {"sha": "08ff030a33b0fba0743509307ec12676215ad729", "filename": "src/rt/sundown/src/stack.h", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fstack.h", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Frt%2Fsundown%2Fsrc%2Fstack.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Fsundown%2Fsrc%2Fstack.h?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -0,0 +1,29 @@\n+#ifndef STACK_H__\n+#define STACK_H__\n+\n+#include <stdlib.h>\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+struct stack {\n+\tvoid **item;\n+\tsize_t size;\n+\tsize_t asize;\n+};\n+\n+void stack_free(struct stack *);\n+int stack_grow(struct stack *, size_t);\n+int stack_init(struct stack *, size_t);\n+\n+int stack_push(struct stack *, void *);\n+\n+void *stack_pop(struct stack *);\n+void *stack_top(struct stack *);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif"}, {"sha": "bcaa3b9086cf3e5deda357aa10f519cfe157bef2", "filename": "src/test/compile-fail/borrowck-anon-fields-struct.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-struct.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -34,4 +34,4 @@ fn same_variant() {\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "de2a8d83268089cc692fed36d3d4626821bfd798", "filename": "src/test/compile-fail/borrowck-anon-fields-tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-tuple.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -32,4 +32,4 @@ fn same_variant() {\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "da0a9323d2c8178da4b8cff2cf4db54e790596c8", "filename": "src/test/compile-fail/borrowck-anon-fields-variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-anon-fields-variant.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -40,4 +40,4 @@ fn same_variant() {\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c142876c5c2c5c60bb10cf9ba45b9eb020ff4a8e", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-free.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-free.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -40,4 +40,4 @@ fn explicit() {\n         rewrite(&mut a)); //~ ERROR cannot borrow\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "622d2e78ee7946666df589d63e01f272e354012c", "filename": "src/test/compile-fail/borrowck-bad-nested-calls-move.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-bad-nested-calls-move.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -40,4 +40,4 @@ fn explicit() {\n         a); //~ ERROR cannot move\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "628ccd1a5d782e537c4de34007e732d4b38f7290", "filename": "src/test/compile-fail/borrowck-move-in-irrefut-pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-in-irrefut-pat.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -13,4 +13,4 @@ fn let_pat() {\n     //~^ ERROR cannot move out of dereference of & pointer\n }\n \n-pub fn main() {}\n\\ No newline at end of file\n+pub fn main() {}"}, {"sha": "565629b1c306df59cae114fcbe10da62c6e6a9b4", "filename": "src/test/compile-fail/borrowck-move-mut-base-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-move-mut-base-ptr.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -12,4 +12,4 @@ fn foo(t0: &mut int) {\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ab6f70945be6cab8a66db1bd2da1ccb92ee24273", "filename": "src/test/compile-fail/borrowck-swap-mut-base-ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-swap-mut-base-ptr.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -13,4 +13,4 @@ fn foo<'a>(mut t0: &'a mut int,\n }\n \n fn main() {\n-}\n\\ No newline at end of file\n+}"}, {"sha": "0a94d6c456081d9cb794103164d35e33c5731d2d", "filename": "src/test/compile-fail/cast-immutable-mutable-trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fcast-immutable-mutable-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fcast-immutable-mutable-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-immutable-mutable-trait.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -25,4 +25,4 @@ fn main() {\n     let s = @S { unused: 0 };\n     let _s2 = s as @mut T; //~ error: types differ in mutability\n     let _s3 = &s as &mut T; //~ error: types differ in mutability\n-}\n\\ No newline at end of file\n+}"}, {"sha": "ce58b260f61860ef6dd2107cd17770a2964ce90a", "filename": "src/test/compile-fail/cast-vector-to-unsafe-nonstatic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcast-vector-to-unsafe-nonstatic.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -11,4 +11,4 @@\n fn main() {\n     let foo = ['h' as u8, 'i' as u8, 0 as u8];\n     let bar = &foo as *u8; //~ ERROR mismatched types\n-}\n\\ No newline at end of file\n+}"}, {"sha": "fbf1acb60665b307c9b5d6fc4c5fa6ea779fb049", "filename": "src/test/compile-fail/closure-bounds-not-builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-not-builtin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-not-builtin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fclosure-bounds-not-builtin.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -5,4 +5,4 @@ fn take(f: &fn:Foo()) {\n     //~^ ERROR only the builtin traits can be used as closure or object bounds\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "2c3fbc827aad689e390fd9a517151a9d57a02a97", "filename": "src/test/compile-fail/coherence_inherent.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -42,4 +42,4 @@ mod NoImport {\n     }\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "40d733f8bab5c101d2826adaf73ef53e98412c99", "filename": "src/test/compile-fail/coherence_inherent_cc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcoherence_inherent_cc.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -35,4 +35,4 @@ mod NoImport {\n     }\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "e4576e0f57c54122c5c7e87cf4bd0b864a6a36ff", "filename": "src/test/compile-fail/deprecated-auto-code.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fdeprecated-auto-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fdeprecated-auto-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fdeprecated-auto-code.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -12,4 +12,4 @@\n #[auto_decode] //~ ERROR: `#[auto_decode]` is deprecated\n struct A;\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "ea8ee8699e4821742811fb39dd7a20efcc1d2acc", "filename": "src/test/compile-fail/issue-2995.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-2995.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -12,4 +12,4 @@ fn bad (p: *int) {\n     let _q: &int = p as &int; //~ ERROR non-scalar cast\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "6f410ea3c3739f5576cc8a9aef338745ea332e2c", "filename": "src/test/compile-fail/issue-4736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -12,4 +12,4 @@ struct NonCopyable(());\n \n fn main() {\n     let z = NonCopyable{ p: () }; //~ ERROR structure has no field named `p`\n-}\n\\ No newline at end of file\n+}"}, {"sha": "14dcc4ea8a3a89d2ce2a52ee7bd975eb833af4b0", "filename": "src/test/compile-fail/issue-6762.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fissue-6762.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fissue-6762.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-6762.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -21,4 +21,4 @@ fn main()\n \n       twice(x);\n       invoke(sq);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "6b5055cb1a2cdd11bb370a0bf4ee33078c644767", "filename": "src/test/compile-fail/lub-if.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Flub-if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-if.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -49,4 +49,4 @@ pub fn opt_str3<'a>(maybestr: &'a Option<~str>) -> &'static str {\n }\n \n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "37b9cc55dc8226eaeea8e00d6d72f12e2e35f191", "filename": "src/test/compile-fail/lub-match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Flub-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flub-match.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -52,4 +52,4 @@ pub fn opt_str3<'a>(maybestr: &'a Option<~str>) -> &'static str {\n     }\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "ef3f8140c68a043e9c21faa09702fed28c45c532", "filename": "src/test/compile-fail/main-wrong-location.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fmain-wrong-location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fmain-wrong-location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmain-wrong-location.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -12,4 +12,4 @@ mod m {\n     // An inferred main entry point (that doesn't use #[main])\n     // must appear at the top of the crate\n     fn main() { } //~ NOTE here is a function named 'main'\n-}\n\\ No newline at end of file\n+}"}, {"sha": "66ab4b7705433851896c2f167a315e05bac63d9e", "filename": "src/test/compile-fail/regions-free-region-ordering-callee.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-callee.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -34,4 +34,4 @@ fn ordering4<'a, 'b>(a: &'a uint, b: &'b uint, x: &fn(&'a &'b uint)) {\n     let z: Option<&'a &'b uint> = None;\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "c9859899ea4f1132349beea335a804839711b4bb", "filename": "src/test/compile-fail/regions-free-region-ordering-caller.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-free-region-ordering-caller.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -37,4 +37,4 @@ fn call4<'a, 'b>(a: &'a uint, b: &'b uint) {\n }\n \n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "4848262750720fc61766f40f9f48786ab25e2e1b", "filename": "src/test/compile-fail/regions-ref-in-fn-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregions-ref-in-fn-arg.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -8,4 +8,4 @@ fn arg_closure() -> &'static int {\n     with(|~ref x| x) //~ ERROR borrowed value does not live long enough\n }\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "e40bca58bad75f0f25ae5734febb80de564e5c90", "filename": "src/test/compile-fail/suppressed-error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsuppressed-error.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -11,4 +11,4 @@\n fn main() {\n     let (x, y) = (); //~ ERROR expected `()` but found tuple (types differ)\n     return x;\n-}\n\\ No newline at end of file\n+}"}, {"sha": "a5f85a685e6958ce63b639bdd39956db3b3730b0", "filename": "src/test/compile-fail/tag-variant-disr-dup.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftag-variant-disr-dup.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -20,4 +20,4 @@ enum color {\n     white = 0x000000,\n }\n \n-fn main() { }\n\\ No newline at end of file\n+fn main() { }"}, {"sha": "7c41c5d12e6000a52d537e52d1689817a7d3d528", "filename": "src/test/compile-fail/type-parameter-names.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Ftype-parameter-names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Fcompile-fail%2Ftype-parameter-names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftype-parameter-names.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -3,4 +3,4 @@\n \n fn foo<Foo, Bar>(x: Foo) -> Bar { x } //~ ERROR expected `Bar` but found `Foo`\n \n-fn main() {}\n\\ No newline at end of file\n+fn main() {}"}, {"sha": "0e7572220a8b45ceca4181361516f3d5b75955b6", "filename": "src/test/run-pass/borrowck-scope-of-deref-issue-4666.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fborrowck-scope-of-deref-issue-4666.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fborrowck-scope-of-deref-issue-4666.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fborrowck-scope-of-deref-issue-4666.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -47,4 +47,4 @@ fn fun2() {\n pub fn main() {\n     fun1();\n     fun2();\n-}\n\\ No newline at end of file\n+}"}, {"sha": "74698b9db28bc79defe796036a9b646f9cc6fcad", "filename": "src/test/run-pass/deriving-via-extension-struct-empty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-via-extension-struct-empty.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -14,4 +14,4 @@ struct Foo;\n pub fn main() {\n   assert_eq!(Foo, Foo);\n   assert!(!(Foo != Foo));\n-}\n\\ No newline at end of file\n+}"}, {"sha": "c7ba345517cd6193c6040e5a88d757816e6974f6", "filename": "src/test/run-pass/issue-4252.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fissue-4252.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-4252.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -34,4 +34,4 @@ impl<T: X> Drop for Z<T> {\n fn main() {\n     let y = Y;\n     let _z = Z{x: y};\n-}\n\\ No newline at end of file\n+}"}, {"sha": "730ed18fbbd4540397cee745af724703daa56467", "filename": "src/test/run-pass/xc_conditions_client.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fxc_conditions_client.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fxc_conditions_client.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxc_conditions_client.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -37,4 +37,4 @@ pub fn main() {\n         let x = trouble();\n         assert_eq!(x,12345);\n     }\n-}\n\\ No newline at end of file\n+}"}, {"sha": "69ddb3701b09951ae95100a0834d54f3dcebee9f", "filename": "src/test/run-pass/xc_conditions_client_4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fxc_conditions_client_4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/41826c48eddfb964b830229dff6f0480ac649827/src%2Ftest%2Frun-pass%2Fxc_conditions_client_4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fxc_conditions_client_4.rs?ref=41826c48eddfb964b830229dff6f0480ac649827", "patch": "@@ -29,4 +29,4 @@ pub fn main() {\n         let t = SThunk { x : 10 };\n         assert_eq!(xcc::callback(t), xcc::Red)\n     }\n-}\n\\ No newline at end of file\n+}"}]}