{"sha": "8563a193847ff404f4f49f8dfdac2785cfb035bb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NjNhMTkzODQ3ZmY0MDRmNGY0OWY4ZGZkYWMyNzg1Y2ZiMDM1YmI=", "commit": {"author": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-03-10T03:37:21Z"}, "committer": {"name": "Camelid", "email": "camelidcamel@gmail.com", "date": "2021-04-08T01:03:38Z"}, "message": "Document `Res` and its friends", "tree": {"sha": "cc7e49a6b4cbc6caaaec79dbfdf6f1a00f994870", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc7e49a6b4cbc6caaaec79dbfdf6f1a00f994870"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8563a193847ff404f4f49f8dfdac2785cfb035bb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8563a193847ff404f4f49f8dfdac2785cfb035bb", "html_url": "https://github.com/rust-lang/rust/commit/8563a193847ff404f4f49f8dfdac2785cfb035bb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8563a193847ff404f4f49f8dfdac2785cfb035bb/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a5d45f68cadc8fff4fbb557780f92b403b19c19", "url": "https://api.github.com/repos/rust-lang/rust/commits/3a5d45f68cadc8fff4fbb557780f92b403b19c19", "html_url": "https://github.com/rust-lang/rust/commit/3a5d45f68cadc8fff4fbb557780f92b403b19c19"}], "stats": {"total": 155, "additions": 142, "deletions": 13}, "files": [{"sha": "de10d88c1d250b8e6e6462a2e3fc0b8e2b3b96c6", "filename": "compiler/rustc_hir/src/def.rs", "status": "modified", "additions": 142, "deletions": 13, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/8563a193847ff404f4f49f8dfdac2785cfb035bb/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8563a193847ff404f4f49f8dfdac2785cfb035bb/compiler%2Frustc_hir%2Fsrc%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fdef.rs?ref=8563a193847ff404f4f49f8dfdac2785cfb035bb", "patch": "@@ -20,6 +20,7 @@ pub enum CtorOf {\n     Variant,\n }\n \n+/// What kind of constructor something is.\n #[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum CtorKind {\n@@ -31,6 +32,7 @@ pub enum CtorKind {\n     Fictive,\n }\n \n+/// An attribute that is not a macro; e.g., `#[inline]` or `#[rustfmt::skip]`.\n #[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum NonMacroAttrKind {\n@@ -47,33 +49,51 @@ pub enum NonMacroAttrKind {\n     Registered,\n }\n \n+/// What kind of definition something is; e.g., `mod` vs `struct`.\n #[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum DefKind {\n     // Type namespace\n     Mod,\n-    /// Refers to the struct itself, `DefKind::Ctor` refers to its constructor if it exists.\n+    /// Refers to the struct itself, [`DefKind::Ctor`] refers to its constructor if it exists.\n     Struct,\n     Union,\n     Enum,\n-    /// Refers to the variant itself, `DefKind::Ctor` refers to its constructor if it exists.\n+    /// Refers to the variant itself, [`DefKind::Ctor`] refers to its constructor if it exists.\n     Variant,\n     Trait,\n-    /// `type Foo = Bar;`\n+    /// Type alias: `type Foo = Bar;`\n     TyAlias,\n+    /// Type from an `extern` block.\n     ForeignTy,\n+    /// Trait alias: `trait IntIterator = Iterator<Item = i32>;`\n     TraitAlias,\n+    /// Associated type: `trait MyTrait { type Assoc; }`\n     AssocTy,\n+    /// Type parameter: the `T` in `struct Vec<T> { ... }`\n     TyParam,\n \n     // Value namespace\n     Fn,\n     Const,\n+    /// Constant generic parameter: `struct Foo<const N: usize> { ... }`\n     ConstParam,\n     Static,\n     /// Refers to the struct or enum variant's constructor.\n+    ///\n+    /// The reason `Ctor` exists in addition to [`DefKind::Struct`] and\n+    /// [`DefKind::Variant`] is because structs and enum variants exist\n+    /// in the *type* namespace, whereas struct and enum variant *constructors*\n+    /// exist in the *value* namespace.\n+    ///\n+    /// You may wonder why enum variants exist in the type namespace as opposed\n+    /// to the value namespace. Check out [RFC 2593] for intuition on why that is.\n+    ///\n+    /// [RFC 2593]: https://github.com/rust-lang/rfcs/pull/2593\n     Ctor(CtorOf, CtorKind),\n+    /// Associated function: `impl MyStruct { fn associated() {} }`\n     AssocFn,\n+    /// Associated constant: `trait MyTrait { const ASSOC: usize; }`\n     AssocConst,\n \n     // Macro namespace\n@@ -82,11 +102,16 @@ pub enum DefKind {\n     // Not namespaced (or they are, but we don't treat them so)\n     ExternCrate,\n     Use,\n+    /// An `extern` block.\n     ForeignMod,\n+    /// Anonymous constant, e.g. the `1 + 2` in `[u8; 1 + 2]`, or `const { 1 + 2}`\n     AnonConst,\n+    /// Opaque type, aka `impl Trait`.\n     OpaqueTy,\n     Field,\n+    /// Lifetime parameter: the `'a` in `struct Foo<'a> { ... }`\n     LifetimeParam,\n+    /// A use of [`global_asm!`].\n     GlobalAsm,\n     Impl,\n     Closure,\n@@ -196,35 +221,130 @@ impl DefKind {\n }\n \n /// The resolution of a path or export.\n+///\n+/// For every path or identifier in Rust, the compiler must determine\n+/// what the path refers to. This process is called name resolution,\n+/// and `Res` is the primary result of name resolution.\n+///\n+/// For example, everything prefixed with `/* Res */` in this example has\n+/// an associated `Res`:\n+///\n+/// ```\n+/// fn str_to_string(s: & /* Res */ str) -> /* Res */ String {\n+///     /* Res */ String::from(/* Res */ s)\n+/// }\n+///\n+/// /* Res */ str_to_string(\"hello\");\n+/// ```\n+///\n+/// The associated `Res`s will be:\n+///\n+/// - `str` will resolve to [`Res::PrimTy`];\n+/// - `String` will resolve to [`Res::Def`], and the `Res` will include the [`DefId`]\n+///   for `String` as defined in the standard library;\n+/// - `String::from` will also resolve to [`Res::Def`], with the [`DefId`]\n+///   pointing to `String::from`;\n+/// - `s` will resolve to [`Res::Local`];\n+/// - the call to `str_to_string` will resolve to [`Res::Def`], with the [`DefId`]\n+///   pointing to the definition of `str_to_string` in the current crate.\n+//\n #[derive(Clone, Copy, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n pub enum Res<Id = hir::HirId> {\n+    /// Definition having a unique ID (`DefId`), corresponds to something defined in user code.\n+    ///\n+    /// **Not bound to a specific namespace.**\n     Def(DefKind, DefId),\n \n     // Type namespace\n+    /// A primitive type such as `i32` or `str`.\n+    ///\n+    /// **Belongs to the type namespace.**\n     PrimTy(hir::PrimTy),\n-    /// `Self`, with both an optional trait and impl `DefId`.\n+    /// The `Self` type, optionally with the trait it is associated with\n+    /// and optionally with the [`DefId`] of the impl it is associated with.\n+    ///\n+    /// **Belongs to the type namespace.**\n+    ///\n+    /// For example, the `Self` in\n     ///\n-    /// HACK(min_const_generics): impl self types also have an optional requirement to not mention\n+    /// ```\n+    /// trait Foo {\n+    ///     fn foo() -> Box<Self>;\n+    /// }\n+    /// ```\n+    ///\n+    /// would have the [`DefId`] of `Foo` associated with it. The `Self` in\n+    ///\n+    /// ```\n+    /// struct Bar;\n+    ///\n+    /// impl Bar {\n+    ///     fn new() -> Self { Bar }\n+    /// }\n+    /// ```\n+    ///\n+    /// would have the [`DefId`] of the impl associated with it. Finally, the `Self` in\n+    ///\n+    /// ```\n+    /// impl Foo for Bar {\n+    ///     fn foo() -> Box<Self> { Box::new(Bar) }\n+    /// }\n+    /// ```\n+    ///\n+    /// would have both the [`DefId`] of `Foo` and the [`DefId`] of the impl\n+    /// associated with it.\n+    ///\n+    /// *See also [`Res::SelfCtor`].*\n+    ///\n+    /// -----\n+    ///\n+    /// HACK(min_const_generics): impl self types also have an optional requirement to **not** mention\n     /// any generic parameters to allow the following with `min_const_generics`:\n-    /// ```rust\n-    /// impl Foo { fn test() -> [u8; std::mem::size_of::<Self>()] {} }\n+    /// ```\n+    /// impl Foo { fn test() -> [u8; std::mem::size_of::<Self>()] { todo!() } }\n     /// ```\n     /// We do however allow `Self` in repeat expression even if it is generic to not break code\n     /// which already works on stable while causing the `const_evaluatable_unchecked` future compat lint.\n     ///\n     /// FIXME(lazy_normalization_consts): Remove this bodge once that feature is stable.\n-    SelfTy(Option<DefId> /* trait */, Option<(DefId, bool)> /* impl */),\n-    ToolMod, // e.g., `rustfmt` in `#[rustfmt::skip]`\n+    SelfTy(\n+        /// Optionally, the trait associated with this `Self` type.\n+        Option<DefId>,\n+        /// Optionally, the impl associated with this `Self` type.\n+        Option<(DefId, bool)>,\n+    ),\n+    /// A tool attribute module; e.g., the `rustfmt` in `#[rustfmt::skip]`.\n+    ///\n+    /// **Belongs to the type namespace.**\n+    ToolMod,\n \n     // Value namespace\n-    SelfCtor(DefId /* impl */), // `DefId` refers to the impl\n+    /// The `Self` constructor, along with the [`DefId`]\n+    /// of the impl it is associated with.\n+    ///\n+    /// **Belongs to the value namespace.**\n+    ///\n+    /// *See also [`Res::SelfTy`].*\n+    SelfCtor(DefId),\n+    /// A local variable or function parameter.\n+    ///\n+    /// **Belongs to the value namespace.**\n     Local(Id),\n \n     // Macro namespace\n+    /// An attribute that is *not* implemented via macro.\n+    /// E.g., `#[inline]` and `#[rustfmt::skip]`, which are essentially directives,\n+    /// as opposed to `#[test]`, which is a builtin macro.\n+    ///\n+    /// **Belongs to the macro namespace.**\n     NonMacroAttr(NonMacroAttrKind), // e.g., `#[inline]` or `#[rustfmt::skip]`\n \n     // All namespaces\n+    /// Name resolution failed. We use a dummy `Res` variant so later phases\n+    /// of the compiler won't crash and can instead report more errors.\n+    ///\n+    /// **Not bound to a specific namespace.**\n     Err,\n }\n \n@@ -275,17 +395,26 @@ impl PartialRes {\n     }\n }\n \n-/// Different kinds of symbols don't influence each other.\n-///\n-/// Therefore, they have a separate universe (namespace).\n+/// Different kinds of symbols can coexist even if they share the same textual name.\n+/// Therefore, they each have a separate universe (known as a \"namespace\").\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub enum Namespace {\n+    /// The type namespace includes `struct`s, `enum`s, `union`s, `trait`s, and `mod`s\n+    /// (and, by extension, crates).\n+    ///\n+    /// Note that the type namespace includes other items; this is not an\n+    /// exhaustive list.\n     TypeNS,\n+    /// The value namespace includes `fn`s, `const`s, `static`s, and local variables (including function arguments).\n     ValueNS,\n+    /// The macro namespace includes `macro_rules!` macros, declarative `macro`s,\n+    /// procedural macros, attribute macros, `derive` macros, and non-macro attributes\n+    /// like `#[inline]` and `#[rustfmt::skip]`.\n     MacroNS,\n }\n \n impl Namespace {\n+    /// The English description of the namespace.\n     pub fn descr(self) -> &'static str {\n         match self {\n             Self::TypeNS => \"type\","}]}