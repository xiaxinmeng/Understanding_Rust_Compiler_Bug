{"sha": "69bacd002b432292f5b0fdf76b4fad1432473f36", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY5YmFjZDAwMmI0MzIyOTJmNWIwZmRmNzZiNGZhZDE0MzI0NzNmMzY=", "commit": {"author": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-01-08T05:05:26Z"}, "committer": {"name": "John K\u00e5re Alsaker", "email": "john.kare.alsaker@gmail.com", "date": "2020-01-09T21:37:05Z"}, "message": "Precompile CGUs while the main thread has the implicit job server token", "tree": {"sha": "5d28a1a098c34cdd9480ffeb68915aa682984dba", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d28a1a098c34cdd9480ffeb68915aa682984dba"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69bacd002b432292f5b0fdf76b4fad1432473f36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69bacd002b432292f5b0fdf76b4fad1432473f36", "html_url": "https://github.com/rust-lang/rust/commit/69bacd002b432292f5b0fdf76b4fad1432473f36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69bacd002b432292f5b0fdf76b4fad1432473f36/comments", "author": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Zoxc", "id": 25784, "node_id": "MDQ6VXNlcjI1Nzg0", "avatar_url": "https://avatars.githubusercontent.com/u/25784?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Zoxc", "html_url": "https://github.com/Zoxc", "followers_url": "https://api.github.com/users/Zoxc/followers", "following_url": "https://api.github.com/users/Zoxc/following{/other_user}", "gists_url": "https://api.github.com/users/Zoxc/gists{/gist_id}", "starred_url": "https://api.github.com/users/Zoxc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Zoxc/subscriptions", "organizations_url": "https://api.github.com/users/Zoxc/orgs", "repos_url": "https://api.github.com/users/Zoxc/repos", "events_url": "https://api.github.com/users/Zoxc/events{/privacy}", "received_events_url": "https://api.github.com/users/Zoxc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f45758cddc962248dc46d8c051f9f3a73ef50c14", "url": "https://api.github.com/repos/rust-lang/rust/commits/f45758cddc962248dc46d8c051f9f3a73ef50c14", "html_url": "https://github.com/rust-lang/rust/commit/f45758cddc962248dc46d8c051f9f3a73ef50c14"}], "stats": {"total": 103, "additions": 65, "deletions": 38}, "files": [{"sha": "3e39fa7c8f36d319bcfe5fc79310439aa12c4063", "filename": "src/librustc_codegen_ssa/base.rs", "status": "modified", "additions": 63, "deletions": 38, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/69bacd002b432292f5b0fdf76b4fad1432473f36/src%2Flibrustc_codegen_ssa%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69bacd002b432292f5b0fdf76b4fad1432473f36/src%2Flibrustc_codegen_ssa%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fbase.rs?ref=69bacd002b432292f5b0fdf76b4fad1432473f36", "patch": "@@ -609,54 +609,75 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     let total_codegen_time = Lock::new(Duration::new(0, 0));\n \n-    let cgu_reuse: Vec<_> = tcx.sess.time(\"find cgu reuse\", || {\n-        codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect()\n-    });\n-\n-    let mut cgus: FxHashMap<usize, _> = if cfg!(parallel_compiler) {\n-        tcx.sess.time(\"compile first CGUs\", || {\n-            // Try to find one CGU to compile per thread.\n-            let cgus: Vec<_> = cgu_reuse\n-                .iter()\n-                .enumerate()\n-                .filter(|&(_, reuse)| reuse == &CguReuse::No)\n-                .take(tcx.sess.threads())\n-                .collect();\n-\n-            // Compile the found CGUs in parallel.\n-            par_iter(cgus)\n-                .map(|(i, _)| {\n-                    let start_time = Instant::now();\n-                    let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n-                    let mut time = total_codegen_time.lock();\n-                    *time += start_time.elapsed();\n-                    (i, module)\n-                })\n-                .collect()\n-        })\n-    } else {\n-        FxHashMap::default()\n+    // The non-parallel compiler can only translate codegen units to LLVM IR\n+    // on a single thread, leading to a staircase effect where the N LLVM\n+    // threads have to wait on the single codegen threads to generate work\n+    // for them. The parallel compiler does not have this restriction, so\n+    // we can pre-load the LLVM queue in parallel before handing off\n+    // coordination to the OnGoingCodegen scheduler.\n+    //\n+    // This likely is a temporary measure. Once we don't have to support the\n+    // non-parallel compiler anymore, we can compile CGUs end-to-end in\n+    // parallel and get rid of the complicated scheduling logic.\n+    let pre_compile_cgus = |cgu_reuse: &[CguReuse]| {\n+        if cfg!(parallel_compiler) {\n+            tcx.sess.time(\"compile_first_CGU_batch\", || {\n+                // Try to find one CGU to compile per thread.\n+                let cgus: Vec<_> = cgu_reuse\n+                    .iter()\n+                    .enumerate()\n+                    .filter(|&(_, reuse)| reuse == &CguReuse::No)\n+                    .take(tcx.sess.threads())\n+                    .collect();\n+\n+                // Compile the found CGUs in parallel.\n+                par_iter(cgus)\n+                    .map(|(i, _)| {\n+                        let start_time = Instant::now();\n+                        let module = backend.compile_codegen_unit(tcx, codegen_units[i].name());\n+                        let mut time = total_codegen_time.lock();\n+                        *time += start_time.elapsed();\n+                        (i, module)\n+                    })\n+                    .collect()\n+            })\n+        } else {\n+            FxHashMap::default()\n+        }\n     };\n \n-    let mut total_codegen_time = total_codegen_time.into_inner();\n+    let mut cgu_reuse = Vec::new();\n+    let mut pre_compiled_cgus: Option<FxHashMap<usize, _>> = None;\n \n-    for (i, cgu) in codegen_units.into_iter().enumerate() {\n+    for (i, cgu) in codegen_units.iter().enumerate() {\n         ongoing_codegen.wait_for_signal_to_codegen_item();\n         ongoing_codegen.check_for_errors(tcx.sess);\n \n+        // Do some setup work in the first iteration\n+        if pre_compiled_cgus.is_none() {\n+            // Calculate the CGU reuse\n+            cgu_reuse = tcx.sess.time(\"find_cgu_reuse\", || {\n+                codegen_units.iter().map(|cgu| determine_cgu_reuse(tcx, &cgu)).collect()\n+            });\n+            // Pre compile some CGUs\n+            pre_compiled_cgus = Some(pre_compile_cgus(&cgu_reuse));\n+        }\n+\n         let cgu_reuse = cgu_reuse[i];\n         tcx.sess.cgu_reuse_tracker.set_actual_reuse(&cgu.name().as_str(), cgu_reuse);\n \n         match cgu_reuse {\n             CguReuse::No => {\n-                let (module, cost) = if let Some(cgu) = cgus.remove(&i) {\n-                    cgu\n-                } else {\n-                    let start_time = Instant::now();\n-                    let module = backend.compile_codegen_unit(tcx, cgu.name());\n-                    total_codegen_time += start_time.elapsed();\n-                    module\n-                };\n+                let (module, cost) =\n+                    if let Some(cgu) = pre_compiled_cgus.as_mut().unwrap().remove(&i) {\n+                        cgu\n+                    } else {\n+                        let start_time = Instant::now();\n+                        let module = backend.compile_codegen_unit(tcx, cgu.name());\n+                        let mut time = total_codegen_time.lock();\n+                        *time += start_time.elapsed();\n+                        module\n+                    };\n                 submit_codegened_module_to_llvm(\n                     &backend,\n                     &ongoing_codegen.coordinator_send,\n@@ -695,7 +716,11 @@ pub fn codegen_crate<B: ExtraBackendMethods>(\n \n     // Since the main thread is sometimes blocked during codegen, we keep track\n     // -Ztime-passes output manually.\n-    print_time_passes_entry(tcx.sess.time_passes(), \"codegen_to_LLVM_IR\", total_codegen_time);\n+    print_time_passes_entry(\n+        tcx.sess.time_passes(),\n+        \"codegen_to_LLVM_IR\",\n+        total_codegen_time.into_inner(),\n+    );\n \n     ::rustc_incremental::assert_module_sources::assert_module_sources(tcx);\n "}, {"sha": "bc3a75250bf703f0b20606c8113c2f3831ea1979", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/69bacd002b432292f5b0fdf76b4fad1432473f36/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69bacd002b432292f5b0fdf76b4fad1432473f36/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=69bacd002b432292f5b0fdf76b4fad1432473f36", "patch": "@@ -48,6 +48,8 @@ pub trait ExtraBackendMethods: CodegenBackend + WriteBackendMethods + Sized + Se\n         mods: &mut Self::Module,\n         kind: AllocatorKind,\n     );\n+    /// This generates the codegen unit and returns it along with\n+    /// a `u64` giving an estimate of the unit's processing cost.\n     fn compile_codegen_unit(\n         &self,\n         tcx: TyCtxt<'_>,"}]}