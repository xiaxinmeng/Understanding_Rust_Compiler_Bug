{"sha": "85757be59aa401f250cadb50a4f6d75ffb526249", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1NzU3YmU1OWFhNDAxZjI1MGNhZGI1MGE0ZjZkNzVmZmI1MjYyNDk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-02T23:00:45Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-04-02T23:00:45Z"}, "message": "Allow interning strings", "tree": {"sha": "35822d50eee5433a236b2281db15e3fbefeb9deb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35822d50eee5433a236b2281db15e3fbefeb9deb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/85757be59aa401f250cadb50a4f6d75ffb526249", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/85757be59aa401f250cadb50a4f6d75ffb526249", "html_url": "https://github.com/rust-lang/rust/commit/85757be59aa401f250cadb50a4f6d75ffb526249", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/85757be59aa401f250cadb50a4f6d75ffb526249/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8e3e13f3a41b311c82fa5859c5bfebbbcd82cad4", "url": "https://api.github.com/repos/rust-lang/rust/commits/8e3e13f3a41b311c82fa5859c5bfebbbcd82cad4", "html_url": "https://github.com/rust-lang/rust/commit/8e3e13f3a41b311c82fa5859c5bfebbbcd82cad4"}], "stats": {"total": 55, "additions": 46, "deletions": 9}, "files": [{"sha": "d163f633f303f599c9d7606ea32b406fe8d5f4e7", "filename": "crates/hir_def/src/intern.rs", "status": "modified", "additions": 46, "deletions": 9, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/85757be59aa401f250cadb50a4f6d75ffb526249/crates%2Fhir_def%2Fsrc%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/85757be59aa401f250cadb50a4f6d75ffb526249/crates%2Fhir_def%2Fsrc%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fintern.rs?ref=85757be59aa401f250cadb50a4f6d75ffb526249", "patch": "@@ -3,17 +3,20 @@\n //! Eventually this should probably be replaced with salsa-based interning.\n \n use std::{\n+    collections::HashMap,\n     fmt::{self, Debug},\n     hash::{BuildHasherDefault, Hash},\n     ops::Deref,\n     sync::Arc,\n };\n \n-use dashmap::{DashMap, SharedValue};\n+use dashmap::{lock::RwLockWriteGuard, DashMap, SharedValue};\n use once_cell::sync::OnceCell;\n use rustc_hash::FxHasher;\n \n type InternMap<T> = DashMap<Arc<T>, (), BuildHasherDefault<FxHasher>>;\n+type Guard<T> =\n+    RwLockWriteGuard<'static, HashMap<Arc<T>, SharedValue<()>, BuildHasherDefault<FxHasher>>>;\n \n #[derive(Hash)]\n pub struct Interned<T: Internable + ?Sized> {\n@@ -22,10 +25,22 @@ pub struct Interned<T: Internable + ?Sized> {\n \n impl<T: Internable> Interned<T> {\n     pub fn new(obj: T) -> Self {\n+        match Interned::lookup(&obj) {\n+            Ok(this) => this,\n+            Err(shard) => {\n+                let arc = Arc::new(obj);\n+                Self::alloc(arc, shard)\n+            }\n+        }\n+    }\n+}\n+\n+impl<T: Internable + ?Sized> Interned<T> {\n+    fn lookup(obj: &T) -> Result<Self, Guard<T>> {\n         let storage = T::storage().get();\n-        let shard_idx = storage.determine_map(&obj);\n+        let shard_idx = storage.determine_map(obj);\n         let shard = &storage.shards()[shard_idx];\n-        let mut shard = shard.write();\n+        let shard = shard.write();\n \n         // Atomically,\n         // - check if `obj` is already in the map\n@@ -34,13 +49,15 @@ impl<T: Internable> Interned<T> {\n         // This needs to be atomic (locking the shard) to avoid races with other thread, which could\n         // insert the same object between us looking it up and inserting it.\n \n-        // FIXME: avoid double lookup by using raw entry API (once stable, or when hashbrown can be\n-        // plugged into dashmap)\n-        if let Some((arc, _)) = shard.get_key_value(&obj) {\n-            return Self { arc: arc.clone() };\n+        // FIXME: avoid double lookup/hashing by using raw entry API (once stable, or when\n+        // hashbrown can be plugged into dashmap)\n+        match shard.get_key_value(obj) {\n+            Some((arc, _)) => Ok(Self { arc: arc.clone() }),\n+            None => Err(shard),\n         }\n+    }\n \n-        let arc = Arc::new(obj);\n+    fn alloc(arc: Arc<T>, mut shard: Guard<T>) -> Self {\n         let arc2 = arc.clone();\n \n         shard.insert(arc2, SharedValue::new(()));\n@@ -49,6 +66,18 @@ impl<T: Internable> Interned<T> {\n     }\n }\n \n+impl Interned<str> {\n+    pub fn new_str(s: &str) -> Self {\n+        match Interned::lookup(s) {\n+            Ok(this) => this,\n+            Err(shard) => {\n+                let arc = Arc::<str>::from(s);\n+                Self::alloc(arc, shard)\n+            }\n+        }\n+    }\n+}\n+\n impl<T: Internable + ?Sized> Drop for Interned<T> {\n     #[inline]\n     fn drop(&mut self) {\n@@ -98,6 +127,14 @@ impl<T: Internable> PartialEq for Interned<T> {\n \n impl<T: Internable> Eq for Interned<T> {}\n \n+impl PartialEq for Interned<str> {\n+    fn eq(&self, other: &Self) -> bool {\n+        Arc::ptr_eq(&self.arc, &other.arc)\n+    }\n+}\n+\n+impl Eq for Interned<str> {}\n+\n impl<T: Internable + ?Sized> AsRef<T> for Interned<T> {\n     #[inline]\n     fn as_ref(&self) -> &T {\n@@ -157,4 +194,4 @@ macro_rules! impl_internable {\n     )+ };\n }\n \n-impl_internable!(crate::type_ref::TypeRef, crate::type_ref::TraitRef, crate::path::ModPath);\n+impl_internable!(crate::type_ref::TypeRef, crate::type_ref::TraitRef, crate::path::ModPath, str);"}]}