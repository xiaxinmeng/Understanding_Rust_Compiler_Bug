{"sha": "02f3c17593e653e30e8835500319ef412855fa34", "node_id": "C_kwDOAAsO6NoAKDAyZjNjMTc1OTNlNjUzZTMwZTg4MzU1MDAzMTllZjQxMjg1NWZhMzQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-18T10:55:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-18T10:55:05Z"}, "message": "Auto merge of #8419 - flip1995:await_parking_alot, r=llogiq\n\nFix `await_holding_lock` not linting `parking_lot` Mutex/RwLock\n\nThis adds tests for `RwLock` and `parking_lot::{Mutex, RwLock}`, which were added before in https://github.com/rust-lang/rust-clippy/commit/2dc8c083f54454ca87bb09d691577eada2d23539, but never tested in UI tests. I noticed this while reading [fasterthanli.me](https://fasterthanli.me/articles/a-rust-match-made-in-hell) latest blog post, complaining that Clippy doesn't catch this for `parking_lot`. (Too many people read his blog, he's too powerful)\n\nSome more things:\n- Adds a test for #6446\n- Improves the lint message\n\nchangelog: [`await_holding_lock`]: Now also lints for `parking_lot::{Mutex, RwLock}`", "tree": {"sha": "9d8ca5bce443e385eb2507e961c8d84872028629", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d8ca5bce443e385eb2507e961c8d84872028629"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02f3c17593e653e30e8835500319ef412855fa34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02f3c17593e653e30e8835500319ef412855fa34", "html_url": "https://github.com/rust-lang/rust/commit/02f3c17593e653e30e8835500319ef412855fa34", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02f3c17593e653e30e8835500319ef412855fa34/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "76f91b6f5a538f7b0389a5e7cc8cb8170a6d5117", "url": "https://api.github.com/repos/rust-lang/rust/commits/76f91b6f5a538f7b0389a5e7cc8cb8170a6d5117", "html_url": "https://github.com/rust-lang/rust/commit/76f91b6f5a538f7b0389a5e7cc8cb8170a6d5117"}, {"sha": "ea0ce7bb76bb01741fc3ba2ca32a80c75a380d0f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0ce7bb76bb01741fc3ba2ca32a80c75a380d0f", "html_url": "https://github.com/rust-lang/rust/commit/ea0ce7bb76bb01741fc3ba2ca32a80c75a380d0f"}], "stats": {"total": 582, "additions": 454, "deletions": 128}, "files": [{"sha": "f0979840ff8d8ab9d55d0a1426b5905ee10d23ec", "filename": "clippy_lints/src/await_holding_invalid.rs", "status": "modified", "additions": 82, "deletions": 37, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/02f3c17593e653e30e8835500319ef412855fa34/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f3c17593e653e30e8835500319ef412855fa34/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fawait_holding_invalid.rs?ref=02f3c17593e653e30e8835500319ef412855fa34", "patch": "@@ -1,4 +1,4 @@\n-use clippy_utils::diagnostics::span_lint_and_note;\n+use clippy_utils::diagnostics::span_lint_and_then;\n use clippy_utils::{match_def_path, paths};\n use rustc_hir::def_id::DefId;\n use rustc_hir::{AsyncGeneratorKind, Body, BodyId, GeneratorKind};\n@@ -9,8 +9,7 @@ use rustc_span::Span;\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to await while holding a\n-    /// non-async-aware MutexGuard.\n+    /// Checks for calls to await while holding a non-async-aware MutexGuard.\n     ///\n     /// ### Why is this bad?\n     /// The Mutex types found in std::sync and parking_lot\n@@ -22,77 +21,110 @@ declare_clippy_lint! {\n     /// either by introducing a scope or an explicit call to Drop::drop.\n     ///\n     /// ### Known problems\n-    /// Will report false positive for explicitly dropped guards ([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)).\n+    /// Will report false positive for explicitly dropped guards\n+    /// ([#6446](https://github.com/rust-lang/rust-clippy/issues/6446)). A workaround for this is\n+    /// to wrap the `.lock()` call in a block instead of explicitly dropping the guard.\n     ///\n     /// ### Example\n-    /// ```rust,ignore\n-    /// use std::sync::Mutex;\n-    ///\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &Mutex<u32>) {\n-    ///   let guard = x.lock().unwrap();\n+    ///   let mut guard = x.lock().unwrap();\n     ///   *guard += 1;\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &Mutex<u32>) {\n+    ///   let mut guard = x.lock().unwrap();\n+    ///   *guard += 1;\n+    ///   drop(guard); // explicit drop\n+    ///   baz().await;\n     /// }\n     /// ```\n     ///\n     /// Use instead:\n-    /// ```rust,ignore\n-    /// use std::sync::Mutex;\n-    ///\n+    /// ```rust\n+    /// # use std::sync::Mutex;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &Mutex<u32>) {\n     ///   {\n-    ///     let guard = x.lock().unwrap();\n+    ///     let mut guard = x.lock().unwrap();\n     ///     *guard += 1;\n     ///   }\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &Mutex<u32>) {\n+    ///   {\n+    ///     let mut guard = x.lock().unwrap();\n+    ///     *guard += 1;\n+    ///   } // guard dropped here at end of scope\n+    ///   baz().await;\n     /// }\n     /// ```\n     #[clippy::version = \"1.45.0\"]\n     pub AWAIT_HOLDING_LOCK,\n-    pedantic,\n-    \"Inside an async function, holding a MutexGuard while calling await\"\n+    suspicious,\n+    \"inside an async function, holding a `MutexGuard` while calling `await`\"\n }\n \n declare_clippy_lint! {\n     /// ### What it does\n-    /// Checks for calls to await while holding a\n-    /// `RefCell` `Ref` or `RefMut`.\n+    /// Checks for calls to await while holding a `RefCell` `Ref` or `RefMut`.\n     ///\n     /// ### Why is this bad?\n     /// `RefCell` refs only check for exclusive mutable access\n     /// at runtime. Holding onto a `RefCell` ref across an `await` suspension point\n     /// risks panics from a mutable ref shared while other refs are outstanding.\n     ///\n     /// ### Known problems\n-    /// Will report false positive for explicitly dropped refs ([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)).\n+    /// Will report false positive for explicitly dropped refs\n+    /// ([#6353](https://github.com/rust-lang/rust-clippy/issues/6353)). A workaround for this is\n+    /// to wrap the `.borrow[_mut]()` call in a block instead of explicitly dropping the ref.\n     ///\n     /// ### Example\n-    /// ```rust,ignore\n-    /// use std::cell::RefCell;\n-    ///\n+    /// ```rust\n+    /// # use std::cell::RefCell;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &RefCell<u32>) {\n     ///   let mut y = x.borrow_mut();\n     ///   *y += 1;\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &RefCell<u32>) {\n+    ///   let mut y = x.borrow_mut();\n+    ///   *y += 1;\n+    ///   drop(y); // explicit drop\n+    ///   baz().await;\n     /// }\n     /// ```\n     ///\n     /// Use instead:\n-    /// ```rust,ignore\n-    /// use std::cell::RefCell;\n-    ///\n+    /// ```rust\n+    /// # use std::cell::RefCell;\n+    /// # async fn baz() {}\n     /// async fn foo(x: &RefCell<u32>) {\n     ///   {\n     ///      let mut y = x.borrow_mut();\n     ///      *y += 1;\n     ///   }\n-    ///   bar.await;\n+    ///   baz().await;\n+    /// }\n+    ///\n+    /// async fn bar(x: &RefCell<u32>) {\n+    ///   {\n+    ///     let mut y = x.borrow_mut();\n+    ///     *y += 1;\n+    ///   } // y dropped here at end of scope\n+    ///   baz().await;\n     /// }\n     /// ```\n     #[clippy::version = \"1.49.0\"]\n     pub AWAIT_HOLDING_REFCELL_REF,\n-    pedantic,\n-    \"Inside an async function, holding a RefCell ref while calling await\"\n+    suspicious,\n+    \"inside an async function, holding a `RefCell` ref while calling `await`\"\n }\n \n declare_lint_pass!(AwaitHolding => [AWAIT_HOLDING_LOCK, AWAIT_HOLDING_REFCELL_REF]);\n@@ -118,23 +150,36 @@ fn check_interior_types(cx: &LateContext<'_>, ty_causes: &[GeneratorInteriorType\n     for ty_cause in ty_causes {\n         if let rustc_middle::ty::Adt(adt, _) = ty_cause.ty.kind() {\n             if is_mutex_guard(cx, adt.did) {\n-                span_lint_and_note(\n+                span_lint_and_then(\n                     cx,\n                     AWAIT_HOLDING_LOCK,\n                     ty_cause.span,\n-                    \"this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this lock is held through\",\n+                    \"this `MutexGuard` is held across an `await` point\",\n+                    |diag| {\n+                        diag.help(\n+                            \"consider using an async-aware `Mutex` type or ensuring the \\\n+                                `MutexGuard` is dropped before calling await\",\n+                        );\n+                        diag.span_note(\n+                            ty_cause.scope_span.unwrap_or(span),\n+                            \"these are all the `await` points this lock is held through\",\n+                        );\n+                    },\n                 );\n             }\n             if is_refcell_ref(cx, adt.did) {\n-                span_lint_and_note(\n+                span_lint_and_then(\n                     cx,\n                     AWAIT_HOLDING_REFCELL_REF,\n                     ty_cause.span,\n-                    \"this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\",\n-                    ty_cause.scope_span.or(Some(span)),\n-                    \"these are all the await points this ref is held through\",\n+                    \"this `RefCell` reference is held across an `await` point\",\n+                    |diag| {\n+                        diag.help(\"ensure the reference is dropped before calling `await`\");\n+                        diag.span_note(\n+                            ty_cause.scope_span.unwrap_or(span),\n+                            \"these are all the `await` points this reference is held through\",\n+                        );\n+                    },\n                 );\n             }\n         }"}, {"sha": "a94f6b528b47bfba5e5000eb2fe985a1d3dabc4f", "filename": "clippy_lints/src/lib.register_all.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f3c17593e653e30e8835500319ef412855fa34/clippy_lints%2Fsrc%2Flib.register_all.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f3c17593e653e30e8835500319ef412855fa34/clippy_lints%2Fsrc%2Flib.register_all.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_all.rs?ref=02f3c17593e653e30e8835500319ef412855fa34", "patch": "@@ -14,6 +14,8 @@ store.register_group(true, \"clippy::all\", Some(\"clippy_all\"), vec![\n     LintId::of(attrs::DEPRECATED_SEMVER),\n     LintId::of(attrs::MISMATCHED_TARGET_OS),\n     LintId::of(attrs::USELESS_ATTRIBUTE),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(bit_mask::BAD_BIT_MASK),\n     LintId::of(bit_mask::INEFFECTIVE_BIT_MASK),\n     LintId::of(blacklisted_name::BLACKLISTED_NAME),"}, {"sha": "00d305131810df7418ae29eb519c660cbd954746", "filename": "clippy_lints/src/lib.register_pedantic.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f3c17593e653e30e8835500319ef412855fa34/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f3c17593e653e30e8835500319ef412855fa34/clippy_lints%2Fsrc%2Flib.register_pedantic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_pedantic.rs?ref=02f3c17593e653e30e8835500319ef412855fa34", "patch": "@@ -4,8 +4,6 @@\n \n store.register_group(true, \"clippy::pedantic\", Some(\"clippy_pedantic\"), vec![\n     LintId::of(attrs::INLINE_ALWAYS),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n-    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(bit_mask::VERBOSE_BIT_MASK),\n     LintId::of(borrow_as_ptr::BORROW_AS_PTR),\n     LintId::of(bytecount::NAIVE_BYTECOUNT),"}, {"sha": "da56f80080499e730fdf925b31ad702aa1dfec7c", "filename": "clippy_lints/src/lib.register_suspicious.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/02f3c17593e653e30e8835500319ef412855fa34/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f3c17593e653e30e8835500319ef412855fa34/clippy_lints%2Fsrc%2Flib.register_suspicious.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.register_suspicious.rs?ref=02f3c17593e653e30e8835500319ef412855fa34", "patch": "@@ -5,6 +5,8 @@\n store.register_group(true, \"clippy::suspicious\", Some(\"clippy_suspicious\"), vec![\n     LintId::of(assign_ops::MISREFACTORED_ASSIGN_OP),\n     LintId::of(attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_LOCK),\n+    LintId::of(await_holding_invalid::AWAIT_HOLDING_REFCELL_REF),\n     LintId::of(eval_order_dependence::EVAL_ORDER_DEPENDENCE),\n     LintId::of(float_equality_without_abs::FLOAT_EQUALITY_WITHOUT_ABS),\n     LintId::of(formatting::SUSPICIOUS_ASSIGNMENT_FORMATTING),"}, {"sha": "b54bd3a4fef0b0186b34433a4e910484d6def13b", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/02f3c17593e653e30e8835500319ef412855fa34/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f3c17593e653e30e8835500319ef412855fa34/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=02f3c17593e653e30e8835500319ef412855fa34", "patch": "@@ -105,9 +105,9 @@ pub const OS_STRING_AS_OS_STR: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsString\",\n pub const OS_STR_TO_OS_STRING: [&str; 5] = [\"std\", \"ffi\", \"os_str\", \"OsStr\", \"to_os_string\"];\n pub const PARKING_LOT_RAWMUTEX: [&str; 3] = [\"parking_lot\", \"raw_mutex\", \"RawMutex\"];\n pub const PARKING_LOT_RAWRWLOCK: [&str; 3] = [\"parking_lot\", \"raw_rwlock\", \"RawRwLock\"];\n-pub const PARKING_LOT_MUTEX_GUARD: [&str; 2] = [\"parking_lot\", \"MutexGuard\"];\n-pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockReadGuard\"];\n-pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 2] = [\"parking_lot\", \"RwLockWriteGuard\"];\n+pub const PARKING_LOT_MUTEX_GUARD: [&str; 3] = [\"lock_api\", \"mutex\", \"MutexGuard\"];\n+pub const PARKING_LOT_RWLOCK_READ_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockReadGuard\"];\n+pub const PARKING_LOT_RWLOCK_WRITE_GUARD: [&str; 3] = [\"lock_api\", \"rwlock\", \"RwLockWriteGuard\"];\n pub const PATH_BUF_AS_PATH: [&str; 4] = [\"std\", \"path\", \"PathBuf\", \"as_path\"];\n pub const PATH_TO_PATH_BUF: [&str; 4] = [\"std\", \"path\", \"Path\", \"to_path_buf\"];\n pub const PERMISSIONS: [&str; 3] = [\"std\", \"fs\", \"Permissions\"];"}, {"sha": "57e5b55045b95de03495fa9a9ca22db68a6657b1", "filename": "tests/ui/await_holding_lock.rs", "status": "modified", "additions": 167, "deletions": 39, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/02f3c17593e653e30e8835500319ef412855fa34/tests%2Fui%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02f3c17593e653e30e8835500319ef412855fa34/tests%2Fui%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.rs?ref=02f3c17593e653e30e8835500319ef412855fa34", "patch": "@@ -1,64 +1,192 @@\n #![warn(clippy::await_holding_lock)]\n \n-use std::sync::Mutex;\n+// When adding or modifying a test, please do the same for parking_lot::Mutex.\n+mod std_mutex {\n+    use super::baz;\n+    use std::sync::{Mutex, RwLock};\n \n-async fn bad(x: &Mutex<u32>) -> u32 {\n-    let guard = x.lock().unwrap();\n-    baz().await\n-}\n+    pub async fn bad(x: &Mutex<u32>) -> u32 {\n+        let guard = x.lock().unwrap();\n+        baz().await\n+    }\n \n-async fn good(x: &Mutex<u32>) -> u32 {\n-    {\n+    pub async fn good(x: &Mutex<u32>) -> u32 {\n+        {\n+            let guard = x.lock().unwrap();\n+            let y = *guard + 1;\n+        }\n+        baz().await;\n         let guard = x.lock().unwrap();\n-        let y = *guard + 1;\n+        47\n     }\n-    baz().await;\n-    let guard = x.lock().unwrap();\n-    47\n-}\n \n-async fn baz() -> u32 {\n-    42\n-}\n+    pub async fn bad_rw(x: &RwLock<u32>) -> u32 {\n+        let guard = x.read().unwrap();\n+        baz().await\n+    }\n \n-async fn also_bad(x: &Mutex<u32>) -> u32 {\n-    let first = baz().await;\n+    pub async fn bad_rw_write(x: &RwLock<u32>) -> u32 {\n+        let mut guard = x.write().unwrap();\n+        baz().await\n+    }\n \n-    let guard = x.lock().unwrap();\n+    pub async fn good_rw(x: &RwLock<u32>) -> u32 {\n+        {\n+            let guard = x.read().unwrap();\n+            let y = *guard + 1;\n+        }\n+        {\n+            let mut guard = x.write().unwrap();\n+            *guard += 1;\n+        }\n+        baz().await;\n+        let guard = x.read().unwrap();\n+        47\n+    }\n \n-    let second = baz().await;\n+    pub async fn also_bad(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n \n-    let third = baz().await;\n+        let guard = x.lock().unwrap();\n \n-    first + second + third\n+        let second = baz().await;\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    pub async fn not_good(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let second = {\n+            let guard = x.lock().unwrap();\n+            baz().await\n+        };\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    #[allow(clippy::manual_async_fn)]\n+    pub fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+        async move {\n+            let guard = x.lock().unwrap();\n+            baz().await\n+        }\n+    }\n }\n \n-async fn not_good(x: &Mutex<u32>) -> u32 {\n-    let first = baz().await;\n+// When adding or modifying a test, please do the same for std::Mutex.\n+mod parking_lot_mutex {\n+    use super::baz;\n+    use parking_lot::{Mutex, RwLock};\n \n-    let second = {\n-        let guard = x.lock().unwrap();\n+    pub async fn bad(x: &Mutex<u32>) -> u32 {\n+        let guard = x.lock();\n         baz().await\n-    };\n+    }\n \n-    let third = baz().await;\n+    pub async fn good(x: &Mutex<u32>) -> u32 {\n+        {\n+            let guard = x.lock();\n+            let y = *guard + 1;\n+        }\n+        baz().await;\n+        let guard = x.lock();\n+        47\n+    }\n \n-    first + second + third\n-}\n+    pub async fn bad_rw(x: &RwLock<u32>) -> u32 {\n+        let guard = x.read();\n+        baz().await\n+    }\n \n-#[allow(clippy::manual_async_fn)]\n-fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n-    async move {\n-        let guard = x.lock().unwrap();\n+    pub async fn bad_rw_write(x: &RwLock<u32>) -> u32 {\n+        let mut guard = x.write();\n         baz().await\n     }\n+\n+    pub async fn good_rw(x: &RwLock<u32>) -> u32 {\n+        {\n+            let guard = x.read();\n+            let y = *guard + 1;\n+        }\n+        {\n+            let mut guard = x.write();\n+            *guard += 1;\n+        }\n+        baz().await;\n+        let guard = x.read();\n+        47\n+    }\n+\n+    pub async fn also_bad(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let guard = x.lock();\n+\n+        let second = baz().await;\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    pub async fn not_good(x: &Mutex<u32>) -> u32 {\n+        let first = baz().await;\n+\n+        let second = {\n+            let guard = x.lock();\n+            baz().await\n+        };\n+\n+        let third = baz().await;\n+\n+        first + second + third\n+    }\n+\n+    #[allow(clippy::manual_async_fn)]\n+    pub fn block_bad(x: &Mutex<u32>) -> impl std::future::Future<Output = u32> + '_ {\n+        async move {\n+            let guard = x.lock();\n+            baz().await\n+        }\n+    }\n+}\n+\n+async fn baz() -> u32 {\n+    42\n+}\n+\n+async fn no_await(x: std::sync::Mutex<u32>) {\n+    let mut guard = x.lock().unwrap();\n+    *guard += 1;\n+}\n+\n+// FIXME: FP, because the `MutexGuard` is dropped before crossing the await point. This is\n+// something the needs to be fixed in rustc. There's already drop-tracking, but this is currently\n+// disabled, see rust-lang/rust#93751. This case isn't picked up by drop-tracking though. If the\n+// `*guard += 1` is removed it is picked up.\n+async fn dropped_before_await(x: std::sync::Mutex<u32>) {\n+    let mut guard = x.lock().unwrap();\n+    *guard += 1;\n+    drop(guard);\n+    baz().await;\n }\n \n fn main() {\n-    let m = Mutex::new(100);\n-    good(&m);\n-    bad(&m);\n-    also_bad(&m);\n-    not_good(&m);\n-    block_bad(&m);\n+    let m = std::sync::Mutex::new(100);\n+    std_mutex::good(&m);\n+    std_mutex::bad(&m);\n+    std_mutex::also_bad(&m);\n+    std_mutex::not_good(&m);\n+    std_mutex::block_bad(&m);\n+\n+    let m = parking_lot::Mutex::new(100);\n+    parking_lot_mutex::good(&m);\n+    parking_lot_mutex::bad(&m);\n+    parking_lot_mutex::also_bad(&m);\n+    parking_lot_mutex::not_good(&m);\n }"}, {"sha": "976da8d924247897317bed03461c579077a855cd", "filename": "tests/ui/await_holding_lock.stderr", "status": "modified", "additions": 180, "deletions": 35, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/02f3c17593e653e30e8835500319ef412855fa34/tests%2Fui%2Fawait_holding_lock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02f3c17593e653e30e8835500319ef412855fa34/tests%2Fui%2Fawait_holding_lock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_lock.stderr?ref=02f3c17593e653e30e8835500319ef412855fa34", "patch": "@@ -1,63 +1,208 @@\n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:6:9\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:9:13\n    |\n-LL |     let guard = x.lock().unwrap();\n-   |         ^^^^^\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n    |\n    = note: `-D clippy::await-holding-lock` implied by `-D warnings`\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:6:5\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:9:9\n    |\n-LL | /     let guard = x.lock().unwrap();\n-LL | |     baz().await\n-LL | | }\n-   | |_^\n+LL | /         let guard = x.lock().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:27:9\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:24:13\n    |\n-LL |     let guard = x.lock().unwrap();\n-   |         ^^^^^\n+LL |         let guard = x.read().unwrap();\n+   |             ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:27:5\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:24:9\n    |\n-LL | /     let guard = x.lock().unwrap();\n+LL | /         let guard = x.read().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:29:13\n+   |\n+LL |         let mut guard = x.write().unwrap();\n+   |             ^^^^^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:29:9\n+   |\n+LL | /         let mut guard = x.write().unwrap();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:50:13\n+   |\n+LL |         let guard = x.lock().unwrap();\n+   |             ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:50:9\n+   |\n+LL | /         let guard = x.lock().unwrap();\n LL | |\n-LL | |     let second = baz().await;\n+LL | |         let second = baz().await;\n LL | |\n ...  |\n-LL | |     first + second + third\n-LL | | }\n-   | |_^\n+LL | |         first + second + third\n+LL | |     }\n+   | |_____^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:40:13\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:63:17\n    |\n-LL |         let guard = x.lock().unwrap();\n+LL |             let guard = x.lock().unwrap();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:63:13\n+   |\n+LL | /             let guard = x.lock().unwrap();\n+LL | |             baz().await\n+LL | |         };\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:75:17\n+   |\n+LL |             let guard = x.lock().unwrap();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:75:13\n+   |\n+LL | /             let guard = x.lock().unwrap();\n+LL | |             baz().await\n+LL | |         }\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:87:13\n+   |\n+LL |         let guard = x.lock();\n    |             ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:40:9\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:87:9\n    |\n-LL | /         let guard = x.lock().unwrap();\n+LL | /         let guard = x.lock();\n LL | |         baz().await\n-LL | |     };\n+LL | |     }\n    | |_____^\n \n-error: this MutexGuard is held across an 'await' point. Consider using an async-aware Mutex type or ensuring the MutexGuard is dropped before calling await\n-  --> $DIR/await_holding_lock.rs:52:13\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:102:13\n    |\n-LL |         let guard = x.lock().unwrap();\n+LL |         let guard = x.read();\n    |             ^^^^^\n    |\n-note: these are all the await points this lock is held through\n-  --> $DIR/await_holding_lock.rs:52:9\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:102:9\n    |\n-LL | /         let guard = x.lock().unwrap();\n+LL | /         let guard = x.read();\n LL | |         baz().await\n LL | |     }\n    | |_____^\n \n-error: aborting due to 4 previous errors\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:107:13\n+   |\n+LL |         let mut guard = x.write();\n+   |             ^^^^^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:107:9\n+   |\n+LL | /         let mut guard = x.write();\n+LL | |         baz().await\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:128:13\n+   |\n+LL |         let guard = x.lock();\n+   |             ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:128:9\n+   |\n+LL | /         let guard = x.lock();\n+LL | |\n+LL | |         let second = baz().await;\n+LL | |\n+...  |\n+LL | |         first + second + third\n+LL | |     }\n+   | |_____^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:141:17\n+   |\n+LL |             let guard = x.lock();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:141:13\n+   |\n+LL | /             let guard = x.lock();\n+LL | |             baz().await\n+LL | |         };\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:153:17\n+   |\n+LL |             let guard = x.lock();\n+   |                 ^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:153:13\n+   |\n+LL | /             let guard = x.lock();\n+LL | |             baz().await\n+LL | |         }\n+   | |_________^\n+\n+error: this `MutexGuard` is held across an `await` point\n+  --> $DIR/await_holding_lock.rs:173:9\n+   |\n+LL |     let mut guard = x.lock().unwrap();\n+   |         ^^^^^^^^^\n+   |\n+   = help: consider using an async-aware `Mutex` type or ensuring the `MutexGuard` is dropped before calling await\n+note: these are all the `await` points this lock is held through\n+  --> $DIR/await_holding_lock.rs:173:5\n+   |\n+LL | /     let mut guard = x.lock().unwrap();\n+LL | |     *guard += 1;\n+LL | |     drop(guard);\n+LL | |     baz().await;\n+LL | | }\n+   | |_^\n+\n+error: aborting due to 13 previous errors\n "}, {"sha": "4339fca735dd4554eabcc0d7a9ad6a0963fc2d31", "filename": "tests/ui/await_holding_refcell_ref.stderr", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/02f3c17593e653e30e8835500319ef412855fa34/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/02f3c17593e653e30e8835500319ef412855fa34/tests%2Fui%2Fawait_holding_refcell_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fawait_holding_refcell_ref.stderr?ref=02f3c17593e653e30e8835500319ef412855fa34", "patch": "@@ -1,39 +1,42 @@\n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:6:9\n    |\n LL |     let b = x.borrow();\n    |         ^\n    |\n    = note: `-D clippy::await-holding-refcell-ref` implied by `-D warnings`\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:6:5\n    |\n LL | /     let b = x.borrow();\n LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:11:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:11:5\n    |\n LL | /     let b = x.borrow_mut();\n LL | |     baz().await\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:32:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:32:5\n    |\n LL | /     let b = x.borrow_mut();\n@@ -45,13 +48,14 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:44:9\n    |\n LL |     let b = x.borrow_mut();\n    |         ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:44:5\n    |\n LL | /     let b = x.borrow_mut();\n@@ -63,27 +67,29 @@ LL | |     first + second + third\n LL | | }\n    | |_^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:59:13\n    |\n LL |         let b = x.borrow_mut();\n    |             ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:59:9\n    |\n LL | /         let b = x.borrow_mut();\n LL | |         baz().await\n LL | |     };\n    | |_____^\n \n-error: this RefCell Ref is held across an 'await' point. Consider ensuring the Ref is dropped before calling await\n+error: this `RefCell` reference is held across an `await` point\n   --> $DIR/await_holding_refcell_ref.rs:71:13\n    |\n LL |         let b = x.borrow_mut();\n    |             ^\n    |\n-note: these are all the await points this ref is held through\n+   = help: ensure the reference is dropped before calling `await`\n+note: these are all the `await` points this reference is held through\n   --> $DIR/await_holding_refcell_ref.rs:71:9\n    |\n LL | /         let b = x.borrow_mut();"}]}