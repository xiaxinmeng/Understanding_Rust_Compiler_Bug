{"sha": "3af2e3ba857630214d9bc81756be1c07ae305fc4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNhZjJlM2JhODU3NjMwMjE0ZDliYzgxNzU2YmUxYzA3YWUzMDVmYzQ=", "commit": {"author": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-22T23:06:31Z"}, "committer": {"name": "R.Chavignat", "email": "r.chavignat@gmail.com", "date": "2015-08-23T04:26:31Z"}, "message": "Refactored CastPass.", "tree": {"sha": "5f3fae7c0720b9db12a8a3972d3cac17ef5d1303", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f3fae7c0720b9db12a8a3972d3cac17ef5d1303"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3af2e3ba857630214d9bc81756be1c07ae305fc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3af2e3ba857630214d9bc81756be1c07ae305fc4", "html_url": "https://github.com/rust-lang/rust/commit/3af2e3ba857630214d9bc81756be1c07ae305fc4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3af2e3ba857630214d9bc81756be1c07ae305fc4/comments", "author": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Robzz", "id": 304428, "node_id": "MDQ6VXNlcjMwNDQyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/304428?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Robzz", "html_url": "https://github.com/Robzz", "followers_url": "https://api.github.com/users/Robzz/followers", "following_url": "https://api.github.com/users/Robzz/following{/other_user}", "gists_url": "https://api.github.com/users/Robzz/gists{/gist_id}", "starred_url": "https://api.github.com/users/Robzz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Robzz/subscriptions", "organizations_url": "https://api.github.com/users/Robzz/orgs", "repos_url": "https://api.github.com/users/Robzz/repos", "events_url": "https://api.github.com/users/Robzz/events{/privacy}", "received_events_url": "https://api.github.com/users/Robzz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e80f2470b710838aefd1020c09562e275bdcb28e", "url": "https://api.github.com/repos/rust-lang/rust/commits/e80f2470b710838aefd1020c09562e275bdcb28e", "html_url": "https://github.com/rust-lang/rust/commit/e80f2470b710838aefd1020c09562e275bdcb28e"}], "stats": {"total": 143, "additions": 70, "deletions": 73}, "files": [{"sha": "4e9dd133ac8e76d57c5417bb6b8cb589b42a183d", "filename": "src/types.rs", "status": "modified", "additions": 70, "deletions": 73, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/3af2e3ba857630214d9bc81756be1c07ae305fc4/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3af2e3ba857630214d9bc81756be1c07ae305fc4/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=3af2e3ba857630214d9bc81756be1c07ae305fc4", "patch": "@@ -134,6 +134,72 @@ fn is_isize_or_usize(typ: &ty::TyS) -> bool {\n     }\n }\n \n+fn span_precision_loss_lint(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast_to_f64: bool) {\n+    let mantissa_nbits = if cast_to_f64 {52} else {23};\n+    let arch_dependent = is_isize_or_usize(cast_from) && cast_to_f64;\n+    let arch_dependent_str = \"on targets with 64-bit wide pointers \";\n+    let from_nbits_str = if arch_dependent {\"64\".to_owned()}\n+                         else if is_isize_or_usize(cast_from) {\"32 or 64\".to_owned()}\n+                         else {int_ty_to_nbits(cast_from).to_string()};\n+    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n+              &format!(\"casting {0} to {1} causes a loss of precision {2}\\\n+                        ({0} is {3} bits wide, but {1}'s mantissa is only {4} bits wide)\",\n+                       cast_from, if cast_to_f64 {\"f64\"} else {\"f32\"},\n+                       if arch_dependent {arch_dependent_str} else {\"\"},\n+                       from_nbits_str,\n+                       mantissa_nbits));\n+}\n+\n+enum ArchSuffix {\n+    _32, _64, None\n+}\n+\n+fn check_truncation_and_wrapping(cx: &Context, expr: &Expr, cast_from: &ty::TyS, cast_to: &ty::TyS) {\n+    let arch_64_suffix = \" on targets with 64-bit wide pointers\";\n+    let arch_32_suffix = \" on targets with 32-bit wide pointers\";\n+    let cast_unsigned_to_signed = !cast_from.is_signed() && cast_to.is_signed();\n+    let (from_nbits, to_nbits) = (int_ty_to_nbits(cast_from), int_ty_to_nbits(cast_to));\n+    let (span_truncation, suffix_truncation, span_wrap, suffix_wrap) =\n+        match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n+            (true, true) | (false, false) => (\n+                to_nbits < from_nbits,\n+                ArchSuffix::None,\n+                to_nbits == from_nbits && cast_unsigned_to_signed,\n+                ArchSuffix::None\n+                ),\n+            (true, false) => (\n+                to_nbits <= 32,\n+                if to_nbits == 32 {ArchSuffix::_64} else {ArchSuffix::None},\n+                to_nbits <= 32 && cast_unsigned_to_signed,\n+                ArchSuffix::_32\n+                ),\n+            (false, true) => (\n+                from_nbits == 64,\n+                ArchSuffix::_32,\n+                cast_unsigned_to_signed,\n+                if from_nbits == 64 {ArchSuffix::_64} else {ArchSuffix::_32}\n+                ),\n+        };\n+    if span_truncation {\n+        span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n+                  &format!(\"casting {} to {} may truncate the value{}\",\n+                           cast_from, cast_to,\n+                           match suffix_truncation {\n+                               ArchSuffix::_32 => arch_32_suffix,\n+                               ArchSuffix::_64 => arch_64_suffix,\n+                               ArchSuffix::None => \"\" }));\n+    }\n+    if span_wrap {\n+        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n+                  &format!(\"casting {} to {} may wrap around the value{}\",\n+                           cast_from, cast_to,\n+                           match suffix_wrap {\n+                               ArchSuffix::_32 => arch_32_suffix,\n+                               ArchSuffix::_64 => arch_64_suffix,\n+                               ArchSuffix::None => \"\" }));\n+    }\n+}\n+\n impl LintPass for CastPass {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(CAST_PRECISION_LOSS,\n@@ -149,33 +215,9 @@ impl LintPass for CastPass {\n                 match (cast_from.is_integral(), cast_to.is_integral()) {\n                     (true, false) => {\n                         let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits : usize = match cast_to.sty {\n-                            ty::TyFloat(ast::TyF32) => 32,\n-                            ty::TyFloat(ast::TyF64) => 64,\n-                            _ => 0\n-                        };\n-                        if from_nbits != 0 {\n-                            // When casting to f32, precision loss would occur regardless of the arch\n-                            if is_isize_or_usize(cast_from) {\n-                                if to_nbits == 64 {\n-                                    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n-                                              &format!(\"casting {0} to f64 causes a loss of precision on targets with 64-bit wide pointers \\\n-                                        \t  \t\t\t({0} is 64 bits wide, but f64's mantissa is only 52 bits wide)\",\n-                                                       cast_from));\n-                                }\n-                                else {\n-                                    span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n-                                              &format!(\"casting {0} to f32 causes a loss of precision \\\n-                                        \t  \t\t\t({0} is 32 or 64 bits wide, but f32's mantissa is only 23 bits wide)\",\n-                                                       cast_from));\n-                                }\n-                            }\n-                            else if from_nbits >= to_nbits {\n-                                span_lint(cx, CAST_PRECISION_LOSS, expr.span,\n-                                          &format!(\"casting {0} to {1} causes a loss of precision \\\n-                                          \t    ({0} is {2} bits wide, but {1}'s mantissa is only {3} bits wide)\",\n-                                                   cast_from, cast_to, from_nbits, if to_nbits == 64 {52} else {23} ));\n-                            }\n+                        let to_nbits = if let ty::TyFloat(ast::TyF32) = cast_to.sty {32} else {64};\n+                        if is_isize_or_usize(cast_from) || from_nbits >= to_nbits {\n+                            span_precision_loss_lint(cx, expr, cast_from, to_nbits == 64);\n                         }\n                     },\n                     (false, true) => {\n@@ -187,56 +229,11 @@ impl LintPass for CastPass {\n                         }\n                     },\n                     (true, true) => {\n-                        let from_nbits = int_ty_to_nbits(cast_from);\n-                        let to_nbits   = int_ty_to_nbits(cast_to);\n                         if cast_from.is_signed() && !cast_to.is_signed() {\n                             span_lint(cx, CAST_SIGN_LOSS, expr.span,\n                                       &format!(\"casting {} to {} may lose the sign of the value\", cast_from, cast_to));\n                         }\n-                        match (is_isize_or_usize(cast_from), is_isize_or_usize(cast_to)) {\n-                            (true, true) | (false, false) =>\n-                                if to_nbits < from_nbits {\n-                                    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                              &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n-                                }\n-                                else if !cast_from.is_signed() && cast_to.is_signed() && to_nbits == from_nbits {\n-                                    span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n-                                              &format!(\"casting {} to {} may wrap around the value\", cast_from, cast_to));\n-                                },\n-                            (true, false) =>\n-                                if to_nbits == 32 {\n-                                    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                              &format!(\"casting {} to {} may truncate the value on targets with 64-bit wide pointers\",\n-                                                       cast_from, cast_to));\n-                                    if !cast_from.is_signed() && cast_to.is_signed() {\n-                                        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n-                                                  &format!(\"casting {} to {} may wrap around the value on targets with 32-bit wide pointers\",\n-                                                           cast_from, cast_to));\n-                                    }\n-                                }\n-                                else if to_nbits < 32 {\n-                                    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                              &format!(\"casting {} to {} may truncate the value\", cast_from, cast_to));\n-                                },\n-                            (false, true) =>\n-                                if from_nbits == 64 {\n-                                    span_lint(cx, CAST_POSSIBLE_TRUNCATION, expr.span,\n-                                              &format!(\"casting {} to {} may truncate the value on targets with 32-bit wide pointers\",\n-                                                       cast_from, cast_to));\n-                                    if !cast_from.is_signed() && cast_to.is_signed() {\n-                                        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n-                                                  &format!(\"casting {} to {} may wrap around the value on targets with 64-bit wide pointers\",\n-                                                           cast_from, cast_to));\n-                                    }\n-                                }\n-                                else {\n-                                    if !cast_from.is_signed() && cast_to.is_signed() {\n-                                        span_lint(cx, CAST_POSSIBLE_WRAP, expr.span,\n-                                                  &format!(\"casting {} to {} may wrap around the value on targets with 32-bit wide pointers\",\n-                                                           cast_from, cast_to));\n-                                    }\n-                                }\n-                        }\n+                        check_truncation_and_wrapping(cx, expr, cast_from, cast_to);\n                     }\n                     (false, false) => {\n                         if let (&ty::TyFloat(ast::TyF64),"}]}