{"sha": "eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViMzZiYzY2NmE0ZTFlOGI2ZjU0ZjUwZjI3NWFlMTBhNGMyMmM3N2Y=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2021-05-07T23:06:22Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-07T23:06:22Z"}, "message": "Rollup merge of #76808 - LeSeulArtichaut:diagnose-functions-struct, r=jackh726\n\nImprove diagnostics for functions in `struct` definitions\n\nTries to implement #76421.\nThis is probably going to need unit tests, but I wanted to hear from review all the cases tests should cover.\n\nI'd like to follow up with the \"mechanically applicable suggestion here that adds an impl block\" step, but I'd need guidance. My idea for now would be to try to parse a function, and if that succeeds, create a dummy `ast::Item` impl block to then format it using `pprust`. Would that be a viable approach? Is there a better alternative?\n\nr? `@matklad` cc `@estebank\ufeff`", "tree": {"sha": "c5f0802f19737d8c278cee99cf8ba8be804bb26c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5f0802f19737d8c278cee99cf8ba8be804bb26c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJglcfuCRBK7hj4Ov3rIwAAAW0IAHPFNlLvSvDUY2CWuftgpBrA\nDQae8vchT/T+3oEdl+ko1HvQXzRNX8mWBLupg3wQ0wluxE5gamtYmWw2kabyuuzj\nNZlXeZipxNxp3LFZw+iA8sOIEd1ORcs6aaSUzQ0WiZ0zt9rJp33cwbJaJKgq92nB\nYN4fcx4MiRlgEhZjuwpSIQO1z4HnaOdazwm3Lx0zIbeNnXlPiM/ccMA/8/F6+LiR\n/ZmM3IXcj3+HRTMr9Nt2ZPAn9RyImZNrPc92Qup08V1A1uszIMfg7+Xok6Y6BkcF\nnD+RZbVvqFvgQF157HK069uRVHboRrbqHz0wOsPrNx9FPNgQdWiTM09PZBQFYRk=\n=hr4V\n-----END PGP SIGNATURE-----\n", "payload": "tree c5f0802f19737d8c278cee99cf8ba8be804bb26c\nparent 770792ff8d1ec542e78e77876ac936f43ffb8e05\nparent 6717f81b96aca75f5b811104ae75620274dad35d\nauthor Dylan DPC <dylan.dpc@gmail.com> 1620428782 +0200\ncommitter GitHub <noreply@github.com> 1620428782 +0200\n\nRollup merge of #76808 - LeSeulArtichaut:diagnose-functions-struct, r=jackh726\n\nImprove diagnostics for functions in `struct` definitions\n\nTries to implement #76421.\nThis is probably going to need unit tests, but I wanted to hear from review all the cases tests should cover.\n\nI'd like to follow up with the \"mechanically applicable suggestion here that adds an impl block\" step, but I'd need guidance. My idea for now would be to try to parse a function, and if that succeeds, create a dummy `ast::Item` impl block to then format it using `pprust`. Would that be a viable approach? Is there a better alternative?\n\nr? `@matklad` cc `@estebank\ufeff`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f", "html_url": "https://github.com/rust-lang/rust/commit/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "770792ff8d1ec542e78e77876ac936f43ffb8e05", "url": "https://api.github.com/repos/rust-lang/rust/commits/770792ff8d1ec542e78e77876ac936f43ffb8e05", "html_url": "https://github.com/rust-lang/rust/commit/770792ff8d1ec542e78e77876ac936f43ffb8e05"}, {"sha": "6717f81b96aca75f5b811104ae75620274dad35d", "url": "https://api.github.com/repos/rust-lang/rust/commits/6717f81b96aca75f5b811104ae75620274dad35d", "html_url": "https://github.com/rust-lang/rust/commit/6717f81b96aca75f5b811104ae75620274dad35d"}], "stats": {"total": 150, "additions": 120, "deletions": 30}, "files": [{"sha": "20e8b0f6425cee73b752550b58a1a40da46d69e0", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 40, "deletions": 12, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f", "patch": "@@ -1124,11 +1124,11 @@ impl<'a> Parser<'a> {\n                 if !this.recover_nested_adt_item(kw::Enum)? {\n                     return Ok((None, TrailingToken::None));\n                 }\n-                let ident = this.parse_ident()?;\n+                let ident = this.parse_field_ident(\"enum\", vlo)?;\n \n                 let struct_def = if this.check(&token::OpenDelim(token::Brace)) {\n                     // Parse a struct variant.\n-                    let (fields, recovered) = this.parse_record_struct_body()?;\n+                    let (fields, recovered) = this.parse_record_struct_body(\"struct\")?;\n                     VariantData::Struct(fields, recovered)\n                 } else if this.check(&token::OpenDelim(token::Paren)) {\n                     VariantData::Tuple(this.parse_tuple_struct_body()?, DUMMY_NODE_ID)\n@@ -1182,15 +1182,15 @@ impl<'a> Parser<'a> {\n                 VariantData::Unit(DUMMY_NODE_ID)\n             } else {\n                 // If we see: `struct Foo<T> where T: Copy { ... }`\n-                let (fields, recovered) = self.parse_record_struct_body()?;\n+                let (fields, recovered) = self.parse_record_struct_body(\"struct\")?;\n                 VariantData::Struct(fields, recovered)\n             }\n         // No `where` so: `struct Foo<T>;`\n         } else if self.eat(&token::Semi) {\n             VariantData::Unit(DUMMY_NODE_ID)\n         // Record-style struct definition\n         } else if self.token == token::OpenDelim(token::Brace) {\n-            let (fields, recovered) = self.parse_record_struct_body()?;\n+            let (fields, recovered) = self.parse_record_struct_body(\"struct\")?;\n             VariantData::Struct(fields, recovered)\n         // Tuple-style struct definition with optional where-clause.\n         } else if self.token == token::OpenDelim(token::Paren) {\n@@ -1220,10 +1220,10 @@ impl<'a> Parser<'a> {\n \n         let vdata = if self.token.is_keyword(kw::Where) {\n             generics.where_clause = self.parse_where_clause()?;\n-            let (fields, recovered) = self.parse_record_struct_body()?;\n+            let (fields, recovered) = self.parse_record_struct_body(\"union\")?;\n             VariantData::Struct(fields, recovered)\n         } else if self.token == token::OpenDelim(token::Brace) {\n-            let (fields, recovered) = self.parse_record_struct_body()?;\n+            let (fields, recovered) = self.parse_record_struct_body(\"union\")?;\n             VariantData::Struct(fields, recovered)\n         } else {\n             let token_str = super::token_descr(&self.token);\n@@ -1236,12 +1236,15 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemKind::Union(vdata, generics)))\n     }\n \n-    fn parse_record_struct_body(&mut self) -> PResult<'a, (Vec<FieldDef>, /* recovered */ bool)> {\n+    fn parse_record_struct_body(\n+        &mut self,\n+        adt_ty: &str,\n+    ) -> PResult<'a, (Vec<FieldDef>, /* recovered */ bool)> {\n         let mut fields = Vec::new();\n         let mut recovered = false;\n         if self.eat(&token::OpenDelim(token::Brace)) {\n             while self.token != token::CloseDelim(token::Brace) {\n-                let field = self.parse_field_def().map_err(|e| {\n+                let field = self.parse_field_def(adt_ty).map_err(|e| {\n                     self.consume_block(token::Brace, ConsumeClosingDelim::No);\n                     recovered = true;\n                     e\n@@ -1294,24 +1297,25 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses an element of a struct declaration.\n-    fn parse_field_def(&mut self) -> PResult<'a, FieldDef> {\n+    fn parse_field_def(&mut self, adt_ty: &str) -> PResult<'a, FieldDef> {\n         let attrs = self.parse_outer_attributes()?;\n         self.collect_tokens_trailing_token(attrs, ForceCollect::No, |this, attrs| {\n             let lo = this.token.span;\n             let vis = this.parse_visibility(FollowedByType::No)?;\n-            Ok((this.parse_single_struct_field(lo, vis, attrs)?, TrailingToken::None))\n+            Ok((this.parse_single_struct_field(adt_ty, lo, vis, attrs)?, TrailingToken::None))\n         })\n     }\n \n     /// Parses a structure field declaration.\n     fn parse_single_struct_field(\n         &mut self,\n+        adt_ty: &str,\n         lo: Span,\n         vis: Visibility,\n         attrs: Vec<Attribute>,\n     ) -> PResult<'a, FieldDef> {\n         let mut seen_comma: bool = false;\n-        let a_var = self.parse_name_and_ty(lo, vis, attrs)?;\n+        let a_var = self.parse_name_and_ty(adt_ty, lo, vis, attrs)?;\n         if self.token == token::Comma {\n             seen_comma = true;\n         }\n@@ -1398,11 +1402,12 @@ impl<'a> Parser<'a> {\n     /// Parses a structure field.\n     fn parse_name_and_ty(\n         &mut self,\n+        adt_ty: &str,\n         lo: Span,\n         vis: Visibility,\n         attrs: Vec<Attribute>,\n     ) -> PResult<'a, FieldDef> {\n-        let name = self.parse_ident_common(false)?;\n+        let name = self.parse_field_ident(adt_ty, lo)?;\n         self.expect(&token::Colon)?;\n         let ty = self.parse_ty()?;\n         Ok(FieldDef {\n@@ -1416,6 +1421,29 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n+    /// Parses a field identifier. Specialized version of `parse_ident_common`\n+    /// for better diagnostics and suggestions.\n+    fn parse_field_ident(&mut self, adt_ty: &str, lo: Span) -> PResult<'a, Ident> {\n+        let (ident, is_raw) = self.ident_or_err()?;\n+        if !is_raw && ident.is_reserved() {\n+            let err = if self.check_fn_front_matter(false) {\n+                let _ = self.parse_fn(&mut Vec::new(), |_| true, lo);\n+                let mut err = self.struct_span_err(\n+                    lo.to(self.prev_token.span),\n+                    &format!(\"functions are not allowed in {} definitions\", adt_ty),\n+                );\n+                err.help(\"unlike in C++, Java, and C#, functions are declared in `impl` blocks\");\n+                err.help(\"see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\");\n+                err\n+            } else {\n+                self.expected_ident_found()\n+            };\n+            return Err(err);\n+        }\n+        self.bump();\n+        Ok(ident)\n+    }\n+\n     /// Parses a declarative macro 2.0 definition.\n     /// The `macro` keyword has already been parsed.\n     /// ```"}, {"sha": "74481e236f31c7c3846addced8f2a4869e4dac91", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f", "patch": "@@ -522,27 +522,27 @@ impl<'a> Parser<'a> {\n         self.parse_ident_common(true)\n     }\n \n+    fn ident_or_err(&mut self) -> PResult<'a, (Ident, /* is_raw */ bool)> {\n+        self.token.ident().ok_or_else(|| match self.prev_token.kind {\n+            TokenKind::DocComment(..) => {\n+                self.span_fatal_err(self.prev_token.span, Error::UselessDocComment)\n+            }\n+            _ => self.expected_ident_found(),\n+        })\n+    }\n+\n     fn parse_ident_common(&mut self, recover: bool) -> PResult<'a, Ident> {\n-        match self.token.ident() {\n-            Some((ident, is_raw)) => {\n-                if !is_raw && ident.is_reserved() {\n-                    let mut err = self.expected_ident_found();\n-                    if recover {\n-                        err.emit();\n-                    } else {\n-                        return Err(err);\n-                    }\n-                }\n-                self.bump();\n-                Ok(ident)\n+        let (ident, is_raw) = self.ident_or_err()?;\n+        if !is_raw && ident.is_reserved() {\n+            let mut err = self.expected_ident_found();\n+            if recover {\n+                err.emit();\n+            } else {\n+                return Err(err);\n             }\n-            _ => Err(match self.prev_token.kind {\n-                TokenKind::DocComment(..) => {\n-                    self.span_fatal_err(self.prev_token.span, Error::UselessDocComment)\n-                }\n-                _ => self.expected_ident_found(),\n-            }),\n         }\n+        self.bump();\n+        Ok(ident)\n     }\n \n     /// Checks if the next token is `tok`, and returns `true` if so."}, {"sha": "5ae1b727dc772f44054ae2a90b00433479216d24", "filename": "src/test/ui/structs/struct-fn-in-definition.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.rs?ref=eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f", "patch": "@@ -0,0 +1,33 @@\n+// It might be intuitive for a user coming from languages like Java\n+// to declare a method directly in a struct's definition. Make sure\n+// rustc can give a helpful suggestion.\n+// Suggested in issue #76421\n+\n+struct S {\n+    field: usize,\n+\n+    fn foo() {}\n+    //~^ ERROR functions are not allowed in struct definitions\n+    //~| HELP unlike in C++, Java, and C#, functions are declared in `impl` blocks\n+    //~| HELP see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+}\n+\n+union U {\n+    variant: usize,\n+\n+    fn foo() {}\n+    //~^ ERROR functions are not allowed in union definitions\n+    //~| HELP unlike in C++, Java, and C#, functions are declared in `impl` blocks\n+    //~| HELP see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+}\n+\n+enum E {\n+    Variant,\n+\n+    fn foo() {}\n+    //~^ ERROR functions are not allowed in enum definitions\n+    //~| HELP unlike in C++, Java, and C#, functions are declared in `impl` blocks\n+    //~| HELP see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+}\n+\n+fn main() {}"}, {"sha": "1d7cd5272958659f729c2889b6898367c7db5dcd", "filename": "src/test/ui/structs/struct-fn-in-definition.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstructs%2Fstruct-fn-in-definition.stderr?ref=eb36bc666a4e1e8b6f54f50f275ae10a4c22c77f", "patch": "@@ -0,0 +1,29 @@\n+error: functions are not allowed in struct definitions\n+  --> $DIR/struct-fn-in-definition.rs:9:5\n+   |\n+LL |     fn foo() {}\n+   |     ^^^^^^^^^^^\n+   |\n+   = help: unlike in C++, Java, and C#, functions are declared in `impl` blocks\n+   = help: see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+\n+error: functions are not allowed in union definitions\n+  --> $DIR/struct-fn-in-definition.rs:18:5\n+   |\n+LL |     fn foo() {}\n+   |     ^^^^^^^^^^^\n+   |\n+   = help: unlike in C++, Java, and C#, functions are declared in `impl` blocks\n+   = help: see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+\n+error: functions are not allowed in enum definitions\n+  --> $DIR/struct-fn-in-definition.rs:27:5\n+   |\n+LL |     fn foo() {}\n+   |     ^^^^^^^^^^^\n+   |\n+   = help: unlike in C++, Java, and C#, functions are declared in `impl` blocks\n+   = help: see https://doc.rust-lang.org/book/ch05-03-method-syntax.html for more information\n+\n+error: aborting due to 3 previous errors\n+"}]}