{"sha": "654c536fec01d984f758ec32904354378aa3b792", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY1NGM1MzZmZWMwMWQ5ODRmNzU4ZWMzMjkwNDM1NDM3OGFhM2I3OTI=", "commit": {"author": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-07-27T18:02:18Z"}, "committer": {"name": "Palmer Cox", "email": "p@lmercox.com", "date": "2013-08-02T22:48:14Z"}, "message": "Sha2: Create cryptoutil.rs and re-write the Sha2 module to make use of it.\n\nThere are 2 main pieces of functionality in cryptoutil.rs:\n* A set of unsafe function for efficiently reading and writing u32 and u64\n  values. All of these functions are fairly easy to audit to confirm that\n  they do what they are supposed to.\n* A FixedBuffer struct. This struct keeps track of input data until there\n  is enough of it to execute the a function on it which expects a fixed\n  block of data.\n\nThe Sha2 module was rewritten to take advantage of the new functions in\ncryptoutil as well as FixedBuffer. The result is that the duplicate code\nfor maintaining a buffer of input data is removed from the Sha512 and\nSha256 implementation. Additionally, the FixedBuffer code is much more\nefficient than the previous code was.", "tree": {"sha": "14cceb6fa6590ba897d5aaa7759d7fd460560181", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/14cceb6fa6590ba897d5aaa7759d7fd460560181"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/654c536fec01d984f758ec32904354378aa3b792", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/654c536fec01d984f758ec32904354378aa3b792", "html_url": "https://github.com/rust-lang/rust/commit/654c536fec01d984f758ec32904354378aa3b792", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/654c536fec01d984f758ec32904354378aa3b792/comments", "author": null, "committer": null, "parents": [{"sha": "3cac62822edf3715afdaa2770333f00f38a51545", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cac62822edf3715afdaa2770333f00f38a51545", "html_url": "https://github.com/rust-lang/rust/commit/3cac62822edf3715afdaa2770333f00f38a51545"}], "stats": {"total": 1002, "additions": 551, "deletions": 451}, "files": [{"sha": "6e791f90b233f0dfee29749603fbae366a3d4bdb", "filename": "src/libextra/crypto/cryptoutil.rs", "status": "added", "additions": 243, "deletions": 0, "changes": 243, "blob_url": "https://github.com/rust-lang/rust/blob/654c536fec01d984f758ec32904354378aa3b792/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654c536fec01d984f758ec32904354378aa3b792/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fcryptoutil.rs?ref=654c536fec01d984f758ec32904354378aa3b792", "patch": "@@ -0,0 +1,243 @@\n+// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::vec::bytes::{MutableByteVector, copy_memory};\n+\n+\n+/// Write a u64 into a vector, which must be 8 bytes long. The value is written in big-endian\n+/// format.\n+pub fn write_u64_be(dst: &mut[u8], input: u64) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be64;\n+    assert!(dst.len() == 8);\n+    unsafe {\n+        let x: *mut i64 = transmute(dst.unsafe_mut_ref(0));\n+        *x = to_be64(input as i64);\n+    }\n+}\n+\n+/// Write a u32 into a vector, which must be 4 bytes long. The value is written in big-endian\n+/// format.\n+pub fn write_u32_be(dst: &mut[u8], input: u32) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() == 4);\n+    unsafe {\n+        let x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        *x = to_be32(input as i32);\n+    }\n+}\n+\n+/// Read a vector of bytes into a vector of u64s. The values are read in big-endian format.\n+pub fn read_u64v_be(dst: &mut[u64], input: &[u8]) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be64;\n+    assert!(dst.len() * 8 == input.len());\n+    unsafe {\n+        let mut x: *mut i64 = transmute(dst.unsafe_mut_ref(0));\n+        let mut y: *i64 = transmute(input.unsafe_ref(0));\n+        do dst.len().times() {\n+            *x = to_be64(*y);\n+            x = x.offset(1);\n+            y = y.offset(1);\n+        }\n+    }\n+}\n+\n+/// Read a vector of bytes into a vector of u32s. The values are read in big-endian format.\n+pub fn read_u32v_be(dst: &mut[u32], input: &[u8]) {\n+    use std::cast::transmute;\n+    use std::unstable::intrinsics::to_be32;\n+    assert!(dst.len() * 4 == input.len());\n+    unsafe {\n+        let mut x: *mut i32 = transmute(dst.unsafe_mut_ref(0));\n+        let mut y: *i32 = transmute(input.unsafe_ref(0));\n+        do dst.len().times() {\n+            *x = to_be32(*y);\n+            x = x.offset(1);\n+            y = y.offset(1);\n+        }\n+    }\n+}\n+\n+\n+/// A FixedBuffer, likes its name implies, is a fixed size buffer. When the buffer becomes full, it\n+/// must be processed. The input() method takes care of processing and then clearing the buffer\n+/// automatically. However, other methods do not and require the caller to process the buffer. Any\n+/// method that modifies the buffer directory or provides the caller with bytes that can be modifies\n+/// results in those bytes being marked as used by the buffer.\n+pub trait FixedBuffer {\n+    /// Input a vector of bytes. If the buffer becomes full, proccess it with the provided\n+    /// function and then clear the buffer.\n+    fn input(&mut self, input: &[u8], func: &fn(&[u8]));\n+\n+    /// Reset the buffer.\n+    fn reset(&mut self);\n+\n+    /// Zero the buffer up until the specified index. The buffer position currently must not be\n+    /// greater than that index.\n+    fn zero_until(&mut self, idx: uint);\n+\n+    /// Get a slice of the buffer of the specified size. There must be at least that many bytes\n+    /// remaining in the buffer.\n+    fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8];\n+\n+    /// Get the current buffer. The buffer must already be full. This clears the buffer as well.\n+    fn full_buffer<'s>(&'s mut self) -> &'s [u8];\n+\n+    /// Get the current position of the buffer.\n+    fn position(&self) -> uint;\n+\n+    /// Get the number of bytes remaining in the buffer until it is full.\n+    fn remaining(&self) -> uint;\n+\n+    /// Get the size of the buffer\n+    fn size(&self) -> uint;\n+}\n+\n+macro_rules! impl_fixed_buffer( ($name:ident, $size:expr) => (\n+    impl FixedBuffer for $name {\n+        fn input(&mut self, input: &[u8], func: &fn(&[u8])) {\n+            let mut i = 0;\n+\n+            // FIXME: #6304 - This local variable shouldn't be necessary.\n+            let size = $size;\n+\n+            // If there is already data in the buffer, copy as much as we can into it and process\n+            // the data if the buffer becomes full.\n+            if self.buffer_idx != 0 {\n+                let buffer_remaining = size - self.buffer_idx;\n+                if input.len() >= buffer_remaining {\n+                        copy_memory(\n+                            self.buffer.mut_slice(self.buffer_idx, size),\n+                            input.slice_to(buffer_remaining),\n+                            buffer_remaining);\n+                    self.buffer_idx = 0;\n+                    func(self.buffer);\n+                    i += buffer_remaining;\n+                } else {\n+                    copy_memory(\n+                        self.buffer.mut_slice(self.buffer_idx, self.buffer_idx + input.len()),\n+                        input,\n+                        input.len());\n+                    self.buffer_idx += input.len();\n+                    return;\n+                }\n+            }\n+\n+            // While we have at least a full buffer size chunks's worth of data, process that data\n+            // without copying it into the buffer\n+            while input.len() - i >= size {\n+                func(input.slice(i, i + size));\n+                i += size;\n+            }\n+\n+            // Copy any input data into the buffer. At this point in the method, the ammount of\n+            // data left in the input vector will be less than the buffer size and the buffer will\n+            // be empty.\n+            let input_remaining = input.len() - i;\n+            copy_memory(\n+                self.buffer.mut_slice(0, input_remaining),\n+                input.slice_from(i),\n+                input.len() - i);\n+            self.buffer_idx += input_remaining;\n+        }\n+\n+        fn reset(&mut self) {\n+            self.buffer_idx = 0;\n+        }\n+\n+        fn zero_until(&mut self, idx: uint) {\n+            assert!(idx >= self.buffer_idx);\n+            self.buffer.mut_slice(self.buffer_idx, idx).set_memory(0);\n+            self.buffer_idx = idx;\n+        }\n+\n+        fn next<'s>(&'s mut self, len: uint) -> &'s mut [u8] {\n+            self.buffer_idx += len;\n+            return self.buffer.mut_slice(self.buffer_idx - len, self.buffer_idx);\n+        }\n+\n+        fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n+            assert!(self.buffer_idx == $size);\n+            self.buffer_idx = 0;\n+            return self.buffer.slice_to($size);\n+        }\n+\n+        fn position(&self) -> uint { self.buffer_idx }\n+\n+        fn remaining(&self) -> uint { $size - self.buffer_idx }\n+\n+        fn size(&self) -> uint { $size }\n+    }\n+))\n+\n+\n+/// A fixed size buffer of 64 bytes useful for cryptographic operations.\n+pub struct FixedBuffer64 {\n+    priv buffer: [u8, ..64],\n+    priv buffer_idx: uint,\n+}\n+\n+impl FixedBuffer64 {\n+    /// Create a new buffer\n+    pub fn new() -> FixedBuffer64 {\n+        return FixedBuffer64 {\n+            buffer: [0u8, ..64],\n+            buffer_idx: 0\n+        };\n+    }\n+}\n+\n+impl_fixed_buffer!(FixedBuffer64, 64)\n+\n+/// A fixed size buffer of 128 bytes useful for cryptographic operations.\n+pub struct FixedBuffer128 {\n+    priv buffer: [u8, ..128],\n+    priv buffer_idx: uint,\n+}\n+\n+impl FixedBuffer128 {\n+    /// Create a new buffer\n+    pub fn new() -> FixedBuffer128 {\n+        return FixedBuffer128 {\n+            buffer: [0u8, ..128],\n+            buffer_idx: 0\n+        };\n+    }\n+}\n+\n+impl_fixed_buffer!(FixedBuffer128, 128)\n+\n+\n+/// The StandardPadding trait adds a method useful for various hash algorithms to a FixedBuffer\n+/// struct.\n+pub trait StandardPadding {\n+    /// Add standard padding to the buffer. The buffer must not be full when this method is called\n+    /// and is guaranteed to have exactly rem remaining bytes when it returns. If there are not at\n+    /// least rem bytes available, the buffer will be zero padded, processed, cleared, and then\n+    /// filled with zeros again until only rem bytes are remaining.\n+    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8]));\n+}\n+\n+impl <T: FixedBuffer> StandardPadding for T {\n+    fn standard_padding(&mut self, rem: uint, func: &fn(&[u8])) {\n+        let size = self.size();\n+\n+        self.next(1)[0] = 128;\n+\n+        if self.remaining() < rem {\n+            self.zero_until(size);\n+            func(self.full_buffer());\n+        }\n+\n+        self.zero_until(size - rem);\n+    }\n+}"}, {"sha": "dc2d56f483e09c9737997664f7d0abbb3547dce4", "filename": "src/libextra/crypto/sha2.rs", "status": "modified", "additions": 306, "deletions": 451, "changes": 757, "blob_url": "https://github.com/rust-lang/rust/blob/654c536fec01d984f758ec32904354378aa3b792/src%2Flibextra%2Fcrypto%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654c536fec01d984f758ec32904354378aa3b792/src%2Flibextra%2Fcrypto%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fcrypto%2Fsha2.rs?ref=654c536fec01d984f758ec32904354378aa3b792", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use cryptoutil::{write_u64_be, write_u32_be, read_u64v_be, read_u32v_be, FixedBuffer,\n+    FixedBuffer128, FixedBuffer64, StandardPadding};\n use digest::Digest;\n \n \n@@ -22,6 +24,13 @@ struct BitCounter {\n }\n \n impl BitCounter {\n+    fn new() -> BitCounter {\n+        return BitCounter {\n+            high_bit_count: 0,\n+            low_byte_count: 0\n+        };\n+    }\n+\n     fn add_bytes(&mut self, bytes: uint) {\n         self.low_byte_count += bytes as u64;\n         if(self.low_byte_count > 0x1fffffffffffffffu64) {\n@@ -45,12 +54,9 @@ impl BitCounter {\n }\n \n \n-// A structure that represents that state of a digest computation\n-// for the SHA-2 512 family of digest functions\n-struct Engine512 {\n-    input_buffer: [u8, ..8],\n-    input_buffer_idx: uint,\n-    bit_counter: BitCounter,\n+// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n+// functions\n+struct Engine512State {\n     H0: u64,\n     H1: u64,\n     H2: u64,\n@@ -59,91 +65,34 @@ struct Engine512 {\n     H5: u64,\n     H6: u64,\n     H7: u64,\n-    W: [u64, ..80],\n-    W_idx: uint,\n-    finished: bool,\n }\n \n-// Convert a [u8] to a u64 in big-endian format\n-fn to_u64(input: &[u8]) -> u64 {\n-    (input[0] as u64) << 56 |\n-    (input[1] as u64) << 48 |\n-    (input[2] as u64) << 40 |\n-    (input[3] as u64) << 32 |\n-    (input[4] as u64) << 24 |\n-    (input[5] as u64) << 16 |\n-    (input[6] as u64) << 8 |\n-    (input[7] as u64)\n-}\n-\n-// Convert a u64 to a [u8] in big endian format\n-fn from_u64(input: u64, out: &mut [u8]) {\n-    out[0] = (input >> 56) as u8;\n-    out[1] = (input >> 48) as u8;\n-    out[2] = (input >> 40) as u8;\n-    out[3] = (input >> 32) as u8;\n-    out[4] = (input >> 24) as u8;\n-    out[5] = (input >> 16) as u8;\n-    out[6] = (input >> 8) as u8;\n-    out[7] = input as u8;\n-}\n-\n-impl Engine512 {\n-    fn input_byte(&mut self, input: u8) {\n-        assert!(!self.finished)\n-\n-        self.input_buffer[self.input_buffer_idx] = input;\n-        self.input_buffer_idx += 1;\n-\n-        if (self.input_buffer_idx == 8) {\n-            self.input_buffer_idx = 0;\n-            let w = to_u64(self.input_buffer);\n-            self.process_word(w);\n-        }\n-\n-        self.bit_counter.add_bytes(1);\n-    }\n-\n-    fn input_vec(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n-\n-        let mut i = 0;\n-\n-        while i < input.len() && self.input_buffer_idx != 0 {\n-            self.input_byte(input[i]);\n-            i += 1;\n-        }\n-\n-        while input.len() - i >= 8 {\n-            let w = to_u64(input.slice(i, i + 8));\n-            self.process_word(w);\n-            self.bit_counter.add_bytes(8);\n-            i += 8;\n-        }\n-\n-        while i < input.len() {\n-            self.input_byte(input[i]);\n-            i += 1;\n-        }\n+impl Engine512State {\n+    fn new(h: &[u64, ..8]) -> Engine512State {\n+        return Engine512State {\n+            H0: h[0],\n+            H1: h[1],\n+            H2: h[2],\n+            H3: h[3],\n+            H4: h[4],\n+            H5: h[5],\n+            H6: h[6],\n+            H7: h[7]\n+        };\n     }\n \n-    fn reset(&mut self) {\n-        self.bit_counter.reset();\n-        self.finished = false;\n-        self.input_buffer_idx = 0;\n-        self.W_idx = 0;\n+    fn reset(&mut self, h: &[u64, ..8]) {\n+        self.H0 = h[0];\n+        self.H1 = h[1];\n+        self.H2 = h[2];\n+        self.H3 = h[3];\n+        self.H4 = h[4];\n+        self.H5 = h[5];\n+        self.H6 = h[6];\n+        self.H7 = h[7];\n     }\n \n-    fn process_word(&mut self, input: u64) {\n-        self.W[self.W_idx] = input;\n-        self.W_idx += 1;\n-        if (self.W_idx == 16) {\n-            self.W_idx = 0;\n-            self.process_block();\n-        }\n-    }\n-\n-    fn process_block(&mut self) {\n+    fn process_block(&mut self, data: &[u8]) {\n         fn ch(x: u64, y: u64, z: u64) -> u64 {\n             ((x & y) ^ ((!x) & z))\n         }\n@@ -168,9 +117,13 @@ impl Engine512 {\n             ((x << 45) | (x >> 19)) ^ ((x << 3) | (x >> 61)) ^ (x >> 6)\n         }\n \n+        let mut W = [0u64, ..80];\n+\n+        read_u64v_be(W.mut_slice(0, 16), data);\n+\n         foreach t in range(16u, 80) {\n-            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n-                self.W[t - 16];\n+            W[t] = sigma1(W[t - 2]) + W[t - 7] + sigma0(W[t - 15]) +\n+                W[t - 16];\n         }\n \n         let mut a = self.H0;\n@@ -183,43 +136,44 @@ impl Engine512 {\n         let mut h = self.H7;\n \n         let mut t = 0;\n+        \n         foreach _ in range(0u, 10) {\n-            h += sum1(e) + ch(e, f, g) + K64[t] + self.W[t];\n+            h += sum1(e) + ch(e, f, g) + K64[t] + W[t];\n             d += h;\n             h += sum0(a) + maj(a, b, c);\n             t += 1;\n \n-            g += sum1(d) + ch(d, e, f) + K64[t] + self.W[t];\n+            g += sum1(d) + ch(d, e, f) + K64[t] + W[t];\n             c += g;\n             g += sum0(h) + maj(h, a, b);\n             t += 1;\n \n-            f += sum1(c) + ch(c, d, e) + K64[t] + self.W[t];\n+            f += sum1(c) + ch(c, d, e) + K64[t] + W[t];\n             b += f;\n             f += sum0(g) + maj(g, h, a);\n             t += 1;\n \n-            e += sum1(b) + ch(b, c, d) + K64[t] + self.W[t];\n+            e += sum1(b) + ch(b, c, d) + K64[t] + W[t];\n             a += e;\n             e += sum0(f) + maj(f, g, h);\n             t += 1;\n \n-            d += sum1(a) + ch(a, b, c) + K64[t] + self.W[t];\n+            d += sum1(a) + ch(a, b, c) + K64[t] + W[t];\n             h += d;\n             d += sum0(e) + maj(e, f, g);\n             t += 1;\n \n-            c += sum1(h) + ch(h, a, b) + K64[t] + self.W[t];\n+            c += sum1(h) + ch(h, a, b) + K64[t] + W[t];\n             g += c;\n             c += sum0(d) + maj(d, e, f);\n             t += 1;\n \n-            b += sum1(g) + ch(g, h, a) + K64[t] + self.W[t];\n+            b += sum1(g) + ch(g, h, a) + K64[t] + W[t];\n             f += b;\n             b += sum0(c) + maj(c, d, e);\n             t += 1;\n \n-            a += sum1(f) + ch(f, g, h) + K64[t] + self.W[t];\n+            a += sum1(f) + ch(f, g, h) + K64[t] + W[t];\n             e += a;\n             a += sum0(b) + maj(b, c, d);\n             t += 1;\n@@ -234,39 +188,6 @@ impl Engine512 {\n         self.H6 += g;\n         self.H7 += h;\n     }\n-\n-    fn finish(&mut self) {\n-        if (self.finished) {\n-            return;\n-        }\n-\n-        // must get message length before padding is added\n-        let high_bit_count = self.bit_counter.get_high_bit_count();\n-        let low_bit_count = self.bit_counter.get_low_bit_count();\n-\n-        // add padding\n-        self.input_byte(128u8);\n-\n-        while self.input_buffer_idx != 0 {\n-            self.input_byte(0u8);\n-        }\n-\n-        // add length\n-        if (self.W_idx > 14) {\n-            foreach _ in range(self.W_idx, 16) {\n-                self.process_word(0);\n-            }\n-        }\n-\n-        while self.W_idx < 14 {\n-            self.process_word(0);\n-        }\n-\n-        self.process_word(high_bit_count);\n-        self.process_word(low_bit_count);\n-\n-        self.finished = true;\n-    }\n }\n \n // Constants necessary for SHA-2 512 family of digests.\n@@ -294,6 +215,53 @@ static K64: [u64, ..80] = [\n ];\n \n \n+// A structure that keeps track of the state of the Sha-512 operation and contains the logic\n+// necessary to perform the final calculations.\n+struct Engine512 {\n+    bit_counter: BitCounter,\n+    buffer: FixedBuffer128,\n+    state: Engine512State,\n+    finished: bool,\n+}\n+\n+impl Engine512 {\n+    fn new(h: &[u64, ..8]) -> Engine512 {\n+        return Engine512 {\n+            bit_counter: BitCounter::new(),\n+            buffer: FixedBuffer128::new(),\n+            state: Engine512State::new(h),\n+            finished: false\n+        }\n+    }\n+\n+    fn reset(&mut self, h: &[u64, ..8]) {\n+        self.bit_counter.reset();\n+        self.buffer.reset();\n+        self.state.reset(h);\n+        self.finished = false;\n+    }\n+\n+    fn input(&mut self, input: &[u8]) {\n+        assert!(!self.finished)\n+        self.bit_counter.add_bytes(input.len());\n+        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n+    }\n+\n+    fn finish(&mut self) {\n+        if self.finished {\n+            return;\n+        }\n+\n+        self.buffer.standard_padding(16, |input: &[u8]| { self.state.process_block(input) });\n+        write_u64_be(self.buffer.next(8), self.bit_counter.get_high_bit_count());\n+        write_u64_be(self.buffer.next(8), self.bit_counter.get_low_bit_count());\n+        self.state.process_block(self.buffer.full_buffer());\n+\n+        self.finished = true;\n+    }\n+}\n+\n+\n struct Sha512 {\n     priv engine: Engine512\n }\n@@ -303,62 +271,48 @@ impl Sha512 {\n      * Construct an new instance of a SHA-512 digest.\n      */\n     pub fn new() -> Sha512 {\n-        Sha512 {\n-            engine: Engine512 {\n-                input_buffer: [0u8, ..8],\n-                input_buffer_idx: 0,\n-                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n-                H0: 0x6a09e667f3bcc908u64,\n-                H1: 0xbb67ae8584caa73bu64,\n-                H2: 0x3c6ef372fe94f82bu64,\n-                H3: 0xa54ff53a5f1d36f1u64,\n-                H4: 0x510e527fade682d1u64,\n-                H5: 0x9b05688c2b3e6c1fu64,\n-                H6: 0x1f83d9abfb41bd6bu64,\n-                H7: 0x5be0cd19137e2179u64,\n-                W: [0u64, ..80],\n-                W_idx: 0,\n-                finished: false,\n-            }\n-        }\n+        return Sha512 {\n+            engine: Engine512::new(&H512)\n+        };\n     }\n }\n \n impl Digest for Sha512 {\n     fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n+        self.engine.input(d);\n     }\n \n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        from_u64(self.engine.H0, out.mut_slice(0, 8));\n-        from_u64(self.engine.H1, out.mut_slice(8, 16));\n-        from_u64(self.engine.H2, out.mut_slice(16, 24));\n-        from_u64(self.engine.H3, out.mut_slice(24, 32));\n-        from_u64(self.engine.H4, out.mut_slice(32, 40));\n-        from_u64(self.engine.H5, out.mut_slice(40, 48));\n-        from_u64(self.engine.H6, out.mut_slice(48, 56));\n-        from_u64(self.engine.H7, out.mut_slice(56, 64));\n-\n+        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n+        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n+        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n+        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n+        write_u64_be(out.mut_slice(32, 40), self.engine.state.H4);\n+        write_u64_be(out.mut_slice(40, 48), self.engine.state.H5);\n+        write_u64_be(out.mut_slice(48, 56), self.engine.state.H6);\n+        write_u64_be(out.mut_slice(56, 64), self.engine.state.H7);\n     }\n \n     fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0x6a09e667f3bcc908u64;\n-        self.engine.H1 = 0xbb67ae8584caa73bu64;\n-        self.engine.H2 = 0x3c6ef372fe94f82bu64;\n-        self.engine.H3 = 0xa54ff53a5f1d36f1u64;\n-        self.engine.H4 = 0x510e527fade682d1u64;\n-        self.engine.H5 = 0x9b05688c2b3e6c1fu64;\n-        self.engine.H6 = 0x1f83d9abfb41bd6bu64;\n-        self.engine.H7 = 0x5be0cd19137e2179u64;\n+        self.engine.reset(&H512);\n     }\n \n     fn output_bits(&self) -> uint { 512 }\n }\n \n+static H512: [u64, ..8] = [\n+    0x6a09e667f3bcc908,\n+    0xbb67ae8584caa73b,\n+    0x3c6ef372fe94f82b,\n+    0xa54ff53a5f1d36f1,\n+    0x510e527fade682d1,\n+    0x9b05688c2b3e6c1f,\n+    0x1f83d9abfb41bd6b,\n+    0x5be0cd19137e2179\n+];\n+\n \n struct Sha384 {\n     priv engine: Engine512\n@@ -370,58 +324,45 @@ impl Sha384 {\n      */\n     pub fn new() -> Sha384 {\n         Sha384 {\n-            engine: Engine512 {\n-                input_buffer: [0u8, ..8],\n-                input_buffer_idx: 0,\n-                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n-                H0: 0xcbbb9d5dc1059ed8u64,\n-                H1: 0x629a292a367cd507u64,\n-                H2: 0x9159015a3070dd17u64,\n-                H3: 0x152fecd8f70e5939u64,\n-                H4: 0x67332667ffc00b31u64,\n-                H5: 0x8eb44a8768581511u64,\n-                H6: 0xdb0c2e0d64f98fa7u64,\n-                H7: 0x47b5481dbefa4fa4u64,\n-                W: [0u64, ..80],\n-                W_idx: 0,\n-                finished: false,\n-            }\n+            engine: Engine512::new(&H384)\n         }\n     }\n }\n \n impl Digest for Sha384 {\n     fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n+        self.engine.input(d);\n     }\n \n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        from_u64(self.engine.H0, out.mut_slice(0, 8));\n-        from_u64(self.engine.H1, out.mut_slice(8, 16));\n-        from_u64(self.engine.H2, out.mut_slice(16, 24));\n-        from_u64(self.engine.H3, out.mut_slice(24, 32));\n-        from_u64(self.engine.H4, out.mut_slice(32, 40));\n-        from_u64(self.engine.H5, out.mut_slice(40, 48));\n+        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n+        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n+        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n+        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n+        write_u64_be(out.mut_slice(32, 40), self.engine.state.H4);\n+        write_u64_be(out.mut_slice(40, 48), self.engine.state.H5);\n     }\n \n     fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0xcbbb9d5dc1059ed8u64;\n-        self.engine.H1 = 0x629a292a367cd507u64;\n-        self.engine.H2 = 0x9159015a3070dd17u64;\n-        self.engine.H3 = 0x152fecd8f70e5939u64;\n-        self.engine.H4 = 0x67332667ffc00b31u64;\n-        self.engine.H5 = 0x8eb44a8768581511u64;\n-        self.engine.H6 = 0xdb0c2e0d64f98fa7u64;\n-        self.engine.H7 = 0x47b5481dbefa4fa4u64;\n+        self.engine.reset(&H384);\n     }\n \n     fn output_bits(&self) -> uint { 384 }\n }\n \n+static H384: [u64, ..8] = [\n+    0xcbbb9d5dc1059ed8,\n+    0x629a292a367cd507,\n+    0x9159015a3070dd17,\n+    0x152fecd8f70e5939,\n+    0x67332667ffc00b31,\n+    0x8eb44a8768581511,\n+    0xdb0c2e0d64f98fa7,\n+    0x47b5481dbefa4fa4\n+];\n+\n \n struct Sha512Trunc256 {\n     priv engine: Engine512\n@@ -433,56 +374,43 @@ impl Sha512Trunc256 {\n      */\n     pub fn new() -> Sha512Trunc256 {\n         Sha512Trunc256 {\n-            engine: Engine512 {\n-                input_buffer: [0u8, ..8],\n-                input_buffer_idx: 0,\n-                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n-                H0: 0x22312194fc2bf72cu64,\n-                H1: 0x9f555fa3c84c64c2u64,\n-                H2: 0x2393b86b6f53b151u64,\n-                H3: 0x963877195940eabdu64,\n-                H4: 0x96283ee2a88effe3u64,\n-                H5: 0xbe5e1e2553863992u64,\n-                H6: 0x2b0199fc2c85b8aau64,\n-                H7: 0x0eb72ddc81c52ca2u64,\n-                W: [0u64, ..80],\n-                W_idx: 0,\n-                finished: false,\n-            }\n+            engine: Engine512::new(&H512_TRUNC_256)\n         }\n     }\n }\n \n impl Digest for Sha512Trunc256 {\n     fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n+        self.engine.input(d);\n     }\n \n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        from_u64(self.engine.H0, out.mut_slice(0, 8));\n-        from_u64(self.engine.H1, out.mut_slice(8, 16));\n-        from_u64(self.engine.H2, out.mut_slice(16, 24));\n-        from_u64(self.engine.H3, out.mut_slice(24, 32));\n+        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n+        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n+        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n+        write_u64_be(out.mut_slice(24, 32), self.engine.state.H3);\n     }\n \n     fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0x22312194fc2bf72cu64;\n-        self.engine.H1 = 0x9f555fa3c84c64c2u64;\n-        self.engine.H2 = 0x2393b86b6f53b151u64;\n-        self.engine.H3 = 0x963877195940eabdu64;\n-        self.engine.H4 = 0x96283ee2a88effe3u64;\n-        self.engine.H5 = 0xbe5e1e2553863992u64;\n-        self.engine.H6 = 0x2b0199fc2c85b8aau64;\n-        self.engine.H7 = 0x0eb72ddc81c52ca2u64;\n+        self.engine.reset(&H512_TRUNC_256);\n     }\n \n     fn output_bits(&self) -> uint { 256 }\n }\n \n+static H512_TRUNC_256: [u64, ..8] = [\n+    0x22312194fc2bf72c,\n+    0x9f555fa3c84c64c2,\n+    0x2393b86b6f53b151,\n+    0x963877195940eabd,\n+    0x96283ee2a88effe3,\n+    0xbe5e1e2553863992,\n+    0x2b0199fc2c85b8aa,\n+    0x0eb72ddc81c52ca2\n+];\n+\n \n struct Sha512Trunc224 {\n     priv engine: Engine512\n@@ -494,63 +422,47 @@ impl Sha512Trunc224 {\n      */\n     pub fn new() -> Sha512Trunc224 {\n         Sha512Trunc224 {\n-            engine: Engine512 {\n-                input_buffer: [0u8, ..8],\n-                input_buffer_idx: 0,\n-                bit_counter: BitCounter { high_bit_count: 0, low_byte_count: 0 },\n-                H0: 0x8c3d37c819544da2u64,\n-                H1: 0x73e1996689dcd4d6u64,\n-                H2: 0x1dfab7ae32ff9c82u64,\n-                H3: 0x679dd514582f9fcfu64,\n-                H4: 0x0f6d2b697bd44da8u64,\n-                H5: 0x77e36f7304c48942u64,\n-                H6: 0x3f9d85a86a1d36c8u64,\n-                H7: 0x1112e6ad91d692a1u64,\n-                W: [0u64, ..80],\n-                W_idx: 0,\n-                finished: false,\n-            }\n+            engine: Engine512::new(&H512_TRUNC_224)\n         }\n     }\n }\n \n impl Digest for Sha512Trunc224 {\n     fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n+        self.engine.input(d);\n     }\n \n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        from_u64(self.engine.H0, out.mut_slice(0, 8));\n-        from_u64(self.engine.H1, out.mut_slice(8, 16));\n-        from_u64(self.engine.H2, out.mut_slice(16, 24));\n-        from_u32((self.engine.H3 >> 32) as u32, out.mut_slice(24, 28));\n+        write_u64_be(out.mut_slice(0, 8), self.engine.state.H0);\n+        write_u64_be(out.mut_slice(8, 16), self.engine.state.H1);\n+        write_u64_be(out.mut_slice(16, 24), self.engine.state.H2);\n+        write_u32_be(out.mut_slice(24, 28), (self.engine.state.H3 >> 32) as u32);\n     }\n \n     fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0x8c3d37c819544da2u64;\n-        self.engine.H1 = 0x73e1996689dcd4d6u64;\n-        self.engine.H2 = 0x1dfab7ae32ff9c82u64;\n-        self.engine.H3 = 0x679dd514582f9fcfu64;\n-        self.engine.H4 = 0x0f6d2b697bd44da8u64;\n-        self.engine.H5 = 0x77e36f7304c48942u64;\n-        self.engine.H6 = 0x3f9d85a86a1d36c8u64;\n-        self.engine.H7 = 0x1112e6ad91d692a1u64;\n+        self.engine.reset(&H512_TRUNC_224);\n     }\n \n     fn output_bits(&self) -> uint { 224 }\n }\n \n+static H512_TRUNC_224: [u64, ..8] = [\n+    0x8c3d37c819544da2,\n+    0x73e1996689dcd4d6,\n+    0x1dfab7ae32ff9c82,\n+    0x679dd514582f9fcf,\n+    0x0f6d2b697bd44da8,\n+    0x77e36f7304c48942,\n+    0x3f9d85a86a1d36c8,\n+    0x1112e6ad91d692a1,\n+];\n \n-// A structure that represents that state of a digest computation\n-// for the SHA-2 256 family of digest functions\n-struct Engine256 {\n-    input_buffer: [u8, ..4],\n-    input_buffer_idx: uint,\n-    length_bytes: u64,\n+\n+// A structure that represents that state of a digest computation for the SHA-2 512 family of digest\n+// functions\n+struct Engine256State {\n     H0: u32,\n     H1: u32,\n     H2: u32,\n@@ -559,84 +471,34 @@ struct Engine256 {\n     H5: u32,\n     H6: u32,\n     H7: u32,\n-    W: [u32, ..64],\n-    W_idx: uint,\n-    finished: bool\n-}\n-\n-// Convert a [u8] to a u32 in big endian format\n-fn to_u32(input: &[u8]) -> u32 {\n-    (input[0] as u32) << 24 |\n-    (input[1] as u32) << 16 |\n-    (input[2] as u32) << 8 |\n-    (input[3] as u32)\n-}\n-\n-// Convert a u32 to a [u8] in big endian format\n-fn from_u32(input: u32, out: &mut [u8]) {\n-    out[0] = (input >> 24) as u8;\n-    out[1] = (input >> 16) as u8;\n-    out[2] = (input >> 8) as u8;\n-    out[3] = input as u8;\n }\n \n-impl Engine256 {\n-    fn input_byte(&mut self, input: u8) {\n-        assert!(!self.finished)\n-\n-        self.input_buffer[self.input_buffer_idx] = input;\n-        self.input_buffer_idx += 1;\n-\n-        if (self.input_buffer_idx == 4) {\n-            self.input_buffer_idx = 0;\n-            let w = to_u32(self.input_buffer);\n-            self.process_word(w);\n-        }\n-\n-        self.length_bytes += 1;\n-    }\n-\n-    fn input_vec(&mut self, input: &[u8]) {\n-        assert!(!self.finished)\n-\n-        let mut i = 0;\n-\n-        while i < input.len() && self.input_buffer_idx != 0 {\n-            self.input_byte(input[i]);\n-            i += 1;\n-        }\n-\n-        while input.len() - i >= 4 {\n-            let w = to_u32(input.slice(i, i + 4));\n-            self.process_word(w);\n-            self.length_bytes += 4;\n-            i += 4;\n-        }\n-\n-        while i < input.len() {\n-            self.input_byte(input[i]);\n-            i += 1;\n-        }\n-\n+impl Engine256State {\n+    fn new(h: &[u32, ..8]) -> Engine256State {\n+        return Engine256State {\n+            H0: h[0],\n+            H1: h[1],\n+            H2: h[2],\n+            H3: h[3],\n+            H4: h[4],\n+            H5: h[5],\n+            H6: h[6],\n+            H7: h[7]\n+        };\n     }\n \n-    fn reset(&mut self) {\n-        self.length_bytes = 0;\n-        self.finished = false;\n-        self.input_buffer_idx = 0;\n-        self.W_idx = 0;\n+    fn reset(&mut self, h: &[u32, ..8]) {\n+        self.H0 = h[0];\n+        self.H1 = h[1];\n+        self.H2 = h[2];\n+        self.H3 = h[3];\n+        self.H4 = h[4];\n+        self.H5 = h[5];\n+        self.H6 = h[6];\n+        self.H7 = h[7];\n     }\n \n-    fn process_word(&mut self, input: u32) {\n-        self.W[self.W_idx] = input;\n-        self.W_idx += 1;\n-        if (self.W_idx == 16) {\n-            self.W_idx = 0;\n-            self.process_block();\n-        }\n-    }\n-\n-    fn process_block(&mut self) {\n+    fn process_block(&mut self, data: &[u8]) {\n         fn ch(x: u32, y: u32, z: u32) -> u32 {\n             ((x & y) ^ ((!x) & z))\n         }\n@@ -661,9 +523,13 @@ impl Engine256 {\n             ((x >> 17) | (x << 15)) ^ ((x >> 19) | (x << 13)) ^ (x >> 10)\n         }\n \n+        let mut W = [0u32, ..80];\n+\n+        read_u32v_be(W.mut_slice(0, 16), data);\n+\n         foreach t in range(16u, 64) {\n-            self.W[t] = sigma1(self.W[t - 2]) + self.W[t - 7] + sigma0(self.W[t - 15]) +\n-                self.W[t - 16];\n+            W[t] = sigma1(W[t - 2]) + W[t - 7] + sigma0(W[t - 15]) +\n+                W[t - 16];\n         }\n \n         let mut a = self.H0;\n@@ -676,43 +542,44 @@ impl Engine256 {\n         let mut h = self.H7;\n \n         let mut t = 0;\n+\n         foreach _ in range(0u, 8) {\n-            h += sum1(e) + ch(e, f, g) + K32[t] + self.W[t];\n+            h += sum1(e) + ch(e, f, g) + K32[t] + W[t];\n             d += h;\n             h += sum0(a) + maj(a, b, c);\n             t += 1;\n \n-            g += sum1(d) + ch(d, e, f) + K32[t] + self.W[t];\n+            g += sum1(d) + ch(d, e, f) + K32[t] + W[t];\n             c += g;\n             g += sum0(h) + maj(h, a, b);\n             t += 1;\n \n-            f += sum1(c) + ch(c, d, e) + K32[t] + self.W[t];\n+            f += sum1(c) + ch(c, d, e) + K32[t] + W[t];\n             b += f;\n             f += sum0(g) + maj(g, h, a);\n             t += 1;\n \n-            e += sum1(b) + ch(b, c, d) + K32[t] + self.W[t];\n+            e += sum1(b) + ch(b, c, d) + K32[t] + W[t];\n             a += e;\n             e += sum0(f) + maj(f, g, h);\n             t += 1;\n \n-            d += sum1(a) + ch(a, b, c) + K32[t] + self.W[t];\n+            d += sum1(a) + ch(a, b, c) + K32[t] + W[t];\n             h += d;\n             d += sum0(e) + maj(e, f, g);\n             t += 1;\n \n-            c += sum1(h) + ch(h, a, b) + K32[t] + self.W[t];\n+            c += sum1(h) + ch(h, a, b) + K32[t] + W[t];\n             g += c;\n             c += sum0(d) + maj(d, e, f);\n             t += 1;\n \n-            b += sum1(g) + ch(g, h, a) + K32[t] + self.W[t];\n+            b += sum1(g) + ch(g, h, a) + K32[t] + W[t];\n             f += b;\n             b += sum0(c) + maj(c, d, e);\n             t += 1;\n \n-            a += sum1(f) + ch(f, g, h) + K32[t] + self.W[t];\n+            a += sum1(f) + ch(f, g, h) + K32[t] + W[t];\n             e += a;\n             a += sum0(b) + maj(b, c, d);\n             t += 1;\n@@ -727,38 +594,6 @@ impl Engine256 {\n         self.H6 += g;\n         self.H7 += h;\n     }\n-\n-    fn finish(&mut self) {\n-        if (self.finished) {\n-            return;\n-        }\n-\n-        // must get length before adding padding\n-        let bit_length = self.length_bytes << 3;\n-\n-        // add padding\n-        self.input_byte(128u8);\n-\n-        while self.input_buffer_idx != 0 {\n-            self.input_byte(0u8);\n-        }\n-\n-        // add length\n-        if (self.W_idx > 14) {\n-            foreach _ in range(self.W_idx, 16) {\n-                self.process_word(0);\n-            }\n-        }\n-\n-        while self.W_idx < 14 {\n-            self.process_word(0);\n-        }\n-\n-        self.process_word((bit_length >> 32) as u32);\n-        self.process_word(bit_length as u32);\n-\n-        self.finished = true;\n-    }\n }\n \n static K32: [u32, ..64] = [\n@@ -781,6 +616,53 @@ static K32: [u32, ..64] = [\n ];\n \n \n+// A structure that keeps track of the state of the Sha-256 operation and contains the logic\n+// necessary to perform the final calculations.\n+struct Engine256 {\n+    length: u64,\n+    buffer: FixedBuffer64,\n+    state: Engine256State,\n+    finished: bool,\n+}\n+\n+impl Engine256 {\n+    fn new(h: &[u32, ..8]) -> Engine256 {\n+        return Engine256 {\n+            length: 0,\n+            buffer: FixedBuffer64::new(),\n+            state: Engine256State::new(h),\n+            finished: false\n+        }\n+    }\n+\n+    fn reset(&mut self, h: &[u32, ..8]) {\n+        self.length = 0;\n+        self.buffer.reset();\n+        self.state.reset(h);\n+        self.finished = false;\n+    }\n+\n+    fn input(&mut self, input: &[u8]) {\n+        assert!(!self.finished)\n+        self.length += input.len() as u64;\n+        self.buffer.input(input, |input: &[u8]| { self.state.process_block(input) });\n+    }\n+\n+    fn finish(&mut self) {\n+        if self.finished {\n+            return;\n+        }\n+\n+        self.buffer.standard_padding(8, |input: &[u8]| { self.state.process_block(input) });\n+        write_u32_be(self.buffer.next(4), (self.length >> 29) as u32 );\n+        write_u32_be(self.buffer.next(4), (self.length << 3) as u32);\n+        self.state.process_block(self.buffer.full_buffer());\n+\n+        self.finished = true;\n+    }\n+}\n+\n+\n struct Sha256 {\n     priv engine: Engine256\n }\n@@ -791,60 +673,47 @@ impl Sha256 {\n      */\n     pub fn new() -> Sha256 {\n         Sha256 {\n-            engine: Engine256 {\n-                input_buffer: [0u8, ..4],\n-                input_buffer_idx: 0,\n-                length_bytes: 0,\n-                H0: 0x6a09e667u32,\n-                H1: 0xbb67ae85u32,\n-                H2: 0x3c6ef372u32,\n-                H3: 0xa54ff53au32,\n-                H4: 0x510e527fu32,\n-                H5: 0x9b05688cu32,\n-                H6: 0x1f83d9abu32,\n-                H7: 0x5be0cd19u32,\n-                W: [0u32, ..64],\n-                W_idx: 0,\n-                finished: false,\n-            }\n+            engine: Engine256::new(&H256)\n         }\n     }\n }\n \n impl Digest for Sha256 {\n     fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n+        self.engine.input(d);\n     }\n \n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n \n-        from_u32(self.engine.H0, out.mut_slice(0, 4));\n-        from_u32(self.engine.H1, out.mut_slice(4, 8));\n-        from_u32(self.engine.H2, out.mut_slice(8, 12));\n-        from_u32(self.engine.H3, out.mut_slice(12, 16));\n-        from_u32(self.engine.H4, out.mut_slice(16, 20));\n-        from_u32(self.engine.H5, out.mut_slice(20, 24));\n-        from_u32(self.engine.H6, out.mut_slice(24, 28));\n-        from_u32(self.engine.H7, out.mut_slice(28, 32));\n+        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n+        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n+        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n+        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n+        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n+        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n+        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n+        write_u32_be(out.mut_slice(28, 32), self.engine.state.H7);\n     }\n \n     fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0x6a09e667u32;\n-        self.engine.H1 = 0xbb67ae85u32;\n-        self.engine.H2 = 0x3c6ef372u32;\n-        self.engine.H3 = 0xa54ff53au32;\n-        self.engine.H4 = 0x510e527fu32;\n-        self.engine.H5 = 0x9b05688cu32;\n-        self.engine.H6 = 0x1f83d9abu32;\n-        self.engine.H7 = 0x5be0cd19u32;\n+        self.engine.reset(&H256);\n     }\n \n     fn output_bits(&self) -> uint { 256 }\n }\n \n+static H256: [u32, ..8] = [\n+    0x6a09e667,\n+    0xbb67ae85,\n+    0x3c6ef372,\n+    0xa54ff53a,\n+    0x510e527f,\n+    0x9b05688c,\n+    0x1f83d9ab,\n+    0x5be0cd19\n+];\n+\n \n struct Sha224 {\n     priv engine: Engine256\n@@ -856,59 +725,45 @@ impl Sha224 {\n      */\n     pub fn new() -> Sha224 {\n         Sha224 {\n-            engine: Engine256 {\n-                input_buffer: [0u8, ..4],\n-                input_buffer_idx: 0,\n-                length_bytes: 0,\n-                H0: 0xc1059ed8u32,\n-                H1: 0x367cd507u32,\n-                H2: 0x3070dd17u32,\n-                H3: 0xf70e5939u32,\n-                H4: 0xffc00b31u32,\n-                H5: 0x68581511u32,\n-                H6: 0x64f98fa7u32,\n-                H7: 0xbefa4fa4u32,\n-                W: [0u32, ..64],\n-                W_idx: 0,\n-                finished: false,\n-            }\n+            engine: Engine256::new(&H224)\n         }\n     }\n }\n \n impl Digest for Sha224 {\n     fn input(&mut self, d: &[u8]) {\n-        self.engine.input_vec(d);\n+        self.engine.input(d);\n     }\n \n     fn result(&mut self, out: &mut [u8]) {\n         self.engine.finish();\n-\n-        from_u32(self.engine.H0, out.mut_slice(0, 4));\n-        from_u32(self.engine.H1, out.mut_slice(4, 8));\n-        from_u32(self.engine.H2, out.mut_slice(8, 12));\n-        from_u32(self.engine.H3, out.mut_slice(12, 16));\n-        from_u32(self.engine.H4, out.mut_slice(16, 20));\n-        from_u32(self.engine.H5, out.mut_slice(20, 24));\n-        from_u32(self.engine.H6, out.mut_slice(24, 28));\n+        write_u32_be(out.mut_slice(0, 4), self.engine.state.H0);\n+        write_u32_be(out.mut_slice(4, 8), self.engine.state.H1);\n+        write_u32_be(out.mut_slice(8, 12), self.engine.state.H2);\n+        write_u32_be(out.mut_slice(12, 16), self.engine.state.H3);\n+        write_u32_be(out.mut_slice(16, 20), self.engine.state.H4);\n+        write_u32_be(out.mut_slice(20, 24), self.engine.state.H5);\n+        write_u32_be(out.mut_slice(24, 28), self.engine.state.H6);\n     }\n \n     fn reset(&mut self) {\n-        self.engine.reset();\n-\n-        self.engine.H0 = 0xc1059ed8u32;\n-        self.engine.H1 = 0x367cd507u32;\n-        self.engine.H2 = 0x3070dd17u32;\n-        self.engine.H3 = 0xf70e5939u32;\n-        self.engine.H4 = 0xffc00b31u32;\n-        self.engine.H5 = 0x68581511u32;\n-        self.engine.H6 = 0x64f98fa7u32;\n-        self.engine.H7 = 0xbefa4fa4u32;\n+        self.engine.reset(&H224);\n     }\n \n     fn output_bits(&self) -> uint { 224 }\n }\n \n+static H224: [u32, ..8] = [\n+    0xc1059ed8,\n+    0x367cd507,\n+    0x3070dd17,\n+    0xf70e5939,\n+    0xffc00b31,\n+    0x68581511,\n+    0x64f98fa7,\n+    0xbefa4fa4\n+];\n+\n \n #[cfg(test)]\n mod tests {"}, {"sha": "e6134bb340cd8c45b708ab71d6f3539b45b4061d", "filename": "src/libextra/extra.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/654c536fec01d984f758ec32904354378aa3b792/src%2Flibextra%2Fextra.rs", "raw_url": "https://github.com/rust-lang/rust/raw/654c536fec01d984f758ec32904354378aa3b792/src%2Flibextra%2Fextra.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fextra.rs?ref=654c536fec01d984f758ec32904354378aa3b792", "patch": "@@ -67,6 +67,8 @@ pub mod dlist;\n pub mod treemap;\n \n // Crypto\n+#[path=\"crypto/cryptoutil.rs\"]\n+mod cryptoutil;\n #[path=\"crypto/digest.rs\"]\n pub mod digest;\n #[path=\"crypto/sha1.rs\"]"}]}