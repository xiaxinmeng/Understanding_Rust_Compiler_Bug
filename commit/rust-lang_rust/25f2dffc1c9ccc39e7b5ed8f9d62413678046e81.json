{"sha": "25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI1ZjJkZmZjMWM5Y2NjMzllN2I1ZWQ4ZjlkNjI0MTM2NzgwNDZlODE=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-02-18T20:13:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-02-18T20:13:52Z"}, "message": "Merge pull request #2461 from topecongiro/reorder-mod\n\nRefactoring: add `reorder` modules", "tree": {"sha": "96e1df4feac741613c4f29b42115335b2481fc1f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96e1df4feac741613c4f29b42115335b2481fc1f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJaid6ACRBK7hj4Ov3rIwAAdHIIACP0d3DLUY9YT9UZty2WXR8G\npfb428HMOs755iFfyS3NSljSJsndRxd/52PPAPSVkbQTKOplZjq+Cm6vSlLPHjin\nwx9TQ64hBiOl5bvN/TIhL8gTzUolToxypxuArjFvKi46NK/DELbV+c/Puv/ngfya\n+Z0ikVGoOLPVQzHNx4Qb7OgqWYwi0a05GVguSu9P6a3g5HBLhiBmT/FvUmpSBQFW\ntU/t1Dl182u4KAhs4AvqzYIMlgOHEHtA7aFFJMD907oI6UdYxfvX5yVC7OESJddb\n7r479Y6aNXT4vnbzAnzjGIHmVXLO6sQAEQJpoLJCo9tAEr7Vwya4MJvZ5nbuRsE=\n=9QNZ\n-----END PGP SIGNATURE-----\n", "payload": "tree 96e1df4feac741613c4f29b42115335b2481fc1f\nparent cbf524f9e954694d3194cdbfacb7040682c9f9c1\nparent c32eb1fe3447201861b052d71230629e9aece2b8\nauthor Nick Cameron <nrc@ncameron.org> 1518984832 +1300\ncommitter GitHub <noreply@github.com> 1518984832 +1300\n\nMerge pull request #2461 from topecongiro/reorder-mod\n\nRefactoring: add `reorder` modules"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "html_url": "https://github.com/rust-lang/rust/commit/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbf524f9e954694d3194cdbfacb7040682c9f9c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbf524f9e954694d3194cdbfacb7040682c9f9c1", "html_url": "https://github.com/rust-lang/rust/commit/cbf524f9e954694d3194cdbfacb7040682c9f9c1"}, {"sha": "c32eb1fe3447201861b052d71230629e9aece2b8", "url": "https://api.github.com/repos/rust-lang/rust/commits/c32eb1fe3447201861b052d71230629e9aece2b8", "html_url": "https://github.com/rust-lang/rust/commit/c32eb1fe3447201861b052d71230629e9aece2b8"}], "stats": {"total": 649, "additions": 351, "deletions": 298}, "files": [{"sha": "e384359c2b402e3762b9aafab57dd17b424c74aa", "filename": "rustfmt-core/src/imports.rs", "status": "modified", "additions": 6, "deletions": 207, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fimports.rs?ref=25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "patch": "@@ -15,132 +15,20 @@ use syntax::ast;\n use syntax::codemap::{BytePos, Span};\n \n use codemap::SpanUtils;\n-use comment::combine_strs_with_missing_comments;\n use config::IndentStyle;\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use rewrite::{Rewrite, RewriteContext};\n use shape::Shape;\n-use spanned::Spanned;\n use types::{rewrite_path, PathContext};\n use utils::{format_visibility, mk_sp};\n-use visitor::{rewrite_extern_crate, FmtVisitor};\n+use visitor::FmtVisitor;\n \n-fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n-    a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n-}\n-\n-fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n-    for segment in a.segments.iter().zip(b.segments.iter()) {\n-        let ord = compare_path_segments(segment.0, segment.1);\n-        if ord != Ordering::Equal {\n-            return ord;\n-        }\n-    }\n-    a.segments.len().cmp(&b.segments.len())\n-}\n-\n-fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Ordering {\n-    use ast::UseTreeKind::*;\n-\n-    // `use_nested_groups` is not yet supported, remove the `if !nested` when support will be\n-    // fully added\n-    if !nested {\n-        let paths_cmp = compare_paths(&a.prefix, &b.prefix);\n-        if paths_cmp != Ordering::Equal {\n-            return paths_cmp;\n-        }\n-    }\n-\n-    match (&a.kind, &b.kind) {\n-        (&Simple(ident_a), &Simple(ident_b)) => {\n-            let name_a = &*path_to_imported_ident(&a.prefix).name.as_str();\n-            let name_b = &*path_to_imported_ident(&b.prefix).name.as_str();\n-            let name_ordering = if name_a == \"self\" {\n-                if name_b == \"self\" {\n-                    Ordering::Equal\n-                } else {\n-                    Ordering::Less\n-                }\n-            } else if name_b == \"self\" {\n-                Ordering::Greater\n-            } else {\n-                name_a.cmp(name_b)\n-            };\n-            if name_ordering == Ordering::Equal {\n-                if ident_a.name.as_str() != name_a {\n-                    if ident_b.name.as_str() != name_b {\n-                        ident_a.name.as_str().cmp(&ident_b.name.as_str())\n-                    } else {\n-                        Ordering::Greater\n-                    }\n-                } else {\n-                    Ordering::Less\n-                }\n-            } else {\n-                name_ordering\n-            }\n-        }\n-        (&Glob, &Glob) => Ordering::Equal,\n-        (&Simple(_), _) | (&Glob, &Nested(_)) => Ordering::Less,\n-        (&Nested(ref a_items), &Nested(ref b_items)) => {\n-            let mut a = a_items\n-                .iter()\n-                .map(|&(ref tree, _)| tree.clone())\n-                .collect::<Vec<_>>();\n-            let mut b = b_items\n-                .iter()\n-                .map(|&(ref tree, _)| tree.clone())\n-                .collect::<Vec<_>>();\n-            a.sort_by(|a, b| compare_use_trees(a, b, true));\n-            b.sort_by(|a, b| compare_use_trees(a, b, true));\n-            for comparison_pair in a.iter().zip(b.iter()) {\n-                let ord = compare_use_trees(comparison_pair.0, comparison_pair.1, true);\n-                if ord != Ordering::Equal {\n-                    return ord;\n-                }\n-            }\n-            a.len().cmp(&b.len())\n-        }\n-        (&Glob, &Simple(_)) | (&Nested(_), _) => Ordering::Greater,\n-    }\n-}\n-\n-fn compare_use_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n-    match (&a.node, &b.node) {\n-        (&ast::ItemKind::Mod(..), &ast::ItemKind::Mod(..)) => {\n-            a.ident.name.as_str().cmp(&b.ident.name.as_str())\n-        }\n-        (&ast::ItemKind::Use(ref a_tree), &ast::ItemKind::Use(ref b_tree)) => {\n-            compare_use_trees(a_tree, b_tree, false)\n-        }\n-        (&ast::ItemKind::ExternCrate(ref a_name), &ast::ItemKind::ExternCrate(ref b_name)) => {\n-            // `extern crate foo as bar;`\n-            //               ^^^ Comparing this.\n-            let a_orig_name =\n-                a_name.map_or_else(|| a.ident.name.as_str(), |symbol| symbol.as_str());\n-            let b_orig_name =\n-                b_name.map_or_else(|| b.ident.name.as_str(), |symbol| symbol.as_str());\n-            let result = a_orig_name.cmp(&b_orig_name);\n-            if result != Ordering::Equal {\n-                return result;\n-            }\n-\n-            // `extern crate foo as bar;`\n-            //                      ^^^ Comparing this.\n-            match (a_name, b_name) {\n-                (Some(..), None) => Ordering::Greater,\n-                (None, Some(..)) => Ordering::Less,\n-                (None, None) => Ordering::Equal,\n-                (Some(..), Some(..)) => a.ident.name.as_str().cmp(&b.ident.name.as_str()),\n-            }\n-        }\n-        _ => unreachable!(),\n-    }\n+/// Returns a name imported by a `use` declaration. e.g. returns `Ordering`\n+/// for `std::cmp::Ordering` and `self` for `std::cmp::self`.\n+pub fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n+    path.segments.last().unwrap().identifier\n }\n \n-// TODO (some day) remove unused imports, expand globs, compress many single\n-// imports into a list import.\n-\n fn rewrite_prefix(path: &ast::Path, context: &RewriteContext, shape: Shape) -> Option<String> {\n     if path.segments.len() > 1 && path_to_imported_ident(path).to_string() == \"self\" {\n         let path = &ast::Path {\n@@ -208,7 +96,7 @@ fn is_unused_import_inner(tree: &ast::UseTree) -> bool {\n }\n \n // Rewrite `use foo;` WITHOUT attributes.\n-fn rewrite_import(\n+pub fn rewrite_import(\n     context: &RewriteContext,\n     vis: &ast::Visibility,\n     tree: &ast::UseTree,\n@@ -234,92 +122,7 @@ fn rewrite_import(\n     }\n }\n \n-/// Rewrite an inline mod.\n-fn rewrite_mod(item: &ast::Item) -> String {\n-    let mut result = String::with_capacity(32);\n-    result.push_str(&*format_visibility(&item.vis));\n-    result.push_str(\"mod \");\n-    result.push_str(&item.ident.to_string());\n-    result.push(';');\n-    result\n-}\n-\n-fn rewrite_imports(\n-    context: &RewriteContext,\n-    use_items: &[&ast::Item],\n-    shape: Shape,\n-    span: Span,\n-) -> Option<String> {\n-    let items = itemize_list(\n-        context.codemap,\n-        use_items.iter(),\n-        \"\",\n-        \";\",\n-        |item| item.span().lo(),\n-        |item| item.span().hi(),\n-        |item| {\n-            let attrs = ::visitor::filter_inline_attrs(&item.attrs, item.span());\n-            let attrs_str = attrs.rewrite(context, shape)?;\n-\n-            let missed_span = if attrs.is_empty() {\n-                mk_sp(item.span.lo(), item.span.lo())\n-            } else {\n-                mk_sp(attrs.last().unwrap().span.hi(), item.span.lo())\n-            };\n-\n-            let item_str = match item.node {\n-                ast::ItemKind::Use(ref tree) => {\n-                    rewrite_import(context, &item.vis, tree, &item.attrs, shape)?\n-                }\n-                ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n-                ast::ItemKind::Mod(..) => rewrite_mod(item),\n-                _ => return None,\n-            };\n-\n-            combine_strs_with_missing_comments(\n-                context,\n-                &attrs_str,\n-                &item_str,\n-                missed_span,\n-                shape,\n-                false,\n-            )\n-        },\n-        span.lo(),\n-        span.hi(),\n-        false,\n-    );\n-    let mut item_pair_vec: Vec<_> = items.zip(use_items.iter()).collect();\n-    item_pair_vec.sort_by(|a, b| compare_use_items(a.1, b.1));\n-    let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n-\n-    let fmt = ListFormatting {\n-        tactic: DefinitiveListTactic::Vertical,\n-        separator: \"\",\n-        trailing_separator: SeparatorTactic::Never,\n-        separator_place: SeparatorPlace::Back,\n-        shape,\n-        ends_with_newline: true,\n-        preserve_newline: false,\n-        config: context.config,\n-    };\n-\n-    write_list(&item_vec, &fmt)\n-}\n-\n impl<'a> FmtVisitor<'a> {\n-    pub fn format_imports(&mut self, use_items: &[&ast::Item]) {\n-        if use_items.is_empty() {\n-            return;\n-        }\n-\n-        let lo = use_items.first().unwrap().span().lo();\n-        let hi = use_items.last().unwrap().span().hi();\n-        let span = mk_sp(lo, hi);\n-        let rw = rewrite_imports(&self.get_context(), use_items, self.shape(), span);\n-        self.push_rewrite(span, rw);\n-    }\n-\n     pub fn format_import(&mut self, item: &ast::Item, tree: &ast::UseTree) {\n         let span = item.span;\n         let shape = self.shape();\n@@ -594,7 +397,3 @@ fn move_self_to_front(items: &mut Vec<ListItem>) -> bool {\n         None => false,\n     }\n }\n-\n-fn path_to_imported_ident(path: &ast::Path) -> ast::Ident {\n-    path.segments.last().unwrap().identifier\n-}"}, {"sha": "07b6c1d79bff163aa7a9fb4eaba06b50314c45bf", "filename": "rustfmt-core/src/items.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fitems.rs?ref=25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "patch": "@@ -2845,3 +2845,13 @@ impl Rewrite for ast::GenericParam {\n         }\n     }\n }\n+\n+/// Rewrite an inline mod.\n+pub fn rewrite_mod(item: &ast::Item) -> String {\n+    let mut result = String::with_capacity(32);\n+    result.push_str(&*format_visibility(&item.vis));\n+    result.push_str(\"mod \");\n+    result.push_str(&item.ident.to_string());\n+    result.push(';');\n+    result\n+}"}, {"sha": "9d138a306880c82f5be3c6a44e7dd054b3cdca4d", "filename": "rustfmt-core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Flib.rs?ref=25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "patch": "@@ -52,6 +52,7 @@ pub use config::summary::Summary;\n \n #[macro_use]\n mod utils;\n+\n mod chains;\n mod checkstyle;\n mod closures;\n@@ -67,6 +68,7 @@ mod macros;\n mod missed_spans;\n pub mod modules;\n mod patterns;\n+mod reorder;\n mod rewrite;\n pub mod rustfmt_diff;\n mod shape;"}, {"sha": "a38eba74be5a7966dcfbe3d49410a94dc40212f3", "filename": "rustfmt-core/src/reorder.rs", "status": "added", "additions": 330, "deletions": 0, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Freorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Freorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Freorder.rs?ref=25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "patch": "@@ -0,0 +1,330 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Reorder items.\n+//!\n+//! `mod`, `extern crate` and `use` declarations are reorderd in alphabetical\n+//! order. Trait items are reordered in pre-determined order (associated types\n+//! and constatns comes before methods).\n+\n+// TODO(#2455): Reorder trait items.\n+\n+use config::{Config, lists::*};\n+use syntax::{ast, attr, codemap::Span};\n+\n+use codemap::LineRangeUtils;\n+use comment::combine_strs_with_missing_comments;\n+use imports::{path_to_imported_ident, rewrite_import};\n+use items::rewrite_mod;\n+use lists::{itemize_list, write_list, ListFormatting};\n+use rewrite::{Rewrite, RewriteContext};\n+use shape::Shape;\n+use spanned::Spanned;\n+use utils::mk_sp;\n+use visitor::{filter_inline_attrs, rewrite_extern_crate, FmtVisitor};\n+\n+use std::cmp::Ordering;\n+\n+fn compare_path_segments(a: &ast::PathSegment, b: &ast::PathSegment) -> Ordering {\n+    a.identifier.name.as_str().cmp(&b.identifier.name.as_str())\n+}\n+\n+fn compare_paths(a: &ast::Path, b: &ast::Path) -> Ordering {\n+    for segment in a.segments.iter().zip(b.segments.iter()) {\n+        let ord = compare_path_segments(segment.0, segment.1);\n+        if ord != Ordering::Equal {\n+            return ord;\n+        }\n+    }\n+    a.segments.len().cmp(&b.segments.len())\n+}\n+\n+fn compare_use_trees(a: &ast::UseTree, b: &ast::UseTree, nested: bool) -> Ordering {\n+    use ast::UseTreeKind::*;\n+\n+    // `use_nested_groups` is not yet supported, remove the `if !nested` when support will be\n+    // fully added\n+    if !nested {\n+        let paths_cmp = compare_paths(&a.prefix, &b.prefix);\n+        if paths_cmp != Ordering::Equal {\n+            return paths_cmp;\n+        }\n+    }\n+\n+    match (&a.kind, &b.kind) {\n+        (&Simple(ident_a), &Simple(ident_b)) => {\n+            let name_a = &*path_to_imported_ident(&a.prefix).name.as_str();\n+            let name_b = &*path_to_imported_ident(&b.prefix).name.as_str();\n+            let name_ordering = if name_a == \"self\" {\n+                if name_b == \"self\" {\n+                    Ordering::Equal\n+                } else {\n+                    Ordering::Less\n+                }\n+            } else if name_b == \"self\" {\n+                Ordering::Greater\n+            } else {\n+                name_a.cmp(name_b)\n+            };\n+            if name_ordering == Ordering::Equal {\n+                if ident_a.name.as_str() != name_a {\n+                    if ident_b.name.as_str() != name_b {\n+                        ident_a.name.as_str().cmp(&ident_b.name.as_str())\n+                    } else {\n+                        Ordering::Greater\n+                    }\n+                } else {\n+                    Ordering::Less\n+                }\n+            } else {\n+                name_ordering\n+            }\n+        }\n+        (&Glob, &Glob) => Ordering::Equal,\n+        (&Simple(_), _) | (&Glob, &Nested(_)) => Ordering::Less,\n+        (&Nested(ref a_items), &Nested(ref b_items)) => {\n+            let mut a = a_items\n+                .iter()\n+                .map(|&(ref tree, _)| tree.clone())\n+                .collect::<Vec<_>>();\n+            let mut b = b_items\n+                .iter()\n+                .map(|&(ref tree, _)| tree.clone())\n+                .collect::<Vec<_>>();\n+            a.sort_by(|a, b| compare_use_trees(a, b, true));\n+            b.sort_by(|a, b| compare_use_trees(a, b, true));\n+            for comparison_pair in a.iter().zip(b.iter()) {\n+                let ord = compare_use_trees(comparison_pair.0, comparison_pair.1, true);\n+                if ord != Ordering::Equal {\n+                    return ord;\n+                }\n+            }\n+            a.len().cmp(&b.len())\n+        }\n+        (&Glob, &Simple(_)) | (&Nested(_), _) => Ordering::Greater,\n+    }\n+}\n+\n+/// Choose the ordering between the given two items.\n+fn compare_items(a: &ast::Item, b: &ast::Item) -> Ordering {\n+    match (&a.node, &b.node) {\n+        (&ast::ItemKind::Mod(..), &ast::ItemKind::Mod(..)) => {\n+            a.ident.name.as_str().cmp(&b.ident.name.as_str())\n+        }\n+        (&ast::ItemKind::Use(ref a_tree), &ast::ItemKind::Use(ref b_tree)) => {\n+            compare_use_trees(a_tree, b_tree, false)\n+        }\n+        (&ast::ItemKind::ExternCrate(ref a_name), &ast::ItemKind::ExternCrate(ref b_name)) => {\n+            // `extern crate foo as bar;`\n+            //               ^^^ Comparing this.\n+            let a_orig_name =\n+                a_name.map_or_else(|| a.ident.name.as_str(), |symbol| symbol.as_str());\n+            let b_orig_name =\n+                b_name.map_or_else(|| b.ident.name.as_str(), |symbol| symbol.as_str());\n+            let result = a_orig_name.cmp(&b_orig_name);\n+            if result != Ordering::Equal {\n+                return result;\n+            }\n+\n+            // `extern crate foo as bar;`\n+            //                      ^^^ Comparing this.\n+            match (a_name, b_name) {\n+                (Some(..), None) => Ordering::Greater,\n+                (None, Some(..)) => Ordering::Less,\n+                (None, None) => Ordering::Equal,\n+                (Some(..), Some(..)) => a.ident.name.as_str().cmp(&b.ident.name.as_str()),\n+            }\n+        }\n+        _ => unreachable!(),\n+    }\n+}\n+\n+/// Rewrite a list of items with reordering. Every item in `items` must have\n+/// the same `ast::ItemKind`.\n+// TODO (some day) remove unused imports, expand globs, compress many single\n+// imports into a list import.\n+fn rewrite_reorderable_items(\n+    context: &RewriteContext,\n+    reorderable_items: &[&ast::Item],\n+    shape: Shape,\n+    span: Span,\n+) -> Option<String> {\n+    let items = itemize_list(\n+        context.codemap,\n+        reorderable_items.iter(),\n+        \"\",\n+        \";\",\n+        |item| item.span().lo(),\n+        |item| item.span().hi(),\n+        |item| {\n+            let attrs = filter_inline_attrs(&item.attrs, item.span());\n+            let attrs_str = attrs.rewrite(context, shape)?;\n+\n+            let missed_span = if attrs.is_empty() {\n+                mk_sp(item.span.lo(), item.span.lo())\n+            } else {\n+                mk_sp(attrs.last().unwrap().span.hi(), item.span.lo())\n+            };\n+\n+            let item_str = match item.node {\n+                ast::ItemKind::Use(ref tree) => {\n+                    rewrite_import(context, &item.vis, tree, &item.attrs, shape)?\n+                }\n+                ast::ItemKind::ExternCrate(..) => rewrite_extern_crate(context, item)?,\n+                ast::ItemKind::Mod(..) => rewrite_mod(item),\n+                _ => return None,\n+            };\n+\n+            combine_strs_with_missing_comments(\n+                context,\n+                &attrs_str,\n+                &item_str,\n+                missed_span,\n+                shape,\n+                false,\n+            )\n+        },\n+        span.lo(),\n+        span.hi(),\n+        false,\n+    );\n+    let mut item_pair_vec: Vec<_> = items.zip(reorderable_items.iter()).collect();\n+    item_pair_vec.sort_by(|a, b| compare_items(a.1, b.1));\n+    let item_vec: Vec<_> = item_pair_vec.into_iter().map(|pair| pair.0).collect();\n+\n+    let fmt = ListFormatting {\n+        tactic: DefinitiveListTactic::Vertical,\n+        separator: \"\",\n+        trailing_separator: SeparatorTactic::Never,\n+        separator_place: SeparatorPlace::Back,\n+        shape,\n+        ends_with_newline: true,\n+        preserve_newline: false,\n+        config: context.config,\n+    };\n+\n+    write_list(&item_vec, &fmt)\n+}\n+\n+fn contains_macro_use_attr(item: &ast::Item) -> bool {\n+    attr::contains_name(&filter_inline_attrs(&item.attrs, item.span()), \"macro_use\")\n+}\n+\n+/// A simplified version of `ast::ItemKind`.\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+enum ReorderableItemKind {\n+    ExternCrate,\n+    Mod,\n+    Use,\n+    /// An item that cannot be reordered. Either has an unreorderable item kind\n+    /// or an `macro_use` attribute.\n+    Other,\n+}\n+\n+impl ReorderableItemKind {\n+    pub fn from(item: &ast::Item) -> Self {\n+        match item.node {\n+            _ if contains_macro_use_attr(item) => ReorderableItemKind::Other,\n+            ast::ItemKind::ExternCrate(..) => ReorderableItemKind::ExternCrate,\n+            ast::ItemKind::Mod(..) => ReorderableItemKind::Mod,\n+            ast::ItemKind::Use(..) => ReorderableItemKind::Use,\n+            _ => ReorderableItemKind::Other,\n+        }\n+    }\n+\n+    pub fn is_same_item_kind(&self, item: &ast::Item) -> bool {\n+        ReorderableItemKind::from(item) == *self\n+    }\n+\n+    pub fn is_reorderable(&self, config: &Config) -> bool {\n+        match *self {\n+            ReorderableItemKind::ExternCrate => config.reorder_extern_crates(),\n+            ReorderableItemKind::Mod => config.reorder_modules(),\n+            ReorderableItemKind::Use => config.reorder_imports(),\n+            ReorderableItemKind::Other => false,\n+        }\n+    }\n+\n+    pub fn in_group(&self, config: &Config) -> bool {\n+        match *self {\n+            ReorderableItemKind::ExternCrate => config.reorder_extern_crates_in_group(),\n+            ReorderableItemKind::Mod => config.reorder_modules(),\n+            ReorderableItemKind::Use => config.reorder_imports_in_group(),\n+            ReorderableItemKind::Other => false,\n+        }\n+    }\n+}\n+\n+impl<'b, 'a: 'b> FmtVisitor<'a> {\n+    /// Format items with the same item kind and reorder them. If `in_group` is\n+    /// `true`, then the items separated by an empty line will not be reordered\n+    /// together.\n+    fn walk_reorderable_items(\n+        &mut self,\n+        items: &[&ast::Item],\n+        item_kind: ReorderableItemKind,\n+        in_group: bool,\n+    ) -> usize {\n+        let mut last = self.codemap.lookup_line_range(items[0].span());\n+        let item_length = items\n+            .iter()\n+            .take_while(|ppi| {\n+                item_kind.is_same_item_kind(&***ppi) && (!in_group || {\n+                    let current = self.codemap.lookup_line_range(ppi.span());\n+                    let in_same_group = current.lo < last.hi + 2;\n+                    last = current;\n+                    in_same_group\n+                })\n+            })\n+            .count();\n+        let items = &items[..item_length];\n+\n+        let at_least_one_in_file_lines = items\n+            .iter()\n+            .any(|item| !out_of_file_lines_range!(self, item.span));\n+\n+        if at_least_one_in_file_lines && !items.is_empty() {\n+            let lo = items.first().unwrap().span().lo();\n+            let hi = items.last().unwrap().span().hi();\n+            let span = mk_sp(lo, hi);\n+            let rw = rewrite_reorderable_items(&self.get_context(), items, self.shape(), span);\n+            self.push_rewrite(span, rw);\n+        } else {\n+            for item in items {\n+                self.push_rewrite(item.span, None);\n+            }\n+        }\n+\n+        item_length\n+    }\n+\n+    /// Visit and format the given items. Items are reordered If they are\n+    /// consecutive and reorderable.\n+    pub fn visit_items_with_reordering(&mut self, mut items: &[&ast::Item]) {\n+        while !items.is_empty() {\n+            // If the next item is a `use`, `extern crate` or `mod`, then extract it and any\n+            // subsequent items that have the same item kind to be reordered within\n+            // `walk_reorderable_items`. Otherwise, just format the next item for output.\n+            let item_kind = ReorderableItemKind::from(items[0]);\n+            if item_kind.is_reorderable(self.config) {\n+                let visited_items_num =\n+                    self.walk_reorderable_items(items, item_kind, item_kind.in_group(self.config));\n+                let (_, rest) = items.split_at(visited_items_num);\n+                items = rest;\n+            } else {\n+                // Reaching here means items were not reordered. There must be at least\n+                // one item left in `items`, so calling `unwrap()` here is safe.\n+                let (item, rest) = items.split_first().unwrap();\n+                self.visit_item(item);\n+                items = rest;\n+            }\n+        }\n+    }\n+}"}, {"sha": "d1b9859245f10f58010cef25f2a2c0fe62aad31b", "filename": "rustfmt-core/src/visitor.rs", "status": "modified", "additions": 3, "deletions": 91, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/25f2dffc1c9ccc39e7b5ed8f9d62413678046e81/rustfmt-core%2Fsrc%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt-core%2Fsrc%2Fvisitor.rs?ref=25f2dffc1c9ccc39e7b5ed8f9d62413678046e81", "patch": "@@ -12,7 +12,7 @@ use std::cmp;\n \n use config::lists::*;\n use syntax::{ast, visit};\n-use syntax::attr::{self, HasAttrs};\n+use syntax::attr::HasAttrs;\n use syntax::codemap::{self, BytePos, CodeMap, Pos, Span};\n use syntax::parse::ParseSess;\n \n@@ -49,39 +49,20 @@ fn is_mod_decl(item: &ast::Item) -> bool {\n     }\n }\n \n-fn contains_macro_use_attr(attrs: &[ast::Attribute], span: Span) -> bool {\n-    attr::contains_name(&filter_inline_attrs(attrs, span), \"macro_use\")\n-}\n-\n-/// Returns true for `mod foo;` without any inline attributes.\n-/// We cannot reorder modules with attributes because doing so can break the code.\n-/// e.g. `#[macro_use]`.\n-fn is_mod_decl_without_attr(item: &ast::Item) -> bool {\n-    is_mod_decl(item) && !contains_macro_use_attr(&item.attrs, item.span())\n-}\n-\n fn is_use_item(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::Use(_) => true,\n         _ => false,\n     }\n }\n \n-fn is_use_item_without_attr(item: &ast::Item) -> bool {\n-    is_use_item(item) && !contains_macro_use_attr(&item.attrs, item.span())\n-}\n-\n fn is_extern_crate(item: &ast::Item) -> bool {\n     match item.node {\n         ast::ItemKind::ExternCrate(..) => true,\n         _ => false,\n     }\n }\n \n-fn is_extern_crate_without_attr(item: &ast::Item) -> bool {\n-    is_extern_crate(item) && !contains_macro_use_attr(&item.attrs, item.span())\n-}\n-\n /// Creates a string slice corresponding to the specified span.\n pub struct SnippetProvider<'a> {\n     /// A pointer to the content of the file we are formatting.\n@@ -641,77 +622,8 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n         false\n     }\n \n-    fn reorder_items<F>(&mut self, items_left: &[&ast::Item], is_item: &F, in_group: bool) -> usize\n-    where\n-        F: Fn(&ast::Item) -> bool,\n-    {\n-        let mut last = self.codemap.lookup_line_range(items_left[0].span());\n-        let item_length = items_left\n-            .iter()\n-            .take_while(|ppi| {\n-                is_item(&***ppi) && (!in_group || {\n-                    let current = self.codemap.lookup_line_range(ppi.span());\n-                    let in_same_group = current.lo < last.hi + 2;\n-                    last = current;\n-                    in_same_group\n-                })\n-            })\n-            .count();\n-        let items = &items_left[..item_length];\n-\n-        let at_least_one_in_file_lines = items\n-            .iter()\n-            .any(|item| !out_of_file_lines_range!(self, item.span));\n-\n-        if at_least_one_in_file_lines {\n-            self.format_imports(items);\n-        } else {\n-            for item in items {\n-                self.push_rewrite(item.span, None);\n-            }\n-        }\n-\n-        item_length\n-    }\n-\n-    fn walk_items(&mut self, mut items_left: &[&ast::Item]) {\n-        macro try_reorder_items_with($reorder: ident, $in_group: ident, $pred: ident) {\n-            if self.config.$reorder() && $pred(&*items_left[0]) {\n-                let used_items_len =\n-                    self.reorder_items(items_left, &$pred, self.config.$in_group());\n-                let (_, rest) = items_left.split_at(used_items_len);\n-                items_left = rest;\n-                continue;\n-            }\n-        }\n-\n-        while !items_left.is_empty() {\n-            // If the next item is a `use`, `extern crate` or `mod`, then extract it and any\n-            // subsequent items that have the same item kind to be reordered within\n-            // `format_imports`. Otherwise, just format the next item for output.\n-            {\n-                try_reorder_items_with!(\n-                    reorder_imports,\n-                    reorder_imports_in_group,\n-                    is_use_item_without_attr\n-                );\n-                try_reorder_items_with!(\n-                    reorder_extern_crates,\n-                    reorder_extern_crates_in_group,\n-                    is_extern_crate_without_attr\n-                );\n-                try_reorder_items_with!(reorder_modules, reorder_modules, is_mod_decl_without_attr);\n-            }\n-            // Reaching here means items were not reordered. There must be at least\n-            // one item left in `items_left`, so calling `unwrap()` here is safe.\n-            let (item, rest) = items_left.split_first().unwrap();\n-            self.visit_item(item);\n-            items_left = rest;\n-        }\n-    }\n-\n     fn walk_mod_items(&mut self, m: &ast::Mod) {\n-        self.walk_items(&ptr_vec_to_ref_vec(&m.items));\n+        self.visit_items_with_reordering(&ptr_vec_to_ref_vec(&m.items));\n     }\n \n     fn walk_stmts(&mut self, stmts: &[ast::Stmt]) {\n@@ -737,7 +649,7 @@ impl<'b, 'a: 'b> FmtVisitor<'a> {\n             self.visit_stmt(&stmts[0]);\n             self.walk_stmts(&stmts[1..]);\n         } else {\n-            self.walk_items(&items);\n+            self.visit_items_with_reordering(&items);\n             self.walk_stmts(&stmts[items.len()..]);\n         }\n     }"}]}