{"sha": "cf11ef436bb8883dce57213c27a73bc39870aa9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNmMTFlZjQzNmJiODg4M2RjZTU3MjEzYzI3YTczYmMzOTg3MGFhOWI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-10-09T15:44:56Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-10-10T11:12:00Z"}, "message": "Fixed client code for diagnostics migration, adding new methods to `trait BorrowckErrors` as necessary.", "tree": {"sha": "3e1dcb2e3a460e22008d360d757d81d7eeb44d6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e1dcb2e3a460e22008d360d757d81d7eeb44d6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cf11ef436bb8883dce57213c27a73bc39870aa9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cf11ef436bb8883dce57213c27a73bc39870aa9b", "html_url": "https://github.com/rust-lang/rust/commit/cf11ef436bb8883dce57213c27a73bc39870aa9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cf11ef436bb8883dce57213c27a73bc39870aa9b/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52cb6fc9367f3aed373d8edda7c7fa52ed9f4c25", "url": "https://api.github.com/repos/rust-lang/rust/commits/52cb6fc9367f3aed373d8edda7c7fa52ed9f4c25", "html_url": "https://github.com/rust-lang/rust/commit/52cb6fc9367f3aed373d8edda7c7fa52ed9f4c25"}], "stats": {"total": 192, "additions": 138, "deletions": 54}, "files": [{"sha": "5b5d9f5a7cf5670b98ba6713b91df784d2cb740c", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 19, "deletions": 52, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/cf11ef436bb8883dce57213c27a73bc39870aa9b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf11ef436bb8883dce57213c27a73bc39870aa9b/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=cf11ef436bb8883dce57213c27a73bc39870aa9b", "patch": "@@ -614,11 +614,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 let partial = moved_lp.depth() > lp.depth();\n                 let msg = if !has_fork && partial { \"partially \" }\n                           else if has_fork && !has_common { \"collaterally \"}\n-                          else { \"\" };\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, use_span, E0382,\n-                    \"{} of {}moved value: `{}`\",\n-                    verb, msg, nl);\n+                else { \"\" };\n+                let mut err = self.cannot_act_on_moved_value(use_span,\n+                                                             verb,\n+                                                             msg,\n+                                                             &format!(\"{}\", nl));\n                 let need_note = match lp.ty.sty {\n                     ty::TypeVariants::TyClosure(id, _) => {\n                         let node_id = self.tcx.hir.as_local_node_id(id).unwrap();\n@@ -698,10 +698,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             &self,\n             span: Span,\n             lp: &LoanPath<'tcx>) {\n-        span_err!(\n-            self.tcx.sess, span, E0383,\n-            \"partial reinitialization of uninitialized structure `{}`\",\n-            self.loan_path_to_string(lp));\n+        self.cannot_partially_reinit_an_uninit_struct(span, &self.loan_path_to_string(lp))\n+            .emit();\n     }\n \n     pub fn report_reassigned_immutable_variable(&self,\n@@ -762,8 +760,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         self.cannot_assign(error_span, &descr, Origin::Ast)\n                     }\n                     BorrowViolation(euv::ClosureCapture(_)) => {\n-                        struct_span_err!(self.tcx.sess, error_span, E0595,\n-                                         \"closure cannot assign to {}\", descr)\n+                        self.closure_cannot_assign_to_borrowed(error_span, &descr)\n                     }\n                     BorrowViolation(euv::OverloadedOperator) |\n                     BorrowViolation(euv::AddrOf) |\n@@ -772,8 +769,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     BorrowViolation(euv::AutoUnsafe) |\n                     BorrowViolation(euv::ForLoop) |\n                     BorrowViolation(euv::MatchDiscriminant) => {\n-                        struct_span_err!(self.tcx.sess, error_span, E0596,\n-                                         \"cannot borrow {} as mutable\", descr)\n+                        self.cannot_borrow_path_as_mutable(error_span, &descr)\n                     }\n                     BorrowViolation(euv::ClosureInvocation) => {\n                         span_bug!(err.span,\n@@ -855,21 +851,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n \n                 if let Some((yield_span, _)) = maybe_borrow_across_yield {\n                     debug!(\"err_out_of_scope: opt_yield_span = {:?}\", yield_span);\n-                    struct_span_err!(self.tcx.sess,\n-                                     error_span,\n-                                     E0626,\n-                                     \"borrow may still be in use when generator yields\")\n-                        .span_label(yield_span, \"possible yield occurs here\")\n+                    self.cannot_borrow_across_generator_yield(error_span, yield_span)\n                         .emit();\n                     return;\n                 }\n \n-                let mut db = struct_span_err!(self.tcx.sess,\n-                                              error_span,\n-                                              E0597,\n-                                              \"{} does not live long enough\",\n-                                              msg);\n-\n+                let mut db = self.path_does_not_live_long_enough(error_span, &msg);\n                 let (value_kind, value_msg) = match err.cmt.cat {\n                     mc::Categorization::Rvalue(..) =>\n                         (\"temporary value\", \"temporary value created here\"),\n@@ -978,11 +965,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             }\n             err_borrowed_pointer_too_short(loan_scope, ptr_scope) => {\n                 let descr = self.cmt_to_path_or_string(&err.cmt);\n-                let mut db = struct_span_err!(self.tcx.sess, error_span, E0598,\n-                                              \"lifetime of {} is too short to guarantee \\\n-                                               its contents can be safely reborrowed\",\n-                                              descr);\n-\n+                let mut db = self.lifetime_too_short_for_reborrow(error_span, &descr);\n                 let descr = match opt_loan_path(&err.cmt) {\n                     Some(lp) => {\n                         format!(\"`{}`\", self.loan_path_to_string(&lp))\n@@ -1054,12 +1037,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n         let blame = cmt.immutability_blame();\n         let mut err = match blame {\n             Some(ImmutabilityBlame::ClosureEnv(id)) => {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0387,\n-                    \"{} in a captured outer variable in an `Fn` closure\", prefix);\n-\n                 // FIXME: the distinction between these 2 messages looks wrong.\n-                let help = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n+                let help_msg = if let BorrowViolation(euv::ClosureCapture(_)) = kind {\n                     // The aliasability violation with closure captures can\n                     // happen for nested closures, so we know the enclosing\n                     // closure incorrectly accepts an `Fn` while it needs to\n@@ -1070,15 +1049,11 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     \"consider changing this closure to take self by mutable reference\"\n                 };\n                 let node_id = self.tcx.hir.def_index_to_node_id(id);\n-                err.span_help(self.tcx.hir.span(node_id), help);\n-                err\n+                let help_span = self.tcx.hir.span(node_id);\n+                self.cannot_act_on_capture_in_sharable_fn(span, prefix, (help_span, help_msg))\n             }\n             _ =>  {\n-                let mut err = struct_span_err!(\n-                    self.tcx.sess, span, E0389,\n-                    \"{} in a `&` reference\", prefix);\n-                err.span_label(span, \"assignment into an immutable reference\");\n-                err\n+                self.cannot_assign_into_immutable_reference(span, prefix)\n             }\n         };\n         self.note_immutability_blame(&mut err, blame);\n@@ -1230,17 +1205,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 Err(_) => format!(\"move |<args>| <body>\")\n             };\n \n-        struct_span_err!(self.tcx.sess, err.span, E0373,\n-                         \"closure may outlive the current function, \\\n-                          but it borrows {}, \\\n-                          which is owned by the current function\",\n-                         cmt_path_or_string)\n-            .span_label(capture_span,\n-                       format!(\"{} is borrowed here\",\n-                                cmt_path_or_string))\n-            .span_label(err.span,\n-                       format!(\"may outlive borrowed value {}\",\n-                                cmt_path_or_string))\n+        self.cannot_capture_in_long_lived_closure(err.span,\n+                                                  &cmt_path_or_string,\n+                                                  capture_span)\n             .span_suggestion(err.span,\n                              &format!(\"to force the closure to take ownership of {} \\\n                                        (and any other referenced variables), \\"}, {"sha": "11120d2e46f2af6ed09d7a316bfeeec19610908c", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cf11ef436bb8883dce57213c27a73bc39870aa9b/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf11ef436bb8883dce57213c27a73bc39870aa9b/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=cf11ef436bb8883dce57213c27a73bc39870aa9b", "patch": "@@ -18,7 +18,7 @@\n #![feature(quote)]\n \n #[macro_use] extern crate log;\n-#[macro_use] extern crate syntax;\n+extern crate syntax;\n extern crate syntax_pos;\n extern crate rustc_errors as errors;\n "}, {"sha": "3514302c6c8f3e49ea18c1e6aa700450944b15e1", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cf11ef436bb8883dce57213c27a73bc39870aa9b/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf11ef436bb8883dce57213c27a73bc39870aa9b/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=cf11ef436bb8883dce57213c27a73bc39870aa9b", "patch": "@@ -1259,7 +1259,6 @@ pub fn diagnostics_registry() -> errors::registry::Registry {\n     let mut all_errors = Vec::new();\n     all_errors.extend_from_slice(&rustc::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_typeck::DIAGNOSTICS);\n-    all_errors.extend_from_slice(&rustc_borrowck::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_resolve::DIAGNOSTICS);\n     all_errors.extend_from_slice(&rustc_privacy::DIAGNOSTICS);\n     #[cfg(feature=\"llvm\")]"}, {"sha": "3c002b586faffd2fd3c42c9c04ae1f460d769786", "filename": "src/librustc_mir/util/borrowck_errors.rs", "status": "modified", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/cf11ef436bb8883dce57213c27a73bc39870aa9b/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cf11ef436bb8883dce57213c27a73bc39870aa9b/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fborrowck_errors.rs?ref=cf11ef436bb8883dce57213c27a73bc39870aa9b", "patch": "@@ -294,6 +294,124 @@ pub trait BorrowckErrors {\n         err.span_label(move_from_span, \"cannot move out of here\");\n         err\n     }\n+\n+    fn cannot_act_on_moved_value(&self,\n+                                 use_span: Span,\n+                                 verb: &str,\n+                                 optional_adverb_for_moved: &str,\n+                                 moved_path: &str)\n+                                 -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, use_span, E0382,\n+                                   \"{} of {}moved value: `{}`\",\n+                                   verb, optional_adverb_for_moved, moved_path);\n+        err\n+    }\n+\n+    fn cannot_partially_reinit_an_uninit_struct(&self,\n+                                                span: Span,\n+                                                uninit_path: &str)\n+                                                -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self,\n+                                   span,\n+                                   E0383,\n+                                   \"partial reinitialization of uninitialized structure `{}`\",\n+                                   uninit_path);\n+        err\n+    }\n+\n+    fn closure_cannot_assign_to_borrowed(&self,\n+                                         span: Span,\n+                                         descr: &str)\n+                                         -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0595, \"closure cannot assign to {}\", descr);\n+        err\n+    }\n+\n+    fn cannot_borrow_path_as_mutable(&self,\n+                                     span: Span,\n+                                     path: &str)\n+                                     -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0596, \"cannot borrow {} as mutable\", path);\n+        err\n+    }\n+\n+    fn cannot_borrow_across_generator_yield(&self,\n+                                            span: Span,\n+                                            yield_span: Span)\n+                                            -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self,\n+                                       span,\n+                                       E0626,\n+                                       \"borrow may still be in use when generator yields\");\n+        err.span_label(yield_span, \"possible yield occurs here\");\n+        err\n+    }\n+\n+    fn path_does_not_live_long_enough(&self,\n+                                      span: Span,\n+                                      path: &str)\n+                                      -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0597, \"{} does not live long enough\", path);\n+        err\n+    }\n+\n+    fn lifetime_too_short_for_reborrow(&self,\n+                                       span: Span,\n+                                       path: &str)\n+                                       -> DiagnosticBuilder\n+    {\n+        let err = struct_span_err!(self, span, E0598,\n+                                   \"lifetime of {} is too short to guarantee \\\n+                                    its contents can be safely reborrowed\",\n+                                   path);\n+        err\n+    }\n+\n+    fn cannot_act_on_capture_in_sharable_fn(&self,\n+                                            span: Span,\n+                                            bad_thing: &str,\n+                                            help: (Span, &str))\n+                                            -> DiagnosticBuilder\n+    {\n+        let (help_span, help_msg) = help;\n+        let mut err = struct_span_err!(self, span, E0387,\n+                                       \"{} in a captured outer variable in an `Fn` closure\",\n+                                       bad_thing);\n+        err.span_help(help_span, help_msg);\n+        err\n+    }\n+\n+    fn cannot_assign_into_immutable_reference(&self,\n+                                              span: Span,\n+                                              bad_thing: &str)\n+                                              -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, span, E0389, \"{} in a `&` reference\", bad_thing);\n+        err.span_label(span, \"assignment into an immutable reference\");\n+        err\n+    }\n+\n+    fn cannot_capture_in_long_lived_closure(&self,\n+                                            closure_span: Span,\n+                                            borrowed_path: &str,\n+                                            capture_span: Span)\n+                                            -> DiagnosticBuilder\n+    {\n+        let mut err = struct_span_err!(self, closure_span, E0373,\n+                                       \"closure may outlive the current function, \\\n+                                        but it borrows {}, \\\n+                                        which is owned by the current function\",\n+                                       borrowed_path);\n+        err.span_label(capture_span, format!(\"{} is borrowed here\", borrowed_path))\n+            .span_label(closure_span, format!(\"may outlive borrowed value {}\", borrowed_path));\n+        err\n+    }\n }\n \n impl<'b, 'tcx, 'gcx> BorrowckErrors for TyCtxt<'b, 'tcx, 'gcx> {"}]}