{"sha": "9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "node_id": "C_kwDOAAsO6NoAKDlmNWVlMTU1YzFhMzljMDI4Zjc5ZTI4MWQxZWRjYWFjYzU0YmVkYjE", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-02T17:09:30Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-03T14:52:03Z"}, "message": "Move path completions for patterns into pattern module", "tree": {"sha": "493d36a61e09c1d58abe84b7d20f811fc4885562", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/493d36a61e09c1d58abe84b7d20f811fc4885562"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "html_url": "https://github.com/rust-lang/rust/commit/9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "url": "https://api.github.com/repos/rust-lang/rust/commits/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1", "html_url": "https://github.com/rust-lang/rust/commit/33fd2d7aeffc13efc40a22a77116ae9a4de9dff1"}], "stats": {"total": 266, "additions": 215, "deletions": 51}, "files": [{"sha": "4704e842e6a36d360d632b00a3b8a6244f73ccda", "filename": "crates/ide_completion/src/completions/keyword.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fkeyword.rs?ref=9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "patch": "@@ -27,6 +27,9 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         cov_mark::hit!(no_keyword_completion_in_non_trivial_path);\n         return;\n     }\n+    if ctx.pattern_ctx.is_some() {\n+        return;\n+    }\n \n     let mut add_keyword = |kw, snippet| add_keyword(acc, ctx, kw, snippet);\n \n@@ -117,7 +120,7 @@ pub(crate) fn complete_expr_keyword(acc: &mut Completions, ctx: &CompletionConte\n         add_keyword(\"else if\", \"else if $1 {\\n    $0\\n}\");\n     }\n \n-    if ctx.expects_ident_pat_or_ref_expr() {\n+    if ctx.expects_ident_ref_expr() {\n         add_keyword(\"mut\", \"mut \");\n     }\n "}, {"sha": "438230c58f1c49d84ed855cd699ce9de83cd9577", "filename": "crates/ide_completion/src/completions/pattern.rs", "status": "modified", "additions": 139, "deletions": 6, "changes": 145, "blob_url": "https://github.com/rust-lang/rust/blob/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fpattern.rs?ref=9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "patch": "@@ -1,20 +1,52 @@\n //! Completes constants and paths in unqualified patterns.\n \n-use hir::db::DefDatabase;\n+use hir::{db::DefDatabase, AssocItem, ScopeDef};\n+use rustc_hash::FxHashSet;\n+use syntax::ast::Pat;\n \n use crate::{\n-    context::{PatternContext, PatternRefutability},\n+    context::{PathCompletionCtx, PathQualifierCtx, PatternRefutability},\n     CompletionContext, Completions,\n };\n \n /// Completes constants and paths in unqualified patterns.\n pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n-    let refutable = match ctx.pattern_ctx {\n-        Some(PatternContext { refutability, .. }) if ctx.path_context.is_none() => {\n-            refutability == PatternRefutability::Refutable\n-        }\n+    let patctx = match &ctx.pattern_ctx {\n+        Some(ctx) => ctx,\n         _ => return,\n     };\n+    let refutable = patctx.refutability == PatternRefutability::Refutable;\n+\n+    if let Some(path_ctx) = &ctx.path_context {\n+        pattern_path_completion(acc, ctx, path_ctx);\n+        return;\n+    }\n+\n+    match patctx.parent_pat.as_ref() {\n+        Some(Pat::RangePat(_) | Pat::BoxPat(_)) => (),\n+        Some(Pat::RefPat(r)) => {\n+            if r.mut_token().is_none() {\n+                acc.add_keyword(ctx, \"mut\");\n+            }\n+        }\n+        _ => {\n+            let tok = ctx.token.text_range().start();\n+            match (patctx.ref_token.as_ref(), patctx.mut_token.as_ref()) {\n+                (None, None) => {\n+                    acc.add_keyword(ctx, \"ref\");\n+                    acc.add_keyword(ctx, \"mut\");\n+                }\n+                (None, Some(m)) if tok < m.text_range().start() => {\n+                    acc.add_keyword(ctx, \"ref\");\n+                }\n+                (Some(r), None) if tok > r.text_range().end() => {\n+                    acc.add_keyword(ctx, \"mut\");\n+                }\n+                _ => (),\n+            }\n+        }\n+    }\n+\n     let single_variant_enum = |enum_: hir::Enum| ctx.db.enum_data(enum_.into()).variants.len() == 1;\n \n     if let Some(hir::Adt::Enum(e)) =\n@@ -63,3 +95,104 @@ pub(crate) fn complete_pattern(acc: &mut Completions, ctx: &CompletionContext) {\n         }\n     });\n }\n+\n+fn pattern_path_completion(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+    PathCompletionCtx { qualifier, is_absolute_path, .. }: &PathCompletionCtx,\n+) {\n+    match qualifier {\n+        Some(PathQualifierCtx { resolution, is_super_chain, .. }) => {\n+            if *is_super_chain {\n+                acc.add_keyword(ctx, \"super::\");\n+            }\n+\n+            let resolution = match resolution {\n+                Some(it) => it,\n+                None => return,\n+            };\n+\n+            match resolution {\n+                hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n+                    let module_scope = module.scope(ctx.db, ctx.module);\n+                    for (name, def) in module_scope {\n+                        let add_resolution = match def {\n+                            ScopeDef::MacroDef(m) if m.is_fn_like() => true,\n+                            ScopeDef::ModuleDef(_) => true,\n+                            _ => false,\n+                        };\n+\n+                        if add_resolution {\n+                            acc.add_resolution(ctx, name, def);\n+                        }\n+                    }\n+                }\n+                hir::PathResolution::Def(hir::ModuleDef::Adt(hir::Adt::Enum(e))) => {\n+                    cov_mark::hit!(enum_plain_qualified_use_tree);\n+                    e.variants(ctx.db)\n+                        .into_iter()\n+                        .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                }\n+                res @ (hir::PathResolution::TypeParam(_) | hir::PathResolution::SelfType(_)) => {\n+                    if let Some(krate) = ctx.krate {\n+                        let ty = match res {\n+                            hir::PathResolution::TypeParam(param) => param.ty(ctx.db),\n+                            hir::PathResolution::SelfType(impl_def) => impl_def.self_ty(ctx.db),\n+                            _ => return,\n+                        };\n+\n+                        // Note associated consts cannot be referenced in patterns\n+                        if let Some(hir::Adt::Enum(e)) = ty.as_adt() {\n+                            e.variants(ctx.db)\n+                                .into_iter()\n+                                .for_each(|variant| acc.add_enum_variant(ctx, variant, None));\n+                        }\n+\n+                        let traits_in_scope = ctx.scope.visible_traits();\n+                        let mut seen = FxHashSet::default();\n+                        ty.iterate_path_candidates(\n+                            ctx.db,\n+                            krate,\n+                            &traits_in_scope,\n+                            ctx.module,\n+                            None,\n+                            |_ty, item| {\n+                                // We might iterate candidates of a trait multiple times here, so deduplicate\n+                                // them.\n+                                if let AssocItem::TypeAlias(ta) = item {\n+                                    if seen.insert(item) {\n+                                        acc.add_type_alias(ctx, ta);\n+                                    }\n+                                }\n+                                None::<()>\n+                            },\n+                        );\n+                    }\n+                }\n+                _ => {}\n+            }\n+        }\n+        // qualifier can only be none here if we are in a TuplePat or RecordPat in which case special characters have to follow the path\n+        // so executing the rest of this completion doesn't make sense\n+        // fresh use tree with leading colon2, only show crate roots\n+        None if *is_absolute_path => {\n+            cov_mark::hit!(use_tree_crate_roots_only);\n+            ctx.process_all_names(&mut |name, res| match res {\n+                ScopeDef::ModuleDef(hir::ModuleDef::Module(m)) if m.is_crate_root(ctx.db) => {\n+                    acc.add_resolution(ctx, name, res);\n+                }\n+                _ => (),\n+            });\n+        }\n+        // only show modules in a fresh UseTree\n+        None => {\n+            cov_mark::hit!(unqualified_path_only_modules_in_import);\n+            ctx.process_all_names(&mut |name, res| {\n+                if let ScopeDef::ModuleDef(hir::ModuleDef::Module(_)) = res {\n+                    acc.add_resolution(ctx, name, res);\n+                }\n+            });\n+            [\"self::\", \"super::\", \"crate::\"].into_iter().for_each(|kw| acc.add_keyword(ctx, kw));\n+        }\n+    }\n+}"}, {"sha": "cf78f7c1adf47d4b8027914d86f5277846242a3b", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "patch": "@@ -15,6 +15,9 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     if ctx.is_path_disallowed() || ctx.has_impl_or_trait_prev_sibling() {\n         return;\n     }\n+    if ctx.pattern_ctx.is_some() {\n+        return;\n+    }\n     let (qualifier, kind) = match ctx.path_context {\n         // let ... else, syntax would come in really handy here right now\n         Some(PathCompletionCtx { qualifier: Some(ref qualifier), kind, .. }) => (qualifier, kind),\n@@ -60,10 +63,9 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     }\n \n     match kind {\n-        Some(PathKind::Attr { .. } | PathKind::Vis { .. } | PathKind::Use) => {\n+        Some(PathKind::Pat | PathKind::Attr { .. } | PathKind::Vis { .. } | PathKind::Use) => {\n             return;\n         }\n-        Some(PathKind::Pat) => (),\n         _ => {\n             // Add associated types on type parameters and `Self`.\n             ctx.scope.assoc_type_shorthand_candidates(&resolution, |_, alias| {"}, {"sha": "cca2785e2dd43c056141eff1680c5f17503c3c3a", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "patch": "@@ -17,7 +17,13 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n     }\n     match ctx.path_context {\n         Some(PathCompletionCtx {\n-            kind: Some(PathKind::Vis { .. } | PathKind::Attr { .. } | PathKind::Use { .. }),\n+            kind:\n+                Some(\n+                    PathKind::Vis { .. }\n+                    | PathKind::Attr { .. }\n+                    | PathKind::Use { .. }\n+                    | PathKind::Pat,\n+                ),\n             ..\n         }) => return,\n         Some(PathCompletionCtx { is_absolute_path: false, qualifier: None, .. }) => (),"}, {"sha": "910652cba8994a1a07f0b082d148e0838a010c95", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "patch": "@@ -85,6 +85,9 @@ pub(super) struct PatternContext {\n     pub(super) refutability: PatternRefutability,\n     pub(super) param_ctx: Option<(ast::ParamList, ast::Param, ParamKind)>,\n     pub(super) has_type_ascription: bool,\n+    pub(super) parent_pat: Option<ast::Pat>,\n+    pub(super) ref_token: Option<SyntaxToken>,\n+    pub(super) mut_token: Option<SyntaxToken>,\n }\n \n #[derive(Debug)]\n@@ -219,11 +222,8 @@ impl<'a> CompletionContext<'a> {\n         matches!(self.completion_location, Some(ImmediateLocation::StmtList))\n     }\n \n-    pub(crate) fn expects_ident_pat_or_ref_expr(&self) -> bool {\n-        matches!(\n-            self.completion_location,\n-            Some(ImmediateLocation::IdentPat | ImmediateLocation::RefExpr)\n-        )\n+    pub(crate) fn expects_ident_ref_expr(&self) -> bool {\n+        matches!(self.completion_location, Some(ImmediateLocation::RefExpr))\n     }\n \n     pub(crate) fn expect_field(&self) -> bool {\n@@ -789,9 +789,6 @@ impl<'a> CompletionContext<'a> {\n         if is_name_in_field_pat {\n             return None;\n         }\n-        if !bind_pat.is_simple_ident() {\n-            return None;\n-        }\n         Some(pattern_context_for(original_file, bind_pat.into()))\n     }\n \n@@ -949,7 +946,18 @@ fn pattern_context_for(original_file: &SyntaxNode, pat: ast::Pat) -> PatternCont\n             };\n             (refutability, false)\n         });\n-    PatternContext { refutability, param_ctx: is_param, has_type_ascription }\n+    let (ref_token, mut_token) = match &pat {\n+        ast::Pat::IdentPat(it) => (it.ref_token(), it.mut_token()),\n+        _ => (None, None),\n+    };\n+    PatternContext {\n+        refutability,\n+        param_ctx: is_param,\n+        has_type_ascription,\n+        parent_pat: pat.syntax().parent().and_then(ast::Pat::cast),\n+        mut_token,\n+        ref_token,\n+    }\n }\n \n fn find_node_in_file<N: AstNode>(syntax: &SyntaxNode, node: &N) -> Option<N> {"}, {"sha": "779ec0c3a7661ea44b1e4ce1548cdfb7dd3de84e", "filename": "crates/ide_completion/src/tests/fn_param.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Ffn_param.rs?ref=9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "patch": "@@ -17,6 +17,7 @@ fn baz(file$0) {}\n \"#,\n         expect![[r#\"\n             bn file_id: usize\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -32,6 +33,7 @@ fn baz(foo: (), file$0) {}\n \"#,\n         expect![[r#\"\n             bn file_id: usize\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -47,6 +49,7 @@ fn baz(file$0 id: u32) {}\n \"#,\n         expect![[r#\"\n             bn file_id: usize,\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -60,6 +63,7 @@ fn foo(file_id: usize) {}\n fn bar(file_id: u32, $0) {}\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -76,6 +80,7 @@ pub(crate) trait SourceRoot {\n \"#,\n         expect![[r#\"\n             bn file_id: usize\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -91,6 +96,7 @@ fn outer(text: &str) {\n \"#,\n         expect![[r#\"\n             bn text: &str\n+            kw ref\n             kw mut\n         \"#]],\n     )\n@@ -106,6 +112,7 @@ fn foo2($0) {}\n \"#,\n         expect![[r#\"\n             bn Bar { bar }: Bar\n+            kw ref\n             kw mut\n             bn Bar              Bar { bar$1 }: Bar$0\n             st Bar\n@@ -130,6 +137,7 @@ impl A {\n             bn mut self\n             bn &mut self\n             bn file_id: usize\n+            kw ref\n             kw mut\n             sp Self\n             st A\n@@ -150,6 +158,7 @@ impl A {\n \"#,\n         expect![[r#\"\n             bn file_id: usize\n+            kw ref\n             kw mut\n             sp Self\n             st A\n@@ -178,6 +187,7 @@ fn outer() {\n             bn foo: i32\n             bn baz: i32\n             bn bar: i32\n+            kw ref\n             kw mut\n         \"#]],\n     )\n@@ -202,6 +212,22 @@ fn outer() {\n             bn baz: i32\n             bn bar: i32\n             bn foo: i32\n+            kw ref\n+            kw mut\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn completes_fully_equal() {\n+    check(\n+        r#\"\n+fn foo(bar: u32) {}\n+fn bar(bar$0) {}\n+\"#,\n+        expect![[r#\"\n+            bn bar: u32\n+            kw ref\n             kw mut\n         \"#]],\n     )"}, {"sha": "fe532576729dfdec594b155b88ace75fef293197", "filename": "crates/ide_completion/src/tests/pattern.rs", "status": "modified", "additions": 18, "deletions": 32, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5ee155c1a39c028f79e281d1edcaacc54bedb1/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fpattern.rs?ref=9f5ee155c1a39c028f79e281d1edcaacc54bedb1", "patch": "@@ -22,6 +22,7 @@ fn quux() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n         \"#]],\n     );\n@@ -53,26 +54,21 @@ fn quux() {\n \n #[test]\n fn ident_ref_mut_pat() {\n-    // FIXME mut is already here, don't complete it again\n     check_empty(\n         r#\"\n fn quux() {\n     let ref mut en$0\n }\n \"#,\n-        expect![[r#\"\n-            kw mut\n-        \"#]],\n+        expect![[r#\"\"#]],\n     );\n     check_empty(\n         r#\"\n fn quux() {\n     let ref mut en$0 @ x\n }\n \"#,\n-        expect![[r#\"\n-            kw mut\n-        \"#]],\n+        expect![[r#\"\"#]],\n     );\n }\n \n@@ -88,16 +84,13 @@ fn quux() {\n             kw mut\n         \"#]],\n     );\n-    // FIXME mut is already here, don't complete it again\n     check_empty(\n         r#\"\n fn quux() {\n     let &mut en$0\n }\n \"#,\n-        expect![[r#\"\n-            kw mut\n-        \"#]],\n+        expect![[r#\"\"#]],\n     );\n }\n \n@@ -110,6 +103,7 @@ fn foo() {\n }\n \"#,\n         expect![[r##\"\n+            kw ref\n             kw mut\n             en Enum\n             bn Record    Record { field$1 }$0\n@@ -139,6 +133,7 @@ fn foo() {\n }\n \"#,\n         expect![[r##\"\n+            kw ref\n             kw mut\n             bn Record            Record { field$1 }$0\n             st Record\n@@ -160,6 +155,7 @@ fn foo(a$0) {\n }\n \"#,\n         expect![[r##\"\n+            kw ref\n             kw mut\n             bn Record    Record { field$1 }: Record$0\n             st Record\n@@ -175,6 +171,7 @@ fn foo(a$0: Tuple) {\n }\n \"#,\n         expect![[r##\"\n+            kw ref\n             kw mut\n             bn Record    Record { field$1 }$0\n             st Record\n@@ -200,6 +197,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             ma m!(\u2026) macro_rules! m\n         \"#]],\n@@ -218,6 +216,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             ev E::X  ()\n             en E\n@@ -242,6 +241,7 @@ fn outer() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Record    Record { field$1, .. }$0\n             st Record\n@@ -267,6 +267,7 @@ impl Foo {\n }\n     \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Self Self($1)$0\n             sp Self\n@@ -278,7 +279,6 @@ impl Foo {\n \n #[test]\n fn enum_qualified() {\n-    // FIXME: Don't show functions, they aren't patterns\n     check(\n         r#\"\n impl Enum {\n@@ -291,12 +291,9 @@ fn func() {\n }\n \"#,\n         expect![[r#\"\n-            ev TupleV(\u2026)   (u32)\n-            ev RecordV     {field: u32}\n-            ev UnitV       ()\n-            ct ASSOC_CONST const ASSOC_CONST: ()\n-            fn assoc_fn()  fn()\n-            ta AssocType   type AssocType = ()\n+            ev TupleV(\u2026) (u32)\n+            ev RecordV   {field: u32}\n+            ev UnitV     ()\n         \"#]],\n     );\n }\n@@ -310,6 +307,7 @@ struct Bar(u32);\n fn outer(Foo { bar: $0 }: Foo) {}\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Foo Foo { bar$1 }$0\n             st Foo\n@@ -340,6 +338,7 @@ struct Bar(u32);\n fn foo($0) {}\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Foo Foo { bar$1 }: Foo$0\n             st Foo\n@@ -360,6 +359,7 @@ fn foo() {\n }\n \"#,\n         expect![[r#\"\n+            kw ref\n             kw mut\n             bn Foo Foo { bar$1 }$0\n             st Foo\n@@ -368,17 +368,3 @@ fn foo() {\n         \"#]],\n     )\n }\n-\n-#[test]\n-fn completes_fully_equal() {\n-    check_empty(\n-        r#\"\n-fn foo(bar: u32) {}\n-fn bar(bar$0) {}\n-\"#,\n-        expect![[r#\"\n-            bn bar: u32\n-            kw mut\n-        \"#]],\n-    )\n-}"}]}