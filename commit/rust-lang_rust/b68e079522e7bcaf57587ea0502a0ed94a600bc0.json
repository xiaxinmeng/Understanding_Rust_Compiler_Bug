{"sha": "b68e079522e7bcaf57587ea0502a0ed94a600bc0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2OGUwNzk1MjJlN2JjYWY1NzU4N2VhMDUwMmEwZWQ5NGE2MDBiYzA=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-06-23T13:05:39Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-06-23T13:05:39Z"}, "message": "Actually consolidate the CodeMap tests", "tree": {"sha": "bdf42405ec2b3b63c140e1977e3375de30b96308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bdf42405ec2b3b63c140e1977e3375de30b96308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b68e079522e7bcaf57587ea0502a0ed94a600bc0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b68e079522e7bcaf57587ea0502a0ed94a600bc0", "html_url": "https://github.com/rust-lang/rust/commit/b68e079522e7bcaf57587ea0502a0ed94a600bc0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b68e079522e7bcaf57587ea0502a0ed94a600bc0/comments", "author": null, "committer": null, "parents": [{"sha": "bad4869d28594da7daa1e9a3b7dffc958e1ecb2d", "url": "https://api.github.com/repos/rust-lang/rust/commits/bad4869d28594da7daa1e9a3b7dffc958e1ecb2d", "html_url": "https://github.com/rust-lang/rust/commit/bad4869d28594da7daa1e9a3b7dffc958e1ecb2d"}], "stats": {"total": 1034, "additions": 517, "deletions": 517}, "files": [{"sha": "da9ba0a464d92d7d1b0e2182e58de55bef71d096", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 517, "deletions": 0, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/b68e079522e7bcaf57587ea0502a0ed94a600bc0/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68e079522e7bcaf57587ea0502a0ed94a600bc0/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=b68e079522e7bcaf57587ea0502a0ed94a600bc0", "patch": "@@ -1385,4 +1385,521 @@ r\"blork2.rs:2:1: 2:12\n             diag.highlight_lines(&msp, Level::Error).unwrap();\n         });\n     }\n+\n+    #[test]\n+    fn tab() {\n+        let file_text = \"\n+fn foo() {\n+\\tbar;\n+}\n+\";\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n+\n+        let mut snippet = SnippetData::new(cm, Some(span_bar));\n+        snippet.push(span_bar, true, None);\n+\n+        let lines = snippet.render_lines();\n+        let text = make_string(&lines);\n+        assert_eq!(&text[..], &\"\n+ --> foo.rs:3:2\n+  |>\n+3 |> \\tbar;\n+  |> \\t^^^\n+\"[1..]);\n+    }\n+\n+    #[test]\n+    fn one_line() {\n+        let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+        let mut snippet = SnippetData::new(cm, None);\n+        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=\\n{}\", text);\n+        assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn two_files() {\n+        let file_text_foo = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let file_text_bar = r#\"\n+fn bar() {\n+    // these blank links here\n+    // serve to ensure that the line numbers\n+    // from bar.rs\n+    // require more digits\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+\n+    vec.push();\n+\n+    // this line will get elided\n+\n+    vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n+        let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n+        let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n+        let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n+\n+        let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n+        let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n+        let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n+        let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n+\n+        let mut snippet = SnippetData::new(cm, Some(span_foo_vec1));\n+        snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n+        snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n+        snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n+        snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n+        snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n+        snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=\\n{}\", text);\n+\n+        // Note that the `|>` remain aligned across both files:\n+        assert_eq!(&text[..], &r#\"\n+   --> foo.rs:3:14\n+    |>\n+3   |>     vec.push(vec.pop().unwrap());\n+    |>     ---      ^^^                - c\n+    |>     |        |\n+    |>     |        b\n+    |>     a\n+   ::: bar.rs\n+    |>\n+17  |>     vec.push();\n+    |>     ---       - f\n+    |>     |\n+    |>     d\n+...\n+21  |>     vec.pop().unwrap());\n+    |>     --- e\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn multi_line() {\n+        let file_text = r#\"\n+fn foo() {\n+    let name = find_id(&data, 22).unwrap();\n+\n+    // Add one more item we forgot to the vector. Silly us.\n+    data.push(Data { name: format!(\"Hera\"), id: 66 });\n+\n+    // Print everything out.\n+    println!(\"Name: {:?}\", name);\n+    println!(\"Data: {:?}\", data);\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n+        let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n+        let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n+\n+        let mut snippet = SnippetData::new(cm, None);\n+        snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n+        snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n+        snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=\\n{}\", text);\n+        assert_eq!(&text[..], &r#\"\n+   ::: foo.rs\n+    |>\n+3   |>     let name = find_id(&data, 22).unwrap();\n+    |>                         ---- immutable borrow begins here\n+...\n+6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n+    |>     ---- mutable borrow occurs here\n+...\n+11  |> }\n+    |> - immutable borrow ends here\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn overlapping() {\n+        let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n+        let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+        let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n+        let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n+\n+        let mut snippet = SnippetData::new(cm, None);\n+        snippet.push(span0, false, Some(format!(\"A\")));\n+        snippet.push(span1, false, Some(format!(\"B\")));\n+        snippet.push(span2, false, Some(format!(\"C\")));\n+        snippet.push(span3, false, Some(format!(\"D\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+        assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     --------           ------ D\n+  |>     ||\n+  |>     |C\n+  |>     A\n+  |>     B\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn one_line_out_of_order() {\n+        let file_text = r#\"\n+fn foo() {\n+    vec.push(vec.pop().unwrap());\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n+        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n+        let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n+\n+        // intentionally don't push the snippets left to right\n+        let mut snippet = SnippetData::new(cm, None);\n+        snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n+        snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n+        snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+        let text: String = make_string(&lines);\n+\n+        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+        assert_eq!(&text[..], &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     vec.push(vec.pop().unwrap());\n+  |>     ---      ---                - previous borrow ends here\n+  |>     |        |\n+  |>     |        error occurs here\n+  |>     previous borrow of `vec` occurs here\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn elide_unnecessary_lines() {\n+        let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+        let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n+        let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n+\n+        let mut snippet = SnippetData::new(cm, None);\n+        snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n+            has type `collections::vec::Vec<i32>`\")));\n+        snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n+\n+        let lines = snippet.render_lines();\n+        println!(\"{:#?}\", lines);\n+        let text: String = make_string(&lines);\n+        println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n+        assert_eq!(&text[..], &r#\"\n+   ::: foo.rs\n+    |>\n+4   |>     let mut vec2 = vec;\n+    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n+...\n+9   |>     vec.push(7);\n+    |>     --- use of moved value: `vec`\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn spans_without_labels() {\n+        let file_text = r#\"\n+fn foo() {\n+    let mut vec = vec![0, 1, 2];\n+    let mut vec2 = vec;\n+    vec2.push(3);\n+    vec2.push(4);\n+    vec2.push(5);\n+    vec2.push(6);\n+    vec.push(7);\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None);\n+        for i in 0..4 {\n+            let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n+            snippet.push(span_veci, false, None);\n+        }\n+\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     let mut vec = vec![0, 1, 2];\n+  |>             ---   ---\n+4 |>     let mut vec2 = vec;\n+  |>             ---    ---\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_long_selection() {\n+        let file_text = r#\"\n+impl SomeTrait for () {\n+    fn foo(x: u32) {\n+        // impl 1\n+        // impl 2\n+        // impl 3\n+    }\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None);\n+        let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n+        let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+        snippet.push(splice(fn_span, rbrace_span), false, None);\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>     fn foo(x: u32) {\n+  |>     -\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_overlap_label() {\n+        // Test that we don't put `x_span` to the right of its highlight,\n+        // since there is another highlight that overlaps it.\n+\n+        let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None);\n+        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n+        let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n+        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+        snippet.push(x_span, false, Some(format!(\"x_span\")));\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_overlap_label2() {\n+        // Test that we don't put `x_span` to the right of its highlight,\n+        // since there is another highlight that overlaps it. In this\n+        // case, the overlap is only at the beginning, but it's still\n+        // better to show the beginning more clearly.\n+\n+        let file_text = r#\"\n+    fn foo(x: u32) {\n+    }\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None);\n+        let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n+        let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n+        snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n+        snippet.push(x_span, false, Some(format!(\"x_span\")));\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+2 |>     fn foo(x: u32) {\n+  |>     --------------\n+  |>     |      |\n+  |>     |      x_span\n+  |>     fn_span\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_overlap_label3() {\n+        // Test that we don't put `x_span` to the right of its highlight,\n+        // since there is another highlight that overlaps it. In this\n+        // case, the overlap is only at the beginning, but it's still\n+        // better to show the beginning more clearly.\n+\n+        let file_text = r#\"\n+    fn foo() {\n+       let closure = || {\n+           inner\n+       };\n+    }\n+}\n+\"#;\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut snippet = SnippetData::new(cm.clone(), None);\n+\n+        let closure_span = {\n+            let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n+            let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n+            splice(closure_start_span, closure_end_span)\n+        };\n+\n+        let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n+\n+        snippet.push(closure_span, false, Some(format!(\"foo\")));\n+        snippet.push(inner_span, false, Some(format!(\"bar\")));\n+\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+ ::: foo.rs\n+  |>\n+3 |>        let closure = || {\n+  |>                      - foo\n+4 |>            inner\n+  |>            ----- bar\n+\"#[1..]);\n+    }\n+\n+    #[test]\n+    fn span_empty() {\n+        // In one of the unit tests, we found that the parser sometimes\n+        // gives empty spans, and in particular it supplied an EOF span\n+        // like this one, which points at the very end. We want to\n+        // fallback gracefully in this case.\n+\n+        let file_text = r#\"\n+fn main() {\n+    struct Foo;\n+\n+    impl !Sync for Foo {}\n+\n+    unsafe impl Send for &'static Foo {\n+    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n+    //        can only be implemented for a struct/enum type, not\n+    //        `&'static Foo`\n+}\"#;\n+\n+\n+        let cm = Rc::new(CodeMap::new());\n+        let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n+\n+        let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n+        rbrace_span.lo = rbrace_span.hi;\n+\n+        let mut snippet = SnippetData::new(cm.clone(), Some(rbrace_span));\n+        snippet.push(rbrace_span, false, None);\n+        let lines = snippet.render_lines();\n+        let text: String = make_string(&lines);\n+        println!(\"r#\\\"\\n{}\\\"\", text);\n+        assert_eq!(text, &r#\"\n+  --> foo.rs:11:2\n+   |>\n+11 |> }\n+   |>  -\n+\"#[1..]);\n+    }\n }"}, {"sha": "a88280339637c9ef8e3085fd7ee509d7db1b795c", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 0, "deletions": 517, "changes": 517, "blob_url": "https://github.com/rust-lang/rust/blob/b68e079522e7bcaf57587ea0502a0ed94a600bc0/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68e079522e7bcaf57587ea0502a0ed94a600bc0/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=b68e079522e7bcaf57587ea0502a0ed94a600bc0", "patch": "@@ -755,520 +755,3 @@ fn make_string(lines: &[RenderedLine]) -> String {\n          })\n          .collect()\n }\n-\n-#[test]\n-fn tab() {\n-    let file_text = \"\n-fn foo() {\n-\\tbar;\n-}\n-\";\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_bar = cm.span_substr(&foo, file_text, \"bar\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, Some(span_bar));\n-    snippet.push(span_bar, true, None);\n-\n-    let lines = snippet.render_lines();\n-    let text = make_string(&lines);\n-    assert_eq!(&text[..], &\"\n- --> foo.rs:3:2\n-  |>\n-3 |> \\tbar;\n-  |> \\t^^^\n-\"[1..]);\n-}\n-\n-#[test]\n-fn one_line() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn two_files() {\n-    let file_text_foo = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let file_text_bar = r#\"\n-fn bar() {\n-    // these blank links here\n-    // serve to ensure that the line numbers\n-    // from bar.rs\n-    // require more digits\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-    vec.push();\n-\n-    // this line will get elided\n-\n-    vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo_map = cm.new_filemap_and_lines(\"foo.rs\", None, file_text_foo);\n-    let span_foo_vec0 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 0);\n-    let span_foo_vec1 = cm.span_substr(&foo_map, file_text_foo, \"vec\", 1);\n-    let span_foo_semi = cm.span_substr(&foo_map, file_text_foo, \";\", 0);\n-\n-    let bar_map = cm.new_filemap_and_lines(\"bar.rs\", None, file_text_bar);\n-    let span_bar_vec0 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 0);\n-    let span_bar_vec1 = cm.span_substr(&bar_map, file_text_bar, \"vec\", 1);\n-    let span_bar_semi = cm.span_substr(&bar_map, file_text_bar, \";\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, Some(span_foo_vec1));\n-    snippet.push(span_foo_vec0, false, Some(format!(\"a\")));\n-    snippet.push(span_foo_vec1, true, Some(format!(\"b\")));\n-    snippet.push(span_foo_semi, false, Some(format!(\"c\")));\n-    snippet.push(span_bar_vec0, false, Some(format!(\"d\")));\n-    snippet.push(span_bar_vec1, false, Some(format!(\"e\")));\n-    snippet.push(span_bar_semi, false, Some(format!(\"f\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-\n-    // Note that the `|>` remain aligned across both files:\n-    assert_eq!(&text[..], &r#\"\n-   --> foo.rs:3:14\n-    |>\n-3   |>     vec.push(vec.pop().unwrap());\n-    |>     ---      ^^^                - c\n-    |>     |        |\n-    |>     |        b\n-    |>     a\n-   ::: bar.rs\n-    |>\n-17  |>     vec.push();\n-    |>     ---       - f\n-    |>     |\n-    |>     d\n-...\n-21  |>     vec.pop().unwrap());\n-    |>     --- e\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn multi_line() {\n-    let file_text = r#\"\n-fn foo() {\n-    let name = find_id(&data, 22).unwrap();\n-\n-    // Add one more item we forgot to the vector. Silly us.\n-    data.push(Data { name: format!(\"Hera\"), id: 66 });\n-\n-    // Print everything out.\n-    println!(\"Name: {:?}\", name);\n-    println!(\"Data: {:?}\", data);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_data0 = cm.span_substr(&foo, file_text, \"data\", 0);\n-    let span_data1 = cm.span_substr(&foo, file_text, \"data\", 1);\n-    let span_rbrace = cm.span_substr(&foo, file_text, \"}\", 3);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_data0, false, Some(format!(\"immutable borrow begins here\")));\n-    snippet.push(span_data1, false, Some(format!(\"mutable borrow occurs here\")));\n-    snippet.push(span_rbrace, false, Some(format!(\"immutable borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=\\n{}\", text);\n-    assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-3   |>     let name = find_id(&data, 22).unwrap();\n-    |>                         ---- immutable borrow begins here\n-...\n-6   |>     data.push(Data { name: format!(\"Hera\"), id: 66 });\n-    |>     ---- mutable borrow occurs here\n-...\n-11  |> }\n-    |> - immutable borrow ends here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn overlapping() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span0 = cm.span_substr(&foo, file_text, \"vec.push\", 0);\n-    let span1 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span2 = cm.span_substr(&foo, file_text, \"ec.push\", 0);\n-    let span3 = cm.span_substr(&foo, file_text, \"unwrap\", 0);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span0, false, Some(format!(\"A\")));\n-    snippet.push(span1, false, Some(format!(\"B\")));\n-    snippet.push(span2, false, Some(format!(\"C\")));\n-    snippet.push(span3, false, Some(format!(\"D\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     --------           ------ D\n-  |>     ||\n-  |>     |C\n-  |>     A\n-  |>     B\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn one_line_out_of_order() {\n-    let file_text = r#\"\n-fn foo() {\n-    vec.push(vec.pop().unwrap());\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 0);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 1);\n-    let span_semi = cm.span_substr(&foo, file_text, \";\", 0);\n-\n-    // intentionally don't push the snippets left to right\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec1, false, Some(format!(\"error occurs here\")));\n-    snippet.push(span_vec0, false, Some(format!(\"previous borrow of `vec` occurs here\")));\n-    snippet.push(span_semi, false, Some(format!(\"previous borrow ends here\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     vec.push(vec.pop().unwrap());\n-  |>     ---      ---                - previous borrow ends here\n-  |>     |        |\n-  |>     |        error occurs here\n-  |>     previous borrow of `vec` occurs here\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn elide_unnecessary_lines() {\n-    let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-    let span_vec0 = cm.span_substr(&foo, file_text, \"vec\", 3);\n-    let span_vec1 = cm.span_substr(&foo, file_text, \"vec\", 8);\n-\n-    let mut snippet = SnippetData::new(cm, None);\n-    snippet.push(span_vec0, false, Some(format!(\"`vec` moved here because it \\\n-        has type `collections::vec::Vec<i32>`\")));\n-    snippet.push(span_vec1, false, Some(format!(\"use of moved value: `vec`\")));\n-\n-    let lines = snippet.render_lines();\n-    println!(\"{:#?}\", lines);\n-    let text: String = make_string(&lines);\n-    println!(\"text=r#\\\"\\n{}\\\".trim_left()\", text);\n-    assert_eq!(&text[..], &r#\"\n-   ::: foo.rs\n-    |>\n-4   |>     let mut vec2 = vec;\n-    |>                    --- `vec` moved here because it has type `collections::vec::Vec<i32>`\n-...\n-9   |>     vec.push(7);\n-    |>     --- use of moved value: `vec`\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn spans_without_labels() {\n-    let file_text = r#\"\n-fn foo() {\n-    let mut vec = vec![0, 1, 2];\n-    let mut vec2 = vec;\n-    vec2.push(3);\n-    vec2.push(4);\n-    vec2.push(5);\n-    vec2.push(6);\n-    vec.push(7);\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    for i in 0..4 {\n-        let span_veci = cm.span_substr(&foo, file_text, \"vec\", i);\n-        snippet.push(span_veci, false, None);\n-    }\n-\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"text=&r#\\\"\\n{}\\n\\\"#[1..]\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     let mut vec = vec![0, 1, 2];\n-  |>             ---   ---\n-4 |>     let mut vec2 = vec;\n-  |>             ---    ---\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_long_selection() {\n-    let file_text = r#\"\n-impl SomeTrait for () {\n-    fn foo(x: u32) {\n-        // impl 1\n-        // impl 2\n-        // impl 3\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn\", 0);\n-    let rbrace_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-    snippet.push(splice(fn_span, rbrace_span), false, None);\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>     fn foo(x: u32) {\n-  |>     -\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it.\n-\n-    let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x: u32)\", 0);\n-    let x_span = cm.span_substr(&foo, file_text, \"x\", 0);\n-    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-    snippet.push(x_span, false, Some(format!(\"x_span\")));\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label2() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it. In this\n-    // case, the overlap is only at the beginning, but it's still\n-    // better to show the beginning more clearly.\n-\n-    let file_text = r#\"\n-    fn foo(x: u32) {\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-    let fn_span = cm.span_substr(&foo, file_text, \"fn foo(x\", 0);\n-    let x_span = cm.span_substr(&foo, file_text, \"x: u32)\", 0);\n-    snippet.push(fn_span, false, Some(format!(\"fn_span\")));\n-    snippet.push(x_span, false, Some(format!(\"x_span\")));\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-2 |>     fn foo(x: u32) {\n-  |>     --------------\n-  |>     |      |\n-  |>     |      x_span\n-  |>     fn_span\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_overlap_label3() {\n-    // Test that we don't put `x_span` to the right of its highlight,\n-    // since there is another highlight that overlaps it. In this\n-    // case, the overlap is only at the beginning, but it's still\n-    // better to show the beginning more clearly.\n-\n-    let file_text = r#\"\n-    fn foo() {\n-       let closure = || {\n-           inner\n-       };\n-    }\n-}\n-\"#;\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut snippet = SnippetData::new(cm.clone(), None);\n-\n-    let closure_span = {\n-        let closure_start_span = cm.span_substr(&foo, file_text, \"||\", 0);\n-        let closure_end_span = cm.span_substr(&foo, file_text, \"}\", 0);\n-        splice(closure_start_span, closure_end_span)\n-    };\n-\n-    let inner_span = cm.span_substr(&foo, file_text, \"inner\", 0);\n-\n-    snippet.push(closure_span, false, Some(format!(\"foo\")));\n-    snippet.push(inner_span, false, Some(format!(\"bar\")));\n-\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n- ::: foo.rs\n-  |>\n-3 |>        let closure = || {\n-  |>                      - foo\n-4 |>            inner\n-  |>            ----- bar\n-\"#[1..]);\n-}\n-\n-#[test]\n-fn span_empty() {\n-    // In one of the unit tests, we found that the parser sometimes\n-    // gives empty spans, and in particular it supplied an EOF span\n-    // like this one, which points at the very end. We want to\n-    // fallback gracefully in this case.\n-\n-    let file_text = r#\"\n-fn main() {\n-    struct Foo;\n-\n-    impl !Sync for Foo {}\n-\n-    unsafe impl Send for &'static Foo {\n-    // error: cross-crate traits with a default impl, like `core::marker::Send`,\n-    //        can only be implemented for a struct/enum type, not\n-    //        `&'static Foo`\n-}\"#;\n-\n-\n-    let cm = Rc::new(CodeMap::new());\n-    let foo = cm.new_filemap_and_lines(\"foo.rs\", None, file_text);\n-\n-    let mut rbrace_span = cm.span_substr(&foo, file_text, \"}\", 1);\n-    rbrace_span.lo = rbrace_span.hi;\n-\n-    let mut snippet = SnippetData::new(cm.clone(), Some(rbrace_span));\n-    snippet.push(rbrace_span, false, None);\n-    let lines = snippet.render_lines();\n-    let text: String = make_string(&lines);\n-    println!(\"r#\\\"\\n{}\\\"\", text);\n-    assert_eq!(text, &r#\"\n-  --> foo.rs:11:2\n-   |>\n-11 |> }\n-   |>  -\n-\"#[1..]);\n-}"}]}