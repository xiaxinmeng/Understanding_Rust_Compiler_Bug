{"sha": "ebb560a069c7edb9dc506fdc302dbf1c57576952", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViYjU2MGEwNjljN2VkYjlkYzUwNmZkYzMwMmRiZjFjNTc1NzY5NTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-24T14:30:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-24T14:30:46Z"}, "message": "Auto merge of #29934 - arielb1:constrained-projection-2, r=nikomatsakis\n\nFixes #29861 - it was a bug I accidentally introduced in #26275.\n\nr? @nikomatsakis", "tree": {"sha": "f7e87bc79d9d42cd79e6052debc5b977db9729b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f7e87bc79d9d42cd79e6052debc5b977db9729b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ebb560a069c7edb9dc506fdc302dbf1c57576952", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ebb560a069c7edb9dc506fdc302dbf1c57576952", "html_url": "https://github.com/rust-lang/rust/commit/ebb560a069c7edb9dc506fdc302dbf1c57576952", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ebb560a069c7edb9dc506fdc302dbf1c57576952/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cf0e3c752e05d49019f9bc5f12d290545ba58a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cf0e3c752e05d49019f9bc5f12d290545ba58a4", "html_url": "https://github.com/rust-lang/rust/commit/9cf0e3c752e05d49019f9bc5f12d290545ba58a4"}, {"sha": "3c0d55cc76c524c12160bfb45663d9aca73e6556", "url": "https://api.github.com/repos/rust-lang/rust/commits/3c0d55cc76c524c12160bfb45663d9aca73e6556", "html_url": "https://github.com/rust-lang/rust/commit/3c0d55cc76c524c12160bfb45663d9aca73e6556"}], "stats": {"total": 104, "additions": 85, "deletions": 19}, "files": [{"sha": "36be59da6efb690ee1b8a2cae98c5040b9666e69", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ebb560a069c7edb9dc506fdc302dbf1c57576952/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb560a069c7edb9dc506fdc302dbf1c57576952/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ebb560a069c7edb9dc506fdc302dbf1c57576952", "patch": "@@ -2387,9 +2387,9 @@ fn enforce_impl_params_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // reachable from there, to start (if this is an inherent impl,\n     // then just examine the self type).\n     let mut input_parameters: HashSet<_> =\n-        ctp::parameters_for_type(impl_scheme.ty).into_iter().collect();\n+        ctp::parameters_for_type(impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n-        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref));\n+        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref, false));\n     }\n \n     ctp::setup_constraining_predicates(tcx,\n@@ -2418,9 +2418,9 @@ fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n     let mut input_parameters: HashSet<_> =\n-        ctp::parameters_for_type(impl_scheme.ty).into_iter().collect();\n+        ctp::parameters_for_type(impl_scheme.ty, false).into_iter().collect();\n     if let Some(ref trait_ref) = impl_trait_ref {\n-        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref));\n+        input_parameters.extend(ctp::parameters_for_trait_ref(trait_ref, false));\n     }\n     ctp::identify_constrained_type_params(tcx,\n         &impl_predicates.predicates.as_slice(), impl_trait_ref, &mut input_parameters);\n@@ -2432,7 +2432,7 @@ fn enforce_impl_lifetimes_are_constrained<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       ty::TypeTraitItem(ref assoc_ty) => assoc_ty.ty,\n                       ty::ConstTraitItem(..) | ty::MethodTraitItem(..) => None\n                   })\n-                  .flat_map(|ty| ctp::parameters_for_type(ty))\n+                  .flat_map(|ty| ctp::parameters_for_type(ty, true))\n                   .filter_map(|p| match p {\n                       ctp::Parameter::Type(_) => None,\n                       ctp::Parameter::Region(r) => Some(r),"}, {"sha": "9abe101e2d9d657dafb9ebdf3c65b5a733005dfe", "filename": "src/librustc_typeck/constrained_type_params.rs", "status": "modified", "additions": 50, "deletions": 14, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/ebb560a069c7edb9dc506fdc302dbf1c57576952/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb560a069c7edb9dc506fdc302dbf1c57576952/src%2Flibrustc_typeck%2Fconstrained_type_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fconstrained_type_params.rs?ref=ebb560a069c7edb9dc506fdc302dbf1c57576952", "patch": "@@ -19,15 +19,20 @@ pub enum Parameter {\n     Region(ty::EarlyBoundRegion),\n }\n \n-/// Returns the list of parameters that are constrained by the type `ty`\n-/// - i.e. the value of each parameter in the list is uniquely determined\n-/// by `ty` (see RFC 447).\n-pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n+/// If `include_projections` is false, returns the list of parameters that are\n+/// constrained by the type `ty` - i.e. the value of each parameter in the list is\n+/// uniquely determined by `ty` (see RFC 447). If it is true, return the list\n+/// of parameters whose values are needed in order to constrain `ty` - these\n+/// differ, with the latter being a superset, in the presence of projections.\n+pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>,\n+                                 include_projections: bool) -> Vec<Parameter> {\n     let mut result = vec![];\n-    ty.maybe_walk(|t| {\n-        if let ty::TyProjection(..) = t.sty {\n+    ty.maybe_walk(|t| match t.sty {\n+        ty::TyProjection(..) if !include_projections => {\n+\n             false // projections are not injective.\n-        } else {\n+        }\n+        _ => {\n             result.append(&mut parameters_for_type_shallow(t));\n             // non-projection type constructors are injective.\n             true\n@@ -36,13 +41,16 @@ pub fn parameters_for_type<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n     result\n }\n \n-pub fn parameters_for_trait_ref<'tcx>(trait_ref: &ty::TraitRef<'tcx>) -> Vec<Parameter> {\n+pub fn parameters_for_trait_ref<'tcx>(trait_ref: &ty::TraitRef<'tcx>,\n+                                      include_projections: bool) -> Vec<Parameter> {\n     let mut region_parameters =\n         parameters_for_regions_in_substs(&trait_ref.substs);\n \n     let type_parameters =\n-        trait_ref.substs.types.iter()\n-                              .flat_map(|ty| parameters_for_type(ty));\n+        trait_ref.substs\n+                 .types\n+                 .iter()\n+                 .flat_map(|ty| parameters_for_type(ty, include_projections));\n \n     region_parameters.extend(type_parameters);\n \n@@ -60,8 +68,14 @@ fn parameters_for_type_shallow<'tcx>(ty: Ty<'tcx>) -> Vec<Parameter> {\n             parameters_for_regions_in_substs(substs),\n         ty::TyTrait(ref data) =>\n             parameters_for_regions_in_substs(&data.principal.skip_binder().substs),\n-        _ =>\n-            vec![],\n+        ty::TyProjection(ref pi) =>\n+            parameters_for_regions_in_substs(&pi.trait_ref.substs),\n+        ty::TyBool | ty::TyChar | ty::TyInt(..) | ty::TyUint(..) |\n+        ty::TyFloat(..) | ty::TyBox(..) | ty::TyStr |\n+        ty::TyArray(..) | ty::TySlice(..) | ty::TyBareFn(..) |\n+        ty::TyTuple(..) | ty::TyRawPtr(..) |\n+        ty::TyInfer(..) | ty::TyClosure(..) | ty::TyError =>\n+            vec![]\n     }\n }\n \n@@ -113,6 +127,22 @@ pub fn identify_constrained_type_params<'tcx>(_tcx: &ty::ctxt<'tcx>,\n /// pass, we want the projection to come first. In fact, as projections\n /// can (acyclically) depend on one another - see RFC447 for details - we\n /// need to topologically sort them.\n+///\n+/// We *do* have to be somewhat careful when projection targets contain\n+/// projections themselves, for example in\n+///     impl<S,U,V,W> Trait for U where\n+/// /* 0 */   S: Iterator<Item=U>,\n+/// /* - */   U: Iterator,\n+/// /* 1 */   <U as Iterator>::Item: ToOwned<Owned=(W,<V as Iterator>::Item)>\n+/// /* 2 */   W: Iterator<Item=V>\n+/// /* 3 */   V: Debug\n+/// we have to evaluate the projections in the order I wrote them:\n+/// `V: Debug` requires `V` to be evaluated. The only projection that\n+/// *determines* `V` is 2 (1 contains it, but *does not determine it*,\n+/// as it is only contained within a projection), but that requires `W`\n+/// which is determined by 1, which requires `U`, that is determined\n+/// by 0. I should probably pick a less tangled example, but I can't\n+/// think of any.\n pub fn setup_constraining_predicates<'tcx>(_tcx: &ty::ctxt<'tcx>,\n                                            predicates: &mut [ty::Predicate<'tcx>],\n                                            impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n@@ -157,12 +187,18 @@ pub fn setup_constraining_predicates<'tcx>(_tcx: &ty::ctxt<'tcx>,\n                     continue;\n                 }\n \n-                let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref);\n+                // A projection depends on its input types and determines its output\n+                // type. For example, if we have\n+                //     `<<T as Bar>::Baz as Iterator>::Output = <U as Iterator>::Output`\n+                // Then the projection only applies if `T` is known, but it still\n+                // does not determine `U`.\n+\n+                let inputs = parameters_for_trait_ref(&projection.projection_ty.trait_ref, true);\n                 let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n                 if !relies_only_on_inputs {\n                     continue;\n                 }\n-                input_parameters.extend(parameters_for_type(projection.ty));\n+                input_parameters.extend(parameters_for_type(projection.ty, false));\n             } else {\n                 continue;\n             }"}, {"sha": "79514ad376b3bf1434ce4d3a3a61b7486f39c1a3", "filename": "src/test/compile-fail/issue-29861.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ebb560a069c7edb9dc506fdc302dbf1c57576952/src%2Ftest%2Fcompile-fail%2Fissue-29861.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ebb560a069c7edb9dc506fdc302dbf1c57576952/src%2Ftest%2Fcompile-fail%2Fissue-29861.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-29861.rs?ref=ebb560a069c7edb9dc506fdc302dbf1c57576952", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait MakeRef<'a> {\n+    type Ref;\n+}\n+impl<'a, T: 'a> MakeRef<'a> for T {\n+    type Ref = &'a T;\n+}\n+\n+pub trait MakeRef2 {\n+    type Ref2;\n+}\n+impl<'a, T: 'a> MakeRef2 for T {\n+//~^ ERROR the lifetime parameter `'a` is not constrained\n+    type Ref2 = <T as MakeRef<'a>>::Ref;\n+}\n+\n+fn foo() -> <String as MakeRef2>::Ref2 { &String::from(\"foo\") }\n+\n+fn main() {\n+    println!(\"{}\", foo());\n+}"}]}