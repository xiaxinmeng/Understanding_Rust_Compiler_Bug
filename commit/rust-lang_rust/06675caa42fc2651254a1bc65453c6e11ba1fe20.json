{"sha": "06675caa42fc2651254a1bc65453c6e11ba1fe20", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2Njc1Y2FhNDJmYzI2NTEyNTRhMWJjNjU0NTNjNmUxMWJhMWZlMjA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-29T02:50:22Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-08-29T02:51:11Z"}, "message": "Comment the default case in typeck::check::vtable::lookup_vtable copiously\n\nTry to save the next person who looks at this code the heartbreak that I\nwent through.", "tree": {"sha": "98094c523e56c50b03021146a6b5b456160838a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98094c523e56c50b03021146a6b5b456160838a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06675caa42fc2651254a1bc65453c6e11ba1fe20", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06675caa42fc2651254a1bc65453c6e11ba1fe20", "html_url": "https://github.com/rust-lang/rust/commit/06675caa42fc2651254a1bc65453c6e11ba1fe20", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06675caa42fc2651254a1bc65453c6e11ba1fe20/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a70e37b214407743ba9ac7e688e13d7a9d644ad5", "url": "https://api.github.com/repos/rust-lang/rust/commits/a70e37b214407743ba9ac7e688e13d7a9d644ad5", "html_url": "https://github.com/rust-lang/rust/commit/a70e37b214407743ba9ac7e688e13d7a9d644ad5"}], "stats": {"total": 108, "additions": 98, "deletions": 10}, "files": [{"sha": "afb5701fd5f8b75bc2d31921069ab621fde9cae5", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 98, "deletions": 10, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/06675caa42fc2651254a1bc65453c6e11ba1fe20/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06675caa42fc2651254a1bc65453c6e11ba1fe20/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=06675caa42fc2651254a1bc65453c6e11ba1fe20", "patch": "@@ -169,46 +169,115 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                 // Nothing found. Continue.\n             }\n             Some(implementations) => {\n+                /*\n+                implementations is the list of all impls in scope for\n+                trait_ty. (Usually, there's just one.)\n+                */\n                 for uint::range(0, implementations.len()) |i| {\n                     let im = implementations[i];\n \n-                    // im = one specific impl\n+                    // im is one specific impl of trait_ty.\n \n                     // First, ensure that we haven't processed this impl yet.\n                     if impls_seen.contains_key(im.did) {\n                         again;\n                     }\n                     impls_seen.insert(im.did, ());\n \n-                    // find the trait that im implements (if any)\n+\n+                /*\n+                ty::impl_traits gives us the list of all traits that im\n+                implements. Again, usually there's just one.\n+\n+                For example, if im represented the struct in:\n+\n+                struct foo : baz<int>, bar, quux { ... }\n+\n+                then ty::impl_traits would return\n+                    ~[baz<int>, bar, quux]\n+\n+                For each of the traits foo implements, if it's the\n+                same trait as trait_ty, we need to unify it with\n+                trait_ty in order to get all the ty vars sorted out.\n+                */\n                     for vec::each(ty::impl_traits(tcx, im.did)) |of_ty| {\n-                        // it must have the same id as the expected one\n                         match ty::get(of_ty).struct {\n+                        // This is a trait that is different from the one\n+                        // we're looking for, so we skip to the next one.\n                           ty::ty_trait(id, _, _) if id != trait_id => again,\n                           _ => { /* ok */ }\n                         }\n \n-                        // check whether the type unifies with the type\n-                        // that the impl is for, and continue if not\n+                /* At this point, we know that of_ty is the same trait\n+                as trait_ty, but possibly applied to different substs.\n+\n+                Next, we check whether the \"for\" ty in the impl is\n+                compatible with the type that we're casting to a trait. That\n+                is, if im is:\n+\n+                impl<T> self_ty<T>: some_trait<T> { ... }\n+\n+                we check whether self_ty<T> is the type of the thing that\n+                we're trying to cast to some_trait.\n+                */\n                         let {substs: substs, ty: for_ty} =\n                             impl_self_ty(fcx, expr, im.did, false);\n                         let im_bs = ty::lookup_item_type(tcx, im.did).bounds;\n                         match fcx.mk_subty(false, expr.span, ty, for_ty) {\n+                // for_ty is not compatible with ty, so this impl is\n+                // irrelevant and we skip to the next impl\n                           result::Err(_) => again,\n+                // The impl is an impl for ty of the desired trait.\n                           result::Ok(()) => ()\n                         }\n \n-                        // check that desired trait type unifies\n+                /*\n+                Now, in the previous example, for_ty is bound to the\n+                type self_ty, and substs is bound to [T].\n+                */\n+                        debug!(\"The self ty is %s and its substs are %s\",\n+                               fcx.infcx.ty_to_str(for_ty),\n+                               tys_to_str(fcx.ccx.tcx, substs.tps));\n+\n+                /*\n+                Next, we unify trait_ty -- the type that we want to cast\n+                to -- with of_ty -- the trait that im implements. At this\n+                point, we require that they be unifiable with each other --\n+                that's what relate_trait_tys does.\n+\n+                For example, in the above example, of_ty would be\n+                some_trait<T>, so we would be unifying trait_ty<U> (for\n+                some value of U) with some_trait<T>. This would fail if\n+                T and U weren't compatible.\n+                */\n+\n                         debug!(\"(checking vtable) @2 relating trait ty %s to \\\n                                 of_ty %s\",\n                                fcx.infcx.ty_to_str(trait_ty),\n                                fcx.infcx.ty_to_str(of_ty));\n                         let of_ty = ty::subst(tcx, &substs, of_ty);\n                         relate_trait_tys(fcx, expr, trait_ty, of_ty);\n \n-                        // recursively process the bounds.\n+                /*\n+                Recall that trait_ty -- the trait type we're casting to --\n+                is the trait with id trait_id applied to the substs\n+                trait_substs. Now we extract out the types themselves\n+                from trait_substs.\n+                */\n+\n                         let trait_tps = trait_substs.tps;\n-                        // see comments around the earlier call to fixup_ty\n+\n+                        debug!(\"Casting to a trait ty whose substs \\\n+                          (trait_tps) are %s\",\n+                               tys_to_str(fcx.ccx.tcx, trait_tps));\n+\n+                /*\n+                Recall that substs is the impl self type's list of\n+                substitutions. That is, if this is an impl of some trait\n+                for foo<T, U>, then substs is [T, U]. substs might contain\n+                type variables, so we call fixup_substs to resolve them.\n+                */\n+\n                         let substs_f = match fixup_substs(fcx, expr, trait_id,\n                                                           substs, is_early) {\n                             Some(substs) => substs,\n@@ -219,11 +288,30 @@ fn lookup_vtable(fcx: @fn_ctxt,\n                             }\n                         };\n \n+                        debug!(\"The fixed-up substs for the self ty are %s - \\\n+                                they will be unified with the bounds for \\\n+                                the target ty, %s\",\n+                               tys_to_str(fcx.ccx.tcx, substs_f.tps),\n+                               tys_to_str(fcx.ccx.tcx, trait_tps));\n+\n+                /*\n+                Next, we unify the fixed-up substitutions for the impl self\n+                ty with the substitutions from the trait type that we're\n+                trying to cast to. connect_trait_tps requires these\n+                lists of types to unify pairwise.\n+                */\n+\n                         connect_trait_tps(fcx, expr, substs_f.tps,\n                                           trait_tps, im.did);\n                         let subres = lookup_vtables(\n                             fcx, expr, im_bs, &substs_f,\n                             false, is_early);\n+\n+                /*\n+                Finally, we register that we found a matching impl,\n+                and record the def ID of the impl as well as the resolved\n+                list of type substitutions for the target trait.\n+                */\n                         vec::push(found,\n                                   vtable_static(im.did, substs_f.tps,\n                                                 subres));\n@@ -233,8 +321,8 @@ fn lookup_vtable(fcx: @fn_ctxt,\n         }\n \n         match found.len() {\n-          0u => { /* fallthrough */ }\n-          1u => { return found[0]; }\n+          0 => { /* fallthrough */ }\n+          1 => { return found[0]; }\n           _ => {\n             if !is_early {\n                 fcx.ccx.tcx.sess.span_err("}]}