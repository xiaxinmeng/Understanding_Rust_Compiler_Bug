{"sha": "a25d58b41b273993c27a2533dc193b799abbf43f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNWQ1OGI0MWIyNzM5OTNjMjdhMjUzM2RjMTkzYjc5OWFiYmY0M2Y=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-05T22:41:54Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-05T22:41:54Z"}, "message": "Auto merge of #68461 - cjgillot:split_infer_prelude, r=matthewjasper\n\nMove datatypes definitions in specific modules inside rustc::{traits, infer}\n\nPrelude to #67953\n\nSome data types inside `rustc::traits` and `rustc::infer` are used in other parts of `librustc`. These cannot go to a separate crate `librustc_infer`.\n\nThis PR moves those data types to `traits::types` and `infer::types` modules, from where everything is reexported.\n\nNote for review: some imports feature the `crate -> rustc` substitution. This is cruft from the splitting out of #67953. This can be reverted, but are bound to be put back by #67953.\n\nr? @Centril\ncc @Zoxc", "tree": {"sha": "44db1d4ce32f25ec8d1213cc758bc1ac2fe38bed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/44db1d4ce32f25ec8d1213cc758bc1ac2fe38bed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a25d58b41b273993c27a2533dc193b799abbf43f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a25d58b41b273993c27a2533dc193b799abbf43f", "html_url": "https://github.com/rust-lang/rust/commit/a25d58b41b273993c27a2533dc193b799abbf43f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a25d58b41b273993c27a2533dc193b799abbf43f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "58b834344fc7b9185e7a50db1ff24e5eb07dae5e", "url": "https://api.github.com/repos/rust-lang/rust/commits/58b834344fc7b9185e7a50db1ff24e5eb07dae5e", "html_url": "https://github.com/rust-lang/rust/commit/58b834344fc7b9185e7a50db1ff24e5eb07dae5e"}, {"sha": "735d664e7401de8f272cf26f404d1f0a44db5471", "url": "https://api.github.com/repos/rust-lang/rust/commits/735d664e7401de8f272cf26f404d1f0a44db5471", "html_url": "https://github.com/rust-lang/rust/commit/735d664e7401de8f272cf26f404d1f0a44db5471"}], "stats": {"total": 5282, "additions": 2725, "deletions": 2557}, "files": [{"sha": "f157d805bcd8cb4f3f2cb2adf946d57e5b839596", "filename": "src/librustc/infer/canonical/mod.rs", "status": "modified", "additions": 5, "deletions": 334, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fcanonical%2Fmod.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -21,284 +21,22 @@\n //!\n //! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n \n-use crate::infer::region_constraints::MemberConstraint;\n use crate::infer::{ConstVariableOrigin, ConstVariableOriginKind};\n use crate::infer::{InferCtxt, RegionVariableOrigin, TypeVariableOrigin, TypeVariableOriginKind};\n-use crate::ty::fold::TypeFoldable;\n-use crate::ty::subst::GenericArg;\n-use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n+use rustc::ty::fold::TypeFoldable;\n+use rustc::ty::subst::GenericArg;\n+use rustc::ty::{self, BoundVar, List};\n use rustc_index::vec::IndexVec;\n-use rustc_macros::HashStable;\n-use rustc_serialize::UseSpecializedDecodable;\n use rustc_span::source_map::Span;\n-use smallvec::SmallVec;\n-use std::ops::Index;\n+\n+pub use rustc::infer::types::canonical::*;\n \n mod canonicalizer;\n \n pub mod query_response;\n \n mod substitute;\n \n-/// A \"canonicalized\" type `V` is one where all free inference\n-/// variables have been rewritten to \"canonical vars\". These are\n-/// numbered starting from 0 in order of first appearance.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable, TypeFoldable, Lift)]\n-pub struct Canonical<'tcx, V> {\n-    pub max_universe: ty::UniverseIndex,\n-    pub variables: CanonicalVarInfos<'tcx>,\n-    pub value: V,\n-}\n-\n-pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo>;\n-\n-impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n-\n-/// A set of values corresponding to the canonical variables from some\n-/// `Canonical`. You can give these values to\n-/// `canonical_value.substitute` to substitute them into the canonical\n-/// value at the right places.\n-///\n-/// When you canonicalize a value `V`, you get back one of these\n-/// vectors with the original values that were replaced by canonical\n-/// variables. You will need to supply it later to instantiate the\n-/// canonicalized query response.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n-#[derive(HashStable, TypeFoldable, Lift)]\n-pub struct CanonicalVarValues<'tcx> {\n-    pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n-}\n-\n-/// When we canonicalize a value to form a query, we wind up replacing\n-/// various parts of it with canonical variables. This struct stores\n-/// those replaced bits to remember for when we process the query\n-/// result.\n-#[derive(Clone, Debug)]\n-pub struct OriginalQueryValues<'tcx> {\n-    /// Map from the universes that appear in the query to the\n-    /// universes in the caller context. For the time being, we only\n-    /// ever put ROOT values into the query, so this map is very\n-    /// simple.\n-    pub universe_map: SmallVec<[ty::UniverseIndex; 4]>,\n-\n-    /// This is equivalent to `CanonicalVarValues`, but using a\n-    /// `SmallVec` yields a significant performance win.\n-    pub var_values: SmallVec<[GenericArg<'tcx>; 8]>,\n-}\n-\n-impl Default for OriginalQueryValues<'tcx> {\n-    fn default() -> Self {\n-        let mut universe_map = SmallVec::default();\n-        universe_map.push(ty::UniverseIndex::ROOT);\n-\n-        Self { universe_map, var_values: SmallVec::default() }\n-    }\n-}\n-\n-/// Information about a canonical variable that is included with the\n-/// canonical value. This is sufficient information for code to create\n-/// a copy of the canonical value in some other inference context,\n-/// with fresh inference variables replacing the canonical values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub struct CanonicalVarInfo {\n-    pub kind: CanonicalVarKind,\n-}\n-\n-impl CanonicalVarInfo {\n-    pub fn universe(&self) -> ty::UniverseIndex {\n-        self.kind.universe()\n-    }\n-\n-    pub fn is_existential(&self) -> bool {\n-        match self.kind {\n-            CanonicalVarKind::Ty(_) => true,\n-            CanonicalVarKind::PlaceholderTy(_) => false,\n-            CanonicalVarKind::Region(_) => true,\n-            CanonicalVarKind::PlaceholderRegion(..) => false,\n-            CanonicalVarKind::Const(_) => true,\n-            CanonicalVarKind::PlaceholderConst(_) => false,\n-        }\n-    }\n-}\n-\n-/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n-/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n-/// that analyzes type-like values.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub enum CanonicalVarKind {\n-    /// Some kind of type inference variable.\n-    Ty(CanonicalTyVarKind),\n-\n-    /// A \"placeholder\" that represents \"any type\".\n-    PlaceholderTy(ty::PlaceholderType),\n-\n-    /// Region variable `'?R`.\n-    Region(ty::UniverseIndex),\n-\n-    /// A \"placeholder\" that represents \"any region\". Created when you\n-    /// are solving a goal like `for<'a> T: Foo<'a>` to represent the\n-    /// bound region `'a`.\n-    PlaceholderRegion(ty::PlaceholderRegion),\n-\n-    /// Some kind of const inference variable.\n-    Const(ty::UniverseIndex),\n-\n-    /// A \"placeholder\" that represents \"any const\".\n-    PlaceholderConst(ty::PlaceholderConst),\n-}\n-\n-impl CanonicalVarKind {\n-    pub fn universe(self) -> ty::UniverseIndex {\n-        match self {\n-            CanonicalVarKind::Ty(kind) => match kind {\n-                CanonicalTyVarKind::General(ui) => ui,\n-                CanonicalTyVarKind::Float | CanonicalTyVarKind::Int => ty::UniverseIndex::ROOT,\n-            },\n-\n-            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.universe,\n-            CanonicalVarKind::Region(ui) => ui,\n-            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n-            CanonicalVarKind::Const(ui) => ui,\n-            CanonicalVarKind::PlaceholderConst(placeholder) => placeholder.universe,\n-        }\n-    }\n-}\n-\n-/// Rust actually has more than one category of type variables;\n-/// notably, the type variables we create for literals (e.g., 22 or\n-/// 22.) can only be instantiated with integral/float types (e.g.,\n-/// usize or f32). In order to faithfully reproduce a type, we need to\n-/// know what set of types a given type variable can be unified with.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n-pub enum CanonicalTyVarKind {\n-    /// General type variable `?T` that can be unified with arbitrary types.\n-    General(ty::UniverseIndex),\n-\n-    /// Integral type variable `?I` (that can only be unified with integral types).\n-    Int,\n-\n-    /// Floating-point type variable `?F` (that can only be unified with float types).\n-    Float,\n-}\n-\n-/// After we execute a query with a canonicalized key, we get back a\n-/// `Canonical<QueryResponse<..>>`. You can use\n-/// `instantiate_query_result` to access the data in this result.\n-#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n-pub struct QueryResponse<'tcx, R> {\n-    pub var_values: CanonicalVarValues<'tcx>,\n-    pub region_constraints: QueryRegionConstraints<'tcx>,\n-    pub certainty: Certainty,\n-    pub value: R,\n-}\n-\n-#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n-pub struct QueryRegionConstraints<'tcx> {\n-    pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n-    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n-}\n-\n-impl QueryRegionConstraints<'_> {\n-    /// Represents an empty (trivially true) set of region\n-    /// constraints.\n-    pub fn is_empty(&self) -> bool {\n-        self.outlives.is_empty() && self.member_constraints.is_empty()\n-    }\n-}\n-\n-pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n-\n-pub type CanonicalizedQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n-\n-/// Indicates whether or not we were able to prove the query to be\n-/// true.\n-#[derive(Copy, Clone, Debug, HashStable)]\n-pub enum Certainty {\n-    /// The query is known to be true, presuming that you apply the\n-    /// given `var_values` and the region-constraints are satisfied.\n-    Proven,\n-\n-    /// The query is not known to be true, but also not known to be\n-    /// false. The `var_values` represent *either* values that must\n-    /// hold in order for the query to be true, or helpful tips that\n-    /// *might* make it true. Currently rustc's trait solver cannot\n-    /// distinguish the two (e.g., due to our preference for where\n-    /// clauses over impls).\n-    ///\n-    /// After some unifiations and things have been done, it makes\n-    /// sense to try and prove again -- of course, at that point, the\n-    /// canonical form will be different, making this a distinct\n-    /// query.\n-    Ambiguous,\n-}\n-\n-impl Certainty {\n-    pub fn is_proven(&self) -> bool {\n-        match self {\n-            Certainty::Proven => true,\n-            Certainty::Ambiguous => false,\n-        }\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, R> QueryResponse<'tcx, R> {\n-    pub fn is_proven(&self) -> bool {\n-        self.certainty.is_proven()\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {\n-    pub fn is_proven(&self) -> bool {\n-        self.value.is_proven()\n-    }\n-\n-    pub fn is_ambiguous(&self) -> bool {\n-        !self.is_proven()\n-    }\n-}\n-\n-impl<'tcx, V> Canonical<'tcx, V> {\n-    /// Allows you to map the `value` of a canonical while keeping the\n-    /// same set of bound variables.\n-    ///\n-    /// **WARNING:** This function is very easy to mis-use, hence the\n-    /// name!  In particular, the new value `W` must use all **the\n-    /// same type/region variables** in **precisely the same order**\n-    /// as the original! (The ordering is defined by the\n-    /// `TypeFoldable` implementation of the type in question.)\n-    ///\n-    /// An example of a **correct** use of this:\n-    ///\n-    /// ```rust,ignore (not real code)\n-    /// let a: Canonical<'_, T> = ...;\n-    /// let b: Canonical<'_, (T,)> = a.unchecked_map(|v| (v, ));\n-    /// ```\n-    ///\n-    /// An example of an **incorrect** use of this:\n-    ///\n-    /// ```rust,ignore (not real code)\n-    /// let a: Canonical<'tcx, T> = ...;\n-    /// let ty: Ty<'tcx> = ...;\n-    /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n-    /// ```\n-    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'tcx, W> {\n-        let Canonical { max_universe, variables, value } = self;\n-        Canonical { max_universe, variables, value: map_op(value) }\n-    }\n-}\n-\n-pub type QueryOutlivesConstraint<'tcx> =\n-    ty::Binder<ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n-\n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Creates a substitution S for the canonical value with fresh\n     /// inference variables and applies it to the canonical value.\n@@ -424,70 +162,3 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         }\n     }\n }\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    crate::infer::canonical::Certainty,\n-    crate::infer::canonical::CanonicalVarInfo,\n-    crate::infer::canonical::CanonicalVarKind,\n-}\n-\n-CloneTypeFoldableImpls! {\n-    for <'tcx> {\n-        crate::infer::canonical::CanonicalVarInfos<'tcx>,\n-    }\n-}\n-\n-impl<'tcx> CanonicalVarValues<'tcx> {\n-    pub fn len(&self) -> usize {\n-        self.var_values.len()\n-    }\n-\n-    /// Makes an identity substitution from this one: each bound var\n-    /// is matched to the same bound var, preserving the original kinds.\n-    /// For example, if we have:\n-    /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n-    /// we'll return a substitution `subst` with:\n-    /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n-    pub fn make_identity(&self, tcx: TyCtxt<'tcx>) -> Self {\n-        use crate::ty::subst::GenericArgKind;\n-\n-        CanonicalVarValues {\n-            var_values: self\n-                .var_values\n-                .iter()\n-                .zip(0..)\n-                .map(|(kind, i)| match kind.unpack() {\n-                    GenericArgKind::Type(..) => {\n-                        tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n-                    }\n-                    GenericArgKind::Lifetime(..) => tcx\n-                        .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i)))\n-                        .into(),\n-                    GenericArgKind::Const(ct) => tcx\n-                        .mk_const(ty::Const {\n-                            ty: ct.ty,\n-                            val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n-                        })\n-                        .into(),\n-                })\n-                .collect(),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n-    type Item = GenericArg<'tcx>;\n-    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, GenericArg<'tcx>>>;\n-\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.var_values.iter().cloned()\n-    }\n-}\n-\n-impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n-    type Output = GenericArg<'tcx>;\n-\n-    fn index(&self, value: BoundVar) -> &GenericArg<'tcx> {\n-        &self.var_values[value]\n-    }\n-}"}, {"sha": "4681a47317cf2369e6cff2c419dcc5f53a9eefae", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -61,6 +61,7 @@ pub mod region_constraints;\n pub mod resolve;\n mod sub;\n pub mod type_variable;\n+mod types;\n pub mod unify_key;\n \n #[must_use]\n@@ -556,16 +557,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n }\n \n-impl<T> ExpectedFound<T> {\n-    pub fn new(a_is_expected: bool, a: T, b: T) -> Self {\n-        if a_is_expected {\n-            ExpectedFound { expected: a, found: b }\n-        } else {\n-            ExpectedFound { expected: b, found: a }\n-        }\n-    }\n-}\n-\n impl<'tcx, T> InferOk<'tcx, T> {\n     pub fn unit(self) -> InferOk<'tcx, ()> {\n         InferOk { value: (), obligations: self.obligations }"}, {"sha": "410058b70b5d8c6495cf1fdbd7787216bef31857", "filename": "src/librustc/infer/region_constraints/mod.rs", "status": "modified", "additions": 2, "deletions": 24, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -23,6 +23,8 @@ use std::{cmp, fmt, mem};\n \n mod leak_check;\n \n+pub use rustc::infer::types::MemberConstraint;\n+\n #[derive(Default)]\n pub struct RegionConstraintCollector<'tcx> {\n     /// For each `RegionVid`, the corresponding `RegionVariableOrigin`.\n@@ -145,30 +147,6 @@ impl Constraint<'_> {\n     }\n }\n \n-/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n-/// We often denote this using the syntax:\n-///\n-/// ```\n-/// R0 member of [O1..On]\n-/// ```\n-#[derive(Debug, Clone, HashStable, TypeFoldable, Lift)]\n-pub struct MemberConstraint<'tcx> {\n-    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n-    pub opaque_type_def_id: DefId,\n-\n-    /// The span where the hidden type was instantiated.\n-    pub definition_span: Span,\n-\n-    /// The hidden type in which `member_region` appears: used for error reporting.\n-    pub hidden_ty: Ty<'tcx>,\n-\n-    /// The region `R0`.\n-    pub member_region: Region<'tcx>,\n-\n-    /// The options `O1..On`.\n-    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n-}\n-\n /// `VerifyGenericBound(T, _, R, RS)`: the parameter type `T` (or\n /// associated type) must outlive the region `R`. `T` is known to\n /// outlive `RS`. Therefore, verify that `R <= RS[i]` for some"}, {"sha": "f391a054a2a5dd1cebb852da55fa06a0eb4e3d20", "filename": "src/librustc/infer/type_variable.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Ftype_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftype_variable.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -453,18 +453,3 @@ impl<'tcx> ut::UnifyValue for TypeVariableValue<'tcx> {\n         }\n     }\n }\n-\n-/// Raw `TyVid` are used as the unification key for `sub_relations`;\n-/// they carry no values.\n-impl ut::UnifyKey for ty::TyVid {\n-    type Value = ();\n-    fn index(&self) -> u32 {\n-        self.index\n-    }\n-    fn from_index(i: u32) -> ty::TyVid {\n-        ty::TyVid { index: i }\n-    }\n-    fn tag() -> &'static str {\n-        \"TyVid\"\n-    }\n-}"}, {"sha": "133cf1b592862048616e6bc7de3eeb1f17b4f71b", "filename": "src/librustc/infer/types/canonical.rs", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftypes%2Fcanonical.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -0,0 +1,357 @@\n+//! **Canonicalization** is the key to constructing a query in the\n+//! middle of type inference. Ordinarily, it is not possible to store\n+//! types from type inference in query keys, because they contain\n+//! references to inference variables whose lifetimes are too short\n+//! and so forth. Canonicalizing a value T1 using `canonicalize_query`\n+//! produces two things:\n+//!\n+//! - a value T2 where each unbound inference variable has been\n+//!   replaced with a **canonical variable**;\n+//! - a map M (of type `CanonicalVarValues`) from those canonical\n+//!   variables back to the original.\n+//!\n+//! We can then do queries using T2. These will give back constraints\n+//! on the canonical variables which can be translated, using the map\n+//! M, into constraints in our source context. This process of\n+//! translating the results back is done by the\n+//! `instantiate_query_result` method.\n+//!\n+//! For a more detailed look at what is happening here, check\n+//! out the [chapter in the rustc guide][c].\n+//!\n+//! [c]: https://rust-lang.github.io/rustc-guide/traits/canonicalization.html\n+\n+use crate::infer::region_constraints::MemberConstraint;\n+use crate::ty::subst::GenericArg;\n+use crate::ty::{self, BoundVar, List, Region, TyCtxt};\n+use rustc_index::vec::IndexVec;\n+use rustc_macros::HashStable;\n+use rustc_serialize::UseSpecializedDecodable;\n+use smallvec::SmallVec;\n+use std::ops::Index;\n+\n+/// A \"canonicalized\" type `V` is one where all free inference\n+/// variables have been rewritten to \"canonical vars\". These are\n+/// numbered starting from 0 in order of first appearance.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(HashStable, TypeFoldable, Lift)]\n+pub struct Canonical<'tcx, V> {\n+    pub max_universe: ty::UniverseIndex,\n+    pub variables: CanonicalVarInfos<'tcx>,\n+    pub value: V,\n+}\n+\n+pub type CanonicalVarInfos<'tcx> = &'tcx List<CanonicalVarInfo>;\n+\n+impl<'tcx> UseSpecializedDecodable for CanonicalVarInfos<'tcx> {}\n+\n+/// A set of values corresponding to the canonical variables from some\n+/// `Canonical`. You can give these values to\n+/// `canonical_value.substitute` to substitute them into the canonical\n+/// value at the right places.\n+///\n+/// When you canonicalize a value `V`, you get back one of these\n+/// vectors with the original values that were replaced by canonical\n+/// variables. You will need to supply it later to instantiate the\n+/// canonicalized query response.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable)]\n+#[derive(HashStable, TypeFoldable, Lift)]\n+pub struct CanonicalVarValues<'tcx> {\n+    pub var_values: IndexVec<BoundVar, GenericArg<'tcx>>,\n+}\n+\n+/// When we canonicalize a value to form a query, we wind up replacing\n+/// various parts of it with canonical variables. This struct stores\n+/// those replaced bits to remember for when we process the query\n+/// result.\n+#[derive(Clone, Debug)]\n+pub struct OriginalQueryValues<'tcx> {\n+    /// Map from the universes that appear in the query to the\n+    /// universes in the caller context. For the time being, we only\n+    /// ever put ROOT values into the query, so this map is very\n+    /// simple.\n+    pub universe_map: SmallVec<[ty::UniverseIndex; 4]>,\n+\n+    /// This is equivalent to `CanonicalVarValues`, but using a\n+    /// `SmallVec` yields a significant performance win.\n+    pub var_values: SmallVec<[GenericArg<'tcx>; 8]>,\n+}\n+\n+impl Default for OriginalQueryValues<'tcx> {\n+    fn default() -> Self {\n+        let mut universe_map = SmallVec::default();\n+        universe_map.push(ty::UniverseIndex::ROOT);\n+\n+        Self { universe_map, var_values: SmallVec::default() }\n+    }\n+}\n+\n+/// Information about a canonical variable that is included with the\n+/// canonical value. This is sufficient information for code to create\n+/// a copy of the canonical value in some other inference context,\n+/// with fresh inference variables replacing the canonical values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+pub struct CanonicalVarInfo {\n+    pub kind: CanonicalVarKind,\n+}\n+\n+impl CanonicalVarInfo {\n+    pub fn universe(&self) -> ty::UniverseIndex {\n+        self.kind.universe()\n+    }\n+\n+    pub fn is_existential(&self) -> bool {\n+        match self.kind {\n+            CanonicalVarKind::Ty(_) => true,\n+            CanonicalVarKind::PlaceholderTy(_) => false,\n+            CanonicalVarKind::Region(_) => true,\n+            CanonicalVarKind::PlaceholderRegion(..) => false,\n+            CanonicalVarKind::Const(_) => true,\n+            CanonicalVarKind::PlaceholderConst(_) => false,\n+        }\n+    }\n+}\n+\n+/// Describes the \"kind\" of the canonical variable. This is a \"kind\"\n+/// in the type-theory sense of the term -- i.e., a \"meta\" type system\n+/// that analyzes type-like values.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+pub enum CanonicalVarKind {\n+    /// Some kind of type inference variable.\n+    Ty(CanonicalTyVarKind),\n+\n+    /// A \"placeholder\" that represents \"any type\".\n+    PlaceholderTy(ty::PlaceholderType),\n+\n+    /// Region variable `'?R`.\n+    Region(ty::UniverseIndex),\n+\n+    /// A \"placeholder\" that represents \"any region\". Created when you\n+    /// are solving a goal like `for<'a> T: Foo<'a>` to represent the\n+    /// bound region `'a`.\n+    PlaceholderRegion(ty::PlaceholderRegion),\n+\n+    /// Some kind of const inference variable.\n+    Const(ty::UniverseIndex),\n+\n+    /// A \"placeholder\" that represents \"any const\".\n+    PlaceholderConst(ty::PlaceholderConst),\n+}\n+\n+impl CanonicalVarKind {\n+    pub fn universe(self) -> ty::UniverseIndex {\n+        match self {\n+            CanonicalVarKind::Ty(kind) => match kind {\n+                CanonicalTyVarKind::General(ui) => ui,\n+                CanonicalTyVarKind::Float | CanonicalTyVarKind::Int => ty::UniverseIndex::ROOT,\n+            },\n+\n+            CanonicalVarKind::PlaceholderTy(placeholder) => placeholder.universe,\n+            CanonicalVarKind::Region(ui) => ui,\n+            CanonicalVarKind::PlaceholderRegion(placeholder) => placeholder.universe,\n+            CanonicalVarKind::Const(ui) => ui,\n+            CanonicalVarKind::PlaceholderConst(placeholder) => placeholder.universe,\n+        }\n+    }\n+}\n+\n+/// Rust actually has more than one category of type variables;\n+/// notably, the type variables we create for literals (e.g., 22 or\n+/// 22.) can only be instantiated with integral/float types (e.g.,\n+/// usize or f32). In order to faithfully reproduce a type, we need to\n+/// know what set of types a given type variable can be unified with.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash, RustcDecodable, RustcEncodable, HashStable)]\n+pub enum CanonicalTyVarKind {\n+    /// General type variable `?T` that can be unified with arbitrary types.\n+    General(ty::UniverseIndex),\n+\n+    /// Integral type variable `?I` (that can only be unified with integral types).\n+    Int,\n+\n+    /// Floating-point type variable `?F` (that can only be unified with float types).\n+    Float,\n+}\n+\n+/// After we execute a query with a canonicalized key, we get back a\n+/// `Canonical<QueryResponse<..>>`. You can use\n+/// `instantiate_query_result` to access the data in this result.\n+#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n+pub struct QueryResponse<'tcx, R> {\n+    pub var_values: CanonicalVarValues<'tcx>,\n+    pub region_constraints: QueryRegionConstraints<'tcx>,\n+    pub certainty: Certainty,\n+    pub value: R,\n+}\n+\n+#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n+pub struct QueryRegionConstraints<'tcx> {\n+    pub outlives: Vec<QueryOutlivesConstraint<'tcx>>,\n+    pub member_constraints: Vec<MemberConstraint<'tcx>>,\n+}\n+\n+impl QueryRegionConstraints<'_> {\n+    /// Represents an empty (trivially true) set of region\n+    /// constraints.\n+    pub fn is_empty(&self) -> bool {\n+        self.outlives.is_empty() && self.member_constraints.is_empty()\n+    }\n+}\n+\n+pub type Canonicalized<'tcx, V> = Canonical<'tcx, V>;\n+\n+pub type CanonicalizedQueryResponse<'tcx, T> = &'tcx Canonical<'tcx, QueryResponse<'tcx, T>>;\n+\n+/// Indicates whether or not we were able to prove the query to be\n+/// true.\n+#[derive(Copy, Clone, Debug, HashStable)]\n+pub enum Certainty {\n+    /// The query is known to be true, presuming that you apply the\n+    /// given `var_values` and the region-constraints are satisfied.\n+    Proven,\n+\n+    /// The query is not known to be true, but also not known to be\n+    /// false. The `var_values` represent *either* values that must\n+    /// hold in order for the query to be true, or helpful tips that\n+    /// *might* make it true. Currently rustc's trait solver cannot\n+    /// distinguish the two (e.g., due to our preference for where\n+    /// clauses over impls).\n+    ///\n+    /// After some unifiations and things have been done, it makes\n+    /// sense to try and prove again -- of course, at that point, the\n+    /// canonical form will be different, making this a distinct\n+    /// query.\n+    Ambiguous,\n+}\n+\n+impl Certainty {\n+    pub fn is_proven(&self) -> bool {\n+        match self {\n+            Certainty::Proven => true,\n+            Certainty::Ambiguous => false,\n+        }\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> QueryResponse<'tcx, R> {\n+    pub fn is_proven(&self) -> bool {\n+        self.certainty.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, R> Canonical<'tcx, QueryResponse<'tcx, R>> {\n+    pub fn is_proven(&self) -> bool {\n+        self.value.is_proven()\n+    }\n+\n+    pub fn is_ambiguous(&self) -> bool {\n+        !self.is_proven()\n+    }\n+}\n+\n+impl<'tcx, V> Canonical<'tcx, V> {\n+    /// Allows you to map the `value` of a canonical while keeping the\n+    /// same set of bound variables.\n+    ///\n+    /// **WARNING:** This function is very easy to mis-use, hence the\n+    /// name!  In particular, the new value `W` must use all **the\n+    /// same type/region variables** in **precisely the same order**\n+    /// as the original! (The ordering is defined by the\n+    /// `TypeFoldable` implementation of the type in question.)\n+    ///\n+    /// An example of a **correct** use of this:\n+    ///\n+    /// ```rust,ignore (not real code)\n+    /// let a: Canonical<'_, T> = ...;\n+    /// let b: Canonical<'_, (T,)> = a.unchecked_map(|v| (v, ));\n+    /// ```\n+    ///\n+    /// An example of an **incorrect** use of this:\n+    ///\n+    /// ```rust,ignore (not real code)\n+    /// let a: Canonical<'tcx, T> = ...;\n+    /// let ty: Ty<'tcx> = ...;\n+    /// let b: Canonical<'tcx, (T, Ty<'tcx>)> = a.unchecked_map(|v| (v, ty));\n+    /// ```\n+    pub fn unchecked_map<W>(self, map_op: impl FnOnce(V) -> W) -> Canonical<'tcx, W> {\n+        let Canonical { max_universe, variables, value } = self;\n+        Canonical { max_universe, variables, value: map_op(value) }\n+    }\n+}\n+\n+pub type QueryOutlivesConstraint<'tcx> =\n+    ty::Binder<ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>;\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    crate::infer::canonical::Certainty,\n+    crate::infer::canonical::CanonicalVarInfo,\n+    crate::infer::canonical::CanonicalVarKind,\n+}\n+\n+CloneTypeFoldableImpls! {\n+    for <'tcx> {\n+        crate::infer::canonical::CanonicalVarInfos<'tcx>,\n+    }\n+}\n+\n+impl<'tcx> CanonicalVarValues<'tcx> {\n+    pub fn len(&self) -> usize {\n+        self.var_values.len()\n+    }\n+\n+    /// Makes an identity substitution from this one: each bound var\n+    /// is matched to the same bound var, preserving the original kinds.\n+    /// For example, if we have:\n+    /// `self.var_values == [Type(u32), Lifetime('a), Type(u64)]`\n+    /// we'll return a substitution `subst` with:\n+    /// `subst.var_values == [Type(^0), Lifetime(^1), Type(^2)]`.\n+    pub fn make_identity(&self, tcx: TyCtxt<'tcx>) -> Self {\n+        use crate::ty::subst::GenericArgKind;\n+\n+        CanonicalVarValues {\n+            var_values: self\n+                .var_values\n+                .iter()\n+                .zip(0..)\n+                .map(|(kind, i)| match kind.unpack() {\n+                    GenericArgKind::Type(..) => {\n+                        tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n+                    }\n+                    GenericArgKind::Lifetime(..) => tcx\n+                        .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion::BrAnon(i)))\n+                        .into(),\n+                    GenericArgKind::Const(ct) => tcx\n+                        .mk_const(ty::Const {\n+                            ty: ct.ty,\n+                            val: ty::ConstKind::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i)),\n+                        })\n+                        .into(),\n+                })\n+                .collect(),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> IntoIterator for &'a CanonicalVarValues<'tcx> {\n+    type Item = GenericArg<'tcx>;\n+    type IntoIter = ::std::iter::Cloned<::std::slice::Iter<'a, GenericArg<'tcx>>>;\n+\n+    fn into_iter(self) -> Self::IntoIter {\n+        self.var_values.iter().cloned()\n+    }\n+}\n+\n+impl<'tcx> Index<BoundVar> for CanonicalVarValues<'tcx> {\n+    type Output = GenericArg<'tcx>;\n+\n+    fn index(&self, value: BoundVar) -> &GenericArg<'tcx> {\n+        &self.var_values[value]\n+    }\n+}"}, {"sha": "534f4cb179c4f78eb7d2e5f183b55343e69fc74e", "filename": "src/librustc/infer/types/mod.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ftypes%2Fmod.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -0,0 +1,31 @@\n+pub mod canonical;\n+\n+use crate::ty::Region;\n+use crate::ty::Ty;\n+use rustc_data_structures::sync::Lrc;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::Span;\n+\n+/// Requires that `region` must be equal to one of the regions in `choice_regions`.\n+/// We often denote this using the syntax:\n+///\n+/// ```\n+/// R0 member of [O1..On]\n+/// ```\n+#[derive(Debug, Clone, HashStable, TypeFoldable, Lift)]\n+pub struct MemberConstraint<'tcx> {\n+    /// The `DefId` of the opaque type causing this constraint: used for error reporting.\n+    pub opaque_type_def_id: DefId,\n+\n+    /// The span where the hidden type was instantiated.\n+    pub definition_span: Span,\n+\n+    /// The hidden type in which `member_region` appears: used for error reporting.\n+    pub hidden_ty: Ty<'tcx>,\n+\n+    /// The region `R0`.\n+    pub member_region: Region<'tcx>,\n+\n+    /// The options `O1..On`.\n+    pub choice_regions: Lrc<Vec<Region<'tcx>>>,\n+}"}, {"sha": "d88188538fccb6998b99fb72dafdea71f2002ecd", "filename": "src/librustc/infer/unify_key.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Funify_key.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Finfer%2Funify_key.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Funify_key.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -12,6 +12,21 @@ pub trait ToType {\n     fn to_type<'tcx>(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx>;\n }\n \n+/// Raw `TyVid` are used as the unification key for `sub_relations`;\n+/// they carry no values.\n+impl UnifyKey for ty::TyVid {\n+    type Value = ();\n+    fn index(&self) -> u32 {\n+        self.index\n+    }\n+    fn from_index(i: u32) -> ty::TyVid {\n+        ty::TyVid { index: i }\n+    }\n+    fn tag() -> &'static str {\n+        \"TyVid\"\n+    }\n+}\n+\n impl UnifyKey for ty::IntVid {\n     type Value = Option<IntVarValue>;\n     fn index(&self) -> u32 {"}, {"sha": "d775393a808f74da948b3ec1aeb0ca2deae2587b", "filename": "src/librustc/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fauto_trait.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -9,6 +9,7 @@ use crate::ty::fold::TypeFolder;\n use crate::ty::{Region, RegionVid};\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use syntax::ast;\n \n use std::collections::hash_map::Entry;\n use std::collections::VecDeque;"}, {"sha": "e88f4e65c7eb11fca4c8327a8bb23435e925943a", "filename": "src/librustc/traits/mod.rs", "status": "modified", "additions": 6, "deletions": 684, "changes": 690, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fmod.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -19,31 +19,25 @@ mod select;\n mod specialize;\n mod structural_impls;\n mod structural_match;\n+mod types;\n mod util;\n pub mod wf;\n \n use crate::infer::outlives::env::OutlivesEnvironment;\n use crate::infer::{InferCtxt, SuppressRegionErrors};\n use crate::middle::region;\n-use crate::mir::interpret::ErrorHandled;\n use crate::ty::error::{ExpectedFound, TypeError};\n-use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::fold::TypeFoldable;\n use crate::ty::subst::{InternalSubsts, SubstsRef};\n-use crate::ty::{self, AdtKind, GenericParamDefKind, List, ToPredicate, Ty, TyCtxt, WithConstness};\n+use crate::ty::{self, GenericParamDefKind, ToPredicate, Ty, TyCtxt, WithConstness};\n use crate::util::common::ErrorReported;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_macros::HashStable;\n use rustc_span::{Span, DUMMY_SP};\n-use syntax::ast;\n \n use std::fmt::Debug;\n-use std::rc::Rc;\n \n pub use self::FulfillmentErrorCode::*;\n-pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n \n pub use self::coherence::{add_placeholder_note, orphan_check, overlapping_impls};\n pub use self::coherence::{OrphanCheckErr, OverlapResult};\n@@ -57,9 +51,8 @@ pub use self::object_safety::ObjectSafetyViolation;\n pub use self::on_unimplemented::{OnUnimplementedDirective, OnUnimplementedNote};\n pub use self::project::MismatchedProjectionTypes;\n pub use self::project::{normalize, normalize_projection_type, poly_project_and_unify_type};\n-pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot, Reveal};\n-pub use self::select::{EvaluationCache, SelectionCache, SelectionContext};\n-pub use self::select::{EvaluationResult, IntercrateAmbiguityCause, OverflowError};\n+pub use self::project::{Normalized, ProjectionCache, ProjectionCacheSnapshot};\n+pub use self::select::{IntercrateAmbiguityCause, SelectionContext};\n pub use self::specialize::find_associated_item;\n pub use self::specialize::specialization_graph::FutureCompatOverlapError;\n pub use self::specialize::specialization_graph::FutureCompatOverlapErrorKind;\n@@ -81,10 +74,7 @@ pub use self::chalk_fulfill::{\n     CanonicalGoal as ChalkCanonicalGoal, FulfillmentContext as ChalkFulfillmentContext,\n };\n \n-pub use self::FulfillmentErrorCode::*;\n-pub use self::ObligationCauseCode::*;\n-pub use self::SelectionError::*;\n-pub use self::Vtable::*;\n+pub use self::types::*;\n \n /// Whether to enable bug compatibility with issue #43355.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n@@ -138,392 +128,12 @@ pub type TraitObligation<'tcx> = Obligation<'tcx, ty::PolyTraitPredicate<'tcx>>;\n #[cfg(target_arch = \"x86_64\")]\n static_assert_size!(PredicateObligation<'_>, 112);\n \n-/// The reason why we incurred this obligation; used for error reporting.\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct ObligationCause<'tcx> {\n-    pub span: Span,\n-\n-    /// The ID of the fn body that triggered this obligation. This is\n-    /// used for region obligations to determine the precise\n-    /// environment in which the region obligation should be evaluated\n-    /// (in particular, closures can add new assumptions). See the\n-    /// field `region_obligations` of the `FulfillmentContext` for more\n-    /// information.\n-    pub body_id: hir::HirId,\n-\n-    pub code: ObligationCauseCode<'tcx>,\n-}\n-\n-impl ObligationCause<'_> {\n-    pub fn span(&self, tcx: TyCtxt<'_>) -> Span {\n-        match self.code {\n-            ObligationCauseCode::CompareImplMethodObligation { .. }\n-            | ObligationCauseCode::MainFunctionType\n-            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n-            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n-                arm_span,\n-                ..\n-            }) => arm_span,\n-            _ => self.span,\n-        }\n-    }\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub enum ObligationCauseCode<'tcx> {\n-    /// Not well classified or should be obvious from the span.\n-    MiscObligation,\n-\n-    /// A slice or array is WF only if `T: Sized`.\n-    SliceOrArrayElem,\n-\n-    /// A tuple is WF only if its middle elements are `Sized`.\n-    TupleElem,\n-\n-    /// This is the trait reference from the given projection.\n-    ProjectionWf(ty::ProjectionTy<'tcx>),\n-\n-    /// In an impl of trait `X` for type `Y`, type `Y` must\n-    /// also implement all supertraits of `X`.\n-    ItemObligation(DefId),\n-\n-    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n-    BindingObligation(DefId, Span),\n-\n-    /// A type like `&'a T` is WF only if `T: 'a`.\n-    ReferenceOutlivesReferent(Ty<'tcx>),\n-\n-    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n-    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n-\n-    /// Obligation incurred due to an object cast.\n-    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n-\n-    /// Obligation incurred due to a coercion.\n-    Coercion {\n-        source: Ty<'tcx>,\n-        target: Ty<'tcx>,\n-    },\n-\n-    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n-    /// `L = X` implies that `L` is `Sized`.\n-    AssignmentLhsSized,\n-    /// `(x1, .., xn)` must be `Sized`.\n-    TupleInitializerSized,\n-    /// `S { ... }` must be `Sized`.\n-    StructInitializerSized,\n-    /// Type of each variable must be `Sized`.\n-    VariableType(hir::HirId),\n-    /// Argument type must be `Sized`.\n-    SizedArgumentType,\n-    /// Return type must be `Sized`.\n-    SizedReturnType,\n-    /// Yield type must be `Sized`.\n-    SizedYieldType,\n-    /// `[T, ..n]` implies that `T` must be `Copy`.\n-    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n-    RepeatVec(bool),\n-\n-    /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n-    FieldSized {\n-        adt_kind: AdtKind,\n-        last: bool,\n-    },\n-\n-    /// Constant expressions must be sized.\n-    ConstSized,\n-\n-    /// `static` items must have `Sync` type.\n-    SharedStatic,\n-\n-    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n-\n-    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplMethodObligation {\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Error derived when matching traits/impls; see ObligationCause for more details\n-    CompareImplTypeObligation {\n-        item_name: ast::Name,\n-        impl_item_def_id: DefId,\n-        trait_item_def_id: DefId,\n-    },\n-\n-    /// Checking that this expression can be assigned where it needs to be\n-    // FIXME(eddyb) #11161 is the original Expr required?\n-    ExprAssignable,\n-\n-    /// Computing common supertype in the arms of a match expression\n-    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n-\n-    /// Type error arising from type checking a pattern against an expected type.\n-    Pattern {\n-        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n-        span: Option<Span>,\n-        /// The root expected type induced by a scrutinee or type expression.\n-        root_ty: Ty<'tcx>,\n-        /// Whether the `Span` came from an expression or a type expression.\n-        origin_expr: bool,\n-    },\n-\n-    /// Constants in patterns must have `Structural` type.\n-    ConstPatternStructural,\n-\n-    /// Computing common supertype in an if expression\n-    IfExpression(Box<IfExpressionCause>),\n-\n-    /// Computing common supertype of an if expression with no else counter-part\n-    IfExpressionWithNoElse,\n-\n-    /// `main` has wrong type\n-    MainFunctionType,\n-\n-    /// `start` has wrong type\n-    StartFunctionType,\n-\n-    /// Intrinsic has wrong type\n-    IntrinsicType,\n-\n-    /// Method receiver\n-    MethodReceiver,\n-\n-    /// `return` with no expression\n-    ReturnNoExpression,\n-\n-    /// `return` with an expression\n-    ReturnValue(hir::HirId),\n-\n-    /// Return type of this function\n-    ReturnType,\n-\n-    /// Block implicit return\n-    BlockTailExpression(hir::HirId),\n-\n-    /// #[feature(trivial_bounds)] is not enabled\n-    TrivialBound,\n-\n-    AssocTypeBound(Box<AssocTypeBoundData>),\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct AssocTypeBoundData {\n-    pub impl_span: Option<Span>,\n-    pub original: Span,\n-    pub bounds: Vec<Span>,\n-}\n-\n-// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n-#[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(ObligationCauseCode<'_>, 32);\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct MatchExpressionArmCause<'tcx> {\n-    pub arm_span: Span,\n-    pub source: hir::MatchSource,\n-    pub prior_arms: Vec<Span>,\n-    pub last_ty: Ty<'tcx>,\n-    pub scrut_hir_id: hir::HirId,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct IfExpressionCause {\n-    pub then: Span,\n-    pub outer: Option<Span>,\n-    pub semicolon: Option<Span>,\n-}\n-\n-#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n-pub struct DerivedObligationCause<'tcx> {\n-    /// The trait reference of the parent obligation that led to the\n-    /// current obligation. Note that only trait obligations lead to\n-    /// derived obligations, so we just store the trait reference here\n-    /// directly.\n-    parent_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n-    /// The parent trait had this cause.\n-    parent_code: Rc<ObligationCauseCode<'tcx>>,\n-}\n-\n pub type Obligations<'tcx, O> = Vec<Obligation<'tcx, O>>;\n pub type PredicateObligations<'tcx> = Vec<PredicateObligation<'tcx>>;\n pub type TraitObligations<'tcx> = Vec<TraitObligation<'tcx>>;\n \n-/// The following types:\n-/// * `WhereClause`,\n-/// * `WellFormed`,\n-/// * `FromEnv`,\n-/// * `DomainGoal`,\n-/// * `Goal`,\n-/// * `Clause`,\n-/// * `Environment`,\n-/// * `InEnvironment`,\n-/// are used for representing the trait system in the form of\n-/// logic programming clauses. They are part of the interface\n-/// for the chalk SLG solver.\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WhereClause<'tcx> {\n-    Implemented(ty::TraitPredicate<'tcx>),\n-    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n-    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n-    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum WellFormed<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum FromEnv<'tcx> {\n-    Trait(ty::TraitPredicate<'tcx>),\n-    Ty(Ty<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum DomainGoal<'tcx> {\n-    Holds(WhereClause<'tcx>),\n-    WellFormed(WellFormed<'tcx>),\n-    FromEnv(FromEnv<'tcx>),\n-    Normalize(ty::ProjectionPredicate<'tcx>),\n-}\n-\n-pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum QuantifierKind {\n-    Universal,\n-    Existential,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n-pub enum GoalKind<'tcx> {\n-    Implies(Clauses<'tcx>, Goal<'tcx>),\n-    And(Goal<'tcx>, Goal<'tcx>),\n-    Not(Goal<'tcx>),\n-    DomainGoal(DomainGoal<'tcx>),\n-    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n-    Subtype(Ty<'tcx>, Ty<'tcx>),\n-    CannotProve,\n-}\n-\n-pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n-\n-pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n-\n-impl<'tcx> DomainGoal<'tcx> {\n-    pub fn into_goal(self) -> GoalKind<'tcx> {\n-        GoalKind::DomainGoal(self)\n-    }\n-\n-    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n-        ProgramClause {\n-            goal: self,\n-            hypotheses: ty::List::empty(),\n-            category: ProgramClauseCategory::Other,\n-        }\n-    }\n-}\n-\n-impl<'tcx> GoalKind<'tcx> {\n-    pub fn from_poly_domain_goal(\n-        domain_goal: PolyDomainGoal<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> GoalKind<'tcx> {\n-        match domain_goal.no_bound_vars() {\n-            Some(p) => p.into_goal(),\n-            None => GoalKind::Quantified(\n-                QuantifierKind::Universal,\n-                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n-            ),\n-        }\n-    }\n-}\n-\n-/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n-/// Harrop Formulas\".\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub enum Clause<'tcx> {\n-    Implies(ProgramClause<'tcx>),\n-    ForAll(ty::Binder<ProgramClause<'tcx>>),\n-}\n-\n-impl Clause<'tcx> {\n-    pub fn category(self) -> ProgramClauseCategory {\n-        match self {\n-            Clause::Implies(clause) => clause.category,\n-            Clause::ForAll(clause) => clause.skip_binder().category,\n-        }\n-    }\n-}\n-\n-/// Multiple clauses.\n-pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n-\n-/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n-/// that the domain goal `D` is true if `G1...Gn` are provable. This\n-/// is equivalent to the implication `G1..Gn => D`; we usually write\n-/// it with the reverse implication operator `:-` to emphasize the way\n-/// that programs are actually solved (via backchaining, which starts\n-/// with the goal to solve and proceeds from there).\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct ProgramClause<'tcx> {\n-    /// This goal will be considered true ...\n-    pub goal: DomainGoal<'tcx>,\n-\n-    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n-    pub hypotheses: Goals<'tcx>,\n-\n-    /// Useful for filtering clauses.\n-    pub category: ProgramClauseCategory,\n-}\n-\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n-pub enum ProgramClauseCategory {\n-    ImpliedBound,\n-    WellFormed,\n-    Other,\n-}\n-\n-/// A set of clauses that we assume to be true.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct Environment<'tcx> {\n-    pub clauses: Clauses<'tcx>,\n-}\n-\n-impl Environment<'tcx> {\n-    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n-        InEnvironment { environment: self, goal }\n-    }\n-}\n-\n-/// Something (usually a goal), along with an environment.\n-#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n-pub struct InEnvironment<'tcx, G> {\n-    pub environment: Environment<'tcx>,\n-    pub goal: G,\n-}\n-\n pub type Selection<'tcx> = Vtable<'tcx, PredicateObligation<'tcx>>;\n \n-#[derive(Clone, Debug, TypeFoldable)]\n-pub enum SelectionError<'tcx> {\n-    Unimplemented,\n-    OutputTypeParameterMismatch(\n-        ty::PolyTraitRef<'tcx>,\n-        ty::PolyTraitRef<'tcx>,\n-        ty::error::TypeError<'tcx>,\n-    ),\n-    TraitNotObjectSafe(DefId),\n-    ConstEvalFailure(ErrorHandled),\n-    Overflow,\n-}\n-\n pub struct FulfillmentError<'tcx> {\n     pub obligation: PredicateObligation<'tcx>,\n     pub code: FulfillmentErrorCode<'tcx>,\n@@ -541,164 +151,6 @@ pub enum FulfillmentErrorCode<'tcx> {\n     CodeAmbiguity,\n }\n \n-/// When performing resolution, it is typically the case that there\n-/// can be one of three outcomes:\n-///\n-/// - `Ok(Some(r))`: success occurred with result `r`\n-/// - `Ok(None)`: could not definitely determine anything, usually due\n-///   to inconclusive type inference.\n-/// - `Err(e)`: error `e` occurred\n-pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n-\n-/// Given the successful resolution of an obligation, the `Vtable`\n-/// indicates where the vtable comes from. Note that while we call this\n-/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n-/// runtime. `Vtable` instances just tell the compiler where to find\n-/// methods, but in generic code those methods are typically statically\n-/// dispatched -- only when an object is constructed is a `Vtable`\n-/// instance reified into an actual vtable.\n-///\n-/// For example, the vtable may be tied to a specific impl (case A),\n-/// or it may be relative to some bound that is in scope (case B).\n-///\n-/// ```\n-/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n-/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n-/// impl Clone for int { ... }             // Impl_3\n-///\n-/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n-///                 param: T,\n-///                 mixed: Option<T>) {\n-///\n-///    // Case A: Vtable points at a specific impl. Only possible when\n-///    // type is concretely known. If the impl itself has bounded\n-///    // type parameters, Vtable will carry resolutions for those as well:\n-///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n-///\n-///    // Case B: Vtable must be provided by caller. This applies when\n-///    // type is a type parameter.\n-///    param.clone();    // VtableParam\n-///\n-///    // Case C: A mix of cases A and B.\n-///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n-/// }\n-/// ```\n-///\n-/// ### The type parameter `N`\n-///\n-/// See explanation on `VtableImplData`.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub enum Vtable<'tcx, N> {\n-    /// Vtable identifying a particular impl.\n-    VtableImpl(VtableImplData<'tcx, N>),\n-\n-    /// Vtable for auto trait implementations.\n-    /// This carries the information and nested obligations with regards\n-    /// to an auto implementation for a trait `Trait`. The nested obligations\n-    /// ensure the trait implementation holds for all the constituent types.\n-    VtableAutoImpl(VtableAutoImplData<N>),\n-\n-    /// Successful resolution to an obligation provided by the caller\n-    /// for some type parameter. The `Vec<N>` represents the\n-    /// obligations incurred from normalizing the where-clause (if\n-    /// any).\n-    VtableParam(Vec<N>),\n-\n-    /// Virtual calls through an object.\n-    VtableObject(VtableObjectData<'tcx, N>),\n-\n-    /// Successful resolution for a builtin trait.\n-    VtableBuiltin(VtableBuiltinData<N>),\n-\n-    /// Vtable automatically generated for a closure. The `DefId` is the ID\n-    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n-    /// impl is generated by the compiler and does not appear in the source.\n-    VtableClosure(VtableClosureData<'tcx, N>),\n-\n-    /// Same as above, but for a function pointer type with the given signature.\n-    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n-\n-    /// Vtable automatically generated for a generator.\n-    VtableGenerator(VtableGeneratorData<'tcx, N>),\n-\n-    /// Vtable for a trait alias.\n-    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n-}\n-\n-/// Identifies a particular impl in the source, along with a set of\n-/// substitutions from the impl's type/lifetime parameters. The\n-/// `nested` vector corresponds to the nested obligations attached to\n-/// the impl's type parameters.\n-///\n-/// The type parameter `N` indicates the type used for \"nested\n-/// obligations\" that are required by the impl. During type-check, this\n-/// is `Obligation`, as one might expect. During codegen, however, this\n-/// is `()`, because codegen only requires a shallow resolution of an\n-/// impl, and nested obligations are satisfied later.\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableImplData<'tcx, N> {\n-    pub impl_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableGeneratorData<'tcx, N> {\n-    pub generator_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the generator\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableClosureData<'tcx, N> {\n-    pub closure_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    /// Nested obligations. This can be non-empty if the closure\n-    /// signature contains associated types.\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableAutoImplData<N> {\n-    pub trait_def_id: DefId,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableBuiltinData<N> {\n-    pub nested: Vec<N>,\n-}\n-\n-/// A vtable for some object-safe trait `Foo` automatically derived\n-/// for the object type `Foo`.\n-#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableObjectData<'tcx, N> {\n-    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n-    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n-\n-    /// The vtable is formed by concatenating together the method lists of\n-    /// the base object trait and all supertraits; this is the start of\n-    /// `upcast_trait_ref`'s methods in that vtable.\n-    pub vtable_base: usize,\n-\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableFnPointerData<'tcx, N> {\n-    pub fn_ty: Ty<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n-pub struct VtableTraitAliasData<'tcx, N> {\n-    pub alias_def_id: DefId,\n-    pub substs: SubstsRef<'tcx>,\n-    pub nested: Vec<N>,\n-}\n-\n /// Creates predicate obligations from the generic bounds.\n pub fn predicates_for_generics<'tcx>(\n     cause: ObligationCause<'tcx>,\n@@ -1147,97 +599,6 @@ impl<'tcx, O> Obligation<'tcx, O> {\n     }\n }\n \n-impl<'tcx> ObligationCause<'tcx> {\n-    #[inline]\n-    pub fn new(\n-        span: Span,\n-        body_id: hir::HirId,\n-        code: ObligationCauseCode<'tcx>,\n-    ) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id, code }\n-    }\n-\n-    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n-        ObligationCause { span, body_id, code: MiscObligation }\n-    }\n-\n-    pub fn dummy() -> ObligationCause<'tcx> {\n-        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n-    }\n-}\n-\n-impl ObligationCauseCode<'_> {\n-    // Return the base obligation, ignoring derived obligations.\n-    pub fn peel_derives(&self) -> &Self {\n-        let mut base_cause = self;\n-        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n-            base_cause = &cause.parent_code;\n-        }\n-        base_cause\n-    }\n-}\n-\n-impl<'tcx, N> Vtable<'tcx, N> {\n-    pub fn nested_obligations(self) -> Vec<N> {\n-        match self {\n-            VtableImpl(i) => i.nested,\n-            VtableParam(n) => n,\n-            VtableBuiltin(i) => i.nested,\n-            VtableAutoImpl(d) => d.nested,\n-            VtableClosure(c) => c.nested,\n-            VtableGenerator(c) => c.nested,\n-            VtableObject(d) => d.nested,\n-            VtableFnPointer(d) => d.nested,\n-            VtableTraitAlias(d) => d.nested,\n-        }\n-    }\n-\n-    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n-    where\n-        F: FnMut(N) -> M,\n-    {\n-        match self {\n-            VtableImpl(i) => VtableImpl(VtableImplData {\n-                impl_def_id: i.impl_def_id,\n-                substs: i.substs,\n-                nested: i.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n-            VtableBuiltin(i) => {\n-                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n-            }\n-            VtableObject(o) => VtableObject(VtableObjectData {\n-                upcast_trait_ref: o.upcast_trait_ref,\n-                vtable_base: o.vtable_base,\n-                nested: o.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n-                trait_def_id: d.trait_def_id,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableClosure(c) => VtableClosure(VtableClosureData {\n-                closure_def_id: c.closure_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n-                generator_def_id: c.generator_def_id,\n-                substs: c.substs,\n-                nested: c.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n-                fn_ty: p.fn_ty,\n-                nested: p.nested.into_iter().map(f).collect(),\n-            }),\n-            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n-                alias_def_id: d.alias_def_id,\n-                substs: d.substs,\n-                nested: d.nested.into_iter().map(f).collect(),\n-            }),\n-        }\n-    }\n-}\n-\n impl<'tcx> FulfillmentError<'tcx> {\n     fn new(\n         obligation: PredicateObligation<'tcx>,\n@@ -1265,42 +626,3 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         ..*providers\n     };\n }\n-\n-pub trait ExClauseFold<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        folder: &mut F,\n-    ) -> chalk_engine::ExClause<Self>;\n-\n-    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        visitor: &mut V,\n-    ) -> bool;\n-}\n-\n-pub trait ChalkContextLift<'tcx>\n-where\n-    Self: chalk_engine::context::Context + Clone,\n-{\n-    type LiftedExClause: Debug + 'tcx;\n-    type LiftedDelayedLiteral: Debug + 'tcx;\n-    type LiftedLiteral: Debug + 'tcx;\n-\n-    fn lift_ex_clause_to_tcx(\n-        ex_clause: &chalk_engine::ExClause<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedExClause>;\n-\n-    fn lift_delayed_literal_to_tcx(\n-        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedDelayedLiteral>;\n-\n-    fn lift_literal_to_tcx(\n-        ex_clause: &chalk_engine::Literal<Self>,\n-        tcx: TyCtxt<'tcx>,\n-    ) -> Option<Self::LiftedLiteral>;\n-}"}, {"sha": "fffcf66075f932b7c7590e5974402a953a79aeb5", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 1, "deletions": 42, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -19,52 +19,11 @@ use crate::ty::subst::{InternalSubsts, Subst};\n use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, WithConstness};\n use rustc_data_structures::snapshot_map::{Snapshot, SnapshotMap};\n use rustc_hir::def_id::DefId;\n-use rustc_macros::HashStable;\n use rustc_span::symbol::sym;\n use rustc_span::DUMMY_SP;\n use syntax::ast::Ident;\n \n-/// Depending on the stage of compilation, we want projection to be\n-/// more or less conservative.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n-pub enum Reveal {\n-    /// At type-checking time, we refuse to project any associated\n-    /// type that is marked `default`. Non-`default` (\"final\") types\n-    /// are always projected. This is necessary in general for\n-    /// soundness of specialization. However, we *could* allow\n-    /// projections in fully-monomorphic cases. We choose not to,\n-    /// because we prefer for `default type` to force the type\n-    /// definition to be treated abstractly by any consumers of the\n-    /// impl. Concretely, that means that the following example will\n-    /// fail to compile:\n-    ///\n-    /// ```\n-    /// trait Assoc {\n-    ///     type Output;\n-    /// }\n-    ///\n-    /// impl<T> Assoc for T {\n-    ///     default type Output = bool;\n-    /// }\n-    ///\n-    /// fn main() {\n-    ///     let <() as Assoc>::Output = true;\n-    /// }\n-    UserFacing,\n-\n-    /// At codegen time, all monomorphic projections will succeed.\n-    /// Also, `impl Trait` is normalized to the concrete type,\n-    /// which has to be already collected by type-checking.\n-    ///\n-    /// NOTE: as `impl Trait`'s concrete type should *never*\n-    /// be observable directly by the user, `Reveal::All`\n-    /// should not be used by checks which may expose\n-    /// type equality or type contents to the user.\n-    /// There are some exceptions, e.g., around OIBITS and\n-    /// transmute-checking, which expose some details, but\n-    /// not the whole concrete type of the `impl Trait`.\n-    All,\n-}\n+pub use rustc::traits::Reveal;\n \n pub type PolyProjectionObligation<'tcx> = Obligation<'tcx, ty::PolyProjectionPredicate<'tcx>>;\n "}, {"sha": "a1d7a2836e42d3c032f5a165bea61a95e2b2c6d7", "filename": "src/librustc/traits/query/dropck_outlives.rs", "status": "modified", "additions": 5, "deletions": 74, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fdropck_outlives.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -1,10 +1,11 @@\n use crate::infer::at::At;\n use crate::infer::canonical::OriginalQueryValues;\n use crate::infer::InferOk;\n-use crate::ty::subst::GenericArg;\n-use crate::ty::{self, Ty, TyCtxt};\n-use rustc_span::source_map::Span;\n-use std::iter::FromIterator;\n+\n+use rustc::ty::subst::GenericArg;\n+use rustc::ty::{self, Ty, TyCtxt};\n+\n+pub use rustc::traits::query::{DropckOutlivesResult, DtorckConstraint};\n \n impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Given a type `ty` of some value being dropped, computes a set\n@@ -65,76 +66,6 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     }\n }\n \n-#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n-pub struct DropckOutlivesResult<'tcx> {\n-    pub kinds: Vec<GenericArg<'tcx>>,\n-    pub overflows: Vec<Ty<'tcx>>,\n-}\n-\n-impl<'tcx> DropckOutlivesResult<'tcx> {\n-    pub fn report_overflows(&self, tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n-        if let Some(overflow_ty) = self.overflows.iter().next() {\n-            rustc_errors::struct_span_err!(\n-                tcx.sess,\n-                span,\n-                E0320,\n-                \"overflow while adding drop-check rules for {}\",\n-                ty,\n-            )\n-            .note(&format!(\"overflowed on {}\", overflow_ty))\n-            .emit();\n-        }\n-    }\n-\n-    pub fn into_kinds_reporting_overflows(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        span: Span,\n-        ty: Ty<'tcx>,\n-    ) -> Vec<GenericArg<'tcx>> {\n-        self.report_overflows(tcx, span, ty);\n-        let DropckOutlivesResult { kinds, overflows: _ } = self;\n-        kinds\n-    }\n-}\n-\n-/// A set of constraints that need to be satisfied in order for\n-/// a type to be valid for destruction.\n-#[derive(Clone, Debug, HashStable)]\n-pub struct DtorckConstraint<'tcx> {\n-    /// Types that are required to be alive in order for this\n-    /// type to be valid for destruction.\n-    pub outlives: Vec<ty::subst::GenericArg<'tcx>>,\n-\n-    /// Types that could not be resolved: projections and params.\n-    pub dtorck_types: Vec<Ty<'tcx>>,\n-\n-    /// If, during the computation of the dtorck constraint, we\n-    /// overflow, that gets recorded here. The caller is expected to\n-    /// report an error.\n-    pub overflows: Vec<Ty<'tcx>>,\n-}\n-\n-impl<'tcx> DtorckConstraint<'tcx> {\n-    pub fn empty() -> DtorckConstraint<'tcx> {\n-        DtorckConstraint { outlives: vec![], dtorck_types: vec![], overflows: vec![] }\n-    }\n-}\n-\n-impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n-    fn from_iter<I: IntoIterator<Item = DtorckConstraint<'tcx>>>(iter: I) -> Self {\n-        let mut result = Self::empty();\n-\n-        for DtorckConstraint { outlives, dtorck_types, overflows } in iter {\n-            result.outlives.extend(outlives);\n-            result.dtorck_types.extend(dtorck_types);\n-            result.overflows.extend(overflows);\n-        }\n-\n-        result\n-    }\n-}\n-\n /// This returns true if the type `ty` is \"trivial\" for\n /// dropck-outlives -- that is, if it doesn't require any types to\n /// outlive. This is similar but not *quite* the same as the"}, {"sha": "80748c5ef388efe15f3109b5f6990e9e6517896c", "filename": "src/librustc/traits/query/method_autoderef.rs", "status": "modified", "additions": 1, "deletions": 33, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmethod_autoderef.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -1,33 +1 @@\n-use crate::infer::canonical::{Canonical, QueryResponse};\n-use crate::ty::Ty;\n-use rustc_data_structures::sync::Lrc;\n-\n-#[derive(Debug, HashStable)]\n-pub struct CandidateStep<'tcx> {\n-    pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n-    pub autoderefs: usize,\n-    /// `true` if the type results from a dereference of a raw pointer.\n-    /// when assembling candidates, we include these steps, but not when\n-    /// picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n-    /// `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n-    /// `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n-    pub from_unsafe_deref: bool,\n-    pub unsize: bool,\n-}\n-\n-#[derive(Clone, Debug, HashStable)]\n-pub struct MethodAutoderefStepsResult<'tcx> {\n-    /// The valid autoderef steps that could be find.\n-    pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n-    /// If Some(T), a type autoderef reported an error on.\n-    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>,\n-    /// If `true`, `steps` has been truncated due to reaching the\n-    /// recursion limit.\n-    pub reached_recursion_limit: bool,\n-}\n-\n-#[derive(Debug, HashStable)]\n-pub struct MethodAutoderefBadTy<'tcx> {\n-    pub reached_raw_pointer: bool,\n-    pub ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n-}\n+pub use rustc::traits::query::{CandidateStep, MethodAutoderefBadTy, MethodAutoderefStepsResult};"}, {"sha": "20a873dc4c6b6692e69730db871580fb0be8ef3f", "filename": "src/librustc/traits/query/mod.rs", "status": "modified", "additions": 1, "deletions": 36, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fmod.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -5,46 +5,11 @@\n //! The providers for the queries defined here can be found in\n //! `librustc_traits`.\n \n-use crate::infer::canonical::Canonical;\n-use crate::ty::error::TypeError;\n-use crate::ty::{self, Ty};\n-\n pub mod dropck_outlives;\n pub mod evaluate_obligation;\n pub mod method_autoderef;\n pub mod normalize;\n pub mod outlives_bounds;\n pub mod type_op;\n \n-pub type CanonicalProjectionGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n-\n-pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n-\n-pub type CanonicalPredicateGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>>;\n-\n-pub type CanonicalTypeOpAscribeUserTypeGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::ascribe_user_type::AscribeUserType<'tcx>>>;\n-\n-pub type CanonicalTypeOpEqGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::eq::Eq<'tcx>>>;\n-\n-pub type CanonicalTypeOpSubtypeGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::subtype::Subtype<'tcx>>>;\n-\n-pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::prove_predicate::ProvePredicate<'tcx>>>;\n-\n-pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n-    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::normalize::Normalize<T>>>;\n-\n-#[derive(Clone, Debug, HashStable)]\n-pub struct NoSolution;\n-\n-pub type Fallible<T> = Result<T, NoSolution>;\n-\n-impl<'tcx> From<TypeError<'tcx>> for NoSolution {\n-    fn from(_: TypeError<'tcx>) -> NoSolution {\n-        NoSolution\n-    }\n-}\n+pub use rustc::traits::types::query::*;"}, {"sha": "737b4fc6bb9dc4a2b994106337af6226db8b6ce2", "filename": "src/librustc/traits/query/normalize.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Fnormalize.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -13,6 +13,8 @@ use crate::ty::{self, Ty, TyCtxt};\n \n use super::NoSolution;\n \n+pub use rustc::traits::query::NormalizationResult;\n+\n impl<'cx, 'tcx> At<'cx, 'tcx> {\n     /// Normalize `value` in the context of the inference context,\n     /// yielding a resulting type, or an error if `value` cannot be\n@@ -59,13 +61,6 @@ impl<'cx, 'tcx> At<'cx, 'tcx> {\n     }\n }\n \n-/// Result from the `normalize_projection_ty` query.\n-#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n-pub struct NormalizationResult<'tcx> {\n-    /// Result of normalization.\n-    pub normalized_ty: Ty<'tcx>,\n-}\n-\n struct QueryNormalizer<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n     cause: &'cx ObligationCause<'tcx>,"}, {"sha": "594faffa5f3aa3b9ea4f3b8bd34824af03f0a3f8", "filename": "src/librustc/traits/query/outlives_bounds.rs", "status": "modified", "additions": 1, "deletions": 37, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Foutlives_bounds.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -6,43 +6,7 @@ use crate::ty::{self, Ty};\n use rustc_hir as hir;\n use rustc_span::source_map::Span;\n \n-use crate::ich::StableHashingContext;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use std::mem;\n-\n-/// Outlives bounds are relationships between generic parameters,\n-/// whether they both be regions (`'a: 'b`) or whether types are\n-/// involved (`T: 'a`). These relationships can be extracted from the\n-/// full set of predicates we understand or also from types (in which\n-/// case they are called implied bounds). They are fed to the\n-/// `OutlivesEnv` which in turn is supplied to the region checker and\n-/// other parts of the inference system.\n-#[derive(Clone, Debug, TypeFoldable, Lift)]\n-pub enum OutlivesBound<'tcx> {\n-    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n-    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n-    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n-}\n-\n-impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        mem::discriminant(self).hash_stable(hcx, hasher);\n-        match *self {\n-            OutlivesBound::RegionSubRegion(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            OutlivesBound::RegionSubParam(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-            OutlivesBound::RegionSubProjection(ref a, ref b) => {\n-                a.hash_stable(hcx, hasher);\n-                b.hash_stable(hcx, hasher);\n-            }\n-        }\n-    }\n-}\n+pub use rustc::traits::query::OutlivesBound;\n \n impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n     /// Implied bounds are region relationships that we deduce"}, {"sha": "b14b79f090778fbb230369539b1e41848b92368c", "filename": "src/librustc/traits/query/type_op/ascribe_user_type.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fascribe_user_type.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -1,21 +1,8 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::subst::UserSubsts;\n-use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n-use rustc_hir::def_id::DefId;\n+use rustc::ty::{ParamEnvAnd, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct AscribeUserType<'tcx> {\n-    pub mir_ty: Ty<'tcx>,\n-    pub def_id: DefId,\n-    pub user_substs: UserSubsts<'tcx>,\n-}\n-\n-impl<'tcx> AscribeUserType<'tcx> {\n-    pub fn new(mir_ty: Ty<'tcx>, def_id: DefId, user_substs: UserSubsts<'tcx>) -> Self {\n-        Self { mir_ty, def_id, user_substs }\n-    }\n-}\n+pub use rustc::traits::query::type_op::AscribeUserType;\n \n impl<'tcx> super::QueryTypeOp<'tcx> for AscribeUserType<'tcx> {\n     type QueryResponse = ();"}, {"sha": "1de13430d4623707fe551e1e21b427baea789c81", "filename": "src/librustc/traits/query/type_op/eq.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Feq.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -1,18 +1,8 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::{ParamEnvAnd, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct Eq<'tcx> {\n-    pub a: Ty<'tcx>,\n-    pub b: Ty<'tcx>,\n-}\n-\n-impl<'tcx> Eq<'tcx> {\n-    pub fn new(a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n-        Self { a, b }\n-    }\n-}\n+pub use rustc::traits::query::type_op::Eq;\n \n impl<'tcx> super::QueryTypeOp<'tcx> for Eq<'tcx> {\n     type QueryResponse = ();"}, {"sha": "2d03d77cf6645fd4517eaff69f11394ca54fbc2a", "filename": "src/librustc/traits/query/type_op/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fmod.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -19,6 +19,8 @@ pub mod prove_predicate;\n use self::prove_predicate::ProvePredicate;\n pub mod subtype;\n \n+pub use crate::traits::types::query::type_op::*;\n+\n /// \"Type ops\" are used in NLL to perform some particular action and\n /// extract out the resulting region constraints (or an error if it\n /// cannot be completed)."}, {"sha": "b1e0e29620df6b132ec7cb20a00422868d495ffb", "filename": "src/librustc/traits/query/type_op/normalize.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fnormalize.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -4,19 +4,7 @@ use crate::ty::fold::TypeFoldable;\n use crate::ty::{self, Lift, ParamEnvAnd, Ty, TyCtxt};\n use std::fmt;\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct Normalize<T> {\n-    pub value: T,\n-}\n-\n-impl<'tcx, T> Normalize<T>\n-where\n-    T: fmt::Debug + TypeFoldable<'tcx>,\n-{\n-    pub fn new(value: T) -> Self {\n-        Self { value }\n-    }\n-}\n+pub use rustc::traits::query::type_op::Normalize;\n \n impl<'tcx, T> super::QueryTypeOp<'tcx> for Normalize<T>\n where"}, {"sha": "92cfb82e27e953a97afce53868dec46d5daf247a", "filename": "src/librustc/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -2,16 +2,7 @@ use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n use crate::ty::{ParamEnvAnd, Predicate, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct ProvePredicate<'tcx> {\n-    pub predicate: Predicate<'tcx>,\n-}\n-\n-impl<'tcx> ProvePredicate<'tcx> {\n-    pub fn new(predicate: Predicate<'tcx>) -> Self {\n-        ProvePredicate { predicate }\n-    }\n-}\n+pub use rustc::traits::query::type_op::ProvePredicate;\n \n impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n     type QueryResponse = ();"}, {"sha": "2877a74aaff01bc689713d0979a7d013805fa627", "filename": "src/librustc/traits/query/type_op/subtype.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fquery%2Ftype_op%2Fsubtype.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -1,18 +1,8 @@\n use crate::infer::canonical::{Canonicalized, CanonicalizedQueryResponse};\n use crate::traits::query::Fallible;\n-use crate::ty::{ParamEnvAnd, Ty, TyCtxt};\n+use crate::ty::{ParamEnvAnd, TyCtxt};\n \n-#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n-pub struct Subtype<'tcx> {\n-    pub sub: Ty<'tcx>,\n-    pub sup: Ty<'tcx>,\n-}\n-\n-impl<'tcx> Subtype<'tcx> {\n-    pub fn new(sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n-        Self { sub, sup }\n-    }\n-}\n+pub use rustc::traits::query::type_op::Subtype;\n \n impl<'tcx> super::QueryTypeOp<'tcx> for Subtype<'tcx> {\n     type QueryResponse = ();"}, {"sha": "e4ef68c167f943297e6ed66eefdfeff382bc444e", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 2, "deletions": 300, "changes": 302, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -41,7 +41,6 @@ use crate::ty::{self, ToPolyTraitRef, ToPredicate, Ty, TyCtxt, TypeFoldable, Wit\n use rustc_hir::def_id::DefId;\n \n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n-use rustc_data_structures::sync::Lock;\n use rustc_hir as hir;\n use rustc_index::bit_set::GrowableBitSet;\n use rustc_span::symbol::sym;\n@@ -53,6 +52,8 @@ use std::iter;\n use std::rc::Rc;\n use syntax::{ast, attr};\n \n+pub use rustc::traits::types::select::*;\n+\n pub struct SelectionContext<'cx, 'tcx> {\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n \n@@ -181,146 +182,6 @@ struct TraitObligationStack<'prev, 'tcx> {\n     dfn: usize,\n }\n \n-#[derive(Clone, Default)]\n-pub struct SelectionCache<'tcx> {\n-    hashmap: Lock<\n-        FxHashMap<\n-            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n-            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n-        >,\n-    >,\n-}\n-\n-/// The selection process begins by considering all impls, where\n-/// clauses, and so forth that might resolve an obligation. Sometimes\n-/// we'll be able to say definitively that (e.g.) an impl does not\n-/// apply to the obligation: perhaps it is defined for `usize` but the\n-/// obligation is for `int`. In that case, we drop the impl out of the\n-/// list. But the other cases are considered *candidates*.\n-///\n-/// For selection to succeed, there must be exactly one matching\n-/// candidate. If the obligation is fully known, this is guaranteed\n-/// by coherence. However, if the obligation contains type parameters\n-/// or variables, there may be multiple such impls.\n-///\n-/// It is not a real problem if multiple matching impls exist because\n-/// of type variables - it just means the obligation isn't sufficiently\n-/// elaborated. In that case we report an ambiguity, and the caller can\n-/// try again after more type information has been gathered or report a\n-/// \"type annotations needed\" error.\n-///\n-/// However, with type parameters, this can be a real problem - type\n-/// parameters don't unify with regular types, but they *can* unify\n-/// with variables from blanket impls, and (unless we know its bounds\n-/// will always be satisfied) picking the blanket impl will be wrong\n-/// for at least *some* substitutions. To make this concrete, if we have\n-///\n-///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n-///    impl<T: fmt::Debug> AsDebug for T {\n-///        type Out = T;\n-///        fn debug(self) -> fmt::Debug { self }\n-///    }\n-///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n-///\n-/// we can't just use the impl to resolve the `<T as AsDebug>` obligation\n-/// -- a type from another crate (that doesn't implement `fmt::Debug`) could\n-/// implement `AsDebug`.\n-///\n-/// Because where-clauses match the type exactly, multiple clauses can\n-/// only match if there are unresolved variables, and we can mostly just\n-/// report this ambiguity in that case. This is still a problem - we can't\n-/// *do anything* with ambiguities that involve only regions. This is issue\n-/// #21974.\n-///\n-/// If a single where-clause matches and there are no inference\n-/// variables left, then it definitely matches and we can just select\n-/// it.\n-///\n-/// In fact, we even select the where-clause when the obligation contains\n-/// inference variables. The can lead to inference making \"leaps of logic\",\n-/// for example in this situation:\n-///\n-///    pub trait Foo<T> { fn foo(&self) -> T; }\n-///    impl<T> Foo<()> for T { fn foo(&self) { } }\n-///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n-///\n-///    pub fn foo<T>(t: T) where T: Foo<bool> {\n-///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n-///    }\n-///    fn main() { foo(false); }\n-///\n-/// Here the obligation `<T as Foo<$0>>` can be matched by both the blanket\n-/// impl and the where-clause. We select the where-clause and unify `$0=bool`,\n-/// so the program prints \"false\". However, if the where-clause is omitted,\n-/// the blanket impl is selected, we unify `$0=()`, and the program prints\n-/// \"()\".\n-///\n-/// Exactly the same issues apply to projection and object candidates, except\n-/// that we can have both a projection candidate and a where-clause candidate\n-/// for the same obligation. In that case either would do (except that\n-/// different \"leaps of logic\" would occur if inference variables are\n-/// present), and we just pick the where-clause. This is, for example,\n-/// required for associated types to work in default impls, as the bounds\n-/// are visible both as projection bounds and as where-clauses from the\n-/// parameter environment.\n-#[derive(PartialEq, Eq, Debug, Clone, TypeFoldable)]\n-enum SelectionCandidate<'tcx> {\n-    BuiltinCandidate {\n-        /// `false` if there are no *further* obligations.\n-        has_nested: bool,\n-    },\n-    ParamCandidate(ty::PolyTraitRef<'tcx>),\n-    ImplCandidate(DefId),\n-    AutoImplCandidate(DefId),\n-\n-    /// This is a trait matching with a projected type as `Self`, and\n-    /// we found an applicable bound in the trait definition.\n-    ProjectionCandidate,\n-\n-    /// Implementation of a `Fn`-family trait by one of the anonymous types\n-    /// generated for a `||` expression.\n-    ClosureCandidate,\n-\n-    /// Implementation of a `Generator` trait by one of the anonymous types\n-    /// generated for a generator.\n-    GeneratorCandidate,\n-\n-    /// Implementation of a `Fn`-family trait by one of the anonymous\n-    /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n-    FnPointerCandidate,\n-\n-    TraitAliasCandidate(DefId),\n-\n-    ObjectCandidate,\n-\n-    BuiltinObjectCandidate,\n-\n-    BuiltinUnsizeCandidate,\n-}\n-\n-impl<'a, 'tcx> ty::Lift<'tcx> for SelectionCandidate<'a> {\n-    type Lifted = SelectionCandidate<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        Some(match *self {\n-            BuiltinCandidate { has_nested } => BuiltinCandidate { has_nested },\n-            ImplCandidate(def_id) => ImplCandidate(def_id),\n-            AutoImplCandidate(def_id) => AutoImplCandidate(def_id),\n-            ProjectionCandidate => ProjectionCandidate,\n-            ClosureCandidate => ClosureCandidate,\n-            GeneratorCandidate => GeneratorCandidate,\n-            FnPointerCandidate => FnPointerCandidate,\n-            TraitAliasCandidate(def_id) => TraitAliasCandidate(def_id),\n-            ObjectCandidate => ObjectCandidate,\n-            BuiltinObjectCandidate => BuiltinObjectCandidate,\n-            BuiltinUnsizeCandidate => BuiltinUnsizeCandidate,\n-\n-            ParamCandidate(ref trait_ref) => {\n-                return tcx.lift(trait_ref).map(ParamCandidate);\n-            }\n-        })\n-    }\n-}\n-\n struct SelectionCandidateSet<'tcx> {\n     // A list of candidates that definitely apply to the current\n     // obligation (meaning: types unify).\n@@ -350,134 +211,6 @@ enum BuiltinImplConditions<'tcx> {\n     Ambiguous,\n }\n \n-/// The result of trait evaluation. The order is important\n-/// here as the evaluation of a list is the maximum of the\n-/// evaluations.\n-///\n-/// The evaluation results are ordered:\n-///     - `EvaluatedToOk` implies `EvaluatedToOkModuloRegions`\n-///       implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n-///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n-///     - the \"union\" of evaluation results is equal to their maximum -\n-///     all the \"potential success\" candidates can potentially succeed,\n-///     so they are noops when unioned with a definite error, and within\n-///     the categories it's easy to see that the unions are correct.\n-#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq, HashStable)]\n-pub enum EvaluationResult {\n-    /// Evaluation successful.\n-    EvaluatedToOk,\n-    /// Evaluation successful, but there were unevaluated region obligations.\n-    EvaluatedToOkModuloRegions,\n-    /// Evaluation is known to be ambiguous -- it *might* hold for some\n-    /// assignment of inference variables, but it might not.\n-    ///\n-    /// While this has the same meaning as `EvaluatedToUnknown` -- we can't\n-    /// know whether this obligation holds or not -- it is the result we\n-    /// would get with an empty stack, and therefore is cacheable.\n-    EvaluatedToAmbig,\n-    /// Evaluation failed because of recursion involving inference\n-    /// variables. We are somewhat imprecise there, so we don't actually\n-    /// know the real result.\n-    ///\n-    /// This can't be trivially cached for the same reason as `EvaluatedToRecur`.\n-    EvaluatedToUnknown,\n-    /// Evaluation failed because we encountered an obligation we are already\n-    /// trying to prove on this branch.\n-    ///\n-    /// We know this branch can't be a part of a minimal proof-tree for\n-    /// the \"root\" of our cycle, because then we could cut out the recursion\n-    /// and maintain a valid proof tree. However, this does not mean\n-    /// that all the obligations on this branch do not hold -- it's possible\n-    /// that we entered this branch \"speculatively\", and that there\n-    /// might be some other way to prove this obligation that does not\n-    /// go through this cycle -- so we can't cache this as a failure.\n-    ///\n-    /// For example, suppose we have this:\n-    ///\n-    /// ```rust,ignore (pseudo-Rust)\n-    /// pub trait Trait { fn xyz(); }\n-    /// // This impl is \"useless\", but we can still have\n-    /// // an `impl Trait for SomeUnsizedType` somewhere.\n-    /// impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n-    ///\n-    /// pub fn foo<T: Trait + ?Sized>() {\n-    ///     <T as Trait>::xyz();\n-    /// }\n-    /// ```\n-    ///\n-    /// When checking `foo`, we have to prove `T: Trait`. This basically\n-    /// translates into this:\n-    ///\n-    /// ```plain,ignore\n-    /// (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n-    /// ```\n-    ///\n-    /// When we try to prove it, we first go the first option, which\n-    /// recurses. This shows us that the impl is \"useless\" -- it won't\n-    /// tell us that `T: Trait` unless it already implemented `Trait`\n-    /// by some other means. However, that does not prevent `T: Trait`\n-    /// does not hold, because of the bound (which can indeed be satisfied\n-    /// by `SomeUnsizedType` from another crate).\n-    //\n-    // FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n-    // ought to convert it to an `EvaluatedToErr`, because we know\n-    // there definitely isn't a proof tree for that obligation. Not\n-    // doing so is still sound -- there isn't any proof tree, so the\n-    // branch still can't be a part of a minimal one -- but does not re-enable caching.\n-    EvaluatedToRecur,\n-    /// Evaluation failed.\n-    EvaluatedToErr,\n-}\n-\n-impl EvaluationResult {\n-    /// Returns `true` if this evaluation result is known to apply, even\n-    /// considering outlives constraints.\n-    pub fn must_apply_considering_regions(self) -> bool {\n-        self == EvaluatedToOk\n-    }\n-\n-    /// Returns `true` if this evaluation result is known to apply, ignoring\n-    /// outlives constraints.\n-    pub fn must_apply_modulo_regions(self) -> bool {\n-        self <= EvaluatedToOkModuloRegions\n-    }\n-\n-    pub fn may_apply(self) -> bool {\n-        match self {\n-            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToUnknown => {\n-                true\n-            }\n-\n-            EvaluatedToErr | EvaluatedToRecur => false,\n-        }\n-    }\n-\n-    fn is_stack_dependent(self) -> bool {\n-        match self {\n-            EvaluatedToUnknown | EvaluatedToRecur => true,\n-\n-            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToErr => false,\n-        }\n-    }\n-}\n-\n-/// Indicates that trait evaluation caused overflow.\n-#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n-pub struct OverflowError;\n-\n-impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n-    fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n-        SelectionError::Overflow\n-    }\n-}\n-\n-#[derive(Clone, Default)]\n-pub struct EvaluationCache<'tcx> {\n-    hashmap: Lock<\n-        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n-    >,\n-}\n-\n impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     pub fn new(infcx: &'cx InferCtxt<'cx, 'tcx>) -> SelectionContext<'cx, 'tcx> {\n         SelectionContext {\n@@ -3827,20 +3560,6 @@ impl<'tcx> TraitObligation<'tcx> {\n     }\n }\n \n-impl<'tcx> SelectionCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n-impl<'tcx> EvaluationCache<'tcx> {\n-    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n-    pub fn clear(&self) {\n-        *self.hashmap.borrow_mut() = Default::default();\n-    }\n-}\n-\n impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n     fn list(&'o self) -> TraitObligationStackList<'o, 'tcx> {\n         TraitObligationStackList::with(self)\n@@ -4126,20 +3845,3 @@ impl<'o, 'tcx> fmt::Debug for TraitObligationStack<'o, 'tcx> {\n         write!(f, \"TraitObligationStack({:?})\", self.obligation)\n     }\n }\n-\n-#[derive(Clone, Eq, PartialEq)]\n-pub struct WithDepNode<T> {\n-    dep_node: DepNodeIndex,\n-    cached_value: T,\n-}\n-\n-impl<T: Clone> WithDepNode<T> {\n-    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n-        WithDepNode { dep_node, cached_value }\n-    }\n-\n-    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n-        tcx.dep_graph.read_index(self.dep_node);\n-        self.cached_value.clone()\n-    }\n-}"}, {"sha": "c90fa428001fcd4af655dd9437e981227ade6813", "filename": "src/librustc/traits/specialize/specialization_graph.rs", "status": "modified", "additions": 4, "deletions": 196, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fspecialize%2Fspecialization_graph.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -1,58 +1,11 @@\n use super::OverlapError;\n \n-use crate::ich::{self, StableHashingContext};\n use crate::traits;\n-use crate::ty::fast_reject::{self, SimplifiedType};\n-use crate::ty::{self, TyCtxt, TypeFoldable};\n-use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n-use rustc_hir::def_id::{DefId, DefIdMap};\n-use syntax::ast::Ident;\n-\n-/// A per-trait graph of impls in specialization order. At the moment, this\n-/// graph forms a tree rooted with the trait itself, with all other nodes\n-/// representing impls, and parent-child relationships representing\n-/// specializations.\n-///\n-/// The graph provides two key services:\n-///\n-/// - Construction. This implicitly checks for overlapping impls (i.e., impls\n-///   that overlap but where neither specializes the other -- an artifact of the\n-///   simple \"chain\" rule.\n-///\n-/// - Parent extraction. In particular, the graph can give you the *immediate*\n-///   parents of a given specializing impl, which is needed for extracting\n-///   default items amongst other things. In the simple \"chain\" rule, every impl\n-///   has at most one parent.\n-#[derive(RustcEncodable, RustcDecodable, HashStable)]\n-pub struct Graph {\n-    // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n-    // of the trait.\n-    parent: DefIdMap<DefId>,\n-\n-    // The \"root\" impls are found by looking up the trait's def_id.\n-    children: DefIdMap<Children>,\n-}\n+use rustc::ty::fast_reject::{self, SimplifiedType};\n+use rustc::ty::{self, TyCtxt, TypeFoldable};\n+use rustc_hir::def_id::DefId;\n \n-/// Children of a given impl, grouped into blanket/non-blanket varieties as is\n-/// done in `TraitDef`.\n-#[derive(Default, RustcEncodable, RustcDecodable)]\n-struct Children {\n-    // Impls of a trait (or specializations of a given impl). To allow for\n-    // quicker lookup, the impls are indexed by a simplified version of their\n-    // `Self` type: impls with a simplifiable `Self` are stored in\n-    // `nonblanket_impls` keyed by it, while all other impls are stored in\n-    // `blanket_impls`.\n-    //\n-    // A similar division is used within `TraitDef`, but the lists there collect\n-    // together *all* the impls for a trait, and are populated prior to building\n-    // the specialization graph.\n-    /// Impls of the trait.\n-    nonblanket_impls: FxHashMap<fast_reject::SimplifiedType, Vec<DefId>>,\n-\n-    /// Blanket impls associated with the trait.\n-    blanket_impls: Vec<DefId>,\n-}\n+pub use rustc::traits::types::specialization_graph::*;\n \n #[derive(Copy, Clone, Debug)]\n pub enum FutureCompatOverlapErrorKind {\n@@ -269,10 +222,6 @@ where\n }\n \n impl<'tcx> Graph {\n-    pub fn new() -> Graph {\n-        Graph { parent: Default::default(), children: Default::default() }\n-    }\n-\n     /// Insert a local impl into the specialization graph. If an existing impl\n     /// conflicts with it (has overlap, but neither specializes the other),\n     /// information about the area of overlap is returned in the `Err`.\n@@ -383,145 +332,4 @@ impl<'tcx> Graph {\n \n         self.children.entry(parent).or_default().insert_blindly(tcx, child);\n     }\n-\n-    /// The parent of a given impl, which is the `DefId` of the trait when the\n-    /// impl is a \"specialization root\".\n-    pub fn parent(&self, child: DefId) -> DefId {\n-        *self.parent.get(&child).unwrap_or_else(|| panic!(\"Failed to get parent for {:?}\", child))\n-    }\n-}\n-\n-/// A node in the specialization graph is either an impl or a trait\n-/// definition; either can serve as a source of item definitions.\n-/// There is always exactly one trait definition node: the root.\n-#[derive(Debug, Copy, Clone)]\n-pub enum Node {\n-    Impl(DefId),\n-    Trait(DefId),\n-}\n-\n-impl<'tcx> Node {\n-    pub fn is_from_trait(&self) -> bool {\n-        match *self {\n-            Node::Trait(..) => true,\n-            _ => false,\n-        }\n-    }\n-\n-    /// Iterate over the items defined directly by the given (impl or trait) node.\n-    pub fn items(&self, tcx: TyCtxt<'tcx>) -> ty::AssocItemsIterator<'tcx> {\n-        tcx.associated_items(self.def_id())\n-    }\n-\n-    /// Finds an associated item defined in this node.\n-    ///\n-    /// If this returns `None`, the item can potentially still be found in\n-    /// parents of this node.\n-    pub fn item(\n-        &self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_item_name: Ident,\n-        trait_item_kind: ty::AssocKind,\n-        trait_def_id: DefId,\n-    ) -> Option<ty::AssocItem> {\n-        use crate::ty::AssocKind::*;\n-\n-        tcx.associated_items(self.def_id()).find(move |impl_item| {\n-            match (trait_item_kind, impl_item.kind) {\n-                | (Const, Const)\n-                | (Method, Method)\n-                | (Type, Type)\n-                | (Type, OpaqueTy)  // assoc. types can be made opaque in impls\n-                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n-\n-                | (Const, _)\n-                | (Method, _)\n-                | (Type, _)\n-                | (OpaqueTy, _)\n-                => false,\n-            }\n-        })\n-    }\n-\n-    pub fn def_id(&self) -> DefId {\n-        match *self {\n-            Node::Impl(did) => did,\n-            Node::Trait(did) => did,\n-        }\n-    }\n-}\n-\n-#[derive(Copy, Clone)]\n-pub struct Ancestors<'tcx> {\n-    trait_def_id: DefId,\n-    specialization_graph: &'tcx Graph,\n-    current_source: Option<Node>,\n-}\n-\n-impl Iterator for Ancestors<'_> {\n-    type Item = Node;\n-    fn next(&mut self) -> Option<Node> {\n-        let cur = self.current_source.take();\n-        if let Some(Node::Impl(cur_impl)) = cur {\n-            let parent = self.specialization_graph.parent(cur_impl);\n-\n-            self.current_source = if parent == self.trait_def_id {\n-                Some(Node::Trait(parent))\n-            } else {\n-                Some(Node::Impl(parent))\n-            };\n-        }\n-        cur\n-    }\n-}\n-\n-pub struct NodeItem<T> {\n-    pub node: Node,\n-    pub item: T,\n-}\n-\n-impl<T> NodeItem<T> {\n-    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> NodeItem<U> {\n-        NodeItem { node: self.node, item: f(self.item) }\n-    }\n-}\n-\n-impl<'tcx> Ancestors<'tcx> {\n-    /// Finds the bottom-most (ie. most specialized) definition of an associated\n-    /// item.\n-    pub fn leaf_def(\n-        mut self,\n-        tcx: TyCtxt<'tcx>,\n-        trait_item_name: Ident,\n-        trait_item_kind: ty::AssocKind,\n-    ) -> Option<NodeItem<ty::AssocItem>> {\n-        let trait_def_id = self.trait_def_id;\n-        self.find_map(|node| {\n-            node.item(tcx, trait_item_name, trait_item_kind, trait_def_id)\n-                .map(|item| NodeItem { node, item })\n-        })\n-    }\n-}\n-\n-/// Walk up the specialization ancestors of a given impl, starting with that\n-/// impl itself.\n-pub fn ancestors(\n-    tcx: TyCtxt<'tcx>,\n-    trait_def_id: DefId,\n-    start_from_impl: DefId,\n-) -> Ancestors<'tcx> {\n-    let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n-    Ancestors {\n-        trait_def_id,\n-        specialization_graph,\n-        current_source: Some(Node::Impl(start_from_impl)),\n-    }\n-}\n-\n-impl<'a> HashStable<StableHashingContext<'a>> for Children {\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let Children { ref nonblanket_impls, ref blanket_impls } = *self;\n-\n-        ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, nonblanket_impls);\n-    }\n }"}, {"sha": "80731c7b1892fe3d82b79cd4eb0db9d8fea67378", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 703, "changes": 704, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -1,13 +1,9 @@\n use crate::traits;\n use crate::traits::project::Normalized;\n+use crate::ty;\n use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use crate::ty::{self, Lift, Ty, TyCtxt};\n-use rustc_span::symbol::Symbol;\n-use smallvec::SmallVec;\n \n-use std::collections::{BTreeMap, BTreeSet};\n use std::fmt;\n-use std::rc::Rc;\n \n // Structural impls for the structs in `traits`.\n \n@@ -31,102 +27,6 @@ impl<'tcx, O: fmt::Debug> fmt::Debug for traits::Obligation<'tcx, O> {\n     }\n }\n \n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n-\n-            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n-\n-            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n-\n-            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n-\n-            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n-\n-            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n-        }\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.impl_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.generator_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.closure_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n-    }\n-}\n-\n-impl<N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n-            self.trait_def_id, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n-            self.upcast_trait_ref, self.vtable_base, self.nested\n-        )\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(f, \"VtableFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n-    }\n-}\n-\n-impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        write!(\n-            f,\n-            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n-            self.alias_def_id, self.substs, self.nested\n-        )\n-    }\n-}\n-\n impl<'tcx> fmt::Debug for traits::FulfillmentError<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         write!(f, \"FulfillmentError({:?},{:?})\", self.obligation, self.code)\n@@ -152,531 +52,6 @@ impl<'tcx> fmt::Debug for traits::MismatchedProjectionTypes<'tcx> {\n     }\n }\n \n-impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::WhereClause::*;\n-\n-        // Bypass `ty::print` because it does not print out anonymous regions.\n-        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n-        fn write_region_name<'tcx>(\n-            r: ty::Region<'tcx>,\n-            fmt: &mut fmt::Formatter<'_>,\n-        ) -> fmt::Result {\n-            match r {\n-                ty::ReLateBound(index, br) => match br {\n-                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n-                    ty::BoundRegion::BrAnon(var) => {\n-                        if *index == ty::INNERMOST {\n-                            write!(fmt, \"'^{}\", var)\n-                        } else {\n-                            write!(fmt, \"'^{}_{}\", index.index(), var)\n-                        }\n-                    }\n-                    _ => write!(fmt, \"'_\"),\n-                },\n-\n-                _ => write!(fmt, \"{}\", r),\n-            }\n-        }\n-\n-        match self {\n-            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n-            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n-            RegionOutlives(predicate) => {\n-                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-            TypeOutlives(predicate) => {\n-                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n-                write_region_name(predicate.1, fmt)?;\n-                write!(fmt, \")\")\n-            }\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::WellFormed::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::FromEnv::*;\n-\n-        match self {\n-            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n-            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::DomainGoal::*;\n-\n-        match self {\n-            Holds(wc) => write!(fmt, \"{}\", wc),\n-            WellFormed(wf) => write!(fmt, \"{}\", wf),\n-            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n-            Normalize(projection) => {\n-                write!(fmt, \"Normalize({} -> {})\", projection.projection_ty, projection.ty)\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Display for traits::QuantifierKind {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::QuantifierKind::*;\n-\n-        match self {\n-            Universal => write!(fmt, \"forall\"),\n-            Existential => write!(fmt, \"exists\"),\n-        }\n-    }\n-}\n-\n-/// Collect names for regions / types bound by a quantified goal / clause.\n-/// This collector does not try to do anything clever like in `ty::print`, it's just used\n-/// for debug output in tests anyway.\n-struct BoundNamesCollector {\n-    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n-    regions: BTreeSet<Symbol>,\n-\n-    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n-    // by the list of type parameters.\n-    types: BTreeMap<u32, Symbol>,\n-\n-    binder_index: ty::DebruijnIndex,\n-}\n-\n-impl BoundNamesCollector {\n-    fn new() -> Self {\n-        BoundNamesCollector {\n-            regions: BTreeSet::new(),\n-            types: BTreeMap::new(),\n-            binder_index: ty::INNERMOST,\n-        }\n-    }\n-\n-    fn is_empty(&self) -> bool {\n-        self.regions.is_empty() && self.types.is_empty()\n-    }\n-\n-    fn write_names(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let mut start = true;\n-        for r in &self.regions {\n-            if !start {\n-                write!(fmt, \", \")?;\n-            }\n-            start = false;\n-            write!(fmt, \"{}\", r)?;\n-        }\n-        for (_, t) in &self.types {\n-            if !start {\n-                write!(fmt, \", \")?;\n-            }\n-            start = false;\n-            write!(fmt, \"{}\", t)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n-    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n-        self.binder_index.shift_in(1);\n-        let result = t.super_visit_with(self);\n-        self.binder_index.shift_out(1);\n-        result\n-    }\n-\n-    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n-        match t.kind {\n-            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n-                self.types.insert(\n-                    bound_ty.var.as_u32(),\n-                    match bound_ty.kind {\n-                        ty::BoundTyKind::Param(name) => name,\n-                        ty::BoundTyKind::Anon => {\n-                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()))\n-                        }\n-                    },\n-                );\n-            }\n-\n-            _ => (),\n-        };\n-\n-        t.super_visit_with(self)\n-    }\n-\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n-                ty::BoundRegion::BrNamed(_, name) => {\n-                    self.regions.insert(*name);\n-                }\n-\n-                ty::BoundRegion::BrAnon(var) => {\n-                    self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n-                }\n-\n-                _ => (),\n-            },\n-\n-            _ => (),\n-        };\n-\n-        r.super_visit_with(self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::GoalKind::*;\n-\n-        match self {\n-            Implies(hypotheses, goal) => {\n-                write!(fmt, \"if (\")?;\n-                for (index, hyp) in hypotheses.iter().enumerate() {\n-                    if index > 0 {\n-                        write!(fmt, \", \")?;\n-                    }\n-                    write!(fmt, \"{}\", hyp)?;\n-                }\n-                write!(fmt, \") {{ {} }}\", goal)\n-            }\n-            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n-            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n-            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n-            Quantified(qkind, goal) => {\n-                let mut collector = BoundNamesCollector::new();\n-                goal.skip_binder().visit_with(&mut collector);\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \"{}<\", qkind)?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n-\n-                write!(fmt, \"{}\", goal.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n-\n-                Ok(())\n-            }\n-            Subtype(a, b) => write!(fmt, \"{} <: {}\", a, b),\n-            CannotProve => write!(fmt, \"CannotProve\"),\n-        }\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let traits::ProgramClause { goal, hypotheses, .. } = self;\n-        write!(fmt, \"{}\", goal)?;\n-        if !hypotheses.is_empty() {\n-            write!(fmt, \" :- \")?;\n-            for (index, condition) in hypotheses.iter().enumerate() {\n-                if index > 0 {\n-                    write!(fmt, \", \")?;\n-                }\n-                write!(fmt, \"{}\", condition)?;\n-            }\n-        }\n-        write!(fmt, \".\")\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        use crate::traits::Clause::*;\n-\n-        match self {\n-            Implies(clause) => write!(fmt, \"{}\", clause),\n-            ForAll(clause) => {\n-                let mut collector = BoundNamesCollector::new();\n-                clause.skip_binder().visit_with(&mut collector);\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \"forall<\")?;\n-                    collector.write_names(fmt)?;\n-                    write!(fmt, \"> {{ \")?;\n-                }\n-\n-                write!(fmt, \"{}\", clause.skip_binder())?;\n-\n-                if !collector.is_empty() {\n-                    write!(fmt, \" }}\")?;\n-                }\n-\n-                Ok(())\n-            }\n-        }\n-    }\n-}\n-\n-///////////////////////////////////////////////////////////////////////////\n-// Lift implementations\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n-    type Lifted = traits::SelectionError<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::Unimplemented => Some(super::Unimplemented),\n-            super::OutputTypeParameterMismatch(a, b, ref err) => {\n-                tcx.lift(&(a, b)).and_then(|(a, b)| {\n-                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n-                })\n-            }\n-            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n-            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n-            super::Overflow => Some(super::Overflow),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n-    type Lifted = traits::ObligationCauseCode<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match *self {\n-            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n-            super::MiscObligation => Some(super::MiscObligation),\n-            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n-            super::TupleElem => Some(super::TupleElem),\n-            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n-            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n-            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n-            super::ReferenceOutlivesReferent(ty) => {\n-                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n-            }\n-            super::ObjectTypeBound(ty, r) => tcx\n-                .lift(&ty)\n-                .and_then(|ty| tcx.lift(&r).and_then(|r| Some(super::ObjectTypeBound(ty, r)))),\n-            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n-            super::Coercion { source, target } => {\n-                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n-            }\n-            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n-            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n-            super::StructInitializerSized => Some(super::StructInitializerSized),\n-            super::VariableType(id) => Some(super::VariableType(id)),\n-            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n-            super::ReturnType => Some(super::ReturnType),\n-            super::SizedArgumentType => Some(super::SizedArgumentType),\n-            super::SizedReturnType => Some(super::SizedReturnType),\n-            super::SizedYieldType => Some(super::SizedYieldType),\n-            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n-            super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n-            super::ConstSized => Some(super::ConstSized),\n-            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n-            super::SharedStatic => Some(super::SharedStatic),\n-            super::BuiltinDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n-            }\n-            super::ImplDerivedObligation(ref cause) => {\n-                tcx.lift(cause).map(super::ImplDerivedObligation)\n-            }\n-            super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            } => Some(super::CompareImplMethodObligation {\n-                item_name,\n-                impl_item_def_id,\n-                trait_item_def_id,\n-            }),\n-            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n-                Some(super::CompareImplTypeObligation {\n-                    item_name,\n-                    impl_item_def_id,\n-                    trait_item_def_id,\n-                })\n-            }\n-            super::ExprAssignable => Some(super::ExprAssignable),\n-            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                arm_span,\n-                source,\n-                ref prior_arms,\n-                last_ty,\n-                scrut_hir_id,\n-            }) => tcx.lift(&last_ty).map(|last_ty| {\n-                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n-                    arm_span,\n-                    source,\n-                    prior_arms: prior_arms.clone(),\n-                    last_ty,\n-                    scrut_hir_id,\n-                })\n-            }),\n-            super::Pattern { span, root_ty, origin_expr } => {\n-                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n-            }\n-            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n-                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n-            }\n-            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n-            super::MainFunctionType => Some(super::MainFunctionType),\n-            super::StartFunctionType => Some(super::StartFunctionType),\n-            super::IntrinsicType => Some(super::IntrinsicType),\n-            super::MethodReceiver => Some(super::MethodReceiver),\n-            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n-            super::TrivialBound => Some(super::TrivialBound),\n-            super::AssocTypeBound(ref data) => Some(super::AssocTypeBound(data.clone())),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n-    type Lifted = traits::DerivedObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n-            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n-                parent_trait_ref: trait_ref,\n-                parent_code: Rc::new(code),\n-            })\n-        })\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n-    type Lifted = traits::ObligationCause<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n-            span: self.span,\n-            body_id: self.body_id,\n-            code,\n-        })\n-    }\n-}\n-\n-// For codegen only.\n-impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n-    type Lifted = traits::Vtable<'tcx, ()>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self.clone() {\n-            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested })\n-                })\n-            }\n-            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n-            traits::VtableGenerator(traits::VtableGeneratorData {\n-                generator_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableGenerator(traits::VtableGeneratorData {\n-                    generator_def_id: generator_def_id,\n-                    substs: substs,\n-                    nested: nested,\n-                })\n-            }),\n-            traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {\n-                tcx.lift(&substs).map(|substs| {\n-                    traits::VtableClosure(traits::VtableClosureData {\n-                        closure_def_id,\n-                        substs,\n-                        nested,\n-                    })\n-                })\n-            }\n-            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n-                tcx.lift(&fn_ty).map(|fn_ty| {\n-                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n-                })\n-            }\n-            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n-            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n-            traits::VtableObject(traits::VtableObjectData {\n-                upcast_trait_ref,\n-                vtable_base,\n-                nested,\n-            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n-                traits::VtableObject(traits::VtableObjectData {\n-                    upcast_trait_ref: trait_ref,\n-                    vtable_base,\n-                    nested,\n-                })\n-            }),\n-            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n-                alias_def_id,\n-                substs,\n-                nested,\n-            }) => tcx.lift(&substs).map(|substs| {\n-                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n-                    alias_def_id,\n-                    substs,\n-                    nested,\n-                })\n-            }),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n-    type Lifted = traits::Environment<'tcx>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.clauses).map(|clauses| traits::Environment { clauses })\n-    }\n-}\n-\n-impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n-    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        tcx.lift(&self.environment).and_then(|environment| {\n-            tcx.lift(&self.goal).map(|goal| traits::InEnvironment { environment, goal })\n-        })\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedExClause;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::DelayedLiteral<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedDelayedLiteral;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n-    }\n-}\n-\n-impl<'tcx, C> Lift<'tcx> for chalk_engine::Literal<C>\n-where\n-    C: chalk_engine::context::Context + Clone,\n-    C: traits::ChalkContextLift<'tcx>,\n-{\n-    type Lifted = C::LiftedLiteral;\n-\n-    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n-    }\n-}\n-\n ///////////////////////////////////////////////////////////////////////////\n // TypeFoldable implementations.\n \n@@ -694,80 +69,3 @@ impl<'tcx, O: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Obligation<'tcx\n         self.predicate.visit_with(visitor)\n     }\n }\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    traits::QuantifierKind,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_goals(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = (**self).fold_with(folder);\n-        folder.tcx().mk_goal(v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        (**self).visit_with(visitor)\n-    }\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    traits::ProgramClauseCategory,\n-}\n-\n-impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n-        folder.tcx().intern_clauses(&v)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        self.iter().any(|t| t.visit_with(visitor))\n-    }\n-}\n-\n-impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n-where\n-    C: traits::ExClauseFold<'tcx>,\n-    C::Substitution: Clone,\n-    C::RegionConstraint: Clone,\n-{\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        <C as traits::ExClauseFold>::fold_ex_clause_with(self, folder)\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        <C as traits::ExClauseFold>::visit_ex_clause_with(self, visitor)\n-    }\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n-        (chalk_engine::DelayedLiteral::CannotProve)(a),\n-        (chalk_engine::DelayedLiteral::Negative)(a),\n-        (chalk_engine::DelayedLiteral::Positive)(a, b),\n-    } where\n-        C: chalk_engine::context::Context<CanonicalConstrainedSubst: TypeFoldable<'tcx>> + Clone,\n-}\n-\n-EnumTypeFoldableImpl! {\n-    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n-        (chalk_engine::Literal::Negative)(a),\n-        (chalk_engine::Literal::Positive)(a),\n-    } where\n-        C: chalk_engine::context::Context<GoalInEnvironment: Clone + TypeFoldable<'tcx>> + Clone,\n-}\n-\n-CloneTypeFoldableAndLiftImpls! {\n-    chalk_engine::TableIndex,\n-}"}, {"sha": "571fb505779ca2408d2303a525fbc4d848df145d", "filename": "src/librustc/traits/types/mod.rs", "status": "added", "additions": 736, "deletions": 0, "changes": 736, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fmod.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -0,0 +1,736 @@\n+//! Trait Resolution. See the [rustc guide] for more information on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html\n+\n+pub mod query;\n+pub mod select;\n+pub mod specialization_graph;\n+mod structural_impls;\n+\n+use crate::mir::interpret::ErrorHandled;\n+use crate::ty::fold::{TypeFolder, TypeVisitor};\n+use crate::ty::subst::SubstsRef;\n+use crate::ty::{self, AdtKind, List, Ty, TyCtxt};\n+\n+use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n+use rustc_span::{Span, DUMMY_SP};\n+use syntax::ast;\n+\n+use std::fmt::Debug;\n+use std::rc::Rc;\n+\n+pub use self::select::{EvaluationCache, EvaluationResult, OverflowError, SelectionCache};\n+\n+pub use self::ObligationCauseCode::*;\n+pub use self::SelectionError::*;\n+pub use self::Vtable::*;\n+\n+/// Depending on the stage of compilation, we want projection to be\n+/// more or less conservative.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, HashStable)]\n+pub enum Reveal {\n+    /// At type-checking time, we refuse to project any associated\n+    /// type that is marked `default`. Non-`default` (\"final\") types\n+    /// are always projected. This is necessary in general for\n+    /// soundness of specialization. However, we *could* allow\n+    /// projections in fully-monomorphic cases. We choose not to,\n+    /// because we prefer for `default type` to force the type\n+    /// definition to be treated abstractly by any consumers of the\n+    /// impl. Concretely, that means that the following example will\n+    /// fail to compile:\n+    ///\n+    /// ```\n+    /// trait Assoc {\n+    ///     type Output;\n+    /// }\n+    ///\n+    /// impl<T> Assoc for T {\n+    ///     default type Output = bool;\n+    /// }\n+    ///\n+    /// fn main() {\n+    ///     let <() as Assoc>::Output = true;\n+    /// }\n+    /// ```\n+    UserFacing,\n+\n+    /// At codegen time, all monomorphic projections will succeed.\n+    /// Also, `impl Trait` is normalized to the concrete type,\n+    /// which has to be already collected by type-checking.\n+    ///\n+    /// NOTE: as `impl Trait`'s concrete type should *never*\n+    /// be observable directly by the user, `Reveal::All`\n+    /// should not be used by checks which may expose\n+    /// type equality or type contents to the user.\n+    /// There are some exceptions, e.g., around OIBITS and\n+    /// transmute-checking, which expose some details, but\n+    /// not the whole concrete type of the `impl Trait`.\n+    All,\n+}\n+\n+/// The reason why we incurred this obligation; used for error reporting.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct ObligationCause<'tcx> {\n+    pub span: Span,\n+\n+    /// The ID of the fn body that triggered this obligation. This is\n+    /// used for region obligations to determine the precise\n+    /// environment in which the region obligation should be evaluated\n+    /// (in particular, closures can add new assumptions). See the\n+    /// field `region_obligations` of the `FulfillmentContext` for more\n+    /// information.\n+    pub body_id: hir::HirId,\n+\n+    pub code: ObligationCauseCode<'tcx>,\n+}\n+\n+impl<'tcx> ObligationCause<'tcx> {\n+    #[inline]\n+    pub fn new(\n+        span: Span,\n+        body_id: hir::HirId,\n+        code: ObligationCauseCode<'tcx>,\n+    ) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code }\n+    }\n+\n+    pub fn misc(span: Span, body_id: hir::HirId) -> ObligationCause<'tcx> {\n+        ObligationCause { span, body_id, code: MiscObligation }\n+    }\n+\n+    pub fn dummy() -> ObligationCause<'tcx> {\n+        ObligationCause { span: DUMMY_SP, body_id: hir::CRATE_HIR_ID, code: MiscObligation }\n+    }\n+\n+    pub fn span(&self, tcx: TyCtxt<'tcx>) -> Span {\n+        match self.code {\n+            ObligationCauseCode::CompareImplMethodObligation { .. }\n+            | ObligationCauseCode::MainFunctionType\n+            | ObligationCauseCode::StartFunctionType => tcx.sess.source_map().def_span(self.span),\n+            ObligationCauseCode::MatchExpressionArm(box MatchExpressionArmCause {\n+                arm_span,\n+                ..\n+            }) => arm_span,\n+            _ => self.span,\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ObligationCauseCode<'tcx> {\n+    /// Not well classified or should be obvious from the span.\n+    MiscObligation,\n+\n+    /// A slice or array is WF only if `T: Sized`.\n+    SliceOrArrayElem,\n+\n+    /// A tuple is WF only if its middle elements are `Sized`.\n+    TupleElem,\n+\n+    /// This is the trait reference from the given projection.\n+    ProjectionWf(ty::ProjectionTy<'tcx>),\n+\n+    /// In an impl of trait `X` for type `Y`, type `Y` must\n+    /// also implement all supertraits of `X`.\n+    ItemObligation(DefId),\n+\n+    /// Like `ItemObligation`, but with extra detail on the source of the obligation.\n+    BindingObligation(DefId, Span),\n+\n+    /// A type like `&'a T` is WF only if `T: 'a`.\n+    ReferenceOutlivesReferent(Ty<'tcx>),\n+\n+    /// A type like `Box<Foo<'a> + 'b>` is WF only if `'b: 'a`.\n+    ObjectTypeBound(Ty<'tcx>, ty::Region<'tcx>),\n+\n+    /// Obligation incurred due to an object cast.\n+    ObjectCastObligation(/* Object type */ Ty<'tcx>),\n+\n+    /// Obligation incurred due to a coercion.\n+    Coercion {\n+        source: Ty<'tcx>,\n+        target: Ty<'tcx>,\n+    },\n+\n+    /// Various cases where expressions must be `Sized` / `Copy` / etc.\n+    /// `L = X` implies that `L` is `Sized`.\n+    AssignmentLhsSized,\n+    /// `(x1, .., xn)` must be `Sized`.\n+    TupleInitializerSized,\n+    /// `S { ... }` must be `Sized`.\n+    StructInitializerSized,\n+    /// Type of each variable must be `Sized`.\n+    VariableType(hir::HirId),\n+    /// Argument type must be `Sized`.\n+    SizedArgumentType,\n+    /// Return type must be `Sized`.\n+    SizedReturnType,\n+    /// Yield type must be `Sized`.\n+    SizedYieldType,\n+    /// `[T, ..n]` implies that `T` must be `Copy`.\n+    /// If `true`, suggest `const_in_array_repeat_expressions` feature flag.\n+    RepeatVec(bool),\n+\n+    /// Types of fields (other than the last, except for packed structs) in a struct must be sized.\n+    FieldSized {\n+        adt_kind: AdtKind,\n+        last: bool,\n+    },\n+\n+    /// Constant expressions must be sized.\n+    ConstSized,\n+\n+    /// `static` items must have `Sync` type.\n+    SharedStatic,\n+\n+    BuiltinDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    ImplDerivedObligation(DerivedObligationCause<'tcx>),\n+\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplMethodObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n+    /// Error derived when matching traits/impls; see ObligationCause for more details\n+    CompareImplTypeObligation {\n+        item_name: ast::Name,\n+        impl_item_def_id: DefId,\n+        trait_item_def_id: DefId,\n+    },\n+\n+    /// Checking that this expression can be assigned where it needs to be\n+    // FIXME(eddyb) #11161 is the original Expr required?\n+    ExprAssignable,\n+\n+    /// Computing common supertype in the arms of a match expression\n+    MatchExpressionArm(Box<MatchExpressionArmCause<'tcx>>),\n+\n+    /// Type error arising from type checking a pattern against an expected type.\n+    Pattern {\n+        /// The span of the scrutinee or type expression which caused the `root_ty` type.\n+        span: Option<Span>,\n+        /// The root expected type induced by a scrutinee or type expression.\n+        root_ty: Ty<'tcx>,\n+        /// Whether the `Span` came from an expression or a type expression.\n+        origin_expr: bool,\n+    },\n+\n+    /// Constants in patterns must have `Structural` type.\n+    ConstPatternStructural,\n+\n+    /// Computing common supertype in an if expression\n+    IfExpression(Box<IfExpressionCause>),\n+\n+    /// Computing common supertype of an if expression with no else counter-part\n+    IfExpressionWithNoElse,\n+\n+    /// `main` has wrong type\n+    MainFunctionType,\n+\n+    /// `start` has wrong type\n+    StartFunctionType,\n+\n+    /// Intrinsic has wrong type\n+    IntrinsicType,\n+\n+    /// Method receiver\n+    MethodReceiver,\n+\n+    /// `return` with no expression\n+    ReturnNoExpression,\n+\n+    /// `return` with an expression\n+    ReturnValue(hir::HirId),\n+\n+    /// Return type of this function\n+    ReturnType,\n+\n+    /// Block implicit return\n+    BlockTailExpression(hir::HirId),\n+\n+    /// #[feature(trivial_bounds)] is not enabled\n+    TrivialBound,\n+\n+    AssocTypeBound(Box<AssocTypeBoundData>),\n+}\n+\n+impl ObligationCauseCode<'_> {\n+    // Return the base obligation, ignoring derived obligations.\n+    pub fn peel_derives(&self) -> &Self {\n+        let mut base_cause = self;\n+        while let BuiltinDerivedObligation(cause) | ImplDerivedObligation(cause) = base_cause {\n+            base_cause = &cause.parent_code;\n+        }\n+        base_cause\n+    }\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct AssocTypeBoundData {\n+    pub impl_span: Option<Span>,\n+    pub original: Span,\n+    pub bounds: Vec<Span>,\n+}\n+\n+// `ObligationCauseCode` is used a lot. Make sure it doesn't unintentionally get bigger.\n+#[cfg(target_arch = \"x86_64\")]\n+static_assert_size!(ObligationCauseCode<'_>, 32);\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct MatchExpressionArmCause<'tcx> {\n+    pub arm_span: Span,\n+    pub source: hir::MatchSource,\n+    pub prior_arms: Vec<Span>,\n+    pub last_ty: Ty<'tcx>,\n+    pub scrut_hir_id: hir::HirId,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct IfExpressionCause {\n+    pub then: Span,\n+    pub outer: Option<Span>,\n+    pub semicolon: Option<Span>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct DerivedObligationCause<'tcx> {\n+    /// The trait reference of the parent obligation that led to the\n+    /// current obligation. Note that only trait obligations lead to\n+    /// derived obligations, so we just store the trait reference here\n+    /// directly.\n+    pub parent_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The parent trait had this cause.\n+    pub parent_code: Rc<ObligationCauseCode<'tcx>>,\n+}\n+\n+/// The following types:\n+/// * `WhereClause`,\n+/// * `WellFormed`,\n+/// * `FromEnv`,\n+/// * `DomainGoal`,\n+/// * `Goal`,\n+/// * `Clause`,\n+/// * `Environment`,\n+/// * `InEnvironment`,\n+/// are used for representing the trait system in the form of\n+/// logic programming clauses. They are part of the interface\n+/// for the chalk SLG solver.\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum WhereClause<'tcx> {\n+    Implemented(ty::TraitPredicate<'tcx>),\n+    ProjectionEq(ty::ProjectionPredicate<'tcx>),\n+    RegionOutlives(ty::RegionOutlivesPredicate<'tcx>),\n+    TypeOutlives(ty::TypeOutlivesPredicate<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum WellFormed<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum FromEnv<'tcx> {\n+    Trait(ty::TraitPredicate<'tcx>),\n+    Ty(Ty<'tcx>),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum DomainGoal<'tcx> {\n+    Holds(WhereClause<'tcx>),\n+    WellFormed(WellFormed<'tcx>),\n+    FromEnv(FromEnv<'tcx>),\n+    Normalize(ty::ProjectionPredicate<'tcx>),\n+}\n+\n+pub type PolyDomainGoal<'tcx> = ty::Binder<DomainGoal<'tcx>>;\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n+pub enum QuantifierKind {\n+    Universal,\n+    Existential,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable, Lift)]\n+pub enum GoalKind<'tcx> {\n+    Implies(Clauses<'tcx>, Goal<'tcx>),\n+    And(Goal<'tcx>, Goal<'tcx>),\n+    Not(Goal<'tcx>),\n+    DomainGoal(DomainGoal<'tcx>),\n+    Quantified(QuantifierKind, ty::Binder<Goal<'tcx>>),\n+    Subtype(Ty<'tcx>, Ty<'tcx>),\n+    CannotProve,\n+}\n+\n+pub type Goal<'tcx> = &'tcx GoalKind<'tcx>;\n+\n+pub type Goals<'tcx> = &'tcx List<Goal<'tcx>>;\n+\n+impl<'tcx> DomainGoal<'tcx> {\n+    pub fn into_goal(self) -> GoalKind<'tcx> {\n+        GoalKind::DomainGoal(self)\n+    }\n+\n+    pub fn into_program_clause(self) -> ProgramClause<'tcx> {\n+        ProgramClause {\n+            goal: self,\n+            hypotheses: ty::List::empty(),\n+            category: ProgramClauseCategory::Other,\n+        }\n+    }\n+}\n+\n+impl<'tcx> GoalKind<'tcx> {\n+    pub fn from_poly_domain_goal(\n+        domain_goal: PolyDomainGoal<'tcx>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> GoalKind<'tcx> {\n+        match domain_goal.no_bound_vars() {\n+            Some(p) => p.into_goal(),\n+            None => GoalKind::Quantified(\n+                QuantifierKind::Universal,\n+                domain_goal.map_bound(|p| tcx.mk_goal(p.into_goal())),\n+            ),\n+        }\n+    }\n+}\n+\n+/// This matches the definition from Page 7 of \"A Proof Procedure for the Logic of Hereditary\n+/// Harrop Formulas\".\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub enum Clause<'tcx> {\n+    Implies(ProgramClause<'tcx>),\n+    ForAll(ty::Binder<ProgramClause<'tcx>>),\n+}\n+\n+impl Clause<'tcx> {\n+    pub fn category(self) -> ProgramClauseCategory {\n+        match self {\n+            Clause::Implies(clause) => clause.category,\n+            Clause::ForAll(clause) => clause.skip_binder().category,\n+        }\n+    }\n+}\n+\n+/// Multiple clauses.\n+pub type Clauses<'tcx> = &'tcx List<Clause<'tcx>>;\n+\n+/// A \"program clause\" has the form `D :- G1, ..., Gn`. It is saying\n+/// that the domain goal `D` is true if `G1...Gn` are provable. This\n+/// is equivalent to the implication `G1..Gn => D`; we usually write\n+/// it with the reverse implication operator `:-` to emphasize the way\n+/// that programs are actually solved (via backchaining, which starts\n+/// with the goal to solve and proceeds from there).\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct ProgramClause<'tcx> {\n+    /// This goal will be considered true ...\n+    pub goal: DomainGoal<'tcx>,\n+\n+    /// ... if we can prove these hypotheses (there may be no hypotheses at all):\n+    pub hypotheses: Goals<'tcx>,\n+\n+    /// Useful for filtering clauses.\n+    pub category: ProgramClauseCategory,\n+}\n+\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable)]\n+pub enum ProgramClauseCategory {\n+    ImpliedBound,\n+    WellFormed,\n+    Other,\n+}\n+\n+/// A set of clauses that we assume to be true.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct Environment<'tcx> {\n+    pub clauses: Clauses<'tcx>,\n+}\n+\n+impl Environment<'tcx> {\n+    pub fn with<G>(self, goal: G) -> InEnvironment<'tcx, G> {\n+        InEnvironment { environment: self, goal }\n+    }\n+}\n+\n+/// Something (usually a goal), along with an environment.\n+#[derive(Copy, Clone, PartialEq, Eq, Hash, Debug, HashStable, TypeFoldable)]\n+pub struct InEnvironment<'tcx, G> {\n+    pub environment: Environment<'tcx>,\n+    pub goal: G,\n+}\n+\n+#[derive(Clone, Debug, TypeFoldable)]\n+pub enum SelectionError<'tcx> {\n+    Unimplemented,\n+    OutputTypeParameterMismatch(\n+        ty::PolyTraitRef<'tcx>,\n+        ty::PolyTraitRef<'tcx>,\n+        ty::error::TypeError<'tcx>,\n+    ),\n+    TraitNotObjectSafe(DefId),\n+    ConstEvalFailure(ErrorHandled),\n+    Overflow,\n+}\n+\n+/// When performing resolution, it is typically the case that there\n+/// can be one of three outcomes:\n+///\n+/// - `Ok(Some(r))`: success occurred with result `r`\n+/// - `Ok(None)`: could not definitely determine anything, usually due\n+///   to inconclusive type inference.\n+/// - `Err(e)`: error `e` occurred\n+pub type SelectionResult<'tcx, T> = Result<Option<T>, SelectionError<'tcx>>;\n+\n+/// Given the successful resolution of an obligation, the `Vtable`\n+/// indicates where the vtable comes from. Note that while we call this\n+/// a \"vtable\", it does not necessarily indicate dynamic dispatch at\n+/// runtime. `Vtable` instances just tell the compiler where to find\n+/// methods, but in generic code those methods are typically statically\n+/// dispatched -- only when an object is constructed is a `Vtable`\n+/// instance reified into an actual vtable.\n+///\n+/// For example, the vtable may be tied to a specific impl (case A),\n+/// or it may be relative to some bound that is in scope (case B).\n+///\n+/// ```\n+/// impl<T:Clone> Clone<T> for Option<T> { ... } // Impl_1\n+/// impl<T:Clone> Clone<T> for Box<T> { ... }    // Impl_2\n+/// impl Clone for int { ... }             // Impl_3\n+///\n+/// fn foo<T:Clone>(concrete: Option<Box<int>>,\n+///                 param: T,\n+///                 mixed: Option<T>) {\n+///\n+///    // Case A: Vtable points at a specific impl. Only possible when\n+///    // type is concretely known. If the impl itself has bounded\n+///    // type parameters, Vtable will carry resolutions for those as well:\n+///    concrete.clone(); // Vtable(Impl_1, [Vtable(Impl_2, [Vtable(Impl_3)])])\n+///\n+///    // Case B: Vtable must be provided by caller. This applies when\n+///    // type is a type parameter.\n+///    param.clone();    // VtableParam\n+///\n+///    // Case C: A mix of cases A and B.\n+///    mixed.clone();    // Vtable(Impl_1, [VtableParam])\n+/// }\n+/// ```\n+///\n+/// ### The type parameter `N`\n+///\n+/// See explanation on `VtableImplData`.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub enum Vtable<'tcx, N> {\n+    /// Vtable identifying a particular impl.\n+    VtableImpl(VtableImplData<'tcx, N>),\n+\n+    /// Vtable for auto trait implementations.\n+    /// This carries the information and nested obligations with regards\n+    /// to an auto implementation for a trait `Trait`. The nested obligations\n+    /// ensure the trait implementation holds for all the constituent types.\n+    VtableAutoImpl(VtableAutoImplData<N>),\n+\n+    /// Successful resolution to an obligation provided by the caller\n+    /// for some type parameter. The `Vec<N>` represents the\n+    /// obligations incurred from normalizing the where-clause (if\n+    /// any).\n+    VtableParam(Vec<N>),\n+\n+    /// Virtual calls through an object.\n+    VtableObject(VtableObjectData<'tcx, N>),\n+\n+    /// Successful resolution for a builtin trait.\n+    VtableBuiltin(VtableBuiltinData<N>),\n+\n+    /// Vtable automatically generated for a closure. The `DefId` is the ID\n+    /// of the closure expression. This is a `VtableImpl` in spirit, but the\n+    /// impl is generated by the compiler and does not appear in the source.\n+    VtableClosure(VtableClosureData<'tcx, N>),\n+\n+    /// Same as above, but for a function pointer type with the given signature.\n+    VtableFnPointer(VtableFnPointerData<'tcx, N>),\n+\n+    /// Vtable automatically generated for a generator.\n+    VtableGenerator(VtableGeneratorData<'tcx, N>),\n+\n+    /// Vtable for a trait alias.\n+    VtableTraitAlias(VtableTraitAliasData<'tcx, N>),\n+}\n+\n+impl<'tcx, N> Vtable<'tcx, N> {\n+    pub fn nested_obligations(self) -> Vec<N> {\n+        match self {\n+            VtableImpl(i) => i.nested,\n+            VtableParam(n) => n,\n+            VtableBuiltin(i) => i.nested,\n+            VtableAutoImpl(d) => d.nested,\n+            VtableClosure(c) => c.nested,\n+            VtableGenerator(c) => c.nested,\n+            VtableObject(d) => d.nested,\n+            VtableFnPointer(d) => d.nested,\n+            VtableTraitAlias(d) => d.nested,\n+        }\n+    }\n+\n+    pub fn map<M, F>(self, f: F) -> Vtable<'tcx, M>\n+    where\n+        F: FnMut(N) -> M,\n+    {\n+        match self {\n+            VtableImpl(i) => VtableImpl(VtableImplData {\n+                impl_def_id: i.impl_def_id,\n+                substs: i.substs,\n+                nested: i.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableParam(n) => VtableParam(n.into_iter().map(f).collect()),\n+            VtableBuiltin(i) => {\n+                VtableBuiltin(VtableBuiltinData { nested: i.nested.into_iter().map(f).collect() })\n+            }\n+            VtableObject(o) => VtableObject(VtableObjectData {\n+                upcast_trait_ref: o.upcast_trait_ref,\n+                vtable_base: o.vtable_base,\n+                nested: o.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableAutoImpl(d) => VtableAutoImpl(VtableAutoImplData {\n+                trait_def_id: d.trait_def_id,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableClosure(c) => VtableClosure(VtableClosureData {\n+                closure_def_id: c.closure_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableGenerator(c) => VtableGenerator(VtableGeneratorData {\n+                generator_def_id: c.generator_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableFnPointer(p) => VtableFnPointer(VtableFnPointerData {\n+                fn_ty: p.fn_ty,\n+                nested: p.nested.into_iter().map(f).collect(),\n+            }),\n+            VtableTraitAlias(d) => VtableTraitAlias(VtableTraitAliasData {\n+                alias_def_id: d.alias_def_id,\n+                substs: d.substs,\n+                nested: d.nested.into_iter().map(f).collect(),\n+            }),\n+        }\n+    }\n+}\n+\n+/// Identifies a particular impl in the source, along with a set of\n+/// substitutions from the impl's type/lifetime parameters. The\n+/// `nested` vector corresponds to the nested obligations attached to\n+/// the impl's type parameters.\n+///\n+/// The type parameter `N` indicates the type used for \"nested\n+/// obligations\" that are required by the impl. During type-check, this\n+/// is `Obligation`, as one might expect. During codegen, however, this\n+/// is `()`, because codegen only requires a shallow resolution of an\n+/// impl, and nested obligations are satisfied later.\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableImplData<'tcx, N> {\n+    pub impl_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableGeneratorData<'tcx, N> {\n+    pub generator_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the generator\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableClosureData<'tcx, N> {\n+    pub closure_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    /// Nested obligations. This can be non-empty if the closure\n+    /// signature contains associated types.\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableAutoImplData<N> {\n+    pub trait_def_id: DefId,\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableBuiltinData<N> {\n+    pub nested: Vec<N>,\n+}\n+\n+/// A vtable for some object-safe trait `Foo` automatically derived\n+/// for the object type `Foo`.\n+#[derive(PartialEq, Eq, Clone, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableObjectData<'tcx, N> {\n+    /// `Foo` upcast to the obligation trait. This will be some supertrait of `Foo`.\n+    pub upcast_trait_ref: ty::PolyTraitRef<'tcx>,\n+\n+    /// The vtable is formed by concatenating together the method lists of\n+    /// the base object trait and all supertraits; this is the start of\n+    /// `upcast_trait_ref`'s methods in that vtable.\n+    pub vtable_base: usize,\n+\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableFnPointerData<'tcx, N> {\n+    pub fn_ty: Ty<'tcx>,\n+    pub nested: Vec<N>,\n+}\n+\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, HashStable, TypeFoldable)]\n+pub struct VtableTraitAliasData<'tcx, N> {\n+    pub alias_def_id: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub nested: Vec<N>,\n+}\n+\n+pub trait ExClauseFold<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    fn fold_ex_clause_with<F: TypeFolder<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        folder: &mut F,\n+    ) -> chalk_engine::ExClause<Self>;\n+\n+    fn visit_ex_clause_with<V: TypeVisitor<'tcx>>(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        visitor: &mut V,\n+    ) -> bool;\n+}\n+\n+pub trait ChalkContextLift<'tcx>\n+where\n+    Self: chalk_engine::context::Context + Clone,\n+{\n+    type LiftedExClause: Debug + 'tcx;\n+    type LiftedDelayedLiteral: Debug + 'tcx;\n+    type LiftedLiteral: Debug + 'tcx;\n+\n+    fn lift_ex_clause_to_tcx(\n+        ex_clause: &chalk_engine::ExClause<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedExClause>;\n+\n+    fn lift_delayed_literal_to_tcx(\n+        ex_clause: &chalk_engine::DelayedLiteral<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedDelayedLiteral>;\n+\n+    fn lift_literal_to_tcx(\n+        ex_clause: &chalk_engine::Literal<Self>,\n+        tcx: TyCtxt<'tcx>,\n+    ) -> Option<Self::LiftedLiteral>;\n+}"}, {"sha": "c90551826202efd4300a90cde649cae91c71d8b0", "filename": "src/librustc/traits/types/query.rs", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fquery.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -0,0 +1,332 @@\n+//! Experimental types for the trait query interface. The methods\n+//! defined in this module are all based on **canonicalization**,\n+//! which makes a canonical query by replacing unbound inference\n+//! variables and regions, so that results can be reused more broadly.\n+//! The providers for the queries defined here can be found in\n+//! `librustc_traits`.\n+\n+use crate::ich::StableHashingContext;\n+use crate::infer::canonical::{Canonical, QueryResponse};\n+use crate::ty::error::TypeError;\n+use crate::ty::subst::GenericArg;\n+use crate::ty::{self, Ty, TyCtxt};\n+\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sync::Lrc;\n+use rustc_errors::struct_span_err;\n+use rustc_span::source_map::Span;\n+use std::iter::FromIterator;\n+use std::mem;\n+\n+pub mod type_op {\n+    use crate::ty::fold::TypeFoldable;\n+    use crate::ty::subst::UserSubsts;\n+    use crate::ty::{Predicate, Ty};\n+    use rustc_hir::def_id::DefId;\n+    use std::fmt;\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct AscribeUserType<'tcx> {\n+        pub mir_ty: Ty<'tcx>,\n+        pub def_id: DefId,\n+        pub user_substs: UserSubsts<'tcx>,\n+    }\n+\n+    impl<'tcx> AscribeUserType<'tcx> {\n+        pub fn new(mir_ty: Ty<'tcx>, def_id: DefId, user_substs: UserSubsts<'tcx>) -> Self {\n+            Self { mir_ty, def_id, user_substs }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct Eq<'tcx> {\n+        pub a: Ty<'tcx>,\n+        pub b: Ty<'tcx>,\n+    }\n+\n+    impl<'tcx> Eq<'tcx> {\n+        pub fn new(a: Ty<'tcx>, b: Ty<'tcx>) -> Self {\n+            Self { a, b }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct Subtype<'tcx> {\n+        pub sub: Ty<'tcx>,\n+        pub sup: Ty<'tcx>,\n+    }\n+\n+    impl<'tcx> Subtype<'tcx> {\n+        pub fn new(sub: Ty<'tcx>, sup: Ty<'tcx>) -> Self {\n+            Self { sub, sup }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct ProvePredicate<'tcx> {\n+        pub predicate: Predicate<'tcx>,\n+    }\n+\n+    impl<'tcx> ProvePredicate<'tcx> {\n+        pub fn new(predicate: Predicate<'tcx>) -> Self {\n+            ProvePredicate { predicate }\n+        }\n+    }\n+\n+    #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq, HashStable, TypeFoldable, Lift)]\n+    pub struct Normalize<T> {\n+        pub value: T,\n+    }\n+\n+    impl<'tcx, T> Normalize<T>\n+    where\n+        T: fmt::Debug + TypeFoldable<'tcx>,\n+    {\n+        pub fn new(value: T) -> Self {\n+            Self { value }\n+        }\n+    }\n+}\n+\n+pub type CanonicalProjectionGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::ProjectionTy<'tcx>>>;\n+\n+pub type CanonicalTyGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, Ty<'tcx>>>;\n+\n+pub type CanonicalPredicateGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, ty::Predicate<'tcx>>>;\n+\n+pub type CanonicalTypeOpAscribeUserTypeGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::AscribeUserType<'tcx>>>;\n+\n+pub type CanonicalTypeOpEqGoal<'tcx> = Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Eq<'tcx>>>;\n+\n+pub type CanonicalTypeOpSubtypeGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Subtype<'tcx>>>;\n+\n+pub type CanonicalTypeOpProvePredicateGoal<'tcx> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::ProvePredicate<'tcx>>>;\n+\n+pub type CanonicalTypeOpNormalizeGoal<'tcx, T> =\n+    Canonical<'tcx, ty::ParamEnvAnd<'tcx, type_op::Normalize<T>>>;\n+\n+#[derive(Clone, Debug, HashStable)]\n+pub struct NoSolution;\n+\n+pub type Fallible<T> = Result<T, NoSolution>;\n+\n+impl<'tcx> From<TypeError<'tcx>> for NoSolution {\n+    fn from(_: TypeError<'tcx>) -> NoSolution {\n+        NoSolution\n+    }\n+}\n+\n+#[derive(Clone, Debug, Default, HashStable, TypeFoldable, Lift)]\n+pub struct DropckOutlivesResult<'tcx> {\n+    pub kinds: Vec<GenericArg<'tcx>>,\n+    pub overflows: Vec<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> DropckOutlivesResult<'tcx> {\n+    pub fn report_overflows(&self, tcx: TyCtxt<'tcx>, span: Span, ty: Ty<'tcx>) {\n+        if let Some(overflow_ty) = self.overflows.iter().next() {\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                span,\n+                E0320,\n+                \"overflow while adding drop-check rules for {}\",\n+                ty,\n+            );\n+            err.note(&format!(\"overflowed on {}\", overflow_ty));\n+            err.emit();\n+        }\n+    }\n+\n+    pub fn into_kinds_reporting_overflows(\n+        self,\n+        tcx: TyCtxt<'tcx>,\n+        span: Span,\n+        ty: Ty<'tcx>,\n+    ) -> Vec<GenericArg<'tcx>> {\n+        self.report_overflows(tcx, span, ty);\n+        let DropckOutlivesResult { kinds, overflows: _ } = self;\n+        kinds\n+    }\n+}\n+\n+/// A set of constraints that need to be satisfied in order for\n+/// a type to be valid for destruction.\n+#[derive(Clone, Debug, HashStable)]\n+pub struct DtorckConstraint<'tcx> {\n+    /// Types that are required to be alive in order for this\n+    /// type to be valid for destruction.\n+    pub outlives: Vec<ty::subst::GenericArg<'tcx>>,\n+\n+    /// Types that could not be resolved: projections and params.\n+    pub dtorck_types: Vec<Ty<'tcx>>,\n+\n+    /// If, during the computation of the dtorck constraint, we\n+    /// overflow, that gets recorded here. The caller is expected to\n+    /// report an error.\n+    pub overflows: Vec<Ty<'tcx>>,\n+}\n+\n+impl<'tcx> DtorckConstraint<'tcx> {\n+    pub fn empty() -> DtorckConstraint<'tcx> {\n+        DtorckConstraint { outlives: vec![], dtorck_types: vec![], overflows: vec![] }\n+    }\n+}\n+\n+impl<'tcx> FromIterator<DtorckConstraint<'tcx>> for DtorckConstraint<'tcx> {\n+    fn from_iter<I: IntoIterator<Item = DtorckConstraint<'tcx>>>(iter: I) -> Self {\n+        let mut result = Self::empty();\n+\n+        for DtorckConstraint { outlives, dtorck_types, overflows } in iter {\n+            result.outlives.extend(outlives);\n+            result.dtorck_types.extend(dtorck_types);\n+            result.overflows.extend(overflows);\n+        }\n+\n+        result\n+    }\n+}\n+\n+/// This returns true if the type `ty` is \"trivial\" for\n+/// dropck-outlives -- that is, if it doesn't require any types to\n+/// outlive. This is similar but not *quite* the same as the\n+/// `needs_drop` test in the compiler already -- that is, for every\n+/// type T for which this function return true, needs-drop would\n+/// return `false`. But the reverse does not hold: in particular,\n+/// `needs_drop` returns false for `PhantomData`, but it is not\n+/// trivial for dropck-outlives.\n+///\n+/// Note also that `needs_drop` requires a \"global\" type (i.e., one\n+/// with erased regions), but this function does not.\n+pub fn trivial_dropck_outlives<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    match ty.kind {\n+        // None of these types have a destructor and hence they do not\n+        // require anything in particular to outlive the dtor's\n+        // execution.\n+        ty::Infer(ty::FreshIntTy(_))\n+        | ty::Infer(ty::FreshFloatTy(_))\n+        | ty::Bool\n+        | ty::Int(_)\n+        | ty::Uint(_)\n+        | ty::Float(_)\n+        | ty::Never\n+        | ty::FnDef(..)\n+        | ty::FnPtr(_)\n+        | ty::Char\n+        | ty::GeneratorWitness(..)\n+        | ty::RawPtr(_)\n+        | ty::Ref(..)\n+        | ty::Str\n+        | ty::Foreign(..)\n+        | ty::Error => true,\n+\n+        // [T; N] and [T] have same properties as T.\n+        ty::Array(ty, _) | ty::Slice(ty) => trivial_dropck_outlives(tcx, ty),\n+\n+        // (T1..Tn) and closures have same properties as T1..Tn --\n+        // check if *any* of those are trivial.\n+        ty::Tuple(ref tys) => tys.iter().all(|t| trivial_dropck_outlives(tcx, t.expect_ty())),\n+        ty::Closure(def_id, ref substs) => {\n+            substs.as_closure().upvar_tys(def_id, tcx).all(|t| trivial_dropck_outlives(tcx, t))\n+        }\n+\n+        ty::Adt(def, _) => {\n+            if Some(def.did) == tcx.lang_items().manually_drop() {\n+                // `ManuallyDrop` never has a dtor.\n+                true\n+            } else {\n+                // Other types might. Moreover, PhantomData doesn't\n+                // have a dtor, but it is considered to own its\n+                // content, so it is non-trivial. Unions can have `impl Drop`,\n+                // and hence are non-trivial as well.\n+                false\n+            }\n+        }\n+\n+        // The following *might* require a destructor: needs deeper inspection.\n+        ty::Dynamic(..)\n+        | ty::Projection(..)\n+        | ty::Param(_)\n+        | ty::Opaque(..)\n+        | ty::Placeholder(..)\n+        | ty::Infer(_)\n+        | ty::Bound(..)\n+        | ty::Generator(..) => false,\n+\n+        ty::UnnormalizedProjection(..) => bug!(\"only used with chalk-engine\"),\n+    }\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct CandidateStep<'tcx> {\n+    pub self_ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+    pub autoderefs: usize,\n+    /// `true` if the type results from a dereference of a raw pointer.\n+    /// when assembling candidates, we include these steps, but not when\n+    /// picking methods. This so that if we have `foo: *const Foo` and `Foo` has methods\n+    /// `fn by_raw_ptr(self: *const Self)` and `fn by_ref(&self)`, then\n+    /// `foo.by_raw_ptr()` will work and `foo.by_ref()` won't.\n+    pub from_unsafe_deref: bool,\n+    pub unsize: bool,\n+}\n+\n+#[derive(Clone, Debug, HashStable)]\n+pub struct MethodAutoderefStepsResult<'tcx> {\n+    /// The valid autoderef steps that could be find.\n+    pub steps: Lrc<Vec<CandidateStep<'tcx>>>,\n+    /// If Some(T), a type autoderef reported an error on.\n+    pub opt_bad_ty: Option<Lrc<MethodAutoderefBadTy<'tcx>>>,\n+    /// If `true`, `steps` has been truncated due to reaching the\n+    /// recursion limit.\n+    pub reached_recursion_limit: bool,\n+}\n+\n+#[derive(Debug, HashStable)]\n+pub struct MethodAutoderefBadTy<'tcx> {\n+    pub reached_raw_pointer: bool,\n+    pub ty: Canonical<'tcx, QueryResponse<'tcx, Ty<'tcx>>>,\n+}\n+\n+/// Result from the `normalize_projection_ty` query.\n+#[derive(Clone, Debug, HashStable, TypeFoldable, Lift)]\n+pub struct NormalizationResult<'tcx> {\n+    /// Result of normalization.\n+    pub normalized_ty: Ty<'tcx>,\n+}\n+\n+/// Outlives bounds are relationships between generic parameters,\n+/// whether they both be regions (`'a: 'b`) or whether types are\n+/// involved (`T: 'a`). These relationships can be extracted from the\n+/// full set of predicates we understand or also from types (in which\n+/// case they are called implied bounds). They are fed to the\n+/// `OutlivesEnv` which in turn is supplied to the region checker and\n+/// other parts of the inference system.\n+#[derive(Clone, Debug, TypeFoldable, Lift)]\n+pub enum OutlivesBound<'tcx> {\n+    RegionSubRegion(ty::Region<'tcx>, ty::Region<'tcx>),\n+    RegionSubParam(ty::Region<'tcx>, ty::ParamTy),\n+    RegionSubProjection(ty::Region<'tcx>, ty::ProjectionTy<'tcx>),\n+}\n+\n+impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for OutlivesBound<'tcx> {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        mem::discriminant(self).hash_stable(hcx, hasher);\n+        match *self {\n+            OutlivesBound::RegionSubRegion(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            OutlivesBound::RegionSubParam(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+            OutlivesBound::RegionSubProjection(ref a, ref b) => {\n+                a.hash_stable(hcx, hasher);\n+                b.hash_stable(hcx, hasher);\n+            }\n+        }\n+    }\n+}"}, {"sha": "ac3d0049c0c7c42908e6cff2df5b90e46ea13c50", "filename": "src/librustc/traits/types/select.rs", "status": "added", "additions": 290, "deletions": 0, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fselect.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -0,0 +1,290 @@\n+//! Candidate selection. See the [rustc guide] for more information on how this works.\n+//!\n+//! [rustc guide]: https://rust-lang.github.io/rustc-guide/traits/resolution.html#selection\n+\n+use self::EvaluationResult::*;\n+\n+use super::{SelectionError, SelectionResult};\n+\n+use crate::dep_graph::DepNodeIndex;\n+use crate::ty::{self, TyCtxt};\n+\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::sync::Lock;\n+use rustc_hir::def_id::DefId;\n+\n+#[derive(Clone, Default)]\n+pub struct SelectionCache<'tcx> {\n+    pub hashmap: Lock<\n+        FxHashMap<\n+            ty::ParamEnvAnd<'tcx, ty::TraitRef<'tcx>>,\n+            WithDepNode<SelectionResult<'tcx, SelectionCandidate<'tcx>>>,\n+        >,\n+    >,\n+}\n+\n+impl<'tcx> SelectionCache<'tcx> {\n+    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n+    pub fn clear(&self) {\n+        *self.hashmap.borrow_mut() = Default::default();\n+    }\n+}\n+\n+/// The selection process begins by considering all impls, where\n+/// clauses, and so forth that might resolve an obligation. Sometimes\n+/// we'll be able to say definitively that (e.g.) an impl does not\n+/// apply to the obligation: perhaps it is defined for `usize` but the\n+/// obligation is for `int`. In that case, we drop the impl out of the\n+/// list. But the other cases are considered *candidates*.\n+///\n+/// For selection to succeed, there must be exactly one matching\n+/// candidate. If the obligation is fully known, this is guaranteed\n+/// by coherence. However, if the obligation contains type parameters\n+/// or variables, there may be multiple such impls.\n+///\n+/// It is not a real problem if multiple matching impls exist because\n+/// of type variables - it just means the obligation isn't sufficiently\n+/// elaborated. In that case we report an ambiguity, and the caller can\n+/// try again after more type information has been gathered or report a\n+/// \"type annotations needed\" error.\n+///\n+/// However, with type parameters, this can be a real problem - type\n+/// parameters don't unify with regular types, but they *can* unify\n+/// with variables from blanket impls, and (unless we know its bounds\n+/// will always be satisfied) picking the blanket impl will be wrong\n+/// for at least *some* substitutions. To make this concrete, if we have\n+///\n+///    trait AsDebug { type Out : fmt::Debug; fn debug(self) -> Self::Out; }\n+///    impl<T: fmt::Debug> AsDebug for T {\n+///        type Out = T;\n+///        fn debug(self) -> fmt::Debug { self }\n+///    }\n+///    fn foo<T: AsDebug>(t: T) { println!(\"{:?}\", <T as AsDebug>::debug(t)); }\n+///\n+/// we can't just use the impl to resolve the `<T as AsDebug>` obligation\n+/// -- a type from another crate (that doesn't implement `fmt::Debug`) could\n+/// implement `AsDebug`.\n+///\n+/// Because where-clauses match the type exactly, multiple clauses can\n+/// only match if there are unresolved variables, and we can mostly just\n+/// report this ambiguity in that case. This is still a problem - we can't\n+/// *do anything* with ambiguities that involve only regions. This is issue\n+/// #21974.\n+///\n+/// If a single where-clause matches and there are no inference\n+/// variables left, then it definitely matches and we can just select\n+/// it.\n+///\n+/// In fact, we even select the where-clause when the obligation contains\n+/// inference variables. The can lead to inference making \"leaps of logic\",\n+/// for example in this situation:\n+///\n+///    pub trait Foo<T> { fn foo(&self) -> T; }\n+///    impl<T> Foo<()> for T { fn foo(&self) { } }\n+///    impl Foo<bool> for bool { fn foo(&self) -> bool { *self } }\n+///\n+///    pub fn foo<T>(t: T) where T: Foo<bool> {\n+///       println!(\"{:?}\", <T as Foo<_>>::foo(&t));\n+///    }\n+///    fn main() { foo(false); }\n+///\n+/// Here the obligation `<T as Foo<$0>>` can be matched by both the blanket\n+/// impl and the where-clause. We select the where-clause and unify `$0=bool`,\n+/// so the program prints \"false\". However, if the where-clause is omitted,\n+/// the blanket impl is selected, we unify `$0=()`, and the program prints\n+/// \"()\".\n+///\n+/// Exactly the same issues apply to projection and object candidates, except\n+/// that we can have both a projection candidate and a where-clause candidate\n+/// for the same obligation. In that case either would do (except that\n+/// different \"leaps of logic\" would occur if inference variables are\n+/// present), and we just pick the where-clause. This is, for example,\n+/// required for associated types to work in default impls, as the bounds\n+/// are visible both as projection bounds and as where-clauses from the\n+/// parameter environment.\n+#[derive(PartialEq, Eq, Debug, Clone, TypeFoldable)]\n+pub enum SelectionCandidate<'tcx> {\n+    BuiltinCandidate {\n+        /// `false` if there are no *further* obligations.\n+        has_nested: bool,\n+    },\n+    ParamCandidate(ty::PolyTraitRef<'tcx>),\n+    ImplCandidate(DefId),\n+    AutoImplCandidate(DefId),\n+\n+    /// This is a trait matching with a projected type as `Self`, and\n+    /// we found an applicable bound in the trait definition.\n+    ProjectionCandidate,\n+\n+    /// Implementation of a `Fn`-family trait by one of the anonymous types\n+    /// generated for a `||` expression.\n+    ClosureCandidate,\n+\n+    /// Implementation of a `Generator` trait by one of the anonymous types\n+    /// generated for a generator.\n+    GeneratorCandidate,\n+\n+    /// Implementation of a `Fn`-family trait by one of the anonymous\n+    /// types generated for a fn pointer type (e.g., `fn(int) -> int`)\n+    FnPointerCandidate,\n+\n+    TraitAliasCandidate(DefId),\n+\n+    ObjectCandidate,\n+\n+    BuiltinObjectCandidate,\n+\n+    BuiltinUnsizeCandidate,\n+}\n+\n+/// The result of trait evaluation. The order is important\n+/// here as the evaluation of a list is the maximum of the\n+/// evaluations.\n+///\n+/// The evaluation results are ordered:\n+///     - `EvaluatedToOk` implies `EvaluatedToOkModuloRegions`\n+///       implies `EvaluatedToAmbig` implies `EvaluatedToUnknown`\n+///     - `EvaluatedToErr` implies `EvaluatedToRecur`\n+///     - the \"union\" of evaluation results is equal to their maximum -\n+///     all the \"potential success\" candidates can potentially succeed,\n+///     so they are noops when unioned with a definite error, and within\n+///     the categories it's easy to see that the unions are correct.\n+#[derive(Copy, Clone, Debug, PartialOrd, Ord, PartialEq, Eq, HashStable)]\n+pub enum EvaluationResult {\n+    /// Evaluation successful.\n+    EvaluatedToOk,\n+    /// Evaluation successful, but there were unevaluated region obligations.\n+    EvaluatedToOkModuloRegions,\n+    /// Evaluation is known to be ambiguous -- it *might* hold for some\n+    /// assignment of inference variables, but it might not.\n+    ///\n+    /// While this has the same meaning as `EvaluatedToUnknown` -- we can't\n+    /// know whether this obligation holds or not -- it is the result we\n+    /// would get with an empty stack, and therefore is cacheable.\n+    EvaluatedToAmbig,\n+    /// Evaluation failed because of recursion involving inference\n+    /// variables. We are somewhat imprecise there, so we don't actually\n+    /// know the real result.\n+    ///\n+    /// This can't be trivially cached for the same reason as `EvaluatedToRecur`.\n+    EvaluatedToUnknown,\n+    /// Evaluation failed because we encountered an obligation we are already\n+    /// trying to prove on this branch.\n+    ///\n+    /// We know this branch can't be a part of a minimal proof-tree for\n+    /// the \"root\" of our cycle, because then we could cut out the recursion\n+    /// and maintain a valid proof tree. However, this does not mean\n+    /// that all the obligations on this branch do not hold -- it's possible\n+    /// that we entered this branch \"speculatively\", and that there\n+    /// might be some other way to prove this obligation that does not\n+    /// go through this cycle -- so we can't cache this as a failure.\n+    ///\n+    /// For example, suppose we have this:\n+    ///\n+    /// ```rust,ignore (pseudo-Rust)\n+    /// pub trait Trait { fn xyz(); }\n+    /// // This impl is \"useless\", but we can still have\n+    /// // an `impl Trait for SomeUnsizedType` somewhere.\n+    /// impl<T: Trait + Sized> Trait for T { fn xyz() {} }\n+    ///\n+    /// pub fn foo<T: Trait + ?Sized>() {\n+    ///     <T as Trait>::xyz();\n+    /// }\n+    /// ```\n+    ///\n+    /// When checking `foo`, we have to prove `T: Trait`. This basically\n+    /// translates into this:\n+    ///\n+    /// ```plain,ignore\n+    /// (T: Trait + Sized \u2192_\\impl T: Trait), T: Trait \u22a2 T: Trait\n+    /// ```\n+    ///\n+    /// When we try to prove it, we first go the first option, which\n+    /// recurses. This shows us that the impl is \"useless\" -- it won't\n+    /// tell us that `T: Trait` unless it already implemented `Trait`\n+    /// by some other means. However, that does not prevent `T: Trait`\n+    /// does not hold, because of the bound (which can indeed be satisfied\n+    /// by `SomeUnsizedType` from another crate).\n+    //\n+    // FIXME: when an `EvaluatedToRecur` goes past its parent root, we\n+    // ought to convert it to an `EvaluatedToErr`, because we know\n+    // there definitely isn't a proof tree for that obligation. Not\n+    // doing so is still sound -- there isn't any proof tree, so the\n+    // branch still can't be a part of a minimal one -- but does not re-enable caching.\n+    EvaluatedToRecur,\n+    /// Evaluation failed.\n+    EvaluatedToErr,\n+}\n+\n+impl EvaluationResult {\n+    /// Returns `true` if this evaluation result is known to apply, even\n+    /// considering outlives constraints.\n+    pub fn must_apply_considering_regions(self) -> bool {\n+        self == EvaluatedToOk\n+    }\n+\n+    /// Returns `true` if this evaluation result is known to apply, ignoring\n+    /// outlives constraints.\n+    pub fn must_apply_modulo_regions(self) -> bool {\n+        self <= EvaluatedToOkModuloRegions\n+    }\n+\n+    pub fn may_apply(self) -> bool {\n+        match self {\n+            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToUnknown => {\n+                true\n+            }\n+\n+            EvaluatedToErr | EvaluatedToRecur => false,\n+        }\n+    }\n+\n+    pub fn is_stack_dependent(self) -> bool {\n+        match self {\n+            EvaluatedToUnknown | EvaluatedToRecur => true,\n+\n+            EvaluatedToOk | EvaluatedToOkModuloRegions | EvaluatedToAmbig | EvaluatedToErr => false,\n+        }\n+    }\n+}\n+\n+/// Indicates that trait evaluation caused overflow.\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, HashStable)]\n+pub struct OverflowError;\n+\n+impl<'tcx> From<OverflowError> for SelectionError<'tcx> {\n+    fn from(OverflowError: OverflowError) -> SelectionError<'tcx> {\n+        SelectionError::Overflow\n+    }\n+}\n+\n+#[derive(Clone, Default)]\n+pub struct EvaluationCache<'tcx> {\n+    pub hashmap: Lock<\n+        FxHashMap<ty::ParamEnvAnd<'tcx, ty::PolyTraitRef<'tcx>>, WithDepNode<EvaluationResult>>,\n+    >,\n+}\n+\n+impl<'tcx> EvaluationCache<'tcx> {\n+    /// Actually frees the underlying memory in contrast to what stdlib containers do on `clear`\n+    pub fn clear(&self) {\n+        *self.hashmap.borrow_mut() = Default::default();\n+    }\n+}\n+\n+#[derive(Clone, Eq, PartialEq)]\n+pub struct WithDepNode<T> {\n+    dep_node: DepNodeIndex,\n+    cached_value: T,\n+}\n+\n+impl<T: Clone> WithDepNode<T> {\n+    pub fn new(dep_node: DepNodeIndex, cached_value: T) -> Self {\n+        WithDepNode { dep_node, cached_value }\n+    }\n+\n+    pub fn get(&self, tcx: TyCtxt<'_>) -> T {\n+        tcx.dep_graph.read_index(self.dep_node);\n+        self.cached_value.clone()\n+    }\n+}"}, {"sha": "3086850db6d9cdf38a57ee9b5afa0ac969827446", "filename": "src/librustc/traits/types/specialization_graph.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fspecialization_graph.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -0,0 +1,199 @@\n+use crate::ich::{self, StableHashingContext};\n+use crate::ty::fast_reject::SimplifiedType;\n+use crate::ty::{self, TyCtxt};\n+use rustc_data_structures::fx::FxHashMap;\n+use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def_id::{DefId, DefIdMap};\n+use syntax::ast::Ident;\n+\n+/// A per-trait graph of impls in specialization order. At the moment, this\n+/// graph forms a tree rooted with the trait itself, with all other nodes\n+/// representing impls, and parent-child relationships representing\n+/// specializations.\n+///\n+/// The graph provides two key services:\n+///\n+/// - Construction. This implicitly checks for overlapping impls (i.e., impls\n+///   that overlap but where neither specializes the other -- an artifact of the\n+///   simple \"chain\" rule.\n+///\n+/// - Parent extraction. In particular, the graph can give you the *immediate*\n+///   parents of a given specializing impl, which is needed for extracting\n+///   default items amongst other things. In the simple \"chain\" rule, every impl\n+///   has at most one parent.\n+#[derive(RustcEncodable, RustcDecodable, HashStable)]\n+pub struct Graph {\n+    // All impls have a parent; the \"root\" impls have as their parent the `def_id`\n+    // of the trait.\n+    pub parent: DefIdMap<DefId>,\n+\n+    // The \"root\" impls are found by looking up the trait's def_id.\n+    pub children: DefIdMap<Children>,\n+}\n+\n+impl Graph {\n+    pub fn new() -> Graph {\n+        Graph { parent: Default::default(), children: Default::default() }\n+    }\n+\n+    /// The parent of a given impl, which is the `DefId` of the trait when the\n+    /// impl is a \"specialization root\".\n+    pub fn parent(&self, child: DefId) -> DefId {\n+        *self.parent.get(&child).unwrap_or_else(|| panic!(\"Failed to get parent for {:?}\", child))\n+    }\n+}\n+\n+/// Children of a given impl, grouped into blanket/non-blanket varieties as is\n+/// done in `TraitDef`.\n+#[derive(Default, RustcEncodable, RustcDecodable)]\n+pub struct Children {\n+    // Impls of a trait (or specializations of a given impl). To allow for\n+    // quicker lookup, the impls are indexed by a simplified version of their\n+    // `Self` type: impls with a simplifiable `Self` are stored in\n+    // `nonblanket_impls` keyed by it, while all other impls are stored in\n+    // `blanket_impls`.\n+    //\n+    // A similar division is used within `TraitDef`, but the lists there collect\n+    // together *all* the impls for a trait, and are populated prior to building\n+    // the specialization graph.\n+    /// Impls of the trait.\n+    pub nonblanket_impls: FxHashMap<SimplifiedType, Vec<DefId>>,\n+\n+    /// Blanket impls associated with the trait.\n+    pub blanket_impls: Vec<DefId>,\n+}\n+\n+/// A node in the specialization graph is either an impl or a trait\n+/// definition; either can serve as a source of item definitions.\n+/// There is always exactly one trait definition node: the root.\n+#[derive(Debug, Copy, Clone)]\n+pub enum Node {\n+    Impl(DefId),\n+    Trait(DefId),\n+}\n+\n+impl<'tcx> Node {\n+    pub fn is_from_trait(&self) -> bool {\n+        match *self {\n+            Node::Trait(..) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Iterate over the items defined directly by the given (impl or trait) node.\n+    pub fn items(&self, tcx: TyCtxt<'tcx>) -> ty::AssocItemsIterator<'tcx> {\n+        tcx.associated_items(self.def_id())\n+    }\n+\n+    /// Finds an associated item defined in this node.\n+    ///\n+    /// If this returns `None`, the item can potentially still be found in\n+    /// parents of this node.\n+    pub fn item(\n+        &self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_item_name: Ident,\n+        trait_item_kind: ty::AssocKind,\n+        trait_def_id: DefId,\n+    ) -> Option<ty::AssocItem> {\n+        use crate::ty::AssocKind::*;\n+\n+        tcx.associated_items(self.def_id()).find(move |impl_item| {\n+            match (trait_item_kind, impl_item.kind) {\n+                | (Const, Const)\n+                | (Method, Method)\n+                | (Type, Type)\n+                | (Type, OpaqueTy)  // assoc. types can be made opaque in impls\n+                => tcx.hygienic_eq(impl_item.ident, trait_item_name, trait_def_id),\n+\n+                | (Const, _)\n+                | (Method, _)\n+                | (Type, _)\n+                | (OpaqueTy, _)\n+                => false,\n+            }\n+        })\n+    }\n+\n+    pub fn def_id(&self) -> DefId {\n+        match *self {\n+            Node::Impl(did) => did,\n+            Node::Trait(did) => did,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Ancestors<'tcx> {\n+    trait_def_id: DefId,\n+    specialization_graph: &'tcx Graph,\n+    current_source: Option<Node>,\n+}\n+\n+impl Iterator for Ancestors<'_> {\n+    type Item = Node;\n+    fn next(&mut self) -> Option<Node> {\n+        let cur = self.current_source.take();\n+        if let Some(Node::Impl(cur_impl)) = cur {\n+            let parent = self.specialization_graph.parent(cur_impl);\n+\n+            self.current_source = if parent == self.trait_def_id {\n+                Some(Node::Trait(parent))\n+            } else {\n+                Some(Node::Impl(parent))\n+            };\n+        }\n+        cur\n+    }\n+}\n+\n+pub struct NodeItem<T> {\n+    pub node: Node,\n+    pub item: T,\n+}\n+\n+impl<T> NodeItem<T> {\n+    pub fn map<U, F: FnOnce(T) -> U>(self, f: F) -> NodeItem<U> {\n+        NodeItem { node: self.node, item: f(self.item) }\n+    }\n+}\n+\n+impl<'tcx> Ancestors<'tcx> {\n+    /// Finds the bottom-most (ie. most specialized) definition of an associated\n+    /// item.\n+    pub fn leaf_def(\n+        mut self,\n+        tcx: TyCtxt<'tcx>,\n+        trait_item_name: Ident,\n+        trait_item_kind: ty::AssocKind,\n+    ) -> Option<NodeItem<ty::AssocItem>> {\n+        let trait_def_id = self.trait_def_id;\n+        self.find_map(|node| {\n+            node.item(tcx, trait_item_name, trait_item_kind, trait_def_id)\n+                .map(|item| NodeItem { node, item })\n+        })\n+    }\n+}\n+\n+/// Walk up the specialization ancestors of a given impl, starting with that\n+/// impl itself.\n+pub fn ancestors(\n+    tcx: TyCtxt<'tcx>,\n+    trait_def_id: DefId,\n+    start_from_impl: DefId,\n+) -> Ancestors<'tcx> {\n+    let specialization_graph = tcx.specialization_graph_of(trait_def_id);\n+    Ancestors {\n+        trait_def_id,\n+        specialization_graph,\n+        current_source: Some(Node::Impl(start_from_impl)),\n+    }\n+}\n+\n+impl<'a> HashStable<StableHashingContext<'a>> for Children {\n+    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n+        let Children { ref nonblanket_impls, ref blanket_impls } = *self;\n+\n+        ich::hash_stable_trait_impls(hcx, hasher, blanket_impls, nonblanket_impls);\n+    }\n+}"}, {"sha": "48ed29f2bb33841cc974147d5b81218453a2cb16", "filename": "src/librustc/traits/types/structural_impls.rs", "status": "added", "additions": 712, "deletions": 0, "changes": 712, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ftypes%2Fstructural_impls.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -0,0 +1,712 @@\n+use crate::traits;\n+use crate::ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n+use crate::ty::{self, Lift, Ty, TyCtxt};\n+use rustc_span::symbol::Symbol;\n+use smallvec::SmallVec;\n+\n+use std::collections::{BTreeMap, BTreeSet};\n+use std::fmt;\n+use std::rc::Rc;\n+\n+// Structural impls for the structs in `traits`.\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::Vtable<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match *self {\n+            super::VtableImpl(ref v) => write!(f, \"{:?}\", v),\n+\n+            super::VtableAutoImpl(ref t) => write!(f, \"{:?}\", t),\n+\n+            super::VtableClosure(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableGenerator(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableFnPointer(ref d) => write!(f, \"VtableFnPointer({:?})\", d),\n+\n+            super::VtableObject(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableParam(ref n) => write!(f, \"VtableParam({:?})\", n),\n+\n+            super::VtableBuiltin(ref d) => write!(f, \"{:?}\", d),\n+\n+            super::VtableTraitAlias(ref d) => write!(f, \"{:?}\", d),\n+        }\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableImplData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableImplData(impl_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.impl_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableGeneratorData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableGeneratorData(generator_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.generator_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableClosureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableClosureData(closure_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.closure_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<N: fmt::Debug> fmt::Debug for traits::VtableBuiltinData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"VtableBuiltinData(nested={:?})\", self.nested)\n+    }\n+}\n+\n+impl<N: fmt::Debug> fmt::Debug for traits::VtableAutoImplData<N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableAutoImplData(trait_def_id={:?}, nested={:?})\",\n+            self.trait_def_id, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableObjectData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableObjectData(upcast={:?}, vtable_base={}, nested={:?})\",\n+            self.upcast_trait_ref, self.vtable_base, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableFnPointerData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"VtableFnPointerData(fn_ty={:?}, nested={:?})\", self.fn_ty, self.nested)\n+    }\n+}\n+\n+impl<'tcx, N: fmt::Debug> fmt::Debug for traits::VtableTraitAliasData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"VtableTraitAlias(alias_def_id={:?}, substs={:?}, nested={:?})\",\n+            self.alias_def_id, self.substs, self.nested\n+        )\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WhereClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::WhereClause::*;\n+\n+        // Bypass `ty::print` because it does not print out anonymous regions.\n+        // FIXME(eddyb) implement a custom `PrettyPrinter`, or move this to `ty::print`.\n+        fn write_region_name<'tcx>(\n+            r: ty::Region<'tcx>,\n+            fmt: &mut fmt::Formatter<'_>,\n+        ) -> fmt::Result {\n+            match r {\n+                ty::ReLateBound(index, br) => match br {\n+                    ty::BoundRegion::BrNamed(_, name) => write!(fmt, \"{}\", name),\n+                    ty::BoundRegion::BrAnon(var) => {\n+                        if *index == ty::INNERMOST {\n+                            write!(fmt, \"'^{}\", var)\n+                        } else {\n+                            write!(fmt, \"'^{}_{}\", index.index(), var)\n+                        }\n+                    }\n+                    _ => write!(fmt, \"'_\"),\n+                },\n+\n+                _ => write!(fmt, \"{}\", r),\n+            }\n+        }\n+\n+        match self {\n+            Implemented(trait_ref) => write!(fmt, \"Implemented({})\", trait_ref),\n+            ProjectionEq(projection) => write!(fmt, \"ProjectionEq({})\", projection),\n+            RegionOutlives(predicate) => {\n+                write!(fmt, \"RegionOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n+            }\n+            TypeOutlives(predicate) => {\n+                write!(fmt, \"TypeOutlives({}: \", predicate.0)?;\n+                write_region_name(predicate.1, fmt)?;\n+                write!(fmt, \")\")\n+            }\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::WellFormed<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::WellFormed::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"WellFormed({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"WellFormed({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::FromEnv<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::FromEnv::*;\n+\n+        match self {\n+            Trait(trait_ref) => write!(fmt, \"FromEnv({})\", trait_ref),\n+            Ty(ty) => write!(fmt, \"FromEnv({})\", ty),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::DomainGoal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::DomainGoal::*;\n+\n+        match self {\n+            Holds(wc) => write!(fmt, \"{}\", wc),\n+            WellFormed(wf) => write!(fmt, \"{}\", wf),\n+            FromEnv(from_env) => write!(fmt, \"{}\", from_env),\n+            Normalize(projection) => {\n+                write!(fmt, \"Normalize({} -> {})\", projection.projection_ty, projection.ty)\n+            }\n+        }\n+    }\n+}\n+\n+impl fmt::Display for traits::QuantifierKind {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::QuantifierKind::*;\n+\n+        match self {\n+            Universal => write!(fmt, \"forall\"),\n+            Existential => write!(fmt, \"exists\"),\n+        }\n+    }\n+}\n+\n+/// Collect names for regions / types bound by a quantified goal / clause.\n+/// This collector does not try to do anything clever like in `ty::print`, it's just used\n+/// for debug output in tests anyway.\n+struct BoundNamesCollector {\n+    // Just sort by name because `BoundRegion::BrNamed` does not have a `BoundVar` index anyway.\n+    regions: BTreeSet<Symbol>,\n+\n+    // Sort by `BoundVar` index, so usually this should be equivalent to the order given\n+    // by the list of type parameters.\n+    types: BTreeMap<u32, Symbol>,\n+\n+    binder_index: ty::DebruijnIndex,\n+}\n+\n+impl BoundNamesCollector {\n+    fn new() -> Self {\n+        BoundNamesCollector {\n+            regions: BTreeSet::new(),\n+            types: BTreeMap::new(),\n+            binder_index: ty::INNERMOST,\n+        }\n+    }\n+\n+    fn is_empty(&self) -> bool {\n+        self.regions.is_empty() && self.types.is_empty()\n+    }\n+\n+    fn write_names(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let mut start = true;\n+        for r in &self.regions {\n+            if !start {\n+                write!(fmt, \", \")?;\n+            }\n+            start = false;\n+            write!(fmt, \"{}\", r)?;\n+        }\n+        for (_, t) in &self.types {\n+            if !start {\n+                write!(fmt, \", \")?;\n+            }\n+            start = false;\n+            write!(fmt, \"{}\", t)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for BoundNamesCollector {\n+    fn visit_binder<T: TypeFoldable<'tcx>>(&mut self, t: &ty::Binder<T>) -> bool {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> bool {\n+        match t.kind {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                self.types.insert(\n+                    bound_ty.var.as_u32(),\n+                    match bound_ty.kind {\n+                        ty::BoundTyKind::Param(name) => name,\n+                        ty::BoundTyKind::Anon => {\n+                            Symbol::intern(&format!(\"^{}\", bound_ty.var.as_u32()))\n+                        }\n+                    },\n+                );\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n+\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => match br {\n+                ty::BoundRegion::BrNamed(_, name) => {\n+                    self.regions.insert(*name);\n+                }\n+\n+                ty::BoundRegion::BrAnon(var) => {\n+                    self.regions.insert(Symbol::intern(&format!(\"'^{}\", var)));\n+                }\n+\n+                _ => (),\n+            },\n+\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Goal<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::GoalKind::*;\n+\n+        match self {\n+            Implies(hypotheses, goal) => {\n+                write!(fmt, \"if (\")?;\n+                for (index, hyp) in hypotheses.iter().enumerate() {\n+                    if index > 0 {\n+                        write!(fmt, \", \")?;\n+                    }\n+                    write!(fmt, \"{}\", hyp)?;\n+                }\n+                write!(fmt, \") {{ {} }}\", goal)\n+            }\n+            And(goal1, goal2) => write!(fmt, \"({} && {})\", goal1, goal2),\n+            Not(goal) => write!(fmt, \"not {{ {} }}\", goal),\n+            DomainGoal(goal) => write!(fmt, \"{}\", goal),\n+            Quantified(qkind, goal) => {\n+                let mut collector = BoundNamesCollector::new();\n+                goal.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"{}<\", qkind)?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", goal.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+            Subtype(a, b) => write!(fmt, \"{} <: {}\", a, b),\n+            CannotProve => write!(fmt, \"CannotProve\"),\n+        }\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::ProgramClause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        let traits::ProgramClause { goal, hypotheses, .. } = self;\n+        write!(fmt, \"{}\", goal)?;\n+        if !hypotheses.is_empty() {\n+            write!(fmt, \" :- \")?;\n+            for (index, condition) in hypotheses.iter().enumerate() {\n+                if index > 0 {\n+                    write!(fmt, \", \")?;\n+                }\n+                write!(fmt, \"{}\", condition)?;\n+            }\n+        }\n+        write!(fmt, \".\")\n+    }\n+}\n+\n+impl<'tcx> fmt::Display for traits::Clause<'tcx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use crate::traits::Clause::*;\n+\n+        match self {\n+            Implies(clause) => write!(fmt, \"{}\", clause),\n+            ForAll(clause) => {\n+                let mut collector = BoundNamesCollector::new();\n+                clause.skip_binder().visit_with(&mut collector);\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \"forall<\")?;\n+                    collector.write_names(fmt)?;\n+                    write!(fmt, \"> {{ \")?;\n+                }\n+\n+                write!(fmt, \"{}\", clause.skip_binder())?;\n+\n+                if !collector.is_empty() {\n+                    write!(fmt, \" }}\")?;\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// Lift implementations\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::SelectionError<'a> {\n+    type Lifted = traits::SelectionError<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::Unimplemented => Some(super::Unimplemented),\n+            super::OutputTypeParameterMismatch(a, b, ref err) => {\n+                tcx.lift(&(a, b)).and_then(|(a, b)| {\n+                    tcx.lift(err).map(|err| super::OutputTypeParameterMismatch(a, b, err))\n+                })\n+            }\n+            super::TraitNotObjectSafe(def_id) => Some(super::TraitNotObjectSafe(def_id)),\n+            super::ConstEvalFailure(err) => Some(super::ConstEvalFailure(err)),\n+            super::Overflow => Some(super::Overflow),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCauseCode<'a> {\n+    type Lifted = traits::ObligationCauseCode<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match *self {\n+            super::ReturnNoExpression => Some(super::ReturnNoExpression),\n+            super::MiscObligation => Some(super::MiscObligation),\n+            super::SliceOrArrayElem => Some(super::SliceOrArrayElem),\n+            super::TupleElem => Some(super::TupleElem),\n+            super::ProjectionWf(proj) => tcx.lift(&proj).map(super::ProjectionWf),\n+            super::ItemObligation(def_id) => Some(super::ItemObligation(def_id)),\n+            super::BindingObligation(def_id, span) => Some(super::BindingObligation(def_id, span)),\n+            super::ReferenceOutlivesReferent(ty) => {\n+                tcx.lift(&ty).map(super::ReferenceOutlivesReferent)\n+            }\n+            super::ObjectTypeBound(ty, r) => tcx\n+                .lift(&ty)\n+                .and_then(|ty| tcx.lift(&r).and_then(|r| Some(super::ObjectTypeBound(ty, r)))),\n+            super::ObjectCastObligation(ty) => tcx.lift(&ty).map(super::ObjectCastObligation),\n+            super::Coercion { source, target } => {\n+                Some(super::Coercion { source: tcx.lift(&source)?, target: tcx.lift(&target)? })\n+            }\n+            super::AssignmentLhsSized => Some(super::AssignmentLhsSized),\n+            super::TupleInitializerSized => Some(super::TupleInitializerSized),\n+            super::StructInitializerSized => Some(super::StructInitializerSized),\n+            super::VariableType(id) => Some(super::VariableType(id)),\n+            super::ReturnValue(id) => Some(super::ReturnValue(id)),\n+            super::ReturnType => Some(super::ReturnType),\n+            super::SizedArgumentType => Some(super::SizedArgumentType),\n+            super::SizedReturnType => Some(super::SizedReturnType),\n+            super::SizedYieldType => Some(super::SizedYieldType),\n+            super::RepeatVec(suggest_flag) => Some(super::RepeatVec(suggest_flag)),\n+            super::FieldSized { adt_kind, last } => Some(super::FieldSized { adt_kind, last }),\n+            super::ConstSized => Some(super::ConstSized),\n+            super::ConstPatternStructural => Some(super::ConstPatternStructural),\n+            super::SharedStatic => Some(super::SharedStatic),\n+            super::BuiltinDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::BuiltinDerivedObligation)\n+            }\n+            super::ImplDerivedObligation(ref cause) => {\n+                tcx.lift(cause).map(super::ImplDerivedObligation)\n+            }\n+            super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            } => Some(super::CompareImplMethodObligation {\n+                item_name,\n+                impl_item_def_id,\n+                trait_item_def_id,\n+            }),\n+            super::CompareImplTypeObligation { item_name, impl_item_def_id, trait_item_def_id } => {\n+                Some(super::CompareImplTypeObligation {\n+                    item_name,\n+                    impl_item_def_id,\n+                    trait_item_def_id,\n+                })\n+            }\n+            super::ExprAssignable => Some(super::ExprAssignable),\n+            super::MatchExpressionArm(box super::MatchExpressionArmCause {\n+                arm_span,\n+                source,\n+                ref prior_arms,\n+                last_ty,\n+                scrut_hir_id,\n+            }) => tcx.lift(&last_ty).map(|last_ty| {\n+                super::MatchExpressionArm(box super::MatchExpressionArmCause {\n+                    arm_span,\n+                    source,\n+                    prior_arms: prior_arms.clone(),\n+                    last_ty,\n+                    scrut_hir_id,\n+                })\n+            }),\n+            super::Pattern { span, root_ty, origin_expr } => {\n+                tcx.lift(&root_ty).map(|root_ty| super::Pattern { span, root_ty, origin_expr })\n+            }\n+            super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }) => {\n+                Some(super::IfExpression(box super::IfExpressionCause { then, outer, semicolon }))\n+            }\n+            super::IfExpressionWithNoElse => Some(super::IfExpressionWithNoElse),\n+            super::MainFunctionType => Some(super::MainFunctionType),\n+            super::StartFunctionType => Some(super::StartFunctionType),\n+            super::IntrinsicType => Some(super::IntrinsicType),\n+            super::MethodReceiver => Some(super::MethodReceiver),\n+            super::BlockTailExpression(id) => Some(super::BlockTailExpression(id)),\n+            super::TrivialBound => Some(super::TrivialBound),\n+            super::AssocTypeBound(ref data) => Some(super::AssocTypeBound(data.clone())),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::DerivedObligationCause<'a> {\n+    type Lifted = traits::DerivedObligationCause<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.parent_trait_ref).and_then(|trait_ref| {\n+            tcx.lift(&*self.parent_code).map(|code| traits::DerivedObligationCause {\n+                parent_trait_ref: trait_ref,\n+                parent_code: Rc::new(code),\n+            })\n+        })\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::ObligationCause<'a> {\n+    type Lifted = traits::ObligationCause<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.code).map(|code| traits::ObligationCause {\n+            span: self.span,\n+            body_id: self.body_id,\n+            code,\n+        })\n+    }\n+}\n+\n+// For codegen only.\n+impl<'a, 'tcx> Lift<'tcx> for traits::Vtable<'a, ()> {\n+    type Lifted = traits::Vtable<'tcx, ()>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        match self.clone() {\n+            traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableImpl(traits::VtableImplData { impl_def_id, substs, nested })\n+                })\n+            }\n+            traits::VtableAutoImpl(t) => Some(traits::VtableAutoImpl(t)),\n+            traits::VtableGenerator(traits::VtableGeneratorData {\n+                generator_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableGenerator(traits::VtableGeneratorData {\n+                    generator_def_id: generator_def_id,\n+                    substs: substs,\n+                    nested: nested,\n+                })\n+            }),\n+            traits::VtableClosure(traits::VtableClosureData { closure_def_id, substs, nested }) => {\n+                tcx.lift(&substs).map(|substs| {\n+                    traits::VtableClosure(traits::VtableClosureData {\n+                        closure_def_id,\n+                        substs,\n+                        nested,\n+                    })\n+                })\n+            }\n+            traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested }) => {\n+                tcx.lift(&fn_ty).map(|fn_ty| {\n+                    traits::VtableFnPointer(traits::VtableFnPointerData { fn_ty, nested })\n+                })\n+            }\n+            traits::VtableParam(n) => Some(traits::VtableParam(n)),\n+            traits::VtableBuiltin(n) => Some(traits::VtableBuiltin(n)),\n+            traits::VtableObject(traits::VtableObjectData {\n+                upcast_trait_ref,\n+                vtable_base,\n+                nested,\n+            }) => tcx.lift(&upcast_trait_ref).map(|trait_ref| {\n+                traits::VtableObject(traits::VtableObjectData {\n+                    upcast_trait_ref: trait_ref,\n+                    vtable_base,\n+                    nested,\n+                })\n+            }),\n+            traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                alias_def_id,\n+                substs,\n+                nested,\n+            }) => tcx.lift(&substs).map(|substs| {\n+                traits::VtableTraitAlias(traits::VtableTraitAliasData {\n+                    alias_def_id,\n+                    substs,\n+                    nested,\n+                })\n+            }),\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for traits::Environment<'a> {\n+    type Lifted = traits::Environment<'tcx>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.clauses).map(|clauses| traits::Environment { clauses })\n+    }\n+}\n+\n+impl<'a, 'tcx, G: Lift<'tcx>> Lift<'tcx> for traits::InEnvironment<'a, G> {\n+    type Lifted = traits::InEnvironment<'tcx, G::Lifted>;\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        tcx.lift(&self.environment).and_then(|environment| {\n+            tcx.lift(&self.goal).map(|goal| traits::InEnvironment { environment, goal })\n+        })\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedExClause;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_ex_clause_to_tcx(self, tcx)\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::DelayedLiteral<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedDelayedLiteral;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_delayed_literal_to_tcx(self, tcx)\n+    }\n+}\n+\n+impl<'tcx, C> Lift<'tcx> for chalk_engine::Literal<C>\n+where\n+    C: chalk_engine::context::Context + Clone,\n+    C: traits::ChalkContextLift<'tcx>,\n+{\n+    type Lifted = C::LiftedLiteral;\n+\n+    fn lift_to_tcx(&self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n+        <C as traits::ChalkContextLift>::lift_literal_to_tcx(self, tcx)\n+    }\n+}\n+\n+///////////////////////////////////////////////////////////////////////////\n+// TypeFoldable implementations.\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    traits::QuantifierKind,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_goals(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::Goal<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = (**self).fold_with(folder);\n+        folder.tcx().mk_goal(v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        (**self).visit_with(visitor)\n+    }\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    traits::ProgramClauseCategory,\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for traits::Clauses<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n+        folder.tcx().intern_clauses(&v)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        self.iter().any(|t| t.visit_with(visitor))\n+    }\n+}\n+\n+impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::ExClause<C>\n+where\n+    C: traits::ExClauseFold<'tcx>,\n+    C::Substitution: Clone,\n+    C::RegionConstraint: Clone,\n+{\n+    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n+        <C as traits::ExClauseFold>::fold_ex_clause_with(self, folder)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n+        <C as traits::ExClauseFold>::visit_ex_clause_with(self, visitor)\n+    }\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::DelayedLiteral<C> {\n+        (chalk_engine::DelayedLiteral::CannotProve)(a),\n+        (chalk_engine::DelayedLiteral::Negative)(a),\n+        (chalk_engine::DelayedLiteral::Positive)(a, b),\n+    } where\n+        C: chalk_engine::context::Context<CanonicalConstrainedSubst: TypeFoldable<'tcx>> + Clone,\n+}\n+\n+EnumTypeFoldableImpl! {\n+    impl<'tcx, C> TypeFoldable<'tcx> for chalk_engine::Literal<C> {\n+        (chalk_engine::Literal::Negative)(a),\n+        (chalk_engine::Literal::Positive)(a),\n+    } where\n+        C: chalk_engine::context::Context<GoalInEnvironment: Clone + TypeFoldable<'tcx>> + Clone,\n+}\n+\n+CloneTypeFoldableAndLiftImpls! {\n+    chalk_engine::TableIndex,\n+}"}, {"sha": "0282f409b328d620bc158df4370c9adcf1098edc", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a25d58b41b273993c27a2533dc193b799abbf43f/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=a25d58b41b273993c27a2533dc193b799abbf43f", "patch": "@@ -15,6 +15,16 @@ pub struct ExpectedFound<T> {\n     pub found: T,\n }\n \n+impl<T> ExpectedFound<T> {\n+    pub fn new(a_is_expected: bool, a: T, b: T) -> Self {\n+        if a_is_expected {\n+            ExpectedFound { expected: a, found: b }\n+        } else {\n+            ExpectedFound { expected: b, found: a }\n+        }\n+    }\n+}\n+\n // Data structures used in type unification\n #[derive(Clone, Debug, TypeFoldable)]\n pub enum TypeError<'tcx> {"}]}