{"sha": "394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5NGI4Y2RmYjc3MzRhNmRjYjEwYjM5MmM1YjgzZTFiM2Q5NTIxZDM=", "commit": {"author": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-06-28T10:58:20Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-07-04T16:37:52Z"}, "message": "Match on `Symbol` instead of `&str` for type-checking intrinsics.", "tree": {"sha": "2e01743ccf4315e7fea32eb65059aa03c7a94f65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e01743ccf4315e7fea32eb65059aa03c7a94f65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3", "html_url": "https://github.com/rust-lang/rust/commit/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "66fb778acc512213b8883101f275a7fa44c9b75d", "url": "https://api.github.com/repos/rust-lang/rust/commits/66fb778acc512213b8883101f275a7fa44c9b75d", "html_url": "https://github.com/rust-lang/rust/commit/66fb778acc512213b8883101f275a7fa44c9b75d"}], "stats": {"total": 344, "additions": 229, "deletions": 115}, "files": [{"sha": "c34da8b1cf326a03eb14f3702cea38cbe842411e", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3", "patch": "@@ -152,10 +152,14 @@ symbols! {\n         arm_target_feature,\n         asm,\n         assert,\n+        assert_inhabited,\n+        assert_uninit_valid,\n+        assert_zero_valid,\n         associated_consts,\n         associated_type_bounds,\n         associated_type_defaults,\n         associated_types,\n+        assume,\n         assume_init,\n         async_await,\n         async_closure,\n@@ -181,11 +185,14 @@ symbols! {\n         box_patterns,\n         box_syntax,\n         braced_empty_structs,\n+        breakpoint,\n         bswap,\n         bitreverse,\n         C,\n         caller_location,\n         cdylib,\n+        ceilf32,\n+        ceilf64,\n         cfg,\n         cfg_accessible,\n         cfg_attr,\n@@ -239,8 +246,14 @@ symbols! {\n         convert,\n         Copy,\n         copy_closures,\n+        copy,\n+        copy_nonoverlapping,\n+        copysignf32,\n+        copysignf64,\n         core,\n         core_intrinsics,\n+        cosf32,\n+        cosf64,\n         count_code_region,\n         coverage_counter_add,\n         coverage_counter_subtract,\n@@ -299,6 +312,7 @@ symbols! {\n         dropck_eyepatch,\n         dropck_parametricity,\n         drop_types_in_const,\n+        drop_in_place,\n         dylib,\n         dyn_trait,\n         eh_personality,\n@@ -311,11 +325,16 @@ symbols! {\n         Eq,\n         Equal,\n         enclosing_scope,\n+        exact_div,\n         except,\n         exclusive_range_pattern,\n         exhaustive_integer_patterns,\n         exhaustive_patterns,\n         existential_type,\n+        expf32,\n+        expf64,\n+        exp2f32,\n+        exp2f64,\n         expected,\n         export_name,\n         expr,\n@@ -329,20 +348,32 @@ symbols! {\n         f16c_target_feature,\n         f32,\n         f64,\n+        fadd_fast,\n+        fabsf32,\n+        fabsf64,\n+        fdiv_fast,\n         feature,\n         ffi_const,\n         ffi_pure,\n         ffi_returns_twice,\n         field,\n         field_init_shorthand,\n         file,\n+        float_to_int_unchecked,\n+        floorf64,\n+        floorf32,\n+        fmaf32,\n+        fmaf64,\n         fmt,\n         fmt_internals,\n+        fmul_fast,\n         fn_must_use,\n         forbid,\n+        forget,\n         format_args,\n         format_args_nl,\n         format_args_capture,\n+        frem_fast,\n         from,\n         From,\n         from_desugaring,\n@@ -352,6 +383,7 @@ symbols! {\n         from_ok,\n         from_usize,\n         from_trait,\n+        fsub_fast,\n         fundamental,\n         future,\n         Future,\n@@ -448,6 +480,12 @@ symbols! {\n         llvm_asm,\n         local_inner_macros,\n         log_syntax,\n+        logf32,\n+        logf64,\n+        log10f32,\n+        log10f64,\n+        log2f32,\n+        log2f64,\n         loop_break_value,\n         macro_at_most_once_rep,\n         macro_escape,\n@@ -475,10 +513,16 @@ symbols! {\n         message,\n         meta,\n         min_align_of,\n+        min_align_of_val,\n         min_const_fn,\n         min_const_unsafe_fn,\n         min_specialization,\n+        minnumf32,\n+        minnumf64,\n+        maxnumf32,\n+        maxnumf64,\n         mips_target_feature,\n+        miri_start_panic,\n         mmx_target_feature,\n         module,\n         module_path,\n@@ -491,6 +535,8 @@ symbols! {\n         naked,\n         naked_functions,\n         name,\n+        nearbyintf32,\n+        nearbyintf64,\n         needs_allocator,\n         needs_drop,\n         needs_panic_runtime,\n@@ -518,6 +564,7 @@ symbols! {\n         None,\n         non_exhaustive,\n         non_modrs_mods,\n+        nontemporal_store,\n         nontrapping_fptoint: \"nontrapping-fptoint\",\n         noreturn,\n         no_niche,\n@@ -577,8 +624,16 @@ symbols! {\n         poll,\n         Poll,\n         powerpc_target_feature,\n+        powf32,\n+        powf64,\n+        powif32,\n+        powif64,\n         precise_pointer_size_matching,\n         pref_align_of,\n+        prefetch_read_data,\n+        prefetch_read_instruction,\n+        prefetch_write_data,\n+        prefetch_write_instruction,\n         prelude,\n         prelude_import,\n         preserves_flags,\n@@ -640,10 +695,14 @@ symbols! {\n         Result,\n         Return,\n         rhs,\n+        rintf32,\n+        rintf64,\n         riscv_target_feature,\n         rlib,\n         rotate_left,\n         rotate_right,\n+        roundf32,\n+        roundf64,\n         rt,\n         rtm_target_feature,\n         rust,\n@@ -726,14 +785,19 @@ symbols! {\n         simd_ffi,\n         simd_insert,\n         since,\n+        sinf32,\n+        sinf64,\n         size,\n         size_of,\n+        size_of_val,\n         slice_patterns,\n         slicing_syntax,\n         soft,\n         Some,\n         specialization,\n         speed,\n+        sqrtf32,\n+        sqrtf64,\n         sse4a_target_feature,\n         stable,\n         staged_api,\n@@ -787,6 +851,8 @@ symbols! {\n         transparent_enums,\n         transparent_unions,\n         trivial_bounds,\n+        truncf32,\n+        truncf64,\n         Try,\n         try_blocks,\n         try_trait,\n@@ -809,6 +875,8 @@ symbols! {\n         u32,\n         u64,\n         u8,\n+        unaligned_volatile_load,\n+        unaligned_volatile_store,\n         unboxed_closures,\n         unchecked_add,\n         unchecked_div,\n@@ -824,6 +892,7 @@ symbols! {\n         universal_impl_trait,\n         unlikely,\n         unmarked_api,\n+        unreachable,\n         unreachable_code,\n         unrestricted_attribute_tokens,\n         unsafe_block_in_unsafe_fn,\n@@ -843,12 +912,21 @@ symbols! {\n         val,\n         var,\n         variant_count,\n+        va_arg,\n+        va_copy,\n+        va_end,\n+        va_start,\n         vec,\n         Vec,\n         version,\n         vis,\n         visible_private_types,\n         volatile,\n+        volatile_copy_memory,\n+        volatile_copy_nonoverlapping_memory,\n+        volatile_load,\n+        volatile_set_memory,\n+        volatile_store,\n         warn,\n         wasm_import_module,\n         wasm_target_feature,\n@@ -858,6 +936,7 @@ symbols! {\n         wrapping_add,\n         wrapping_sub,\n         wrapping_mul,\n+        write_bytes,\n         Yield,\n     }\n }"}, {"sha": "9b3b4a67650a2ab74918a25a8b42ebce711d9697", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 149, "deletions": 114, "changes": 263, "blob_url": "https://github.com/rust-lang/rust/blob/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3", "patch": "@@ -5,25 +5,25 @@ use crate::require_same_types;\n \n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n+use rustc_hir::def_id::DefId;\n use rustc_middle::traits::{ObligationCause, ObligationCauseCode};\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{self, Ty, TyCtxt};\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{kw, sym, Symbol};\n use rustc_target::spec::abi::Abi;\n \n use std::iter;\n \n fn equate_intrinsic_type<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     it: &hir::ForeignItem<'_>,\n+    def_id: DefId,\n     n_tps: usize,\n     abi: Abi,\n     safety: hir::Unsafety,\n     inputs: Vec<Ty<'tcx>>,\n     output: Ty<'tcx>,\n ) {\n-    let def_id = tcx.hir().local_def_id(it.hir_id);\n-\n     match it.kind {\n         hir::ForeignItemKind::Fn(..) => {}\n         _ => {\n@@ -67,15 +67,43 @@ fn equate_intrinsic_type<'tcx>(\n }\n \n /// Returns `true` if the given intrinsic is unsafe to call or not.\n-pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n+pub fn intrinsic_operation_unsafety(intrinsic: Symbol) -> hir::Unsafety {\n     match intrinsic {\n-        \"abort\" | \"size_of\" | \"min_align_of\" | \"needs_drop\" | \"caller_location\" | \"size_of_val\"\n-        | \"min_align_of_val\" | \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\"\n-        | \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" | \"saturating_add\"\n-        | \"saturating_sub\" | \"rotate_left\" | \"rotate_right\" | \"ctpop\" | \"ctlz\" | \"cttz\"\n-        | \"bswap\" | \"bitreverse\" | \"discriminant_value\" | \"type_id\" | \"likely\" | \"unlikely\"\n-        | \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" | \"minnumf32\" | \"minnumf64\" | \"maxnumf32\"\n-        | \"rustc_peek\" | \"maxnumf64\" | \"type_name\" | \"variant_count\" => hir::Unsafety::Normal,\n+        sym::abort\n+        | sym::size_of\n+        | sym::min_align_of\n+        | sym::needs_drop\n+        | sym::caller_location\n+        | sym::size_of_val\n+        | sym::min_align_of_val\n+        | sym::add_with_overflow\n+        | sym::sub_with_overflow\n+        | sym::mul_with_overflow\n+        | sym::wrapping_add\n+        | sym::wrapping_sub\n+        | sym::wrapping_mul\n+        | sym::saturating_add\n+        | sym::saturating_sub\n+        | sym::rotate_left\n+        | sym::rotate_right\n+        | sym::ctpop\n+        | sym::ctlz\n+        | sym::cttz\n+        | sym::bswap\n+        | sym::bitreverse\n+        | sym::discriminant_value\n+        | sym::type_id\n+        | sym::likely\n+        | sym::unlikely\n+        | sym::ptr_guaranteed_eq\n+        | sym::ptr_guaranteed_ne\n+        | sym::minnumf32\n+        | sym::minnumf64\n+        | sym::maxnumf32\n+        | sym::rustc_peek\n+        | sym::maxnumf64\n+        | sym::type_name\n+        | sym::variant_count => hir::Unsafety::Normal,\n         _ => hir::Unsafety::Unsafe,\n     }\n }\n@@ -84,7 +112,9 @@ pub fn intrinsic_operation_unsafety(intrinsic: &str) -> hir::Unsafety {\n /// and in libcore/intrinsics.rs\n pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let param = |n| tcx.mk_ty_param(n, Symbol::intern(&format!(\"P{}\", n)));\n-    let name = it.ident.as_str();\n+    let def_id = tcx.hir().local_def_id(it.hir_id).to_def_id();\n+    let intrinsic_name = tcx.item_name(def_id);\n+    let name_str = intrinsic_name.as_str();\n \n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n@@ -98,8 +128,8 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         })\n     };\n \n-    let (n_tps, inputs, output, unsafety) = if name.starts_with(\"atomic_\") {\n-        let split: Vec<&str> = name.split('_').collect();\n+    let (n_tps, inputs, output, unsafety) = if name_str.starts_with(\"atomic_\") {\n+        let split: Vec<&str> = name_str.split('_').collect();\n         assert!(split.len() >= 2, \"Atomic intrinsic in an incorrect format\");\n \n         //We only care about the operation here\n@@ -129,53 +159,51 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             }\n         };\n         (n_tps, inputs, output, hir::Unsafety::Unsafe)\n-    } else if &name[..] == \"abort\" {\n-        (0, Vec::new(), tcx.types.never, hir::Unsafety::Normal)\n-    } else if &name[..] == \"unreachable\" {\n-        (0, Vec::new(), tcx.types.never, hir::Unsafety::Unsafe)\n     } else {\n-        let unsafety = intrinsic_operation_unsafety(&name[..]);\n-        let (n_tps, inputs, output) = match &name[..] {\n-            \"breakpoint\" => (0, Vec::new(), tcx.mk_unit()),\n-            \"size_of\" | \"pref_align_of\" | \"min_align_of\" | \"variant_count\" => {\n+        let unsafety = intrinsic_operation_unsafety(intrinsic_name);\n+        let (n_tps, inputs, output) = match intrinsic_name {\n+            sym::abort => (0, Vec::new(), tcx.types.never),\n+            sym::unreachable => (0, Vec::new(), tcx.types.never),\n+            sym::breakpoint => (0, Vec::new(), tcx.mk_unit()),\n+            sym::size_of | sym::pref_align_of | sym::min_align_of | sym::variant_count => {\n                 (1, Vec::new(), tcx.types.usize)\n             }\n-            \"size_of_val\" | \"min_align_of_val\" => {\n+            sym::size_of_val | sym::min_align_of_val => {\n                 (1, vec![tcx.mk_imm_ptr(param(0))], tcx.types.usize)\n             }\n-            \"rustc_peek\" => (1, vec![param(0)], param(0)),\n-            \"caller_location\" => (0, vec![], tcx.caller_location_ty()),\n-            \"assert_inhabited\" | \"assert_zero_valid\" | \"assert_uninit_valid\" => {\n+            sym::rustc_peek => (1, vec![param(0)], param(0)),\n+            sym::caller_location => (0, vec![], tcx.caller_location_ty()),\n+            sym::assert_inhabited | sym::assert_zero_valid | sym::assert_uninit_valid => {\n                 (1, Vec::new(), tcx.mk_unit())\n             }\n-            \"forget\" => (1, vec![param(0)], tcx.mk_unit()),\n-            \"transmute\" => (2, vec![param(0)], param(1)),\n-            \"move_val_init\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n-            \"prefetch_read_data\"\n-            | \"prefetch_write_data\"\n-            | \"prefetch_read_instruction\"\n-            | \"prefetch_write_instruction\" => (\n+            sym::forget => (1, vec![param(0)], tcx.mk_unit()),\n+            sym::transmute => (2, vec![param(0)], param(1)),\n+            sym::move_val_init => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n+            sym::prefetch_read_data\n+            | sym::prefetch_write_data\n+            | sym::prefetch_read_instruction\n+            | sym::prefetch_write_instruction => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n                     tcx.types.i32,\n                 ],\n                 tcx.mk_unit(),\n             ),\n-            \"drop_in_place\" => (1, vec![tcx.mk_mut_ptr(param(0))], tcx.mk_unit()),\n-            \"needs_drop\" => (1, Vec::new(), tcx.types.bool),\n+            sym::drop_in_place => (1, vec![tcx.mk_mut_ptr(param(0))], tcx.mk_unit()),\n+            sym::needs_drop => (1, Vec::new(), tcx.types.bool),\n \n-            \"type_name\" => (1, Vec::new(), tcx.mk_static_str()),\n-            \"type_id\" => (1, Vec::new(), tcx.types.u64),\n-            \"offset\" | \"arith_offset\" => (\n+            sym::type_name => (1, Vec::new(), tcx.mk_static_str()),\n+            sym::type_id => (1, Vec::new(), tcx.types.u64),\n+            sym::offset | sym::arith_offset => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n                     tcx.types.isize,\n                 ],\n                 tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n             ),\n-            \"copy\" | \"copy_nonoverlapping\" => (\n+            sym::copy | sym::copy_nonoverlapping => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Not }),\n@@ -184,7 +212,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_unit(),\n             ),\n-            \"volatile_copy_memory\" | \"volatile_copy_nonoverlapping_memory\" => (\n+            sym::volatile_copy_memory | sym::volatile_copy_nonoverlapping_memory => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Mut }),\n@@ -193,7 +221,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_unit(),\n             ),\n-            \"write_bytes\" | \"volatile_set_memory\" => (\n+            sym::write_bytes | sym::volatile_set_memory => (\n                 1,\n                 vec![\n                     tcx.mk_ptr(ty::TypeAndMut { ty: param(0), mutbl: hir::Mutability::Mut }),\n@@ -202,93 +230,98 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 ],\n                 tcx.mk_unit(),\n             ),\n-            \"sqrtf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"sqrtf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"powif32\" => (0, vec![tcx.types.f32, tcx.types.i32], tcx.types.f32),\n-            \"powif64\" => (0, vec![tcx.types.f64, tcx.types.i32], tcx.types.f64),\n-            \"sinf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"sinf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"cosf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"cosf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"powf32\" => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"powf64\" => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"expf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"expf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"exp2f32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"exp2f64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"logf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"logf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"log10f32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"log10f64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"log2f32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"log2f64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"fmaf32\" => (0, vec![tcx.types.f32, tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"fmaf64\" => (0, vec![tcx.types.f64, tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"fabsf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"fabsf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"minnumf32\" => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"minnumf64\" => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"maxnumf32\" => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"maxnumf64\" => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"copysignf32\" => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n-            \"copysignf64\" => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n-            \"floorf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"floorf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"ceilf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"ceilf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"truncf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"truncf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"rintf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"rintf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"nearbyintf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"nearbyintf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-            \"roundf32\" => (0, vec![tcx.types.f32], tcx.types.f32),\n-            \"roundf64\" => (0, vec![tcx.types.f64], tcx.types.f64),\n-\n-            \"volatile_load\" | \"unaligned_volatile_load\" => {\n+            sym::sqrtf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::sqrtf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::powif32 => (0, vec![tcx.types.f32, tcx.types.i32], tcx.types.f32),\n+            sym::powif64 => (0, vec![tcx.types.f64, tcx.types.i32], tcx.types.f64),\n+            sym::sinf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::sinf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::cosf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::cosf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::powf32 => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::powf64 => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::expf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::expf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::exp2f32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::exp2f64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::logf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::logf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::log10f32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::log10f64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::log2f32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::log2f64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::fmaf32 => (0, vec![tcx.types.f32, tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::fmaf64 => (0, vec![tcx.types.f64, tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::fabsf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::fabsf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::minnumf32 => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::minnumf64 => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::maxnumf32 => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::maxnumf64 => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::copysignf32 => (0, vec![tcx.types.f32, tcx.types.f32], tcx.types.f32),\n+            sym::copysignf64 => (0, vec![tcx.types.f64, tcx.types.f64], tcx.types.f64),\n+            sym::floorf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::floorf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::ceilf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::ceilf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::truncf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::truncf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::rintf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::rintf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::nearbyintf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::nearbyintf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+            sym::roundf32 => (0, vec![tcx.types.f32], tcx.types.f32),\n+            sym::roundf64 => (0, vec![tcx.types.f64], tcx.types.f64),\n+\n+            sym::volatile_load | sym::unaligned_volatile_load => {\n                 (1, vec![tcx.mk_imm_ptr(param(0))], param(0))\n             }\n-            \"volatile_store\" | \"unaligned_volatile_store\" => {\n+            sym::volatile_store | sym::unaligned_volatile_store => {\n                 (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit())\n             }\n \n-            \"ctpop\" | \"ctlz\" | \"ctlz_nonzero\" | \"cttz\" | \"cttz_nonzero\" | \"bswap\"\n-            | \"bitreverse\" => (1, vec![param(0)], param(0)),\n+            sym::ctpop\n+            | sym::ctlz\n+            | sym::ctlz_nonzero\n+            | sym::cttz\n+            | sym::cttz_nonzero\n+            | sym::bswap\n+            | sym::bitreverse => (1, vec![param(0)], param(0)),\n \n-            \"add_with_overflow\" | \"sub_with_overflow\" | \"mul_with_overflow\" => {\n+            sym::add_with_overflow | sym::sub_with_overflow | sym::mul_with_overflow => {\n                 (1, vec![param(0), param(0)], tcx.intern_tup(&[param(0), tcx.types.bool]))\n             }\n \n-            \"ptr_guaranteed_eq\" | \"ptr_guaranteed_ne\" => {\n+            sym::ptr_guaranteed_eq | sym::ptr_guaranteed_ne => {\n                 (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.bool)\n             }\n \n-            \"ptr_offset_from\" => {\n+            sym::ptr_offset_from => {\n                 (1, vec![tcx.mk_imm_ptr(param(0)), tcx.mk_imm_ptr(param(0))], tcx.types.isize)\n             }\n-            \"unchecked_div\" | \"unchecked_rem\" | \"exact_div\" => {\n+            sym::unchecked_div | sym::unchecked_rem | sym::exact_div => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"unchecked_shl\" | \"unchecked_shr\" | \"rotate_left\" | \"rotate_right\" => {\n+            sym::unchecked_shl | sym::unchecked_shr | sym::rotate_left | sym::rotate_right => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"unchecked_add\" | \"unchecked_sub\" | \"unchecked_mul\" => {\n+            sym::unchecked_add | sym::unchecked_sub | sym::unchecked_mul => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"wrapping_add\" | \"wrapping_sub\" | \"wrapping_mul\" => {\n+            sym::wrapping_add | sym::wrapping_sub | sym::wrapping_mul => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"saturating_add\" | \"saturating_sub\" => (1, vec![param(0), param(0)], param(0)),\n-            \"fadd_fast\" | \"fsub_fast\" | \"fmul_fast\" | \"fdiv_fast\" | \"frem_fast\" => {\n+            sym::saturating_add | sym::saturating_sub => (1, vec![param(0), param(0)], param(0)),\n+            sym::fadd_fast | sym::fsub_fast | sym::fmul_fast | sym::fdiv_fast | sym::frem_fast => {\n                 (1, vec![param(0), param(0)], param(0))\n             }\n-            \"float_to_int_unchecked\" => (2, vec![param(0)], param(1)),\n+            sym::float_to_int_unchecked => (2, vec![param(0)], param(1)),\n \n-            \"assume\" => (0, vec![tcx.types.bool], tcx.mk_unit()),\n-            \"likely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n-            \"unlikely\" => (0, vec![tcx.types.bool], tcx.types.bool),\n+            sym::assume => (0, vec![tcx.types.bool], tcx.mk_unit()),\n+            sym::likely => (0, vec![tcx.types.bool], tcx.types.bool),\n+            sym::unlikely => (0, vec![tcx.types.bool], tcx.types.bool),\n \n-            \"discriminant_value\" => {\n+            sym::discriminant_value => {\n                 let assoc_items =\n                     tcx.associated_items(tcx.lang_items().discriminant_kind_trait().unwrap());\n                 let discriminant_def_id = assoc_items.in_definition_order().next().unwrap().def_id;\n@@ -303,7 +336,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 )\n             }\n \n-            \"try\" => {\n+            kw::Try => {\n                 let mut_u8 = tcx.mk_mut_ptr(tcx.types.u8);\n                 let try_fn_ty = ty::Binder::bind(tcx.mk_fn_sig(\n                     iter::once(mut_u8),\n@@ -326,51 +359,51 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                 )\n             }\n \n-            \"va_start\" | \"va_end\" => match mk_va_list_ty(hir::Mutability::Mut) {\n+            sym::va_start | sym::va_end => match mk_va_list_ty(hir::Mutability::Mut) {\n                 Some((va_list_ref_ty, _)) => (0, vec![va_list_ref_ty], tcx.mk_unit()),\n                 None => bug!(\"`va_list` language item needed for C-variadic intrinsics\"),\n             },\n \n-            \"va_copy\" => match mk_va_list_ty(hir::Mutability::Not) {\n+            sym::va_copy => match mk_va_list_ty(hir::Mutability::Not) {\n                 Some((va_list_ref_ty, va_list_ty)) => {\n                     let va_list_ptr_ty = tcx.mk_mut_ptr(va_list_ty);\n                     (0, vec![va_list_ptr_ty, va_list_ref_ty], tcx.mk_unit())\n                 }\n                 None => bug!(\"`va_list` language item needed for C-variadic intrinsics\"),\n             },\n \n-            \"va_arg\" => match mk_va_list_ty(hir::Mutability::Mut) {\n+            sym::va_arg => match mk_va_list_ty(hir::Mutability::Mut) {\n                 Some((va_list_ref_ty, _)) => (1, vec![va_list_ref_ty], param(0)),\n                 None => bug!(\"`va_list` language item needed for C-variadic intrinsics\"),\n             },\n \n-            \"nontemporal_store\" => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n+            sym::nontemporal_store => (1, vec![tcx.mk_mut_ptr(param(0)), param(0)], tcx.mk_unit()),\n \n-            \"miri_start_panic\" => {\n+            sym::miri_start_panic => {\n                 // FIXME - the relevant types aren't lang items,\n                 // so it's not trivial to check this\n                 return;\n             }\n \n-            \"count_code_region\" => {\n+            sym::count_code_region => {\n                 (0, vec![tcx.types.u32, tcx.types.u32, tcx.types.u32], tcx.mk_unit())\n             }\n \n-            \"coverage_counter_add\" | \"coverage_counter_subtract\" => (\n+            sym::coverage_counter_add | sym::coverage_counter_subtract => (\n                 0,\n                 vec![tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32, tcx.types.u32],\n                 tcx.mk_unit(),\n             ),\n \n-            \"coverage_unreachable\" => (0, vec![tcx.types.u32, tcx.types.u32], tcx.mk_unit()),\n+            sym::coverage_unreachable => (0, vec![tcx.types.u32, tcx.types.u32], tcx.mk_unit()),\n \n-            ref other => {\n+            other => {\n                 struct_span_err!(\n                     tcx.sess,\n                     it.span,\n                     E0093,\n                     \"unrecognized intrinsic function: `{}`\",\n-                    *other\n+                    other,\n                 )\n                 .span_label(it.span, \"unrecognized intrinsic\")\n                 .emit();\n@@ -379,7 +412,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         };\n         (n_tps, inputs, output, unsafety)\n     };\n-    equate_intrinsic_type(tcx, it, n_tps, Abi::RustIntrinsic, unsafety, inputs, output)\n+    equate_intrinsic_type(tcx, it, def_id, n_tps, Abi::RustIntrinsic, unsafety, inputs, output)\n }\n \n /// Type-check `extern \"platform-intrinsic\" { ... }` functions.\n@@ -389,6 +422,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n         tcx.mk_ty_param(n, name)\n     };\n \n+    let def_id = tcx.hir().local_def_id(it.hir_id).to_def_id();\n     let name = it.ident.as_str();\n \n     let (n_tps, inputs, output) = match &*name {\n@@ -463,6 +497,7 @@ pub fn check_platform_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>)\n     equate_intrinsic_type(\n         tcx,\n         it,\n+        def_id,\n         n_tps,\n         Abi::PlatformIntrinsic,\n         hir::Unsafety::Unsafe,"}, {"sha": "cc491c527db0b99c23f7d9372ad42b999fe69326", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=394b8cdfb7734a6dcb10b392c5b83e1b3d9521d3", "patch": "@@ -2063,7 +2063,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     ident: Ident,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {\n-        intrinsic_operation_unsafety(&tcx.item_name(def_id).as_str())\n+        intrinsic_operation_unsafety(tcx.item_name(def_id))\n     } else {\n         hir::Unsafety::Unsafe\n     };"}]}