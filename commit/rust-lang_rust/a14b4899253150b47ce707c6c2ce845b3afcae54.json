{"sha": "a14b4899253150b47ce707c6c2ce845b3afcae54", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExNGI0ODk5MjUzMTUwYjQ3Y2U3MDdjNmMyY2U4NDViM2FmY2FlNTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-03T00:30:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-03-03T00:30:39Z"}, "message": "auto merge of #5199 : thestinger/rust/hashmap, r=brson\n\nCloses #4764", "tree": {"sha": "b620c7d40bc157c678e532b1d2a13c2fbf5a36a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b620c7d40bc157c678e532b1d2a13c2fbf5a36a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a14b4899253150b47ce707c6c2ce845b3afcae54", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a14b4899253150b47ce707c6c2ce845b3afcae54", "html_url": "https://github.com/rust-lang/rust/commit/a14b4899253150b47ce707c6c2ce845b3afcae54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a14b4899253150b47ce707c6c2ce845b3afcae54/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "347d19934db06f0467377ec138e7415a119f2a3c", "url": "https://api.github.com/repos/rust-lang/rust/commits/347d19934db06f0467377ec138e7415a119f2a3c", "html_url": "https://github.com/rust-lang/rust/commit/347d19934db06f0467377ec138e7415a119f2a3c"}, {"sha": "a4175c34c3e7ebeee69417abb03953fb81875165", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4175c34c3e7ebeee69417abb03953fb81875165", "html_url": "https://github.com/rust-lang/rust/commit/a4175c34c3e7ebeee69417abb03953fb81875165"}], "stats": {"total": 626, "additions": 313, "deletions": 313}, "files": [{"sha": "007e3260aa11ce0a3b6f3e36d2d3d4d8990b8ebb", "filename": "src/libcore/hashmap.rs", "status": "modified", "additions": 313, "deletions": 313, "changes": 626, "blob_url": "https://github.com/rust-lang/rust/blob/a14b4899253150b47ce707c6c2ce845b3afcae54/src%2Flibcore%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a14b4899253150b47ce707c6c2ce845b3afcae54/src%2Flibcore%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhashmap.rs?ref=a14b4899253150b47ce707c6c2ce845b3afcae54", "patch": "@@ -36,11 +36,11 @@ pub mod linear {\n     }\n \n     pub struct LinearMap<K,V> {\n-        k0: u64,\n-        k1: u64,\n-        resize_at: uint,\n-        size: uint,\n-        buckets: ~[Option<Bucket<K, V>>],\n+        priv k0: u64,\n+        priv k1: u64,\n+        priv resize_at: uint,\n+        priv size: uint,\n+        priv buckets: ~[Option<Bucket<K, V>>],\n     }\n \n     // We could rewrite FoundEntry to have type Option<&Bucket<K, V>>\n@@ -582,335 +582,335 @@ pub mod linear {\n             self.map.reserve_at_least(n)\n         }\n     }\n-}\n-\n-#[test]\n-mod test_map {\n-    use container::{Container, Mutable, Map, Set};\n-    use option::{None, Some};\n-    use hashmap::linear::LinearMap;\n-    use hashmap::linear;\n-    use uint;\n-\n-    #[test]\n-    pub fn test_insert() {\n-        let mut m = LinearMap::new();\n-        assert m.insert(1, 2);\n-        assert m.insert(2, 4);\n-        assert *m.get(&1) == 2;\n-        assert *m.get(&2) == 4;\n-    }\n-\n-    #[test]\n-    pub fn test_insert_overwrite() {\n-        let mut m = LinearMap::new();\n-        assert m.insert(1, 2);\n-        assert *m.get(&1) == 2;\n-        assert !m.insert(1, 3);\n-        assert *m.get(&1) == 3;\n-    }\n-\n-    #[test]\n-    pub fn test_insert_conflicts() {\n-        let mut m = linear::linear_map_with_capacity(4);\n-        assert m.insert(1, 2);\n-        assert m.insert(5, 3);\n-        assert m.insert(9, 4);\n-        assert *m.get(&9) == 4;\n-        assert *m.get(&5) == 3;\n-        assert *m.get(&1) == 2;\n-    }\n-\n-    #[test]\n-    pub fn test_conflict_remove() {\n-        let mut m = linear::linear_map_with_capacity(4);\n-        assert m.insert(1, 2);\n-        assert m.insert(5, 3);\n-        assert m.insert(9, 4);\n-        assert m.remove(&1);\n-        assert *m.get(&9) == 4;\n-        assert *m.get(&5) == 3;\n-    }\n-\n-    #[test]\n-    pub fn test_is_empty() {\n-        let mut m = linear::linear_map_with_capacity(4);\n-        assert m.insert(1, 2);\n-        assert !m.is_empty();\n-        assert m.remove(&1);\n-        assert m.is_empty();\n-    }\n-\n-    #[test]\n-    pub fn test_pop() {\n-        let mut m = LinearMap::new();\n-        m.insert(1, 2);\n-        assert m.pop(&1) == Some(2);\n-        assert m.pop(&1) == None;\n-    }\n-\n-    #[test]\n-    pub fn test_swap() {\n-        let mut m = LinearMap::new();\n-        assert m.swap(1, 2) == None;\n-        assert m.swap(1, 3) == Some(2);\n-        assert m.swap(1, 4) == Some(3);\n-    }\n-\n-    #[test]\n-    pub fn test_find_or_insert() {\n-        let mut m = LinearMap::new::<int, int>();\n-        assert m.find_or_insert(1, 2) == &2;\n-        assert m.find_or_insert(1, 3) == &2;\n-    }\n-\n-    #[test]\n-    pub fn test_find_or_insert_with() {\n-        let mut m = LinearMap::new::<int, int>();\n-        assert m.find_or_insert_with(1, |_| 2) == &2;\n-        assert m.find_or_insert_with(1, |_| 3) == &2;\n-    }\n \n     #[test]\n-    pub fn test_consume() {\n-        let mut m = LinearMap::new();\n-        assert m.insert(1, 2);\n-        assert m.insert(2, 3);\n-        let mut m2 = LinearMap::new();\n-        do m.consume |k, v| {\n-            m2.insert(k, v);\n-        }\n-        assert m.len() == 0;\n-        assert m2.len() == 2;\n-        assert m2.get(&1) == &2;\n-        assert m2.get(&2) == &3;\n-    }\n-\n-    #[test]\n-    pub fn test_iterate() {\n-        let mut m = linear::linear_map_with_capacity(4);\n-        for uint::range(0, 32) |i| {\n-            assert m.insert(i, i*2);\n+    mod test_map {\n+        use container::{Container, Mutable, Map, Set};\n+        use option::{None, Some};\n+        use hashmap::linear::LinearMap;\n+        use hashmap::linear;\n+        use uint;\n+\n+        #[test]\n+        pub fn test_insert() {\n+            let mut m = LinearMap::new();\n+            assert m.insert(1, 2);\n+            assert m.insert(2, 4);\n+            assert *m.get(&1) == 2;\n+            assert *m.get(&2) == 4;\n+        }\n+\n+        #[test]\n+        pub fn test_insert_overwrite() {\n+            let mut m = LinearMap::new();\n+            assert m.insert(1, 2);\n+            assert *m.get(&1) == 2;\n+            assert !m.insert(1, 3);\n+            assert *m.get(&1) == 3;\n+        }\n+\n+        #[test]\n+        pub fn test_insert_conflicts() {\n+            let mut m = linear::linear_map_with_capacity(4);\n+            assert m.insert(1, 2);\n+            assert m.insert(5, 3);\n+            assert m.insert(9, 4);\n+            assert *m.get(&9) == 4;\n+            assert *m.get(&5) == 3;\n+            assert *m.get(&1) == 2;\n+        }\n+\n+        #[test]\n+        pub fn test_conflict_remove() {\n+            let mut m = linear::linear_map_with_capacity(4);\n+            assert m.insert(1, 2);\n+            assert m.insert(5, 3);\n+            assert m.insert(9, 4);\n+            assert m.remove(&1);\n+            assert *m.get(&9) == 4;\n+            assert *m.get(&5) == 3;\n+        }\n+\n+        #[test]\n+        pub fn test_is_empty() {\n+            let mut m = linear::linear_map_with_capacity(4);\n+            assert m.insert(1, 2);\n+            assert !m.is_empty();\n+            assert m.remove(&1);\n+            assert m.is_empty();\n+        }\n+\n+        #[test]\n+        pub fn test_pop() {\n+            let mut m = LinearMap::new();\n+            m.insert(1, 2);\n+            assert m.pop(&1) == Some(2);\n+            assert m.pop(&1) == None;\n+        }\n+\n+        #[test]\n+        pub fn test_swap() {\n+            let mut m = LinearMap::new();\n+            assert m.swap(1, 2) == None;\n+            assert m.swap(1, 3) == Some(2);\n+            assert m.swap(1, 4) == Some(3);\n+        }\n+\n+        #[test]\n+        pub fn test_find_or_insert() {\n+            let mut m = LinearMap::new::<int, int>();\n+            assert m.find_or_insert(1, 2) == &2;\n+            assert m.find_or_insert(1, 3) == &2;\n+        }\n+\n+        #[test]\n+        pub fn test_find_or_insert_with() {\n+            let mut m = LinearMap::new::<int, int>();\n+            assert m.find_or_insert_with(1, |_| 2) == &2;\n+            assert m.find_or_insert_with(1, |_| 3) == &2;\n+        }\n+\n+        #[test]\n+        pub fn test_consume() {\n+            let mut m = LinearMap::new();\n+            assert m.insert(1, 2);\n+            assert m.insert(2, 3);\n+            let mut m2 = LinearMap::new();\n+            do m.consume |k, v| {\n+                m2.insert(k, v);\n+            }\n+            assert m.len() == 0;\n+            assert m2.len() == 2;\n+            assert m2.get(&1) == &2;\n+            assert m2.get(&2) == &3;\n         }\n-        let mut observed = 0;\n-        for m.each |&(k, v)| {\n-            assert *v == *k * 2;\n-            observed |= (1 << *k);\n+\n+        #[test]\n+        pub fn test_iterate() {\n+            let mut m = linear::linear_map_with_capacity(4);\n+            for uint::range(0, 32) |i| {\n+                assert m.insert(i, i*2);\n+            }\n+            let mut observed = 0;\n+            for m.each |&(k, v)| {\n+                assert *v == *k * 2;\n+                observed |= (1 << *k);\n+            }\n+            assert observed == 0xFFFF_FFFF;\n         }\n-        assert observed == 0xFFFF_FFFF;\n-    }\n \n-    #[test]\n-    pub fn test_find() {\n-        let mut m = LinearMap::new();\n-        assert m.find(&1).is_none();\n-        m.insert(1, 2);\n-        match m.find(&1) {\n-            None => fail!(),\n-            Some(v) => assert *v == 2\n+        #[test]\n+        pub fn test_find() {\n+            let mut m = LinearMap::new();\n+            assert m.find(&1).is_none();\n+            m.insert(1, 2);\n+            match m.find(&1) {\n+                None => fail!(),\n+                Some(v) => assert *v == 2\n+            }\n         }\n-    }\n \n-    #[test]\n-    pub fn test_eq() {\n-        let mut m1 = LinearMap::new();\n-        m1.insert(1, 2);\n-        m1.insert(2, 3);\n-        m1.insert(3, 4);\n+        #[test]\n+        pub fn test_eq() {\n+            let mut m1 = LinearMap::new();\n+            m1.insert(1, 2);\n+            m1.insert(2, 3);\n+            m1.insert(3, 4);\n \n-        let mut m2 = LinearMap::new();\n-        m2.insert(1, 2);\n-        m2.insert(2, 3);\n+            let mut m2 = LinearMap::new();\n+            m2.insert(1, 2);\n+            m2.insert(2, 3);\n \n-        assert m1 != m2;\n+            assert m1 != m2;\n \n-        m2.insert(3, 4);\n+            m2.insert(3, 4);\n \n-        assert m1 == m2;\n-    }\n+            assert m1 == m2;\n+        }\n \n-    #[test]\n-    pub fn test_expand() {\n-        let mut m = LinearMap::new();\n+        #[test]\n+        pub fn test_expand() {\n+            let mut m = LinearMap::new();\n \n-        assert m.len() == 0;\n-        assert m.is_empty();\n+            assert m.len() == 0;\n+            assert m.is_empty();\n \n-        let mut i = 0u;\n-        let old_resize_at = m.resize_at;\n-        while old_resize_at == m.resize_at {\n-            m.insert(i, i);\n-            i += 1;\n-        }\n+            let mut i = 0u;\n+            let old_resize_at = m.resize_at;\n+            while old_resize_at == m.resize_at {\n+                m.insert(i, i);\n+                i += 1;\n+            }\n \n-        assert m.len() == i;\n-        assert !m.is_empty();\n+            assert m.len() == i;\n+            assert !m.is_empty();\n+        }\n     }\n-}\n \n #[test]\n-mod test_set {\n-    use hashmap::linear;\n-    use container::{Container, Mutable, Map, Set};\n-    use vec;\n-\n-    #[test]\n-    fn test_disjoint() {\n-        let mut xs = linear::LinearSet::new();\n-        let mut ys = linear::LinearSet::new();\n-        assert xs.is_disjoint(&ys);\n-        assert ys.is_disjoint(&xs);\n-        assert xs.insert(5);\n-        assert ys.insert(11);\n-        assert xs.is_disjoint(&ys);\n-        assert ys.is_disjoint(&xs);\n-        assert xs.insert(7);\n-        assert xs.insert(19);\n-        assert xs.insert(4);\n-        assert ys.insert(2);\n-        assert ys.insert(-11);\n-        assert xs.is_disjoint(&ys);\n-        assert ys.is_disjoint(&xs);\n-        assert ys.insert(7);\n-        assert !xs.is_disjoint(&ys);\n-        assert !ys.is_disjoint(&xs);\n-    }\n-\n-    #[test]\n-    fn test_subset_and_superset() {\n-        let mut a = linear::LinearSet::new();\n-        assert a.insert(0);\n-        assert a.insert(5);\n-        assert a.insert(11);\n-        assert a.insert(7);\n-\n-        let mut b = linear::LinearSet::new();\n-        assert b.insert(0);\n-        assert b.insert(7);\n-        assert b.insert(19);\n-        assert b.insert(250);\n-        assert b.insert(11);\n-        assert b.insert(200);\n-\n-        assert !a.is_subset(&b);\n-        assert !a.is_superset(&b);\n-        assert !b.is_subset(&a);\n-        assert !b.is_superset(&a);\n-\n-        assert b.insert(5);\n-\n-        assert a.is_subset(&b);\n-        assert !a.is_superset(&b);\n-        assert !b.is_subset(&a);\n-        assert b.is_superset(&a);\n-    }\n+    mod test_set {\n+        use hashmap::linear;\n+        use container::{Container, Mutable, Map, Set};\n+        use vec;\n+\n+        #[test]\n+        fn test_disjoint() {\n+            let mut xs = linear::LinearSet::new();\n+            let mut ys = linear::LinearSet::new();\n+            assert xs.is_disjoint(&ys);\n+            assert ys.is_disjoint(&xs);\n+            assert xs.insert(5);\n+            assert ys.insert(11);\n+            assert xs.is_disjoint(&ys);\n+            assert ys.is_disjoint(&xs);\n+            assert xs.insert(7);\n+            assert xs.insert(19);\n+            assert xs.insert(4);\n+            assert ys.insert(2);\n+            assert ys.insert(-11);\n+            assert xs.is_disjoint(&ys);\n+            assert ys.is_disjoint(&xs);\n+            assert ys.insert(7);\n+            assert !xs.is_disjoint(&ys);\n+            assert !ys.is_disjoint(&xs);\n+        }\n+\n+        #[test]\n+        fn test_subset_and_superset() {\n+            let mut a = linear::LinearSet::new();\n+            assert a.insert(0);\n+            assert a.insert(5);\n+            assert a.insert(11);\n+            assert a.insert(7);\n+\n+            let mut b = linear::LinearSet::new();\n+            assert b.insert(0);\n+            assert b.insert(7);\n+            assert b.insert(19);\n+            assert b.insert(250);\n+            assert b.insert(11);\n+            assert b.insert(200);\n+\n+            assert !a.is_subset(&b);\n+            assert !a.is_superset(&b);\n+            assert !b.is_subset(&a);\n+            assert !b.is_superset(&a);\n+\n+            assert b.insert(5);\n+\n+            assert a.is_subset(&b);\n+            assert !a.is_superset(&b);\n+            assert !b.is_subset(&a);\n+            assert b.is_superset(&a);\n+        }\n+\n+        #[test]\n+        fn test_intersection() {\n+            let mut a = linear::LinearSet::new();\n+            let mut b = linear::LinearSet::new();\n+\n+            assert a.insert(11);\n+            assert a.insert(1);\n+            assert a.insert(3);\n+            assert a.insert(77);\n+            assert a.insert(103);\n+            assert a.insert(5);\n+            assert a.insert(-5);\n+\n+            assert b.insert(2);\n+            assert b.insert(11);\n+            assert b.insert(77);\n+            assert b.insert(-9);\n+            assert b.insert(-42);\n+            assert b.insert(5);\n+            assert b.insert(3);\n+\n+            let mut i = 0;\n+            let expected = [3, 5, 11, 77];\n+            for a.intersection(&b) |x| {\n+                assert vec::contains(expected, x);\n+                i += 1\n+            }\n+            assert i == expected.len();\n+        }\n \n-    #[test]\n-    fn test_intersection() {\n-        let mut a = linear::LinearSet::new();\n-        let mut b = linear::LinearSet::new();\n-\n-        assert a.insert(11);\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(77);\n-        assert a.insert(103);\n-        assert a.insert(5);\n-        assert a.insert(-5);\n-\n-        assert b.insert(2);\n-        assert b.insert(11);\n-        assert b.insert(77);\n-        assert b.insert(-9);\n-        assert b.insert(-42);\n-        assert b.insert(5);\n-        assert b.insert(3);\n-\n-        let mut i = 0;\n-        let expected = [3, 5, 11, 77];\n-        for a.intersection(&b) |x| {\n-            assert vec::contains(expected, x);\n-            i += 1\n-        }\n-        assert i == expected.len();\n-    }\n+        #[test]\n+        fn test_difference() {\n+            let mut a = linear::LinearSet::new();\n+            let mut b = linear::LinearSet::new();\n \n-    #[test]\n-    fn test_difference() {\n-        let mut a = linear::LinearSet::new();\n-        let mut b = linear::LinearSet::new();\n-\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n-\n-        assert b.insert(3);\n-        assert b.insert(9);\n-\n-        let mut i = 0;\n-        let expected = [1, 5, 11];\n-        for a.difference(&b) |x| {\n-            assert vec::contains(expected, x);\n-            i += 1\n-        }\n-        assert i == expected.len();\n-    }\n+            assert a.insert(1);\n+            assert a.insert(3);\n+            assert a.insert(5);\n+            assert a.insert(9);\n+            assert a.insert(11);\n \n-    #[test]\n-    fn test_symmetric_difference() {\n-        let mut a = linear::LinearSet::new();\n-        let mut b = linear::LinearSet::new();\n-\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n-\n-        assert b.insert(-2);\n-        assert b.insert(3);\n-        assert b.insert(9);\n-        assert b.insert(14);\n-        assert b.insert(22);\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 5, 11, 14, 22];\n-        for a.symmetric_difference(&b) |x| {\n-            assert vec::contains(expected, x);\n-            i += 1\n-        }\n-        assert i == expected.len();\n-    }\n+            assert b.insert(3);\n+            assert b.insert(9);\n \n-    #[test]\n-    fn test_union() {\n-        let mut a = linear::LinearSet::new();\n-        let mut b = linear::LinearSet::new();\n-\n-        assert a.insert(1);\n-        assert a.insert(3);\n-        assert a.insert(5);\n-        assert a.insert(9);\n-        assert a.insert(11);\n-        assert a.insert(16);\n-        assert a.insert(19);\n-        assert a.insert(24);\n-\n-        assert b.insert(-2);\n-        assert b.insert(1);\n-        assert b.insert(5);\n-        assert b.insert(9);\n-        assert b.insert(13);\n-        assert b.insert(19);\n-\n-        let mut i = 0;\n-        let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n-        for a.union(&b) |x| {\n-            assert vec::contains(expected, x);\n-            i += 1\n-        }\n-        assert i == expected.len();\n+            let mut i = 0;\n+            let expected = [1, 5, 11];\n+            for a.difference(&b) |x| {\n+                assert vec::contains(expected, x);\n+                i += 1\n+            }\n+            assert i == expected.len();\n+        }\n+\n+        #[test]\n+        fn test_symmetric_difference() {\n+            let mut a = linear::LinearSet::new();\n+            let mut b = linear::LinearSet::new();\n+\n+            assert a.insert(1);\n+            assert a.insert(3);\n+            assert a.insert(5);\n+            assert a.insert(9);\n+            assert a.insert(11);\n+\n+            assert b.insert(-2);\n+            assert b.insert(3);\n+            assert b.insert(9);\n+            assert b.insert(14);\n+            assert b.insert(22);\n+\n+            let mut i = 0;\n+            let expected = [-2, 1, 5, 11, 14, 22];\n+            for a.symmetric_difference(&b) |x| {\n+                assert vec::contains(expected, x);\n+                i += 1\n+            }\n+            assert i == expected.len();\n+        }\n+\n+        #[test]\n+        fn test_union() {\n+            let mut a = linear::LinearSet::new();\n+            let mut b = linear::LinearSet::new();\n+\n+            assert a.insert(1);\n+            assert a.insert(3);\n+            assert a.insert(5);\n+            assert a.insert(9);\n+            assert a.insert(11);\n+            assert a.insert(16);\n+            assert a.insert(19);\n+            assert a.insert(24);\n+\n+            assert b.insert(-2);\n+            assert b.insert(1);\n+            assert b.insert(5);\n+            assert b.insert(9);\n+            assert b.insert(13);\n+            assert b.insert(19);\n+\n+            let mut i = 0;\n+            let expected = [-2, 1, 3, 5, 9, 11, 13, 16, 19, 24];\n+            for a.union(&b) |x| {\n+                assert vec::contains(expected, x);\n+                i += 1\n+            }\n+            assert i == expected.len();\n+        }\n     }\n }"}]}