{"sha": "2ad71f1350906b5169c26e9c13589ec9ac528b08", "node_id": "C_kwDOAAsO6NoAKDJhZDcxZjEzNTA5MDZiNTE2OWMyNmU5YzEzNTg5ZWM5YWM1MjhiMDg", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-03T16:25:24Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-03T16:25:24Z"}, "message": "Shrink `mbe::ExpandError` and `mbe::ParseError`", "tree": {"sha": "586a08c705cca0e6b7f75f8da93b57952a564ecf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/586a08c705cca0e6b7f75f8da93b57952a564ecf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2ad71f1350906b5169c26e9c13589ec9ac528b08", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2ad71f1350906b5169c26e9c13589ec9ac528b08", "html_url": "https://github.com/rust-lang/rust/commit/2ad71f1350906b5169c26e9c13589ec9ac528b08", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2ad71f1350906b5169c26e9c13589ec9ac528b08/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2310908df7f67f078c3d845db655d0bf7d5ecbef", "url": "https://api.github.com/repos/rust-lang/rust/commits/2310908df7f67f078c3d845db655d0bf7d5ecbef", "html_url": "https://github.com/rust-lang/rust/commit/2310908df7f67f078c3d845db655d0bf7d5ecbef"}], "stats": {"total": 170, "additions": 78, "deletions": 92}, "files": [{"sha": "1b49fc0ab4e27156cc52c6bf098442dfb6a7c760", "filename": "crates/hir_expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=2ad71f1350906b5169c26e9c13589ec9ac528b08", "patch": "@@ -368,7 +368,7 @@ fn compile_error_expand(\n             let text = it.text.as_str();\n             if text.starts_with('\"') && text.ends_with('\"') {\n                 // FIXME: does not handle raw strings\n-                mbe::ExpandError::Other(text[1..text.len() - 1].to_string())\n+                mbe::ExpandError::Other(text[1..text.len() - 1].into())\n             } else {\n                 mbe::ExpandError::BindingError(\"`compile_error!` argument must be a string\".into())\n             }\n@@ -451,12 +451,12 @@ fn relative_file(\n ) -> Result<FileId, mbe::ExpandError> {\n     let call_site = call_id.as_file().original_file(db);\n     let path = AnchoredPath { anchor: call_site, path: path_str };\n-    let res = db\n-        .resolve_path(path)\n-        .ok_or_else(|| mbe::ExpandError::Other(format!(\"failed to load file `{}`\", path_str)))?;\n+    let res = db.resolve_path(path).ok_or_else(|| {\n+        mbe::ExpandError::Other(format!(\"failed to load file `{path_str}`\").into())\n+    })?;\n     // Prevent include itself\n     if res == call_site && !allow_recursion {\n-        Err(mbe::ExpandError::Other(format!(\"recursive inclusion of `{}`\", path_str)))\n+        Err(mbe::ExpandError::Other(format!(\"recursive inclusion of `{path_str}`\").into()))\n     } else {\n         Ok(res)\n     }"}, {"sha": "d9bfdd6fd4f8c5647c58801f12464a581c28969f", "filename": "crates/hir_expand/src/db.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fhir_expand%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fdb.rs?ref=2ad71f1350906b5169c26e9c13589ec9ac528b08", "patch": "@@ -390,7 +390,7 @@ fn macro_def(db: &dyn AstDatabase, id: MacroDefId) -> Result<Arc<TokenExpander>,\n         MacroDefKind::BuiltInEager(..) => {\n             // FIXME: Return a random error here just to make the types align.\n             // This obviously should do something real instead.\n-            Err(mbe::ParseError::UnexpectedToken(\"unexpected eager macro\".to_string()))\n+            Err(mbe::ParseError::UnexpectedToken(\"unexpected eager macro\".into()))\n         }\n         MacroDefKind::ProcMacro(expander, ..) => Ok(Arc::new(TokenExpander::ProcMacro(expander))),\n     }"}, {"sha": "27c45f002b44fb4a89c71fc96c779ee036543564", "filename": "crates/hir_expand/src/proc_macro.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_expand%2Fsrc%2Fproc_macro.rs?ref=2ad71f1350906b5169c26e9c13589ec9ac528b08", "patch": "@@ -51,12 +51,12 @@ impl ProcMacroExpander {\n                         {\n                             ExpandResult {\n                                 value: tt.clone(),\n-                                err: Some(mbe::ExpandError::Other(text)),\n+                                err: Some(mbe::ExpandError::Other(text.into())),\n                             }\n                         }\n                         ProcMacroExpansionError::System(text)\n                         | ProcMacroExpansionError::Panic(text) => {\n-                            ExpandResult::only_err(mbe::ExpandError::Other(text))\n+                            ExpandResult::only_err(mbe::ExpandError::Other(text.into()))\n                         }\n                     },\n                 }"}, {"sha": "c5c555e3028779d3521580662a284b570daed026", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 12, "deletions": 18, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=2ad71f1350906b5169c26e9c13589ec9ac528b08", "patch": "@@ -88,15 +88,6 @@ impl Bindings {\n     }\n }\n \n-macro_rules! err {\n-    () => {\n-        ExpandError::BindingError(format!(\"\"))\n-    };\n-    ($($tt:tt)*) => {\n-        ExpandError::BindingError(format!($($tt)*))\n-    };\n-}\n-\n #[derive(Clone, Debug, Default, PartialEq, Eq)]\n pub(super) struct Match {\n     pub(super) bindings: Bindings,\n@@ -607,7 +598,7 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n                 src = it;\n                 res.unmatched_tts += src.len();\n             }\n-            res.add_err(err!(\"leftover tokens\"));\n+            res.add_err(ExpandError::binding_error(\"leftover tokens\"));\n \n             if let Some(error_reover_item) = error_recover_item {\n                 res.bindings = bindings_builder.build(&error_reover_item);\n@@ -664,10 +655,9 @@ fn match_loop(pattern: &MetaTemplate, src: &tt::Subtree) -> Match {\n }\n \n fn match_leaf(lhs: &tt::Leaf, src: &mut TtIter) -> Result<(), ExpandError> {\n-    let rhs = match src.expect_leaf() {\n-        Ok(l) => l,\n-        Err(()) => return Err(err!(\"expected leaf: `{}`\", lhs)),\n-    };\n+    let rhs = src\n+        .expect_leaf()\n+        .map_err(|()| ExpandError::BindingError(format!(\"expected leaf: `{lhs}`\").into()))?;\n     match (lhs, rhs) {\n         (\n             tt::Leaf::Punct(tt::Punct { char: lhs, .. }),\n@@ -708,9 +698,13 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragmen\n                 \"ident\" => input\n                     .expect_ident()\n                     .map(|ident| tt::Leaf::from(ident.clone()).into())\n-                    .map_err(|()| err!(\"expected ident\")),\n-                \"tt\" => input.expect_tt().map_err(|()| err!()),\n-                \"lifetime\" => input.expect_lifetime().map_err(|()| err!(\"expected lifetime\")),\n+                    .map_err(|()| ExpandError::binding_error(\"expected ident\")),\n+                \"tt\" => input\n+                    .expect_tt()\n+                    .map_err(|()| ExpandError::binding_error(\"expected token tree\")),\n+                \"lifetime\" => input\n+                    .expect_lifetime()\n+                    .map_err(|()| ExpandError::binding_error(\"expected lifetime\")),\n                 \"literal\" => {\n                     let neg = input.eat_char('-');\n                     input\n@@ -725,7 +719,7 @@ fn match_meta_var(kind: &str, input: &mut TtIter) -> ExpandResult<Option<Fragmen\n                                 }),\n                             }\n                         })\n-                        .map_err(|()| err!())\n+                        .map_err(|()| ExpandError::binding_error(\"expected literal\"))\n                 }\n                 _ => Err(ExpandError::UnexpectedToken),\n             };"}, {"sha": "e24a75a9b038c3aae8ecc3ec4239268d62b37e76", "filename": "crates/mbe/src/expander/transcriber.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Ftranscriber.rs?ref=2ad71f1350906b5169c26e9c13589ec9ac528b08", "patch": "@@ -17,34 +17,32 @@ impl Bindings {\n \n     fn get(&self, name: &str, nesting: &mut [NestingState]) -> Result<&Fragment, ExpandError> {\n         macro_rules! binding_err {\n-            ($($arg:tt)*) => { ExpandError::BindingError(format!($($arg)*)) };\n+            ($($arg:tt)*) => { ExpandError::BindingError(format!($($arg)*).into()) };\n         }\n \n-        let mut b: &Binding = self\n-            .inner\n-            .get(name)\n-            .ok_or_else(|| binding_err!(\"could not find binding `{}`\", name))?;\n+        let mut b: &Binding =\n+            self.inner.get(name).ok_or_else(|| binding_err!(\"could not find binding `{name}`\"))?;\n         for nesting_state in nesting.iter_mut() {\n             nesting_state.hit = true;\n             b = match b {\n                 Binding::Fragment(_) => break,\n                 Binding::Nested(bs) => bs.get(nesting_state.idx).ok_or_else(|| {\n                     nesting_state.at_end = true;\n-                    binding_err!(\"could not find nested binding `{}`\", name)\n+                    binding_err!(\"could not find nested binding `{name}`\")\n                 })?,\n                 Binding::Empty => {\n                     nesting_state.at_end = true;\n-                    return Err(binding_err!(\"could not find empty binding `{}`\", name));\n+                    return Err(binding_err!(\"could not find empty binding `{name}`\"));\n                 }\n             };\n         }\n         match b {\n             Binding::Fragment(it) => Ok(it),\n             Binding::Nested(_) => {\n-                Err(binding_err!(\"expected simple binding, found nested binding `{}`\", name))\n+                Err(binding_err!(\"expected simple binding, found nested binding `{name}`\"))\n             }\n             Binding::Empty => {\n-                Err(binding_err!(\"expected simple binding, found empty binding `{}`\", name))\n+                Err(binding_err!(\"expected simple binding, found empty binding `{name}`\"))\n             }\n         }\n     }\n@@ -180,7 +178,7 @@ fn expand_repeat(\n             );\n             return ExpandResult {\n                 value: Fragment::Tokens(Subtree::default().into()),\n-                err: Some(ExpandError::Other(\"Expand exceed limit\".to_string())),\n+                err: Some(ExpandError::Other(\"Expand exceed limit\".into())),\n             };\n         }\n "}, {"sha": "135282a3cb02cedd599c0c73ff6fb969abaf71da", "filename": "crates/mbe/src/lib.rs", "status": "modified", "additions": 44, "deletions": 37, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Flib.rs?ref=2ad71f1350906b5169c26e9c13589ec9ac528b08", "patch": "@@ -37,12 +37,22 @@ pub use crate::{\n \n #[derive(Debug, PartialEq, Eq, Clone)]\n pub enum ParseError {\n-    UnexpectedToken(String),\n-    Expected(String),\n+    UnexpectedToken(Box<str>),\n+    Expected(Box<str>),\n     InvalidRepeat,\n     RepetitionEmptyTokenTree,\n }\n \n+impl ParseError {\n+    fn expected(e: &str) -> ParseError {\n+        ParseError::Expected(e.into())\n+    }\n+\n+    fn unexpected(e: &str) -> ParseError {\n+        ParseError::UnexpectedToken(e.into())\n+    }\n+}\n+\n impl fmt::Display for ParseError {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match self {\n@@ -58,11 +68,17 @@ impl fmt::Display for ParseError {\n pub enum ExpandError {\n     NoMatchingRule,\n     UnexpectedToken,\n-    BindingError(String),\n+    BindingError(Box<str>),\n     ConversionError,\n     // FIXME: no way mbe should know about proc macros.\n     UnresolvedProcMacro,\n-    Other(String),\n+    Other(Box<str>),\n+}\n+\n+impl ExpandError {\n+    fn binding_error(e: &str) -> ExpandError {\n+        ExpandError::BindingError(e.into())\n+    }\n }\n \n impl fmt::Display for ExpandError {\n@@ -107,28 +123,25 @@ impl Shift {\n \n         // Find the max token id inside a subtree\n         fn max_id(subtree: &tt::Subtree) -> Option<u32> {\n-            subtree\n-                .token_trees\n-                .iter()\n-                .filter_map(|tt| match tt {\n-                    tt::TokenTree::Subtree(subtree) => {\n-                        let tree_id = max_id(subtree);\n-                        match subtree.delimiter {\n-                            Some(it) if it.id != tt::TokenId::unspecified() => {\n-                                Some(tree_id.map_or(it.id.0, |t| t.max(it.id.0)))\n-                            }\n-                            _ => tree_id,\n+            let filter = |tt: &_| match tt {\n+                tt::TokenTree::Subtree(subtree) => {\n+                    let tree_id = max_id(subtree);\n+                    match subtree.delimiter {\n+                        Some(it) if it.id != tt::TokenId::unspecified() => {\n+                            Some(tree_id.map_or(it.id.0, |t| t.max(it.id.0)))\n                         }\n+                        _ => tree_id,\n                     }\n-                    tt::TokenTree::Leaf(leaf) => {\n-                        let &(tt::Leaf::Ident(tt::Ident { id, .. })\n-                        | tt::Leaf::Punct(tt::Punct { id, .. })\n-                        | tt::Leaf::Literal(tt::Literal { id, .. })) = leaf;\n+                }\n+                tt::TokenTree::Leaf(leaf) => {\n+                    let &(tt::Leaf::Ident(tt::Ident { id, .. })\n+                    | tt::Leaf::Punct(tt::Punct { id, .. })\n+                    | tt::Leaf::Literal(tt::Literal { id, .. })) = leaf;\n \n-                        (id != tt::TokenId::unspecified()).then(|| id.0)\n-                    }\n-                })\n-                .max()\n+                    (id != tt::TokenId::unspecified()).then(|| id.0)\n+                }\n+            };\n+            subtree.token_trees.iter().filter_map(filter).max()\n         }\n     }\n \n@@ -183,7 +196,7 @@ impl DeclarativeMacro {\n             rules.push(rule);\n             if let Err(()) = src.expect_char(';') {\n                 if src.len() > 0 {\n-                    return Err(ParseError::Expected(\"expected `;`\".to_string()));\n+                    return Err(ParseError::expected(\"expected `;`\"));\n                 }\n                 break;\n             }\n@@ -208,9 +221,7 @@ impl DeclarativeMacro {\n                 rules.push(rule);\n                 if let Err(()) = src.expect_any_char(&[';', ',']) {\n                     if src.len() > 0 {\n-                        return Err(ParseError::Expected(\n-                            \"expected `;` or `,` to delimit rules\".to_string(),\n-                        ));\n+                        return Err(ParseError::expected(\"expected `;` or `,` to delimit rules\"));\n                     }\n                     break;\n                 }\n@@ -219,7 +230,7 @@ impl DeclarativeMacro {\n             cov_mark::hit!(parse_macro_def_simple);\n             let rule = Rule::parse(&mut src, false)?;\n             if src.len() != 0 {\n-                return Err(ParseError::Expected(\"remaining tokens in macro def\".to_string()));\n+                return Err(ParseError::expected(\"remaining tokens in macro def\"));\n             }\n             rules.push(rule);\n         }\n@@ -256,16 +267,12 @@ impl DeclarativeMacro {\n \n impl Rule {\n     fn parse(src: &mut TtIter, expect_arrow: bool) -> Result<Self, ParseError> {\n-        let lhs = src\n-            .expect_subtree()\n-            .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?;\n+        let lhs = src.expect_subtree().map_err(|()| ParseError::expected(\"expected subtree\"))?;\n         if expect_arrow {\n-            src.expect_char('=').map_err(|()| ParseError::Expected(\"expected `=`\".to_string()))?;\n-            src.expect_char('>').map_err(|()| ParseError::Expected(\"expected `>`\".to_string()))?;\n+            src.expect_char('=').map_err(|()| ParseError::expected(\"expected `=`\"))?;\n+            src.expect_char('>').map_err(|()| ParseError::expected(\"expected `>`\"))?;\n         }\n-        let rhs = src\n-            .expect_subtree()\n-            .map_err(|()| ParseError::Expected(\"expected subtree\".to_string()))?;\n+        let rhs = src.expect_subtree().map_err(|()| ParseError::expected(\"expected subtree\"))?;\n \n         let lhs = MetaTemplate::parse_pattern(lhs)?;\n         let rhs = MetaTemplate::parse_template(rhs)?;\n@@ -325,7 +332,7 @@ impl<T> ExpandResult<T> {\n     where\n         T: Default,\n     {\n-        Self::only_err(ExpandError::Other(err))\n+        Self::only_err(ExpandError::Other(err.into()))\n     }\n \n     pub fn map<U>(self, f: impl FnOnce(T) -> U) -> ExpandResult<U> {"}, {"sha": "9be8d7085da0b7a5414ed3862c44147c09ad9679", "filename": "crates/mbe/src/parser.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fparser.rs?ref=2ad71f1350906b5169c26e9c13589ec9ac528b08", "patch": "@@ -104,12 +104,6 @@ enum Mode {\n     Template,\n }\n \n-macro_rules! err {\n-    ($($tt:tt)*) => {\n-        ParseError::UnexpectedToken(($($tt)*).to_string())\n-    };\n-}\n-\n fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Result<Op, ParseError> {\n     let res = match first {\n         tt::TokenTree::Leaf(leaf @ tt::Leaf::Punct(tt::Punct { char: '$', .. })) => {\n@@ -142,7 +136,7 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n                         Op::Var { name, kind, id }\n                     }\n                     tt::Leaf::Punct(_) | tt::Leaf::Literal(_) => {\n-                        return Err(ParseError::Expected(\"ident\".to_string()))\n+                        return Err(ParseError::expected(\"expected ident\"))\n                     }\n                 },\n             }\n@@ -158,8 +152,10 @@ fn next_op<'a>(first: &tt::TokenTree, src: &mut TtIter<'a>, mode: Mode) -> Resul\n \n fn eat_fragment_kind(src: &mut TtIter<'_>, mode: Mode) -> Result<Option<SmolStr>, ParseError> {\n     if let Mode::Pattern = mode {\n-        src.expect_char(':').map_err(|()| err!(\"missing fragment specifier\"))?;\n-        let ident = src.expect_ident().map_err(|()| err!(\"missing fragment specifier\"))?;\n+        src.expect_char(':').map_err(|()| ParseError::unexpected(\"missing fragment specifier\"))?;\n+        let ident = src\n+            .expect_ident()\n+            .map_err(|()| ParseError::unexpected(\"missing fragment specifier\"))?;\n         return Ok(Some(ident.text.clone()));\n     };\n     Ok(None)"}, {"sha": "3a006a5a10308f57e6db18dfd4d95944da6b0b9d", "filename": "crates/mbe/src/tt_iter.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2ad71f1350906b5169c26e9c13589ec9ac528b08/crates%2Fmbe%2Fsrc%2Ftt_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Ftt_iter.rs?ref=2ad71f1350906b5169c26e9c13589ec9ac528b08", "patch": "@@ -6,15 +6,6 @@ use tt::buffer::TokenBuffer;\n \n use crate::{to_parser_input::to_parser_input, ExpandError, ExpandResult};\n \n-macro_rules! err {\n-    () => {\n-        ExpandError::BindingError(format!(\"\"))\n-    };\n-    ($($tt:tt)*) => {\n-        ExpandError::BindingError(format!($($tt)*))\n-    };\n-}\n-\n #[derive(Debug, Clone)]\n pub(crate) struct TtIter<'a> {\n     pub(crate) inner: std::slice::Iter<'a, tt::TokenTree>,\n@@ -115,7 +106,7 @@ impl<'a> TtIter<'a> {\n         }\n \n         let err = if error || !cursor.is_root() {\n-            Some(err!(\"expected {:?}\", entry_point))\n+            Some(ExpandError::BindingError(format!(\"expected {entry_point:?}\").into()))\n         } else {\n             None\n         };"}]}