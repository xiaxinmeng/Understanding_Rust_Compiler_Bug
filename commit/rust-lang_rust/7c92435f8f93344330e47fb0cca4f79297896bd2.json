{"sha": "7c92435f8f93344330e47fb0cca4f79297896bd2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjOTI0MzVmOGY5MzM0NDMzMGU0N2ZiMGNjYTRmNzkyOTc4OTZiZDI=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-17T02:23:12Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-10-17T02:54:38Z"}, "message": "remove the rusti command\n\nCloses #9818\nCloses #9567\nCloses #8924\nCloses #8910\nCloses #8392\nCloses #7692\nCloses #7499\nCloses #7220", "tree": {"sha": "ffe48fbcd78b323a306858f7bff6f4f0e7c3e33e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ffe48fbcd78b323a306858f7bff6f4f0e7c3e33e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c92435f8f93344330e47fb0cca4f79297896bd2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c92435f8f93344330e47fb0cca4f79297896bd2", "html_url": "https://github.com/rust-lang/rust/commit/7c92435f8f93344330e47fb0cca4f79297896bd2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c92435f8f93344330e47fb0cca4f79297896bd2/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c92f2168d49ee330992b9e23cd3dabf695e0d248", "url": "https://api.github.com/repos/rust-lang/rust/commits/c92f2168d49ee330992b9e23cd3dabf695e0d248", "html_url": "https://github.com/rust-lang/rust/commit/c92f2168d49ee330992b9e23cd3dabf695e0d248"}], "stats": {"total": 1432, "additions": 15, "deletions": 1417}, "files": [{"sha": "7e77f6fd6787b8d1e999c1b567fbac992ddb63d7", "filename": "Makefile.in", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/Makefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/Makefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Makefile.in?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -221,22 +221,19 @@ CFG_LIBRUSTC_$(1) :=$(call CFG_LIB_NAME_$(1),rustc)\n CFG_LIBSYNTAX_$(1) :=$(call CFG_LIB_NAME_$(1),syntax)\n CFG_LIBRUSTPKG_$(1) :=$(call CFG_LIB_NAME_$(1),rustpkg)\n CFG_LIBRUSTDOC_$(1) :=$(call CFG_LIB_NAME_$(1),rustdoc)\n-CFG_LIBRUSTI_$(1) :=$(call CFG_LIB_NAME_$(1),rusti)\n \n EXTRALIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),extra)\n STDLIB_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),std)\n LIBRUSTC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustc)\n LIBSYNTAX_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),syntax)\n LIBRUSTPKG_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustpkg)\n LIBRUSTDOC_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rustdoc)\n-LIBRUSTI_GLOB_$(1) :=$(call CFG_LIB_GLOB_$(1),rusti)\n EXTRALIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),extra)\n STDLIB_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),std)\n LIBRUSTC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustc)\n LIBSYNTAX_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),syntax)\n LIBRUSTPKG_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustpkg)\n LIBRUSTDOC_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rustdoc)\n-LIBRUSTI_DSYM_GLOB_$(1) :=$(call CFG_LIB_DSYM_GLOB_$(1),rusti)\n \n endef\n \n@@ -446,14 +443,12 @@ CSREQ$(1)_T_$(2)_H_$(3) = \\\n \t$$(HBIN$(1)_H_$(3))/rusti$$(X_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTPKG_$(3)) \\\n \t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTDOC_$(3)) \\\n-\t$$(HLIB$(1)_H_$(3))/$(CFG_LIBRUSTI_$(3)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_STDLIB_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))  \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2)) \\\n \t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2)) \\\n-\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTI_$(2)) \\\n+\t$$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n \n ifeq ($(1),0)\n # Don't run the the stage0 compiler under valgrind - that ship has sailed"}, {"sha": "e2dfa32032713ec573720ab4658fe4096dcd172b", "filename": "RELEASES.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/RELEASES.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/RELEASES.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.txt?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -1,3 +1,11 @@\n+Version 0.9 (XXX 2013)\n+--------------------------\n+\n+   * ~XXX changes, numerous bugfixes\n+\n+   * Tooling\n+      * The `rust` and `rusti` commands have been removed, due to lack of maintenance.\n+\n Version 0.8 (September 2013)\n --------------------------\n "}, {"sha": "241e0367fefa421a45cd9624693c4002d91254b2", "filename": "doc/tutorial.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/doc%2Ftutorial.md", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/doc%2Ftutorial.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial.md?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -113,9 +113,7 @@ for more information on them.\n \n When complete, `make install` will place several programs into\n `/usr/local/bin`: `rustc`, the Rust compiler; `rustdoc`, the\n-API-documentation tool; `rustpkg`, the Rust package manager;\n-`rusti`, the Rust REPL; and `rust`, a tool which acts both as a unified\n-interface for them, and for a few common command line scenarios.\n+API-documentation tool; and `rustpkg`, the Rust package manager.\n \n [tarball]: http://static.rust-lang.org/dist/rust-0.8.tar.gz\n [win-exe]: http://static.rust-lang.org/dist/rust-0.8-install.exe"}, {"sha": "e4cfab7747f504cc61c72dc6666c52a77a21a4ce", "filename": "man/rustc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/man%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/man%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustc.1?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -130,7 +130,7 @@ To build an executable with debug info (experimental):\n \n .SH \"SEE ALSO\"\n \n-rust, rustdoc, rustpkg, rusti\n+rustdoc, rustpkg\n \n .SH \"BUGS\"\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues."}, {"sha": "78340984f9679cba4dc2b0addccb11c414dcae9a", "filename": "man/rustdoc.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/man%2Frustdoc.1", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/man%2Frustdoc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustdoc.1?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -84,7 +84,7 @@ The generated HTML can be viewed with any standard web browser.\n \n .SH \"SEE ALSO\"\n \n-rust, rustc, rustpkg, rusti\n+rustc, rustpkg\n \n .SH \"BUGS\"\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues."}, {"sha": "9f7d1733c6514a070d129a4a7a2e23400da35736", "filename": "man/rusti.1", "status": "removed", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/man%2Frusti.1", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/man%2Frusti.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frusti.1?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -1,82 +0,0 @@\n-.TH RUSTI \"1\" \"July 2013\" \"rusti 0.7\" \"User Commands\"\n-\\\" Macros\n-..\n-.de Vb \\\" Begin verbatim text                                                   \n-.ft CW\n-.nf\n-.ne \\\\$1\n-..\n-.de Ve \\\" End verbatim text                                                     \n-.ft R\n-.fi\n-..\n-.SH NAME\n-rusti \\- Rust interactive shell\n-\n-.SH SYNOPSIS\n-.B rusti\n-\n-.SH DESCRIPTION\n-\n-This program is a REPL (Read-Eval-Print Loop) for the Rust language, available\n-at <\\fBhttps://www.rust-lang.org\\fR>. It provides an interactive shell to\n-evaluate Rust expressions, functions and code snippets, and to experiment with\n-Rust code.\n-\n-.B WARNING:\n-The Rust REPL is experimental and may be unstable. If you encounter problems,\n-please use the compiler instead.\n-\n-.SH OPTIONS\n-\n-Currently none.\n-\n-.SH SPECIAL COMMANDS\n-\n-The interactive shell evaluates all input as a sequence of Rust expressions,\n-except for a set of special commands prefixed by a colon ':'. These special\n-commands are described below:\n-\n-.TP\n-\\fB:help\\fR\n-Display a summary of available commands.\n-.TP\n-\\fB:{\\\\n ..lines.. \\\\n:}\\\\n\\fR\n-execute multiline command\n-.TP\n-\\fB:load <crate> ...\\fR\n-loads given crates as dynamic libraries\n-.TP\n-\\fB:clear\\fR\n-clear the bindings\n-.TP\n-\\fB:exit\\fR\n-exit from the repl\n-\n-.SH \"EXAMPLES\"\n-\n-A simple example session, declaring a variable, defining a function,\n-evaluating an expression and printing the result:\n-\n-.PP\n-.Vb\n-\\&\t\\fBrusti>\\fR let x = 42;\n-\\&\t\\fBrusti>\\fR fn square(n: int) -> int { n*n }\n-\\&\t\\fBrusti>\\fR println(fmt!(\"%d squared is %d\", x, square(x)));\n-\\&\t42 squared is 1764\n-.Ve\n-\n-.SH \"SEE ALSO\"\n-\n-rust, rustc, rustdoc, rustpkg\n-\n-.SH \"BUGS\"\n-See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues.\n-\n-.SH \"AUTHOR\"\n-See \\fBAUTHORS.txt\\fR in the rust source distribution. Graydon Hoare\n-<\\fIgraydon@mozilla.com\\fR> is the project leader.\n-\n-.SH \"COPYRIGHT\"\n-This work is dual-licensed under Apache 2.0 and MIT terms.  See \\fBCOPYRIGHT\\fR\n-file in the rust source distribution."}, {"sha": "856f90228137c03b430061d7daf4fed3e42f946a", "filename": "man/rustpkg.1", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/man%2Frustpkg.1", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/man%2Frustpkg.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/man%2Frustpkg.1?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -181,7 +181,7 @@ custom build logic.\n \n .SH \"SEE ALSO\"\n \n-rust, rustc, rustdoc, rusti\n+rustc, rustdoc\n \n .SH \"BUGS\"\n See <\\fBhttps://github.com/mozilla/rust/issues\\fR> for issues."}, {"sha": "09a80c5507bca854451a508923b6ff5e9d70e3d3", "filename": "mk/clean.mk", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Fclean.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Fclean.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fclean.mk?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -67,7 +67,6 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/serializer$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rustdoc$(X_$(2))\n-\t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rusti$(X_$(2))\n \t$(Q)rm -f $$(HBIN$(1)_H_$(2))/rust$(X_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTDOC_$(2))\n@@ -76,14 +75,12 @@ clean$(1)_H_$(2):\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_EXTRALIB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTC_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBSYNTAX_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_LIBRUSTI_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(STDLIB_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(EXTRALIB_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTDOC_GLOB_$(2))\n-\t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(LIBRUSTI_GLOB_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/$(CFG_RUSTLLVM_$(2))\n \t$(Q)rm -f $$(HLIB$(1)_H_$(2))/libstd.rlib\n \n@@ -100,7 +97,6 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustpkg$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/serializer$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rustdoc$(X_$(2))\n-\t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rusti$(X_$(2))\n \t$(Q)rm -f $$(TBIN$(1)_T_$(2)_H_$(3))/rust$(X_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTPKG_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTDOC_$(2))\n@@ -109,14 +105,12 @@ clean$(1)_T_$(2)_H_$(3):\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_EXTRALIB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTC_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBSYNTAX_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_LIBRUSTI_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(STDLIB_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(EXTRALIB_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTC_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBSYNTAX_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTPKG_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTDOC_GLOB_$(2))\n-\t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(LIBRUSTI_GLOB_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/$(CFG_RUSTLLVM_$(2))\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libstd.rlib\n \t$(Q)rm -f $$(TLIB$(1)_T_$(2)_H_$(3))/libmorestack.a"}, {"sha": "13b9509e66705f9400b6042458eec800920bdcf1", "filename": "mk/dist.mk", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Fdist.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Fdist.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fdist.mk?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -29,7 +29,6 @@ PKG_FILES := \\\n       README.txt                               \\\n       driver                                   \\\n       librustpkg                               \\\n-      librusti                                 \\\n       librustc                                 \\\n       compiletest                              \\\n       etc                                      \\"}, {"sha": "942600563864a797894f8e7475026650edbed97a", "filename": "mk/install.mk", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Finstall.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Finstall.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Finstall.mk?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -104,7 +104,6 @@ install-target-$(1)-host-$(2): $$(CSREQ$$(ISTAGE)_T_$(1)_H_$(2))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBSYNTAX_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTPKG_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTDOC_GLOB_$(1)))\n-\t$$(Q)$$(call INSTALL_LIB,$$(LIBRUSTI_GLOB_$(1)))\n \t$$(Q)$$(call INSTALL_LIB,libmorestack.a)\n \n endef\n@@ -138,19 +137,16 @@ install-host: $(CSREQ$(ISTAGE)_T_$(CFG_BUILD_TRIPLE)_H_$(CFG_BUILD_TRIPLE))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustc$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustpkg$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HB2),$(PHB),rustdoc$(X_$(CFG_BUILD_TRIPLE)))\n-\t$(Q)$(call INSTALL,$(HB2),$(PHB),rusti$(X_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(STDLIB_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(EXTRALIB_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTC_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBSYNTAX_GLOB_$(CFG_BUILD_TRIPLE)))\n-\t$(Q)$(call INSTALL_LIB,$(LIBRUSTI_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL_LIB,$(LIBRUSTDOC_GLOB_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUNTIME_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(HL),$(PHL),$(CFG_RUSTLLVM_$(CFG_BUILD_TRIPLE)))\n \t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rustc.1)\n \t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rustdoc.1)\n-\t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rusti.1)\n \t$(Q)$(call INSTALL,$(S)/man, $(PREFIX_ROOT)/share/man/man1,rustpkg.1)\n \n install-targets: $(INSTALL_TARGET_RULES)\n@@ -162,7 +158,6 @@ HOST_LIB_FROM_HL_GLOB = \\\n uninstall:\n \t$(Q)rm -f $(PHB)/rustc$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHB)/rustpkg$(X_$(CFG_BUILD_TRIPLE))\n-\t$(Q)rm -f $(PHB)/rusti$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHB)/rustdoc$(X_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHL)/$(CFG_RUSTLLVM_$(CFG_BUILD_TRIPLE))\n \t$(Q)rm -f $(PHL)/$(CFG_RUNTIME_$(CFG_BUILD_TRIPLE))\n@@ -173,14 +168,12 @@ uninstall:\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBSYNTAX_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTPKG_GLOB_$(CFG_BUILD_TRIPLE))) \\\n           $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTDOC_GLOB_$(CFG_BUILD_TRIPLE))) \\\n-          $(call HOST_LIB_FROM_HL_GLOB,$(LIBRUSTI_GLOB_$(CFG_BUILD_TRIPLE))) \\\n         ; \\\n         do rm -f $$i ; \\\n         done\n \t$(Q)rm -Rf $(PHL)/rustc\n \t$(Q)rm -f $(PREFIX_ROOT)/share/man/man1/rustc.1\n \t$(Q)rm -f $(PREFIX_ROOT)/share/man/man1/rustdoc.1\n-\t$(Q)rm -f $(PREFIX_ROOT)/share/man/man1/rusti.1\n \t$(Q)rm -f $(PREFIX_ROOT)/share/man/man1/rustpkg.1\n \n # target platform specific variables"}, {"sha": "fb5bd094404b5cc614f87afcf6759eab67f21cd0", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -15,7 +15,7 @@\n \n # The names of crates that must be tested\n TEST_TARGET_CRATES = std extra\n-TEST_HOST_CRATES = rusti rustpkg rustc rustdoc syntax\n+TEST_HOST_CRATES = rustpkg rustc rustdoc syntax\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n # Markdown files under doc/ that should have their code extracted and run\n@@ -189,7 +189,7 @@ check-test: cleantestlibs cleantmptestlogs all check-stage2-rfail\n \n check-lite: cleantestlibs cleantmptestlogs \\\n \tcheck-stage2-std check-stage2-extra check-stage2-rpass \\\n-\tcheck-stage2-rustpkg check-stage2-rusti \\\n+\tcheck-stage2-rustpkg \\\n \tcheck-stage2-rfail check-stage2-cfail\n \t$(Q)$(CFG_PYTHON) $(S)src/etc/check-summary.py tmp/*.log\n \n@@ -379,14 +379,6 @@ $(3)/stage$(1)/test/rustpkgtest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n-$(3)/stage$(1)/test/rustitest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n-\t\t$$(RUSTI_LIB) $$(RUSTI_INPUTS)\t\t\\\n-\t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBSYNTAX_$(2)) \\\n-\t\t$$(TLIB$(1)_T_$(2)_H_$(3))/$$(CFG_LIBRUSTC_$(2))\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n-\n $(3)/stage$(1)/test/rustdoctest-$(2)$$(X_$(2)):\t\t\t\t\t\\\n \t\t$$(RUSTDOC_LIB) $$(RUSTDOC_INPUTS)\t\t\\\n \t\t$$(SREQ$(1)_T_$(2)_H_$(3)) \\"}, {"sha": "a9ea12b5b24edcc2a306928ea4e662c81ad481c0", "filename": "mk/tools.mk", "status": "modified", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Ftools.mk", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/mk%2Ftools.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftools.mk?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -24,10 +24,6 @@ RUSTDOC_LIB := $(S)src/librustdoc/rustdoc.rs\n RUSTDOC_INPUTS := $(wildcard $(addprefix $(S)src/librustdoc/,        \\\n                                            *.rs */*.rs */*/*.rs))\n \n-# Rusti, the JIT REPL\n-RUSTI_LIB := $(S)src/librusti/rusti.rs\n-RUSTI_INPUTS := $(wildcard $(S)src/librusti/*.rs)\n-\n # FIXME: These are only built for the host arch. Eventually we'll\n # have tools that need to built for other targets.\n define TOOLS_STAGE_N_TARGET\n@@ -75,24 +71,6 @@ $$(TBIN$(1)_T_$(4)_H_$(3))/rustdoc$$(X_$(4)):\t\t\t\\\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rustdoc -o $$@ $$<\n \n-$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4)):\t\t\\\n-\t\t$$(RUSTI_LIB) $$(RUSTI_INPUTS)\t\t\t\\\n-\t\t$$(SREQ$(1)_T_$(4)_H_$(3))\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTC_$(4))\t\\\n-\t\t| $$(TLIB$(1)_T_$(4)_H_$(3))/\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) $$(WFLAGS_ST$(1)) --out-dir $$(@D) $$< && touch $$@\n-\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\n-$$(TBIN$(1)_T_$(4)_H_$(3))/rusti$$(X_$(4)):\t\t\t\\\n-\t\t$$(DRIVER_CRATE) \t\t\t\t\t\t\t\\\n-\t\t$$(TSREQ$(1)_T_$(4)_H_$(3))\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(4))/$(CFG_LIBRUSTI_$(4)) \\\n-\t\t| $$(TBIN$(1)_T_$(4)_H_$(3))/\n-\t@$$(call E, compile_and_link: $$@)\n-\t$$(STAGE$(1)_T_$(4)_H_$(3)) --cfg rusti -o $$@ $$<\n-\n endef\n \n define TOOLS_STAGE_N_HOST\n@@ -147,27 +125,6 @@ $$(HBIN$(2)_H_$(4))/rustdoc$$(X_$(4)):\t\t\t\t\\\n \t@$$(call E, cp: $$@)\n \t$$(Q)cp $$< $$@\n \n-$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTI_$(4)):\t\t\t\t\t\\\n-\t\t$$(TLIB$(1)_T_$(4)_H_$(3))/$(CFG_LIBRUSTI_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTC_$(4))\t\t\t\\\n-\t\t$$(HSREQ$(2)_H_$(4)) \\\n-\t\t| $$(HLIB$(2)_H_$(4))/\n-\t@$$(call E, cp: $$@)\n-\t$$(call REMOVE_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\t$$(Q)cp $$< $$@\n-\t$$(call LIST_ALL_OLD_GLOB_MATCHES_EXCEPT,$$(dir $$@),$(LIBRUSTI_GLOB_$(4)),$$(notdir $$@))\n-\t$$(Q)cp -R $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTI_GLOB_$(4)) \\\n-\t\t$$(wildcard $$(TLIB$(1)_T_$(4)_H_$(3))/$(LIBRUSTI_DSYM_GLOB_$(4))) \\\n-\t        $$(HLIB$(2)_H_$(4))\n-\n-$$(HBIN$(2)_H_$(4))/rusti$$(X_$(4)):\t\t\t\t\\\n-\t\t$$(TBIN$(1)_T_$(4)_H_$(3))/rusti$$(X_$(4))\t\\\n-\t\t$$(HLIB$(2)_H_$(4))/$(CFG_LIBRUSTI_$(4))\t\\\n-\t\t$$(HSREQ$(2)_H_$(4))\t\t\t\t\\\n-\t\t| $$(HBIN$(2)_H_$(4))/\n-\t@$$(call E, cp: $$@)\n-\t$$(Q)cp $$< $$@\n-\n endef\n \n $(foreach host,$(CFG_HOST_TRIPLES),\t\t\t\t\\"}, {"sha": "7cf523e10176b00bffa6041c6a204354f4d88991", "filename": "src/README.txt", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2FREADME.txt", "raw_url": "https://github.com/rust-lang/rust/raw/7c92435f8f93344330e47fb0cca4f79297896bd2/src%2FREADME.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.txt?ref=7c92435f8f93344330e47fb0cca4f79297896bd2", "patch": "@@ -31,8 +31,6 @@ compiletest/       The test runner\n \n librustpkg/        The package manager and build system\n \n-librusti/          The JIT REPL\n-\n librustdoc/        The Rust API documentation tool\n \n llvm/              The LLVM submodule"}, {"sha": "4ab9ac4aef5f362717aad896b30f35e1cad0cf62", "filename": "src/librusti/program.rs", "status": "removed", "additions": 0, "deletions": 416, "changes": 416, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrusti%2Fprogram.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrusti%2Fprogram.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Fprogram.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -1,416 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::cast;\n-use std::util;\n-use std::hashmap::HashMap;\n-use std::local_data;\n-\n-use syntax::ast;\n-use syntax::parse::token;\n-use syntax::print::pprust;\n-use rustc::middle::ty;\n-use rustc::util::ppaux;\n-\n-use utils::*;\n-\n-/// This structure keeps track of the state of the world for the code being\n-/// executed in rusti.\n-#[deriving(Clone)]\n-pub struct Program {\n-    /// All known local variables\n-    local_vars: HashMap<~str, LocalVariable>,\n-    /// New variables which will be present (learned from typechecking)\n-    newvars: HashMap<~str, LocalVariable>,\n-    /// All known view items (use statements), distinct because these must\n-    /// follow extern mods\n-    view_items: ~str,\n-    /// All known 'extern mod' statements (must always come first)\n-    externs: ~str,\n-    /// All known structs defined. These need to have\n-    /// #[deriving(Encodable,Decodable)] to be at all useful in rusti\n-    structs: HashMap<~str, ~str>,\n-    /// All other items, can all be intermingled. Duplicate definitions of the\n-    /// same name have the previous one overwritten.\n-    items: HashMap<~str, ~str>,\n-}\n-\n-/// Represents a local variable that the program is currently using.\n-#[deriving(Clone)]\n-struct LocalVariable {\n-    /// Should this variable be locally declared as mutable?\n-    mutable: bool,\n-    /// This is the type of the serialized data below\n-    ty: ~str,\n-    /// This is the serialized version of the variable\n-    data: ~[u8],\n-    /// When taking borrowed pointers or slices, care must be taken to ensure\n-    /// that the deserialization produces what we'd expect. If some magic is in\n-    /// order, the first element of this pair is the actual type of the local\n-    /// variable (which can be different from the deserialized type), and the\n-    /// second element are the '&'s which need to be prepended.\n-    alterations: Option<(~str, ~str)>,\n-}\n-\n-type LocalCache = @mut HashMap<~str, @~[u8]>;\n-local_data_key!(tls_key: LocalCache)\n-\n-impl Program {\n-    pub fn new() -> Program {\n-        Program {\n-            local_vars: HashMap::new(),\n-            newvars: HashMap::new(),\n-            view_items: ~\"\",\n-            externs: ~\"\",\n-            structs: HashMap::new(),\n-            items: HashMap::new(),\n-        }\n-    }\n-\n-    /// Clears all local bindings about variables, items, externs, etc.\n-    pub fn clear(&mut self) {\n-        *self = Program::new();\n-    }\n-\n-    /// Creates a block of code to be fed to rustc. This code is not meant to\n-    /// run, but rather it is meant to learn about the input given. This will\n-    /// assert that the types of all bound local variables are encodable,\n-    /// along with checking syntax and other rust-related things. The reason\n-    /// that we only check for encodability is that some super-common types\n-    /// (like &'static str) are not decodable, but are encodable. By doing some\n-    /// mild approximation when decoding, we can emulate at least &str and &[T].\n-    ///\n-    /// Once this code has been fed to rustc, it is intended that the code()\n-    /// function is used to actually generate code to fully compile and run.\n-    pub fn test_code(&self, user_input: &str, to_print: &Option<~str>,\n-                     new_locals: &[(~str, bool)]) -> ~str {\n-        let mut code = self.program_header();\n-        code.push_str(\"\n-    fn assert_encodable<T: Encodable<::extra::ebml::writer::Encoder>>(t: &T) {}\n-        \");\n-\n-        code.push_str(\"fn main() {\\n\");\n-        // It's easy to initialize things if we don't run things...\n-        for (name, var) in self.local_vars.iter() {\n-            let mt = var.mt();\n-            code.push_str(format!(\"let{} {}: {} = fail!();\\n\", mt, *name, var.ty));\n-            var.alter(*name, &mut code);\n-        }\n-        code.push_str(\"{\\n\");\n-        code.push_str(user_input);\n-        code.push_char('\\n');\n-        match *to_print {\n-            Some(ref s) => {\n-                code.push_str(*s);\n-                code.push_str(\";\\n\");\n-            }\n-            None => {}\n-        }\n-\n-        for p in new_locals.iter() {\n-            code.push_str(format!(\"assert_encodable(&{});\\n\", *p.first_ref()));\n-        }\n-        code.push_str(\"};}\");\n-        return code;\n-    }\n-\n-    /// Creates a program to be fed into rustc. This program is structured to\n-    /// deserialize all bindings into local variables, run the code input, and\n-    /// then reserialize all the variables back out.\n-    ///\n-    /// This program (unlike test_code) is meant to run to actually execute the\n-    /// user's input\n-    pub fn code(&mut self, user_input: &str, to_print: &Option<~str>) -> ~str {\n-        let mut code = self.program_header();\n-        code.push_str(\"\n-            fn main() {\n-        \");\n-\n-        let key: uint= unsafe { cast::transmute(tls_key) };\n-        // First, get a handle to the tls map which stores all the local\n-        // variables. This works by totally legitimately using the 'code'\n-        // pointer of the 'tls_key' function as a uint, and then casting it back\n-        // up to a function\n-        code.push_str(format!(\"\n-            let __tls_map: @mut ::std::hashmap::HashMap<~str, @~[u8]> = unsafe \\\\{\n-                let key = ::std::cast::transmute({});\n-                ::std::local_data::get(key, |k| k.map(|&x| *x)).unwrap()\n-            \\\\};\\n\", key));\n-\n-        // Using this __tls_map handle, deserialize each variable binding that\n-        // we know about\n-        for (name, var) in self.local_vars.iter() {\n-            let mt = var.mt();\n-            code.push_str(format!(\"let{} {}: {} = \\\\{\n-                let data = __tls_map.get_copy(&~\\\"{}\\\");\n-                let doc = ::extra::ebml::reader::Doc(data);\n-                let mut decoder = ::extra::ebml::reader::Decoder(doc);\n-                ::extra::serialize::Decodable::decode(&mut decoder)\n-            \\\\};\\n\", mt, *name, var.ty, *name));\n-            var.alter(*name, &mut code);\n-        }\n-\n-        // After all that, actually run the user's code.\n-        code.push_str(user_input);\n-        code.push_char('\\n');\n-\n-        match *to_print {\n-            Some(ref s) => { code.push_str(format!(\"pp(\\\\{\\n{}\\n\\\\});\", *s)); }\n-            None => {}\n-        }\n-\n-        let newvars = util::replace(&mut self.newvars, HashMap::new());\n-        for (name, var) in newvars.move_iter() {\n-            self.local_vars.insert(name, var);\n-        }\n-\n-        // After the input code is run, we can re-serialize everything back out\n-        // into tls map (to be read later on by this task)\n-        for (name, var) in self.local_vars.iter() {\n-            code.push_str(format!(\"\\\\{\n-                let local: {} = {};\n-                let bytes = do ::std::io::with_bytes_writer |io| \\\\{\n-                    let mut enc = ::extra::ebml::writer::Encoder(io);\n-                    local.encode(&mut enc);\n-                \\\\};\n-                __tls_map.insert(~\\\"{}\\\", @bytes);\n-            \\\\}\\n\", var.real_ty(), *name, *name));\n-        }\n-\n-        // Close things up, and we're done.\n-        code.push_str(\"}\");\n-        return code;\n-    }\n-\n-    /// Creates the header of the programs which are generated to send to rustc\n-    fn program_header(&self) -> ~str {\n-        // up front, disable lots of annoying lints, then include all global\n-        // state such as items, view items, and extern mods.\n-        let mut code = format!(\"\n-            \\\\#[allow(warnings)];\n-\n-            extern mod extra;\n-            {} // extern mods\n-\n-            use extra::serialize::*;\n-            {} // view items\n-        \", self.externs, self.view_items);\n-        for (_, s) in self.structs.iter() {\n-            // The structs aren't really useful unless they're encodable\n-            code.push_str(\"#[deriving(Encodable, Decodable)]\");\n-            code.push_str(*s);\n-            code.push_str(\"\\n\");\n-        }\n-        for (_, s) in self.items.iter() {\n-            code.push_str(*s);\n-            code.push_str(\"\\n\");\n-        }\n-        code.push_str(\"fn pp<T>(t: T) { println(fmt!(\\\"%?\\\", t)); }\\n\");\n-        return code;\n-    }\n-\n-    /// Initializes the task-local cache of all local variables known to the\n-    /// program. This will be used to read local variables out of once the\n-    /// program starts\n-    pub fn set_cache(&self) {\n-        let map = @mut HashMap::new();\n-        for (name, value) in self.local_vars.iter() {\n-            map.insert((*name).clone(), @(value.data).clone());\n-        }\n-        local_data::set(tls_key, map);\n-    }\n-\n-    /// Once the program has finished running, this function will consume the\n-    /// task-local cache of local variables. After the program finishes running,\n-    /// it updates this cache with the new values of each local variable.\n-    pub fn consume_cache(&mut self) {\n-        let map = local_data::pop(tls_key).expect(\"tls is empty\");\n-        let cons_map = util::replace(map, HashMap::new());\n-        for (name, value) in cons_map.move_iter() {\n-            match self.local_vars.find_mut(&name) {\n-                Some(v) => { v.data = (*value).clone(); }\n-                None => { fail2!(\"unknown variable {}\", name) }\n-            }\n-        }\n-    }\n-\n-    // Simple functions to record various global things (as strings)\n-\n-    pub fn record_view_item(&mut self, vi: &str) {\n-        self.view_items.push_str(vi);\n-        self.view_items.push_char('\\n');\n-    }\n-\n-    pub fn record_struct(&mut self, name: &str, s: ~str) {\n-        let name = name.to_owned();\n-        self.items.remove(&name);\n-        self.structs.insert(name, s);\n-    }\n-\n-    pub fn record_item(&mut self, name: &str, it: ~str) {\n-        let name = name.to_owned();\n-        self.structs.remove(&name);\n-        self.items.insert(name, it);\n-    }\n-\n-    pub fn record_extern(&mut self, name: &str) {\n-        self.externs.push_str(name);\n-        self.externs.push_char('\\n');\n-    }\n-\n-    /// This monster function is responsible for reading the main function\n-    /// generated by test_code() to determine the type of each local binding\n-    /// created by the user's input.\n-    ///\n-    /// Once the types are known, they are inserted into the local_vars map in\n-    /// this Program (to be deserialized later on\n-    pub fn register_new_vars(&mut self, blk: &ast::Block, tcx: ty::ctxt) {\n-        debug2!(\"looking for new variables\");\n-        let newvars = @mut HashMap::new();\n-        do each_user_local(blk) |local| {\n-            let mutable = local.is_mutbl;\n-            do each_binding(local) |path, id| {\n-                let name = do with_pp(token::get_ident_interner()) |pp, _| {\n-                    pprust::print_path(pp, path, false);\n-                };\n-                let mut t = ty::node_id_to_type(tcx, id);\n-                let mut tystr = ~\"\";\n-                let mut lvar = LocalVariable {\n-                    ty: ~\"\",\n-                    data: ~[],\n-                    mutable: mutable,\n-                    alterations: None,\n-                };\n-                // This loop is responsible for figuring out what \"alterations\"\n-                // are necessary for this local variable.\n-                loop {\n-                    match ty::get(t).sty {\n-                        // &T encoded will decode to T, so we need to be sure to\n-                        // re-take a loan after decoding\n-                        ty::ty_rptr(_, mt) => {\n-                            if mt.mutbl == ast::MutMutable {\n-                                tystr.push_str(\"&mut \");\n-                            } else {\n-                                tystr.push_str(\"&\");\n-                            }\n-                            t = mt.ty;\n-                        }\n-                        // Literals like [1, 2, 3] and (~[0]).slice() will both\n-                        // be serialized to ~[T], whereas it's requested to be a\n-                        // &[T] instead.\n-                        ty::ty_evec(mt, ty::vstore_slice(*)) |\n-                        ty::ty_evec(mt, ty::vstore_fixed(*)) => {\n-                            let vty = ppaux::ty_to_str(tcx, mt.ty);\n-                            let derefs = tystr.clone();\n-                            lvar.ty = tystr + \"~[\" + vty + \"]\";\n-                            lvar.alterations = Some((tystr + \"&[\" + vty + \"]\",\n-                                                     derefs));\n-                            break;\n-                        }\n-                        // Similar to vectors, &str serializes to ~str, so a\n-                        // borrow must be taken\n-                        ty::ty_estr(ty::vstore_slice(*)) => {\n-                            let derefs = tystr.clone();\n-                            lvar.ty = tystr + \"~str\";\n-                            lvar.alterations = Some((tystr + \"&str\", derefs));\n-                            break;\n-                        }\n-                        // Don't generate extra stuff if there's no borrowing\n-                        // going on here\n-                        _ if \"\" == tystr => {\n-                            lvar.ty = ppaux::ty_to_str(tcx, t);\n-                            break;\n-                        }\n-                        // If we're just borrowing (no vectors or strings), then\n-                        // we just need to record how many borrows there were.\n-                        _ => {\n-                            let derefs = tystr.clone();\n-                            let tmptystr = ppaux::ty_to_str(tcx, t);\n-                            lvar.alterations = Some((tystr + tmptystr, derefs));\n-                            lvar.ty = tmptystr;\n-                            break;\n-                        }\n-                    }\n-                }\n-                newvars.insert(name, lvar);\n-            }\n-        }\n-\n-        // I'm not an @ pointer, so this has to be done outside.\n-        let cons_newvars = util::replace(newvars, HashMap::new());\n-        for (k, v) in cons_newvars.move_iter() {\n-            self.newvars.insert(k, v);\n-        }\n-\n-        // helper functions to perform ast iteration\n-        fn each_user_local(blk: &ast::Block, f: &fn(@ast::Local)) {\n-            do find_user_block(blk) |blk| {\n-                for stmt in blk.stmts.iter() {\n-                    match stmt.node {\n-                        ast::StmtDecl(d, _) => {\n-                            match d.node {\n-                                ast::DeclLocal(l) => { f(l); }\n-                                _ => {}\n-                            }\n-                        }\n-                        _ => {}\n-                    }\n-                }\n-            }\n-        }\n-\n-        fn find_user_block(blk: &ast::Block, f: &fn(&ast::Block)) {\n-            for stmt in blk.stmts.iter() {\n-                match stmt.node {\n-                    ast::StmtSemi(e, _) => {\n-                        match e.node {\n-                            ast::ExprBlock(ref blk) => { return f(blk); }\n-                            _ => {}\n-                        }\n-                    }\n-                    _ => {}\n-                }\n-            }\n-            fail2!(\"couldn't find user block\");\n-        }\n-    }\n-}\n-\n-impl LocalVariable {\n-    /// Performs alterations to the code provided, given the name of this\n-    /// variable.\n-    fn alter(&self, name: &str, code: &mut ~str) {\n-        match self.alterations {\n-            Some((ref real_ty, ref prefix)) => {\n-                code.push_str(format!(\"let{} {}: {} = {}{};\\n\",\n-                                      self.mt(), name,\n-                                      *real_ty, *prefix, name));\n-            }\n-            None => {}\n-        }\n-    }\n-\n-    fn real_ty<'a>(&'a self) -> &'a str {\n-        match self.alterations {\n-            Some((ref real_ty, _)) => {\n-                let ret: &'a str = *real_ty;\n-                return ret;\n-            }\n-            None => {\n-                let ret: &'a str = self.ty;\n-                return ret;\n-            }\n-        }\n-    }\n-\n-    fn mt(&self) -> &'static str {\n-        if self.mutable {\" mut\"} else {\"\"}\n-    }\n-}"}, {"sha": "c025d9b10dd0421fb5d6bd675baba28539bb2a7d", "filename": "src/librusti/rusti.rs", "status": "removed", "additions": 0, "deletions": 786, "changes": 786, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrusti%2Frusti.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrusti%2Frusti.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -1,786 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*!\n- * rusti - A REPL using the JIT backend\n- *\n- * Rusti works by serializing state between lines of input. This means that each\n- * line can be run in a separate task, and the only limiting factor is that all\n- * local bound variables are encodable.\n- *\n- * This is accomplished by feeding in generated input to rustc for execution in\n- * the JIT compiler. Currently input actually gets fed in three times to get\n- * information about the program.\n- *\n- * - Pass #1\n- *   In this pass, the input is simply thrown at the parser and the input comes\n- *   back. This validates the structure of the program, and at this stage the\n- *   global items (fns, structs, impls, traits, etc.) are filtered from the\n- *   input into the \"global namespace\". These declarations shadow all previous\n- *   declarations of an item by the same name.\n- *\n- * - Pass #2\n- *   After items have been stripped, the remaining input is passed to rustc\n- *   along with all local variables declared (initialized to nothing). This pass\n- *   runs up to typechecking. From this, we can learn about the types of each\n- *   bound variable, what variables are bound, and also ensure that all the\n- *   types are encodable (the input can actually be run).\n- *\n- * - Pass #3\n- *   Finally, a program is generated to deserialize the local variable state,\n- *   run the code input, and then reserialize all bindings back into a local\n- *   hash map. This code is then run in the JIT engine provided by the rust\n- *   compiler.\n- *\n- * - Pass #4\n- *   Once this code runs, the input has fully been run and the hash map of local\n- *   variables from TLS is read back into the local store of variables. This is\n- *   then used later to pass back along to the parent rusti task and then begin\n- *   waiting for input again.\n- *\n- * - Pass #5\n- *   When running rusti code, it's important to consume ownership of the LLVM\n- *   jit contextual information to prevent code from being deallocated too soon\n- *   (before drop glue runs, see #7732). For this reason, the jit context is\n- *   consumed and also passed along to the parent task. The parent task then\n- *   keeps around all contexts while rusti is running. This must be done because\n- *   tasks could in theory be spawned off and running in the background (still\n- *   using the code).\n- *\n- * Encoding/decoding is done with EBML, and there is simply a map of ~str ->\n- * ~[u8] maintaining the values of each local binding (by name).\n- */\n-\n-#[link(name = \"rusti\",\n-       vers = \"0.9-pre\",\n-       uuid = \"7fb5bf52-7d45-4fee-8325-5ad3311149fc\",\n-       url = \"https://github.com/mozilla/rust/tree/master/src/rusti\")];\n-\n-#[license = \"MIT/ASL2\"];\n-#[crate_type = \"lib\"];\n-\n-#[feature(globs)];\n-\n-extern mod extra;\n-extern mod rustc;\n-extern mod syntax;\n-\n-use std::{libc, io, os, task};\n-use std::cell::Cell;\n-use extra::rl::CompletionCb;\n-use extra::rl;\n-\n-use rustc::driver::{driver, session};\n-use rustc::back::link::jit;\n-use syntax::{ast, codemap, diagnostic};\n-use syntax::ast_util::*;\n-use syntax::diagnostic::Emitter;\n-use syntax::parse::token;\n-use syntax::print::pprust;\n-\n-use program::Program;\n-use utils::*;\n-\n-mod program;\n-pub mod utils;\n-\n-/**\n- * A structure shared across REPL instances for storing history\n- * such as statements and view items. I wish the AST was sendable.\n- */\n-pub struct Repl {\n-    prompt: ~str,\n-    binary: ~str,\n-    running: bool,\n-    lib_search_paths: ~[~str],\n-    engines: ~[~jit::Engine],\n-\n-    program: ~Program,\n-}\n-\n-// Action to do after reading a :command\n-enum CmdAction {\n-    action_none,\n-    action_run_line(~str),\n-}\n-\n-struct EncodableWarningEmitter;\n-\n-impl diagnostic::Emitter for EncodableWarningEmitter {\n-    fn emit(&self,\n-            cm: Option<(@codemap::CodeMap, codemap::Span)>,\n-            msg: &str,\n-            lvl: diagnostic::level) {\n-        diagnostic::DefaultEmitter.emit(cm, msg, lvl);\n-        if msg.contains(\"failed to find an implementation of trait\") &&\n-           msg.contains(\"extra::serialize::Encodable\") {\n-            diagnostic::DefaultEmitter.emit(cm,\n-                                            \"Currrently rusti serializes \\\n-                                             bound locals between different \\\n-                                             lines of input. This means that \\\n-                                             all values of local variables \\\n-                                             need to be encodable, and this \\\n-                                             type isn't encodable\",\n-                                            diagnostic::note);\n-        }\n-    }\n-}\n-\n-/// Run an input string in a Repl, returning the new Repl.\n-fn run(mut program: ~Program, binary: ~str, lib_search_paths: ~[~str],\n-       input: ~str) -> (~Program, Option<~jit::Engine>)\n-{\n-    // Build some necessary rustc boilerplate for compiling things\n-    let binary = binary.to_managed();\n-    let options = @session::options {\n-        crate_type: session::unknown_crate,\n-        binary: binary,\n-        addl_lib_search_paths: @mut lib_search_paths.map(|p| Path::new(p.as_slice())),\n-        jit: true,\n-        .. (*session::basic_options()).clone()\n-    };\n-    // Because we assume that everything is encodable (and assert so), add some\n-    // extra helpful information if the error crops up. Otherwise people are\n-    // bound to be very confused when they find out code is running that they\n-    // never typed in...\n-    let sess = driver::build_session(options,\n-                                     @EncodableWarningEmitter as\n-                                        @diagnostic::Emitter);\n-    let intr = token::get_ident_interner();\n-\n-    //\n-    // Stage 1: parse the input and filter it into the program (as necessary)\n-    //\n-    debug2!(\"parsing: {}\", input);\n-    let crate = parse_input(sess, input);\n-    let mut to_run = ~[];       // statements to run (emitted back into code)\n-    let new_locals = @mut ~[];  // new locals being defined\n-    let mut result = None;      // resultant expression (to print via pp)\n-    do find_main(&crate, sess) |blk| {\n-        // Fish out all the view items, be sure to record 'extern mod' items\n-        // differently beause they must appear before all 'use' statements\n-        for vi in blk.view_items.iter() {\n-            let s = do with_pp(intr) |pp, _| {\n-                pprust::print_view_item(pp, vi);\n-            };\n-            match vi.node {\n-                ast::view_item_extern_mod(*) => {\n-                    program.record_extern(s);\n-                }\n-                ast::view_item_use(*) => { program.record_view_item(s); }\n-            }\n-        }\n-\n-        // Iterate through all of the block's statements, inserting them into\n-        // the correct portions of the program\n-        for stmt in blk.stmts.iter() {\n-            let s = do with_pp(intr) |pp, _| { pprust::print_stmt(pp, *stmt); };\n-            match stmt.node {\n-                ast::StmtDecl(d, _) => {\n-                    match d.node {\n-                        ast::DeclItem(it) => {\n-                            let name = sess.str_of(it.ident);\n-                            match it.node {\n-                                // Structs are treated specially because to make\n-                                // them at all usable they need to be decorated\n-                                // with #[deriving(Encoable, Decodable)]\n-                                ast::item_struct(*) => {\n-                                    program.record_struct(name, s);\n-                                }\n-                                // Item declarations are hoisted out of main()\n-                                _ => { program.record_item(name, s); }\n-                            }\n-                        }\n-\n-                        // Local declarations must be specially dealt with,\n-                        // record all local declarations for use later on\n-                        ast::DeclLocal(l) => {\n-                            let mutbl = l.is_mutbl;\n-                            do each_binding(l) |path, _| {\n-                                let s = do with_pp(intr) |pp, _| {\n-                                    pprust::print_path(pp, path, false);\n-                                };\n-                                new_locals.push((s, mutbl));\n-                            }\n-                            to_run.push(s);\n-                        }\n-                    }\n-                }\n-\n-                // run statements with expressions (they have effects)\n-                ast::StmtMac(*) | ast::StmtSemi(*) | ast::StmtExpr(*) => {\n-                    to_run.push(s);\n-                }\n-            }\n-        }\n-        result = do blk.expr.map |e| {\n-            do with_pp(intr) |pp, _| { pprust::print_expr(pp, e); }\n-        };\n-    }\n-    // return fast for empty inputs\n-    if to_run.len() == 0 && result.is_none() {\n-        return (program, None);\n-    }\n-\n-    //\n-    // Stage 2: run everything up to typeck to learn the types of the new\n-    //          variables introduced into the program\n-    //\n-    info2!(\"Learning about the new types in the program\");\n-    program.set_cache(); // before register_new_vars (which changes them)\n-    let input = to_run.connect(\"\\n\");\n-    let test = program.test_code(input, &result, *new_locals);\n-    debug2!(\"testing with ^^^^^^ {:?}\", (||{ println(test) })());\n-    let dinput = driver::str_input(test.to_managed());\n-    let cfg = driver::build_configuration(sess);\n-\n-    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &dinput);\n-    let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n-\n-    // Once we're typechecked, record the types of all local variables defined\n-    // in this input\n-    do find_main(&expanded_crate, sess) |blk| {\n-        program.register_new_vars(blk, analysis.ty_cx);\n-    }\n-\n-    //\n-    // Stage 3: Actually run the code in the JIT\n-    //\n-    info2!(\"actually running code\");\n-    let code = program.code(input, &result);\n-    debug2!(\"actually running ^^^^^^ {:?}\", (||{ println(code) })());\n-    let input = driver::str_input(code.to_managed());\n-    let cfg = driver::build_configuration(sess);\n-    let outputs = driver::build_output_filenames(&input, &None, &None, [], sess);\n-    let sess = driver::build_session(options,\n-                                     @diagnostic::DefaultEmitter as\n-                                        @diagnostic::Emitter);\n-\n-    let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-    let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-    let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n-    let trans = driver::phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n-    driver::phase_5_run_llvm_passes(sess, &trans, outputs);\n-\n-    //\n-    // Stage 4: Inform the program that computation is done so it can update all\n-    //          local variable bindings.\n-    //\n-    info2!(\"cleaning up after code\");\n-    program.consume_cache();\n-\n-    //\n-    // Stage 5: Extract the LLVM execution engine to take ownership of the\n-    //          generated JIT code. This means that rusti can spawn parallel\n-    //          tasks and we won't deallocate the code emitted until rusti\n-    //          itself is destroyed.\n-    //\n-    return (program, jit::consume_engine());\n-\n-    fn parse_input(sess: session::Session, input: &str) -> ast::Crate {\n-        let code = format!(\"fn main() \\\\{\\n {} \\n\\\\}\", input);\n-        let input = driver::str_input(code.to_managed());\n-        let cfg = driver::build_configuration(sess);\n-        driver::phase_1_parse_input(sess, cfg.clone(), &input)\n-    }\n-\n-    fn find_main(crate: &ast::Crate, sess: session::Session,\n-                 f: &fn(&ast::Block)) {\n-        for item in crate.module.items.iter() {\n-            match item.node {\n-                ast::item_fn(_, _, _, _, ref blk) => {\n-                    if item.ident == sess.ident_of(\"main\") {\n-                        return f(blk);\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n-        fail2!(\"main function was expected somewhere...\");\n-    }\n-}\n-\n-// Compiles a crate given by the filename as a library if the compiled\n-// version doesn't exist or is older than the source file. Binary is\n-// the name of the compiling executable. Returns Some(true) if it\n-// successfully compiled, Some(false) if the crate wasn't compiled\n-// because it already exists and is newer than the source file, or\n-// None if there were compile errors.\n-fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n-    fn has_prefix(v: &[u8], pref: &[u8]) -> bool {\n-        v.len() >= pref.len() && v.slice_to(pref.len()) == pref\n-    }\n-    fn has_extension(v: &[u8], ext: Option<&[u8]>) -> bool {\n-        match ext {\n-            None => true,\n-            Some(ext) => {\n-                v.len() > ext.len() && v[v.len()-ext.len()-1] == '.' as u8 &&\n-                    v.slice_from(v.len()-ext.len()) == ext\n-            }\n-        }\n-    }\n-    match do task::try {\n-        let src_path = Path::new(src_filename.as_slice());\n-        let binary = binary.to_managed();\n-        let options = @session::options {\n-            binary: binary,\n-            addl_lib_search_paths: @mut ~[os::getcwd()],\n-            .. (*session::basic_options()).clone()\n-        };\n-        let input = driver::file_input(src_path.clone());\n-        let sess = driver::build_session(options,\n-                                         @diagnostic::DefaultEmitter as\n-                                            @diagnostic::Emitter);\n-        *sess.building_library = true;\n-        let cfg = driver::build_configuration(sess);\n-        let outputs = driver::build_output_filenames(\n-            &input, &None, &None, [], sess);\n-        // If the library already exists and is newer than the source\n-        // file, skip compilation and return None.\n-        let mut should_compile = true;\n-        let dir = os::list_dir_path(&outputs.out_filename.dir_path());\n-        let maybe_lib_path = do dir.iter().find |file| {\n-            // The actual file's name has a hash value and version\n-            // number in it which is unknown at this time, so looking\n-            // for a file that matches out_filename won't work,\n-            // instead we guess which file is the library by matching\n-            // the prefix and suffix of out_filename to files in the\n-            // directory.\n-            let file_vec = file.filename().unwrap();\n-            has_prefix(file_vec, outputs.out_filename.filestem().unwrap()) &&\n-                has_extension(file_vec, outputs.out_filename.extension())\n-        };\n-        match maybe_lib_path {\n-            Some(lib_path) => {\n-                let (src_mtime, _) = src_path.get_mtime().unwrap();\n-                let (lib_mtime, _) = lib_path.get_mtime().unwrap();\n-                if lib_mtime >= src_mtime {\n-                    should_compile = false;\n-                }\n-            },\n-            None => { },\n-        }\n-        if (should_compile) {\n-            println(format!(\"compiling {}...\", src_filename));\n-            let crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n-            let expanded_crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n-            let analysis = driver::phase_3_run_analysis_passes(sess, &expanded_crate);\n-            let trans = driver::phase_4_translate_to_llvm(sess, expanded_crate, &analysis, outputs);\n-            driver::phase_5_run_llvm_passes(sess, &trans, outputs);\n-            true\n-        } else { false }\n-    } {\n-        Ok(true) => Some(true),\n-        Ok(false) => Some(false),\n-        Err(_) => None,\n-    }\n-}\n-\n-/// Tries to get a line from rl after outputting a prompt. Returns\n-/// None if no input was read (e.g. EOF was reached).\n-fn get_line(use_rl: bool, prompt: &str) -> Option<~str> {\n-    if use_rl {\n-        let result = rl::read(prompt);\n-\n-        match result {\n-            None => None,\n-            Some(line) => {\n-                rl::add_history(line);\n-                Some(line)\n-            }\n-        }\n-    } else {\n-        if io::stdin().eof() {\n-            None\n-        } else {\n-            Some(io::stdin().read_line())\n-        }\n-    }\n-}\n-\n-/// Run a command, e.g. :clear, :exit, etc.\n-fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n-           cmd: ~str, args: ~[~str], use_rl: bool) -> CmdAction {\n-    let mut action = action_none;\n-    match cmd {\n-        ~\"exit\" => repl.running = false,\n-        ~\"clear\" => {\n-            repl.program.clear();\n-\n-            // XXX: Win32 version of linenoise can't do this\n-            //rl::clear();\n-        }\n-        ~\"help\" => {\n-            println(\n-                \":{\\\\n ..lines.. \\\\n:}\\\\n - execute multiline command\\n\\\n-                 :load <crate> ... - loads given crates as dynamic libraries\\n\\\n-                 :clear - clear the bindings\\n\\\n-                 :exit - exit from the repl\\n\\\n-                 :help - show this message\");\n-        }\n-        ~\"load\" => {\n-            let mut loaded_crates: ~[~str] = ~[];\n-            for arg in args.iter() {\n-                let (crate, filename) =\n-                    if arg.ends_with(\".rs\") || arg.ends_with(\".rc\") {\n-                    (arg.slice_to(arg.len() - 3).to_owned(), (*arg).clone())\n-                } else {\n-                    ((*arg).clone(), *arg + \".rs\")\n-                };\n-                match compile_crate(filename, repl.binary.clone()) {\n-                    Some(_) => loaded_crates.push(crate),\n-                    None => { }\n-                }\n-            }\n-            for crate in loaded_crates.iter() {\n-                let crate_path = Path::new(crate.as_slice());\n-                // FIXME (#9639): This needs to handle non-utf8 paths\n-                let crate_dir = crate_path.dirname_str().unwrap();\n-                repl.program.record_extern(format!(\"extern mod {};\", *crate));\n-                if !repl.lib_search_paths.iter().any(|x| crate_dir == *x) {\n-                    repl.lib_search_paths.push(crate_dir.to_owned());\n-                }\n-            }\n-            if loaded_crates.is_empty() {\n-                println(\"no crates loaded\");\n-            } else {\n-                println!(\"crates loaded: {}\", loaded_crates.connect(\", \"));\n-            }\n-        }\n-        ~\"{\" => {\n-            let mut multiline_cmd = ~\"\";\n-            let mut end_multiline = false;\n-            while (!end_multiline) {\n-                match get_line(use_rl, \"rusti| \") {\n-                    None => fail2!(\"unterminated multiline command :\\\\{ .. :\\\\}\"),\n-                    Some(line) => {\n-                        if line.trim() == \":}\" {\n-                            end_multiline = true;\n-                        } else {\n-                            multiline_cmd.push_str(line);\n-                            multiline_cmd.push_char('\\n');\n-                        }\n-                    }\n-                }\n-            }\n-            action = action_run_line(multiline_cmd);\n-        }\n-        _ => println(~\"unknown cmd: \" + cmd)\n-    }\n-    return action;\n-}\n-\n-/// Executes a line of input, which may either be rust code or a\n-/// :command. Returns a new Repl if it has changed.\n-pub fn run_line(repl: &mut Repl, input: @io::Reader, out: @io::Writer, line: ~str,\n-                use_rl: bool) -> bool\n-{\n-    if line.starts_with(\":\") {\n-        // drop the : and the \\n (one byte each)\n-        let full = line.slice(1, line.len());\n-        let split: ~[~str] = full.word_iter().map(|s| s.to_owned()).collect();\n-        let len = split.len();\n-\n-        if len > 0 {\n-            let cmd = split[0].clone();\n-\n-            if !cmd.is_empty() {\n-                let args = if len > 1 {\n-                    split.slice(1, len).to_owned()\n-                } else { ~[] };\n-\n-                match run_cmd(repl, input, out, cmd, args, use_rl) {\n-                    action_none => { }\n-                    action_run_line(multiline_cmd) => {\n-                        if !multiline_cmd.is_empty() {\n-                            return run_line(repl, input, out, multiline_cmd, use_rl);\n-                        }\n-                    }\n-                }\n-                return true;\n-            }\n-        }\n-    }\n-\n-    let line = Cell::new(line);\n-    let program = Cell::new(repl.program.clone());\n-    let lib_search_paths = Cell::new(repl.lib_search_paths.clone());\n-    let binary = Cell::new(repl.binary.clone());\n-    let result = do task::try {\n-        run(program.take(), binary.take(), lib_search_paths.take(), line.take())\n-    };\n-\n-    match result {\n-        Ok((program, engine)) => {\n-            repl.program = program;\n-            match engine {\n-                Some(e) => { repl.engines.push(e); }\n-                None => {}\n-            }\n-            return true;\n-        }\n-        Err(*) => { return false; }\n-    }\n-}\n-\n-pub fn main() {\n-    os::set_exit_status(main_args(os::args()));\n-}\n-\n-struct Completer;\n-\n-impl CompletionCb for Completer {\n-    fn complete(&self, line: ~str, suggest: &fn(~str)) {\n-        if line.starts_with(\":\") {\n-            suggest(~\":clear\");\n-            suggest(~\":exit\");\n-            suggest(~\":help\");\n-            suggest(~\":load\");\n-        }\n-    }\n-}\n-\n-pub fn main_args(args: &[~str]) -> int {\n-    #[fixed_stack_segment]; #[inline(never)];\n-\n-    let input = io::stdin();\n-    let out = io::stdout();\n-    let mut repl = Repl {\n-        prompt: ~\"rusti> \",\n-        binary: args[0].clone(),\n-        running: true,\n-        lib_search_paths: ~[],\n-        engines: ~[],\n-\n-        program: ~Program::new(),\n-    };\n-\n-    let istty = unsafe { libc::isatty(libc::STDIN_FILENO as i32) } != 0;\n-\n-    // only print this stuff if the user is actually typing into rusti\n-    if istty {\n-        println(\"WARNING: The Rust REPL is experimental and may be\");\n-        println(\"unstable. If you encounter problems, please use the\");\n-        println(\"compiler instead. Type :help for help.\");\n-\n-        unsafe {\n-            rl::complete(@Completer as @CompletionCb)\n-        }\n-    }\n-\n-    while repl.running {\n-        match get_line(istty, repl.prompt) {\n-            None => break,\n-            Some(line) => {\n-                if line.is_empty() {\n-                    if istty {\n-                        println(\"()\");\n-                    }\n-                    continue;\n-                }\n-                run_line(&mut repl, input, out, line, istty);\n-            }\n-        }\n-    }\n-\n-    return 0;\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::io;\n-    use program::Program;\n-    use super::*;\n-\n-    fn repl() -> Repl {\n-        Repl {\n-            prompt: ~\"rusti> \",\n-            binary: ~\"rusti\",\n-            running: true,\n-            lib_search_paths: ~[],\n-            engines: ~[],\n-            program: ~Program::new(),\n-        }\n-    }\n-\n-    // FIXME: #7220 rusti on 32bit mac doesn't work.\n-    // FIXME: #7641 rusti on 32bit linux cross compile doesn't work\n-    // FIXME: #7115 re-enable once LLVM has been upgraded\n-    #[cfg(thiswillneverbeacfgflag)]\n-    fn run_program(prog: &str) {\n-        let mut r = repl();\n-        for cmd in prog.split_iter('\\n') {\n-            assert!(run_line(&mut r, io::stdin(), io::stdout(),\n-                             cmd.to_owned(), false),\n-                    \"the command '%s' failed\", cmd);\n-        }\n-    }\n-    fn run_program(_: &str) {}\n-\n-    #[ignore]\n-    #[test]\n-    fn super_basic() {\n-        run_program(\"\");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn regression_5937() {\n-        run_program(\"use std::hashmap;\");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn regression_5784() {\n-        run_program(\"let a = 3;\");\n-    }\n-\n-    #[test] #[ignore]\n-    fn new_tasks() {\n-        // XXX: can't spawn new tasks because the JIT code is cleaned up\n-        //      after the main function is done.\n-        run_program(\"\n-            spawn( || println(\\\"Please don't segfault\\\") );\n-            do spawn { println(\\\"Please?\\\"); }\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn inferred_integers_usable() {\n-        run_program(\"let a = 2;\\n()\\n\");\n-        run_program(\"\n-            let a = 3;\n-            let b = 4u;\n-            assert!((a as uint) + b == 7)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn local_variables_allow_shadowing() {\n-        run_program(\"\n-            let a = 3;\n-            let a = 5;\n-            assert!(a == 5)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn string_usable() {\n-        run_program(\"\n-            let a = ~\\\"\\\";\n-            let b = \\\"\\\";\n-            let c = @\\\"\\\";\n-            let d = a + b + c;\n-            assert!(d.len() == 0);\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn vectors_usable() {\n-        run_program(\"\n-            let a = ~[1, 2, 3];\n-            let b = &[1, 2, 3];\n-            let c = @[1, 2, 3];\n-            let d = a + b + c;\n-            assert!(d.len() == 9);\n-            let e: &[int] = [];\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn structs_usable() {\n-        run_program(\"\n-            struct A{ a: int }\n-            let b = A{ a: 3 };\n-            assert!(b.a == 3)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn mutable_variables_work() {\n-        run_program(\"\n-            let mut a = 3;\n-            a = 5;\n-            let mut b = std::hashmap::HashSet::new::<int>();\n-            b.insert(a);\n-            assert!(b.contains(&5))\n-            assert!(b.len() == 1)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn functions_saved() {\n-        run_program(\"\n-            fn fib(x: int) -> int { if x < 2 {x} else { fib(x - 1) + fib(x - 2) } }\n-            let a = fib(3);\n-            let a = a + fib(4);\n-            assert!(a == 5)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn modules_saved() {\n-        run_program(\"\n-            mod b { pub fn foo() -> uint { 3 } }\n-            assert!(b::foo() == 3)\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn multiple_functions() {\n-        run_program(\"\n-            fn f() {}\n-            fn f() {}\n-            f()\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn multiple_items_same_name() {\n-        run_program(\"\n-            fn f() {}\n-            mod f {}\n-            struct f;\n-            enum f {}\n-            fn f() {}\n-            f()\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn simultaneous_definition_and_expression() {\n-        run_program(\"\n-            let a = 3; a as u8\n-        \");\n-    }\n-\n-    #[ignore]\n-    #[test]\n-    fn exit_quits() {\n-        let mut r = repl();\n-        assert!(r.running);\n-        let result = run_line(&mut r, io::stdin(), io::stdout(),\n-                              ~\":exit\", false);\n-        assert!(result);\n-        assert!(!r.running);\n-    }\n-}"}, {"sha": "904594fdfb8f5a94f27de907997660ae4c79c233", "filename": "src/librusti/utils.rs", "status": "removed", "additions": 0, "deletions": 52, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrusti%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c92f2168d49ee330992b9e23cd3dabf695e0d248/src%2Flibrusti%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Futils.rs?ref=c92f2168d49ee330992b9e23cd3dabf695e0d248", "patch": "@@ -1,52 +0,0 @@\n-// Copyright 2012-2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::io;\n-use syntax::ast;\n-use syntax::print::pp;\n-use syntax::print::pprust;\n-use syntax::parse::token;\n-use syntax::visit;\n-\n-struct EachBindingVisitor<'self> {\n-    f: &'self fn(&ast::Path, ast::NodeId)\n-}\n-\n-impl<'self> visit::Visitor<()> for EachBindingVisitor<'self> {\n-    fn visit_pat(&mut self, pat:@ast::Pat, _:()) {\n-                match pat.node {\n-                    ast::PatIdent(_, ref path, _) => {\n-                        (self.f)(path, pat.id);\n-                    }\n-                    _ => {}\n-                }\n-\n-                visit::walk_pat(self, pat, ());\n-    }\n-}\n-\n-pub fn each_binding(l: @ast::Local, f: &fn(&ast::Path, ast::NodeId)) {\n-    use syntax::visit::Visitor;\n-\n-    let mut vt = EachBindingVisitor{ f: f };\n-\n-    vt.visit_pat(l.pat, ());\n-}\n-\n-/// A utility function that hands off a pretty printer to a callback.\n-pub fn with_pp(intr: @token::ident_interner,\n-               cb: &fn(@pprust::ps, @io::Writer)) -> ~str {\n-    do io::with_str_writer |writer| {\n-        let pp = pprust::rust_printer(writer, intr);\n-\n-        cb(pp, writer);\n-        pp::eof(pp.s);\n-    }\n-}"}]}