{"sha": "477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3N2U5ZjAxNzE0YjZkZmZhMWZiNzVlOTViODkwZDdhYmMyZmNjNTI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-30T12:48:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-07-30T12:48:20Z"}, "message": "Auto merge of #43543 - petrochenkov:32330, r=nikomatsakis\n\nCleanup some remains of `hr_lifetime_in_assoc_type` compatibility lint\n\nr? @nikomatsakis", "tree": {"sha": "e14286226a468b3a745cfa19190596f42252b508", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e14286226a468b3a745cfa19190596f42252b508"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "html_url": "https://github.com/rust-lang/rust/commit/477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5c71e4ef90ef79c1ac79c4132333cbc80f5b85b9", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c71e4ef90ef79c1ac79c4132333cbc80f5b85b9", "html_url": "https://github.com/rust-lang/rust/commit/5c71e4ef90ef79c1ac79c4132333cbc80f5b85b9"}, {"sha": "80cf3f99f4a3377fd9b544d18017ef29b8713dfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/80cf3f99f4a3377fd9b544d18017ef29b8713dfd", "html_url": "https://github.com/rust-lang/rust/commit/80cf3f99f4a3377fd9b544d18017ef29b8713dfd"}], "stats": {"total": 391, "additions": 113, "deletions": 278}, "files": [{"sha": "42e4338ca30733ef22784aecf3cbd815e5738441", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -368,7 +368,6 @@ for ty::RegionParameterDef {\n             name,\n             def_id,\n             index,\n-            issue_32330: _,\n             pure_wrt_drop\n         } = *self;\n "}, {"sha": "8e8576b83e4ed4d238638768cbe61d012d928b0b", "filename": "src/librustc/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 33, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -66,8 +66,7 @@ use hir::map as hir_map;\n use hir::def_id::DefId;\n use middle::region;\n use traits::{ObligationCause, ObligationCauseCode};\n-use ty::{self, TyCtxt, TypeFoldable};\n-use ty::{Region, Issue32330};\n+use ty::{self, Region, TyCtxt, TypeFoldable};\n use ty::error::TypeError;\n use syntax::ast::DUMMY_NODE_ID;\n use syntax_pos::{Pos, Span};\n@@ -713,35 +712,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n         self.tcx.note_and_explain_type_err(diag, terr, span);\n     }\n \n-    pub fn note_issue_32330(&self,\n-                            diag: &mut DiagnosticBuilder<'tcx>,\n-                            terr: &TypeError<'tcx>)\n-    {\n-        debug!(\"note_issue_32330: terr={:?}\", terr);\n-        match *terr {\n-            TypeError::RegionsInsufficientlyPolymorphic(_, _, Some(box Issue32330 {\n-                fn_def_id, region_name\n-            })) |\n-            TypeError::RegionsOverlyPolymorphic(_, _, Some(box Issue32330 {\n-                fn_def_id, region_name\n-            })) => {\n-                diag.note(\n-                    &format!(\"lifetime parameter `{0}` declared on fn `{1}` \\\n-                              appears only in the return type, \\\n-                              but here is required to be higher-ranked, \\\n-                              which means that `{0}` must appear in both \\\n-                              argument and return types\",\n-                             region_name,\n-                             self.tcx.item_path_str(fn_def_id)));\n-                diag.note(\n-                    &format!(\"this error is the result of a recent bug fix; \\\n-                              for more information, see issue #33685 \\\n-                              <https://github.com/rust-lang/rust/issues/33685>\"));\n-            }\n-            _ => {}\n-        }\n-    }\n-\n     pub fn report_and_explain_type_error(&self,\n                                          trace: TypeTrace<'tcx>,\n                                          terr: &TypeError<'tcx>)\n@@ -761,7 +731,6 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n             }\n         };\n         self.note_type_err(&mut diag, &trace.cause, None, Some(trace.values), terr);\n-        self.note_issue_32330(&mut diag, terr);\n         diag\n     }\n \n@@ -934,7 +903,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 format!(\" for lifetime parameter {}in trait containing associated type `{}`\",\n                         br_string(br), type_name)\n             }\n-            infer::EarlyBoundRegion(_, name, _) => {\n+            infer::EarlyBoundRegion(_, name) => {\n                 format!(\" for lifetime parameter `{}`\",\n                         name)\n             }"}, {"sha": "9ecc8b0e66b9bb1b9fea9deb14496f2fa7d2ad88", "filename": "src/librustc/infer/higher_ranked/mod.rs", "status": "modified", "additions": 7, "deletions": 49, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -13,9 +13,7 @@\n \n use super::{CombinedSnapshot,\n             InferCtxt,\n-            LateBoundRegion,\n             HigherRankedType,\n-            RegionVariableOrigin,\n             SubregionOrigin,\n             SkolemizationMap};\n use super::combine::CombineFields;\n@@ -29,15 +27,6 @@ use util::nodemap::{FxHashMap, FxHashSet};\n \n pub struct HrMatchResult<U> {\n     pub value: U,\n-\n-    /// Normally, when we do a higher-ranked match operation, we\n-    /// expect all higher-ranked regions to be constrained as part of\n-    /// the match operation. However, in the transition period for\n-    /// #32330, it can happen that we sometimes have unconstrained\n-    /// regions that get instantiated with fresh variables. In that\n-    /// case, we collect the set of unconstrained bound regions here\n-    /// and replace them with fresh variables.\n-    pub unconstrained_regions: Vec<ty::BoundRegion>,\n }\n \n impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n@@ -108,7 +97,6 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n     /// that do not appear in `T`. If that happens, those regions are\n     /// unconstrained, and this routine replaces them with `'static`.\n     pub fn higher_ranked_match<T, U>(&mut self,\n-                                     span: Span,\n                                      a_pair: &Binder<(T, U)>,\n                                      b_match: &T,\n                                      a_is_expected: bool)\n@@ -158,28 +146,16 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // be any region from the sets above, except for other members of\n             // `skol_map`. There should always be a representative if things\n             // are properly well-formed.\n-            let mut unconstrained_regions = vec![];\n             let skol_representatives: FxHashMap<_, _> =\n                 skol_resolution_map\n                 .iter()\n-                .map(|(&skol, &(br, ref regions))| {\n+                .map(|(&skol, &(_, ref regions))| {\n                     let representative =\n                         regions.iter()\n                                .filter(|&&r| !skol_resolution_map.contains_key(r))\n                                .cloned()\n                                .next()\n-                               .unwrap_or_else(|| { // [1]\n-                                   unconstrained_regions.push(br);\n-                                   self.infcx.next_region_var(\n-                                       LateBoundRegion(span, br, HigherRankedType))\n-                               });\n-\n-                    // [1] There should always be a representative,\n-                    // unless the higher-ranked region did not appear\n-                    // in the values being matched. We should reject\n-                    // as ill-formed cases that can lead to this, but\n-                    // right now we sometimes issue warnings (see\n-                    // #32330).\n+                               .expect(\"no representative region\");\n \n                     (skol, representative)\n                 })\n@@ -216,10 +192,7 @@ impl<'a, 'gcx, 'tcx> CombineFields<'a, 'gcx, 'tcx> {\n             // We are now done with these skolemized variables.\n             self.infcx.pop_skolemized(skol_map, snapshot);\n \n-            Ok(HrMatchResult {\n-                value: a_value,\n-                unconstrained_regions,\n-            })\n+            Ok(HrMatchResult { value: a_value })\n         });\n     }\n \n@@ -657,28 +630,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                        skol_br,\n                        tainted_region);\n \n-                let issue_32330 = if let &ty::ReVar(vid) = tainted_region {\n-                    match self.region_vars.var_origin(vid) {\n-                        RegionVariableOrigin::EarlyBoundRegion(_, _, issue_32330) => {\n-                            issue_32330.map(Box::new)\n-                        }\n-                        _ => None\n-                    }\n-                } else {\n-                    None\n-                };\n-\n-                if overly_polymorphic {\n+                return Err(if overly_polymorphic {\n                     debug!(\"Overly polymorphic!\");\n-                    return Err(TypeError::RegionsOverlyPolymorphic(skol_br,\n-                                                                   tainted_region,\n-                                                                   issue_32330));\n+                    TypeError::RegionsOverlyPolymorphic(skol_br, tainted_region)\n                 } else {\n                     debug!(\"Not as polymorphic!\");\n-                    return Err(TypeError::RegionsInsufficientlyPolymorphic(skol_br,\n-                                                                           tainted_region,\n-                                                                           issue_32330));\n-                }\n+                    TypeError::RegionsInsufficientlyPolymorphic(skol_br, tainted_region)\n+                })\n             }\n         }\n "}, {"sha": "bf79becfe4a1077582efab02196ef529a4330c24", "filename": "src/librustc/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Fmod.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -299,7 +299,7 @@ pub enum RegionVariableOrigin {\n     Coercion(Span),\n \n     // Region variables created as the values for early-bound regions\n-    EarlyBoundRegion(Span, ast::Name, Option<ty::Issue32330>),\n+    EarlyBoundRegion(Span, ast::Name),\n \n     // Region variables created for bound regions\n     // in a function or method that is called\n@@ -989,7 +989,7 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                               span: Span,\n                               def: &ty::RegionParameterDef)\n                               -> ty::Region<'tcx> {\n-        self.next_region_var(EarlyBoundRegion(span, def.name, def.issue_32330))\n+        self.next_region_var(EarlyBoundRegion(span, def.name))\n     }\n \n     /// Create a type inference variable for the given\n@@ -1278,14 +1278,13 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                                            -> InferResult<'tcx, HrMatchResult<Ty<'tcx>>>\n     {\n         let match_pair = match_a.map_bound(|p| (p.projection_ty.trait_ref(self.tcx), p.ty));\n-        let span = cause.span;\n         let trace = TypeTrace {\n             cause,\n             values: TraitRefs(ExpectedFound::new(true, match_pair.skip_binder().0, match_b))\n         };\n \n         let mut combine = self.combine_fields(trace, param_env);\n-        let result = combine.higher_ranked_match(span, &match_pair, &match_b, true)?;\n+        let result = combine.higher_ranked_match(&match_pair, &match_b, true)?;\n         Ok(InferOk { value: result, obligations: combine.obligations })\n     }\n "}, {"sha": "13efa94a5c9484ca1d603518f451ab3745c89277", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 32, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -153,10 +153,6 @@ pub struct NamedRegionMap {\n     // (b) it DOES appear in the arguments.\n     pub late_bound: NodeSet,\n \n-    // Contains the node-ids for lifetimes that were (incorrectly) categorized\n-    // as late-bound, until #32330 was fixed.\n-    pub issue_32330: NodeMap<ty::Issue32330>,\n-\n     // For each type and trait definition, maps type parameters\n     // to the trait object lifetime defaults computed from them.\n     pub object_lifetime_defaults: NodeMap<Vec<ObjectLifetimeDefault>>,\n@@ -261,7 +257,6 @@ pub fn krate(sess: &Session,\n     let mut map = NamedRegionMap {\n         defs: NodeMap(),\n         late_bound: NodeSet(),\n-        issue_32330: NodeMap(),\n         object_lifetime_defaults: compute_object_lifetime_defaults(sess, hir_map),\n     };\n     sess.track_errors(|| {\n@@ -303,7 +298,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n         match item.node {\n             hir::ItemFn(ref decl, _, _, _, ref generics, _) => {\n-                self.visit_early_late(item.id, None, decl, generics, |this| {\n+                self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n             }\n@@ -355,7 +350,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem) {\n         match item.node {\n             hir::ForeignItemFn(ref decl, _, ref generics) => {\n-                self.visit_early_late(item.id, None, decl, generics, |this| {\n+                self.visit_early_late(None, decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -406,7 +401,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem) {\n         if let hir::TraitItemKind::Method(ref sig, _) = trait_item.node {\n             self.visit_early_late(\n-                trait_item.id,\n                 Some(self.hir_map.get_parent(trait_item.id)),\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_trait_item(this, trait_item))\n@@ -418,7 +412,6 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n             self.visit_early_late(\n-                impl_item.id,\n                 Some(self.hir_map.get_parent(impl_item.id)),\n                 &sig.decl, &sig.generics,\n                 |this| intravisit::walk_impl_item(this, impl_item))\n@@ -811,18 +804,13 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     /// bound lifetimes are resolved by name and associated with a binder id (`binder_id`), so the\n     /// ordering is not important there.\n     fn visit_early_late<F>(&mut self,\n-                           fn_id: ast::NodeId,\n                            parent_id: Option<ast::NodeId>,\n                            decl: &'tcx hir::FnDecl,\n                            generics: &'tcx hir::Generics,\n                            walk: F) where\n         F: for<'b, 'c> FnOnce(&'b mut LifetimeContext<'c, 'tcx>),\n     {\n-        let fn_def_id = self.hir_map.local_def_id(fn_id);\n-        insert_late_bound_lifetimes(self.map,\n-                                    fn_def_id,\n-                                    decl,\n-                                    generics);\n+        insert_late_bound_lifetimes(self.map, decl, generics);\n \n         // Find the start of nested early scopes, e.g. in methods.\n         let mut index = 0;\n@@ -1549,7 +1537,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n /// not amongst the inputs to a projection.  In other words, `<&'a\n /// T as Trait<''b>>::Foo` does not constrain `'a` or `'b`.\n fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n-                               fn_def_id: DefId,\n                                decl: &hir::FnDecl,\n                                generics: &hir::Generics) {\n     debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\", decl, generics);\n@@ -1607,22 +1594,9 @@ fn insert_late_bound_lifetimes(map: &mut NamedRegionMap,\n         // any `impl Trait` in the return type? early-bound.\n         if appears_in_output.impl_trait { continue; }\n \n-        // does not appear in the inputs, but appears in the return\n-        // type? eventually this will be early-bound, but for now we\n-        // just mark it so we can issue warnings.\n-        let constrained_by_input = constrained_by_input.regions.contains(&name);\n-        let appears_in_output = appears_in_output.regions.contains(&name);\n-        if !constrained_by_input && appears_in_output {\n-            debug!(\"inserting issue_32330 entry for {:?}, {:?} on {:?}\",\n-                   lifetime.lifetime.id,\n-                   name,\n-                   fn_def_id);\n-            map.issue_32330.insert(\n-                lifetime.lifetime.id,\n-                ty::Issue32330 {\n-                    fn_def_id,\n-                    region_name: name,\n-                });\n+        // does not appear in the inputs, but appears in the return type? early-bound.\n+        if !constrained_by_input.regions.contains(&name) &&\n+            appears_in_output.regions.contains(&name) {\n             continue;\n         }\n "}, {"sha": "cae1eba5797cfb0d84cc720b1fcf60b284fe9c2d", "filename": "src/librustc/traits/project.rs", "status": "modified", "additions": 10, "deletions": 31, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fproject.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -479,9 +479,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n \n     let obligation = Obligation::with_depth(cause.clone(), depth, param_env, projection_ty);\n     match project_type(selcx, &obligation) {\n-        Ok(ProjectedTy::Progress(Progress { ty: projected_ty,\n-                                            mut obligations,\n-                                            cacheable })) => {\n+        Ok(ProjectedTy::Progress(Progress { ty: projected_ty, mut obligations })) => {\n             // if projection succeeded, then what we get out of this\n             // is also non-normalized (consider: it was derived from\n             // an impl, where-clause etc) and hence we must\n@@ -490,12 +488,10 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n             debug!(\"opt_normalize_projection_type: \\\n                     projected_ty={:?} \\\n                     depth={} \\\n-                    obligations={:?} \\\n-                    cacheable={:?}\",\n+                    obligations={:?}\",\n                    projected_ty,\n                    depth,\n-                   obligations,\n-                   cacheable);\n+                   obligations);\n \n             let result = if projected_ty.has_projection_types() {\n                 let mut normalizer = AssociatedTypeNormalizer::new(selcx,\n@@ -520,8 +516,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                     obligations,\n                 }\n             };\n-            infcx.projection_cache.borrow_mut()\n-                                  .complete(projection_ty, &result, cacheable);\n+            infcx.projection_cache.borrow_mut().complete(projection_ty, &result);\n             Some(result)\n         }\n         Ok(ProjectedTy::NoProgress(projected_ty)) => {\n@@ -532,8 +527,7 @@ fn opt_normalize_projection_type<'a, 'b, 'gcx, 'tcx>(\n                 value: projected_ty,\n                 obligations: vec![]\n             };\n-            infcx.projection_cache.borrow_mut()\n-                                  .complete(projection_ty, &result, true);\n+            infcx.projection_cache.borrow_mut().complete(projection_ty, &result);\n             Some(result)\n         }\n         Err(ProjectionTyError::TooManyCandidates) => {\n@@ -606,15 +600,13 @@ enum ProjectedTy<'tcx> {\n struct Progress<'tcx> {\n     ty: Ty<'tcx>,\n     obligations: Vec<PredicateObligation<'tcx>>,\n-    cacheable: bool,\n }\n \n impl<'tcx> Progress<'tcx> {\n     fn error<'a,'gcx>(tcx: TyCtxt<'a,'gcx,'tcx>) -> Self {\n         Progress {\n             ty: tcx.types.err,\n             obligations: vec![],\n-            cacheable: true\n         }\n     }\n \n@@ -1228,7 +1220,6 @@ fn confirm_param_env_candidate<'cx, 'gcx, 'tcx>(\n             Progress {\n                 ty: ty_match.value,\n                 obligations,\n-                cacheable: ty_match.unconstrained_regions.is_empty(),\n             }\n         }\n         Err(e) => {\n@@ -1272,7 +1263,6 @@ fn confirm_impl_candidate<'cx, 'gcx, 'tcx>(\n     Progress {\n         ty: ty.subst(tcx, substs),\n         obligations: nested,\n-        cacheable: true\n     }\n }\n \n@@ -1380,22 +1370,11 @@ impl<'tcx> ProjectionCache<'tcx> {\n         Ok(())\n     }\n \n-    /// Indicates that `key` was normalized to `value`. If `cacheable` is false,\n-    /// then this result is sadly not cacheable.\n-    fn complete(&mut self,\n-                key: ty::ProjectionTy<'tcx>,\n-                value: &NormalizedTy<'tcx>,\n-                cacheable: bool) {\n-        let fresh_key = if cacheable {\n-            debug!(\"ProjectionCacheEntry::complete: adding cache entry: key={:?}, value={:?}\",\n-                   key, value);\n-            self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.value))\n-        } else {\n-            debug!(\"ProjectionCacheEntry::complete: cannot cache: key={:?}, value={:?}\",\n-                   key, value);\n-            !self.map.remove(key)\n-        };\n-\n+    /// Indicates that `key` was normalized to `value`.\n+    fn complete(&mut self, key: ty::ProjectionTy<'tcx>, value: &NormalizedTy<'tcx>) {\n+        debug!(\"ProjectionCacheEntry::complete: adding cache entry: key={:?}, value={:?}\",\n+               key, value);\n+        let fresh_key = self.map.insert(key, ProjectionCacheEntry::NormalizedTy(value.value));\n         assert!(!fresh_key, \"never started projecting `{:?}`\", key);\n     }\n "}, {"sha": "86a4f66918965f3df58cd4a229c202501df477f0", "filename": "src/librustc/ty/error.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Ferror.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -39,8 +39,8 @@ pub enum TypeError<'tcx> {\n     RegionsDoesNotOutlive(Region<'tcx>, Region<'tcx>),\n     RegionsNotSame(Region<'tcx>, Region<'tcx>),\n     RegionsNoOverlap(Region<'tcx>, Region<'tcx>),\n-    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>, Option<Box<ty::Issue32330>>),\n-    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>, Option<Box<ty::Issue32330>>),\n+    RegionsInsufficientlyPolymorphic(BoundRegion, Region<'tcx>),\n+    RegionsOverlyPolymorphic(BoundRegion, Region<'tcx>),\n     Sorts(ExpectedFound<Ty<'tcx>>),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ast::FloatTy>),\n@@ -116,13 +116,13 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             RegionsNoOverlap(..) => {\n                 write!(f, \"lifetimes do not intersect\")\n             }\n-            RegionsInsufficientlyPolymorphic(br, _, _) => {\n+            RegionsInsufficientlyPolymorphic(br, _) => {\n                 write!(f,\n                        \"expected bound lifetime parameter{}{}, found concrete lifetime\",\n                        if br.is_named() { \" \" } else { \"\" },\n                        br)\n             }\n-            RegionsOverlyPolymorphic(br, _, _) => {\n+            RegionsOverlyPolymorphic(br, _) => {\n                 write!(f,\n                        \"expected concrete lifetime, found bound lifetime parameter{}{}\",\n                        if br.is_named() { \" \" } else { \"\" },\n@@ -257,15 +257,15 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n                 self.note_and_explain_region(db, \"...does not overlap \",\n                                            region2, \"\");\n             }\n-            RegionsInsufficientlyPolymorphic(_, conc_region, _) => {\n+            RegionsInsufficientlyPolymorphic(_, conc_region) => {\n                 self.note_and_explain_region(db, \"concrete lifetime that was found is \",\n                                            conc_region, \"\");\n             }\n-            RegionsOverlyPolymorphic(_, &ty::ReVar(_), _) => {\n+            RegionsOverlyPolymorphic(_, &ty::ReVar(_)) => {\n                 // don't bother to print out the message below for\n                 // inference variables, it's not very illuminating.\n             }\n-            RegionsOverlyPolymorphic(_, conc_region, _) => {\n+            RegionsOverlyPolymorphic(_, conc_region) => {\n                 self.note_and_explain_region(db, \"expected concrete lifetime is \",\n                                            conc_region, \"\");\n             }"}, {"sha": "2ee7149fc1311795bdd0d86cd2bb956f7a186729", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -67,7 +67,6 @@ pub use self::sty::{ExistentialTraitRef, PolyExistentialTraitRef};\n pub use self::sty::{ExistentialProjection, PolyExistentialProjection};\n pub use self::sty::{BoundRegion, EarlyBoundRegion, FreeRegion, Region};\n pub use self::sty::RegionKind;\n-pub use self::sty::Issue32330;\n pub use self::sty::{TyVid, IntVid, FloatVid, RegionVid, SkolemizedRegionVid};\n pub use self::sty::BoundRegion::*;\n pub use self::sty::InferTy::*;\n@@ -676,7 +675,6 @@ pub struct RegionParameterDef {\n     pub name: Name,\n     pub def_id: DefId,\n     pub index: u32,\n-    pub issue_32330: Option<ty::Issue32330>,\n \n     /// `pure_wrt_drop`, set by the (unsafe) `#[may_dangle]` attribute\n     /// on generic parameter `'a`, asserts data of lifetime `'a`"}, {"sha": "48ace804995ab238697101669dcbf644791c9eaf", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -346,13 +346,11 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             RegionsNoOverlap(a, b) => {\n                 return tcx.lift(&(a, b)).map(|(a, b)| RegionsNoOverlap(a, b))\n             }\n-            RegionsInsufficientlyPolymorphic(a, b, ref c) => {\n-                let c = c.clone();\n-                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b, c))\n+            RegionsInsufficientlyPolymorphic(a, b) => {\n+                return tcx.lift(&b).map(|b| RegionsInsufficientlyPolymorphic(a, b))\n             }\n-            RegionsOverlyPolymorphic(a, b, ref c) => {\n-                let c = c.clone();\n-                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b, c))\n+            RegionsOverlyPolymorphic(a, b) => {\n+                return tcx.lift(&b).map(|b| RegionsOverlyPolymorphic(a, b))\n             }\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n@@ -1004,13 +1002,11 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             RegionsNoOverlap(a, b) => {\n                 RegionsNoOverlap(a.fold_with(folder), b.fold_with(folder))\n             },\n-            RegionsInsufficientlyPolymorphic(a, b, ref c) => {\n-                let c = c.clone();\n-                RegionsInsufficientlyPolymorphic(a, b.fold_with(folder), c)\n+            RegionsInsufficientlyPolymorphic(a, b) => {\n+                RegionsInsufficientlyPolymorphic(a, b.fold_with(folder))\n             },\n-            RegionsOverlyPolymorphic(a, b, ref c) => {\n-                let c = c.clone();\n-                RegionsOverlyPolymorphic(a, b.fold_with(folder), c)\n+            RegionsOverlyPolymorphic(a, b) => {\n+                RegionsOverlyPolymorphic(a, b.fold_with(folder))\n             },\n             IntMismatch(x) => IntMismatch(x),\n             FloatMismatch(x) => FloatMismatch(x),\n@@ -1036,8 +1032,8 @@ impl<'tcx> TypeFoldable<'tcx> for ty::error::TypeError<'tcx> {\n             RegionsNoOverlap(a, b) => {\n                 a.visit_with(visitor) || b.visit_with(visitor)\n             },\n-            RegionsInsufficientlyPolymorphic(_, b, _) |\n-            RegionsOverlyPolymorphic(_, b, _) => {\n+            RegionsInsufficientlyPolymorphic(_, b) |\n+            RegionsOverlyPolymorphic(_, b) => {\n                 b.visit_with(visitor)\n             },\n             Sorts(x) => x.visit_with(visitor),"}, {"sha": "b42180b288bf6cb7cc43484d7293cba7ca1e529f", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -77,20 +77,6 @@ impl BoundRegion {\n     }\n }\n \n-/// When a region changed from late-bound to early-bound when #32330\n-/// was fixed, its `RegionParameterDef` will have one of these\n-/// structures that we can use to give nicer errors.\n-#[derive(Copy, Clone, Debug, PartialEq, PartialOrd, Eq, Ord, Hash,\n-         RustcEncodable, RustcDecodable)]\n-pub struct Issue32330 {\n-    /// fn where is region declared\n-    pub fn_def_id: DefId,\n-\n-    /// name of region; duplicates the info in BrNamed but convenient\n-    /// to have it here, and this code is only temporary\n-    pub region_name: ast::Name,\n-}\n-\n /// NB: If you change this, you'll probably want to change the corresponding\n /// AST structure in libsyntax/ast.rs as well.\n #[derive(Clone, PartialEq, Eq, Hash, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "1ec850ad7f3494ab228869167a5f0f52736f81fd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 37, "deletions": 43, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -1110,46 +1110,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n             }\n             hir::TyBareFn(ref bf) => {\n                 require_c_abi_if_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n-                let bare_fn_ty = self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl);\n-\n-                // Find any late-bound regions declared in return type that do\n-                // not appear in the arguments. These are not wellformed.\n-                //\n-                // Example:\n-                //\n-                //     for<'a> fn() -> &'a str <-- 'a is bad\n-                //     for<'a> fn(&'a String) -> &'a str <-- 'a is ok\n-                //\n-                // Note that we do this check **here** and not in\n-                // `ty_of_bare_fn` because the latter is also used to make\n-                // the types for fn items, and we do not want to issue a\n-                // warning then. (Once we fix #32330, the regions we are\n-                // checking for here would be considered early bound\n-                // anyway.)\n-                let inputs = bare_fn_ty.inputs();\n-                let late_bound_in_args = tcx.collect_constrained_late_bound_regions(\n-                    &inputs.map_bound(|i| i.to_owned()));\n-                let output = bare_fn_ty.output();\n-                let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n-                for br in late_bound_in_ret.difference(&late_bound_in_args) {\n-                    let br_name = match *br {\n-                        ty::BrNamed(_, name) => name,\n-                        _ => {\n-                            span_bug!(\n-                                bf.decl.output.span(),\n-                                \"anonymous bound region {:?} in return but not args\",\n-                                br);\n-                        }\n-                    };\n-                    struct_span_err!(tcx.sess,\n-                                     ast_ty.span,\n-                                     E0581,\n-                                     \"return type references lifetime `{}`, \\\n-                                      which does not appear in the fn input types\",\n-                                     br_name)\n-                        .emit();\n-                }\n-                tcx.mk_fn_ptr(bare_fn_ty)\n+                tcx.mk_fn_ptr(self.ty_of_fn(bf.unsafety, bf.abi, &bf.decl))\n             }\n             hir::TyTraitObject(ref bounds, ref lifetime) => {\n                 self.conv_object_ty_poly_trait_ref(ast_ty.span, bounds, lifetime)\n@@ -1269,23 +1230,56 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n                     -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n \n+        let tcx = self.tcx();\n         let input_tys: Vec<Ty> =\n             decl.inputs.iter().map(|a| self.ty_of_arg(a, None)).collect();\n \n         let output_ty = match decl.output {\n             hir::Return(ref output) => self.ast_ty_to_ty(output),\n-            hir::DefaultReturn(..) => self.tcx().mk_nil(),\n+            hir::DefaultReturn(..) => tcx.mk_nil(),\n         };\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n-        ty::Binder(self.tcx().mk_fn_sig(\n+        let bare_fn_ty = ty::Binder(tcx.mk_fn_sig(\n             input_tys.into_iter(),\n             output_ty,\n             decl.variadic,\n             unsafety,\n             abi\n-        ))\n+        ));\n+\n+        // Find any late-bound regions declared in return type that do\n+        // not appear in the arguments. These are not wellformed.\n+        //\n+        // Example:\n+        //     for<'a> fn() -> &'a str <-- 'a is bad\n+        //     for<'a> fn(&'a String) -> &'a str <-- 'a is ok\n+        let inputs = bare_fn_ty.inputs();\n+        let late_bound_in_args = tcx.collect_constrained_late_bound_regions(\n+            &inputs.map_bound(|i| i.to_owned()));\n+        let output = bare_fn_ty.output();\n+        let late_bound_in_ret = tcx.collect_referenced_late_bound_regions(&output);\n+        for br in late_bound_in_ret.difference(&late_bound_in_args) {\n+            let br_name = match *br {\n+                ty::BrNamed(_, name) => name,\n+                _ => {\n+                    span_bug!(\n+                        decl.output.span(),\n+                        \"anonymous bound region {:?} in return but not args\",\n+                        br);\n+                }\n+            };\n+            struct_span_err!(tcx.sess,\n+                             decl.output.span(),\n+                             E0581,\n+                             \"return type references lifetime `{}`, \\\n+                             which does not appear in the fn input types\",\n+                             br_name)\n+                .emit();\n+        }\n+\n+        bare_fn_ty\n     }\n \n     pub fn ty_of_closure(&self,"}, {"sha": "cb22dcc21de22a471df046994afdb0525512a16b", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -1607,7 +1607,7 @@ impl<'a, 'gcx, 'tcx> AstConv<'gcx, 'tcx> for FnCtxt<'a, 'gcx, 'tcx> {\n     fn re_infer(&self, span: Span, def: Option<&ty::RegionParameterDef>)\n                 -> Option<ty::Region<'tcx>> {\n         let v = match def {\n-            Some(def) => infer::EarlyBoundRegion(span, def.name, def.issue_32330),\n+            Some(def) => infer::EarlyBoundRegion(span, def.name),\n             None => infer::MiscVariable(span)\n         };\n         Some(self.next_region_var(v))"}, {"sha": "f25a6cf58a79e6f0f3887e72f338f35bcd9ef521", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -979,13 +979,11 @@ fn generics_of<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     let early_lifetimes = early_bound_lifetimes_from_generics(tcx, ast_generics);\n     let regions = early_lifetimes.enumerate().map(|(i, l)| {\n-        let issue_32330 = tcx.named_region_map.issue_32330.get(&l.lifetime.id).cloned();\n         ty::RegionParameterDef {\n             name: l.lifetime.name,\n             index: own_start + i as u32,\n             def_id: tcx.hir.local_def_id(l.lifetime.id),\n             pure_wrt_drop: l.pure_wrt_drop,\n-            issue_32330: issue_32330,\n         }\n     }).collect::<Vec<_>>();\n "}, {"sha": "0e822aff01e877771ef084835c72736bec3aeacc", "filename": "src/test/compile-fail/associated-types/cache/project-fn-ret-contravariant.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-contravariant.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -43,23 +43,19 @@ fn baz<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n     (a, b)\n }\n \n-// FIXME(#32330)\n-//#[cfg(transmute)] // one instantiations: BAD\n-//fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n-//    bar(foo, x) //[transmute] ERROR E0495\n-//}\n+#[cfg(transmute)] // one instantiations: BAD\n+fn baz<'a,'b>(x: &'a u32) -> &'static u32 {\n+   bar(foo, x) //[transmute]~ ERROR E0495\n+}\n \n-// FIXME(#32330)\n-//#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n-//fn transmute<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n-//    let a = bar(foo, y); //[krisskross] ERROR E0495\n-//    let b = bar(foo, x); //[krisskross] ERROR E0495\n-//    (a, b)\n-//}\n+#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n+fn transmute<'a,'b>(x: &'a u32, y: &'b u32) -> (&'a u32, &'b u32) {\n+   let a = bar(foo, y); //[krisskross]~ ERROR E0495\n+   let b = bar(foo, x); //[krisskross]~ ERROR E0495\n+   (a, b)\n+}\n \n #[rustc_error]\n fn main() { }\n //[ok]~^ ERROR compilation successful\n //[oneuse]~^^ ERROR compilation successful\n-//[transmute]~^^^ ERROR compilation successful\n-//[krisskross]~^^^^ ERROR compilation successful"}, {"sha": "10fe612980d34a114cd374250926afcfb66e39e5", "filename": "src/test/compile-fail/associated-types/cache/project-fn-ret-invariant.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -42,35 +42,29 @@ fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n     (a, b)\n }\n \n-// FIXME(#32330)\n-//#[cfg(oneuse)] // one instantiation: BAD\n-//fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-//    let f = foo; // <-- No consistent type can be inferred for `f` here.\n-//    let a = bar(f, x); //[oneuse] ERROR E0495\n-//    let b = bar(f, y);\n-//    (a, b)\n-//}\n+#[cfg(oneuse)] // one instantiation: BAD\n+fn baz<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   let f = foo; // <-- No consistent type can be inferred for `f` here.\n+   let a = bar(f, x); //[oneuse]~^ ERROR E0495\n+   let b = bar(f, y);\n+   (a, b)\n+}\n \n-// FIXME(#32330)\n-//#[cfg(transmute)] // one instantiations: BAD\n-//fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n-//    // Cannot instantiate `foo` with any lifetime other than `'a`,\n-//    // since it is provided as input.\n-//\n-//    bar(foo, x) //[transmute] ERROR E0495\n-//}\n+#[cfg(transmute)] // one instantiations: BAD\n+fn baz<'a,'b>(x: Type<'a>) -> Type<'static> {\n+   // Cannot instantiate `foo` with any lifetime other than `'a`,\n+   // since it is provided as input.\n \n-// FIXME(#32330)\n-//#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n-//fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n-//    let a = bar(foo, y); //[krisskross] ERROR E0495\n-//    let b = bar(foo, x); //[krisskross] ERROR E0495\n-//    (a, b)\n-//}\n+   bar(foo, x) //[transmute]~ ERROR E0495\n+}\n+\n+#[cfg(krisskross)] // two instantiations, mixing and matching: BAD\n+fn transmute<'a,'b>(x: Type<'a>, y: Type<'b>) -> (Type<'a>, Type<'b>) {\n+   let a = bar(foo, y); //[krisskross]~ ERROR E0495\n+   let b = bar(foo, x); //[krisskross]~ ERROR E0495\n+   (a, b)\n+}\n \n #[rustc_error]\n fn main() { }\n //[ok]~^ ERROR compilation successful\n-//[oneuse]~^^ ERROR compilation successful\n-//[transmute]~^^^ ERROR compilation successful\n-//[krisskross]~^^^^ ERROR compilation successful"}, {"sha": "c88d74d53ce9424cf21d56aef2b13676010ad182", "filename": "src/test/compile-fail/hr-subtype.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhr-subtype.rs?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -91,9 +91,6 @@ check! { free_inv_x_vs_free_inv_y: (fn(Inv<'x>),\n // - if we are covariant, then 'a and 'b can be set to the call-site\n //   intersection;\n // - if we are contravariant, then 'a can be inferred to 'static.\n-//\n-// FIXME(#32330) this is true, but we are not currently impl'ing this\n-// full semantics\n check! { bound_a_b_vs_bound_a: (for<'a,'b> fn(&'a u32, &'b u32),\n                                 for<'a>    fn(&'a u32, &'a u32)) }\n check! { bound_co_a_b_vs_bound_co_a: (for<'a,'b> fn(Co<'a>, Co<'b>),"}, {"sha": "1598a8a40d2f0b8bfd30b1f42629ee6e4c23e1c1", "filename": "src/test/ui/regions-fn-subtyping-return-static.stderr", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/477e9f01714b6dffa1fb75e95b890d7abc2fcc52/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions-fn-subtyping-return-static.stderr?ref=477e9f01714b6dffa1fb75e95b890d7abc2fcc52", "patch": "@@ -6,8 +6,6 @@ error[E0308]: mismatched types\n    |\n    = note: expected type `fn(&'cx S) -> &'cx S`\n               found type `fn(&'a S) -> &S {bar::<'_>}`\n-   = note: lifetime parameter `'b` declared on fn `bar` appears only in the return type, but here is required to be higher-ranked, which means that `'b` must appear in both argument and return types\n-   = note: this error is the result of a recent bug fix; for more information, see issue #33685 <https://github.com/rust-lang/rust/issues/33685>\n \n error: aborting due to previous error\n "}]}