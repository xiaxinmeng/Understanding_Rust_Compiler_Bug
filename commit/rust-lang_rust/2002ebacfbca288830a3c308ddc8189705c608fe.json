{"sha": "2002ebacfbca288830a3c308ddc8189705c608fe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwMDJlYmFjZmJjYTI4ODgzMGEzYzMwOGRkYzgxODk3MDVjNjA4ZmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-14T17:11:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-07-14T17:11:02Z"}, "message": "Auto merge of #74330 - Manishearth:rollup-mrc09pb, r=Manishearth\n\nRollup of 15 pull requests\n\nSuccessful merges:\n\n - #71237 (Add Ayu theme to rustdoc)\n - #73720 (Clean up E0704 error explanation)\n - #73866 (Obviate #[allow(improper_ctypes_definitions)])\n - #73965 (typeck: check for infer before type impls trait)\n - #73986 (add (unchecked) indexing methods to raw (and NonNull) slices)\n - #74173 (Detect tuple struct incorrectly used as struct pat)\n - #74220 (Refactor Windows `parse_prefix`)\n - #74227 (Remove an unwrap in layout computation)\n - #74239 (Update llvm-project to latest origin/rustc/10.0-2020-05-05 commit )\n - #74257 (don't mark linux kernel module targets as a unix environment)\n - #74270 (typeck: report placeholder type error w/out span)\n - #74296 (Clarify the description for rfind)\n - #74310 (Use `ArrayVec` in `SparseBitSet`.)\n - #74316 (Remove unnecessary type hints from Wake internals)\n - #74324 (Update Clippy)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "d02268730c1ae866eb4a1ec31e144592b868be3d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d02268730c1ae866eb4a1ec31e144592b868be3d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2002ebacfbca288830a3c308ddc8189705c608fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2002ebacfbca288830a3c308ddc8189705c608fe", "html_url": "https://github.com/rust-lang/rust/commit/2002ebacfbca288830a3c308ddc8189705c608fe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2002ebacfbca288830a3c308ddc8189705c608fe/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c724b67e1b474262917a5154d74e7072267593fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/c724b67e1b474262917a5154d74e7072267593fe", "html_url": "https://github.com/rust-lang/rust/commit/c724b67e1b474262917a5154d74e7072267593fe"}, {"sha": "5414eae4521d0b6141b9db4c44be144757e5d5fb", "url": "https://api.github.com/repos/rust-lang/rust/commits/5414eae4521d0b6141b9db4c44be144757e5d5fb", "html_url": "https://github.com/rust-lang/rust/commit/5414eae4521d0b6141b9db4c44be144757e5d5fb"}], "stats": {"total": 7116, "additions": 5650, "deletions": 1466}, "files": [{"sha": "5309c03ee23aedd346dbf0acb7964f1bf76439ff", "filename": "Cargo.lock", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -94,6 +94,12 @@ dependencies = [\n  \"nodrop\",\n ]\n \n+[[package]]\n+name = \"arrayvec\"\n+version = \"0.5.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"cff77d8686867eceff3105329d4698d96c2391c176d5d03adc90c7389162b5b8\"\n+\n [[package]]\n name = \"atty\"\n version = \"0.2.14\"\n@@ -164,7 +170,7 @@ version = \"0.2.18\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"5d6d530bdd2d52966a6d03b7a964add7ae1a288d25214066fd4b600f0f796400\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.4.7\",\n  \"constant_time_eq\",\n ]\n \n@@ -714,7 +720,7 @@ version = \"0.7.2\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"fedcd6772e37f3da2a9af9bf12ebe046c0dfe657992377b4df982a2b54cd37a9\"\n dependencies = [\n- \"arrayvec\",\n+ \"arrayvec 0.4.7\",\n  \"cfg-if\",\n  \"crossbeam-utils 0.6.5\",\n  \"lazy_static\",\n@@ -3494,8 +3500,8 @@ dependencies = [\n name = \"rustc_index\"\n version = \"0.0.0\"\n dependencies = [\n+ \"arrayvec 0.5.1\",\n  \"rustc_serialize\",\n- \"smallvec 1.4.0\",\n ]\n \n [[package]]\n@@ -3996,6 +4002,7 @@ dependencies = [\n  \"rustc_data_structures\",\n  \"rustc_errors\",\n  \"rustc_hir\",\n+ \"rustc_hir_pretty\",\n  \"rustc_index\",\n  \"rustc_infer\",\n  \"rustc_middle\","}, {"sha": "252e04a410548e9ad9f9eb82ade14b6d1ddedd47", "filename": "src/liballoc/task.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Fliballoc%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Fliballoc%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftask.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -69,14 +69,13 @@ fn raw_waker<W: Wake + Send + Sync + 'static>(waker: Arc<W>) -> RawWaker {\n \n     // Wake by value, moving the Arc into the Wake::wake function\n     unsafe fn wake<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        let waker: Arc<W> = unsafe { Arc::from_raw(waker as *const W) };\n+        let waker = unsafe { Arc::from_raw(waker as *const W) };\n         <W as Wake>::wake(waker);\n     }\n \n     // Wake by reference, wrap the waker in ManuallyDrop to avoid dropping it\n     unsafe fn wake_by_ref<W: Wake + Send + Sync + 'static>(waker: *const ()) {\n-        let waker: ManuallyDrop<Arc<W>> =\n-            unsafe { ManuallyDrop::new(Arc::from_raw(waker as *const W)) };\n+        let waker = unsafe { ManuallyDrop::new(Arc::from_raw(waker as *const W)) };\n         <W as Wake>::wake_by_ref(&waker);\n     }\n "}, {"sha": "c7496c209bcb06427a96adaeee727559a6ede34b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -148,6 +148,7 @@\n #![feature(associated_type_bounds)]\n #![feature(const_type_id)]\n #![feature(const_caller_location)]\n+#![feature(slice_ptr_get)]\n #![feature(no_niche)] // rust-lang/rust#68303\n #![feature(unsafe_block_in_unsafe_fn)]\n #![deny(unsafe_op_in_unsafe_fn)]"}, {"sha": "39d4aca636a05c6a632bc1a0347dd1913f52e4d1", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,6 +2,7 @@ use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n use crate::mem;\n+use crate::slice::SliceIndex;\n \n #[lang = \"const_ptr\"]\n impl<T: ?Sized> *const T {\n@@ -826,6 +827,55 @@ impl<T> *const [T] {\n         // Only `std` can make this guarantee.\n         unsafe { Repr { rust: self }.raw }.len\n     }\n+\n+    /// Returns a raw pointer to the slice's buffer.\n+    ///\n+    /// This is equivalent to casting `self` to `*const T`, but more type-safe.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_get)]\n+    /// use std::ptr;\n+    ///\n+    /// let slice: *const [i8] = ptr::slice_from_raw_parts(ptr::null(), 3);\n+    /// assert_eq!(slice.as_ptr(), 0 as *const i8);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[rustc_const_unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    pub const fn as_ptr(self) -> *const T {\n+        self as *const T\n+    }\n+\n+    /// Returns a raw pointer to an element or subslice, without doing bounds\n+    /// checking.\n+    ///\n+    /// Calling this method with an out-of-bounds index or when `self` is not dereferencable\n+    /// is *[undefined behavior]* even if the resulting pointer is not used.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_get)]\n+    ///\n+    /// let x = &[1, 2, 4] as *const [i32];\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked(1), x.as_ptr().add(1));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked<I>(self, index: I) -> *const I::Output\n+    where\n+        I: SliceIndex<[T]>,\n+    {\n+        // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n+        unsafe { index.get_unchecked(self) }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "644465d7d17f8a60fc92dcb49f515124a4a6ab84", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,6 +1,7 @@\n use super::*;\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::intrinsics;\n+use crate::slice::SliceIndex;\n \n #[lang = \"mut_ptr\"]\n impl<T: ?Sized> *mut T {\n@@ -1014,7 +1015,6 @@ impl<T> *mut [T] {\n     ///\n     /// ```rust\n     /// #![feature(slice_ptr_len)]\n-    ///\n     /// use std::ptr;\n     ///\n     /// let slice: *mut [i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 3);\n@@ -1028,6 +1028,55 @@ impl<T> *mut [T] {\n         // Only `std` can make this guarantee.\n         unsafe { Repr { rust_mut: self }.raw }.len\n     }\n+\n+    /// Returns a raw pointer to the slice's buffer.\n+    ///\n+    /// This is equivalent to casting `self` to `*mut T`, but more type-safe.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_get)]\n+    /// use std::ptr;\n+    ///\n+    /// let slice: *mut [i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 3);\n+    /// assert_eq!(slice.as_mut_ptr(), 0 as *mut i8);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[rustc_const_unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    pub const fn as_mut_ptr(self) -> *mut T {\n+        self as *mut T\n+    }\n+\n+    /// Returns a raw pointer to an element or subslice, without doing bounds\n+    /// checking.\n+    ///\n+    /// Calling this method with an out-of-bounds index or when `self` is not dereferencable\n+    /// is *[undefined behavior]* even if the resulting pointer is not used.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_get)]\n+    ///\n+    /// let x = &mut [1, 2, 4] as *mut [i32];\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked_mut(1), x.as_mut_ptr().add(1));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I>(self, index: I) -> *mut I::Output\n+    where\n+        I: SliceIndex<[T]>,\n+    {\n+        // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n+        unsafe { index.get_unchecked_mut(self) }\n+    }\n }\n \n // Equality for pointers"}, {"sha": "b362a49d604e7ffd2a3ccdecee89c4f33c17f440", "filename": "src/libcore/ptr/non_null.rs", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -6,6 +6,7 @@ use crate::marker::Unsize;\n use crate::mem;\n use crate::ops::{CoerceUnsized, DispatchFromDyn};\n use crate::ptr::Unique;\n+use crate::slice::SliceIndex;\n \n /// `*mut T` but non-zero and covariant.\n ///\n@@ -192,7 +193,6 @@ impl<T> NonNull<[T]> {\n     ///\n     /// ```rust\n     /// #![feature(slice_ptr_len, nonnull_slice_from_raw_parts)]\n-    ///\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n@@ -204,6 +204,57 @@ impl<T> NonNull<[T]> {\n     pub const fn len(self) -> usize {\n         self.as_ptr().len()\n     }\n+\n+    /// Returns a non-null pointer to the slice's buffer.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_get, nonnull_slice_from_raw_parts)]\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n+    /// assert_eq!(slice.as_non_null_ptr(), NonNull::new(1 as *mut i8).unwrap());\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[rustc_const_unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    pub const fn as_non_null_ptr(self) -> NonNull<T> {\n+        // SAFETY: We know `self` is non-null.\n+        unsafe { NonNull::new_unchecked(self.as_ptr().as_mut_ptr()) }\n+    }\n+\n+    /// Returns a raw pointer to an element or subslice, without doing bounds\n+    /// checking.\n+    ///\n+    /// Calling this method with an out-of-bounds index or when `self` is not dereferencable\n+    /// is *[undefined behavior]* even if the resulting pointer is not used.\n+    ///\n+    /// [undefined behavior]: https://doc.rust-lang.org/reference/behavior-considered-undefined.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(slice_ptr_get, nonnull_slice_from_raw_parts)]\n+    /// use std::ptr::NonNull;\n+    ///\n+    /// let x = &mut [1, 2, 4];\n+    /// let x = NonNull::slice_from_raw_parts(NonNull::new(x.as_mut_ptr()).unwrap(), x.len());\n+    ///\n+    /// unsafe {\n+    ///     assert_eq!(x.get_unchecked_mut(1).as_ptr(), x.as_non_null_ptr().as_ptr().add(1));\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_ptr_get\", issue = \"74265\")]\n+    #[inline]\n+    pub unsafe fn get_unchecked_mut<I>(self, index: I) -> NonNull<I::Output>\n+    where\n+        I: SliceIndex<[T]>,\n+    {\n+        // SAFETY: the caller ensures that `self` is dereferencable and `index` in-bounds.\n+        // As a consequence, the resulting pointer cannot be NULL.\n+        unsafe { NonNull::new_unchecked(self.as_ptr().get_unchecked_mut(index)) }\n+    }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]"}, {"sha": "0e202bb7801cff50e7d16e597e70ce710447761d", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -310,8 +310,10 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        // SAFETY: the caller must uphold the safety requirements for `get_unchecked`.\n-        unsafe { index.get_unchecked(self) }\n+        // SAFETY: the caller must uphold most of the safety requirements for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*index.get_unchecked(self) }\n     }\n \n     /// Returns a mutable reference to an element or subslice, without doing\n@@ -342,8 +344,10 @@ impl<T> [T] {\n     where\n         I: SliceIndex<Self>,\n     {\n-        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`.\n-        unsafe { index.get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety requirements for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *index.get_unchecked_mut(self) }\n     }\n \n     /// Returns a raw pointer to the slice's buffer.\n@@ -3010,6 +3014,9 @@ mod private_slice_index {\n }\n \n /// A helper trait used for indexing operations.\n+///\n+/// Implementations of this trait have to promise that if the argument\n+/// to `get_(mut_)unchecked` is a safe reference, then so is the result.\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n #[rustc_on_unimplemented(\n     on(T = \"str\", label = \"string indices are ranges of `usize`\",),\n@@ -3021,7 +3028,7 @@ see chapter in The Book <https://doc.rust-lang.org/book/ch08-02-strings.html#ind\n     message = \"the type `{T}` cannot be indexed by `{Self}`\",\n     label = \"slice indices are of type `usize` or ranges of `usize`\"\n )]\n-pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n+pub unsafe trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n     /// The output type returned by methods.\n     #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n     type Output: ?Sized;\n@@ -3038,21 +3045,21 @@ pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n \n     /// Returns a shared reference to the output at this location, without\n     /// performing any bounds checking.\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used.\n+    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n+    /// is *[undefined behavior]* even if the resulting reference is not used.\n     ///\n     /// [undefined behavior]: ../../reference/behavior-considered-undefined.html\n     #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    unsafe fn get_unchecked(self, slice: &T) -> &Self::Output;\n+    unsafe fn get_unchecked(self, slice: *const T) -> *const Self::Output;\n \n     /// Returns a mutable reference to the output at this location, without\n     /// performing any bounds checking.\n-    /// Calling this method with an out-of-bounds index is *[undefined behavior]*\n-    /// even if the resulting reference is not used.\n+    /// Calling this method with an out-of-bounds index or a dangling `slice` pointer\n+    /// is *[undefined behavior]* even if the resulting reference is not used.\n     ///\n     /// [undefined behavior]: ../../reference/behavior-considered-undefined.html\n     #[unstable(feature = \"slice_index_methods\", issue = \"none\")]\n-    unsafe fn get_unchecked_mut(self, slice: &mut T) -> &mut Self::Output;\n+    unsafe fn get_unchecked_mut(self, slice: *mut T) -> *mut Self::Output;\n \n     /// Returns a shared reference to the output at this location, panicking\n     /// if out of bounds.\n@@ -3068,33 +3075,32 @@ pub trait SliceIndex<T: ?Sized>: private_slice_index::Sealed {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for usize {\n+unsafe impl<T> SliceIndex<[T]> for usize {\n     type Output = T;\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&T> {\n-        if self < slice.len() { unsafe { Some(self.get_unchecked(slice)) } } else { None }\n+        if self < slice.len() { unsafe { Some(&*self.get_unchecked(slice)) } } else { None }\n     }\n \n     #[inline]\n     fn get_mut(self, slice: &mut [T]) -> Option<&mut T> {\n-        if self < slice.len() { unsafe { Some(self.get_unchecked_mut(slice)) } } else { None }\n+        if self < slice.len() { unsafe { Some(&mut *self.get_unchecked_mut(slice)) } } else { None }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &T {\n-        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n-        // the caller guarantees that `self` is in bounds of `slice`\n-        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n-        // The obtained pointer comes from a reference which is guaranteed\n-        // to be valid.\n-        unsafe { &*slice.as_ptr().add(self) }\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const T {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { slice.as_ptr().add(self) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut T {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut T {\n         // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { &mut *slice.as_mut_ptr().add(self) }\n+        unsafe { slice.as_mut_ptr().add(self) }\n     }\n \n     #[inline]\n@@ -3111,15 +3117,15 @@ impl<T> SliceIndex<[T]> for usize {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::Range<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::Range<usize> {\n     type Output = [T];\n \n     #[inline]\n     fn get(self, slice: &[T]) -> Option<&[T]> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n-            unsafe { Some(self.get_unchecked(slice)) }\n+            unsafe { Some(&*self.get_unchecked(slice)) }\n         }\n     }\n \n@@ -3128,24 +3134,25 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         if self.start > self.end || self.end > slice.len() {\n             None\n         } else {\n-            unsafe { Some(self.get_unchecked_mut(slice)) }\n+            unsafe { Some(&mut *self.get_unchecked_mut(slice)) }\n         }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n-        // SAFETY: `slice` cannot be longer than `isize::MAX` and\n-        // the caller guarantees that `self` is in bounds of `slice`\n-        // so `self` cannot overflow an `isize`, so the call to `add` is safe.\n-        // Also, since the caller guarantees that `self` is in bounds of `slice`,\n-        // `from_raw_parts` will give a subslice of `slice` which is always safe.\n-        unsafe { from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n+        // SAFETY: the caller guarantees that `slice` is not dangling, so it\n+        // cannot be longer than `isize::MAX`. They also guarantee that\n+        // `self` is in bounds of `slice` so `self` cannot overflow an `isize`,\n+        // so the call to `add` is safe.\n+        unsafe { ptr::slice_from_raw_parts(slice.as_ptr().add(self.start), self.end - self.start) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: see comments for `get_unchecked` above.\n-        unsafe { from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start) }\n+        unsafe {\n+            ptr::slice_from_raw_parts_mut(slice.as_mut_ptr().add(self.start), self.end - self.start)\n+        }\n     }\n \n     #[inline]\n@@ -3155,7 +3162,7 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_index_len_fail(self.end, slice.len());\n         }\n-        unsafe { self.get_unchecked(slice) }\n+        unsafe { &*self.get_unchecked(slice) }\n     }\n \n     #[inline]\n@@ -3165,12 +3172,12 @@ impl<T> SliceIndex<[T]> for ops::Range<usize> {\n         } else if self.end > slice.len() {\n             slice_index_len_fail(self.end, slice.len());\n         }\n-        unsafe { self.get_unchecked_mut(slice) }\n+        unsafe { &mut *self.get_unchecked_mut(slice) }\n     }\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3184,13 +3191,13 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (0..self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (0..self.end).get_unchecked_mut(slice) }\n     }\n@@ -3207,7 +3214,7 @@ impl<T> SliceIndex<[T]> for ops::RangeTo<usize> {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3221,13 +3228,13 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (self.start..slice.len()).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (self.start..slice.len()).get_unchecked_mut(slice) }\n     }\n@@ -3244,7 +3251,7 @@ impl<T> SliceIndex<[T]> for ops::RangeFrom<usize> {\n }\n \n #[stable(feature = \"slice_get_slice_impls\", since = \"1.15.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeFull {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeFull {\n     type Output = [T];\n \n     #[inline]\n@@ -3258,12 +3265,12 @@ impl<T> SliceIndex<[T]> for ops::RangeFull {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         slice\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         slice\n     }\n \n@@ -3279,7 +3286,7 @@ impl<T> SliceIndex<[T]> for ops::RangeFull {\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3297,13 +3304,13 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n     }\n@@ -3326,7 +3333,7 @@ impl<T> SliceIndex<[T]> for ops::RangeInclusive<usize> {\n }\n \n #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n+unsafe impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     type Output = [T];\n \n     #[inline]\n@@ -3340,13 +3347,13 @@ impl<T> SliceIndex<[T]> for ops::RangeToInclusive<usize> {\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked(self, slice: &[T]) -> &[T] {\n+    unsafe fn get_unchecked(self, slice: *const [T]) -> *const [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked`.\n         unsafe { (0..=self.end).get_unchecked(slice) }\n     }\n \n     #[inline]\n-    unsafe fn get_unchecked_mut(self, slice: &mut [T]) -> &mut [T] {\n+    unsafe fn get_unchecked_mut(self, slice: *mut [T]) -> *mut [T] {\n         // SAFETY: the caller has to uphold the safety contract for `get_unchecked_mut`.\n         unsafe { (0..=self.end).get_unchecked_mut(slice) }\n     }"}, {"sha": "393911675c73e8d1e2311beff926924e13611ded", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 81, "deletions": 82, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1731,7 +1731,8 @@ Section: Trait implementations\n mod traits {\n     use crate::cmp::Ordering;\n     use crate::ops;\n-    use crate::slice::{self, SliceIndex};\n+    use crate::ptr;\n+    use crate::slice::SliceIndex;\n \n     /// Implements ordering of strings.\n     ///\n@@ -1822,7 +1823,7 @@ mod traits {\n     ///\n     /// Equivalent to `&self[0 .. len]` or `&mut self[0 .. len]`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeFull {\n+    unsafe impl SliceIndex<str> for ops::RangeFull {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -1833,11 +1834,11 @@ mod traits {\n             Some(slice)\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             slice\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             slice\n         }\n         #[inline]\n@@ -1886,16 +1887,18 @@ mod traits {\n     /// // &s[3 .. 100];\n     /// ```\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::Range<usize> {\n+    unsafe impl SliceIndex<str> for ops::Range<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if self.start <= self.end\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `start` and `end` are on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                // We also checked char boundaries, so this is valid UTF-8.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n@@ -1907,34 +1910,28 @@ mod traits {\n                 && slice.is_char_boundary(self.end)\n             {\n                 // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // We know the pointer is unique because we got it from `slice`.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n             // which satisfies all the conditions for `add`.\n             let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.start` and `self.end` are char boundaries.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n+            ptr::slice_from_raw_parts(ptr, len) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             // SAFETY: see comments for `get_unchecked`.\n             let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = self.end - self.start;\n-            // SAFETY: mostly identical to the comments for `get_unchecked`, except that we\n-            // can return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n+            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -1949,8 +1946,9 @@ mod traits {\n                 && slice.is_char_boundary(self.start)\n                 && slice.is_char_boundary(self.end)\n             {\n-                // SAFETY: just checked that `start` and `end` are on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `start` and `end` are on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, self.end)\n             }\n@@ -1973,44 +1971,39 @@ mod traits {\n     /// Panics if `end` does not point to the starting byte offset of a\n     /// character (as defined by `is_char_boundary`), or if `end > len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeTo<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeTo<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             let ptr = slice.as_ptr();\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.end` is a char boundary.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, self.end)) }\n+            ptr::slice_from_raw_parts(ptr, self.end) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             let ptr = slice.as_mut_ptr();\n-            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n-            // return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, self.end)) }\n+            ptr::slice_from_raw_parts_mut(ptr, self.end) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2020,8 +2013,9 @@ mod traits {\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n             if slice.is_char_boundary(self.end) {\n-                // SAFETY: just checked that `end` is on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `end` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, 0, self.end)\n             }\n@@ -2045,49 +2039,44 @@ mod traits {\n     /// Panics if `begin` does not point to the starting byte offset of\n     /// a character (as defined by `is_char_boundary`), or if `begin >= len`.\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n-    impl SliceIndex<str> for ops::RangeFrom<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeFrom<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                Some(unsafe { self.get_unchecked(slice) })\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &*self.get_unchecked(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n         fn get_mut(self, slice: &mut str) -> Option<&mut Self::Output> {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                Some(unsafe { self.get_unchecked_mut(slice) })\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                Some(unsafe { &mut *self.get_unchecked_mut(slice) })\n             } else {\n                 None\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n+            let slice = slice as *const [u8];\n             // SAFETY: the caller guarantees that `self` is in bounds of `slice`\n             // which satisfies all the conditions for `add`.\n             let ptr = unsafe { slice.as_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            // SAFETY: as the caller guarantees that `self` is in bounds of `slice`,\n-            // we can safely construct a subslice with `from_raw_parts` and use it\n-            // since we return a shared thus immutable reference.\n-            // The call to `from_utf8_unchecked` is safe since the data comes from\n-            // a `str` which is guaranteed to be valid utf8, since the caller\n-            // must guarantee that `self.start` is a char boundary.\n-            unsafe { super::from_utf8_unchecked(slice::from_raw_parts(ptr, len)) }\n+            ptr::slice_from_raw_parts(ptr, len) as *const str\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n+            let slice = slice as *mut [u8];\n             // SAFETY: identical to `get_unchecked`.\n             let ptr = unsafe { slice.as_mut_ptr().add(self.start) };\n             let len = slice.len() - self.start;\n-            // SAFETY: mostly identical to `get_unchecked`, except that we can safely\n-            // return a mutable reference since the caller passed a mutable reference\n-            // and is thus guaranteed to have exclusive write access to `slice`.\n-            unsafe { super::from_utf8_unchecked_mut(slice::from_raw_parts_mut(ptr, len)) }\n+            ptr::slice_from_raw_parts_mut(ptr, len) as *mut str\n         }\n         #[inline]\n         fn index(self, slice: &str) -> &Self::Output {\n@@ -2097,8 +2086,9 @@ mod traits {\n         #[inline]\n         fn index_mut(self, slice: &mut str) -> &mut Self::Output {\n             if slice.is_char_boundary(self.start) {\n-                // SAFETY: just checked that `start` is on a char boundary.\n-                unsafe { self.get_unchecked_mut(slice) }\n+                // SAFETY: just checked that `start` is on a char boundary,\n+                // and we are passing in a safe reference, so the return value will also be one.\n+                unsafe { &mut *self.get_unchecked_mut(slice) }\n             } else {\n                 super::slice_error_fail(slice, self.start, slice.len())\n             }\n@@ -2122,7 +2112,7 @@ mod traits {\n     /// to the ending byte offset of a character (`end + 1` is either a starting\n     /// byte offset or equal to `len`), if `begin > end`, or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl SliceIndex<str> for ops::RangeInclusive<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeInclusive<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -2141,12 +2131,12 @@ mod traits {\n             }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n             unsafe { (*self.start()..self.end() + 1).get_unchecked(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n             unsafe { (*self.start()..self.end() + 1).get_unchecked_mut(slice) }\n         }\n@@ -2181,7 +2171,7 @@ mod traits {\n     /// (`end + 1` is either a starting byte offset as defined by\n     /// `is_char_boundary`, or equal to `len`), or if `end >= len`.\n     #[stable(feature = \"inclusive_range\", since = \"1.26.0\")]\n-    impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n+    unsafe impl SliceIndex<str> for ops::RangeToInclusive<usize> {\n         type Output = str;\n         #[inline]\n         fn get(self, slice: &str) -> Option<&Self::Output> {\n@@ -2192,12 +2182,12 @@ mod traits {\n             if self.end == usize::MAX { None } else { (..self.end + 1).get_mut(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked(self, slice: &str) -> &Self::Output {\n+        unsafe fn get_unchecked(self, slice: *const str) -> *const Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n             unsafe { (..self.end + 1).get_unchecked(slice) }\n         }\n         #[inline]\n-        unsafe fn get_unchecked_mut(self, slice: &mut str) -> &mut Self::Output {\n+        unsafe fn get_unchecked_mut(self, slice: *mut str) -> *mut Self::Output {\n             // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n             unsafe { (..self.end + 1).get_unchecked_mut(slice) }\n         }\n@@ -2560,8 +2550,10 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked<I: SliceIndex<str>>(&self, i: I) -> &I::Output {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { i.get_unchecked(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*i.get_unchecked(self) }\n     }\n \n     /// Returns a mutable, unchecked subslice of `str`.\n@@ -2593,8 +2585,10 @@ impl str {\n     #[stable(feature = \"str_checked_slicing\", since = \"1.20.0\")]\n     #[inline]\n     pub unsafe fn get_unchecked_mut<I: SliceIndex<str>>(&mut self, i: I) -> &mut I::Output {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { i.get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *i.get_unchecked_mut(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2644,8 +2638,10 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked`.\n-        unsafe { (begin..end).get_unchecked(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &*(begin..end).get_unchecked(self) }\n     }\n \n     /// Creates a string slice from another string slice, bypassing safety\n@@ -2676,8 +2672,10 @@ impl str {\n     #[rustc_deprecated(since = \"1.29.0\", reason = \"use `get_unchecked_mut(begin..end)` instead\")]\n     #[inline]\n     pub unsafe fn slice_mut_unchecked(&mut self, begin: usize, end: usize) -> &mut str {\n-        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`.\n-        unsafe { (begin..end).get_unchecked_mut(self) }\n+        // SAFETY: the caller must uphold the safety contract for `get_unchecked_mut`;\n+        // the slice is dereferencable because `self` is a safe reference.\n+        // The returned pointer is safe because impls of `SliceIndex` have to guarantee that it is.\n+        unsafe { &mut *(begin..end).get_unchecked_mut(self) }\n     }\n \n     /// Divide one string slice into two at an index.\n@@ -3158,11 +3156,11 @@ impl str {\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard Gepardi\";\n     ///\n     /// assert_eq!(s.find('L'), Some(0));\n     /// assert_eq!(s.find('\u00e9'), Some(14));\n-    /// assert_eq!(s.find(\"L\u00e9opard\"), Some(13));\n+    /// assert_eq!(s.find(\"pard\"), Some(17));\n     /// ```\n     ///\n     /// More complex patterns using point-free style and closures:\n@@ -3190,8 +3188,8 @@ impl str {\n         pat.into_searcher(self).next_match().map(|(i, _)| i)\n     }\n \n-    /// Returns the byte index of the last character of this string slice that\n-    /// matches the pattern.\n+    /// Returns the byte index for the first character of the rightmost match of the pattern in\n+    /// this string slice.\n     ///\n     /// Returns [`None`] if the pattern doesn't match.\n     ///\n@@ -3207,10 +3205,11 @@ impl str {\n     /// Simple patterns:\n     ///\n     /// ```\n-    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n+    /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard Gepardi\";\n     ///\n     /// assert_eq!(s.rfind('L'), Some(13));\n     /// assert_eq!(s.rfind('\u00e9'), Some(14));\n+    /// assert_eq!(s.rfind(\"pard\"), Some(24));\n     /// ```\n     ///\n     /// More complex patterns with closures:"}, {"sha": "60aa12b0511c73a5933fbe769a7aefe8bfc2dcf9", "filename": "src/librustc_error_codes/error_codes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_error_codes%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_error_codes%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -451,6 +451,7 @@ E0765: include_str!(\"./error_codes/E0765.md\"),\n E0766: include_str!(\"./error_codes/E0766.md\"),\n E0767: include_str!(\"./error_codes/E0767.md\"),\n E0768: include_str!(\"./error_codes/E0768.md\"),\n+E0769: include_str!(\"./error_codes/E0769.md\"),\n ;\n //  E0006, // merged with E0005\n //  E0008, // cannot bind by-move into a pattern guard"}, {"sha": "c22b274fb223e8e2b652e11188328fd5a056d85c", "filename": "src/librustc_error_codes/error_codes/E0704.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_error_codes%2Ferror_codes%2FE0704.md", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_error_codes%2Ferror_codes%2FE0704.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0704.md?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,6 +1,6 @@\n-This error indicates that a incorrect visibility restriction was specified.\n+An incorrect visibility restriction was specified.\n \n-Example of erroneous code:\n+Erroneous code example:\n \n ```compile_fail,E0704\n mod foo {\n@@ -12,6 +12,7 @@ mod foo {\n \n To make struct `Bar` only visible in module `foo` the `in` keyword should be\n used:\n+\n ```\n mod foo {\n     pub(in crate::foo) struct Bar {"}, {"sha": "d1995be9899b140a01686d1c7c386c8ce998454a", "filename": "src/librustc_error_codes/error_codes/E0769.md", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_error_codes%2Ferror_codes%2FE0769.md", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_error_codes%2Ferror_codes%2FE0769.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0769.md?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,39 @@\n+A tuple struct or tuple variant was used in a pattern as if it were a\n+struct or struct variant.\n+\n+Erroneous code example:\n+\n+```compile_fail,E0769\n+enum E {\n+    A(i32),\n+}\n+let e = E::A(42);\n+match e {\n+    E::A { number } => println!(\"{}\", x),\n+}\n+```\n+\n+To fix this error, you can use the tuple pattern:\n+\n+```\n+# enum E {\n+#     A(i32),\n+# }\n+# let e = E::A(42);\n+match e {\n+    E::A(number) => println!(\"{}\", number),\n+}\n+```\n+\n+Alternatively, you can also use the struct pattern by using the correct\n+field names and binding them to new identifiers:\n+\n+```\n+# enum E {\n+#     A(i32),\n+# }\n+# let e = E::A(42);\n+match e {\n+    E::A { 0: number } => println!(\"{}\", number),\n+}\n+```"}, {"sha": "00b23760182a229510d25480298bc0abd9ca292f", "filename": "src/librustc_index/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_index%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_index%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2FCargo.toml?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -11,4 +11,4 @@ doctest = false\n \n [dependencies]\n rustc_serialize = { path = \"../librustc_serialize\" }\n-smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }\n+arrayvec = \"0.5.1\""}, {"sha": "3e1d4b68c6fa104f1184d1908c8740009174ceaf", "filename": "src/librustc_index/bit_set.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_index%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_index%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_index%2Fbit_set.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,5 +1,5 @@\n use crate::vec::{Idx, IndexVec};\n-use smallvec::SmallVec;\n+use arrayvec::ArrayVec;\n use std::fmt;\n use std::iter;\n use std::marker::PhantomData;\n@@ -355,20 +355,19 @@ where\n const SPARSE_MAX: usize = 8;\n \n /// A fixed-size bitset type with a sparse representation and a maximum of\n-/// `SPARSE_MAX` elements. The elements are stored as a sorted `SmallVec` with\n-/// no duplicates; although `SmallVec` can spill its elements to the heap, that\n-/// never happens within this type because of the `SPARSE_MAX` limit.\n+/// `SPARSE_MAX` elements. The elements are stored as a sorted `ArrayVec` with\n+/// no duplicates.\n ///\n /// This type is used by `HybridBitSet`; do not use directly.\n #[derive(Clone, Debug)]\n pub struct SparseBitSet<T: Idx> {\n     domain_size: usize,\n-    elems: SmallVec<[T; SPARSE_MAX]>,\n+    elems: ArrayVec<[T; SPARSE_MAX]>,\n }\n \n impl<T: Idx> SparseBitSet<T> {\n     fn new_empty(domain_size: usize) -> Self {\n-        SparseBitSet { domain_size, elems: SmallVec::new() }\n+        SparseBitSet { domain_size, elems: ArrayVec::new() }\n     }\n \n     fn len(&self) -> usize {"}, {"sha": "82daae7d921b2a2b3c6a7060553a6e5f4315c3d7", "filename": "src/librustc_middle/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_middle%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_middle%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Flayout.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -774,12 +774,12 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     (present_variants.next(), present_variants.next())\n                 };\n                 let present_first = match present_first {\n-                    present_first @ Some(_) => present_first,\n+                    Some(present_first) => present_first,\n                     // Uninhabited because it has no variants, or only absent ones.\n                     None if def.is_enum() => return tcx.layout_raw(param_env.and(tcx.types.never)),\n                     // If it's a struct, still compute a layout so that we can still compute the\n                     // field offsets.\n-                    None => Some(VariantIdx::new(0)),\n+                    None => VariantIdx::new(0),\n                 };\n \n                 let is_struct = !def.is_enum() ||\n@@ -791,7 +791,7 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n                     // Struct, or univariant enum equivalent to a struct.\n                     // (Typechecking will reject discriminant-sizing attrs.)\n \n-                    let v = present_first.unwrap();\n+                    let v = present_first;\n                     let kind = if def.is_enum() || variants[v].is_empty() {\n                         StructKind::AlwaysSized\n                     } else {"}, {"sha": "6d929d1244789004f1512b4b3a89373be7fb7679", "filename": "src/librustc_target/spec/linux_kernel_base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_target%2Fspec%2Flinux_kernel_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_target%2Fspec%2Flinux_kernel_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Flinux_kernel_base.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -17,7 +17,6 @@ pub fn opts() -> TargetOptions {\n         needs_plt: true,\n         relro_level: RelroLevel::Full,\n         relocation_model: RelocModel::Static,\n-        target_family: Some(\"unix\".to_string()),\n         pre_link_args,\n \n         ..Default::default()"}, {"sha": "93b503c976be4c8706ecee600cf78d08cfefe1f1", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -18,6 +18,7 @@ rustc_attr = { path = \"../librustc_attr\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_hir = { path = \"../librustc_hir\" }\n+rustc_hir_pretty = { path = \"../librustc_hir_pretty\" }\n rustc_target = { path = \"../librustc_target\" }\n rustc_session = { path = \"../librustc_session\" }\n smallvec = { version = \"1.0\", features = [\"union\", \"may_dangle\"] }"}, {"sha": "7581940b6ac6912e0b5693af3fe8b771ad98bd88", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -3049,14 +3049,14 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let bare_fn_ty =\n             ty::Binder::bind(tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi));\n \n-        if let (false, Some(ident_span)) = (self.allow_ty_infer(), ident_span) {\n+        if !self.allow_ty_infer() {\n             // We always collect the spans for placeholder types when evaluating `fn`s, but we\n             // only want to emit an error complaining about them if infer types (`_`) are not\n             // allowed. `allow_ty_infer` gates this behavior. We check for the presence of\n             // `ident_span` to not emit an error twice when we have `fn foo(_: fn() -> _)`.\n             crate::collect::placeholder_type_error(\n                 tcx,\n-                ident_span.shrink_to_hi(),\n+                ident_span.map(|sp| sp.shrink_to_hi()),\n                 &generics.params[..],\n                 visitor.0,\n                 true,"}, {"sha": "8948e5a3e00db252ad7b5253e6a8a15c6079b351", "filename": "src/librustc_typeck/check/cast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcast.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -387,6 +387,7 @@ impl<'a, 'tcx> CastCheck<'tcx> {\n                             // Check for infer types because cases like `Option<{integer}>` would\n                             // panic otherwise.\n                             if !expr_ty.has_infer_types()\n+                                && !ty.has_infer_types()\n                                 && fcx.tcx.type_implements_trait((\n                                     from_trait,\n                                     ty,"}, {"sha": "a654fc3dfc2dffa8d47c6adc9d81dfb36b3e4a4e", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 78, "deletions": 13, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1082,20 +1082,23 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .filter(|ident| !used_fields.contains_key(&ident))\n             .collect::<Vec<_>>();\n \n-        if !inexistent_fields.is_empty() && !variant.recovered {\n-            self.error_inexistent_fields(\n+        let inexistent_fields_err = if !inexistent_fields.is_empty() && !variant.recovered {\n+            Some(self.error_inexistent_fields(\n                 adt.variant_descr(),\n                 &inexistent_fields,\n                 &mut unmentioned_fields,\n                 variant,\n-            );\n-        }\n+            ))\n+        } else {\n+            None\n+        };\n \n         // Require `..` if struct has non_exhaustive attribute.\n         if variant.is_field_list_non_exhaustive() && !adt.did.is_local() && !etc {\n             self.error_foreign_non_exhaustive_spat(pat, adt.variant_descr(), fields.is_empty());\n         }\n \n+        let mut unmentioned_err = None;\n         // Report an error if incorrect number of the fields were specified.\n         if adt.is_union() {\n             if fields.len() != 1 {\n@@ -1107,7 +1110,25 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 tcx.sess.struct_span_err(pat.span, \"`..` cannot be used in union patterns\").emit();\n             }\n         } else if !etc && !unmentioned_fields.is_empty() {\n-            self.error_unmentioned_fields(pat.span, &unmentioned_fields, variant);\n+            unmentioned_err = Some(self.error_unmentioned_fields(pat.span, &unmentioned_fields));\n+        }\n+        match (inexistent_fields_err, unmentioned_err) {\n+            (Some(mut i), Some(mut u)) => {\n+                if let Some(mut e) = self.error_tuple_variant_as_struct_pat(pat, fields, variant) {\n+                    // We don't want to show the inexistent fields error when this was\n+                    // `Foo { a, b }` when it should have been `Foo(a, b)`.\n+                    i.delay_as_bug();\n+                    u.delay_as_bug();\n+                    e.emit();\n+                } else {\n+                    i.emit();\n+                    u.emit();\n+                }\n+            }\n+            (None, Some(mut err)) | (Some(mut err), None) => {\n+                err.emit();\n+            }\n+            (None, None) => {}\n         }\n         no_field_errors\n     }\n@@ -1154,7 +1175,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         inexistent_fields: &[Ident],\n         unmentioned_fields: &mut Vec<Ident>,\n         variant: &ty::VariantDef,\n-    ) {\n+    ) -> DiagnosticBuilder<'tcx> {\n         let tcx = self.tcx;\n         let (field_names, t, plural) = if inexistent_fields.len() == 1 {\n             (format!(\"a field named `{}`\", inexistent_fields[0]), \"this\", \"\")\n@@ -1221,15 +1242,62 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     it explicitly.\",\n             );\n         }\n-        err.emit();\n+        err\n+    }\n+\n+    fn error_tuple_variant_as_struct_pat(\n+        &self,\n+        pat: &Pat<'_>,\n+        fields: &'tcx [hir::FieldPat<'tcx>],\n+        variant: &ty::VariantDef,\n+    ) -> Option<DiagnosticBuilder<'tcx>> {\n+        if let (CtorKind::Fn, PatKind::Struct(qpath, ..)) = (variant.ctor_kind, &pat.kind) {\n+            let path = rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                s.print_qpath(qpath, false)\n+            });\n+            let mut err = struct_span_err!(\n+                self.tcx.sess,\n+                pat.span,\n+                E0769,\n+                \"tuple variant `{}` written as struct variant\",\n+                path\n+            );\n+            let (sugg, appl) = if fields.len() == variant.fields.len() {\n+                (\n+                    fields\n+                        .iter()\n+                        .map(|f| match self.tcx.sess.source_map().span_to_snippet(f.pat.span) {\n+                            Ok(f) => f,\n+                            Err(_) => rustc_hir_pretty::to_string(rustc_hir_pretty::NO_ANN, |s| {\n+                                s.print_pat(f.pat)\n+                            }),\n+                        })\n+                        .collect::<Vec<String>>()\n+                        .join(\", \"),\n+                    Applicability::MachineApplicable,\n+                )\n+            } else {\n+                (\n+                    variant.fields.iter().map(|_| \"_\").collect::<Vec<&str>>().join(\", \"),\n+                    Applicability::MaybeIncorrect,\n+                )\n+            };\n+            err.span_suggestion(\n+                pat.span,\n+                \"use the tuple variant pattern syntax instead\",\n+                format!(\"{}({})\", path, sugg),\n+                appl,\n+            );\n+            return Some(err);\n+        }\n+        None\n     }\n \n     fn error_unmentioned_fields(\n         &self,\n         span: Span,\n         unmentioned_fields: &[Ident],\n-        variant: &ty::VariantDef,\n-    ) {\n+    ) -> DiagnosticBuilder<'tcx> {\n         let field_names = if unmentioned_fields.len() == 1 {\n             format!(\"field `{}`\", unmentioned_fields[0])\n         } else {\n@@ -1248,9 +1316,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             field_names\n         );\n         diag.span_label(span, format!(\"missing {}\", field_names));\n-        if variant.ctor_kind == CtorKind::Fn {\n-            diag.note(\"trying to match a tuple variant with a struct variant pattern\");\n-        }\n         if self.tcx.sess.teach(&diag.get_code().unwrap()) {\n             diag.note(\n                 \"This error indicates that a pattern for a struct fails to specify a \\\n@@ -1259,7 +1324,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     ignore unwanted fields.\",\n             );\n         }\n-        diag.emit();\n+        diag\n     }\n \n     fn check_pat_box("}, {"sha": "625b72091a6cc167307336d2969ae33e4ab24616", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -129,20 +129,23 @@ struct CollectItemTypesVisitor<'tcx> {\n /// all already existing generic type parameters to avoid suggesting a name that is already in use.\n crate fn placeholder_type_error(\n     tcx: TyCtxt<'tcx>,\n-    span: Span,\n+    span: Option<Span>,\n     generics: &[hir::GenericParam<'_>],\n     placeholder_types: Vec<Span>,\n     suggest: bool,\n ) {\n     if placeholder_types.is_empty() {\n         return;\n     }\n-    let type_name = generics.next_type_param_name(None);\n \n+    let type_name = generics.next_type_param_name(None);\n     let mut sugg: Vec<_> =\n         placeholder_types.iter().map(|sp| (*sp, (*type_name).to_string())).collect();\n+\n     if generics.is_empty() {\n-        sugg.push((span, format!(\"<{}>\", type_name)));\n+        if let Some(span) = span {\n+            sugg.push((span, format!(\"<{}>\", type_name)));\n+        }\n     } else if let Some(arg) = generics.iter().find(|arg| match arg.name {\n         hir::ParamName::Plain(Ident { name: kw::Underscore, .. }) => true,\n         _ => false,\n@@ -158,6 +161,7 @@ crate fn placeholder_type_error(\n             format!(\", {}\", type_name),\n         ));\n     }\n+\n     let mut err = bad_placeholder_type(tcx, placeholder_types);\n     if suggest {\n         err.multipart_suggestion(\n@@ -186,7 +190,7 @@ fn reject_placeholder_type_signatures_in_item(tcx: TyCtxt<'tcx>, item: &'tcx hir\n     let mut visitor = PlaceholderHirTyCollector::default();\n     visitor.visit_item(item);\n \n-    placeholder_type_error(tcx, generics.span, &generics.params[..], visitor.0, suggest);\n+    placeholder_type_error(tcx, Some(generics.span), &generics.params[..], visitor.0, suggest);\n }\n \n impl Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n@@ -722,7 +726,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::HirId) {\n             // Account for `const C: _;` and `type T = _;`.\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, DUMMY_SP, &[], visitor.0, false);\n+            placeholder_type_error(tcx, None, &[], visitor.0, false);\n         }\n \n         hir::TraitItemKind::Type(_, None) => {}\n@@ -745,7 +749,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::HirId) {\n             // Account for `type T = _;`\n             let mut visitor = PlaceholderHirTyCollector::default();\n             visitor.visit_impl_item(impl_item);\n-            placeholder_type_error(tcx, DUMMY_SP, &[], visitor.0, false);\n+            placeholder_type_error(tcx, None, &[], visitor.0, false);\n         }\n         hir::ImplItemKind::Const(..) => {}\n     }"}, {"sha": "39e33da44964e00ebe77497a411172b2a30a4afc", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -20,6 +20,7 @@ use crate::core::new_handler;\n use crate::externalfiles::ExternalHtml;\n use crate::html;\n use crate::html::markdown::IdMap;\n+use crate::html::render::StylePath;\n use crate::html::static_files;\n use crate::opts;\n use crate::passes::{self, Condition, DefaultPassOption};\n@@ -207,7 +208,7 @@ pub struct RenderOptions {\n     pub sort_modules_alphabetically: bool,\n     /// List of themes to extend the docs with. Original argument name is included to assist in\n     /// displaying errors if it fails a theme check.\n-    pub themes: Vec<PathBuf>,\n+    pub themes: Vec<StylePath>,\n     /// If present, CSS file that contains rules to add to the default CSS.\n     pub extension_css: Option<PathBuf>,\n     /// A map of crate names to the URL to use instead of querying the crate's `html_root_url`.\n@@ -410,7 +411,7 @@ impl Options {\n                     ))\n                     .emit();\n                 }\n-                themes.push(theme_file);\n+                themes.push(StylePath { path: theme_file, disabled: true });\n             }\n         }\n "}, {"sha": "cc6b38ebcdb7fb26b929b7485724add16d254f3c", "filename": "src/librustdoc/html/layout.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Flayout.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -3,7 +3,7 @@ use std::path::PathBuf;\n use crate::externalfiles::ExternalHtml;\n use crate::html::escape::Escape;\n use crate::html::format::{Buffer, Print};\n-use crate::html::render::ensure_trailing_slash;\n+use crate::html::render::{ensure_trailing_slash, StylePath};\n \n #[derive(Clone)]\n pub struct Layout {\n@@ -36,7 +36,7 @@ pub fn render<T: Print, S: Print>(\n     page: &Page<'_>,\n     sidebar: S,\n     t: T,\n-    themes: &[PathBuf],\n+    style_files: &[StylePath],\n ) -> String {\n     let static_root_path = page.static_root_path.unwrap_or(page.root_path);\n     format!(\n@@ -52,10 +52,7 @@ pub fn render<T: Print, S: Print>(\n     <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{static_root_path}normalize{suffix}.css\\\">\\\n     <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{static_root_path}rustdoc{suffix}.css\\\" \\\n           id=\\\"mainThemeStyle\\\">\\\n-    {themes}\\\n-    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{static_root_path}dark{suffix}.css\\\">\\\n-    <link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"{static_root_path}light{suffix}.css\\\" \\\n-          id=\\\"themeStyle\\\">\\\n+    {style_files}\\\n     <script src=\\\"{static_root_path}storage{suffix}.js\\\"></script>\\\n     <noscript><link rel=\\\"stylesheet\\\" href=\\\"{static_root_path}noscript{suffix}.css\\\"></noscript>\\\n     {css_extension}\\\n@@ -172,13 +169,19 @@ pub fn render<T: Print, S: Print>(\n         after_content = layout.external_html.after_content,\n         sidebar = Buffer::html().to_display(sidebar),\n         krate = layout.krate,\n-        themes = themes\n+        style_files = style_files\n             .iter()\n-            .filter_map(|t| t.file_stem())\n-            .filter_map(|t| t.to_str())\n+            .filter_map(|t| {\n+                if let Some(stem) = t.path.file_stem() { Some((stem, t.disabled)) } else { None }\n+            })\n+            .filter_map(|t| {\n+                if let Some(path) = t.0.to_str() { Some((path, t.1)) } else { None }\n+            })\n             .map(|t| format!(\n-                r#\"<link rel=\"stylesheet\" type=\"text/css\" href=\"{}.css\">\"#,\n-                Escape(&format!(\"{}{}{}\", static_root_path, t, page.resource_suffix))\n+                r#\"<link rel=\"stylesheet\" type=\"text/css\" href=\"{}.css\" {} {}>\"#,\n+                Escape(&format!(\"{}{}{}\", static_root_path, t.0, page.resource_suffix)),\n+                if t.1 { \"disabled\" } else { \"\" },\n+                if t.0 == \"light\" { \"id=\\\"themeStyle\\\"\" } else { \"\" }\n             ))\n             .collect::<String>(),\n         suffix = page.resource_suffix,"}, {"sha": "8fa581180ef60eaa9516981161ec8c0baa10f923", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 65, "deletions": 29, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -188,8 +188,8 @@ crate struct SharedContext {\n     /// This flag indicates whether listings of modules (in the side bar and documentation itself)\n     /// should be ordered alphabetically or in order of appearance (in the source code).\n     pub sort_modules_alphabetically: bool,\n-    /// Additional themes to be added to the generated docs.\n-    pub themes: Vec<PathBuf>,\n+    /// Additional CSS files to be added to the generated docs.\n+    pub style_files: Vec<StylePath>,\n     /// Suffix to be added on resource files (if suffix is \"-v2\" then \"light.css\" becomes\n     /// \"light-v2.css\").\n     pub resource_suffix: String,\n@@ -418,6 +418,14 @@ impl Serialize for TypeWithKind {\n     }\n }\n \n+#[derive(Debug, Clone)]\n+pub struct StylePath {\n+    /// The path to the theme\n+    pub path: PathBuf,\n+    /// What the `disabled` attribute should be set to in the HTML tag\n+    pub disabled: bool,\n+}\n+\n thread_local!(static CACHE_KEY: RefCell<Arc<Cache>> = Default::default());\n thread_local!(pub static CURRENT_DEPTH: Cell<usize> = Cell::new(0));\n \n@@ -461,7 +469,7 @@ pub fn run(\n         id_map,\n         playground_url,\n         sort_modules_alphabetically,\n-        themes,\n+        themes: style_files,\n         extension_css,\n         extern_html_root_urls,\n         resource_suffix,\n@@ -531,7 +539,7 @@ pub fn run(\n         layout,\n         created_dirs: Default::default(),\n         sort_modules_alphabetically,\n-        themes,\n+        style_files,\n         resource_suffix,\n         static_root_path,\n         fs: DocFS::new(&errors),\n@@ -540,6 +548,19 @@ pub fn run(\n         playground,\n     };\n \n+    // Add the default themes to the `Vec` of stylepaths\n+    //\n+    // Note that these must be added before `sources::render` is called\n+    // so that the resulting source pages are styled\n+    //\n+    // `light.css` is not disabled because it is the stylesheet that stays loaded\n+    // by the browser as the theme stylesheet. The theme system (hackily) works by\n+    // changing the href to this stylesheet. All other themes are disabled to\n+    // prevent rule conflicts\n+    scx.style_files.push(StylePath { path: PathBuf::from(\"light.css\"), disabled: false });\n+    scx.style_files.push(StylePath { path: PathBuf::from(\"dark.css\"), disabled: true });\n+    scx.style_files.push(StylePath { path: PathBuf::from(\"ayu.css\"), disabled: true });\n+\n     let dst = output;\n     scx.ensure_dir(&dst)?;\n     krate = sources::render(&dst, &mut scx, krate)?;\n@@ -616,11 +637,40 @@ fn write_shared(\n     // then we'll run over the \"official\" styles.\n     let mut themes: FxHashSet<String> = FxHashSet::default();\n \n-    for entry in &cx.shared.themes {\n-        let content = try_err!(fs::read(&entry), &entry);\n-        let theme = try_none!(try_none!(entry.file_stem(), &entry).to_str(), &entry);\n-        let extension = try_none!(try_none!(entry.extension(), &entry).to_str(), &entry);\n-        cx.shared.fs.write(cx.path(&format!(\"{}.{}\", theme, extension)), content.as_slice())?;\n+    for entry in &cx.shared.style_files {\n+        let theme = try_none!(try_none!(entry.path.file_stem(), &entry.path).to_str(), &entry.path);\n+        let extension =\n+            try_none!(try_none!(entry.path.extension(), &entry.path).to_str(), &entry.path);\n+\n+        // Handle the official themes\n+        match theme {\n+            \"light\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"light.css\"),\n+                static_files::themes::LIGHT,\n+                options.enable_minification,\n+            )?,\n+            \"dark\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"dark.css\"),\n+                static_files::themes::DARK,\n+                options.enable_minification,\n+            )?,\n+            \"ayu\" => write_minify(\n+                &cx.shared.fs,\n+                cx.path(\"ayu.css\"),\n+                static_files::themes::AYU,\n+                options.enable_minification,\n+            )?,\n+            _ => {\n+                // Handle added third-party themes\n+                let content = try_err!(fs::read(&entry.path), &entry.path);\n+                cx.shared\n+                    .fs\n+                    .write(cx.path(&format!(\"{}.{}\", theme, extension)), content.as_slice())?;\n+            }\n+        };\n+\n         themes.insert(theme.to_owned());\n     }\n \n@@ -634,20 +684,6 @@ fn write_shared(\n     write(cx.path(\"brush.svg\"), static_files::BRUSH_SVG)?;\n     write(cx.path(\"wheel.svg\"), static_files::WHEEL_SVG)?;\n     write(cx.path(\"down-arrow.svg\"), static_files::DOWN_ARROW_SVG)?;\n-    write_minify(\n-        &cx.shared.fs,\n-        cx.path(\"light.css\"),\n-        static_files::themes::LIGHT,\n-        options.enable_minification,\n-    )?;\n-    themes.insert(\"light\".to_owned());\n-    write_minify(\n-        &cx.shared.fs,\n-        cx.path(\"dark.css\"),\n-        static_files::themes::DARK,\n-        options.enable_minification,\n-    )?;\n-    themes.insert(\"dark\".to_owned());\n \n     let mut themes: Vec<&String> = themes.iter().collect();\n     themes.sort();\n@@ -958,7 +994,7 @@ themePicker.onblur = handleThemeButtonsBlur;\n                     })\n                     .collect::<String>()\n             );\n-            let v = layout::render(&cx.shared.layout, &page, \"\", content, &cx.shared.themes);\n+            let v = layout::render(&cx.shared.layout, &page, \"\", content, &cx.shared.style_files);\n             cx.shared.fs.write(&dst, v.as_bytes())?;\n         }\n     }\n@@ -1376,7 +1412,7 @@ impl Context {\n             &page,\n             sidebar,\n             |buf: &mut Buffer| all.print(buf),\n-            &self.shared.themes,\n+            &self.shared.style_files,\n         );\n         self.shared.fs.write(&final_file, v.as_bytes())?;\n \n@@ -1385,9 +1421,9 @@ impl Context {\n         page.description = \"Settings of Rustdoc\";\n         page.root_path = \"./\";\n \n-        let mut themes = self.shared.themes.clone();\n+        let mut style_files = self.shared.style_files.clone();\n         let sidebar = \"<p class='location'>Settings</p><div class='sidebar-elems'></div>\";\n-        themes.push(PathBuf::from(\"settings.css\"));\n+        style_files.push(StylePath { path: PathBuf::from(\"settings.css\"), disabled: false });\n         let v = layout::render(\n             &self.shared.layout,\n             &page,\n@@ -1396,7 +1432,7 @@ impl Context {\n                 self.shared.static_root_path.as_deref().unwrap_or(\"./\"),\n                 &self.shared.resource_suffix,\n             ),\n-            &themes,\n+            &style_files,\n         );\n         self.shared.fs.write(&settings_file, v.as_bytes())?;\n \n@@ -1458,7 +1494,7 @@ impl Context {\n                 &page,\n                 |buf: &mut _| print_sidebar(self, it, buf),\n                 |buf: &mut _| print_item(self, it, buf),\n-                &self.shared.themes,\n+                &self.shared.style_files,\n             )\n         } else {\n             let mut url = self.root_path();"}, {"sha": "03f79b931868b547fefb899dd4a6afa81ecb1a0f", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -123,7 +123,7 @@ impl<'a> SourceCollector<'a> {\n             &page,\n             \"\",\n             |buf: &mut _| print_src(buf, &contents),\n-            &self.scx.themes,\n+            &self.scx.style_files,\n         );\n         self.scx.fs.write(&cur, v.as_bytes())?;\n         self.scx.local_sources.insert(p, href);"}, {"sha": "bc21c28750fd86ed2bcfbb160bda3bf6edfd5b91", "filename": "src/librustdoc/html/static/themes/ayu.css", "status": "added", "additions": 561, "deletions": 0, "changes": 561, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fthemes%2Fayu.css?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,561 @@\n+/*\n+Based off of the Ayu theme\n+Original by Dempfi (https://github.com/dempfi/ayu)\n+*/\n+\n+/* General structure and fonts */\n+\n+body {\n+\tbackground-color: #0f1419;\n+\tcolor: #c5c5c5;\n+}\n+\n+h1, h2, h3:not(.impl):not(.method):not(.type):not(.tymethod), h4:not(.method):not(.type):not(.tymethod) {\n+\tcolor: white;\n+}\n+h1.fqn {\n+\tborder-bottom-color: #5c6773;\n+}\n+h1.fqn  a {\n+\tcolor: #fff;\n+}\n+h2, h3:not(.impl):not(.method):not(.type):not(.tymethod) {\n+\tborder-bottom-color: #5c6773;\n+}\n+h4:not(.method):not(.type):not(.tymethod):not(.associatedconstant) {\n+\tborder: none;\n+}\n+\n+.in-band {\n+\tbackground-color: #0f1419;\n+}\n+\n+.invisible {\n+\tbackground: rgba(0, 0, 0, 0);\n+}\n+\n+code {\n+\tcolor: #ffb454;\n+}\n+h3 > code, h4 > code, h5 > code {\n+\tcolor: #e6e1cf;\n+}\n+pre > code {\n+    color: #e6e1cf; \n+}\n+span code {\n+    color: #e6e1cf;\n+}\n+.docblock a > code {\n+    color: #39AFD7 !important;\n+}\n+.docblock code, .docblock-short code {\n+\tbackground-color: #191f26;\n+}\n+pre {\n+\tcolor: #e6e1cf;\n+\tbackground-color: #191f26;\n+}\n+\n+.sidebar {\n+\tbackground-color: #14191f;\n+}\n+\n+/* Improve the scrollbar display on firefox */\n+* {\n+\tscrollbar-color: #5c6773 transparent;\n+}\n+\n+.sidebar {\n+\tscrollbar-color: #5c6773 transparent;\n+}\n+\n+/* Improve the scrollbar display on webkit-based browsers */\n+::-webkit-scrollbar-track {\n+\tbackground-color: transparent;\n+}\n+::-webkit-scrollbar-thumb {\n+\tbackground-color: #5c6773;\n+}\n+.sidebar::-webkit-scrollbar-track {\n+\tbackground-color: transparent;\n+}\n+.sidebar::-webkit-scrollbar-thumb {\n+\tbackground-color: #5c6773;\n+}\n+\n+.sidebar .current {\n+\tbackground-color: transparent;\n+\tcolor: #ffb44c;\n+}\n+\n+.source .sidebar {\n+\tbackground-color: #0f1419;\n+}\n+\n+.sidebar .location {\n+\tborder-color: #000;\n+\tbackground-color: #0f1419;\n+\tcolor: #fff;\n+}\n+\n+.sidebar-elems .location {\n+    color: #ff7733;\n+}\n+\n+.sidebar-elems .location a {\n+    color: #fff;\n+}\n+\n+.sidebar .version {\n+\tborder-bottom-color: #DDD;\n+}\n+\n+.sidebar-title {\n+\tborder-top-color: #5c6773;\n+\tborder-bottom-color: #5c6773;\n+}\n+\n+.block a:hover {\n+\tbackground: transparent;\n+\tcolor: #ffb44c;\n+}\n+\n+.line-numbers span { color: #5c6773ab; }\n+.line-numbers .line-highlighted {\n+    background-color: rgba(255, 236, 164, 0.06) !important;\n+    padding-right: 4px;\n+    border-right: 1px solid #ffb44c;\n+}\n+\n+.docblock h1, .docblock h2, .docblock h3, .docblock h4, .docblock h5 {\n+\tborder-bottom-color: #5c6773;\n+}\n+\n+.docblock table, .docblock table td, .docblock table th {\n+\tborder-color: #5c6773;\n+}\n+\n+.content .method .where,\n+.content .fn .where,\n+.content .where.fmt-newline {\n+\tcolor: #c5c5c5;\n+}\n+\n+.content .highlighted {\n+\tcolor: #000 !important;\n+\tbackground-color: #c6afb3;\n+}\n+.content .highlighted a, .content .highlighted span { color: #000 !important; }\n+.content .highlighted {\n+\tbackground-color: #c6afb3;\n+}\n+.search-results a {\n+\tcolor: #0096cf;\n+}\n+.search-results a span.desc {\n+\tcolor: #c5c5c5;\n+}\n+\n+.content .stability::before { color: #ccc; }\n+\n+.content span.foreigntype, .content a.foreigntype { color: #ef57ff; }\n+.content span.union, .content a.union { color: #98a01c; }\n+.content span.constant, .content a.constant,\n+.content span.static, .content a.static { color: #6380a0; }\n+.content span.primitive, .content a.primitive { color: #32889b; }\n+.content span.traitalias, .content a.traitalias { color: #57d399; }\n+.content span.keyword, .content a.keyword { color: #de5249; }\n+\n+.content span.externcrate, .content span.mod, .content a.mod {\n+    color: #acccf9;\n+}\n+.content span.struct, .content a.struct {\n+    color: #ffa0a5;\n+}\n+.content span.enum, .content a.enum {\n+    color: #99e0c9;\n+}\n+.content span.trait, .content a.trait {\n+    color: #39AFD7;\n+}\n+.content span.type, .content a.type {\n+    color: #cfbcf5;\n+}\n+.content span.fn, .content a.fn, .content span.method,\n+.content a.method, .content span.tymethod,\n+.content a.tymethod, .content .fnname {\n+    color: #fdd687;\n+}\n+.content span.attr, .content a.attr, .content span.derive,\n+.content a.derive, .content span.macro, .content a.macro {\n+    color: #a37acc;\n+}\n+\n+pre.rust .comment, pre.rust .doccomment { \n+\tcolor: #788797;\n+\tfont-style: italic;\n+}\n+\n+nav:not(.sidebar) {\n+\tborder-bottom-color: #e0e0e0;\n+}\n+nav.main .current {\n+\tborder-top-color: #5c6773;\n+\tborder-bottom-color: #5c6773;\n+}\n+nav.main .separator {\n+\tborder: 1px solid #5c6773;\n+}\n+a {\n+\tcolor: #c5c5c5;\n+}\n+\n+.docblock:not(.type-decl) a:not(.srclink):not(.test-arrow),\n+.docblock-short a:not(.srclink):not(.test-arrow), .stability a {\n+\tcolor: #39AFD7;\n+}\n+\n+.stab.internal a {\n+\tcolor: #304FFE;\n+}\n+\n+.collapse-toggle {\n+\tcolor: #999;\n+}\n+\n+#crate-search {\n+\tcolor: #c5c5c5;\n+\tbackground-color: #141920;\n+\tborder-radius: 4px;\n+\tbox-shadow: none;\n+\tborder-color: #5c6773;\n+}\n+\n+.search-input {\n+    color: #ffffff;\n+    background-color: #141920;\n+    box-shadow: none;\n+    transition: box-shadow 150ms ease-in-out;\n+    border-radius: 4px;\n+    margin-left: 8px;\n+}\n+\n+#crate-search+.search-input:focus {\n+    box-shadow: 0px 6px 20px 0px black;\n+}\n+\n+.search-focus:disabled {\n+\tcolor: #929292;\n+}\n+\n+.module-item .stab {\n+\tcolor: #000;\n+}\n+\n+.stab.unstable,\n+.stab.internal,\n+.stab.deprecated,\n+.stab.portability {\n+    color: #c5c5c5;\n+\tbackground: #314559 !important;\n+\tborder-style: none !important;\n+\tborder-radius: 4px;\n+\tpadding: 3px 6px 3px 6px;\n+}\n+\n+.stab.portability > code {\n+\tcolor: #e6e1cf;\n+\tbackground-color: transparent;\n+}\n+\n+#help > div {\n+    background: #14191f;\n+    box-shadow: 0px 6px 20px 0px black;\n+    border: none;\n+    border-radius: 4px;\n+}\n+\n+.since {\n+\tcolor: grey;\n+}\n+\n+tr.result span.primitive::after, tr.result span.keyword::after {\n+\tcolor: #788797;\n+}\n+\n+.line-numbers :target { background-color: transparent; }\n+\n+/* Code highlighting */\n+pre.rust .number, pre.rust .string { color: #b8cc52; }\n+pre.rust .kw, pre.rust .kw-2, pre.rust .prelude-ty,\n+pre.rust .bool-val, pre.rust .prelude-val,\n+pre.rust .op, pre.rust .lifetime { color: #ff7733; }\n+pre.rust .macro, pre.rust .macro-nonterminal { color: #a37acc; }\n+pre.rust .question-mark {\n+\tcolor: #ff9011;\n+}\n+pre.rust .self {\n+    color: #36a3d9;\n+    font-style: italic;\n+}\n+pre.rust .attribute {\n+    color: #e6e1cf;\n+}\n+pre.rust .attribute .ident, pre.rust .attribute .op {\n+    color: #e6e1cf;\n+}\n+\n+.example-wrap > pre.line-number {\n+\tcolor: #5c67736e;\n+\tborder: none;\n+}\n+\n+a.test-arrow {\n+    font-size: 100%;\n+    color: #788797;\n+    border-radius: 4px;\n+    background-color: rgba(255, 255, 255, 0);\n+}\n+\n+a.test-arrow:hover {\n+    background-color: rgba(242, 151, 24, 0.05);\n+    color: #ffb44c;\n+}\n+\n+.toggle-label {\n+\tcolor: #999;\n+}\n+\n+:target > code, :target > .in-band {\n+\tbackground: rgba(255, 236, 164, 0.06);\n+\tborder-right: 3px solid #ffb44c;\n+}\n+\n+pre.compile_fail {\n+\tborder-left: 2px solid rgba(255,0,0,.4);\n+}\n+\n+pre.compile_fail:hover, .information:hover + pre.compile_fail {\n+\tborder-left: 2px solid #f00;\n+}\n+\n+pre.should_panic {\n+\tborder-left: 2px solid rgba(255,0,0,.4);\n+}\n+\n+pre.should_panic:hover, .information:hover + pre.should_panic {\n+\tborder-left: 2px solid #f00;\n+}\n+\n+pre.ignore {\n+\tborder-left: 2px solid rgba(255,142,0,.6);\n+}\n+\n+pre.ignore:hover, .information:hover + pre.ignore {\n+\tborder-left: 2px solid #ff9200;\n+}\n+\n+.tooltip.compile_fail {\n+\tcolor: rgba(255,0,0,.5);\n+}\n+\n+.information > .compile_fail:hover {\n+\tcolor: #f00;\n+}\n+\n+.tooltip.should_panic {\n+\tcolor: rgba(255,0,0,.5);\n+}\n+\n+.information > .should_panic:hover {\n+\tcolor: #f00;\n+}\n+\n+.tooltip.ignore {\n+\tcolor: rgba(255,142,0,.6);\n+}\n+\n+.information > .ignore:hover {\n+\tcolor: #ff9200;\n+}\n+\n+.search-failed a {\n+\tcolor: #39AFD7;\n+}\n+\n+.tooltip .tooltiptext {\n+    background-color: #314559;\n+    color: #c5c5c5;\n+    border: 1px solid #5c6773;\n+}\n+\n+.tooltip .tooltiptext::after {\n+\tborder-color: transparent #314559 transparent transparent;\n+}\n+\n+#titles > div.selected {\n+    background-color: #141920 !important;\n+\tborder-bottom: 1px solid #ffb44c !important;\n+\tborder-top: none;\n+}\n+\n+#titles > div:not(.selected) {\n+\tbackground-color: transparent !important;\n+\tborder: none;\n+}\n+\n+#titles > div:hover {\n+    border-bottom: 1px solid rgba(242, 151, 24, 0.3);\n+}\n+\n+#titles > div > div.count {\n+\tcolor: #888;\n+}\n+\n+/* rules that this theme does not need to set, here to satisfy the rule checker */\n+/* note that a lot of these are partially set in some way (meaning they are set\n+individually rather than as a group) */\n+/* TODO: these rules should be at the bottom of the file but currently must be\n+above the `@media (max-width: 700px)` rules due to a bug in the css checker */\n+/* see https://github.com/rust-lang/rust/pull/71237#issuecomment-618170143 */\n+.content .highlighted.mod, .content .highlighted.externcrate {}\n+.search-input:focus {}\n+.content span.attr,.content a.attr,.block a.current.attr,.content span.derive,.content a.derive,.block a.current.derive,.content span.macro,.content a.macro,.block a.current.macro {}\n+.content .highlighted.trait {}\n+.content span.struct,.content a.struct,.block a.current.struct {}\n+#titles>div:hover,#titles>div.selected {}\n+.content .highlighted.traitalias {}\n+.content span.type,.content a.type,.block a.current.type {}\n+.content span.union,.content a.union,.block a.current.union {}\n+.content .highlighted.foreigntype {}\n+pre.rust .lifetime {}\n+.content .highlighted.primitive {}\n+.content .highlighted.constant,.content .highlighted.static {}\n+.stab.unstable {}\n+.content .highlighted.fn,.content .highlighted.method,.content .highlighted.tymethod {}\n+h2,h3:not(.impl):not(.method):not(.type):not(.tymethod),h4:not(.method):not(.type):not(.tymethod) {}\n+.content span.enum,.content a.enum,.block a.current.enum {}\n+.content span.constant,.content a.constant,.block a.current.constant,.content span.static,.content a.static,.block a.current.static {}\n+.content span.keyword,.content a.keyword,.block a.current.keyword {}\n+pre.rust .comment {}\n+.content .highlighted.enum {}\n+.content .highlighted.struct {}\n+.content .highlighted.keyword {}\n+.content span.traitalias,.content a.traitalias,.block a.current.traitalias {}\n+.content span.fn,.content a.fn,.block a.current.fn,.content span.method,.content a.method,.block a.current.method,.content span.tymethod,.content a.tymethod,.block a.current.tymethod,.content .fnname {}\n+pre.rust .kw {}\n+pre.rust .self,pre.rust .bool-val,pre.rust .prelude-val,pre.rust .attribute,pre.rust .attribute .ident {}\n+.content span.foreigntype,.content a.foreigntype,.block a.current.foreigntype {}\n+pre.rust .doccomment {}\n+.stab.deprecated {}\n+.content .highlighted.attr,.content .highlighted.derive,.content .highlighted.macro {}\n+.stab.portability {}\n+.content .highlighted.union {}\n+.content span.primitive,.content a.primitive,.block a.current.primitive {}\n+.content span.externcrate,.content span.mod,.content a.mod,.block a.current.mod {}\n+.content .highlighted.type {}\n+pre.rust .kw-2,pre.rust .prelude-ty {}\n+.content span.trait,.content a.trait,.block a.current.trait {}\n+.stab.internal {}\n+\n+@media (max-width: 700px) {\n+\t.sidebar-menu {\n+\t\tbackground-color: #14191f;\n+\t\tborder-bottom-color: #5c6773;\n+\t\tborder-right-color: #5c6773;\n+\t}\n+\n+\t.sidebar-elems {\n+\t\tbackground-color: #14191f;\n+\t\tborder-right-color: #5c6773;\n+\t}\n+\n+\t#sidebar-filler {\n+\t\tbackground-color: #14191f;\n+\t\tborder-bottom-color: #5c6773;\n+\t}\n+}\n+\n+kbd {\n+\tcolor: #c5c5c5;\n+\tbackground-color: #314559;\n+\tborder-color: #5c6773;\n+\tborder-bottom-color: #5c6773;\n+\tbox-shadow-color: #c6cbd1;\n+}\n+\n+#theme-picker, #settings-menu {\n+\tborder-color: #5c6773;\n+    background-color: #0f1419;\n+}\n+\n+#theme-picker > img, #settings-menu > img {\n+    filter: invert(100);\n+}\n+\n+#theme-picker:hover, #theme-picker:focus,\n+#settings-menu:hover, #settings-menu:focus {\n+\tborder-color: #e0e0e0;\n+}\n+\n+#theme-choices {\n+\tborder-color: #5c6773;\n+\tbackground-color: #0f1419;\n+}\n+\n+#theme-choices > button:not(:first-child) {\n+\tborder-top-color: #c5c5c5;\n+}\n+\n+#theme-choices > button:hover, #theme-choices > button:focus {\n+\tbackground-color: rgba(70, 70, 70, 0.33);\n+}\n+\n+@media (max-width: 700px) {\n+\t#theme-picker {\n+\t\tbackground: #0f1419;\n+\t}\n+}\n+\n+#all-types {\n+\tbackground-color: #14191f;\n+}\n+#all-types:hover {\n+\tbackground-color: rgba(70, 70, 70, 0.33);\n+}\n+\n+.search-results td span.alias {\n+\tcolor: #c5c5c5;\n+}\n+.search-results td span.grey {\n+\tcolor: #999;\n+}\n+\n+#sidebar-toggle {\n+\tbackground-color: #14191f;\n+}\n+#sidebar-toggle:hover {\n+\tbackground-color: rgba(70, 70, 70, 0.33);\n+}\n+#source-sidebar {\n+\tbackground-color: #14191f;\n+}\n+#source-sidebar > .title {\n+\tcolor: #fff;\n+\tborder-bottom-color: #5c6773;\n+}\n+div.files > a:hover, div.name:hover {\n+\tbackground-color: #14191f;\n+\tcolor: #ffb44c;\n+}\n+div.files > .selected {\n+\tbackground-color: #14191f;\n+\tcolor: #ffb44c;\n+}\n+.setting-line > .title {\n+\tborder-bottom-color: #5c6773;\n+}\n+input:checked + .slider {\n+\tbackground-color: #ffb454 !important;\n+}"}, {"sha": "6bd7e53cdfbe23acfc2e80fe7e41a72361b6e40b", "filename": "src/librustdoc/html/static_files.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic_files.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -64,6 +64,9 @@ pub mod themes {\n \n     /// The \"dark\" theme.\n     pub static DARK: &str = include_str!(\"static/themes/dark.css\");\n+\n+    /// The \"ayu\" theme.\n+    pub static AYU: &str = include_str!(\"static/themes/ayu.css\");\n }\n \n /// Files related to the Fira Sans font."}, {"sha": "5215db7cdb3ce8d43217ab583443560f0fdde99e", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -242,8 +242,8 @@\n #![feature(atomic_mut_ptr)]\n #![feature(box_syntax)]\n #![feature(c_variadic)]\n-#![feature(cfg_accessible)]\n #![feature(can_vector)]\n+#![feature(cfg_accessible)]\n #![feature(cfg_target_has_atomic)]\n #![feature(cfg_target_thread_local)]\n #![feature(char_error_internals)]\n@@ -276,8 +276,8 @@\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]\n #![feature(int_error_matching)]\n-#![feature(into_future)]\n #![feature(integer_atomics)]\n+#![feature(into_future)]\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(link_args)]\n@@ -286,6 +286,7 @@\n #![feature(log_syntax)]\n #![feature(maybe_uninit_ref)]\n #![feature(maybe_uninit_slice)]\n+#![feature(min_specialization)]\n #![feature(needs_panic_runtime)]\n #![feature(negative_impls)]\n #![feature(never_type)]\n@@ -305,7 +306,7 @@\n #![feature(shrink_to)]\n #![feature(slice_concat_ext)]\n #![feature(slice_internals)]\n-#![feature(min_specialization)]\n+#![feature(slice_strip)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n #![feature(stdsimd)]"}, {"sha": "b0693b63a48fd19c3b863edd53daa79a7de9d438", "filename": "src/libstd/sys/sgx/abi/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fsgx%2Fabi%2Fmod.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -17,6 +17,9 @@ pub mod usercalls;\n #[cfg(not(test))]\n global_asm!(include_str!(\"entry.S\"));\n \n+#[repr(C)]\n+struct EntryReturn(u64, u64);\n+\n #[cfg(not(test))]\n #[no_mangle]\n unsafe extern \"C\" fn tcs_init(secondary: bool) {\n@@ -56,16 +59,15 @@ unsafe extern \"C\" fn tcs_init(secondary: bool) {\n // able to specify this\n #[cfg(not(test))]\n #[no_mangle]\n-#[allow(improper_ctypes_definitions)]\n-extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> (u64, u64) {\n+extern \"C\" fn entry(p1: u64, p2: u64, p3: u64, secondary: bool, p4: u64, p5: u64) -> EntryReturn {\n     // FIXME: how to support TLS in library mode?\n     let tls = Box::new(tls::Tls::new());\n     let _tls_guard = unsafe { tls.activate() };\n \n     if secondary {\n         super::thread::Thread::entry();\n \n-        (0, 0)\n+        EntryReturn(0, 0)\n     } else {\n         extern \"C\" {\n             fn main(argc: isize, argv: *const *const u8) -> isize;"}, {"sha": "dda3ed68cfc95aac651c2d65f27ecf6abf77a68f", "filename": "src/libstd/sys/windows/path.rs", "status": "modified", "additions": 76, "deletions": 63, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,6 +2,16 @@ use crate::ffi::OsStr;\n use crate::mem;\n use crate::path::Prefix;\n \n+#[cfg(test)]\n+mod tests;\n+\n+pub const MAIN_SEP_STR: &str = \"\\\\\";\n+pub const MAIN_SEP: char = '\\\\';\n+\n+// The unsafety here stems from converting between `&OsStr` and `&[u8]`\n+// and back. This is safe to do because (1) we only look at ASCII\n+// contents of the encoding and (2) new &OsStr values are produced\n+// only from ASCII-bounded slices of existing &OsStr values.\n fn os_str_as_u8_slice(s: &OsStr) -> &[u8] {\n     unsafe { mem::transmute(s) }\n }\n@@ -19,76 +29,79 @@ pub fn is_verbatim_sep(b: u8) -> bool {\n     b == b'\\\\'\n }\n \n+// In most DOS systems, it is not possible to have more than 26 drive letters.\n+// See <https://en.wikipedia.org/wiki/Drive_letter_assignment#Common_assignments>.\n+pub fn is_valid_drive_letter(disk: u8) -> bool {\n+    disk.is_ascii_alphabetic()\n+}\n+\n pub fn parse_prefix(path: &OsStr) -> Option<Prefix<'_>> {\n-    use crate::path::Prefix::*;\n-    unsafe {\n-        // The unsafety here stems from converting between &OsStr and &[u8]\n-        // and back. This is safe to do because (1) we only look at ASCII\n-        // contents of the encoding and (2) new &OsStr values are produced\n-        // only from ASCII-bounded slices of existing &OsStr values.\n-        let mut path = os_str_as_u8_slice(path);\n+    use Prefix::{DeviceNS, Disk, Verbatim, VerbatimDisk, VerbatimUNC, UNC};\n+\n+    let path = os_str_as_u8_slice(path);\n \n-        if path.starts_with(br\"\\\\\") {\n-            // \\\\\n-            path = &path[2..];\n-            if path.starts_with(br\"?\\\") {\n-                // \\\\?\\\n-                path = &path[2..];\n-                if path.starts_with(br\"UNC\\\") {\n-                    // \\\\?\\UNC\\server\\share\n-                    path = &path[4..];\n-                    let (server, share) = match parse_two_comps(path, is_verbatim_sep) {\n-                        Some((server, share)) => {\n-                            (u8_slice_as_os_str(server), u8_slice_as_os_str(share))\n-                        }\n-                        None => (u8_slice_as_os_str(path), u8_slice_as_os_str(&[])),\n-                    };\n-                    return Some(VerbatimUNC(server, share));\n-                } else {\n-                    // \\\\?\\path\n-                    let idx = path.iter().position(|&b| b == b'\\\\');\n-                    if idx == Some(2) && path[1] == b':' {\n-                        let c = path[0];\n-                        if c.is_ascii() && (c as char).is_alphabetic() {\n-                            // \\\\?\\C:\\ path\n-                            return Some(VerbatimDisk(c.to_ascii_uppercase()));\n-                        }\n+    // \\\\\n+    if let Some(path) = path.strip_prefix(br\"\\\\\") {\n+        // \\\\?\\\n+        if let Some(path) = path.strip_prefix(br\"?\\\") {\n+            // \\\\?\\UNC\\server\\share\n+            if let Some(path) = path.strip_prefix(br\"UNC\\\") {\n+                let (server, share) = match get_first_two_components(path, is_verbatim_sep) {\n+                    Some((server, share)) => unsafe {\n+                        (u8_slice_as_os_str(server), u8_slice_as_os_str(share))\n+                    },\n+                    None => (unsafe { u8_slice_as_os_str(path) }, OsStr::new(\"\")),\n+                };\n+                return Some(VerbatimUNC(server, share));\n+            } else {\n+                // \\\\?\\path\n+                match path {\n+                    // \\\\?\\C:\\path\n+                    [c, b':', b'\\\\', ..] if is_valid_drive_letter(*c) => {\n+                        return Some(VerbatimDisk(c.to_ascii_uppercase()));\n+                    }\n+                    // \\\\?\\cat_pics\n+                    _ => {\n+                        let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n+                        let slice = &path[..idx];\n+                        return Some(Verbatim(unsafe { u8_slice_as_os_str(slice) }));\n                     }\n-                    let slice = &path[..idx.unwrap_or(path.len())];\n-                    return Some(Verbatim(u8_slice_as_os_str(slice)));\n-                }\n-            } else if path.starts_with(b\".\\\\\") {\n-                // \\\\.\\path\n-                path = &path[2..];\n-                let pos = path.iter().position(|&b| b == b'\\\\');\n-                let slice = &path[..pos.unwrap_or(path.len())];\n-                return Some(DeviceNS(u8_slice_as_os_str(slice)));\n-            }\n-            match parse_two_comps(path, is_sep_byte) {\n-                Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n-                    // \\\\server\\share\n-                    return Some(UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)));\n                 }\n-                _ => (),\n             }\n-        } else if path.get(1) == Some(&b':') {\n-            // C:\n-            let c = path[0];\n-            if c.is_ascii() && (c as char).is_alphabetic() {\n-                return Some(Disk(c.to_ascii_uppercase()));\n+        } else if let Some(path) = path.strip_prefix(b\".\\\\\") {\n+            // \\\\.\\COM42\n+            let idx = path.iter().position(|&b| b == b'\\\\').unwrap_or(path.len());\n+            let slice = &path[..idx];\n+            return Some(DeviceNS(unsafe { u8_slice_as_os_str(slice) }));\n+        }\n+        match get_first_two_components(path, is_sep_byte) {\n+            Some((server, share)) if !server.is_empty() && !share.is_empty() => {\n+                // \\\\server\\share\n+                return Some(unsafe { UNC(u8_slice_as_os_str(server), u8_slice_as_os_str(share)) });\n             }\n+            _ => {}\n+        }\n+    } else if let [c, b':', ..] = path {\n+        // C:\n+        if is_valid_drive_letter(*c) {\n+            return Some(Disk(c.to_ascii_uppercase()));\n         }\n-        return None;\n-    }\n-\n-    fn parse_two_comps(mut path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n-        let first = &path[..path.iter().position(|x| f(*x))?];\n-        path = &path[(first.len() + 1)..];\n-        let idx = path.iter().position(|x| f(*x));\n-        let second = &path[..idx.unwrap_or(path.len())];\n-        Some((first, second))\n     }\n+    None\n }\n \n-pub const MAIN_SEP_STR: &str = \"\\\\\";\n-pub const MAIN_SEP: char = '\\\\';\n+/// Returns the first two path components with predicate `f`.\n+///\n+/// The two components returned will be use by caller\n+/// to construct `VerbatimUNC` or `UNC` Windows path prefix.\n+///\n+/// Returns [`None`] if there are no separators in path.\n+fn get_first_two_components(path: &[u8], f: fn(u8) -> bool) -> Option<(&[u8], &[u8])> {\n+    let idx = path.iter().position(|&x| f(x))?;\n+    // Panic safe\n+    // The max `idx+1` is `path.len()` and `path[path.len()..]` is a valid index.\n+    let (first, path) = (&path[..idx], &path[idx + 1..]);\n+    let idx = path.iter().position(|&x| f(x)).unwrap_or(path.len());\n+    let second = &path[..idx];\n+    Some((first, second))\n+}"}, {"sha": "fbac1dc1ca17a017091e27a6bd082e11181a0729", "filename": "src/libstd/sys/windows/path/tests.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Fsys%2Fwindows%2Fpath%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpath%2Ftests.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,21 @@\n+use super::*;\n+\n+#[test]\n+fn test_get_first_two_components() {\n+    assert_eq!(\n+        get_first_two_components(br\"server\\share\", is_verbatim_sep),\n+        Some((&b\"server\"[..], &b\"share\"[..])),\n+    );\n+\n+    assert_eq!(\n+        get_first_two_components(br\"server\\\", is_verbatim_sep),\n+        Some((&b\"server\"[..], &b\"\"[..]))\n+    );\n+\n+    assert_eq!(\n+        get_first_two_components(br\"\\server\\\", is_verbatim_sep),\n+        Some((&b\"\"[..], &b\"server\"[..]))\n+    );\n+\n+    assert_eq!(get_first_two_components(br\"there are no separators here\", is_verbatim_sep), None,);\n+}"}, {"sha": "d354a9b1842c21c9eee5eb8c76efbfe287c1bcd5", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -641,9 +641,8 @@ where\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn current() -> Thread {\n     thread_info::current_thread().expect(\n-        \"use of std::thread::current() is not \\\n-                                          possible after the thread's local \\\n-                                          data has been destroyed\",\n+        \"use of std::thread::current() is not possible \\\n+         after the thread's local data has been destroyed\",\n     )\n }\n "}, {"sha": "86b120e6f302d39cd6973b6391fb299d7bc22122", "filename": "src/llvm-project", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fllvm-project?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1 +1 @@\n-Subproject commit d134a53927fa033ae7e0f3e8ee872ff2dc71468d\n+Subproject commit 86b120e6f302d39cd6973b6391fb299d7bc22122"}, {"sha": "2f1ec8c6d6227a6e624119447f29e43bc16d1247", "filename": "src/test/ui/issues/issue-73886.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fissues%2Fissue-73886.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fissues%2Fissue-73886.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-73886.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,6 @@\n+fn main() {\n+    let _ = &&[0] as &[_];\n+    //~^ ERROR non-primitive cast: `&&[i32; 1]` as `&[_]`\n+    let _ = 7u32 as Option<_>;\n+    //~^ ERROR non-primitive cast: `u32` as `std::option::Option<_>`\n+}"}, {"sha": "e8ab7db6b82c2e91cea279893d7d5d58be9e1969", "filename": "src/test/ui/issues/issue-73886.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fissues%2Fissue-73886.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fissues%2Fissue-73886.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-73886.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,15 @@\n+error[E0605]: non-primitive cast: `&&[i32; 1]` as `&[_]`\n+  --> $DIR/issue-73886.rs:2:13\n+   |\n+LL |     let _ = &&[0] as &[_];\n+   |             ^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n+\n+error[E0605]: non-primitive cast: `u32` as `std::option::Option<_>`\n+  --> $DIR/issue-73886.rs:4:13\n+   |\n+LL |     let _ = 7u32 as Option<_>;\n+   |             ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0605`."}, {"sha": "f68a665b2f38d949507c63253ba0c3a0fca81268", "filename": "src/test/ui/issues/issue-74086.rs", "status": "added", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fissues%2Fissue-74086.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fissues%2Fissue-74086.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-74086.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,4 @@\n+fn main() {\n+    static BUG: fn(_) -> u8 = |_| 8;\n+    //~^ ERROR the type placeholder `_` is not allowed within types on item signatures [E0121]\n+}"}, {"sha": "4127f48a093f478f7884cad515eba50f04f6c505", "filename": "src/test/ui/issues/issue-74086.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fissues%2Fissue-74086.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fissues%2Fissue-74086.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-74086.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,12 @@\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/issue-74086.rs:2:20\n+   |\n+LL |     static BUG: fn(_) -> u8 = |_| 8;\n+   |                    ^\n+   |                    |\n+   |                    not allowed in type signatures\n+   |                    help: use type parameters instead: `T`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0121`."}, {"sha": "40304a674a63365b6e6321fd16128427b0ce0326", "filename": "src/test/ui/missing/missing-fields-in-struct-pattern.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fmissing%2Fmissing-fields-in-struct-pattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fmissing%2Fmissing-fields-in-struct-pattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-fields-in-struct-pattern.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,8 +2,7 @@ struct S(usize, usize, usize, usize);\n \n fn main() {\n     if let S { a, b, c, d } = S(1, 2, 3, 4) {\n-    //~^ ERROR struct `S` does not have fields named `a`, `b`, `c`, `d` [E0026]\n-    //~| ERROR pattern does not mention fields `0`, `1`, `2`, `3` [E0027]\n+    //~^ ERROR tuple variant `S` written as struct variant\n         println!(\"hi\");\n     }\n }"}, {"sha": "6583524aad18f9ba401e3a9e9310549adaf2a9ad", "filename": "src/test/ui/missing/missing-fields-in-struct-pattern.stderr", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fmissing%2Fmissing-fields-in-struct-pattern.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Fmissing%2Fmissing-fields-in-struct-pattern.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmissing%2Fmissing-fields-in-struct-pattern.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,18 +1,9 @@\n-error[E0026]: struct `S` does not have fields named `a`, `b`, `c`, `d`\n-  --> $DIR/missing-fields-in-struct-pattern.rs:4:16\n-   |\n-LL |     if let S { a, b, c, d } = S(1, 2, 3, 4) {\n-   |                ^  ^  ^  ^ struct `S` does not have these fields\n-\n-error[E0027]: pattern does not mention fields `0`, `1`, `2`, `3`\n+error[E0769]: tuple variant `S` written as struct variant\n   --> $DIR/missing-fields-in-struct-pattern.rs:4:12\n    |\n LL |     if let S { a, b, c, d } = S(1, 2, 3, 4) {\n-   |            ^^^^^^^^^^^^^^^^ missing fields `0`, `1`, `2`, `3`\n-   |\n-   = note: trying to match a tuple variant with a struct variant pattern\n+   |            ^^^^^^^^^^^^^^^^ help: use the tuple variant pattern syntax instead: `S(a, b, c, d)`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0026, E0027.\n-For more information about an error, try `rustc --explain E0026`.\n+For more information about this error, try `rustc --explain E0769`."}, {"sha": "cbd39f5f9e6ed5c842acc199414cfb3063475edd", "filename": "src/test/ui/type/type-check/issue-41314.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-41314.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-41314.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-41314.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -4,7 +4,7 @@ enum X {\n \n fn main() {\n     match X::Y(0) {\n-        X::Y { number } => {} //~ ERROR does not have a field named `number`\n-        //~^ ERROR pattern does not mention field `0`\n+        X::Y { number } => {}\n+        //~^ ERROR tuple variant `X::Y` written as struct variant\n     }\n }"}, {"sha": "bd4d2071c2059ac2c9208a87442863114340b098", "filename": "src/test/ui/type/type-check/issue-41314.stderr", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-41314.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-41314.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype%2Ftype-check%2Fissue-41314.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,18 +1,9 @@\n-error[E0026]: variant `X::Y` does not have a field named `number`\n-  --> $DIR/issue-41314.rs:7:16\n-   |\n-LL |         X::Y { number } => {}\n-   |                ^^^^^^ variant `X::Y` does not have this field\n-\n-error[E0027]: pattern does not mention field `0`\n+error[E0769]: tuple variant `X::Y` written as struct variant\n   --> $DIR/issue-41314.rs:7:9\n    |\n LL |         X::Y { number } => {}\n-   |         ^^^^^^^^^^^^^^^ missing field `0`\n-   |\n-   = note: trying to match a tuple variant with a struct variant pattern\n+   |         ^^^^^^^^^^^^^^^ help: use the tuple variant pattern syntax instead: `X::Y(number)`\n \n-error: aborting due to 2 previous errors\n+error: aborting due to previous error\n \n-Some errors have detailed explanations: E0026, E0027.\n-For more information about an error, try `rustc --explain E0026`.\n+For more information about this error, try `rustc --explain E0769`."}, {"sha": "133c5231031fd65a8d86b67159828b3b539d8362", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -32,6 +32,7 @@ fn test7(x: _) { let _x: usize = x; }\n \n fn test8(_f: fn() -> _) { }\n //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+//~^^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n struct Test9;\n \n@@ -98,6 +99,7 @@ pub fn main() {\n \n     fn fn_test8(_f: fn() -> _) { }\n     //~^ ERROR the type placeholder `_` is not allowed within types on item signatures\n+    //~^^ ERROR the type placeholder `_` is not allowed within types on item signatures\n \n     struct FnTest9;\n "}, {"sha": "a1945f2b9cf4e88b314f5d395d555a76f3a1ced4", "filename": "src/test/ui/typeck/typeck_type_placeholder_item.stderr", "status": "modified", "additions": 73, "deletions": 55, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftypeck%2Ftypeck_type_placeholder_item.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,43 +1,43 @@\n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/typeck_type_placeholder_item.rs:152:18\n+  --> $DIR/typeck_type_placeholder_item.rs:154:18\n    |\n LL | struct BadStruct<_>(_);\n    |                  ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/typeck_type_placeholder_item.rs:155:16\n+  --> $DIR/typeck_type_placeholder_item.rs:157:16\n    |\n LL | trait BadTrait<_> {}\n    |                ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/typeck_type_placeholder_item.rs:165:19\n+  --> $DIR/typeck_type_placeholder_item.rs:167:19\n    |\n LL | struct BadStruct1<_, _>(_);\n    |                   ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/typeck_type_placeholder_item.rs:165:22\n+  --> $DIR/typeck_type_placeholder_item.rs:167:22\n    |\n LL | struct BadStruct1<_, _>(_);\n    |                      ^ expected identifier, found reserved identifier\n \n error: expected identifier, found reserved identifier `_`\n-  --> $DIR/typeck_type_placeholder_item.rs:170:19\n+  --> $DIR/typeck_type_placeholder_item.rs:172:19\n    |\n LL | struct BadStruct2<_, T>(_, T);\n    |                   ^ expected identifier, found reserved identifier\n \n error: associated constant in `impl` without body\n-  --> $DIR/typeck_type_placeholder_item.rs:201:5\n+  --> $DIR/typeck_type_placeholder_item.rs:203:5\n    |\n LL |     const C: _;\n    |     ^^^^^^^^^^-\n    |               |\n    |               help: provide a definition for the constant: `= <expr>;`\n \n error[E0403]: the name `_` is already used for a generic parameter in this item's generic parameters\n-  --> $DIR/typeck_type_placeholder_item.rs:165:22\n+  --> $DIR/typeck_type_placeholder_item.rs:167:22\n    |\n LL | struct BadStruct1<_, _>(_);\n    |                   -  ^ already used\n@@ -131,6 +131,15 @@ help: use type parameters instead\n LL | fn test7<T>(x: T) { let _x: usize = x; }\n    |         ^^^    ^\n \n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:33:22\n+   |\n+LL | fn test8(_f: fn() -> _) { }\n+   |                      ^\n+   |                      |\n+   |                      not allowed in type signatures\n+   |                      help: use type parameters instead: `T`\n+\n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n   --> $DIR/typeck_type_placeholder_item.rs:33:22\n    |\n@@ -143,7 +152,7 @@ LL | fn test8<T>(_f: fn() -> T) { }\n    |         ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:46:26\n+  --> $DIR/typeck_type_placeholder_item.rs:47:26\n    |\n LL | fn test11(x: &usize) -> &_ {\n    |                         -^\n@@ -152,7 +161,7 @@ LL | fn test11(x: &usize) -> &_ {\n    |                         help: replace with the correct return type: `&&usize`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:51:52\n+  --> $DIR/typeck_type_placeholder_item.rs:52:52\n    |\n LL | unsafe fn test12(x: *const usize) -> *const *const _ {\n    |                                      --------------^\n@@ -161,7 +170,7 @@ LL | unsafe fn test12(x: *const usize) -> *const *const _ {\n    |                                      help: replace with the correct return type: `*const *const usize`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:65:8\n+  --> $DIR/typeck_type_placeholder_item.rs:66:8\n    |\n LL |     a: _,\n    |        ^ not allowed in type signatures\n@@ -180,13 +189,13 @@ LL |     b: (T, T),\n    |\n \n error: missing type for `static` item\n-  --> $DIR/typeck_type_placeholder_item.rs:71:12\n+  --> $DIR/typeck_type_placeholder_item.rs:72:12\n    |\n LL |     static A = 42;\n    |            ^ help: provide a type for the item: `A: i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:73:15\n+  --> $DIR/typeck_type_placeholder_item.rs:74:15\n    |\n LL |     static B: _ = 42;\n    |               ^\n@@ -195,13 +204,13 @@ LL |     static B: _ = 42;\n    |               help: replace `_` with the correct type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:75:15\n+  --> $DIR/typeck_type_placeholder_item.rs:76:15\n    |\n LL |     static C: Option<_> = Some(42);\n    |               ^^^^^^^^^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:78:21\n+  --> $DIR/typeck_type_placeholder_item.rs:79:21\n    |\n LL |     fn fn_test() -> _ { 5 }\n    |                     ^\n@@ -210,7 +219,7 @@ LL |     fn fn_test() -> _ { 5 }\n    |                     help: replace with the correct return type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:81:23\n+  --> $DIR/typeck_type_placeholder_item.rs:82:23\n    |\n LL |     fn fn_test2() -> (_, _) { (5, 5) }\n    |                      -^--^-\n@@ -220,7 +229,7 @@ LL |     fn fn_test2() -> (_, _) { (5, 5) }\n    |                      help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:84:22\n+  --> $DIR/typeck_type_placeholder_item.rs:85:22\n    |\n LL |     static FN_TEST3: _ = \"test\";\n    |                      ^\n@@ -229,7 +238,7 @@ LL |     static FN_TEST3: _ = \"test\";\n    |                      help: replace `_` with the correct type: `&str`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:87:22\n+  --> $DIR/typeck_type_placeholder_item.rs:88:22\n    |\n LL |     static FN_TEST4: _ = 145;\n    |                      ^\n@@ -238,13 +247,13 @@ LL |     static FN_TEST4: _ = 145;\n    |                      help: replace `_` with the correct type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:90:22\n+  --> $DIR/typeck_type_placeholder_item.rs:91:22\n    |\n LL |     static FN_TEST5: (_, _) = (1, 2);\n    |                      ^^^^^^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:93:20\n+  --> $DIR/typeck_type_placeholder_item.rs:94:20\n    |\n LL |     fn fn_test6(_: _) { }\n    |                    ^ not allowed in type signatures\n@@ -255,7 +264,7 @@ LL |     fn fn_test6<T>(_: T) { }\n    |                ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:96:20\n+  --> $DIR/typeck_type_placeholder_item.rs:97:20\n    |\n LL |     fn fn_test7(x: _) { let _x: usize = x; }\n    |                    ^ not allowed in type signatures\n@@ -266,7 +275,16 @@ LL |     fn fn_test7<T>(x: T) { let _x: usize = x; }\n    |                ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:99:29\n+  --> $DIR/typeck_type_placeholder_item.rs:100:29\n+   |\n+LL |     fn fn_test8(_f: fn() -> _) { }\n+   |                             ^\n+   |                             |\n+   |                             not allowed in type signatures\n+   |                             help: use type parameters instead: `T`\n+\n+error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n+  --> $DIR/typeck_type_placeholder_item.rs:100:29\n    |\n LL |     fn fn_test8(_f: fn() -> _) { }\n    |                             ^ not allowed in type signatures\n@@ -277,7 +295,7 @@ LL |     fn fn_test8<T>(_f: fn() -> T) { }\n    |                ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:121:12\n+  --> $DIR/typeck_type_placeholder_item.rs:123:12\n    |\n LL |         a: _,\n    |            ^ not allowed in type signatures\n@@ -296,21 +314,21 @@ LL |         b: (T, T),\n    |\n \n error[E0282]: type annotations needed\n-  --> $DIR/typeck_type_placeholder_item.rs:126:18\n+  --> $DIR/typeck_type_placeholder_item.rs:128:18\n    |\n LL |     fn fn_test11(_: _) -> (_, _) { panic!() }\n    |                  ^ cannot infer type\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:126:28\n+  --> $DIR/typeck_type_placeholder_item.rs:128:28\n    |\n LL |     fn fn_test11(_: _) -> (_, _) { panic!() }\n    |                            ^  ^ not allowed in type signatures\n    |                            |\n    |                            not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:130:30\n+  --> $DIR/typeck_type_placeholder_item.rs:132:30\n    |\n LL |     fn fn_test12(x: i32) -> (_, _) { (x, x) }\n    |                             -^--^-\n@@ -320,7 +338,7 @@ LL |     fn fn_test12(x: i32) -> (_, _) { (x, x) }\n    |                             help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:133:33\n+  --> $DIR/typeck_type_placeholder_item.rs:135:33\n    |\n LL |     fn fn_test13(x: _) -> (i32, _) { (x, x) }\n    |                           ------^-\n@@ -329,7 +347,7 @@ LL |     fn fn_test13(x: _) -> (i32, _) { (x, x) }\n    |                           help: replace with the correct return type: `(i32, i32)`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:152:21\n+  --> $DIR/typeck_type_placeholder_item.rs:154:21\n    |\n LL | struct BadStruct<_>(_);\n    |                     ^ not allowed in type signatures\n@@ -340,7 +358,7 @@ LL | struct BadStruct<T>(T);\n    |                  ^  ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:157:15\n+  --> $DIR/typeck_type_placeholder_item.rs:159:15\n    |\n LL | impl BadTrait<_> for BadStruct<_> {}\n    |               ^                ^ not allowed in type signatures\n@@ -353,13 +371,13 @@ LL | impl<T> BadTrait<T> for BadStruct<T> {}\n    |     ^^^          ^                ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:160:34\n+  --> $DIR/typeck_type_placeholder_item.rs:162:34\n    |\n LL | fn impl_trait() -> impl BadTrait<_> {\n    |                                  ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:165:25\n+  --> $DIR/typeck_type_placeholder_item.rs:167:25\n    |\n LL | struct BadStruct1<_, _>(_);\n    |                         ^ not allowed in type signatures\n@@ -370,7 +388,7 @@ LL | struct BadStruct1<T, _>(T);\n    |                   ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:170:25\n+  --> $DIR/typeck_type_placeholder_item.rs:172:25\n    |\n LL | struct BadStruct2<_, T>(_, T);\n    |                         ^ not allowed in type signatures\n@@ -381,13 +399,13 @@ LL | struct BadStruct2<U, T>(U, T);\n    |                   ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:174:14\n+  --> $DIR/typeck_type_placeholder_item.rs:176:14\n    |\n LL | type X = Box<_>;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:42:27\n+  --> $DIR/typeck_type_placeholder_item.rs:43:27\n    |\n LL |     fn test10(&self, _x : _) { }\n    |                           ^ not allowed in type signatures\n@@ -398,7 +416,7 @@ LL |     fn test10<T>(&self, _x : T) { }\n    |              ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:138:31\n+  --> $DIR/typeck_type_placeholder_item.rs:140:31\n    |\n LL |     fn method_test1(&self, x: _);\n    |                               ^ not allowed in type signatures\n@@ -409,7 +427,7 @@ LL |     fn method_test1<T>(&self, x: T);\n    |                    ^^^           ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:140:31\n+  --> $DIR/typeck_type_placeholder_item.rs:142:31\n    |\n LL |     fn method_test2(&self, x: _) -> _;\n    |                               ^     ^ not allowed in type signatures\n@@ -422,7 +440,7 @@ LL |     fn method_test2<T>(&self, x: T) -> T;\n    |                    ^^^           ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:142:31\n+  --> $DIR/typeck_type_placeholder_item.rs:144:31\n    |\n LL |     fn method_test3(&self) -> _;\n    |                               ^ not allowed in type signatures\n@@ -433,7 +451,7 @@ LL |     fn method_test3<T>(&self) -> T;\n    |                    ^^^           ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:144:26\n+  --> $DIR/typeck_type_placeholder_item.rs:146:26\n    |\n LL |     fn assoc_fn_test1(x: _);\n    |                          ^ not allowed in type signatures\n@@ -444,7 +462,7 @@ LL |     fn assoc_fn_test1<T>(x: T);\n    |                      ^^^    ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:146:26\n+  --> $DIR/typeck_type_placeholder_item.rs:148:26\n    |\n LL |     fn assoc_fn_test2(x: _) -> _;\n    |                          ^     ^ not allowed in type signatures\n@@ -457,7 +475,7 @@ LL |     fn assoc_fn_test2<T>(x: T) -> T;\n    |                      ^^^    ^     ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:148:28\n+  --> $DIR/typeck_type_placeholder_item.rs:150:28\n    |\n LL |     fn assoc_fn_test3() -> _;\n    |                            ^ not allowed in type signatures\n@@ -468,7 +486,7 @@ LL |     fn assoc_fn_test3<T>() -> T;\n    |                      ^^^      ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:60:37\n+  --> $DIR/typeck_type_placeholder_item.rs:61:37\n    |\n LL |     fn clone_from(&mut self, other: _) { *self = Test9; }\n    |                                     ^ not allowed in type signatures\n@@ -479,7 +497,7 @@ LL |     fn clone_from<T>(&mut self, other: T) { *self = Test9; }\n    |                  ^^^                   ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:108:34\n+  --> $DIR/typeck_type_placeholder_item.rs:110:34\n    |\n LL |         fn fn_test10(&self, _x : _) { }\n    |                                  ^ not allowed in type signatures\n@@ -490,7 +508,7 @@ LL |         fn fn_test10<T>(&self, _x : T) { }\n    |                     ^^^             ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:116:41\n+  --> $DIR/typeck_type_placeholder_item.rs:118:41\n    |\n LL |         fn clone_from(&mut self, other: _) { *self = FnTest9; }\n    |                                         ^ not allowed in type signatures\n@@ -501,25 +519,25 @@ LL |         fn clone_from<T>(&mut self, other: T) { *self = FnTest9; }\n    |                      ^^^                   ^\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:180:21\n+  --> $DIR/typeck_type_placeholder_item.rs:182:21\n    |\n LL | type Y = impl Trait<_>;\n    |                     ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:188:14\n+  --> $DIR/typeck_type_placeholder_item.rs:190:14\n    |\n LL |     type B = _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:190:14\n+  --> $DIR/typeck_type_placeholder_item.rs:192:14\n    |\n LL |     const C: _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:192:14\n+  --> $DIR/typeck_type_placeholder_item.rs:194:14\n    |\n LL |     const D: _ = 42;\n    |              ^\n@@ -528,7 +546,7 @@ LL |     const D: _ = 42;\n    |              help: replace `_` with the correct type: `i32`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:39:24\n+  --> $DIR/typeck_type_placeholder_item.rs:40:24\n    |\n LL |     fn test9(&self) -> _ { () }\n    |                        ^\n@@ -537,7 +555,7 @@ LL |     fn test9(&self) -> _ { () }\n    |                        help: replace with the correct return type: `()`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:57:24\n+  --> $DIR/typeck_type_placeholder_item.rs:58:24\n    |\n LL |     fn clone(&self) -> _ { Test9 }\n    |                        ^\n@@ -546,7 +564,7 @@ LL |     fn clone(&self) -> _ { Test9 }\n    |                        help: replace with the correct return type: `Test9`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:105:31\n+  --> $DIR/typeck_type_placeholder_item.rs:107:31\n    |\n LL |         fn fn_test9(&self) -> _ { () }\n    |                               ^\n@@ -555,7 +573,7 @@ LL |         fn fn_test9(&self) -> _ { () }\n    |                               help: replace with the correct return type: `()`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:113:28\n+  --> $DIR/typeck_type_placeholder_item.rs:115:28\n    |\n LL |         fn clone(&self) -> _ { FnTest9 }\n    |                            ^\n@@ -564,33 +582,33 @@ LL |         fn clone(&self) -> _ { FnTest9 }\n    |                            help: replace with the correct return type: `main::FnTest9`\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:197:14\n+  --> $DIR/typeck_type_placeholder_item.rs:199:14\n    |\n LL |     type A = _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:199:14\n+  --> $DIR/typeck_type_placeholder_item.rs:201:14\n    |\n LL |     type B = _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:201:14\n+  --> $DIR/typeck_type_placeholder_item.rs:203:14\n    |\n LL |     const C: _;\n    |              ^ not allowed in type signatures\n \n error[E0121]: the type placeholder `_` is not allowed within types on item signatures\n-  --> $DIR/typeck_type_placeholder_item.rs:204:14\n+  --> $DIR/typeck_type_placeholder_item.rs:206:14\n    |\n LL |     const D: _ = 42;\n    |              ^\n    |              |\n    |              not allowed in type signatures\n    |              help: replace `_` with the correct type: `i32`\n \n-error: aborting due to 64 previous errors\n+error: aborting due to 66 previous errors\n \n Some errors have detailed explanations: E0121, E0282, E0403.\n For more information about an error, try `rustc --explain E0121`."}, {"sha": "48654347285d3be45c7a97d9f4641788e03ef972", "filename": "src/test/ui/union/union-fields-2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Funion%2Funion-fields-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftest%2Fui%2Funion%2Funion-fields-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funion%2Funion-fields-2.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -48,18 +48,18 @@ error: union patterns should have exactly one field\n LL |     let U { a, b } = u;\n    |         ^^^^^^^^^^\n \n-error[E0026]: union `U` does not have a field named `c`\n-  --> $DIR/union-fields-2.rs:18:19\n-   |\n-LL |     let U { a, b, c } = u;\n-   |                   ^ union `U` does not have this field\n-\n error: union patterns should have exactly one field\n   --> $DIR/union-fields-2.rs:18:9\n    |\n LL |     let U { a, b, c } = u;\n    |         ^^^^^^^^^^^^^\n \n+error[E0026]: union `U` does not have a field named `c`\n+  --> $DIR/union-fields-2.rs:18:19\n+   |\n+LL |     let U { a, b, c } = u;\n+   |                   ^ union `U` does not have this field\n+\n error: union patterns should have exactly one field\n   --> $DIR/union-fields-2.rs:20:9\n    |"}, {"sha": "98fd0df685fdb31711ea1c8234f9afea43e62c0a", "filename": "src/tools/clippy/.github/ISSUE_TEMPLATE/new_lint.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2FISSUE_TEMPLATE%2Fnew_lint.md?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -12,7 +12,7 @@ labels: L-lint\n \n - Kind: *See <https://github.com/rust-lang/rust-clippy/blob/master/README.md#clippy> for list of lint kinds*\n \n-*What benefit of this lint over old code?*\n+*What is the advantage of the recommended code over the original code*\n \n For example:\n - Remove bounce checking inserted by ..."}, {"sha": "fd0cd7a1890bd79c8630a52fcd17a39d729ed61f", "filename": "src/tools/clippy/.github/workflows/clippy_bors.yml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2F.github%2Fworkflows%2Fclippy_bors.yml?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -240,7 +240,8 @@ jobs:\n         - 'Geal/nom'\n         - 'rust-lang/stdarch'\n         - 'serde-rs/serde'\n-        - 'chronotope/chrono'\n+        # FIXME: chrono currently cannot be compiled with `--all-targets`\n+        # - 'chronotope/chrono'\n         - 'hyperium/hyper'\n         - 'rust-random/rand'\n         - 'rust-lang/futures-rs'"}, {"sha": "5d08b44ba404f9294f0b45973e017e571c208058", "filename": "src/tools/clippy/CHANGELOG.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2FCHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2FCHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCHANGELOG.md?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1352,6 +1352,7 @@ Released 2018-09-13\n [`bad_bit_mask`]: https://rust-lang.github.io/rust-clippy/master/index.html#bad_bit_mask\n [`bind_instead_of_map`]: https://rust-lang.github.io/rust-clippy/master/index.html#bind_instead_of_map\n [`blacklisted_name`]: https://rust-lang.github.io/rust-clippy/master/index.html#blacklisted_name\n+[`blanket_clippy_restriction_lints`]: https://rust-lang.github.io/rust-clippy/master/index.html#blanket_clippy_restriction_lints\n [`blocks_in_if_conditions`]: https://rust-lang.github.io/rust-clippy/master/index.html#blocks_in_if_conditions\n [`bool_comparison`]: https://rust-lang.github.io/rust-clippy/master/index.html#bool_comparison\n [`borrow_interior_mutable_const`]: https://rust-lang.github.io/rust-clippy/master/index.html#borrow_interior_mutable_const\n@@ -1508,9 +1509,11 @@ Released 2018-09-13\n [`map_clone`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_clone\n [`map_entry`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_entry\n [`map_flatten`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_flatten\n+[`map_identity`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_identity\n [`map_unwrap_or`]: https://rust-lang.github.io/rust-clippy/master/index.html#map_unwrap_or\n [`match_as_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_as_ref\n [`match_bool`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_bool\n+[`match_like_matches_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_like_matches_macro\n [`match_on_vec_items`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_on_vec_items\n [`match_overlapping_arm`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_overlapping_arm\n [`match_ref_pats`]: https://rust-lang.github.io/rust-clippy/master/index.html#match_ref_pats\n@@ -1575,6 +1578,7 @@ Released 2018-09-13\n [`op_ref`]: https://rust-lang.github.io/rust-clippy/master/index.html#op_ref\n [`option_as_ref_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_as_ref_deref\n [`option_env_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_env_unwrap\n+[`option_if_let_else`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_if_let_else\n [`option_map_or_none`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_or_none\n [`option_map_unit_fn`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_map_unit_fn\n [`option_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#option_option\n@@ -1586,6 +1590,7 @@ Released 2018-09-13\n [`panicking_unwrap`]: https://rust-lang.github.io/rust-clippy/master/index.html#panicking_unwrap\n [`partialeq_ne_impl`]: https://rust-lang.github.io/rust-clippy/master/index.html#partialeq_ne_impl\n [`path_buf_push_overwrite`]: https://rust-lang.github.io/rust-clippy/master/index.html#path_buf_push_overwrite\n+[`pattern_type_mismatch`]: https://rust-lang.github.io/rust-clippy/master/index.html#pattern_type_mismatch\n [`possible_missing_comma`]: https://rust-lang.github.io/rust-clippy/master/index.html#possible_missing_comma\n [`precedence`]: https://rust-lang.github.io/rust-clippy/master/index.html#precedence\n [`print_literal`]: https://rust-lang.github.io/rust-clippy/master/index.html#print_literal\n@@ -1612,6 +1617,7 @@ Released 2018-09-13\n [`redundant_static_lifetimes`]: https://rust-lang.github.io/rust-clippy/master/index.html#redundant_static_lifetimes\n [`ref_in_deref`]: https://rust-lang.github.io/rust-clippy/master/index.html#ref_in_deref\n [`regex_macro`]: https://rust-lang.github.io/rust-clippy/master/index.html#regex_macro\n+[`repeat_once`]: https://rust-lang.github.io/rust-clippy/master/index.html#repeat_once\n [`replace_consts`]: https://rust-lang.github.io/rust-clippy/master/index.html#replace_consts\n [`rest_pat_in_fully_bound_structs`]: https://rust-lang.github.io/rust-clippy/master/index.html#rest_pat_in_fully_bound_structs\n [`result_map_or_into_option`]: https://rust-lang.github.io/rust-clippy/master/index.html#result_map_or_into_option"}, {"sha": "69a734e4ee4c2126a6bef72218d0b9a4b5e4aafc", "filename": "src/tools/clippy/CONTRIBUTING.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2FCONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2FCONTRIBUTING.md?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -245,7 +245,7 @@ this to work, you will need the fix of `git subtree` available\n [here][gitgitgadget-pr].\n \n [gitgitgadget-pr]: https://github.com/gitgitgadget/git/pull/493\n-[subtree]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#external-dependencies-subtree\n+[subtree]: https://rustc-dev-guide.rust-lang.org/contributing.html#external-dependencies-subtree\n [`rust-lang/rust`]: https://github.com/rust-lang/rust\n \n ## Issue and PR triage"}, {"sha": "ef01364b7d9655b97ee426fdcdd29ce7a6e4dcdf", "filename": "src/tools/clippy/clippy_lints/src/attrs.rs", "status": "modified", "additions": 76, "deletions": 39, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fattrs.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,8 +2,8 @@\n \n use crate::reexport::Name;\n use crate::utils::{\n-    first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_sugg,\n-    span_lint_and_then, without_block_comments,\n+    first_line_of_span, is_present_in_source, match_def_path, paths, snippet_opt, span_lint, span_lint_and_help,\n+    span_lint_and_sugg, span_lint_and_then, without_block_comments,\n };\n use if_chain::if_chain;\n use rustc_ast::ast::{AttrKind, AttrStyle, Attribute, Lit, LitKind, MetaItemKind, NestedMetaItem};\n@@ -17,7 +17,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::Span;\n-use rustc_span::symbol::Symbol;\n+use rustc_span::symbol::{Symbol, SymbolStr};\n use semver::Version;\n \n static UNIX_SYSTEMS: &[&str] = &[\n@@ -182,6 +182,29 @@ declare_clippy_lint! {\n     \"unknown_lints for scoped Clippy lints\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `warn`/`deny`/`forbid` attributes targeting the whole clippy::restriction category.\n+    ///\n+    /// **Why is this bad?** Restriction lints sometimes are in contrast with other lints or even go against idiomatic rust.\n+    /// These lints should only be enabled on a lint-by-lint basis and with careful consideration.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// Bad:\n+    /// ```rust\n+    /// #![deny(clippy::restriction)]\n+    /// ```\n+    ///\n+    /// Good:\n+    /// ```rust\n+    /// #![deny(clippy::as_conversions)]\n+    /// ```\n+    pub BLANKET_CLIPPY_RESTRICTION_LINTS,\n+    style,\n+    \"enabling the complete restriction group\"\n+}\n+\n declare_clippy_lint! {\n     /// **What it does:** Checks for `#[cfg_attr(rustfmt, rustfmt_skip)]` and suggests to replace it\n     /// with `#[rustfmt::skip]`.\n@@ -249,15 +272,17 @@ declare_lint_pass!(Attributes => [\n     DEPRECATED_SEMVER,\n     USELESS_ATTRIBUTE,\n     UNKNOWN_CLIPPY_LINTS,\n+    BLANKET_CLIPPY_RESTRICTION_LINTS,\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Attributes {\n     fn check_attribute(&mut self, cx: &LateContext<'tcx>, attr: &'tcx Attribute) {\n         if let Some(items) = &attr.meta_item_list() {\n             if let Some(ident) = attr.ident() {\n-                match &*ident.as_str() {\n+                let ident = &*ident.as_str();\n+                match ident {\n                     \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                        check_clippy_lint_names(cx, items);\n+                        check_clippy_lint_names(cx, ident, items);\n                     },\n                     _ => {},\n                 }\n@@ -363,38 +388,43 @@ impl<'tcx> LateLintPass<'tcx> for Attributes {\n     }\n }\n \n-#[allow(clippy::single_match_else)]\n-fn check_clippy_lint_names(cx: &LateContext<'_>, items: &[NestedMetaItem]) {\n-    let lint_store = cx.lints();\n-    for lint in items {\n+fn check_clippy_lint_names(cx: &LateContext<'_>, ident: &str, items: &[NestedMetaItem]) {\n+    fn extract_name(lint: &NestedMetaItem) -> Option<SymbolStr> {\n         if_chain! {\n             if let Some(meta_item) = lint.meta_item();\n             if meta_item.path.segments.len() > 1;\n             if let tool_name = meta_item.path.segments[0].ident;\n             if tool_name.as_str() == \"clippy\";\n-            let name = meta_item.path.segments.last().unwrap().ident.name;\n-            if let CheckLintNameResult::Tool(Err((None, _))) = lint_store.check_lint_name(\n-                &name.as_str(),\n-                Some(tool_name.name),\n-            );\n+            let lint_name = meta_item.path.segments.last().unwrap().ident.name;\n             then {\n+                return Some(lint_name.as_str());\n+            }\n+        }\n+        None\n+    }\n+\n+    let lint_store = cx.lints();\n+    for lint in items {\n+        if let Some(lint_name) = extract_name(lint) {\n+            if let CheckLintNameResult::Tool(Err((None, _))) =\n+                lint_store.check_lint_name(&lint_name, Some(sym!(clippy)))\n+            {\n                 span_lint_and_then(\n                     cx,\n                     UNKNOWN_CLIPPY_LINTS,\n                     lint.span(),\n-                    &format!(\"unknown clippy lint: clippy::{}\", name),\n+                    &format!(\"unknown clippy lint: clippy::{}\", lint_name),\n                     |diag| {\n-                        let name_lower = name.as_str().to_lowercase();\n-                        let symbols = lint_store.get_lints().iter().map(\n-                            |l| Symbol::intern(&l.name_lower())\n-                        ).collect::<Vec<_>>();\n-                        let sugg = find_best_match_for_name(\n-                            symbols.iter(),\n-                            &format!(\"clippy::{}\", name_lower),\n-                            None,\n-                        );\n-                        if name.as_str().chars().any(char::is_uppercase)\n-                            && lint_store.find_lints(&format!(\"clippy::{}\", name_lower)).is_ok() {\n+                        let name_lower = lint_name.to_lowercase();\n+                        let symbols = lint_store\n+                            .get_lints()\n+                            .iter()\n+                            .map(|l| Symbol::intern(&l.name_lower()))\n+                            .collect::<Vec<_>>();\n+                        let sugg = find_best_match_for_name(symbols.iter(), &format!(\"clippy::{}\", name_lower), None);\n+                        if lint_name.chars().any(char::is_uppercase)\n+                            && lint_store.find_lints(&format!(\"clippy::{}\", name_lower)).is_ok()\n+                        {\n                             diag.span_suggestion(\n                                 lint.span(),\n                                 \"lowercase the lint name\",\n@@ -409,10 +439,19 @@ fn check_clippy_lint_names(cx: &LateContext<'_>, items: &[NestedMetaItem]) {\n                                 Applicability::MachineApplicable,\n                             );\n                         }\n-                    }\n+                    },\n+                );\n+            } else if lint_name == \"restriction\" && ident != \"allow\" {\n+                span_lint_and_help(\n+                    cx,\n+                    BLANKET_CLIPPY_RESTRICTION_LINTS,\n+                    lint.span(),\n+                    \"restriction lints are not meant to be all enabled\",\n+                    None,\n+                    \"try enabling only the lints you really need\",\n                 );\n             }\n-        };\n+        }\n     }\n }\n \n@@ -442,15 +481,14 @@ fn is_relevant_trait(cx: &LateContext<'_>, item: &TraitItem<'_>) -> bool {\n }\n \n fn is_relevant_block(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, block: &Block<'_>) -> bool {\n-    if let Some(stmt) = block.stmts.first() {\n-        match &stmt.kind {\n+    block.stmts.first().map_or(\n+        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e)),\n+        |stmt| match &stmt.kind {\n             StmtKind::Local(_) => true,\n             StmtKind::Expr(expr) | StmtKind::Semi(expr) => is_relevant_expr(cx, tables, expr),\n             _ => false,\n-        }\n-    } else {\n-        block.expr.as_ref().map_or(false, |e| is_relevant_expr(cx, tables, e))\n-    }\n+        },\n+    )\n }\n \n fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &Expr<'_>) -> bool {\n@@ -460,11 +498,10 @@ fn is_relevant_expr(cx: &LateContext<'_>, tables: &ty::TypeckTables<'_>, expr: &\n         ExprKind::Ret(None) | ExprKind::Break(_, None) => false,\n         ExprKind::Call(path_expr, _) => {\n             if let ExprKind::Path(qpath) = &path_expr.kind {\n-                if let Some(fun_id) = tables.qpath_res(qpath, path_expr.hir_id).opt_def_id() {\n-                    !match_def_path(cx, fun_id, &paths::BEGIN_PANIC)\n-                } else {\n-                    true\n-                }\n+                tables\n+                    .qpath_res(qpath, path_expr.hir_id)\n+                    .opt_def_id()\n+                    .map_or(true, |fun_id| !match_def_path(cx, fun_id, &paths::BEGIN_PANIC))\n             } else {\n                 true\n             }"}, {"sha": "d337262dfa6e2384897d37267bb1ec5ef0cd784e", "filename": "src/tools/clippy/clippy_lints/src/await_holding_lock.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fawait_holding_lock.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -11,7 +11,7 @@ declare_clippy_lint! {\n     /// non-async-aware MutexGuard.\n     ///\n     /// **Why is this bad?** The Mutex types found in syd::sync and parking_lot\n-    /// are not designed to operator in an async context across await points.\n+    /// are not designed to operate in an async context across await points.\n     ///\n     /// There are two potential solutions. One is to use an asynx-aware Mutex\n     /// type. Many asynchronous foundation crates provide such a Mutex type. The"}, {"sha": "42bff564de03d471b49264bee9da3daaa691cb19", "filename": "src/tools/clippy/clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -115,7 +115,7 @@ fn check_collapsible_maybe_if_let(cx: &EarlyContext<'_>, else_: &ast::Expr) {\n                 COLLAPSIBLE_IF,\n                 block.span,\n                 \"this `else { if .. }` block can be collapsed\",\n-                \"try\",\n+                \"collapse nested if block\",\n                 snippet_block_with_applicability(cx, else_.span, \"..\", Some(block.span), &mut applicability).into_owned(),\n                 applicability,\n             );\n@@ -142,7 +142,7 @@ fn check_collapsible_no_if_let(cx: &EarlyContext<'_>, expr: &ast::Expr, check: &\n                 let rhs = Sugg::ast(cx, check_inner, \"..\");\n                 diag.span_suggestion(\n                     expr.span,\n-                    \"try\",\n+                    \"collapse nested if block\",\n                     format!(\n                         \"if {} {}\",\n                         lhs.and(&rhs),"}, {"sha": "25ccabc1c883e200811c69b2762d6c0f008a8349", "filename": "src/tools/clippy/clippy_lints/src/comparison_chain.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fcomparison_chain.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -122,8 +122,5 @@ impl<'tcx> LateLintPass<'tcx> for ComparisonChain {\n }\n \n fn kind_is_cmp(kind: BinOpKind) -> bool {\n-    match kind {\n-        BinOpKind::Lt | BinOpKind::Gt | BinOpKind::Eq => true,\n-        _ => false,\n-    }\n+    matches!(kind, BinOpKind::Lt | BinOpKind::Gt | BinOpKind::Eq)\n }"}, {"sha": "818d8188a787a6608f3071810b539010fea3ffcb", "filename": "src/tools/clippy/clippy_lints/src/deprecated_lints.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdeprecated_lints.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -153,5 +153,13 @@ declare_deprecated_lint! {\n     ///\n     /// **Deprecation reason:** Associated-constants are now preferred.\n     pub REPLACE_CONSTS,\n-    \"associated-constants `MIN`/`MAX` of integers are prefer to `{min,max}_value()` and module constants\"\n+    \"associated-constants `MIN`/`MAX` of integers are prefered to `{min,max}_value()` and module constants\"\n+}\n+\n+declare_deprecated_lint! {\n+    /// **What it does:** Nothing. This lint has been deprecated.\n+    ///\n+    /// **Deprecation reason:** The regex! macro does not exist anymore.\n+    pub REGEX_MACRO,\n+    \"the regex! macro has been removed from the regex crate in 2018\"\n }"}, {"sha": "323cad7fa1a8c7dcfe62eb67e71c4af4dd36bfae", "filename": "src/tools/clippy/clippy_lints/src/dereference.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fdereference.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -73,9 +73,10 @@ impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var_span: Span, expr_span: Span) {\n     match method_name {\n         \"deref\" => {\n-            if cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n+            let impls_deref_trait = cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n                 implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n-            }) {\n+            });\n+            if impls_deref_trait {\n                 span_lint_and_sugg(\n                     cx,\n                     EXPLICIT_DEREF_METHODS,\n@@ -88,9 +89,10 @@ fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var\n             }\n         },\n         \"deref_mut\" => {\n-            if cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n+            let impls_deref_mut_trait = cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n                 implements_trait(cx, cx.tables().expr_ty(&call_expr), id, &[])\n-            }) {\n+            });\n+            if impls_deref_mut_trait {\n                 span_lint_and_sugg(\n                     cx,\n                     EXPLICIT_DEREF_METHODS,"}, {"sha": "01eff28cb195a26b27589e6960871aff443d718d", "filename": "src/tools/clippy/clippy_lints/src/eq_op.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feq_op.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -214,20 +214,20 @@ impl<'tcx> LateLintPass<'tcx> for EqOp {\n }\n \n fn is_valid_operator(op: BinOp) -> bool {\n-    match op.node {\n+    matches!(\n+        op.node,\n         BinOpKind::Sub\n-        | BinOpKind::Div\n-        | BinOpKind::Eq\n-        | BinOpKind::Lt\n-        | BinOpKind::Le\n-        | BinOpKind::Gt\n-        | BinOpKind::Ge\n-        | BinOpKind::Ne\n-        | BinOpKind::And\n-        | BinOpKind::Or\n-        | BinOpKind::BitXor\n-        | BinOpKind::BitAnd\n-        | BinOpKind::BitOr => true,\n-        _ => false,\n-    }\n+            | BinOpKind::Div\n+            | BinOpKind::Eq\n+            | BinOpKind::Lt\n+            | BinOpKind::Le\n+            | BinOpKind::Gt\n+            | BinOpKind::Ge\n+            | BinOpKind::Ne\n+            | BinOpKind::And\n+            | BinOpKind::Or\n+            | BinOpKind::BitXor\n+            | BinOpKind::BitAnd\n+            | BinOpKind::BitOr\n+    )\n }"}, {"sha": "ceb3c40d869a1ba4409fcd28b50060a2ab628149", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -105,10 +105,7 @@ fn is_argument(map: rustc_middle::hir::map::Map<'_>, id: HirId) -> bool {\n         _ => return false,\n     }\n \n-    match map.find(map.get_parent_node(id)) {\n-        Some(Node::Param(_)) => true,\n-        _ => false,\n-    }\n+    matches!(map.find(map.get_parent_node(id)), Some(Node::Param(_)))\n }\n \n impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {"}, {"sha": "fb26b9fc27d259793ed799f6d6d4888aaec85d3d", "filename": "src/tools/clippy/clippy_lints/src/eta_reduction.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Feta_reduction.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -175,10 +175,7 @@ fn get_ufcs_type_name(cx: &LateContext<'_>, method_def_id: def_id::DefId, self_a\n fn match_borrow_depth(lhs: Ty<'_>, rhs: Ty<'_>) -> bool {\n     match (&lhs.kind, &rhs.kind) {\n         (ty::Ref(_, t1, mut1), ty::Ref(_, t2, mut2)) => mut1 == mut2 && match_borrow_depth(&t1, &t2),\n-        (l, r) => match (l, r) {\n-            (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _)) => false,\n-            (_, _) => true,\n-        },\n+        (l, r) => !matches!((l, r), (ty::Ref(_, _, _), _) | (_, ty::Ref(_, _, _))),\n     }\n }\n "}, {"sha": "3087d6a940a867268b8aab2c823193400bed58d8", "filename": "src/tools/clippy/clippy_lints/src/floating_point_arithmetic.rs", "status": "modified", "additions": 224, "deletions": 3, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffloating_point_arithmetic.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,11 +1,11 @@\n use crate::consts::{\n     constant, constant_simple, Constant,\n-    Constant::{F32, F64},\n+    Constant::{Int, F32, F64},\n };\n-use crate::utils::{higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n+use crate::utils::{get_parent_expr, higher, numeric_literal, span_lint_and_sugg, sugg, SpanlessEq};\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::{BinOpKind, Expr, ExprKind, UnOp};\n+use rustc_hir::{BinOpKind, Expr, ExprKind, PathSegment, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n@@ -293,6 +293,121 @@ fn check_powf(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n     }\n }\n \n+fn check_powi(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some((value, _)) = constant(cx, cx.tables(), &args[1]) {\n+        if value == Int(2) {\n+            if let Some(parent) = get_parent_expr(cx, expr) {\n+                if let Some(grandparent) = get_parent_expr(cx, parent) {\n+                    if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, _, args, _) = grandparent.kind {\n+                        if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+                            return;\n+                        }\n+                    }\n+                }\n+\n+                if let ExprKind::Binary(\n+                    Spanned {\n+                        node: BinOpKind::Add, ..\n+                    },\n+                    ref lhs,\n+                    ref rhs,\n+                ) = parent.kind\n+                {\n+                    let other_addend = if lhs.hir_id == expr.hir_id { rhs } else { lhs };\n+\n+                    span_lint_and_sugg(\n+                        cx,\n+                        SUBOPTIMAL_FLOPS,\n+                        parent.span,\n+                        \"square can be computed more efficiently\",\n+                        \"consider using\",\n+                        format!(\n+                            \"{}.mul_add({}, {})\",\n+                            Sugg::hir(cx, &args[0], \"..\"),\n+                            Sugg::hir(cx, &args[0], \"..\"),\n+                            Sugg::hir(cx, &other_addend, \"..\"),\n+                        ),\n+                        Applicability::MachineApplicable,\n+                    );\n+\n+                    return;\n+                }\n+            }\n+\n+            span_lint_and_sugg(\n+                cx,\n+                SUBOPTIMAL_FLOPS,\n+                expr.span,\n+                \"square can be computed more efficiently\",\n+                \"consider using\",\n+                format!(\"{} * {}\", Sugg::hir(cx, &args[0], \"..\"), Sugg::hir(cx, &args[0], \"..\")),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn detect_hypot(cx: &LateContext<'_>, args: &[Expr<'_>]) -> Option<String> {\n+    if let ExprKind::Binary(\n+        Spanned {\n+            node: BinOpKind::Add, ..\n+        },\n+        ref add_lhs,\n+        ref add_rhs,\n+    ) = args[0].kind\n+    {\n+        // check if expression of the form x * x + y * y\n+        if_chain! {\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref lmul_lhs, ref lmul_rhs) = add_lhs.kind;\n+            if let ExprKind::Binary(Spanned { node: BinOpKind::Mul, .. }, ref rmul_lhs, ref rmul_rhs) = add_rhs.kind;\n+            if are_exprs_equal(cx, lmul_lhs, lmul_rhs);\n+            if are_exprs_equal(cx, rmul_lhs, rmul_rhs);\n+            then {\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &lmul_lhs, \"..\"), Sugg::hir(cx, &rmul_lhs, \"..\")));\n+            }\n+        }\n+\n+        // check if expression of the form x.powi(2) + y.powi(2)\n+        if_chain! {\n+            if let ExprKind::MethodCall(\n+                PathSegment { ident: lmethod_name, .. },\n+                ref _lspan,\n+                ref largs,\n+                _\n+            ) = add_lhs.kind;\n+            if let ExprKind::MethodCall(\n+                PathSegment { ident: rmethod_name, .. },\n+                ref _rspan,\n+                ref rargs,\n+                _\n+            ) = add_rhs.kind;\n+            if lmethod_name.as_str() == \"powi\" && rmethod_name.as_str() == \"powi\";\n+            if let Some((lvalue, _)) = constant(cx, cx.tables(), &largs[1]);\n+            if let Some((rvalue, _)) = constant(cx, cx.tables(), &rargs[1]);\n+            if Int(2) == lvalue && Int(2) == rvalue;\n+            then {\n+                return Some(format!(\"{}.hypot({})\", Sugg::hir(cx, &largs[0], \"..\"), Sugg::hir(cx, &rargs[0], \"..\")));\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn check_hypot(cx: &LateContext<'_>, expr: &Expr<'_>, args: &[Expr<'_>]) {\n+    if let Some(message) = detect_hypot(cx, args) {\n+        span_lint_and_sugg(\n+            cx,\n+            IMPRECISE_FLOPS,\n+            expr.span,\n+            \"hypotenuse can be computed more accurately\",\n+            \"consider using\",\n+            message,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n+\n // TODO: Lint expressions of the form `x.exp() - y` where y > 1\n // and suggest usage of `x.exp_m1() - (y - 1)` instead\n fn check_expm1(cx: &LateContext<'_>, expr: &Expr<'_>) {\n@@ -344,6 +459,14 @@ fn check_mul_add(cx: &LateContext<'_>, expr: &Expr<'_>) {\n         rhs,\n     ) = &expr.kind\n     {\n+        if let Some(parent) = get_parent_expr(cx, expr) {\n+            if let ExprKind::MethodCall(PathSegment { ident: method_name, .. }, _, args, _) = parent.kind {\n+                if method_name.as_str() == \"sqrt\" && detect_hypot(cx, args).is_some() {\n+                    return;\n+                }\n+            }\n+        }\n+\n         let (recv, arg1, arg2) = if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, lhs) {\n             (inner_lhs, inner_rhs, rhs)\n         } else if let Some((inner_lhs, inner_rhs)) = is_float_mul_expr(cx, rhs) {\n@@ -479,6 +602,100 @@ fn check_custom_abs(cx: &LateContext<'_>, expr: &Expr<'_>) {\n     }\n }\n \n+fn are_same_base_logs(cx: &LateContext<'_>, expr_a: &Expr<'_>, expr_b: &Expr<'_>) -> bool {\n+    if_chain! {\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_a, .. }, _, ref args_a, _) = expr_a.kind;\n+        if let ExprKind::MethodCall(PathSegment { ident: method_name_b, .. }, _, ref args_b, _) = expr_b.kind;\n+        then {\n+            return method_name_a.as_str() == method_name_b.as_str() &&\n+                args_a.len() == args_b.len() &&\n+                (\n+                    [\"ln\", \"log2\", \"log10\"].contains(&&*method_name_a.as_str()) ||\n+                    method_name_a.as_str() == \"log\" && args_a.len() == 2 && are_exprs_equal(cx, &args_a[1], &args_b[1])\n+                );\n+        }\n+    }\n+\n+    false\n+}\n+\n+fn check_log_division(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    // check if expression of the form x.logN() / y.logN()\n+    if_chain! {\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Div, ..\n+            },\n+            lhs,\n+            rhs,\n+        ) = &expr.kind;\n+        if are_same_base_logs(cx, lhs, rhs);\n+        if let ExprKind::MethodCall(_, _, ref largs, _) = lhs.kind;\n+        if let ExprKind::MethodCall(_, _, ref rargs, _) = rhs.kind;\n+        then {\n+            span_lint_and_sugg(\n+                cx,\n+                SUBOPTIMAL_FLOPS,\n+                expr.span,\n+                \"log base can be expressed more clearly\",\n+                \"consider using\",\n+                format!(\"{}.log({})\", Sugg::hir(cx, &largs[0], \"..\"), Sugg::hir(cx, &rargs[0], \"..\"),),\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+    }\n+}\n+\n+fn check_radians(cx: &LateContext<'_>, expr: &Expr<'_>) {\n+    if_chain! {\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Div, ..\n+            },\n+            div_lhs,\n+            div_rhs,\n+        ) = &expr.kind;\n+        if let ExprKind::Binary(\n+            Spanned {\n+                node: BinOpKind::Mul, ..\n+            },\n+            mul_lhs,\n+            mul_rhs,\n+        ) = &div_lhs.kind;\n+        if let Some((rvalue, _)) = constant(cx, cx.tables(), div_rhs);\n+        if let Some((lvalue, _)) = constant(cx, cx.tables(), mul_rhs);\n+        then {\n+            // TODO: also check for constant values near PI/180 or 180/PI\n+            if (F32(f32_consts::PI) == rvalue || F64(f64_consts::PI) == rvalue) &&\n+               (F32(180_f32) == lvalue || F64(180_f64) == lvalue)\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    SUBOPTIMAL_FLOPS,\n+                    expr.span,\n+                    \"conversion to degrees can be done more accurately\",\n+                    \"consider using\",\n+                    format!(\"{}.to_degrees()\", Sugg::hir(cx, &mul_lhs, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else if\n+                (F32(180_f32) == rvalue || F64(180_f64) == rvalue) &&\n+                (F32(f32_consts::PI) == lvalue || F64(f64_consts::PI) == lvalue)\n+            {\n+                span_lint_and_sugg(\n+                    cx,\n+                    SUBOPTIMAL_FLOPS,\n+                    expr.span,\n+                    \"conversion to radians can be done more accurately\",\n+                    \"consider using\",\n+                    format!(\"{}.to_radians()\", Sugg::hir(cx, &mul_lhs, \"..\")),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if let ExprKind::MethodCall(ref path, _, args, _) = &expr.kind {\n@@ -489,13 +706,17 @@ impl<'tcx> LateLintPass<'tcx> for FloatingPointArithmetic {\n                     \"ln\" => check_ln1p(cx, expr, args),\n                     \"log\" => check_log_base(cx, expr, args),\n                     \"powf\" => check_powf(cx, expr, args),\n+                    \"powi\" => check_powi(cx, expr, args),\n+                    \"sqrt\" => check_hypot(cx, expr, args),\n                     _ => {},\n                 }\n             }\n         } else {\n             check_expm1(cx, expr);\n             check_mul_add(cx, expr);\n             check_custom_abs(cx, expr);\n+            check_log_division(cx, expr);\n+            check_radians(cx, expr);\n         }\n     }\n }"}, {"sha": "1bd16e6cce53a3a5fae6dab1fb18b936c1679682", "filename": "src/tools/clippy/clippy_lints/src/formatting.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fformatting.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -305,18 +305,10 @@ fn check_missing_else(cx: &EarlyContext<'_>, first: &Expr, second: &Expr) {\n }\n \n fn is_block(expr: &Expr) -> bool {\n-    if let ExprKind::Block(..) = expr.kind {\n-        true\n-    } else {\n-        false\n-    }\n+    matches!(expr.kind, ExprKind::Block(..))\n }\n \n /// Check if the expression is an `if` or `if let`\n fn is_if(expr: &Expr) -> bool {\n-    if let ExprKind::If(..) = expr.kind {\n-        true\n-    } else {\n-        false\n-    }\n+    matches!(expr.kind, ExprKind::If(..))\n }"}, {"sha": "63133a4872a3e76dd698cc3354a490cd2f0fdf91", "filename": "src/tools/clippy/clippy_lints/src/functions.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffunctions.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -645,13 +645,7 @@ fn is_mutated_static(cx: &LateContext<'_>, e: &hir::Expr<'_>) -> bool {\n     use hir::ExprKind::{Field, Index, Path};\n \n     match e.kind {\n-        Path(ref qpath) => {\n-            if let Res::Local(_) = qpath_res(cx, qpath, e.hir_id) {\n-                false\n-            } else {\n-                true\n-            }\n-        },\n+        Path(ref qpath) => !matches!(qpath_res(cx, qpath, e.hir_id), Res::Local(_)),\n         Field(ref inner, _) | Index(ref inner, _) => is_mutated_static(cx, inner),\n         _ => false,\n     }"}, {"sha": "fbd2eeacc6ef553cf7146eade14619877280cab2", "filename": "src/tools/clippy/clippy_lints/src/if_let_mutex.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fif_let_mutex.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -135,13 +135,10 @@ impl<'tcx> Visitor<'tcx> for ArmVisitor<'_, 'tcx> {\n     }\n }\n \n-impl<'tcx> ArmVisitor<'_, 'tcx> {\n+impl<'tcx, 'l> ArmVisitor<'tcx, 'l> {\n     fn same_mutex(&self, cx: &LateContext<'_>, op_mutex: &Expr<'_>) -> bool {\n-        if let Some(arm_mutex) = self.found_mutex {\n-            SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex)\n-        } else {\n-            false\n-        }\n+        self.found_mutex\n+            .map_or(false, |arm_mutex| SpanlessEq::new(cx).eq_expr(op_mutex, arm_mutex))\n     }\n }\n "}, {"sha": "1b09328ceabb004275f41c031f913d132154ec64", "filename": "src/tools/clippy/clippy_lints/src/len_zero.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flen_zero.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -302,16 +302,12 @@ fn has_is_empty(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n \n     let ty = &walk_ptrs_ty(cx.tables().expr_ty(expr));\n     match ty.kind {\n-        ty::Dynamic(ref tt, ..) => {\n-            if let Some(principal) = tt.principal() {\n-                cx.tcx\n-                    .associated_items(principal.def_id())\n-                    .in_definition_order()\n-                    .any(|item| is_is_empty(cx, &item))\n-            } else {\n-                false\n-            }\n-        },\n+        ty::Dynamic(ref tt, ..) => tt.principal().map_or(false, |principal| {\n+            cx.tcx\n+                .associated_items(principal.def_id())\n+                .in_definition_order()\n+                .any(|item| is_is_empty(cx, &item))\n+        }),\n         ty::Projection(ref proj) => has_is_empty_impl(cx, proj.item_def_id),\n         ty::Adt(id, _) => has_is_empty_impl(cx, id.did),\n         ty::Array(..) | ty::Slice(..) | ty::Str => true,"}, {"sha": "fa560ffb980c82407d748018b6b12717c7572267", "filename": "src/tools/clippy/clippy_lints/src/let_and_return.rs", "status": "modified", "additions": 2, "deletions": 19, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_and_return.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,6 +1,5 @@\n use if_chain::if_chain;\n use rustc_errors::Applicability;\n-use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc_hir::{Block, Expr, ExprKind, PatKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n@@ -9,7 +8,7 @@ use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::subst::GenericArgKind;\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n \n-use crate::utils::{in_macro, match_qpath, snippet_opt, span_lint_and_then};\n+use crate::utils::{fn_def_id, in_macro, match_qpath, snippet_opt, span_lint_and_then};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for `let`-bindings, which are subsequently\n@@ -97,22 +96,6 @@ struct BorrowVisitor<'a, 'tcx> {\n     borrows: bool,\n }\n \n-impl BorrowVisitor<'_, '_> {\n-    fn fn_def_id(&self, expr: &Expr<'_>) -> Option<DefId> {\n-        match &expr.kind {\n-            ExprKind::MethodCall(..) => self.cx.tables().type_dependent_def_id(expr.hir_id),\n-            ExprKind::Call(\n-                Expr {\n-                    kind: ExprKind::Path(qpath),\n-                    ..\n-                },\n-                ..,\n-            ) => self.cx.qpath_res(qpath, expr.hir_id).opt_def_id(),\n-            _ => None,\n-        }\n-    }\n-}\n-\n impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -121,7 +104,7 @@ impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n             return;\n         }\n \n-        if let Some(def_id) = self.fn_def_id(expr) {\n+        if let Some(def_id) = fn_def_id(self.cx, expr) {\n             self.borrows = self\n                 .cx\n                 .tcx"}, {"sha": "32e79317f82254119bf9b3075ef15f3b827f3ea7", "filename": "src/tools/clippy/clippy_lints/src/lib.rs", "status": "modified", "additions": 36, "deletions": 13, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flib.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -229,6 +229,7 @@ mod main_recursion;\n mod manual_async_fn;\n mod manual_non_exhaustive;\n mod map_clone;\n+mod map_identity;\n mod map_unit_fn;\n mod match_on_vec_items;\n mod matches;\n@@ -263,22 +264,24 @@ mod non_copy_const;\n mod non_expressive_names;\n mod open_options;\n mod option_env_unwrap;\n+mod option_if_let_else;\n mod overflow_check_conditional;\n mod panic_unimplemented;\n mod partialeq_ne_impl;\n mod path_buf_push_overwrite;\n+mod pattern_type_mismatch;\n mod precedence;\n mod ptr;\n mod ptr_offset_with_cast;\n mod question_mark;\n mod ranges;\n mod redundant_clone;\n mod redundant_field_names;\n-mod redundant_pattern_matching;\n mod redundant_pub_crate;\n mod redundant_static_lifetimes;\n mod reference;\n mod regex;\n+mod repeat_once;\n mod returns;\n mod serde_api;\n mod shadow;\n@@ -459,7 +462,11 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     );\n     store.register_removed(\n         \"clippy::replace_consts\",\n-        \"associated-constants `MIN`/`MAX` of integers are prefer to `{min,max}_value()` and module constants\",\n+        \"associated-constants `MIN`/`MAX` of integers are prefered to `{min,max}_value()` and module constants\",\n+    );\n+    store.register_removed(\n+        \"clippy::regex_macro\",\n+        \"the regex! macro has been removed from the regex crate in 2018\",\n     );\n     // end deprecated lints, do not remove this comment, it\u2019s used in `update_lints`\n \n@@ -473,6 +480,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &assign_ops::ASSIGN_OP_PATTERN,\n         &assign_ops::MISREFACTORED_ASSIGN_OP,\n         &atomic_ordering::INVALID_ATOMIC_ORDERING,\n+        &attrs::BLANKET_CLIPPY_RESTRICTION_LINTS,\n         &attrs::DEPRECATED_CFG_ATTR,\n         &attrs::DEPRECATED_SEMVER,\n         &attrs::EMPTY_LINE_AFTER_OUTER_ATTR,\n@@ -608,17 +616,20 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &manual_async_fn::MANUAL_ASYNC_FN,\n         &manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE,\n         &map_clone::MAP_CLONE,\n+        &map_identity::MAP_IDENTITY,\n         &map_unit_fn::OPTION_MAP_UNIT_FN,\n         &map_unit_fn::RESULT_MAP_UNIT_FN,\n         &match_on_vec_items::MATCH_ON_VEC_ITEMS,\n         &matches::INFALLIBLE_DESTRUCTURING_MATCH,\n         &matches::MATCH_AS_REF,\n         &matches::MATCH_BOOL,\n+        &matches::MATCH_LIKE_MATCHES_MACRO,\n         &matches::MATCH_OVERLAPPING_ARM,\n         &matches::MATCH_REF_PATS,\n         &matches::MATCH_SINGLE_BINDING,\n         &matches::MATCH_WILDCARD_FOR_SINGLE_VARIANTS,\n         &matches::MATCH_WILD_ERR_ARM,\n+        &matches::REDUNDANT_PATTERN_MATCHING,\n         &matches::REST_PAT_IN_FULLY_BOUND_STRUCTS,\n         &matches::SINGLE_MATCH,\n         &matches::SINGLE_MATCH_ELSE,\n@@ -726,6 +737,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &non_expressive_names::SIMILAR_NAMES,\n         &open_options::NONSENSICAL_OPEN_OPTIONS,\n         &option_env_unwrap::OPTION_ENV_UNWRAP,\n+        &option_if_let_else::OPTION_IF_LET_ELSE,\n         &overflow_check_conditional::OVERFLOW_CHECK_CONDITIONAL,\n         &panic_unimplemented::PANIC,\n         &panic_unimplemented::PANIC_PARAMS,\n@@ -734,6 +746,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &panic_unimplemented::UNREACHABLE,\n         &partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n         &path_buf_push_overwrite::PATH_BUF_PUSH_OVERWRITE,\n+        &pattern_type_mismatch::PATTERN_TYPE_MISMATCH,\n         &precedence::PRECEDENCE,\n         &ptr::CMP_NULL,\n         &ptr::MUT_FROM_REF,\n@@ -746,14 +759,13 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         &ranges::REVERSED_EMPTY_RANGES,\n         &redundant_clone::REDUNDANT_CLONE,\n         &redundant_field_names::REDUNDANT_FIELD_NAMES,\n-        &redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING,\n         &redundant_pub_crate::REDUNDANT_PUB_CRATE,\n         &redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES,\n         &reference::DEREF_ADDROF,\n         &reference::REF_IN_DEREF,\n         &regex::INVALID_REGEX,\n-        &regex::REGEX_MACRO,\n         &regex::TRIVIAL_REGEX,\n+        &repeat_once::REPEAT_ONCE,\n         &returns::NEEDLESS_RETURN,\n         &returns::UNUSED_UNIT,\n         &serde_api::SERDE_API_MISUSE,\n@@ -946,7 +958,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box missing_doc::MissingDoc::new());\n     store.register_late_pass(|| box missing_inline::MissingInline);\n     store.register_late_pass(|| box if_let_some_result::OkIfLet);\n-    store.register_late_pass(|| box redundant_pattern_matching::RedundantPatternMatching);\n     store.register_late_pass(|| box partialeq_ne_impl::PartialEqNeImpl);\n     store.register_late_pass(|| box unused_io_amount::UnusedIoAmount);\n     let enum_variant_size_threshold = conf.enum_variant_size_threshold;\n@@ -990,7 +1001,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box checked_conversions::CheckedConversions);\n     store.register_late_pass(|| box integer_division::IntegerDivision);\n     store.register_late_pass(|| box inherent_to_string::InherentToString);\n-    store.register_late_pass(|| box trait_bounds::TraitBounds);\n+    let max_trait_bounds = conf.max_trait_bounds;\n+    store.register_late_pass(move || box trait_bounds::TraitBounds::new(max_trait_bounds));\n     store.register_late_pass(|| box comparison_chain::ComparisonChain);\n     store.register_late_pass(|| box mut_key::MutableKeyType);\n     store.register_late_pass(|| box modulo_arithmetic::ModuloArithmetic);\n@@ -1027,7 +1039,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     let array_size_threshold = conf.array_size_threshold;\n     store.register_late_pass(move || box large_stack_arrays::LargeStackArrays::new(array_size_threshold));\n     store.register_late_pass(move || box large_const_arrays::LargeConstArrays::new(array_size_threshold));\n-    store.register_late_pass(move || box floating_point_arithmetic::FloatingPointArithmetic);\n+    store.register_late_pass(|| box floating_point_arithmetic::FloatingPointArithmetic);\n     store.register_early_pass(|| box as_conversions::AsConversions);\n     store.register_early_pass(|| box utils::internal_lints::ProduceIce);\n     store.register_late_pass(|| box let_underscore::LetUnderscore);\n@@ -1043,6 +1055,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n     store.register_late_pass(|| box dereference::Dereferencing);\n+    store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box utils::internal_lints::CollapsibleCalls);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);\n@@ -1057,6 +1070,9 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     });\n     store.register_early_pass(|| box unnested_or_patterns::UnnestedOrPatterns);\n     store.register_late_pass(|| box macro_use::MacroUseImports::default());\n+    store.register_late_pass(|| box map_identity::MapIdentity);\n+    store.register_late_pass(|| box pattern_type_mismatch::PatternTypeMismatch);\n+    store.register_late_pass(|| box repeat_once::RepeatOnce);\n \n     store.register_group(true, \"clippy::restriction\", Some(\"clippy_restriction\"), vec![\n         LintId::of(&arithmetic::FLOAT_ARITHMETIC),\n@@ -1090,6 +1106,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&panic_unimplemented::TODO),\n         LintId::of(&panic_unimplemented::UNIMPLEMENTED),\n         LintId::of(&panic_unimplemented::UNREACHABLE),\n+        LintId::of(&pattern_type_mismatch::PATTERN_TYPE_MISMATCH),\n         LintId::of(&shadow::SHADOW_REUSE),\n         LintId::of(&shadow::SHADOW_SAME),\n         LintId::of(&strings::STRING_ADD),\n@@ -1146,6 +1163,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&needless_continue::NEEDLESS_CONTINUE),\n         LintId::of(&needless_pass_by_value::NEEDLESS_PASS_BY_VALUE),\n         LintId::of(&non_expressive_names::SIMILAR_NAMES),\n+        LintId::of(&option_if_let_else::OPTION_IF_LET_ELSE),\n+        LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_PLUS_ONE),\n         LintId::of(&shadow::SHADOW_UNRELATED),\n         LintId::of(&strings::STRING_ADD_ASSIGN),\n@@ -1186,6 +1205,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&assign_ops::ASSIGN_OP_PATTERN),\n         LintId::of(&assign_ops::MISREFACTORED_ASSIGN_OP),\n         LintId::of(&atomic_ordering::INVALID_ATOMIC_ORDERING),\n+        LintId::of(&attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(&attrs::DEPRECATED_CFG_ATTR),\n         LintId::of(&attrs::DEPRECATED_SEMVER),\n         LintId::of(&attrs::MISMATCHED_TARGET_OS),\n@@ -1273,13 +1293,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_async_fn::MANUAL_ASYNC_FN),\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n+        LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n         LintId::of(&matches::MATCH_AS_REF),\n+        LintId::of(&matches::MATCH_LIKE_MATCHES_MACRO),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n         LintId::of(&matches::MATCH_SINGLE_BINDING),\n+        LintId::of(&matches::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&matches::WILDCARD_IN_OR_PATTERNS),\n         LintId::of(&mem_discriminant::MEM_DISCRIMINANT_NON_ENUM),\n@@ -1364,18 +1387,16 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::PTR_ARG),\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n         LintId::of(&question_mark::QUESTION_MARK),\n-        LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n         LintId::of(&ranges::REVERSED_EMPTY_RANGES),\n         LintId::of(&redundant_clone::REDUNDANT_CLONE),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n-        LintId::of(&redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n         LintId::of(&reference::DEREF_ADDROF),\n         LintId::of(&reference::REF_IN_DEREF),\n         LintId::of(&regex::INVALID_REGEX),\n-        LintId::of(&regex::REGEX_MACRO),\n         LintId::of(&regex::TRIVIAL_REGEX),\n+        LintId::of(&repeat_once::REPEAT_ONCE),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n         LintId::of(&serde_api::SERDE_API_MISUSE),\n@@ -1437,6 +1458,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_group(true, \"clippy::style\", Some(\"clippy_style\"), vec![\n         LintId::of(&assertions_on_constants::ASSERTIONS_ON_CONSTANTS),\n         LintId::of(&assign_ops::ASSIGN_OP_PATTERN),\n+        LintId::of(&attrs::BLANKET_CLIPPY_RESTRICTION_LINTS),\n         LintId::of(&attrs::UNKNOWN_CLIPPY_LINTS),\n         LintId::of(&bit_mask::VERBOSE_BIT_MASK),\n         LintId::of(&blacklisted_name::BLACKLISTED_NAME),\n@@ -1470,8 +1492,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&manual_non_exhaustive::MANUAL_NON_EXHAUSTIVE),\n         LintId::of(&map_clone::MAP_CLONE),\n         LintId::of(&matches::INFALLIBLE_DESTRUCTURING_MATCH),\n+        LintId::of(&matches::MATCH_LIKE_MATCHES_MACRO),\n         LintId::of(&matches::MATCH_OVERLAPPING_ARM),\n         LintId::of(&matches::MATCH_REF_PATS),\n+        LintId::of(&matches::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&matches::SINGLE_MATCH),\n         LintId::of(&mem_replace::MEM_REPLACE_OPTION_WITH_NONE),\n         LintId::of(&mem_replace::MEM_REPLACE_WITH_DEFAULT),\n@@ -1508,9 +1532,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&ptr::PTR_ARG),\n         LintId::of(&question_mark::QUESTION_MARK),\n         LintId::of(&redundant_field_names::REDUNDANT_FIELD_NAMES),\n-        LintId::of(&redundant_pattern_matching::REDUNDANT_PATTERN_MATCHING),\n         LintId::of(&redundant_static_lifetimes::REDUNDANT_STATIC_LIFETIMES),\n-        LintId::of(&regex::REGEX_MACRO),\n         LintId::of(&regex::TRIVIAL_REGEX),\n         LintId::of(&returns::NEEDLESS_RETURN),\n         LintId::of(&returns::UNUSED_UNIT),\n@@ -1550,6 +1572,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&loops::EXPLICIT_COUNTER_LOOP),\n         LintId::of(&loops::MUT_RANGE_BOUND),\n         LintId::of(&loops::WHILE_LET_LOOP),\n+        LintId::of(&map_identity::MAP_IDENTITY),\n         LintId::of(&map_unit_fn::OPTION_MAP_UNIT_FN),\n         LintId::of(&map_unit_fn::RESULT_MAP_UNIT_FN),\n         LintId::of(&matches::MATCH_AS_REF),\n@@ -1580,10 +1603,10 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n         LintId::of(&partialeq_ne_impl::PARTIALEQ_NE_IMPL),\n         LintId::of(&precedence::PRECEDENCE),\n         LintId::of(&ptr_offset_with_cast::PTR_OFFSET_WITH_CAST),\n-        LintId::of(&ranges::RANGE_MINUS_ONE),\n         LintId::of(&ranges::RANGE_ZIP_WITH_LEN),\n         LintId::of(&reference::DEREF_ADDROF),\n         LintId::of(&reference::REF_IN_DEREF),\n+        LintId::of(&repeat_once::REPEAT_ONCE),\n         LintId::of(&swap::MANUAL_SWAP),\n         LintId::of(&temporary_assignment::TEMPORARY_ASSIGNMENT),\n         LintId::of(&transmute::CROSSPOINTER_TRANSMUTE),"}, {"sha": "168f9f953e4d899b70174f8db6d06b55610f1a09", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -129,10 +129,10 @@ fn check_fn_inner<'tcx>(\n     }\n \n     let mut bounds_lts = Vec::new();\n-    let types = generics.params.iter().filter(|param| match param.kind {\n-        GenericParamKind::Type { .. } => true,\n-        _ => false,\n-    });\n+    let types = generics\n+        .params\n+        .iter()\n+        .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n         for bound in typ.bounds {\n             let mut visitor = RefVisitor::new(cx);\n@@ -337,10 +337,10 @@ impl<'a, 'tcx> RefVisitor<'a, 'tcx> {\n     fn collect_anonymous_lifetimes(&mut self, qpath: &QPath<'_>, ty: &Ty<'_>) {\n         if let Some(ref last_path_segment) = last_path_segment(qpath).args {\n             if !last_path_segment.parenthesized\n-                && !last_path_segment.args.iter().any(|arg| match arg {\n-                    GenericArg::Lifetime(_) => true,\n-                    _ => false,\n-                })\n+                && !last_path_segment\n+                    .args\n+                    .iter()\n+                    .any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n             {\n                 let hir_id = ty.hir_id;\n                 match self.cx.qpath_res(qpath, hir_id) {"}, {"sha": "a36fdca5d5de6a5816d8ff369501fad9c651b3dd", "filename": "src/tools/clippy/clippy_lints/src/literal_representation.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fliteral_representation.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -264,10 +264,13 @@ impl LiteralDigitGrouping {\n \n         let (part, mistyped_suffixes, missing_char) = if let Some((_, exponent)) = &mut num_lit.exponent {\n             (exponent, &[\"32\", \"64\"][..], 'f')\n-        } else if let Some(fraction) = &mut num_lit.fraction {\n-            (fraction, &[\"32\", \"64\"][..], 'f')\n         } else {\n-            (&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i')\n+            num_lit\n+                .fraction\n+                .as_mut()\n+                .map_or((&mut num_lit.integer, &[\"8\", \"16\", \"32\", \"64\"][..], 'i'), |fraction| {\n+                    (fraction, &[\"32\", \"64\"][..], 'f')\n+                })\n         };\n \n         let mut split = part.rsplit('_');"}, {"sha": "396bb6591090321e80c534f2903f68d88b4b3b69", "filename": "src/tools/clippy/clippy_lints/src/loops.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -686,13 +686,9 @@ fn never_loop_expr(expr: &Expr<'_>, main_loop_id: HirId) -> NeverLoopResult {\n                 NeverLoopResult::AlwaysBreak\n             }\n         },\n-        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => {\n-            if let Some(ref e) = *e {\n-                combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n-            } else {\n-                NeverLoopResult::AlwaysBreak\n-            }\n-        },\n+        ExprKind::Break(_, ref e) | ExprKind::Ret(ref e) => e.as_ref().map_or(NeverLoopResult::AlwaysBreak, |e| {\n+            combine_seq(never_loop_expr(e, main_loop_id), NeverLoopResult::AlwaysBreak)\n+        }),\n         ExprKind::InlineAsm(ref asm) => asm\n             .operands\n             .iter()\n@@ -1881,13 +1877,9 @@ fn is_ref_iterable_type(cx: &LateContext<'_>, e: &Expr<'_>) -> bool {\n fn is_iterable_array<'tcx>(ty: Ty<'tcx>, cx: &LateContext<'tcx>) -> bool {\n     // IntoIterator is currently only implemented for array sizes <= 32 in rustc\n     match ty.kind {\n-        ty::Array(_, n) => {\n-            if let Some(val) = n.try_eval_usize(cx.tcx, cx.param_env) {\n-                (0..=32).contains(&val)\n-            } else {\n-                false\n-            }\n-        },\n+        ty::Array(_, n) => n\n+            .try_eval_usize(cx.tcx, cx.param_env)\n+            .map_or(false, |val| (0..=32).contains(&val)),\n         _ => false,\n     }\n }\n@@ -1899,11 +1891,7 @@ fn extract_expr_from_first_stmt<'tcx>(block: &Block<'tcx>) -> Option<&'tcx Expr<\n         return None;\n     }\n     if let StmtKind::Local(ref local) = block.stmts[0].kind {\n-        if let Some(expr) = local.init {\n-            Some(expr)\n-        } else {\n-            None\n-        }\n+        local.init //.map(|expr| expr)\n     } else {\n         None\n     }\n@@ -2023,15 +2011,13 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n                 if let PatKind::Binding(.., ident, _) = local.pat.kind {\n                     self.name = Some(ident.name);\n \n-                    self.state = if let Some(ref init) = local.init {\n+                    self.state = local.init.as_ref().map_or(VarState::Declared, |init| {\n                         if is_integer_const(&self.cx, init, 0) {\n                             VarState::Warn\n                         } else {\n                             VarState::Declared\n                         }\n-                    } else {\n-                        VarState::Declared\n-                    }\n+                    })\n                 }\n             }\n         }\n@@ -2105,17 +2091,11 @@ fn var_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<HirId> {\n }\n \n fn is_loop(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Loop(..) => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Loop(..))\n }\n \n fn is_conditional(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Match(..) => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Match(..))\n }\n \n fn is_nested(cx: &LateContext<'_>, match_expr: &Expr<'_>, iter_expr: &Expr<'_>) -> bool {"}, {"sha": "24ec78c884647951dcb82849f8ffff9f2bc24800", "filename": "src/tools/clippy/clippy_lints/src/map_identity.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmap_identity.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,126 @@\n+use crate::utils::{\n+    is_adjusted, is_type_diagnostic_item, match_path, match_trait_method, match_var, paths, remove_blocks,\n+    span_lint_and_sugg,\n+};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Body, Expr, ExprKind, Pat, PatKind, QPath, StmtKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for instances of `map(f)` where `f` is the identity function.\n+    ///\n+    /// **Why is this bad?** It can be written more concisely without the call to `map`.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// let x = [1, 2, 3];\n+    /// let y: Vec<_> = x.iter().map(|x| x).map(|x| 2*x).collect();\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// let x = [1, 2, 3];\n+    /// let y: Vec<_> = x.iter().map(|x| 2*x).collect();\n+    /// ```\n+    pub MAP_IDENTITY,\n+    complexity,\n+    \"using iterator.map(|x| x)\"\n+}\n+\n+declare_lint_pass!(MapIdentity => [MAP_IDENTITY]);\n+\n+impl<'tcx> LateLintPass<'tcx> for MapIdentity {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n+        if expr.span.from_expansion() {\n+            return;\n+        }\n+\n+        if_chain! {\n+            if let Some([caller, func]) = get_map_argument(cx, expr);\n+            if is_expr_identity_function(cx, func);\n+            then {\n+                span_lint_and_sugg(\n+                    cx,\n+                    MAP_IDENTITY,\n+                    expr.span.trim_start(caller.span).unwrap(),\n+                    \"unnecessary map of the identity function\",\n+                    \"remove the call to `map`\",\n+                    String::new(),\n+                    Applicability::MachineApplicable\n+                )\n+            }\n+        }\n+    }\n+}\n+\n+/// Returns the arguments passed into map() if the expression is a method call to\n+/// map(). Otherwise, returns None.\n+fn get_map_argument<'a>(cx: &LateContext<'_>, expr: &'a Expr<'a>) -> Option<&'a [Expr<'a>]> {\n+    if_chain! {\n+        if let ExprKind::MethodCall(ref method, _, ref args, _) = expr.kind;\n+        if args.len() == 2 && method.ident.as_str() == \"map\";\n+        let caller_ty = cx.tables().expr_ty(&args[0]);\n+        if match_trait_method(cx, expr, &paths::ITERATOR)\n+            || is_type_diagnostic_item(cx, caller_ty, sym!(result_type))\n+            || is_type_diagnostic_item(cx, caller_ty, sym!(option_type));\n+        then {\n+            Some(args)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Checks if an expression represents the identity function\n+/// Only examines closures and `std::convert::identity`\n+fn is_expr_identity_function(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    match expr.kind {\n+        ExprKind::Closure(_, _, body_id, _, _) => is_body_identity_function(cx, cx.tcx.hir().body(body_id)),\n+        ExprKind::Path(QPath::Resolved(_, ref path)) => match_path(path, &paths::STD_CONVERT_IDENTITY),\n+        _ => false,\n+    }\n+}\n+\n+/// Checks if a function's body represents the identity function\n+/// Looks for bodies of the form `|x| x`, `|x| return x`, `|x| { return x }` or `|x| {\n+/// return x; }`\n+fn is_body_identity_function(cx: &LateContext<'_>, func: &Body<'_>) -> bool {\n+    let params = func.params;\n+    let body = remove_blocks(&func.value);\n+\n+    // if there's less/more than one parameter, then it is not the identity function\n+    if params.len() != 1 {\n+        return false;\n+    }\n+\n+    match body.kind {\n+        ExprKind::Path(QPath::Resolved(None, _)) => match_expr_param(cx, body, params[0].pat),\n+        ExprKind::Ret(Some(ref ret_val)) => match_expr_param(cx, ret_val, params[0].pat),\n+        ExprKind::Block(ref block, _) => {\n+            if_chain! {\n+                if block.stmts.len() == 1;\n+                if let StmtKind::Semi(ref expr) | StmtKind::Expr(ref expr) = block.stmts[0].kind;\n+                if let ExprKind::Ret(Some(ref ret_val)) = expr.kind;\n+                then {\n+                    match_expr_param(cx, ret_val, params[0].pat)\n+                } else {\n+                    false\n+                }\n+            }\n+        },\n+        _ => false,\n+    }\n+}\n+\n+/// Returns true iff an expression returns the same thing as a parameter's pattern\n+fn match_expr_param(cx: &LateContext<'_>, expr: &Expr<'_>, pat: &Pat<'_>) -> bool {\n+    if let PatKind::Binding(_, _, ident, _) = pat.kind {\n+        match_var(expr, ident.name) && !(cx.tables().hir_owner == expr.hir_id.owner && is_adjusted(cx, expr))\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "bd474c208070cb516d9b5ff3305272cc91c8f69d", "filename": "src/tools/clippy/clippy_lints/src/matches.rs", "status": "modified", "additions": 390, "deletions": 22, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmatches.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -13,14 +13,14 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::def::CtorKind;\n use rustc_hir::{\n-    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Local, MatchSource, Mutability, Node, Pat, PatKind,\n-    QPath, RangeEnd,\n+    Arm, BindingAnnotation, Block, BorrowKind, Expr, ExprKind, Guard, Local, MatchSource, Mutability, Node, Pat,\n+    PatKind, QPath, RangeEnd,\n };\n use rustc_lint::{LateContext, LateLintPass, LintContext};\n use rustc_middle::lint::in_external_macro;\n use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n-use rustc_span::source_map::Span;\n+use rustc_span::source_map::{Span, Spanned};\n use std::cmp::Ordering;\n use std::collections::Bound;\n \n@@ -409,6 +409,74 @@ declare_clippy_lint! {\n     \"a match on a struct that binds all fields but still uses the wildcard pattern\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Lint for redundant pattern matching over `Result` or\n+    /// `Option`\n+    ///\n+    /// **Why is this bad?** It's more concise and clear to just use the proper\n+    /// utility function\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n+    /// if let Err(_) = Err::<i32, i32>(42) {}\n+    /// if let None = None::<()> {}\n+    /// if let Some(_) = Some(42) {}\n+    /// match Ok::<i32, i32>(42) {\n+    ///     Ok(_) => true,\n+    ///     Err(_) => false,\n+    /// };\n+    /// ```\n+    ///\n+    /// The more idiomatic use would be:\n+    ///\n+    /// ```rust\n+    /// if Ok::<i32, i32>(42).is_ok() {}\n+    /// if Err::<i32, i32>(42).is_err() {}\n+    /// if None::<()>.is_none() {}\n+    /// if Some(42).is_some() {}\n+    /// Ok::<i32, i32>(42).is_ok();\n+    /// ```\n+    pub REDUNDANT_PATTERN_MATCHING,\n+    style,\n+    \"use the proper utility function avoiding an `if let`\"\n+}\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for `match`  or `if let` expressions producing a\n+    /// `bool` that could be written using `matches!`\n+    ///\n+    /// **Why is this bad?** Readability and needless complexity.\n+    ///\n+    /// **Known problems:** None\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// let x = Some(5);\n+    ///\n+    /// // Bad\n+    /// let a = match x {\n+    ///     Some(0) => true,\n+    ///     _ => false,\n+    /// };\n+    ///\n+    /// let a = if let Some(0) = x {\n+    ///     true\n+    /// } else {\n+    ///     false\n+    /// };\n+    ///\n+    /// // Good\n+    /// let a = matches!(x, Some(0));\n+    /// ```\n+    pub MATCH_LIKE_MATCHES_MACRO,\n+    style,\n+    \"a match that could be written with the matches! macro\"\n+}\n+\n #[derive(Default)]\n pub struct Matches {\n     infallible_destructuring_match_linted: bool,\n@@ -427,14 +495,20 @@ impl_lint_pass!(Matches => [\n     WILDCARD_IN_OR_PATTERNS,\n     MATCH_SINGLE_BINDING,\n     INFALLIBLE_DESTRUCTURING_MATCH,\n-    REST_PAT_IN_FULLY_BOUND_STRUCTS\n+    REST_PAT_IN_FULLY_BOUND_STRUCTS,\n+    REDUNDANT_PATTERN_MATCHING,\n+    MATCH_LIKE_MATCHES_MACRO\n ]);\n \n impl<'tcx> LateLintPass<'tcx> for Matches {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if in_external_macro(cx.sess(), expr.span) {\n             return;\n         }\n+\n+        redundant_pattern_match::check(cx, expr);\n+        check_match_like_matches(cx, expr);\n+\n         if let ExprKind::Match(ref ex, ref arms, MatchSource::Normal) = expr.kind {\n             check_single_match(cx, ex, arms, expr);\n             check_match_bool(cx, ex, arms, expr);\n@@ -530,16 +604,22 @@ fn check_single_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], exp\n             // the lint noisy in unnecessary situations\n             return;\n         }\n-        let els = remove_blocks(&arms[1].body);\n-        let els = if is_unit_expr(els) {\n+        let els = arms[1].body;\n+        let els = if is_unit_expr(remove_blocks(els)) {\n             None\n-        } else if let ExprKind::Block(_, _) = els.kind {\n-            // matches with blocks that contain statements are prettier as `if let + else`\n-            Some(els)\n+        } else if let ExprKind::Block(Block { stmts, expr: block_expr, .. }, _) = els.kind {\n+            if stmts.len() == 1 && block_expr.is_none() || stmts.is_empty() && block_expr.is_some() {\n+                // single statement/expr \"else\" block, don't lint\n+                return;\n+            } else {\n+                // block with 2+ statements or 1 expr and 1+ statement\n+                Some(els)\n+            }\n         } else {\n-            // allow match arms with just expressions\n-            return;\n+            // not a block, don't lint\n+            return; \n         };\n+\n         let ty = cx.tables().expr_ty(ex);\n         if ty.kind != ty::Bool || is_allowed(cx, MATCH_BOOL, ex.hir_id) {\n             check_single_match_single_pattern(cx, ex, arms, expr, els);\n@@ -802,13 +882,8 @@ fn check_wild_enum_match(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>])\n                     // Some simple checks for exhaustive patterns.\n                     // There is a room for improvements to detect more cases,\n                     // but it can be more expensive to do so.\n-                    let is_pattern_exhaustive = |pat: &&Pat<'_>| {\n-                        if let PatKind::Wild | PatKind::Binding(.., None) = pat.kind {\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    };\n+                    let is_pattern_exhaustive =\n+                        |pat: &&Pat<'_>| matches!(pat.kind, PatKind::Wild | PatKind::Binding(.., None));\n                     if patterns.iter().all(is_pattern_exhaustive) {\n                         missing_variants.retain(|e| e.ctor_def_id != Some(p.res.def_id()));\n                     }\n@@ -989,6 +1064,79 @@ fn check_wild_in_or_pats(cx: &LateContext<'_>, arms: &[Arm<'_>]) {\n     }\n }\n \n+/// Lint a `match` or `if let .. { .. } else { .. }` expr that could be replaced by `matches!`\n+fn check_match_like_matches<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+    if let ExprKind::Match(ex, arms, ref match_source) = &expr.kind {\n+        match match_source {\n+            MatchSource::Normal => find_matches_sugg(cx, ex, arms, expr, false),\n+            MatchSource::IfLetDesugar { .. } => find_matches_sugg(cx, ex, arms, expr, true),\n+            _ => return,\n+        }\n+    }\n+}\n+\n+/// Lint a `match` or desugared `if let` for replacement by `matches!`\n+fn find_matches_sugg(cx: &LateContext<'_>, ex: &Expr<'_>, arms: &[Arm<'_>], expr: &Expr<'_>, desugared: bool) {\n+    if_chain! {\n+        if arms.len() == 2;\n+        if cx.tables().expr_ty(expr).is_bool();\n+        if is_wild(&arms[1].pat);\n+        if let Some(first) = find_bool_lit(&arms[0].body.kind, desugared);\n+        if let Some(second) = find_bool_lit(&arms[1].body.kind, desugared);\n+        if first != second;\n+        then {\n+            let mut applicability = Applicability::MachineApplicable;\n+\n+            let pat_and_guard = if let Some(Guard::If(g)) = arms[0].guard {\n+                format!(\"{} if {}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability), snippet_with_applicability(cx, g.span, \"..\", &mut applicability))\n+            } else {\n+                format!(\"{}\", snippet_with_applicability(cx, arms[0].pat.span, \"..\", &mut applicability))\n+            };\n+            span_lint_and_sugg(\n+                cx,\n+                MATCH_LIKE_MATCHES_MACRO,\n+                expr.span,\n+                &format!(\"{} expression looks like `matches!` macro\", if desugared { \"if let .. else\" } else { \"match\" }),\n+                \"try this\",\n+                format!(\n+                    \"{}matches!({}, {})\",\n+                    if first { \"\" } else { \"!\" },\n+                    snippet_with_applicability(cx, ex.span, \"..\", &mut applicability),\n+                    pat_and_guard,\n+                ),\n+                applicability,\n+            )\n+        }\n+    }\n+}\n+\n+/// Extract a `bool` or `{ bool }`\n+fn find_bool_lit(ex: &ExprKind<'_>, desugared: bool) -> Option<bool> {\n+    match ex {\n+        ExprKind::Lit(Spanned {\n+            node: LitKind::Bool(b), ..\n+        }) => Some(*b),\n+        ExprKind::Block(\n+            rustc_hir::Block {\n+                stmts: &[],\n+                expr: Some(exp),\n+                ..\n+            },\n+            _,\n+        ) if desugared => {\n+            if let ExprKind::Lit(Spanned {\n+                node: LitKind::Bool(b), ..\n+            }) = exp.kind\n+            {\n+                Some(b)\n+            } else {\n+                None\n+            }\n+        },\n+        _ => None,\n+    }\n+}\n+\n fn check_match_single_binding<'a>(cx: &LateContext<'a>, ex: &Expr<'a>, arms: &[Arm<'_>], expr: &Expr<'_>) {\n     if in_macro(expr.span) || arms.len() != 1 || is_refutable(cx, arms[0].pat) {\n         return;\n@@ -1179,10 +1327,7 @@ fn is_unit_expr(expr: &Expr<'_>) -> bool {\n \n // Checks if arm has the form `None => None`\n fn is_none_arm(arm: &Arm<'_>) -> bool {\n-    match arm.pat.kind {\n-        PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE) => true,\n-        _ => false,\n-    }\n+    matches!(arm.pat.kind, PatKind::Path(ref path) if match_qpath(path, &paths::OPTION_NONE))\n }\n \n // Checks if arm has the form `Some(ref v) => Some(v)` (checks for `ref` and `ref mut`)\n@@ -1293,6 +1438,229 @@ where\n     None\n }\n \n+mod redundant_pattern_match {\n+    use super::REDUNDANT_PATTERN_MATCHING;\n+    use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n+    use if_chain::if_chain;\n+    use rustc_ast::ast::LitKind;\n+    use rustc_errors::Applicability;\n+    use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n+    use rustc_lint::LateContext;\n+    use rustc_middle::ty;\n+    use rustc_mir::const_eval::is_const_fn;\n+    use rustc_span::source_map::Symbol;\n+\n+    pub fn check<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n+            match match_source {\n+                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n+                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n+                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n+                _ => {},\n+            }\n+        }\n+    }\n+\n+    fn find_sugg_for_if_let<'tcx>(\n+        cx: &LateContext<'tcx>,\n+        expr: &'tcx Expr<'_>,\n+        op: &Expr<'_>,\n+        arms: &[Arm<'_>],\n+        keyword: &'static str,\n+    ) {\n+        fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n+            if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n+                return Some(\"is_ok()\");\n+            }\n+            if match_qpath(path, &paths::RESULT_ERR) && can_suggest(cx, hir_id, sym!(result_type), \"is_err\") {\n+                return Some(\"is_err()\");\n+            }\n+            if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n+                return Some(\"is_some()\");\n+            }\n+            if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n+                return Some(\"is_none()\");\n+            }\n+            None\n+        }\n+\n+        let hir_id = expr.hir_id;\n+        let good_method = match arms[0].pat.kind {\n+            PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n+                if let PatKind::Wild = patterns[0].kind {\n+                    find_suggestion(cx, hir_id, path)\n+                } else {\n+                    None\n+                }\n+            },\n+            PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n+            _ => None,\n+        };\n+        let good_method = match good_method {\n+            Some(method) => method,\n+            None => return,\n+        };\n+\n+        // check that `while_let_on_iterator` lint does not trigger\n+        if_chain! {\n+            if keyword == \"while\";\n+            if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n+            if method_path.ident.name == sym!(next);\n+            if match_trait_method(cx, op, &paths::ITERATOR);\n+            then {\n+                return;\n+            }\n+        }\n+\n+        span_lint_and_then(\n+            cx,\n+            REDUNDANT_PATTERN_MATCHING,\n+            arms[0].pat.span,\n+            &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+            |diag| {\n+                // while let ... = ... { ... }\n+                // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+                let expr_span = expr.span;\n+\n+                // while let ... = ... { ... }\n+                //                 ^^^\n+                let op_span = op.span.source_callsite();\n+\n+                // while let ... = ... { ... }\n+                // ^^^^^^^^^^^^^^^^^^^\n+                let span = expr_span.until(op_span.shrink_to_hi());\n+                diag.span_suggestion(\n+                    span,\n+                    \"try this\",\n+                    format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n+                    Applicability::MachineApplicable, // snippet\n+                );\n+            },\n+        );\n+    }\n+\n+    fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n+        if arms.len() == 2 {\n+            let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n+\n+            let hir_id = expr.hir_id;\n+            let found_good_method = match node_pair {\n+                (\n+                    PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n+                    PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n+                ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n+                    if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n+                        find_good_method_for_match(\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::RESULT_OK,\n+                            &paths::RESULT_ERR,\n+                            \"is_ok()\",\n+                            \"is_err()\",\n+                            || can_suggest(cx, hir_id, sym!(result_type), \"is_ok\"),\n+                            || can_suggest(cx, hir_id, sym!(result_type), \"is_err\"),\n+                        )\n+                    } else {\n+                        None\n+                    }\n+                },\n+                (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n+                | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n+                    if patterns.len() == 1 =>\n+                {\n+                    if let PatKind::Wild = patterns[0].kind {\n+                        find_good_method_for_match(\n+                            arms,\n+                            path_left,\n+                            path_right,\n+                            &paths::OPTION_SOME,\n+                            &paths::OPTION_NONE,\n+                            \"is_some()\",\n+                            \"is_none()\",\n+                            || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n+                            || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n+                        )\n+                    } else {\n+                        None\n+                    }\n+                },\n+                _ => None,\n+            };\n+\n+            if let Some(good_method) = found_good_method {\n+                span_lint_and_then(\n+                    cx,\n+                    REDUNDANT_PATTERN_MATCHING,\n+                    expr.span,\n+                    &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n+                    |diag| {\n+                        let span = expr.span.to(op.span);\n+                        diag.span_suggestion(\n+                            span,\n+                            \"try this\",\n+                            format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n+                            Applicability::MaybeIncorrect, // snippet\n+                        );\n+                    },\n+                );\n+            }\n+        }\n+    }\n+\n+    #[allow(clippy::too_many_arguments)]\n+    fn find_good_method_for_match<'a>(\n+        arms: &[Arm<'_>],\n+        path_left: &QPath<'_>,\n+        path_right: &QPath<'_>,\n+        expected_left: &[&str],\n+        expected_right: &[&str],\n+        should_be_left: &'a str,\n+        should_be_right: &'a str,\n+        can_suggest_left: impl Fn() -> bool,\n+        can_suggest_right: impl Fn() -> bool,\n+    ) -> Option<&'a str> {\n+        let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n+            (&(*arms[0].body).kind, &(*arms[1].body).kind)\n+        } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n+            (&(*arms[1].body).kind, &(*arms[0].body).kind)\n+        } else {\n+            return None;\n+        };\n+\n+        match body_node_pair {\n+            (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n+                (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n+                (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n+                _ => None,\n+            },\n+            _ => None,\n+        }\n+    }\n+\n+    fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n+        if !in_constant(cx, hir_id) {\n+            return true;\n+        }\n+\n+        // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n+        cx.tcx\n+            .get_diagnostic_item(diag_item)\n+            .and_then(|def_id| {\n+                cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n+                    cx.tcx\n+                        .associated_items(*imp)\n+                        .in_definition_order()\n+                        .find_map(|item| match item.kind {\n+                            ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n+                            _ => None,\n+                        })\n+                })\n+            })\n+            .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n+    }\n+}\n+\n #[test]\n fn test_overlapping() {\n     use rustc_span::source_map::DUMMY_SP;"}, {"sha": "4c595029ff7bc32fd81c56a2e7c7c69af1943204", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1844,10 +1844,10 @@ fn lint_expect_fun_call(\n                         ty::Ref(ty::ReStatic, ..)\n                     )\n                 }),\n-            hir::ExprKind::Path(ref p) => match cx.qpath_res(p, arg.hir_id) {\n-                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _) => true,\n-                _ => false,\n-            },\n+            hir::ExprKind::Path(ref p) => matches!(\n+                cx.qpath_res(p, arg.hir_id),\n+                hir::def::Res::Def(hir::def::DefKind::Const | hir::def::DefKind::Static, _)\n+            ),\n             _ => false,\n         }\n     }\n@@ -2028,13 +2028,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n                     .tables()\n                     .expr_adjustments(arg)\n                     .iter()\n-                    .filter(|adj| {\n-                        if let ty::adjustment::Adjust::Deref(_) = adj.kind {\n-                            true\n-                        } else {\n-                            false\n-                        }\n-                    })\n+                    .filter(|adj| matches!(adj.kind, ty::adjustment::Adjust::Deref(_)))\n                     .count();\n                 let derefs: String = iter::repeat('*').take(deref_count).collect();\n                 snip = Some((\"try dereferencing it\", format!(\"{}{}\", derefs, snippet)));\n@@ -2044,7 +2038,7 @@ fn lint_clone_on_copy(cx: &LateContext<'_>, expr: &hir::Expr<'_>, arg: &hir::Exp\n         }\n         span_lint_and_then(cx, CLONE_ON_COPY, expr.span, \"using `clone` on a `Copy` type\", |diag| {\n             if let Some((text, snip)) = snip {\n-                diag.span_suggestion(expr.span, text, snip, Applicability::Unspecified);\n+                diag.span_suggestion(expr.span, text, snip, Applicability::MachineApplicable);\n             }\n         });\n     }\n@@ -2460,13 +2454,9 @@ fn derefs_to_slice<'tcx>(\n             ty::Slice(_) => true,\n             ty::Adt(def, _) if def.is_box() => may_slice(cx, ty.boxed_ty()),\n             ty::Adt(..) => is_type_diagnostic_item(cx, ty, sym!(vec_type)),\n-            ty::Array(_, size) => {\n-                if let Some(size) = size.try_eval_usize(cx.tcx, cx.param_env) {\n-                    size < 32\n-                } else {\n-                    false\n-                }\n-            },\n+            ty::Array(_, size) => size\n+                .try_eval_usize(cx.tcx, cx.param_env)\n+                .map_or(false, |size| size < 32),\n             ty::Ref(_, inner, _) => may_slice(cx, inner),\n             _ => false,\n         }"}, {"sha": "75e123eb5939d971b7c7943485ea569894377ee1", "filename": "src/tools/clippy/clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -77,13 +77,10 @@ fn check_expression<'tcx>(cx: &LateContext<'tcx>, arg_id: hir::HirId, expr: &'tc\n             }\n             (true, true)\n         },\n-        hir::ExprKind::Block(ref block, _) => {\n-            if let Some(expr) = &block.expr {\n-                check_expression(cx, arg_id, &expr)\n-            } else {\n-                (false, false)\n-            }\n-        },\n+        hir::ExprKind::Block(ref block, _) => block\n+            .expr\n+            .as_ref()\n+            .map_or((false, false), |expr| check_expression(cx, arg_id, &expr)),\n         hir::ExprKind::Match(_, arms, _) => {\n             let mut found_mapping = false;\n             let mut found_filtering = false;"}, {"sha": "c8aa98d348927e3f870d7e666df7d653f45b5dff", "filename": "src/tools/clippy/clippy_lints/src/minmax.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fminmax.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -53,7 +53,7 @@ impl<'tcx> LateLintPass<'tcx> for MinMaxPass {\n     }\n }\n \n-#[derive(PartialEq, Eq, Debug)]\n+#[derive(PartialEq, Eq, Debug, Clone, Copy)]\n enum MinMax {\n     Min,\n     Max,\n@@ -86,16 +86,15 @@ fn fetch_const<'a>(cx: &LateContext<'_>, args: &'a [Expr<'a>], m: MinMax) -> Opt\n     if args.len() != 2 {\n         return None;\n     }\n-    if let Some(c) = constant_simple(cx, cx.tables(), &args[0]) {\n-        if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n-            // otherwise ignore\n-            Some((m, c, &args[1]))\n-        } else {\n-            None\n-        }\n-    } else if let Some(c) = constant_simple(cx, cx.tables(), &args[1]) {\n-        Some((m, c, &args[0]))\n-    } else {\n-        None\n-    }\n+    constant_simple(cx, cx.tables(), &args[0]).map_or_else(\n+        || constant_simple(cx, cx.tables(), &args[1]).map(|c| (m, c, &args[0])),\n+        |c| {\n+            if constant_simple(cx, cx.tables(), &args[1]).is_none() {\n+                // otherwise ignore\n+                Some((m, c, &args[1]))\n+            } else {\n+                None\n+            }\n+        },\n+    )\n }"}, {"sha": "400f4b609af7f577833d183d1bf3486ef2224a88", "filename": "src/tools/clippy/clippy_lints/src/misc.rs", "status": "modified", "additions": 64, "deletions": 49, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -3,11 +3,11 @@ use rustc_ast::ast::LitKind;\n use rustc_errors::Applicability;\n use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt, StmtKind, Ty,\n-    TyKind, UnOp,\n+    self as hir, def, BinOpKind, BindingAnnotation, Body, Expr, ExprKind, FnDecl, HirId, Mutability, PatKind, Stmt,\n+    StmtKind, TyKind, UnOp,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::hygiene::DesugaringKind;\n use rustc_span::source_map::{ExpnKind, Span};\n@@ -371,8 +371,8 @@ impl<'tcx> LateLintPass<'tcx> for MiscLints {\n                 if op.is_comparison() {\n                     check_nan(cx, left, expr);\n                     check_nan(cx, right, expr);\n-                    check_to_owned(cx, left, right);\n-                    check_to_owned(cx, right, left);\n+                    check_to_owned(cx, left, right, true);\n+                    check_to_owned(cx, right, left, false);\n                 }\n                 if (op == BinOpKind::Eq || op == BinOpKind::Ne) && (is_float(cx, left) || is_float(cx, right)) {\n                     if is_allowed(cx, left) || is_allowed(cx, right) {\n@@ -570,19 +570,38 @@ fn is_array(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     matches!(&walk_ptrs_ty(cx.tables().expr_ty(expr)).kind, ty::Array(_, _))\n }\n \n-fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n+fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>, left: bool) {\n+    #[derive(Default)]\n+    struct EqImpl {\n+        ty_eq_other: bool,\n+        other_eq_ty: bool,\n+    }\n+\n+    impl EqImpl {\n+        fn is_implemented(&self) -> bool {\n+            self.ty_eq_other || self.other_eq_ty\n+        }\n+    }\n+\n+    fn symmetric_partial_eq<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>, other: Ty<'tcx>) -> Option<EqImpl> {\n+        cx.tcx.lang_items().eq_trait().map(|def_id| EqImpl {\n+            ty_eq_other: implements_trait(cx, ty, def_id, &[other.into()]),\n+            other_eq_ty: implements_trait(cx, other, def_id, &[ty.into()]),\n+        })\n+    }\n+\n     let (arg_ty, snip) = match expr.kind {\n         ExprKind::MethodCall(.., ref args, _) if args.len() == 1 => {\n             if match_trait_method(cx, expr, &paths::TO_STRING) || match_trait_method(cx, expr, &paths::TO_OWNED) {\n-                (cx.tables().expr_ty_adjusted(&args[0]), snippet(cx, args[0].span, \"..\"))\n+                (cx.tables().expr_ty(&args[0]), snippet(cx, args[0].span, \"..\"))\n             } else {\n                 return;\n             }\n         },\n         ExprKind::Call(ref path, ref v) if v.len() == 1 => {\n             if let ExprKind::Path(ref path) = path.kind {\n                 if match_qpath(path, &[\"String\", \"from_str\"]) || match_qpath(path, &[\"String\", \"from\"]) {\n-                    (cx.tables().expr_ty_adjusted(&v[0]), snippet(cx, v[0].span, \"..\"))\n+                    (cx.tables().expr_ty(&v[0]), snippet(cx, v[0].span, \"..\"))\n                 } else {\n                     return;\n                 }\n@@ -593,28 +612,19 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n         _ => return,\n     };\n \n-    let other_ty = cx.tables().expr_ty_adjusted(other);\n-    let partial_eq_trait_id = match cx.tcx.lang_items().eq_trait() {\n-        Some(id) => id,\n-        None => return,\n-    };\n+    let other_ty = cx.tables().expr_ty(other);\n \n-    let deref_arg_impl_partial_eq_other = arg_ty.builtin_deref(true).map_or(false, |tam| {\n-        implements_trait(cx, tam.ty, partial_eq_trait_id, &[other_ty.into()])\n-    });\n-    let arg_impl_partial_eq_deref_other = other_ty.builtin_deref(true).map_or(false, |tam| {\n-        implements_trait(cx, arg_ty, partial_eq_trait_id, &[tam.ty.into()])\n-    });\n-    let arg_impl_partial_eq_other = implements_trait(cx, arg_ty, partial_eq_trait_id, &[other_ty.into()]);\n+    let without_deref = symmetric_partial_eq(cx, arg_ty, other_ty).unwrap_or_default();\n+    let with_deref = arg_ty\n+        .builtin_deref(true)\n+        .and_then(|tam| symmetric_partial_eq(cx, tam.ty, other_ty))\n+        .unwrap_or_default();\n \n-    if !deref_arg_impl_partial_eq_other && !arg_impl_partial_eq_deref_other && !arg_impl_partial_eq_other {\n+    if !with_deref.is_implemented() && !without_deref.is_implemented() {\n         return;\n     }\n \n-    let other_gets_derefed = match other.kind {\n-        ExprKind::Unary(UnOp::UnDeref, _) => true,\n-        _ => false,\n-    };\n+    let other_gets_derefed = matches!(other.kind, ExprKind::Unary(UnOp::UnDeref, _));\n \n     let lint_span = if other_gets_derefed {\n         expr.span.to(other.span)\n@@ -634,18 +644,34 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n                 return;\n             }\n \n-            let try_hint = if deref_arg_impl_partial_eq_other {\n-                // suggest deref on the left\n-                format!(\"*{}\", snip)\n+            let expr_snip;\n+            let eq_impl;\n+            if with_deref.is_implemented() {\n+                expr_snip = format!(\"*{}\", snip);\n+                eq_impl = with_deref;\n             } else {\n-                // suggest dropping the to_owned on the left\n-                snip.to_string()\n+                expr_snip = snip.to_string();\n+                eq_impl = without_deref;\n             };\n \n+            let span;\n+            let hint;\n+            if (eq_impl.ty_eq_other && left) || (eq_impl.other_eq_ty && !left) {\n+                span = expr.span;\n+                hint = expr_snip;\n+            } else {\n+                span = expr.span.to(other.span);\n+                if eq_impl.ty_eq_other {\n+                    hint = format!(\"{} == {}\", expr_snip, snippet(cx, other.span, \"..\"));\n+                } else {\n+                    hint = format!(\"{} == {}\", snippet(cx, other.span, \"..\"), expr_snip);\n+                }\n+            }\n+\n             diag.span_suggestion(\n-                lint_span,\n+                span,\n                 \"try\",\n-                try_hint,\n+                hint,\n                 Applicability::MachineApplicable, // snippet\n             );\n         },\n@@ -656,16 +682,10 @@ fn check_to_owned(cx: &LateContext<'_>, expr: &Expr<'_>, other: &Expr<'_>) {\n /// `unused_variables`'s idea\n /// of what it means for an expression to be \"used\".\n fn is_used(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-    if let Some(parent) = get_parent_expr(cx, expr) {\n-        match parent.kind {\n-            ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => {\n-                SpanlessEq::new(cx).eq_expr(rhs, expr)\n-            },\n-            _ => is_used(cx, parent),\n-        }\n-    } else {\n-        true\n-    }\n+    get_parent_expr(cx, expr).map_or(true, |parent| match parent.kind {\n+        ExprKind::Assign(_, ref rhs, _) | ExprKind::AssignOp(_, _, ref rhs) => SpanlessEq::new(cx).eq_expr(rhs, expr),\n+        _ => is_used(cx, parent),\n+    })\n }\n \n /// Tests whether an expression is in a macro expansion (e.g., something\n@@ -674,12 +694,7 @@ fn in_attributes_expansion(expr: &Expr<'_>) -> bool {\n     use rustc_span::hygiene::MacroKind;\n     if expr.span.from_expansion() {\n         let data = expr.span.ctxt().outer_expn_data();\n-\n-        if let ExpnKind::Macro(MacroKind::Attr, _) = data.kind {\n-            true\n-        } else {\n-            false\n-        }\n+        matches!(data.kind, ExpnKind::Macro(MacroKind::Attr, _))\n     } else {\n         false\n     }\n@@ -694,7 +709,7 @@ fn non_macro_local(cx: &LateContext<'_>, res: def::Res) -> bool {\n     }\n }\n \n-fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &Ty<'_>) {\n+fn check_cast(cx: &LateContext<'_>, span: Span, e: &Expr<'_>, ty: &hir::Ty<'_>) {\n     if_chain! {\n         if let TyKind::Ptr(ref mut_ty) = ty.kind;\n         if let ExprKind::Lit(ref lit) = e.kind;"}, {"sha": "b84a1a3fe249449a81a574ea2be25118976bbd7e", "filename": "src/tools/clippy/clippy_lints/src/misc_early.rs", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmisc_early.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -641,28 +641,22 @@ fn check_unneeded_wildcard_pattern(cx: &EarlyContext<'_>, pat: &Pat) {\n             );\n         }\n \n-        #[allow(clippy::trivially_copy_pass_by_ref)]\n-        fn is_wild<P: std::ops::Deref<Target = Pat>>(pat: &&P) -> bool {\n-            if let PatKind::Wild = pat.kind {\n-                true\n-            } else {\n-                false\n-            }\n-        }\n-\n         if let Some(rest_index) = patterns.iter().position(|pat| pat.is_rest()) {\n             if let Some((left_index, left_pat)) = patterns[..rest_index]\n                 .iter()\n                 .rev()\n-                .take_while(is_wild)\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n                 .enumerate()\n                 .last()\n             {\n                 span_lint(cx, left_pat.span.until(patterns[rest_index].span), left_index == 0);\n             }\n \n-            if let Some((right_index, right_pat)) =\n-                patterns[rest_index + 1..].iter().take_while(is_wild).enumerate().last()\n+            if let Some((right_index, right_pat)) = patterns[rest_index + 1..]\n+                .iter()\n+                .take_while(|pat| matches!(pat.kind, PatKind::Wild))\n+                .enumerate()\n+                .last()\n             {\n                 span_lint(\n                     cx,"}, {"sha": "9c9626735370180deccffb545cc5579933943f59", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -71,10 +71,11 @@ fn check_missing_inline_attrs(cx: &LateContext<'_>, attrs: &[ast::Attribute], sp\n fn is_executable(cx: &LateContext<'_>) -> bool {\n     use rustc_session::config::CrateType;\n \n-    cx.tcx.sess.crate_types().iter().any(|t: &CrateType| match t {\n-        CrateType::Executable => true,\n-        _ => false,\n-    })\n+    cx.tcx\n+        .sess\n+        .crate_types()\n+        .iter()\n+        .any(|t: &CrateType| matches!(t, CrateType::Executable))\n }\n \n declare_lint_pass!(MissingInline => [MISSING_INLINE_IN_PUBLIC_ITEMS]);"}, {"sha": "621ebdef2f0b17462cbabee5e277f369899cf47a", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -80,10 +80,12 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                             // can't be implemented for unsafe new\n                             return;\n                         }\n-                        if impl_item.generics.params.iter().any(|gen| match gen.kind {\n-                            hir::GenericParamKind::Type { .. } => true,\n-                            _ => false,\n-                        }) {\n+                        if impl_item\n+                            .generics\n+                            .params\n+                            .iter()\n+                            .any(|gen| matches!(gen.kind, hir::GenericParamKind::Type { .. }))\n+                        {\n                             // when the result of `new()` depends on a type parameter we should not require\n                             // an\n                             // impl of `Default`"}, {"sha": "a3521c31a6be6b7f063703b911767113c7ed43b3", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -238,10 +238,10 @@ impl<'tcx> LateLintPass<'tcx> for NonCopyConst {\n \n             let ty = if needs_check_adjustment {\n                 let adjustments = cx.tables().expr_adjustments(dereferenced_expr);\n-                if let Some(i) = adjustments.iter().position(|adj| match adj.kind {\n-                    Adjust::Borrow(_) | Adjust::Deref(_) => true,\n-                    _ => false,\n-                }) {\n+                if let Some(i) = adjustments\n+                    .iter()\n+                    .position(|adj| matches!(adj.kind, Adjust::Borrow(_) | Adjust::Deref(_)))\n+                {\n                     if i == 0 {\n                         cx.tables().expr_ty(dereferenced_expr)\n                     } else {"}, {"sha": "8dbe58763bfb287648e369f0491dbe7cf206cd3f", "filename": "src/tools/clippy/clippy_lints/src/option_if_let_else.rs", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Foption_if_let_else.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,267 @@\n+use crate::utils;\n+use crate::utils::sugg::Sugg;\n+use crate::utils::{match_type, paths, span_lint_and_sugg};\n+use if_chain::if_chain;\n+\n+use rustc_errors::Applicability;\n+use rustc_hir::intravisit::{NestedVisitorMap, Visitor};\n+use rustc_hir::{Arm, BindingAnnotation, Block, Expr, ExprKind, MatchSource, Mutability, PatKind, UnOp};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::hir::map::Map;\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:**\n+    /// Lints usage of  `if let Some(v) = ... { y } else { x }` which is more\n+    /// idiomatically done with `Option::map_or` (if the else bit is a simple\n+    /// expression) or `Option::map_or_else` (if the else bit is a longer\n+    /// block).\n+    ///\n+    /// **Why is this bad?**\n+    /// Using the dedicated functions of the Option type is clearer and\n+    /// more concise than an if let expression.\n+    ///\n+    /// **Known problems:**\n+    /// This lint uses whether the block is just an expression or if it has\n+    /// more statements to decide whether to use `Option::map_or` or\n+    /// `Option::map_or_else`. If you have a single expression which calls\n+    /// an expensive function, then it would be more efficient to use\n+    /// `Option::map_or_else`, but this lint would suggest `Option::map_or`.\n+    ///\n+    /// Also, this lint uses a deliberately conservative metric for checking\n+    /// if the inside of either body contains breaks or continues which will\n+    /// cause it to not suggest a fix if either block contains a loop with\n+    /// continues or breaks contained within the loop.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// # let optional: Option<u32> = Some(0);\n+    /// # fn do_complicated_function() -> u32 { 5 };\n+    /// let _ = if let Some(foo) = optional {\n+    ///     foo\n+    /// } else {\n+    ///     5\n+    /// };\n+    /// let _ = if let Some(foo) = optional {\n+    ///     foo\n+    /// } else {\n+    ///     let y = do_complicated_function();\n+    ///     y*y\n+    /// };\n+    /// ```\n+    ///\n+    /// should be\n+    ///\n+    /// ```rust\n+    /// # let optional: Option<u32> = Some(0);\n+    /// # fn do_complicated_function() -> u32 { 5 };\n+    /// let _ = optional.map_or(5, |foo| foo);\n+    /// let _ = optional.map_or_else(||{\n+    ///     let y = do_complicated_function();\n+    ///     y*y\n+    /// }, |foo| foo);\n+    /// ```\n+    pub OPTION_IF_LET_ELSE,\n+    pedantic,\n+    \"reimplementation of Option::map_or\"\n+}\n+\n+declare_lint_pass!(OptionIfLetElse => [OPTION_IF_LET_ELSE]);\n+\n+/// Returns true iff the given expression is the result of calling `Result::ok`\n+fn is_result_ok(cx: &LateContext<'_>, expr: &'_ Expr<'_>) -> bool {\n+    if let ExprKind::MethodCall(ref path, _, &[ref receiver], _) = &expr.kind {\n+        path.ident.name.to_ident_string() == \"ok\" && match_type(cx, &cx.tables().expr_ty(&receiver), &paths::RESULT)\n+    } else {\n+        false\n+    }\n+}\n+\n+/// A struct containing information about occurences of the\n+/// `if let Some(..) = .. else` construct that this lint detects.\n+struct OptionIfLetElseOccurence {\n+    option: String,\n+    method_sugg: String,\n+    some_expr: String,\n+    none_expr: String,\n+    wrap_braces: bool,\n+}\n+\n+struct ReturnBreakContinueMacroVisitor {\n+    seen_return_break_continue: bool,\n+}\n+impl ReturnBreakContinueMacroVisitor {\n+    fn new() -> ReturnBreakContinueMacroVisitor {\n+        ReturnBreakContinueMacroVisitor {\n+            seen_return_break_continue: false,\n+        }\n+    }\n+}\n+impl<'tcx> Visitor<'tcx> for ReturnBreakContinueMacroVisitor {\n+    type Map = Map<'tcx>;\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+\n+    fn visit_expr(&mut self, ex: &'tcx Expr<'tcx>) {\n+        if self.seen_return_break_continue {\n+            // No need to look farther if we've already seen one of them\n+            return;\n+        }\n+        match &ex.kind {\n+            ExprKind::Ret(..) | ExprKind::Break(..) | ExprKind::Continue(..) => {\n+                self.seen_return_break_continue = true;\n+            },\n+            // Something special could be done here to handle while or for loop\n+            // desugaring, as this will detect a break if there's a while loop\n+            // or a for loop inside the expression.\n+            _ => {\n+                if utils::in_macro(ex.span) {\n+                    self.seen_return_break_continue = true;\n+                } else {\n+                    rustc_hir::intravisit::walk_expr(self, ex);\n+                }\n+            },\n+        }\n+    }\n+}\n+\n+fn contains_return_break_continue_macro(expression: &Expr<'_>) -> bool {\n+    let mut recursive_visitor = ReturnBreakContinueMacroVisitor::new();\n+    recursive_visitor.visit_expr(expression);\n+    recursive_visitor.seen_return_break_continue\n+}\n+\n+/// Extracts the body of a given arm. If the arm contains only an expression,\n+/// then it returns the expression. Otherwise, it returns the entire block\n+fn extract_body_from_arm<'a>(arm: &'a Arm<'a>) -> Option<&'a Expr<'a>> {\n+    if let ExprKind::Block(\n+        Block {\n+            stmts: statements,\n+            expr: Some(expr),\n+            ..\n+        },\n+        _,\n+    ) = &arm.body.kind\n+    {\n+        if let [] = statements {\n+            Some(&expr)\n+        } else {\n+            Some(&arm.body)\n+        }\n+    } else {\n+        None\n+    }\n+}\n+\n+/// If this is the else body of an if/else expression, then we need to wrap\n+/// it in curcly braces. Otherwise, we don't.\n+fn should_wrap_in_braces(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    utils::get_enclosing_block(cx, expr.hir_id).map_or(false, |parent| {\n+        if let Some(Expr {\n+            kind:\n+                ExprKind::Match(\n+                    _,\n+                    arms,\n+                    MatchSource::IfDesugar {\n+                        contains_else_clause: true,\n+                    }\n+                    | MatchSource::IfLetDesugar {\n+                        contains_else_clause: true,\n+                    },\n+                ),\n+            ..\n+        }) = parent.expr\n+        {\n+            expr.hir_id == arms[1].body.hir_id\n+        } else {\n+            false\n+        }\n+    })\n+}\n+\n+fn format_option_in_sugg(cx: &LateContext<'_>, cond_expr: &Expr<'_>, as_ref: bool, as_mut: bool) -> String {\n+    format!(\n+        \"{}{}\",\n+        Sugg::hir(cx, cond_expr, \"..\").maybe_par(),\n+        if as_mut {\n+            \".as_mut()\"\n+        } else if as_ref {\n+            \".as_ref()\"\n+        } else {\n+            \"\"\n+        }\n+    )\n+}\n+\n+/// If this expression is the option if let/else construct we're detecting, then\n+/// this function returns an `OptionIfLetElseOccurence` struct with details if\n+/// this construct is found, or None if this construct is not found.\n+fn detect_option_if_let_else(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<OptionIfLetElseOccurence> {\n+    if_chain! {\n+        if !utils::in_macro(expr.span); // Don't lint macros, because it behaves weirdly\n+        if let ExprKind::Match(cond_expr, arms, MatchSource::IfLetDesugar{contains_else_clause: true}) = &expr.kind;\n+        if arms.len() == 2;\n+        if !is_result_ok(cx, cond_expr); // Don't lint on Result::ok because a different lint does it already\n+        if let PatKind::TupleStruct(struct_qpath, &[inner_pat], _) = &arms[0].pat.kind;\n+        if utils::match_qpath(struct_qpath, &paths::OPTION_SOME);\n+        if let PatKind::Binding(bind_annotation, _, id, _) = &inner_pat.kind;\n+        if !contains_return_break_continue_macro(arms[0].body);\n+        if !contains_return_break_continue_macro(arms[1].body);\n+        then {\n+            let capture_mut = if bind_annotation == &BindingAnnotation::Mutable { \"mut \" } else { \"\" };\n+            let some_body = extract_body_from_arm(&arms[0])?;\n+            let none_body = extract_body_from_arm(&arms[1])?;\n+            let method_sugg = match &none_body.kind {\n+                ExprKind::Block(..) => \"map_or_else\",\n+                _ => \"map_or\",\n+            };\n+            let capture_name = id.name.to_ident_string();\n+            let wrap_braces = should_wrap_in_braces(cx, expr);\n+            let (as_ref, as_mut) = match &cond_expr.kind {\n+                ExprKind::AddrOf(_, Mutability::Not, _) => (true, false),\n+                ExprKind::AddrOf(_, Mutability::Mut, _) => (false, true),\n+                _ => (bind_annotation == &BindingAnnotation::Ref, bind_annotation == &BindingAnnotation::RefMut),\n+            };\n+            let cond_expr = match &cond_expr.kind {\n+                // Pointer dereferencing happens automatically, so we can omit it in the suggestion\n+                ExprKind::Unary(UnOp::UnDeref, expr) | ExprKind::AddrOf(_, _, expr) => expr,\n+                _ => cond_expr,\n+            };\n+            Some(OptionIfLetElseOccurence {\n+                option: format_option_in_sugg(cx, cond_expr, as_ref, as_mut),\n+                method_sugg: method_sugg.to_string(),\n+                some_expr: format!(\"|{}{}| {}\", capture_mut, capture_name, Sugg::hir(cx, some_body, \"..\")),\n+                none_expr: format!(\"{}{}\", if method_sugg == \"map_or\" { \"\" } else { \"|| \" }, Sugg::hir(cx, none_body, \"..\")),\n+                wrap_braces,\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'a> LateLintPass<'a> for OptionIfLetElse {\n+    fn check_expr(&mut self, cx: &LateContext<'a>, expr: &Expr<'_>) {\n+        if let Some(detection) = detect_option_if_let_else(cx, expr) {\n+            span_lint_and_sugg(\n+                cx,\n+                OPTION_IF_LET_ELSE,\n+                expr.span,\n+                format!(\"use Option::{} instead of an if let/else\", detection.method_sugg).as_str(),\n+                \"try\",\n+                format!(\n+                    \"{}{}.{}({}, {}){}\",\n+                    if detection.wrap_braces { \"{ \" } else { \"\" },\n+                    detection.option,\n+                    detection.method_sugg,\n+                    detection.none_expr,\n+                    detection.some_expr,\n+                    if detection.wrap_braces { \" }\" } else { \"\" },\n+                ),\n+                Applicability::MaybeIncorrect,\n+            );\n+        }\n+    }\n+}"}, {"sha": "a49dc87c0b47f5697b2d5c28bbc58714aad030b5", "filename": "src/tools/clippy/clippy_lints/src/pattern_type_mismatch.rs", "status": "added", "additions": 311, "deletions": 0, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fpattern_type_mismatch.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,311 @@\n+use crate::utils::{last_path_segment, span_lint_and_help};\n+use rustc_hir::{\n+    intravisit, Body, Expr, ExprKind, FieldPat, FnDecl, HirId, LocalSource, MatchSource, Mutability, Pat, PatKind,\n+    QPath, Stmt, StmtKind,\n+};\n+use rustc_lint::{LateContext, LateLintPass, LintContext};\n+use rustc_middle::lint::in_external_macro;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{AdtDef, FieldDef, Ty, TyKind, VariantDef};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+use rustc_span::source_map::Span;\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for patterns that aren't exact representations of the types\n+    /// they are applied to.\n+    ///\n+    /// To satisfy this lint, you will have to adjust either the expression that is matched\n+    /// against or the pattern itself, as well as the bindings that are introduced by the\n+    /// adjusted patterns. For matching you will have to either dereference the expression\n+    /// with the `*` operator, or amend the patterns to explicitly match against `&<pattern>`\n+    /// or `&mut <pattern>` depending on the reference mutability. For the bindings you need\n+    /// to use the inverse. You can leave them as plain bindings if you wish for the value\n+    /// to be copied, but you must use `ref mut <variable>` or `ref <variable>` to construct\n+    /// a reference into the matched structure.\n+    ///\n+    /// If you are looking for a way to learn about ownership semantics in more detail, it\n+    /// is recommended to look at IDE options available to you to highlight types, lifetimes\n+    /// and reference semantics in your code. The available tooling would expose these things\n+    /// in a general way even outside of the various pattern matching mechanics. Of course\n+    /// this lint can still be used to highlight areas of interest and ensure a good understanding\n+    /// of ownership semantics.\n+    ///\n+    /// **Why is this bad?** It isn't bad in general. But in some contexts it can be desirable\n+    /// because it increases ownership hints in the code, and will guard against some changes\n+    /// in ownership.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// This example shows the basic adjustments necessary to satisfy the lint. Note how\n+    /// the matched expression is explicitly dereferenced with `*` and the `inner` variable\n+    /// is bound to a shared borrow via `ref inner`.\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// let value = &Some(Box::new(23));\n+    /// match value {\n+    ///     Some(inner) => println!(\"{}\", inner),\n+    ///     None => println!(\"none\"),\n+    /// }\n+    ///\n+    /// // Good\n+    /// let value = &Some(Box::new(23));\n+    /// match *value {\n+    ///     Some(ref inner) => println!(\"{}\", inner),\n+    ///     None => println!(\"none\"),\n+    /// }\n+    /// ```\n+    ///\n+    /// The following example demonstrates one of the advantages of the more verbose style.\n+    /// Note how the second version uses `ref mut a` to explicitly declare `a` a shared mutable\n+    /// borrow, while `b` is simply taken by value. This ensures that the loop body cannot\n+    /// accidentally modify the wrong part of the structure.\n+    ///\n+    /// ```rust,ignore\n+    /// // Bad\n+    /// let mut values = vec![(2, 3), (3, 4)];\n+    /// for (a, b) in &mut values {\n+    ///     *a += *b;\n+    /// }\n+    ///\n+    /// // Good\n+    /// let mut values = vec![(2, 3), (3, 4)];\n+    /// for &mut (ref mut a, b) in &mut values {\n+    ///     *a += b;\n+    /// }\n+    /// ```\n+    pub PATTERN_TYPE_MISMATCH,\n+    restriction,\n+    \"type of pattern does not match the expression type\"\n+}\n+\n+declare_lint_pass!(PatternTypeMismatch => [PATTERN_TYPE_MISMATCH]);\n+\n+impl<'tcx> LateLintPass<'tcx> for PatternTypeMismatch {\n+    fn check_stmt(&mut self, cx: &LateContext<'tcx>, stmt: &'tcx Stmt<'_>) {\n+        if let StmtKind::Local(ref local) = stmt.kind {\n+            if let Some(init) = &local.init {\n+                if let Some(init_ty) = cx.tables().node_type_opt(init.hir_id) {\n+                    let pat = &local.pat;\n+                    if in_external_macro(cx.sess(), pat.span) {\n+                        return;\n+                    }\n+                    let deref_possible = match local.source {\n+                        LocalSource::Normal => DerefPossible::Possible,\n+                        _ => DerefPossible::Impossible,\n+                    };\n+                    apply_lint(cx, pat, init_ty, deref_possible);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+        if let ExprKind::Match(ref expr, arms, source) = expr.kind {\n+            match source {\n+                MatchSource::Normal | MatchSource::IfLetDesugar { .. } | MatchSource::WhileLetDesugar => {\n+                    if let Some(expr_ty) = cx.tables().node_type_opt(expr.hir_id) {\n+                        'pattern_checks: for arm in arms {\n+                            let pat = &arm.pat;\n+                            if in_external_macro(cx.sess(), pat.span) {\n+                                continue 'pattern_checks;\n+                            }\n+                            if apply_lint(cx, pat, expr_ty, DerefPossible::Possible) {\n+                                break 'pattern_checks;\n+                            }\n+                        }\n+                    }\n+                },\n+                _ => (),\n+            }\n+        }\n+    }\n+\n+    fn check_fn(\n+        &mut self,\n+        cx: &LateContext<'tcx>,\n+        _: intravisit::FnKind<'tcx>,\n+        _: &'tcx FnDecl<'_>,\n+        body: &'tcx Body<'_>,\n+        _: Span,\n+        hir_id: HirId,\n+    ) {\n+        if let Some(fn_sig) = cx.tables().liberated_fn_sigs().get(hir_id) {\n+            for (param, ty) in body.params.iter().zip(fn_sig.inputs().iter()) {\n+                apply_lint(cx, &param.pat, ty, DerefPossible::Impossible);\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+enum DerefPossible {\n+    Possible,\n+    Impossible,\n+}\n+\n+fn apply_lint<'tcx>(cx: &LateContext<'tcx>, pat: &Pat<'_>, expr_ty: Ty<'tcx>, deref_possible: DerefPossible) -> bool {\n+    let maybe_mismatch = find_first_mismatch(cx, pat, expr_ty, Level::Top);\n+    if let Some((span, mutability, level)) = maybe_mismatch {\n+        span_lint_and_help(\n+            cx,\n+            PATTERN_TYPE_MISMATCH,\n+            span,\n+            \"type of pattern does not match the expression type\",\n+            None,\n+            &format!(\n+                \"{}explicitly match against a `{}` pattern and adjust the enclosed variable bindings\",\n+                match (deref_possible, level) {\n+                    (DerefPossible::Possible, Level::Top) => \"use `*` to dereference the match expression or \",\n+                    _ => \"\",\n+                },\n+                match mutability {\n+                    Mutability::Mut => \"&mut _\",\n+                    Mutability::Not => \"&_\",\n+                },\n+            ),\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone)]\n+enum Level {\n+    Top,\n+    Lower,\n+}\n+\n+#[allow(rustc::usage_of_ty_tykind)]\n+fn find_first_mismatch<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    pat: &Pat<'_>,\n+    ty: Ty<'tcx>,\n+    level: Level,\n+) -> Option<(Span, Mutability, Level)> {\n+    if let PatKind::Ref(ref sub_pat, _) = pat.kind {\n+        if let TyKind::Ref(_, sub_ty, _) = ty.kind {\n+            return find_first_mismatch(cx, sub_pat, sub_ty, Level::Lower);\n+        }\n+    }\n+\n+    if let TyKind::Ref(_, _, mutability) = ty.kind {\n+        if is_non_ref_pattern(&pat.kind) {\n+            return Some((pat.span, mutability, level));\n+        }\n+    }\n+\n+    if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+            if let Some(variant) = get_variant(adt_def, qpath) {\n+                let field_defs = &variant.fields;\n+                return find_first_mismatch_in_struct(cx, field_pats, field_defs, substs_ref);\n+            }\n+        }\n+    }\n+\n+    if let PatKind::TupleStruct(ref qpath, ref pats, _) = pat.kind {\n+        if let TyKind::Adt(ref adt_def, ref substs_ref) = ty.kind {\n+            if let Some(variant) = get_variant(adt_def, qpath) {\n+                let field_defs = &variant.fields;\n+                let ty_iter = field_defs.iter().map(|field_def| field_def.ty(cx.tcx, substs_ref));\n+                return find_first_mismatch_in_tuple(cx, pats, ty_iter);\n+            }\n+        }\n+    }\n+\n+    if let PatKind::Tuple(ref pats, _) = pat.kind {\n+        if let TyKind::Tuple(..) = ty.kind {\n+            return find_first_mismatch_in_tuple(cx, pats, ty.tuple_fields());\n+        }\n+    }\n+\n+    if let PatKind::Or(sub_pats) = pat.kind {\n+        for pat in sub_pats {\n+            let maybe_mismatch = find_first_mismatch(cx, pat, ty, level);\n+            if let Some(mismatch) = maybe_mismatch {\n+                return Some(mismatch);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn get_variant<'a>(adt_def: &'a AdtDef, qpath: &QPath<'_>) -> Option<&'a VariantDef> {\n+    if adt_def.is_struct() {\n+        if let Some(variant) = adt_def.variants.iter().next() {\n+            return Some(variant);\n+        }\n+    }\n+\n+    if adt_def.is_enum() {\n+        let pat_ident = last_path_segment(qpath).ident;\n+        for variant in &adt_def.variants {\n+            if variant.ident == pat_ident {\n+                return Some(variant);\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn find_first_mismatch_in_tuple<'tcx, I>(\n+    cx: &LateContext<'tcx>,\n+    pats: &[&Pat<'_>],\n+    ty_iter_src: I,\n+) -> Option<(Span, Mutability, Level)>\n+where\n+    I: IntoIterator<Item = Ty<'tcx>>,\n+{\n+    let mut field_tys = ty_iter_src.into_iter();\n+    'fields: for pat in pats {\n+        let field_ty = if let Some(ty) = field_tys.next() {\n+            ty\n+        } else {\n+            break 'fields;\n+        };\n+\n+        let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n+        if let Some(mismatch) = maybe_mismatch {\n+            return Some(mismatch);\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn find_first_mismatch_in_struct<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    field_pats: &[FieldPat<'_>],\n+    field_defs: &[FieldDef],\n+    substs_ref: SubstsRef<'tcx>,\n+) -> Option<(Span, Mutability, Level)> {\n+    for field_pat in field_pats {\n+        'definitions: for field_def in field_defs {\n+            if field_pat.ident == field_def.ident {\n+                let field_ty = field_def.ty(cx.tcx, substs_ref);\n+                let pat = &field_pat.pat;\n+                let maybe_mismatch = find_first_mismatch(cx, pat, field_ty, Level::Lower);\n+                if let Some(mismatch) = maybe_mismatch {\n+                    return Some(mismatch);\n+                }\n+                break 'definitions;\n+            }\n+        }\n+    }\n+\n+    None\n+}\n+\n+fn is_non_ref_pattern(pat_kind: &PatKind<'_>) -> bool {\n+    match pat_kind {\n+        PatKind::Struct(..) | PatKind::Tuple(..) | PatKind::TupleStruct(..) | PatKind::Path(..) => true,\n+        PatKind::Or(sub_pats) => sub_pats.iter().any(|pat| is_non_ref_pattern(&pat.kind)),\n+        _ => false,\n+    }\n+}"}, {"sha": "4797771e7bdbb4aa9e95dba4f3a00c9f587cda42", "filename": "src/tools/clippy/clippy_lints/src/precedence.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fprecedence.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -148,17 +148,11 @@ fn is_arith_expr(expr: &Expr) -> bool {\n #[must_use]\n fn is_bit_op(op: BinOpKind) -> bool {\n     use rustc_ast::ast::BinOpKind::{BitAnd, BitOr, BitXor, Shl, Shr};\n-    match op {\n-        BitXor | BitAnd | BitOr | Shl | Shr => true,\n-        _ => false,\n-    }\n+    matches!(op, BitXor | BitAnd | BitOr | Shl | Shr)\n }\n \n #[must_use]\n fn is_arith_op(op: BinOpKind) -> bool {\n     use rustc_ast::ast::BinOpKind::{Add, Div, Mul, Rem, Sub};\n-    match op {\n-        Add | Sub | Mul | Div | Rem => true,\n-        _ => false,\n-    }\n+    matches!(op, Add | Sub | Mul | Div | Rem)\n }"}, {"sha": "dd608de5723e228defc9f1e9be5d91a2c0a445e6", "filename": "src/tools/clippy/clippy_lints/src/ranges.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Franges.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -52,6 +52,11 @@ declare_clippy_lint! {\n     /// exclusive ranges, because they essentially add an extra branch that\n     /// LLVM may fail to hoist out of the loop.\n     ///\n+    /// This will cause a warning that cannot be fixed if the consumer of the\n+    /// range only accepts a specific range type, instead of the generic\n+    /// `RangeBounds` trait\n+    /// ([#3307](https://github.com/rust-lang/rust-clippy/issues/3307)).\n+    ///\n     /// **Example:**\n     /// ```rust,ignore\n     /// for x..(y+1) { .. }\n@@ -72,7 +77,10 @@ declare_clippy_lint! {\n     /// **Why is this bad?** The code is more readable with an exclusive range\n     /// like `x..y`.\n     ///\n-    /// **Known problems:** None.\n+    /// **Known problems:** This will cause a warning that cannot be fixed if\n+    /// the consumer of the range only accepts a specific range type, instead of\n+    /// the generic `RangeBounds` trait\n+    /// ([#3307](https://github.com/rust-lang/rust-clippy/issues/3307)).\n     ///\n     /// **Example:**\n     /// ```rust,ignore\n@@ -83,7 +91,7 @@ declare_clippy_lint! {\n     /// for x..y { .. }\n     /// ```\n     pub RANGE_MINUS_ONE,\n-    complexity,\n+    pedantic,\n     \"`x..=(y-1)` reads better as `x..y`\"\n }\n "}, {"sha": "d8d16efb978a53727fe61bdd746c11d2c5a10708", "filename": "src/tools/clippy/clippy_lints/src/redundant_pattern_matching.rs", "status": "removed", "additions": 0, "deletions": 260, "changes": 260, "blob_url": "https://github.com/rust-lang/rust/blob/c724b67e1b474262917a5154d74e7072267593fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c724b67e1b474262917a5154d74e7072267593fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_pattern_matching.rs?ref=c724b67e1b474262917a5154d74e7072267593fe", "patch": "@@ -1,260 +0,0 @@\n-use crate::utils::{in_constant, match_qpath, match_trait_method, paths, snippet, span_lint_and_then};\n-use if_chain::if_chain;\n-use rustc_ast::ast::LitKind;\n-use rustc_errors::Applicability;\n-use rustc_hir::{Arm, Expr, ExprKind, HirId, MatchSource, PatKind, QPath};\n-use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::ty;\n-use rustc_mir::const_eval::is_const_fn;\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Symbol;\n-\n-declare_clippy_lint! {\n-    /// **What it does:** Lint for redundant pattern matching over `Result` or\n-    /// `Option`\n-    ///\n-    /// **Why is this bad?** It's more concise and clear to just use the proper\n-    /// utility function\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    ///\n-    /// ```rust\n-    /// if let Ok(_) = Ok::<i32, i32>(42) {}\n-    /// if let Err(_) = Err::<i32, i32>(42) {}\n-    /// if let None = None::<()> {}\n-    /// if let Some(_) = Some(42) {}\n-    /// match Ok::<i32, i32>(42) {\n-    ///     Ok(_) => true,\n-    ///     Err(_) => false,\n-    /// };\n-    /// ```\n-    ///\n-    /// The more idiomatic use would be:\n-    ///\n-    /// ```rust\n-    /// if Ok::<i32, i32>(42).is_ok() {}\n-    /// if Err::<i32, i32>(42).is_err() {}\n-    /// if None::<()>.is_none() {}\n-    /// if Some(42).is_some() {}\n-    /// Ok::<i32, i32>(42).is_ok();\n-    /// ```\n-    pub REDUNDANT_PATTERN_MATCHING,\n-    style,\n-    \"use the proper utility function avoiding an `if let`\"\n-}\n-\n-declare_lint_pass!(RedundantPatternMatching => [REDUNDANT_PATTERN_MATCHING]);\n-\n-impl<'tcx> LateLintPass<'tcx> for RedundantPatternMatching {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if let ExprKind::Match(op, arms, ref match_source) = &expr.kind {\n-            match match_source {\n-                MatchSource::Normal => find_sugg_for_match(cx, expr, op, arms),\n-                MatchSource::IfLetDesugar { .. } => find_sugg_for_if_let(cx, expr, op, arms, \"if\"),\n-                MatchSource::WhileLetDesugar => find_sugg_for_if_let(cx, expr, op, arms, \"while\"),\n-                _ => return,\n-            }\n-        }\n-    }\n-}\n-\n-fn find_sugg_for_if_let<'tcx>(\n-    cx: &LateContext<'tcx>,\n-    expr: &'tcx Expr<'_>,\n-    op: &Expr<'_>,\n-    arms: &[Arm<'_>],\n-    keyword: &'static str,\n-) {\n-    fn find_suggestion(cx: &LateContext<'_>, hir_id: HirId, path: &QPath<'_>) -> Option<&'static str> {\n-        if match_qpath(path, &paths::RESULT_OK) && can_suggest(cx, hir_id, sym!(result_type), \"is_ok\") {\n-            return Some(\"is_ok()\");\n-        }\n-        if match_qpath(path, &paths::RESULT_ERR) && can_suggest(cx, hir_id, sym!(result_type), \"is_err\") {\n-            return Some(\"is_err()\");\n-        }\n-        if match_qpath(path, &paths::OPTION_SOME) && can_suggest(cx, hir_id, sym!(option_type), \"is_some\") {\n-            return Some(\"is_some()\");\n-        }\n-        if match_qpath(path, &paths::OPTION_NONE) && can_suggest(cx, hir_id, sym!(option_type), \"is_none\") {\n-            return Some(\"is_none()\");\n-        }\n-        None\n-    }\n-\n-    let hir_id = expr.hir_id;\n-    let good_method = match arms[0].pat.kind {\n-        PatKind::TupleStruct(ref path, ref patterns, _) if patterns.len() == 1 => {\n-            if let PatKind::Wild = patterns[0].kind {\n-                find_suggestion(cx, hir_id, path)\n-            } else {\n-                None\n-            }\n-        },\n-        PatKind::Path(ref path) => find_suggestion(cx, hir_id, path),\n-        _ => None,\n-    };\n-    let good_method = match good_method {\n-        Some(method) => method,\n-        None => return,\n-    };\n-\n-    // check that `while_let_on_iterator` lint does not trigger\n-    if_chain! {\n-        if keyword == \"while\";\n-        if let ExprKind::MethodCall(method_path, _, _, _) = op.kind;\n-        if method_path.ident.name == sym!(next);\n-        if match_trait_method(cx, op, &paths::ITERATOR);\n-        then {\n-            return;\n-        }\n-    }\n-\n-    span_lint_and_then(\n-        cx,\n-        REDUNDANT_PATTERN_MATCHING,\n-        arms[0].pat.span,\n-        &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-        |diag| {\n-            // while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-            let expr_span = expr.span;\n-\n-            // while let ... = ... { ... }\n-            //                 ^^^\n-            let op_span = op.span.source_callsite();\n-\n-            // while let ... = ... { ... }\n-            // ^^^^^^^^^^^^^^^^^^^\n-            let span = expr_span.until(op_span.shrink_to_hi());\n-            diag.span_suggestion(\n-                span,\n-                \"try this\",\n-                format!(\"{} {}.{}\", keyword, snippet(cx, op_span, \"_\"), good_method),\n-                Applicability::MachineApplicable, // snippet\n-            );\n-        },\n-    );\n-}\n-\n-fn find_sugg_for_match<'tcx>(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, op: &Expr<'_>, arms: &[Arm<'_>]) {\n-    if arms.len() == 2 {\n-        let node_pair = (&arms[0].pat.kind, &arms[1].pat.kind);\n-\n-        let hir_id = expr.hir_id;\n-        let found_good_method = match node_pair {\n-            (\n-                PatKind::TupleStruct(ref path_left, ref patterns_left, _),\n-                PatKind::TupleStruct(ref path_right, ref patterns_right, _),\n-            ) if patterns_left.len() == 1 && patterns_right.len() == 1 => {\n-                if let (PatKind::Wild, PatKind::Wild) = (&patterns_left[0].kind, &patterns_right[0].kind) {\n-                    find_good_method_for_match(\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        &paths::RESULT_OK,\n-                        &paths::RESULT_ERR,\n-                        \"is_ok()\",\n-                        \"is_err()\",\n-                        || can_suggest(cx, hir_id, sym!(result_type), \"is_ok\"),\n-                        || can_suggest(cx, hir_id, sym!(result_type), \"is_err\"),\n-                    )\n-                } else {\n-                    None\n-                }\n-            },\n-            (PatKind::TupleStruct(ref path_left, ref patterns, _), PatKind::Path(ref path_right))\n-            | (PatKind::Path(ref path_left), PatKind::TupleStruct(ref path_right, ref patterns, _))\n-                if patterns.len() == 1 =>\n-            {\n-                if let PatKind::Wild = patterns[0].kind {\n-                    find_good_method_for_match(\n-                        arms,\n-                        path_left,\n-                        path_right,\n-                        &paths::OPTION_SOME,\n-                        &paths::OPTION_NONE,\n-                        \"is_some()\",\n-                        \"is_none()\",\n-                        || can_suggest(cx, hir_id, sym!(option_type), \"is_some\"),\n-                        || can_suggest(cx, hir_id, sym!(option_type), \"is_none\"),\n-                    )\n-                } else {\n-                    None\n-                }\n-            },\n-            _ => None,\n-        };\n-\n-        if let Some(good_method) = found_good_method {\n-            span_lint_and_then(\n-                cx,\n-                REDUNDANT_PATTERN_MATCHING,\n-                expr.span,\n-                &format!(\"redundant pattern matching, consider using `{}`\", good_method),\n-                |diag| {\n-                    let span = expr.span.to(op.span);\n-                    diag.span_suggestion(\n-                        span,\n-                        \"try this\",\n-                        format!(\"{}.{}\", snippet(cx, op.span, \"_\"), good_method),\n-                        Applicability::MaybeIncorrect, // snippet\n-                    );\n-                },\n-            );\n-        }\n-    }\n-}\n-\n-#[allow(clippy::too_many_arguments)]\n-fn find_good_method_for_match<'a>(\n-    arms: &[Arm<'_>],\n-    path_left: &QPath<'_>,\n-    path_right: &QPath<'_>,\n-    expected_left: &[&str],\n-    expected_right: &[&str],\n-    should_be_left: &'a str,\n-    should_be_right: &'a str,\n-    can_suggest_left: impl Fn() -> bool,\n-    can_suggest_right: impl Fn() -> bool,\n-) -> Option<&'a str> {\n-    let body_node_pair = if match_qpath(path_left, expected_left) && match_qpath(path_right, expected_right) {\n-        (&(*arms[0].body).kind, &(*arms[1].body).kind)\n-    } else if match_qpath(path_right, expected_left) && match_qpath(path_left, expected_right) {\n-        (&(*arms[1].body).kind, &(*arms[0].body).kind)\n-    } else {\n-        return None;\n-    };\n-\n-    match body_node_pair {\n-        (ExprKind::Lit(ref lit_left), ExprKind::Lit(ref lit_right)) => match (&lit_left.node, &lit_right.node) {\n-            (LitKind::Bool(true), LitKind::Bool(false)) if can_suggest_left() => Some(should_be_left),\n-            (LitKind::Bool(false), LitKind::Bool(true)) if can_suggest_right() => Some(should_be_right),\n-            _ => None,\n-        },\n-        _ => None,\n-    }\n-}\n-\n-fn can_suggest(cx: &LateContext<'_>, hir_id: HirId, diag_item: Symbol, name: &str) -> bool {\n-    if !in_constant(cx, hir_id) {\n-        return true;\n-    }\n-\n-    // Avoid suggesting calls to non-`const fn`s in const contexts, see #5697.\n-    cx.tcx\n-        .get_diagnostic_item(diag_item)\n-        .and_then(|def_id| {\n-            cx.tcx.inherent_impls(def_id).iter().find_map(|imp| {\n-                cx.tcx\n-                    .associated_items(*imp)\n-                    .in_definition_order()\n-                    .find_map(|item| match item.kind {\n-                        ty::AssocKind::Fn if item.ident.name.as_str() == name => Some(item.def_id),\n-                        _ => None,\n-                    })\n-            })\n-        })\n-        .map_or(false, |def_id| is_const_fn(cx.tcx, def_id))\n-}"}, {"sha": "f204a0ffb2c7b92aed6041cfc80dbbcaf39a7bb7", "filename": "src/tools/clippy/clippy_lints/src/regex.rs", "status": "modified", "additions": 4, "deletions": 60, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fregex.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,9 +1,9 @@\n use crate::consts::{constant, Constant};\n-use crate::utils::{is_expn_of, match_def_path, match_type, paths, span_lint, span_lint_and_help};\n+use crate::utils::{match_def_path, paths, span_lint, span_lint_and_help};\n use if_chain::if_chain;\n use rustc_ast::ast::{LitKind, StrStyle};\n use rustc_data_structures::fx::FxHashSet;\n-use rustc_hir::{Block, BorrowKind, Crate, Expr, ExprKind, HirId};\n+use rustc_hir::{BorrowKind, Expr, ExprKind, HirId};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::{BytePos, Span};\n@@ -46,66 +46,15 @@ declare_clippy_lint! {\n     \"trivial regular expressions\"\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for usage of `regex!(_)` which (as of now) is\n-    /// usually slower than `Regex::new(_)` unless called in a loop (which is a bad\n-    /// idea anyway).\n-    ///\n-    /// **Why is this bad?** Performance, at least for now. The macro version is\n-    /// likely to catch up long-term, but for now the dynamic version is faster.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```ignore\n-    /// regex!(\"foo|bar\")\n-    /// ```\n-    pub REGEX_MACRO,\n-    style,\n-    \"use of `regex!(_)` instead of `Regex::new(_)`\"\n-}\n-\n #[derive(Clone, Default)]\n pub struct Regex {\n     spans: FxHashSet<Span>,\n     last: Option<HirId>,\n }\n \n-impl_lint_pass!(Regex => [INVALID_REGEX, REGEX_MACRO, TRIVIAL_REGEX]);\n+impl_lint_pass!(Regex => [INVALID_REGEX, TRIVIAL_REGEX]);\n \n impl<'tcx> LateLintPass<'tcx> for Regex {\n-    fn check_crate(&mut self, _: &LateContext<'tcx>, _: &'tcx Crate<'_>) {\n-        self.spans.clear();\n-    }\n-\n-    fn check_block(&mut self, cx: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        if_chain! {\n-            if self.last.is_none();\n-            if let Some(ref expr) = block.expr;\n-            if match_type(cx, cx.tables().expr_ty(expr), &paths::REGEX);\n-            if let Some(span) = is_expn_of(expr.span, \"regex\");\n-            then {\n-                if !self.spans.contains(&span) {\n-                    span_lint(\n-                        cx,\n-                        REGEX_MACRO,\n-                        span,\n-                        \"`regex!(_)` found. \\\n-                        Please use `Regex::new(_)`, which is faster for now.\"\n-                    );\n-                    self.spans.insert(span);\n-                }\n-                self.last = Some(block.hir_id);\n-            }\n-        }\n-    }\n-\n-    fn check_block_post(&mut self, _: &LateContext<'tcx>, block: &'tcx Block<'_>) {\n-        if self.last.map_or(false, |id| block.hir_id == id) {\n-            self.last = None;\n-        }\n-    }\n-\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n         if_chain! {\n             if let ExprKind::Call(ref fun, ref args) = expr.kind;\n@@ -150,12 +99,7 @@ fn is_trivial_regex(s: &regex_syntax::hir::Hir) -> Option<&'static str> {\n     use regex_syntax::hir::Anchor::{EndText, StartText};\n     use regex_syntax::hir::HirKind::{Alternation, Anchor, Concat, Empty, Literal};\n \n-    let is_literal = |e: &[regex_syntax::hir::Hir]| {\n-        e.iter().all(|e| match *e.kind() {\n-            Literal(_) => true,\n-            _ => false,\n-        })\n-    };\n+    let is_literal = |e: &[regex_syntax::hir::Hir]| e.iter().all(|e| matches!(*e.kind(), Literal(_)));\n \n     match *s.kind() {\n         Empty | Anchor(_) => Some(\"the regex is unlikely to be useful as it is\"),"}, {"sha": "a3af369e41e5a1d72429f77735fb7dac41ac500c", "filename": "src/tools/clippy/clippy_lints/src/repeat_once.rs", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Frepeat_once.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,82 @@\n+use crate::consts::{constant_context, Constant};\n+use crate::utils::{in_macro, is_type_diagnostic_item, snippet, span_lint_and_sugg, walk_ptrs_ty};\n+use if_chain::if_chain;\n+use rustc_errors::Applicability;\n+use rustc_hir::{Expr, ExprKind};\n+use rustc_lint::{LateContext, LateLintPass};\n+use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+declare_clippy_lint! {\n+    /// **What it does:** Checks for usage of `.repeat(1)` and suggest the following method for each types.\n+    /// - `.to_string()` for `str`\n+    /// - `.clone()` for `String`\n+    /// - `.to_vec()` for `slice`\n+    ///\n+    /// **Why is this bad?** For example, `String.repeat(1)` is equivalent to `.clone()`. If cloning the string is the intention behind this, `clone()` should be used.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    ///\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = String::from(\"hello world\").repeat(1);\n+    /// }\n+    /// ```\n+    /// Use instead:\n+    /// ```rust\n+    /// fn main() {\n+    ///     let x = String::from(\"hello world\").clone();\n+    /// }\n+    /// ```\n+    pub REPEAT_ONCE,\n+    complexity,\n+    \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \"\n+}\n+\n+declare_lint_pass!(RepeatOnce => [REPEAT_ONCE]);\n+\n+impl<'tcx> LateLintPass<'tcx> for RepeatOnce {\n+    fn check_expr(&mut self, cx: &LateContext<'_>, expr: &'tcx Expr<'_>) {\n+        if_chain! {\n+            if let ExprKind::MethodCall(ref path, _, ref args, _) = expr.kind;\n+            if path.ident.name == sym!(repeat);\n+            if let Some(Constant::Int(1)) = constant_context(cx, cx.tables()).expr(&args[1]);\n+            if !in_macro(args[0].span);\n+            then {\n+                let ty = walk_ptrs_ty(cx.tables().expr_ty(&args[0]));\n+                if ty.is_str() {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        REPEAT_ONCE,\n+                        expr.span,\n+                        \"calling `repeat(1)` on str\",\n+                        \"consider using `.to_string()` instead\",\n+                        format!(\"{}.to_string()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if ty.builtin_index().is_some() {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        REPEAT_ONCE,\n+                        expr.span,\n+                        \"calling `repeat(1)` on slice\",\n+                        \"consider using `.to_vec()` instead\",\n+                        format!(\"{}.to_vec()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else if is_type_diagnostic_item(cx, ty, sym!(string_type)) {\n+                    span_lint_and_sugg(\n+                        cx,\n+                        REPEAT_ONCE,\n+                        expr.span,\n+                        \"calling `repeat(1)` on a string literal\",\n+                        \"consider using `.clone()` instead\",\n+                        format!(\"{}.clone()\", snippet(cx, args[0].span, r#\"\"...\"\"#)),\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "faef7e724dd056a8464957cfb91a5b4e6c53f157", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -259,15 +259,15 @@ fn is_unit_expr(expr: &ast::Expr) -> bool {\n \n fn lint_unneeded_unit_return(cx: &EarlyContext<'_>, ty: &ast::Ty, span: Span) {\n     let (ret_span, appl) = if let Ok(fn_source) = cx.sess().source_map().span_to_snippet(span.with_hi(ty.span.hi())) {\n-        if let Some(rpos) = fn_source.rfind(\"->\") {\n-            #[allow(clippy::cast_possible_truncation)]\n-            (\n-                ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n-                Applicability::MachineApplicable,\n-            )\n-        } else {\n-            (ty.span, Applicability::MaybeIncorrect)\n-        }\n+        fn_source\n+            .rfind(\"->\")\n+            .map_or((ty.span, Applicability::MaybeIncorrect), |rpos| {\n+                (\n+                    #[allow(clippy::cast_possible_truncation)]\n+                    ty.span.with_lo(BytePos(span.lo().0 + rpos as u32)),\n+                    Applicability::MachineApplicable,\n+                )\n+            })\n     } else {\n         (ty.span, Applicability::MaybeIncorrect)\n     };"}, {"sha": "194786c5c41451be22774b8db0ca7ba16350429b", "filename": "src/tools/clippy/clippy_lints/src/shadow.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fshadow.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -165,14 +165,7 @@ fn check_local<'tcx>(cx: &LateContext<'tcx>, local: &'tcx Local<'_>, bindings: &\n \n fn is_binding(cx: &LateContext<'_>, pat_id: HirId) -> bool {\n     let var_ty = cx.tables().node_type_opt(pat_id);\n-    if let Some(var_ty) = var_ty {\n-        match var_ty.kind {\n-            ty::Adt(..) => false,\n-            _ => true,\n-        }\n-    } else {\n-        false\n-    }\n+    var_ty.map_or(false, |var_ty| !matches!(var_ty.kind, ty::Adt(..)))\n }\n \n fn check_pat<'tcx>("}, {"sha": "1aeff1baa362e24a2362263c07a946e412abde46", "filename": "src/tools/clippy/clippy_lints/src/temporary_assignment.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftemporary_assignment.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -25,13 +25,7 @@ declare_clippy_lint! {\n fn is_temporary(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     match &expr.kind {\n         ExprKind::Struct(..) | ExprKind::Tup(..) => true,\n-        ExprKind::Path(qpath) => {\n-            if let Res::Def(DefKind::Const, ..) = cx.qpath_res(qpath, expr.hir_id) {\n-                true\n-            } else {\n-                false\n-            }\n-        },\n+        ExprKind::Path(qpath) => matches!(cx.qpath_res(qpath, expr.hir_id), Res::Def(DefKind::Const, ..)),\n         _ => false,\n     }\n }"}, {"sha": "0ef70311fb1cde5a80e9f21b20f21ed511d1093f", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,19 +1,19 @@\n use crate::utils::{in_macro, snippet, snippet_with_applicability, span_lint_and_help, SpanlessHash};\n+use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::Applicability;\n use rustc_hir::{GenericBound, Generics, WherePredicate};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n \n-#[derive(Copy, Clone)]\n-pub struct TraitBounds;\n-\n declare_clippy_lint! {\n     /// **What it does:** This lint warns about unnecessary type repetitions in trait bounds\n     ///\n     /// **Why is this bad?** Repeating the type for every bound makes the code\n     /// less readable than combining the bounds\n     ///\n+    /// **Known problems:** None.\n+    ///\n     /// **Example:**\n     /// ```rust\n     /// pub fn foo<T>(t: T) where T: Copy, T: Clone {}\n@@ -29,6 +29,18 @@ declare_clippy_lint! {\n     \"Types are repeated unnecessary in trait bounds use `+` instead of using `T: _, T: _`\"\n }\n \n+#[derive(Copy, Clone)]\n+pub struct TraitBounds {\n+    max_trait_bounds: u64,\n+}\n+\n+impl TraitBounds {\n+    #[must_use]\n+    pub fn new(max_trait_bounds: u64) -> Self {\n+        Self { max_trait_bounds }\n+    }\n+}\n+\n impl_lint_pass!(TraitBounds => [TYPE_REPETITION_IN_BOUNDS]);\n \n impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n@@ -44,9 +56,14 @@ impl<'tcx> LateLintPass<'tcx> for TraitBounds {\n         let mut map = FxHashMap::default();\n         let mut applicability = Applicability::MaybeIncorrect;\n         for bound in gen.where_clause.predicates {\n-            if let WherePredicate::BoundPredicate(ref p) = bound {\n+            if_chain! {\n+                if let WherePredicate::BoundPredicate(ref p) = bound;\n+                if p.bounds.len() as u64 <= self.max_trait_bounds;\n+                if !in_macro(p.span);\n                 let h = hash(&p.bounded_ty);\n-                if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>()) {\n+                if let Some(ref v) = map.insert(h, p.bounds.iter().collect::<Vec<_>>());\n+\n+                then {\n                     let mut hint_string = format!(\n                         \"consider combining the bounds: `{}:\",\n                         snippet(cx, p.bounded_ty.span, \"_\")"}, {"sha": "bca388ecdcc3846b4b317808547cbb054471ca42", "filename": "src/tools/clippy/clippy_lints/src/types.rs", "status": "modified", "additions": 21, "deletions": 31, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -775,11 +775,7 @@ impl<'tcx> LateLintPass<'tcx> for UnitArg {\n                     .iter()\n                     .filter(|arg| {\n                         if is_unit(cx.tables().expr_ty(arg)) && !is_unit_literal(arg) {\n-                            if let ExprKind::Match(.., MatchSource::TryDesugar) = &arg.kind {\n-                                false\n-                            } else {\n-                                true\n-                            }\n+                            !matches!(&arg.kind, ExprKind::Match(.., MatchSource::TryDesugar))\n                         } else {\n                             false\n                         }\n@@ -899,17 +895,11 @@ fn is_questionmark_desugar_marked_call(expr: &Expr<'_>) -> bool {\n }\n \n fn is_unit(ty: Ty<'_>) -> bool {\n-    match ty.kind {\n-        ty::Tuple(slice) if slice.is_empty() => true,\n-        _ => false,\n-    }\n+    matches!(ty.kind, ty::Tuple(slice) if slice.is_empty())\n }\n \n fn is_unit_literal(expr: &Expr<'_>) -> bool {\n-    match expr.kind {\n-        ExprKind::Tup(ref slice) if slice.is_empty() => true,\n-        _ => false,\n-    }\n+    matches!(expr.kind, ExprKind::Tup(ref slice) if slice.is_empty())\n }\n \n declare_clippy_lint! {\n@@ -1154,10 +1144,7 @@ fn int_ty_to_nbits(typ: Ty<'_>, tcx: TyCtxt<'_>) -> u64 {\n }\n \n fn is_isize_or_usize(typ: Ty<'_>) -> bool {\n-    match typ.kind {\n-        ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize) => true,\n-        _ => false,\n-    }\n+    matches!(typ.kind, ty::Int(IntTy::Isize) | ty::Uint(UintTy::Usize))\n }\n \n fn span_precision_loss_lint(cx: &LateContext<'_>, expr: &Expr<'_>, cast_from: Ty<'_>, cast_to_f64: bool) {\n@@ -1205,16 +1192,19 @@ fn span_lossless_lint(cx: &LateContext<'_>, expr: &Expr<'_>, op: &Expr<'_>, cast\n     // has parens on the outside, they are no longer needed.\n     let mut applicability = Applicability::MachineApplicable;\n     let opt = snippet_opt(cx, op.span);\n-    let sugg = if let Some(ref snip) = opt {\n-        if should_strip_parens(op, snip) {\n-            &snip[1..snip.len() - 1]\n-        } else {\n-            snip.as_str()\n-        }\n-    } else {\n-        applicability = Applicability::HasPlaceholders;\n-        \"..\"\n-    };\n+    let sugg = opt.as_ref().map_or_else(\n+        || {\n+            applicability = Applicability::HasPlaceholders;\n+            \"..\"\n+        },\n+        |snip| {\n+            if should_strip_parens(op, snip) {\n+                &snip[1..snip.len() - 1]\n+            } else {\n+                snip.as_str()\n+            }\n+        },\n+    );\n \n     span_lint_and_sugg(\n         cx,\n@@ -1734,10 +1724,10 @@ impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n \n             TyKind::TraitObject(ref param_bounds, _) => {\n                 let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n-                    bound.bound_generic_params.iter().any(|gen| match gen.kind {\n-                        GenericParamKind::Lifetime { .. } => true,\n-                        _ => false,\n-                    })\n+                    bound\n+                        .bound_generic_params\n+                        .iter()\n+                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n                 });\n                 if has_lifetime_parameters {\n                     // complex trait bounds like A<'a, 'b>"}, {"sha": "25d136e564d3ee8bd8e4633d3c33915ef502c91f", "filename": "src/tools/clippy/clippy_lints/src/unnamed_address.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnamed_address.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -58,10 +58,10 @@ declare_lint_pass!(UnnamedAddress => [FN_ADDRESS_COMPARISONS, VTABLE_ADDRESS_COM\n impl LateLintPass<'_> for UnnamedAddress {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &Expr<'_>) {\n         fn is_comparison(binop: BinOpKind) -> bool {\n-            match binop {\n-                BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ne | BinOpKind::Ge | BinOpKind::Gt => true,\n-                _ => false,\n-            }\n+            matches!(\n+                binop,\n+                BinOpKind::Eq | BinOpKind::Lt | BinOpKind::Le | BinOpKind::Ne | BinOpKind::Ge | BinOpKind::Gt\n+            )\n         }\n \n         fn is_trait_ptr(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n@@ -72,11 +72,7 @@ impl LateLintPass<'_> for UnnamedAddress {\n         }\n \n         fn is_fn_def(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n-            if let ty::FnDef(..) = cx.tables().expr_ty(expr).kind {\n-                true\n-            } else {\n-                false\n-            }\n+            matches!(cx.tables().expr_ty(expr).kind, ty::FnDef(..))\n         }\n \n         if_chain! {"}, {"sha": "91c1789a2ffb1b592da5b6c06132962fa074aed1", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 30, "deletions": 18, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -5,24 +5,23 @@ use if_chain::if_chain;\n use rustc_errors::Applicability;\n use rustc_hir::{Expr, ExprKind, Mutability, Param, Pat, PatKind, Path, PathSegment, QPath};\n use rustc_lint::{LateContext, LateLintPass};\n+use rustc_middle::ty::{self, subst::GenericArgKind};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::symbol::Ident;\n \n declare_clippy_lint! {\n     /// **What it does:**\n-    /// Detects when people use `Vec::sort_by` and pass in a function\n+    /// Detects uses of `Vec::sort_by` passing in a closure\n     /// which compares the two arguments, either directly or indirectly.\n     ///\n     /// **Why is this bad?**\n     /// It is more clear to use `Vec::sort_by_key` (or `Vec::sort` if\n-    /// possible) than to use `Vec::sort_by` and and a more complicated\n+    /// possible) than to use `Vec::sort_by` and a more complicated\n     /// closure.\n     ///\n     /// **Known problems:**\n-    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't\n-    /// imported by a use statement in the current frame, then a `use`\n-    /// statement that imports it will need to be added (which this lint\n-    /// can't do).\n+    /// If the suggested `Vec::sort_by_key` uses Reverse and it isn't already\n+    /// imported by a use statement, then it will need to be added manually.\n     ///\n     /// **Example:**\n     ///\n@@ -201,28 +200,41 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n             };\n             let vec_name = Sugg::hir(cx, &args[0], \"..\").to_string();\n             let unstable = name == \"sort_unstable_by\";\n+\n             if_chain! {\n                 if let ExprKind::Path(QPath::Resolved(_, Path {\n                     segments: [PathSegment { ident: left_name, .. }], ..\n                 })) = &left_expr.kind;\n                 if left_name == left_ident;\n                 then {\n-                    Some(LintTrigger::Sort(SortDetection { vec_name, unstable }))\n-                }\n-                else {\n-                    Some(LintTrigger::SortByKey(SortByKeyDetection {\n-                        vec_name,\n-                        unstable,\n-                        closure_arg,\n-                        closure_body,\n-                        reverse\n-                    }))\n+                    return Some(LintTrigger::Sort(SortDetection { vec_name, unstable }))\n+                } else {\n+                    if !key_returns_borrow(cx, left_expr) {\n+                        return Some(LintTrigger::SortByKey(SortByKeyDetection {\n+                            vec_name,\n+                            unstable,\n+                            closure_arg,\n+                            closure_body,\n+                            reverse\n+                        }))\n+                    }\n                 }\n             }\n-        } else {\n-            None\n         }\n     }\n+\n+    None\n+}\n+\n+fn key_returns_borrow(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n+    if let Some(def_id) = utils::fn_def_id(cx, expr) {\n+        let output = cx.tcx.fn_sig(def_id).output();\n+        let ty = output.skip_binder();\n+        return matches!(ty.kind, ty::Ref(..))\n+            || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n+    }\n+\n+    false\n }\n \n impl LateLintPass<'_> for UnnecessarySortBy {"}, {"sha": "502bf0c427954b616a817d91512586ff1f968d68", "filename": "src/tools/clippy/clippy_lints/src/unnested_or_patterns.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnested_or_patterns.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -72,8 +72,8 @@ impl EarlyLintPass for UnnestedOrPatterns {\n }\n \n fn lint_unnested_or_patterns(cx: &EarlyContext<'_>, pat: &Pat) {\n-    if !cx.sess.opts.unstable_features.is_nightly_build() {\n-        // User cannot do `#![feature(or_patterns)]`, so bail.\n+    if !cx.sess.features_untracked().or_patterns {\n+        // Do not suggest nesting the patterns if the feature `or_patterns` is not enabled.\n         return;\n     }\n \n@@ -400,8 +400,8 @@ fn extend_with_matching(\n \n /// Are the patterns in `ps1` and `ps2` equal save for `ps1[idx]` compared to `ps2[idx]`?\n fn eq_pre_post(ps1: &[P<Pat>], ps2: &[P<Pat>], idx: usize) -> bool {\n-    ps1[idx].is_rest() == ps2[idx].is_rest() // Avoid `[x, ..] | [x, 0]` => `[x, .. | 0]`.\n-        && ps1.len() == ps2.len()\n+    ps1.len() == ps2.len()\n+        && ps1[idx].is_rest() == ps2[idx].is_rest() // Avoid `[x, ..] | [x, 0]` => `[x, .. | 0]`.\n         && over(&ps1[..idx], &ps2[..idx], |l, r| eq_pat(l, r))\n         && over(&ps1[idx + 1..], &ps2[idx + 1..], |l, r| eq_pat(l, r))\n }"}, {"sha": "776c6bc57ca6f857c4d86b699d99a4d5f2351f41", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -167,14 +167,11 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n             if let TyKind::Path(QPath::Resolved(_, ref item_path)) = item_type.kind;\n             then {\n                 let parameters = &item_path.segments.last().expect(SEGMENTS_MSG).args;\n-                let should_check = if let Some(ref params) = *parameters {\n-                    !params.parenthesized && !params.args.iter().any(|arg| match arg {\n-                        GenericArg::Lifetime(_) => true,\n-                        _ => false,\n-                    })\n-                } else {\n-                    true\n-                };\n+                let should_check = parameters.as_ref().map_or(\n+                    true,\n+                    |params| !params.parenthesized\n+                        &&!params.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)))\n+                );\n \n                 if should_check {\n                     let visitor = &mut UseSelfVisitor {"}, {"sha": "58c1103da9f7dfed78e7039b107944057e7eecb9", "filename": "src/tools/clippy/clippy_lints/src/utils/ast_utils.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fast_utils.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -387,10 +387,7 @@ pub fn eq_use_tree_kind(l: &UseTreeKind, r: &UseTreeKind) -> bool {\n }\n \n pub fn eq_defaultness(l: Defaultness, r: Defaultness) -> bool {\n-    match (l, r) {\n-        (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)) => true,\n-        _ => false,\n-    }\n+    matches!((l, r), (Defaultness::Final, Defaultness::Final) | (Defaultness::Default(_), Defaultness::Default(_)))\n }\n \n pub fn eq_vis(l: &Visibility, r: &Visibility) -> bool {"}, {"sha": "4bb4b087c5566773b5dfa9249c936a486b103f98", "filename": "src/tools/clippy/clippy_lints/src/utils/attrs.rs", "status": "modified", "additions": 36, "deletions": 33, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fattrs.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -65,42 +65,45 @@ pub fn get_attr<'a>(\n         };\n         let attr_segments = &attr.path.segments;\n         if attr_segments.len() == 2 && attr_segments[0].ident.to_string() == \"clippy\" {\n-            if let Some(deprecation_status) =\n-                BUILTIN_ATTRIBUTES\n-                    .iter()\n-                    .find_map(|(builtin_name, deprecation_status)| {\n-                        if *builtin_name == attr_segments[1].ident.to_string() {\n-                            Some(deprecation_status)\n-                        } else {\n-                            None\n-                        }\n-                    })\n-            {\n-                let mut diag = sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n-                match *deprecation_status {\n-                    DeprecationStatus::Deprecated => {\n-                        diag.emit();\n-                        false\n-                    },\n-                    DeprecationStatus::Replaced(new_name) => {\n-                        diag.span_suggestion(\n-                            attr_segments[1].ident.span,\n-                            \"consider using\",\n-                            new_name.to_string(),\n-                            Applicability::MachineApplicable,\n-                        );\n-                        diag.emit();\n+            BUILTIN_ATTRIBUTES\n+                .iter()\n+                .find_map(|(builtin_name, deprecation_status)| {\n+                    if *builtin_name == attr_segments[1].ident.to_string() {\n+                        Some(deprecation_status)\n+                    } else {\n+                        None\n+                    }\n+                })\n+                .map_or_else(\n+                    || {\n+                        sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n                         false\n                     },\n-                    DeprecationStatus::None => {\n-                        diag.cancel();\n-                        attr_segments[1].ident.to_string() == name\n+                    |deprecation_status| {\n+                        let mut diag =\n+                            sess.struct_span_err(attr_segments[1].ident.span, \"Usage of deprecated attribute\");\n+                        match *deprecation_status {\n+                            DeprecationStatus::Deprecated => {\n+                                diag.emit();\n+                                false\n+                            },\n+                            DeprecationStatus::Replaced(new_name) => {\n+                                diag.span_suggestion(\n+                                    attr_segments[1].ident.span,\n+                                    \"consider using\",\n+                                    new_name.to_string(),\n+                                    Applicability::MachineApplicable,\n+                                );\n+                                diag.emit();\n+                                false\n+                            },\n+                            DeprecationStatus::None => {\n+                                diag.cancel();\n+                                attr_segments[1].ident.to_string() == name\n+                            },\n+                        }\n                     },\n-                }\n-            } else {\n-                sess.span_err(attr_segments[1].ident.span, \"Usage of unknown attribute\");\n-                false\n-            }\n+                )\n         } else {\n             false\n         }"}, {"sha": "de425211e38ef60b99011a5307377d6fb63c55cf", "filename": "src/tools/clippy/clippy_lints/src/utils/conf.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fconf.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -156,6 +156,8 @@ define_Conf! {\n     (array_size_threshold, \"array_size_threshold\": u64, 512_000),\n     /// Lint: VEC_BOX. The size of the boxed type in bytes, where boxing in a `Vec` is allowed\n     (vec_box_size_threshold, \"vec_box_size_threshold\": u64, 4096),\n+    /// Lint: TYPE_REPETITION_IN_BOUNDS. The maximum number of bounds a trait can have to be linted\n+    (max_trait_bounds, \"max_trait_bounds\": u64, 3),\n     /// Lint: STRUCT_EXCESSIVE_BOOLS. The maximum number of bools a struct can have\n     (max_struct_bools, \"max_struct_bools\": u64, 3),\n     /// Lint: FN_PARAMS_EXCESSIVE_BOOLS. The maximum number of bools function parameters can have"}, {"sha": "34341594c1985ef41a7a48b84198fad986c59233", "filename": "src/tools/clippy/clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -703,6 +703,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                     }\n                     for segment in path.segments {\n                         segment.ident.name.hash(&mut self.s);\n+                        self.hash_generic_args(segment.generic_args().args);\n                     }\n                 },\n                 QPath::TypeRelative(ref ty, ref segment) => {\n@@ -711,13 +712,7 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n                 },\n             },\n             TyKind::OpaqueDef(_, arg_list) => {\n-                for arg in *arg_list {\n-                    match arg {\n-                        GenericArg::Lifetime(ref l) => self.hash_lifetime(l),\n-                        GenericArg::Type(ref ty) => self.hash_ty(&ty),\n-                        GenericArg::Const(ref ca) => self.hash_body(ca.value.body),\n-                    }\n-                }\n+                self.hash_generic_args(arg_list);\n             },\n             TyKind::TraitObject(_, lifetime) => {\n                 self.hash_lifetime(lifetime);\n@@ -735,4 +730,14 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         self.hash_expr(&self.cx.tcx.hir().body(body_id).value);\n         self.maybe_typeck_tables = old_maybe_typeck_tables;\n     }\n+\n+    fn hash_generic_args(&mut self, arg_list: &[GenericArg<'_>]) {\n+        for arg in arg_list {\n+            match arg {\n+                GenericArg::Lifetime(ref l) => self.hash_lifetime(l),\n+                GenericArg::Type(ref ty) => self.hash_ty(&ty),\n+                GenericArg::Const(ref ca) => self.hash_body(ca.value.body),\n+            }\n+        }\n+    }\n }"}, {"sha": "4b7a1c2b537f382c5a825eb631221bda07a005fc", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 37, "deletions": 51, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -102,11 +102,7 @@ pub fn in_constant(cx: &LateContext<'_>, id: HirId) -> bool {\n #[must_use]\n pub fn in_macro(span: Span) -> bool {\n     if span.from_expansion() {\n-        if let ExpnKind::Desugaring(..) = span.ctxt().outer_expn_data().kind {\n-            false\n-        } else {\n-            true\n-        }\n+        !matches!(span.ctxt().outer_expn_data().kind, ExpnKind::Desugaring(..))\n     } else {\n         false\n     }\n@@ -127,10 +123,7 @@ pub fn is_present_in_source<T: LintContext>(cx: &T, span: Span) -> bool {\n \n /// Checks if given pattern is a wildcard (`_`)\n pub fn is_wild<'tcx>(pat: &impl std::ops::Deref<Target = Pat<'tcx>>) -> bool {\n-    match pat.kind {\n-        PatKind::Wild => true,\n-        _ => false,\n-    }\n+    matches!(pat.kind, PatKind::Wild)\n }\n \n /// Checks if type is struct, enum or union type with the given def path.\n@@ -153,11 +146,7 @@ pub fn is_type_diagnostic_item(cx: &LateContext<'_>, ty: Ty<'_>, diag_item: Symb\n pub fn match_trait_method(cx: &LateContext<'_>, expr: &Expr<'_>, path: &[&str]) -> bool {\n     let def_id = cx.tables().type_dependent_def_id(expr.hir_id).unwrap();\n     let trt_id = cx.tcx.trait_of_item(def_id);\n-    if let Some(trt_id) = trt_id {\n-        match_def_path(cx, trt_id, path)\n-    } else {\n-        false\n-    }\n+    trt_id.map_or(false, |trt_id| match_def_path(cx, trt_id, path))\n }\n \n /// Checks if an expression references a variable of the given name.\n@@ -600,21 +589,15 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n /// //  ^^^^^^^^^^\n /// ```\n pub fn first_line_of_span<T: LintContext>(cx: &T, span: Span) -> Span {\n-    if let Some(first_char_pos) = first_char_in_first_line(cx, span) {\n-        span.with_lo(first_char_pos)\n-    } else {\n-        span\n-    }\n+    first_char_in_first_line(cx, span).map_or(span, |first_char_pos| span.with_lo(first_char_pos))\n }\n \n fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePos> {\n     let line_span = line_span(cx, span);\n-    if let Some(snip) = snippet_opt(cx, line_span) {\n+    snippet_opt(cx, line_span).and_then(|snip| {\n         snip.find(|c: char| !c.is_whitespace())\n             .map(|pos| line_span.lo() + BytePos::from_usize(pos))\n-    } else {\n-        None\n-    }\n+    })\n }\n \n /// Returns the indentation of the line of a span\n@@ -626,11 +609,7 @@ fn first_char_in_first_line<T: LintContext>(cx: &T, span: Span) -> Option<BytePo\n /// //          ^^ -- will return 4\n /// ```\n pub fn indent_of<T: LintContext>(cx: &T, span: Span) -> Option<usize> {\n-    if let Some(snip) = snippet_opt(cx, line_span(cx, span)) {\n-        snip.find(|c: char| !c.is_whitespace())\n-    } else {\n-        None\n-    }\n+    snippet_opt(cx, line_span(cx, span)).and_then(|snip| snip.find(|c: char| !c.is_whitespace()))\n }\n \n /// Extends the span to the beginning of the spans line, incl. whitespaces.\n@@ -738,25 +717,21 @@ pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Optio\n     let enclosing_node = map\n         .get_enclosing_scope(hir_id)\n         .and_then(|enclosing_id| map.find(enclosing_id));\n-    if let Some(node) = enclosing_node {\n-        match node {\n-            Node::Block(block) => Some(block),\n-            Node::Item(&Item {\n-                kind: ItemKind::Fn(_, _, eid),\n-                ..\n-            })\n-            | Node::ImplItem(&ImplItem {\n-                kind: ImplItemKind::Fn(_, eid),\n-                ..\n-            }) => match cx.tcx.hir().body(eid).value.kind {\n-                ExprKind::Block(ref block, _) => Some(block),\n-                _ => None,\n-            },\n+    enclosing_node.and_then(|node| match node {\n+        Node::Block(block) => Some(block),\n+        Node::Item(&Item {\n+            kind: ItemKind::Fn(_, _, eid),\n+            ..\n+        })\n+        | Node::ImplItem(&ImplItem {\n+            kind: ImplItemKind::Fn(_, eid),\n+            ..\n+        }) => match cx.tcx.hir().body(eid).value.kind {\n+            ExprKind::Block(ref block, _) => Some(block),\n             _ => None,\n-        }\n-    } else {\n-        None\n-    }\n+        },\n+        _ => None,\n+    })\n }\n \n /// Returns the base type for HIR references and pointers.\n@@ -1328,11 +1303,7 @@ pub fn is_must_use_func_call(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n         _ => None,\n     };\n \n-    if let Some(did) = did {\n-        must_use_attr(&cx.tcx.get_attrs(did)).is_some()\n-    } else {\n-        false\n-    }\n+    did.map_or(false, |did| must_use_attr(&cx.tcx.get_attrs(did)).is_some())\n }\n \n pub fn is_no_std_crate(krate: &Crate<'_>) -> bool {\n@@ -1385,6 +1356,21 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n     )\n }\n \n+/// Returns the `DefId` of the callee if the given expression is a function or method call.\n+pub fn fn_def_id(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<DefId> {\n+    match &expr.kind {\n+        ExprKind::MethodCall(..) => cx.tables().type_dependent_def_id(expr.hir_id),\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(qpath),\n+                ..\n+            },\n+            ..,\n+        ) => cx.tables().qpath_res(qpath, expr.hir_id).opt_def_id(),\n+        _ => None,\n+    }\n+}\n+\n pub fn run_lints(cx: &LateContext<'_>, lints: &[&'static Lint], id: HirId) -> bool {\n     lints.iter().any(|lint| {\n         matches!("}, {"sha": "87cb454f654bcfb9a2a8ad70c4cceac6ccbd3253", "filename": "src/tools/clippy/clippy_lints/src/utils/numeric_literal.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fnumeric_literal.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -51,7 +51,7 @@ impl<'a> NumericLiteral<'a> {\n     pub fn from_lit_kind(src: &'a str, lit_kind: &LitKind) -> Option<NumericLiteral<'a>> {\n         if lit_kind.is_numeric() && src.chars().next().map_or(false, |c| c.is_digit(10)) {\n             let (unsuffixed, suffix) = split_suffix(&src, lit_kind);\n-            let float = if let LitKind::Float(..) = lit_kind { true } else { false };\n+            let float = matches!(lit_kind, LitKind::Float(..));\n             Some(NumericLiteral::new(unsuffixed, suffix, float))\n         } else {\n             None\n@@ -200,12 +200,10 @@ impl<'a> NumericLiteral<'a> {\n \n fn split_suffix<'a>(src: &'a str, lit_kind: &LitKind) -> (&'a str, Option<&'a str>) {\n     debug_assert!(lit_kind.is_numeric());\n-    if let Some(suffix_length) = lit_suffix_length(lit_kind) {\n+    lit_suffix_length(lit_kind).map_or((src, None), |suffix_length| {\n         let (unsuffixed, suffix) = src.split_at(src.len() - suffix_length);\n         (unsuffixed, Some(suffix))\n-    } else {\n-        (src, None)\n-    }\n+    })\n }\n \n fn lit_suffix_length(lit_kind: &LitKind) -> Option<usize> {"}, {"sha": "4c3462802e9218535b8343bc10b1946a3c3adb87", "filename": "src/tools/clippy/clippy_lints/src/utils/paths.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fpaths.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -98,7 +98,6 @@ pub const RANGE_TO_STD: [&str; 3] = [\"std\", \"ops\", \"RangeTo\"];\n pub const RC: [&str; 3] = [\"alloc\", \"rc\", \"Rc\"];\n pub const RC_PTR_EQ: [&str; 4] = [\"alloc\", \"rc\", \"Rc\", \"ptr_eq\"];\n pub const RECEIVER: [&str; 4] = [\"std\", \"sync\", \"mpsc\", \"Receiver\"];\n-pub const REGEX: [&str; 3] = [\"regex\", \"re_unicode\", \"Regex\"];\n pub const REGEX_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"unicode\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_BUILDER_NEW: [&str; 5] = [\"regex\", \"re_builder\", \"bytes\", \"RegexBuilder\", \"new\"];\n pub const REGEX_BYTES_NEW: [&str; 4] = [\"regex\", \"re_bytes\", \"Regex\", \"new\"];"}, {"sha": "0ac7714fbeb79cd9b3feb6d3665b437c72aabcd0", "filename": "src/tools/clippy/clippy_lints/src/utils/sugg.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -325,22 +325,22 @@ pub fn make_unop(op: &str, expr: Sugg<'_>) -> Sugg<'static> {\n /// parenthesis will always be added for a mix of these.\n pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static> {\n     /// Returns `true` if the operator is a shift operator `<<` or `>>`.\n-    fn is_shift(op: &AssocOp) -> bool {\n-        matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n+    fn is_shift(op: AssocOp) -> bool {\n+        matches!(op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n     }\n \n     /// Returns `true` if the operator is a arithmetic operator\n     /// (i.e., `+`, `-`, `*`, `/`, `%`).\n-    fn is_arith(op: &AssocOp) -> bool {\n+    fn is_arith(op: AssocOp) -> bool {\n         matches!(\n-            *op,\n+            op,\n             AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus\n         )\n     }\n \n     /// Returns `true` if the operator `op` needs parenthesis with the operator\n     /// `other` in the direction `dir`.\n-    fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n+    fn needs_paren(op: AssocOp, other: AssocOp, dir: Associativity) -> bool {\n         other.precedence() < op.precedence()\n             || (other.precedence() == op.precedence()\n                 && ((op != other && associativity(op) != dir)\n@@ -349,14 +349,14 @@ pub fn make_assoc(op: AssocOp, lhs: &Sugg<'_>, rhs: &Sugg<'_>) -> Sugg<'static>\n             || is_shift(other) && is_arith(op)\n     }\n \n-    let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n-        needs_paren(&op, lop, Associativity::Left)\n+    let lhs_paren = if let Sugg::BinOp(lop, _) = *lhs {\n+        needs_paren(op, lop, Associativity::Left)\n     } else {\n         false\n     };\n \n-    let rhs_paren = if let Sugg::BinOp(ref rop, _) = *rhs {\n-        needs_paren(&op, rop, Associativity::Right)\n+    let rhs_paren = if let Sugg::BinOp(rop, _) = *rhs {\n+        needs_paren(op, rop, Associativity::Right)\n     } else {\n         false\n     };\n@@ -424,13 +424,13 @@ enum Associativity {\n /// they are considered\n /// associative.\n #[must_use]\n-fn associativity(op: &AssocOp) -> Associativity {\n+fn associativity(op: AssocOp) -> Associativity {\n     use rustc_ast::util::parser::AssocOp::{\n         Add, As, Assign, AssignOp, BitAnd, BitOr, BitXor, Colon, Divide, DotDot, DotDotEq, Equal, Greater,\n         GreaterEqual, LAnd, LOr, Less, LessEqual, Modulus, Multiply, NotEqual, ShiftLeft, ShiftRight, Subtract,\n     };\n \n-    match *op {\n+    match op {\n         Assign | AssignOp(_) => Associativity::Right,\n         Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply | As | Colon => Associativity::Both,\n         Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft | ShiftRight\n@@ -492,20 +492,20 @@ fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n /// before it on its line.\n fn indentation<T: LintContext>(cx: &T, span: Span) -> Option<String> {\n     let lo = cx.sess().source_map().lookup_char_pos(span.lo());\n-    if let Some(line) = lo.file.get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */) {\n-        if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n-            // We can mix char and byte positions here because we only consider `[ \\t]`.\n-            if lo.col == CharPos(pos) {\n-                Some(line[..pos].into())\n+    lo.file\n+        .get_line(lo.line - 1 /* line numbers in `Loc` are 1-based */)\n+        .and_then(|line| {\n+            if let Some((pos, _)) = line.char_indices().find(|&(_, c)| c != ' ' && c != '\\t') {\n+                // We can mix char and byte positions here because we only consider `[ \\t]`.\n+                if lo.col == CharPos(pos) {\n+                    Some(line[..pos].into())\n+                } else {\n+                    None\n+                }\n             } else {\n                 None\n             }\n-        } else {\n-            None\n-        }\n-    } else {\n-        None\n-    }\n+        })\n }\n \n /// Convenience extension trait for `DiagnosticBuilder`."}, {"sha": "063f94582b9d14cc38f138d8914e8ce178aaae66", "filename": "src/tools/clippy/clippy_lints/src/write.rs", "status": "modified", "additions": 24, "deletions": 6, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fwrite.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -23,7 +23,11 @@ declare_clippy_lint! {\n     ///\n     /// **Example:**\n     /// ```rust\n+    /// // Bad\n     /// println!(\"\");\n+    ///\n+    /// // Good\n+    /// println!();\n     /// ```\n     pub PRINTLN_EMPTY_STRING,\n     style,\n@@ -32,8 +36,7 @@ declare_clippy_lint! {\n \n declare_clippy_lint! {\n     /// **What it does:** This lint warns when you use `print!()` with a format\n-    /// string that\n-    /// ends in a newline.\n+    /// string that ends in a newline.\n     ///\n     /// **Why is this bad?** You should use `println!()` instead, which appends the\n     /// newline.\n@@ -125,7 +128,12 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n+    ///\n+    /// // Bad\n     /// writeln!(buf, \"\");\n+    ///\n+    /// // Good\n+    /// writeln!(buf);\n     /// ```\n     pub WRITELN_EMPTY_STRING,\n     style,\n@@ -147,7 +155,12 @@ declare_clippy_lint! {\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n     /// # let name = \"World\";\n+    ///\n+    /// // Bad\n     /// write!(buf, \"Hello {}!\\n\", name);\n+    ///\n+    /// // Good\n+    /// writeln!(buf, \"Hello {}!\", name);\n     /// ```\n     pub WRITE_WITH_NEWLINE,\n     style,\n@@ -168,7 +181,12 @@ declare_clippy_lint! {\n     /// ```rust\n     /// # use std::fmt::Write;\n     /// # let mut buf = String::new();\n+    ///\n+    /// // Bad\n     /// writeln!(buf, \"{}\", \"foo\");\n+    ///\n+    /// // Good\n+    /// writeln!(buf, \"foo\");\n     /// ```\n     pub WRITE_LITERAL,\n     style,\n@@ -279,13 +297,13 @@ impl EarlyLintPass for Write {\n             if let (Some(fmt_str), expr) = self.check_tts(cx, &mac.args.inner_tokens(), true) {\n                 if fmt_str.symbol == Symbol::intern(\"\") {\n                     let mut applicability = Applicability::MachineApplicable;\n-                    let suggestion = match expr {\n-                        Some(expr) => snippet_with_applicability(cx, expr.span, \"v\", &mut applicability),\n-                        None => {\n+                    let suggestion = expr.map_or_else(\n+                        || {\n                             applicability = Applicability::HasPlaceholders;\n                             Cow::Borrowed(\"v\")\n                         },\n-                    };\n+                        |e| snippet_with_applicability(cx, e.span, \"v\", &mut Applicability::MachineApplicable),\n+                    );\n \n                     span_lint_and_sugg(\n                         cx,"}, {"sha": "47315fa64cd8019cba3c508de3d960a6c50ebcc0", "filename": "src/tools/clippy/src/driver.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Fdriver.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -382,13 +382,8 @@ pub fn main() {\n \n         let should_describe_lints = || {\n             let args: Vec<_> = env::args().collect();\n-            args.windows(2).any(|args| {\n-                args[1] == \"help\"\n-                    && match args[0].as_str() {\n-                        \"-W\" | \"-A\" | \"-D\" | \"-F\" => true,\n-                        _ => false,\n-                    }\n-            })\n+            args.windows(2)\n+                .any(|args| args[1] == \"help\" && matches!(args[0].as_str(), \"-W\" | \"-A\" | \"-D\" | \"-F\"))\n         };\n \n         if !wrapper_mode && should_describe_lints() {"}, {"sha": "b89a87128626bc927db31c27665d220c452c52fd", "filename": "src/tools/clippy/src/lintlist/mod.rs", "status": "modified", "additions": 41, "deletions": 6, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fsrc%2Flintlist%2Fmod.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -80,6 +80,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"blacklisted_name\",\n     },\n+    Lint {\n+        name: \"blanket_clippy_restriction_lints\",\n+        group: \"style\",\n+        desc: \"enabling the complete restriction group\",\n+        deprecation: None,\n+        module: \"attrs\",\n+    },\n     Lint {\n         name: \"blocks_in_if_conditions\",\n         group: \"style\",\n@@ -1144,6 +1151,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"methods\",\n     },\n+    Lint {\n+        name: \"map_identity\",\n+        group: \"complexity\",\n+        desc: \"using iterator.map(|x| x)\",\n+        deprecation: None,\n+        module: \"map_identity\",\n+    },\n     Lint {\n         name: \"map_unwrap_or\",\n         group: \"pedantic\",\n@@ -1165,6 +1179,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"matches\",\n     },\n+    Lint {\n+        name: \"match_like_matches_macro\",\n+        group: \"style\",\n+        desc: \"a match that could be written with the matches! macro\",\n+        deprecation: None,\n+        module: \"matches\",\n+    },\n     Lint {\n         name: \"match_on_vec_items\",\n         group: \"pedantic\",\n@@ -1606,6 +1627,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"option_env_unwrap\",\n     },\n+    Lint {\n+        name: \"option_if_let_else\",\n+        group: \"pedantic\",\n+        desc: \"reimplementation of Option::map_or\",\n+        deprecation: None,\n+        module: \"option_if_let_else\",\n+    },\n     Lint {\n         name: \"option_map_or_none\",\n         group: \"style\",\n@@ -1683,6 +1711,13 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         deprecation: None,\n         module: \"path_buf_push_overwrite\",\n     },\n+    Lint {\n+        name: \"pattern_type_mismatch\",\n+        group: \"restriction\",\n+        desc: \"type of pattern does not match the expression type\",\n+        deprecation: None,\n+        module: \"pattern_type_mismatch\",\n+    },\n     Lint {\n         name: \"possible_missing_comma\",\n         group: \"correctness\",\n@@ -1755,7 +1790,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n     },\n     Lint {\n         name: \"range_minus_one\",\n-        group: \"complexity\",\n+        group: \"pedantic\",\n         desc: \"`x..=(y-1)` reads better as `x..y`\",\n         deprecation: None,\n         module: \"ranges\",\n@@ -1828,7 +1863,7 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         group: \"style\",\n         desc: \"use the proper utility function avoiding an `if let`\",\n         deprecation: None,\n-        module: \"redundant_pattern_matching\",\n+        module: \"matches\",\n     },\n     Lint {\n         name: \"redundant_pub_crate\",\n@@ -1852,11 +1887,11 @@ pub static ref ALL_LINTS: Vec<Lint> = vec![\n         module: \"reference\",\n     },\n     Lint {\n-        name: \"regex_macro\",\n-        group: \"style\",\n-        desc: \"use of `regex!(_)` instead of `Regex::new(_)`\",\n+        name: \"repeat_once\",\n+        group: \"complexity\",\n+        desc: \"using `.repeat(1)` instead of `String.clone()`, `str.to_string()` or `slice.to_vec()` \",\n         deprecation: None,\n-        module: \"regex\",\n+        module: \"repeat_once\",\n     },\n     Lint {\n         name: \"rest_pat_in_fully_bound_structs\","}, {"sha": "26a47d237065a9f0c16cc3db6638a014b9ae86b7", "filename": "src/tools/clippy/tests/compile-test.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fcompile-test.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -12,19 +12,11 @@ use std::path::{Path, PathBuf};\n mod cargo;\n \n fn host_lib() -> PathBuf {\n-    if let Some(path) = option_env!(\"HOST_LIBS\") {\n-        PathBuf::from(path)\n-    } else {\n-        cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\"))\n-    }\n+    option_env!(\"HOST_LIBS\").map_or(cargo::CARGO_TARGET_DIR.join(env!(\"PROFILE\")), PathBuf::from)\n }\n \n fn clippy_driver_path() -> PathBuf {\n-    if let Some(path) = option_env!(\"CLIPPY_DRIVER_PATH\") {\n-        PathBuf::from(path)\n-    } else {\n-        cargo::TARGET_LIB.join(\"clippy-driver\")\n-    }\n+    option_env!(\"CLIPPY_DRIVER_PATH\").map_or(cargo::TARGET_LIB.join(\"clippy-driver\"), PathBuf::from)\n }\n \n // When we'll want to use `extern crate ..` for a dependency that is used"}, {"sha": "7e96aa36feb45635355b372e0ac6bb9ba3a11bcb", "filename": "src/tools/clippy/tests/ui-cargo/multiple_crate_versions/fail/Cargo.lock", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2FCargo.lock?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,109 @@\n+# This file is automatically @generated by Cargo.\n+# It is not intended for manual editing.\n+[[package]]\n+name = \"ansi_term\"\n+version = \"0.11.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ee49baf6cb617b853aa8d93bf420db2383fab46d314482ca2803b40d5fde979b\"\n+dependencies = [\n+ \"winapi 0.3.9\",\n+]\n+\n+[[package]]\n+name = \"bitflags\"\n+version = \"0.9.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4efd02e230a02e18f92fc2735f44597385ed02ad8f831e7c1c1156ee5e1ab3a5\"\n+\n+[[package]]\n+name = \"cfg-if\"\n+version = \"0.1.10\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822\"\n+\n+[[package]]\n+name = \"ctrlc\"\n+version = \"3.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"653abc99aa905f693d89df4797fadc08085baee379db92be9f2496cefe8a6f2c\"\n+dependencies = [\n+ \"kernel32-sys\",\n+ \"nix\",\n+ \"winapi 0.2.8\",\n+]\n+\n+[[package]]\n+name = \"kernel32-sys\"\n+version = \"0.2.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"7507624b29483431c0ba2d82aece8ca6cdba9382bff4ddd0f7490560c056098d\"\n+dependencies = [\n+ \"winapi 0.2.8\",\n+ \"winapi-build\",\n+]\n+\n+[[package]]\n+name = \"libc\"\n+version = \"0.2.71\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"9457b06509d27052635f90d6466700c65095fdf75409b3fbdd903e988b886f49\"\n+\n+[[package]]\n+name = \"multiple_crate_versions\"\n+version = \"0.1.0\"\n+dependencies = [\n+ \"ansi_term\",\n+ \"ctrlc\",\n+]\n+\n+[[package]]\n+name = \"nix\"\n+version = \"0.9.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"a2c5afeb0198ec7be8569d666644b574345aad2e95a53baf3a532da3e0f3fb32\"\n+dependencies = [\n+ \"bitflags\",\n+ \"cfg-if\",\n+ \"libc\",\n+ \"void\",\n+]\n+\n+[[package]]\n+name = \"void\"\n+version = \"1.0.2\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"6a02e4885ed3bc0f2de90ea6dd45ebcbb66dacffe03547fadbb0eeae2770887d\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.2.8\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"167dc9d6949a9b857f3451275e911c3f44255842c1f7a76f33c55103a909087a\"\n+\n+[[package]]\n+name = \"winapi\"\n+version = \"0.3.9\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"5c839a674fcd7a98952e593242ea400abe93992746761e38641405d28b00f419\"\n+dependencies = [\n+ \"winapi-i686-pc-windows-gnu\",\n+ \"winapi-x86_64-pc-windows-gnu\",\n+]\n+\n+[[package]]\n+name = \"winapi-build\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"2d315eee3b34aca4797b2da6b13ed88266e6d612562a0c46390af8299fc699bc\"\n+\n+[[package]]\n+name = \"winapi-i686-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6\"\n+\n+[[package]]\n+name = \"winapi-x86_64-pc-windows-gnu\"\n+version = \"0.4.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f\""}, {"sha": "f3113e093650221171de886a7701689239b55516", "filename": "src/tools/clippy/tests/ui-cargo/multiple_crate_versions/fail/src/main.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-cargo%2Fmultiple_crate_versions%2Ffail%2Fsrc%2Fmain.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,4 +1,4 @@\n-error: multiple versions for dependency `winapi`: 0.2.8, 0.3.8\n+error: multiple versions for dependency `winapi`: 0.2.8, 0.3.9\n    |\n    = note: `-D clippy::multiple-crate-versions` implied by `-D warnings`\n "}, {"sha": "6fbba01416a8d5a27ed47c0b8ae60206ccc1f5fe", "filename": "src/tools/clippy/tests/ui-toml/toml_unknown_key/conf_unknown_key.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui-toml%2Ftoml_unknown_key%2Fconf_unknown_key.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,4 +1,4 @@\n-error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `third-party` at line 5 column 1\n+error: error reading Clippy's configuration file `$DIR/clippy.toml`: unknown field `foobar`, expected one of `blacklisted-names`, `cognitive-complexity-threshold`, `cyclomatic-complexity-threshold`, `doc-valid-idents`, `too-many-arguments-threshold`, `type-complexity-threshold`, `single-char-binding-names-threshold`, `too-large-for-stack`, `enum-variant-name-threshold`, `enum-variant-size-threshold`, `verbose-bit-mask-threshold`, `literal-representation-threshold`, `trivial-copy-size-limit`, `too-many-lines-threshold`, `array-size-threshold`, `vec-box-size-threshold`, `max-trait-bounds`, `max-struct-bools`, `max-fn-params-bools`, `warn-on-all-wildcard-imports`, `third-party` at line 5 column 1\n \n error: aborting due to previous error\n "}, {"sha": "908d063729f45c4bcdb0a41dc6fb18bfc73c470d", "filename": "src/tools/clippy/tests/ui/attrs.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,5 +1,11 @@\n #![warn(clippy::inline_always, clippy::deprecated_semver)]\n #![allow(clippy::assertions_on_constants)]\n+// Test that the whole restriction group is not enabled\n+#![warn(clippy::restriction)]\n+#![deny(clippy::restriction)]\n+#![forbid(clippy::restriction)]\n+#![allow(clippy::missing_docs_in_private_items, clippy::panic, clippy::unreachable)]\n+\n #[inline(always)]\n fn test_attr_lint() {\n     assert!(true)"}, {"sha": "ef4b89eaa6dee41522557104579adbdca5031133", "filename": "src/tools/clippy/tests/ui/attrs.stderr", "status": "modified", "additions": 29, "deletions": 4, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fattrs.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,24 +1,49 @@\n error: you have declared `#[inline(always)]` on `test_attr_lint`. This is usually a bad idea\n-  --> $DIR/attrs.rs:3:1\n+  --> $DIR/attrs.rs:9:1\n    |\n LL | #[inline(always)]\n    | ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::inline-always` implied by `-D warnings`\n \n error: the since field must contain a semver-compliant version\n-  --> $DIR/attrs.rs:23:14\n+  --> $DIR/attrs.rs:29:14\n    |\n LL | #[deprecated(since = \"forever\")]\n    |              ^^^^^^^^^^^^^^^^^\n    |\n    = note: `-D clippy::deprecated-semver` implied by `-D warnings`\n \n error: the since field must contain a semver-compliant version\n-  --> $DIR/attrs.rs:26:14\n+  --> $DIR/attrs.rs:32:14\n    |\n LL | #[deprecated(since = \"1\")]\n    |              ^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors\n+error: restriction lints are not meant to be all enabled\n+  --> $DIR/attrs.rs:4:9\n+   |\n+LL | #![warn(clippy::restriction)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::blanket-clippy-restriction-lints` implied by `-D warnings`\n+   = help: try enabling only the lints you really need\n+\n+error: restriction lints are not meant to be all enabled\n+  --> $DIR/attrs.rs:5:9\n+   |\n+LL | #![deny(clippy::restriction)]\n+   |         ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try enabling only the lints you really need\n+\n+error: restriction lints are not meant to be all enabled\n+  --> $DIR/attrs.rs:6:11\n+   |\n+LL | #![forbid(clippy::restriction)]\n+   |           ^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: try enabling only the lints you really need\n+\n+error: aborting due to 6 previous errors\n "}, {"sha": "1f0ca101757ec849a7d51ef30db43894f7dc742f", "filename": "src/tools/clippy/tests/ui/clone_on_copy.fixed", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+\n+#![allow(\n+    unused,\n+    clippy::redundant_clone,\n+    clippy::deref_addrof,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation\n+)]\n+\n+use std::cell::RefCell;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+\n+fn is_ascii(ch: char) -> bool {\n+    ch.is_ascii()\n+}\n+\n+fn clone_on_copy() {\n+    42;\n+\n+    vec![1].clone(); // ok, not a Copy type\n+    Some(vec![1]).clone(); // ok, not a Copy type\n+    *(&42);\n+\n+    let rc = RefCell::new(0);\n+    *rc.borrow();\n+\n+    // Issue #4348\n+    let mut x = 43;\n+    let _ = &x.clone(); // ok, getting a ref\n+    'a'.clone().make_ascii_uppercase(); // ok, clone and then mutate\n+    is_ascii('z');\n+\n+    // Issue #5436\n+    let mut vec = Vec::new();\n+    vec.push(42);\n+}"}, {"sha": "ca39a654b4fce21c6fe1e57a81377152ae8beba0", "filename": "src/tools/clippy/tests/ui/clone_on_copy.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,40 @@\n+// run-rustfix\n+\n+#![allow(\n+    unused,\n+    clippy::redundant_clone,\n+    clippy::deref_addrof,\n+    clippy::no_effect,\n+    clippy::unnecessary_operation\n+)]\n+\n+use std::cell::RefCell;\n+use std::rc::{self, Rc};\n+use std::sync::{self, Arc};\n+\n+fn main() {}\n+\n+fn is_ascii(ch: char) -> bool {\n+    ch.is_ascii()\n+}\n+\n+fn clone_on_copy() {\n+    42.clone();\n+\n+    vec![1].clone(); // ok, not a Copy type\n+    Some(vec![1]).clone(); // ok, not a Copy type\n+    (&42).clone();\n+\n+    let rc = RefCell::new(0);\n+    rc.borrow().clone();\n+\n+    // Issue #4348\n+    let mut x = 43;\n+    let _ = &x.clone(); // ok, getting a ref\n+    'a'.clone().make_ascii_uppercase(); // ok, clone and then mutate\n+    is_ascii('z'.clone());\n+\n+    // Issue #5436\n+    let mut vec = Vec::new();\n+    vec.push(42.clone());\n+}"}, {"sha": "ec2faf4ab40d2c94b0370006f0633940d8c62d5b", "filename": "src/tools/clippy/tests/ui/clone_on_copy.stderr", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fclone_on_copy.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,34 @@\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:22:5\n+   |\n+LL |     42.clone();\n+   |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n+   |\n+   = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n+\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:26:5\n+   |\n+LL |     (&42).clone();\n+   |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n+\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:29:5\n+   |\n+LL |     rc.borrow().clone();\n+   |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n+\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:35:14\n+   |\n+LL |     is_ascii('z'.clone());\n+   |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n+\n+error: using `clone` on a `Copy` type\n+  --> $DIR/clone_on_copy.rs:39:14\n+   |\n+LL |     vec.push(42.clone());\n+   |              ^^^^^^^^^^ help: try removing the `clone` call: `42`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "3305ac9bf8b6cb40ec93bc7fadea0ad83b920d4e", "filename": "src/tools/clippy/tests/ui/cmp_owned/asymmetric_partial_eq.fixed", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+#![allow(unused, clippy::redundant_clone)] // See #5700\n+\n+// Define the types in each module to avoid trait impls leaking between modules.\n+macro_rules! impl_types {\n+    () => {\n+        #[derive(PartialEq)]\n+        pub struct Owned;\n+\n+        pub struct Borrowed;\n+\n+        impl ToOwned for Borrowed {\n+            type Owned = Owned;\n+            fn to_owned(&self) -> Owned {\n+                Owned {}\n+            }\n+        }\n+\n+        impl std::borrow::Borrow<Borrowed> for Owned {\n+            fn borrow(&self) -> &Borrowed {\n+                static VALUE: Borrowed = Borrowed {};\n+                &VALUE\n+            }\n+        }\n+    };\n+}\n+\n+// Only Borrowed == Owned is implemented\n+mod borrowed_eq_owned {\n+    impl_types!();\n+\n+    impl PartialEq<Owned> for Borrowed {\n+        fn eq(&self, _: &Owned) -> bool {\n+            true\n+        }\n+    }\n+\n+    pub fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if borrowed == owned {}\n+        if borrowed == owned {}\n+    }\n+}\n+\n+// Only Owned == Borrowed is implemented\n+mod owned_eq_borrowed {\n+    impl_types!();\n+\n+    impl PartialEq<Borrowed> for Owned {\n+        fn eq(&self, _: &Borrowed) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if owned == borrowed {}\n+        if owned == borrowed {}\n+    }\n+}\n+\n+mod issue_4874 {\n+    impl_types!();\n+\n+    // NOTE: PartialEq<Borrowed> for T can't be implemented due to the orphan rules\n+    impl<T> PartialEq<T> for Borrowed\n+    where\n+        T: AsRef<str> + ?Sized,\n+    {\n+        fn eq(&self, _: &T) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl std::fmt::Display for Borrowed {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"borrowed\")\n+        }\n+    }\n+\n+    fn compare() {\n+        let borrowed = Borrowed {};\n+\n+        if borrowed == \"Hi\" {}\n+        if borrowed == \"Hi\" {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "88bc2f51dd6629a8b923f4a1a874ad424764c80f", "filename": "src/tools/clippy/tests/ui/cmp_owned/asymmetric_partial_eq.rs", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,93 @@\n+// run-rustfix\n+#![allow(unused, clippy::redundant_clone)] // See #5700\n+\n+// Define the types in each module to avoid trait impls leaking between modules.\n+macro_rules! impl_types {\n+    () => {\n+        #[derive(PartialEq)]\n+        pub struct Owned;\n+\n+        pub struct Borrowed;\n+\n+        impl ToOwned for Borrowed {\n+            type Owned = Owned;\n+            fn to_owned(&self) -> Owned {\n+                Owned {}\n+            }\n+        }\n+\n+        impl std::borrow::Borrow<Borrowed> for Owned {\n+            fn borrow(&self) -> &Borrowed {\n+                static VALUE: Borrowed = Borrowed {};\n+                &VALUE\n+            }\n+        }\n+    };\n+}\n+\n+// Only Borrowed == Owned is implemented\n+mod borrowed_eq_owned {\n+    impl_types!();\n+\n+    impl PartialEq<Owned> for Borrowed {\n+        fn eq(&self, _: &Owned) -> bool {\n+            true\n+        }\n+    }\n+\n+    pub fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if borrowed.to_owned() == owned {}\n+        if owned == borrowed.to_owned() {}\n+    }\n+}\n+\n+// Only Owned == Borrowed is implemented\n+mod owned_eq_borrowed {\n+    impl_types!();\n+\n+    impl PartialEq<Borrowed> for Owned {\n+        fn eq(&self, _: &Borrowed) -> bool {\n+            true\n+        }\n+    }\n+\n+    fn compare() {\n+        let owned = Owned {};\n+        let borrowed = Borrowed {};\n+\n+        if owned == borrowed.to_owned() {}\n+        if borrowed.to_owned() == owned {}\n+    }\n+}\n+\n+mod issue_4874 {\n+    impl_types!();\n+\n+    // NOTE: PartialEq<Borrowed> for T can't be implemented due to the orphan rules\n+    impl<T> PartialEq<T> for Borrowed\n+    where\n+        T: AsRef<str> + ?Sized,\n+    {\n+        fn eq(&self, _: &T) -> bool {\n+            true\n+        }\n+    }\n+\n+    impl std::fmt::Display for Borrowed {\n+        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+            write!(f, \"borrowed\")\n+        }\n+    }\n+\n+    fn compare() {\n+        let borrowed = Borrowed {};\n+\n+        if \"Hi\" == borrowed.to_string() {}\n+        if borrowed.to_string() == \"Hi\" {}\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "43bf8851fc620d700fe9adcc457f8d88466c2780", "filename": "src/tools/clippy/tests/ui/cmp_owned/asymmetric_partial_eq.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcmp_owned%2Fasymmetric_partial_eq.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,46 @@\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:42:12\n+   |\n+LL |         if borrowed.to_owned() == owned {}\n+   |            ^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+   |\n+   = note: `-D clippy::cmp-owned` implied by `-D warnings`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:43:21\n+   |\n+LL |         if owned == borrowed.to_owned() {}\n+   |            ---------^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: try: `borrowed == owned`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:61:21\n+   |\n+LL |         if owned == borrowed.to_owned() {}\n+   |                     ^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:62:12\n+   |\n+LL |         if borrowed.to_owned() == owned {}\n+   |            ^^^^^^^^^^^^^^^^^^^---------\n+   |            |\n+   |            help: try: `owned == borrowed`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:88:20\n+   |\n+LL |         if \"Hi\" == borrowed.to_string() {}\n+   |            --------^^^^^^^^^^^^^^^^^^^^\n+   |            |\n+   |            help: try: `borrowed == \"Hi\"`\n+\n+error: this creates an owned instance just for comparison\n+  --> $DIR/asymmetric_partial_eq.rs:89:12\n+   |\n+LL |         if borrowed.to_string() == \"Hi\" {}\n+   |            ^^^^^^^^^^^^^^^^^^^^ help: try: `borrowed`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "3d1c458879e58818efd38abb03c8935e23b852de", "filename": "src/tools/clippy/tests/ui/collapsible_else_if.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_else_if.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -10,7 +10,7 @@ LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::collapsible-if` implied by `-D warnings`\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if y == \"world\" {\n LL |         println!(\"world!\")\n@@ -28,7 +28,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if let Some(42) = Some(42) {\n LL |         println!(\"world!\")\n@@ -48,7 +48,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if y == \"world\" {\n LL |         println!(\"world\")\n@@ -71,7 +71,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if let Some(42) = Some(42) {\n LL |         println!(\"world\")\n@@ -94,7 +94,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if let Some(42) = Some(42) {\n LL |         println!(\"world\")\n@@ -117,7 +117,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if x == \"hello\" {\n LL |         println!(\"world\")\n@@ -140,7 +140,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     } else if let Some(42) = Some(42) {\n LL |         println!(\"world\")"}, {"sha": "f56dd65b9dd26c77144b24d0763ac472b739c238", "filename": "src/tools/clippy/tests/ui/collapsible_if.stderr", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fcollapsible_if.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -9,7 +9,7 @@ LL | |     }\n    | |_____^\n    |\n    = note: `-D clippy::collapsible-if` implied by `-D warnings`\n-help: try\n+help: collapse nested if block\n    |\n LL |     if x == \"hello\" && y == \"world\" {\n LL |         println!(\"Hello world!\");\n@@ -26,7 +26,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if (x == \"hello\" || x == \"world\") && (y == \"world\" || y == \"hello\") {\n LL |         println!(\"Hello world!\");\n@@ -43,7 +43,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if x == \"hello\" && x == \"world\" && (y == \"world\" || y == \"hello\") {\n LL |         println!(\"Hello world!\");\n@@ -60,7 +60,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if (x == \"hello\" || x == \"world\") && y == \"world\" && y == \"hello\" {\n LL |         println!(\"Hello world!\");\n@@ -77,7 +77,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if x == \"hello\" && x == \"world\" && y == \"world\" && y == \"hello\" {\n LL |         println!(\"Hello world!\");\n@@ -94,7 +94,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if 42 == 1337 && 'a' != 'A' {\n LL |         println!(\"world!\")\n@@ -111,7 +111,7 @@ LL | |         }\n LL | |     }\n    | |_____^\n    |\n-help: try\n+help: collapse nested if block\n    |\n LL |     if x == \"hello\" && y == \"world\" { // Collapsible\n LL |         println!(\"Hello world!\");"}, {"sha": "3eefb232780f1a9931a6040307eb67edbefeca4d", "filename": "src/tools/clippy/tests/ui/deprecated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -7,5 +7,6 @@\n #[warn(clippy::invalid_ref)]\n #[warn(clippy::into_iter_on_array)]\n #[warn(clippy::unused_label)]\n+#[warn(clippy::regex_macro)]\n \n fn main() {}"}, {"sha": "a80e2bf31feb6b37a7869bba98cef5e84b5ccdae", "filename": "src/tools/clippy/tests/ui/deprecated.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fdeprecated.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -54,11 +54,17 @@ error: lint `clippy::unused_label` has been removed: `this lint has been uplifte\n LL | #[warn(clippy::unused_label)]\n    |        ^^^^^^^^^^^^^^^^^^^^\n \n+error: lint `clippy::regex_macro` has been removed: `the regex! macro has been removed from the regex crate in 2018`\n+  --> $DIR/deprecated.rs:10:8\n+   |\n+LL | #[warn(clippy::regex_macro)]\n+   |        ^^^^^^^^^^^^^^^^^^^\n+\n error: lint `clippy::str_to_string` has been removed: `using `str::to_string` is common even today and specialization will likely happen soon`\n   --> $DIR/deprecated.rs:1:8\n    |\n LL | #[warn(clippy::str_to_string)]\n    |        ^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 10 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "88d3b0e74900152d33938bf332da60dd9035f31c", "filename": "src/tools/clippy/tests/ui/find_map.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -19,6 +19,7 @@ fn main() {\n \n     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s| s.parse().unwrap());\n \n+    #[allow(clippy::match_like_matches_macro)]\n     let _: Option<Flavor> = desserts_of_the_week\n         .iter()\n         .find(|dessert| match *dessert {"}, {"sha": "f279850fef8af91a0c520197efb7571f4e22b5e6", "filename": "src/tools/clippy/tests/ui/find_map.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffind_map.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -8,7 +8,7 @@ LL |     let _: Option<i32> = a.iter().find(|s| s.parse::<i32>().is_ok()).map(|s\n    = help: this is more succinctly expressed by calling `.find_map(..)` instead\n \n error: called `find(p).map(q)` on an `Iterator`\n-  --> $DIR/find_map.rs:22:29\n+  --> $DIR/find_map.rs:23:29\n    |\n LL |       let _: Option<Flavor> = desserts_of_the_week\n    |  _____________________________^"}, {"sha": "bbe411b3f48843bc0487d14a326e6e0df0ebb663", "filename": "src/tools/clippy/tests/ui/floating_point_hypot.fixed", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+#![warn(clippy::imprecise_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let y = 4f32;\n+    let _ = x.hypot(y);\n+    let _ = (x + 1f32).hypot(y);\n+    let _ = x.hypot(y);\n+    // Cases where the lint shouldn't be applied\n+    // TODO: linting this adds some complexity, but could be done\n+    let _ = x.mul_add(x, y * y).sqrt();\n+    let _ = (x * 4f32 + y * y).sqrt();\n+}"}, {"sha": "586fd170ea14565dc41018f640c1c27da3672e3b", "filename": "src/tools/clippy/tests/ui/floating_point_hypot.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,14 @@\n+// run-rustfix\n+#![warn(clippy::imprecise_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let y = 4f32;\n+    let _ = (x * x + y * y).sqrt();\n+    let _ = ((x + 1f32) * (x + 1f32) + y * y).sqrt();\n+    let _ = (x.powi(2) + y.powi(2)).sqrt();\n+    // Cases where the lint shouldn't be applied\n+    // TODO: linting this adds some complexity, but could be done\n+    let _ = x.mul_add(x, y * y).sqrt();\n+    let _ = (x * 4f32 + y * y).sqrt();\n+}"}, {"sha": "42069d9ee9efbad760b05431f0262688149eda5f", "filename": "src/tools/clippy/tests/ui/floating_point_hypot.stderr", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_hypot.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,22 @@\n+error: hypotenuse can be computed more accurately\n+  --> $DIR/floating_point_hypot.rs:7:13\n+   |\n+LL |     let _ = (x * x + y * y).sqrt();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.hypot(y)`\n+   |\n+   = note: `-D clippy::imprecise-flops` implied by `-D warnings`\n+\n+error: hypotenuse can be computed more accurately\n+  --> $DIR/floating_point_hypot.rs:8:13\n+   |\n+LL |     let _ = ((x + 1f32) * (x + 1f32) + y * y).sqrt();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x + 1f32).hypot(y)`\n+\n+error: hypotenuse can be computed more accurately\n+  --> $DIR/floating_point_hypot.rs:9:13\n+   |\n+LL |     let _ = (x.powi(2) + y.powi(2)).sqrt();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.hypot(y)`\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "7dc7ee94affc0d06c7ca21e0ad7df80a8d9903d9", "filename": "src/tools/clippy/tests/ui/floating_point_log.fixed", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -25,11 +25,11 @@ fn check_ln1p() {\n     let _ = 2.0f32.ln_1p();\n     let _ = x.ln_1p();\n     let _ = (x / 2.0).ln_1p();\n-    let _ = x.powi(2).ln_1p();\n-    let _ = (x.powi(2) / 2.0).ln_1p();\n+    let _ = x.powi(3).ln_1p();\n+    let _ = (x.powi(3) / 2.0).ln_1p();\n     let _ = ((std::f32::consts::E - 1.0)).ln_1p();\n     let _ = x.ln_1p();\n-    let _ = x.powi(2).ln_1p();\n+    let _ = x.powi(3).ln_1p();\n     let _ = (x + 2.0).ln_1p();\n     let _ = (x / 2.0).ln_1p();\n     // Cases where the lint shouldn't be applied\n@@ -43,9 +43,9 @@ fn check_ln1p() {\n     let _ = 2.0f64.ln_1p();\n     let _ = x.ln_1p();\n     let _ = (x / 2.0).ln_1p();\n-    let _ = x.powi(2).ln_1p();\n+    let _ = x.powi(3).ln_1p();\n     let _ = x.ln_1p();\n-    let _ = x.powi(2).ln_1p();\n+    let _ = x.powi(3).ln_1p();\n     let _ = (x + 2.0).ln_1p();\n     let _ = (x / 2.0).ln_1p();\n     // Cases where the lint shouldn't be applied"}, {"sha": "01181484e7dee290c0973d60a38a93bd71062905", "filename": "src/tools/clippy/tests/ui/floating_point_log.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -25,11 +25,11 @@ fn check_ln1p() {\n     let _ = (1f32 + 2.0).ln();\n     let _ = (1.0 + x).ln();\n     let _ = (1.0 + x / 2.0).ln();\n-    let _ = (1.0 + x.powi(2)).ln();\n-    let _ = (1.0 + x.powi(2) / 2.0).ln();\n+    let _ = (1.0 + x.powi(3)).ln();\n+    let _ = (1.0 + x.powi(3) / 2.0).ln();\n     let _ = (1.0 + (std::f32::consts::E - 1.0)).ln();\n     let _ = (x + 1.0).ln();\n-    let _ = (x.powi(2) + 1.0).ln();\n+    let _ = (x.powi(3) + 1.0).ln();\n     let _ = (x + 2.0 + 1.0).ln();\n     let _ = (x / 2.0 + 1.0).ln();\n     // Cases where the lint shouldn't be applied\n@@ -43,9 +43,9 @@ fn check_ln1p() {\n     let _ = (1f64 + 2.0).ln();\n     let _ = (1.0 + x).ln();\n     let _ = (1.0 + x / 2.0).ln();\n-    let _ = (1.0 + x.powi(2)).ln();\n+    let _ = (1.0 + x.powi(3)).ln();\n     let _ = (x + 1.0).ln();\n-    let _ = (x.powi(2) + 1.0).ln();\n+    let _ = (x.powi(3) + 1.0).ln();\n     let _ = (x + 2.0 + 1.0).ln();\n     let _ = (x / 2.0 + 1.0).ln();\n     // Cases where the lint shouldn't be applied"}, {"sha": "900dc2b79336a8bd1e67a642c54a6eb1c74966fa", "filename": "src/tools/clippy/tests/ui/floating_point_log.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_log.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -77,14 +77,14 @@ LL |     let _ = (1.0 + x / 2.0).ln();\n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:28:13\n    |\n-LL |     let _ = (1.0 + x.powi(2)).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+LL |     let _ = (1.0 + x.powi(3)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:29:13\n    |\n-LL |     let _ = (1.0 + x.powi(2) / 2.0).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x.powi(2) / 2.0).ln_1p()`\n+LL |     let _ = (1.0 + x.powi(3) / 2.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `(x.powi(3) / 2.0).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:30:13\n@@ -101,8 +101,8 @@ LL |     let _ = (x + 1.0).ln();\n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:32:13\n    |\n-LL |     let _ = (x.powi(2) + 1.0).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+LL |     let _ = (x.powi(3) + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:33:13\n@@ -143,8 +143,8 @@ LL |     let _ = (1.0 + x / 2.0).ln();\n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:46:13\n    |\n-LL |     let _ = (1.0 + x.powi(2)).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+LL |     let _ = (1.0 + x.powi(3)).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:47:13\n@@ -155,8 +155,8 @@ LL |     let _ = (x + 1.0).ln();\n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:48:13\n    |\n-LL |     let _ = (x.powi(2) + 1.0).ln();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(2).ln_1p()`\n+LL |     let _ = (x.powi(3) + 1.0).ln();\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.powi(3).ln_1p()`\n \n error: ln(1 + x) can be computed more accurately\n   --> $DIR/floating_point_log.rs:49:13"}, {"sha": "13962a272d4552b6ccce46a9ff908890e0add9cf", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let y = 5f32;\n+    let _ = x.log(y);\n+    let _ = x.log(y);\n+    let _ = x.log(y);\n+    let _ = x.log(y);\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.ln() / y.powf(3.2);\n+    let _ = x.powf(3.2) / y.powf(3.2);\n+    let _ = x.powf(3.2) / y.ln();\n+    let _ = x.log(5f32) / y.log(7f32);\n+}"}, {"sha": "26bc20d5370b1f0a6f678d1b7d54b6fe447487d8", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let y = 5f32;\n+    let _ = x.ln() / y.ln();\n+    let _ = x.log2() / y.log2();\n+    let _ = x.log10() / y.log10();\n+    let _ = x.log(5f32) / y.log(5f32);\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.ln() / y.powf(3.2);\n+    let _ = x.powf(3.2) / y.powf(3.2);\n+    let _ = x.powf(3.2) / y.ln();\n+    let _ = x.log(5f32) / y.log(7f32);\n+}"}, {"sha": "78354c2f62d432eaf0e9c7a9cd6670bfc3bbc4cf", "filename": "src/tools/clippy/tests/ui/floating_point_logbase.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_logbase.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,28 @@\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:7:13\n+   |\n+LL |     let _ = x.ln() / y.ln();\n+   |             ^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:8:13\n+   |\n+LL |     let _ = x.log2() / y.log2();\n+   |             ^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n+\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:9:13\n+   |\n+LL |     let _ = x.log10() / y.log10();\n+   |             ^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n+\n+error: log base can be expressed more clearly\n+  --> $DIR/floating_point_logbase.rs:10:13\n+   |\n+LL |     let _ = x.log(5f32) / y.log(5f32);\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.log(y)`\n+\n+error: aborting due to 4 previous errors\n+"}, {"sha": "911700bab0040e2e4a33439c537b73cbbeb69721", "filename": "src/tools/clippy/tests/ui/floating_point_mul_add.fixed", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -18,4 +18,9 @@ fn main() {\n \n     let _ = a.mul_add(b, c).mul_add(a.mul_add(b, c), a.mul_add(b, c)) + c;\n     let _ = 1234.567_f64.mul_add(45.67834_f64, 0.0004_f64);\n+\n+    let _ = a.mul_add(a, b).sqrt();\n+\n+    // Cases where the lint shouldn't be applied\n+    let _ = (a * a + b * b).sqrt();\n }"}, {"sha": "d202385fc8ae76a0ee0f169852b1d410b3a76f77", "filename": "src/tools/clippy/tests/ui/floating_point_mul_add.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -18,4 +18,9 @@ fn main() {\n \n     let _ = a.mul_add(b, c) * a.mul_add(b, c) + a.mul_add(b, c) + c;\n     let _ = 1234.567_f64 * 45.67834_f64 + 0.0004_f64;\n+\n+    let _ = (a * a + b).sqrt();\n+\n+    // Cases where the lint shouldn't be applied\n+    let _ = (a * a + b * b).sqrt();\n }"}, {"sha": "ac8d0c0cae068cf87162396380ce510e075d3477", "filename": "src/tools/clippy/tests/ui/floating_point_mul_add.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_mul_add.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -54,5 +54,11 @@ error: multiply and add expressions can be calculated more efficiently and accur\n LL |     let _ = 1234.567_f64 * 45.67834_f64 + 0.0004_f64;\n    |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `1234.567_f64.mul_add(45.67834_f64, 0.0004_f64)`\n \n-error: aborting due to 9 previous errors\n+error: multiply and add expressions can be calculated more efficiently and accurately\n+  --> $DIR/floating_point_mul_add.rs:22:13\n+   |\n+LL |     let _ = (a * a + b).sqrt();\n+   |             ^^^^^^^^^^^ help: consider using: `a.mul_add(a, b)`\n+\n+error: aborting due to 10 previous errors\n "}, {"sha": "b0641a100cdc810b4a3c7d3d045928970dfe1272", "filename": "src/tools/clippy/tests/ui/floating_point_powf.fixed", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let _ = (-3.1f32).exp();\n     let _ = x.sqrt();\n     let _ = x.cbrt();\n-    let _ = x.powi(2);\n+    let _ = x.powi(3);\n     let _ = x.powi(-2);\n     let _ = x.powi(16_777_215);\n     let _ = x.powi(-16_777_215);\n@@ -30,7 +30,7 @@ fn main() {\n     let _ = (-3.1f64).exp();\n     let _ = x.sqrt();\n     let _ = x.cbrt();\n-    let _ = x.powi(2);\n+    let _ = x.powi(3);\n     let _ = x.powi(-2);\n     let _ = x.powi(-2_147_483_648);\n     let _ = x.powi(2_147_483_647);"}, {"sha": "a0a2c973900f4b7ba943f29a7bb90dcecaf6a8ce", "filename": "src/tools/clippy/tests/ui/floating_point_powf.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -11,7 +11,7 @@ fn main() {\n     let _ = std::f32::consts::E.powf(-3.1);\n     let _ = x.powf(1.0 / 2.0);\n     let _ = x.powf(1.0 / 3.0);\n-    let _ = x.powf(2.0);\n+    let _ = x.powf(3.0);\n     let _ = x.powf(-2.0);\n     let _ = x.powf(16_777_215.0);\n     let _ = x.powf(-16_777_215.0);\n@@ -30,7 +30,7 @@ fn main() {\n     let _ = std::f64::consts::E.powf(-3.1);\n     let _ = x.powf(1.0 / 2.0);\n     let _ = x.powf(1.0 / 3.0);\n-    let _ = x.powf(2.0);\n+    let _ = x.powf(3.0);\n     let _ = x.powf(-2.0);\n     let _ = x.powf(-2_147_483_648.0);\n     let _ = x.powf(2_147_483_647.0);"}, {"sha": "2422eb911e90a7041dedbecccf2fa2677a12710d", "filename": "src/tools/clippy/tests/ui/floating_point_powf.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powf.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -53,8 +53,8 @@ LL |     let _ = x.powf(1.0 / 3.0);\n error: exponentiation with integer powers can be computed more efficiently\n   --> $DIR/floating_point_powf.rs:14:13\n    |\n-LL |     let _ = x.powf(2.0);\n-   |             ^^^^^^^^^^^ help: consider using: `x.powi(2)`\n+LL |     let _ = x.powf(3.0);\n+   |             ^^^^^^^^^^^ help: consider using: `x.powi(3)`\n \n error: exponentiation with integer powers can be computed more efficiently\n   --> $DIR/floating_point_powf.rs:15:13\n@@ -125,8 +125,8 @@ LL |     let _ = x.powf(1.0 / 3.0);\n error: exponentiation with integer powers can be computed more efficiently\n   --> $DIR/floating_point_powf.rs:33:13\n    |\n-LL |     let _ = x.powf(2.0);\n-   |             ^^^^^^^^^^^ help: consider using: `x.powi(2)`\n+LL |     let _ = x.powf(3.0);\n+   |             ^^^^^^^^^^^ help: consider using: `x.powi(3)`\n \n error: exponentiation with integer powers can be computed more efficiently\n   --> $DIR/floating_point_powf.rs:34:13"}, {"sha": "56762400593b54fc3806cd7636594698fdf9962a", "filename": "src/tools/clippy/tests/ui/floating_point_powi.fixed", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let one = 1;\n+    let x = 3f32;\n+    let _ = x * x;\n+    let _ = x * x;\n+\n+    let y = 4f32;\n+    let _ = x.mul_add(x, y);\n+    let _ = y.mul_add(y, x);\n+    let _ = x.mul_add(x, y).sqrt();\n+    let _ = y.mul_add(y, x).sqrt();\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.powi(3);\n+    let _ = x.powi(one + 1);\n+    let _ = (x.powi(2) + y.powi(2)).sqrt();\n+}"}, {"sha": "1f800e4628dcae43fa277f5cbabc5897b9b67008", "filename": "src/tools/clippy/tests/ui/floating_point_powi.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,19 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let one = 1;\n+    let x = 3f32;\n+    let _ = x.powi(2);\n+    let _ = x.powi(1 + 1);\n+\n+    let y = 4f32;\n+    let _ = x.powi(2) + y;\n+    let _ = x + y.powi(2);\n+    let _ = (x.powi(2) + y).sqrt();\n+    let _ = (x + y.powi(2)).sqrt();\n+    // Cases where the lint shouldn't be applied\n+    let _ = x.powi(3);\n+    let _ = x.powi(one + 1);\n+    let _ = (x.powi(2) + y.powi(2)).sqrt();\n+}"}, {"sha": "d5a5f1bcca1015cb948a125e4c2b09c873b2de0c", "filename": "src/tools/clippy/tests/ui/floating_point_powi.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_powi.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,40 @@\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:7:13\n+   |\n+LL |     let _ = x.powi(2);\n+   |             ^^^^^^^^^ help: consider using: `x * x`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:8:13\n+   |\n+LL |     let _ = x.powi(1 + 1);\n+   |             ^^^^^^^^^^^^^ help: consider using: `x * x`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:11:13\n+   |\n+LL |     let _ = x.powi(2) + y;\n+   |             ^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:12:13\n+   |\n+LL |     let _ = x + y.powi(2);\n+   |             ^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:13:13\n+   |\n+LL |     let _ = (x.powi(2) + y).sqrt();\n+   |             ^^^^^^^^^^^^^^^ help: consider using: `x.mul_add(x, y)`\n+\n+error: square can be computed more efficiently\n+  --> $DIR/floating_point_powi.rs:14:13\n+   |\n+LL |     let _ = (x + y.powi(2)).sqrt();\n+   |             ^^^^^^^^^^^^^^^ help: consider using: `y.mul_add(y, x)`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "92480c5db8be446f807d15087515ecab6482fdc3", "filename": "src/tools/clippy/tests/ui/floating_point_rad.fixed", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let _ = x.to_degrees();\n+    let _ = x.to_radians();\n+    // Cases where the lint shouldn't be applied\n+    let _ = x * 90f32 / std::f32::consts::PI;\n+    let _ = x * std::f32::consts::PI / 90f32;\n+    let _ = x * 180f32 / std::f32::consts::E;\n+    let _ = x * std::f32::consts::E / 180f32;\n+}"}, {"sha": "062e7c3fdc17afe8d7c1aa4d9a53aa00bff0ae3c", "filename": "src/tools/clippy/tests/ui/floating_point_rad.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,13 @@\n+// run-rustfix\n+#![warn(clippy::suboptimal_flops)]\n+\n+fn main() {\n+    let x = 3f32;\n+    let _ = x * 180f32 / std::f32::consts::PI;\n+    let _ = x * std::f32::consts::PI / 180f32;\n+    // Cases where the lint shouldn't be applied\n+    let _ = x * 90f32 / std::f32::consts::PI;\n+    let _ = x * std::f32::consts::PI / 90f32;\n+    let _ = x * 180f32 / std::f32::consts::E;\n+    let _ = x * std::f32::consts::E / 180f32;\n+}"}, {"sha": "a6ffdca64eefea7b563eec7a75c4002f87083be1", "filename": "src/tools/clippy/tests/ui/floating_point_rad.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ffloating_point_rad.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,16 @@\n+error: conversion to degrees can be done more accurately\n+  --> $DIR/floating_point_rad.rs:6:13\n+   |\n+LL |     let _ = x * 180f32 / std::f32::consts::PI;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.to_degrees()`\n+   |\n+   = note: `-D clippy::suboptimal-flops` implied by `-D warnings`\n+\n+error: conversion to radians can be done more accurately\n+  --> $DIR/floating_point_rad.rs:7:13\n+   |\n+LL |     let _ = x * std::f32::consts::PI / 180f32;\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: consider using: `x.to_radians()`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "4171d80f48a3f51826fe8c59870e75ebdd2e488b", "filename": "src/tools/clippy/tests/ui/map_flatten.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,6 +2,7 @@\n \n #![warn(clippy::all, clippy::pedantic)]\n #![allow(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::map_identity)]\n \n fn main() {\n     let _: Vec<_> = vec![5_i8; 6].into_iter().flat_map(|x| 0..x).collect();"}, {"sha": "16a0fd090ad04533e0fc1fde345d8c11ea930b5d", "filename": "src/tools/clippy/tests/ui/map_flatten.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,6 +2,7 @@\n \n #![warn(clippy::all, clippy::pedantic)]\n #![allow(clippy::missing_docs_in_private_items)]\n+#![allow(clippy::map_identity)]\n \n fn main() {\n     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();"}, {"sha": "00bc41c15e9b8d892ee6eb4ee30d3a5ad62a81eb", "filename": "src/tools/clippy/tests/ui/map_flatten.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_flatten.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,13 +1,13 @@\n error: called `map(..).flatten()` on an `Iterator`. This is more succinctly expressed by calling `.flat_map(..)`\n-  --> $DIR/map_flatten.rs:7:21\n+  --> $DIR/map_flatten.rs:8:21\n    |\n LL |     let _: Vec<_> = vec![5_i8; 6].into_iter().map(|x| 0..x).flatten().collect();\n    |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `flat_map` instead: `vec![5_i8; 6].into_iter().flat_map(|x| 0..x)`\n    |\n    = note: `-D clippy::map-flatten` implied by `-D warnings`\n \n error: called `map(..).flatten()` on an `Option`. This is more succinctly expressed by calling `.and_then(..)`\n-  --> $DIR/map_flatten.rs:8:24\n+  --> $DIR/map_flatten.rs:9:24\n    |\n LL |     let _: Option<_> = (Some(Some(1))).map(|x| x).flatten();\n    |                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try using `and_then` instead: `(Some(Some(1))).and_then(|x| x)`"}, {"sha": "4a1452b25f343923c71059722e6d0fe3d32dcc6f", "filename": "src/tools/clippy/tests/ui/map_identity.fixed", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,23 @@\n+// run-rustfix\n+#![warn(clippy::map_identity)]\n+#![allow(clippy::needless_return)]\n+\n+fn main() {\n+    let x: [u16; 3] = [1, 2, 3];\n+    // should lint\n+    let _: Vec<_> = x.iter().map(not_identity).collect();\n+    let _: Vec<_> = x.iter().collect();\n+    let _: Option<u8> = Some(3);\n+    let _: Result<i8, f32> = Ok(-3);\n+    // should not lint\n+    let _: Vec<_> = x.iter().map(|x| 2 * x).collect();\n+    let _: Vec<_> = x.iter().map(not_identity).map(|x| return x - 4).collect();\n+    let _: Option<u8> = None.map(|x: u8| x - 1);\n+    let _: Result<i8, f32> = Err(2.3).map(|x: i8| {\n+        return x + 3;\n+    });\n+}\n+\n+fn not_identity(x: &u16) -> u16 {\n+    *x\n+}"}, {"sha": "65c7e6e1ea554a7db9d691ce237337a450e2c3ed", "filename": "src/tools/clippy/tests/ui/map_identity.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,25 @@\n+// run-rustfix\n+#![warn(clippy::map_identity)]\n+#![allow(clippy::needless_return)]\n+\n+fn main() {\n+    let x: [u16; 3] = [1, 2, 3];\n+    // should lint\n+    let _: Vec<_> = x.iter().map(not_identity).map(|x| return x).collect();\n+    let _: Vec<_> = x.iter().map(std::convert::identity).map(|y| y).collect();\n+    let _: Option<u8> = Some(3).map(|x| x);\n+    let _: Result<i8, f32> = Ok(-3).map(|x| {\n+        return x;\n+    });\n+    // should not lint\n+    let _: Vec<_> = x.iter().map(|x| 2 * x).collect();\n+    let _: Vec<_> = x.iter().map(not_identity).map(|x| return x - 4).collect();\n+    let _: Option<u8> = None.map(|x: u8| x - 1);\n+    let _: Result<i8, f32> = Err(2.3).map(|x: i8| {\n+        return x + 3;\n+    });\n+}\n+\n+fn not_identity(x: &u16) -> u16 {\n+    *x\n+}"}, {"sha": "e4a0320cbda55721fffd017087d3db81a0868937", "filename": "src/tools/clippy/tests/ui/map_identity.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmap_identity.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,37 @@\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:8:47\n+   |\n+LL |     let _: Vec<_> = x.iter().map(not_identity).map(|x| return x).collect();\n+   |                                               ^^^^^^^^^^^^^^^^^^ help: remove the call to `map`\n+   |\n+   = note: `-D clippy::map-identity` implied by `-D warnings`\n+\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:9:57\n+   |\n+LL |     let _: Vec<_> = x.iter().map(std::convert::identity).map(|y| y).collect();\n+   |                                                         ^^^^^^^^^^^ help: remove the call to `map`\n+\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:9:29\n+   |\n+LL |     let _: Vec<_> = x.iter().map(std::convert::identity).map(|y| y).collect();\n+   |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: remove the call to `map`\n+\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:10:32\n+   |\n+LL |     let _: Option<u8> = Some(3).map(|x| x);\n+   |                                ^^^^^^^^^^^ help: remove the call to `map`\n+\n+error: unnecessary map of the identity function\n+  --> $DIR/map_identity.rs:11:36\n+   |\n+LL |       let _: Result<i8, f32> = Ok(-3).map(|x| {\n+   |  ____________________________________^\n+LL | |         return x;\n+LL | |     });\n+   | |______^ help: remove the call to `map`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "f3e19092480ad12483c9d6a91ddd36abaaa2ff8e", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.fixed", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,36 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_like_matches_macro)]\n+#![allow(unreachable_patterns)]\n+\n+fn main() {\n+    let x = Some(5);\n+\n+    // Lint\n+    let _y = matches!(x, Some(0));\n+\n+    // Lint\n+    let _w = matches!(x, Some(_));\n+\n+    // Turn into is_none\n+    let _z = x.is_none();\n+\n+    // Lint\n+    let _zz = !matches!(x, Some(r) if r == 0);\n+\n+    // Lint\n+    let _zzz = matches!(x, Some(5));\n+\n+    // No lint\n+    let _a = match x {\n+        Some(_) => false,\n+        _ => false,\n+    };\n+\n+    // No lint\n+    let _ab = match x {\n+        Some(0) => false,\n+        _ => true,\n+        None => false,\n+    };\n+}"}, {"sha": "fbae7c18b92392f2bf494a59d3efcb684983962a", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,48 @@\n+// run-rustfix\n+\n+#![warn(clippy::match_like_matches_macro)]\n+#![allow(unreachable_patterns)]\n+\n+fn main() {\n+    let x = Some(5);\n+\n+    // Lint\n+    let _y = match x {\n+        Some(0) => true,\n+        _ => false,\n+    };\n+\n+    // Lint\n+    let _w = match x {\n+        Some(_) => true,\n+        _ => false,\n+    };\n+\n+    // Turn into is_none\n+    let _z = match x {\n+        Some(_) => false,\n+        None => true,\n+    };\n+\n+    // Lint\n+    let _zz = match x {\n+        Some(r) if r == 0 => false,\n+        _ => true,\n+    };\n+\n+    // Lint\n+    let _zzz = if let Some(5) = x { true } else { false };\n+\n+    // No lint\n+    let _a = match x {\n+        Some(_) => false,\n+        _ => false,\n+    };\n+\n+    // No lint\n+    let _ab = match x {\n+        Some(0) => false,\n+        _ => true,\n+        None => false,\n+    };\n+}"}, {"sha": "4668f8565a656f54740ecb3eb0a21f2a63f12386", "filename": "src/tools/clippy/tests/ui/match_expr_like_matches_macro.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fmatch_expr_like_matches_macro.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,52 @@\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:10:14\n+   |\n+LL |       let _y = match x {\n+   |  ______________^\n+LL | |         Some(0) => true,\n+LL | |         _ => false,\n+LL | |     };\n+   | |_____^ help: try this: `matches!(x, Some(0))`\n+   |\n+   = note: `-D clippy::match-like-matches-macro` implied by `-D warnings`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:16:14\n+   |\n+LL |       let _w = match x {\n+   |  ______________^\n+LL | |         Some(_) => true,\n+LL | |         _ => false,\n+LL | |     };\n+   | |_____^ help: try this: `matches!(x, Some(_))`\n+\n+error: redundant pattern matching, consider using `is_none()`\n+  --> $DIR/match_expr_like_matches_macro.rs:22:14\n+   |\n+LL |       let _z = match x {\n+   |  ______________^\n+LL | |         Some(_) => false,\n+LL | |         None => true,\n+LL | |     };\n+   | |_____^ help: try this: `x.is_none()`\n+   |\n+   = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n+\n+error: match expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:28:15\n+   |\n+LL |       let _zz = match x {\n+   |  _______________^\n+LL | |         Some(r) if r == 0 => false,\n+LL | |         _ => true,\n+LL | |     };\n+   | |_____^ help: try this: `!matches!(x, Some(r) if r == 0)`\n+\n+error: if let .. else expression looks like `matches!` macro\n+  --> $DIR/match_expr_like_matches_macro.rs:34:16\n+   |\n+LL |     let _zzz = if let Some(5) = x { true } else { false };\n+   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try this: `matches!(x, Some(5))`\n+\n+error: aborting due to 5 previous errors\n+"}, {"sha": "2d392c593b3e7e58cc2d160067f48eb43b1f7a1c", "filename": "src/tools/clippy/tests/ui/neg_cmp_op_on_partial_ord.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fneg_cmp_op_on_partial_ord.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -4,7 +4,7 @@\n \n use std::cmp::Ordering;\n \n-#[allow(clippy::unnested_or_patterns)]\n+#[allow(clippy::unnested_or_patterns, clippy::match_like_matches_macro)]\n #[warn(clippy::neg_cmp_op_on_partial_ord)]\n fn main() {\n     let a_value = 1.0;"}, {"sha": "695a460cc4edfda0a16871c1aa0b3f1498359271", "filename": "src/tools/clippy/tests/ui/option_if_let_else.fixed", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,74 @@\n+// run-rustfix\n+#![warn(clippy::option_if_let_else)]\n+\n+fn bad1(string: Option<&str>) -> (bool, &str) {\n+    string.map_or((false, \"hello\"), |x| (true, x))\n+}\n+\n+fn else_if_option(string: Option<&str>) -> Option<(bool, &str)> {\n+    if string.is_none() {\n+        None\n+    } else { string.map_or(Some((false, \"\")), |x| Some((true, x))) }\n+}\n+\n+fn unop_bad(string: &Option<&str>, mut num: Option<i32>) {\n+    let _ = string.map_or(0, |s| s.len());\n+    let _ = num.as_ref().map_or(&0, |s| s);\n+    let _ = num.as_mut().map_or(&mut 0, |s| {\n+        *s += 1;\n+        s\n+    });\n+    let _ = num.as_ref().map_or(&0, |s| s);\n+    let _ = num.map_or(0, |mut s| {\n+        s += 1;\n+        s\n+    });\n+    let _ = num.as_mut().map_or(&mut 0, |s| {\n+        *s += 1;\n+        s\n+    });\n+}\n+\n+fn longer_body(arg: Option<u32>) -> u32 {\n+    arg.map_or(13, |x| {\n+        let y = x * x;\n+        y * y\n+    })\n+}\n+\n+fn test_map_or_else(arg: Option<u32>) {\n+    let _ = arg.map_or_else(|| {\n+        let mut y = 1;\n+        y = (y + 2 / y) / 2;\n+        y = (y + 2 / y) / 2;\n+        y\n+    }, |x| x * x * x * x);\n+}\n+\n+fn negative_tests(arg: Option<u32>) -> u32 {\n+    let _ = if let Some(13) = arg { \"unlucky\" } else { \"lucky\" };\n+    for _ in 0..10 {\n+        let _ = if let Some(x) = arg {\n+            x\n+        } else {\n+            continue;\n+        };\n+    }\n+    let _ = if let Some(x) = arg {\n+        return x;\n+    } else {\n+        5\n+    };\n+    7\n+}\n+\n+fn main() {\n+    let optional = Some(5);\n+    let _ = optional.map_or(5, |x| x + 2);\n+    let _ = bad1(None);\n+    let _ = else_if_option(None);\n+    unop_bad(&None, None);\n+    let _ = longer_body(None);\n+    test_map_or_else(None);\n+    let _ = negative_tests(None);\n+}"}, {"sha": "dee80d26bd976d93fda3f72fd0ce3a4cd65c3307", "filename": "src/tools/clippy/tests/ui/option_if_let_else.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,92 @@\n+// run-rustfix\n+#![warn(clippy::option_if_let_else)]\n+\n+fn bad1(string: Option<&str>) -> (bool, &str) {\n+    if let Some(x) = string {\n+        (true, x)\n+    } else {\n+        (false, \"hello\")\n+    }\n+}\n+\n+fn else_if_option(string: Option<&str>) -> Option<(bool, &str)> {\n+    if string.is_none() {\n+        None\n+    } else if let Some(x) = string {\n+        Some((true, x))\n+    } else {\n+        Some((false, \"\"))\n+    }\n+}\n+\n+fn unop_bad(string: &Option<&str>, mut num: Option<i32>) {\n+    let _ = if let Some(s) = *string { s.len() } else { 0 };\n+    let _ = if let Some(s) = &num { s } else { &0 };\n+    let _ = if let Some(s) = &mut num {\n+        *s += 1;\n+        s\n+    } else {\n+        &mut 0\n+    };\n+    let _ = if let Some(ref s) = num { s } else { &0 };\n+    let _ = if let Some(mut s) = num {\n+        s += 1;\n+        s\n+    } else {\n+        0\n+    };\n+    let _ = if let Some(ref mut s) = num {\n+        *s += 1;\n+        s\n+    } else {\n+        &mut 0\n+    };\n+}\n+\n+fn longer_body(arg: Option<u32>) -> u32 {\n+    if let Some(x) = arg {\n+        let y = x * x;\n+        y * y\n+    } else {\n+        13\n+    }\n+}\n+\n+fn test_map_or_else(arg: Option<u32>) {\n+    let _ = if let Some(x) = arg {\n+        x * x * x * x\n+    } else {\n+        let mut y = 1;\n+        y = (y + 2 / y) / 2;\n+        y = (y + 2 / y) / 2;\n+        y\n+    };\n+}\n+\n+fn negative_tests(arg: Option<u32>) -> u32 {\n+    let _ = if let Some(13) = arg { \"unlucky\" } else { \"lucky\" };\n+    for _ in 0..10 {\n+        let _ = if let Some(x) = arg {\n+            x\n+        } else {\n+            continue;\n+        };\n+    }\n+    let _ = if let Some(x) = arg {\n+        return x;\n+    } else {\n+        5\n+    };\n+    7\n+}\n+\n+fn main() {\n+    let optional = Some(5);\n+    let _ = if let Some(x) = optional { x + 2 } else { 5 };\n+    let _ = bad1(None);\n+    let _ = else_if_option(None);\n+    unop_bad(&None, None);\n+    let _ = longer_body(None);\n+    test_map_or_else(None);\n+    let _ = negative_tests(None);\n+}"}, {"sha": "7005850efaf833b47f693ae04a7e9cd37722e476", "filename": "src/tools/clippy/tests/ui/option_if_let_else.stderr", "status": "added", "additions": 151, "deletions": 0, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Foption_if_let_else.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,151 @@\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:5:5\n+   |\n+LL | /     if let Some(x) = string {\n+LL | |         (true, x)\n+LL | |     } else {\n+LL | |         (false, \"hello\")\n+LL | |     }\n+   | |_____^ help: try: `string.map_or((false, \"hello\"), |x| (true, x))`\n+   |\n+   = note: `-D clippy::option-if-let-else` implied by `-D warnings`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:15:12\n+   |\n+LL |       } else if let Some(x) = string {\n+   |  ____________^\n+LL | |         Some((true, x))\n+LL | |     } else {\n+LL | |         Some((false, \"\"))\n+LL | |     }\n+   | |_____^ help: try: `{ string.map_or(Some((false, \"\")), |x| Some((true, x))) }`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:23:13\n+   |\n+LL |     let _ = if let Some(s) = *string { s.len() } else { 0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `string.map_or(0, |s| s.len())`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:24:13\n+   |\n+LL |     let _ = if let Some(s) = &num { s } else { &0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:25:13\n+   |\n+LL |       let _ = if let Some(s) = &mut num {\n+   |  _____________^\n+LL | |         *s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         &mut 0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.as_mut().map_or(&mut 0, |s| {\n+LL |         *s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:31:13\n+   |\n+LL |     let _ = if let Some(ref s) = num { s } else { &0 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `num.as_ref().map_or(&0, |s| s)`\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:32:13\n+   |\n+LL |       let _ = if let Some(mut s) = num {\n+   |  _____________^\n+LL | |         s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.map_or(0, |mut s| {\n+LL |         s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:38:13\n+   |\n+LL |       let _ = if let Some(ref mut s) = num {\n+   |  _____________^\n+LL | |         *s += 1;\n+LL | |         s\n+LL | |     } else {\n+LL | |         &mut 0\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = num.as_mut().map_or(&mut 0, |s| {\n+LL |         *s += 1;\n+LL |         s\n+LL |     });\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:47:5\n+   |\n+LL | /     if let Some(x) = arg {\n+LL | |         let y = x * x;\n+LL | |         y * y\n+LL | |     } else {\n+LL | |         13\n+LL | |     }\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     arg.map_or(13, |x| {\n+LL |         let y = x * x;\n+LL |         y * y\n+LL |     })\n+   |\n+\n+error: use Option::map_or_else instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:56:13\n+   |\n+LL |       let _ = if let Some(x) = arg {\n+   |  _____________^\n+LL | |         x * x * x * x\n+LL | |     } else {\n+LL | |         let mut y = 1;\n+...  |\n+LL | |         y\n+LL | |     };\n+   | |_____^\n+   |\n+help: try\n+   |\n+LL |     let _ = arg.map_or_else(|| {\n+LL |         let mut y = 1;\n+LL |         y = (y + 2 / y) / 2;\n+LL |         y = (y + 2 / y) / 2;\n+LL |         y\n+LL |     }, |x| x * x * x * x);\n+   |\n+\n+error: use Option::map_or instead of an if let/else\n+  --> $DIR/option_if_let_else.rs:85:13\n+   |\n+LL |     let _ = if let Some(x) = optional { x + 2 } else { 5 };\n+   |             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: try: `optional.map_or(5, |x| x + 2)`\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "9b4f2f1f57934dbd8332c2932bfed5f30836626a", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/mutability.rs", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,40 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn should_lint() {\n+    let value = &Some(23);\n+    match value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+\n+    let value = &mut Some(23);\n+    match value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+}\n+\n+fn should_not_lint() {\n+    let value = &Some(23);\n+    match value {\n+        &Some(_) => (),\n+        _ => (),\n+    }\n+    match *value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+\n+    let value = &mut Some(23);\n+    match value {\n+        &mut Some(_) => (),\n+        _ => (),\n+    }\n+    match *value {\n+        Some(_) => (),\n+        _ => (),\n+    }\n+}"}, {"sha": "3421d568365cc98b01afd8189aa6e3d7206752aa", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/mutability.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fmutability.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,19 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/mutability.rs:9:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/mutability.rs:15:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&mut _` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "065ea9fb9b5a4c823ddf37d111f8b466dd1a5025", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_alternatives.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,24 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn alternatives() {\n+    enum Value<'a> {\n+        Unused,\n+        A(&'a Option<i32>),\n+        B,\n+    }\n+    let ref_value = &Value::A(&Some(23));\n+\n+    // not ok\n+    if let Value::B | Value::A(_) = ref_value {}\n+    if let &Value::B | &Value::A(Some(_)) = ref_value {}\n+    if let Value::B | Value::A(Some(_)) = *ref_value {}\n+\n+    // ok\n+    if let &Value::B | &Value::A(_) = ref_value {}\n+    if let Value::B | Value::A(_) = *ref_value {}\n+    if let &Value::B | &Value::A(&Some(_)) = ref_value {}\n+    if let Value::B | Value::A(&Some(_)) = *ref_value {}\n+}"}, {"sha": "d285c93782c67962664f2a0e048d428307b8b3f7", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_alternatives.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_alternatives.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,27 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:15:12\n+   |\n+LL |     if let Value::B | Value::A(_) = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:16:34\n+   |\n+LL |     if let &Value::B | &Value::A(Some(_)) = ref_value {}\n+   |                                  ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_alternatives.rs:17:32\n+   |\n+LL |     if let Value::B | Value::A(Some(_)) = *ref_value {}\n+   |                                ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 3 previous errors\n+"}, {"sha": "417b1c107c55b8ce8c4ae160175c0e511ca3fcab", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_structs.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,45 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn struct_types() {\n+    struct Struct<'a> {\n+        ref_inner: &'a Option<i32>,\n+    }\n+    let ref_value = &Struct { ref_inner: &Some(42) };\n+\n+    // not ok\n+    let Struct { .. } = ref_value;\n+    if let &Struct { ref_inner: Some(_) } = ref_value {}\n+    if let Struct { ref_inner: Some(_) } = *ref_value {}\n+\n+    // ok\n+    let &Struct { .. } = ref_value;\n+    let Struct { .. } = *ref_value;\n+    if let &Struct { ref_inner: &Some(_) } = ref_value {}\n+    if let Struct { ref_inner: &Some(_) } = *ref_value {}\n+}\n+\n+fn struct_enum_variants() {\n+    enum StructEnum<'a> {\n+        Empty,\n+        Var { inner_ref: &'a Option<i32> },\n+    }\n+    let ref_value = &StructEnum::Var { inner_ref: &Some(42) };\n+\n+    // not ok\n+    if let StructEnum::Var { .. } = ref_value {}\n+    if let StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+    if let &StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+    if let StructEnum::Var { inner_ref: Some(_) } = *ref_value {}\n+    if let StructEnum::Empty = ref_value {}\n+\n+    // ok\n+    if let &StructEnum::Var { .. } = ref_value {}\n+    if let StructEnum::Var { .. } = *ref_value {}\n+    if let &StructEnum::Var { inner_ref: &Some(_) } = ref_value {}\n+    if let StructEnum::Var { inner_ref: &Some(_) } = *ref_value {}\n+    if let &StructEnum::Empty = ref_value {}\n+    if let StructEnum::Empty = *ref_value {}\n+}"}, {"sha": "d428e85b0c91403be6c9356fe3a383eb1a61d2ea", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_structs.stderr", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_structs.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,67 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:13:9\n+   |\n+LL |     let Struct { .. } = ref_value;\n+   |         ^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:14:33\n+   |\n+LL |     if let &Struct { ref_inner: Some(_) } = ref_value {}\n+   |                                 ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:15:32\n+   |\n+LL |     if let Struct { ref_inner: Some(_) } = *ref_value {}\n+   |                                ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:32:12\n+   |\n+LL |     if let StructEnum::Var { .. } = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:33:12\n+   |\n+LL |     if let StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:34:42\n+   |\n+LL |     if let &StructEnum::Var { inner_ref: Some(_) } = ref_value {}\n+   |                                          ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:35:41\n+   |\n+LL |     if let StructEnum::Var { inner_ref: Some(_) } = *ref_value {}\n+   |                                         ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_structs.rs:36:12\n+   |\n+LL |     if let StructEnum::Empty = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "19504a051d8b12927f9365decd04f09f2b005d31", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_tuples.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,57 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn tuple_types() {\n+    struct TupleStruct<'a>(&'a Option<i32>);\n+    let ref_value = &TupleStruct(&Some(42));\n+\n+    // not ok\n+    let TupleStruct(_) = ref_value;\n+    if let &TupleStruct(Some(_)) = ref_value {}\n+    if let TupleStruct(Some(_)) = *ref_value {}\n+\n+    // ok\n+    let &TupleStruct(_) = ref_value;\n+    let TupleStruct(_) = *ref_value;\n+    if let &TupleStruct(&Some(_)) = ref_value {}\n+    if let TupleStruct(&Some(_)) = *ref_value {}\n+}\n+\n+fn tuple_enum_variants() {\n+    enum TupleEnum<'a> {\n+        Empty,\n+        Var(&'a Option<i32>),\n+    }\n+    let ref_value = &TupleEnum::Var(&Some(42));\n+\n+    // not ok\n+    if let TupleEnum::Var(_) = ref_value {}\n+    if let &TupleEnum::Var(Some(_)) = ref_value {}\n+    if let TupleEnum::Var(Some(_)) = *ref_value {}\n+    if let TupleEnum::Empty = ref_value {}\n+\n+    // ok\n+    if let &TupleEnum::Var(_) = ref_value {}\n+    if let TupleEnum::Var(_) = *ref_value {}\n+    if let &TupleEnum::Var(&Some(_)) = ref_value {}\n+    if let TupleEnum::Var(&Some(_)) = *ref_value {}\n+    if let &TupleEnum::Empty = ref_value {}\n+    if let TupleEnum::Empty = *ref_value {}\n+}\n+\n+fn plain_tuples() {\n+    let ref_value = &(&Some(23), &Some(42));\n+\n+    // not ok\n+    let (_a, _b) = ref_value;\n+    if let &(_a, Some(_)) = ref_value {}\n+    if let (_a, Some(_)) = *ref_value {}\n+\n+    // ok\n+    let &(_a, _b) = ref_value;\n+    let (_a, _b) = *ref_value;\n+    if let &(_a, &Some(_)) = ref_value {}\n+    if let (_a, &Some(_)) = *ref_value {}\n+}"}, {"sha": "edd0074d00d3b52228a370642907526e70d1c26c", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/pattern_tuples.stderr", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fpattern_tuples.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,83 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:11:9\n+   |\n+LL |     let TupleStruct(_) = ref_value;\n+   |         ^^^^^^^^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:12:25\n+   |\n+LL |     if let &TupleStruct(Some(_)) = ref_value {}\n+   |                         ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:13:24\n+   |\n+LL |     if let TupleStruct(Some(_)) = *ref_value {}\n+   |                        ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:30:12\n+   |\n+LL |     if let TupleEnum::Var(_) = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:31:28\n+   |\n+LL |     if let &TupleEnum::Var(Some(_)) = ref_value {}\n+   |                            ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:32:27\n+   |\n+LL |     if let TupleEnum::Var(Some(_)) = *ref_value {}\n+   |                           ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:33:12\n+   |\n+LL |     if let TupleEnum::Empty = ref_value {}\n+   |            ^^^^^^^^^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:48:9\n+   |\n+LL |     let (_a, _b) = ref_value;\n+   |         ^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:49:18\n+   |\n+LL |     if let &(_a, Some(_)) = ref_value {}\n+   |                  ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/pattern_tuples.rs:50:17\n+   |\n+LL |     if let (_a, Some(_)) = *ref_value {}\n+   |                 ^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: aborting due to 10 previous errors\n+"}, {"sha": "e89917c41e8c1a72a50451d1b628a0dfaef4fe78", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/syntax.rs", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,146 @@\n+#![allow(clippy::all)]\n+#![warn(clippy::pattern_type_mismatch)]\n+\n+fn main() {}\n+\n+fn syntax_match() {\n+    let ref_value = &Some(&Some(42));\n+\n+    // not ok\n+    match ref_value {\n+        Some(_) => (),\n+        None => (),\n+    }\n+\n+    // ok\n+    match ref_value {\n+        &Some(_) => (),\n+        &None => (),\n+    }\n+    match *ref_value {\n+        Some(_) => (),\n+        None => (),\n+    }\n+}\n+\n+fn syntax_if_let() {\n+    let ref_value = &Some(42);\n+\n+    // not ok\n+    if let Some(_) = ref_value {}\n+\n+    // ok\n+    if let &Some(_) = ref_value {}\n+    if let Some(_) = *ref_value {}\n+}\n+\n+fn syntax_while_let() {\n+    let ref_value = &Some(42);\n+\n+    // not ok\n+    while let Some(_) = ref_value {\n+        break;\n+    }\n+\n+    // ok\n+    while let &Some(_) = ref_value {\n+        break;\n+    }\n+    while let Some(_) = *ref_value {\n+        break;\n+    }\n+}\n+\n+fn syntax_for() {\n+    let ref_value = &Some(23);\n+    let slice = &[(2, 3), (4, 2)];\n+\n+    // not ok\n+    for (_a, _b) in slice.iter() {}\n+\n+    // ok\n+    for &(_a, _b) in slice.iter() {}\n+}\n+\n+fn syntax_let() {\n+    let ref_value = &(2, 3);\n+\n+    // not ok\n+    let (_n, _m) = ref_value;\n+\n+    // ok\n+    let &(_n, _m) = ref_value;\n+    let (_n, _m) = *ref_value;\n+}\n+\n+fn syntax_fn() {\n+    // not ok\n+    fn foo((_a, _b): &(i32, i32)) {}\n+\n+    // ok\n+    fn foo_ok_1(&(_a, _b): &(i32, i32)) {}\n+}\n+\n+fn syntax_closure() {\n+    fn foo<F>(f: F)\n+    where\n+        F: FnOnce(&(i32, i32)),\n+    {\n+    }\n+\n+    // not ok\n+    foo(|(_a, _b)| ());\n+\n+    // ok\n+    foo(|&(_a, _b)| ());\n+}\n+\n+fn macro_with_expression() {\n+    macro_rules! matching_macro {\n+        ($e:expr) => {\n+            $e\n+        };\n+    }\n+    let value = &Some(23);\n+\n+    // not ok\n+    matching_macro!(match value {\n+        Some(_) => (),\n+        _ => (),\n+    });\n+\n+    // ok\n+    matching_macro!(match value {\n+        &Some(_) => (),\n+        _ => (),\n+    });\n+    matching_macro!(match *value {\n+        Some(_) => (),\n+        _ => (),\n+    });\n+}\n+\n+fn macro_expansion() {\n+    macro_rules! matching_macro {\n+        ($e:expr) => {\n+            // not ok\n+            match $e {\n+                Some(_) => (),\n+                _ => (),\n+            }\n+\n+            // ok\n+            match $e {\n+                &Some(_) => (),\n+                _ => (),\n+            }\n+            match *$e {\n+                Some(_) => (),\n+                _ => (),\n+            }\n+        };\n+    }\n+\n+    let value = &Some(23);\n+    matching_macro!(value);\n+}"}, {"sha": "5a5186bd4fcb3389cbca59b4e09fd7554e7f5330", "filename": "src/tools/clippy/tests/ui/pattern_type_mismatch/syntax.stderr", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fpattern_type_mismatch%2Fsyntax.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,79 @@\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:11:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = note: `-D clippy::pattern-type-mismatch` implied by `-D warnings`\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:30:12\n+   |\n+LL |     if let Some(_) = ref_value {}\n+   |            ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:41:15\n+   |\n+LL |     while let Some(_) = ref_value {\n+   |               ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:59:9\n+   |\n+LL |     for (_a, _b) in slice.iter() {}\n+   |         ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:69:9\n+   |\n+LL |     let (_n, _m) = ref_value;\n+   |         ^^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:78:12\n+   |\n+LL |     fn foo((_a, _b): &(i32, i32)) {}\n+   |            ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:92:10\n+   |\n+LL |     foo(|(_a, _b)| ());\n+   |          ^^^^^^^^\n+   |\n+   = help: explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:108:9\n+   |\n+LL |         Some(_) => (),\n+   |         ^^^^^^^\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+\n+error: type of pattern does not match the expression type\n+  --> $DIR/syntax.rs:128:17\n+   |\n+LL |                 Some(_) => (),\n+   |                 ^^^^^^^\n+...\n+LL |     matching_macro!(value);\n+   |     ----------------------- in this macro invocation\n+   |\n+   = help: use `*` to dereference the match expression or explicitly match against a `&_` pattern and adjust the enclosed variable bindings\n+   = note: this error originates in a macro (in Nightly builds, run with -Z macro-backtrace for more info)\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "19b253b0fe2c6b94c1c43c9cfd4e736b438967b5", "filename": "src/tools/clippy/tests/ui/range_plus_minus_one.fixed", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -7,6 +7,7 @@ fn f() -> usize {\n }\n \n #[warn(clippy::range_plus_one)]\n+#[warn(clippy::range_minus_one)]\n fn main() {\n     for _ in 0..2 {}\n     for _ in 0..=2 {}"}, {"sha": "7d034117547caf87990d1c824b99b872471eefe8", "filename": "src/tools/clippy/tests/ui/range_plus_minus_one.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -7,6 +7,7 @@ fn f() -> usize {\n }\n \n #[warn(clippy::range_plus_one)]\n+#[warn(clippy::range_minus_one)]\n fn main() {\n     for _ in 0..2 {}\n     for _ in 0..=2 {}"}, {"sha": "fb4f1658597a585de8f220e9255e0f5c57388ad5", "filename": "src/tools/clippy/tests/ui/range_plus_minus_one.stderr", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frange_plus_minus_one.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,57 +1,57 @@\n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:14:14\n+  --> $DIR/range_plus_minus_one.rs:15:14\n    |\n LL |     for _ in 0..3 + 1 {}\n    |              ^^^^^^^^ help: use: `0..=3`\n    |\n    = note: `-D clippy::range-plus-one` implied by `-D warnings`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:17:14\n+  --> $DIR/range_plus_minus_one.rs:18:14\n    |\n LL |     for _ in 0..1 + 5 {}\n    |              ^^^^^^^^ help: use: `0..=5`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:20:14\n+  --> $DIR/range_plus_minus_one.rs:21:14\n    |\n LL |     for _ in 1..1 + 1 {}\n    |              ^^^^^^^^ help: use: `1..=1`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:26:14\n+  --> $DIR/range_plus_minus_one.rs:27:14\n    |\n LL |     for _ in 0..(1 + f()) {}\n    |              ^^^^^^^^^^^^ help: use: `0..=f()`\n \n error: an exclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:30:13\n+  --> $DIR/range_plus_minus_one.rs:31:13\n    |\n LL |     let _ = ..=11 - 1;\n    |             ^^^^^^^^^ help: use: `..11`\n    |\n    = note: `-D clippy::range-minus-one` implied by `-D warnings`\n \n error: an exclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:31:13\n+  --> $DIR/range_plus_minus_one.rs:32:13\n    |\n LL |     let _ = ..=(11 - 1);\n    |             ^^^^^^^^^^^ help: use: `..11`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:32:13\n+  --> $DIR/range_plus_minus_one.rs:33:13\n    |\n LL |     let _ = (1..11 + 1);\n    |             ^^^^^^^^^^^ help: use: `(1..=11)`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:33:13\n+  --> $DIR/range_plus_minus_one.rs:34:13\n    |\n LL |     let _ = (f() + 1)..(f() + 1);\n    |             ^^^^^^^^^^^^^^^^^^^^ help: use: `((f() + 1)..=f())`\n \n error: an inclusive range would be more readable\n-  --> $DIR/range_plus_minus_one.rs:37:14\n+  --> $DIR/range_plus_minus_one.rs:38:14\n    |\n LL |     for _ in 1..ONE + ONE {}\n    |              ^^^^^^^^^^^^ help: use: `1..=ONE`"}, {"sha": "ce8582d2b221cd21c891bfd38af0d20bfd073ec4", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.fixed", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,7 +2,13 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(clippy::unit_arg, unused_must_use, clippy::needless_bool, deprecated)]\n+#![allow(\n+    clippy::unit_arg,\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    deprecated\n+)]\n \n fn main() {\n     if Ok::<i32, i32>(42).is_ok() {}"}, {"sha": "a3a9aa40e3b9c8ec7fd2b7a708c34bf5d93377ab", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,7 +2,13 @@\n \n #![warn(clippy::all)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(clippy::unit_arg, unused_must_use, clippy::needless_bool, deprecated)]\n+#![allow(\n+    clippy::unit_arg,\n+    unused_must_use,\n+    clippy::needless_bool,\n+    clippy::match_like_matches_macro,\n+    deprecated\n+)]\n \n fn main() {\n     if let Ok(_) = Ok::<i32, i32>(42) {}"}, {"sha": "25d1476062e7f599e7fe37dfddab9c1ce80bc1c0", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching.stderr", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,73 +1,73 @@\n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:8:12\n+  --> $DIR/redundant_pattern_matching.rs:14:12\n    |\n LL |     if let Ok(_) = Ok::<i32, i32>(42) {}\n    |     -------^^^^^--------------------- help: try this: `if Ok::<i32, i32>(42).is_ok()`\n    |\n    = note: `-D clippy::redundant-pattern-matching` implied by `-D warnings`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:10:12\n+  --> $DIR/redundant_pattern_matching.rs:16:12\n    |\n LL |     if let Err(_) = Err::<i32, i32>(42) {}\n    |     -------^^^^^^---------------------- help: try this: `if Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:12:12\n+  --> $DIR/redundant_pattern_matching.rs:18:12\n    |\n LL |     if let None = None::<()> {}\n    |     -------^^^^------------- help: try this: `if None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:14:12\n+  --> $DIR/redundant_pattern_matching.rs:20:12\n    |\n LL |     if let Some(_) = Some(42) {}\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:16:12\n+  --> $DIR/redundant_pattern_matching.rs:22:12\n    |\n LL |     if let Some(_) = Some(42) {\n    |     -------^^^^^^^----------- help: try this: `if Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:22:15\n+  --> $DIR/redundant_pattern_matching.rs:28:15\n    |\n LL |     while let Some(_) = Some(42) {}\n    |     ----------^^^^^^^----------- help: try this: `while Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:24:15\n+  --> $DIR/redundant_pattern_matching.rs:30:15\n    |\n LL |     while let None = Some(42) {}\n    |     ----------^^^^----------- help: try this: `while Some(42).is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:26:15\n+  --> $DIR/redundant_pattern_matching.rs:32:15\n    |\n LL |     while let None = None::<()> {}\n    |     ----------^^^^------------- help: try this: `while None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:28:15\n+  --> $DIR/redundant_pattern_matching.rs:34:15\n    |\n LL |     while let Ok(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:30:15\n+  --> $DIR/redundant_pattern_matching.rs:36:15\n    |\n LL |     while let Err(_) = Ok::<i32, i32>(10) {}\n    |     ----------^^^^^^--------------------- help: try this: `while Ok::<i32, i32>(10).is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:33:15\n+  --> $DIR/redundant_pattern_matching.rs:39:15\n    |\n LL |     while let Some(_) = v.pop() {\n    |     ----------^^^^^^^---------- help: try this: `while v.pop().is_some()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:49:5\n+  --> $DIR/redundant_pattern_matching.rs:55:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -76,7 +76,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:54:5\n+  --> $DIR/redundant_pattern_matching.rs:60:5\n    |\n LL | /     match Ok::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -85,7 +85,7 @@ LL | |     };\n    | |_____^ help: try this: `Ok::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:59:5\n+  --> $DIR/redundant_pattern_matching.rs:65:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => false,\n@@ -94,7 +94,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_err()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:64:5\n+  --> $DIR/redundant_pattern_matching.rs:70:5\n    |\n LL | /     match Err::<i32, i32>(42) {\n LL | |         Ok(_) => true,\n@@ -103,7 +103,7 @@ LL | |     };\n    | |_____^ help: try this: `Err::<i32, i32>(42).is_ok()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:69:5\n+  --> $DIR/redundant_pattern_matching.rs:75:5\n    |\n LL | /     match Some(42) {\n LL | |         Some(_) => true,\n@@ -112,7 +112,7 @@ LL | |     };\n    | |_____^ help: try this: `Some(42).is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:74:5\n+  --> $DIR/redundant_pattern_matching.rs:80:5\n    |\n LL | /     match None::<()> {\n LL | |         Some(_) => false,\n@@ -121,7 +121,7 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:79:13\n+  --> $DIR/redundant_pattern_matching.rs:85:13\n    |\n LL |       let _ = match None::<()> {\n    |  _____________^\n@@ -131,61 +131,61 @@ LL | |     };\n    | |_____^ help: try this: `None::<()>.is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:84:20\n+  --> $DIR/redundant_pattern_matching.rs:90:20\n    |\n LL |     let _ = if let Ok(_) = Ok::<usize, ()>(4) { true } else { false };\n    |             -------^^^^^--------------------- help: try this: `if Ok::<usize, ()>(4).is_ok()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:87:20\n+  --> $DIR/redundant_pattern_matching.rs:93:20\n    |\n LL |     let x = if let Some(_) = opt { true } else { false };\n    |             -------^^^^^^^------ help: try this: `if opt.is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:93:20\n+  --> $DIR/redundant_pattern_matching.rs:99:20\n    |\n LL |     let _ = if let Some(_) = gen_opt() {\n    |             -------^^^^^^^------------ help: try this: `if gen_opt().is_some()`\n \n error: redundant pattern matching, consider using `is_none()`\n-  --> $DIR/redundant_pattern_matching.rs:95:19\n+  --> $DIR/redundant_pattern_matching.rs:101:19\n    |\n LL |     } else if let None = gen_opt() {\n    |            -------^^^^------------ help: try this: `if gen_opt().is_none()`\n \n error: redundant pattern matching, consider using `is_ok()`\n-  --> $DIR/redundant_pattern_matching.rs:97:19\n+  --> $DIR/redundant_pattern_matching.rs:103:19\n    |\n LL |     } else if let Ok(_) = gen_res() {\n    |            -------^^^^^------------ help: try this: `if gen_res().is_ok()`\n \n error: redundant pattern matching, consider using `is_err()`\n-  --> $DIR/redundant_pattern_matching.rs:99:19\n+  --> $DIR/redundant_pattern_matching.rs:105:19\n    |\n LL |     } else if let Err(_) = gen_res() {\n    |            -------^^^^^^------------ help: try this: `if gen_res().is_err()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:132:19\n+  --> $DIR/redundant_pattern_matching.rs:138:19\n    |\n LL |         while let Some(_) = r#try!(result_opt()) {}\n    |         ----------^^^^^^^----------------------- help: try this: `while r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:133:16\n+  --> $DIR/redundant_pattern_matching.rs:139:16\n    |\n LL |         if let Some(_) = r#try!(result_opt()) {}\n    |         -------^^^^^^^----------------------- help: try this: `if r#try!(result_opt()).is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:139:12\n+  --> $DIR/redundant_pattern_matching.rs:145:12\n    |\n LL |     if let Some(_) = m!() {}\n    |     -------^^^^^^^------- help: try this: `if m!().is_some()`\n \n error: redundant pattern matching, consider using `is_some()`\n-  --> $DIR/redundant_pattern_matching.rs:140:15\n+  --> $DIR/redundant_pattern_matching.rs:146:15\n    |\n LL |     while let Some(_) = m!() {}\n    |     ----------^^^^^^^------- help: try this: `while m!().is_some()`"}, {"sha": "de3fe00d5fa689b81591706e9acd4693f1073053", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_const_result.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(const_result)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused)]\n+#![allow(clippy::match_like_matches_macro, unused)]\n \n // Test that results are linted with the feature enabled.\n "}, {"sha": "b77969d53d92df3def12d657c545d7c62e5ee39d", "filename": "src/tools/clippy/tests/ui/redundant_pattern_matching_const_result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fredundant_pattern_matching_const_result.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,7 +2,7 @@\n \n #![feature(const_result)]\n #![warn(clippy::redundant_pattern_matching)]\n-#![allow(unused)]\n+#![allow(clippy::match_like_matches_macro, unused)]\n \n // Test that results are linted with the feature enabled.\n "}, {"sha": "9767e5bf76a85ca7953b01ee53068b67925b282a", "filename": "src/tools/clippy/tests/ui/regex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fregex.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,5 +1,5 @@\n #![allow(unused)]\n-#![warn(clippy::invalid_regex, clippy::trivial_regex, clippy::regex_macro)]\n+#![warn(clippy::invalid_regex, clippy::trivial_regex)]\n \n extern crate regex;\n "}, {"sha": "a637c22fbcd266211e9247df2ac21c2b14b3dd56", "filename": "src/tools/clippy/tests/ui/repeat_once.fixed", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::repeat_once)]\n+#[allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n+fn main() {\n+    const N: usize = 1;\n+    let s = \"str\";\n+    let string = \"String\".to_string();\n+    let slice = [1; 5];\n+\n+    let a = [1; 5].to_vec();\n+    let b = slice.to_vec();\n+    let c = \"hello\".to_string();\n+    let d = \"hi\".to_string();\n+    let e = s.to_string();\n+    let f = string.clone();\n+}"}, {"sha": "d99ca1b5b55d4200df4831fa22074cc3f2ce39cb", "filename": "src/tools/clippy/tests/ui/repeat_once.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,16 @@\n+// run-rustfix\n+#![warn(clippy::repeat_once)]\n+#[allow(unused, clippy::many_single_char_names, clippy::redundant_clone)]\n+fn main() {\n+    const N: usize = 1;\n+    let s = \"str\";\n+    let string = \"String\".to_string();\n+    let slice = [1; 5];\n+\n+    let a = [1; 5].repeat(1);\n+    let b = slice.repeat(1);\n+    let c = \"hello\".repeat(N);\n+    let d = \"hi\".repeat(1);\n+    let e = s.repeat(1);\n+    let f = string.repeat(1);\n+}"}, {"sha": "915eea3bfc6b8fbec2a4c74c55b4126602aaccab", "filename": "src/tools/clippy/tests/ui/repeat_once.stderr", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Frepeat_once.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,40 @@\n+error: calling `repeat(1)` on slice\n+  --> $DIR/repeat_once.rs:10:13\n+   |\n+LL |     let a = [1; 5].repeat(1);\n+   |             ^^^^^^^^^^^^^^^^ help: consider using `.to_vec()` instead: `[1; 5].to_vec()`\n+   |\n+   = note: `-D clippy::repeat-once` implied by `-D warnings`\n+\n+error: calling `repeat(1)` on slice\n+  --> $DIR/repeat_once.rs:11:13\n+   |\n+LL |     let b = slice.repeat(1);\n+   |             ^^^^^^^^^^^^^^^ help: consider using `.to_vec()` instead: `slice.to_vec()`\n+\n+error: calling `repeat(1)` on str\n+  --> $DIR/repeat_once.rs:12:13\n+   |\n+LL |     let c = \"hello\".repeat(N);\n+   |             ^^^^^^^^^^^^^^^^^ help: consider using `.to_string()` instead: `\"hello\".to_string()`\n+\n+error: calling `repeat(1)` on str\n+  --> $DIR/repeat_once.rs:13:13\n+   |\n+LL |     let d = \"hi\".repeat(1);\n+   |             ^^^^^^^^^^^^^^ help: consider using `.to_string()` instead: `\"hi\".to_string()`\n+\n+error: calling `repeat(1)` on str\n+  --> $DIR/repeat_once.rs:14:13\n+   |\n+LL |     let e = s.repeat(1);\n+   |             ^^^^^^^^^^^ help: consider using `.to_string()` instead: `s.to_string()`\n+\n+error: calling `repeat(1)` on a string literal\n+  --> $DIR/repeat_once.rs:15:13\n+   |\n+LL |     let f = string.repeat(1);\n+   |             ^^^^^^^^^^^^^^^^ help: consider using `.clone()` instead: `string.clone()`\n+\n+error: aborting due to 6 previous errors\n+"}, {"sha": "b624a41a29b2da10375b212d321afbabac572c6a", "filename": "src/tools/clippy/tests/ui/single_match_else.rs", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,4 +1,6 @@\n #![warn(clippy::single_match_else)]\n+#![allow(clippy::needless_return)]\n+#![allow(clippy::no_effect)]\n \n enum ExprNode {\n     ExprAddrOf,\n@@ -30,6 +32,55 @@ macro_rules! unwrap_addr {\n     };\n }\n \n+#[rustfmt::skip]\n fn main() {\n     unwrap_addr!(ExprNode::Unicorns);\n+\n+    //\n+    // don't lint single exprs/statements\n+    //\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => return,\n+    }\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            return\n+        },\n+    }\n+\n+    // don't lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            return;\n+        },\n+    }\n+\n+    //\n+    // lint multiple exprs/statements \"else\" blocks\n+    //\n+\n+    // lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            println!(\"else block\");\n+            return\n+        },\n+    }\n+\n+    // lint here\n+    match Some(1) {\n+        Some(a) => println!(\"${:?}\", a),\n+        None => {\n+            println!(\"else block\");\n+            return;\n+        },\n+    }\n }"}, {"sha": "3a07c2ec5426278848e9b2e5e3910ea03a01ba31", "filename": "src/tools/clippy/tests/ui/single_match_else.stderr", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Fsingle_match_else.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,5 +1,5 @@\n error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n-  --> $DIR/single_match_else.rs:12:5\n+  --> $DIR/single_match_else.rs:14:5\n    |\n LL | /     match ExprNode::Butterflies {\n LL | |         ExprNode::ExprAddrOf => Some(&NODE),\n@@ -19,5 +19,45 @@ LL |         None\n LL |     }\n    |\n \n-error: aborting due to previous error\n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:70:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL |         println!(\"else block\");\n+LL |         return\n+LL |     }\n+   |\n+\n+error: you seem to be trying to use match for destructuring a single pattern. Consider using `if let`\n+  --> $DIR/single_match_else.rs:79:5\n+   |\n+LL | /     match Some(1) {\n+LL | |         Some(a) => println!(\"${:?}\", a),\n+LL | |         None => {\n+LL | |             println!(\"else block\");\n+LL | |             return;\n+LL | |         },\n+LL | |     }\n+   | |_____^\n+   |\n+help: try this\n+   |\n+LL |     if let Some(a) = Some(1) { println!(\"${:?}\", a) } else {\n+LL |         println!(\"else block\");\n+LL |         return;\n+LL |     }\n+   |\n+\n+error: aborting due to 3 previous errors\n "}, {"sha": "766190f209977fcec1a70bd9f5ae9a4ec467c603", "filename": "src/tools/clippy/tests/ui/type_repetition_in_bounds.rs", "status": "modified", "additions": 54, "deletions": 1, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,4 +1,6 @@\n-#[deny(clippy::type_repetition_in_bounds)]\n+#![deny(clippy::type_repetition_in_bounds)]\n+\n+use std::ops::{Add, AddAssign, Div, DivAssign, Mul, MulAssign, Sub, SubAssign};\n \n pub fn foo<T>(_t: T)\n where\n@@ -16,4 +18,55 @@ where\n     unimplemented!();\n }\n \n+// Threshold test (see #4380)\n+trait LintBounds\n+where\n+    Self: Clone,\n+    Self: Copy + Default + Ord,\n+    Self: Add<Output = Self> + AddAssign + Sub<Output = Self> + SubAssign,\n+    Self: Mul<Output = Self> + MulAssign + Div<Output = Self> + DivAssign,\n+{\n+}\n+\n+trait LotsOfBounds\n+where\n+    Self: Clone + Copy + Default + Ord,\n+    Self: Add<Output = Self> + AddAssign + Sub<Output = Self> + SubAssign,\n+    Self: Mul<Output = Self> + MulAssign + Div<Output = Self> + DivAssign,\n+{\n+}\n+\n+// Generic distinction (see #4323)\n+mod issue4323 {\n+    pub struct Foo<A>(A);\n+    pub struct Bar<A, B> {\n+        a: Foo<A>,\n+        b: Foo<B>,\n+    }\n+\n+    impl<A, B> Unpin for Bar<A, B>\n+    where\n+        Foo<A>: Unpin,\n+        Foo<B>: Unpin,\n+    {\n+    }\n+}\n+\n+// Extern macros shouldn't lint (see #4326)\n+extern crate serde;\n+mod issue4326 {\n+    use serde::{Deserialize, Serialize};\n+\n+    trait Foo {}\n+    impl Foo for String {}\n+\n+    #[derive(Debug, Serialize, Deserialize)]\n+    struct Bar<S>\n+    where\n+        S: Foo,\n+    {\n+        foo: S,\n+    }\n+}\n+\n fn main() {}"}, {"sha": "148c19c7d0701dc2910de718d175a03122d26e03", "filename": "src/tools/clippy/tests/ui/type_repetition_in_bounds.stderr", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Ftype_repetition_in_bounds.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,15 +1,23 @@\n error: this type has already been used as a bound predicate\n-  --> $DIR/type_repetition_in_bounds.rs:6:5\n+  --> $DIR/type_repetition_in_bounds.rs:8:5\n    |\n LL |     T: Clone,\n    |     ^^^^^^^^\n    |\n note: the lint level is defined here\n-  --> $DIR/type_repetition_in_bounds.rs:1:8\n+  --> $DIR/type_repetition_in_bounds.rs:1:9\n    |\n-LL | #[deny(clippy::type_repetition_in_bounds)]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #![deny(clippy::type_repetition_in_bounds)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = help: consider combining the bounds: `T: Copy + Clone`\n \n-error: aborting due to previous error\n+error: this type has already been used as a bound predicate\n+  --> $DIR/type_repetition_in_bounds.rs:25:5\n+   |\n+LL |     Self: Copy + Default + Ord,\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = help: consider combining the bounds: `Self: Clone + Copy + Default + Ord`\n+\n+error: aborting due to 2 previous errors\n "}, {"sha": "2c9d4d39e6c7d9e7d18c8c7daf59fbe075b18b32", "filename": "src/tools/clippy/tests/ui/unnecessary_clone.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -13,31 +13,6 @@ impl SomeTrait for SomeImpl {}\n \n fn main() {}\n \n-fn is_ascii(ch: char) -> bool {\n-    ch.is_ascii()\n-}\n-\n-fn clone_on_copy() {\n-    42.clone();\n-\n-    vec![1].clone(); // ok, not a Copy type\n-    Some(vec![1]).clone(); // ok, not a Copy type\n-    (&42).clone();\n-\n-    let rc = RefCell::new(0);\n-    rc.borrow().clone();\n-\n-    // Issue #4348\n-    let mut x = 43;\n-    let _ = &x.clone(); // ok, getting a ref\n-    'a'.clone().make_ascii_uppercase(); // ok, clone and then mutate\n-    is_ascii('z'.clone());\n-\n-    // Issue #5436\n-    let mut vec = Vec::new();\n-    vec.push(42.clone());\n-}\n-\n fn clone_on_ref_ptr() {\n     let rc = Rc::new(true);\n     let arc = Arc::new(true);"}, {"sha": "113fab6900954c891b2610517dd728148aa3994b", "filename": "src/tools/clippy/tests/ui/unnecessary_clone.stderr", "status": "modified", "additions": 14, "deletions": 44, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_clone.stderr?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -1,81 +1,51 @@\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:21:5\n-   |\n-LL |     42.clone();\n-   |     ^^^^^^^^^^ help: try removing the `clone` call: `42`\n-   |\n-   = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n-\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:25:5\n-   |\n-LL |     (&42).clone();\n-   |     ^^^^^^^^^^^^^ help: try dereferencing it: `*(&42)`\n-\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:28:5\n-   |\n-LL |     rc.borrow().clone();\n-   |     ^^^^^^^^^^^^^^^^^^^ help: try dereferencing it: `*rc.borrow()`\n-\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:34:14\n-   |\n-LL |     is_ascii('z'.clone());\n-   |              ^^^^^^^^^^^ help: try removing the `clone` call: `'z'`\n-\n-error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:38:14\n-   |\n-LL |     vec.push(42.clone());\n-   |              ^^^^^^^^^^ help: try removing the `clone` call: `42`\n-\n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:48:5\n+  --> $DIR/unnecessary_clone.rs:23:5\n    |\n LL |     rc.clone();\n    |     ^^^^^^^^^^ help: try this: `Rc::<bool>::clone(&rc)`\n    |\n    = note: `-D clippy::clone-on-ref-ptr` implied by `-D warnings`\n \n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:51:5\n+  --> $DIR/unnecessary_clone.rs:26:5\n    |\n LL |     arc.clone();\n    |     ^^^^^^^^^^^ help: try this: `Arc::<bool>::clone(&arc)`\n \n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:54:5\n+  --> $DIR/unnecessary_clone.rs:29:5\n    |\n LL |     rcweak.clone();\n    |     ^^^^^^^^^^^^^^ help: try this: `Weak::<bool>::clone(&rcweak)`\n \n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:57:5\n+  --> $DIR/unnecessary_clone.rs:32:5\n    |\n LL |     arc_weak.clone();\n    |     ^^^^^^^^^^^^^^^^ help: try this: `Weak::<bool>::clone(&arc_weak)`\n \n error: using `.clone()` on a ref-counted pointer\n-  --> $DIR/unnecessary_clone.rs:61:33\n+  --> $DIR/unnecessary_clone.rs:36:33\n    |\n LL |     let _: Arc<dyn SomeTrait> = x.clone();\n    |                                 ^^^^^^^^^ help: try this: `Arc::<SomeImpl>::clone(&x)`\n \n error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:65:5\n+  --> $DIR/unnecessary_clone.rs:40:5\n    |\n LL |     t.clone();\n    |     ^^^^^^^^^ help: try removing the `clone` call: `t`\n+   |\n+   = note: `-D clippy::clone-on-copy` implied by `-D warnings`\n \n error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:67:5\n+  --> $DIR/unnecessary_clone.rs:42:5\n    |\n LL |     Some(t).clone();\n    |     ^^^^^^^^^^^^^^^ help: try removing the `clone` call: `Some(t)`\n \n error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n-  --> $DIR/unnecessary_clone.rs:73:22\n+  --> $DIR/unnecessary_clone.rs:48:22\n    |\n LL |     let z: &Vec<_> = y.clone();\n    |                      ^^^^^^^^^\n@@ -91,13 +61,13 @@ LL |     let z: &Vec<_> = <&std::vec::Vec<i32>>::clone(y);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `clone` on a `Copy` type\n-  --> $DIR/unnecessary_clone.rs:109:20\n+  --> $DIR/unnecessary_clone.rs:84:20\n    |\n LL |         let _: E = a.clone();\n    |                    ^^^^^^^^^ help: try dereferencing it: `*****a`\n \n error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n-  --> $DIR/unnecessary_clone.rs:114:22\n+  --> $DIR/unnecessary_clone.rs:89:22\n    |\n LL |         let _ = &mut encoded.clone();\n    |                      ^^^^^^^^^^^^^^^\n@@ -112,7 +82,7 @@ LL |         let _ = &mut <&[u8]>::clone(encoded);\n    |                      ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: using `clone` on a double-reference; this will copy the reference instead of cloning the inner type\n-  --> $DIR/unnecessary_clone.rs:115:18\n+  --> $DIR/unnecessary_clone.rs:90:18\n    |\n LL |         let _ = &encoded.clone();\n    |                  ^^^^^^^^^^^^^^^\n@@ -126,5 +96,5 @@ help: or try being explicit if you are sure, that you want to clone a reference\n LL |         let _ = &<&[u8]>::clone(encoded);\n    |                  ^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 11 previous errors\n "}, {"sha": "c017d1cf9a468bc03ddc55829e277442dfe87734", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.fixed", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.fixed?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,11 +2,11 @@\n \n use std::cmp::Reverse;\n \n-fn id(x: isize) -> isize {\n-    x\n-}\n+fn unnecessary_sort_by() {\n+    fn id(x: isize) -> isize {\n+        x\n+    }\n \n-fn main() {\n     let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n     // Forward examples\n     vec.sort();\n@@ -24,3 +24,41 @@ fn main() {\n     vec.sort_by(|_, b| b.cmp(c));\n     vec.sort_unstable_by(|a, _| a.cmp(c));\n }\n+\n+// Should not be linted to avoid hitting https://github.com/rust-lang/rust/issues/34162\n+mod issue_5754 {\n+    struct Test(String);\n+\n+    #[derive(PartialOrd, Ord, PartialEq, Eq)]\n+    struct Wrapper<'a>(&'a str);\n+\n+    impl Test {\n+        fn name(&self) -> &str {\n+            &self.0\n+        }\n+\n+        fn wrapped(&self) -> Wrapper<'_> {\n+            Wrapper(&self.0)\n+        }\n+    }\n+\n+    pub fn test() {\n+        let mut args: Vec<Test> = vec![];\n+\n+        // Forward\n+        args.sort_by(|a, b| a.name().cmp(b.name()));\n+        args.sort_by(|a, b| a.wrapped().cmp(&b.wrapped()));\n+        args.sort_unstable_by(|a, b| a.name().cmp(b.name()));\n+        args.sort_unstable_by(|a, b| a.wrapped().cmp(&b.wrapped()));\n+        // Reverse\n+        args.sort_by(|a, b| b.name().cmp(a.name()));\n+        args.sort_by(|a, b| b.wrapped().cmp(&a.wrapped()));\n+        args.sort_unstable_by(|a, b| b.name().cmp(a.name()));\n+        args.sort_unstable_by(|a, b| b.wrapped().cmp(&a.wrapped()));\n+    }\n+}\n+\n+fn main() {\n+    unnecessary_sort_by();\n+    issue_5754::test();\n+}"}, {"sha": "1929c72b2f2cd3737194c2c52eba6aaa309b3380", "filename": "src/tools/clippy/tests/ui/unnecessary_sort_by.rs", "status": "modified", "additions": 42, "deletions": 4, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnecessary_sort_by.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -2,11 +2,11 @@\n \n use std::cmp::Reverse;\n \n-fn id(x: isize) -> isize {\n-    x\n-}\n+fn unnecessary_sort_by() {\n+    fn id(x: isize) -> isize {\n+        x\n+    }\n \n-fn main() {\n     let mut vec: Vec<isize> = vec![3, 6, 1, 2, 5];\n     // Forward examples\n     vec.sort_by(|a, b| a.cmp(b));\n@@ -24,3 +24,41 @@ fn main() {\n     vec.sort_by(|_, b| b.cmp(c));\n     vec.sort_unstable_by(|a, _| a.cmp(c));\n }\n+\n+// Should not be linted to avoid hitting https://github.com/rust-lang/rust/issues/34162\n+mod issue_5754 {\n+    struct Test(String);\n+\n+    #[derive(PartialOrd, Ord, PartialEq, Eq)]\n+    struct Wrapper<'a>(&'a str);\n+\n+    impl Test {\n+        fn name(&self) -> &str {\n+            &self.0\n+        }\n+\n+        fn wrapped(&self) -> Wrapper<'_> {\n+            Wrapper(&self.0)\n+        }\n+    }\n+\n+    pub fn test() {\n+        let mut args: Vec<Test> = vec![];\n+\n+        // Forward\n+        args.sort_by(|a, b| a.name().cmp(b.name()));\n+        args.sort_by(|a, b| a.wrapped().cmp(&b.wrapped()));\n+        args.sort_unstable_by(|a, b| a.name().cmp(b.name()));\n+        args.sort_unstable_by(|a, b| a.wrapped().cmp(&b.wrapped()));\n+        // Reverse\n+        args.sort_by(|a, b| b.name().cmp(a.name()));\n+        args.sort_by(|a, b| b.wrapped().cmp(&a.wrapped()));\n+        args.sort_unstable_by(|a, b| b.name().cmp(a.name()));\n+        args.sort_unstable_by(|a, b| b.wrapped().cmp(&a.wrapped()));\n+    }\n+}\n+\n+fn main() {\n+    unnecessary_sort_by();\n+    issue_5754::test();\n+}"}, {"sha": "6bd35057bfad12f8ef301d808fc12e38db203a4c", "filename": "src/tools/clippy/tests/ui/unnested_or_patterns3.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2002ebacfbca288830a3c308ddc8189705c608fe/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Ftests%2Fui%2Funnested_or_patterns3.rs?ref=2002ebacfbca288830a3c308ddc8189705c608fe", "patch": "@@ -0,0 +1,6 @@\n+#![warn(clippy::unnested_or_patterns)]\n+\n+// Test that `unnested_or_patterns` does not trigger without enabling `or_patterns`\n+fn main() {\n+    if let (0, 1) | (0, 2) | (0, 3) = (0, 0) {}\n+}"}]}