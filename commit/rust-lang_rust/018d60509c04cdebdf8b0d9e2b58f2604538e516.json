{"sha": "018d60509c04cdebdf8b0d9e2b58f2604538e516", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxOGQ2MDUwOWMwNGNkZWJkZjhiMGQ5ZTJiNThmMjYwNDUzOGU1MTY=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-13T05:38:57Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-12-25T03:59:52Z"}, "message": "std: Get stdtest all passing again\n\nThis commit brings the library up-to-date in order to get all tests passing\nagain", "tree": {"sha": "00245c6192d883dbc4d45cbb10a314c4e2239d07", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/00245c6192d883dbc4d45cbb10a314c4e2239d07"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/018d60509c04cdebdf8b0d9e2b58f2604538e516", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/018d60509c04cdebdf8b0d9e2b58f2604538e516", "html_url": "https://github.com/rust-lang/rust/commit/018d60509c04cdebdf8b0d9e2b58f2604538e516", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/018d60509c04cdebdf8b0d9e2b58f2604538e516/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d830fcc6eb5173061888d4b128c0670a49515f58", "url": "https://api.github.com/repos/rust-lang/rust/commits/d830fcc6eb5173061888d4b128c0670a49515f58", "html_url": "https://github.com/rust-lang/rust/commit/d830fcc6eb5173061888d4b128c0670a49515f58"}], "stats": {"total": 1041, "additions": 451, "deletions": 590}, "files": [{"sha": "f94afe587f3fa3dada1697f9db7686fd78602f1a", "filename": "mk/host.mk", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/mk%2Fhost.mk", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/mk%2Fhost.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fhost.mk?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -24,7 +24,7 @@ define CP_HOST_STAGE_N\n # Note: $(3) and $(4) are both the same!\n \n $$(HBIN$(2)_H_$(4))/rustc$$(X_$(4)): \\\n-\t$$(TBIN$(1)_T_$(4)_H_$(3))/rustc$$(X_$(4))\n+\t$$(TBIN$(1)_T_$(4)_H_$(3))/rustc$$(X_$(4)) \\\n \t$$(HLIBRUSTC_DEFAULT$(2)_H_$(4)) \\\n \t| $$(HBIN$(2)_H_$(4))/\n \t@$$(call E, cp: $$@)"}, {"sha": "9fd9d9617c7d3457e6a83a6acf9579c5e381e21a", "filename": "mk/tests.mk", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -348,13 +348,13 @@ STDTESTDEP_$(1)_$(2)_$(3) =\n endif\n \n $(3)/stage$(1)/test/stdtest-$(2)$$(X_$(2)):\t\t\t\\\n-\t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS)\t\\\n+\t\t$$(STDLIB_CRATE) $$(STDLIB_INPUTS)\t\t\\\n \t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test\n \n $(3)/stage$(1)/test/extratest-$(2)$$(X_$(2)):\t\t\t\\\n-\t\t$$(EXTRALIB_CRATE) $$(EXTRALIB_INPUTS)\t\\\n+\t\t$$(EXTRALIB_CRATE) $$(EXTRALIB_INPUTS)\t\t\\\n \t\t$$(STDTESTDEP_$(1)_$(2)_$(3))\n \t@$$(call E, compile_and_link: $$@)\n \t$$(STAGE$(1)_T_$(2)_H_$(3)) -o $$@ $$< --test"}, {"sha": "8e5b6356a0b834506eb3097643b920cffb352dc2", "filename": "src/driver/driver.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Fdriver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Fdriver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdriver%2Fdriver.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[cfg(stage0)] extern mod green;\n+\n #[cfg(rustpkg)]\n extern mod this = \"rustpkg\";\n "}, {"sha": "6530316a62722e51dc0fc823e521de5847cb1b25", "filename": "src/libgreen/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibgreen%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibgreen%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgreen%2Flib.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -57,6 +57,8 @@ pub mod sleeper_list;\n pub mod stack;\n pub mod task;\n \n+#[cfg(test)] mod tests;\n+\n #[cfg(stage0)]\n #[lang = \"start\"]\n pub fn lang_start(main: *u8, argc: int, argv: **u8) -> int {"}, {"sha": "782bef10c92160a2ea83ccc45d27d49194a5c100", "filename": "src/libnative/task.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibnative%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibnative%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibnative%2Ftask.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -22,7 +22,7 @@ use std::rt::task::{Task, BlockedTask};\n use std::rt::thread::Thread;\n use std::rt;\n use std::sync::atomics::{AtomicUint, SeqCst, INIT_ATOMIC_UINT};\n-use std::task::TaskOpts;\n+use std::task::{TaskOpts, default_task_opts};\n use std::unstable::mutex::{Mutex, MUTEX_INIT};\n use std::unstable::stack;\n \n@@ -73,9 +73,14 @@ pub fn new() -> ~Task {\n     return task;\n }\n \n+/// Spawns a function with the default configuration\n+pub fn spawn(f: proc()) {\n+    spawn_opts(default_task_opts(), f)\n+}\n+\n /// Spawns a new task given the configuration options and a procedure to run\n /// inside the task.\n-pub fn spawn(opts: TaskOpts, f: proc()) {\n+pub fn spawn_opts(opts: TaskOpts, f: proc()) {\n     // must happen before the spawn, no need to synchronize with a lock.\n     unsafe { THREAD_CNT.fetch_add(1, SeqCst); }\n \n@@ -238,7 +243,7 @@ impl rt::Runtime for Ops {\n         cur_task.put_runtime(self as ~rt::Runtime);\n         Local::put(cur_task);\n \n-        task::spawn(opts, f);\n+        task::spawn_opts(opts, f);\n     }\n \n     fn local_io<'a>(&'a mut self) -> Option<rtio::LocalIo<'a>> {"}, {"sha": "45a91d01b7a9cee9920a1a3d7176b366d688ad47", "filename": "src/libstd/any.rs", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fany.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -119,7 +119,7 @@ impl<'a> AnyMutRefExt<'a> for &'a mut Any {\n /// Extension methods for a owning `Any` trait object\n pub trait AnyOwnExt {\n     /// Returns the boxed value if it is of type `T`, or\n-    /// `None` if it isn't.\n+    /// `Err(Self)` if it isn't.\n     fn move<T: 'static>(self) -> Result<~T, Self>;\n }\n \n@@ -156,9 +156,8 @@ impl<'a> ToStr for &'a Any {\n \n #[cfg(test)]\n mod tests {\n+    use prelude::*;\n     use super::*;\n-    use super::AnyRefExt;\n-    use option::{Some, None};\n \n     #[deriving(Eq)]\n     struct Test;\n@@ -385,8 +384,14 @@ mod tests {\n         let a = ~8u as ~Any;\n         let b = ~Test as ~Any;\n \n-        assert_eq!(a.move(), Ok(~8u));\n-        assert_eq!(b.move(), Ok(~Test));\n+        match a.move::<uint>() {\n+            Ok(a) => { assert_eq!(a, ~8u); }\n+            Err(..) => fail!()\n+        }\n+        match b.move::<Test>() {\n+            Ok(a) => { assert_eq!(a, ~Test); }\n+            Err(..) => fail!()\n+        }\n \n         let a = ~8u as ~Any;\n         let b = ~Test as ~Any;"}, {"sha": "76a9e5d17e1018152a86512d80d91204e9abd26a", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 182, "deletions": 230, "changes": 412, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -251,18 +251,21 @@ macro_rules! test (\n         mod $name {\n             #[allow(unused_imports)];\n \n-            use util;\n-            use super::super::*;\n+            use native;\n             use prelude::*;\n+            use super::*;\n+            use super::super::*;\n+            use task;\n+            use util;\n \n             fn f() $b\n \n             $($a)* #[test] fn uv() { f() }\n-            $($a)* #[test]\n-            #[ignore(cfg(windows))] // FIXME(#11003)\n-            fn native() {\n-                use unstable::run_in_bare_thread;\n-                run_in_bare_thread(f);\n+            $($a)* #[test] fn native() {\n+                use native;\n+                let (p, c) = Chan::new();\n+                do native::task::spawn { c.send(f()) }\n+                p.recv();\n             }\n         }\n     )\n@@ -889,10 +892,16 @@ impl<T: Send> Drop for Port<T> {\n mod test {\n     use prelude::*;\n \n-    use task;\n-    use rt::thread::Thread;\n+    use native;\n+    use os;\n     use super::*;\n-    use rt::test::*;\n+\n+    pub fn stress_factor() -> uint {\n+        match os::getenv(\"RUST_TEST_STRESS\") {\n+            Some(val) => from_str::<uint>(val).unwrap(),\n+            None => 1,\n+        }\n+    }\n \n     test!(fn smoke() {\n         let (p, c) = Chan::new();\n@@ -919,99 +928,88 @@ mod test {\n         assert_eq!(p.recv(), 1);\n     })\n \n-    #[test]\n-    fn smoke_threads() {\n+    test!(fn smoke_threads() {\n         let (p, c) = Chan::new();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             c.send(1);\n         }\n         assert_eq!(p.recv(), 1);\n-    }\n+    })\n \n-    #[test] #[should_fail]\n-    fn smoke_port_gone() {\n+    test!(fn smoke_port_gone() {\n         let (p, c) = Chan::new();\n         drop(p);\n         c.send(1);\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn smoke_shared_port_gone() {\n+    test!(fn smoke_shared_port_gone() {\n         let (p, c) = SharedChan::new();\n         drop(p);\n         c.send(1);\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn smoke_shared_port_gone2() {\n+    test!(fn smoke_shared_port_gone2() {\n         let (p, c) = SharedChan::new();\n         drop(p);\n         let c2 = c.clone();\n         drop(c);\n         c2.send(1);\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn port_gone_concurrent() {\n+    test!(fn port_gone_concurrent() {\n         let (p, c) = Chan::new();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             p.recv();\n         }\n         loop { c.send(1) }\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn port_gone_concurrent_shared() {\n+    test!(fn port_gone_concurrent_shared() {\n         let (p, c) = SharedChan::new();\n         let c1 = c.clone();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             p.recv();\n         }\n         loop {\n             c.send(1);\n             c1.send(1);\n         }\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn smoke_chan_gone() {\n+    test!(fn smoke_chan_gone() {\n         let (p, c) = Chan::<int>::new();\n         drop(c);\n         p.recv();\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn smoke_chan_gone_shared() {\n+    test!(fn smoke_chan_gone_shared() {\n         let (p, c) = SharedChan::<()>::new();\n         let c2 = c.clone();\n         drop(c);\n         drop(c2);\n         p.recv();\n-    }\n+    } #[should_fail])\n \n-    #[test] #[should_fail]\n-    fn chan_gone_concurrent() {\n+    test!(fn chan_gone_concurrent() {\n         let (p, c) = Chan::new();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             c.send(1);\n             c.send(1);\n         }\n         loop { p.recv(); }\n-    }\n+    } #[should_fail])\n \n-    #[test]\n-    fn stress() {\n+    test!(fn stress() {\n         let (p, c) = Chan::new();\n-        do task::spawn_sched(task::SingleThreaded) {\n+        do spawn {\n             for _ in range(0, 10000) { c.send(1); }\n         }\n         for _ in range(0, 10000) {\n             assert_eq!(p.recv(), 1);\n         }\n-    }\n+    })\n \n-    #[test]\n-    fn stress_shared() {\n+    test!(fn stress_shared() {\n         static AMT: uint = 10000;\n         static NTHREADS: uint = 8;\n         let (p, c) = SharedChan::<int>::new();\n@@ -1027,221 +1025,186 @@ mod test {\n \n         for _ in range(0, NTHREADS) {\n             let c = c.clone();\n-            do task::spawn_sched(task::SingleThreaded) {\n+            do spawn {\n                 for _ in range(0, AMT) { c.send(1); }\n             }\n         }\n         p1.recv();\n-\n-    }\n+    })\n \n     #[test]\n     #[ignore(cfg(windows))] // FIXME(#11003)\n     fn send_from_outside_runtime() {\n         let (p, c) = Chan::<int>::new();\n         let (p1, c1) = Chan::new();\n+        let (port, chan) = SharedChan::new();\n+        let chan2 = chan.clone();\n         do spawn {\n             c1.send(());\n             for _ in range(0, 40) {\n                 assert_eq!(p.recv(), 1);\n             }\n+            chan2.send(());\n         }\n         p1.recv();\n-        let t = do Thread::start {\n+        do native::task::spawn {\n             for _ in range(0, 40) {\n                 c.send(1);\n             }\n-        };\n-        t.join();\n+            chan.send(());\n+        }\n+        port.recv();\n+        port.recv();\n     }\n \n     #[test]\n     #[ignore(cfg(windows))] // FIXME(#11003)\n     fn recv_from_outside_runtime() {\n         let (p, c) = Chan::<int>::new();\n-        let t = do Thread::start {\n+        let (dp, dc) = Chan::new();\n+        do native::task::spawn {\n             for _ in range(0, 40) {\n                 assert_eq!(p.recv(), 1);\n             }\n+            dc.send(());\n         };\n         for _ in range(0, 40) {\n             c.send(1);\n         }\n-        t.join();\n+        dp.recv();\n     }\n \n     #[test]\n     #[ignore(cfg(windows))] // FIXME(#11003)\n     fn no_runtime() {\n         let (p1, c1) = Chan::<int>::new();\n         let (p2, c2) = Chan::<int>::new();\n-        let t1 = do Thread::start {\n+        let (port, chan) = SharedChan::new();\n+        let chan2 = chan.clone();\n+        do native::task::spawn {\n             assert_eq!(p1.recv(), 1);\n             c2.send(2);\n-        };\n-        let t2 = do Thread::start {\n+            chan2.send(());\n+        }\n+        do native::task::spawn {\n             c1.send(1);\n             assert_eq!(p2.recv(), 2);\n-        };\n-        t1.join();\n-        t2.join();\n+            chan.send(());\n+        }\n+        port.recv();\n+        port.recv();\n     }\n \n-    #[test]\n-    fn oneshot_single_thread_close_port_first() {\n+    test!(fn oneshot_single_thread_close_port_first() {\n         // Simple test of closing without sending\n-        do run_in_newsched_task {\n-            let (port, _chan) = Chan::<int>::new();\n-            { let _p = port; }\n-        }\n-    }\n+        let (port, _chan) = Chan::<int>::new();\n+        { let _p = port; }\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_close_chan_first() {\n+    test!(fn oneshot_single_thread_close_chan_first() {\n         // Simple test of closing without sending\n-        do run_in_newsched_task {\n-            let (_port, chan) = Chan::<int>::new();\n-            { let _c = chan; }\n-        }\n-    }\n+        let (_port, chan) = Chan::<int>::new();\n+        { let _c = chan; }\n+    })\n \n-    #[test] #[should_fail]\n-    fn oneshot_single_thread_send_port_close() {\n+    test!(fn oneshot_single_thread_send_port_close() {\n         // Testing that the sender cleans up the payload if receiver is closed\n         let (port, chan) = Chan::<~int>::new();\n         { let _p = port; }\n         chan.send(~0);\n-    }\n+    } #[should_fail])\n \n-    #[test]\n-    fn oneshot_single_thread_recv_chan_close() {\n+    test!(fn oneshot_single_thread_recv_chan_close() {\n         // Receiving on a closed chan will fail\n-        do run_in_newsched_task {\n-            let res = do spawntask_try {\n-                let (port, chan) = Chan::<~int>::new();\n-                { let _c = chan; }\n-                port.recv();\n-            };\n-            // What is our res?\n-            assert!(res.is_err());\n-        }\n-    }\n-\n-    #[test]\n-    fn oneshot_single_thread_send_then_recv() {\n-        do run_in_newsched_task {\n+        let res = do task::try {\n             let (port, chan) = Chan::<~int>::new();\n-            chan.send(~10);\n-            assert!(port.recv() == ~10);\n-        }\n-    }\n+            { let _c = chan; }\n+            port.recv();\n+        };\n+        // What is our res?\n+        assert!(res.is_err());\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_open() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            assert!(chan.try_send(10));\n-            assert!(port.recv() == 10);\n-        }\n-    }\n+    test!(fn oneshot_single_thread_send_then_recv() {\n+        let (port, chan) = Chan::<~int>::new();\n+        chan.send(~10);\n+        assert!(port.recv() == ~10);\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_try_send_closed() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            { let _p = port; }\n-            assert!(!chan.try_send(10));\n-        }\n-    }\n+    test!(fn oneshot_single_thread_try_send_open() {\n+        let (port, chan) = Chan::<int>::new();\n+        assert!(chan.try_send(10));\n+        assert!(port.recv() == 10);\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_try_recv_open() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            chan.send(10);\n-            assert!(port.try_recv() == Some(10));\n-        }\n-    }\n+    test!(fn oneshot_single_thread_try_send_closed() {\n+        let (port, chan) = Chan::<int>::new();\n+        { let _p = port; }\n+        assert!(!chan.try_send(10));\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_try_recv_closed() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            { let _c = chan; }\n-            assert!(port.recv_opt() == None);\n-        }\n-    }\n+    test!(fn oneshot_single_thread_try_recv_open() {\n+        let (port, chan) = Chan::<int>::new();\n+        chan.send(10);\n+        assert!(port.try_recv() == Some(10));\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_peek_data() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            assert!(port.try_recv().is_none());\n-            chan.send(10);\n-            assert!(port.try_recv().is_some());\n-        }\n-    }\n+    test!(fn oneshot_single_thread_try_recv_closed() {\n+        let (port, chan) = Chan::<int>::new();\n+        { let _c = chan; }\n+        assert!(port.recv_opt() == None);\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_peek_close() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<int>::new();\n-            { let _c = chan; }\n-            assert!(port.try_recv().is_none());\n-            assert!(port.try_recv().is_none());\n-        }\n-    }\n+    test!(fn oneshot_single_thread_peek_data() {\n+        let (port, chan) = Chan::<int>::new();\n+        assert!(port.try_recv().is_none());\n+        chan.send(10);\n+        assert!(port.try_recv().is_some());\n+    })\n \n-    #[test]\n-    fn oneshot_single_thread_peek_open() {\n-        do run_in_newsched_task {\n-            let (port, _) = Chan::<int>::new();\n-            assert!(port.try_recv().is_none());\n-        }\n-    }\n+    test!(fn oneshot_single_thread_peek_close() {\n+        let (port, chan) = Chan::<int>::new();\n+        { let _c = chan; }\n+        assert!(port.try_recv().is_none());\n+        assert!(port.try_recv().is_none());\n+    })\n \n-    #[test]\n-    fn oneshot_multi_task_recv_then_send() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<~int>::new();\n-            do spawntask {\n-                assert!(port.recv() == ~10);\n-            }\n+    test!(fn oneshot_single_thread_peek_open() {\n+        let (port, _) = Chan::<int>::new();\n+        assert!(port.try_recv().is_none());\n+    })\n \n-            chan.send(~10);\n+    test!(fn oneshot_multi_task_recv_then_send() {\n+        let (port, chan) = Chan::<~int>::new();\n+        do spawn {\n+            assert!(port.recv() == ~10);\n         }\n-    }\n \n-    #[test]\n-    fn oneshot_multi_task_recv_then_close() {\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::<~int>::new();\n-            do spawntask_later {\n-                let _chan = chan;\n-            }\n-            let res = do spawntask_try {\n-                assert!(port.recv() == ~10);\n-            };\n-            assert!(res.is_err());\n+        chan.send(~10);\n+    })\n+\n+    test!(fn oneshot_multi_task_recv_then_close() {\n+        let (port, chan) = Chan::<~int>::new();\n+        do spawn {\n+            let _chan = chan;\n         }\n-    }\n+        let res = do task::try {\n+            assert!(port.recv() == ~10);\n+        };\n+        assert!(res.is_err());\n+    })\n \n-    #[test]\n-    fn oneshot_multi_thread_close_stress() {\n+    test!(fn oneshot_multi_thread_close_stress() {\n         stress_factor().times(|| {\n-            do run_in_newsched_task {\n-                let (port, chan) = Chan::<int>::new();\n-                let thread = do spawntask_thread {\n-                    let _p = port;\n-                };\n-                let _chan = chan;\n-                thread.join();\n+            let (port, chan) = Chan::<int>::new();\n+            do spawn {\n+                let _p = port;\n             }\n+            let _chan = chan;\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn oneshot_multi_thread_send_close_stress() {\n+    test!(fn oneshot_multi_thread_send_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n             do spawn {\n@@ -1251,10 +1214,9 @@ mod test {\n                 chan.send(1);\n             };\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn oneshot_multi_thread_recv_close_stress() {\n+    test!(fn oneshot_multi_thread_recv_close_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<int>::new();\n             do spawn {\n@@ -1271,10 +1233,9 @@ mod test {\n                 }\n             };\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn oneshot_multi_thread_send_recv_stress() {\n+    test!(fn oneshot_multi_thread_send_recv_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<~int>::new();\n             do spawn {\n@@ -1284,10 +1245,9 @@ mod test {\n                 assert!(port.recv() == ~10);\n             }\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn stream_send_recv_stress() {\n+    test!(fn stream_send_recv_stress() {\n         stress_factor().times(|| {\n             let (port, chan) = Chan::<~int>::new();\n \n@@ -1297,7 +1257,7 @@ mod test {\n             fn send(chan: Chan<~int>, i: int) {\n                 if i == 10 { return }\n \n-                do spawntask_random {\n+                do spawn {\n                     chan.send(~i);\n                     send(chan, i + 1);\n                 }\n@@ -1306,44 +1266,37 @@ mod test {\n             fn recv(port: Port<~int>, i: int) {\n                 if i == 10 { return }\n \n-                do spawntask_random {\n+                do spawn {\n                     assert!(port.recv() == ~i);\n                     recv(port, i + 1);\n                 };\n             }\n         })\n-    }\n+    })\n \n-    #[test]\n-    fn recv_a_lot() {\n+    test!(fn recv_a_lot() {\n         // Regression test that we don't run out of stack in scheduler context\n-        do run_in_newsched_task {\n-            let (port, chan) = Chan::new();\n-            10000.times(|| { chan.send(()) });\n-            10000.times(|| { port.recv() });\n-        }\n-    }\n+        let (port, chan) = Chan::new();\n+        10000.times(|| { chan.send(()) });\n+        10000.times(|| { port.recv() });\n+    })\n \n-    #[test]\n-    fn shared_chan_stress() {\n-        do run_in_mt_newsched_task {\n-            let (port, chan) = SharedChan::new();\n-            let total = stress_factor() + 100;\n-            total.times(|| {\n-                let chan_clone = chan.clone();\n-                do spawntask_random {\n-                    chan_clone.send(());\n-                }\n-            });\n+    test!(fn shared_chan_stress() {\n+        let (port, chan) = SharedChan::new();\n+        let total = stress_factor() + 100;\n+        total.times(|| {\n+            let chan_clone = chan.clone();\n+            do spawn {\n+                chan_clone.send(());\n+            }\n+        });\n \n-            total.times(|| {\n-                port.recv();\n-            });\n-        }\n-    }\n+        total.times(|| {\n+            port.recv();\n+        });\n+    })\n \n-    #[test]\n-    fn test_nested_recv_iter() {\n+    test!(fn test_nested_recv_iter() {\n         let (port, chan) = Chan::<int>::new();\n         let (total_port, total_chan) = Chan::<int>::new();\n \n@@ -1360,10 +1313,9 @@ mod test {\n         chan.send(2);\n         drop(chan);\n         assert_eq!(total_port.recv(), 6);\n-    }\n+    })\n \n-    #[test]\n-    fn test_recv_iter_break() {\n+    test!(fn test_recv_iter_break() {\n         let (port, chan) = Chan::<int>::new();\n         let (count_port, count_chan) = Chan::<int>::new();\n \n@@ -1385,5 +1337,5 @@ mod test {\n         chan.try_send(2);\n         drop(chan);\n         assert_eq!(count_port.recv(), 4);\n-    }\n+    })\n }"}, {"sha": "302c9d9ea469be20b9ea917caf3ba1443d8d97e5", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 13, "deletions": 81, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -51,11 +51,11 @@ use ops::Drop;\n use option::{Some, None, Option};\n use ptr::RawPtr;\n use result::{Ok, Err};\n-use rt::thread::Thread;\n use rt::local::Local;\n use rt::task::Task;\n use super::{Packet, Port};\n use sync::atomics::{Relaxed, SeqCst};\n+use task;\n use uint;\n \n macro_rules! select {\n@@ -310,6 +310,7 @@ impl Iterator<*mut Packet> for PacketIterator {\n }\n \n #[cfg(test)]\n+#[allow(unused_imports)]\n mod test {\n     use super::super::*;\n     use prelude::*;\n@@ -365,19 +366,16 @@ mod test {\n         )\n     })\n \n-    #[test]\n-    fn unblocks() {\n-        use std::io::timer;\n-\n+    test!(fn unblocks() {\n         let (mut p1, c1) = Chan::<int>::new();\n         let (mut p2, _c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<int>::new();\n \n         do spawn {\n-            timer::sleep(3);\n+            20.times(task::deschedule);\n             c1.send(1);\n             p3.recv();\n-            timer::sleep(3);\n+            20.times(task::deschedule);\n         }\n \n         select! (\n@@ -389,18 +387,15 @@ mod test {\n             a = p1.recv_opt() => { assert_eq!(a, None); },\n             _b = p2.recv() => { fail!() }\n         )\n-    }\n-\n-    #[test]\n-    fn both_ready() {\n-        use std::io::timer;\n+    })\n \n+    test!(fn both_ready() {\n         let (mut p1, c1) = Chan::<int>::new();\n         let (mut p2, c2) = Chan::<int>::new();\n         let (p3, c3) = Chan::<()>::new();\n \n         do spawn {\n-            timer::sleep(3);\n+            20.times(task::deschedule);\n             c1.send(1);\n             c2.send(2);\n             p3.recv();\n@@ -414,11 +409,12 @@ mod test {\n             a = p1.recv() => { assert_eq!(a, 1); },\n             a = p2.recv() => { assert_eq!(a, 2); }\n         )\n+        assert_eq!(p1.try_recv(), None);\n+        assert_eq!(p2.try_recv(), None);\n         c3.send(());\n-    }\n+    })\n \n-    #[test]\n-    fn stress() {\n+    test!(fn stress() {\n         static AMT: int = 10000;\n         let (mut p1, c1) = Chan::<int>::new();\n         let (mut p2, c2) = Chan::<int>::new();\n@@ -442,69 +438,5 @@ mod test {\n             )\n             c3.send(());\n         }\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(windows))] // FIXME(#11003)\n-    fn stress_native() {\n-        use std::rt::thread::Thread;\n-        use std::unstable::run_in_bare_thread;\n-        static AMT: int = 10000;\n-\n-        do run_in_bare_thread {\n-            let (mut p1, c1) = Chan::<int>::new();\n-            let (mut p2, c2) = Chan::<int>::new();\n-            let (p3, c3) = Chan::<()>::new();\n-\n-            let t = do Thread::start {\n-                for i in range(0, AMT) {\n-                    if i % 2 == 0 {\n-                        c1.send(i);\n-                    } else {\n-                        c2.send(i);\n-                    }\n-                    p3.recv();\n-                }\n-            };\n-\n-            for i in range(0, AMT) {\n-                select! (\n-                    i1 = p1.recv() => { assert!(i % 2 == 0 && i == i1); },\n-                    i2 = p2.recv() => { assert!(i % 2 == 1 && i == i2); }\n-                )\n-                c3.send(());\n-            }\n-            t.join();\n-        }\n-    }\n-\n-    #[test]\n-    #[ignore(cfg(windows))] // FIXME(#11003)\n-    fn native_both_ready() {\n-        use std::rt::thread::Thread;\n-        use std::unstable::run_in_bare_thread;\n-\n-        do run_in_bare_thread {\n-            let (mut p1, c1) = Chan::<int>::new();\n-            let (mut p2, c2) = Chan::<int>::new();\n-            let (p3, c3) = Chan::<()>::new();\n-\n-            let t = do Thread::start {\n-                c1.send(1);\n-                c2.send(2);\n-                p3.recv();\n-            };\n-\n-            select! (\n-                a = p1.recv() => { assert_eq!(a, 1); },\n-                b = p2.recv() => { assert_eq!(b, 2); }\n-            )\n-            select! (\n-                a = p1.recv() => { assert_eq!(a, 1); },\n-                b = p2.recv() => { assert_eq!(b, 2); }\n-            )\n-            c3.send(());\n-            t.join();\n-        }\n-    }\n+    })\n }"}, {"sha": "b4838d534dcd6c05813f6c465b3e86711d98428e", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 31, "deletions": 56, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -714,40 +714,15 @@ mod test {\n         }\n     }\n \n-    fn tmpdir() -> TempDir {\n+    pub fn tmpdir() -> TempDir {\n         use os;\n         use rand;\n         let ret = os::tmpdir().join(format!(\"rust-{}\", rand::random::<u32>()));\n         io::fs::mkdir(&ret, io::UserRWX);\n         TempDir(ret)\n     }\n \n-    macro_rules! test (\n-        { fn $name:ident() $b:block } => (\n-            mod $name {\n-                use prelude::*;\n-                use io::{SeekSet, SeekCur, SeekEnd, io_error, Read, Open,\n-                         ReadWrite};\n-                use io;\n-                use str;\n-                use io::fs::{File, rmdir, mkdir, readdir, rmdir_recursive,\n-                             mkdir_recursive, copy, unlink, stat, symlink, link,\n-                             readlink, chmod, lstat, change_file_times};\n-                use io::fs::test::tmpdir;\n-                use util;\n-\n-                fn f() $b\n-\n-                #[test] fn uv() { f() }\n-                #[test] fn native() {\n-                    use rt::test::run_in_newsched_task;\n-                    run_in_newsched_task(f);\n-                }\n-            }\n-        )\n-    )\n-\n-    test!(fn file_test_io_smoke_test() {\n+    iotest!(fn file_test_io_smoke_test() {\n         let message = \"it's alright. have a good time\";\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_rt_io_file_test.txt\");\n@@ -767,7 +742,7 @@ mod test {\n         unlink(filename);\n     })\n \n-    test!(fn invalid_path_raises() {\n+    iotest!(fn invalid_path_raises() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_that_does_not_exist.txt\");\n         let mut called = false;\n@@ -780,7 +755,7 @@ mod test {\n         assert!(called);\n     })\n \n-    test!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n+    iotest!(fn file_test_iounlinking_invalid_path_should_raise_condition() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_another_file_that_does_not_exist.txt\");\n         let mut called = false;\n@@ -790,7 +765,7 @@ mod test {\n         assert!(called);\n     })\n \n-    test!(fn file_test_io_non_positional_read() {\n+    iotest!(fn file_test_io_non_positional_read() {\n         let message: &str = \"ten-four\";\n         let mut read_mem = [0, .. 8];\n         let tmpdir = tmpdir();\n@@ -815,7 +790,7 @@ mod test {\n         assert_eq!(read_str, message);\n     })\n \n-    test!(fn file_test_io_seek_and_tell_smoke_test() {\n+    iotest!(fn file_test_io_seek_and_tell_smoke_test() {\n         let message = \"ten-four\";\n         let mut read_mem = [0, .. 4];\n         let set_cursor = 4 as u64;\n@@ -841,7 +816,7 @@ mod test {\n         assert_eq!(tell_pos_post_read, message.len() as u64);\n     })\n \n-    test!(fn file_test_io_seek_and_write() {\n+    iotest!(fn file_test_io_seek_and_write() {\n         let initial_msg =   \"food-is-yummy\";\n         let overwrite_msg =    \"-the-bar!!\";\n         let final_msg =     \"foo-the-bar!!\";\n@@ -864,7 +839,7 @@ mod test {\n         assert!(read_str == final_msg.to_owned());\n     })\n \n-    test!(fn file_test_io_seek_shakedown() {\n+    iotest!(fn file_test_io_seek_shakedown() {\n         use std::str;          // 01234567890123\n         let initial_msg =   \"qwer-asdf-zxcv\";\n         let chunk_one: &str = \"qwer\";\n@@ -895,7 +870,7 @@ mod test {\n         unlink(filename);\n     })\n \n-    test!(fn file_test_stat_is_correct_on_is_file() {\n+    iotest!(fn file_test_stat_is_correct_on_is_file() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_file.txt\");\n         {\n@@ -908,7 +883,7 @@ mod test {\n         unlink(filename);\n     })\n \n-    test!(fn file_test_stat_is_correct_on_is_dir() {\n+    iotest!(fn file_test_stat_is_correct_on_is_dir() {\n         let tmpdir = tmpdir();\n         let filename = &tmpdir.join(\"file_stat_correct_on_is_dir\");\n         mkdir(filename, io::UserRWX);\n@@ -917,15 +892,15 @@ mod test {\n         rmdir(filename);\n     })\n \n-    test!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n+    iotest!(fn file_test_fileinfo_false_when_checking_is_file_on_a_directory() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"fileinfo_false_on_dir\");\n         mkdir(dir, io::UserRWX);\n         assert!(dir.is_file() == false);\n         rmdir(dir);\n     })\n \n-    test!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n+    iotest!(fn file_test_fileinfo_check_exists_before_and_after_file_creation() {\n         let tmpdir = tmpdir();\n         let file = &tmpdir.join(\"fileinfo_check_exists_b_and_a.txt\");\n         File::create(file).write(bytes!(\"foo\"));\n@@ -934,7 +909,7 @@ mod test {\n         assert!(!file.exists());\n     })\n \n-    test!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n+    iotest!(fn file_test_directoryinfo_check_exists_before_and_after_mkdir() {\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"before_and_after_dir\");\n         assert!(!dir.exists());\n@@ -945,7 +920,7 @@ mod test {\n         assert!(!dir.exists());\n     })\n \n-    test!(fn file_test_directoryinfo_readdir() {\n+    iotest!(fn file_test_directoryinfo_readdir() {\n         use std::str;\n         let tmpdir = tmpdir();\n         let dir = &tmpdir.join(\"di_readdir\");\n@@ -976,11 +951,11 @@ mod test {\n         rmdir(dir);\n     })\n \n-    test!(fn recursive_mkdir_slash() {\n+    iotest!(fn recursive_mkdir_slash() {\n         mkdir_recursive(&Path::new(\"/\"), io::UserRWX);\n     })\n \n-    test!(fn unicode_path_is_dir() {\n+    iotest!(fn unicode_path_is_dir() {\n         assert!(Path::new(\".\").is_dir());\n         assert!(!Path::new(\"test/stdtest/fs.rs\").is_dir());\n \n@@ -998,7 +973,7 @@ mod test {\n         assert!(filepath.exists());\n     })\n \n-    test!(fn unicode_path_exists() {\n+    iotest!(fn unicode_path_exists() {\n         assert!(Path::new(\".\").exists());\n         assert!(!Path::new(\"test/nonexistent-bogus-path\").exists());\n \n@@ -1010,7 +985,7 @@ mod test {\n         assert!(!Path::new(\"test/unicode-bogus-path-\uac01\u4e01\u30fc\u518d\u89c1\").exists());\n     })\n \n-    test!(fn copy_file_does_not_exist() {\n+    iotest!(fn copy_file_does_not_exist() {\n         let from = Path::new(\"test/nonexistent-bogus-path\");\n         let to = Path::new(\"test/other-bogus-path\");\n         match io::result(|| copy(&from, &to)) {\n@@ -1022,7 +997,7 @@ mod test {\n         }\n     })\n \n-    test!(fn copy_file_ok() {\n+    iotest!(fn copy_file_ok() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1035,7 +1010,7 @@ mod test {\n         assert_eq!(input.stat().perm, out.stat().perm);\n     })\n \n-    test!(fn copy_file_dst_dir() {\n+    iotest!(fn copy_file_dst_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n@@ -1045,7 +1020,7 @@ mod test {\n         }\n     })\n \n-    test!(fn copy_file_dst_exists() {\n+    iotest!(fn copy_file_dst_exists() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in\");\n         let output = tmpdir.join(\"out\");\n@@ -1058,7 +1033,7 @@ mod test {\n                    (bytes!(\"foo\")).to_owned());\n     })\n \n-    test!(fn copy_file_src_dir() {\n+    iotest!(fn copy_file_src_dir() {\n         let tmpdir = tmpdir();\n         let out = tmpdir.join(\"out\");\n \n@@ -1068,7 +1043,7 @@ mod test {\n         assert!(!out.exists());\n     })\n \n-    test!(fn copy_file_preserves_perm_bits() {\n+    iotest!(fn copy_file_preserves_perm_bits() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1083,7 +1058,7 @@ mod test {\n     })\n \n     #[cfg(not(windows))] // FIXME(#10264) operation not permitted?\n-    test!(fn symlinks_work() {\n+    iotest!(fn symlinks_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1098,22 +1073,22 @@ mod test {\n     })\n \n     #[cfg(not(windows))] // apparently windows doesn't like symlinks\n-    test!(fn symlink_noexist() {\n+    iotest!(fn symlink_noexist() {\n         let tmpdir = tmpdir();\n         // symlinks can point to things that don't exist\n         symlink(&tmpdir.join(\"foo\"), &tmpdir.join(\"bar\"));\n         assert!(readlink(&tmpdir.join(\"bar\")).unwrap() == tmpdir.join(\"foo\"));\n     })\n \n-    test!(fn readlink_not_symlink() {\n+    iotest!(fn readlink_not_symlink() {\n         let tmpdir = tmpdir();\n         match io::result(|| readlink(&*tmpdir)) {\n             Ok(..) => fail!(\"wanted a failure\"),\n             Err(..) => {}\n         }\n     })\n \n-    test!(fn links_work() {\n+    iotest!(fn links_work() {\n         let tmpdir = tmpdir();\n         let input = tmpdir.join(\"in.txt\");\n         let out = tmpdir.join(\"out.txt\");\n@@ -1139,7 +1114,7 @@ mod test {\n         }\n     })\n \n-    test!(fn chmod_works() {\n+    iotest!(fn chmod_works() {\n         let tmpdir = tmpdir();\n         let file = tmpdir.join(\"in.txt\");\n \n@@ -1156,7 +1131,7 @@ mod test {\n         chmod(&file, io::UserFile);\n     })\n \n-    test!(fn sync_doesnt_kill_anything() {\n+    iotest!(fn sync_doesnt_kill_anything() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n@@ -1169,7 +1144,7 @@ mod test {\n         drop(file);\n     })\n \n-    test!(fn truncate_works() {\n+    iotest!(fn truncate_works() {\n         let tmpdir = tmpdir();\n         let path = tmpdir.join(\"in.txt\");\n \n@@ -1200,7 +1175,7 @@ mod test {\n         drop(file);\n     })\n \n-    test!(fn open_flavors() {\n+    iotest!(fn open_flavors() {\n         let tmpdir = tmpdir();\n \n         match io::result(|| File::open_mode(&tmpdir.join(\"a\"), io::Open,"}, {"sha": "8481de73c7f0350b925b905f3286023f67699f2f", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -313,6 +313,10 @@ pub use self::net::udp::UdpStream;\n pub use self::pipe::PipeStream;\n pub use self::process::Process;\n \n+/// Testing helpers\n+#[cfg(test)]\n+mod test;\n+\n /// Synchronous, non-blocking filesystem operations.\n pub mod fs;\n "}, {"sha": "e7787692dd2f56f2a8f42ad5f5828ffdbc6a334e", "filename": "src/libstd/io/net/tcp.rs", "status": "modified", "additions": 27, "deletions": 35, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Ftcp.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -176,7 +176,7 @@ mod test {\n     #[test]\n     fn smoke_test_ip4() {\n         let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -195,7 +195,7 @@ mod test {\n     #[test]\n     fn smoke_test_ip6() {\n         let addr = next_test_ip6();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -214,7 +214,7 @@ mod test {\n     #[test]\n     fn read_eof_ip4() {\n         let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -233,7 +233,7 @@ mod test {\n     #[test]\n     fn read_eof_ip6() {\n         let addr = next_test_ip6();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -252,10 +252,10 @@ mod test {\n     #[test]\n     fn read_eof_twice_ip4() {\n         let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n-            port.take().recv();\n+            port.recv();\n             let _stream = TcpStream::connect(addr);\n             // Close\n         }\n@@ -281,7 +281,7 @@ mod test {\n     #[test]\n     fn read_eof_twice_ip6() {\n         let addr = next_test_ip6();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -310,7 +310,7 @@ mod test {\n     #[test]\n     fn write_close_ip4() {\n         let addr = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -342,7 +342,7 @@ mod test {\n     #[test]\n     fn write_close_ip6() {\n         let addr = next_test_ip6();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -375,7 +375,7 @@ mod test {\n     fn multiple_connect_serial_ip4() {\n         let addr = next_test_ip4();\n         let max = 10;\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -398,7 +398,7 @@ mod test {\n     fn multiple_connect_serial_ip6() {\n         let addr = next_test_ip6();\n         let max = 10;\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -421,16 +421,15 @@ mod test {\n     fn multiple_connect_interleaved_greedy_schedule_ip4() {\n         let addr = next_test_ip4();\n         static MAX: int = 10;\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                let stream = Cell::new(stream);\n                 // Start another task to handle the connection\n                 do spawn {\n-                    let mut stream = stream.take();\n+                    let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == i as u8);\n@@ -460,15 +459,15 @@ mod test {\n     fn multiple_connect_interleaved_greedy_schedule_ip6() {\n         let addr = next_test_ip6();\n         static MAX: int = 10;\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::<()>::new();\n \n         do spawn {\n             let mut acceptor = TcpListener::bind(addr).listen();\n+            chan.send(());\n             for (i, stream) in acceptor.incoming().enumerate().take(MAX as uint) {\n-                let stream = Cell::new(stream);\n                 // Start another task to handle the connection\n                 do spawn {\n-                    let mut stream = stream.take();\n+                    let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == i as u8);\n@@ -498,16 +497,15 @@ mod test {\n     fn multiple_connect_interleaved_lazy_schedule_ip4() {\n         let addr = next_test_ip4();\n         static MAX: int = 10;\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for stream in acceptor.incoming().take(MAX as uint) {\n-                let stream = Cell::new(stream);\n                 // Start another task to handle the connection\n                 do spawn {\n-                    let mut stream = stream.take();\n+                    let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == 99);\n@@ -536,16 +534,15 @@ mod test {\n     fn multiple_connect_interleaved_lazy_schedule_ip6() {\n         let addr = next_test_ip6();\n         static MAX: int = 10;\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let mut acceptor = TcpListener::bind(addr).listen();\n             chan.send(());\n             for stream in acceptor.incoming().take(MAX as uint) {\n-                let stream = Cell::new(stream);\n                 // Start another task to handle the connection\n                 do spawn {\n-                    let mut stream = stream.take();\n+                    let mut stream = stream;\n                     let mut buf = [0];\n                     stream.read(buf);\n                     assert!(buf[0] == 99);\n@@ -573,23 +570,18 @@ mod test {\n \n     #[cfg(test)]\n     fn socket_name(addr: SocketAddr) {\n-        do run_in_mt_newsched_task {\n-            do spawntask {\n-                let mut listener = TcpListener::bind(addr).unwrap();\n-\n-                // Make sure socket_name gives\n-                // us the socket we binded to.\n-                let so_name = listener.socket_name();\n-                assert!(so_name.is_some());\n-                assert_eq!(addr, so_name.unwrap());\n+        let mut listener = TcpListener::bind(addr).unwrap();\n \n-            }\n-        }\n+        // Make sure socket_name gives\n+        // us the socket we binded to.\n+        let so_name = listener.socket_name();\n+        assert!(so_name.is_some());\n+        assert_eq!(addr, so_name.unwrap());\n     }\n \n     #[cfg(test)]\n     fn peer_name(addr: SocketAddr) {\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             let mut acceptor = TcpListener::bind(addr).listen();"}, {"sha": "7cb8f741cf3c157634fc3af1394e585d27dd36ae", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -101,6 +101,7 @@ mod test {\n     use super::*;\n     use io::net::ip::{Ipv4Addr, SocketAddr};\n     use io::*;\n+    use io::test::*;\n     use prelude::*;\n \n     #[test]  #[ignore]\n@@ -121,7 +122,7 @@ mod test {\n     fn socket_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             match UdpSocket::bind(client_ip) {\n@@ -154,7 +155,7 @@ mod test {\n     fn socket_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::<()>::new();\n \n         do spawn {\n             match UdpSocket::bind(client_ip) {\n@@ -168,7 +169,7 @@ mod test {\n \n         match UdpSocket::bind(server_ip) {\n             Some(ref mut server) => {\n-                chan.take().send(());\n+                chan.send(());\n                 let mut buf = [0];\n                 match server.recvfrom(buf) {\n                     Some((nread, src)) => {\n@@ -187,7 +188,7 @@ mod test {\n     fn stream_smoke_test_ip4() {\n         let server_ip = next_test_ip4();\n         let client_ip = next_test_ip4();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             match UdpSocket::bind(client_ip) {\n@@ -223,7 +224,7 @@ mod test {\n     fn stream_smoke_test_ip6() {\n         let server_ip = next_test_ip6();\n         let client_ip = next_test_ip6();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             match UdpSocket::bind(client_ip) {"}, {"sha": "59a6903adbf8ea745495e8e9e11c0e5068fc9404", "filename": "src/libstd/io/net/unix.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fnet%2Funix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Funix.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -141,11 +141,12 @@ mod tests {\n     use prelude::*;\n     use super::*;\n     use io::*;\n+    use io::test::*;\n \n     fn smalltest(server: proc(UnixStream), client: proc(UnixStream)) {\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();\n@@ -229,7 +230,7 @@ mod tests {\n         let times = 10;\n         let path1 = next_test_unix();\n         let path2 = path1.clone();\n-        let (port, chan) = oneshot();\n+        let (port, chan) = Chan::new();\n \n         do spawn {\n             port.recv();"}, {"sha": "5249d331f72515611ca8becfb4facb0e6d33d2eb", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -308,23 +308,10 @@ impl Writer for StdWriter {\n \n #[cfg(test)]\n mod tests {\n-    use super::*;\n-    use rt::test::run_in_newsched_task;\n-\n-    #[test]\n-    fn smoke_uv() {\n+    iotest!(fn smoke() {\n         // Just make sure we can acquire handles\n         stdin();\n         stdout();\n         stderr();\n-    }\n-\n-    #[test]\n-    fn smoke_native() {\n-        do run_in_newsched_task {\n-            stdin();\n-            stdout();\n-            stderr();\n-        }\n-    }\n+    })\n }"}, {"sha": "dd24150e03e1f012a244bcfbbcd046aa0e8c9622", "filename": "src/libstd/io/test.rs", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fio%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftest.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -8,9 +8,48 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[macro_escape];\n+\n+use os;\n+use prelude::*;\n+use rand;\n+use rand::Rng;\n+use std::io::net::ip::*;\n+use sync::atomics::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n+\n+macro_rules! iotest (\n+    { fn $name:ident() $b:block } => (\n+        mod $name {\n+            #[allow(unused_imports)];\n+\n+            use super::super::*;\n+            use super::*;\n+            use io;\n+            use prelude::*;\n+            use io::*;\n+            use io::fs::*;\n+            use io::net::tcp::*;\n+            use io::net::ip::*;\n+            use io::net::udp::*;\n+            use io::net::unix::*;\n+            use str;\n+            use util;\n+\n+            fn f() $b\n+\n+            #[test] fn green() { f() }\n+            #[test] fn native() {\n+                use native;\n+                let (p, c) = Chan::new();\n+                do native::task::spawn { c.send(f()) }\n+                p.recv();\n+            }\n+        }\n+    )\n+)\n+\n /// Get a port number, starting at 9600, for use in tests\n pub fn next_test_port() -> u16 {\n-    use unstable::atomics::{AtomicUint, INIT_ATOMIC_UINT, Relaxed};\n     static mut next_offset: AtomicUint = INIT_ATOMIC_UINT;\n     unsafe {\n         base_port() + next_offset.fetch_add(1, Relaxed) as u16\n@@ -44,9 +83,6 @@ all want to use ports. This function figures out which workspace\n it is running in and assigns a port range based on it.\n */\n fn base_port() -> u16 {\n-    use os;\n-    use str::StrSlice;\n-    use vec::ImmutableVector;\n \n     let base = 9600u16;\n     let range = 1000u16;"}, {"sha": "4f633a63babc4c1a3b49ac0f1bcd73543dcafa54", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -65,13 +65,15 @@\n // When testing libstd, bring in libuv as the I/O backend so tests can print\n // things and all of the std::io tests have an I/O interface to run on top\n // of\n-#[cfg(test)] extern mod rustuv = \"rustuv#0.9-pre\";\n+#[cfg(test)] extern mod rustuv = \"rustuv\";\n+#[cfg(test)] extern mod native = \"native\";\n+#[cfg(test)] extern mod green = \"green\";\n \n // Make extra accessible for benchmarking\n-#[cfg(test)] extern mod extra = \"extra#0.9-pre\";\n+#[cfg(test)] extern mod extra = \"extra\";\n \n // Make std testable by not duplicating lang items. See #2912\n-#[cfg(test)] extern mod realstd = \"std#0.9-pre\";\n+#[cfg(test)] extern mod realstd = \"std\";\n #[cfg(test)] pub use kinds = realstd::kinds;\n #[cfg(test)] pub use ops = realstd::ops;\n #[cfg(test)] pub use cmp = realstd::cmp;"}, {"sha": "d7e11d2f3a70f693a1ff9b8f44386ab0d0e2e4be", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -432,6 +432,7 @@ mod tests {\n     }\n \n     #[test]\n+    #[allow(dead_code)]\n     fn test_tls_overwrite_multiple_types() {\n         static str_key: Key<~str> = &Key;\n         static box_key: Key<@()> = &Key;"}, {"sha": "1c04b6b43ce77418f0f6cf2c99bab13f0bf8e8a1", "filename": "src/libstd/rt/local.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Frt%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Frt%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Flocal.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -49,7 +49,6 @@ impl Local<local_ptr::Borrowed<Task>> for Task {\n mod test {\n     use option::None;\n     use unstable::run_in_bare_thread;\n-    use rt::test::*;\n     use super::*;\n     use rt::task::Task;\n     use rt::local_ptr;\n@@ -58,8 +57,7 @@ mod test {\n     fn thread_local_task_smoke_test() {\n         do run_in_bare_thread {\n             local_ptr::init();\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -70,12 +68,11 @@ mod test {\n     fn thread_local_task_two_instances() {\n         do run_in_bare_thread {\n             local_ptr::init();\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n             let task: ~Task = Local::take();\n             cleanup_task(task);\n@@ -87,8 +84,7 @@ mod test {\n     fn borrow_smoke_test() {\n         do run_in_bare_thread {\n             local_ptr::init();\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n \n             unsafe {\n@@ -103,8 +99,7 @@ mod test {\n     fn borrow_with_return() {\n         do run_in_bare_thread {\n             local_ptr::init();\n-            let mut sched = ~new_test_uv_sched();\n-            let task = ~Task::new_root(&mut sched.stack_pool, None, proc(){});\n+            let task = ~Task::new();\n             Local::put(task);\n \n             {\n@@ -116,5 +111,9 @@ mod test {\n         }\n     }\n \n+    fn cleanup_task(mut t: ~Task) {\n+        t.destroyed = true;\n+    }\n+\n }\n "}, {"sha": "c0164891cd41c942160ae8f45333d73d3a0b0a23", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -176,8 +176,12 @@ impl Task {\n         // Cleanup the dynamic borrowck debugging info\n         borrowck::clear_task_borrow_list();\n \n+        // TODO: dox\n+        unsafe {\n+            let me: *mut Task = Local::unsafe_borrow();\n+            (*me).death.collect_failure((*me).unwinder.result());\n+        }\n         let mut me: ~Task = Local::take();\n-        me.death.collect_failure(me.unwinder.result());\n         me.destroyed = true;\n         return me;\n     }\n@@ -375,92 +379,76 @@ impl Drop for Death {\n #[cfg(test)]\n mod test {\n     use super::*;\n-    use rt::test::*;\n     use prelude::*;\n+    use task;\n \n     #[test]\n     fn local_heap() {\n-        do run_in_newsched_task() {\n-            let a = @5;\n-            let b = a;\n-            assert!(*a == 5);\n-            assert!(*b == 5);\n-        }\n+        let a = @5;\n+        let b = a;\n+        assert!(*a == 5);\n+        assert!(*b == 5);\n     }\n \n     #[test]\n     fn tls() {\n         use local_data;\n-        do run_in_newsched_task() {\n-            local_data_key!(key: @~str)\n-            local_data::set(key, @~\"data\");\n-            assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n-            local_data_key!(key2: @~str)\n-            local_data::set(key2, @~\"data\");\n-            assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n-        }\n+        local_data_key!(key: @~str)\n+        local_data::set(key, @~\"data\");\n+        assert!(*local_data::get(key, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n+        local_data_key!(key2: @~str)\n+        local_data::set(key2, @~\"data\");\n+        assert!(*local_data::get(key2, |k| k.map(|k| *k)).unwrap() == ~\"data\");\n     }\n \n     #[test]\n     fn unwind() {\n-        do run_in_newsched_task() {\n-            let result = spawntask_try(proc()());\n-            rtdebug!(\"trying first assert\");\n-            assert!(result.is_ok());\n-            let result = spawntask_try(proc() fail!());\n-            rtdebug!(\"trying second assert\");\n-            assert!(result.is_err());\n-        }\n+        let result = task::try(proc()());\n+        rtdebug!(\"trying first assert\");\n+        assert!(result.is_ok());\n+        let result = task::try::<()>(proc() fail!());\n+        rtdebug!(\"trying second assert\");\n+        assert!(result.is_err());\n     }\n \n     #[test]\n     fn rng() {\n-        do run_in_uv_task() {\n-            use rand::{rng, Rng};\n-            let mut r = rng();\n-            let _ = r.next_u32();\n-        }\n+        use rand::{rng, Rng};\n+        let mut r = rng();\n+        let _ = r.next_u32();\n     }\n \n     #[test]\n     fn logging() {\n-        do run_in_uv_task() {\n-            info!(\"here i am. logging in a newsched task\");\n-        }\n+        info!(\"here i am. logging in a newsched task\");\n     }\n \n     #[test]\n     fn comm_stream() {\n-        do run_in_newsched_task() {\n-            let (port, chan) = Chan::new();\n-            chan.send(10);\n-            assert!(port.recv() == 10);\n-        }\n+        let (port, chan) = Chan::new();\n+        chan.send(10);\n+        assert!(port.recv() == 10);\n     }\n \n     #[test]\n     fn comm_shared_chan() {\n-        do run_in_newsched_task() {\n-            let (port, chan) = SharedChan::new();\n-            chan.send(10);\n-            assert!(port.recv() == 10);\n-        }\n+        let (port, chan) = SharedChan::new();\n+        chan.send(10);\n+        assert!(port.recv() == 10);\n     }\n \n     #[test]\n     fn heap_cycles() {\n         use option::{Option, Some, None};\n \n-        do run_in_newsched_task {\n-            struct List {\n-                next: Option<@mut List>,\n-            }\n+        struct List {\n+            next: Option<@mut List>,\n+        }\n \n-            let a = @mut List { next: None };\n-            let b = @mut List { next: Some(a) };\n+        let a = @mut List { next: None };\n+        let b = @mut List { next: Some(a) };\n \n-            a.next = Some(b);\n-        }\n+        a.next = Some(b);\n     }\n \n     #[test]\n@@ -471,8 +459,8 @@ mod test {\n \n     #[test]\n     fn block_and_wake() {\n-        do with_test_task |task| {\n-            BlockedTask::block(task).wake().unwrap()\n-        }\n+        let task = ~Task::new();\n+        let mut task = BlockedTask::block(task).wake().unwrap();\n+        task.destroyed = true;\n     }\n }"}, {"sha": "69704c855ee8f2f3a5da4d45d31facee7bc94172", "filename": "src/libstd/run.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Frun.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Frun.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frun.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -426,13 +426,13 @@ mod tests {\n     }\n \n     fn writeclose(fd: c_int, s: &str) {\n-        let mut writer = PipeStream::open(fd as int);\n+        let mut writer = PipeStream::open(fd);\n         writer.write(s.as_bytes());\n     }\n \n     fn readclose(fd: c_int) -> ~str {\n         let mut res = ~[];\n-        let mut reader = PipeStream::open(fd as int);\n+        let mut reader = PipeStream::open(fd);\n         let mut buf = [0, ..1024];\n         loop {\n             match reader.read(buf) {"}, {"sha": "7b94a3acc2b7dac27a06ded944c800f11d54edda", "filename": "src/libstd/sync/arc.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fsync%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fsync%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Farc.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -131,7 +131,6 @@ impl<T> Drop for UnsafeArc<T>{\n mod tests {\n     use prelude::*;\n     use super::UnsafeArc;\n-    use task;\n     use mem::size_of;\n \n     #[test]"}, {"sha": "fe51de4e42d067c5aab7d4c4b94de76f0902b166", "filename": "src/libstd/sync/mpmc_bounded_queue.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpmc_bounded_queue.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -163,23 +163,26 @@ impl<T: Send> Clone for Queue<T> {\n mod tests {\n     use prelude::*;\n     use option::*;\n-    use task;\n     use super::Queue;\n+    use native;\n \n     #[test]\n     fn test() {\n         let nthreads = 8u;\n         let nmsgs = 1000u;\n         let mut q = Queue::with_capacity(nthreads*nmsgs);\n         assert_eq!(None, q.pop());\n+        let (port, chan) = SharedChan::new();\n \n         for _ in range(0, nthreads) {\n             let q = q.clone();\n-            do task::spawn_sched(task::SingleThreaded) {\n+            let chan = chan.clone();\n+            do native::task::spawn {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     assert!(q.push(i));\n                 }\n+                chan.send(());\n             }\n         }\n \n@@ -188,7 +191,7 @@ mod tests {\n             let (completion_port, completion_chan) = Chan::new();\n             completion_ports.push(completion_port);\n             let q = q.clone();\n-            do task::spawn_sched(task::SingleThreaded) {\n+            do native::task::spawn {\n                 let mut q = q;\n                 let mut i = 0u;\n                 loop {\n@@ -207,5 +210,8 @@ mod tests {\n         for completion_port in completion_ports.mut_iter() {\n             assert_eq!(nmsgs, completion_port.recv());\n         }\n+        for _ in range(0, nthreads) {\n+            port.recv();\n+        }\n     }\n }"}, {"sha": "a249d6ed2e8ce8cc65e93398db6a74fc4c251500", "filename": "src/libstd/sync/mpsc_queue.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fsync%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc_queue.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -203,8 +203,8 @@ impl<T: Send, P: Send> Consumer<T, P> {\n mod tests {\n     use prelude::*;\n \n-    use task;\n     use super::{queue, Data, Empty, Inconsistent};\n+    use native;\n \n     #[test]\n     fn test_full() {\n@@ -222,14 +222,17 @@ mod tests {\n             Empty => {}\n             Inconsistent | Data(..) => fail!()\n         }\n+        let (port, chan) = SharedChan::new();\n \n         for _ in range(0, nthreads) {\n             let q = p.clone();\n-            do task::spawn_sched(task::SingleThreaded) {\n+            let chan = chan.clone();\n+            do native::task::spawn {\n                 let mut q = q;\n                 for i in range(0, nmsgs) {\n                     q.push(i);\n                 }\n+                chan.send(());\n             }\n         }\n \n@@ -240,6 +243,9 @@ mod tests {\n                 Data(_) => { i += 1 }\n             }\n         }\n+        for _ in range(0, nthreads) {\n+            port.recv();\n+        }\n     }\n }\n "}, {"sha": "6f1b887c271569c2ca23a9d6209367768fc719c6", "filename": "src/libstd/sync/spsc_queue.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fsync%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fspsc_queue.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -268,7 +268,7 @@ impl<T: Send, P: Send> Drop for State<T, P> {\n mod test {\n     use prelude::*;\n     use super::queue;\n-    use task;\n+    use native;\n \n     #[test]\n     fn smoke() {\n@@ -314,7 +314,8 @@ mod test {\n \n         fn stress_bound(bound: uint) {\n             let (c, mut p) = queue(bound, ());\n-            do task::spawn_sched(task::SingleThreaded) {\n+            let (port, chan) = Chan::new();\n+            do native::task::spawn {\n                 let mut c = c;\n                 for _ in range(0, 100000) {\n                     loop {\n@@ -325,10 +326,12 @@ mod test {\n                         }\n                     }\n                 }\n+                chan.send(());\n             }\n             for _ in range(0, 100000) {\n                 p.push(1);\n             }\n+            port.recv();\n         }\n     }\n }"}, {"sha": "3b9cde5f44da0241266a0cb740c866b249d70233", "filename": "src/libstd/task.rs", "status": "modified", "additions": 32, "deletions": 66, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -64,6 +64,7 @@ use send_str::{SendStr, IntoSendStr};\n use str::Str;\n use util;\n \n+#[cfg(test)] use any::{AnyOwnExt, AnyRefExt};\n #[cfg(test)] use comm::SharedChan;\n #[cfg(test)] use ptr;\n #[cfg(test)] use result;\n@@ -385,59 +386,43 @@ pub fn failing() -> bool {\n \n #[test]\n fn test_unnamed_task() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        do spawn {\n-            with_task_name(|name| {\n-                assert!(name.is_none());\n-            })\n-        }\n+    do spawn {\n+        with_task_name(|name| {\n+            assert!(name.is_none());\n+        })\n     }\n }\n \n #[test]\n fn test_owned_named_task() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        let mut t = task();\n-        t.name(~\"ada lovelace\");\n-        do t.spawn {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        }\n+    let mut t = task();\n+    t.name(~\"ada lovelace\");\n+    do t.spawn {\n+        with_task_name(|name| {\n+            assert!(name.unwrap() == \"ada lovelace\");\n+        })\n     }\n }\n \n #[test]\n fn test_static_named_task() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        let mut t = task();\n-        t.name(\"ada lovelace\");\n-        do t.spawn {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        }\n+    let mut t = task();\n+    t.name(\"ada lovelace\");\n+    do t.spawn {\n+        with_task_name(|name| {\n+            assert!(name.unwrap() == \"ada lovelace\");\n+        })\n     }\n }\n \n #[test]\n fn test_send_named_task() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        let mut t = task();\n-        t.name(\"ada lovelace\".into_send_str());\n-        do t.spawn {\n-            with_task_name(|name| {\n-                assert!(name.unwrap() == \"ada lovelace\");\n-            })\n-        }\n+    let mut t = task();\n+    t.name(\"ada lovelace\".into_send_str());\n+    do t.spawn {\n+        with_task_name(|name| {\n+            assert!(name.unwrap() == \"ada lovelace\");\n+        })\n     }\n }\n \n@@ -508,28 +493,19 @@ fn test_try_fail() {\n     }\n }\n \n-#[cfg(test)]\n-fn get_sched_id() -> int {\n-    use rt::sched::Scheduler;\n-    let mut sched = Local::borrow(None::<Scheduler>);\n-    sched.get().sched_id() as int\n-}\n-\n #[test]\n fn test_spawn_sched() {\n+    use clone::Clone;\n+\n     let (po, ch) = SharedChan::new();\n \n     fn f(i: int, ch: SharedChan<()>) {\n-        let parent_sched_id = get_sched_id();\n-\n-        do spawn_sched(SingleThreaded) {\n-            let child_sched_id = get_sched_id();\n-            assert!(parent_sched_id != child_sched_id);\n-\n+        let ch = ch.clone();\n+        do spawn {\n             if (i == 0) {\n                 ch.send(());\n             } else {\n-                f(i - 1, ch.clone());\n+                f(i - 1, ch);\n             }\n         };\n \n@@ -542,16 +518,9 @@ fn test_spawn_sched() {\n fn test_spawn_sched_childs_on_default_sched() {\n     let (po, ch) = Chan::new();\n \n-    // Assuming tests run on the default scheduler\n-    let default_id = get_sched_id();\n-\n-    do spawn_sched(SingleThreaded) {\n+    do spawn {\n         let ch = ch;\n-        let parent_sched_id = get_sched_id();\n         do spawn {\n-            let child_sched_id = get_sched_id();\n-            assert!(parent_sched_id != child_sched_id);\n-            assert_eq!(child_sched_id, default_id);\n             ch.send(());\n         };\n     };\n@@ -562,6 +531,7 @@ fn test_spawn_sched_childs_on_default_sched() {\n #[test]\n fn test_spawn_sched_blocking() {\n     use unstable::mutex::Mutex;\n+    use num::Times;\n \n     unsafe {\n \n@@ -574,7 +544,7 @@ fn test_spawn_sched_blocking() {\n             let mut lock = Mutex::new();\n             let lock2 = lock.clone();\n \n-            do spawn_sched(SingleThreaded) {\n+            do spawn {\n                 let mut lock = lock2;\n                 lock.lock();\n \n@@ -681,11 +651,7 @@ fn test_child_doesnt_ref_parent() {\n \n #[test]\n fn test_simple_newsched_spawn() {\n-    use rt::test::run_in_uv_task;\n-\n-    do run_in_uv_task {\n-        spawn(proc()())\n-    }\n+    spawn(proc()())\n }\n \n #[test]"}, {"sha": "5b2fac8e74e2eb44cf095fcb7230a87cf9bfa8cc", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -333,12 +333,12 @@ mod test {\n     fn somke_cond() {\n         static mut lock: Mutex = MUTEX_INIT;\n         unsafe {\n+            lock.lock();\n             let t = do Thread::start {\n                 lock.lock();\n                 lock.signal();\n                 lock.unlock();\n             };\n-            lock.lock();\n             lock.wait();\n             lock.unlock();\n             t.join();"}, {"sha": "b8788b8c55c1e16851522609bf99e3a6f40123cb", "filename": "src/libstd/unstable/stack.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Funstable%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Funstable%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fstack.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -24,11 +24,6 @@\n //! detection is not guaranteed to continue in the future. Usage of this module\n //! is discouraged unless absolutely necessary.\n \n-use rt::task::Task;\n-use option::None;\n-use rt::local::Local;\n-use unstable::intrinsics;\n-\n static RED_ZONE: uint = 20 * 1024;\n \n /// This function is invoked from rust's current __morestack function. Segmented\n@@ -41,6 +36,10 @@ static RED_ZONE: uint = 20 * 1024;\n                   //   irrelevant for documentation purposes.\n #[cfg(not(test))] // in testing, use the original libstd's version\n pub extern \"C\" fn rust_stack_exhausted() {\n+    use rt::task::Task;\n+    use option::None;\n+    use rt::local::Local;\n+    use unstable::intrinsics;\n \n     unsafe {\n         // We're calling this function because the stack just ran out. We need"}, {"sha": "687efea939b52705e2f011174b0564d30a43a8c8", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -161,9 +161,8 @@ impl<T:Send> Exclusive<T> {\n mod tests {\n     use option::*;\n     use prelude::*;\n-    use super::{Exclusive, UnsafeArc, atomic};\n+    use super::Exclusive;\n     use task;\n-    use mem::size_of;\n \n     #[test]\n     fn exclusive_new_arc() {"}, {"sha": "86f28c28f6977597f063a899c984fd8e90bae17c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/018d60509c04cdebdf8b0d9e2b58f2604538e516/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=018d60509c04cdebdf8b0d9e2b58f2604538e516", "patch": "@@ -2874,7 +2874,6 @@ impl<A> Extendable<A> for ~[A] {\n \n #[cfg(test)]\n mod tests {\n-    use option::{None, Some};\n     use mem;\n     use vec::*;\n     use cmp::*;"}]}