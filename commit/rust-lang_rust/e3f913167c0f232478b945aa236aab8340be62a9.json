{"sha": "e3f913167c0f232478b945aa236aab8340be62a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZjkxMzE2N2MwZjIzMjQ3OGI5NDVhYTIzNmFhYjgzNDBiZTYyYTk=", "commit": {"author": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-12T15:07:09Z"}, "committer": {"name": "Michael Woerister", "email": "michaelwoerister@posteo", "date": "2017-09-18T09:25:34Z"}, "message": "Fix issues uncovered by rebasing:\n\n- Don't hash traits in scope as part of HIR hashing any more.\n- Some queries returned DefIndexes from other crates.\n- Provide a generic way of stably hashing maps (not used everywhere yet).", "tree": {"sha": "76657da3d2bf4d06a9e6d1f9b6f23fc8b3e274c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/76657da3d2bf4d06a9e6d1f9b6f23fc8b3e274c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3f913167c0f232478b945aa236aab8340be62a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3f913167c0f232478b945aa236aab8340be62a9", "html_url": "https://github.com/rust-lang/rust/commit/e3f913167c0f232478b945aa236aab8340be62a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3f913167c0f232478b945aa236aab8340be62a9/comments", "author": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michaelwoerister", "id": 1825894, "node_id": "MDQ6VXNlcjE4MjU4OTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1825894?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michaelwoerister", "html_url": "https://github.com/michaelwoerister", "followers_url": "https://api.github.com/users/michaelwoerister/followers", "following_url": "https://api.github.com/users/michaelwoerister/following{/other_user}", "gists_url": "https://api.github.com/users/michaelwoerister/gists{/gist_id}", "starred_url": "https://api.github.com/users/michaelwoerister/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michaelwoerister/subscriptions", "organizations_url": "https://api.github.com/users/michaelwoerister/orgs", "repos_url": "https://api.github.com/users/michaelwoerister/repos", "events_url": "https://api.github.com/users/michaelwoerister/events{/privacy}", "received_events_url": "https://api.github.com/users/michaelwoerister/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3cc3ae22bddc4fb24c790b58700a699c764ebd0e", "url": "https://api.github.com/repos/rust-lang/rust/commits/3cc3ae22bddc4fb24c790b58700a699c764ebd0e", "html_url": "https://github.com/rust-lang/rust/commit/3cc3ae22bddc4fb24c790b58700a699c764ebd0e"}], "stats": {"total": 565, "additions": 328, "deletions": 237}, "files": [{"sha": "1dcc9272d4e0264b1c0914df5b9a0c4ffc5d7a1b", "filename": "src/librustc/dep_graph/dep_node.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdep_graph%2Fdep_node.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -633,6 +633,18 @@ impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId,) {\n     }\n }\n \n+impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefIndex,) {\n+    const CAN_RECONSTRUCT_QUERY_KEY: bool = true;\n+\n+    fn to_fingerprint(&self, tcx: TyCtxt) -> Fingerprint {\n+        tcx.hir.definitions().def_path_hash(self.0).0\n+    }\n+\n+    fn to_debug_str(&self, tcx: TyCtxt<'a, 'gcx, 'tcx>) -> String {\n+        tcx.item_path_str(DefId::local(self.0))\n+    }\n+}\n+\n impl<'a, 'gcx: 'tcx + 'a, 'tcx: 'a> DepNodeParams<'a, 'gcx, 'tcx> for (DefId, DefId) {\n     const CAN_RECONSTRUCT_QUERY_KEY: bool = false;\n "}, {"sha": "daf1ff8ad2b959576b58eb5409d88f53164e9458", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 15, "deletions": 29, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -27,7 +27,8 @@ use syntax::symbol::Symbol;\n use syntax_pos::Span;\n \n use rustc_data_structures::stable_hasher::{HashStable, StableHashingContextProvider,\n-                                           StableHasher, StableHasherResult};\n+                                           StableHasher, StableHasherResult,\n+                                           ToStableHashKey};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n /// This is the context state available during incr. comp. hashing. It contains\n@@ -48,9 +49,7 @@ pub struct StableHashingContext<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n #[derive(PartialEq, Eq, Clone, Copy)]\n pub enum NodeIdHashingMode {\n     Ignore,\n-    CheckedIgnore,\n     HashDefPath,\n-    HashTraitsInScope,\n }\n \n impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n@@ -150,7 +149,7 @@ impl<'a, 'gcx, 'tcx> StableHashingContext<'a, 'gcx, 'tcx> {\n             self.overflow_checks_enabled = true;\n         }\n         let prev_hash_node_ids = self.node_id_hashing_mode;\n-        self.node_id_hashing_mode = NodeIdHashingMode::CheckedIgnore;\n+        self.node_id_hashing_mode = NodeIdHashingMode::Ignore;\n \n         f(self);\n \n@@ -207,41 +206,28 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::N\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let hir_id = hcx.tcx.hir.node_to_hir_id(*self);\n         match hcx.node_id_hashing_mode {\n             NodeIdHashingMode::Ignore => {\n                 // Don't do anything.\n             }\n-            NodeIdHashingMode::CheckedIgnore => {\n-                // Most NodeIds in the HIR can be ignored, but if there is a\n-                // corresponding entry in the `trait_map` we need to hash that.\n-                // Make sure we don't ignore too much by checking that there is\n-                // no entry in a debug_assert!().\n-                debug_assert!(hcx.tcx.in_scope_traits(hir_id).is_none());\n-            }\n             NodeIdHashingMode::HashDefPath => {\n-                hir_id.hash_stable(hcx, hasher);\n-            }\n-            NodeIdHashingMode::HashTraitsInScope => {\n-                if let Some(traits) = hcx.tcx.in_scope_traits(hir_id) {\n-                    // The ordering of the candidates is not fixed. So we hash\n-                    // the def-ids and then sort them and hash the collection.\n-                    let mut candidates: AccumulateVec<[_; 8]> =\n-                        traits.iter()\n-                              .map(|&hir::TraitCandidate { def_id, import_id: _ }| {\n-                                  hcx.def_path_hash(def_id)\n-                              })\n-                              .collect();\n-                    if traits.len() > 1 {\n-                        candidates.sort();\n-                    }\n-                    candidates.hash_stable(hcx, hasher);\n-                }\n+                hcx.tcx.hir.node_to_hir_id(*self).hash_stable(hcx, hasher);\n             }\n         }\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for ast::NodeId {\n+    type KeyType = (DefPathHash, hir::ItemLocalId);\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          hcx: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          -> (DefPathHash, hir::ItemLocalId) {\n+        hcx.tcx.hir.node_to_hir_id(*self).to_stable_hash_key(hcx)\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for Span {\n \n     // Hash a span in a stable way. We can't directly hash the span's BytePos"}, {"sha": "057a83ebbe35251c2940f2d24a887d54e4cf50eb", "filename": "src/librustc/ich/impls_cstore.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fimpls_cstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_cstore.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -45,3 +45,9 @@ impl_stable_hash_for!(struct middle::cstore::ExternCrate {\n     direct,\n     path_len\n });\n+\n+impl_stable_hash_for!(struct middle::cstore::CrateSource {\n+    dylib,\n+    rlib,\n+    rmeta\n+});"}, {"sha": "9da147472ce4ead413f06c24924cdaf523a16dc3", "filename": "src/librustc/ich/impls_hir.rs", "status": "modified", "additions": 101, "deletions": 99, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fimpls_hir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_hir.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -12,13 +12,13 @@\n //! types in no particular order.\n \n use hir;\n+use hir::map::DefPathHash;\n use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n-use ich::{self, StableHashingContext, NodeIdHashingMode};\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use ich::{StableHashingContext, NodeIdHashingMode};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n+                                           StableHasher, StableHasherResult};\n use std::mem;\n use syntax::ast;\n-use util::nodemap::DefIdSet;\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n     #[inline]\n@@ -29,14 +29,12 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefId\n     }\n }\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for DefIdSet\n-{\n-    fn hash_stable<W: StableHasherResult>(&self,\n-                                          hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n-                                          hasher: &mut StableHasher<W>) {\n-        ich::hash_stable_hashset(hcx, hasher, self, |hcx, def_id| {\n-            hcx.def_path_hash(*def_id)\n-        });\n+impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for DefId {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a, 'gcx, 'tcx>) -> DefPathHash {\n+        hcx.tcx().def_path_hash(*self)\n     }\n }\n \n@@ -50,11 +48,22 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::H\n             local_id,\n         } = *self;\n \n-        hcx.def_path_hash(DefId::local(owner)).hash_stable(hcx, hasher);\n+        hcx.tcx().hir.definitions().def_path_hash(owner).hash_stable(hcx, hasher);\n         local_id.hash_stable(hcx, hasher);\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for hir::HirId {\n+    type KeyType = (DefPathHash, hir::ItemLocalId);\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          hcx: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          -> (DefPathHash, hir::ItemLocalId) {\n+        let def_path_hash = hcx.tcx().hir.definitions().def_path_hash(self.owner);\n+        (def_path_hash, self.local_id)\n+    }\n+}\n \n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for CrateNum {\n     #[inline]\n@@ -68,8 +77,30 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for CrateN\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for CrateNum {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a, 'gcx, 'tcx>) -> DefPathHash {\n+        let def_id = DefId { krate: *self, index: CRATE_DEF_INDEX };\n+        def_id.to_stable_hash_key(hcx)\n+    }\n+}\n+\n impl_stable_hash_for!(tuple_struct hir::ItemLocalId { index });\n \n+impl<'a, 'gcx, 'lcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'lcx>>\n+for hir::ItemLocalId {\n+    type KeyType = hir::ItemLocalId;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          _: &StableHashingContext<'a, 'gcx, 'lcx>)\n+                          -> hir::ItemLocalId {\n+        *self\n+    }\n+}\n+\n // The following implementations of HashStable for ItemId, TraitItemId, and\n // ImplItemId deserve special attention. Normally we do not hash NodeIds within\n // the HIR, since they just signify a HIR nodes own path. But ItemId et al\n@@ -231,36 +262,13 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::T\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let node_id_hashing_mode = match self.node {\n-            hir::TySlice(..)       |\n-            hir::TyArray(..)       |\n-            hir::TyPtr(..)         |\n-            hir::TyRptr(..)        |\n-            hir::TyBareFn(..)      |\n-            hir::TyNever           |\n-            hir::TyTup(..)         |\n-            hir::TyTraitObject(..) |\n-            hir::TyImplTrait(..)   |\n-            hir::TyTypeof(..)      |\n-            hir::TyErr             |\n-            hir::TyInfer           => {\n-                NodeIdHashingMode::CheckedIgnore\n-            }\n-            hir::TyPath(..) => {\n-                NodeIdHashingMode::HashTraitsInScope\n-            }\n-        };\n-\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Ty {\n-                id,\n+                id: _,\n                 ref node,\n                 ref span,\n             } = *self;\n \n-            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-                id.hash_stable(hcx, hasher);\n-            });\n             node.hash_stable(hcx, hasher);\n             span.hash_stable(hcx, hasher);\n         })\n@@ -317,13 +325,11 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::T\n                                           hasher: &mut StableHasher<W>) {\n         let hir::TraitRef {\n             ref path,\n-            ref_id,\n+            // Don't hash the ref_id. It is tracked via the thing it is used to access\n+            ref_id: _,\n         } = *self;\n \n         path.hash_stable(hcx, hasher);\n-        hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n-            ref_id.hash_stable(hcx, hasher);\n-        });\n     }\n }\n \n@@ -357,7 +363,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n         let hir::Block {\n             ref stmts,\n             ref expr,\n-            id,\n+            id: _,\n             hir_id: _,\n             rules,\n             span,\n@@ -392,7 +398,6 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n         }\n \n         expr.hash_stable(hcx, hasher);\n-        id.hash_stable(hcx, hasher);\n         rules.hash_stable(hcx, hasher);\n         span.hash_stable(hcx, hasher);\n         targeted_by_break.hash_stable(hcx, hasher);\n@@ -403,34 +408,13 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::P\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let node_id_hashing_mode = match self.node {\n-            hir::PatKind::Wild        |\n-            hir::PatKind::Binding(..) |\n-            hir::PatKind::Tuple(..)   |\n-            hir::PatKind::Box(..)     |\n-            hir::PatKind::Ref(..)     |\n-            hir::PatKind::Lit(..)     |\n-            hir::PatKind::Range(..)   |\n-            hir::PatKind::Slice(..)   => {\n-                NodeIdHashingMode::CheckedIgnore\n-            }\n-            hir::PatKind::Path(..)        |\n-            hir::PatKind::Struct(..)      |\n-            hir::PatKind::TupleStruct(..) => {\n-                NodeIdHashingMode::HashTraitsInScope\n-            }\n-        };\n-\n         let hir::Pat {\n-            id,\n+            id: _,\n             hir_id: _,\n             ref node,\n             ref span\n         } = *self;\n \n-        hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-            id.hash_stable(hcx, hasher);\n-        });\n         node.hash_stable(hcx, hasher);\n         span.hash_stable(hcx, hasher);\n     }\n@@ -552,14 +536,14 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n                                           hasher: &mut StableHasher<W>) {\n         hcx.while_hashing_hir_bodies(true, |hcx| {\n             let hir::Expr {\n-                id,\n+                id: _,\n                 hir_id: _,\n                 ref span,\n                 ref node,\n                 ref attrs\n             } = *self;\n \n-            let (spans_always_on, node_id_hashing_mode) = match *node {\n+            let spans_always_on = match *node {\n                 hir::ExprBox(..)        |\n                 hir::ExprArray(..)      |\n                 hir::ExprCall(..)       |\n@@ -578,41 +562,33 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::E\n                 hir::ExprBreak(..)      |\n                 hir::ExprAgain(..)      |\n                 hir::ExprRet(..)        |\n-                hir::ExprYield(..)    |\n+                hir::ExprYield(..)      |\n                 hir::ExprInlineAsm(..)  |\n                 hir::ExprRepeat(..)     |\n-                hir::ExprTup(..)        => {\n+                hir::ExprTup(..)        |\n+                hir::ExprMethodCall(..) |\n+                hir::ExprPath(..)       |\n+                hir::ExprStruct(..)     |\n+                hir::ExprField(..)      => {\n                     // For these we only hash the span when debuginfo is on.\n-                    (false, NodeIdHashingMode::CheckedIgnore)\n+                    false\n                 }\n                 // For the following, spans might be significant because of\n                 // panic messages indicating the source location.\n                 hir::ExprBinary(op, ..) => {\n-                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::CheckedIgnore)\n+                    hcx.binop_can_panic_at_runtime(op.node)\n                 }\n                 hir::ExprUnary(op, _) => {\n-                    (hcx.unop_can_panic_at_runtime(op), NodeIdHashingMode::CheckedIgnore)\n+                    hcx.unop_can_panic_at_runtime(op)\n                 }\n                 hir::ExprAssignOp(op, ..) => {\n-                    (hcx.binop_can_panic_at_runtime(op.node), NodeIdHashingMode::CheckedIgnore)\n+                    hcx.binop_can_panic_at_runtime(op.node)\n                 }\n                 hir::ExprIndex(..) => {\n-                    (true, NodeIdHashingMode::CheckedIgnore)\n-                }\n-                // For these we don't care about the span, but want to hash the\n-                // trait in scope\n-                hir::ExprMethodCall(..) |\n-                hir::ExprPath(..)       |\n-                hir::ExprStruct(..)     |\n-                hir::ExprField(..)      => {\n-                    (false, NodeIdHashingMode::HashTraitsInScope)\n+                    true\n                 }\n             };\n \n-            hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-                id.hash_stable(hcx, hasher);\n-            });\n-\n             if spans_always_on {\n                 hcx.while_hashing_spans(true, |hcx| {\n                     span.hash_stable(hcx, hasher);\n@@ -815,7 +791,7 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::V\n                 // No fields to hash.\n             }\n             hir::Visibility::Restricted { ref path, id } => {\n-                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashTraitsInScope, |hcx| {\n+                hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                     id.hash_stable(hcx, hasher);\n                 });\n                 path.hash_stable(hcx, hasher);\n@@ -904,16 +880,13 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        let (node_id_hashing_mode, hash_spans) = match self.node {\n+        let hash_spans = match self.node {\n             hir::ItemStatic(..)      |\n             hir::ItemConst(..)       |\n             hir::ItemFn(..)          => {\n-                (NodeIdHashingMode::CheckedIgnore, hcx.hash_spans())\n+                hcx.hash_spans()\n             }\n-            hir::ItemUse(..) => {\n-                (NodeIdHashingMode::HashTraitsInScope, false)\n-            }\n-\n+            hir::ItemUse(..)         |\n             hir::ItemExternCrate(..) |\n             hir::ItemForeignMod(..)  |\n             hir::ItemGlobalAsm(..)   |\n@@ -925,14 +898,14 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n             hir::ItemEnum(..)        |\n             hir::ItemStruct(..)      |\n             hir::ItemUnion(..)       => {\n-                (NodeIdHashingMode::CheckedIgnore, false)\n+                false\n             }\n         };\n \n         let hir::Item {\n             name,\n             ref attrs,\n-            id,\n+            id: _,\n             hir_id: _,\n             ref node,\n             ref vis,\n@@ -941,9 +914,6 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::I\n \n         hcx.hash_hir_item_like(attrs, |hcx| {\n             hcx.while_hashing_spans(hash_spans, |hcx| {\n-                hcx.with_node_id_hashing_mode(node_id_hashing_mode, |hcx| {\n-                    id.hash_stable(hcx, hasher);\n-                });\n                 name.hash_stable(hcx, hasher);\n                 attrs.hash_stable(hcx, hasher);\n                 node.hash_stable(hcx, hasher);\n@@ -1049,6 +1019,18 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for hir::B\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for hir::BodyId {\n+    type KeyType = (DefPathHash, hir::ItemLocalId);\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          hcx: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          -> (DefPathHash, hir::ItemLocalId) {\n+        let hir::BodyId { node_id } = *self;\n+        node_id.to_stable_hash_key(hcx)\n+    }\n+}\n+\n impl_stable_hash_for!(struct hir::InlineAsmOutput {\n     constraint,\n     is_rw,\n@@ -1151,7 +1133,17 @@ for hir::def_id::DefIndex {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n                                           hasher: &mut StableHasher<W>) {\n-        DefId::local(*self).hash_stable(hcx, hasher);\n+        hcx.tcx().hir.definitions().def_path_hash(*self).hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>>\n+for hir::def_id::DefIndex {\n+    type KeyType = DefPathHash;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self, hcx: &StableHashingContext<'a, 'gcx, 'tcx>) -> DefPathHash {\n+         hcx.tcx().hir.definitions().def_path_hash(*self)\n     }\n }\n \n@@ -1170,6 +1162,11 @@ for ::middle::lang_items::LangItem {\n     }\n }\n \n+impl_stable_hash_for!(struct ::middle::lang_items::LanguageItems {\n+    items,\n+    missing\n+});\n+\n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n for hir::TraitCandidate {\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -1186,3 +1183,8 @@ for hir::TraitCandidate {\n         });\n     }\n }\n+\n+impl_stable_hash_for!(struct hir::Freevar {\n+    def,\n+    span\n+});"}, {"sha": "951315fb4a84931cd04205f8380c0105f364c76f", "filename": "src/librustc/ich/impls_misc.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fimpls_misc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_misc.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! This module contains `HashStable` implementations for various data types\n+//! that don't fit into any of the other impls_xxx modules.\n+\n+impl_stable_hash_for!(enum ::session::search_paths::PathKind {\n+    Native,\n+    Crate,\n+    Dependency,\n+    Framework,\n+    ExternFlag,\n+    All\n+});\n+\n+impl_stable_hash_for!(enum ::rustc_back::PanicStrategy {\n+    Abort,\n+    Unwind\n+});"}, {"sha": "a75527c14bd691a11f6ab46357622f6fb1efa40d", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 26, "deletions": 4, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -18,17 +18,17 @@ use std::mem;\n \n use syntax::ast;\n use syntax::parse::token;\n+use syntax::symbol::InternedString;\n use syntax::tokenstream;\n use syntax_pos::{Span, FileMap};\n \n use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher,\n-                                           StableHasherResult};\n+use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n+                                           StableHasher, StableHasherResult};\n use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n-impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>>\n-for ::syntax::symbol::InternedString {\n+impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for InternedString {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           hcx: &mut StableHashingContext<'a, 'gcx, 'tcx>,\n@@ -38,6 +38,17 @@ for ::syntax::symbol::InternedString {\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for InternedString {\n+    type KeyType = InternedString;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          _: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          -> InternedString {\n+        self.clone()\n+    }\n+}\n+\n impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Name {\n     #[inline]\n     fn hash_stable<W: StableHasherResult>(&self,\n@@ -47,6 +58,17 @@ impl<'a, 'gcx, 'tcx> HashStable<StableHashingContext<'a, 'gcx, 'tcx>> for ast::N\n     }\n }\n \n+impl<'a, 'gcx, 'tcx> ToStableHashKey<StableHashingContext<'a, 'gcx, 'tcx>> for ast::Name {\n+    type KeyType = InternedString;\n+\n+    #[inline]\n+    fn to_stable_hash_key(&self,\n+                          _: &StableHashingContext<'a, 'gcx, 'tcx>)\n+                          -> InternedString {\n+        self.as_str()\n+    }\n+}\n+\n impl_stable_hash_for!(enum ::syntax::ast::AsmDialect {\n     Att,\n     Intel"}, {"sha": "5558534b71d2e0e68becd6b842f2dfc5ac6f5bc7", "filename": "src/librustc/ich/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fich%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fmod.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -24,6 +24,7 @@ mod impls_const_math;\n mod impls_cstore;\n mod impls_hir;\n mod impls_mir;\n+mod impls_misc;\n mod impls_ty;\n mod impls_syntax;\n "}, {"sha": "7c60c6d6430e1d588d5204adf0a7dcb8241ccfe8", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -132,7 +132,7 @@ pub struct NativeLibrary {\n     pub kind: NativeLibraryKind,\n     pub name: Symbol,\n     pub cfg: Option<ast::MetaItem>,\n-    pub foreign_items: Vec<DefIndex>,\n+    pub foreign_items: Vec<DefId>,\n }\n \n pub enum LoadedMacro {"}, {"sha": "0c0b9697338e92f0feb66d77c177f7d3ee6248b3", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -192,8 +192,7 @@ pub fn extract(attrs: &[ast::Attribute]) -> Option<Symbol> {\n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n     let mut collector = LanguageItemCollector::new(tcx);\n     for &cnum in tcx.crates().iter() {\n-        for &(index, item_index) in tcx.defined_lang_items(cnum).iter() {\n-            let def_id = DefId { krate: cnum, index: index };\n+        for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n             collector.collect_item(item_index, def_id);\n         }\n     }"}, {"sha": "89049958309a126a61a033afde7f6b71587e7d9e", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -65,6 +65,11 @@ pub struct DeprecationEntry {\n     origin: Option<HirId>,\n }\n \n+impl_stable_hash_for!(struct self::DeprecationEntry {\n+    attr,\n+    origin\n+});\n+\n impl DeprecationEntry {\n     fn local(attr: Deprecation, id: HirId) -> DeprecationEntry {\n         DeprecationEntry {\n@@ -102,6 +107,13 @@ pub struct Index<'tcx> {\n     active_features: FxHashSet<Symbol>,\n }\n \n+impl_stable_hash_for!(struct self::Index<'tcx> {\n+    stab_map,\n+    depr_map,\n+    staged_api,\n+    active_features\n+});\n+\n // A private tree-walker for producing an Index.\n struct Annotator<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,"}, {"sha": "7edc55e8a9fe44b03411646cfa0661f4bd22995d", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -1083,6 +1083,9 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             None\n         };\n \n+        // FIXME(mw): Each of the Vecs in the trait_map should be brought into\n+        // a deterministic order here. Otherwise we might end up with\n+        // unnecessarily unstable incr. comp. hashes.\n         let mut trait_map = FxHashMap();\n         for (k, v) in resolutions.trait_map {\n             let hir_id = hir.node_to_hir_id(k);\n@@ -1171,17 +1174,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     pub fn lang_items(self) -> Rc<middle::lang_items::LanguageItems> {\n-        // FIXME(#42293) Right now we insert a `with_ignore` node in the dep\n-        // graph here to ignore the fact that `get_lang_items` below depends on\n-        // the entire crate.  For now this'll prevent false positives of\n-        // recompiling too much when anything changes.\n-        //\n-        // Once red/green incremental compilation lands we should be able to\n-        // remove this because while the crate changes often the lint level map\n-        // will change rarely.\n-        self.dep_graph.with_ignore(|| {\n-            self.get_lang_items(LOCAL_CRATE)\n-        })\n+        self.get_lang_items(LOCAL_CRATE)\n     }\n \n     pub fn stability(self) -> Rc<stability::Index<'tcx>> {\n@@ -2198,7 +2191,15 @@ pub fn provide(providers: &mut ty::maps::Providers) {\n     };\n     providers.get_lang_items = |tcx, id| {\n         assert_eq!(id, LOCAL_CRATE);\n-        Rc::new(middle::lang_items::collect(tcx))\n+        // FIXME(#42293) Right now we insert a `with_ignore` node in the dep\n+        // graph here to ignore the fact that `get_lang_items` below depends on\n+        // the entire crate.  For now this'll prevent false positives of\n+        // recompiling too much when anything changes.\n+        //\n+        // Once red/green incremental compilation lands we should be able to\n+        // remove this because while the crate changes often the lint level map\n+        // will change rarely.\n+        tcx.dep_graph.with_ignore(|| Rc::new(middle::lang_items::collect(tcx)))\n     };\n     providers.freevars = |tcx, id| tcx.gcx.freevars.get(&id).cloned();\n     providers.maybe_unused_trait_import = |tcx, id| {"}, {"sha": "fc803d1c849b5ef79ab0f512fc5d484aaf820fb3", "filename": "src/librustc/ty/maps.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fty%2Fmaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc%2Fty%2Fmaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmaps.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -1400,7 +1400,7 @@ define_maps! { <'tcx>\n     [] fn extern_mod_stmt_cnum: ExternModStmtCnum(DefId) -> Option<CrateNum>,\n \n     [] fn get_lang_items: get_lang_items_node(CrateNum) -> Rc<LanguageItems>,\n-    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefIndex, usize)>>,\n+    [] fn defined_lang_items: DefinedLangItems(CrateNum) -> Rc<Vec<(DefId, usize)>>,\n     [] fn missing_lang_items: MissingLangItems(CrateNum) -> Rc<Vec<LangItem>>,\n     [] fn extern_const_body: ExternConstBody(DefId) -> &'tcx hir::Body,\n     [] fn visible_parent_map: visible_parent_map_node(CrateNum)"}, {"sha": "1b2d09bef934c9ecaeb86a754e9e832332481fbe", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 65, "deletions": 22, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::hash::{Hash, Hasher};\n+use std::hash::{Hash, Hasher, BuildHasher};\n use std::marker::PhantomData;\n use std::mem;\n use blake2b::Blake2bHasher;\n@@ -222,6 +222,14 @@ pub trait HashStable<CTX> {\n                                           hasher: &mut StableHasher<W>);\n }\n \n+/// Implement this for types that can be turned into stable keys like, for\n+/// example, for DefId that can be converted to a DefPathHash. This is used for\n+/// bringing maps into a predictable order before hashing them.\n+pub trait ToStableHashKey<HCX> {\n+    type KeyType: Ord + Clone + Sized + HashStable<HCX>;\n+    fn to_stable_hash_key(&self, hcx: &HCX) -> Self::KeyType;\n+}\n+\n // Implement HashStable by just calling `Hash::hash()`. This works fine for\n // self-contained values that don't depend on the hashing context `CTX`.\n macro_rules! impl_stable_hash_via_hash {\n@@ -423,53 +431,88 @@ impl<T, CTX> HashStable<CTX> for ::std::mem::Discriminant<T> {\n     }\n }\n \n-impl<K, V, CTX> HashStable<CTX> for ::std::collections::BTreeMap<K, V>\n-    where K: Ord + HashStable<CTX>,\n-          V: HashStable<CTX>,\n+impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<I, T>\n+    where T: HashStable<CTX>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n                                           hasher: &mut StableHasher<W>) {\n         self.len().hash_stable(ctx, hasher);\n-        for (k, v) in self {\n-            k.hash_stable(ctx, hasher);\n+        for v in &self.raw {\n             v.hash_stable(ctx, hasher);\n         }\n     }\n }\n \n-impl<T, CTX> HashStable<CTX> for ::std::collections::BTreeSet<T>\n-    where T: Ord + HashStable<CTX>,\n+\n+impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSetBuf<I>\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n                                           ctx: &mut CTX,\n                                           hasher: &mut StableHasher<W>) {\n-        self.len().hash_stable(ctx, hasher);\n-        for v in self {\n-            v.hash_stable(ctx, hasher);\n-        }\n+        self.words().hash_stable(ctx, hasher);\n     }\n }\n \n-impl<I: ::indexed_vec::Idx, T, CTX> HashStable<CTX> for ::indexed_vec::IndexVec<I, T>\n-    where T: HashStable<CTX>,\n+impl_stable_hash_via_hash!(::std::path::Path);\n+impl_stable_hash_via_hash!(::std::path::PathBuf);\n+\n+impl<K, V, R, HCX> HashStable<HCX> for ::std::collections::HashMap<K, V, R>\n+    where K: ToStableHashKey<HCX> + Eq + Hash,\n+          V: HashStable<HCX>,\n+          R: BuildHasher,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n+                                          hcx: &mut HCX,\n                                           hasher: &mut StableHasher<W>) {\n-        self.len().hash_stable(ctx, hasher);\n-        for v in &self.raw {\n-            v.hash_stable(ctx, hasher);\n-        }\n+        let mut entries: Vec<_> = self.iter()\n+                                      .map(|(k, v)| (k.to_stable_hash_key(hcx), v))\n+                                      .collect();\n+        entries.sort_unstable_by(|&(ref sk1, _), &(ref sk2, _)| sk1.cmp(sk2));\n+        entries.hash_stable(hcx, hasher);\n     }\n }\n \n+impl<K, R, HCX> HashStable<HCX> for ::std::collections::HashSet<K, R>\n+    where K: ToStableHashKey<HCX> + Eq + Hash,\n+          R: BuildHasher,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mut keys: Vec<_> = self.iter()\n+                                   .map(|k| k.to_stable_hash_key(hcx))\n+                                   .collect();\n+        keys.sort_unstable();\n+        keys.hash_stable(hcx, hasher);\n+    }\n+}\n \n-impl<I: ::indexed_vec::Idx, CTX> HashStable<CTX> for ::indexed_set::IdxSetBuf<I>\n+impl<K, V, HCX> HashStable<HCX> for ::std::collections::BTreeMap<K, V>\n+    where K: ToStableHashKey<HCX>,\n+          V: HashStable<HCX>,\n {\n     fn hash_stable<W: StableHasherResult>(&self,\n-                                          ctx: &mut CTX,\n+                                          hcx: &mut HCX,\n                                           hasher: &mut StableHasher<W>) {\n-        self.words().hash_stable(ctx, hasher);\n+        let mut entries: Vec<_> = self.iter()\n+                                      .map(|(k, v)| (k.to_stable_hash_key(hcx), v))\n+                                      .collect();\n+        entries.sort_unstable_by(|&(ref sk1, _), &(ref sk2, _)| sk1.cmp(sk2));\n+        entries.hash_stable(hcx, hasher);\n+    }\n+}\n+\n+impl<K, HCX> HashStable<HCX> for ::std::collections::BTreeSet<K>\n+    where K: ToStableHashKey<HCX>,\n+{\n+    fn hash_stable<W: StableHasherResult>(&self,\n+                                          hcx: &mut HCX,\n+                                          hasher: &mut StableHasher<W>) {\n+        let mut keys: Vec<_> = self.iter()\n+                                   .map(|k| k.to_stable_hash_key(hcx))\n+                                   .collect();\n+        keys.sort_unstable();\n+        keys.hash_stable(hcx, hasher);\n     }\n }"}, {"sha": "d8e201d3acdcf85c0833f0ee9164dd39a2c953b9", "filename": "src/librustc_incremental/calculate_svh/mod.rs", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fcalculate_svh%2Fmod.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -31,7 +31,7 @@ use std::cell::RefCell;\n use std::hash::Hash;\n use rustc::dep_graph::{DepNode, DepKind};\n use rustc::hir;\n-use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId, DefIndex};\n use rustc::hir::map::DefPathHash;\n use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::ich::{Fingerprint, StableHashingContext};\n@@ -96,7 +96,7 @@ struct ComputeItemHashesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n     fn compute_and_store_ich_for_item_like<T>(&mut self,\n-                                              dep_node: DepNode,\n+                                              def_index: DefIndex,\n                                               hash_bodies: bool,\n                                               item_like: T)\n         where T: HashStable<StableHashingContext<'a, 'tcx, 'tcx>>\n@@ -108,13 +108,20 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n             return\n         }\n \n+        let def_path_hash = self.hcx.tcx().hir.definitions().def_path_hash(def_index);\n+\n         let mut hasher = IchHasher::new();\n         self.hcx.while_hashing_hir_bodies(hash_bodies, |hcx| {\n             item_like.hash_stable(hcx, &mut hasher);\n         });\n \n         let bytes_hashed = hasher.bytes_hashed();\n         let item_hash = hasher.finish();\n+        let dep_node = if hash_bodies {\n+            def_path_hash.to_dep_node(DepKind::HirBody)\n+        } else {\n+            def_path_hash.to_dep_node(DepKind::Hir)\n+        };\n         debug!(\"calculate_def_hash: dep_node={:?} hash={:?}\", dep_node, item_hash);\n         self.hashes.insert(dep_node, item_hash);\n \n@@ -123,6 +130,14 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n             tcx.sess.perf_stats.incr_comp_bytes_hashed.get() +\n             bytes_hashed;\n         tcx.sess.perf_stats.incr_comp_bytes_hashed.set(bytes_hashed);\n+\n+        if hash_bodies {\n+            let in_scope_traits_map = tcx.in_scope_traits_map(def_index);\n+            let mut hasher = IchHasher::new();\n+            in_scope_traits_map.hash_stable(&mut self.hcx, &mut hasher);\n+            let dep_node = def_path_hash.to_dep_node(DepKind::InScopeTraits);\n+            self.hashes.insert(dep_node, hasher.finish());\n+        }\n     }\n \n     fn compute_crate_hash(&mut self) {\n@@ -145,6 +160,7 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n                                 // This `match` determines what kinds of nodes\n                                 // go into the SVH:\n                                 match item_dep_node.kind {\n+                                    DepKind::InScopeTraits |\n                                     DepKind::Hir |\n                                     DepKind::HirBody => {\n                                         // We want to incoporate these into the\n@@ -195,11 +211,10 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n             body_ids: _,\n         } = *krate;\n \n-        let def_path_hash = self.hcx.tcx().hir.definitions().def_path_hash(CRATE_DEF_INDEX);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n                                                  false,\n                                                  (module, (span, attrs)));\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+        self.compute_and_store_ich_for_item_like(CRATE_DEF_INDEX,\n                                                  true,\n                                                  (module, (span, attrs)));\n     }\n@@ -251,34 +266,31 @@ impl<'a, 'tcx: 'a> ComputeItemHashesVisitor<'a, 'tcx> {\n \n impl<'a, 'tcx: 'a> ItemLikeVisitor<'tcx> for ComputeItemHashesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &'tcx hir::Item) {\n-        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+        let def_index = self.hcx.tcx().hir.local_def_id(item.id).index;\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  false,\n                                                  item);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  true,\n                                                  item);\n     }\n \n     fn visit_trait_item(&mut self, item: &'tcx hir::TraitItem) {\n-        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+        let def_index = self.hcx.tcx().hir.local_def_id(item.id).index;\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  false,\n                                                  item);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  true,\n                                                  item);\n     }\n \n     fn visit_impl_item(&mut self, item: &'tcx hir::ImplItem) {\n-        let def_id = self.hcx.tcx().hir.local_def_id(item.id);\n-        let def_path_hash = self.hcx.tcx().def_path_hash(def_id);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+        let def_index = self.hcx.tcx().hir.local_def_id(item.id).index;\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  false,\n                                                  item);\n-        self.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+        self.compute_and_store_ich_for_item_like(def_index,\n                                                  true,\n                                                  item);\n     }\n@@ -301,12 +313,11 @@ pub fn compute_incremental_hashes_map<'a, 'tcx: 'a>(tcx: TyCtxt<'a, 'tcx, 'tcx>)\n         krate.visit_all_item_likes(&mut visitor);\n \n         for macro_def in krate.exported_macros.iter() {\n-            let def_id = tcx.hir.local_def_id(macro_def.id);\n-            let def_path_hash = tcx.def_path_hash(def_id);\n-            visitor.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::Hir),\n+            let def_index = tcx.hir.local_def_id(macro_def.id).index;\n+            visitor.compute_and_store_ich_for_item_like(def_index,\n                                                         false,\n                                                         macro_def);\n-            visitor.compute_and_store_ich_for_item_like(def_path_hash.to_dep_node(DepKind::HirBody),\n+            visitor.compute_and_store_ich_for_item_like(def_index,\n                                                         true,\n                                                         macro_def);\n         }"}, {"sha": "8355f319139386b013204024f02ef5e60617c384", "filename": "src/librustc_incremental/persist/hash.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fhash.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -49,6 +49,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n         match dep_node.kind {\n             DepKind::Krate |\n             DepKind::Hir |\n+            DepKind::InScopeTraits |\n             DepKind::HirBody =>\n                 true,\n             DepKind::MetaData => {\n@@ -66,6 +67,7 @@ impl<'a, 'tcx> HashContext<'a, 'tcx> {\n             }\n \n             // HIR nodes (which always come from our crate) are an input:\n+            DepKind::InScopeTraits |\n             DepKind::Hir |\n             DepKind::HirBody => {\n                 Some(self.incremental_hashes_map[dep_node])"}, {"sha": "9865ea8c2856acd2f36beefb51fe7656136bda02", "filename": "src/librustc_incremental/persist/load.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_incremental%2Fpersist%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Fpersist%2Fload.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -104,6 +104,7 @@ fn does_still_exist(tcx: TyCtxt, dep_node: &DepNode) -> bool {\n     match dep_node.kind {\n         DepKind::Hir |\n         DepKind::HirBody |\n+        DepKind::InScopeTraits |\n         DepKind::MetaData => {\n             dep_node.extract_def_id(tcx).is_some()\n         }"}, {"sha": "39bdf88925e4444f2c2630dc65fc34381093fcd8", "filename": "src/librustc_metadata/creader.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_metadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_metadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcreader.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -301,7 +301,10 @@ impl<'a> CrateLoader<'a> {\n             .decode(&cmeta)\n             .filter(|lib| relevant_lib(self.sess, lib) &&\n                           lib.kind == cstore::NativeLibraryKind::NativeUnknown)\n-            .flat_map(|lib| lib.foreign_items.into_iter())\n+            .flat_map(|lib| {\n+                assert!(lib.foreign_items.iter().all(|def_id| def_id.krate == cnum));\n+                lib.foreign_items.into_iter().map(|def_id| def_id.index)\n+            })\n             .collect();\n \n         cmeta.dllimport_foreign_items = dllimports;"}, {"sha": "e4de27ee15e524e9f5dd837837f3c7d079f76852", "filename": "src/librustc_metadata/cstore_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_metadata%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_metadata%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcstore_impl.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -264,7 +264,7 @@ pub fn provide_local<'tcx>(providers: &mut Providers<'tcx>) {\n             tcx.native_libraries(id.krate)\n                 .iter()\n                 .filter(|lib| native_libs::relevant_lib(&tcx.sess, lib))\n-                .find(|l| l.foreign_items.contains(&id.index))\n+                .find(|l| l.foreign_items.contains(&id))\n                 .map(|l| l.kind)\n         },\n         native_libraries: |tcx, cnum| {"}, {"sha": "4696759817fcb99ba3f567b40d42539bc8fa7af5", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -659,10 +659,11 @@ impl<'a, 'tcx> CrateMetadata {\n     }\n \n     /// Iterates over the language items in the given crate.\n-    pub fn get_lang_items(&self) -> Vec<(DefIndex, usize)> {\n+    pub fn get_lang_items(&self) -> Vec<(DefId, usize)> {\n         self.root\n             .lang_items\n             .decode(self)\n+            .map(|(def_index, index)| (self.local_def_id(def_index), index))\n             .collect()\n     }\n "}, {"sha": "cc332acb5b08e8315aff614941e8523fc7ee447b", "filename": "src/librustc_metadata/native_libs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_metadata%2Fnative_libs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_metadata%2Fnative_libs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fnative_libs.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for Collector<'a, 'tcx> {\n                 list[0].meta_item().unwrap().clone()\n             });\n             let foreign_items = fm.items.iter()\n-                .map(|it| self.tcx.hir.local_def_id(it.id).index)\n+                .map(|it| self.tcx.hir.local_def_id(it.id))\n                 .collect();\n             let lib = NativeLibrary {\n                 name: n,"}, {"sha": "dc18cdd8f0dd6006e2270974f8cae06240319d0e", "filename": "src/librustc_mir/transform/erase_regions.rs", "status": "modified", "additions": 1, "deletions": 41, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Ferase_regions.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -15,8 +15,7 @@\n //! \"types-as-contracts\"-validation, namely, AcquireValid, ReleaseValid, and EndRegion.\n \n use rustc::ty::subst::Substs;\n-use rustc::ty::{self, Ty, TyCtxt, ClosureSubsts};\n-use rustc::middle::const_val::ConstVal;\n+use rustc::ty::{self, Ty, TyCtxt};\n use rustc::mir::*;\n use rustc::mir::visit::{MutVisitor, Lookup};\n use rustc::mir::transform::{MirPass, MirSource};\n@@ -80,45 +79,6 @@ impl<'a, 'tcx> MutVisitor<'tcx> for EraseRegionsVisitor<'a, 'tcx> {\n         self.super_statement(block, statement, location);\n         self.in_validation_statement = false;\n     }\n-\n-    fn visit_const_val(&mut self,\n-                       const_val: &mut ConstVal<'tcx>,\n-                       _: Location) {\n-        erase_const_val(self.tcx, const_val);\n-        self.super_const_val(const_val);\n-\n-        fn erase_const_val<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                     const_val: &mut ConstVal<'tcx>) {\n-            match *const_val {\n-                ConstVal::Float(_)    |\n-                ConstVal::Integral(_) |\n-                ConstVal::Str(_)      |\n-                ConstVal::ByteStr(_)  |\n-                ConstVal::Bool(_)     |\n-                ConstVal::Char(_)     |\n-                ConstVal::Variant(_)  => {\n-                    // nothing to do\n-                }\n-                ConstVal::Function(_, ref mut substs) => {\n-                    *substs = tcx.erase_regions(&{*substs});\n-                }\n-                ConstVal::Struct(ref mut field_map) => {\n-                    for (_, field_val) in field_map {\n-                        erase_const_val(tcx, field_val);\n-                    }\n-                }\n-                ConstVal::Tuple(ref mut fields) |\n-                ConstVal::Array(ref mut fields) => {\n-                    for field_val in fields {\n-                        erase_const_val(tcx, field_val);\n-                    }\n-                }\n-                ConstVal::Repeat(ref mut expr, _) => {\n-                    erase_const_val(tcx, &mut **expr);\n-                }\n-            }\n-        }\n-    }\n }\n \n pub struct EraseRegions;"}, {"sha": "7f4e2b0f17652b2dd8110f4d20b4c314d761c097", "filename": "src/test/incremental/ich_method_call_trait_scope.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e3f913167c0f232478b945aa236aab8340be62a9/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3f913167c0f232478b945aa236aab8340be62a9/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fich_method_call_trait_scope.rs?ref=e3f913167c0f232478b945aa236aab8340be62a9", "patch": "@@ -12,6 +12,7 @@\n // scope.\n \n // revisions: rpass1 rpass2\n+// compile-flags: -Z query-dep-graph\n \n #![feature(rustc_attrs)]\n \n@@ -47,13 +48,15 @@ mod mod3 {\n     use Trait2;\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n-    #[rustc_dirty(label=\"HirBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n+    #[rustc_dirty(label=\"TypeckTables\", cfg=\"rpass2\")]\n     fn bar() {\n         ().method();\n     }\n \n     #[rustc_clean(label=\"Hir\", cfg=\"rpass2\")]\n     #[rustc_clean(label=\"HirBody\", cfg=\"rpass2\")]\n+    #[rustc_clean(label=\"TypeckTables\", cfg=\"rpass2\")]\n     fn baz() {\n         22; // no method call, traits in scope don't matter\n     }"}]}