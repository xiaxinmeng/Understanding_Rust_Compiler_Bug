{"sha": "1c4d4539690fe841aefea2f54c243be5f0579970", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFjNGQ0NTM5NjkwZmU4NDFhZWZlYTJmNTRjMjQzYmU1ZjA1Nzk5NzA=", "commit": {"author": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2019-11-30T03:30:49Z"}, "committer": {"name": "David Tolnay", "email": "dtolnay@gmail.com", "date": "2019-11-30T04:25:07Z"}, "message": "Format liballoc with rustfmt", "tree": {"sha": "79e0bce428a31e998d3d83f71eadb2eab4813e2c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/79e0bce428a31e998d3d83f71eadb2eab4813e2c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1c4d4539690fe841aefea2f54c243be5f0579970", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEERijF2Cz/ZdaBZKeK+boUO5X/bYIFAl3h7yMACgkQ+boUO5X/\nbYLnlRAAh82m8N5wz+8x7TWE27bB3ItbBkDnpYZiSKTsoCxbAJL0ovQesGpqWSb2\n71FFxrp21U1/vNbaR+pKGlDvru3V1dVO+QaAOGO85aYbs3JN+KpnQBmKcn4TFBQ7\n8CciZRCHtmfBljzEJYcnJm+kCsnK8sAnsJlgRkm07wMK0pM8fKv6gchbKOxv7bOF\nFhs0XYkanBtXYb7N1spmFKdV92dulQpZpb4gQP8ew/ehUk27BtznQf/wmqKZ6bvS\naZpzsshpTqA1YiPqSW42Dm4EdhMPPXNkUsMxi12o9yF2DFBUj43k7Tk8IQaXmDxZ\nqttQ2Ww/dwZlmuXYhkoKKtTkzVxC0FYnb4EdYFrESocQwJE58KzJ/m/lPtY7LGIe\nMOLgNDOSAIodmKWCeuUfkFNbS5sMLcypowEe8Fcain/WSytbnINRIn2pJQOpJPC3\naYQrWdNCbYYzH+k8T6mPsQytgSP4/M+0XcgHMOBNtv2oQBWd4ZDOKlQPYQJKE7tz\nwJGKatyvBzUE1Q4xKbaMuC15mwksaXR/KbmPj85/uaXppUW94tlho/quChr5o7BZ\nZK3jz7zW9q2GVMZVT4GpiHsTRivSuPXFOrZjNOVjDTNQqX+ZfwTPgYiw69VN8tcN\njy2xdIzk9AaLDTnFFJbgrktpOiEvheEMdF/a7hSPxXJV5gOrePw=\n=H10X\n-----END PGP SIGNATURE-----", "payload": "tree 79e0bce428a31e998d3d83f71eadb2eab4813e2c\nparent 9081929d45f12d3f56d43b1d6db7519981580fc9\nauthor David Tolnay <dtolnay@gmail.com> 1575084649 -0800\ncommitter David Tolnay <dtolnay@gmail.com> 1575087907 -0800\n\nFormat liballoc with rustfmt\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1c4d4539690fe841aefea2f54c243be5f0579970", "html_url": "https://github.com/rust-lang/rust/commit/1c4d4539690fe841aefea2f54c243be5f0579970", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1c4d4539690fe841aefea2f54c243be5f0579970/comments", "author": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dtolnay", "id": 1940490, "node_id": "MDQ6VXNlcjE5NDA0OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/1940490?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dtolnay", "html_url": "https://github.com/dtolnay", "followers_url": "https://api.github.com/users/dtolnay/followers", "following_url": "https://api.github.com/users/dtolnay/following{/other_user}", "gists_url": "https://api.github.com/users/dtolnay/gists{/gist_id}", "starred_url": "https://api.github.com/users/dtolnay/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dtolnay/subscriptions", "organizations_url": "https://api.github.com/users/dtolnay/orgs", "repos_url": "https://api.github.com/users/dtolnay/repos", "events_url": "https://api.github.com/users/dtolnay/events{/privacy}", "received_events_url": "https://api.github.com/users/dtolnay/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9081929d45f12d3f56d43b1d6db7519981580fc9", "url": "https://api.github.com/repos/rust-lang/rust/commits/9081929d45f12d3f56d43b1d6db7519981580fc9", "html_url": "https://github.com/rust-lang/rust/commit/9081929d45f12d3f56d43b1d6db7519981580fc9"}], "stats": {"total": 774, "additions": 373, "deletions": 401}, "files": [{"sha": "956298d7836b854a2be3d10535c8d84630588ec2", "filename": "src/liballoc/alloc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,15 +1,15 @@\n use super::*;\n \n extern crate test;\n-use test::Bencher;\n use crate::boxed::Box;\n+use test::Bencher;\n \n #[test]\n fn allocate_zeroed() {\n     unsafe {\n         let layout = Layout::from_size_align(1024, 1).unwrap();\n-        let ptr = Global.alloc_zeroed(layout.clone())\n-            .unwrap_or_else(|_| handle_alloc_error(layout));\n+        let ptr =\n+            Global.alloc_zeroed(layout.clone()).unwrap_or_else(|_| handle_alloc_error(layout));\n \n         let mut i = ptr.cast::<u8>().as_ptr();\n         let end = i.add(layout.size());"}, {"sha": "eb5f51d9adc584b39efbc6760685828e6723ecb6", "filename": "src/liballoc/benches/btree/map.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fmap.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,12 +1,12 @@\n+use std::collections::BTreeMap;\n use std::iter::Iterator;\n use std::vec::Vec;\n-use std::collections::BTreeMap;\n \n-use rand::{Rng, seq::SliceRandom, thread_rng};\n-use test::{Bencher, black_box};\n+use rand::{seq::SliceRandom, thread_rng, Rng};\n+use test::{black_box, Bencher};\n \n macro_rules! map_insert_rand_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let n: usize = $n;\n@@ -27,11 +27,11 @@ macro_rules! map_insert_rand_bench {\n             });\n             black_box(map);\n         }\n-    )\n+    };\n }\n \n macro_rules! map_insert_seq_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -50,11 +50,11 @@ macro_rules! map_insert_seq_bench {\n             });\n             black_box(map);\n         }\n-    )\n+    };\n }\n \n macro_rules! map_find_rand_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -78,11 +78,11 @@ macro_rules! map_find_rand_bench {\n                 black_box(t);\n             })\n         }\n-    )\n+    };\n }\n \n macro_rules! map_find_seq_bench {\n-    ($name: ident, $n: expr, $map: ident) => (\n+    ($name: ident, $n: expr, $map: ident) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             let mut map = $map::new();\n@@ -101,20 +101,20 @@ macro_rules! map_find_seq_bench {\n                 black_box(x);\n             })\n         }\n-    )\n+    };\n }\n \n-map_insert_rand_bench!{insert_rand_100,    100,    BTreeMap}\n-map_insert_rand_bench!{insert_rand_10_000, 10_000, BTreeMap}\n+map_insert_rand_bench! {insert_rand_100,    100,    BTreeMap}\n+map_insert_rand_bench! {insert_rand_10_000, 10_000, BTreeMap}\n \n-map_insert_seq_bench!{insert_seq_100,    100,    BTreeMap}\n-map_insert_seq_bench!{insert_seq_10_000, 10_000, BTreeMap}\n+map_insert_seq_bench! {insert_seq_100,    100,    BTreeMap}\n+map_insert_seq_bench! {insert_seq_10_000, 10_000, BTreeMap}\n \n-map_find_rand_bench!{find_rand_100,    100,    BTreeMap}\n-map_find_rand_bench!{find_rand_10_000, 10_000, BTreeMap}\n+map_find_rand_bench! {find_rand_100,    100,    BTreeMap}\n+map_find_rand_bench! {find_rand_10_000, 10_000, BTreeMap}\n \n-map_find_seq_bench!{find_seq_100,    100,    BTreeMap}\n-map_find_seq_bench!{find_seq_10_000, 10_000, BTreeMap}\n+map_find_seq_bench! {find_seq_100,    100,    BTreeMap}\n+map_find_seq_bench! {find_seq_10_000, 10_000, BTreeMap}\n \n fn bench_iter(b: &mut Bencher, size: i32) {\n     let mut map = BTreeMap::<i32, i32>::new();"}, {"sha": "e20c043286e6fedd50cc43a87c616c3bda9e58b0", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 32, "deletions": 31, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,9 +1,9 @@\n use std::{mem, ptr};\n \n+use rand::distributions::{Alphanumeric, Standard};\n use rand::{thread_rng, Rng, SeedableRng};\n-use rand::distributions::{Standard, Alphanumeric};\n use rand_xorshift::XorShiftRng;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn iterator(b: &mut Bencher) {\n@@ -239,7 +239,7 @@ macro_rules! sort {\n             b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_strings {\n@@ -251,7 +251,7 @@ macro_rules! sort_strings {\n             b.iter(|| v.clone().$f());\n             b.bytes = $len * mem::size_of::<&str>() as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_expensive {\n@@ -273,7 +273,7 @@ macro_rules! sort_expensive {\n             });\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n macro_rules! sort_lexicographic {\n@@ -284,7 +284,7 @@ macro_rules! sort_lexicographic {\n             b.iter(|| v.clone().$f(|x| x.to_string()));\n             b.bytes = $len * mem::size_of_val(&$gen(1)[0]) as u64;\n         }\n-    }\n+    };\n }\n \n sort!(sort, sort_small_ascending, gen_ascending, 10);\n@@ -325,57 +325,58 @@ macro_rules! reverse {\n         fn $name(b: &mut Bencher) {\n             // odd length and offset by 1 to be as unaligned as possible\n             let n = 0xFFFFF;\n-            let mut v: Vec<_> =\n-                (0..1+(n / mem::size_of::<$ty>() as u64))\n-                .map($f)\n-                .collect();\n+            let mut v: Vec<_> = (0..1 + (n / mem::size_of::<$ty>() as u64)).map($f).collect();\n             b.iter(|| black_box(&mut v[1..]).reverse());\n             b.bytes = n;\n         }\n-    }\n+    };\n }\n \n reverse!(reverse_u8, u8, |x| x as u8);\n reverse!(reverse_u16, u16, |x| x as u16);\n-reverse!(reverse_u8x3, [u8;3], |x| [x as u8, (x>>8) as u8, (x>>16) as u8]);\n+reverse!(reverse_u8x3, [u8; 3], |x| [x as u8, (x >> 8) as u8, (x >> 16) as u8]);\n reverse!(reverse_u32, u32, |x| x as u32);\n reverse!(reverse_u64, u64, |x| x as u64);\n reverse!(reverse_u128, u128, |x| x as u128);\n-#[repr(simd)] struct F64x4(f64, f64, f64, f64);\n-reverse!(reverse_simd_f64x4, F64x4, |x| { let x = x as f64; F64x4(x,x,x,x) });\n+#[repr(simd)]\n+struct F64x4(f64, f64, f64, f64);\n+reverse!(reverse_simd_f64x4, F64x4, |x| {\n+    let x = x as f64;\n+    F64x4(x, x, x, x)\n+});\n \n macro_rules! rotate {\n     ($name:ident, $gen:expr, $len:expr, $mid:expr) => {\n         #[bench]\n         fn $name(b: &mut Bencher) {\n             let size = mem::size_of_val(&$gen(1)[0]);\n             let mut v = $gen($len * 8 / size);\n-            b.iter(|| black_box(&mut v).rotate_left(($mid*8+size-1)/size));\n+            b.iter(|| black_box(&mut v).rotate_left(($mid * 8 + size - 1) / size));\n             b.bytes = (v.len() * size) as u64;\n         }\n-    }\n+    };\n }\n \n rotate!(rotate_tiny_by1, gen_random, 16, 1);\n-rotate!(rotate_tiny_half, gen_random, 16, 16/2);\n-rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16/2+1);\n+rotate!(rotate_tiny_half, gen_random, 16, 16 / 2);\n+rotate!(rotate_tiny_half_plus_one, gen_random, 16, 16 / 2 + 1);\n \n rotate!(rotate_medium_by1, gen_random, 9158, 1);\n rotate!(rotate_medium_by727_u64, gen_random, 9158, 727);\n rotate!(rotate_medium_by727_bytes, gen_random_bytes, 9158, 727);\n rotate!(rotate_medium_by727_strings, gen_strings, 9158, 727);\n-rotate!(rotate_medium_half, gen_random, 9158, 9158/2);\n-rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158/2+1);\n+rotate!(rotate_medium_half, gen_random, 9158, 9158 / 2);\n+rotate!(rotate_medium_half_plus_one, gen_random, 9158, 9158 / 2 + 1);\n \n // Intended to use more RAM than the machine has cache\n-rotate!(rotate_huge_by1, gen_random, 5*1024*1024, 1);\n-rotate!(rotate_huge_by9199_u64, gen_random, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_strings, gen_strings, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by9199_big, gen_big_random, 5*1024*1024, 9199);\n-rotate!(rotate_huge_by1234577_u64, gen_random, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_strings, gen_strings, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_by1234577_big, gen_big_random, 5*1024*1024, 1234577);\n-rotate!(rotate_huge_half, gen_random, 5*1024*1024, 5*1024*1024/2);\n-rotate!(rotate_huge_half_plus_one, gen_random, 5*1024*1024, 5*1024*1024/2+1);\n+rotate!(rotate_huge_by1, gen_random, 5 * 1024 * 1024, 1);\n+rotate!(rotate_huge_by9199_u64, gen_random, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_bytes, gen_random_bytes, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_strings, gen_strings, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by9199_big, gen_big_random, 5 * 1024 * 1024, 9199);\n+rotate!(rotate_huge_by1234577_u64, gen_random, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_bytes, gen_random_bytes, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_strings, gen_strings, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_by1234577_big, gen_big_random, 5 * 1024 * 1024, 1234577);\n+rotate!(rotate_huge_half, gen_random, 5 * 1024 * 1024, 5 * 1024 * 1024 / 2);\n+rotate!(rotate_huge_half_plus_one, gen_random, 5 * 1024 * 1024, 5 * 1024 * 1024 / 2 + 1);"}, {"sha": "391475bc0c75deda0ca0e47e15f8e7ad9cb2f8f3", "filename": "src/liballoc/benches/str.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fstr.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,4 +1,4 @@\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn char_iterator(b: &mut Bencher) {\n@@ -12,7 +12,9 @@ fn char_iterator_for(b: &mut Bencher) {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n     b.iter(|| {\n-        for ch in s.chars() { black_box(ch); }\n+        for ch in s.chars() {\n+            black_box(ch);\n+        }\n     });\n }\n \n@@ -40,7 +42,9 @@ fn char_iterator_rev_for(b: &mut Bencher) {\n     let s = \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lamb\";\n \n     b.iter(|| {\n-        for ch in s.chars().rev() { black_box(ch); }\n+        for ch in s.chars().rev() {\n+            black_box(ch);\n+        }\n     });\n }\n \n@@ -79,7 +83,9 @@ fn split_ascii(b: &mut Bencher) {\n fn split_extern_fn(b: &mut Bencher) {\n     let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n     let len = s.split(' ').count();\n-    fn pred(c: char) -> bool { c == ' ' }\n+    fn pred(c: char) -> bool {\n+        c == ' '\n+    }\n \n     b.iter(|| assert_eq!(s.split(pred).count(), len));\n }\n@@ -185,16 +191,19 @@ fn bench_contains_equal(b: &mut Bencher) {\n     })\n }\n \n-\n macro_rules! make_test_inner {\n     ($s:ident, $code:expr, $name:ident, $str:expr, $iters:expr) => {\n         #[bench]\n         fn $name(bencher: &mut Bencher) {\n             let mut $s = $str;\n             black_box(&mut $s);\n-            bencher.iter(|| for _ in 0..$iters { black_box($code); });\n+            bencher.iter(|| {\n+                for _ in 0..$iters {\n+                    black_box($code);\n+                }\n+            });\n         }\n-    }\n+    };\n }\n \n macro_rules! make_test {\n@@ -261,15 +270,9 @@ make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n \n make_test!(split_a_str, s, s.split(\"a\").count());\n \n-make_test!(trim_ascii_char, s, {\n-    s.trim_matches(|c: char| c.is_ascii())\n-});\n-make_test!(trim_start_ascii_char, s, {\n-    s.trim_start_matches(|c: char| c.is_ascii())\n-});\n-make_test!(trim_end_ascii_char, s, {\n-    s.trim_end_matches(|c: char| c.is_ascii())\n-});\n+make_test!(trim_ascii_char, s, { s.trim_matches(|c: char| c.is_ascii()) });\n+make_test!(trim_start_ascii_char, s, { s.trim_start_matches(|c: char| c.is_ascii()) });\n+make_test!(trim_end_ascii_char, s, { s.trim_end_matches(|c: char| c.is_ascii()) });\n \n make_test!(find_underscore_char, s, s.find('_'));\n make_test!(rfind_underscore_char, s, s.rfind('_'));"}, {"sha": "bf2dffd1e931eecfbc52c1b48c5811e196085958", "filename": "src/liballoc/benches/vec_deque.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,5 +1,5 @@\n use std::collections::VecDeque;\n-use test::{Bencher, black_box};\n+use test::{black_box, Bencher};\n \n #[bench]\n fn bench_new(b: &mut Bencher) {"}, {"sha": "5825bdc355f2d173d4ab3aff19bd9e509aa8eb9e", "filename": "src/liballoc/benches/vec_deque_append.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fvec_deque_append.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -30,8 +30,5 @@ fn main() {\n \n     assert!(BENCH_N % 2 == 0);\n     let median = (durations[(l / 2) - 1] + durations[l / 2]) / 2;\n-    println!(\n-        \"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\",\n-        median.as_nanos()\n-    );\n+    println!(\"\\ncustom-bench vec_deque_append {:?} ns/iter\\n\", median.as_nanos());\n }"}, {"sha": "f73a24d09916bb1cbd448fb83868a541c4db84af", "filename": "src/liballoc/collections/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmod.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,6 +1,6 @@\n+pub mod map;\n mod node;\n mod search;\n-pub mod map;\n pub mod set;\n \n #[doc(hidden)]"}, {"sha": "3f3c49a2ef875246600f87cf976b1b4ea538d370", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,21 +1,23 @@\n use core::borrow::Borrow;\n use core::cmp::Ordering;\n \n-use super::node::{Handle, NodeRef, marker, ForceResult::*};\n+use super::node::{marker, ForceResult::*, Handle, NodeRef};\n \n use SearchResult::*;\n \n pub enum SearchResult<BorrowType, K, V, FoundType, GoDownType> {\n     Found(Handle<NodeRef<BorrowType, K, V, FoundType>, marker::KV>),\n-    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>)\n+    GoDown(Handle<NodeRef<BorrowType, K, V, GoDownType>, marker::Edge>),\n }\n \n pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n     mut node: NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n-    key: &Q\n+    key: &Q,\n ) -> SearchResult<BorrowType, K, V, marker::LeafOrInternal, marker::Leaf>\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     loop {\n         match search_node(node, key) {\n             Found(handle) => return Found(handle),\n@@ -25,38 +27,38 @@ pub fn search_tree<BorrowType, K, V, Q: ?Sized>(\n                     node = internal.descend();\n                     continue;\n                 }\n-            }\n+            },\n         }\n     }\n }\n \n pub fn search_node<BorrowType, K, V, Type, Q: ?Sized>(\n     node: NodeRef<BorrowType, K, V, Type>,\n-    key: &Q\n+    key: &Q,\n ) -> SearchResult<BorrowType, K, V, Type, Type>\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     match search_linear(&node, key) {\n-        (idx, true) => Found(\n-            Handle::new_kv(node, idx)\n-        ),\n-        (idx, false) => SearchResult::GoDown(\n-            Handle::new_edge(node, idx)\n-        )\n+        (idx, true) => Found(Handle::new_kv(node, idx)),\n+        (idx, false) => SearchResult::GoDown(Handle::new_edge(node, idx)),\n     }\n }\n \n pub fn search_linear<BorrowType, K, V, Type, Q: ?Sized>(\n     node: &NodeRef<BorrowType, K, V, Type>,\n-    key: &Q\n+    key: &Q,\n ) -> (usize, bool)\n-        where Q: Ord, K: Borrow<Q> {\n-\n+where\n+    Q: Ord,\n+    K: Borrow<Q>,\n+{\n     for (i, k) in node.keys().iter().enumerate() {\n         match key.cmp(k.borrow()) {\n-            Ordering::Greater => {},\n+            Ordering::Greater => {}\n             Ordering::Equal => return (i, true),\n-            Ordering::Less => return (i, false)\n+            Ordering::Less => return (i, false),\n         }\n     }\n     (node.keys().len(), false)"}, {"sha": "94b92df12940098e5d68b888970e57fa553bfe1b", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -177,8 +177,7 @@ fn test_insert_prev() {\n     }\n     check_links(&m);\n     assert_eq!(m.len(), 3 + len * 2);\n-    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-                [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n }\n \n #[test]\n@@ -187,13 +186,13 @@ fn test_insert_prev() {\n fn test_send() {\n     let n = list_from(&[1, 2, 3]);\n     thread::spawn(move || {\n-            check_links(&n);\n-            let a: &[_] = &[&1, &2, &3];\n-            assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n-        })\n-        .join()\n-        .ok()\n-        .unwrap();\n+        check_links(&n);\n+        let a: &[_] = &[&1, &2, &3];\n+        assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n+    })\n+    .join()\n+    .ok()\n+    .unwrap();\n }\n \n #[test]"}, {"sha": "8dc097cc088051a4fdb5d8472fa52c00840314ce", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -66,11 +66,8 @@ fn test_swap_front_back_remove() {\n         let final_len = usable_cap / 2;\n \n         for len in 0..final_len {\n-            let expected: VecDeque<_> = if back {\n-                (0..len).collect()\n-            } else {\n-                (0..len).rev().collect()\n-            };\n+            let expected: VecDeque<_> =\n+                if back { (0..len).collect() } else { (0..len).rev().collect() };\n             for tail_pos in 0..usable_cap {\n                 tester.tail = tail_pos;\n                 tester.head = tail_pos;\n@@ -111,7 +108,6 @@ fn test_insert() {\n     // this test isn't covering what it wants to\n     let cap = tester.capacity();\n \n-\n     // len is the length *after* insertion\n     for len in 1..cap {\n         // 0, 1, 2, .., len - 1\n@@ -198,9 +194,7 @@ fn test_drain() {\n                     assert!(tester.head < tester.cap());\n \n                     // We should see the correct values in the VecDeque\n-                    let expected: VecDeque<_> = (0..drain_start)\n-                        .chain(drain_end..len)\n-                        .collect();\n+                    let expected: VecDeque<_> = (0..drain_start).chain(drain_end..len).collect();\n                     assert_eq!(expected, tester);\n                 }\n             }"}, {"sha": "18ebae333098f9f42ea80c1ceb982825b5eae924", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -516,24 +516,24 @@\n \n #[unstable(feature = \"fmt_internals\", issue = \"0\")]\n pub use core::fmt::rt;\n+#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n+pub use core::fmt::Alignment;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{Formatter, Result, Write};\n+pub use core::fmt::Error;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use core::fmt::{write, ArgumentV1, Arguments};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Binary, Octal};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::fmt::{Debug, Display};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerHex, Pointer, UpperHex};\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{LowerExp, UpperExp};\n+pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::Error;\n+pub use core::fmt::{Formatter, Result, Write};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{write, ArgumentV1, Arguments};\n+pub use core::fmt::{LowerExp, UpperExp};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::fmt::{DebugList, DebugMap, DebugSet, DebugStruct, DebugTuple};\n-#[stable(feature = \"fmt_flags_align\", since = \"1.28.0\")]\n-pub use core::fmt::{Alignment};\n+pub use core::fmt::{LowerHex, Pointer, UpperHex};\n \n use crate::string;\n \n@@ -568,8 +568,6 @@ use crate::string;\n pub fn format(args: Arguments<'_>) -> string::String {\n     let capacity = args.estimated_capacity();\n     let mut output = string::String::with_capacity(capacity);\n-    output\n-        .write_fmt(args)\n-        .expect(\"a formatting trait implementation returned an error\");\n+    output.write_fmt(args).expect(\"a formatting trait implementation returned an error\");\n     output\n }"}, {"sha": "6a53b4ca1f6ca961f1c53703c3a56c5e4ca21f72", "filename": "src/liballoc/prelude/v1.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -4,7 +4,11 @@\n \n #![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n \n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n-#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::borrow::ToOwned;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::boxed::Box;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::string::{String, ToString};\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+pub use crate::vec::Vec;"}, {"sha": "b214cef30111516146e2ea14488dba664118f180", "filename": "src/liballoc/raw_vec/tests.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -16,15 +16,20 @@ fn allocator_param() {\n \n     // A dumb allocator that consumes a fixed amount of fuel\n     // before allocation attempts start failing.\n-    struct BoundedAlloc { fuel: usize }\n+    struct BoundedAlloc {\n+        fuel: usize,\n+    }\n     unsafe impl Alloc for BoundedAlloc {\n         unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n             let size = layout.size();\n             if size > self.fuel {\n                 return Err(AllocErr);\n             }\n             match Global.alloc(layout) {\n-                ok @ Ok(_) => { self.fuel -= size; ok }\n+                ok @ Ok(_) => {\n+                    self.fuel -= size;\n+                    ok\n+                }\n                 err @ Err(_) => err,\n             }\n         }"}, {"sha": "2f6d10c027be38bcd742a8a525d158ebada6b62b", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 92, "deletions": 81, "changes": 173, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -82,7 +82,6 @@\n //! [`.chunks`]: ../../std/primitive.slice.html#method.chunks\n //! [`.windows`]: ../../std/primitive.slice.html#method.windows\n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n-\n // Many of the usings in this module are only used in the test configuration.\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![cfg_attr(test, allow(unused_imports, dead_code))]\n@@ -91,32 +90,32 @@ use core::borrow::{Borrow, BorrowMut};\n use core::cmp::Ordering::{self, Less};\n use core::mem::{self, size_of};\n use core::ptr;\n-use core::{u8, u16, u32};\n+use core::{u16, u32, u8};\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n use crate::vec::Vec;\n \n+#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n+pub use core::slice::SliceIndex;\n+#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n+pub use core::slice::{from_mut, from_ref};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{Chunks, Windows};\n+pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{Iter, IterMut};\n+pub use core::slice::{Chunks, Windows};\n+#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n+pub use core::slice::{ChunksExact, ChunksExactMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{SplitMut, ChunksMut, Split};\n+pub use core::slice::{ChunksMut, Split, SplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{SplitN, RSplitN, SplitNMut, RSplitNMut};\n+pub use core::slice::{Iter, IterMut};\n+#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n+pub use core::slice::{RChunks, RChunksExact, RChunksExactMut, RChunksMut};\n #[stable(feature = \"slice_rsplit\", since = \"1.27.0\")]\n pub use core::slice::{RSplit, RSplitMut};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub use core::slice::{from_raw_parts, from_raw_parts_mut};\n-#[stable(feature = \"from_ref\", since = \"1.28.0\")]\n-pub use core::slice::{from_ref, from_mut};\n-#[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n-pub use core::slice::SliceIndex;\n-#[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n-pub use core::slice::{ChunksExact, ChunksExactMut};\n-#[stable(feature = \"rchunks\", since = \"1.31.0\")]\n-pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n+pub use core::slice::{RSplitN, RSplitNMut, SplitN, SplitNMut};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Basic slice extension methods\n@@ -138,9 +137,9 @@ pub use hack::to_vec;\n // `test_permutations` test\n mod hack {\n     use crate::boxed::Box;\n-    use crate::vec::Vec;\n     #[cfg(test)]\n     use crate::string::ToString;\n+    use crate::vec::Vec;\n \n     pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n         unsafe {\n@@ -153,7 +152,8 @@ mod hack {\n \n     #[inline]\n     pub fn to_vec<T>(s: &[T]) -> Vec<T>\n-        where T: Clone\n+    where\n+        T: Clone,\n     {\n         let mut vector = Vec::with_capacity(s.len());\n         vector.extend_from_slice(s);\n@@ -193,7 +193,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort(&mut self)\n-        where T: Ord\n+    where\n+        T: Ord,\n     {\n         merge_sort(self, |a, b| a.lt(b));\n     }\n@@ -246,7 +247,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn sort_by<F>(&mut self, mut compare: F)\n-        where F: FnMut(&T, &T) -> Ordering\n+    where\n+        F: FnMut(&T, &T) -> Ordering,\n     {\n         merge_sort(self, |a, b| compare(a, b) == Less);\n     }\n@@ -285,7 +287,9 @@ impl<T> [T] {\n     #[stable(feature = \"slice_sort_by_key\", since = \"1.7.0\")]\n     #[inline]\n     pub fn sort_by_key<K, F>(&mut self, mut f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n+    where\n+        F: FnMut(&T) -> K,\n+        K: Ord,\n     {\n         merge_sort(self, |a, b| f(a).lt(&f(b)));\n     }\n@@ -325,11 +329,13 @@ impl<T> [T] {\n     #[stable(feature = \"slice_sort_by_cached_key\", since = \"1.34.0\")]\n     #[inline]\n     pub fn sort_by_cached_key<K, F>(&mut self, f: F)\n-        where F: FnMut(&T) -> K, K: Ord\n+    where\n+        F: FnMut(&T) -> K,\n+        K: Ord,\n     {\n         // Helper macro for indexing our vector by the smallest possible type, to reduce allocation.\n         macro_rules! sort_by_key {\n-            ($t:ty, $slice:ident, $f:ident) => ({\n+            ($t:ty, $slice:ident, $f:ident) => {{\n                 let mut indices: Vec<_> =\n                     $slice.iter().map($f).enumerate().map(|(i, k)| (k, i as $t)).collect();\n                 // The elements of `indices` are unique, as they are indexed, so any sort will be\n@@ -344,19 +350,27 @@ impl<T> [T] {\n                     indices[i].1 = index;\n                     $slice.swap(i, index as usize);\n                 }\n-            })\n+            }};\n         }\n \n-        let sz_u8    = mem::size_of::<(K, u8)>();\n-        let sz_u16   = mem::size_of::<(K, u16)>();\n-        let sz_u32   = mem::size_of::<(K, u32)>();\n+        let sz_u8 = mem::size_of::<(K, u8)>();\n+        let sz_u16 = mem::size_of::<(K, u16)>();\n+        let sz_u32 = mem::size_of::<(K, u32)>();\n         let sz_usize = mem::size_of::<(K, usize)>();\n \n         let len = self.len();\n-        if len < 2 { return }\n-        if sz_u8  < sz_u16   && len <= ( u8::MAX as usize) { return sort_by_key!( u8, self, f) }\n-        if sz_u16 < sz_u32   && len <= (u16::MAX as usize) { return sort_by_key!(u16, self, f) }\n-        if sz_u32 < sz_usize && len <= (u32::MAX as usize) { return sort_by_key!(u32, self, f) }\n+        if len < 2 {\n+            return;\n+        }\n+        if sz_u8 < sz_u16 && len <= (u8::MAX as usize) {\n+            return sort_by_key!(u8, self, f);\n+        }\n+        if sz_u16 < sz_u32 && len <= (u16::MAX as usize) {\n+            return sort_by_key!(u16, self, f);\n+        }\n+        if sz_u32 < sz_usize && len <= (u32::MAX as usize) {\n+            return sort_by_key!(u32, self, f);\n+        }\n         sort_by_key!(usize, self, f)\n     }\n \n@@ -373,7 +387,8 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn to_vec(&self) -> Vec<T>\n-        where T: Clone\n+    where\n+        T: Clone,\n     {\n         // N.B., see the `hack` module in this file for more details.\n         hack::to_vec(self)\n@@ -421,7 +436,10 @@ impl<T> [T] {\n     /// b\"0123456789abcdef\".repeat(usize::max_value());\n     /// ```\n     #[stable(feature = \"repeat_generic_slice\", since = \"1.40.0\")]\n-    pub fn repeat(&self, n: usize) -> Vec<T> where T: Copy {\n+    pub fn repeat(&self, n: usize) -> Vec<T>\n+    where\n+        T: Copy,\n+    {\n         if n == 0 {\n             return Vec::new();\n         }\n@@ -486,7 +504,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n-        where Self: Concat<Item>\n+    where\n+        Self: Concat<Item>,\n     {\n         Concat::concat(self)\n     }\n@@ -503,7 +522,8 @@ impl<T> [T] {\n     /// ```\n     #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n     pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n-        where Self: Join<Separator>\n+    where\n+        Self: Join<Separator>,\n     {\n         Join::join(self, sep)\n     }\n@@ -521,11 +541,11 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n     pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n-        where Self: Join<Separator>\n+    where\n+        Self: Join<Separator>,\n     {\n         Join::join(self, sep)\n     }\n-\n }\n \n #[lang = \"slice_u8_alloc\"]\n@@ -668,8 +688,8 @@ impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() +\n-            sep.len() * (slice.len() - 1);\n+        let size =\n+            slice.iter().map(|v| v.borrow().len()).sum::<usize>() + sep.len() * (slice.len() - 1);\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n@@ -734,7 +754,8 @@ impl<T: Clone> ToOwned for [T] {\n ///\n /// This is the integral subroutine of insertion sort.\n fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     if v.len() >= 2 && is_less(&v[1], &v[0]) {\n         unsafe {\n@@ -767,10 +788,7 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n             // If `is_less` panics at any point during the process, `hole` will get dropped and\n             // fill the hole in `v` with `tmp`, thus ensuring that `v` still holds every object it\n             // initially held exactly once.\n-            let mut hole = InsertionHole {\n-                src: &mut *tmp,\n-                dest: &mut v[1],\n-            };\n+            let mut hole = InsertionHole { src: &mut *tmp, dest: &mut v[1] };\n             ptr::copy_nonoverlapping(&v[1], &mut v[0], 1);\n \n             for i in 2..v.len() {\n@@ -792,7 +810,9 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n \n     impl<T> Drop for InsertionHole<T> {\n         fn drop(&mut self) {\n-            unsafe { ptr::copy_nonoverlapping(self.src, self.dest, 1); }\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.src, self.dest, 1);\n+            }\n         }\n     }\n }\n@@ -805,7 +825,8 @@ fn insert_head<T, F>(v: &mut [T], is_less: &mut F)\n /// The two slices must be non-empty and `mid` must be in bounds. Buffer `buf` must be long enough\n /// to hold a copy of the shorter slice. Also, `T` must not be a zero-sized type.\n unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     let len = v.len();\n     let v = v.as_mut_ptr();\n@@ -834,11 +855,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n     if mid <= len - mid {\n         // The left run is shorter.\n         ptr::copy_nonoverlapping(v, buf, mid);\n-        hole = MergeHole {\n-            start: buf,\n-            end: buf.add(mid),\n-            dest: v,\n-        };\n+        hole = MergeHole { start: buf, end: buf.add(mid), dest: v };\n \n         // Initially, these pointers point to the beginnings of their arrays.\n         let left = &mut hole.start;\n@@ -858,11 +875,7 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n     } else {\n         // The right run is shorter.\n         ptr::copy_nonoverlapping(v_mid, buf, len - mid);\n-        hole = MergeHole {\n-            start: buf,\n-            end: buf.add(len - mid),\n-            dest: v_mid,\n-        };\n+        hole = MergeHole { start: buf, end: buf.add(len - mid), dest: v_mid };\n \n         // Initially, these pointers point past the ends of their arrays.\n         let left = &mut hole.dest;\n@@ -905,7 +918,9 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n         fn drop(&mut self) {\n             // `T` is not a zero-sized type, so it's okay to divide by its size.\n             let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n-            unsafe { ptr::copy_nonoverlapping(self.start, self.dest, len); }\n+            unsafe {\n+                ptr::copy_nonoverlapping(self.start, self.dest, len);\n+            }\n         }\n     }\n }\n@@ -923,7 +938,8 @@ unsafe fn merge<T, F>(v: &mut [T], mid: usize, buf: *mut T, is_less: &mut F)\n ///\n /// The invariants ensure that the total running time is `O(n log n)` worst-case.\n fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n-    where F: FnMut(&T, &T) -> bool\n+where\n+    F: FnMut(&T, &T) -> bool,\n {\n     // Slices of up to this length get sorted using insertion sort.\n     const MAX_INSERTION: usize = 20;\n@@ -940,7 +956,7 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     // Short arrays get sorted in-place via insertion sort to avoid allocations.\n     if len <= MAX_INSERTION {\n         if len >= 2 {\n-            for i in (0..len-1).rev() {\n+            for i in (0..len - 1).rev() {\n                 insert_head(&mut v[i..], &mut is_less);\n             }\n         }\n@@ -966,14 +982,13 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n             start -= 1;\n             unsafe {\n                 if is_less(v.get_unchecked(start + 1), v.get_unchecked(start)) {\n-                    while start > 0 && is_less(v.get_unchecked(start),\n-                                               v.get_unchecked(start - 1)) {\n+                    while start > 0 && is_less(v.get_unchecked(start), v.get_unchecked(start - 1)) {\n                         start -= 1;\n                     }\n                     v[start..end].reverse();\n                 } else {\n-                    while start > 0 && !is_less(v.get_unchecked(start),\n-                                                v.get_unchecked(start - 1)) {\n+                    while start > 0 && !is_less(v.get_unchecked(start), v.get_unchecked(start - 1))\n+                    {\n                         start -= 1;\n                     }\n                 }\n@@ -988,24 +1003,22 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n         }\n \n         // Push this run onto the stack.\n-        runs.push(Run {\n-            start,\n-            len: end - start,\n-        });\n+        runs.push(Run { start, len: end - start });\n         end = start;\n \n         // Merge some pairs of adjacent runs to satisfy the invariants.\n         while let Some(r) = collapse(&runs) {\n             let left = runs[r + 1];\n             let right = runs[r];\n             unsafe {\n-                merge(&mut v[left.start .. right.start + right.len], left.len, buf.as_mut_ptr(),\n-                      &mut is_less);\n+                merge(\n+                    &mut v[left.start..right.start + right.len],\n+                    left.len,\n+                    buf.as_mut_ptr(),\n+                    &mut is_less,\n+                );\n             }\n-            runs[r] = Run {\n-                start: left.start,\n-                len: left.len + right.len,\n-            };\n+            runs[r] = Run { start: left.start, len: left.len + right.len };\n             runs.remove(r + 1);\n         }\n     }\n@@ -1030,15 +1043,13 @@ fn merge_sort<T, F>(v: &mut [T], mut is_less: F)\n     #[inline]\n     fn collapse(runs: &[Run]) -> Option<usize> {\n         let n = runs.len();\n-        if n >= 2 && (runs[n - 1].start == 0 ||\n-                      runs[n - 2].len <= runs[n - 1].len ||\n-                      (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len) ||\n-                      (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len)) {\n-            if n >= 3 && runs[n - 3].len < runs[n - 1].len {\n-                Some(n - 3)\n-            } else {\n-                Some(n - 2)\n-            }\n+        if n >= 2\n+            && (runs[n - 1].start == 0\n+                || runs[n - 2].len <= runs[n - 1].len\n+                || (n >= 3 && runs[n - 3].len <= runs[n - 2].len + runs[n - 1].len)\n+                || (n >= 4 && runs[n - 4].len <= runs[n - 3].len + runs[n - 2].len))\n+        {\n+            if n >= 3 && runs[n - 3].len < runs[n - 1].len { Some(n - 3) } else { Some(n - 2) }\n         } else {\n             None\n         }"}, {"sha": "1b6e0bb291c35c17aba17233df5f574a68b8f091", "filename": "src/liballoc/tests.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,12 +1,12 @@\n //! Test for `boxed` mod.\n \n use core::any::Any;\n-use core::convert::TryInto;\n-use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n use core::clone::Clone;\n+use core::convert::TryInto;\n use core::f64;\n use core::i64;\n+use core::ops::Deref;\n+use core::result::Result::{Err, Ok};\n \n use std::boxed::Box;\n "}, {"sha": "2fbb59b0419e020422fd77aa20ec45b3d52d48ac", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 14, "deletions": 25, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,9 +1,9 @@\n use std::any::Any;\n-use std::sync::{Arc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n use std::iter::TrustedLen;\n use std::mem;\n+use std::sync::{Arc, Weak};\n \n #[test]\n fn uninhabited() {\n@@ -12,16 +12,16 @@ fn uninhabited() {\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n \n-    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    let mut a: Weak<dyn Any> = a; // Unsizing\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n }\n \n #[test]\n fn slice() {\n     let a: Arc<[u32; 3]> = Arc::new([3, 2, 1]);\n-    let a: Arc<[u32]> = a;  // Unsizing\n-    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]);  // Conversion\n+    let a: Arc<[u32]> = a; // Unsizing\n+    let b: Arc<[u32]> = Arc::from(&[3, 2, 1][..]); // Conversion\n     assert_eq!(a, b);\n \n     // Exercise is_dangling() with a DST\n@@ -33,7 +33,7 @@ fn slice() {\n #[test]\n fn trait_object() {\n     let a: Arc<u32> = Arc::new(4);\n-    let a: Arc<dyn Any> = a;  // Unsizing\n+    let a: Arc<dyn Any> = a; // Unsizing\n \n     // Exercise is_dangling() with a DST\n     let mut a = Arc::downgrade(&a);\n@@ -43,7 +43,7 @@ fn trait_object() {\n     let mut b = Weak::<u32>::new();\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n-    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    let mut b: Weak<dyn Any> = b; // Unsizing\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n@@ -57,7 +57,7 @@ fn float_nan_ne() {\n \n #[test]\n fn partial_eq() {\n-    struct TestPEq (RefCell<usize>);\n+    struct TestPEq(RefCell<usize>);\n     impl PartialEq for TestPEq {\n         fn eq(&self, other: &TestPEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -74,7 +74,7 @@ fn partial_eq() {\n #[test]\n fn eq() {\n     #[derive(Eq)]\n-    struct TestEq (RefCell<usize>);\n+    struct TestEq(RefCell<usize>);\n     impl PartialEq for TestEq {\n         fn eq(&self, other: &TestEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -160,13 +160,10 @@ fn shared_from_iter_trustedlen_normal() {\n fn shared_from_iter_trustedlen_panic() {\n     // Exercise the `TrustedLen` implementation when `size_hint()` matches\n     // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n-    let iter = (0..SHARED_ITER_MAX)\n-        .map(|val| {\n-            match val {\n-                98 => panic!(\"I've almost got 99 problems.\"),\n-                _ => Box::new(val),\n-            }\n-        });\n+    let iter = (0..SHARED_ITER_MAX).map(|val| match val {\n+        98 => panic!(\"I've almost got 99 problems.\"),\n+        _ => Box::new(val),\n+    });\n     assert_trusted_len(&iter);\n     let _ = iter.collect::<Rc<[_]>>();\n \n@@ -193,16 +190,8 @@ fn shared_from_iter_trustedlen_no_fuse() {\n         }\n     }\n \n-    let vec = vec![\n-        Some(Box::new(42)),\n-        Some(Box::new(24)),\n-        None,\n-        Some(Box::new(12)),\n-    ];\n+    let vec = vec![Some(Box::new(42)), Some(Box::new(24)), None, Some(Box::new(12))];\n     let iter = Iter(vec.into_iter());\n     assert_trusted_len(&iter);\n-    assert_eq!(\n-        &[Box::new(42), Box::new(24)],\n-        &*iter.collect::<Rc<[_]>>()\n-    );\n+    assert_eq!(&[Box::new(42), Box::new(24)], &*iter.collect::<Rc<[_]>>());\n }"}, {"sha": "66782ecbeb7f6deaa686e98206be3758f03fdd28", "filename": "src/liballoc/tests/boxed.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fboxed.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,5 +1,5 @@\n-use std::ptr::NonNull;\n use std::mem::MaybeUninit;\n+use std::ptr::NonNull;\n \n #[test]\n fn unitialized_zero_size_box() {"}, {"sha": "1d08ae13e054011cd3e9f9285539fb15dfc34675", "filename": "src/liballoc/tests/btree/mod.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmod.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -11,12 +11,7 @@ struct DeterministicRng {\n \n impl DeterministicRng {\n     fn new() -> Self {\n-        DeterministicRng {\n-            x: 0x193a6754,\n-            y: 0xa8a7d469,\n-            z: 0x97830e05,\n-            w: 0x113ba7bb,\n-        }\n+        DeterministicRng { x: 0x193a6754, y: 0xa8a7d469, z: 0x97830e05, w: 0x113ba7bb }\n     }\n \n     fn next(&mut self) -> u32 {"}, {"sha": "daa49c48c6a92461532c3dfe97ca08b8f0536976", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 30, "deletions": 45, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -102,7 +102,6 @@ fn test_split_off() {\n         assert_eq!(m.back(), Some(&1));\n         assert_eq!(m.front(), Some(&1));\n     }\n-\n }\n \n #[test]\n@@ -305,8 +304,7 @@ fn test_show() {\n     assert_eq!(format!(\"{:?}\", list), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n     let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-    assert_eq!(format!(\"{:?}\", list),\n-               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -446,19 +444,14 @@ fn drain_filter_true() {\n \n #[test]\n fn drain_filter_complex() {\n-\n-    {   //                [+xxx++++++xxxxx++++x+x++]\n+    {\n+        //                [+xxx++++++xxxxx++++x+x++]\n         let mut list = vec![\n-            1,\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36,\n-            37, 39\n-        ].into_iter().collect::<LinkedList<_>>();\n+            1, 2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37,\n+            39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -471,17 +464,13 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxx++++++xxxxx++++x+x++]\n+    {\n+        // [xxx++++++xxxxx++++x+x++]\n         let mut list = vec![\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36,\n-            37, 39\n-        ].into_iter().collect::<LinkedList<_>>();\n+            2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36, 37, 39,\n+        ]\n+        .into_iter()\n+        .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -494,16 +483,12 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxx++++++xxxxx++++x+x]\n-        let mut list = vec![\n-            2, 4, 6,\n-            7, 9, 11, 13, 15, 17,\n-            18, 20, 22, 24, 26,\n-            27, 29, 31, 33,\n-            34,\n-            35,\n-            36\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [xxx++++++xxxxx++++x+x]\n+        let mut list =\n+            vec![2, 4, 6, 7, 9, 11, 13, 15, 17, 18, 20, 22, 24, 26, 27, 29, 31, 33, 34, 35, 36]\n+                .into_iter()\n+                .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -516,11 +501,11 @@ fn drain_filter_complex() {\n         );\n     }\n \n-    {   // [xxxxxxxxxx+++++++++++]\n-        let mut list = vec![\n-            2, 4, 6, 8, 10, 12, 14, 16, 18, 20,\n-            1, 3, 5, 7, 9, 11, 13, 15, 17, 19\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [xxxxxxxxxx+++++++++++]\n+        let mut list = vec![2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 1, 3, 5, 7, 9, 11, 13, 15, 17, 19]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);\n@@ -530,11 +515,11 @@ fn drain_filter_complex() {\n         assert_eq!(list.into_iter().collect::<Vec<_>>(), vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19]);\n     }\n \n-    {   // [+++++++++++xxxxxxxxxx]\n-        let mut list = vec![\n-            1, 3, 5, 7, 9, 11, 13, 15, 17, 19,\n-            2, 4, 6, 8, 10, 12, 14, 16, 18, 20\n-        ].into_iter().collect::<LinkedList<_>>();\n+    {\n+        // [+++++++++++xxxxxxxxxx]\n+        let mut list = vec![1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20]\n+            .into_iter()\n+            .collect::<LinkedList<_>>();\n \n         let removed = list.drain_filter(|x| *x % 2 == 0).collect::<Vec<_>>();\n         assert_eq!(removed.len(), 10);"}, {"sha": "e77c57d9a5a09ef38b6721587799b0191b51d71f", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 15, "deletions": 26, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,9 +1,9 @@\n use std::any::Any;\n-use std::rc::{Rc, Weak};\n use std::cell::RefCell;\n use std::cmp::PartialEq;\n-use std::mem;\n use std::iter::TrustedLen;\n+use std::mem;\n+use std::rc::{Rc, Weak};\n \n #[test]\n fn uninhabited() {\n@@ -12,16 +12,16 @@ fn uninhabited() {\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n \n-    let mut a: Weak<dyn Any> = a;  // Unsizing\n+    let mut a: Weak<dyn Any> = a; // Unsizing\n     a = a.clone();\n     assert!(a.upgrade().is_none());\n }\n \n #[test]\n fn slice() {\n     let a: Rc<[u32; 3]> = Rc::new([3, 2, 1]);\n-    let a: Rc<[u32]> = a;  // Unsizing\n-    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]);  // Conversion\n+    let a: Rc<[u32]> = a; // Unsizing\n+    let b: Rc<[u32]> = Rc::from(&[3, 2, 1][..]); // Conversion\n     assert_eq!(a, b);\n \n     // Exercise is_dangling() with a DST\n@@ -33,7 +33,7 @@ fn slice() {\n #[test]\n fn trait_object() {\n     let a: Rc<u32> = Rc::new(4);\n-    let a: Rc<dyn Any> = a;  // Unsizing\n+    let a: Rc<dyn Any> = a; // Unsizing\n \n     // Exercise is_dangling() with a DST\n     let mut a = Rc::downgrade(&a);\n@@ -43,7 +43,7 @@ fn trait_object() {\n     let mut b = Weak::<u32>::new();\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n-    let mut b: Weak<dyn Any> = b;  // Unsizing\n+    let mut b: Weak<dyn Any> = b; // Unsizing\n     b = b.clone();\n     assert!(b.upgrade().is_none());\n }\n@@ -57,7 +57,7 @@ fn float_nan_ne() {\n \n #[test]\n fn partial_eq() {\n-    struct TestPEq (RefCell<usize>);\n+    struct TestPEq(RefCell<usize>);\n     impl PartialEq for TestPEq {\n         fn eq(&self, other: &TestPEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -74,7 +74,7 @@ fn partial_eq() {\n #[test]\n fn eq() {\n     #[derive(Eq)]\n-    struct TestEq (RefCell<usize>);\n+    struct TestEq(RefCell<usize>);\n     impl PartialEq for TestEq {\n         fn eq(&self, other: &TestEq) -> bool {\n             *self.0.borrow_mut() += 1;\n@@ -156,13 +156,10 @@ fn shared_from_iter_trustedlen_normal() {\n fn shared_from_iter_trustedlen_panic() {\n     // Exercise the `TrustedLen` implementation when `size_hint()` matches\n     // `(_, Some(exact_len))` but where `.next()` drops before the last iteration.\n-    let iter = (0..SHARED_ITER_MAX)\n-        .map(|val| {\n-            match val {\n-                98 => panic!(\"I've almost got 99 problems.\"),\n-                _ => Box::new(val),\n-            }\n-        });\n+    let iter = (0..SHARED_ITER_MAX).map(|val| match val {\n+        98 => panic!(\"I've almost got 99 problems.\"),\n+        _ => Box::new(val),\n+    });\n     assert_trusted_len(&iter);\n     let _ = iter.collect::<Rc<[_]>>();\n \n@@ -189,16 +186,8 @@ fn shared_from_iter_trustedlen_no_fuse() {\n         }\n     }\n \n-    let vec = vec![\n-        Some(Box::new(42)),\n-        Some(Box::new(24)),\n-        None,\n-        Some(Box::new(12)),\n-    ];\n+    let vec = vec![Some(Box::new(42)), Some(Box::new(24)), None, Some(Box::new(12))];\n     let iter = Iter(vec.into_iter());\n     assert_trusted_len(&iter);\n-    assert_eq!(\n-        &[Box::new(42), Box::new(24)],\n-        &*iter.collect::<Rc<[_]>>()\n-    );\n+    assert_eq!(&[Box::new(42), Box::new(24)], &*iter.collect::<Rc<[_]>>());\n }"}, {"sha": "5a0162a536175295cb89b0e9897afc6efe88395e", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 83, "deletions": 83, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1c4d4539690fe841aefea2f54c243be5f0579970/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=1c4d4539690fe841aefea2f54c243be5f0579970", "patch": "@@ -1,8 +1,8 @@\n-use std::fmt::Debug;\n-use std::collections::{VecDeque, vec_deque::Drain};\n use std::collections::TryReserveError::*;\n+use std::collections::{vec_deque::Drain, VecDeque};\n+use std::fmt::Debug;\n use std::mem::size_of;\n-use std::{usize, isize};\n+use std::{isize, usize};\n \n use crate::hash;\n \n@@ -148,34 +148,20 @@ fn test_param_taggy() {\n \n #[test]\n fn test_param_taggypar() {\n-    test_parameterized::<Taggypar<i32>>(Onepar::<i32>(1),\n-                                        Twopar::<i32>(1, 2),\n-                                        Threepar::<i32>(1, 2, 3),\n-                                        Twopar::<i32>(17, 42));\n+    test_parameterized::<Taggypar<i32>>(\n+        Onepar::<i32>(1),\n+        Twopar::<i32>(1, 2),\n+        Threepar::<i32>(1, 2, 3),\n+        Twopar::<i32>(17, 42),\n+    );\n }\n \n #[test]\n fn test_param_reccy() {\n-    let reccy1 = RecCy {\n-        x: 1,\n-        y: 2,\n-        t: One(1),\n-    };\n-    let reccy2 = RecCy {\n-        x: 345,\n-        y: 2,\n-        t: Two(1, 2),\n-    };\n-    let reccy3 = RecCy {\n-        x: 1,\n-        y: 777,\n-        t: Three(1, 2, 3),\n-    };\n-    let reccy4 = RecCy {\n-        x: 19,\n-        y: 252,\n-        t: Two(17, 42),\n-    };\n+    let reccy1 = RecCy { x: 1, y: 2, t: One(1) };\n+    let reccy2 = RecCy { x: 345, y: 2, t: Two(1, 2) };\n+    let reccy3 = RecCy { x: 1, y: 777, t: Three(1, 2, 3) };\n+    let reccy4 = RecCy { x: 19, y: 252, t: Two(17, 42) };\n     test_parameterized::<RecCy>(reccy1, reccy2, reccy3, reccy4);\n }\n \n@@ -320,8 +306,7 @@ fn test_mut_rev_iter_wrap() {\n     assert_eq!(d.pop_front(), Some(1));\n     d.push_back(4);\n \n-    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(),\n-               vec![4, 3, 2]);\n+    assert_eq!(d.iter_mut().rev().map(|x| *x).collect::<Vec<_>>(), vec![4, 3, 2]);\n }\n \n #[test]\n@@ -372,7 +357,6 @@ fn test_mut_rev_iter() {\n \n #[test]\n fn test_into_iter() {\n-\n     // Empty iter\n     {\n         let d: VecDeque<i32> = VecDeque::new();\n@@ -431,7 +415,6 @@ fn test_into_iter() {\n \n #[test]\n fn test_drain() {\n-\n     // Empty iter\n     {\n         let mut d: VecDeque<i32> = VecDeque::new();\n@@ -650,12 +633,8 @@ fn test_show() {\n     let ringbuf: VecDeque<_> = (0..10).collect();\n     assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n-    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"]\n-        .iter()\n-        .cloned()\n-        .collect();\n-    assert_eq!(format!(\"{:?}\", ringbuf),\n-               \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+    let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n+    assert_eq!(format!(\"{:?}\", ringbuf), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n }\n \n #[test]\n@@ -955,7 +934,6 @@ fn test_append_permutations() {\n             // doesn't pop more values than are pushed\n             for src_pop_back in 0..(src_push_back + src_push_front) {\n                 for src_pop_front in 0..(src_push_back + src_push_front - src_pop_back) {\n-\n                     let src = construct_vec_deque(\n                         src_push_back,\n                         src_pop_back,\n@@ -966,8 +944,8 @@ fn test_append_permutations() {\n                     for dst_push_back in 0..MAX {\n                         for dst_push_front in 0..MAX {\n                             for dst_pop_back in 0..(dst_push_back + dst_push_front) {\n-                                for dst_pop_front\n-                                    in 0..(dst_push_back + dst_push_front - dst_pop_back)\n+                                for dst_pop_front in\n+                                    0..(dst_push_back + dst_push_front - dst_pop_back)\n                                 {\n                                     let mut dst = construct_vec_deque(\n                                         dst_push_back,\n@@ -1124,7 +1102,6 @@ fn test_reserve_exact_2() {\n #[test]\n #[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve() {\n-\n     // These are the interesting cases:\n     // * exactly isize::MAX should never trigger a CapacityOverflow (can be OOM)\n     // * > isize::MAX should always fail\n@@ -1158,22 +1135,27 @@ fn test_try_reserve() {\n         if guards_against_isize {\n             // Check isize::MAX + 1 does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             // Check usize::MAX does count as overflow\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve(MAX_CAP) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         // Same basic idea, but with non-zero len\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n@@ -1186,47 +1168,54 @@ fn test_try_reserve() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should always overflow in the add-to-len\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         // Same basic idea, but with interesting type size\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         // Should fail in the mul-by-size\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve(MAX_USIZE - 20) {\n         } else {\n             panic!(\"usize::MAX should trigger an overflow!\");\n         }\n     }\n-\n }\n \n #[test]\n #[cfg(not(miri))] // Miri does not support signalling OOM\n fn test_try_reserve_exact() {\n-\n     // This is exactly the same as test_try_reserve with the method changed.\n     // See that test for comments.\n \n@@ -1247,21 +1236,26 @@ fn test_try_reserve_exact() {\n \n         if guards_against_isize {\n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_CAP + 1) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\")\n+            }\n \n             if let Err(CapacityOverflow) = empty_bytes.try_reserve_exact(MAX_USIZE) {\n-            } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+            } else {\n+                panic!(\"usize::MAX should trigger an overflow!\")\n+            }\n         } else {\n             // Check isize::MAX is an OOM\n             // VecDeque starts with capacity 7, always adds 1 to the capacity\n             // and also rounds the number to next power of 2 so this is the\n             // furthest we can go without triggering CapacityOverflow\n             if let Err(AllocError { .. }) = empty_bytes.try_reserve_exact(MAX_CAP) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n     }\n \n-\n     {\n         let mut ten_bytes: VecDeque<u8> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n@@ -1273,36 +1267,46 @@ fn test_try_reserve_exact() {\n         }\n         if guards_against_isize {\n             if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n             if let Err(AllocError { .. }) = ten_bytes.try_reserve_exact(MAX_CAP - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_bytes.try_reserve_exact(MAX_USIZE) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n \n-\n     {\n         let mut ten_u32s: VecDeque<u32> = vec![1, 2, 3, 4, 5, 6, 7, 8, 9, 10].into_iter().collect();\n \n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n-        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 10) {\n+        if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 10) {\n             panic!(\"isize::MAX shouldn't trigger an overflow!\");\n         }\n         if guards_against_isize {\n-            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an overflow!\"); }\n+            if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an overflow!\");\n+            }\n         } else {\n-            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP/4 - 9) {\n-            } else { panic!(\"isize::MAX + 1 should trigger an OOM!\") }\n+            if let Err(AllocError { .. }) = ten_u32s.try_reserve_exact(MAX_CAP / 4 - 9) {\n+            } else {\n+                panic!(\"isize::MAX + 1 should trigger an OOM!\")\n+            }\n         }\n         if let Err(CapacityOverflow) = ten_u32s.try_reserve_exact(MAX_USIZE - 20) {\n-        } else { panic!(\"usize::MAX should trigger an overflow!\") }\n+        } else {\n+            panic!(\"usize::MAX should trigger an overflow!\")\n+        }\n     }\n-\n }\n \n #[test]\n@@ -1404,9 +1408,8 @@ fn test_rotate_right_parts() {\n #[test]\n fn test_rotate_left_random() {\n     let shifts = [\n-        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n-        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n-        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1, 4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11, 9, 4, 12, 3,\n+        12, 9, 11, 1, 7, 9, 7, 2,\n     ];\n     let n = 12;\n     let mut v: VecDeque<_> = (0..n).collect();\n@@ -1423,9 +1426,8 @@ fn test_rotate_left_random() {\n #[test]\n fn test_rotate_right_random() {\n     let shifts = [\n-        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1,\n-        4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11,\n-        9, 4, 12, 3, 12, 9, 11, 1, 7, 9, 7, 2,\n+        6, 1, 0, 11, 12, 1, 11, 7, 9, 3, 6, 1, 4, 0, 5, 1, 3, 1, 12, 8, 3, 1, 11, 11, 9, 4, 12, 3,\n+        12, 9, 11, 1, 7, 9, 7, 2,\n     ];\n     let n = 12;\n     let mut v: VecDeque<_> = (0..n).collect();\n@@ -1447,8 +1449,7 @@ fn test_try_fold_empty() {\n #[test]\n fn test_try_fold_none() {\n     let v: VecDeque<u32> = (0..12).collect();\n-    assert_eq!(None, v.into_iter().try_fold(0, |a, b|\n-        if b < 11 { Some(a + b) } else { None }));\n+    assert_eq!(None, v.into_iter().try_fold(0, |a, b| if b < 11 { Some(a + b) } else { None }));\n }\n \n #[test]\n@@ -1463,7 +1464,6 @@ fn test_try_fold_unit() {\n     assert_eq!(Some(()), v.into_iter().try_fold((), |(), ()| Some(())));\n }\n \n-\n #[test]\n fn test_try_fold_unit_none() {\n     let v: std::collections::VecDeque<()> = [(); 10].iter().cloned().collect();\n@@ -1534,7 +1534,7 @@ fn test_try_rfold_rotated() {\n \n #[test]\n fn test_try_rfold_moves_iter() {\n-    let v : VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n+    let v: VecDeque<_> = [10, 20, 30, 40, 100, 60, 70, 80, 90].iter().collect();\n     let mut iter = v.into_iter();\n     assert_eq!(iter.try_rfold(0_i8, |acc, &x| acc.checked_add(x)), None);\n     assert_eq!(iter.next_back(), Some(&70));"}]}