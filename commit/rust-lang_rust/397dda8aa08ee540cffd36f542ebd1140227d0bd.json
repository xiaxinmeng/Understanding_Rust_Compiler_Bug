{"sha": "397dda8aa08ee540cffd36f542ebd1140227d0bd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5N2RkYThhYTA4ZWU1NDBjZmZkMzZmNTQyZWJkMTE0MDIyN2QwYmQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-11-29T04:08:30Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2014-12-12T06:11:59Z"}, "message": "Add support for equality constraints on associated types", "tree": {"sha": "ee4cc3c5f3434375ef05a0092f7df8154708b765", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ee4cc3c5f3434375ef05a0092f7df8154708b765"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/397dda8aa08ee540cffd36f542ebd1140227d0bd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/397dda8aa08ee540cffd36f542ebd1140227d0bd", "html_url": "https://github.com/rust-lang/rust/commit/397dda8aa08ee540cffd36f542ebd1140227d0bd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/397dda8aa08ee540cffd36f542ebd1140227d0bd/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "da83ad8e2c8e2c5f522dc59963e00f55b1f8c03b", "url": "https://api.github.com/repos/rust-lang/rust/commits/da83ad8e2c8e2c5f522dc59963e00f55b1f8c03b", "html_url": "https://github.com/rust-lang/rust/commit/da83ad8e2c8e2c5f522dc59963e00f55b1f8c03b"}], "stats": {"total": 953, "additions": 790, "deletions": 163}, "files": [{"sha": "641d1e1f2992b6eb07fade0e4d3710156df2ca12", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -148,5 +148,12 @@ register_diagnostics!(\n     E0169,\n     E0170,\n     E0171,\n-    E0172\n+    E0172,\n+    E0173,\n+    E0174,\n+    E0175,\n+    E0176,\n+    E0177,\n+    E0178,\n+    E0179\n )"}, {"sha": "d24eddf9ab05b2fa109226a816a833a7b5e52648", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -1405,10 +1405,22 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 let new_types = data.types.map(|t| {\n                     self.rebuild_arg_ty_or_output(&**t, lifetime, anon_nums, region_names)\n                 });\n+                let new_bindings = data.bindings.map(|b| {\n+                    P(ast::TypeBinding {\n+                        id: b.id,\n+                        ident: b.ident,\n+                        ty: self.rebuild_arg_ty_or_output(&*b.ty,\n+                                                          lifetime,\n+                                                          anon_nums,\n+                                                          region_names),\n+                        span: b.span\n+                    })\n+                });\n                 ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: new_lts,\n-                    types: new_types\n-                })\n+                    types: new_types,\n+                    bindings: new_bindings,\n+               })\n             }\n         };\n         let new_seg = ast::PathSegment {"}, {"sha": "37b7053530604dd246d27fb8b8cfae9d4dce9f84", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -1453,8 +1453,15 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n             }\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            for bound in predicate.bounds.iter() {\n-                self.check_ty_param_bound(predicate.span, bound)\n+            match predicate {\n+                &ast::BoundPredicate(ref bound_pred) => {\n+                    for bound in bound_pred.bounds.iter() {\n+                        self.check_ty_param_bound(bound_pred.span, bound)\n+                    }\n+                }\n+                &ast::EqPredicate(ref eq_pred) => {\n+                    self.visit_ty(&*eq_pred.ty);\n+                }\n             }\n         }\n     }"}, {"sha": "e36fefe578defb8e81ad5393eaa486e755669c4e", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -3407,9 +3407,8 @@ impl<'a> Resolver<'a> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        match self.resolve_module_in_lexical_scope(\n-                                                            module_,\n-                                                            module_path[0]) {\n+                        match self.resolve_module_in_lexical_scope(module_,\n+                                                                   module_path[0]) {\n                             Failed(err) => return Failed(err),\n                             Indeterminate => {\n                                 debug!(\"(resolving module path for import) \\\n@@ -4590,25 +4589,42 @@ impl<'a> Resolver<'a> {\n \n     fn resolve_where_clause(&mut self, where_clause: &ast::WhereClause) {\n         for predicate in where_clause.predicates.iter() {\n-            match self.resolve_identifier(predicate.ident,\n-                                          TypeNS,\n-                                          true,\n-                                          predicate.span) {\n-                Some((def @ DefTyParam(_, _, _), last_private)) => {\n-                    self.record_def(predicate.id, (def, last_private));\n-                }\n-                _ => {\n-                    self.resolve_error(\n-                        predicate.span,\n-                        format!(\"undeclared type parameter `{}`\",\n-                                token::get_ident(\n-                                    predicate.ident)).as_slice());\n+            match predicate {\n+                &ast::BoundPredicate(ref bound_pred) => {\n+                    match self.resolve_identifier(bound_pred.ident,\n+                                                  TypeNS,\n+                                                  true,\n+                                                  bound_pred.span) {\n+                        Some((def @ DefTyParam(..), last_private)) => {\n+                            self.record_def(bound_pred.id, (def, last_private));\n+                        }\n+                        _ => {\n+                            self.resolve_error(\n+                                bound_pred.span,\n+                                format!(\"undeclared type parameter `{}`\",\n+                                        token::get_ident(\n+                                            bound_pred.ident)).as_slice());\n+                        }\n+                    }\n+\n+                    for bound in bound_pred.bounds.iter() {\n+                        self.resolve_type_parameter_bound(bound_pred.id, bound,\n+                                                          TraitBoundingTypeParameter);\n+                    }\n                 }\n-            }\n+                &ast::EqPredicate(ref eq_pred) => {\n+                    match self.resolve_path(eq_pred.id, &eq_pred.path, TypeNS, true) {\n+                        Some((def @ DefTyParam(..), last_private)) => {\n+                            self.record_def(eq_pred.id, (def, last_private));\n+                        }\n+                        _ => {\n+                            self.resolve_error(eq_pred.path.span,\n+                                               \"undeclared associated type\");\n+                        }\n+                    }\n \n-            for bound in predicate.bounds.iter() {\n-                self.resolve_type_parameter_bound(predicate.id, bound,\n-                                                  TraitBoundingTypeParameter);\n+                    self.resolve_type(&*eq_pred.ty);\n+                }\n             }\n         }\n     }\n@@ -5269,15 +5285,19 @@ impl<'a> Resolver<'a> {\n                     path: &Path,\n                     namespace: Namespace,\n                     check_ribs: bool) -> Option<(Def, LastPrivate)> {\n-        // First, resolve the types.\n+        // First, resolve the types and associated type bindings.\n         for ty in path.segments.iter().flat_map(|s| s.parameters.types().into_iter()) {\n             self.resolve_type(&**ty);\n         }\n+        for binding in path.segments.iter().flat_map(|s| s.parameters.bindings().into_iter()) {\n+            self.resolve_type(&*binding.ty);\n+        }\n \n         if path.global {\n             return self.resolve_crate_relative_path(path, namespace);\n         }\n \n+        // Try to find a path to an item in a module.\n         let unqualified_def =\n                 self.resolve_identifier(path.segments\n                                             .last().unwrap()"}, {"sha": "b822e658c0dffa7f6873f35ad54de6677cade862", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -210,8 +210,16 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n             }\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            self.visit_ident(predicate.span, predicate.ident);\n-            visit::walk_ty_param_bounds_helper(self, &predicate.bounds);\n+            match predicate {\n+                &ast::BoundPredicate(ast::WhereBoundPredicate{ident, ref bounds, span, ..}) => {\n+                    self.visit_ident(span, ident);\n+                    visit::walk_ty_param_bounds_helper(self, bounds);\n+                }\n+                &ast::EqPredicate(ast::WhereEqPredicate{id, ref path, ref ty, ..}) => {\n+                    self.visit_path(path, id);\n+                    self.visit_ty(&**ty);\n+                }\n+            }\n         }\n     }\n \n@@ -486,7 +494,12 @@ fn early_bound_lifetime_names(generics: &ast::Generics) -> Vec<ast::Name> {\n             visit::walk_ty_param_bounds_helper(&mut collector, &ty_param.bounds);\n         }\n         for predicate in generics.where_clause.predicates.iter() {\n-            visit::walk_ty_param_bounds_helper(&mut collector, &predicate.bounds);\n+            match predicate {\n+                &ast::BoundPredicate(ast::WhereBoundPredicate{ref bounds, ..}) => {\n+                    visit::walk_ty_param_bounds_helper(&mut collector, bounds);\n+                }\n+                _ => {}\n+            }\n         }\n     }\n "}, {"sha": "fccb45f8724130645b7b38303a2936b0bb074e78", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -123,6 +123,13 @@ pub fn self_ty(&self) -> Option<Ty<'tcx>> {\n         s\n     }\n \n+    pub fn with_assoc_tys(&self, assoc_tys: Vec<Ty<'tcx>>) -> Substs<'tcx> {\n+        assert!(self.types.is_empty_in(AssocSpace));\n+        let mut s = (*self).clone();\n+        s.types.replace(AssocSpace, assoc_tys);\n+        s\n+    }\n+\n     pub fn erase_regions(self) -> Substs<'tcx> {\n         let Substs { types, regions: _ } = self;\n         Substs { types: types, regions: ErasedRegions }"}, {"sha": "66716267135293b9a379c5f7604aafa0088f923c", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -10,7 +10,7 @@\n // except according to those terms.\n \n use middle::subst;\n-use middle::subst::{ParamSpace, Substs, VecPerParamSpace};\n+use middle::subst::{ParamSpace, Substs, VecPerParamSpace, Subst};\n use middle::infer::InferCtxt;\n use middle::ty::{mod, Ty};\n use std::collections::HashSet;\n@@ -149,7 +149,18 @@ pub fn fresh_substs_for_impl<'a, 'tcx>(infcx: &InferCtxt<'a, 'tcx>,\n {\n     let tcx = infcx.tcx;\n     let impl_generics = ty::lookup_item_type(tcx, impl_def_id).generics;\n-    infcx.fresh_substs_for_generics(span, &impl_generics)\n+    let input_substs = infcx.fresh_substs_for_generics(span, &impl_generics);\n+\n+    // Add substs for the associated types bound in the impl.\n+    let ref items = tcx.impl_items.borrow()[impl_def_id];\n+    let mut assoc_tys = Vec::new();\n+    for item in items.iter() {\n+        if let &ty::ImplOrTraitItemId::TypeTraitItemId(id) = item {\n+            assoc_tys.push(tcx.tcache.borrow()[id].ty.subst(tcx, &input_substs));\n+        }\n+    }\n+\n+    input_substs.with_assoc_tys(assoc_tys)\n }\n \n impl<'tcx, N> fmt::Show for VtableImplData<'tcx, N> {"}, {"sha": "89e10270f0105fc3d0e685bca7bfd22e908e5c14", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 110, "deletions": 29, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -83,13 +83,18 @@ pub trait AstConv<'tcx> {\n                                            trait_id: ast::DefId)\n                                            -> bool;\n \n-    /// Returns the binding of the given associated type for some type.\n+    /// Returns the concrete type bound to the given associated type (indicated\n+    /// by associated_type_id) in the current context. For example,\n+    /// in `trait Foo { type A; }` looking up `A` will give a type variable;\n+    /// in `impl Foo for ... { type A = int; ... }` looking up `A` will give `int`.\n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n+                               // DefId for the declaration of the trait\n+                               // in which the associated type is declared.\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx>;\n+                               -> Option<Ty<'tcx>>;\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -207,7 +212,6 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     rscope: &RS,\n     decl_def_id: ast::DefId,\n     decl_generics: &ty::Generics<'tcx>,\n-    self_ty: Option<Ty<'tcx>>,\n     path: &ast::Path)\n     -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n@@ -225,19 +229,26 @@ fn ast_path_substs_for_ty<'tcx,AC,RS>(\n     assert!(decl_generics.regions.all(|d| d.space == TypeSpace));\n     assert!(decl_generics.types.all(|d| d.space != FnSpace));\n \n-    let (regions, types) = match path.segments.last().unwrap().parameters {\n+    let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n         ast::AngleBracketedParameters(ref data) => {\n             convert_angle_bracketed_parameters(this, rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n             span_err!(tcx.sess, path.span, E0169,\n                       \"parenthesized parameters may only be used with a trait\");\n-            (Vec::new(), convert_parenthesized_parameters(this, data))\n+            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n     };\n \n-    create_substs_for_ast_path(this, rscope, path.span, decl_def_id,\n-                               decl_generics, self_ty, types, regions)\n+    create_substs_for_ast_path(this,\n+                               rscope,\n+                               path.span,\n+                               decl_def_id,\n+                               decl_generics,\n+                               None,\n+                               types,\n+                               regions,\n+                               assoc_bindings)\n }\n \n fn create_substs_for_ast_path<'tcx,AC,RS>(\n@@ -248,7 +259,8 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n     decl_generics: &ty::Generics<'tcx>,\n     self_ty: Option<Ty<'tcx>>,\n     types: Vec<Ty<'tcx>>,\n-    regions: Vec<ty::Region>)\n+    regions: Vec<ty::Region>,\n+    assoc_bindings: Vec<(ast::Ident, Ty<'tcx>)>)\n     -> Substs<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n@@ -355,13 +367,49 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n         }\n     }\n \n-    for param in decl_generics.types.get_slice(AssocSpace).iter() {\n-        substs.types.push(\n-            AssocSpace,\n-            this.associated_type_binding(span,\n-                                         self_ty,\n-                                         decl_def_id,\n-                                         param.def_id));\n+    let mut matched_assoc = 0u;\n+    for formal_assoc in decl_generics.types.get_slice(AssocSpace).iter() {\n+        let mut found = false;\n+        for &(ident, ty) in assoc_bindings.iter() {\n+            if formal_assoc.name.ident() == ident {\n+                substs.types.push(AssocSpace, ty);\n+                matched_assoc += 1;\n+                found = true;\n+                break;\n+            }\n+        }\n+        if !found {\n+            match this.associated_type_binding(span,\n+                                               self_ty,\n+                                               decl_def_id,\n+                                               formal_assoc.def_id) {\n+                Some(ty) => {\n+                    substs.types.push(AssocSpace, ty);\n+                    matched_assoc += 1;\n+                }\n+                None => {\n+                    span_err!(this.tcx().sess, span, E0179,\n+                              \"missing type for associated type `{}`\",\n+                              token::get_ident(formal_assoc.name.ident()));\n+                }\n+            }\n+        }\n+    }\n+\n+    if decl_generics.types.get_slice(AssocSpace).len() != matched_assoc {\n+        span_err!(tcx.sess, span, E0171,\n+                  \"wrong number of associated type parameters: expected {}, found {}\",\n+                  decl_generics.types.get_slice(AssocSpace).len(), matched_assoc);\n+    }\n+\n+    for &(ident, _) in assoc_bindings.iter() {\n+        let mut formal_idents = decl_generics.types.get_slice(AssocSpace)\n+                                .iter().map(|t| t.name.ident());\n+        if !formal_idents.any(|i| i == ident) {\n+            span_err!(this.tcx().sess, span, E0177,\n+                      \"associated type `{}` does not exist\",\n+                      token::get_ident(ident));\n+        }\n     }\n \n     return substs;\n@@ -370,7 +418,9 @@ fn create_substs_for_ast_path<'tcx,AC,RS>(\n fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n                                                     rscope: &RS,\n                                                     data: &ast::AngleBracketedParameterData)\n-                                                    -> (Vec<ty::Region>, Vec<Ty<'tcx>>)\n+                                                    -> (Vec<ty::Region>,\n+                                                        Vec<Ty<'tcx>>,\n+                                                        Vec<(ast::Ident, Ty<'tcx>)>)\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n     let regions: Vec<_> =\n@@ -383,7 +433,12 @@ fn convert_angle_bracketed_parameters<'tcx, AC, RS>(this: &AC,\n         .map(|t| ast_ty_to_ty(this, rscope, &**t))\n         .collect();\n \n-    (regions, types)\n+    let assoc_bindings: Vec<_> =\n+        data.bindings.iter()\n+        .map(|b| (b.ident, ast_ty_to_ty(this, rscope, &*b.ty)))\n+        .collect();\n+\n+    (regions, types, assoc_bindings)\n }\n \n /// Returns the appropriate lifetime to use for any output lifetimes\n@@ -484,7 +539,8 @@ pub fn instantiate_poly_trait_ref<'tcx,AC,RS>(\n pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                                          rscope: &RS,\n                                          ast_trait_ref: &ast::TraitRef,\n-                                         self_ty: Option<Ty<'tcx>>)\n+                                         self_ty: Option<Ty<'tcx>>,\n+                                         allow_eq: AllowEqConstraints)\n                                          -> Rc<ty::TraitRef<'tcx>>\n                                          where AC: AstConv<'tcx>,\n                                                RS: RegionScope\n@@ -493,8 +549,12 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n                            ast_trait_ref.path.span,\n                            ast_trait_ref.ref_id) {\n         def::DefTrait(trait_def_id) => {\n-            let trait_ref = Rc::new(ast_path_to_trait_ref(this, rscope, trait_def_id,\n-                                                          self_ty, &ast_trait_ref.path));\n+            let trait_ref = Rc::new(ast_path_to_trait_ref(this,\n+                                                          rscope,\n+                                                          trait_def_id,\n+                                                          self_ty,\n+                                                          &ast_trait_ref.path,\n+                                                          allow_eq));\n             this.tcx().trait_refs.borrow_mut().insert(ast_trait_ref.ref_id,\n                                                       trait_ref.clone());\n             trait_ref\n@@ -507,15 +567,23 @@ pub fn instantiate_trait_ref<'tcx,AC,RS>(this: &AC,\n     }\n }\n \n+#[deriving(PartialEq,Show)]\n+pub enum AllowEqConstraints {\n+    Allow,\n+    DontAllow\n+}\n+\n fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     this: &AC,\n     rscope: &RS,\n     trait_def_id: ast::DefId,\n     self_ty: Option<Ty<'tcx>>,\n-    path: &ast::Path)\n+    path: &ast::Path,\n+    allow_eq: AllowEqConstraints)\n     -> ty::TraitRef<'tcx>\n     where AC: AstConv<'tcx>, RS: RegionScope\n {\n+    debug!(\"ast_path_to_trait_ref {}\", path);\n     let trait_def = this.get_trait_def(trait_def_id);\n \n     // the trait reference introduces a binding level here, so\n@@ -525,23 +593,29 @@ fn ast_path_to_trait_ref<'tcx,AC,RS>(\n     // lifetimes. Oh well, not there yet.\n     let shifted_rscope = ShiftedRscope::new(rscope);\n \n-    let (regions, types) = match path.segments.last().unwrap().parameters {\n+    let (regions, types, assoc_bindings) = match path.segments.last().unwrap().parameters {\n         ast::AngleBracketedParameters(ref data) => {\n             convert_angle_bracketed_parameters(this, &shifted_rscope, data)\n         }\n         ast::ParenthesizedParameters(ref data) => {\n-            (Vec::new(), convert_parenthesized_parameters(this, data))\n+            (Vec::new(), convert_parenthesized_parameters(this, data), Vec::new())\n         }\n     };\n \n+    if allow_eq == AllowEqConstraints::DontAllow && assoc_bindings.len() > 0 {\n+        span_err!(this.tcx().sess, path.span, E0173,\n+                  \"equality constraints are not allowed in this position\");\n+    }\n+\n     let substs = create_substs_for_ast_path(this,\n                                             &shifted_rscope,\n                                             path.span,\n                                             trait_def_id,\n                                             &trait_def.generics,\n                                             self_ty,\n                                             types,\n-                                            regions);\n+                                            regions,\n+                                            assoc_bindings);\n \n     ty::TraitRef::new(trait_def_id, substs)\n }\n@@ -693,7 +767,8 @@ fn ast_ty_to_trait_ref<'tcx,AC,RS>(this: &AC,\n                                                     rscope,\n                                                     trait_def_id,\n                                                     None,\n-                                                    path));\n+                                                    path,\n+                                                    AllowEqConstraints::Allow));\n                 }\n                 _ => {\n                     span_err!(this.tcx().sess, ty.span, E0172, \"expected a reference to a trait\");\n@@ -772,7 +847,8 @@ fn qpath_to_ty<'tcx,AC,RS>(this: &AC,\n     let trait_ref = instantiate_trait_ref(this,\n                                           rscope,\n                                           &*qpath.trait_ref,\n-                                          Some(self_type));\n+                                          Some(self_type),\n+                                          AllowEqConstraints::DontAllow);\n \n     debug!(\"qpath_to_ty: trait_ref={}\", trait_ref.repr(this.tcx()));\n \n@@ -916,7 +992,8 @@ pub fn ast_ty_to_ty<'tcx, AC: AstConv<'tcx>, RS: RegionScope>(\n                                                            rscope,\n                                                            trait_def_id,\n                                                            None,\n-                                                           path);\n+                                                           path,\n+                                                           AllowEqConstraints::Allow);\n                         trait_ref_to_object_type(this, rscope, path.span, result, &[])\n                     }\n                     def::DefTy(did, _) | def::DefStruct(did) => {\n@@ -1336,7 +1413,11 @@ fn conv_ty_poly_trait_ref<'tcx, AC, RS>(\n \n     let main_trait_bound = match partitioned_bounds.trait_bounds.remove(0) {\n         Some(trait_bound) => {\n-            Some(instantiate_poly_trait_ref(this, rscope, trait_bound, None))\n+            Some(instantiate_trait_ref(this,\n+                                       rscope,\n+                                       &trait_bound.trait_ref,\n+                                       None,\n+                                       AllowEqConstraints::Allow))\n         }\n         None => {\n             this.tcx().sess.span_err("}, {"sha": "3fa1234ee6e6042e179fdb2017c12b8801aa01ac", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -318,7 +318,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             substs: rcvr_substs.clone()\n         });\n \n-        self.elaborate_bounds(&[trait_ref.clone()], |this, new_trait_ref, m, method_num| {\n+        self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n             let vtable_index =\n                 get_method_index(tcx, &*new_trait_ref,\n                                  trait_ref.clone(), method_num);\n@@ -365,7 +365,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         let bounds =\n             self.fcx.inh.param_env.bounds.get(space, index).trait_bounds\n             .as_slice();\n-        self.elaborate_bounds(bounds, |this, trait_ref, m, method_num| {\n+        self.elaborate_bounds(bounds, true, |this, trait_ref, m, method_num| {\n             let xform_self_ty =\n                 this.xform_self_ty(&m, &trait_ref.substs);\n \n@@ -402,6 +402,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n     fn elaborate_bounds(\n         &mut self,\n         bounds: &[Rc<ty::TraitRef<'tcx>>],\n+        num_includes_types: bool,\n         mk_cand: for<'a> |this: &mut ProbeContext<'a, 'tcx>,\n                           tr: Rc<ty::TraitRef<'tcx>>,\n                           m: Rc<ty::Method<'tcx>>,\n@@ -415,7 +416,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 continue;\n             }\n \n-            let (pos, method) = match trait_method(tcx, bound_trait_ref.def_id, self.method_name) {\n+            let (pos, method) = match trait_method(tcx,\n+                                                   bound_trait_ref.def_id,\n+                                                   self.method_name,\n+                                                   num_includes_types) {\n                 Some(v) => v,\n                 None => { continue; }\n             };\n@@ -988,12 +992,18 @@ fn impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// index (or `None`, if no such method).\n fn trait_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n                       trait_def_id: ast::DefId,\n-                      method_name: ast::Name)\n+                      method_name: ast::Name,\n+                      num_includes_types: bool)\n                       -> Option<(uint, Rc<ty::Method<'tcx>>)>\n {\n     let trait_items = ty::trait_items(tcx, trait_def_id);\n     trait_items\n         .iter()\n+        .filter(|item|\n+            num_includes_types || match *item {\n+                &ty::MethodTraitItem(_) => true,\n+                &ty::TypeTraitItem(_) => false\n+            })\n         .enumerate()\n         .find(|&(_, ref item)| item.name() == method_name)\n         .and_then(|(idx, item)| item.as_opt_method().map(|m| (idx, m)))"}, {"sha": "6a7f6bd0ea1fb1bf33897b067a6554dd5c4482f8", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -112,7 +112,7 @@ use std::collections::hash_map::{Occupied, Vacant};\n use std::mem::replace;\n use std::rc::Rc;\n use syntax::{mod, abi, attr};\n-use syntax::ast::{mod, ProvidedMethod, RequiredMethod, TypeTraitItem};\n+use syntax::ast::{mod, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{mod, local_def, PostExpansionMethod};\n use syntax::codemap::{mod, Span};\n use syntax::owned_slice::OwnedSlice;\n@@ -1585,9 +1585,9 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n                                _: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         self.tcx().sess.span_err(span, \"unsupported associated type binding\");\n-        ty::mk_err()\n+        Some(ty::mk_err())\n     }\n }\n \n@@ -5152,12 +5152,18 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             }\n \n             Some(space) => {\n+                let trait_def_id = match def {\n+                    def::DefTrait(did) => Some(did),\n+                    _ => None\n+                };\n                 push_explicit_parameters_from_segment_to_substs(fcx,\n                                                                 space,\n                                                                 path.span,\n                                                                 type_defs,\n                                                                 region_defs,\n                                                                 segment,\n+                                                                trait_def_id,\n+                                                                path.span,\n                                                                 &mut substs);\n             }\n         }\n@@ -5244,12 +5250,14 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         segment: &ast::PathSegment,\n+        trait_def_id: Option<DefId>,\n+        path_span: Span,\n         substs: &mut Substs<'tcx>)\n     {\n         match segment.parameters {\n             ast::AngleBracketedParameters(ref data) => {\n                 push_explicit_angle_bracketed_parameters_from_segment_to_substs(\n-                    fcx, space, type_defs, region_defs, data, substs);\n+                    fcx, space, type_defs, region_defs, data, trait_def_id, path_span, substs);\n             }\n \n             ast::ParenthesizedParameters(ref data) => {\n@@ -5265,6 +5273,8 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         type_defs: &VecPerParamSpace<ty::TypeParameterDef<'tcx>>,\n         region_defs: &VecPerParamSpace<ty::RegionParameterDef>,\n         data: &ast::AngleBracketedParameterData,\n+        trait_def_id: Option<DefId>,\n+        path_span: Span,\n         substs: &mut Substs<'tcx>)\n     {\n         {\n@@ -5281,8 +5291,54 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                          found {} parameter(s)\",\n                          type_count, data.types.len());\n                     substs.types.truncate(space, 0);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if let Some(trait_def_id) = trait_def_id {\n+            let ref items = fcx.tcx().trait_item_def_ids.borrow()[trait_def_id];\n+            let mut assoc_tys = Vec::new();\n+            for item in items.iter() {\n+                if let &ty::ImplOrTraitItemId::TypeTraitItemId(id) = item {\n+                    if let ty::ImplOrTraitItem::TypeTraitItem(ref ty) =\n+                      fcx.tcx().impl_or_trait_items.borrow()[id] {\n+                        assoc_tys.push(ty.clone());\n+                    }\n+                }\n+            }\n+\n+            if data.bindings.len() > assoc_tys.len() {\n+                span_err!(fcx.tcx().sess, data.bindings[assoc_tys.len()].span, E0174,\n+                    \"too many type equality constraints provided: \\\n+                     expected at most {} constraint(s), \\\n+                     found {} constraint(s)\",\n+                     assoc_tys.len(), data.types.len());\n+                substs.types.truncate(space, 0);\n+            } else if data.bindings.len() > 0 {\n+                for assoc_ty in assoc_tys.iter() {\n+                    let mut matched = false;\n+                    for binding in data.bindings.iter() {\n+                        if assoc_ty.name.ident() == binding.ident {\n+                            let t = fcx.to_ty(&*binding.ty);\n+                            substs.types.push(space, t);\n+                            matched = true;\n+                            break;\n+                        }\n+                    }\n+                    if !matched {\n+                        span_err!(fcx.tcx().sess, path_span, E0176,\n+                            \"missing type equality constraint for associated type: {}\",\n+                             assoc_ty.name);\n+                        substs.types.truncate(space, 0);\n+                        break;\n+                    }\n                 }\n             }\n+        } else if data.bindings.len() > 0 {\n+            span_err!(fcx.tcx().sess, path_span, E0175,\n+                \"type equality constraints provided on a non-trait type\");\n+            substs.types.truncate(space, 0);\n         }\n \n         {"}, {"sha": "32892aa94ee9885237d13992d6bbf02067dfd58c", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -32,7 +32,7 @@ as `ty_param()` instances.\n use self::ConvertMethodContext::*;\n use self::CreateTypeParametersForAssociatedTypesFlag::*;\n \n-use astconv::{AstConv, ty_of_arg};\n+use astconv::{AstConv, ty_of_arg, AllowEqConstraints};\n use astconv::{ast_ty_to_ty, ast_region_to_region};\n use astconv;\n use metadata::csearch;\n@@ -197,10 +197,10 @@ impl<'a, 'tcx> AstConv<'tcx> for CrateCtxt<'a, 'tcx> {\n                                _: Option<Ty<'tcx>>,\n                                _: ast::DefId,\n                                _: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         self.tcx().sess.span_err(span, \"associated types may not be \\\n                                         referenced here\");\n-        ty::mk_err()\n+        Some(ty::mk_err())\n     }\n }\n \n@@ -782,7 +782,7 @@ impl<'a,'tcx> AstConv<'tcx> for ImplCtxt<'a,'tcx> {\n                         ast::MethodImplItem(_) => {}\n                         ast::TypeImplItem(ref typedef) => {\n                             if associated_type.name() == typedef.ident.name {\n-                                return self.ccx.to_ty(&ExplicitRscope, &*typedef.typ)\n+                                return Some(self.ccx.to_ty(&ExplicitRscope, &*typedef.typ))\n                             }\n                         }\n                     }\n@@ -943,10 +943,10 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n \n     fn associated_type_binding(&self,\n                                span: Span,\n-                               ty: Option<Ty<'tcx>>,\n+                               self_ty: Option<Ty<'tcx>>,\n                                trait_id: ast::DefId,\n                                associated_type_id: ast::DefId)\n-                               -> Ty<'tcx> {\n+                               -> Option<Ty<'tcx>> {\n         debug!(\"collect::TraitMethodCtxt::associated_type_binding()\");\n \n         // If this is one of our own associated types, return it.\n@@ -957,10 +957,10 @@ impl<'a,'tcx> AstConv<'tcx> for TraitMethodCtxt<'a,'tcx> {\n                     ast::RequiredMethod(_) | ast::ProvidedMethod(_) => {}\n                     ast::TypeTraitItem(ref item) => {\n                         if local_def(item.ty_param.id) == associated_type_id {\n-                            return ty::mk_param(self.tcx(),\n-                                                subst::AssocSpace,\n-                                                index,\n-                                                associated_type_id)\n+                            return Some(ty::mk_param(self.tcx(),\n+                                                     subst::AssocSpace,\n+                                                     index,\n+                                                     associated_type_id))\n                         }\n                         index += 1;\n                     }\n@@ -1142,8 +1142,11 @@ pub fn convert(ccx: &CrateCtxt, it: &ast::Item) {\n                             parent_visibility);\n \n             for trait_ref in opt_trait_ref.iter() {\n-                astconv::instantiate_trait_ref(&icx, &ExplicitRscope, trait_ref,\n-                                               Some(selfty));\n+                astconv::instantiate_trait_ref(&icx,\n+                                               &ExplicitRscope,\n+                                               trait_ref,\n+                                               Some(selfty),\n+                                               AllowEqConstraints::DontAllow);\n             }\n         },\n         ast::ItemTrait(_, _, _, ref trait_methods) => {\n@@ -1838,8 +1841,17 @@ fn ty_generics<'tcx,AC>(this: &AC,\n                 let trait_def = ty::lookup_trait_def(this.tcx(), trait_def_id);\n                 let associated_type_defs = trait_def.generics.types.get_slice(subst::AssocSpace);\n \n+                // Find any assocaited type bindings in the bound.\n+                let ref segments = ast_trait_ref.trait_ref.path.segments;\n+                let bindings = segments[segments.len() -1].parameters.bindings();\n+\n                 // Iterate over each associated type `Elem`\n                 for associated_type_def in associated_type_defs.iter() {\n+                    if bindings.iter().any(|b| associated_type_def.name.ident() == b.ident) {\n+                        // Don't add a variable for a bound associated type.\n+                        continue;\n+                    }\n+\n                     // Create the fresh type parameter `A`\n                     let def = ty::TypeParameterDef {\n                         name: associated_type_def.name,\n@@ -1998,10 +2010,11 @@ fn conv_param_bounds<'tcx,AC>(this: &AC,\n     let trait_bounds: Vec<Rc<ty::TraitRef>> =\n         trait_bounds.into_iter()\n         .map(|bound| {\n-            astconv::instantiate_poly_trait_ref(this,\n-                                                &ExplicitRscope,\n-                                                bound,\n-                                                Some(param_ty.to_ty(this.tcx())))\n+            astconv::instantiate_trait_ref(this,\n+                                           &ExplicitRscope,\n+                                           &bound.trait_ref,\n+                                           Some(param_ty.to_ty(this.tcx())),\n+                                           AllowEqConstraints::Allow)\n         })\n         .collect();\n     let region_bounds: Vec<ty::Region> =\n@@ -2029,18 +2042,23 @@ fn merge_param_bounds<'a>(tcx: &ty::ctxt,\n     }\n \n     for predicate in where_clause.predicates.iter() {\n-        let predicate_param_id =\n-            tcx.def_map\n-               .borrow()\n-               .get(&predicate.id)\n-               .expect(\"compute_bounds(): resolve didn't resolve the type \\\n-                        parameter identifier in a `where` clause\")\n-               .def_id();\n-        if param_ty.def_id != predicate_param_id {\n-            continue\n-        }\n-        for bound in predicate.bounds.iter() {\n-            result.push(bound);\n+        match predicate {\n+            &ast::BoundPredicate(ref bound_pred) => {\n+                let predicate_param_id =\n+                    tcx.def_map\n+                       .borrow()\n+                       .get(&bound_pred.id)\n+                       .expect(\"merge_param_bounds(): resolve didn't resolve the \\\n+                                type parameter identifier in a `where` clause\")\n+                       .def_id();\n+                if param_ty.def_id != predicate_param_id {\n+                    continue\n+                }\n+                for bound in bound_pred.bounds.iter() {\n+                    result.push(bound);\n+                }\n+            }\n+            &ast::EqPredicate(_) => panic!(\"not implemented\")\n         }\n     }\n "}, {"sha": "ea8de458ce2255dd059906af3fe442fb1ec6a539", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -255,6 +255,7 @@ impl PathParameters {\n         AngleBracketedParameters(AngleBracketedParameterData {\n             lifetimes: Vec::new(),\n             types: OwnedSlice::empty(),\n+            bindings: OwnedSlice::empty(),\n         })\n     }\n \n@@ -307,6 +308,17 @@ impl PathParameters {\n             }\n         }\n     }\n+\n+    pub fn bindings(&self) -> Vec<&P<TypeBinding>> {\n+        match *self {\n+            AngleBracketedParameters(ref data) => {\n+                data.bindings.iter().collect()\n+            }\n+            ParenthesizedParameters(_) => {\n+                Vec::new()\n+            }\n+        }\n+    }\n }\n \n /// A path like `Foo<'a, T>`\n@@ -316,11 +328,14 @@ pub struct AngleBracketedParameterData {\n     pub lifetimes: Vec<Lifetime>,\n     /// The type parameters for this path segment, if present.\n     pub types: OwnedSlice<P<Ty>>,\n+    /// Bindings (equality constraints) on associated types, if present.\n+    /// E.g., `Foo<A=Bar>`.\n+    pub bindings: OwnedSlice<P<TypeBinding>>,\n }\n \n impl AngleBracketedParameterData {\n     fn is_empty(&self) -> bool {\n-        self.lifetimes.is_empty() && self.types.is_empty()\n+        self.lifetimes.is_empty() && self.types.is_empty() && self.bindings.is_empty()\n     }\n }\n \n@@ -406,13 +421,27 @@ pub struct WhereClause {\n }\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n-pub struct WherePredicate {\n+pub enum WherePredicate {\n+    BoundPredicate(WhereBoundPredicate),\n+    EqPredicate(WhereEqPredicate)\n+}\n+\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct WhereBoundPredicate {\n     pub id: NodeId,\n     pub span: Span,\n     pub ident: Ident,\n     pub bounds: OwnedSlice<TyParamBound>,\n }\n \n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct WhereEqPredicate {\n+    pub id: NodeId,\n+    pub span: Span,\n+    pub path: Path,\n+    pub ty: P<Ty>,\n+}\n+\n /// The set of MetaItems that define the compilation environment of the crate,\n /// used to drive conditional compilation\n pub type CrateConfig = Vec<P<MetaItem>> ;\n@@ -1118,6 +1147,16 @@ impl FloatTy {\n     }\n }\n \n+// Bind a type to an associated type: `A=Foo`.\n+#[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n+pub struct TypeBinding {\n+    pub id: NodeId,\n+    pub ident: Ident,\n+    pub ty: P<Ty>,\n+    pub span: Span,\n+}\n+\n+\n // NB PartialEq method appears below.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash, Show)]\n pub struct Ty {"}, {"sha": "eec3f69ee64de2d073c835529fe40e2ac3e2bd43", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -174,12 +174,28 @@ pub fn ident_to_path(s: Span, identifier: Ident) -> Path {\n                 parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: Vec::new(),\n                     types: OwnedSlice::empty(),\n+                    bindings: OwnedSlice::empty(),\n                 })\n             }\n         ),\n     }\n }\n \n+// If path is a single segment ident path, return that ident. Otherwise, return\n+// None.\n+pub fn path_to_ident(path: &Path) -> Option<Ident> {\n+    if path.segments.len() != 1 {\n+        return None;\n+    }\n+\n+    let segment = &path.segments[0];\n+    if !segment.parameters.is_empty() {\n+        return None;\n+    }\n+\n+    Some(segment.identifier)\n+}\n+\n pub fn ident_to_pat(id: NodeId, s: Span, i: Ident) -> P<Pat> {\n     P(Pat {\n         id: id,"}, {"sha": "84040bcfa9f05b26203bbdd7005951db4474eebd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -37,7 +37,8 @@ pub trait AstBuilder {\n                 global: bool,\n                 idents: Vec<ast::Ident> ,\n                 lifetimes: Vec<ast::Lifetime>,\n-                types: Vec<P<ast::Ty>> )\n+                types: Vec<P<ast::Ty>>,\n+                bindings: Vec<P<ast::TypeBinding>> )\n         -> ast::Path;\n \n     // types\n@@ -293,20 +294,21 @@ pub trait AstBuilder {\n \n impl<'a> AstBuilder for ExtCtxt<'a> {\n     fn path(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, false, strs, Vec::new(), Vec::new())\n+        self.path_all(span, false, strs, Vec::new(), Vec::new(), Vec::new())\n     }\n     fn path_ident(&self, span: Span, id: ast::Ident) -> ast::Path {\n         self.path(span, vec!(id))\n     }\n     fn path_global(&self, span: Span, strs: Vec<ast::Ident> ) -> ast::Path {\n-        self.path_all(span, true, strs, Vec::new(), Vec::new())\n+        self.path_all(span, true, strs, Vec::new(), Vec::new(), Vec::new())\n     }\n     fn path_all(&self,\n                 sp: Span,\n                 global: bool,\n                 mut idents: Vec<ast::Ident> ,\n                 lifetimes: Vec<ast::Lifetime>,\n-                types: Vec<P<ast::Ty>> )\n+                types: Vec<P<ast::Ty>>,\n+                bindings: Vec<P<ast::TypeBinding>> )\n                 -> ast::Path {\n         let last_identifier = idents.pop().unwrap();\n         let mut segments: Vec<ast::PathSegment> = idents.into_iter()\n@@ -321,6 +323,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n             parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                 lifetimes: lifetimes,\n                 types: OwnedSlice::from_vec(types),\n+                bindings: OwnedSlice::from_vec(bindings),\n             })\n         });\n         ast::Path {\n@@ -391,7 +394,8 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                               self.ident_of(\"Option\")\n                           ),\n                           Vec::new(),\n-                          vec!( ty )))\n+                          vec!( ty ),\n+                          Vec::new()))\n     }\n \n     fn ty_field_imm(&self, span: Span, name: Ident, ty: P<ast::Ty>) -> ast::TypeField {"}, {"sha": "cf3b3ad9051aadabd6528d699b5ba7144b181afb", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -444,7 +444,7 @@ impl<'a> TraitDef<'a> {\n         // Create the type of `self`.\n         let self_type = cx.ty_path(\n             cx.path_all(self.span, false, vec!( type_ident ), self_lifetimes,\n-                        self_ty_params.into_vec()));\n+                        self_ty_params.into_vec(), Vec::new()));\n \n         let attr = cx.attribute(\n             self.span,"}, {"sha": "56d11c2377fa4f58050b1d162663aeccaf31bfbc", "filename": "src/libsyntax/ext/deriving/generic/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fty.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -80,7 +80,7 @@ impl<'a> Path<'a> {\n         let lt = mk_lifetimes(cx, span, &self.lifetime);\n         let tys = self.params.iter().map(|t| t.to_ty(cx, span, self_ty, self_generics)).collect();\n \n-        cx.path_all(span, self.global, idents, lt, tys)\n+        cx.path_all(span, self.global, idents, lt, tys, Vec::new())\n     }\n }\n \n@@ -177,7 +177,7 @@ impl<'a> Ty<'a> {\n                                                        .collect();\n \n                 cx.path_all(span, false, vec!(self_ty), lifetimes,\n-                            self_params.into_vec())\n+                            self_params.into_vec(), Vec::new())\n             }\n             Literal(ref p) => {\n                 p.to_path(cx, span, self_ty, self_generics)"}, {"sha": "c4e64d58c293285cff8dba4786ca8ca12f21e320", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -88,6 +88,7 @@ fn rand_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n                                         true,\n                                         rand_ident.clone(),\n                                         Vec::new(),\n+                                        Vec::new(),\n                                         Vec::new());\n             let rand_name = cx.expr_path(rand_name);\n "}, {"sha": "8c17b31f458d0bf9534419b86826c9290ce50cd3", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -45,7 +45,8 @@ pub fn expand_option_env<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenT\n                                                    Some(cx.lifetime(sp,\n                                                         cx.ident_of(\n                                                             \"'static\").name)),\n-                                                   ast::MutImmutable))))\n+                                                   ast::MutImmutable)),\n+                                   Vec::new()))\n       }\n       Some(s) => {\n           cx.expr_call_global(sp,"}, {"sha": "5d595474e9c70e33c25f0fde134030ace1e98d55", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -530,6 +530,7 @@ impl<'a, 'b> Context<'a, 'b> {\n                     self.fmtsp,\n                     true, Context::rtpath(self.ecx, \"Argument\"),\n                     vec![static_lifetime],\n+                    vec![],\n                     vec![]\n                 ));\n             lets.push(Context::item_static_array(self.ecx,"}, {"sha": "69e311c57f5ab6475439bab9dfc86228c6cf04ec", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -146,6 +146,10 @@ pub trait Folder {\n         noop_fold_qpath(t, self)\n     }\n \n+    fn fold_ty_binding(&mut self, t: P<TypeBinding>) -> P<TypeBinding> {\n+        noop_fold_ty_binding(t, self)\n+    }\n+\n     fn fold_mod(&mut self, m: Mod) -> Mod {\n         noop_fold_mod(m, self)\n     }\n@@ -391,6 +395,15 @@ pub fn noop_fold_decl<T: Folder>(d: P<Decl>, fld: &mut T) -> SmallVector<P<Decl>\n     })\n }\n \n+pub fn noop_fold_ty_binding<T: Folder>(b: P<TypeBinding>, fld: &mut T) -> P<TypeBinding> {\n+    b.map(|TypeBinding { id, ident, ty, span }| TypeBinding {\n+        id: fld.new_id(id),\n+        ident: ident,\n+        ty: fld.fold_ty(ty),\n+        span: fld.new_span(span),\n+    })\n+}\n+\n pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     t.map(|Ty {id, node, span}| Ty {\n         id: fld.new_id(id),\n@@ -533,9 +546,10 @@ pub fn noop_fold_angle_bracketed_parameter_data<T: Folder>(data: AngleBracketedP\n                                                            fld: &mut T)\n                                                            -> AngleBracketedParameterData\n {\n-    let AngleBracketedParameterData { lifetimes, types } = data;\n+    let AngleBracketedParameterData { lifetimes, types, bindings } = data;\n     AngleBracketedParameterData { lifetimes: fld.fold_lifetimes(lifetimes),\n-                                  types: types.move_map(|ty| fld.fold_ty(ty)) }\n+                                  types: types.move_map(|ty| fld.fold_ty(ty)),\n+                                  bindings: bindings.move_map(|b| fld.fold_ty_binding(b)) }\n }\n \n pub fn noop_fold_parenthesized_parameter_data<T: Folder>(data: ParenthesizedParameterData,\n@@ -807,14 +821,32 @@ pub fn noop_fold_where_clause<T: Folder>(\n }\n \n pub fn noop_fold_where_predicate<T: Folder>(\n-                                 WherePredicate {id, ident, bounds, span}: WherePredicate,\n+                                 pred: WherePredicate,\n                                  fld: &mut T)\n                                  -> WherePredicate {\n-    WherePredicate {\n-        id: fld.new_id(id),\n-        ident: fld.fold_ident(ident),\n-        bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n-        span: fld.new_span(span)\n+    match pred {\n+        ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{id,\n+                                                                     ident,\n+                                                                     bounds,\n+                                                                     span}) => {\n+            ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                id: fld.new_id(id),\n+                ident: fld.fold_ident(ident),\n+                bounds: bounds.move_map(|x| fld.fold_ty_param_bound(x)),\n+                span: fld.new_span(span)\n+            })\n+        }\n+        ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n+                                                               path,\n+                                                               ty,\n+                                                               span}) => {\n+            ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{\n+                id: fld.new_id(id),\n+                path: fld.fold_path(path),\n+                ty:fld.fold_ty(ty),\n+                span: fld.new_span(span)\n+            })\n+        }\n     }\n }\n "}, {"sha": "92c7380a61ded196fda7f37145ef83bb8810ce1f", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 135, "deletions": 42, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -53,7 +53,7 @@ use ast::{StructVariantKind, BiSub, StrStyle};\n use ast::{SelfExplicit, SelfRegion, SelfStatic, SelfValue};\n use ast::{Delimited, SequenceRepetition, TokenTree, TraitItem, TraitRef};\n use ast::{TtDelimited, TtSequence, TtToken};\n-use ast::{TupleVariantKind, Ty, Ty_};\n+use ast::{TupleVariantKind, Ty, Ty_, TypeBinding};\n use ast::{TypeField, TyFixedLengthVec, TyClosure, TyProc, TyBareFn};\n use ast::{TyTypeof, TyInfer, TypeMethod};\n use ast::{TyParam, TyParamBound, TyParen, TyPath, TyPolyTraitRef, TyPtr, TyQPath};\n@@ -62,7 +62,7 @@ use ast::{TypeImplItem, TypeTraitItem, Typedef, UnboxedClosureKind};\n use ast::{UnnamedField, UnsafeBlock};\n use ast::{UnsafeFn, ViewItem, ViewItem_, ViewItemExternCrate, ViewItemUse};\n use ast::{ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n-use ast::{Visibility, WhereClause, WherePredicate};\n+use ast::{Visibility, WhereClause};\n use ast;\n use ast_util::{mod, as_prec, ident_to_path, operator_prec};\n use codemap::{mod, Span, BytePos, Spanned, spanned, mk_sp};\n@@ -769,13 +769,10 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a sequence bracketed by '<' and '>', stopping\n-    /// before the '>'.\n-    pub fn parse_seq_to_before_gt<T>(\n-                                  &mut self,\n-                                  sep: Option<token::Token>,\n-                                  f: |&mut Parser| -> T)\n-                                  -> OwnedSlice<T> {\n+    pub fn parse_seq_to_before_gt_or_return<T>(&mut self,\n+                                               sep: Option<token::Token>,\n+                                               f: |&mut Parser| -> Option<T>)\n+                                               -> (OwnedSlice<T>, bool) {\n         let mut v = Vec::new();\n         // This loop works by alternating back and forth between parsing types\n         // and commas.  For example, given a string `A, B,>`, the parser would\n@@ -792,24 +789,48 @@ impl<'a> Parser<'a> {\n             }\n \n             if i % 2 == 0 {\n-                v.push(f(self));\n+                match f(self) {\n+                    Some(result) => v.push(result),\n+                    None => return (OwnedSlice::from_vec(v), true)\n+                }\n             } else {\n                 sep.as_ref().map(|t| self.expect(t));\n             }\n         }\n-        return OwnedSlice::from_vec(v);\n+        return (OwnedSlice::from_vec(v), false);\n+    }\n+\n+    /// Parse a sequence bracketed by '<' and '>', stopping\n+    /// before the '>'.\n+    pub fn parse_seq_to_before_gt<T>(&mut self,\n+                                     sep: Option<token::Token>,\n+                                     f: |&mut Parser| -> T)\n+                                     -> OwnedSlice<T> {\n+        let (result, returned) = self.parse_seq_to_before_gt_or_return(sep, |p| Some(f(p)));\n+        assert!(!returned);\n+        return result;\n     }\n \n-    pub fn parse_seq_to_gt<T>(\n-                           &mut self,\n-                           sep: Option<token::Token>,\n-                           f: |&mut Parser| -> T)\n-                           -> OwnedSlice<T> {\n+    pub fn parse_seq_to_gt<T>(&mut self,\n+                              sep: Option<token::Token>,\n+                              f: |&mut Parser| -> T)\n+                              -> OwnedSlice<T> {\n         let v = self.parse_seq_to_before_gt(sep, f);\n         self.expect_gt();\n         return v;\n     }\n \n+    pub fn parse_seq_to_gt_or_return<T>(&mut self,\n+                                        sep: Option<token::Token>,\n+                                        f: |&mut Parser| -> Option<T>)\n+                                        -> (OwnedSlice<T>, bool) {\n+        let (v, returned) = self.parse_seq_to_before_gt_or_return(sep, f);\n+        if !returned {\n+            self.expect_gt();\n+        }\n+        return (v, returned);\n+    }\n+\n     /// Parse a sequence, including the closing delimiter. The function\n     /// f must consume tokens until reaching the next separator or\n     /// closing bracket.\n@@ -1842,11 +1863,12 @@ impl<'a> Parser<'a> {\n \n             // Parse types, optionally.\n             let parameters = if self.eat_lt(false) {\n-                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+                let (lifetimes, types, bindings) = self.parse_generic_values_after_lt();\n \n                 ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                     lifetimes: lifetimes,\n                     types: OwnedSlice::from_vec(types),\n+                    bindings: OwnedSlice::from_vec(bindings),\n                 })\n             } else if self.eat(&token::OpenDelim(token::Paren)) {\n                 let inputs = self.parse_seq_to_end(\n@@ -1894,6 +1916,7 @@ impl<'a> Parser<'a> {\n                     parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                         lifetimes: Vec::new(),\n                         types: OwnedSlice::empty(),\n+                        bindings: OwnedSlice::empty(),\n                     })\n                 });\n                 return segments;\n@@ -1902,12 +1925,13 @@ impl<'a> Parser<'a> {\n             // Check for a type segment.\n             if self.eat_lt(false) {\n                 // Consumed `a::b::<`, go look for types\n-                let (lifetimes, types) = self.parse_generic_values_after_lt();\n+                let (lifetimes, types, bindings) = self.parse_generic_values_after_lt();\n                 segments.push(ast::PathSegment {\n                     identifier: identifier,\n                     parameters: ast::AngleBracketedParameters(ast::AngleBracketedParameterData {\n                         lifetimes: lifetimes,\n                         types: OwnedSlice::from_vec(types),\n+                        bindings: OwnedSlice::from_vec(bindings),\n                     }),\n                 });\n \n@@ -2435,13 +2459,18 @@ impl<'a> Parser<'a> {\n                     let dot = self.last_span.hi;\n                     hi = self.span.hi;\n                     self.bump();\n-                    let (_, tys) = if self.eat(&token::ModSep) {\n+                    let (_, tys, bindings) = if self.eat(&token::ModSep) {\n                         self.expect_lt();\n                         self.parse_generic_values_after_lt()\n                     } else {\n-                        (Vec::new(), Vec::new())\n+                        (Vec::new(), Vec::new(), Vec::new())\n                     };\n \n+                    if bindings.len() > 0 {\n+                        let last_span = self.last_span;\n+                        self.span_err(last_span, \"type bindings are only permitted on trait paths\");\n+                    }\n+\n                     // expr.f() method call\n                     match self.token {\n                         token::OpenDelim(token::Paren) => {\n@@ -4041,16 +4070,51 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_generic_values_after_lt(&mut self) -> (Vec<ast::Lifetime>, Vec<P<Ty>> ) {\n+    fn parse_generic_values_after_lt(&mut self)\n+                                     -> (Vec<ast::Lifetime>, Vec<P<Ty>>, Vec<P<TypeBinding>>) {\n         let lifetimes = self.parse_lifetimes(token::Comma);\n-        let result = self.parse_seq_to_gt(\n+\n+        // First parse types.\n+        let (types, returned) = self.parse_seq_to_gt_or_return(\n+            Some(token::Comma),\n+            |p| {\n+                p.forbid_lifetime();\n+                if p.look_ahead(1, |t| t == &token::Eq) {\n+                    None\n+                } else {\n+                    Some(p.parse_ty_sum())\n+                }\n+            }\n+        );\n+\n+        // If we found the `>`, don't continue.\n+        if !returned {\n+            return (lifetimes, types.into_vec(), Vec::new());\n+        }\n+\n+        // Then parse type bindings.\n+        let bindings = self.parse_seq_to_gt(\n             Some(token::Comma),\n             |p| {\n                 p.forbid_lifetime();\n-                p.parse_ty_sum()\n+                let lo = p.span.lo;\n+                let ident = p.parse_ident();\n+                let found_eq = p.eat(&token::Eq);\n+                if !found_eq {\n+                    let span = p.span;\n+                    p.span_warn(span, \"whoops, no =?\");\n+                }\n+                let ty = p.parse_ty();\n+                let hi = p.span.hi;\n+                let span = mk_sp(lo, hi);\n+                return P(TypeBinding{id: ast::DUMMY_NODE_ID,\n+                    ident: ident,\n+                    ty: ty,\n+                    span: span,\n+                });\n             }\n         );\n-        (lifetimes, result.into_vec())\n+        (lifetimes, types.into_vec(), bindings.into_vec())\n     }\n \n     fn forbid_lifetime(&mut self) {\n@@ -4070,29 +4134,58 @@ impl<'a> Parser<'a> {\n         let mut parsed_something = false;\n         loop {\n             let lo = self.span.lo;\n-            let ident = match self.token {\n-                token::Ident(..) => self.parse_ident(),\n+            let path = match self.token {\n+                token::Ident(..) => self.parse_path(NoTypesAllowed),\n                 _ => break,\n             };\n-            self.expect(&token::Colon);\n \n-            let bounds = self.parse_ty_param_bounds();\n-            let hi = self.span.hi;\n-            let span = mk_sp(lo, hi);\n+            if self.eat(&token::Colon) {\n+                let bounds = self.parse_ty_param_bounds();\n+                let hi = self.span.hi;\n+                let span = mk_sp(lo, hi);\n \n-            if bounds.len() == 0 {\n-                self.span_err(span,\n-                              \"each predicate in a `where` clause must have \\\n-                               at least one bound in it\");\n-            }\n+                if bounds.len() == 0 {\n+                    self.span_err(span,\n+                                  \"each predicate in a `where` clause must have \\\n+                                   at least one bound in it\");\n+                }\n \n-            generics.where_clause.predicates.push(ast::WherePredicate {\n-                id: ast::DUMMY_NODE_ID,\n-                span: span,\n-                ident: ident,\n-                bounds: bounds,\n-            });\n-            parsed_something = true;\n+                let ident = match ast_util::path_to_ident(&path) {\n+                    Some(ident) => ident,\n+                    None => {\n+                        self.span_err(path.span, \"expected a single identifier \\\n+                                                  in bound where clause\");\n+                        break;\n+                    }\n+                };\n+\n+                generics.where_clause.predicates.push(\n+                    ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: span,\n+                        ident: ident,\n+                        bounds: bounds,\n+                }));\n+                parsed_something = true;\n+            } else if self.eat(&token::Eq) {\n+                let ty = self.parse_ty();\n+                let hi = self.span.hi;\n+                let span = mk_sp(lo, hi);\n+                generics.where_clause.predicates.push(\n+                    ast::WherePredicate::EqPredicate(ast::WhereEqPredicate {\n+                        id: ast::DUMMY_NODE_ID,\n+                        span: span,\n+                        path: path,\n+                        ty: ty,\n+                }));\n+                parsed_something = true;\n+                // FIXME(#18433)\n+                self.span_err(span, \"equality constraints are not yet supported in where clauses\");\n+            } else {\n+                let last_span = self.last_span;\n+                self.span_err(last_span,\n+                              \"unexpected token in `where` clause\");\n+            }\n \n             if !self.eat(&token::Comma) {\n                 break"}, {"sha": "26373d00aaf60d9c57c96b5a5899bb2fc44318f1", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -1976,6 +1976,18 @@ impl<'a> State<'a> {\n                         Inconsistent,\n                         data.types.as_slice(),\n                         |s, ty| s.print_type(&**ty)));\n+                        comma = true;\n+                }\n+\n+                for binding in data.bindings.iter() {\n+                    if comma {\n+                        try!(self.word_space(\",\"))\n+                    }\n+                    try!(self.print_ident(binding.ident));\n+                    try!(space(&mut self.s));\n+                    try!(self.word_space(\"=\"));\n+                    try!(self.print_type(&*binding.ty));\n+                    comma = true;\n                 }\n \n                 try!(word(&mut self.s, \">\"))\n@@ -2437,8 +2449,20 @@ impl<'a> State<'a> {\n                 try!(self.word_space(\",\"));\n             }\n \n-            try!(self.print_ident(predicate.ident));\n-            try!(self.print_bounds(\":\", predicate.bounds.as_slice()));\n+            match predicate {\n+                &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{ident,\n+                                                                              ref bounds,\n+                                                                              ..}) => {\n+                    try!(self.print_ident(ident));\n+                    try!(self.print_bounds(\":\", bounds.as_slice()));\n+                }\n+                &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{ref path, ref ty, ..}) => {\n+                    try!(self.print_path(path, false));\n+                    try!(space(&mut self.s));\n+                    try!(self.word_space(\"=\"));\n+                    try!(self.print_type(&**ty));\n+                }\n+            }\n         }\n \n         Ok(())"}, {"sha": "a36f8b23ca3226d1bdb536a83b52980628a1896c", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -573,8 +573,22 @@ pub fn walk_generics<'v, V: Visitor<'v>>(visitor: &mut V, generics: &'v Generics\n     }\n     walk_lifetime_decls_helper(visitor, &generics.lifetimes);\n     for predicate in generics.where_clause.predicates.iter() {\n-        visitor.visit_ident(predicate.span, predicate.ident);\n-        walk_ty_param_bounds_helper(visitor, &predicate.bounds);\n+        match predicate {\n+            &ast::WherePredicate::BoundPredicate(ast::WhereBoundPredicate{span,\n+                                                                          ident,\n+                                                                          ref bounds,\n+                                                                          ..}) => {\n+                visitor.visit_ident(span, ident);\n+                walk_ty_param_bounds_helper(visitor, bounds);\n+            }\n+            &ast::WherePredicate::EqPredicate(ast::WhereEqPredicate{id,\n+                                                                    ref path,\n+                                                                    ref ty,\n+                                                                    ..}) => {\n+                visitor.visit_path(path, id);\n+                visitor.visit_ty(&**ty);\n+            }\n+        }\n     }\n }\n "}, {"sha": "4fd53150618749e5a5f0fd762cb1ee92e81a1c2b", "filename": "src/test/compile-fail/assoc-eq-1.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fassoc-eq-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fassoc-eq-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-eq-1.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types. Check that unsupported syntax\n+// does not ICE.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+fn foo2<I: Foo>(x: I) {\n+    let _: A = x.boo(); //~ERROR use of undeclared\n+    let _: I::A = x.boo(); //~ERROR failed to resolve\n+    //~^ERROR use of undeclared type name `I::A`\n+}\n+\n+pub fn main() {}"}, {"sha": "652bf4fb57753bf38a6ea1a626e450724539cdbe", "filename": "src/test/compile-fail/assoc-eq-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fassoc-eq-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fassoc-eq-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-eq-2.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types. Check we get an error when an\n+// equality constraint is used in a qualified path.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn boo(&self) -> uint { 42 }\n+}\n+\n+fn baz<I: Foo>(x: &<I as Foo<A=Bar>>::A) {} //~ERROR equality constraints are not allowed in this\n+\n+pub fn main() {}"}, {"sha": "880b2e9cc4a77ebf7813e317bd2bc0f4582f27e2", "filename": "src/test/compile-fail/assoc-eq-3.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fassoc-eq-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fassoc-eq-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassoc-eq-3.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types. Check we get type errors\n+// where we should.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn boo(&self) -> uint {\n+        42\n+    }\n+}\n+\n+fn foo1<I: Foo<A=Bar>>(x: I) {\n+    let _: Bar = x.boo();\n+}\n+\n+fn foo2<I: Foo>(x: I) {\n+    let _: Bar = x.boo(); //~ERROR mismatched types\n+}\n+\n+\n+pub fn baz(x: &Foo<A=Bar>) {\n+    let _: Bar = x.boo();\n+}\n+\n+\n+pub fn main() {\n+    let a = 42i;\n+    foo1(a); //~ERROR the trait `Foo` is not implemented for the type `int`\n+    baz(&a); //~ERROR the trait `Foo` is not implemented for the type `int`\n+}"}, {"sha": "e4f7521c33303cc340faabfacff70c593b767580", "filename": "src/test/compile-fail/issue-3973.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-3973.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -31,6 +31,6 @@ impl ToString_ for Point {\n fn main() {\n     let p = Point::new(0.0, 0.0);\n     //~^ ERROR unresolved name `Point::new`\n-    //~^^ ERROR failed to resolve. Use of undeclared module `Point`\n+    //~^^ ERROR failed to resolve. Use of undeclared type or module `Point`\n     println!(\"{}\", p.to_string());\n }"}, {"sha": "4c4fb5572d614a834392db98d33737b3806678f8", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -25,7 +25,7 @@ test!(b,\n #[qux]\n fn main() {\n     a::bar();\n-    //~^ ERROR failed to resolve. Use of undeclared module `a`\n+    //~^ ERROR failed to resolve. Use of undeclared type or module `a`\n     //~^^ ERROR unresolved name `a::bar`\n     b::bar();\n }"}, {"sha": "f1ba382b42dad35a52e62ce9b50499b851400382", "filename": "src/test/run-pass/assoc-eq.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Frun-pass%2Fassoc-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/397dda8aa08ee540cffd36f542ebd1140227d0bd/src%2Ftest%2Frun-pass%2Fassoc-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassoc-eq.rs?ref=397dda8aa08ee540cffd36f542ebd1140227d0bd", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints on associated types.\n+\n+#![feature(associated_types)]\n+\n+pub trait Foo {\n+    type A;\n+    fn boo(&self) -> <Self as Foo>::A;\n+}\n+\n+struct Bar;\n+\n+impl Foo for int {\n+    type A = uint;\n+    fn boo(&self) -> uint { 42 }\n+}\n+impl Foo for Bar {\n+    type A = int;\n+    fn boo(&self) -> int { 43 }\n+}\n+impl Foo for char {\n+    type A = Bar;\n+    fn boo(&self) -> Bar { Bar }\n+}\n+\n+fn foo1<I: Foo<A=Bar>>(x: I) -> Bar {\n+    x.boo()\n+}\n+fn foo2<I: Foo>(x: I) -> <I as Foo>::A {\n+    x.boo()\n+}\n+fn baz(x: &Foo<A=Bar>) -> Bar {\n+    x.boo()\n+}\n+\n+pub fn main() {\n+    let a = 42i;\n+    assert!(foo2(a) == 42u);\n+\n+    let a = Bar;\n+    assert!(foo2(a) == 43i);\n+\n+    let a = 'a';\n+    foo1(a);\n+    baz(&a);\n+}"}]}