{"sha": "80a0a12b07e4c3346cbacf70dcea810779ca0574", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgwYTBhMTJiMDdlNGMzMzQ2Y2JhY2Y3MGRjZWE4MTA3NzljYTA1NzQ=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-31T12:56:46Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-10-31T15:24:34Z"}, "message": "Stacked Borrows: test raw-ref-to-field with raw ptr tracking", "tree": {"sha": "e0a6dc46efa99e30be99d64d9a97ea8b6b630087", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0a6dc46efa99e30be99d64d9a97ea8b6b630087"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/80a0a12b07e4c3346cbacf70dcea810779ca0574", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/80a0a12b07e4c3346cbacf70dcea810779ca0574", "html_url": "https://github.com/rust-lang/rust/commit/80a0a12b07e4c3346cbacf70dcea810779ca0574", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/80a0a12b07e4c3346cbacf70dcea810779ca0574/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a2cfbfc0a6029944fa87372da6870e147961187", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a2cfbfc0a6029944fa87372da6870e147961187", "html_url": "https://github.com/rust-lang/rust/commit/9a2cfbfc0a6029944fa87372da6870e147961187"}], "stats": {"total": 49, "additions": 38, "deletions": 11}, "files": [{"sha": "efba0da1b93586c2f21e46fe76b158735633bcf6", "filename": "tests/run-pass/stacked-borrows/int-to-ptr.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/80a0a12b07e4c3346cbacf70dcea810779ca0574/tests%2Frun-pass%2Fstacked-borrows%2Fint-to-ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a0a12b07e4c3346cbacf70dcea810779ca0574/tests%2Frun-pass%2Fstacked-borrows%2Fint-to-ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2Fint-to-ptr.rs?ref=80a0a12b07e4c3346cbacf70dcea810779ca0574", "patch": "@@ -0,0 +1,13 @@\n+fn main() {\n+    ref_raw_int_raw();\n+}\n+\n+// Just to make sure that casting a ref to raw, to int and back to raw\n+// and only then using it works. This rules out ideas like \"do escape-to-raw lazily\";\n+// after casting to int and back, we lost the tag that could have let us do that.\n+fn ref_raw_int_raw() {\n+    let mut x = 3;\n+    let xref = &mut x;\n+    let xraw = xref as *mut i32 as usize as *mut i32;\n+    assert_eq!(unsafe { *xraw }, 3);\n+}"}, {"sha": "ad1877fc019bc2e98a3ab4fe7a50db5688044beb", "filename": "tests/run-pass/stacked-borrows/stacked-borrows.rs", "status": "modified", "additions": 25, "deletions": 11, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/80a0a12b07e4c3346cbacf70dcea810779ca0574/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/80a0a12b07e4c3346cbacf70dcea810779ca0574/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2Fstacked-borrows.rs?ref=80a0a12b07e4c3346cbacf70dcea810779ca0574", "patch": "@@ -1,8 +1,12 @@\n+// compile-flags: -Zmiri-track-raw-pointers\n+// ignore-windows (FIXME: tracking raw pointers does not work on Windows)\n+#![feature(raw_ref_macros)]\n+use std::ptr;\n+    \n // Test various stacked-borrows-related things.\n fn main() {\n     read_does_not_invalidate1();\n     read_does_not_invalidate2();\n-    ref_raw_int_raw();\n     mut_raw_then_mut_shr();\n     mut_shr_then_mut_raw();\n     mut_raw_mut();\n@@ -12,6 +16,7 @@ fn main() {\n     two_raw();\n     shr_and_raw();\n     disjoint_mutable_subborrows();\n+    raw_ref_to_part();\n }\n \n // Make sure that reading from an `&mut` does, like reborrowing to `&`,\n@@ -37,16 +42,6 @@ fn read_does_not_invalidate2() {\n     assert_eq!(*foo(&mut (1, 2)), 2);\n }\n \n-// Just to make sure that casting a ref to raw, to int and back to raw\n-// and only then using it works. This rules out ideas like \"do escape-to-raw lazily\";\n-// after casting to int and back, we lost the tag that could have let us do that.\n-fn ref_raw_int_raw() {\n-    let mut x = 3;\n-    let xref = &mut x;\n-    let xraw = xref as *mut i32 as usize as *mut i32;\n-    assert_eq!(unsafe { *xraw }, 3);\n-}\n-\n // Escape a mut to raw, then share the same mut and use the share, then the raw.\n // That should work.\n fn mut_raw_then_mut_shr() {\n@@ -162,3 +157,22 @@ fn disjoint_mutable_subborrows() {\n     a.push_str(\" world\");\n     eprintln!(\"{:?} {:?}\", a, b);\n }\n+\n+fn raw_ref_to_part() {\n+    struct Part {\n+        _lame: i32,\n+    }\n+\n+    #[repr(C)]\n+    struct Whole {\n+        part: Part,\n+        extra: i32,\n+    }\n+\n+    let it = Box::new(Whole { part: Part { _lame: 0 }, extra: 42 });\n+    let whole = ptr::raw_mut!(*Box::leak(it));\n+    let part = unsafe { ptr::raw_mut!((*whole).part) };\n+    let typed = unsafe { &mut *(part as *mut Whole) };\n+    assert!(typed.extra == 42);\n+    drop(unsafe { Box::from_raw(whole) });\n+}"}]}