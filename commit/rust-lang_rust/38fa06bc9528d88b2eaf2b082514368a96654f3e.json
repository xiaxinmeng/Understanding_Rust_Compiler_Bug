{"sha": "38fa06bc9528d88b2eaf2b082514368a96654f3e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4ZmEwNmJjOTUyOGQ4OGIyZWFmMmIwODI1MTQzNjhhOTY2NTRmM2U=", "commit": {"author": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2016-02-08T22:08:47Z"}, "committer": {"name": "Piotr Czarnecki", "email": "pioczarn@gmail.com", "date": "2016-02-08T22:08:47Z"}, "message": "Cleanup based on review by @nagisa\n\n* We don't have SEH-based unwinding yet.\n  For this reason we don't need operand bundles in MIR trans.\n* Refactored some uses of fcx.\n* Refactored some calls to `with_block`.", "tree": {"sha": "f8bcf537df4bdd0d4c821ee2e52b96926d051582", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f8bcf537df4bdd0d4c821ee2e52b96926d051582"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/38fa06bc9528d88b2eaf2b082514368a96654f3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/38fa06bc9528d88b2eaf2b082514368a96654f3e", "html_url": "https://github.com/rust-lang/rust/commit/38fa06bc9528d88b2eaf2b082514368a96654f3e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/38fa06bc9528d88b2eaf2b082514368a96654f3e/comments", "author": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pczarn", "id": 3356767, "node_id": "MDQ6VXNlcjMzNTY3Njc=", "avatar_url": "https://avatars.githubusercontent.com/u/3356767?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pczarn", "html_url": "https://github.com/pczarn", "followers_url": "https://api.github.com/users/pczarn/followers", "following_url": "https://api.github.com/users/pczarn/following{/other_user}", "gists_url": "https://api.github.com/users/pczarn/gists{/gist_id}", "starred_url": "https://api.github.com/users/pczarn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pczarn/subscriptions", "organizations_url": "https://api.github.com/users/pczarn/orgs", "repos_url": "https://api.github.com/users/pczarn/repos", "events_url": "https://api.github.com/users/pczarn/events{/privacy}", "received_events_url": "https://api.github.com/users/pczarn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a9ab8096ba4445f6495684b85a7c9b34fd94049c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a9ab8096ba4445f6495684b85a7c9b34fd94049c", "html_url": "https://github.com/rust-lang/rust/commit/a9ab8096ba4445f6495684b85a7c9b34fd94049c"}], "stats": {"total": 103, "additions": 36, "deletions": 67}, "files": [{"sha": "683d5e0ead452436c0be3bdf935ee0168a805302", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=38fa06bc9528d88b2eaf2b082514368a96654f3e", "patch": "@@ -740,7 +740,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     UnwindExit(val) => {\n                         // Generate a block that will resume unwinding to the\n                         // calling function\n-                        let bcx = self.new_block(\"resume\", None, None);\n+                        let bcx = self.new_block(\"resume\", None);\n                         match val {\n                             UnwindKind::LandingPad => {\n                                 let addr = self.landingpad_alloca.get()\n@@ -830,7 +830,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n \n-                let bcx_in = self.new_block(&name[..], None, None);\n+                let bcx_in = self.new_block(&name[..], None);\n                 let exit_label = label.start(bcx_in);\n                 let mut bcx_out = bcx_in;\n                 let len = scope.cleanups.len();\n@@ -873,7 +873,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => return llbb,\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(&name[..], None, None);\n+                    pad_bcx = self.new_block(&name[..], None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }"}, {"sha": "ec33046e5d914c6414e9ff77e8a131c3afe03734", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=38fa06bc9528d88b2eaf2b082514368a96654f3e", "patch": "@@ -434,33 +434,28 @@ impl<'a, 'tcx> FunctionContext<'a, 'tcx> {\n \n     pub fn new_block(&'a self,\n                      name: &str,\n-                     opt_node_id: Option<ast::NodeId>,\n-                     landing_pad: Option<LandingPad>)\n+                     opt_node_id: Option<ast::NodeId>)\n                      -> Block<'a, 'tcx> {\n         unsafe {\n             let name = CString::new(name).unwrap();\n             let llbb = llvm::LLVMAppendBasicBlockInContext(self.ccx.llcx(),\n                                                            self.llfn,\n                                                            name.as_ptr());\n-            let block = BlockS::new(llbb, opt_node_id, self);\n-            if let Some(landing_pad) = landing_pad {\n-                block.lpad.set(Some(self.lpad_arena.alloc(landing_pad)));\n-            }\n-            block\n+            BlockS::new(llbb, opt_node_id, self)\n         }\n     }\n \n     pub fn new_id_block(&'a self,\n                         name: &str,\n                         node_id: ast::NodeId)\n                         -> Block<'a, 'tcx> {\n-        self.new_block(name, Some(node_id), None)\n+        self.new_block(name, Some(node_id))\n     }\n \n     pub fn new_temp_block(&'a self,\n                           name: &str)\n                           -> Block<'a, 'tcx> {\n-        self.new_block(name, None, None)\n+        self.new_block(name, None)\n     }\n \n     pub fn join_blocks(&'a self,\n@@ -759,10 +754,6 @@ impl<'blk, 'tcx> BlockAndBuilder<'blk, 'tcx> {\n         self.bcx.llbb\n     }\n \n-    pub fn lpad(&self) -> Option<&'blk LandingPad> {\n-        self.bcx.lpad()\n-    }\n-\n     pub fn mir(&self) -> &'blk Mir<'tcx> {\n         self.bcx.mir()\n     }"}, {"sha": "b3b8214a9a70d5c076aaca91f8c1a5e2ec807efd", "filename": "src/librustc_trans/trans/mir/block.rs", "status": "modified", "additions": 18, "deletions": 29, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fblock.rs?ref=38fa06bc9528d88b2eaf2b082514368a96654f3e", "patch": "@@ -16,7 +16,7 @@ use trans::adt;\n use trans::attributes;\n use trans::base;\n use trans::build;\n-use trans::common::{self, Block, BlockAndBuilder, LandingPad};\n+use trans::common::{self, Block, BlockAndBuilder};\n use trans::debuginfo::DebugLoc;\n use trans::Disr;\n use trans::foreign;\n@@ -119,16 +119,14 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                 if let Some(unwind) = unwind {\n                     let uwbcx = self.bcx(unwind);\n                     let unwind = self.make_landing_pad(uwbcx);\n-                    let bundle = bcx.lpad().and_then(|b| b.bundle());\n                     bcx.invoke(drop_fn,\n                                &[llvalue],\n                                self.llblock(target),\n                                unwind.llbb(),\n-                               bundle,\n+                               None,\n                                None);\n                 } else {\n-                    let bundle = bcx.lpad().and_then(|b| b.bundle());\n-                    bcx.call(drop_fn, &[llvalue], bundle, None);\n+                    bcx.call(drop_fn, &[llvalue], None, None);\n                     bcx.br(self.llblock(target));\n                 }\n             }\n@@ -190,28 +188,26 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let unreachable_blk = self.unreachable_block();\n-                        let bundle = bcx.lpad().and_then(|b| b.bundle());\n                         bcx.invoke(callee.immediate(),\n                                    &llargs[..],\n                                    unreachable_blk.llbb,\n                                    landingpad.llbb(),\n-                                   bundle,\n+                                   None,\n                                    Some(attrs));\n                     },\n                     (false, false, &Some(cleanup), &Some((_, success))) => {\n                         let cleanup = self.bcx(cleanup);\n                         let landingpad = self.make_landing_pad(cleanup);\n                         let (target, postinvoke) = if must_copy_dest {\n-                            (bcx.fcx().new_block(\"\", None, None).build(), Some(self.bcx(success)))\n+                            (bcx.fcx().new_block(\"\", None).build(), Some(self.bcx(success)))\n                         } else {\n                             (self.bcx(success), None)\n                         };\n-                        let bundle = bcx.lpad().and_then(|b| b.bundle());\n                         let invokeret = bcx.invoke(callee.immediate(),\n                                                    &llargs[..],\n                                                    target.llbb(),\n                                                    landingpad.llbb(),\n-                                                   bundle,\n+                                                   None,\n                                                    Some(attrs));\n                         if let Some(postinvoketarget) = postinvoke {\n                             // We translate the copy into a temporary block. The temporary block is\n@@ -247,15 +243,13 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                         }\n                     },\n                     (false, _, _, &None) => {\n-                        let bundle = bcx.lpad().and_then(|b| b.bundle());\n-                        bcx.call(callee.immediate(), &llargs[..], bundle, Some(attrs));\n+                        bcx.call(callee.immediate(), &llargs[..], None, Some(attrs));\n                         bcx.unreachable();\n                     }\n                     (false, _, _, &Some((_, target))) => {\n-                        let bundle = bcx.lpad().and_then(|b| b.bundle());\n                         let llret = bcx.call(callee.immediate(),\n                                              &llargs[..],\n-                                             bundle,\n+                                             None,\n                                              Some(attrs));\n                         if must_copy_dest {\n                             let (ret_dest, ret_ty) = ret_dest_ty\n@@ -294,40 +288,35 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n             slot\n         } else {\n             let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-            let slot = bcx.with_block(|bcx| {\n-                base::alloca(bcx, llretty, \"personalityslot\")\n-            });\n-            self.llpersonalityslot = Some(slot);\n             bcx.with_block(|bcx| {\n+                let slot = base::alloca(bcx, llretty, \"personalityslot\");\n+                self.llpersonalityslot = Some(slot);\n                 base::call_lifetime_start(bcx, slot);\n-            });\n-            slot\n+                slot\n+            })\n         }\n     }\n \n     fn make_landing_pad(&mut self,\n                         cleanup: BlockAndBuilder<'bcx, 'tcx>)\n                         -> BlockAndBuilder<'bcx, 'tcx>\n     {\n-        let cleanup_llbb = cleanup.llbb();\n-        let bcx = cleanup.map_block(|cleanup| {\n-            // FIXME(#30941) this doesn't handle msvc-style exceptions\n-            cleanup.fcx.new_block(\"cleanup\", None, Some(LandingPad::gnu()))\n-        });\n+        // FIXME(#30941) this doesn't handle msvc-style exceptions\n+        let bcx = self.fcx.new_block(\"cleanup\", None).build();\n         let ccx = bcx.ccx();\n-        let llpersonality = bcx.fcx().eh_personality();\n+        let llpersonality = self.fcx.eh_personality();\n         let llretty = Type::struct_(ccx, &[Type::i8p(ccx), Type::i32(ccx)], false);\n-        let llretval = bcx.landing_pad(llretty, llpersonality, 1, bcx.fcx().llfn);\n+        let llretval = bcx.landing_pad(llretty, llpersonality, 1, self.fcx.llfn);\n         bcx.set_cleanup(llretval);\n         let slot = self.get_personality_slot(&bcx);\n         bcx.store(llretval, slot);\n-        bcx.br(cleanup_llbb);\n+        bcx.br(cleanup.llbb());\n         bcx\n     }\n \n     fn unreachable_block(&mut self) -> Block<'bcx, 'tcx> {\n         self.unreachable_block.unwrap_or_else(|| {\n-            let bl = self.fcx.new_block(\"unreachable\", None, None);\n+            let bl = self.fcx.new_block(\"unreachable\", None);\n             bl.build().unreachable();\n             self.unreachable_block = Some(bl);\n             bl"}, {"sha": "972340e7f5afd9e44d2cf0e6fdd414e6b5aee098", "filename": "src/librustc_trans/trans/mir/mod.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Fmod.rs?ref=38fa06bc9528d88b2eaf2b082514368a96654f3e", "patch": "@@ -13,7 +13,7 @@ use llvm::{self, ValueRef};\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use trans::base;\n-use trans::common::{self, Block, BlockAndBuilder, LandingPad};\n+use trans::common::{self, Block, BlockAndBuilder};\n use trans::expr;\n use trans::type_of;\n \n@@ -115,12 +115,7 @@ pub fn trans_mir<'bcx, 'tcx>(bcx: BlockAndBuilder<'bcx, 'tcx>) {\n         mir_blocks.iter()\n                   .map(|&bb|{\n                       // FIXME(#30941) this doesn't handle msvc-style exceptions\n-                      let lpad = if mir.basic_block_data(bb).is_cleanup {\n-                          Some(LandingPad::gnu())\n-                      } else {\n-                          None\n-                      };\n-                      fcx.new_block(&format!(\"{:?}\", bb), None, lpad)\n+                      fcx.new_block(&format!(\"{:?}\", bb), None)\n                   })\n                   .collect();\n \n@@ -175,11 +170,9 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                let lldata = llvm::get_param(fcx.llfn, idx);\n                let llextra = llvm::get_param(fcx.llfn, idx + 1);\n                idx += 2;\n-               let lltemp = bcx.with_block(|bcx| {\n-                   base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n-               });\n-               let (dataptr, meta) = bcx.with_block(|bcx| {\n-                   (expr::get_dataptr(bcx, lltemp), expr::get_meta(bcx, lltemp))\n+               let (lltemp, dataptr, meta) = bcx.with_block(|bcx| {\n+                   let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+                   (lltemp, expr::get_dataptr(bcx, lltemp), expr::get_meta(bcx, lltemp))\n                });\n                bcx.store(lldata, dataptr);\n                bcx.store(llextra, meta);\n@@ -189,13 +182,11 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                // temporary and store it there\n                let llarg = llvm::get_param(fcx.llfn, idx);\n                idx += 1;\n-               let lltemp = bcx.with_block(|bcx| {\n-                   base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index))\n-               });\n                bcx.with_block(|bcx| {\n-                   base::store_ty(bcx, llarg, lltemp, arg_ty)\n-               });\n-               lltemp\n+                   let lltemp = base::alloc_ty(bcx, arg_ty, &format!(\"arg{}\", arg_index));\n+                   base::store_ty(bcx, llarg, lltemp, arg_ty);\n+                   lltemp\n+               })\n            };\n            LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n        })"}, {"sha": "ab0c299af05ce8fe8c2f6cd0563ceed6231e3504", "filename": "src/librustc_trans/trans/mir/rvalue.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/38fa06bc9528d88b2eaf2b082514368a96654f3e/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmir%2Frvalue.rs?ref=38fa06bc9528d88b2eaf2b082514368a96654f3e", "patch": "@@ -497,12 +497,10 @@ impl<'bcx, 'tcx> MirContext<'bcx, 'tcx> {\n                     if input_ty == tcx.types.f32 {\n                         let lllhs = bcx.fpext(lhs, f64t);\n                         let llrhs = bcx.fpext(rhs, f64t);\n-                        let bundle = bcx.lpad().and_then(|b| b.bundle());\n-                        let llres = bcx.call(llfn, &[lllhs, llrhs], bundle, None);\n+                        let llres = bcx.call(llfn, &[lllhs, llrhs], None, None);\n                         bcx.fptrunc(llres, Type::f32(bcx.ccx()))\n                     } else {\n-                        let bundle = bcx.lpad().and_then(|b| b.bundle());\n-                        bcx.call(llfn, &[lhs, rhs], bundle, None)\n+                        bcx.call(llfn, &[lhs, rhs], None, None)\n                     }\n                 } else {\n                     bcx.frem(lhs, rhs)"}]}