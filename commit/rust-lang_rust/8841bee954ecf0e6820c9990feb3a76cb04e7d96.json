{"sha": "8841bee954ecf0e6820c9990feb3a76cb04e7d96", "node_id": "C_kwDOAAsO6NoAKDg4NDFiZWU5NTRlY2YwZTY4MjBjOTk5MGZlYjNhNzZjYjA0ZTdkOTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-26T08:56:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-26T08:56:20Z"}, "message": "Auto merge of #103556 - clubby789:specialize-option-partial-eq, r=scottmcm\n\nManually implement PartialEq for Option<T> and specialize non-nullable types\n\nThis PR manually implements `PartialEq` and `StructuralPartialEq` for `Option`, which seems to produce slightly better codegen than the automatically derived implementation.\n\nIt also allows specializing on the `core::num::NonZero*` and `core::ptr::NonNull` types, taking advantage of the niche optimization by transmuting the `Option<T>` to `T` to be compared directly, which can be done in just two instructions.\n\nA comparison of the original, new and specialized code generation is available [here](https://godbolt.org/z/dE4jxdYsa).", "tree": {"sha": "33cdcb23858966c692ec79816aaf6ca593b9eaca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33cdcb23858966c692ec79816aaf6ca593b9eaca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8841bee954ecf0e6820c9990feb3a76cb04e7d96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8841bee954ecf0e6820c9990feb3a76cb04e7d96", "html_url": "https://github.com/rust-lang/rust/commit/8841bee954ecf0e6820c9990feb3a76cb04e7d96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8841bee954ecf0e6820c9990feb3a76cb04e7d96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f8a2e491ebec34113563cf8683f6fec2646cebb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/f8a2e491ebec34113563cf8683f6fec2646cebb1", "html_url": "https://github.com/rust-lang/rust/commit/f8a2e491ebec34113563cf8683f6fec2646cebb1"}, {"sha": "b9a95d89902a6c9ba17dae21d84c2c04454bdddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/b9a95d89902a6c9ba17dae21d84c2c04454bdddd", "html_url": "https://github.com/rust-lang/rust/commit/b9a95d89902a6c9ba17dae21d84c2c04454bdddd"}], "stats": {"total": 130, "additions": 128, "deletions": 2}, "files": [{"sha": "ac916bb60689ee96a4c8af306dba542aef9be54c", "filename": "compiler/rustc_macros/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8841bee954ecf0e6820c9990feb3a76cb04e7d96/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8841bee954ecf0e6820c9990feb3a76cb04e7d96/compiler%2Frustc_macros%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Flib.rs?ref=8841bee954ecf0e6820c9990feb3a76cb04e7d96", "patch": "@@ -48,7 +48,7 @@ pub fn symbols(input: TokenStream) -> TokenStream {\n /// `u32::MAX`. You can also customize things like the `Debug` impl,\n /// what traits are derived, and so forth via the macro.\n #[proc_macro]\n-#[allow_internal_unstable(step_trait, rustc_attrs, trusted_step)]\n+#[allow_internal_unstable(step_trait, rustc_attrs, trusted_step, spec_option_partial_eq)]\n pub fn newtype_index(input: TokenStream) -> TokenStream {\n     newtype::newtype(input)\n }"}, {"sha": "fd3f5225155508d23f7d184bd93210fc863b709a", "filename": "compiler/rustc_macros/src/newtype.rs", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/8841bee954ecf0e6820c9990feb3a76cb04e7d96/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8841bee954ecf0e6820c9990feb3a76cb04e7d96/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fnewtype.rs?ref=8841bee954ecf0e6820c9990feb3a76cb04e7d96", "patch": "@@ -192,6 +192,30 @@ impl Parse for Newtype {\n                 }\n             }\n         };\n+        let spec_partial_eq_impl = if let Lit::Int(max) = &max {\n+            if let Ok(max_val) = max.base10_parse::<u32>() {\n+                quote! {\n+                    impl core::option::SpecOptionPartialEq for #name {\n+                        #[inline]\n+                        fn eq(l: &Option<Self>, r: &Option<Self>) -> bool {\n+                            if #max_val < u32::MAX {\n+                                l.map(|i| i.private).unwrap_or(#max_val+1) == r.map(|i| i.private).unwrap_or(#max_val+1)\n+                            } else {\n+                                match (l, r) {\n+                                    (Some(l), Some(r)) => r == l,\n+                                    (None, None) => true,\n+                                    _ => false\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            } else {\n+                quote! {}\n+            }\n+        } else {\n+            quote! {}\n+        };\n \n         Ok(Self(quote! {\n             #(#attrs)*\n@@ -293,6 +317,8 @@ impl Parse for Newtype {\n \n             #step\n \n+            #spec_partial_eq_impl\n+\n             impl From<#name> for u32 {\n                 #[inline]\n                 fn from(v: #name) -> u32 {"}, {"sha": "505d964e518d7d7ffc1fd9fc66d673588a715429", "filename": "library/core/src/option.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/8841bee954ecf0e6820c9990feb3a76cb04e7d96/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8841bee954ecf0e6820c9990feb3a76cb04e7d96/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=8841bee954ecf0e6820c9990feb3a76cb04e7d96", "patch": "@@ -512,7 +512,7 @@ use crate::{\n };\n \n /// The `Option` type. See [the module level documentation](self) for more.\n-#[derive(Copy, PartialEq, PartialOrd, Eq, Ord, Debug, Hash)]\n+#[derive(Copy, PartialOrd, Eq, Ord, Debug, Hash)]\n #[rustc_diagnostic_item = \"Option\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub enum Option<T> {\n@@ -2035,6 +2035,72 @@ impl<'a, T> const From<&'a mut Option<T>> for Option<&'a mut T> {\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T> crate::marker::StructuralPartialEq for Option<T> {}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<T: PartialEq> PartialEq for Option<T> {\n+    #[inline]\n+    fn eq(&self, other: &Self) -> bool {\n+        SpecOptionPartialEq::eq(self, other)\n+    }\n+}\n+\n+#[unstable(feature = \"spec_option_partial_eq\", issue = \"none\", reason = \"exposed only for rustc\")]\n+#[doc(hidden)]\n+pub trait SpecOptionPartialEq: Sized {\n+    fn eq(l: &Option<Self>, other: &Option<Self>) -> bool;\n+}\n+\n+#[unstable(feature = \"spec_option_partial_eq\", issue = \"none\", reason = \"exposed only for rustc\")]\n+impl<T: PartialEq> SpecOptionPartialEq for T {\n+    #[inline]\n+    default fn eq(l: &Option<T>, r: &Option<T>) -> bool {\n+        match (l, r) {\n+            (Some(l), Some(r)) => *l == *r,\n+            (None, None) => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+macro_rules! non_zero_option {\n+    ( $( #[$stability: meta] $NZ:ty; )+ ) => {\n+        $(\n+            #[$stability]\n+            impl SpecOptionPartialEq for $NZ {\n+                #[inline]\n+                fn eq(l: &Option<Self>, r: &Option<Self>) -> bool {\n+                    l.map(Self::get).unwrap_or(0) == r.map(Self::get).unwrap_or(0)\n+                }\n+            }\n+        )+\n+    };\n+}\n+\n+non_zero_option! {\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] crate::num::NonZeroU8;\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] crate::num::NonZeroU16;\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] crate::num::NonZeroU32;\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] crate::num::NonZeroU64;\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] crate::num::NonZeroU128;\n+    #[stable(feature = \"nonzero\", since = \"1.28.0\")] crate::num::NonZeroUsize;\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] crate::num::NonZeroI8;\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] crate::num::NonZeroI16;\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] crate::num::NonZeroI32;\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] crate::num::NonZeroI64;\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] crate::num::NonZeroI128;\n+    #[stable(feature = \"signed_nonzero\", since = \"1.34.0\")] crate::num::NonZeroIsize;\n+}\n+\n+#[stable(feature = \"nonnull\", since = \"1.25.0\")]\n+impl<T> SpecOptionPartialEq for crate::ptr::NonNull<T> {\n+    #[inline]\n+    fn eq(l: &Option<Self>, r: &Option<Self>) -> bool {\n+        l.map(Self::as_ptr).unwrap_or_else(|| crate::ptr::null_mut())\n+            == r.map(Self::as_ptr).unwrap_or_else(|| crate::ptr::null_mut())\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // The Option Iterators\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "598dcc19b491bf9ec70847514ae327ed2362a903", "filename": "src/test/codegen/option-nonzero-eq.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/8841bee954ecf0e6820c9990feb3a76cb04e7d96/src%2Ftest%2Fcodegen%2Foption-nonzero-eq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8841bee954ecf0e6820c9990feb3a76cb04e7d96/src%2Ftest%2Fcodegen%2Foption-nonzero-eq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Foption-nonzero-eq.rs?ref=8841bee954ecf0e6820c9990feb3a76cb04e7d96", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -O -Zmerge-functions=disabled\n+\n+#![crate_type = \"lib\"]\n+\n+extern crate core;\n+use core::num::{NonZeroU32, NonZeroI64};\n+use core::ptr::NonNull;\n+\n+// CHECK-lABEL: @non_zero_eq\n+#[no_mangle]\n+pub fn non_zero_eq(l: Option<NonZeroU32>, r: Option<NonZeroU32>) -> bool {\n+    // CHECK: start:\n+    // CHECK-NEXT: icmp eq i32\n+    // CHECK-NEXT: ret i1\n+    l == r\n+}\n+\n+// CHECK-lABEL: @non_zero_signed_eq\n+#[no_mangle]\n+pub fn non_zero_signed_eq(l: Option<NonZeroI64>, r: Option<NonZeroI64>) -> bool {\n+    // CHECK: start:\n+    // CHECK-NEXT: icmp eq i64\n+    // CHECK-NEXT: ret i1\n+    l == r\n+}\n+\n+// CHECK-lABEL: @non_null_eq\n+#[no_mangle]\n+pub fn non_null_eq(l: Option<NonNull<u8>>, r: Option<NonNull<u8>>) -> bool {\n+    // CHECK: start:\n+    // CHECK-NEXT: icmp eq {{(i8\\*|ptr)}}\n+    // CHECK-NEXT: ret i1\n+    l == r\n+}"}]}