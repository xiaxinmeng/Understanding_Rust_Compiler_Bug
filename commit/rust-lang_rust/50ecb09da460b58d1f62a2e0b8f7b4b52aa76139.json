{"sha": "50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "node_id": "C_kwDOAAsO6NoAKDUwZWNiMDlkYTQ2MGI1OGQxZjYyYTJlMGI4ZjdiNGI1MmFhNzYxMzk", "commit": {"author": {"name": "TJ DeVries", "email": "devries.timothyj@gmail.com", "date": "2022-06-11T01:29:04Z"}, "committer": {"name": "TJ DeVries", "email": "devries.timothyj@gmail.com", "date": "2022-08-22T19:13:46Z"}, "message": "feat: emit SCIP via rust-analyzer", "tree": {"sha": "385aa7986cef50ec02c66a90d3042a87b635af54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/385aa7986cef50ec02c66a90d3042a87b635af54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "html_url": "https://github.com/rust-lang/rust/commit/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/comments", "author": {"login": "tjdevries", "id": 4466899, "node_id": "MDQ6VXNlcjQ0NjY4OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/4466899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tjdevries", "html_url": "https://github.com/tjdevries", "followers_url": "https://api.github.com/users/tjdevries/followers", "following_url": "https://api.github.com/users/tjdevries/following{/other_user}", "gists_url": "https://api.github.com/users/tjdevries/gists{/gist_id}", "starred_url": "https://api.github.com/users/tjdevries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tjdevries/subscriptions", "organizations_url": "https://api.github.com/users/tjdevries/orgs", "repos_url": "https://api.github.com/users/tjdevries/repos", "events_url": "https://api.github.com/users/tjdevries/events{/privacy}", "received_events_url": "https://api.github.com/users/tjdevries/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tjdevries", "id": 4466899, "node_id": "MDQ6VXNlcjQ0NjY4OTk=", "avatar_url": "https://avatars.githubusercontent.com/u/4466899?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tjdevries", "html_url": "https://github.com/tjdevries", "followers_url": "https://api.github.com/users/tjdevries/followers", "following_url": "https://api.github.com/users/tjdevries/following{/other_user}", "gists_url": "https://api.github.com/users/tjdevries/gists{/gist_id}", "starred_url": "https://api.github.com/users/tjdevries/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tjdevries/subscriptions", "organizations_url": "https://api.github.com/users/tjdevries/orgs", "repos_url": "https://api.github.com/users/tjdevries/repos", "events_url": "https://api.github.com/users/tjdevries/events{/privacy}", "received_events_url": "https://api.github.com/users/tjdevries/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6711ded5cdbb6045e8d1e62ba71c98c4fc857601", "url": "https://api.github.com/repos/rust-lang/rust/commits/6711ded5cdbb6045e8d1e62ba71c98c4fc857601", "html_url": "https://github.com/rust-lang/rust/commit/6711ded5cdbb6045e8d1e62ba71c98c4fc857601"}], "stats": {"total": 644, "additions": 630, "deletions": 14}, "files": [{"sha": "783345ce7a45838a7af86aafedd6a3038b5adaba", "filename": "Cargo.lock", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "patch": "@@ -1229,6 +1229,26 @@ dependencies = [\n  \"tracing\",\n ]\n \n+[[package]]\n+name = \"protobuf\"\n+version = \"3.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"4ee4a7d8b91800c8f167a6268d1a1026607368e1adc84e98fe044aeb905302f7\"\n+dependencies = [\n+ \"once_cell\",\n+ \"protobuf-support\",\n+ \"thiserror\",\n+]\n+\n+[[package]]\n+name = \"protobuf-support\"\n+version = \"3.1.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"8ca157fe12fc7ee2e315f2f735e27df41b3d97cdd70ea112824dac1ffb08ee1c\"\n+dependencies = [\n+ \"thiserror\",\n+]\n+\n [[package]]\n name = \"pulldown-cmark\"\n version = \"0.9.2\"\n@@ -1360,6 +1380,7 @@ dependencies = [\n  \"project-model\",\n  \"rayon\",\n  \"rustc-hash\",\n+ \"scip\",\n  \"serde\",\n  \"serde_json\",\n  \"sourcegen\",\n@@ -1446,6 +1467,15 @@ dependencies = [\n  \"winapi-util\",\n ]\n \n+[[package]]\n+name = \"scip\"\n+version = \"0.1.1\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"b2bfbb10286f69fad7c78db71004b7839bf957788359fe0c479f029f9849136b\"\n+dependencies = [\n+ \"protobuf\",\n+]\n+\n [[package]]\n name = \"scoped-tls\"\n version = \"1.0.0\"\n@@ -1631,6 +1661,26 @@ version = \"1.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n checksum = \"288cb548dbe72b652243ea797201f3d481a0609a967980fcc5b2315ea811560a\"\n \n+[[package]]\n+name = \"thiserror\"\n+version = \"1.0.31\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"bd829fe32373d27f76265620b5309d0340cb8550f523c1dda251d6298069069a\"\n+dependencies = [\n+ \"thiserror-impl\",\n+]\n+\n+[[package]]\n+name = \"thiserror-impl\"\n+version = \"1.0.31\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"0396bc89e626244658bef819e22d0cc459e795a5ebe878e6ec336d1674a8d79a\"\n+dependencies = [\n+ \"proc-macro2\",\n+ \"quote\",\n+ \"syn\",\n+]\n+\n [[package]]\n name = \"thread_local\"\n version = \"1.1.4\""}, {"sha": "2b2d3f86a29219ce28d8d642d4920f805d803e20", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "patch": "@@ -87,7 +87,7 @@ pub use crate::{\n     },\n     join_lines::JoinLinesConfig,\n     markup::Markup,\n-    moniker::{MonikerKind, MonikerResult, PackageInformation},\n+    moniker::{MonikerDescriptorKind, MonikerKind, MonikerResult, PackageInformation},\n     move_item::Direction,\n     navigation_target::NavigationTarget,\n     prime_caches::ParallelPrimeCachesProgress,"}, {"sha": "600a526300c76a10594fe7f4b8b5c28ec4a072b8", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 118, "deletions": 13, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "patch": "@@ -13,17 +13,39 @@ use syntax::{AstNode, SyntaxKind::*, T};\n \n use crate::{doc_links::token_as_doc_comment, RangeInfo};\n \n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub enum MonikerDescriptorKind {\n+    Namespace,\n+    Type,\n+    Term,\n+    Method,\n+    TypeParameter,\n+    Parameter,\n+    Macro,\n+    Meta,\n+}\n+\n+#[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct MonikerDescriptor {\n+    pub name: Name,\n+    pub desc: MonikerDescriptorKind,\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct MonikerIdentifier {\n-    crate_name: String,\n-    path: Vec<Name>,\n+    pub crate_name: String,\n+    pub description: Vec<MonikerDescriptor>,\n }\n \n impl ToString for MonikerIdentifier {\n     fn to_string(&self) -> String {\n         match self {\n-            MonikerIdentifier { path, crate_name } => {\n-                format!(\"{}::{}\", crate_name, path.iter().map(|x| x.to_string()).join(\"::\"))\n+            MonikerIdentifier { description, crate_name } => {\n+                format!(\n+                    \"{}::{}\",\n+                    crate_name,\n+                    description.iter().map(|x| x.name.to_string()).join(\"::\")\n+                )\n             }\n         }\n     }\n@@ -42,6 +64,12 @@ pub struct MonikerResult {\n     pub package_information: PackageInformation,\n }\n \n+impl MonikerResult {\n+    pub fn from_def(db: &RootDatabase, def: Definition, from_crate: Crate) -> Option<Self> {\n+        def_to_moniker(db, def, from_crate)\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, Hash)]\n pub struct PackageInformation {\n     pub name: String,\n@@ -105,13 +133,23 @@ pub(crate) fn def_to_moniker(\n     def: Definition,\n     from_crate: Crate,\n ) -> Option<MonikerResult> {\n-    if matches!(def, Definition::GenericParam(_) | Definition::SelfType(_) | Definition::Local(_)) {\n+    if matches!(\n+        def,\n+        Definition::GenericParam(_)\n+            | Definition::Label(_)\n+            | Definition::DeriveHelper(_)\n+            | Definition::BuiltinAttr(_)\n+            | Definition::ToolModule(_)\n+    ) {\n         return None;\n     }\n+\n     let module = def.module(db)?;\n     let krate = module.krate();\n-    let mut path = vec![];\n-    path.extend(module.path_to_root(db).into_iter().filter_map(|x| x.name(db)));\n+    let mut description = vec![];\n+    description.extend(module.path_to_root(db).into_iter().filter_map(|x| {\n+        Some(MonikerDescriptor { name: x.name(db)?, desc: MonikerDescriptorKind::Namespace })\n+    }));\n \n     // Handle associated items within a trait\n     if let Some(assoc) = def.as_assoc_item(db) {\n@@ -120,31 +158,98 @@ pub(crate) fn def_to_moniker(\n             AssocItemContainer::Trait(trait_) => {\n                 // Because different traits can have functions with the same name,\n                 // we have to include the trait name as part of the moniker for uniqueness.\n-                path.push(trait_.name(db));\n+                description.push(MonikerDescriptor {\n+                    name: trait_.name(db),\n+                    desc: MonikerDescriptorKind::Type,\n+                });\n             }\n             AssocItemContainer::Impl(impl_) => {\n                 // Because a struct can implement multiple traits, for implementations\n                 // we add both the struct name and the trait name to the path\n                 if let Some(adt) = impl_.self_ty(db).as_adt() {\n-                    path.push(adt.name(db));\n+                    description.push(MonikerDescriptor {\n+                        name: adt.name(db),\n+                        desc: MonikerDescriptorKind::Type,\n+                    });\n                 }\n \n                 if let Some(trait_) = impl_.trait_(db) {\n-                    path.push(trait_.name(db));\n+                    description.push(MonikerDescriptor {\n+                        name: trait_.name(db),\n+                        desc: MonikerDescriptorKind::Type,\n+                    });\n                 }\n             }\n         }\n     }\n \n     if let Definition::Field(it) = def {\n-        path.push(it.parent_def(db).name(db));\n+        description.push(MonikerDescriptor {\n+            name: it.parent_def(db).name(db),\n+            desc: MonikerDescriptorKind::Type,\n+        });\n     }\n \n-    path.push(def.name(db)?);\n+    let name_desc = match def {\n+        // These are handled by top-level guard (for performance).\n+        Definition::GenericParam(_)\n+        | Definition::Label(_)\n+        | Definition::DeriveHelper(_)\n+        | Definition::BuiltinAttr(_)\n+        | Definition::ToolModule(_) => return None,\n+\n+        Definition::Local(local) => {\n+            if !local.is_param(db) {\n+                return None;\n+            }\n+\n+            MonikerDescriptor { name: local.name(db), desc: MonikerDescriptorKind::Parameter }\n+        }\n+        Definition::Macro(m) => {\n+            MonikerDescriptor { name: m.name(db), desc: MonikerDescriptorKind::Macro }\n+        }\n+        Definition::Function(f) => {\n+            MonikerDescriptor { name: f.name(db), desc: MonikerDescriptorKind::Method }\n+        }\n+        Definition::Variant(v) => {\n+            MonikerDescriptor { name: v.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::Const(c) => {\n+            MonikerDescriptor { name: c.name(db)?, desc: MonikerDescriptorKind::Term }\n+        }\n+        Definition::Trait(trait_) => {\n+            MonikerDescriptor { name: trait_.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::TypeAlias(ta) => {\n+            MonikerDescriptor { name: ta.name(db), desc: MonikerDescriptorKind::TypeParameter }\n+        }\n+        Definition::Module(m) => {\n+            MonikerDescriptor { name: m.name(db)?, desc: MonikerDescriptorKind::Namespace }\n+        }\n+        Definition::BuiltinType(b) => {\n+            MonikerDescriptor { name: b.name(), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::SelfType(imp) => MonikerDescriptor {\n+            name: imp.self_ty(db).as_adt()?.name(db),\n+            desc: MonikerDescriptorKind::Type,\n+        },\n+        Definition::Field(it) => {\n+            MonikerDescriptor { name: it.name(db), desc: MonikerDescriptorKind::Term }\n+        }\n+        Definition::Adt(adt) => {\n+            MonikerDescriptor { name: adt.name(db), desc: MonikerDescriptorKind::Type }\n+        }\n+        Definition::Static(s) => {\n+            MonikerDescriptor { name: s.name(db), desc: MonikerDescriptorKind::Meta }\n+        }\n+    };\n+\n+    description.push(name_desc);\n+\n     Some(MonikerResult {\n         identifier: MonikerIdentifier {\n             crate_name: krate.display_name(db)?.crate_name().to_string(),\n-            path,\n+            description,\n         },\n         kind: if krate == from_crate { MonikerKind::Export } else { MonikerKind::Import },\n         package_information: {"}, {"sha": "b36732c834d85703cefcf7bf7bd065716edc12e8", "filename": "crates/rust-analyzer/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2FCargo.toml?ref=50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "patch": "@@ -23,6 +23,7 @@ crossbeam-channel = \"0.5.5\"\n dissimilar = \"1.0.4\"\n itertools = \"0.10.3\"\n lsp-types = { version = \"0.93.0\", features = [\"proposed\"] }\n+scip = \"0.1.1\"\n parking_lot = \"0.12.1\"\n xflags = \"0.2.4\"\n oorandom = \"11.1.3\""}, {"sha": "f6a6802972525c09002f18bdc81bacb60a39d3dd", "filename": "crates/rust-analyzer/src/bin/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fbin%2Fmain.rs?ref=50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "patch": "@@ -93,6 +93,7 @@ fn try_main() -> Result<()> {\n         flags::RustAnalyzerCmd::Ssr(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Search(cmd) => cmd.run()?,\n         flags::RustAnalyzerCmd::Lsif(cmd) => cmd.run()?,\n+        flags::RustAnalyzerCmd::Scip(cmd) => cmd.run()?,\n     }\n     Ok(())\n }"}, {"sha": "60ba67e25f93bc08679072f4a25de7bf10bdaf7c", "filename": "crates/rust-analyzer/src/cli.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2Fsrc%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli.rs?ref=50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "patch": "@@ -9,6 +9,7 @@ mod analysis_stats;\n mod diagnostics;\n mod ssr;\n mod lsif;\n+mod scip;\n \n mod progress_report;\n "}, {"sha": "aa32654fbdca1efc3afc748e8ac59fb5b28e4c85", "filename": "crates/rust-analyzer/src/cli/flags.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fflags.rs?ref=50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "patch": "@@ -112,6 +112,10 @@ xflags::xflags! {\n         cmd lsif\n             required path: PathBuf\n         {}\n+\n+        cmd scip\n+            required path: PathBuf\n+        {}\n     }\n }\n \n@@ -140,6 +144,7 @@ pub enum RustAnalyzerCmd {\n     Search(Search),\n     ProcMacro(ProcMacro),\n     Lsif(Lsif),\n+    Scip(Scip),\n }\n \n #[derive(Debug)]\n@@ -207,6 +212,11 @@ pub struct Lsif {\n     pub path: PathBuf,\n }\n \n+#[derive(Debug)]\n+pub struct Scip {\n+    pub path: PathBuf,\n+}\n+\n impl RustAnalyzer {\n     pub const HELP: &'static str = Self::HELP_;\n "}, {"sha": "65cc993c45e7145f8936532d002ba8133b7d6105", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "added", "additions": 448, "deletions": 0, "changes": 448, "blob_url": "https://github.com/rust-lang/rust/blob/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/50ecb09da460b58d1f62a2e0b8f7b4b52aa76139/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=50ecb09da460b58d1f62a2e0b8f7b4b52aa76139", "patch": "@@ -0,0 +1,448 @@\n+//! SCIP generator\n+\n+use std::{\n+    collections::{HashMap, HashSet},\n+    time::Instant,\n+};\n+\n+use crate::line_index::{LineEndings, LineIndex, OffsetEncoding};\n+use hir::Name;\n+use ide::{\n+    LineCol, MonikerDescriptorKind, MonikerResult, StaticIndex, StaticIndexedFile, TextRange,\n+    TokenId,\n+};\n+use ide_db::LineIndexDatabase;\n+use project_model::{CargoConfig, ProjectManifest, ProjectWorkspace};\n+use scip::types as scip_types;\n+use std::env;\n+\n+use crate::cli::{\n+    flags,\n+    load_cargo::{load_workspace, LoadCargoConfig},\n+    Result,\n+};\n+\n+impl flags::Scip {\n+    pub fn run(self) -> Result<()> {\n+        eprintln!(\"Generating SCIP start...\");\n+        let now = Instant::now();\n+        let cargo_config = CargoConfig::default();\n+\n+        let no_progress = &|s| (eprintln!(\"rust-analyzer: Loading {}\", s));\n+        let load_cargo_config = LoadCargoConfig {\n+            load_out_dirs_from_check: true,\n+            with_proc_macro: true,\n+            prefill_caches: true,\n+        };\n+        let path = vfs::AbsPathBuf::assert(env::current_dir()?.join(&self.path));\n+        let rootpath = path.normalize();\n+        let manifest = ProjectManifest::discover_single(&path)?;\n+\n+        let workspace = ProjectWorkspace::load(manifest, &cargo_config, no_progress)?;\n+\n+        let (host, vfs, _) = load_workspace(workspace, &load_cargo_config)?;\n+        let db = host.raw_database();\n+        let analysis = host.analysis();\n+\n+        let si = StaticIndex::compute(&analysis);\n+\n+        let mut index = scip_types::Index {\n+            metadata: Some(scip_types::Metadata {\n+                version: scip_types::ProtocolVersion::UnspecifiedProtocolVersion.into(),\n+                tool_info: Some(scip_types::ToolInfo {\n+                    name: \"rust-analyzer\".to_owned(),\n+                    version: \"0.1\".to_owned(),\n+                    arguments: vec![],\n+                    ..Default::default()\n+                })\n+                .into(),\n+                project_root: format!(\n+                    \"file://{}\",\n+                    path.normalize()\n+                        .as_os_str()\n+                        .to_str()\n+                        .ok_or(anyhow::anyhow!(\"Unable to normalize project_root path\"))?\n+                        .to_string()\n+                ),\n+                text_document_encoding: scip_types::TextEncoding::UTF8.into(),\n+                ..Default::default()\n+            })\n+            .into(),\n+            ..Default::default()\n+        };\n+\n+        let mut symbols_emitted: HashSet<TokenId> = HashSet::default();\n+        let mut tokens_to_symbol: HashMap<TokenId, String> = HashMap::new();\n+\n+        for file in si.files {\n+            let mut local_count = 0;\n+            let mut new_local_symbol = || {\n+                let new_symbol = scip::types::Symbol::new_local(local_count);\n+                local_count += 1;\n+\n+                new_symbol\n+            };\n+\n+            let StaticIndexedFile { file_id, tokens, .. } = file;\n+            let relative_path = match get_relative_filepath(&vfs, &rootpath, file_id) {\n+                Some(relative_path) => relative_path,\n+                None => continue,\n+            };\n+\n+            let line_index = LineIndex {\n+                index: db.line_index(file_id),\n+                encoding: OffsetEncoding::Utf8,\n+                endings: LineEndings::Unix,\n+            };\n+\n+            let mut doc = scip_types::Document {\n+                relative_path,\n+                language: \"rust\".to_string(),\n+                ..Default::default()\n+            };\n+\n+            tokens.into_iter().for_each(|(range, id)| {\n+                let token = si.tokens.get(id).unwrap();\n+\n+                let mut occurrence = scip_types::Occurrence::default();\n+                occurrence.range = text_range_to_scip_range(&line_index, range);\n+                occurrence.symbol = match tokens_to_symbol.get(&id) {\n+                    Some(symbol) => symbol.clone(),\n+                    None => {\n+                        let symbol = match &token.moniker {\n+                            Some(moniker) => moniker_to_symbol(&moniker),\n+                            None => new_local_symbol(),\n+                        };\n+\n+                        let symbol = scip::symbol::format_symbol(symbol);\n+                        tokens_to_symbol.insert(id, symbol.clone());\n+                        symbol\n+                    }\n+                };\n+\n+                if let Some(def) = token.definition {\n+                    if def.range == range {\n+                        occurrence.symbol_roles |= scip_types::SymbolRole::Definition as i32;\n+                    }\n+\n+                    if !symbols_emitted.contains(&id) {\n+                        symbols_emitted.insert(id);\n+\n+                        let mut symbol_info = scip_types::SymbolInformation::default();\n+                        symbol_info.symbol = occurrence.symbol.clone();\n+                        if let Some(hover) = &token.hover {\n+                            if !hover.markup.as_str().is_empty() {\n+                                symbol_info.documentation = vec![hover.markup.as_str().to_string()];\n+                            }\n+                        }\n+\n+                        doc.symbols.push(symbol_info)\n+                    }\n+                }\n+\n+                doc.occurrences.push(occurrence);\n+            });\n+\n+            if doc.occurrences.is_empty() {\n+                continue;\n+            }\n+\n+            index.documents.push(doc);\n+        }\n+\n+        scip::write_message_to_file(\"index.scip\", index)\n+            .map_err(|err| anyhow::anyhow!(\"Failed to write scip to file: {}\", err))?;\n+\n+        eprintln!(\"Generating SCIP finished {:?}\", now.elapsed());\n+        Ok(())\n+    }\n+}\n+\n+fn get_relative_filepath(\n+    vfs: &vfs::Vfs,\n+    rootpath: &vfs::AbsPathBuf,\n+    file_id: ide::FileId,\n+) -> Option<String> {\n+    Some(vfs.file_path(file_id).as_path()?.strip_prefix(&rootpath)?.as_ref().to_str()?.to_string())\n+}\n+\n+// SCIP Ranges have a (very large) optimization that ranges if they are on the same line\n+// only encode as a vector of [start_line, start_col, end_col].\n+//\n+// This transforms a line index into the optimized SCIP Range.\n+fn text_range_to_scip_range(line_index: &LineIndex, range: TextRange) -> Vec<i32> {\n+    let LineCol { line: start_line, col: start_col } = line_index.index.line_col(range.start());\n+    let LineCol { line: end_line, col: end_col } = line_index.index.line_col(range.end());\n+\n+    if start_line == end_line {\n+        vec![start_line as i32, start_col as i32, end_col as i32]\n+    } else {\n+        vec![start_line as i32, start_col as i32, end_line as i32, end_col as i32]\n+    }\n+}\n+\n+fn new_descriptor_str(\n+    name: &str,\n+    suffix: scip_types::descriptor::Suffix,\n+) -> scip_types::Descriptor {\n+    scip_types::Descriptor {\n+        name: name.to_string(),\n+        disambiguator: \"\".to_string(),\n+        suffix: suffix.into(),\n+        ..Default::default()\n+    }\n+}\n+\n+fn new_descriptor(name: Name, suffix: scip_types::descriptor::Suffix) -> scip_types::Descriptor {\n+    let mut name = name.to_string();\n+    if name.contains(\"'\") {\n+        name = format!(\"`{}`\", name);\n+    }\n+\n+    new_descriptor_str(name.as_str(), suffix)\n+}\n+\n+/// Loosely based on `def_to_moniker`\n+///\n+/// Only returns a Symbol when it's a non-local symbol.\n+///     So if the visibility isn't outside of a document, then it will return None\n+fn moniker_to_symbol(moniker: &MonikerResult) -> scip_types::Symbol {\n+    use scip_types::descriptor::Suffix::*;\n+\n+    let package_name = moniker.package_information.name.clone();\n+    let version = moniker.package_information.version.clone();\n+    let descriptors = moniker\n+        .identifier\n+        .description\n+        .iter()\n+        .map(|desc| {\n+            new_descriptor(\n+                desc.name.clone(),\n+                match desc.desc {\n+                    MonikerDescriptorKind::Namespace => Namespace,\n+                    MonikerDescriptorKind::Type => Type,\n+                    MonikerDescriptorKind::Term => Term,\n+                    MonikerDescriptorKind::Method => Method,\n+                    MonikerDescriptorKind::TypeParameter => TypeParameter,\n+                    MonikerDescriptorKind::Parameter => Parameter,\n+                    MonikerDescriptorKind::Macro => Macro,\n+                    MonikerDescriptorKind::Meta => Meta,\n+                },\n+            )\n+        })\n+        .collect();\n+\n+    scip_types::Symbol {\n+        scheme: \"rust-analyzer\".into(),\n+        package: Some(scip_types::Package {\n+            manager: \"cargo\".to_string(),\n+            name: package_name,\n+            version,\n+            ..Default::default()\n+        })\n+        .into(),\n+        descriptors,\n+        ..Default::default()\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+    use hir::Semantics;\n+    use ide::{AnalysisHost, FilePosition};\n+    use ide_db::defs::IdentClass;\n+    use ide_db::{base_db::fixture::ChangeFixture, helpers::pick_best_token};\n+    use scip::symbol::format_symbol;\n+    use syntax::SyntaxKind::*;\n+    use syntax::{AstNode, T};\n+\n+    fn position(ra_fixture: &str) -> (AnalysisHost, FilePosition) {\n+        let mut host = AnalysisHost::default();\n+        let change_fixture = ChangeFixture::parse(ra_fixture);\n+        host.raw_database_mut().apply_change(change_fixture.change);\n+        let (file_id, range_or_offset) =\n+            change_fixture.file_position.expect(\"expected a marker ($0)\");\n+        let offset = range_or_offset.expect_offset();\n+        (host, FilePosition { file_id, offset })\n+    }\n+\n+    /// If expected == \"\", then assert that there are no symbols (this is basically local symbol)\n+    #[track_caller]\n+    fn check_symbol(ra_fixture: &str, expected: &str) {\n+        let (host, position) = position(ra_fixture);\n+\n+        let FilePosition { file_id, offset } = position;\n+\n+        let db = host.raw_database();\n+        let sema = &Semantics::new(db);\n+        let file = sema.parse(file_id).syntax().clone();\n+        let original_token = pick_best_token(file.token_at_offset(offset), |kind| match kind {\n+            IDENT\n+            | INT_NUMBER\n+            | LIFETIME_IDENT\n+            | T![self]\n+            | T![super]\n+            | T![crate]\n+            | T![Self]\n+            | COMMENT => 2,\n+            kind if kind.is_trivia() => 0,\n+            _ => 1,\n+        })\n+        .expect(\"OK OK\");\n+\n+        let navs = sema\n+            .descend_into_macros(original_token.clone())\n+            .into_iter()\n+            .filter_map(|token| {\n+                IdentClass::classify_token(sema, &token).map(IdentClass::definitions).map(|it| {\n+                    it.into_iter().flat_map(|def| {\n+                        let module = def.module(db).unwrap();\n+                        let current_crate = module.krate();\n+\n+                        match MonikerResult::from_def(sema.db, def, current_crate) {\n+                            Some(moniker_result) => Some(moniker_to_symbol(&moniker_result)),\n+                            None => None,\n+                        }\n+                    })\n+                })\n+            })\n+            .flatten()\n+            .collect::<Vec<_>>();\n+\n+        if expected == \"\" {\n+            assert_eq!(0, navs.len(), \"must have no symbols {:?}\", navs);\n+            return;\n+        }\n+\n+        assert_eq!(1, navs.len(), \"must have one symbol {:?}\", navs);\n+\n+        let res = navs.get(0).unwrap();\n+        let formatted = format_symbol(res.clone());\n+        assert_eq!(formatted, expected);\n+    }\n+\n+    #[test]\n+    fn basic() {\n+        check_symbol(\n+            r#\"\n+//- /lib.rs crate:main deps:foo\n+use foo::example_mod::func;\n+fn main() {\n+    func$0();\n+}\n+//- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+pub mod example_mod {\n+    pub fn func() {}\n+}\n+\"#,\n+            \"rust-analyzer cargo foo 0.1.0 example_mod/func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait() {\n+        check_symbol(\n+            r#\"\n+//- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+pub mod module {\n+    pub trait MyTrait {\n+        pub fn func$0() {}\n+    }\n+}\n+\"#,\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_constant() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            const MY_CONST$0: u8;\n+        }\n+    }\n+    \"#,\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#MY_CONST.\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_type() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            type MyType$0;\n+        }\n+    }\n+    \"#,\n+            // \"foo::module::MyTrait::MyType\",\n+            \"rust-analyzer cargo foo 0.1.0 module/MyTrait#[MyType]\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_trait_impl_function() {\n+        check_symbol(\n+            r#\"\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub trait MyTrait {\n+            pub fn func() {}\n+        }\n+\n+        struct MyStruct {}\n+\n+        impl MyTrait for MyStruct {\n+            pub fn func$0() {}\n+        }\n+    }\n+    \"#,\n+            // \"foo::module::MyStruct::MyTrait::func\",\n+            \"rust-analyzer cargo foo 0.1.0 module/MyStruct#MyTrait#func().\",\n+        );\n+    }\n+\n+    #[test]\n+    fn symbol_for_field() {\n+        check_symbol(\n+            r#\"\n+    //- /lib.rs crate:main deps:foo\n+    use foo::St;\n+    fn main() {\n+        let x = St { a$0: 2 };\n+    }\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub struct St {\n+        pub a: i32,\n+    }\n+    \"#,\n+            \"rust-analyzer cargo foo 0.1.0 St#a.\",\n+        );\n+    }\n+\n+    #[test]\n+    fn local_symbol_for_local() {\n+        check_symbol(\n+            r#\"\n+    //- /lib.rs crate:main deps:foo\n+    use foo::module::func;\n+    fn main() {\n+        func();\n+    }\n+    //- /foo/lib.rs crate:foo@CratesIo:0.1.0,https://a.b/foo.git\n+    pub mod module {\n+        pub fn func() {\n+            let x$0 = 2;\n+        }\n+    }\n+    \"#,\n+            \"\",\n+        );\n+    }\n+}"}]}