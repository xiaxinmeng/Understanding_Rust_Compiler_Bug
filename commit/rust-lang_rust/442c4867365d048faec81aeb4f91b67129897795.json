{"sha": "442c4867365d048faec81aeb4f91b67129897795", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ0MmM0ODY3MzY1ZDA0OGZhZWM4MWFlYjRmOTFiNjcxMjk4OTc3OTU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T19:17:20Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-02-19T19:17:20Z"}, "message": "separate section for doubly-linked list, reword projections intro", "tree": {"sha": "bc065fc042fd55f2ef148c034c9e0f70c45fa069", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bc065fc042fd55f2ef148c034c9e0f70c45fa069"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/442c4867365d048faec81aeb4f91b67129897795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/442c4867365d048faec81aeb4f91b67129897795", "html_url": "https://github.com/rust-lang/rust/commit/442c4867365d048faec81aeb4f91b67129897795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/442c4867365d048faec81aeb4f91b67129897795/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8111b7d30e8c47c339852987d304fa126f1b4a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8111b7d30e8c47c339852987d304fa126f1b4a6", "html_url": "https://github.com/rust-lang/rust/commit/a8111b7d30e8c47c339852987d304fa126f1b4a6"}], "stats": {"total": 76, "additions": 43, "deletions": 33}, "files": [{"sha": "86c28d4a24ae3a97c45c8b5afec664331a73d408", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/442c4867365d048faec81aeb4f91b67129897795/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442c4867365d048faec81aeb4f91b67129897795/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=442c4867365d048faec81aeb4f91b67129897795", "patch": "@@ -611,8 +611,8 @@ unsafe impl<T: ?Sized> Freeze for &mut T {}\n ///\n /// `Unpin` has no consequence at all for non-pinned data. In particular,\n /// [`mem::replace`] happily moves `!Unpin` data. However, you cannot use\n-/// [`mem::replace`] on data wrapped inside a [`Pin`], and *that* is what makes\n-/// this system work.\n+/// [`mem::replace`] on data wrapped inside a [`Pin`] because you cannot get the\n+/// `&mut T` you need for that, and *that* is what makes this system work.\n ///\n /// So this, for example, can only be done on types implementing `Unpin`:\n ///"}, {"sha": "8317f20e0a41d42a64d0077e4056e2fd2df0f742", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 41, "deletions": 31, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/442c4867365d048faec81aeb4f91b67129897795/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/442c4867365d048faec81aeb4f91b67129897795/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=442c4867365d048faec81aeb4f91b67129897795", "patch": "@@ -25,9 +25,10 @@\n //! values.\n //!\n //! It is worth reiterating that [`Pin`] does *not* change the fact that a Rust compiler\n-//! considers all types movable.  [`mem::swap`] remains callable for any `T`.  Instead, `Pin`\n+//! considers all types movable.  [`mem::swap`] remains callable for any `T`. Instead, `Pin`\n //! prevents certain *values* (pointed to by pointers wrapped in `Pin`) from being\n-//! moved by making it impossible to call methods like [`mem::swap`] on them.\n+//! moved by making it impossible to call methods like [`mem::swap`] on them. These\n+//! methods all need an `&mut T`, and you cannot obtain that from a `Pin`.\n //!\n //! # `Unpin`\n //!\n@@ -42,7 +43,7 @@\n //! `Unpin` has no effect on the behavior of `Pin<Box<T>>` (here, `T` is the\n //! pointed-to type).\n //!\n-//! # Examples\n+//! # Example: Self-referential struct\n //!\n //! ```rust\n //! use std::pin::Pin;\n@@ -97,6 +98,21 @@\n //! // std::mem::swap(&mut *still_unmoved, &mut *new_unmoved);\n //! ```\n //!\n+//! # Example: intrusive doubly-linked list\n+//!\n+//! In an intrusive doubly-linked list, the collection does not actually allocate\n+//! the memory for the elements itself. Allocation is controlled by the clients,\n+//! and elements can live on a stack frame that lives shorter than the collection does.\n+//!\n+//! To make this work, every element has pointers to its predecessor and successor in\n+//! the list. Element can only be added when they are pinned, because moving the elements\n+//! around would invalidate the pointers. Moreover, the `Drop` implementation of a linked\n+//! list element will patch the pointers of its predecessor and successor to remove itself\n+//! from the list.\n+//!\n+//! To make this work, it is crucial taht we can actually rely on `drop` being called.\n+//! And, in fact, this is a guarantee that `Pin` provides.\n+//!\n //! # `Drop` guarantee\n //!\n //! The purpose of pinning is to be able to rely on the placement of some data in memory.\n@@ -108,29 +124,25 @@\n //! replacing a `Some(v)` by `None`, or calling `Vec::set_len` to \"kill\" some elements\n //! off of a vector.\n //!\n-//! The purpose of this guarantee is to allow data structures that store pointers\n-//! to pinned data. For example, in an intrusive doubly-linked list, every element\n-//! has pointers to its predecessor and successor in the list. Every element\n-//! must also be pinned, because moving the elements around would invalidate the pointers.\n-//! Moreover, the `Drop` implementation of a linked list element will patch the pointers\n-//! of its predecessor and successor to remove itself from the list. Clearly, if an element\n-//! could be deallocated or overwritten without calling `drop`, the pointers into it\n+//! This is exactly the kind of guarantee that the intrusive linked list from the previous\n+//! section needs to function correctly. Clearly, if an element\n+//! could be deallocated or otherwise invalidated without calling `drop`, the pointers into it\n //! from its neighbouring elements would become invalid, which would break the data structure.\n //!\n //! Notice that this guarantee does *not* mean that memory does not leak! It is still\n //! completely okay not to ever call `drop` on a pinned element (e.g., you can still\n-//! call [`mem::forget`] on a `Pin<Box<T>>`). However you may *not* then free or reuse the storage\n-//! without calling `drop`.\n+//! call [`mem::forget`] on a `Pin<Box<T>>`). In the example of the doubly-linked\n+//! list, that element would just stay in the list. However you may not free or reuse the storage\n+//! *without calling `drop`*.\n //!\n //! # `Drop` implementation\n //!\n-//! If your type relies on pinning (for example, because it contains internal\n-//! references, or because you are implementing something like the intrusive\n-//! doubly-linked list mentioned in the previous section), you have to be careful\n+//! If your type uses pinning (such as the two examples above), you have to be careful\n //! when implementing `Drop`. The `drop` function takes `&mut self`, but this\n //! is called *even if your type was previously pinned*! It is as if the\n-//! compiler automatically called `get_unchecked_mut`. This can never cause\n-//! a problem in safe code because implementing a type that relies on pinning\n+//! compiler automatically called `get_unchecked_mut`.\n+//!\n+//! This can never cause a problem in safe code because implementing a type that relies on pinning\n //! requires unsafe code, but be aware that deciding to make use of pinning\n //! in your type (for example by implementing some operation on `Pin<&[mut] Self>`)\n //! has consequences for your `Drop` implementation as well: if an element\n@@ -139,38 +151,36 @@\n //!\n //! # Projections and Structural Pinning\n //!\n-//! One interesting question arises when considering pinning and \"container types\" --\n-//! types such as `Vec`, `Box`, or `RefCell`; types that serve as wrappers\n-//! around other types.  When can such a type have a \"projection\" operation, an\n-//! operation with type `fn(Pin<&[mut] Container<T>>) -> Pin<&[mut] T>`?\n-//! This does not just apply to generic container types, even for normal structs\n-//! the question arises whether `fn(Pin<&[mut] Struct>) -> Pin<&[mut] Field>`\n-//! is an operation that can be soundly added to the API.\n+//! One interesting question arises when considering the interaction of pinning and\n+//! the fields of a struct. When can a struct have a \"projection operation\", i.e.,\n+//! an operation with type `fn(Pin<&[mut] Struct>) -> Pin<&[mut] Field>`?\n+//! In a similar vein, when can a container type (such as `Vec`, `Box`, or `RefCell`)\n+//! have an operation with type `fn(Pin<&[mut] Container<T>>) -> Pin<&[mut] T>`?\n //!\n //! This question is closely related to the question of whether pinning is \"structural\":\n-//! when you have pinned a container, have you pinned its contents? Adding a\n+//! when you have pinned a wrapper type, have you pinned its contents? Adding a\n //! projection to the API answers that question with a \"yes\" by offering pinned access\n //! to the contents.\n //!\n //! In general, as the author of a type you get to decide whether pinning is structural, and\n //! whether projections are provided. However, there are a couple requirements to be\n //! upheld when adding projection operations:\n //!\n-//! 1. The container must only be [`Unpin`] if all the fields one can project to are\n+//! 1. The wrapper must only be [`Unpin`] if all the fields one can project to are\n //!    `Unpin`. This is the default, but `Unpin` is a safe trait, so as the author of\n-//!    the container it is your responsibility *not* to add something like\n+//!    the wrapper it is your responsibility *not* to add something like\n //!    `impl<T> Unpin for Container<T>`. (Notice that adding a projection operation\n //!    requires unsafe code, so the fact that `Unpin` is a safe trait  does not break\n //!    the principle that you only have to worry about any of this if you use `unsafe`.)\n-//! 2. The destructor of the container must not move out of its argument. This is the exact\n+//! 2. The destructor of the wrapper must not move out of its argument. This is the exact\n //!    point that was raised in the [previous section][drop-impl]: `drop` takes `&mut self`,\n-//!    but the container (and hence its fields) might have been pinned before.\n+//!    but the wrapper (and hence its fields) might have been pinned before.\n //!    You have to guarantee that you do not move a field inside your `Drop` implementation.\n-//! 3. Your container type must *not* be `#[repr(packed)]`. Packed structs have their fields\n+//! 3. Your wrapper type must *not* be `#[repr(packed)]`. Packed structs have their fields\n //!    moved around when they are dropped to properly align them, which is in conflict with\n //!    claiming that the fields are pinned when your struct is.\n //! 4. You must make sure that you uphold the [`Drop` guarantee][drop-guarantee]:\n-//!    once your container is pinned, the memory that contains the\n+//!    once your wrapper is pinned, the memory that contains the\n //!    content is not overwritten or deallocated without calling the content's destructors.\n //!    This can be tricky, as witnessed by `VecDeque`: the destructor of `VecDeque` can fail\n //!    to call `drop` on all elements if one of the destructors panics. This violates the"}]}