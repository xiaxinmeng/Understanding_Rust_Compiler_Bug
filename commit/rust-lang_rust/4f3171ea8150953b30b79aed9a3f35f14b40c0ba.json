{"sha": "4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRmMzE3MWVhODE1MDk1M2IzMGI3OWFlZDlhM2YzNWYxNGI0MGMwYmE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-01-06T21:04:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@pobox.com", "date": "2012-01-06T21:04:49Z"}, "message": "Merge pull request #1450 from erickt/master\n\nadding some misc functions and some functions just for [u8]", "tree": {"sha": "cc7b4ac9ba0116b14c7c6d69a9ea04cc24fbc1cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc7b4ac9ba0116b14c7c6d69a9ea04cc24fbc1cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "html_url": "https://github.com/rust-lang/rust/commit/4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b00bac540ad4034906db329712d9b46e2d05719", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b00bac540ad4034906db329712d9b46e2d05719", "html_url": "https://github.com/rust-lang/rust/commit/7b00bac540ad4034906db329712d9b46e2d05719"}, {"sha": "6cfc196d424d50e39c3f697b213a62ff8df9979b", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cfc196d424d50e39c3f697b213a62ff8df9979b", "html_url": "https://github.com/rust-lang/rust/commit/6cfc196d424d50e39c3f697b213a62ff8df9979b"}], "stats": {"total": 234, "additions": 214, "deletions": 20}, "files": [{"sha": "569d59b981aeffe7969a022e018fda4c5e0ad3ae", "filename": "src/libcore/u32.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibcore%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibcore%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu32.rs?ref=4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "patch": "@@ -16,6 +16,49 @@ Return the maximal value for a u32\n */\n const max_value: u32 = 0xffff_ffffu32;\n \n+/* Function: add */\n+pure fn add(x: u32, y: u32) -> u32 { ret x + y; }\n+\n+/* Function: sub */\n+pure fn sub(x: u32, y: u32) -> u32 { ret x - y; }\n+\n+/* Function: mul */\n+pure fn mul(x: u32, y: u32) -> u32 { ret x * y; }\n+\n+/* Function: div */\n+pure fn div(x: u32, y: u32) -> u32 { ret x / y; }\n+\n+/* Function: rem */\n+pure fn rem(x: u32, y: u32) -> u32 { ret x % y; }\n+\n+/* Predicate: lt */\n+pure fn lt(x: u32, y: u32) -> bool { ret x < y; }\n+\n+/* Predicate: le */\n+pure fn le(x: u32, y: u32) -> bool { ret x <= y; }\n+\n+/* Predicate: eq */\n+pure fn eq(x: u32, y: u32) -> bool { ret x == y; }\n+\n+/* Predicate: ne */\n+pure fn ne(x: u32, y: u32) -> bool { ret x != y; }\n+\n+/* Predicate: ge */\n+pure fn ge(x: u32, y: u32) -> bool { ret x >= y; }\n+\n+/* Predicate: gt */\n+pure fn gt(x: u32, y: u32) -> bool { ret x > y; }\n+\n+/*\n+Function: range\n+\n+Iterate over the range [`lo`..`hi`)\n+*/\n+fn range(lo: u32, hi: u32, it: block(u32)) {\n+    let i = lo;\n+    while i < hi { it(i); i += 1u32; }\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "bce99f02b87feb2deba74eafccaeec0888ecef9d", "filename": "src/libcore/u64.rs", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibcore%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibcore%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fu64.rs?ref=4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "patch": "@@ -16,6 +16,49 @@ Return the maximal value for a u64\n */\n const max_value: u64 = 18446744073709551615u64;\n \n+/* Function: add */\n+pure fn add(x: u64, y: u64) -> u64 { ret x + y; }\n+\n+/* Function: sub */\n+pure fn sub(x: u64, y: u64) -> u64 { ret x - y; }\n+\n+/* Function: mul */\n+pure fn mul(x: u64, y: u64) -> u64 { ret x * y; }\n+\n+/* Function: div */\n+pure fn div(x: u64, y: u64) -> u64 { ret x / y; }\n+\n+/* Function: rem */\n+pure fn rem(x: u64, y: u64) -> u64 { ret x % y; }\n+\n+/* Predicate: lt */\n+pure fn lt(x: u64, y: u64) -> bool { ret x < y; }\n+\n+/* Predicate: le */\n+pure fn le(x: u64, y: u64) -> bool { ret x <= y; }\n+\n+/* Predicate: eq */\n+pure fn eq(x: u64, y: u64) -> bool { ret x == y; }\n+\n+/* Predicate: ne */\n+pure fn ne(x: u64, y: u64) -> bool { ret x != y; }\n+\n+/* Predicate: ge */\n+pure fn ge(x: u64, y: u64) -> bool { ret x >= y; }\n+\n+/* Predicate: gt */\n+pure fn gt(x: u64, y: u64) -> bool { ret x > y; }\n+\n+/*\n+Function: range\n+\n+Iterate over the range [`lo`..`hi`)\n+*/\n+fn range(lo: u64, hi: u64, it: block(u64)) {\n+    let i = lo;\n+    while i < hi { it(i); i += 1u64; }\n+}\n+\n /*\n Function: to_str\n "}, {"sha": "ee28c07de3d796e1f309b9e6fe0ac2ec799c7570", "filename": "src/libcore/uint.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibcore%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibcore%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fuint.rs?ref=4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "patch": "@@ -103,6 +103,13 @@ pure fn ge(x: uint, y: uint) -> bool { ret x >= y; }\n /* Predicate: gt */\n pure fn gt(x: uint, y: uint) -> bool { ret x > y; }\n \n+/*\n+Function: hash\n+\n+Produce a uint suitable for use in a hash table\n+*/\n+fn hash(x: uint) -> uint { ret x; }\n+\n /*\n Function: range\n "}, {"sha": "66850235e1e4050c0eb88687ee17f030e8e0031c", "filename": "src/libcore/vec.rs", "status": "modified", "additions": 94, "deletions": 1, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibcore%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibcore%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fvec.rs?ref=4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "patch": "@@ -719,7 +719,7 @@ Function: enum_chars\n \n Returns a vector containing a range of chars\n */\n-fn enum_chars(start: u8, end: u8) : u8::le(start, end) -> [char] {\n+fn enum_chars(start: u8, end: u8) : ::u8::le(start, end) -> [char] {\n     let i = start;\n     let r = [];\n     while i <= end { r += [i as char]; i += 1u as u8; }\n@@ -889,6 +889,99 @@ mod unsafe {\n     }\n }\n \n+/*\n+Module: u8\n+*/\n+mod u8 {\n+    export cmp;\n+    export lt, le, eq, ne, ge, gt;\n+    export hash;\n+\n+    #[nolink]\n+    #[abi = \"cdecl\"]\n+    native mod libc {\n+        fn memcmp(s1: *u8, s2: *u8, n: ctypes::size_t) -> ctypes::c_int;\n+    }\n+\n+    /*\n+    Function cmp\n+\n+    Bytewise string comparison\n+    */\n+    pure fn cmp(&&a: [u8], &&b: [u8]) -> int unsafe {\n+        let a_len = len(a);\n+        let b_len = len(b);\n+        let n = math::min(a_len, b_len) as ctypes::size_t;\n+        let r = libc::memcmp(to_ptr(a), to_ptr(b), n) as int;\n+\n+        if r != 0 { r } else {\n+            if a_len == b_len {\n+                0\n+            } else if a_len < b_len {\n+                -1\n+            } else {\n+                1\n+            }\n+        }\n+    }\n+\n+    /*\n+    Function: lt\n+\n+    Bytewise less than or equal\n+    */\n+    pure fn lt(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) < 0 }\n+\n+    /*\n+    Function: le\n+\n+    Bytewise less than or equal\n+    */\n+    pure fn le(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) <= 0 }\n+\n+    /*\n+    Function: eq\n+\n+    Bytewise equality\n+    */\n+    pure fn eq(&&a: [u8], &&b: [u8]) -> bool unsafe { cmp(a, b) == 0 }\n+\n+    /*\n+    Function: ne\n+\n+    Bytewise inequality\n+    */\n+    pure fn ne(&&a: [u8], &&b: [u8]) -> bool unsafe { cmp(a, b) != 0 }\n+\n+    /*\n+    Function: ge\n+\n+    Bytewise greater than or equal\n+    */\n+    pure fn ge(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) >= 0 }\n+\n+    /*\n+    Function: gt\n+\n+    Bytewise greater than\n+    */\n+    pure fn gt(&&a: [u8], &&b: [u8]) -> bool { cmp(a, b) > 0 }\n+\n+    /*\n+    Function: hash\n+\n+    String hash function\n+    */\n+    fn hash(&&s: [u8]) -> uint {\n+        // djb hash.\n+        // FIXME: replace with murmur.\n+\n+        let u: uint = 5381u;\n+        vec::iter(s, { |c| u *= 33u; u += c as uint; });\n+        ret u;\n+    }\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "949c8d007a764430416b1802114e7e5b3b630bcd", "filename": "src/libstd/c_vec.rs", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibstd%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibstd%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_vec.rs?ref=4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "patch": "@@ -31,7 +31,7 @@ taken to ensure that a reference to the c_vec::t is still held if needed.\n export t;\n export create, create_with_dtor;\n export get, set;\n-export size;\n+export len;\n export ptr;\n \n /*\n@@ -43,7 +43,7 @@ export ptr;\n  */\n \n tag t<T> {\n-    t({ base: *mutable T, size: uint, rsrc: @dtor_res});\n+    t({ base: *mutable T, len: uint, rsrc: @dtor_res});\n }\n \n resource dtor_res(dtor: option::t<fn@()>) {\n@@ -60,37 +60,37 @@ resource dtor_res(dtor: option::t<fn@()>) {\n /*\n Function: create\n \n-Create a c_vec::t from a native buffer with a given size.\n+Create a c_vec::t from a native buffer with a given length.\n \n Parameters:\n \n base - A native pointer to a buffer\n-size - The number of elements in the buffer\n+len - The number of elements in the buffer\n */\n-unsafe fn create<T>(base: *mutable T, size: uint) -> t<T> {\n+unsafe fn create<T>(base: *mutable T, len: uint) -> t<T> {\n     ret t({base: base,\n-           size: size,\n+           len: len,\n            rsrc: @dtor_res(option::none)\n           });\n }\n \n /*\n Function: create_with_dtor\n \n-Create a c_vec::t from a native buffer, with a given size,\n+Create a c_vec::t from a native buffer, with a given length,\n and a function to run upon destruction.\n \n Parameters:\n \n base - A native pointer to a buffer\n-size - The number of elements in the buffer\n+len - The number of elements in the buffer\n dtor - A function to run when the value is destructed, useful\n        for freeing the buffer, etc.\n */\n-unsafe fn create_with_dtor<T>(base: *mutable T, size: uint, dtor: fn@())\n+unsafe fn create_with_dtor<T>(base: *mutable T, len: uint, dtor: fn@())\n   -> t<T> {\n     ret t({base: base,\n-           size: size,\n+           len: len,\n            rsrc: @dtor_res(option::some(dtor))\n           });\n }\n@@ -109,7 +109,7 @@ Failure:\n If `ofs` is greater or equal to the length of the vector\n */\n fn get<T: copy>(t: t<T>, ofs: uint) -> T {\n-    assert ofs < (*t).size;\n+    assert ofs < len(t);\n     ret unsafe { *ptr::mut_offset((*t).base, ofs) };\n }\n \n@@ -123,22 +123,21 @@ Failure:\n If `ofs` is greater or equal to the length of the vector\n */\n fn set<T: copy>(t: t<T>, ofs: uint, v: T) {\n-    assert ofs < (*t).size;\n+    assert ofs < len(t);\n     unsafe { *ptr::mut_offset((*t).base, ofs) = v };\n }\n \n /*\n  Section: Elimination forms\n  */\n \n-// FIXME: Rename to len\n /*\n-Function: size\n+Function: len\n \n Returns the length of the vector\n */\n-fn size<T>(t: t<T>) -> uint {\n-    ret (*t).size;\n+fn len<T>(t: t<T>) -> uint {\n+    ret (*t).len;\n }\n \n /*"}, {"sha": "727d32ef65a24b54cc0902bc8225eb418005721d", "filename": "src/libstd/map.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibstd%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Flibstd%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmap.rs?ref=4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "patch": "@@ -378,13 +378,22 @@ fn new_str_hash<V: copy>() -> hashmap<str, V> {\n     ret mk_hashmap(str::hash, str::eq);\n }\n \n+/*\n+Function: new_bytes_hash\n+\n+Construct a hashmap for byte string keys\n+*/\n+fn new_bytes_hash<V: copy>() -> hashmap<[u8], V> {\n+    ret mk_hashmap(vec::u8::hash, vec::u8::eq);\n+}\n+\n /*\n Function: new_int_hash\n \n Construct a hashmap for int keys\n */\n fn new_int_hash<V: copy>() -> hashmap<int, V> {\n-    fn hash_int(&&x: int) -> uint { ret x as uint; }\n+    fn hash_int(&&x: int) -> uint { int::hash(x) }\n     fn eq_int(&&a: int, &&b: int) -> bool { ret a == b; }\n     ret mk_hashmap(hash_int, eq_int);\n }\n@@ -395,7 +404,7 @@ Function: new_uint_hash\n Construct a hashmap for uint keys\n */\n fn new_uint_hash<V: copy>() -> hashmap<uint, V> {\n-    fn hash_uint(&&x: uint) -> uint { ret x; }\n+    fn hash_uint(&&x: uint) -> uint { uint::hash(x) }\n     fn eq_uint(&&a: uint, &&b: uint) -> bool { ret a == b; }\n     ret mk_hashmap(hash_uint, eq_uint);\n }"}, {"sha": "26a67e03f6349dc7933cc8965359182d048c641e", "filename": "src/test/stdtest/c_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Ftest%2Fstdtest%2Fc_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4f3171ea8150953b30b79aed9a3f35f14b40c0ba/src%2Ftest%2Fstdtest%2Fc_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fstdtest%2Fc_vec.rs?ref=4f3171ea8150953b30b79aed9a3f35f14b40c0ba", "patch": "@@ -28,7 +28,7 @@ fn test_basic() {\n     set(cv, 4u, 9u8);\n     assert get(cv, 3u) == 8u8;\n     assert get(cv, 4u) == 9u8;\n-    assert size(cv) == 16u;\n+    assert len(cv) == 16u;\n }\n \n #[test]"}]}