{"sha": "64f6c00772321324d77dfd8a0ee708fbb0d9a277", "node_id": "C_kwDOAAsO6NoAKDY0ZjZjMDA3NzIzMjEzMjRkNzdkZmQ4YTBlZTcwOGZiYjBkOWEyNzc", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-06-16T09:16:15Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-06-16T09:16:15Z"}, "message": "Rollup merge of #112443 - compiler-errors:next-solver-opportunistically-resolve-regions, r=lcnr\n\nOpportunistically resolve regions in new solver\n\nUse `opportunistic_resolve_var` during canonicalization to collapse some regions.\n\nWe have to start using `CanonicalVarValues::is_identity_modulo_regions`. We also have to modify that function to consider responses like `['static, ^0, '^1, ^2]` to be an \"identity\" response, since because we opportunistically resolve regions, there's no longer a 1:1 mapping between canonical var values and bound var indices in the response...\n\nThere's one nasty side-effect -- one test (`tests/ui/dyn-star/param-env-infer.rs`) starts to ICE because the certainty goes from `Yes` to `Maybe(Overflow)`... Not exactly sure why, though? Putting this up for discussion/investigation.\n\nr? ```@lcnr```", "tree": {"sha": "bf5761fe7042f156c7b39836c99faeee00c64907", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bf5761fe7042f156c7b39836c99faeee00c64907"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64f6c00772321324d77dfd8a0ee708fbb0d9a277", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkjChfCRBK7hj4Ov3rIwAAywkIAIBfeWaKs2BiU8BszVEDE9Mh\nBJ9A9D/TZ4dp14sNWMcH4X+mmWBi8dPrPkpHigkJNNeLneJaho0u8TYvF7+xvtUb\npqgIXFbdLbbMjozC8l0SDUbjrKpAu03jNt1R32EC61ey/G8P69ff/bDuDSde3P0W\ny7tak9LyA+uXDNVA87B+3jv45EjT5Sj/ea67vUr4JSOFhn6YUVKdd/hdt6mBekId\nSRqk/Y7PD9Axut4XZVcGxuQL53H5IE3XDkRSWkp43p9KzMzaWwjtknqS0LALfvax\nSb/vj6ntcDrt2hswj4FdJs0jrD7x+yQniyhcMdqgFKBLhZYMtm7Uq6p9QSDwMZc=\n=HQtT\n-----END PGP SIGNATURE-----\n", "payload": "tree bf5761fe7042f156c7b39836c99faeee00c64907\nparent b41db841e8fe01af6b1f2d17a25a2704950b937f\nparent 01377e8064a5b3d987b177c16e18da4bffec03a4\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1686906975 +0530\ncommitter GitHub <noreply@github.com> 1686906975 +0530\n\nRollup merge of #112443 - compiler-errors:next-solver-opportunistically-resolve-regions, r=lcnr\n\nOpportunistically resolve regions in new solver\n\nUse `opportunistic_resolve_var` during canonicalization to collapse some regions.\n\nWe have to start using `CanonicalVarValues::is_identity_modulo_regions`. We also have to modify that function to consider responses like `['static, ^0, '^1, ^2]` to be an \"identity\" response, since because we opportunistically resolve regions, there's no longer a 1:1 mapping between canonical var values and bound var indices in the response...\n\nThere's one nasty side-effect -- one test (`tests/ui/dyn-star/param-env-infer.rs`) starts to ICE because the certainty goes from `Yes` to `Maybe(Overflow)`... Not exactly sure why, though? Putting this up for discussion/investigation.\n\nr? ```@lcnr```\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64f6c00772321324d77dfd8a0ee708fbb0d9a277", "html_url": "https://github.com/rust-lang/rust/commit/64f6c00772321324d77dfd8a0ee708fbb0d9a277", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64f6c00772321324d77dfd8a0ee708fbb0d9a277/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b41db841e8fe01af6b1f2d17a25a2704950b937f", "url": "https://api.github.com/repos/rust-lang/rust/commits/b41db841e8fe01af6b1f2d17a25a2704950b937f", "html_url": "https://github.com/rust-lang/rust/commit/b41db841e8fe01af6b1f2d17a25a2704950b937f"}, {"sha": "01377e8064a5b3d987b177c16e18da4bffec03a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/01377e8064a5b3d987b177c16e18da4bffec03a4", "html_url": "https://github.com/rust-lang/rust/commit/01377e8064a5b3d987b177c16e18da4bffec03a4"}], "stats": {"total": 86, "additions": 75, "deletions": 11}, "files": [{"sha": "1b19ed9ad148b1d090d440ee39ecc7036400be8d", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 33, "deletions": 8, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/64f6c00772321324d77dfd8a0ee708fbb0d9a277/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f6c00772321324d77dfd8a0ee708fbb0d9a277/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=64f6c00772321324d77dfd8a0ee708fbb0d9a277", "patch": "@@ -82,15 +82,40 @@ impl CanonicalVarValues<'_> {\n     }\n \n     pub fn is_identity_modulo_regions(&self) -> bool {\n-        self.var_values.iter().enumerate().all(|(bv, arg)| match arg.unpack() {\n-            ty::GenericArgKind::Lifetime(_) => true,\n-            ty::GenericArgKind::Type(ty) => {\n-                matches!(*ty.kind(), ty::Bound(ty::INNERMOST, bt) if bt.var.as_usize() == bv)\n-            }\n-            ty::GenericArgKind::Const(ct) => {\n-                matches!(ct.kind(), ty::ConstKind::Bound(ty::INNERMOST, bc) if bc.as_usize() == bv)\n+        let mut var = ty::BoundVar::from_u32(0);\n+        for arg in self.var_values {\n+            match arg.unpack() {\n+                ty::GenericArgKind::Lifetime(r) => {\n+                    if let ty::ReLateBound(ty::INNERMOST, br) = *r\n+                        && var == br.var\n+                    {\n+                        var = var + 1;\n+                    } else {\n+                        // It's ok if this region var isn't unique\n+                    }\n+                },\n+                ty::GenericArgKind::Type(ty) => {\n+                    if let ty::Bound(ty::INNERMOST, bt) = *ty.kind()\n+                        && var == bt.var\n+                    {\n+                        var = var + 1;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n+                ty::GenericArgKind::Const(ct) => {\n+                    if let ty::ConstKind::Bound(ty::INNERMOST, bc) = ct.kind()\n+                        && var == bc\n+                    {\n+                        var = var + 1;\n+                    } else {\n+                        return false;\n+                    }\n+                }\n             }\n-        })\n+        }\n+\n+        true\n     }\n }\n "}, {"sha": "05248cb9d17823e60504be327677e8b06ec0c50f", "filename": "compiler/rustc_trait_selection/src/solve/canonicalize.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/64f6c00772321324d77dfd8a0ee708fbb0d9a277/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f6c00772321324d77dfd8a0ee708fbb0d9a277/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fcanonicalize.rs?ref=64f6c00772321324d77dfd8a0ee708fbb0d9a277", "patch": "@@ -208,8 +208,25 @@ impl<'tcx> TypeFolder<TyCtxt<'tcx>> for Canonicalizer<'_, 'tcx> {\n         t\n     }\n \n-    fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        let r = self.infcx.shallow_resolve(r);\n+    fn fold_region(&mut self, mut r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n+        match self.canonicalize_mode {\n+            CanonicalizeMode::Input => {\n+                // Don't resolve infer vars in input, since it affects\n+                // caching and may cause trait selection bugs which rely\n+                // on regions to be equal.\n+            }\n+            CanonicalizeMode::Response { .. } => {\n+                if let ty::ReVar(vid) = *r {\n+                    r = self\n+                        .infcx\n+                        .inner\n+                        .borrow_mut()\n+                        .unwrap_region_constraints()\n+                        .opportunistic_resolve_var(self.infcx.tcx, vid);\n+                }\n+            }\n+        }\n+\n         let kind = match *r {\n             ty::ReLateBound(..) => return r,\n "}, {"sha": "8592fc164d04962b4e87eca12c802cccc33f7cd7", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/64f6c00772321324d77dfd8a0ee708fbb0d9a277/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f6c00772321324d77dfd8a0ee708fbb0d9a277/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=64f6c00772321324d77dfd8a0ee708fbb0d9a277", "patch": "@@ -263,7 +263,10 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             let (_orig_values, canonical_goal) = self.canonicalize_goal(goal);\n             let new_canonical_response =\n                 EvalCtxt::evaluate_canonical_goal(self.tcx(), self.search_graph, canonical_goal)?;\n-            if !new_canonical_response.value.var_values.is_identity() {\n+            // We only check for modulo regions as we convert all regions in\n+            // the input to new existentials, even if they're expected to be\n+            // `'static` or a placeholder region.\n+            if !new_canonical_response.value.var_values.is_identity_modulo_regions() {\n                 bug!(\n                     \"unstable result: re-canonicalized goal={canonical_goal:#?} \\\n                     first_response={canonical_response:#?} \\"}, {"sha": "2610789cd485acbbf2115a39b1c091a08df106f9", "filename": "tests/ui/traits/new-solver/opportunistic-region-resolve.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/64f6c00772321324d77dfd8a0ee708fbb0d9a277/tests%2Fui%2Ftraits%2Fnew-solver%2Fopportunistic-region-resolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64f6c00772321324d77dfd8a0ee708fbb0d9a277/tests%2Fui%2Ftraits%2Fnew-solver%2Fopportunistic-region-resolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fopportunistic-region-resolve.rs?ref=64f6c00772321324d77dfd8a0ee708fbb0d9a277", "patch": "@@ -0,0 +1,19 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_coinductive]\n+trait Trait {}\n+\n+#[rustc_coinductive]\n+trait Indirect {}\n+impl<T: Trait + ?Sized> Indirect for T {}\n+\n+impl<'a> Trait for &'a () where &'a (): Indirect {}\n+\n+fn impls_trait<T: Trait>() {}\n+\n+fn main() {\n+    impls_trait::<&'static ()>();\n+}"}]}