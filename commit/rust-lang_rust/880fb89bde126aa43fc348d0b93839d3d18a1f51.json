{"sha": "880fb89bde126aa43fc348d0b93839d3d18a1f51", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg4MGZiODliZGUxMjZhYTQzZmMzNDhkMGI5MzgzOWQzZDE4YTFmNTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-25T04:28:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-25T04:28:23Z"}, "message": "Auto merge of #22512 - nikomatsakis:issue-20300-where-clause-not-bounds, r=nikomatsakis\n\nThis is a fix for #20300 though as a side-sweep it fixes a number of stack overflows because it integrates cycle detection into the conversion process. I didn't go through and retest everything.\r\n\r\nThe tricky part here is that in some cases we have to go find the information we need from the AST -- we can't use the converted form of the where-clauses because we often have to handle something like `T::Item` *while converting the where-clauses themselves*. Since this is also not a fixed-point process we can't just try and keep trying to find the best order. So instead I modified the `AstConv` interface to allow you to request the bounds for a type parameter; we'll then do a secondary scan of the where-clauses to figure out what we need. This may create a cycle in some cases, but we have code to catch that.\r\n\r\nAnother approach that is NOT taken by this PR would be to \"convert\" `T::Item` into a form that does not specify what trait it's using. This then kind of defers the problem of picking the trait till later. That might be a good idea, but it would make normalization and everything else much harder, so I'm holding off on that (and hoping to find a better way for handling things like `i32::T`).\r\n\r\nThis PR also removes \"most of\" the `bounds` struct from `TypeParameterDef`. Still a little ways to go before `ParamBounds` can be removed entirely -- it's used for supertraits, for example (though those really ought to be converted, I think, to a call to `get_type_parameter_bounds` on `Self` from within the trait definition).\r\n\r\ncc @jroesch \r\n\r\nFixes #20300", "tree": {"sha": "8bd3d758b1ae6a1f780142109a0e92c55c31e4d6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8bd3d758b1ae6a1f780142109a0e92c55c31e4d6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/880fb89bde126aa43fc348d0b93839d3d18a1f51", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/880fb89bde126aa43fc348d0b93839d3d18a1f51", "html_url": "https://github.com/rust-lang/rust/commit/880fb89bde126aa43fc348d0b93839d3d18a1f51", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/880fb89bde126aa43fc348d0b93839d3d18a1f51/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad04cce61c366968098e2adc8594e21e91c578e0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad04cce61c366968098e2adc8594e21e91c578e0", "html_url": "https://github.com/rust-lang/rust/commit/ad04cce61c366968098e2adc8594e21e91c578e0"}, {"sha": "1ef3598ed9da3222467d373bc02973e8ecffbaad", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ef3598ed9da3222467d373bc02973e8ecffbaad", "html_url": "https://github.com/rust-lang/rust/commit/1ef3598ed9da3222467d373bc02973e8ecffbaad"}], "stats": {"total": 1483, "additions": 1066, "deletions": 417}, "files": [{"sha": "baecfb7eb22c5ec6cb95898ee8ca45f60e93f003", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -822,7 +822,6 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n     assert_eq!(next(st), '|');\n     let index = parse_u32(st);\n     assert_eq!(next(st), '|');\n-    let bounds = parse_bounds_(st, conv);\n     let default = parse_opt(st, |st| parse_ty_(st, conv));\n     let object_lifetime_default = parse_object_lifetime_default(st, conv);\n \n@@ -831,7 +830,6 @@ fn parse_type_param_def_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n         def_id: def_id,\n         space: space,\n         index: index,\n-        bounds: bounds,\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n     }\n@@ -924,18 +922,18 @@ fn parse_bounds_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n {\n     let builtin_bounds = parse_builtin_bounds_(st, conv);\n \n+    let region_bounds = parse_region_bounds_(st, conv);\n+\n     let mut param_bounds = ty::ParamBounds {\n-        region_bounds: Vec::new(),\n+        region_bounds: region_bounds,\n         builtin_bounds: builtin_bounds,\n         trait_bounds: Vec::new(),\n         projection_bounds: Vec::new(),\n     };\n+\n+\n     loop {\n         match next(st) {\n-            'R' => {\n-                param_bounds.region_bounds.push(\n-                    parse_region_(st, conv));\n-            }\n             'I' => {\n                 param_bounds.trait_bounds.push(\n                     ty::Binder(parse_trait_ref_(st, conv)));\n@@ -953,3 +951,18 @@ fn parse_bounds_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n         }\n     }\n }\n+\n+fn parse_region_bounds_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F)\n+                              -> Vec<ty::Region> where\n+    F: FnMut(DefIdSource, ast::DefId) -> ast::DefId,\n+{\n+    let mut region_bounds = Vec::new();\n+    loop {\n+        match next(st) {\n+            'R' => { region_bounds.push(parse_region_(st, conv)); }\n+            '.' => { return region_bounds; }\n+            c => { panic!(\"parse_bounds: bad bounds ('{}')\", c); }\n+        }\n+    }\n+}\n+"}, {"sha": "76a365259aa5713a3eb952a9a3eadfffeefb0bba", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -386,10 +386,7 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                             bs: &ty::ParamBounds<'tcx>) {\n     enc_builtin_bounds(w, cx, &bs.builtin_bounds);\n \n-    for &r in &bs.region_bounds {\n-        mywrite!(w, \"R\");\n-        enc_region(w, cx, r);\n-    }\n+    enc_region_bounds(w, cx, &bs.region_bounds);\n \n     for tp in &bs.trait_bounds {\n         mywrite!(w, \"I\");\n@@ -404,12 +401,22 @@ pub fn enc_bounds<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n     mywrite!(w, \".\");\n }\n \n+pub fn enc_region_bounds<'a, 'tcx>(w: &mut SeekableMemWriter,\n+                            cx: &ctxt<'a, 'tcx>,\n+                            rs: &[ty::Region]) {\n+    for &r in rs {\n+        mywrite!(w, \"R\");\n+        enc_region(w, cx, r);\n+    }\n+\n+    mywrite!(w, \".\");\n+}\n+\n pub fn enc_type_param_def<'a, 'tcx>(w: &mut SeekableMemWriter, cx: &ctxt<'a, 'tcx>,\n                                     v: &ty::TypeParameterDef<'tcx>) {\n     mywrite!(w, \"{}:{}|{}|{}|\",\n              token::get_name(v.name), (cx.ds)(v.def_id),\n              v.space.to_uint(), v.index);\n-    enc_bounds(w, cx, &v.bounds);\n     enc_opt(w, v.default, |w, t| enc_ty(w, cx, t));\n     enc_object_lifetime_default(w, cx, v.object_lifetime_default);\n }"}, {"sha": "78b8d4f7b1e28913ce747d166006804127f33c34", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -55,7 +55,7 @@ use middle::region;\n use middle::resolve_lifetime;\n use middle::infer;\n use middle::stability;\n-use middle::subst::{self, Subst, Substs, VecPerParamSpace};\n+use middle::subst::{self, ParamSpace, Subst, Substs, VecPerParamSpace};\n use middle::traits;\n use middle::ty;\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n@@ -1750,7 +1750,6 @@ pub struct TypeParameterDef<'tcx> {\n     pub def_id: ast::DefId,\n     pub space: subst::ParamSpace,\n     pub index: u32,\n-    pub bounds: ParamBounds<'tcx>,\n     pub default: Option<Ty<'tcx>>,\n     pub object_lifetime_default: Option<ObjectLifetimeDefault>,\n }\n@@ -2546,6 +2545,13 @@ impl<'tcx> ctxt<'tcx> {\n     {\n         self.closure_tys.borrow()[def_id].subst(self, substs)\n     }\n+\n+    pub fn type_parameter_def(&self,\n+                              node_id: ast::NodeId)\n+                              -> TypeParameterDef<'tcx>\n+    {\n+        self.ty_param_defs.borrow()[node_id].clone()\n+    }\n }\n \n // Interns a type/name combination, stores the resulting box in cx.interner,\n@@ -2996,6 +3002,13 @@ impl<'tcx> TyS<'tcx> {\n             _ => None,\n         }\n     }\n+\n+    pub fn is_param(&self, space: ParamSpace, index: u32) -> bool {\n+        match self.sty {\n+            ty::ty_param(ref data) => data.space == space && data.idx == index,\n+            _ => false,\n+        }\n+    }\n }\n \n pub fn walk_ty<'tcx, F>(ty_root: Ty<'tcx>, mut f: F)"}, {"sha": "4bf47c3a75f8003761a99ca641a540b8ae4a7f96", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -377,7 +377,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TypeParameterDef<'tcx> {\n             def_id: self.def_id,\n             space: self.space,\n             index: self.index,\n-            bounds: self.bounds.fold_with(folder),\n             default: self.default.fold_with(folder),\n             object_lifetime_default: self.object_lifetime_default.fold_with(folder),\n         }"}, {"sha": "efcde8b2fa1ac94cb00bb44c1dbc19616da14561", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -99,6 +99,7 @@ pub struct Options {\n     pub test: bool,\n     pub parse_only: bool,\n     pub no_trans: bool,\n+    pub treat_err_as_bug: bool,\n     pub no_analysis: bool,\n     pub debugging_opts: DebuggingOptions,\n     /// Whether to write dependency files. It's (enabled, optional filename).\n@@ -223,6 +224,7 @@ pub fn basic_options() -> Options {\n         test: false,\n         parse_only: false,\n         no_trans: false,\n+        treat_err_as_bug: false,\n         no_analysis: false,\n         debugging_opts: basic_debugging_options(),\n         write_dependency_info: (false, None),\n@@ -573,6 +575,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"Parse only; do not compile, assemble, or link\"),\n     no_trans: bool = (false, parse_bool,\n           \"Run all passes except translation; no output\"),\n+    treat_err_as_bug: bool = (false, parse_bool,\n+          \"Treat all errors that occur as bugs\"),\n     no_analysis: bool = (false, parse_bool,\n           \"Parse and expand the source, but run no analysis\"),\n     extra_plugins: Vec<String> = (Vec::new(), parse_list,\n@@ -843,6 +847,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let parse_only = debugging_opts.parse_only;\n     let no_trans = debugging_opts.no_trans;\n+    let treat_err_as_bug = debugging_opts.treat_err_as_bug;\n     let no_analysis = debugging_opts.no_analysis;\n \n     if debugging_opts.debug_llvm {\n@@ -1030,6 +1035,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         test: test,\n         parse_only: parse_only,\n         no_trans: no_trans,\n+        treat_err_as_bug: treat_err_as_bug,\n         no_analysis: no_analysis,\n         debugging_opts: debugging_opts,\n         write_dependency_info: write_dependency_info,"}, {"sha": "324ce1d66d007db4ee06d9afa89041360cd64c2c", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -74,18 +74,27 @@ impl Session {\n         self.diagnostic().handler().fatal(msg)\n     }\n     pub fn span_err(&self, sp: Span, msg: &str) {\n+        if self.opts.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err(sp, &msg[..]),\n             None => self.diagnostic().span_err(sp, msg)\n         }\n     }\n     pub fn span_err_with_code(&self, sp: Span, msg: &str, code: &str) {\n+        if self.opts.treat_err_as_bug {\n+            self.span_bug(sp, msg);\n+        }\n         match split_msg_into_multilines(msg) {\n             Some(msg) => self.diagnostic().span_err_with_code(sp, &msg[..], code),\n             None => self.diagnostic().span_err_with_code(sp, msg, code)\n         }\n     }\n     pub fn err(&self, msg: &str) {\n+        if self.opts.treat_err_as_bug {\n+            self.bug(msg);\n+        }\n         self.diagnostic().handler().err(msg)\n     }\n     pub fn err_count(&self) -> uint {"}, {"sha": "844635117b5e988545db9576d2c9cc6d7858a428", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 33, "deletions": 19, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -73,9 +73,14 @@ use syntax::print::pprust;\n pub trait AstConv<'tcx> {\n     fn tcx<'a>(&'a self) -> &'a ty::ctxt<'tcx>;\n \n-    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx>;\n+    fn get_item_type_scheme(&self, span: Span, id: ast::DefId)\n+                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>;\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>>;\n+    fn get_trait_def(&self, span: Span, id: ast::DefId)\n+                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>;\n+\n+    fn get_type_parameter_bounds(&self, span: Span, def_id: ast::NodeId)\n+                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>;\n \n     /// Return an (optional) substitution to convert bound type parameters that\n     /// are in scope into free ones. This function should only return Some\n@@ -683,7 +688,14 @@ fn ast_path_to_trait_ref<'a,'tcx>(\n     -> Rc<ty::TraitRef<'tcx>>\n {\n     debug!(\"ast_path_to_trait_ref {:?}\", trait_segment);\n-    let trait_def = this.get_trait_def(trait_def_id);\n+    let trait_def = match this.get_trait_def(span, trait_def_id) {\n+        Ok(trait_def) => trait_def,\n+        Err(ErrorReported) => {\n+            // No convenient way to recover from a cycle here. Just bail. Sorry!\n+            this.tcx().sess.abort_if_errors();\n+            this.tcx().sess.bug(\"ErrorReported returned, but no errors reports?\")\n+        }\n+    };\n \n     let (regions, types, assoc_bindings) = match trait_segment.parameters {\n         ast::AngleBracketedParameters(ref data) => {\n@@ -860,10 +872,15 @@ fn ast_path_to_ty<'tcx>(\n     item_segment: &ast::PathSegment)\n     -> Ty<'tcx>\n {\n-    let ty::TypeScheme {\n-        generics,\n-        ty: decl_ty\n-    } = this.get_item_type_scheme(did);\n+    let tcx = this.tcx();\n+    let (generics, decl_ty) = match this.get_item_type_scheme(span, did) {\n+        Ok(ty::TypeScheme { generics,  ty: decl_ty }) => {\n+            (generics, decl_ty)\n+        }\n+        Err(ErrorReported) => {\n+            return tcx.types.err;\n+        }\n+    };\n \n     let substs = ast_path_substs_for_ty(this, rscope,\n                                         span, param_mode,\n@@ -1001,20 +1018,17 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         return (tcx.types.err, ty_path_def);\n     };\n \n-    let mut suitable_bounds: Vec<_>;\n-    let ty_param_name: ast::Name;\n-    { // contain scope of refcell:\n-        let ty_param_defs = tcx.ty_param_defs.borrow();\n-        let ty_param_def = &ty_param_defs[ty_param_node_id];\n-        ty_param_name = ty_param_def.name;\n+    let ty_param_name = tcx.ty_param_defs.borrow()[ty_param_node_id].name;\n \n+    // FIXME(#20300) -- search where clauses, not bounds\n+    let bounds =\n+        this.get_type_parameter_bounds(span, ty_param_node_id)\n+            .unwrap_or(Vec::new());\n \n-        // FIXME(#20300) -- search where clauses, not bounds\n-        suitable_bounds =\n-            traits::transitive_bounds(tcx, &ty_param_def.bounds.trait_bounds)\n-            .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n-            .collect();\n-    }\n+    let mut suitable_bounds: Vec<_> =\n+        traits::transitive_bounds(tcx, &bounds)\n+        .filter(|b| trait_defines_associated_type_named(this, b.def_id(), assoc_name))\n+        .collect();\n \n     if suitable_bounds.len() == 0 {\n         span_err!(tcx.sess, span, E0220,"}, {"sha": "fd6ba79ec21bb87955d3c237fa1ca707edc1a5f4", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 37, "deletions": 7, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -97,7 +97,7 @@ use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace\n use middle::traits;\n use middle::ty::{FnSig, GenericPredicates, VariantInfo, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n-use middle::ty::{self, HasProjectionTypes, RegionEscape, Ty};\n+use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::liberate_late_bound_regions;\n use middle::ty::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n@@ -106,7 +106,7 @@ use session::Session;\n use {CrateCtxt, lookup_full_def, require_same_types};\n use TypeAndSubsts;\n use lint;\n-use util::common::{block_query, indenter, loop_query};\n+use util::common::{block_query, ErrorReported, indenter, loop_query};\n use util::ppaux::{self, Repr};\n use util::nodemap::{DefIdMap, FnvHashMap, NodeMap};\n use util::lev_distance::lev_distance;\n@@ -1206,18 +1206,48 @@ fn check_cast<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n     fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n \n-    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n-        ty::lookup_item_type(self.tcx(), id)\n+    fn get_item_type_scheme(&self, _: Span, id: ast::DefId)\n+                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n+    {\n+        Ok(ty::lookup_item_type(self.tcx(), id))\n     }\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        ty::lookup_trait_def(self.tcx(), id)\n+    fn get_trait_def(&self, _: Span, id: ast::DefId)\n+                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n+    {\n+        Ok(ty::lookup_trait_def(self.tcx(), id))\n     }\n \n     fn get_free_substs(&self) -> Option<&Substs<'tcx>> {\n         Some(&self.inh.param_env.free_substs)\n     }\n \n+    fn get_type_parameter_bounds(&self,\n+                                 _: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n+    {\n+        let def = self.tcx().type_parameter_def(node_id);\n+        let r = self.inh.param_env.caller_bounds\n+                                  .iter()\n+                                  .filter_map(|predicate| {\n+                                      match *predicate {\n+                                          ty::Predicate::Trait(ref data) => {\n+                                              if data.0.self_ty().is_param(def.space, def.index) {\n+                                                  Some(data.to_poly_trait_ref())\n+                                              } else {\n+                                                  None\n+                                              }\n+                                          }\n+                                          _ => {\n+                                              None\n+                                          }\n+                                      }\n+                                  })\n+                                  .collect();\n+        Ok(r)\n+    }\n+\n     fn ty_infer(&self, _span: Span) -> Ty<'tcx> {\n         self.infcx().next_ty_var()\n     }\n@@ -3607,7 +3637,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n             } else {\n               tcx.sess.span_bug(expr.span,\n-                                &format!(\"unbound path {}\", expr.repr(tcx))[])\n+                                &format!(\"unbound path {}\", expr.repr(tcx)))\n           };\n \n           let mut def = path_res.base_def;"}, {"sha": "a6ecafb6241316382fd516b7236ff6527b80571a", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -147,7 +147,7 @@ impl<'cx, 'tcx,'v> visit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                             None => {\n                                 self.tcx.sess.bug(\n                                           &format!(\"no default implementation recorded for `{:?}`\",\n-                                          item)[]);\n+                                          item));\n                             }\n                         }\n                     }"}, {"sha": "74fed6cbf3937364db6459f02cb83cd4b3975509", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 658, "deletions": 370, "changes": 1028, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -91,19 +91,19 @@ use constrained_type_params::identify_constrained_type_params;\n use middle::lang_items::SizedTraitLangItem;\n use middle::region;\n use middle::resolve_lifetime;\n-use middle::subst;\n-use middle::subst::{Substs, SelfSpace, TypeSpace, VecPerParamSpace};\n+use middle::subst::{Substs, FnSpace, ParamSpace, SelfSpace, TypeSpace, VecPerParamSpace};\n use middle::ty::{AsPredicate, ImplContainer, ImplOrTraitItemContainer, TraitContainer};\n-use middle::ty::{self, RegionEscape, Ty, TypeScheme};\n+use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty, TypeScheme};\n use middle::ty_fold::{self, TypeFolder, TypeFoldable};\n use middle::infer;\n use rscope::*;\n-use util::common::memoized;\n+use util::common::{ErrorReported, memoized};\n use util::nodemap::{FnvHashMap, FnvHashSet};\n use util::ppaux;\n use util::ppaux::{Repr,UserString};\n use write_ty_to_tcx;\n \n+use std::cell::RefCell;\n use std::collections::HashSet;\n use std::rc::Rc;\n \n@@ -121,7 +121,7 @@ use syntax::visit;\n // Main entry point\n \n pub fn collect_item_types(tcx: &ty::ctxt) {\n-    let ccx = &CollectCtxt { tcx: tcx };\n+    let ccx = &CrateCtxt { tcx: tcx, stack: RefCell::new(Vec::new()) };\n \n     match ccx.tcx.lang_items.ty_desc() {\n         Some(id) => { collect_intrinsic_type(ccx, id); }\n@@ -141,17 +141,43 @@ pub fn collect_item_types(tcx: &ty::ctxt) {\n \n ///////////////////////////////////////////////////////////////////////////\n \n-struct CollectCtxt<'a,'tcx:'a> {\n+struct CrateCtxt<'a,'tcx:'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n+\n+    // This stack is used to identify cycles in the user's source.\n+    // Note that these cycles can cross multiple items.\n+    stack: RefCell<Vec<AstConvRequest>>,\n+}\n+\n+/// Context specific to some particular item. This is what implements\n+/// AstConv. It has information about the predicates that are defined\n+/// on the trait. Unfortunately, this predicate information is\n+/// available in various different forms at various points in the\n+/// process. So we can't just store a pointer to e.g. the AST or the\n+/// parsed ty form, we have to be more flexible. To this end, the\n+/// `ItemCtxt` is parameterized by a `GetTypeParameterBounds` object\n+/// that it uses to satisfy `get_type_parameter_bounds` requests.\n+/// This object might draw the information from the AST\n+/// (`ast::Generics`) or it might draw from a `ty::GenericPredicates`\n+/// or both (a tuple).\n+struct ItemCtxt<'a,'tcx:'a> {\n+    ccx: &'a CrateCtxt<'a,'tcx>,\n+    param_bounds: &'a (GetTypeParameterBounds<'tcx>+'a),\n+}\n+\n+#[derive(Copy, PartialEq, Eq)]\n+enum AstConvRequest {\n+    GetItemTypeScheme(ast::DefId),\n+    GetTraitDef(ast::DefId),\n+    GetTypeParameterBounds(ast::NodeId),\n }\n \n ///////////////////////////////////////////////////////////////////////////\n // Zeroth phase: collect types of intrinsics\n \n-fn collect_intrinsic_type(ccx: &CollectCtxt,\n+fn collect_intrinsic_type(ccx: &CrateCtxt,\n                           lang_item: ast::DefId) {\n-    let ty::TypeScheme { ty, .. } =\n-        ccx.get_item_type_scheme(lang_item);\n+    let ty::TypeScheme { ty, .. } = type_scheme_of_def_id(ccx, lang_item);\n     ccx.tcx.intrinsic_defs.borrow_mut().insert(lang_item, ty);\n }\n \n@@ -161,7 +187,7 @@ fn collect_intrinsic_type(ccx: &CollectCtxt,\n // know later when parsing field defs.\n \n struct CollectTraitDefVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CollectCtxt<'a, 'tcx>\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n@@ -182,7 +208,7 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectTraitDefVisitor<'a, 'tcx> {\n // Second phase: collection proper.\n \n struct CollectItemTypesVisitor<'a, 'tcx: 'a> {\n-    ccx: &'a CollectCtxt<'a, 'tcx>\n+    ccx: &'a CrateCtxt<'a, 'tcx>\n }\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n@@ -199,42 +225,143 @@ impl<'a, 'tcx, 'v> visit::Visitor<'v> for CollectItemTypesVisitor<'a, 'tcx> {\n ///////////////////////////////////////////////////////////////////////////\n // Utility types and common code for the above passes.\n \n-pub trait ToTy<'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx>;\n-}\n+impl<'a,'tcx> CrateCtxt<'a,'tcx> {\n+    fn icx(&'a self, param_bounds: &'a GetTypeParameterBounds<'tcx>) -> ItemCtxt<'a,'tcx> {\n+        ItemCtxt { ccx: self, param_bounds: param_bounds }\n+    }\n \n-impl<'a,'tcx> ToTy<'tcx> for CollectCtxt<'a,'tcx> {\n-    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n-        ast_ty_to_ty(self, rs, ast_ty)\n+    fn method_ty(&self, method_id: ast::NodeId) -> Rc<ty::Method<'tcx>> {\n+        let def_id = local_def(method_id);\n+        match self.tcx.impl_or_trait_items.borrow()[def_id] {\n+            ty::MethodTraitItem(ref mty) => mty.clone(),\n+            ty::TypeTraitItem(..) => {\n+                self.tcx.sess.bug(&format!(\"method with id {} has the wrong type\", method_id));\n+            }\n+        }\n     }\n-}\n \n-impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n-    fn tcx(&self) -> &ty::ctxt<'tcx> { self.tcx }\n+    fn cycle_check<F,R>(&self,\n+                        span: Span,\n+                        request: AstConvRequest,\n+                        code: F)\n+                        -> Result<R,ErrorReported>\n+        where F: FnOnce() -> R\n+    {\n+        {\n+            let mut stack = self.stack.borrow_mut();\n+            match stack.iter().enumerate().rev().find(|&(_, r)| *r == request) {\n+                None => { }\n+                Some((i, _)) => {\n+                    let cycle = &stack[i..];\n+                    self.report_cycle(span, cycle);\n+                    return Err(ErrorReported);\n+                }\n+            }\n+            stack.push(request);\n+        }\n+\n+        let result = code();\n \n-    fn get_item_type_scheme(&self, id: ast::DefId) -> ty::TypeScheme<'tcx> {\n-        if id.krate != ast::LOCAL_CRATE {\n-            return ty::lookup_item_type(self.tcx, id);\n+        self.stack.borrow_mut().pop();\n+        Ok(result)\n+    }\n+\n+    fn report_cycle(&self,\n+                    span: Span,\n+                    cycle: &[AstConvRequest])\n+    {\n+        assert!(!cycle.is_empty());\n+        let tcx = self.tcx;\n+\n+        tcx.sess.span_err(\n+            span,\n+            &format!(\"unsupported cyclic reference between types/traits detected\"));\n+\n+        match cycle[0] {\n+            AstConvRequest::GetItemTypeScheme(def_id) |\n+            AstConvRequest::GetTraitDef(def_id) => {\n+                tcx.sess.note(\n+                    &format!(\"the cycle begins when processing `{}`...\",\n+                             ty::item_path_str(tcx, def_id)));\n+            }\n+            AstConvRequest::GetTypeParameterBounds(id) => {\n+                let def = tcx.type_parameter_def(id);\n+                tcx.sess.note(\n+                    &format!(\"the cycle begins when computing the bounds \\\n+                              for type parameter `{}`...\",\n+                             def.name.user_string(tcx)));\n+            }\n         }\n \n-        match self.tcx.map.find(id.node) {\n-            Some(ast_map::NodeItem(item)) => {\n-                type_scheme_of_item(self, &*item)\n+        for request in cycle[1..].iter() {\n+            match *request {\n+                AstConvRequest::GetItemTypeScheme(def_id) |\n+                AstConvRequest::GetTraitDef(def_id) => {\n+                    tcx.sess.note(\n+                        &format!(\"...which then requires processing `{}`...\",\n+                                 ty::item_path_str(tcx, def_id)));\n+                }\n+                AstConvRequest::GetTypeParameterBounds(id) => {\n+                    let def = tcx.type_parameter_def(id);\n+                    tcx.sess.note(\n+                        &format!(\"...which then requires computing the bounds \\\n+                                  for type parameter `{}`...\",\n+                                 def.name.user_string(tcx)));\n+                }\n             }\n-            Some(ast_map::NodeForeignItem(foreign_item)) => {\n-                let abi = self.tcx.map.get_foreign_abi(id.node);\n-                type_scheme_of_foreign_item(self, &*foreign_item, abi)\n+        }\n+\n+        match cycle[0] {\n+            AstConvRequest::GetItemTypeScheme(def_id) |\n+            AstConvRequest::GetTraitDef(def_id) => {\n+                tcx.sess.note(\n+                    &format!(\"...which then again requires processing `{}`, completing the cycle.\",\n+                             ty::item_path_str(tcx, def_id)));\n             }\n-            x => {\n-                self.tcx.sess.bug(&format!(\"unexpected sort of node \\\n-                                            in get_item_type_scheme(): {:?}\",\n-                                           x));\n+            AstConvRequest::GetTypeParameterBounds(id) => {\n+                let def = tcx.type_parameter_def(id);\n+                tcx.sess.note(\n+                    &format!(\"...which then again requires computing the bounds \\\n+                              for type parameter `{}`, completing the cycle.\",\n+                             def.name.user_string(tcx)));\n             }\n         }\n     }\n+}\n \n-    fn get_trait_def(&self, id: ast::DefId) -> Rc<ty::TraitDef<'tcx>> {\n-        get_trait_def(self, id)\n+impl<'a,'tcx> ItemCtxt<'a,'tcx> {\n+    fn to_ty<RS:RegionScope>(&self, rs: &RS, ast_ty: &ast::Ty) -> Ty<'tcx> {\n+        ast_ty_to_ty(self, rs, ast_ty)\n+    }\n+}\n+\n+impl<'a, 'tcx> AstConv<'tcx> for ItemCtxt<'a, 'tcx> {\n+    fn tcx(&self) -> &ty::ctxt<'tcx> { self.ccx.tcx }\n+\n+    fn get_item_type_scheme(&self, span: Span, id: ast::DefId)\n+                            -> Result<ty::TypeScheme<'tcx>, ErrorReported>\n+    {\n+        self.ccx.cycle_check(span, AstConvRequest::GetItemTypeScheme(id), || {\n+            type_scheme_of_def_id(self.ccx, id)\n+        })\n+    }\n+\n+    fn get_trait_def(&self, span: Span, id: ast::DefId)\n+                     -> Result<Rc<ty::TraitDef<'tcx>>, ErrorReported>\n+    {\n+        self.ccx.cycle_check(span, AstConvRequest::GetTraitDef(id), || {\n+            get_trait_def(self.ccx, id)\n+        })\n+    }\n+\n+    fn get_type_parameter_bounds(&self,\n+                                 span: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Result<Vec<ty::PolyTraitRef<'tcx>>, ErrorReported>\n+    {\n+        self.ccx.cycle_check(span, AstConvRequest::GetTypeParameterBounds(node_id), || {\n+            self.param_bounds.get_type_parameter_bounds(self, span, node_id)\n+        })\n     }\n \n     fn ty_infer(&self, span: Span) -> Ty<'tcx> {\n@@ -253,11 +380,147 @@ impl<'a, 'tcx> AstConv<'tcx> for CollectCtxt<'a, 'tcx> {\n     }\n }\n \n-fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+/// Interface used to find the bounds on a type parameter from within\n+/// an `ItemCtxt`. This allows us to use multiple kinds of sources.\n+trait GetTypeParameterBounds<'tcx> {\n+    fn get_type_parameter_bounds(&self,\n+                                 astconv: &AstConv<'tcx>,\n+                                 span: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Vec<ty::PolyTraitRef<'tcx>>;\n+}\n+\n+/// Find bounds from both elements of the tuple.\n+impl<'a,'b,'tcx,A,B> GetTypeParameterBounds<'tcx> for (&'a A,&'b B)\n+    where A : GetTypeParameterBounds<'tcx>, B : GetTypeParameterBounds<'tcx>\n+{\n+    fn get_type_parameter_bounds(&self,\n+                                 astconv: &AstConv<'tcx>,\n+                                 span: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        let mut v = self.0.get_type_parameter_bounds(astconv, span, node_id);\n+        v.extend(self.1.get_type_parameter_bounds(astconv, span, node_id).into_iter());\n+        v\n+    }\n+}\n+\n+/// Empty set of bounds.\n+impl<'tcx> GetTypeParameterBounds<'tcx> for () {\n+    fn get_type_parameter_bounds(&self,\n+                                 _astconv: &AstConv<'tcx>,\n+                                 _span: Span,\n+                                 _node_id: ast::NodeId)\n+                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        Vec::new()\n+    }\n+}\n+\n+/// Find bounds from the parsed and converted predicates.  This is\n+/// used when converting methods, because by that time the predicates\n+/// from the trait/impl have been fully converted.\n+impl<'tcx> GetTypeParameterBounds<'tcx> for ty::GenericPredicates<'tcx> {\n+    fn get_type_parameter_bounds(&self,\n+                                 astconv: &AstConv<'tcx>,\n+                                 _span: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        let def = astconv.tcx().type_parameter_def(node_id);\n+\n+        self.predicates\n+            .iter()\n+            .filter_map(|predicate| {\n+                match *predicate {\n+                    ty::Predicate::Trait(ref data) => {\n+                        if data.0.self_ty().is_param(def.space, def.index) {\n+                            Some(data.to_poly_trait_ref())\n+                        } else {\n+                            None\n+                        }\n+                    }\n+                    ty::Predicate::Equate(..) |\n+                    ty::Predicate::RegionOutlives(..) |\n+                    ty::Predicate::TypeOutlives(..) |\n+                    ty::Predicate::Projection(..) => {\n+                        None\n+                    }\n+                }\n+            })\n+            .collect()\n+    }\n+}\n+\n+/// Find bounds from ast::Generics. This requires scanning through the\n+/// AST. We do this to avoid having to convert *all* the bounds, which\n+/// would create artificial cycles. Instead we can only convert the\n+/// bounds for those a type parameter `X` if `X::Foo` is used.\n+impl<'tcx> GetTypeParameterBounds<'tcx> for ast::Generics {\n+    fn get_type_parameter_bounds(&self,\n+                                 astconv: &AstConv<'tcx>,\n+                                 _: Span,\n+                                 node_id: ast::NodeId)\n+                                 -> Vec<ty::PolyTraitRef<'tcx>>\n+    {\n+        // In the AST, bounds can derive from two places. Either\n+        // written inline like `<T:Foo>` or in a where clause like\n+        // `where T:Foo`.\n+\n+        let def = astconv.tcx().type_parameter_def(node_id);\n+        let ty = ty::mk_param_from_def(astconv.tcx(), &def);\n+\n+        let from_ty_params =\n+            self.ty_params\n+                .iter()\n+                .filter(|p| p.id == node_id)\n+                .flat_map(|p| p.bounds.iter())\n+                .filter_map(|b| poly_trait_ref_from_bound(astconv, ty, b, &mut Vec::new()));\n+\n+        let from_where_clauses =\n+            self.where_clause\n+                .predicates\n+                .iter()\n+                .filter_map(|wp| match *wp {\n+                    ast::WherePredicate::BoundPredicate(ref bp) => Some(bp),\n+                    _ => None\n+                })\n+                .filter(|bp| is_param(astconv.tcx(), &bp.bounded_ty, node_id))\n+                .flat_map(|bp| bp.bounds.iter())\n+                .filter_map(|b| poly_trait_ref_from_bound(astconv, ty, b, &mut Vec::new()));\n+\n+        from_ty_params.chain(from_where_clauses).collect()\n+    }\n+}\n+\n+/// Tests whether this is the AST for a reference to the type\n+/// parameter with id `param_id`. We use this so as to avoid running\n+/// `ast_ty_to_ty`, because we want to avoid triggering an all-out\n+/// conversion of the type to avoid inducing unnecessary cycles.\n+fn is_param<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                  ast_ty: &ast::Ty,\n+                  param_id: ast::NodeId)\n+                  -> bool\n+{\n+    if let ast::TyPath(None, _) = ast_ty.node {\n+        let path_res = tcx.def_map.borrow()[ast_ty.id];\n+        if let def::DefTyParam(_, _, def_id, _) = path_res.base_def {\n+            path_res.depth == 0 && def_id == local_def(param_id)\n+        } else {\n+            false\n+        }\n+    } else {\n+        false\n+    }\n+}\n+\n+fn get_enum_variant_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     enum_scheme: ty::TypeScheme<'tcx>,\n                                     enum_predicates: ty::GenericPredicates<'tcx>,\n                                     variants: &[P<ast::Variant>]) {\n     let tcx = ccx.tcx;\n+    let icx = ccx.icx(&enum_predicates);\n \n     // Create a set of parameter types shared among all the variants.\n     for variant in variants {\n@@ -268,8 +531,8 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         let result_ty = match variant.node.kind {\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n-                let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[..], enum_scheme.ty)\n+                let input_tys: Vec<_> = args.iter().map(|va| icx.to_ty(&rs, &*va.ty)).collect();\n+                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys, enum_scheme.ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -294,7 +557,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn collect_trait_methods<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n                                    trait_def: &ty::TraitDef<'tcx>,\n                                    trait_predicates: &ty::GenericPredicates<'tcx>) {\n@@ -393,7 +656,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         }\n     }\n \n-    fn make_method_ty<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n+    fn make_method_ty<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, m: &ty::Method<'tcx>) {\n         ccx.tcx.tcache.borrow_mut().insert(\n             m.def_id,\n             TypeScheme {\n@@ -405,7 +668,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             m.predicates.clone());\n     }\n \n-    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+    fn ty_method_of_trait_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                            trait_id: ast::NodeId,\n                                            trait_generics: &ty::Generics<'tcx>,\n                                            trait_bounds: &ty::GenericPredicates<'tcx>,\n@@ -417,21 +680,17 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                            m_generics: &ast::Generics,\n                                            m_unsafety: &ast::Unsafety,\n                                            m_decl: &ast::FnDecl)\n-                                           -> ty::Method<'tcx> {\n+                                           -> ty::Method<'tcx>\n+    {\n         let ty_generics =\n-            ty_generics_for_fn_or_method(ccx,\n-                                         m_generics,\n-                                         trait_generics.clone());\n+            ty_generics_for_fn(ccx, m_generics, trait_generics);\n \n-        let ty_bounds =\n-            ty_generic_bounds_for_fn_or_method(ccx,\n-                                               m_generics,\n-                                               &ty_generics,\n-                                               trait_bounds.clone());\n+        let ty_generic_predicates =\n+            ty_generic_predicates_for_fn(ccx, m_generics, trait_bounds);\n \n         let (fty, explicit_self_category) = {\n             let trait_self_ty = ty::mk_self_type(ccx.tcx);\n-            astconv::ty_of_method(ccx,\n+            astconv::ty_of_method(&ccx.icx(&(trait_bounds, m_generics)),\n                                   *m_unsafety,\n                                   trait_self_ty,\n                                   m_explicit_self,\n@@ -442,7 +701,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ty::Method::new(\n             *m_name,\n             ty_generics,\n-            ty_bounds,\n+            ty_generic_predicates,\n             fty,\n             explicit_self_category,\n             // assume public, because this is only invoked on trait methods\n@@ -454,12 +713,14 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_field<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n-                                struct_generics: &ty::Generics<'tcx>,\n-                                struct_predicates: &ty::GenericPredicates<'tcx>,\n-                                v: &ast::StructField,\n-                                origin: ast::DefId) -> ty::field_ty {\n-    let tt = ccx.to_ty(&ExplicitRscope, &*v.node.ty);\n+fn convert_field<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                           struct_generics: &ty::Generics<'tcx>,\n+                           struct_predicates: &ty::GenericPredicates<'tcx>,\n+                           v: &ast::StructField,\n+                           origin: ast::DefId)\n+                           -> ty::field_ty\n+{\n+    let tt = ccx.icx(struct_predicates).to_ty(&ExplicitRscope, &*v.node.ty);\n     write_ty_to_tcx(ccx.tcx, v.node.id, tt);\n \n     /* add the field to the tcache */\n@@ -491,7 +752,7 @@ fn convert_field<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn convert_associated_type<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      trait_def: &ty::TraitDef<'tcx>,\n                                      associated_type: &ast::AssociatedType)\n {\n@@ -504,18 +765,18 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     ccx.tcx\n        .impl_or_trait_items\n        .borrow_mut()\n-       .insert(associated_type.def_id,\n-               ty::TypeTraitItem(associated_type));\n+       .insert(associated_type.def_id, ty::TypeTraitItem(associated_type));\n }\n \n-fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_methods<'a,'tcx,'i,I>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  container: ImplOrTraitItemContainer,\n                                  ms: I,\n                                  untransformed_rcvr_ty: Ty<'tcx>,\n                                  rcvr_ty_generics: &ty::Generics<'tcx>,\n                                  rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                                  rcvr_visibility: ast::Visibility)\n-                                 where I: Iterator<Item=&'i ast::Method> {\n+                                 where I: Iterator<Item=&'i ast::Method>\n+{\n     debug!(\"convert_methods(untransformed_rcvr_ty={}, rcvr_ty_generics={})\",\n            untransformed_rcvr_ty.repr(ccx.tcx),\n            rcvr_ty_generics.repr(ccx.tcx));\n@@ -559,31 +820,28 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n            .insert(mty.def_id, ty::MethodTraitItem(mty));\n     }\n \n-    fn ty_of_method<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+    fn ty_of_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                               container: ImplOrTraitItemContainer,\n                               m: &ast::Method,\n                               untransformed_rcvr_ty: Ty<'tcx>,\n                               rcvr_ty_generics: &ty::Generics<'tcx>,\n                               rcvr_ty_predicates: &ty::GenericPredicates<'tcx>,\n                               rcvr_visibility: ast::Visibility)\n-                              -> ty::Method<'tcx> {\n+                              -> ty::Method<'tcx>\n+    {\n         let m_ty_generics =\n-            ty_generics_for_fn_or_method(ccx,\n-                                         m.pe_generics(),\n-                                         rcvr_ty_generics.clone());\n-\n-        let m_ty_bounds =\n-            ty_generic_bounds_for_fn_or_method(ccx,\n-                                               m.pe_generics(),\n-                                               &m_ty_generics,\n-                                               rcvr_ty_predicates.clone());\n-\n-        let (fty, explicit_self_category) = astconv::ty_of_method(ccx,\n-                                                                  m.pe_unsafety(),\n-                                                                  untransformed_rcvr_ty,\n-                                                                  m.pe_explicit_self(),\n-                                                                  &*m.pe_fn_decl(),\n-                                                                  m.pe_abi());\n+            ty_generics_for_fn(ccx, m.pe_generics(), rcvr_ty_generics);\n+\n+        let m_ty_generic_predicates =\n+            ty_generic_predicates_for_fn(ccx, m.pe_generics(), rcvr_ty_predicates);\n+\n+        let (fty, explicit_self_category) =\n+            astconv::ty_of_method(&ccx.icx(&(rcvr_ty_predicates, m.pe_generics())),\n+                                  m.pe_unsafety(),\n+                                  untransformed_rcvr_ty,\n+                                  m.pe_explicit_self(),\n+                                  &*m.pe_fn_decl(),\n+                                  m.pe_abi());\n \n         // if the method specifies a visibility, use that, otherwise\n         // inherit the visibility from the impl (so `foo` in `pub impl\n@@ -593,7 +851,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n \n         ty::Method::new(m.pe_ident().name,\n                         m_ty_generics,\n-                        m_ty_bounds,\n+                        m_ty_generic_predicates,\n                         fty,\n                         explicit_self_category,\n                         method_vis,\n@@ -603,7 +861,7 @@ fn convert_methods<'a,'tcx,'i,I>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n+fn ensure_no_ty_param_bounds(ccx: &CrateCtxt,\n                                  span: Span,\n                                  generics: &ast::Generics,\n                                  thing: &'static str) {\n@@ -632,7 +890,7 @@ fn ensure_no_ty_param_bounds(ccx: &CollectCtxt,\n     }\n }\n \n-fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n+fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     debug!(\"convert: item {} with id {}\", token::get_ident(it.ident), it.id);\n     match it.node {\n@@ -649,7 +907,7 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                                    &enum_definition.variants);\n         },\n         ast::ItemDefaultImpl(_, ref ast_trait_ref) => {\n-            let trait_ref = astconv::instantiate_trait_ref(ccx,\n+            let trait_ref = astconv::instantiate_trait_ref(&ccx.icx(&()),\n                                                            &ExplicitRscope,\n                                                            ast_trait_ref,\n                                                            Some(it.id),\n@@ -667,11 +925,11 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n \n             debug!(\"convert: ast_generics={:?}\", generics);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n-            let ty_predicates = ty_generic_bounds_for_type_or_impl(ccx, &ty_generics, generics);\n+            let ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n \n             debug!(\"convert: impl_bounds={:?}\", ty_predicates);\n \n-            let selfty = ccx.to_ty(&ExplicitRscope, &**selfty);\n+            let selfty = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &**selfty);\n             write_ty_to_tcx(tcx, it.id, selfty);\n \n             tcx.tcache.borrow_mut().insert(local_def(it.id),\n@@ -695,12 +953,6 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n             for impl_item in impl_items {\n                 match *impl_item {\n                     ast::MethodImplItem(ref method) => {\n-                        let body_id = method.pe_body().id;\n-                        check_method_self_type(ccx,\n-                                               &BindingRscope::new(),\n-                                               selfty,\n-                                               method.pe_explicit_self(),\n-                                               body_id);\n                         methods.push(&**method);\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n@@ -709,7 +961,7 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                                               \"associated items are not allowed in inherent impls\");\n                         }\n \n-                        let typ = ccx.to_ty(&ExplicitRscope, &*typedef.typ);\n+                        let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, &*typedef.typ);\n                         tcx.tcache.borrow_mut().insert(local_def(typedef.id),\n                                                        TypeScheme {\n                                                            generics: ty::Generics::empty(),\n@@ -741,8 +993,23 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                             &ty_predicates,\n                             parent_visibility);\n \n+            for impl_item in impl_items {\n+                match *impl_item {\n+                    ast::MethodImplItem(ref method) => {\n+                        let body_id = method.pe_body().id;\n+                        check_method_self_type(ccx,\n+                                               &BindingRscope::new(),\n+                                               ccx.method_ty(method.id),\n+                                               selfty,\n+                                               method.pe_explicit_self(),\n+                                               body_id);\n+                    }\n+                    ast::TypeImplItem(..) => { }\n+                }\n+            }\n+\n             if let Some(ref trait_ref) = *opt_trait_ref {\n-                astconv::instantiate_trait_ref(ccx,\n+                astconv::instantiate_trait_ref(&ccx.icx(&ty_predicates),\n                                                &ExplicitRscope,\n                                                trait_ref,\n                                                Some(it.id),\n@@ -754,27 +1021,50 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                                                    generics,\n                                                    local_def(it.id));\n         },\n-        ast::ItemTrait(_, _, _, ref trait_methods) => {\n+        ast::ItemTrait(_, _, _, ref trait_items) => {\n             let trait_def = trait_def_of_item(ccx, it);\n             convert_trait_predicates(ccx, it);\n             let trait_predicates = ty::lookup_predicates(ccx.tcx, local_def(it.id));\n \n             debug!(\"convert: trait_bounds={:?}\", trait_predicates);\n \n-            for trait_method in trait_methods {\n+            // Run convert_methods on the provided methods.\n+            let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n+            convert_methods(ccx,\n+                            TraitContainer(local_def(it.id)),\n+                            trait_items.iter().filter_map(|m| match *m {\n+                                ast::RequiredMethod(_) => None,\n+                                ast::ProvidedMethod(ref m) => Some(&**m),\n+                                ast::TypeTraitItem(_) => None,\n+                            }),\n+                            untransformed_rcvr_ty,\n+                            &trait_def.generics,\n+                            &trait_predicates,\n+                            it.vis);\n+\n+            // We need to do this *after* converting methods, since\n+            // convert_methods produces a tcache entry that is wrong for\n+            // static trait methods. This is somewhat unfortunate.\n+            collect_trait_methods(ccx, it.id, &*trait_def, &trait_predicates);\n+\n+            // This must be done after `collect_trait_methods` so that\n+            // we have a method type stored for every method.\n+            for trait_item in trait_items {\n                 let self_type = ty::mk_self_type(tcx);\n-                match *trait_method {\n+                match *trait_item {\n                     ast::RequiredMethod(ref type_method) => {\n                         let rscope = BindingRscope::new();\n                         check_method_self_type(ccx,\n                                                &rscope,\n+                                               ccx.method_ty(type_method.id),\n                                                self_type,\n                                                &type_method.explicit_self,\n                                                it.id)\n                     }\n                     ast::ProvidedMethod(ref method) => {\n                         check_method_self_type(ccx,\n                                                &BindingRscope::new(),\n+                                               ccx.method_ty(method.id),\n                                                self_type,\n                                                method.pe_explicit_self(),\n                                                it.id)\n@@ -786,25 +1076,6 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n                     }\n                 }\n             }\n-\n-            // Run convert_methods on the provided methods.\n-            let untransformed_rcvr_ty = ty::mk_self_type(tcx);\n-            convert_methods(ccx,\n-                            TraitContainer(local_def(it.id)),\n-                            trait_methods.iter().filter_map(|m| match *m {\n-                                ast::RequiredMethod(_) => None,\n-                                ast::ProvidedMethod(ref m) => Some(&**m),\n-                                ast::TypeTraitItem(_) => None,\n-                            }),\n-                            untransformed_rcvr_ty,\n-                            &trait_def.generics,\n-                            &trait_predicates,\n-                            it.vis);\n-\n-            // We need to do this *after* converting methods, since\n-            // convert_methods produces a tcache entry that is wrong for\n-            // static trait methods. This is somewhat unfortunate.\n-            collect_trait_methods(ccx, it.id, &*trait_def, &trait_predicates);\n         },\n         ast::ItemStruct(ref struct_def, _) => {\n             // Write the class type.\n@@ -827,7 +1098,7 @@ fn convert_item(ccx: &CollectCtxt, it: &ast::Item) {\n     }\n }\n \n-fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_struct<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             struct_def: &ast::StructDef,\n                             scheme: ty::TypeScheme<'tcx>,\n                             predicates: ty::GenericPredicates<'tcx>,\n@@ -897,7 +1168,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn get_trait_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                            trait_id: ast::DefId)\n                            -> Rc<ty::TraitDef<'tcx>> {\n     let tcx = ccx.tcx;\n@@ -915,7 +1186,7 @@ fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     }\n }\n \n-fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn trait_def_of_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                it: &ast::Item)\n                                -> Rc<ty::TraitDef<'tcx>>\n {\n@@ -958,7 +1229,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let self_param_ty = ty::ParamTy::for_self().to_ty(ccx.tcx);\n \n     // supertraits:\n-    let bounds = compute_bounds(ccx,\n+    let bounds = compute_bounds(&ccx.icx(generics),\n                                 self_param_ty,\n                                 bounds,\n                                 SizedByDefault::No,\n@@ -992,9 +1263,9 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     return trait_def;\n \n-    fn mk_trait_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+    fn mk_trait_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                  generics: &ast::Generics)\n-                                 -> subst::Substs<'tcx>\n+                                 -> Substs<'tcx>\n     {\n         let tcx = ccx.tcx;\n \n@@ -1004,7 +1275,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                     .iter()\n                     .enumerate()\n                     .map(|(i, def)| ty::ReEarlyBound(def.lifetime.id,\n-                                                     subst::TypeSpace,\n+                                                     TypeSpace,\n                                                      i as u32,\n                                                      def.lifetime.name))\n                     .collect();\n@@ -1014,18 +1285,18 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             generics.ty_params\n                     .iter()\n                     .enumerate()\n-                    .map(|(i, def)| ty::mk_param(tcx, subst::TypeSpace,\n+                    .map(|(i, def)| ty::mk_param(tcx, TypeSpace,\n                                                  i as u32, def.ident.name))\n                     .collect();\n \n         // ...and also create the `Self` parameter.\n         let self_ty = ty::mk_self_type(tcx);\n \n-        subst::Substs::new_trait(types, regions, self_ty)\n+        Substs::new_trait(types, regions, self_ty)\n     }\n }\n \n-fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Item) {\n+fn convert_trait_predicates<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>, it: &ast::Item) {\n     let tcx = ccx.tcx;\n     let trait_def = trait_def_of_item(ccx, it);\n \n@@ -1044,9 +1315,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n \n     let super_predicates = ty::predicates(ccx.tcx, self_param_ty, &trait_def.bounds);\n \n-    let assoc_predicates = predicates_for_associated_types(ccx, &trait_def.trait_ref, items);\n-\n-    // `ty_generic_bounds` below will consider the bounds on the type\n+    // `ty_generic_predicates` below will consider the bounds on the type\n     // parameters (including `Self`) and the explicit where-clauses,\n     // but to get the full set of predicates on a trait we need to add\n     // in the supertrait bounds and anything declared on the\n@@ -1055,27 +1324,31 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n         ty::GenericPredicates {\n             predicates: VecPerParamSpace::new(super_predicates, vec![], vec![])\n         };\n-    base_predicates.predicates.extend(subst::TypeSpace, assoc_predicates.into_iter());\n \n-    let self_bounds = &trait_def.generics.types.get_self().unwrap().bounds;\n-    base_predicates.predicates.extend(\n-        subst::SelfSpace,\n-        ty::predicates(ccx.tcx, self_param_ty, self_bounds).into_iter());\n+    // Add in a predicate that `Self:Trait` (where `Trait` is the\n+    // current trait).  This is needed for builtin bounds.\n+    let self_predicate = trait_def.trait_ref.to_poly_trait_ref().as_predicate();\n+    base_predicates.predicates.push(SelfSpace, self_predicate);\n \n     // add in the explicit where-clauses\n-    let trait_predicates =\n-        ty_generic_bounds(ccx,\n-                          subst::TypeSpace,\n-                          &trait_def.generics,\n-                          base_predicates,\n-                          &generics.where_clause);\n+    let mut trait_predicates =\n+        ty_generic_predicates(ccx, TypeSpace, generics, &base_predicates);\n+\n+    let assoc_predicates = predicates_for_associated_types(ccx,\n+                                                           generics,\n+                                                           &trait_predicates,\n+                                                           &trait_def.trait_ref,\n+                                                           items);\n+    trait_predicates.predicates.extend(TypeSpace, assoc_predicates.into_iter());\n \n     let prev_predicates = tcx.predicates.borrow_mut().insert(def_id, trait_predicates);\n     assert!(prev_predicates.is_none());\n \n     return;\n \n-    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+    fn predicates_for_associated_types<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                                 ast_generics: &ast::Generics,\n+                                                 trait_predicates: &ty::GenericPredicates<'tcx>,\n                                                  self_trait_ref: &Rc<ty::TraitRef<'tcx>>,\n                                                  trait_items: &[ast::TraitItem])\n                                                  -> Vec<ty::Predicate<'tcx>>\n@@ -1094,7 +1367,7 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n                                                  self_trait_ref.clone(),\n                                                  assoc_type_def.ident.name);\n \n-                let bounds = compute_bounds(ccx,\n+                let bounds = compute_bounds(&ccx.icx(&(ast_generics, trait_predicates)),\n                                             assoc_ty,\n                                             &*assoc_type_def.bounds,\n                                             SizedByDefault::Yes,\n@@ -1106,7 +1379,31 @@ fn convert_trait_predicates<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>, it: &ast::Ite\n     }\n }\n \n-fn type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+fn type_scheme_of_def_id<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                  def_id: ast::DefId)\n+                                  -> ty::TypeScheme<'tcx>\n+{\n+    if def_id.krate != ast::LOCAL_CRATE {\n+        return ty::lookup_item_type(ccx.tcx, def_id);\n+    }\n+\n+    match ccx.tcx.map.find(def_id.node) {\n+        Some(ast_map::NodeItem(item)) => {\n+            type_scheme_of_item(ccx, &*item)\n+        }\n+        Some(ast_map::NodeForeignItem(foreign_item)) => {\n+            let abi = ccx.tcx.map.get_foreign_abi(def_id.node);\n+            type_scheme_of_foreign_item(ccx, &*foreign_item, abi)\n+        }\n+        x => {\n+            ccx.tcx.sess.bug(&format!(\"unexpected sort of node \\\n+                                            in get_item_type_scheme(): {:?}\",\n+                                       x));\n+        }\n+    }\n+}\n+\n+fn type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                                 it: &ast::Item)\n                                 -> ty::TypeScheme<'tcx>\n {\n@@ -1115,28 +1412,25 @@ fn type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n              |_| compute_type_scheme_of_item(ccx, it))\n }\n \n-\n-fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                              it: &ast::Item)\n-                                              -> ty::TypeScheme<'tcx>\n+fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                        it: &ast::Item)\n+                                        -> ty::TypeScheme<'tcx>\n {\n     let tcx = ccx.tcx;\n     match it.node {\n         ast::ItemStatic(ref t, _, _) | ast::ItemConst(ref t, _) => {\n-            let ty = ccx.to_ty(&ExplicitRscope, &**t);\n+            let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n         }\n         ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n-            let ty_generics = ty_generics_for_fn_or_method(ccx,\n-                                                           generics,\n-                                                           ty::Generics::empty());\n-            let tofd = astconv::ty_of_bare_fn(ccx, unsafety, abi, &**decl);\n+            let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n+            let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n             let ty = ty::mk_bare_fn(tcx, Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemTy(ref t, ref generics) => {\n-            let ty = ccx.to_ty(&ExplicitRscope, &**t);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n+            let ty = ccx.icx(generics).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty_generics }\n         }\n         ast::ItemEnum(_, ref generics) => {\n@@ -1168,7 +1462,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     }\n }\n \n-fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                 it: &ast::Item)\n                                 -> (ty::TypeScheme<'tcx>, ty::GenericPredicates<'tcx>)\n {\n@@ -1181,19 +1475,16 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             ty::GenericPredicates::empty()\n         }\n         ast::ItemFn(_, _, _, ref ast_generics, _) => {\n-            ty_generic_bounds_for_fn_or_method(ccx,\n-                                               ast_generics,\n-                                               &scheme.generics,\n-                                               ty::GenericPredicates::empty())\n+            ty_generic_predicates_for_fn(ccx, ast_generics, &ty::GenericPredicates::empty())\n         }\n         ast::ItemTy(_, ref generics) => {\n-            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+            ty_generic_predicates_for_type_or_impl(ccx, generics)\n         }\n         ast::ItemEnum(_, ref generics) => {\n-            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+            ty_generic_predicates_for_type_or_impl(ccx, generics)\n         }\n         ast::ItemStruct(_, ref generics) => {\n-            ty_generic_bounds_for_type_or_impl(ccx, &scheme.generics, generics)\n+            ty_generic_predicates_for_type_or_impl(ccx, generics)\n         }\n         ast::ItemDefaultImpl(..) |\n         ast::ItemTrait(..) |\n@@ -1205,8 +1496,8 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ast::ItemMac(..) => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n-                        it.node).as_slice());\n+                &format!(\"compute_type_scheme_of_item: unexpected item type: {:?}\",\n+                         it.node));\n         }\n     };\n \n@@ -1222,7 +1513,7 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                      Some(ty::ObjectLifetimeDefault::Specific(r)) =>\n                                          r.user_string(tcx),\n                                      d =>\n-                                         d.repr(ccx.tcx()),\n+                                         d.repr(ccx.tcx),\n                                  })\n                                  .collect::<Vec<String>>()\n                                  .connect(\",\");\n@@ -1234,18 +1525,18 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n }\n \n fn type_scheme_of_foreign_item<'a, 'tcx>(\n-    ccx: &CollectCtxt<'a, 'tcx>,\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     it: &ast::ForeignItem,\n     abi: abi::Abi)\n     -> ty::TypeScheme<'tcx>\n {\n-    memoized(&ccx.tcx().tcache,\n+    memoized(&ccx.tcx.tcache,\n              local_def(it.id),\n              |_| compute_type_scheme_of_foreign_item(ccx, it, abi))\n }\n \n fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n-    ccx: &CollectCtxt<'a, 'tcx>,\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     it: &ast::ForeignItem,\n     abi: abi::Abi)\n     -> ty::TypeScheme<'tcx>\n@@ -1257,13 +1548,13 @@ fn compute_type_scheme_of_foreign_item<'a, 'tcx>(\n         ast::ForeignItemStatic(ref t, _) => {\n             ty::TypeScheme {\n                 generics: ty::Generics::empty(),\n-                ty: ast_ty_to_ty(ccx, &ExplicitRscope, t)\n+                ty: ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, t)\n             }\n         }\n     }\n }\n \n-fn convert_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn convert_foreign_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                   it: &ast::ForeignItem)\n {\n     // For reasons I cannot fully articulate, I do so hate the AST\n@@ -1278,10 +1569,7 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n \n     let predicates = match it.node {\n         ast::ForeignItemFn(_, ref generics) => {\n-            ty_generic_bounds_for_fn_or_method(ccx,\n-                                               generics,\n-                                               &scheme.generics,\n-                                               ty::GenericPredicates::empty())\n+            ty_generic_predicates_for_fn(ccx, generics, &ty::GenericPredicates::empty())\n         }\n         ast::ForeignItemStatic(..) => {\n             ty::GenericPredicates::empty()\n@@ -1292,111 +1580,76 @@ fn convert_foreign_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     assert!(prev_predicates.is_none());\n }\n \n-fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                           generics: &ast::Generics)\n                                           -> ty::Generics<'tcx> {\n-    ty_generics(ccx,\n-                subst::TypeSpace,\n-                &generics.lifetimes,\n-                &generics.ty_params,\n-                &generics.where_clause,\n-                ty::Generics::empty())\n+    ty_generics(ccx, TypeSpace, generics, &ty::Generics::empty())\n }\n \n-fn ty_generic_bounds_for_type_or_impl<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                               ty_generics: &ty::Generics<'tcx>,\n-                                               generics: &ast::Generics)\n-                                               -> ty::GenericPredicates<'tcx>\n+fn ty_generic_predicates_for_type_or_impl<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                                   generics: &ast::Generics)\n+                                                   -> ty::GenericPredicates<'tcx>\n {\n-    ty_generic_bounds(ccx,\n-                      subst::TypeSpace,\n-                      ty_generics,\n-                      ty::GenericPredicates::empty(),\n-                      &generics.where_clause)\n+    ty_generic_predicates(ccx, TypeSpace, generics, &ty::GenericPredicates::empty())\n }\n \n-fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn ty_generics_for_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                    trait_id: ast::NodeId,\n-                                   substs: &'tcx subst::Substs<'tcx>,\n+                                   substs: &'tcx Substs<'tcx>,\n                                    ast_generics: &ast::Generics)\n                                    -> ty::Generics<'tcx>\n {\n     debug!(\"ty_generics_for_trait(trait_id={}, substs={})\",\n            local_def(trait_id).repr(ccx.tcx), substs.repr(ccx.tcx));\n \n-    let mut generics =\n-        ty_generics(ccx,\n-                    subst::TypeSpace,\n-                    &ast_generics.lifetimes,\n-                    &ast_generics.ty_params,\n-                    &ast_generics.where_clause,\n-                    ty::Generics::empty());\n+    let mut generics = ty_generics_for_type_or_impl(ccx, ast_generics);\n \n     // Add in the self type parameter.\n     //\n     // Something of a hack: use the node id for the trait, also as\n     // the node id for the Self type parameter.\n     let param_id = trait_id;\n \n-    let self_trait_ref =\n-        Rc::new(ty::TraitRef { def_id: local_def(trait_id),\n-                               substs: substs });\n-\n     let def = ty::TypeParameterDef {\n-        space: subst::SelfSpace,\n+        space: SelfSpace,\n         index: 0,\n         name: special_idents::type_self.name,\n         def_id: local_def(param_id),\n-        bounds: ty::ParamBounds {\n-            region_bounds: vec!(),\n-            builtin_bounds: ty::empty_builtin_bounds(),\n-            trait_bounds: vec!(ty::Binder(self_trait_ref.clone())),\n-            projection_bounds: vec!(),\n-        },\n         default: None,\n         object_lifetime_default: None,\n     };\n \n     ccx.tcx.ty_param_defs.borrow_mut().insert(param_id, def.clone());\n \n-    generics.types.push(subst::SelfSpace, def);\n+    generics.types.push(SelfSpace, def);\n \n     return generics;\n }\n \n-fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                         generics: &ast::Generics,\n-                                         base_generics: ty::Generics<'tcx>)\n-                                         -> ty::Generics<'tcx>\n+fn ty_generics_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                               generics: &ast::Generics,\n+                               base_generics: &ty::Generics<'tcx>)\n+                               -> ty::Generics<'tcx>\n {\n-    let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n-    ty_generics(ccx,\n-                subst::FnSpace,\n-                &early_lifetimes[..],\n-                &generics.ty_params,\n-                &generics.where_clause,\n-                base_generics)\n+    ty_generics(ccx, FnSpace, generics, base_generics)\n }\n \n-fn ty_generic_bounds_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                               generics: &ast::Generics,\n-                                               ty_generics: &ty::Generics<'tcx>,\n-                                               base: ty::GenericPredicates<'tcx>)\n-                                               -> ty::GenericPredicates<'tcx>\n+fn ty_generic_predicates_for_fn<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                         generics: &ast::Generics,\n+                                         base_predicates: &ty::GenericPredicates<'tcx>)\n+                                         -> ty::GenericPredicates<'tcx>\n {\n-    ty_generic_bounds(ccx,\n-                      subst::FnSpace,\n-                      ty_generics,\n-                      base,\n-                      &generics.where_clause)\n+    ty_generic_predicates(ccx, FnSpace, generics, base_predicates)\n }\n \n // Add the Sized bound, unless the type parameter is marked as `?Sized`.\n-fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                              bounds: &mut ty::BuiltinBounds,\n-                              ast_bounds: &[ast::TyParamBound],\n-                              span: Span)\n+fn add_unsized_bound<'tcx>(astconv: &AstConv<'tcx>,\n+                           bounds: &mut ty::BuiltinBounds,\n+                           ast_bounds: &[ast::TyParamBound],\n+                           span: Span)\n {\n+    let tcx = astconv.tcx();\n+\n     // Try to find an unbound in bounds.\n     let mut unbound = None;\n     for ab in ast_bounds {\n@@ -1405,80 +1658,108 @@ fn add_unsized_bound<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                 assert!(ptr.bound_lifetimes.is_empty());\n                 unbound = Some(ptr.trait_ref.clone());\n             } else {\n-                span_err!(ccx.tcx.sess, span, E0203,\n+                span_err!(tcx.sess, span, E0203,\n                           \"type parameter has more than one relaxed default \\\n                                                 bound, only one is supported\");\n             }\n         }\n     }\n \n-    let kind_id = ccx.tcx.lang_items.require(SizedTraitLangItem);\n+    let kind_id = tcx.lang_items.require(SizedTraitLangItem);\n     match unbound {\n         Some(ref tpb) => {\n             // FIXME(#8559) currently requires the unbound to be built-in.\n-            let trait_def_id = ty::trait_ref_to_def_id(ccx.tcx, tpb);\n+            let trait_def_id = ty::trait_ref_to_def_id(tcx, tpb);\n             match kind_id {\n                 Ok(kind_id) if trait_def_id != kind_id => {\n-                    ccx.tcx.sess.span_warn(span,\n-                                              \"default bound relaxed for a type parameter, but \\\n-                                               this does nothing because the given bound is not \\\n-                                               a default. Only `?Sized` is supported\");\n-                    ty::try_add_builtin_trait(ccx.tcx,\n-                                              kind_id,\n-                                              bounds);\n+                    tcx.sess.span_warn(span,\n+                                       \"default bound relaxed for a type parameter, but \\\n+                                       this does nothing because the given bound is not \\\n+                                       a default. Only `?Sized` is supported\");\n+                    ty::try_add_builtin_trait(tcx, kind_id, bounds);\n                 }\n                 _ => {}\n             }\n         }\n         _ if kind_id.is_ok() => {\n-            ty::try_add_builtin_trait(ccx.tcx, kind_id.unwrap(), bounds);\n+            ty::try_add_builtin_trait(tcx, kind_id.unwrap(), bounds);\n         }\n         // No lang item for Sized, so we can't add it as a bound.\n         None => {}\n     }\n }\n \n-fn ty_generic_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                              space: subst::ParamSpace,\n-                              generics: &ty::Generics<'tcx>,\n-                              base: ty::GenericPredicates<'tcx>,\n-                              where_clause: &ast::WhereClause)\n-                              -> ty::GenericPredicates<'tcx>\n+/// Returns the early-bound lifetimes declared in this generics\n+/// listing.  For anything other than fns/methods, this is just all\n+/// the lifetimes that are declared. For fns or methods, we have to\n+/// screen out those that do not appear in any where-clauses etc using\n+/// `resolve_lifetime::early_bound_lifetimes`.\n+fn early_bound_lifetimes_from_generics(space: ParamSpace,\n+                                       ast_generics: &ast::Generics)\n+                                       -> Vec<ast::LifetimeDef>\n+{\n+    match space {\n+        SelfSpace | TypeSpace => ast_generics.lifetimes.to_vec(),\n+        FnSpace => resolve_lifetime::early_bound_lifetimes(ast_generics),\n+    }\n+}\n+\n+fn ty_generic_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                  space: ParamSpace,\n+                                  ast_generics: &ast::Generics,\n+                                  base_predicates: &ty::GenericPredicates<'tcx>)\n+                                  -> ty::GenericPredicates<'tcx>\n {\n     let tcx = ccx.tcx;\n-    let mut result = base;\n-\n-    // For now, scrape the bounds out of parameters from Generics. This is not great.\n-    for def in generics.regions.get_slice(space) {\n-        let r_a = def.to_early_bound_region();\n-        for &r_b in &def.bounds {\n-            let outlives = ty::Binder(ty::OutlivesPredicate(r_a, r_b));\n-            result.predicates.push(def.space, ty::Predicate::RegionOutlives(outlives));\n-        }\n+    let mut result = base_predicates.clone();\n+\n+    // Collect the predicates that were written inline by the user on each\n+    // type parameter (e.g., `<T:Foo>`).\n+    for (index, param) in ast_generics.ty_params.iter().enumerate() {\n+        let index = index as u32;\n+        let param_ty = ty::ParamTy::new(space, index, param.ident.name).to_ty(ccx.tcx);\n+        let bounds = compute_bounds(&ccx.icx(&(base_predicates, ast_generics)),\n+                                    param_ty,\n+                                    &param.bounds,\n+                                    SizedByDefault::Yes,\n+                                    param.span);\n+        let predicates = ty::predicates(ccx.tcx, param_ty, &bounds);\n+        result.predicates.extend(space, predicates.into_iter());\n     }\n-    for def in generics.types.get_slice(space) {\n-        let t = ty::mk_param_from_def(ccx.tcx, def);\n-        result.predicates.extend(def.space, ty::predicates(ccx.tcx, t, &def.bounds).into_iter());\n+\n+    // Collect the region predicates that were declared inline as\n+    // well. In the case of parameters declared on a fn or method, we\n+    // have to be careful to only iterate over early-bound regions.\n+    let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n+    for (index, param) in early_lifetimes.iter().enumerate() {\n+        let index = index as u32;\n+        let region = ty::ReEarlyBound(param.lifetime.id, space, index, param.lifetime.name);\n+        for bound in &param.bounds {\n+            let bound_region = ast_region_to_region(ccx.tcx, bound);\n+            let outlives = ty::Binder(ty::OutlivesPredicate(region, bound_region));\n+            result.predicates.push(space, outlives.as_predicate());\n+        }\n     }\n \n-    // Add the bounds not associated with a type parameter\n+    // Add in the bounds that appear in the where-clause\n+    let where_clause = &ast_generics.where_clause;\n     for predicate in &where_clause.predicates {\n         match predicate {\n             &ast::WherePredicate::BoundPredicate(ref bound_pred) => {\n-                let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &*bound_pred.bounded_ty);\n+                let ty = ast_ty_to_ty(&ccx.icx(&(base_predicates, ast_generics)),\n+                                      &ExplicitRscope,\n+                                      &*bound_pred.bounded_ty);\n \n                 for bound in &*bound_pred.bounds {\n                     match bound {\n                         &ast::TyParamBound::TraitTyParamBound(ref poly_trait_ref, _) => {\n                             let mut projections = Vec::new();\n \n-                            let trait_ref = astconv::instantiate_poly_trait_ref(\n-                                ccx,\n-                                &ExplicitRscope,\n-                                poly_trait_ref,\n-                                Some(ty),\n-                                &mut projections,\n-                            );\n+                            let trait_ref =\n+                                conv_poly_trait_ref(&ccx.icx(&(base_predicates, ast_generics)),\n+                                                    ty,\n+                                                    poly_trait_ref,\n+                                                    &mut projections);\n \n                             result.predicates.push(space, trait_ref.as_predicate());\n \n@@ -1517,18 +1798,17 @@ fn ty_generic_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     return result;\n }\n \n-fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                        space: subst::ParamSpace,\n-                        lifetime_defs: &[ast::LifetimeDef],\n-                        types: &[ast::TyParam],\n-                        where_clause: &ast::WhereClause,\n-                        base_generics: ty::Generics<'tcx>)\n+fn ty_generics<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                        space: ParamSpace,\n+                        ast_generics: &ast::Generics,\n+                        base_generics: &ty::Generics<'tcx>)\n                         -> ty::Generics<'tcx>\n {\n     let tcx = ccx.tcx;\n-    let mut result = base_generics;\n+    let mut result = base_generics.clone();\n \n-    for (i, l) in lifetime_defs.iter().enumerate() {\n+    let early_lifetimes = early_bound_lifetimes_from_generics(space, ast_generics);\n+    for (i, l) in early_lifetimes.iter().enumerate() {\n         let bounds = l.bounds.iter()\n                              .map(|l| ast_region_to_region(tcx, l))\n                              .collect();\n@@ -1537,46 +1817,39 @@ fn ty_generics<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                                            index: i as u32,\n                                            def_id: local_def(l.lifetime.id),\n                                            bounds: bounds };\n-        // debug!(\"ty_generics: def for region param: {:?}\",\n-        //        def.repr(tcx));\n         result.regions.push(space, def);\n     }\n \n     assert!(result.types.is_empty_in(space));\n \n     // Now create the real type parameters.\n-    for (i, param) in types.iter().enumerate() {\n-        let def = get_or_create_type_parameter_def(ccx, space, param, i as u32, where_clause);\n+    for i in 0..ast_generics.ty_params.len() {\n+        let def = get_or_create_type_parameter_def(ccx, ast_generics, space, i as u32);\n         debug!(\"ty_generics: def for type param: {:?}, {:?}\", def, space);\n         result.types.push(space, def);\n     }\n \n     result\n }\n \n-fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                             space: subst::ParamSpace,\n-                                             param: &ast::TyParam,\n-                                             index: u32,\n-                                             where_clause: &ast::WhereClause)\n+fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                             ast_generics: &ast::Generics,\n+                                             space: ParamSpace,\n+                                             index: u32)\n                                              -> ty::TypeParameterDef<'tcx>\n {\n+    let param = &ast_generics.ty_params[index as usize];\n+\n     let tcx = ccx.tcx;\n     match tcx.ty_param_defs.borrow().get(&param.id) {\n         Some(d) => { return d.clone(); }\n         None => { }\n     }\n \n-    let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n-    let bounds = compute_bounds(ccx,\n-                                param_ty.to_ty(ccx.tcx),\n-                                &param.bounds,\n-                                SizedByDefault::Yes,\n-                                param.span);\n     let default = match param.default {\n         None => None,\n         Some(ref path) => {\n-            let ty = ast_ty_to_ty(ccx, &ExplicitRscope, &**path);\n+            let ty = ast_ty_to_ty(&ccx.icx(&()), &ExplicitRscope, &**path);\n             let cur_idx = index;\n \n             ty::walk_ty(ty, |t| {\n@@ -1595,14 +1868,14 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     };\n \n     let object_lifetime_default =\n-        compute_object_lifetime_default(ccx, space, index, &param.bounds, where_clause);\n+        compute_object_lifetime_default(ccx, param.id,\n+                                        &param.bounds, &ast_generics.where_clause);\n \n     let def = ty::TypeParameterDef {\n         space: space,\n         index: index,\n         name: param.ident.name,\n         def_id: local_def(param.id),\n-        bounds: bounds,\n         default: default,\n         object_lifetime_default: object_lifetime_default,\n     };\n@@ -1618,15 +1891,14 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n /// intentionally avoid just asking astconv to convert all the where\n /// clauses into a `ty::Predicate`. This is because that could induce\n /// artificial cycles.\n-fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                            space: subst::ParamSpace,\n-                                            index: u32,\n+fn compute_object_lifetime_default<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                            param_id: ast::NodeId,\n                                             param_bounds: &[ast::TyParamBound],\n                                             where_clause: &ast::WhereClause)\n                                             -> Option<ty::ObjectLifetimeDefault>\n {\n     let inline_bounds = from_bounds(ccx, param_bounds);\n-    let where_bounds = from_predicates(ccx, space, index, &where_clause.predicates);\n+    let where_bounds = from_predicates(ccx, param_id, &where_clause.predicates);\n     let all_bounds: HashSet<_> = inline_bounds.into_iter()\n                                               .chain(where_bounds.into_iter())\n                                               .collect();\n@@ -1638,7 +1910,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                   .map(ty::ObjectLifetimeDefault::Specific)\n     };\n \n-    fn from_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+    fn from_bounds<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n                             bounds: &[ast::TyParamBound])\n                             -> Vec<ty::Region>\n     {\n@@ -1648,15 +1920,14 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                       ast::TraitTyParamBound(..) =>\n                           None,\n                       ast::RegionTyParamBound(ref lifetime) =>\n-                          Some(astconv::ast_region_to_region(ccx.tcx(), lifetime)),\n+                          Some(astconv::ast_region_to_region(ccx.tcx, lifetime)),\n                   }\n               })\n               .collect()\n     }\n \n-    fn from_predicates<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                space: subst::ParamSpace,\n-                                index: u32,\n+    fn from_predicates<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n+                                param_id: ast::NodeId,\n                                 predicates: &[ast::WherePredicate])\n                                 -> Vec<ty::Region>\n     {\n@@ -1665,7 +1936,7 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                       match *predicate {\n                           ast::WherePredicate::BoundPredicate(ref data) => {\n                               if data.bound_lifetimes.len() == 0 &&\n-                                  is_param(ccx, &data.bounded_ty, space, index)\n+                                  is_param(ccx.tcx, &data.bounded_ty, param_id)\n                               {\n                                   from_bounds(ccx, &data.bounds).into_iter()\n                               } else {\n@@ -1680,50 +1951,32 @@ fn compute_object_lifetime_default<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n                   })\n                   .collect()\n     }\n-\n-    fn is_param(ccx: &CollectCtxt,\n-                ast_ty: &ast::Ty,\n-                space: subst::ParamSpace,\n-                index: u32)\n-                -> bool\n-    {\n-        if let ast::TyPath(None, _) = ast_ty.node {\n-            let path_res = ccx.tcx.def_map.borrow()[ast_ty.id];\n-            if let def::DefTyParam(s, i, _, _) = path_res.base_def {\n-                path_res.depth == 0 && space == s && index == i\n-            } else {\n-                false\n-            }\n-        } else {\n-            false\n-        }\n-    }\n }\n \n enum SizedByDefault { Yes, No }\n \n /// Translate the AST's notion of ty param bounds (which are an enum consisting of a newtyped Ty or\n /// a region) to ty's notion of ty param bounds, which can either be user-defined traits, or the\n /// built-in trait (formerly known as kind): Send.\n-fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                           param_ty: ty::Ty<'tcx>,\n-                           ast_bounds: &[ast::TyParamBound],\n-                           sized_by_default: SizedByDefault,\n-                           span: Span)\n-                           -> ty::ParamBounds<'tcx>\n+fn compute_bounds<'tcx>(astconv: &AstConv<'tcx>,\n+                        param_ty: ty::Ty<'tcx>,\n+                        ast_bounds: &[ast::TyParamBound],\n+                        sized_by_default: SizedByDefault,\n+                        span: Span)\n+                        -> ty::ParamBounds<'tcx>\n {\n-    let mut param_bounds = conv_param_bounds(ccx,\n+    let mut param_bounds = conv_param_bounds(astconv,\n                                              span,\n                                              param_ty,\n                                              ast_bounds);\n \n     if let SizedByDefault::Yes = sized_by_default {\n-        add_unsized_bound(ccx,\n+        add_unsized_bound(astconv,\n                           &mut param_bounds.builtin_bounds,\n                           ast_bounds,\n                           span);\n \n-        check_bounds_compatible(ccx,\n+        check_bounds_compatible(astconv,\n                                 param_ty,\n                                 &param_bounds,\n                                 span);\n@@ -1734,35 +1987,72 @@ fn compute_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     param_bounds\n }\n \n-fn check_bounds_compatible<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n-                                    param_ty: Ty<'tcx>,\n-                                    param_bounds: &ty::ParamBounds<'tcx>,\n-                                    span: Span) {\n+fn check_bounds_compatible<'tcx>(astconv: &AstConv<'tcx>,\n+                                 param_ty: Ty<'tcx>,\n+                                 param_bounds: &ty::ParamBounds<'tcx>,\n+                                 span: Span) {\n+    let tcx = astconv.tcx();\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n-            ccx.tcx,\n+            tcx,\n             &param_bounds.trait_bounds,\n             |trait_ref| {\n-                let trait_def = ccx.get_trait_def(trait_ref.def_id());\n-                if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n-                    span_err!(ccx.tcx.sess, span, E0129,\n-                              \"incompatible bounds on `{}`, \\\n-                               bound `{}` does not allow unsized type\",\n-                              param_ty.user_string(ccx.tcx),\n-                              trait_ref.user_string(ccx.tcx));\n+                match astconv.get_trait_def(span, trait_ref.def_id()) {\n+                    Ok(trait_def) => {\n+                        if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {\n+                            span_err!(tcx.sess, span, E0129,\n+                                      \"incompatible bounds on `{}`, \\\n+                                        bound `{}` does not allow unsized type\",\n+                                      param_ty.user_string(tcx),\n+                                      trait_ref.user_string(tcx));\n+                        }\n+                    }\n+                    Err(ErrorReported) => { }\n                 }\n                 true\n             });\n     }\n }\n \n-fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n+/// Converts a specific TyParamBound from the AST into the\n+/// appropriate poly-trait-reference.\n+fn poly_trait_ref_from_bound<'tcx>(astconv: &AstConv<'tcx>,\n+                                   param_ty: Ty<'tcx>,\n+                                   bound: &ast::TyParamBound,\n+                                   projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                                   -> Option<ty::PolyTraitRef<'tcx>>\n+{\n+    match *bound {\n+        ast::TraitTyParamBound(ref tr, ast::TraitBoundModifier::None) => {\n+            Some(conv_poly_trait_ref(astconv, param_ty, tr, projections))\n+        }\n+        ast::TraitTyParamBound(_, ast::TraitBoundModifier::Maybe) |\n+        ast::RegionTyParamBound(_) => {\n+            None\n+        }\n+    }\n+}\n+\n+fn conv_poly_trait_ref<'tcx>(astconv: &AstConv<'tcx>,\n+                             param_ty: Ty<'tcx>,\n+                             trait_ref: &ast::PolyTraitRef,\n+                             projections: &mut Vec<ty::PolyProjectionPredicate<'tcx>>)\n+                             -> ty::PolyTraitRef<'tcx>\n+{\n+    astconv::instantiate_poly_trait_ref(astconv,\n+                                        &ExplicitRscope,\n+                                        trait_ref,\n+                                        Some(param_ty),\n+                                        projections)\n+}\n+\n+fn conv_param_bounds<'a,'tcx>(astconv: &AstConv<'tcx>,\n                               span: Span,\n                               param_ty: ty::Ty<'tcx>,\n                               ast_bounds: &[ast::TyParamBound])\n                               -> ty::ParamBounds<'tcx>\n {\n-    let tcx = ccx.tcx;\n+    let tcx = astconv.tcx();\n     let astconv::PartitionedBounds {\n         builtin_bounds,\n         trait_bounds,\n@@ -1772,19 +2062,16 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let mut projection_bounds = Vec::new();\n \n     let trait_bounds: Vec<ty::PolyTraitRef> =\n-        trait_bounds.into_iter()\n-        .map(|bound| {\n-            astconv::instantiate_poly_trait_ref(ccx,\n-                                                &ExplicitRscope,\n-                                                bound,\n-                                                Some(param_ty),\n-                                                &mut projection_bounds)\n-        })\n-    .collect();\n+        trait_bounds.iter()\n+                    .map(|bound| conv_poly_trait_ref(astconv,\n+                                                     param_ty,\n+                                                     *bound,\n+                                                     &mut projection_bounds))\n+                    .collect();\n \n     let region_bounds: Vec<ty::Region> =\n         region_bounds.into_iter()\n-                     .map(|r| ast_region_to_region(ccx.tcx, r))\n+                     .map(|r| ast_region_to_region(tcx, r))\n                      .collect();\n \n     ty::ParamBounds {\n@@ -1796,7 +2083,7 @@ fn conv_param_bounds<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n }\n \n fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n-    ccx: &CollectCtxt<'a, 'tcx>,\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     decl: &ast::FnDecl,\n     ast_generics: &ast::Generics,\n     abi: abi::Abi)\n@@ -1813,17 +2100,17 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n         }\n     }\n \n-    let ty_generics = ty_generics_for_fn_or_method(ccx, ast_generics, ty::Generics::empty());\n+    let ty_generics = ty_generics_for_fn(ccx, ast_generics, &ty::Generics::empty());\n \n     let rb = BindingRscope::new();\n     let input_tys = decl.inputs\n                         .iter()\n-                        .map(|a| ty_of_arg(ccx, &rb, a, None))\n+                        .map(|a| ty_of_arg(&ccx.icx(ast_generics), &rb, a, None))\n                         .collect();\n \n     let output = match decl.output {\n         ast::Return(ref ty) =>\n-            ty::FnConverging(ast_ty_to_ty(ccx, &rb, &**ty)),\n+            ty::FnConverging(ast_ty_to_ty(&ccx.icx(ast_generics), &rb, &**ty)),\n         ast::DefaultReturn(..) =>\n             ty::FnConverging(ty::mk_nil(ccx.tcx)),\n         ast::NoReturn(..) =>\n@@ -1847,9 +2134,9 @@ fn compute_type_scheme_of_foreign_fn_decl<'a, 'tcx>(\n     }\n }\n \n-fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n+fn mk_item_substs<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             ty_generics: &ty::Generics<'tcx>)\n-                            -> subst::Substs<'tcx>\n+                            -> Substs<'tcx>\n {\n     let types =\n         ty_generics.types.map(\n@@ -1859,7 +2146,7 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ty_generics.regions.map(\n             |def| def.to_early_bound_region());\n \n-    subst::Substs::new(types, regions)\n+    Substs::new(types, regions)\n }\n \n /// Verifies that the explicit self type of a method matches the impl\n@@ -1869,15 +2156,16 @@ fn mk_item_substs<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n /// comes back to check after the fact that explicit type the user\n /// wrote actually matches what the pre-defined option said.\n fn check_method_self_type<'a, 'tcx, RS:RegionScope>(\n-    ccx: &CollectCtxt<'a, 'tcx>,\n+    ccx: &CrateCtxt<'a, 'tcx>,\n     rs: &RS,\n+    method_type: Rc<ty::Method<'tcx>>,\n     required_type: Ty<'tcx>,\n     explicit_self: &ast::ExplicitSelf,\n     body_id: ast::NodeId)\n {\n     let tcx = ccx.tcx;\n     if let ast::SelfExplicit(ref ast_type, _) = explicit_self.node {\n-        let typ = ccx.to_ty(rs, &**ast_type);\n+        let typ = ccx.icx(&method_type.predicates).to_ty(rs, &**ast_type);\n         let base_type = match typ.sty {\n             ty::ty_ptr(tm) | ty::ty_rptr(_, tm) => tm.ty,\n             ty::ty_uniq(typ) => typ,"}, {"sha": "36d39fa58ba7e5ec7e23a8bcc5cc2c595e59f341", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -479,11 +479,10 @@ impl<'tcx> Clean<TyParam> for ty::TypeParameterDef<'tcx> {\n     fn clean(&self, cx: &DocContext) -> TyParam {\n         cx.external_typarams.borrow_mut().as_mut().unwrap()\n           .insert(self.def_id, self.name.clean(cx));\n-        let bounds = self.bounds.clean(cx);\n         TyParam {\n             name: self.name.clean(cx),\n             did: self.def_id,\n-            bounds: bounds,\n+            bounds: vec![], // these are filled in from the where-clauses\n             default: self.default.clean(cx),\n         }\n     }\n@@ -892,9 +891,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics<'tcx>,\n         // Bounds in the type_params and lifetimes fields are repeated in the predicates\n         // field (see rustc_typeck::collect::ty_generics), so remove them.\n         let stripped_typarams = gens.types.get_slice(space).iter().map(|tp| {\n-            let mut stp = tp.clone();\n-            stp.bounds = ty::ParamBounds::empty();\n-            stp.clean(cx)\n+            tp.clean(cx)\n         }).collect::<Vec<_>>();\n         let stripped_lifetimes = gens.regions.get_slice(space).iter().map(|rp| {\n             let mut srp = rp.clone();"}, {"sha": "ce97019a2b266d5558f39b78fe89965b90d6ad2a", "filename": "src/test/compile-fail/associated-type-projection-ambig-between-bound-and-where-clause.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-ambig-between-bound-and-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-ambig-between-bound-and-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-ambig-between-bound-and-where-clause.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -0,0 +1,52 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test equality constraints in a where clause where the type being\n+// equated appears in a supertrait.\n+\n+pub trait Vehicle {\n+    type Color;\n+\n+    fn go(&self) {  }\n+}\n+\n+pub trait Box {\n+    type Color;\n+\n+    fn mail(&self) {  }\n+}\n+\n+fn a<C:Vehicle+Box>(_: C::Color) {\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n+}\n+\n+fn b<C>(_: C::Color) where C : Vehicle+Box {\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n+}\n+\n+fn c<C>(_: C::Color) where C : Vehicle, C : Box {\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `C`\n+}\n+\n+struct D<X>;\n+impl<X> D<X> where X : Vehicle {\n+    fn d(&self, _: X::Color) where X : Box { }\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `X`\n+}\n+\n+trait E<X:Vehicle> {\n+    fn e(&self, _: X::Color) where X : Box;\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `X`\n+\n+    fn f(&self, _: X::Color) where X : Box { }\n+    //~^ ERROR ambiguous associated type `Color` in bounds of `X`\n+}\n+\n+pub fn main() { }"}, {"sha": "abcbf567d44360f6584efcbfb0da509295d86501", "filename": "src/test/compile-fail/cycle-projection-based-on-where-clause.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-projection-based-on-where-clause.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Example cycle where a bound on `T` uses a shorthand for `T`. This\n+// creates a cycle because we have to know the bounds on `T` to figure\n+// out what trait defines `Item`, but we can't know the bounds on `T`\n+// without knowing how to handle `T::Item`.\n+//\n+// Note that in the future cases like this could perhaps become legal,\n+// if we got more fine-grained about our cycle detection or changed\n+// how we handle `T::Item` resolution.\n+\n+use std::ops::Add;\n+\n+// Preamble.\n+trait Trait { type Item; }\n+\n+struct A<T>\n+    where T : Trait,\n+          T : Add<T::Item>\n+    //~^ ERROR illegal recursive type\n+{\n+    data: T\n+}\n+\n+fn main() {\n+}"}, {"sha": "ef3fead18f6aa1d34f99450012f30764b77ad116", "filename": "src/test/compile-fail/cycle-trait-supertrait-direct.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-direct.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a supertrait cycle where a trait extends itself.\n+\n+trait Chromosome: Chromosome {\n+    //~^ ERROR unsupported cyclic reference\n+}\n+\n+fn main() { }"}, {"sha": "6ebd9a1bcb6e2548cb89a11d173d923911cfc98c", "filename": "src/test/compile-fail/cycle-trait-supertrait-indirect.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcycle-trait-supertrait-indirect.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a supertrait cycle where the first trait we find (`A`) is not\n+// a direct participant in the cycle.\n+\n+trait A: B {\n+}\n+\n+trait B: C { }\n+\n+trait C: B { }\n+    //~^ ERROR unsupported cyclic reference\n+\n+fn main() { }"}, {"sha": "2243e00ffa1604be0dbbc724ed0c1fbbe7e60f98", "filename": "src/test/run-pass/associated-types-project-from-type-param-via-bound-in-where-clause.rs", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fassociated-types-project-from-type-param-via-bound-in-where-clause.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -0,0 +1,107 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Various uses of `T::Item` syntax where the bound that supplies\n+// `Item` originates in a where-clause, not the declaration of\n+// `T`. Issue #20300.\n+\n+use std::marker::{MarkerTrait, PhantomData};\n+use std::sync::atomic::{AtomicUsize, ATOMIC_USIZE_INIT};\n+use std::sync::atomic::Ordering::SeqCst;\n+\n+static COUNTER: AtomicUsize = ATOMIC_USIZE_INIT;\n+\n+// Preamble.\n+trait Trait : MarkerTrait { type Item; }\n+struct Struct;\n+impl Trait for Struct {\n+    type Item = u32;\n+}\n+\n+// Where-clause attached on the method which declares `T`.\n+struct A;\n+impl A {\n+    fn foo<T>(_x: T::Item) where T: Trait {\n+        COUNTER.fetch_add(1, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached on the method to a parameter from the struct.\n+struct B<T>(PhantomData<T>);\n+impl<T> B<T> {\n+    fn foo(_x: T::Item) where T: Trait {\n+        COUNTER.fetch_add(10, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached to free fn.\n+fn c<T>(_: T::Item) where T : Trait {\n+    COUNTER.fetch_add(100, SeqCst);\n+}\n+\n+// Where-clause attached to defaulted and non-defaulted trait method.\n+trait AnotherTrait {\n+    fn method<T>(&self, _: T::Item) where T: Trait;\n+    fn default_method<T>(&self, _: T::Item) where T: Trait {\n+        COUNTER.fetch_add(1000, SeqCst);\n+    }\n+}\n+struct D;\n+impl AnotherTrait for D {\n+    fn method<T>(&self, _: T::Item) where T: Trait {\n+        COUNTER.fetch_add(10000, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached to trait and impl containing the method.\n+trait YetAnotherTrait<T>\n+    where T : Trait\n+{\n+    fn method(&self, _: T::Item);\n+    fn default_method(&self, _: T::Item) {\n+        COUNTER.fetch_add(100000, SeqCst);\n+    }\n+}\n+struct E<T>(PhantomData<T>);\n+impl<T> YetAnotherTrait<T> for E<T>\n+    where T : Trait\n+{\n+    fn method(&self, _: T::Item) {\n+        COUNTER.fetch_add(1000000, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached to inherent impl containing the method.\n+struct F<T>(PhantomData<T>);\n+impl<T> F<T> where T : Trait {\n+    fn method(&self, _: T::Item) {\n+        COUNTER.fetch_add(10000000, SeqCst);\n+    }\n+}\n+\n+// Where-clause attached to struct.\n+#[allow(dead_code)]\n+struct G<T> where T : Trait {\n+    data: T::Item,\n+    phantom: PhantomData<T>,\n+}\n+\n+fn main() {\n+    A::foo::<Struct>(22);\n+    B::<Struct>::foo(22);\n+    c::<Struct>(22);\n+    D.method::<Struct>(22);\n+    D.default_method::<Struct>(22);\n+    E(PhantomData::<Struct>).method(22);\n+    E(PhantomData::<Struct>).default_method(22);\n+    F(PhantomData::<Struct>).method(22);\n+    G::<Struct> { data: 22, phantom: PhantomData };\n+    assert_eq!(COUNTER.load(SeqCst), 11111111);\n+}"}, {"sha": "2388a567f3043e2b10c1a8ffb439b7de3397544b", "filename": "src/test/run-pass/cycle-generic-bound.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-generic-bound.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for #15477. This test just needs to compile.\n+\n+use std::marker::PhantomFn;\n+\n+trait Chromosome<X: Chromosome<i32>> : PhantomFn<(Self,X)> {\n+}\n+\n+fn main() { }"}, {"sha": "6e16e68610603f1f9e7123a5697ef0f515f56729", "filename": "src/test/run-pass/cycle-trait-type-trait.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/880fb89bde126aa43fc348d0b93839d3d18a1f51/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcycle-trait-type-trait.rs?ref=880fb89bde126aa43fc348d0b93839d3d18a1f51", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a case where a supertrait references a type that references\n+// the original trait. This poses no problem at the moment.\n+\n+trait Chromosome: Get<Struct<i32>> {\n+}\n+\n+trait Get<A> {\n+    fn get(&self) -> A;\n+}\n+\n+struct Struct<C:Chromosome> { c: C }\n+\n+fn main() { }"}]}