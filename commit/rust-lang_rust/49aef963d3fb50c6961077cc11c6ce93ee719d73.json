{"sha": "49aef963d3fb50c6961077cc11c6ce93ee719d73", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5YWVmOTYzZDNmYjUwYzY5NjEwNzdjYzExYzZjZTkzZWU3MTlkNzM=", "commit": {"author": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2020-08-10T20:06:48Z"}, "committer": {"name": "Matt Brubeck", "email": "mbrubeck@limpet.net", "date": "2020-09-09T00:24:28Z"}, "message": "Add HashMap::drain_filter and HashSet::drain_filter\n\nImplements #59618.", "tree": {"sha": "a79dee945d1191059731bf16c529a1b2dce20bdd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a79dee945d1191059731bf16c529a1b2dce20bdd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49aef963d3fb50c6961077cc11c6ce93ee719d73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49aef963d3fb50c6961077cc11c6ce93ee719d73", "html_url": "https://github.com/rust-lang/rust/commit/49aef963d3fb50c6961077cc11c6ce93ee719d73", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49aef963d3fb50c6961077cc11c6ce93ee719d73/comments", "author": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mbrubeck", "id": 5920, "node_id": "MDQ6VXNlcjU5MjA=", "avatar_url": "https://avatars.githubusercontent.com/u/5920?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mbrubeck", "html_url": "https://github.com/mbrubeck", "followers_url": "https://api.github.com/users/mbrubeck/followers", "following_url": "https://api.github.com/users/mbrubeck/following{/other_user}", "gists_url": "https://api.github.com/users/mbrubeck/gists{/gist_id}", "starred_url": "https://api.github.com/users/mbrubeck/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mbrubeck/subscriptions", "organizations_url": "https://api.github.com/users/mbrubeck/orgs", "repos_url": "https://api.github.com/users/mbrubeck/repos", "events_url": "https://api.github.com/users/mbrubeck/events{/privacy}", "received_events_url": "https://api.github.com/users/mbrubeck/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebd15e790aceeaacb01bdd5c4361c5b4be2db237", "html_url": "https://github.com/rust-lang/rust/commit/ebd15e790aceeaacb01bdd5c4361c5b4be2db237"}], "stats": {"total": 171, "additions": 171, "deletions": 0}, "files": [{"sha": "1a3a493fbb8f68dcff12a948f828669847bf99fb", "filename": "library/std/src/collections/hash/map.rs", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/49aef963d3fb50c6961077cc11c6ce93ee719d73/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49aef963d3fb50c6961077cc11c6ce93ee719d73/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fmap.rs?ref=49aef963d3fb50c6961077cc11c6ce93ee719d73", "patch": "@@ -497,6 +497,50 @@ impl<K, V, S> HashMap<K, V, S> {\n         Drain { base: self.base.drain() }\n     }\n \n+    /// Creates an iterator which uses a closure to determine if an element should be removed.\n+    ///\n+    /// If the closure returns true, the element is removed from the map and yielded.\n+    /// If the closure returns false, or panics, the element remains in the map and will not be\n+    /// yielded.\n+    ///\n+    /// Note that `drain_filter` lets you mutate every value in the filter closure, regardless of\n+    /// whether you choose to keep or remove it.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// elements will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more elements will be subjected to the closure\n+    /// if a panic occurs in the closure, or a panic occurs while dropping an element,\n+    /// or if the `DrainFilter` value is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a map into even and odd keys, reusing the original map:\n+    ///\n+    /// ```\n+    /// #![feature(hash_drain_filter)]\n+    /// use std::collections::HashMap;\n+    ///\n+    /// let mut map: HashMap<i32, i32> = (0..8).map(|x| (x, x)).collect();\n+    /// let drained: HashMap<i32, i32> = map.drain_filter(|k, _v| k % 2 == 0).collect();\n+    ///\n+    /// let mut evens = drained.keys().copied().collect::<Vec<_>>();\n+    /// let mut odds = map.keys().copied().collect::<Vec<_>>();\n+    /// evens.sort();\n+    /// odds.sort();\n+    ///\n+    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, K, V, F>\n+    where\n+        F: FnMut(&K, &mut V) -> bool,\n+    {\n+        DrainFilter { base: self.base.drain_filter(pred) }\n+    }\n+\n     /// Clears the map, removing all key-value pairs. Keeps the allocated memory\n     /// for reuse.\n     ///\n@@ -1190,6 +1234,19 @@ impl<'a, K, V> Drain<'a, K, V> {\n     }\n }\n \n+/// A draining, filtering iterator over the entries of a `HashMap`.\n+///\n+/// This `struct` is created by the [`drain_filter`] method on [`HashMap`].\n+///\n+/// [`drain_filter`]: HashMap::drain_filter\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+pub struct DrainFilter<'a, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    base: base::DrainFilter<'a, K, V, F>,\n+}\n+\n /// A mutable iterator over the values of a `HashMap`.\n ///\n /// This `struct` is created by the [`values_mut`] method on [`HashMap`]. See its\n@@ -1990,6 +2047,36 @@ where\n     }\n }\n \n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, V, F> Iterator for DrainFilter<'_, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    type Item = (K, V);\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<(K, V)> {\n+        self.base.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.base.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, V, F> FusedIterator for DrainFilter<'_, K, V, F> where F: FnMut(&K, &mut V) -> bool {}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<'a, K, V, F> fmt::Debug for DrainFilter<'a, K, V, F>\n+where\n+    F: FnMut(&K, &mut V) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"DrainFilter { .. }\")\n+    }\n+}\n+\n impl<'a, K, V> Entry<'a, K, V> {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     /// Ensures a value is in the entry by inserting the default if empty, and returns"}, {"sha": "72f4798b65d66d665f27c1bb9af67636e09bb6b0", "filename": "library/std/src/collections/hash/set.rs", "status": "modified", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/49aef963d3fb50c6961077cc11c6ce93ee719d73/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49aef963d3fb50c6961077cc11c6ce93ee719d73/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fcollections%2Fhash%2Fset.rs?ref=49aef963d3fb50c6961077cc11c6ce93ee719d73", "patch": "@@ -247,6 +247,47 @@ impl<T, S> HashSet<T, S> {\n         Drain { base: self.base.drain() }\n     }\n \n+    /// Creates an iterator which uses a closure to determine if a value should be removed.\n+    ///\n+    /// If the closure returns true, then the value is removed and yielded.\n+    /// If the closure returns false, the value will remain in the list and will not be yielded\n+    /// by the iterator.\n+    ///\n+    /// If the iterator is only partially consumed or not consumed at all, each of the remaining\n+    /// values will still be subjected to the closure and removed and dropped if it returns true.\n+    ///\n+    /// It is unspecified how many more values will be subjected to the closure\n+    /// if a panic occurs in the closure, or if a panic occurs while dropping a value, or if the\n+    /// `DrainFilter` itself is leaked.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Splitting a set into even and odd values, reusing the original set:\n+    ///\n+    /// ```\n+    /// #![feature(hash_drain_filter)]\n+    /// use std::collections::HashSet;\n+    ///\n+    /// let mut set: HashSet<i32> = (0..8).collect();\n+    /// let drained: HashSet<i32> = set.drain_filter(|v| v % 2 == 0).collect();\n+    ///\n+    /// let mut evens = drained.into_iter().collect::<Vec<_>>();\n+    /// let mut odds = set.into_iter().collect::<Vec<_>>();\n+    /// evens.sort();\n+    /// odds.sort();\n+    ///\n+    /// assert_eq!(evens, vec![0, 2, 4, 6]);\n+    /// assert_eq!(odds, vec![1, 3, 5, 7]);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+    pub fn drain_filter<F>(&mut self, pred: F) -> DrainFilter<'_, T, F>\n+    where\n+        F: FnMut(&T) -> bool,\n+    {\n+        DrainFilter { base: self.base.drain_filter(pred) }\n+    }\n+\n     /// Clears the set, removing all values.\n     ///\n     /// # Examples\n@@ -1159,6 +1200,19 @@ pub struct Drain<'a, K: 'a> {\n     base: base::Drain<'a, K>,\n }\n \n+/// A draining, filtering iterator over the items of a `HashSet`.\n+///\n+/// This `struct` is created by the [`drain_filter`] method on [`HashSet`].\n+///\n+/// [`drain_filter`]: HashSet::drain_filter\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+pub struct DrainFilter<'a, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    base: base::DrainFilter<'a, K, F>,\n+}\n+\n /// A lazy iterator producing elements in the intersection of `HashSet`s.\n ///\n /// This `struct` is created by the [`intersection`] method on [`HashSet`].\n@@ -1348,6 +1402,36 @@ impl<K: fmt::Debug> fmt::Debug for Drain<'_, K> {\n     }\n }\n \n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, F> Iterator for DrainFilter<'_, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    type Item = K;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<K> {\n+        self.base.next()\n+    }\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.base.size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<K, F> FusedIterator for DrainFilter<'_, K, F> where F: FnMut(&K) -> bool {}\n+\n+#[unstable(feature = \"hash_drain_filter\", issue = \"59618\")]\n+impl<'a, K, F> fmt::Debug for DrainFilter<'a, K, F>\n+where\n+    F: FnMut(&K) -> bool,\n+{\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.pad(\"DrainFilter { .. }\")\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T, S> Clone for Intersection<'_, T, S> {\n     #[inline]"}]}