{"sha": "e83948631836555c61f9eb97e8657f28c74ba433", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4Mzk0ODYzMTgzNjU1NWM2MWY5ZWI5N2U4NjU3ZjI4Yzc0YmE0MzM=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2017-03-01T08:44:05Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2017-03-10T16:08:32Z"}, "message": "Move `resolve_invoc` from `syntax` to `resolve`.", "tree": {"sha": "0738486d39d2061fa4e3eb99219aab9b5361e579", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0738486d39d2061fa4e3eb99219aab9b5361e579"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e83948631836555c61f9eb97e8657f28c74ba433", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e83948631836555c61f9eb97e8657f28c74ba433", "html_url": "https://github.com/rust-lang/rust/commit/e83948631836555c61f9eb97e8657f28c74ba433", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e83948631836555c61f9eb97e8657f28c74ba433/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "212b6c25507b963b60a646a2ff3df7496bd30acf", "url": "https://api.github.com/repos/rust-lang/rust/commits/212b6c25507b963b60a646a2ff3df7496bd30acf", "html_url": "https://github.com/rust-lang/rust/commit/212b6c25507b963b60a646a2ff3df7496bd30acf"}], "stats": {"total": 150, "additions": 78, "deletions": 72}, "files": [{"sha": "bec8bf845a75af6bb76c9ae9abaad8c80684dccf", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 67, "deletions": 9, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/e83948631836555c61f9eb97e8657f28c74ba433/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83948631836555c61f9eb97e8657f28c74ba433/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=e83948631836555c61f9eb97e8657f28c74ba433", "patch": "@@ -17,16 +17,14 @@ use rustc::hir::def_id::{DefId, BUILTIN_MACROS_CRATE, CRATE_DEF_INDEX, DefIndex}\n use rustc::hir::def::{Def, Export};\n use rustc::hir::map::{self, DefCollector};\n use rustc::ty;\n-use std::cell::Cell;\n-use std::rc::Rc;\n use syntax::ast::{self, Name, Ident};\n-use syntax::attr;\n+use syntax::attr::{self, HasAttrs};\n use syntax::errors::DiagnosticBuilder;\n-use syntax::ext::base::{self, Determinacy, MultiModifier, MultiDecorator};\n-use syntax::ext::base::{Resolver as SyntaxResolver, SyntaxExtension};\n-use syntax::ext::base::MacroKind;\n-use syntax::ext::expand::Expansion;\n+use syntax::ext::base::{self, Annotatable, Determinacy, MultiModifier, MultiDecorator};\n+use syntax::ext::base::{MacroKind, SyntaxExtension, Resolver as SyntaxResolver};\n+use syntax::ext::expand::{Expansion, ExpansionKind, Invocation, InvocationKind, find_attr_invoc};\n use syntax::ext::hygiene::Mark;\n+use syntax::ext::placeholders::placeholder;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{self, emit_feature_err, GateIssue};\n use syntax::fold::{self, Folder};\n@@ -35,6 +33,10 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n use syntax_pos::{Span, DUMMY_SP};\n \n+use std::cell::Cell;\n+use std::mem;\n+use std::rc::Rc;\n+\n #[derive(Clone)]\n pub struct InvocationData<'a> {\n     pub module: Cell<Module<'a>>,\n@@ -235,8 +237,64 @@ impl<'a> base::Resolver for Resolver<'a> {\n         None\n     }\n \n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n-                     force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n+    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n+        let (attr, traits, item) = match invoc.kind {\n+            InvocationKind::Attr { attr: None, .. } => return Ok(None),\n+            InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n+            InvocationKind::Bang { ref mac, .. } => {\n+                return self.resolve_macro(scope, &mac.node.path, MacroKind::Bang, force).map(Some);\n+            }\n+            InvocationKind::Derive { name, span, .. } => {\n+                let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n+                return self.resolve_macro(scope, &path, MacroKind::Derive, force).map(Some);\n+            }\n+        };\n+\n+        let (attr_name, path) = {\n+            let attr = attr.as_ref().unwrap();\n+            (attr.name(), ast::Path::from_ident(attr.span, Ident::with_empty_ctxt(attr.name())))\n+        };\n+\n+        let mut determined = true;\n+        match self.resolve_macro(scope, &path, MacroKind::Attr, force) {\n+            Ok(ext) => return Ok(Some(ext)),\n+            Err(Determinacy::Undetermined) => determined = false,\n+            Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n+            Err(Determinacy::Determined) => {}\n+        }\n+\n+        for &(name, span) in traits {\n+            let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n+            match self.resolve_macro(scope, &path, MacroKind::Derive, force) {\n+                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n+                    if inert_attrs.contains(&attr_name) {\n+                        // FIXME(jseyfried) Avoid `mem::replace` here.\n+                        let dummy_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n+                            .make_items().pop().unwrap();\n+                        let dummy_item = Annotatable::Item(dummy_item);\n+                        *item = mem::replace(item, dummy_item).map_attrs(|mut attrs| {\n+                            let inert_attr = attr.take().unwrap();\n+                            attr::mark_known(&inert_attr);\n+                            if self.proc_macro_enabled {\n+                                *attr = find_attr_invoc(&mut attrs);\n+                            }\n+                            attrs.push(inert_attr);\n+                            attrs\n+                        });\n+                    }\n+                    return Err(Determinacy::Undetermined);\n+                },\n+                Err(Determinacy::Undetermined) => determined = false,\n+                Err(Determinacy::Determined) => {}\n+            }\n+        }\n+\n+        Err(if determined { Determinacy::Determined } else { Determinacy::Undetermined })\n+    }\n+\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy> {\n         let ast::Path { ref segments, span } = *path;\n         if segments.iter().any(|segment| segment.parameters.is_some()) {\n             let kind ="}, {"sha": "dc7e7673eb03cb1c1d6282852131824c94d99cb0", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/e83948631836555c61f9eb97e8657f28c74ba433/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83948631836555c61f9eb97e8657f28c74ba433/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=e83948631836555c61f9eb97e8657f28c74ba433", "patch": "@@ -15,7 +15,7 @@ use attr::HasAttrs;\n use codemap::{self, CodeMap, ExpnInfo, Spanned, respan};\n use syntax_pos::{Span, ExpnId, NO_EXPANSION};\n use errors::{DiagnosticBuilder, FatalError};\n-use ext::expand::{self, Expansion};\n+use ext::expand::{self, Expansion, Invocation};\n use ext::hygiene::Mark;\n use fold::{self, Folder};\n use parse::{self, parser, DirectoryOwnership};\n@@ -557,8 +557,10 @@ pub trait Resolver {\n     fn resolve_imports(&mut self);\n     // Resolves attribute and derive legacy macros from `#![plugin(..)]`.\n     fn find_legacy_attr_invoc(&mut self, attrs: &mut Vec<Attribute>) -> Option<Attribute>;\n-    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind,\n-                     force: bool) -> Result<Rc<SyntaxExtension>, Determinacy>;\n+    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n+                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy>;\n+    fn resolve_macro(&mut self, scope: Mark, path: &ast::Path, kind: MacroKind, force: bool)\n+                     -> Result<Rc<SyntaxExtension>, Determinacy>;\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -580,6 +582,10 @@ impl Resolver for DummyResolver {\n \n     fn resolve_imports(&mut self) {}\n     fn find_legacy_attr_invoc(&mut self, _attrs: &mut Vec<Attribute>) -> Option<Attribute> { None }\n+    fn resolve_invoc(&mut self, _invoc: &mut Invocation, _scope: Mark, _force: bool)\n+                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n+        Err(Determinacy::Determined)\n+    }\n     fn resolve_macro(&mut self, _scope: Mark, _path: &ast::Path, _kind: MacroKind,\n                      _force: bool) -> Result<Rc<SyntaxExtension>, Determinacy> {\n         Err(Determinacy::Determined)"}, {"sha": "a208986becf721f99ae8eda66f0b4e724e99018d", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 60, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/e83948631836555c61f9eb97e8657f28c74ba433/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e83948631836555c61f9eb97e8657f28c74ba433/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=e83948631836555c61f9eb97e8657f28c74ba433", "patch": "@@ -251,7 +251,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n \n             let scope =\n                 if self.monotonic { invoc.expansion_data.mark } else { orig_expansion_data.mark };\n-            let ext = match self.resolve_invoc(&mut invoc, scope, force) {\n+            let ext = match self.cx.resolver.resolve_invoc(&mut invoc, scope, force) {\n                 Ok(ext) => Some(ext),\n                 Err(Determinacy::Determined) => None,\n                 Err(Determinacy::Undetermined) => {\n@@ -364,64 +364,6 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         result\n     }\n \n-    fn resolve_invoc(&mut self, invoc: &mut Invocation, scope: Mark, force: bool)\n-                     -> Result<Option<Rc<SyntaxExtension>>, Determinacy> {\n-        let (attr, traits, item) = match invoc.kind {\n-            InvocationKind::Bang { ref mac, .. } => {\n-                return self.cx.resolver.resolve_macro(scope, &mac.node.path,\n-                                                      MacroKind::Bang, force).map(Some);\n-            }\n-            InvocationKind::Attr { attr: None, .. } => return Ok(None),\n-            InvocationKind::Derive { name, span, .. } => {\n-                let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-                return self.cx.resolver.resolve_macro(scope, &path,\n-                                                      MacroKind::Derive, force).map(Some)\n-            }\n-            InvocationKind::Attr { ref mut attr, ref traits, ref mut item } => (attr, traits, item),\n-        };\n-\n-        let (attr_name, path) = {\n-            let attr = attr.as_ref().unwrap();\n-            (attr.name(), ast::Path::from_ident(attr.span, Ident::with_empty_ctxt(attr.name())))\n-        };\n-\n-        let mut determined = true;\n-        match self.cx.resolver.resolve_macro(scope, &path, MacroKind::Attr, force) {\n-            Ok(ext) => return Ok(Some(ext)),\n-            Err(Determinacy::Undetermined) => determined = false,\n-            Err(Determinacy::Determined) if force => return Err(Determinacy::Determined),\n-            _ => {}\n-        }\n-\n-        for &(name, span) in traits {\n-            let path = ast::Path::from_ident(span, Ident::with_empty_ctxt(name));\n-            match self.cx.resolver.resolve_macro(scope, &path, MacroKind::Derive, force) {\n-                Ok(ext) => if let SyntaxExtension::ProcMacroDerive(_, ref inert_attrs) = *ext {\n-                    if inert_attrs.contains(&attr_name) {\n-                        // FIXME(jseyfried) Avoid `mem::replace` here.\n-                        let dummy_item = placeholder(ExpansionKind::Items, ast::DUMMY_NODE_ID)\n-                            .make_items().pop().unwrap();\n-                        *item = mem::replace(item, Annotatable::Item(dummy_item))\n-                            .map_attrs(|mut attrs| {\n-                                let inert_attr = attr.take().unwrap();\n-                                attr::mark_known(&inert_attr);\n-                                if self.cx.ecfg.proc_macro_enabled() {\n-                                    *attr = find_attr_invoc(&mut attrs);\n-                                }\n-                                attrs.push(inert_attr);\n-                                attrs\n-                            });\n-                    }\n-                    return Err(Determinacy::Undetermined);\n-                },\n-                Err(Determinacy::Undetermined) => determined = false,\n-                Err(Determinacy::Determined) => {}\n-            }\n-        }\n-\n-        Err(if determined { Determinacy::Determined } else { Determinacy::Undetermined })\n-    }\n-\n     fn expand_invoc(&mut self, invoc: Invocation, ext: Rc<SyntaxExtension>) -> Expansion {\n         match invoc.kind {\n             InvocationKind::Bang { .. } => self.expand_bang_invoc(invoc, ext),\n@@ -802,7 +744,7 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n     }\n }\n \n-fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n+pub fn find_attr_invoc(attrs: &mut Vec<ast::Attribute>) -> Option<ast::Attribute> {\n     for i in 0 .. attrs.len() {\n         if !attr::is_known(&attrs[i]) && !is_builtin_attr(&attrs[i]) {\n              return Some(attrs.remove(i));"}]}