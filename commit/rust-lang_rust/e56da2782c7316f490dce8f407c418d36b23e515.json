{"sha": "e56da2782c7316f490dce8f407c418d36b23e515", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU1NmRhMjc4MmM3MzE2ZjQ5MGRjZThmNDA3YzQxOGQzNmIyM2U1MTU=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-09-03T21:02:16Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2017-09-03T21:02:16Z"}, "message": "Merge branch 'pr-2016' into HEAD", "tree": {"sha": "c8f894529ad7b0205482fd93bfa80a83d1c541a5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c8f894529ad7b0205482fd93bfa80a83d1c541a5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e56da2782c7316f490dce8f407c418d36b23e515", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e56da2782c7316f490dce8f407c418d36b23e515", "html_url": "https://github.com/rust-lang/rust/commit/e56da2782c7316f490dce8f407c418d36b23e515", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e56da2782c7316f490dce8f407c418d36b23e515/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5bc0a2dbfc224b6960059a79ea4c2e3f96dc7b62", "url": "https://api.github.com/repos/rust-lang/rust/commits/5bc0a2dbfc224b6960059a79ea4c2e3f96dc7b62", "html_url": "https://github.com/rust-lang/rust/commit/5bc0a2dbfc224b6960059a79ea4c2e3f96dc7b62"}, {"sha": "0d9f56674daf4acb7d2fdfdcee2211052837b873", "url": "https://api.github.com/repos/rust-lang/rust/commits/0d9f56674daf4acb7d2fdfdcee2211052837b873", "html_url": "https://github.com/rust-lang/rust/commit/0d9f56674daf4acb7d2fdfdcee2211052837b873"}], "stats": {"total": 250, "additions": 250, "deletions": 0}, "files": [{"sha": "4f3c755d7312248a306aab672b96869a2e62350c", "filename": "clippy_lints/src/is_unit_expr.rs", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/e56da2782c7316f490dce8f407c418d36b23e515/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56da2782c7316f490dce8f407c418d36b23e515/clippy_lints%2Fsrc%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fis_unit_expr.rs?ref=e56da2782c7316f490dce8f407c418d36b23e515", "patch": "@@ -0,0 +1,147 @@\n+use rustc::lint::*;\n+use syntax::ast::*;\n+use syntax::ext::quote::rt::Span;\n+use utils::span_note_and_lint;\n+\n+/// **What it does:** Checks for\n+///  - () being assigned to a variable\n+///  - () being passed to a function\n+///\n+/// **Why is this bad?** It is extremely unlikely that a user intended to\n+/// assign '()' to valiable. Instead,\n+/// Unit is what a block evaluates to when it returns nothing. This is\n+/// typically caused by a trailing\n+///   unintended semicolon.\n+///\n+/// **Known problems:** None.\n+///\n+/// **Example:**\n+/// * `let x = {\"foo\" ;}` when the user almost certainly intended `let x\n+/// ={\"foo\"}`\n+\n+declare_lint! {\n+    pub UNIT_EXPR,\n+    Warn,\n+    \"unintended assignment or use of a unit typed value\"\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct UnitExpr;\n+\n+impl LintPass for UnitExpr {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNIT_EXPR)\n+    }\n+}\n+\n+impl EarlyLintPass for UnitExpr {\n+    fn check_expr(&mut self, cx: &EarlyContext, expr: &Expr) {\n+        if let ExprKind::Assign(ref _left, ref right) = expr.node {\n+            if let Some(span) = is_unit_expr(right) {\n+                span_note_and_lint(\n+                    cx,\n+                    UNIT_EXPR,\n+                    expr.span,\n+                        \"This expression evaluates to the Unit type ()\",\n+                    span,\n+                    \"Consider removing the trailing semicolon\",\n+                );\n+            }\n+        }\n+        if let ExprKind::MethodCall(ref _left, ref args) = expr.node {\n+            for arg in args {\n+                if let Some(span) = is_unit_expr(arg) {\n+                    span_note_and_lint(\n+                        cx,\n+                        UNIT_EXPR,\n+                        expr.span,\n+                        \"This expression evaluates to the Unit type ()\",\n+                        span,\n+                        \"Consider removing the trailing semicolon\",\n+                    );\n+                }\n+            }\n+        }\n+        if let ExprKind::Call(_, ref args) = expr.node {\n+            for arg in args {\n+                if let Some(span) = is_unit_expr(arg) {\n+                    span_note_and_lint(\n+                        cx,\n+                        UNIT_EXPR,\n+                        expr.span,\n+                        \"This expression evaluates to the Unit type ()\",\n+                        span,\n+                        \"Consider removing the trailing semicolon\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+\n+    fn check_stmt(&mut self, cx: &EarlyContext, stmt: &Stmt) {\n+        if let StmtKind::Local(ref local) = stmt.node {\n+            if local.pat.node == PatKind::Wild {\n+                return;\n+            }\n+            if let Some(ref expr) = local.init {\n+                if let Some(span) = is_unit_expr(expr) {\n+                    span_note_and_lint(\n+                        cx,\n+                        UNIT_EXPR,\n+                        expr.span,\n+                        \"This expression evaluates to the Unit type ()\",\n+                        span,\n+                        \"Consider removing the trailing semicolon\",\n+                    );\n+                }\n+            }\n+        }\n+    }\n+}\n+fn is_unit_expr(expr: &Expr) -> Option<Span> {\n+    match expr.node {\n+        ExprKind::Block(ref block) => if check_last_stmt_in_block(block) {\n+            Some(block.stmts[block.stmts.len() - 1].span)\n+        } else {\n+            None\n+        },\n+        ExprKind::If(_, ref then, ref else_) => {\n+            let check_then = check_last_stmt_in_block(then);\n+            if let Some(ref else_) = *else_ {\n+                let check_else = is_unit_expr(else_);\n+                if let Some(ref expr_else) = check_else {\n+                    return Some(*expr_else);\n+                }\n+            }\n+            if check_then {\n+                Some(expr.span)\n+            } else {\n+                None\n+            }\n+        },\n+        ExprKind::Match(ref _pattern, ref arms) => {\n+            for arm in arms {\n+                if let Some(expr) = is_unit_expr(&arm.body) {\n+                    return Some(expr);\n+                }\n+            }\n+            None\n+        },\n+        _ => None,\n+    }\n+}\n+\n+fn check_last_stmt_in_block(block: &Block) -> bool {\n+    let final_stmt = &block.stmts[block.stmts.len() - 1];\n+\n+\n+    //Made a choice here to risk false positives on divergent macro invocations like `panic!()`\n+    match final_stmt.node {\n+        StmtKind::Expr(_) => false,\n+        StmtKind::Semi(ref expr) => match expr.node {\n+            ExprKind::Break(_, _) | ExprKind::Ret(_) => false,\n+            _ => true,\n+        },\n+        _ => true,\n+    }\n+}"}, {"sha": "5b484aceed891e36669621ddfdf073275f0c38ad", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e56da2782c7316f490dce8f407c418d36b23e515/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56da2782c7316f490dce8f407c418d36b23e515/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=e56da2782c7316f490dce8f407c418d36b23e515", "patch": "@@ -91,6 +91,7 @@ pub mod functions;\n pub mod identity_op;\n pub mod if_let_redundant_pattern_matching;\n pub mod if_not_else;\n+pub mod is_unit_expr;\n pub mod infinite_iter;\n pub mod items_after_statements;\n pub mod large_enum_variant;\n@@ -233,6 +234,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n     reg.register_late_lint_pass(box approx_const::Pass);\n     reg.register_late_lint_pass(box misc::Pass);\n     reg.register_early_lint_pass(box precedence::Precedence);\n+    reg.register_early_lint_pass(box is_unit_expr::UnitExpr);\n     reg.register_early_lint_pass(box needless_continue::NeedlessContinue);\n     reg.register_late_lint_pass(box eta_reduction::EtaPass);\n     reg.register_late_lint_pass(box identity_op::IdentityOp);\n@@ -504,6 +506,7 @@ pub fn register_plugins(reg: &mut rustc_plugin::Registry) {\n         panic::PANIC_PARAMS,\n         partialeq_ne_impl::PARTIALEQ_NE_IMPL,\n         precedence::PRECEDENCE,\n+        is_unit_expr::UNIT_EXPR,\n         print::PRINT_WITH_NEWLINE,\n         ptr::CMP_NULL,\n         ptr::MUT_FROM_REF,"}, {"sha": "d1f45d517b05b44e8499731b493dd6a3bf1b7883", "filename": "tests/ui/is_unit_expr.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/e56da2782c7316f490dce8f407c418d36b23e515/tests%2Fui%2Fis_unit_expr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e56da2782c7316f490dce8f407c418d36b23e515/tests%2Fui%2Fis_unit_expr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fis_unit_expr.rs?ref=e56da2782c7316f490dce8f407c418d36b23e515", "patch": "@@ -0,0 +1,48 @@\n+#![feature(plugin)]\n+#![plugin(clippy)]\n+#![warn(unit_expr)]\n+#[allow(unused_variables)]\n+\n+fn main() {\n+    // lint should note removing the semicolon from \"baz\"\n+    let x = {\n+        \"foo\";\n+        \"baz\";\n+    };\n+\n+\n+    // lint should ignore false positive.\n+    let y = if true {\n+        \"foo\"\n+    } else {\n+        return;\n+    };\n+\n+    // lint should note removing semicolon from \"bar\"\n+    let z = if true {\n+        \"foo\";\n+    } else {\n+        \"bar\";\n+    };\n+\n+\n+    let a1 = Some(5);\n+\n+    // lint should ignore false positive\n+    let a2 = match a1 {\n+        Some(x) => x,\n+        _ => {\n+            return;\n+        },\n+    };\n+\n+    // lint should note removing the semicolon after `x;`\n+    let a3 = match a1 {\n+        Some(x) => {\n+            x;\n+        },\n+        _ => {\n+            0;\n+        },\n+    };\n+}"}, {"sha": "dafebb1c82af3f84a2b868464a8fecd8dccbebfd", "filename": "tests/ui/is_unit_expr.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/e56da2782c7316f490dce8f407c418d36b23e515/tests%2Fui%2Fis_unit_expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e56da2782c7316f490dce8f407c418d36b23e515/tests%2Fui%2Fis_unit_expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fis_unit_expr.stderr?ref=e56da2782c7316f490dce8f407c418d36b23e515", "patch": "@@ -0,0 +1,52 @@\n+error: This expression evaluates to the Unit type ()\n+  --> $DIR/is_unit_expr.rs:9:13\n+   |\n+9  |       let x = {\n+   |  _____________^\n+10 | |         \"foo\";\n+11 | |         \"baz\";\n+12 | |     };\n+   | |_____^\n+   |\n+   = note: `-D unit-expr` implied by `-D warnings`\n+note: Consider removing the trailing semicolon\n+  --> $DIR/is_unit_expr.rs:11:9\n+   |\n+11 |         \"baz\";\n+   |         ^^^^^^\n+\n+error: This expression evaluates to the Unit type ()\n+  --> $DIR/is_unit_expr.rs:23:13\n+   |\n+23 |       let z = if true{\n+   |  _____________^\n+24 | |         \"foo\";\n+25 | |     } else{\n+26 | |         \"bar\";\n+27 | |     };\n+   | |_____^\n+   |\n+note: Consider removing the trailing semicolon\n+  --> $DIR/is_unit_expr.rs:26:9\n+   |\n+26 |         \"bar\";\n+   |         ^^^^^^\n+\n+error: This expression evaluates to the Unit type ()\n+  --> $DIR/is_unit_expr.rs:39:14\n+   |\n+39 |       let a3 = match a1 {\n+   |  ______________^\n+40 | |         Some(x) => {x;},\n+41 | |         _ => {0;},\n+42 | |     };\n+   | |_____^\n+   |\n+note: Consider removing the trailing semicolon\n+  --> $DIR/is_unit_expr.rs:40:21\n+   |\n+40 |         Some(x) => {x;},\n+   |                     ^^\n+\n+error: aborting due to 3 previous errors\n+"}]}