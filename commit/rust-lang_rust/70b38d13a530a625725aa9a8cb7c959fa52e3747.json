{"sha": "70b38d13a530a625725aa9a8cb7c959fa52e3747", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwYjM4ZDEzYTUzMGE2MjU3MjVhYTlhOGNiN2M5NTlmYTUyZTM3NDc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-17T00:54:17Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-17T00:54:17Z"}, "message": "Rollup merge of #60873 - estebank:bad-await, r=Centril\n\nParse alternative incorrect uses of await and recover\n\nFix #60613.\n\nr? @Centril", "tree": {"sha": "05bb2df6fa024755e41d2f6840ef5a04be83b88f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05bb2df6fa024755e41d2f6840ef5a04be83b88f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70b38d13a530a625725aa9a8cb7c959fa52e3747", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc3gY5CRBK7hj4Ov3rIwAAdHIIAFVtGHiWoZR1bhIFgzg4gAIz\n10ahK9abeS4KwALFqe7fDv5Dst1tYFbYTZT+2EGbwJsvNEyLdAmgx5IOoj10ubps\nDAXR4qnHp3iDGHuucSMNbRFIIU8R7iAoz575tsFqurG1XogRo1wmhYcPcgYJXRAV\nEq0S9bJd7eze4rTgYYlhN+rsz6GI2+ygZSfFAbWvIBIEuUkrcU73nX1NWoRYGK6/\ndSLG6EimMcQJJDYs3v38xgS7FnRjjhOZta7nfTr+bDYXqi1bz60IqzkgGwwFKpJZ\ndvStyoyUz9p3M10Mxp4ieXeC0Y/kFIddEvyCtZxKMnpJsBp9ZO9dlbjz0NWxLew=\n=jVvH\n-----END PGP SIGNATURE-----\n", "payload": "tree 05bb2df6fa024755e41d2f6840ef5a04be83b88f\nparent 71cd93a1044dcdb4b2a2ffd2ed5e0e5c601eb765\nparent c084d0ed7d1dcad99d523cb82d7fc78c6d76a8c6\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1558054457 +0200\ncommitter GitHub <noreply@github.com> 1558054457 +0200\n\nRollup merge of #60873 - estebank:bad-await, r=Centril\n\nParse alternative incorrect uses of await and recover\n\nFix #60613.\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70b38d13a530a625725aa9a8cb7c959fa52e3747", "html_url": "https://github.com/rust-lang/rust/commit/70b38d13a530a625725aa9a8cb7c959fa52e3747", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70b38d13a530a625725aa9a8cb7c959fa52e3747/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71cd93a1044dcdb4b2a2ffd2ed5e0e5c601eb765", "url": "https://api.github.com/repos/rust-lang/rust/commits/71cd93a1044dcdb4b2a2ffd2ed5e0e5c601eb765", "html_url": "https://github.com/rust-lang/rust/commit/71cd93a1044dcdb4b2a2ffd2ed5e0e5c601eb765"}, {"sha": "c084d0ed7d1dcad99d523cb82d7fc78c6d76a8c6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c084d0ed7d1dcad99d523cb82d7fc78c6d76a8c6", "html_url": "https://github.com/rust-lang/rust/commit/c084d0ed7d1dcad99d523cb82d7fc78c6d76a8c6"}], "stats": {"total": 978, "additions": 690, "deletions": 288}, "files": [{"sha": "3a8b139236ccad97fde64828468dc593664217eb", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -97,6 +97,10 @@ pub struct LoweringContext<'a> {\n     is_generator: bool,\n     is_async_body: bool,\n \n+    /// Used to get the current `fn`'s def span to point to when using `await`\n+    /// outside of an `async fn`.\n+    current_item: Option<Span>,\n+\n     catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n     is_in_loop_condition: bool,\n@@ -250,6 +254,7 @@ pub fn lower_crate(\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n         is_async_body: false,\n+        current_item: None,\n         is_in_trait_impl: false,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n@@ -3116,6 +3121,7 @@ impl<'a> LoweringContext<'a> {\n             ItemKind::Fn(ref decl, ref header, ref generics, ref body) => {\n                 let fn_def_id = self.resolver.definitions().local_def_id(id);\n                 self.with_new_scopes(|this| {\n+                    this.current_item = Some(ident.span);\n                     let mut lower_fn = |decl: &FnDecl| {\n                         // Note: we don't need to change the return type from `T` to\n                         // `impl Future<Output = T>` here because lower_body\n@@ -3654,6 +3660,7 @@ impl<'a> LoweringContext<'a> {\n                 } else {\n                     lower_method(sig)\n                 };\n+                self.current_item = Some(i.span);\n \n                 (generics, hir::ImplItemKind::Method(sig, body_id))\n             }\n@@ -4270,6 +4277,7 @@ impl<'a> LoweringContext<'a> {\n                     let fn_decl = self.lower_fn_decl(decl, None, false, None);\n \n                     self.with_new_scopes(|this| {\n+                        this.current_item = Some(fn_decl_span);\n                         let mut is_generator = false;\n                         let body_id = this.lower_body(Some(decl), |this| {\n                             let e = this.lower_expr(body);\n@@ -5551,13 +5559,18 @@ impl<'a> LoweringContext<'a> {\n         //     }\n         // }\n         if !self.is_async_body {\n-            span_err!(\n+            let mut err = struct_span_err!(\n                 self.sess,\n                 await_span,\n                 E0728,\n                 \"`await` is only allowed inside `async` functions and blocks\"\n             );\n-            self.sess.abort_if_errors();\n+            err.span_label(await_span, \"only allowed inside `async` functions and blocks\");\n+            if let Some(item_sp) = self.current_item {\n+                err.span_label(item_sp, \"this is not `async`\");\n+            }\n+            err.emit();\n+            return hir::ExprKind::Err;\n         }\n         let span = self.sess.source_map().mark_span_with_reason(\n             CompilerDesugaringKind::Await,"}, {"sha": "1a2393be806d55d037f2faef1ef558bcb0fe142b", "filename": "src/libsyntax/parse/diagnostics.rs", "status": "modified", "additions": 301, "deletions": 3, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -1,14 +1,16 @@\n use crate::ast;\n-use crate::ast::{Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind};\n-use crate::parse::parser::PathStyle;\n+use crate::ast::{BlockCheckMode, Expr, ExprKind, Item, ItemKind, Pat, PatKind, QSelf, Ty, TyKind};\n+use crate::parse::parser::{BlockMode, PathStyle, TokenType, SemiColonMode};\n use crate::parse::token;\n use crate::parse::PResult;\n use crate::parse::Parser;\n use crate::print::pprust;\n use crate::ptr::P;\n+use crate::symbol::keywords;\n use crate::ThinVec;\n-use errors::Applicability;\n+use errors::{Applicability, DiagnosticBuilder};\n use syntax_pos::Span;\n+use log::debug;\n \n pub trait RecoverQPath: Sized + 'static {\n     const PATH_STYLE: PathStyle = PathStyle::Expr;\n@@ -223,4 +225,300 @@ impl<'a> Parser<'a> {\n             false\n         }\n     }\n+\n+    /// Consume alternative await syntaxes like `await <expr>`, `await? <expr>`, `await(<expr>)`\n+    /// and `await { <expr> }`.\n+    crate fn parse_incorrect_await_syntax(\n+        &mut self,\n+        lo: Span,\n+        await_sp: Span,\n+    ) -> PResult<'a, (Span, ExprKind)> {\n+        let is_question = self.eat(&token::Question); // Handle `await? <expr>`.\n+        let expr = if self.token == token::OpenDelim(token::Brace) {\n+            // Handle `await { <expr> }`.\n+            // This needs to be handled separatedly from the next arm to avoid\n+            // interpreting `await { <expr> }?` as `<expr>?.await`.\n+            self.parse_block_expr(\n+                None,\n+                self.span,\n+                BlockCheckMode::Default,\n+                ThinVec::new(),\n+            )\n+        } else {\n+            self.parse_expr()\n+        }.map_err(|mut err| {\n+            err.span_label(await_sp, \"while parsing this incorrect await expression\");\n+            err\n+        })?;\n+        let expr_str = self.sess.source_map().span_to_snippet(expr.span)\n+            .unwrap_or_else(|_| pprust::expr_to_string(&expr));\n+        let suggestion = format!(\"{}.await{}\", expr_str, if is_question { \"?\" } else { \"\" });\n+        let sp = lo.to(expr.span);\n+        let app = match expr.node {\n+            ExprKind::Try(_) => Applicability::MaybeIncorrect, // `await <expr>?`\n+            _ => Applicability::MachineApplicable,\n+        };\n+        self.struct_span_err(sp, \"incorrect use of `await`\")\n+            .span_suggestion(sp, \"`await` is a postfix operation\", suggestion, app)\n+            .emit();\n+        Ok((sp, ExprKind::Await(ast::AwaitOrigin::FieldLike, expr)))\n+    }\n+\n+    /// If encountering `future.await()`, consume and emit error.\n+    crate fn recover_from_await_method_call(&mut self) {\n+        if self.token == token::OpenDelim(token::Paren) &&\n+            self.look_ahead(1, |t| t == &token::CloseDelim(token::Paren))\n+        {\n+            // future.await()\n+            let lo = self.span;\n+            self.bump(); // (\n+            let sp = lo.to(self.span);\n+            self.bump(); // )\n+            self.struct_span_err(sp, \"incorrect use of `await`\")\n+                .span_suggestion(\n+                    sp,\n+                    \"`await` is not a method call, remove the parentheses\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                ).emit()\n+        }\n+    }\n+\n+    crate fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n+        self.token.is_ident() &&\n+            if let ast::ExprKind::Path(..) = node { true } else { false } &&\n+            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n+            self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren)) ||\n+            self.look_ahead(1, |t| t == &token::Lt) &&     // `foo:bar<baz`\n+            self.look_ahead(2, |t| t.is_ident()) ||\n+            self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n+            self.look_ahead(2, |t| t.is_ident()) ||\n+            self.look_ahead(1, |t| t == &token::ModSep) &&  // `foo:bar::baz`\n+            self.look_ahead(2, |t| t.is_ident())\n+    }\n+\n+    crate fn bad_type_ascription(\n+        &self,\n+        err: &mut DiagnosticBuilder<'a>,\n+        lhs_span: Span,\n+        cur_op_span: Span,\n+        next_sp: Span,\n+        maybe_path: bool,\n+    ) {\n+        err.span_label(self.span, \"expecting a type here because of type ascription\");\n+        let cm = self.sess.source_map();\n+        let next_pos = cm.lookup_char_pos(next_sp.lo());\n+        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n+        if op_pos.line != next_pos.line {\n+            err.span_suggestion(\n+                cur_op_span,\n+                \"try using a semicolon\",\n+                \";\".to_string(),\n+                Applicability::MaybeIncorrect,\n+            );\n+        } else {\n+            if maybe_path {\n+                err.span_suggestion(\n+                    cur_op_span,\n+                    \"maybe you meant to write a path separator here\",\n+                    \"::\".to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+            } else {\n+                err.note(\"type ascription is a nightly-only feature that lets \\\n+                          you annotate an expression with a type: `<expr>: <type>`\")\n+                    .span_note(\n+                        lhs_span,\n+                        \"this expression expects an ascribed type after the colon\",\n+                    )\n+                    .help(\"this might be indicative of a syntax error elsewhere\");\n+            }\n+        }\n+    }\n+\n+    crate fn recover_seq_parse_error(\n+        &mut self,\n+        delim: token::DelimToken,\n+        lo: Span,\n+        result: PResult<'a, P<Expr>>,\n+    ) -> P<Expr> {\n+        match result {\n+            Ok(x) => x,\n+            Err(mut err) => {\n+                err.emit();\n+                // recover from parse error\n+                self.consume_block(delim);\n+                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n+            }\n+        }\n+    }\n+\n+    crate fn recover_closing_delimiter(\n+        &mut self,\n+        tokens: &[token::Token],\n+        mut err: DiagnosticBuilder<'a>,\n+    ) -> PResult<'a, bool> {\n+        let mut pos = None;\n+        // we want to use the last closing delim that would apply\n+        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n+            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n+                && Some(self.span) > unmatched.unclosed_span\n+            {\n+                pos = Some(i);\n+            }\n+        }\n+        match pos {\n+            Some(pos) => {\n+                // Recover and assume that the detected unclosed delimiter was meant for\n+                // this location. Emit the diagnostic and act as if the delimiter was\n+                // present for the parser's sake.\n+\n+                 // Don't attempt to recover from this unclosed delimiter more than once.\n+                let unmatched = self.unclosed_delims.remove(pos);\n+                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n+\n+                 // We want to suggest the inclusion of the closing delimiter where it makes\n+                // the most sense, which is immediately after the last token:\n+                //\n+                //  {foo(bar {}}\n+                //      -      ^\n+                //      |      |\n+                //      |      help: `)` may belong here (FIXME: #58270)\n+                //      |\n+                //      unclosed delimiter\n+                if let Some(sp) = unmatched.unclosed_span {\n+                    err.span_label(sp, \"unclosed delimiter\");\n+                }\n+                err.span_suggestion_short(\n+                    self.sess.source_map().next_point(self.prev_span),\n+                    &format!(\"{} may belong here\", delim.to_string()),\n+                    delim.to_string(),\n+                    Applicability::MaybeIncorrect,\n+                );\n+                err.emit();\n+                self.expected_tokens.clear();  // reduce errors\n+                Ok(true)\n+            }\n+            _ => Err(err),\n+        }\n+    }\n+\n+    /// Recover from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n+    crate fn eat_bad_pub(&mut self) {\n+        if self.token.is_keyword(keywords::Pub) {\n+            match self.parse_visibility(false) {\n+                Ok(vis) => {\n+                    self.diagnostic()\n+                        .struct_span_err(vis.span, \"unnecessary visibility qualifier\")\n+                        .span_label(vis.span, \"`pub` not permitted here\")\n+                        .emit();\n+                }\n+                Err(mut err) => err.emit(),\n+            }\n+        }\n+    }\n+\n+    // Eat tokens until we can be relatively sure we reached the end of the\n+    // statement. This is something of a best-effort heuristic.\n+    //\n+    // We terminate when we find an unmatched `}` (without consuming it).\n+    crate fn recover_stmt(&mut self) {\n+        self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n+    }\n+\n+    // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n+    // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n+    // approximate - it can mean we break too early due to macros, but that\n+    // should only lead to sub-optimal recovery, not inaccurate parsing).\n+    //\n+    // If `break_on_block` is `Break`, then we will stop consuming tokens\n+    // after finding (and consuming) a brace-delimited block.\n+    crate fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n+        let mut brace_depth = 0;\n+        let mut bracket_depth = 0;\n+        let mut in_block = false;\n+        debug!(\"recover_stmt_ enter loop (semi={:?}, block={:?})\",\n+               break_on_semi, break_on_block);\n+        loop {\n+            debug!(\"recover_stmt_ loop {:?}\", self.token);\n+            match self.token {\n+                token::OpenDelim(token::DelimToken::Brace) => {\n+                    brace_depth += 1;\n+                    self.bump();\n+                    if break_on_block == BlockMode::Break &&\n+                       brace_depth == 1 &&\n+                       bracket_depth == 0 {\n+                        in_block = true;\n+                    }\n+                }\n+                token::OpenDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth += 1;\n+                    self.bump();\n+                }\n+                token::CloseDelim(token::DelimToken::Brace) => {\n+                    if brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n+                        break;\n+                    }\n+                    brace_depth -= 1;\n+                    self.bump();\n+                    if in_block && bracket_depth == 0 && brace_depth == 0 {\n+                        debug!(\"recover_stmt_ return - block end {:?}\", self.token);\n+                        break;\n+                    }\n+                }\n+                token::CloseDelim(token::DelimToken::Bracket) => {\n+                    bracket_depth -= 1;\n+                    if bracket_depth < 0 {\n+                        bracket_depth = 0;\n+                    }\n+                    self.bump();\n+                }\n+                token::Eof => {\n+                    debug!(\"recover_stmt_ return - Eof\");\n+                    break;\n+                }\n+                token::Semi => {\n+                    self.bump();\n+                    if break_on_semi == SemiColonMode::Break &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 {\n+                        debug!(\"recover_stmt_ return - Semi\");\n+                        break;\n+                    }\n+                }\n+                token::Comma if break_on_semi == SemiColonMode::Comma &&\n+                       brace_depth == 0 &&\n+                       bracket_depth == 0 =>\n+                {\n+                    debug!(\"recover_stmt_ return - Semi\");\n+                    break;\n+                }\n+                _ => {\n+                    self.bump()\n+                }\n+            }\n+        }\n+    }\n+\n+    crate fn consume_block(&mut self, delim: token::DelimToken) {\n+        let mut brace_depth = 0;\n+        loop {\n+            if self.eat(&token::OpenDelim(delim)) {\n+                brace_depth += 1;\n+            } else if self.eat(&token::CloseDelim(delim)) {\n+                if brace_depth == 0 {\n+                    return;\n+                } else {\n+                    brace_depth -= 1;\n+                    continue;\n+                }\n+            } else if self.token == token::Eof || self.eat(&token::CloseDelim(token::NoDelim)) {\n+                return;\n+            } else {\n+                self.bump();\n+            }\n+        }\n+    }\n+\n }"}, {"sha": "b1c3e46adc0ecbe8d0271c7729a178bef3ba0518", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 40, "deletions": 256, "changes": 296, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -104,14 +104,14 @@ pub enum PathStyle {\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-enum SemiColonMode {\n+crate enum SemiColonMode {\n     Break,\n     Ignore,\n     Comma,\n }\n \n #[derive(Clone, Copy, PartialEq, Debug)]\n-enum BlockMode {\n+crate enum BlockMode {\n     Break,\n     Ignore,\n }\n@@ -389,7 +389,7 @@ crate enum TokenType {\n }\n \n impl TokenType {\n-    fn to_string(&self) -> String {\n+    crate fn to_string(&self) -> String {\n         match *self {\n             TokenType::Token(ref t) => format!(\"`{}`\", pprust::token_to_string(t)),\n             TokenType::Keyword(kw) => format!(\"`{}`\", kw.name()),\n@@ -673,56 +673,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn recover_closing_delimiter(\n-        &mut self,\n-        tokens: &[token::Token],\n-        mut err: DiagnosticBuilder<'a>,\n-    ) -> PResult<'a, bool> {\n-        let mut pos = None;\n-        // we want to use the last closing delim that would apply\n-        for (i, unmatched) in self.unclosed_delims.iter().enumerate().rev() {\n-            if tokens.contains(&token::CloseDelim(unmatched.expected_delim))\n-                && Some(self.span) > unmatched.unclosed_span\n-            {\n-                pos = Some(i);\n-            }\n-        }\n-        match pos {\n-            Some(pos) => {\n-                // Recover and assume that the detected unclosed delimiter was meant for\n-                // this location. Emit the diagnostic and act as if the delimiter was\n-                // present for the parser's sake.\n-\n-                 // Don't attempt to recover from this unclosed delimiter more than once.\n-                let unmatched = self.unclosed_delims.remove(pos);\n-                let delim = TokenType::Token(token::CloseDelim(unmatched.expected_delim));\n-\n-                 // We want to suggest the inclusion of the closing delimiter where it makes\n-                // the most sense, which is immediately after the last token:\n-                //\n-                //  {foo(bar {}}\n-                //      -      ^\n-                //      |      |\n-                //      |      help: `)` may belong here (FIXME: #58270)\n-                //      |\n-                //      unclosed delimiter\n-                if let Some(sp) = unmatched.unclosed_span {\n-                    err.span_label(sp, \"unclosed delimiter\");\n-                }\n-                err.span_suggestion_short(\n-                    self.sess.source_map().next_point(self.prev_span),\n-                    &format!(\"{} may belong here\", delim.to_string()),\n-                    delim.to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-                err.emit();\n-                self.expected_tokens.clear();  // reduce errors\n-                Ok(true)\n-            }\n-            _ => Err(err),\n-        }\n-    }\n-\n     /// Expect next token to be edible or inedible token.  If edible,\n     /// then consume it; if inedible, then return without consuming\n     /// anything.  Signal a fatal error if next token is unexpected.\n@@ -2343,7 +2293,7 @@ impl<'a> Parser<'a> {\n         })\n     }\n \n-    fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n+    crate fn mk_expr(&self, span: Span, node: ExprKind, attrs: ThinVec<Attribute>) -> P<Expr> {\n         P(Expr { node, span, attrs, id: ast::DUMMY_NODE_ID })\n     }\n \n@@ -2629,14 +2579,9 @@ impl<'a> Parser<'a> {\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n                 } else if self.span.rust_2018() && self.eat_keyword(keywords::Await) {\n-                    // FIXME: remove this branch when `await!` is no longer supported\n-                    // https://github.com/rust-lang/rust/issues/60610\n-                    self.expect(&token::Not)?;\n-                    self.expect(&token::OpenDelim(token::Paren))?;\n-                    let expr = self.parse_expr()?;\n-                    self.expect(&token::CloseDelim(token::Paren))?;\n-                    hi = self.prev_span;\n-                    ex = ExprKind::Await(ast::AwaitOrigin::MacroLike, expr);\n+                    let (await_hi, e_kind) = self.parse_await_macro_or_alt(lo, self.prev_span)?;\n+                    hi = await_hi;\n+                    ex = e_kind;\n                 } else if self.token.is_path_start() {\n                     let path = self.parse_path(PathStyle::Expr)?;\n \n@@ -2701,6 +2646,31 @@ impl<'a> Parser<'a> {\n         self.maybe_recover_from_bad_qpath(expr, true)\n     }\n \n+    /// Parse `await!(<expr>)` calls, or alternatively recover from incorrect but reasonable\n+    /// alternative syntaxes `await <expr>`, `await? <expr>`, `await(<expr>)` and\n+    /// `await { <expr> }`.\n+    fn parse_await_macro_or_alt(\n+        &mut self,\n+        lo: Span,\n+        await_sp: Span,\n+    ) -> PResult<'a, (Span, ExprKind)> {\n+        if self.token == token::Not {\n+            // Handle correct `await!(<expr>)`.\n+            // FIXME: make this an error when `await!` is no longer supported\n+            // https://github.com/rust-lang/rust/issues/60610\n+            self.expect(&token::Not)?;\n+            self.expect(&token::OpenDelim(token::Paren))?;\n+            let expr = self.parse_expr().map_err(|mut err| {\n+                err.span_label(await_sp, \"while parsing this await macro call\");\n+                err\n+            })?;\n+            self.expect(&token::CloseDelim(token::Paren))?;\n+            Ok((self.prev_span, ExprKind::Await(ast::AwaitOrigin::MacroLike, expr)))\n+        } else { // Handle `await <expr>`.\n+            self.parse_incorrect_await_syntax(lo, await_sp)\n+        }\n+    }\n+\n     fn maybe_parse_struct_expr(\n         &mut self,\n         lo: Span,\n@@ -2849,10 +2819,13 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parses a block or unsafe block.\n-    fn parse_block_expr(&mut self, opt_label: Option<Label>,\n-                            lo: Span, blk_mode: BlockCheckMode,\n-                            outer_attrs: ThinVec<Attribute>)\n-                            -> PResult<'a, P<Expr>> {\n+    crate fn parse_block_expr(\n+        &mut self,\n+        opt_label: Option<Label>,\n+        lo: Span,\n+        blk_mode: BlockCheckMode,\n+        outer_attrs: ThinVec<Attribute>,\n+    ) -> PResult<'a, P<Expr>> {\n         self.expect(&token::OpenDelim(token::Brace))?;\n \n         let mut attrs = outer_attrs;\n@@ -2913,6 +2886,7 @@ impl<'a> Parser<'a> {\n                 ExprKind::Await(ast::AwaitOrigin::FieldLike, self_arg),\n                 ThinVec::new(),\n             );\n+            self.recover_from_await_method_call();\n             return Ok(await_expr);\n         }\n         let segment = self.parse_path_segment(PathStyle::Expr)?;\n@@ -3151,23 +3125,6 @@ impl<'a> Parser<'a> {\n         return Ok(e);\n     }\n \n-    fn recover_seq_parse_error(\n-        &mut self,\n-        delim: token::DelimToken,\n-        lo: Span,\n-        result: PResult<'a, P<Expr>>,\n-    ) -> P<Expr> {\n-        match result {\n-            Ok(x) => x,\n-            Err(mut err) => {\n-                err.emit();\n-                // recover from parse error\n-                self.consume_block(delim);\n-                self.mk_expr(lo.to(self.prev_span), ExprKind::Err, ThinVec::new())\n-            }\n-        }\n-    }\n-\n     crate fn process_potential_macro_variable(&mut self) {\n         let (token, span) = match self.token {\n             token::Dollar if self.span.ctxt() != syntax_pos::hygiene::SyntaxContext::empty() &&\n@@ -3570,58 +3527,6 @@ impl<'a> Parser<'a> {\n         Ok(lhs)\n     }\n \n-    fn could_ascription_be_path(&self, node: &ast::ExprKind) -> bool {\n-        self.token.is_ident() &&\n-            if let ast::ExprKind::Path(..) = node { true } else { false } &&\n-            !self.token.is_reserved_ident() &&           // v `foo:bar(baz)`\n-            self.look_ahead(1, |t| t == &token::OpenDelim(token::Paren)) ||\n-            self.look_ahead(1, |t| t == &token::Lt) &&     // `foo:bar<baz`\n-            self.look_ahead(2, |t| t.is_ident()) ||\n-            self.look_ahead(1, |t| t == &token::Colon) &&  // `foo:bar:baz`\n-            self.look_ahead(2, |t| t.is_ident()) ||\n-            self.look_ahead(1, |t| t == &token::ModSep) &&  // `foo:bar::baz`\n-            self.look_ahead(2, |t| t.is_ident())\n-    }\n-\n-    fn bad_type_ascription(\n-        &self,\n-        err: &mut DiagnosticBuilder<'a>,\n-        lhs_span: Span,\n-        cur_op_span: Span,\n-        next_sp: Span,\n-        maybe_path: bool,\n-    ) {\n-        err.span_label(self.span, \"expecting a type here because of type ascription\");\n-        let cm = self.sess.source_map();\n-        let next_pos = cm.lookup_char_pos(next_sp.lo());\n-        let op_pos = cm.lookup_char_pos(cur_op_span.hi());\n-        if op_pos.line != next_pos.line {\n-            err.span_suggestion(\n-                cur_op_span,\n-                \"try using a semicolon\",\n-                \";\".to_string(),\n-                Applicability::MaybeIncorrect,\n-            );\n-        } else {\n-            if maybe_path {\n-                err.span_suggestion(\n-                    cur_op_span,\n-                    \"maybe you meant to write a path separator here\",\n-                    \"::\".to_string(),\n-                    Applicability::MaybeIncorrect,\n-                );\n-            } else {\n-                err.note(\"type ascription is a nightly-only feature that lets \\\n-                          you annotate an expression with a type: `<expr>: <type>`\");\n-                err.span_note(\n-                    lhs_span,\n-                    \"this expression expects an ascribed type after the colon\",\n-                );\n-                err.help(\"this might be indicative of a syntax error elsewhere\");\n-            }\n-        }\n-    }\n-\n     fn parse_assoc_op_cast(&mut self, lhs: P<Expr>, lhs_span: Span,\n                            expr_kind: fn(P<Expr>, P<Ty>) -> ExprKind)\n                            -> PResult<'a, P<Expr>> {\n@@ -4903,92 +4808,6 @@ impl<'a> Parser<'a> {\n         Ok(self.parse_stmt_(true))\n     }\n \n-    // Eat tokens until we can be relatively sure we reached the end of the\n-    // statement. This is something of a best-effort heuristic.\n-    //\n-    // We terminate when we find an unmatched `}` (without consuming it).\n-    fn recover_stmt(&mut self) {\n-        self.recover_stmt_(SemiColonMode::Ignore, BlockMode::Ignore)\n-    }\n-\n-    // If `break_on_semi` is `Break`, then we will stop consuming tokens after\n-    // finding (and consuming) a `;` outside of `{}` or `[]` (note that this is\n-    // approximate - it can mean we break too early due to macros, but that\n-    // should only lead to sub-optimal recovery, not inaccurate parsing).\n-    //\n-    // If `break_on_block` is `Break`, then we will stop consuming tokens\n-    // after finding (and consuming) a brace-delimited block.\n-    fn recover_stmt_(&mut self, break_on_semi: SemiColonMode, break_on_block: BlockMode) {\n-        let mut brace_depth = 0;\n-        let mut bracket_depth = 0;\n-        let mut in_block = false;\n-        debug!(\"recover_stmt_ enter loop (semi={:?}, block={:?})\",\n-               break_on_semi, break_on_block);\n-        loop {\n-            debug!(\"recover_stmt_ loop {:?}\", self.token);\n-            match self.token {\n-                token::OpenDelim(token::DelimToken::Brace) => {\n-                    brace_depth += 1;\n-                    self.bump();\n-                    if break_on_block == BlockMode::Break &&\n-                       brace_depth == 1 &&\n-                       bracket_depth == 0 {\n-                        in_block = true;\n-                    }\n-                }\n-                token::OpenDelim(token::DelimToken::Bracket) => {\n-                    bracket_depth += 1;\n-                    self.bump();\n-                }\n-                token::CloseDelim(token::DelimToken::Brace) => {\n-                    if brace_depth == 0 {\n-                        debug!(\"recover_stmt_ return - close delim {:?}\", self.token);\n-                        break;\n-                    }\n-                    brace_depth -= 1;\n-                    self.bump();\n-                    if in_block && bracket_depth == 0 && brace_depth == 0 {\n-                        debug!(\"recover_stmt_ return - block end {:?}\", self.token);\n-                        break;\n-                    }\n-                }\n-                token::CloseDelim(token::DelimToken::Bracket) => {\n-                    bracket_depth -= 1;\n-                    if bracket_depth < 0 {\n-                        bracket_depth = 0;\n-                    }\n-                    self.bump();\n-                }\n-                token::Eof => {\n-                    debug!(\"recover_stmt_ return - Eof\");\n-                    break;\n-                }\n-                token::Semi => {\n-                    self.bump();\n-                    if break_on_semi == SemiColonMode::Break &&\n-                       brace_depth == 0 &&\n-                       bracket_depth == 0 {\n-                        debug!(\"recover_stmt_ return - Semi\");\n-                        break;\n-                    }\n-                }\n-                token::Comma => {\n-                    if break_on_semi == SemiColonMode::Comma &&\n-                       brace_depth == 0 &&\n-                       bracket_depth == 0 {\n-                        debug!(\"recover_stmt_ return - Semi\");\n-                        break;\n-                    } else {\n-                        self.bump();\n-                    }\n-                }\n-                _ => {\n-                    self.bump()\n-                }\n-            }\n-        }\n-    }\n-\n     fn parse_stmt_(&mut self, macro_legacy_warnings: bool) -> Option<Stmt> {\n         self.parse_stmt_without_recovery(macro_legacy_warnings).unwrap_or_else(|mut e| {\n             e.emit();\n@@ -6892,26 +6711,6 @@ impl<'a> Parser<'a> {\n         Ok((class_name, ItemKind::Union(vdata, generics), None))\n     }\n \n-    fn consume_block(&mut self, delim: token::DelimToken) {\n-        let mut brace_depth = 0;\n-        loop {\n-            if self.eat(&token::OpenDelim(delim)) {\n-                brace_depth += 1;\n-            } else if self.eat(&token::CloseDelim(delim)) {\n-                if brace_depth == 0 {\n-                    return;\n-                } else {\n-                    brace_depth -= 1;\n-                    continue;\n-                }\n-            } else if self.token == token::Eof || self.eat(&token::CloseDelim(token::NoDelim)) {\n-                return;\n-            } else {\n-                self.bump();\n-            }\n-        }\n-    }\n-\n     fn parse_record_struct_body(\n         &mut self,\n     ) -> PResult<'a, (Vec<StructField>, /* recovered */ bool)> {\n@@ -8609,21 +8408,6 @@ impl<'a> Parser<'a> {\n         ).emit();\n     }\n \n-    /// Recover from `pub` keyword in places where it seems _reasonable_ but isn't valid.\n-    fn eat_bad_pub(&mut self) {\n-        if self.token.is_keyword(keywords::Pub) {\n-            match self.parse_visibility(false) {\n-                Ok(vis) => {\n-                    let mut err = self.diagnostic()\n-                        .struct_span_err(vis.span, \"unnecessary visibility qualifier\");\n-                    err.span_label(vis.span, \"`pub` not permitted here\");\n-                    err.emit();\n-                }\n-                Err(mut err) => err.emit(),\n-            }\n-        }\n-    }\n-\n     /// When lowering a `async fn` to the HIR, we need to move all of the arguments of the function\n     /// into the generated closure so that they are dropped when the future is polled and not when\n     /// it is created."}, {"sha": "f59f1160e703e4bd82eec71654567c737666ee61", "filename": "src/test/ui/await-keyword/2018-edition-error-in-non-macro-position.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -22,6 +22,4 @@ macro_rules! await {\n     () => {}\n }\n \n-fn main() {\n-    match await { await => () } //~ ERROR expected `!`, found `{`\n-}\n+fn main() {}"}, {"sha": "c4b82b29f0270f30da71337f84f335b0be32ec1b", "filename": "src/test/ui/await-keyword/2018-edition-error-in-non-macro-position.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -68,13 +68,5 @@ help: you can escape reserved keywords to use them as identifiers\n LL | macro_rules! r#await {\n    |              ^^^^^^^\n \n-error: expected `!`, found `{`\n-  --> $DIR/2018-edition-error-in-non-macro-position.rs:26:17\n-   |\n-LL |     match await { await => () }\n-   |     -----       ^ expected `!`\n-   |     |\n-   |     while parsing this match expression\n-\n-error: aborting due to 8 previous errors\n+error: aborting due to 7 previous errors\n "}, {"sha": "d856869684266c1927441a514bafc40f9a27644d", "filename": "src/test/ui/await-keyword/2018-edition-error.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -9,6 +9,4 @@ mod outer_mod {\n use self::outer_mod::await::await; //~ ERROR expected identifier\n     //~^ ERROR expected identifier, found reserved keyword `await`\n \n-fn main() {\n-    match await { await => () } //~ ERROR expected `!`, found `{`\n-}\n+fn main() {}"}, {"sha": "8afe5c1a36b36db695f0b341e01795a3a1f96822", "filename": "src/test/ui/await-keyword/2018-edition-error.stderr", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -38,13 +38,5 @@ help: you can escape reserved keywords to use them as identifiers\n LL | use self::outer_mod::await::r#await;\n    |                             ^^^^^^^\n \n-error: expected `!`, found `{`\n-  --> $DIR/2018-edition-error.rs:13:17\n-   |\n-LL |     match await { await => () }\n-   |     -----       ^ expected `!`\n-   |     |\n-   |     while parsing this match expression\n-\n-error: aborting due to 5 previous errors\n+error: aborting due to 4 previous errors\n "}, {"sha": "e1e5bdd3d1b9277797af39dbd5626b090879200a", "filename": "src/test/ui/await-keyword/incorrect-syntax-suggestions.rs", "status": "added", "additions": 111, "deletions": 0, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.rs?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -0,0 +1,111 @@\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+async fn bar() -> Result<(), ()> {\n+    Ok(())\n+}\n+\n+async fn foo1() -> Result<(), ()> {\n+    let _ = await bar(); //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo2() -> Result<(), ()> {\n+    let _ = await? bar(); //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo3() -> Result<(), ()> {\n+    let _ = await bar()?; //~ ERROR incorrect use of `await`\n+    //~^ ERROR the `?` operator can only be applied to values that implement `std::ops::Try`\n+    Ok(())\n+}\n+async fn foo21() -> Result<(), ()> {\n+    let _ = await { bar() }; //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo22() -> Result<(), ()> {\n+    let _ = await(bar()); //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo23() -> Result<(), ()> {\n+    let _ = await { bar() }?; //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo4() -> Result<(), ()> {\n+    let _ = (await bar())?; //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo5() -> Result<(), ()> {\n+    let _ = bar().await(); //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo6() -> Result<(), ()> {\n+    let _ = bar().await()?; //~ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+async fn foo7() -> Result<(), ()> {\n+    let _ = bar().await; // OK\n+    Ok(())\n+}\n+async fn foo8() -> Result<(), ()> {\n+    let _ = bar().await?; // OK\n+    Ok(())\n+}\n+fn foo9() -> Result<(), ()> {\n+    let _ = await bar(); //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo10() -> Result<(), ()> {\n+    let _ = await? bar(); //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo11() -> Result<(), ()> {\n+    let _ = await bar()?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo12() -> Result<(), ()> {\n+    let _ = (await bar())?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo13() -> Result<(), ()> {\n+    let _ = bar().await(); //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo14() -> Result<(), ()> {\n+    let _ = bar().await()?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    //~^ ERROR incorrect use of `await`\n+    Ok(())\n+}\n+fn foo15() -> Result<(), ()> {\n+    let _ = bar().await; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    Ok(())\n+}\n+fn foo16() -> Result<(), ()> {\n+    let _ = bar().await?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+    Ok(())\n+}\n+fn foo24() -> Result<(), ()> {\n+    fn foo() -> Result<(), ()> {\n+        let _ = bar().await?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+        Ok(())\n+    }\n+    foo()\n+}\n+fn foo25() -> Result<(), ()> {\n+    let foo = || {\n+        let _ = bar().await?; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+        Ok(())\n+    };\n+    foo()\n+}\n+\n+fn main() {\n+    match await { await => () }\n+    //~^ ERROR expected expression, found `=>`\n+    //~| ERROR incorrect use of `await`\n+} //~ ERROR expected one of `.`, `?`, `{`, or an operator, found `}`"}, {"sha": "380da4448ad323ee0a2853215a212de245aaac21", "filename": "src/test/ui/await-keyword/incorrect-syntax-suggestions.stderr", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2Fincorrect-syntax-suggestions.stderr?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -0,0 +1,207 @@\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:10:13\n+   |\n+LL |     let _ = await bar();\n+   |             ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:14:13\n+   |\n+LL |     let _ = await? bar();\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await?`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:18:13\n+   |\n+LL |     let _ = await bar()?;\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:23:13\n+   |\n+LL |     let _ = await { bar() };\n+   |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:27:13\n+   |\n+LL |     let _ = await(bar());\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `(bar()).await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:31:13\n+   |\n+LL |     let _ = await { bar() }?;\n+   |             ^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ bar() }.await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:35:14\n+   |\n+LL |     let _ = (await bar())?;\n+   |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:39:24\n+   |\n+LL |     let _ = bar().await();\n+   |                        ^^ help: `await` is not a method call, remove the parentheses\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:43:24\n+   |\n+LL |     let _ = bar().await()?;\n+   |                        ^^ help: `await` is not a method call, remove the parentheses\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:55:13\n+   |\n+LL |     let _ = await bar();\n+   |             ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:60:13\n+   |\n+LL |     let _ = await? bar();\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await?`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:65:13\n+   |\n+LL |     let _ = await bar()?;\n+   |             ^^^^^^^^^^^^ help: `await` is a postfix operation: `bar()?.await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:70:14\n+   |\n+LL |     let _ = (await bar())?;\n+   |              ^^^^^^^^^^^ help: `await` is a postfix operation: `bar().await`\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:75:24\n+   |\n+LL |     let _ = bar().await();\n+   |                        ^^ help: `await` is not a method call, remove the parentheses\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:80:24\n+   |\n+LL |     let _ = bar().await()?;\n+   |                        ^^ help: `await` is not a method call, remove the parentheses\n+\n+error: expected expression, found `=>`\n+  --> $DIR/incorrect-syntax-suggestions.rs:108:25\n+   |\n+LL |     match await { await => () }\n+   |                   ----- ^^ expected expression\n+   |                   |\n+   |                   while parsing this incorrect await expression\n+\n+error: incorrect use of `await`\n+  --> $DIR/incorrect-syntax-suggestions.rs:108:11\n+   |\n+LL |     match await { await => () }\n+   |           ^^^^^^^^^^^^^^^^^^^^^ help: `await` is a postfix operation: `{ await => () }.await`\n+\n+error: expected one of `.`, `?`, `{`, or an operator, found `}`\n+  --> $DIR/incorrect-syntax-suggestions.rs:111:1\n+   |\n+LL |     match await { await => () }\n+   |     -----                      - expected one of `.`, `?`, `{`, or an operator here\n+   |     |\n+   |     while parsing this match expression\n+...\n+LL | }\n+   | ^ unexpected token\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:55:13\n+   |\n+LL | fn foo9() -> Result<(), ()> {\n+   |    ---- this is not `async`\n+LL |     let _ = await bar();\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:60:13\n+   |\n+LL | fn foo10() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = await? bar();\n+   |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:65:13\n+   |\n+LL | fn foo11() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = await bar()?;\n+   |             ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:70:14\n+   |\n+LL | fn foo12() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = (await bar())?;\n+   |              ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:75:13\n+   |\n+LL | fn foo13() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = bar().await();\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:80:13\n+   |\n+LL | fn foo14() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = bar().await()?;\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:85:13\n+   |\n+LL | fn foo15() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = bar().await;\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:89:13\n+   |\n+LL | fn foo16() -> Result<(), ()> {\n+   |    ----- this is not `async`\n+LL |     let _ = bar().await?;\n+   |             ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:94:17\n+   |\n+LL |     fn foo() -> Result<(), ()> {\n+   |        --- this is not `async`\n+LL |         let _ = bar().await?;\n+   |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/incorrect-syntax-suggestions.rs:101:17\n+   |\n+LL |     let foo = || {\n+   |               -- this is not `async`\n+LL |         let _ = bar().await?;\n+   |                 ^^^^^^^^^^^ only allowed inside `async` functions and blocks\n+\n+error[E0277]: the `?` operator can only be applied to values that implement `std::ops::Try`\n+  --> $DIR/incorrect-syntax-suggestions.rs:18:19\n+   |\n+LL |     let _ = await bar()?;\n+   |                   ^^^^^^ the `?` operator cannot be applied to type `impl std::future::Future`\n+   |\n+   = help: the trait `std::ops::Try` is not implemented for `impl std::future::Future`\n+   = note: required by `std::ops::Try::into_result`\n+\n+error: aborting due to 29 previous errors\n+\n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "4e525974c2c6fbd521b03e8fbedcbbfc99a5cb7d", "filename": "src/test/ui/await-keyword/post_expansion_error.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -2,7 +2,9 @@ error: expected expression, found `)`\n   --> $DIR/post_expansion_error.rs:8:12\n    |\n LL |     await!()\n-   |            ^ expected expression\n+   |     -----  ^ expected expression\n+   |     |\n+   |     while parsing this await macro call\n \n error: aborting due to previous error\n "}, {"sha": "5966edd0bf09856643ee0d12b73aa2c2104a9b9f", "filename": "src/test/ui/issues/issue-51719.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -9,3 +9,5 @@ async fn foo() {}\n fn make_generator() {\n     let _gen = || foo.await; //~ ERROR `await` is only allowed inside `async` functions and blocks\n }\n+\n+fn main() {}"}, {"sha": "c06165b24468fb97f6b655d597336d699380c0e6", "filename": "src/test/ui/issues/issue-51719.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -2,7 +2,9 @@ error[E0728]: `await` is only allowed inside `async` functions and blocks\n   --> $DIR/issue-51719.rs:10:19\n    |\n LL |     let _gen = || foo.await;\n-   |                   ^^^^^^^^^\n+   |                -- ^^^^^^^^^ only allowed inside `async` functions and blocks\n+   |                |\n+   |                this is not `async`\n \n error: aborting due to previous error\n "}, {"sha": "97b63d1590ec62bdd63511078c9a6f772860a76f", "filename": "src/test/ui/issues/issue-51751.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70b38d13a530a625725aa9a8cb7c959fa52e3747/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr?ref=70b38d13a530a625725aa9a8cb7c959fa52e3747", "patch": "@@ -1,8 +1,11 @@\n error[E0728]: `await` is only allowed inside `async` functions and blocks\n   --> $DIR/issue-51751.rs:11:20\n    |\n+LL | fn main() {\n+   |    ---- this is not `async`\n+LL |     let result = inc(10000);\n LL |     let finished = result.await;\n-   |                    ^^^^^^^^^^^^\n+   |                    ^^^^^^^^^^^^ only allowed inside `async` functions and blocks\n \n error: aborting due to previous error\n "}]}