{"sha": "773fa7adbca745e86c59503e17d9d4c5b7dcc275", "node_id": "C_kwDOAAsO6NoAKDc3M2ZhN2FkYmNhNzQ1ZTg2YzU5NTAzZTE3ZDlkNGM1YjdkY2MyNzU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-01-27T05:47:03Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-02-19T18:59:00Z"}, "message": "Consolidate normalization in confirm_poly_trait_refs", "tree": {"sha": "aea81d57653dd43f24651d053be522fb13a43903", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/aea81d57653dd43f24651d053be522fb13a43903"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/773fa7adbca745e86c59503e17d9d4c5b7dcc275", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/773fa7adbca745e86c59503e17d9d4c5b7dcc275", "html_url": "https://github.com/rust-lang/rust/commit/773fa7adbca745e86c59503e17d9d4c5b7dcc275", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/773fa7adbca745e86c59503e17d9d4c5b7dcc275/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e08d5693609a659e45025b8ea4dbd9efa342fa68", "url": "https://api.github.com/repos/rust-lang/rust/commits/e08d5693609a659e45025b8ea4dbd9efa342fa68", "html_url": "https://github.com/rust-lang/rust/commit/e08d5693609a659e45025b8ea4dbd9efa342fa68"}], "stats": {"total": 103, "additions": 30, "deletions": 73}, "files": [{"sha": "2579e4b3174349d0cb0d734c56a5a8e1723f99c9", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 30, "deletions": 73, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/773fa7adbca745e86c59503e17d9d4c5b7dcc275/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/773fa7adbca745e86c59503e17d9d4c5b7dcc275/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=773fa7adbca745e86c59503e17d9d4c5b7dcc275", "patch": "@@ -553,23 +553,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         )\n         .map_bound(|(trait_ref, _)| trait_ref);\n \n-        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n-            normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                trait_ref,\n-            )\n-        });\n-\n-        obligations.extend(self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation.predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?);\n-        Ok(ImplSourceFnPointerData { fn_ty: self_ty, nested: obligations })\n+        let nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n+        Ok(ImplSourceFnPointerData { fn_ty: self_ty, nested })\n     }\n \n     fn confirm_trait_alias_candidate(\n@@ -616,26 +601,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, ?generator_def_id, ?substs, \"confirm_generator_candidate\");\n \n         let trait_ref = self.generator_trait_ref_unnormalized(obligation, substs);\n-        let Normalized { value: trait_ref, mut obligations } = ensure_sufficient_stack(|| {\n-            normalize_with_depth(\n-                self,\n-                obligation.param_env,\n-                obligation.cause.clone(),\n-                obligation.recursion_depth + 1,\n-                trait_ref,\n-            )\n-        });\n \n-        debug!(?trait_ref, ?obligations, \"generator candidate obligations\");\n-\n-        obligations.extend(self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation.predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?);\n+        let nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n+        debug!(?trait_ref, ?nested, \"generator candidate obligations\");\n \n-        Ok(ImplSourceGeneratorData { generator_def_id, substs, nested: obligations })\n+        Ok(ImplSourceGeneratorData { generator_def_id, substs, nested })\n     }\n \n     #[instrument(skip(self), level = \"debug\")]\n@@ -657,52 +627,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => bug!(\"closure candidate for non-closure {:?}\", obligation),\n         };\n \n-        let obligation_predicate = obligation.predicate;\n-        let Normalized { value: obligation_predicate, mut obligations } =\n-            ensure_sufficient_stack(|| {\n-                normalize_with_depth(\n-                    self,\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    obligation.recursion_depth + 1,\n-                    obligation_predicate,\n-                )\n-            });\n-\n         let trait_ref = self.closure_trait_ref_unnormalized(obligation, substs);\n-        let Normalized { value: trait_ref, obligations: trait_ref_obligations } =\n-            ensure_sufficient_stack(|| {\n-                normalize_with_depth(\n-                    self,\n-                    obligation.param_env,\n-                    obligation.cause.clone(),\n-                    obligation.recursion_depth + 1,\n-                    trait_ref,\n-                )\n-            });\n+        let mut nested = self.confirm_poly_trait_refs(obligation, trait_ref)?;\n \n-        debug!(?closure_def_id, ?trait_ref, ?obligations, \"confirm closure candidate obligations\");\n-\n-        obligations.extend(trait_ref_obligations);\n-        obligations.extend(self.confirm_poly_trait_refs(\n-            obligation.cause.clone(),\n-            obligation.param_env,\n-            obligation_predicate.to_poly_trait_ref(),\n-            trait_ref,\n-        )?);\n+        debug!(?closure_def_id, ?trait_ref, ?nested, \"confirm closure candidate obligations\");\n \n         // FIXME: Chalk\n \n         if !self.tcx().sess.opts.debugging_opts.chalk {\n-            obligations.push(Obligation::new(\n+            nested.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n                 ty::Binder::dummy(ty::PredicateKind::ClosureKind(closure_def_id, substs, kind))\n                     .to_predicate(self.tcx()),\n             ));\n         }\n \n-        Ok(ImplSourceClosureData { closure_def_id, substs, nested: obligations })\n+        Ok(ImplSourceClosureData { closure_def_id, substs, nested })\n     }\n \n     /// In the case of closure types and fn pointers,\n@@ -733,15 +674,31 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     #[instrument(skip(self), level = \"trace\")]\n     fn confirm_poly_trait_refs(\n         &mut self,\n-        obligation_cause: ObligationCause<'tcx>,\n-        obligation_param_env: ty::ParamEnv<'tcx>,\n-        obligation_trait_ref: ty::PolyTraitRef<'tcx>,\n+        obligation: &TraitObligation<'tcx>,\n         expected_trait_ref: ty::PolyTraitRef<'tcx>,\n     ) -> Result<Vec<PredicateObligation<'tcx>>, SelectionError<'tcx>> {\n+        let obligation_trait_ref = obligation.predicate.to_poly_trait_ref();\n+        // Normalize the obligation and expected trait refs together, because why not\n+        let Normalized { obligations: nested, value: (obligation_trait_ref, expected_trait_ref) } =\n+            ensure_sufficient_stack(|| {\n+                self.infcx.commit_unconditionally(|_| {\n+                    normalize_with_depth(\n+                        self,\n+                        obligation.param_env,\n+                        obligation.cause.clone(),\n+                        obligation.recursion_depth + 1,\n+                        (obligation_trait_ref, expected_trait_ref),\n+                    )\n+                })\n+            });\n+\n         self.infcx\n-            .at(&obligation_cause, obligation_param_env)\n+            .at(&obligation.cause, obligation.param_env)\n             .sup(obligation_trait_ref, expected_trait_ref)\n-            .map(|InferOk { obligations, .. }| obligations)\n+            .map(|InferOk { mut obligations, .. }| {\n+                obligations.extend(nested);\n+                obligations\n+            })\n             .map_err(|e| OutputTypeParameterMismatch(expected_trait_ref, obligation_trait_ref, e))\n     }\n "}]}