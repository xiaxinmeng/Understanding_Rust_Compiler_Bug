{"sha": "3112716f123bc0f6f69c4df26894241f41c488ce", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxMTI3MTZmMTIzYmMwZjZmNjljNGRmMjY4OTQyNDFmNDFjNDg4Y2U=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:27:06Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2015-03-23T22:27:06Z"}, "message": "rollup merge of #23506: alexcrichton/remove-some-deprecated-things\n\nConflicts:\n\tsrc/test/run-pass/deprecated-no-split-stack.rs", "tree": {"sha": "9719ea02926515843f8db55b0466e648659eeb44", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9719ea02926515843f8db55b0466e648659eeb44"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3112716f123bc0f6f69c4df26894241f41c488ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3112716f123bc0f6f69c4df26894241f41c488ce", "html_url": "https://github.com/rust-lang/rust/commit/3112716f123bc0f6f69c4df26894241f41c488ce", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3112716f123bc0f6f69c4df26894241f41c488ce/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "aea822626fef66b6607bc50114b1fb6f8dcd148a", "url": "https://api.github.com/repos/rust-lang/rust/commits/aea822626fef66b6607bc50114b1fb6f8dcd148a", "html_url": "https://github.com/rust-lang/rust/commit/aea822626fef66b6607bc50114b1fb6f8dcd148a"}, {"sha": "f945190e6352a1bc965a117569532643319b400f", "url": "https://api.github.com/repos/rust-lang/rust/commits/f945190e6352a1bc965a117569532643319b400f", "html_url": "https://github.com/rust-lang/rust/commit/f945190e6352a1bc965a117569532643319b400f"}], "stats": {"total": 410, "additions": 29, "deletions": 381}, "files": [{"sha": "2f944e49b15161dc6d6243d9aebed4eb49fdb95f", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=3112716f123bc0f6f69c4df26894241f41c488ce", "patch": "@@ -428,11 +428,6 @@ pub fn set_llvm_fn_attrs(ccx: &CrateContext, attrs: &[ast::Attribute], llfn: Val\n         let mut used = true;\n         match &attr.name()[..] {\n             \"no_stack_check\" => unset_split_stack(llfn),\n-            \"no_split_stack\" => {\n-                unset_split_stack(llfn);\n-                ccx.sess().span_warn(attr.span,\n-                                     \"no_split_stack is a deprecated synonym for no_stack_check\");\n-            }\n             \"cold\" => unsafe {\n                 llvm::LLVMAddFunctionAttribute(llfn,\n                                                llvm::FunctionIndex as c_uint,"}, {"sha": "d8c50b5a0942ae37eeedfbad14a71ada51aa65af", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=3112716f123bc0f6f69c4df26894241f41c488ce", "patch": "@@ -78,14 +78,6 @@ pub mod totalord;\n \n pub mod generic;\n \n-fn expand_deprecated_deriving(cx: &mut ExtCtxt,\n-                              span: Span,\n-                              _: &MetaItem,\n-                              _: &Item,\n-                              _: &mut FnMut(P<Item>)) {\n-    cx.span_err(span, \"`deriving` has been renamed to `derive`\");\n-}\n-\n fn expand_derive(cx: &mut ExtCtxt,\n                  _: Span,\n                  mitem: &MetaItem,\n@@ -151,8 +143,6 @@ macro_rules! derive_traits {\n \n             env.insert(intern(\"derive\"),\n                        Modifier(Box::new(expand_derive)));\n-            env.insert(intern(\"deriving\"),\n-                       Decorator(Box::new(expand_deprecated_deriving)));\n         }\n \n         fn is_builtin_trait(name: &str) -> bool {"}, {"sha": "60f81dac1e9abaf09fc2e1c7cba5c113b9030fdc", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=3112716f123bc0f6f69c4df26894241f41c488ce", "patch": "@@ -201,7 +201,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"no_mangle\", Normal),\n     (\"no_link\", Normal),\n     (\"derive\", Normal),\n-    (\"deriving\", Normal), // deprecation err in expansion\n     (\"should_fail\", Normal),\n     (\"should_panic\", Normal),\n     (\"ignore\", Normal),\n@@ -259,7 +258,6 @@ pub const KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"link_section\", Whitelisted),\n     (\"no_builtins\", Whitelisted),\n     (\"no_mangle\", Whitelisted),\n-    (\"no_split_stack\", Whitelisted),\n     (\"no_stack_check\", Whitelisted),\n     (\"packed\", Whitelisted),\n     (\"static_assert\", Gated(\"static_assert\","}, {"sha": "7da0a6de5479cb7594fbd37a7f743c46c7b7ccfd", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=3112716f123bc0f6f69c4df26894241f41c488ce", "patch": "@@ -22,9 +22,6 @@ use ptr::P;\n /// The specific types of unsupported syntax\n #[derive(Copy, PartialEq, Eq, Hash)]\n pub enum ObsoleteSyntax {\n-    Sized,\n-    ForSized,\n-    ClosureType,\n     ClosureKind,\n     EmptyIndex,\n }\n@@ -49,27 +46,11 @@ impl<'a> ParserObsoleteMethods for parser::Parser<'a> {\n     /// Reports an obsolete syntax non-fatal error.\n     fn obsolete(&mut self, sp: Span, kind: ObsoleteSyntax) {\n         let (kind_str, desc, error) = match kind {\n-            ObsoleteSyntax::ForSized => (\n-                \"for Sized?\",\n-                \"no longer required. Traits (and their `Self` type) do not have the `Sized` bound \\\n-                 by default\",\n-                true,\n-            ),\n-            ObsoleteSyntax::ClosureType => (\n-                \"`|usize| -> bool` closure type\",\n-                \"use unboxed closures instead, no type annotation needed\",\n-                true,\n-            ),\n             ObsoleteSyntax::ClosureKind => (\n                 \"`:`, `&mut:`, or `&:`\",\n                 \"rely on inference instead\",\n                 true,\n             ),\n-            ObsoleteSyntax::Sized => (\n-                \"`Sized? T` for removing the `Sized` bound\",\n-                \"write `T: ?Sized` instead\",\n-                true,\n-            ),\n             ObsoleteSyntax::EmptyIndex => (\n                 \"[]\",\n                 \"write `[..]` instead\","}, {"sha": "4ae5e0faa310552144a04720e950c6c5d88d8dcd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 16, "deletions": 260, "changes": 276, "blob_url": "https://github.com/rust-lang/rust/blob/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=3112716f123bc0f6f69c4df26894241f41c488ce", "patch": "@@ -516,11 +516,7 @@ impl<'a> Parser<'a> {\n \n     pub fn parse_path_list_item(&mut self) -> ast::PathListItem {\n         let lo = self.span.lo;\n-        let node = if self.eat_keyword_noexpect(keywords::Mod) {\n-            let span = self.last_span;\n-            self.span_warn(span, \"deprecated syntax; use the `self` keyword now\");\n-            ast::PathListMod { id: ast::DUMMY_NODE_ID }\n-        } else if self.eat_keyword(keywords::SelfValue) {\n+        let node = if self.eat_keyword(keywords::SelfValue) {\n             ast::PathListMod { id: ast::DUMMY_NODE_ID }\n         } else {\n             let ident = self.parse_ident();\n@@ -619,23 +615,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Expect and consume a `|`. If `||` is seen, replace it with a single\n-    /// `|` and continue. If a `|` is not seen, signal an error.\n-    fn expect_or(&mut self) {\n-        self.expected_tokens.push(TokenType::Token(token::BinOp(token::Or)));\n-        match self.token {\n-            token::BinOp(token::Or) => self.bump(),\n-            token::OrOr => {\n-                let span = self.span;\n-                let lo = span.lo + BytePos(1);\n-                self.replace_token(token::BinOp(token::Or), lo, span.hi)\n-            }\n-            _ => {\n-                self.expect_one_of(&[], &[]);\n-            }\n-        }\n-    }\n-\n     pub fn expect_no_suffix(&self, sp: Span, kind: &str, suffix: Option<ast::Name>) {\n         match suffix {\n             None => {/* everything ok */}\n@@ -675,28 +654,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parse a sequence bracketed by `|` and `|`, stopping before the `|`.\n-    fn parse_seq_to_before_or<T, F>(&mut self,\n-                                    sep: &token::Token,\n-                                    mut f: F)\n-                                    -> Vec<T> where\n-        F: FnMut(&mut Parser) -> T,\n-    {\n-        let mut first = true;\n-        let mut vector = Vec::new();\n-        while self.token != token::BinOp(token::Or) &&\n-                self.token != token::OrOr {\n-            if first {\n-                first = false\n-            } else {\n-                self.expect(sep)\n-            }\n-\n-            vector.push(f(self))\n-        }\n-        vector\n-    }\n-\n     /// Expect and consume a GT. if a >> is seen, replace it\n     /// with a single > and continue. If a GT is not seen,\n     /// signal an error.\n@@ -1008,11 +965,6 @@ impl<'a> Parser<'a> {\n             self.check_keyword(keywords::Extern)\n     }\n \n-    /// Is the current token one of the keywords that signals a closure type?\n-    pub fn token_is_closure_keyword(&mut self) -> bool {\n-        self.check_keyword(keywords::Unsafe)\n-    }\n-\n     pub fn get_lifetime(&mut self) -> ast::Ident {\n         match self.token {\n             token::Lifetime(ref ident) => *ident,\n@@ -1042,12 +994,9 @@ impl<'a> Parser<'a> {\n         let lifetime_defs = self.parse_late_bound_lifetime_defs();\n \n         // examine next token to decide to do\n-        if self.token_is_bare_fn_keyword() || self.token_is_closure_keyword() {\n-            self.parse_ty_bare_fn_or_ty_closure(lifetime_defs)\n-        } else if self.check(&token::ModSep) ||\n-                  self.token.is_ident() ||\n-                  self.token.is_path()\n-        {\n+        if self.token_is_bare_fn_keyword() {\n+            self.parse_ty_bare_fn(lifetime_defs)\n+        } else {\n             let hi = self.span.hi;\n             let trait_ref = self.parse_trait_ref();\n             let poly_trait_ref = ast::PolyTraitRef { bound_lifetimes: lifetime_defs,\n@@ -1063,8 +1012,6 @@ impl<'a> Parser<'a> {\n                 .chain(other_bounds.into_vec().into_iter())\n                 .collect();\n             ast::TyPolyTraitRef(all_bounds)\n-        } else {\n-            self.parse_ty_closure(lifetime_defs)\n         }\n     }\n \n@@ -1094,7 +1041,6 @@ impl<'a> Parser<'a> {\n         };\n \n         self.expect_keyword(keywords::Fn);\n-        let lifetime_defs = self.parse_legacy_lifetime_defs(lifetime_defs);\n         let (inputs, variadic) = self.parse_fn_args(false, true);\n         let ret_ty = self.parse_ret_ty();\n         let decl = P(FnDecl {\n@@ -1139,71 +1085,6 @@ impl<'a> Parser<'a> {\n          self.obsolete(span, ObsoleteSyntax::ClosureKind);\n     }\n \n-    pub fn parse_ty_bare_fn_or_ty_closure(&mut self, lifetime_defs: Vec<LifetimeDef>) -> Ty_ {\n-        // Both bare fns and closures can begin with stuff like unsafe\n-        // and extern. So we just scan ahead a few tokens to see if we see\n-        // a `fn`.\n-        //\n-        // Closure:  [unsafe] <'lt> |S| [:Bounds] -> T\n-        // Fn:       [unsafe] [extern \"ABI\"] fn <'lt> (S) -> T\n-\n-        if self.check_keyword(keywords::Fn) {\n-            self.parse_ty_bare_fn(lifetime_defs)\n-        } else if self.check_keyword(keywords::Extern) {\n-            self.parse_ty_bare_fn(lifetime_defs)\n-        } else if self.check_keyword(keywords::Unsafe) {\n-            if self.look_ahead(1, |t| t.is_keyword(keywords::Fn) ||\n-                                      t.is_keyword(keywords::Extern)) {\n-                self.parse_ty_bare_fn(lifetime_defs)\n-            } else {\n-                self.parse_ty_closure(lifetime_defs)\n-            }\n-        } else {\n-            self.parse_ty_closure(lifetime_defs)\n-        }\n-    }\n-\n-    /// Parse a TyClosure type\n-    pub fn parse_ty_closure(&mut self, lifetime_defs: Vec<ast::LifetimeDef>) -> Ty_ {\n-        /*\n-\n-        [unsafe] <'lt> |S| [:Bounds] -> T\n-        ^~~~~~~^ ^~~~^  ^  ^~~~~~~~^    ^\n-          |        |       |      |        |\n-          |        |       |      |      Return type\n-          |        |       |  Closure bounds\n-          |        |     Argument types\n-          |      Deprecated lifetime defs\n-          |\n-        Function Style\n-\n-        */\n-\n-        let ty_closure_span = self.last_span;\n-\n-        // To be helpful, parse the closure type as ever\n-        let _ = self.parse_unsafety();\n-\n-        let _ = self.parse_legacy_lifetime_defs(lifetime_defs);\n-\n-        if !self.eat(&token::OrOr) {\n-            self.expect_or();\n-\n-            let _ = self.parse_seq_to_before_or(\n-                &token::Comma,\n-                |p| p.parse_arg_general(false));\n-            self.expect_or();\n-        }\n-\n-        let _ = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n-\n-        let _ = self.parse_ret_ty();\n-\n-        self.obsolete(ty_closure_span, ObsoleteSyntax::ClosureType);\n-\n-        TyInfer\n-    }\n-\n     pub fn parse_unsafety(&mut self) -> Unsafety {\n         if self.eat_keyword(keywords::Unsafe) {\n             return Unsafety::Unsafe;\n@@ -1212,27 +1093,6 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    /// Parses `[ 'for' '<' lifetime_defs '>' ]'\n-    fn parse_legacy_lifetime_defs(&mut self,\n-                                  lifetime_defs: Vec<ast::LifetimeDef>)\n-                                  -> Vec<ast::LifetimeDef>\n-    {\n-        if self.token == token::Lt {\n-            self.bump();\n-            if lifetime_defs.is_empty() {\n-                self.warn(\"deprecated syntax; use the `for` keyword now \\\n-                            (e.g. change `fn<'a>` to `for<'a> fn`)\");\n-                let lifetime_defs = self.parse_lifetime_defs();\n-                self.expect_gt();\n-                lifetime_defs\n-            } else {\n-                self.fatal(\"cannot use new `for` keyword and older syntax together\");\n-            }\n-        } else {\n-            lifetime_defs\n-        }\n-    }\n-\n     /// Parse the items in a trait declaration\n     pub fn parse_trait_items(&mut self) -> Vec<P<TraitItem>> {\n         self.parse_unspanned_seq(\n@@ -1321,19 +1181,7 @@ impl<'a> Parser<'a> {\n             if self.eat(&token::Not) {\n                 NoReturn(self.span)\n             } else {\n-                let t = self.parse_ty();\n-\n-                // We used to allow `fn foo() -> &T + U`, but don't\n-                // anymore. If we see it, report a useful error.  This\n-                // only makes sense because `parse_ret_ty` is only\n-                // used in fn *declarations*, not fn types or where\n-                // clauses (i.e., not when parsing something like\n-                // `FnMut() -> T + Send`, where the `+` is legal).\n-                if self.token == token::BinOp(token::Plus) {\n-                    self.warn(\"deprecated syntax: `()` are required, see RFC 438 for details\");\n-                }\n-\n-                Return(t)\n+                Return(self.parse_ty())\n             }\n         } else {\n             let pos = self.span.lo;\n@@ -1421,18 +1269,9 @@ impl<'a> Parser<'a> {\n             self.parse_borrowed_pointee()\n         } else if self.check_keyword(keywords::For) {\n             self.parse_for_in_type()\n-        } else if self.token_is_bare_fn_keyword() ||\n-                  self.token_is_closure_keyword() {\n-            // BARE FUNCTION OR CLOSURE\n-            self.parse_ty_bare_fn_or_ty_closure(Vec::new())\n-        } else if self.check(&token::BinOp(token::Or)) ||\n-                  self.token == token::OrOr ||\n-                  (self.token == token::Lt &&\n-                   self.look_ahead(1, |t| {\n-                       *t == token::Gt || t.is_lifetime()\n-                   })) {\n-            // CLOSURE\n-            self.parse_ty_closure(Vec::new())\n+        } else if self.token_is_bare_fn_keyword() {\n+            // BARE FUNCTION\n+            self.parse_ty_bare_fn(Vec::new())\n         } else if self.eat_keyword_noexpect(keywords::Typeof) {\n             // TYPEOF\n             // In order to not be ambiguous, the type must be surrounded by parens.\n@@ -3974,56 +3813,19 @@ impl<'a> Parser<'a> {\n         return OwnedSlice::from_vec(result);\n     }\n \n-    fn trait_ref_from_ident(ident: Ident, span: Span) -> TraitRef {\n-        let segment = ast::PathSegment {\n-            identifier: ident,\n-            parameters: ast::PathParameters::none()\n-        };\n-        let path = ast::Path {\n-            span: span,\n-            global: false,\n-            segments: vec![segment],\n-        };\n-        ast::TraitRef {\n-            path: path,\n-            ref_id: ast::DUMMY_NODE_ID,\n-        }\n-    }\n-\n-    /// Matches typaram = (unbound `?`)? IDENT (`?` unbound)? optbounds ( EQ ty )?\n+    /// Matches typaram = IDENT (`?` unbound)? optbounds ( EQ ty )?\n     fn parse_ty_param(&mut self) -> TyParam {\n-        // This is a bit hacky. Currently we are only interested in a single\n-        // unbound, and it may only be `Sized`. To avoid backtracking and other\n-        // complications, we parse an ident, then check for `?`. If we find it,\n-        // we use the ident as the unbound, otherwise, we use it as the name of\n-        // type param. Even worse, we need to check for `?` before or after the\n-        // bound.\n-        let mut span = self.span;\n-        let mut ident = self.parse_ident();\n-        let mut unbound = None;\n-        if self.eat(&token::Question) {\n-            let tref = Parser::trait_ref_from_ident(ident, span);\n-            unbound = Some(tref);\n-            span = self.span;\n-            ident = self.parse_ident();\n-            self.obsolete(span, ObsoleteSyntax::Sized);\n-        }\n+        let span = self.span;\n+        let ident = self.parse_ident();\n \n-        let mut bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified);\n-        if let Some(unbound) = unbound {\n-            let mut bounds_as_vec = bounds.into_vec();\n-            bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n-                                                                trait_ref: unbound,\n-                                                                span: span },\n-                                                 TraitBoundModifier::Maybe));\n-            bounds = OwnedSlice::from_vec(bounds_as_vec);\n-        };\n+        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Modified);\n \n         let default = if self.check(&token::Eq) {\n             self.bump();\n             Some(self.parse_ty_sum())\n-        }\n-        else { None };\n+        } else {\n+            None\n+        };\n \n         TyParam {\n             ident: ident,\n@@ -4654,22 +4456,9 @@ impl<'a> Parser<'a> {\n \n         let ident = self.parse_ident();\n         let mut tps = self.parse_generics();\n-        // This is not very accurate, but since unbound only exists to catch\n-        // obsolete syntax, the span is unlikely to ever be used.\n-        let unbound_span = self.span;\n-        let unbound = self.parse_for_sized();\n \n         // Parse supertrait bounds.\n-        let mut bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n-\n-        if let Some(unbound) = unbound {\n-            let mut bounds_as_vec = bounds.into_vec();\n-            bounds_as_vec.push(TraitTyParamBound(PolyTraitRef { bound_lifetimes: vec![],\n-                                                                trait_ref: unbound,\n-                                                                span:  unbound_span },\n-                                                 TraitBoundModifier::Maybe));\n-            bounds = OwnedSlice::from_vec(bounds_as_vec);\n-        };\n+        let bounds = self.parse_colon_then_ty_param_bounds(BoundParsingMode::Bare);\n \n         self.parse_where_clause(&mut tps);\n \n@@ -4956,39 +4745,6 @@ impl<'a> Parser<'a> {\n         else { Inherited }\n     }\n \n-    fn parse_for_sized(&mut self) -> Option<ast::TraitRef> {\n-        // FIXME, this should really use TraitBoundModifier, but it will get\n-        // re-jigged shortly in any case, so leaving the hacky version for now.\n-        if self.eat_keyword(keywords::For) {\n-            let span = self.span;\n-\n-            let mut ate_question = false;\n-            if self.eat(&token::Question) {\n-                ate_question = true;\n-            }\n-            let ident = self.parse_ident();\n-            if self.eat(&token::Question) {\n-                if ate_question {\n-                    self.span_err(span,\n-                        \"unexpected `?`\");\n-                }\n-                ate_question = true;\n-            }\n-            if !ate_question {\n-                self.span_err(span,\n-                    \"expected `?Sized` after `for` in trait item\");\n-                return None;\n-            }\n-            let _tref = Parser::trait_ref_from_ident(ident, span);\n-\n-            self.obsolete(span, ObsoleteSyntax::ForSized);\n-\n-            None\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Given a termination token, parse all of the items in a module\n     fn parse_mod_items(&mut self, term: &token::Token, inner_lo: BytePos) -> Mod {\n         let mut items = vec![];"}, {"sha": "828d085fd432eb835fb5bf399ea8e0995d8260ee", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3112716f123bc0f6f69c4df26894241f41c488ce/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=3112716f123bc0f6f69c4df26894241f41c488ce", "patch": "@@ -2712,8 +2712,20 @@ impl<'a> State<'a> {\n                        opt_explicit_self: Option<&ast::ExplicitSelf_>)\n                        -> io::Result<()> {\n         try!(self.ibox(indent_unit));\n+        if generics.lifetimes.len() > 0 || generics.ty_params.len() > 0 {\n+            try!(word(&mut self.s, \"for\"));\n+            try!(self.print_generics(generics));\n+        }\n+        let generics = ast::Generics {\n+            lifetimes: Vec::new(),\n+            ty_params: OwnedSlice::empty(),\n+            where_clause: ast::WhereClause {\n+                id: ast::DUMMY_NODE_ID,\n+                predicates: Vec::new(),\n+            },\n+        };\n         try!(self.print_fn(decl, unsafety, abi, name,\n-                           generics, opt_explicit_self,\n+                           &generics, opt_explicit_self,\n                            ast::Inherited));\n         self.end()\n     }"}, {"sha": "060e178eef2b467dd02a4738ab9a5acd367fec61", "filename": "src/test/compile-fail/deriving-is-deprecated.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/aea822626fef66b6607bc50114b1fb6f8dcd148a/src%2Ftest%2Fcompile-fail%2Fderiving-is-deprecated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea822626fef66b6607bc50114b1fb6f8dcd148a/src%2Ftest%2Fcompile-fail%2Fderiving-is-deprecated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fderiving-is-deprecated.rs?ref=aea822626fef66b6607bc50114b1fb6f8dcd148a", "patch": "@@ -1,15 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-\n-#[deriving(Clone)] //~ ERROR `deriving` has been renamed to `derive`\n-struct Foo;\n-\n-fn main() {}"}, {"sha": "db67249bbd93aa11d8e9ede38b9154b0fdc09801", "filename": "src/test/compile-fail/hrtb-precedence-of-plus-error-message.rs", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/aea822626fef66b6607bc50114b1fb6f8dcd148a/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea822626fef66b6607bc50114b1fb6f8dcd148a/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fhrtb-precedence-of-plus-error-message.rs?ref=aea822626fef66b6607bc50114b1fb6f8dcd148a", "patch": "@@ -1,36 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(unboxed_closures)]\n-\n-// Test that we suggest the correct parentheses\n-\n-trait Bar {\n-    fn dummy(&self) { }\n-}\n-\n-struct Foo<'a> {\n-    a: &'a Bar+'a,\n-        //~^ ERROR E0178\n-        //~^^ HELP perhaps you meant `&'a (Bar + 'a)`?\n-\n-    b: &'a mut Bar+'a,\n-        //~^ ERROR E0178\n-        //~^^ HELP perhaps you meant `&'a mut (Bar + 'a)`?\n-\n-    c: Box<Bar+'a>, // OK, no paren needed in this context\n-\n-    d: fn() -> Bar+'a,\n-        //~^ ERROR E0178\n-        //~^^ HELP perhaps you forgot parentheses\n-        //~^^^ WARN deprecated syntax\n-}\n-\n-fn main() { }"}, {"sha": "1b86d08a50dff50d5f63606bfc371c75a750aac7", "filename": "src/test/parse-fail/obsolete-for-sized.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/aea822626fef66b6607bc50114b1fb6f8dcd148a/src%2Ftest%2Fparse-fail%2Fobsolete-for-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea822626fef66b6607bc50114b1fb6f8dcd148a/src%2Ftest%2Fparse-fail%2Fobsolete-for-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fobsolete-for-sized.rs?ref=aea822626fef66b6607bc50114b1fb6f8dcd148a", "patch": "@@ -1,17 +0,0 @@\n-// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-// Test that we generate obsolete syntax errors around usages of `for Sized?`\n-\n-trait Foo for Sized? {} //~ ERROR obsolete syntax: for Sized?\n-\n-trait Bar for ?Sized {} //~ ERROR obsolete syntax: for Sized?\n-\n-fn main() { }"}, {"sha": "ecbfcff812fc1be52e13379fa6022522c7504365", "filename": "src/test/run-pass/deprecated-no-split-stack.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/aea822626fef66b6607bc50114b1fb6f8dcd148a/src%2Ftest%2Frun-pass%2Fdeprecated-no-split-stack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aea822626fef66b6607bc50114b1fb6f8dcd148a/src%2Ftest%2Frun-pass%2Fdeprecated-no-split-stack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdeprecated-no-split-stack.rs?ref=aea822626fef66b6607bc50114b1fb6f8dcd148a", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//~ WARNING no_split_stack is a deprecated synonym for no_stack_check\n-// pretty-expanded FIXME #23616\n-\n-#[no_split_stack]\n-fn main() {\n-}"}]}