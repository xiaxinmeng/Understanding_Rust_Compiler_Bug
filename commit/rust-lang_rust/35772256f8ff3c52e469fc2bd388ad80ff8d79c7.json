{"sha": "35772256f8ff3c52e469fc2bd388ad80ff8d79c7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM1NzcyMjU2ZjhmZjNjNTJlNDY5ZmMyYmQzODhhZDgwZmY4ZDc5Yzc=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-16T20:27:04Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2021-06-16T20:27:46Z"}, "message": "internal: cleanup tests", "tree": {"sha": "c39b1966fc997f7f2668296f8e3784f7aac4a409", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c39b1966fc997f7f2668296f8e3784f7aac4a409"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/35772256f8ff3c52e469fc2bd388ad80ff8d79c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/35772256f8ff3c52e469fc2bd388ad80ff8d79c7", "html_url": "https://github.com/rust-lang/rust/commit/35772256f8ff3c52e469fc2bd388ad80ff8d79c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/35772256f8ff3c52e469fc2bd388ad80ff8d79c7/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee7b649d445b9c33486f3b5c3bef29bdb28124bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/ee7b649d445b9c33486f3b5c3bef29bdb28124bc", "html_url": "https://github.com/rust-lang/rust/commit/ee7b649d445b9c33486f3b5c3bef29bdb28124bc"}], "stats": {"total": 212, "additions": 140, "deletions": 72}, "files": [{"sha": "8e571723dc54f98cd6fb9c7195c4abecab6cc82c", "filename": "crates/ide_assists/src/handlers/replace_for_loop_with_for_each.rs", "status": "modified", "additions": 114, "deletions": 71, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/35772256f8ff3c52e469fc2bd388ad80ff8d79c7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35772256f8ff3c52e469fc2bd388ad80ff8d79c7/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Freplace_for_loop_with_for_each.rs?ref=35772256f8ff3c52e469fc2bd388ad80ff8d79c7", "patch": "@@ -85,38 +85,48 @@ fn is_ref_and_impls_iter_method(\n     let krate = scope.module()?.krate();\n     let traits_in_scope = scope.traits_in_scope();\n     let iter_trait = FamousDefs(sema, Some(krate)).core_iter_Iterator()?;\n-    let has_wanted_method = typ.iterate_method_candidates(\n-        sema.db,\n-        krate,\n-        &traits_in_scope,\n-        Some(&wanted_method),\n-        |_, func| {\n-            if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n-                return Some(());\n-            }\n-            None\n-        },\n-    );\n-    has_wanted_method.and(Some((expr_behind_ref, wanted_method)))\n+\n+    let has_wanted_method = typ\n+        .iterate_method_candidates(\n+            sema.db,\n+            krate,\n+            &traits_in_scope,\n+            Some(&wanted_method),\n+            |_, func| {\n+                if func.ret_type(sema.db).impls_trait(sema.db, iter_trait, &[]) {\n+                    return Some(());\n+                }\n+                None\n+            },\n+        )\n+        .is_some();\n+    if !has_wanted_method {\n+        return None;\n+    }\n+\n+    Some((expr_behind_ref, wanted_method))\n }\n \n /// Whether iterable implements core::Iterator\n fn impls_core_iter(sema: &hir::Semantics<ide_db::RootDatabase>, iterable: &ast::Expr) -> bool {\n-    let it_typ = if let Some(i) = sema.type_of_expr(iterable) {\n-        i\n-    } else {\n-        return false;\n+    let it_typ = match sema.type_of_expr(iterable) {\n+        Some(it) => it,\n+        None => return false,\n     };\n-    let module = if let Some(m) = sema.scope(iterable.syntax()).module() {\n-        m\n-    } else {\n-        return false;\n+\n+    let module = match sema.scope(iterable.syntax()).module() {\n+        Some(it) => it,\n+        None => return false,\n     };\n+\n     let krate = module.krate();\n-    if let Some(iter_trait) = FamousDefs(sema, Some(krate)).core_iter_Iterator() {\n-        return it_typ.impls_trait(sema.db, iter_trait, &[]);\n+    match FamousDefs(sema, Some(krate)).core_iter_Iterator() {\n+        Some(iter_trait) => {\n+            cov_mark::hit!(test_already_impls_iterator);\n+            it_typ.impls_trait(sema.db, iter_trait, &[])\n+        }\n+        None => false,\n     }\n-    false\n }\n \n #[cfg(test)]\n@@ -125,33 +135,6 @@ mod tests {\n \n     use super::*;\n \n-    const EMPTY_ITER_FIXTURE: &'static str = r\"\n-//- /lib.rs deps:core crate:empty_iter\n-pub struct EmptyIter;\n-impl Iterator for EmptyIter {\n-    type Item = usize;\n-    fn next(&mut self) -> Option<Self::Item> { None }\n-}\n-\n-pub struct Empty;\n-impl Empty {\n-    pub fn iter(&self) -> EmptyIter { EmptyIter }\n-    pub fn iter_mut(&self) -> EmptyIter { EmptyIter }\n-}\n-\n-pub struct NoIterMethod;\n-\";\n-\n-    fn check_assist_with_fixtures(before: &str, after: &str) {\n-        let before = &format!(\n-            \"//- /main.rs crate:main deps:core,empty_iter{}{}{}\",\n-            before,\n-            FamousDefs::FIXTURE,\n-            EMPTY_ITER_FIXTURE\n-        );\n-        check_assist(replace_for_loop_with_for_each, before, after);\n-    }\n-\n     #[test]\n     fn test_not_for() {\n         check_assist_not_applicable(\n@@ -201,20 +184,44 @@ fn main() {\n \n     #[test]\n     fn test_for_borrowed() {\n-        check_assist_with_fixtures(\n+        check_assist(\n+            replace_for_loop_with_for_each,\n             r\"\n-use empty_iter::*;\n+//- minicore: iterator\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Iter { Iter }\n+    fn iter_mut(&mut self) -> Iter { Iter }\n+}\n+\n fn main() {\n-    let x = Empty;\n+    let x = S;\n     for $0v in &x {\n         let a = v * 2;\n     }\n }\n \",\n             r\"\n-use empty_iter::*;\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Iter { Iter }\n+    fn iter_mut(&mut self) -> Iter { Iter }\n+}\n+\n fn main() {\n-    let x = Empty;\n+    let x = S;\n     x.iter().for_each(|v| {\n         let a = v * 2;\n     });\n@@ -225,9 +232,10 @@ fn main() {\n \n     #[test]\n     fn test_for_borrowed_no_iter_method() {\n-        check_assist_with_fixtures(\n+        check_assist(\n+            replace_for_loop_with_for_each,\n             r\"\n-use empty_iter::*;\n+struct NoIterMethod;\n fn main() {\n     let x = NoIterMethod;\n     for $0v in &x {\n@@ -236,7 +244,7 @@ fn main() {\n }\n \",\n             r\"\n-use empty_iter::*;\n+struct NoIterMethod;\n fn main() {\n     let x = NoIterMethod;\n     (&x).into_iter().for_each(|v| {\n@@ -249,20 +257,44 @@ fn main() {\n \n     #[test]\n     fn test_for_borrowed_mut() {\n-        check_assist_with_fixtures(\n+        check_assist(\n+            replace_for_loop_with_for_each,\n             r\"\n-use empty_iter::*;\n+//- minicore: iterator\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Iter { Iter }\n+    fn iter_mut(&mut self) -> Iter { Iter }\n+}\n+\n fn main() {\n-    let x = Empty;\n+    let x = S;\n     for $0v in &mut x {\n         let a = v * 2;\n     }\n }\n \",\n             r\"\n-use empty_iter::*;\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n+struct S;\n+impl S {\n+    fn iter(&self) -> Iter { Iter }\n+    fn iter_mut(&mut self) -> Iter { Iter }\n+}\n+\n fn main() {\n-    let x = Empty;\n+    let x = S;\n     x.iter_mut().for_each(|v| {\n         let a = v * 2;\n     });\n@@ -296,21 +328,32 @@ fn main() {\n \n     #[test]\n     fn test_already_impls_iterator() {\n-        check_assist_with_fixtures(\n+        cov_mark::check!(test_already_impls_iterator);\n+        check_assist(\n+            replace_for_loop_with_for_each,\n             r#\"\n-use empty_iter::*;\n+//- minicore: iterator\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n fn main() {\n-    let x = Empty;\n-    for$0 a in x.iter().take(1) {\n+    for$0 a in Iter.take(1) {\n         println!(\"{}\", a);\n     }\n }\n \"#,\n             r#\"\n-use empty_iter::*;\n+struct Iter;\n+impl Iterator for Iter {\n+    type Item = usize;\n+    fn next(&mut self) -> Option<Self::Item> { None }\n+}\n+\n fn main() {\n-    let x = Empty;\n-    x.iter().take(1).for_each(|a| {\n+    Iter.take(1).for_each(|a| {\n         println!(\"{}\", a);\n     });\n }"}, {"sha": "2f0da7fe53e6074dfe2bfd70e4ff00382502c2ef", "filename": "crates/test_utils/src/minicore.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/35772256f8ff3c52e469fc2bd388ad80ff8d79c7/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/35772256f8ff3c52e469fc2bd388ad80ff8d79c7/crates%2Ftest_utils%2Fsrc%2Fminicore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Fminicore.rs?ref=35772256f8ff3c52e469fc2bd388ad80ff8d79c7", "patch": "@@ -209,17 +209,43 @@ pub mod task {\n \n // region:iterator\n pub mod iter {\n+    mod adapters {\n+        pub struct Take<I> {\n+            iter: I,\n+            n: usize,\n+        }\n+\n+        impl<I> Iterator for Take<I>\n+        where\n+            I: Iterator,\n+        {\n+            type Item = <I as Iterator>::Item;\n+\n+            fn next(&mut self) -> Option<<I as Iterator>::Item> {\n+                loop {}\n+            }\n+        }\n+    }\n+    pub use self::adapters::Take;\n+\n     mod traits {\n         mod iterator {\n+            use super::super::Take;\n+\n             pub trait Iterator {\n                 type Item;\n                 #[lang = \"next\"]\n                 fn next(&mut self) -> Option<Self::Item>;\n                 fn nth(&mut self, n: usize) -> Option<Self::Item> {\n                     loop {}\n                 }\n+                fn take(self, n: usize) -> crate::iter::Take<Self> {\n+                    loop {}\n+                }\n             }\n         }\n+        pub use self::iterator::Iterator;\n+\n         mod collect {\n             pub trait IntoIterator {\n                 type Item;\n@@ -236,7 +262,6 @@ pub mod iter {\n             }\n         }\n         pub use self::collect::IntoIterator;\n-        pub use self::iterator::Iterator;\n     }\n     pub use self::traits::{IntoIterator, Iterator};\n }"}]}