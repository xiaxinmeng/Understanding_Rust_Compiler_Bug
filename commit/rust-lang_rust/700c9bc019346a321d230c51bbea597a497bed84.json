{"sha": "700c9bc019346a321d230c51bbea597a497bed84", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwMGM5YmMwMTkzNDZhMzIxZDIzMGM1MWJiZWE1OTdhNDk3YmVkODQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-10-02T14:42:48Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-10-02T14:42:48Z"}, "message": "Expectify find_references tests", "tree": {"sha": "a3dcf3b7aeabb3e0df1dbfc81614e4f8c216b137", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a3dcf3b7aeabb3e0df1dbfc81614e4f8c216b137"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/700c9bc019346a321d230c51bbea597a497bed84", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/700c9bc019346a321d230c51bbea597a497bed84", "html_url": "https://github.com/rust-lang/rust/commit/700c9bc019346a321d230c51bbea597a497bed84", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/700c9bc019346a321d230c51bbea597a497bed84/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5a0e3f6d67d89e21fcb0b79790c432638eebde65", "url": "https://api.github.com/repos/rust-lang/rust/commits/5a0e3f6d67d89e21fcb0b79790c432638eebde65", "html_url": "https://github.com/rust-lang/rust/commit/5a0e3f6d67d89e21fcb0b79790c432638eebde65"}], "stats": {"total": 357, "additions": 181, "deletions": 176}, "files": [{"sha": "1e3e944e941251ce68df518c1ea48d324130a4f3", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 181, "deletions": 176, "changes": 357, "blob_url": "https://github.com/rust-lang/rust/blob/700c9bc019346a321d230c51bbea597a497bed84/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c9bc019346a321d230c51bbea597a497bed84/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=700c9bc019346a321d230c51bbea597a497bed84", "patch": "@@ -190,14 +190,14 @@ fn get_struct_def_name_for_struct_literal_search(\n \n #[cfg(test)]\n mod tests {\n-    use crate::{\n-        mock_analysis::{analysis_and_position, MockAnalysis},\n-        Declaration, Reference, ReferenceSearchResult, SearchScope,\n-    };\n+    use expect_test::{expect, Expect};\n+    use stdx::format_to;\n+\n+    use crate::{mock_analysis::MockAnalysis, SearchScope};\n \n     #[test]\n     fn test_struct_literal_after_space() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n struct Foo <|>{\n     a: i32,\n@@ -210,53 +210,54 @@ fn main() {\n     f = Foo {a: Foo::f()};\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"Foo STRUCT FileId(1) 0..26 7..10 Other\",\n-            &[\"FileId(1) 101..104 StructLiteral\"],\n+            expect![[r#\"\n+                Foo STRUCT FileId(1) 0..26 7..10 Other\n+\n+                FileId(1) 101..104 StructLiteral\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_struct_literal_before_space() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n struct Foo<|> {}\n     fn main() {\n     let f: Foo;\n     f = Foo {};\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"Foo STRUCT FileId(1) 0..13 7..10 Other\",\n-            &[\"FileId(1) 41..44 Other\", \"FileId(1) 54..57 StructLiteral\"],\n+            expect![[r#\"\n+                Foo STRUCT FileId(1) 0..13 7..10 Other\n+\n+                FileId(1) 41..44 Other\n+                FileId(1) 54..57 StructLiteral\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_struct_literal_with_generic_type() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n struct Foo<T> <|>{}\n     fn main() {\n     let f: Foo::<i32>;\n     f = Foo {};\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"Foo STRUCT FileId(1) 0..16 7..10 Other\",\n-            &[\"FileId(1) 64..67 StructLiteral\"],\n+            expect![[r#\"\n+                Foo STRUCT FileId(1) 0..16 7..10 Other\n+\n+                FileId(1) 64..67 StructLiteral\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_struct_literal_for_tuple() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n struct Foo<|>(i32);\n \n@@ -265,17 +266,17 @@ fn main() {\n     f = Foo(1);\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"Foo STRUCT FileId(1) 0..16 7..10 Other\",\n-            &[\"FileId(1) 54..57 StructLiteral\"],\n+            expect![[r#\"\n+                Foo STRUCT FileId(1) 0..16 7..10 Other\n+\n+                FileId(1) 54..57 StructLiteral\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_find_all_refs_for_local() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n fn main() {\n     let mut i = 1;\n@@ -288,22 +289,20 @@ fn main() {\n \n     i = 5;\n }\"#,\n-        );\n-        check_result(\n-            refs,\n-            \"i IDENT_PAT FileId(1) 24..25 Other Write\",\n-            &[\n-                \"FileId(1) 50..51 Other Write\",\n-                \"FileId(1) 54..55 Other Read\",\n-                \"FileId(1) 76..77 Other Write\",\n-                \"FileId(1) 94..95 Other Write\",\n-            ],\n+            expect![[r#\"\n+                i IDENT_PAT FileId(1) 24..25 Other Write\n+\n+                FileId(1) 50..51 Other Write\n+                FileId(1) 54..55 Other Read\n+                FileId(1) 76..77 Other Write\n+                FileId(1) 94..95 Other Write\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn search_filters_by_range() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n fn foo() {\n     let spam<|> = 92;\n@@ -314,41 +313,46 @@ fn bar() {\n     spam + spam\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"spam IDENT_PAT FileId(1) 19..23 Other\",\n-            &[\"FileId(1) 34..38 Other Read\", \"FileId(1) 41..45 Other Read\"],\n+            expect![[r#\"\n+                spam IDENT_PAT FileId(1) 19..23 Other\n+\n+                FileId(1) 34..38 Other Read\n+                FileId(1) 41..45 Other Read\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_find_all_refs_for_param_inside() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n-fn foo(i : u32) -> u32 {\n-    i<|>\n-}\n+fn foo(i : u32) -> u32 { i<|> }\n \"#,\n+            expect![[r#\"\n+                i IDENT_PAT FileId(1) 7..8 Other\n+\n+                FileId(1) 25..26 Other Read\n+            \"#]],\n         );\n-        check_result(refs, \"i IDENT_PAT FileId(1) 7..8 Other\", &[\"FileId(1) 29..30 Other Read\"]);\n     }\n \n     #[test]\n     fn test_find_all_refs_for_fn_param() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n-fn foo(i<|> : u32) -> u32 {\n-    i\n-}\n+fn foo(i<|> : u32) -> u32 { i }\n \"#,\n+            expect![[r#\"\n+                i IDENT_PAT FileId(1) 7..8 Other\n+\n+                FileId(1) 25..26 Other Read\n+            \"#]],\n         );\n-        check_result(refs, \"i IDENT_PAT FileId(1) 7..8 Other\", &[\"FileId(1) 29..30 Other Read\"]);\n     }\n \n     #[test]\n     fn test_find_all_refs_field_name() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n //- /lib.rs\n struct Foo {\n@@ -359,44 +363,50 @@ fn main(s: Foo) {\n     let f = s.spam;\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"spam RECORD_FIELD FileId(1) 17..30 21..25 Other\",\n-            &[\"FileId(1) 67..71 Other Read\"],\n+            expect![[r#\"\n+                spam RECORD_FIELD FileId(1) 17..30 21..25 Other\n+\n+                FileId(1) 67..71 Other Read\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_find_all_refs_impl_item_name() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n struct Foo;\n impl Foo {\n     fn f<|>(&self) {  }\n }\n \"#,\n+            expect![[r#\"\n+                f FN FileId(1) 27..43 30..31 Other\n+\n+            \"#]],\n         );\n-        check_result(refs, \"f FN FileId(1) 27..43 30..31 Other\", &[]);\n     }\n \n     #[test]\n     fn test_find_all_refs_enum_var_name() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n enum Foo {\n     A,\n     B<|>,\n     C,\n }\n \"#,\n+            expect![[r#\"\n+                B VARIANT FileId(1) 22..23 22..23 Other\n+\n+            \"#]],\n         );\n-        check_result(refs, \"B VARIANT FileId(1) 22..23 22..23 Other\", &[]);\n     }\n \n     #[test]\n     fn test_find_all_refs_two_modules() {\n-        let (analysis, pos) = analysis_and_position(\n+        check(\n             r#\"\n //- /lib.rs\n pub mod foo;\n@@ -428,12 +438,12 @@ fn f() {\n     let i = foo::Foo<|> { n: 5 };\n }\n \"#,\n-        );\n-        let refs = analysis.find_all_refs(pos, None).unwrap().unwrap();\n-        check_result(\n-            refs,\n-            \"Foo STRUCT FileId(2) 17..51 28..31 Other\",\n-            &[\"FileId(1) 53..56 StructLiteral\", \"FileId(3) 79..82 StructLiteral\"],\n+            expect![[r#\"\n+                Foo STRUCT FileId(2) 17..51 28..31 Other\n+\n+                FileId(1) 53..56 StructLiteral\n+                FileId(3) 79..82 StructLiteral\n+            \"#]],\n         );\n     }\n \n@@ -442,7 +452,7 @@ fn f() {\n     // which is the whole `foo.rs`, and the second one is in `use foo::Foo`.\n     #[test]\n     fn test_find_all_refs_decl_module() {\n-        let (analysis, pos) = analysis_and_position(\n+        check(\n             r#\"\n //- /lib.rs\n mod foo<|>;\n@@ -458,14 +468,17 @@ pub struct Foo {\n     pub n: u32,\n }\n \"#,\n+            expect![[r#\"\n+                foo SOURCE_FILE FileId(2) 0..35 Other\n+\n+                FileId(1) 14..17 Other\n+            \"#]],\n         );\n-        let refs = analysis.find_all_refs(pos, None).unwrap().unwrap();\n-        check_result(refs, \"foo SOURCE_FILE FileId(2) 0..35 Other\", &[\"FileId(1) 14..17 Other\"]);\n     }\n \n     #[test]\n     fn test_find_all_refs_super_mod_vis() {\n-        let (analysis, pos) = analysis_and_position(\n+        check(\n             r#\"\n //- /lib.rs\n mod foo;\n@@ -483,12 +496,12 @@ pub(super) struct Foo<|> {\n     pub n: u32,\n }\n \"#,\n-        );\n-        let refs = analysis.find_all_refs(pos, None).unwrap().unwrap();\n-        check_result(\n-            refs,\n-            \"Foo STRUCT FileId(3) 0..41 18..21 Other\",\n-            &[\"FileId(2) 20..23 Other\", \"FileId(2) 47..50 StructLiteral\"],\n+            expect![[r#\"\n+                Foo STRUCT FileId(3) 0..41 18..21 Other\n+\n+                FileId(2) 20..23 Other\n+                FileId(2) 47..50 StructLiteral\n+            \"#]],\n         );\n     }\n \n@@ -508,29 +521,31 @@ pub(super) struct Foo<|> {\n             fn f() { super::quux(); }\n         \"#;\n \n-        let (mock, pos) = MockAnalysis::with_files_and_position(code);\n-        let bar = mock.id_of(\"/bar.rs\");\n-        let analysis = mock.analysis();\n+        check_with_scope(\n+            code,\n+            None,\n+            expect![[r#\"\n+                quux FN FileId(1) 19..35 26..30 Other\n \n-        let refs = analysis.find_all_refs(pos, None).unwrap().unwrap();\n-        check_result(\n-            refs,\n-            \"quux FN FileId(1) 19..35 26..30 Other\",\n-            &[\"FileId(2) 16..20 StructLiteral\", \"FileId(3) 16..20 StructLiteral\"],\n+                FileId(2) 16..20 StructLiteral\n+                FileId(3) 16..20 StructLiteral\n+            \"#]],\n         );\n \n-        let refs =\n-            analysis.find_all_refs(pos, Some(SearchScope::single_file(bar))).unwrap().unwrap();\n-        check_result(\n-            refs,\n-            \"quux FN FileId(1) 19..35 26..30 Other\",\n-            &[\"FileId(3) 16..20 StructLiteral\"],\n+        check_with_scope(\n+            code,\n+            Some(\"/bar.rs\"),\n+            expect![[r#\"\n+                quux FN FileId(1) 19..35 26..30 Other\n+\n+                FileId(3) 16..20 StructLiteral\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_find_all_refs_macro_def() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n #[macro_export]\n macro_rules! m1<|> { () => (()) }\n@@ -540,34 +555,36 @@ fn foo() {\n     m1();\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"m1 MACRO_CALL FileId(1) 0..46 29..31 Other\",\n-            &[\"FileId(1) 63..65 StructLiteral\", \"FileId(1) 73..75 StructLiteral\"],\n+            expect![[r#\"\n+                m1 MACRO_CALL FileId(1) 0..46 29..31 Other\n+\n+                FileId(1) 63..65 StructLiteral\n+                FileId(1) 73..75 StructLiteral\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_basic_highlight_read_write() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n fn foo() {\n     let mut i<|> = 0;\n     i = i + 1;\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"i IDENT_PAT FileId(1) 23..24 Other Write\",\n-            &[\"FileId(1) 34..35 Other Write\", \"FileId(1) 38..39 Other Read\"],\n+            expect![[r#\"\n+                i IDENT_PAT FileId(1) 23..24 Other Write\n+\n+                FileId(1) 34..35 Other Write\n+                FileId(1) 38..39 Other Read\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_basic_highlight_field_read_write() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n struct S {\n     f: u32,\n@@ -578,119 +595,107 @@ fn foo() {\n     s.f<|> = 0;\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"f RECORD_FIELD FileId(1) 15..21 15..16 Other\",\n-            &[\"FileId(1) 55..56 Other Read\", \"FileId(1) 68..69 Other Write\"],\n+            expect![[r#\"\n+                f RECORD_FIELD FileId(1) 15..21 15..16 Other\n+\n+                FileId(1) 55..56 Other Read\n+                FileId(1) 68..69 Other Write\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_basic_highlight_decl_no_write() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n fn foo() {\n     let i<|>;\n     i = 1;\n }\n \"#,\n+            expect![[r#\"\n+                i IDENT_PAT FileId(1) 19..20 Other\n+\n+                FileId(1) 26..27 Other Write\n+            \"#]],\n         );\n-        check_result(refs, \"i IDENT_PAT FileId(1) 19..20 Other\", &[\"FileId(1) 26..27 Other Write\"]);\n     }\n \n     #[test]\n     fn test_find_struct_function_refs_outside_module() {\n-        let refs = get_all_refs(\n+        check(\n             r#\"\n mod foo {\n     pub struct Foo;\n \n     impl Foo {\n-        pub fn new<|>() -> Foo {\n-            Foo\n-        }\n+        pub fn new<|>() -> Foo { Foo }\n     }\n }\n \n fn main() {\n     let _f = foo::Foo::new();\n }\n \"#,\n-        );\n-        check_result(\n-            refs,\n-            \"new FN FileId(1) 54..101 61..64 Other\",\n-            &[\"FileId(1) 146..149 StructLiteral\"],\n+            expect![[r#\"\n+                new FN FileId(1) 54..81 61..64 Other\n+\n+                FileId(1) 126..129 StructLiteral\n+            \"#]],\n         );\n     }\n \n     #[test]\n     fn test_find_all_refs_nested_module() {\n-        let code = r#\"\n-            //- /lib.rs\n-            mod foo {\n-                mod bar;\n-            }\n+        check(\n+            r#\"\n+//- /lib.rs\n+mod foo { mod bar; }\n \n-            fn f<|>() {}\n+fn f<|>() {}\n \n-            //- /foo/bar.rs\n-            use crate::f;\n+//- /foo/bar.rs\n+use crate::f;\n \n-            fn g() {\n-                f();\n-            }\n-        \"#;\n+fn g() { f(); }\n+\"#,\n+            expect![[r#\"\n+                f FN FileId(1) 22..31 25..26 Other\n \n-        let (analysis, pos) = analysis_and_position(code);\n-        let refs = analysis.find_all_refs(pos, None).unwrap().unwrap();\n-        check_result(\n-            refs,\n-            \"f FN FileId(1) 26..35 29..30 Other\",\n-            &[\"FileId(2) 11..12 Other\", \"FileId(2) 28..29 StructLiteral\"],\n+                FileId(2) 11..12 Other\n+                FileId(2) 24..25 StructLiteral\n+            \"#]],\n         );\n     }\n \n-    fn get_all_refs(ra_fixture: &str) -> ReferenceSearchResult {\n-        let (analysis, position) = analysis_and_position(ra_fixture);\n-        analysis.find_all_refs(position, None).unwrap().unwrap()\n+    fn check(ra_fixture: &str, expect: Expect) {\n+        check_with_scope(ra_fixture, None, expect)\n     }\n \n-    fn check_result(res: ReferenceSearchResult, expected_decl: &str, expected_refs: &[&str]) {\n-        res.declaration().assert_match(expected_decl);\n-        assert_eq!(res.references.len(), expected_refs.len());\n-        res.references()\n-            .iter()\n-            .enumerate()\n-            .for_each(|(i, r)| ref_assert_match(r, expected_refs[i]));\n-    }\n+    fn check_with_scope(ra_fixture: &str, search_scope: Option<&str>, expect: Expect) {\n+        let (mock_analysis, pos) = MockAnalysis::with_files_and_position(ra_fixture);\n+        let search_scope =\n+            search_scope.map(|path| SearchScope::single_file(mock_analysis.id_of(path)));\n+        let analysis = mock_analysis.analysis();\n+        let refs = analysis.find_all_refs(pos, search_scope).unwrap().unwrap();\n \n-    impl Declaration {\n-        fn debug_render(&self) -> String {\n-            let mut s = format!(\"{} {:?}\", self.nav.debug_render(), self.kind);\n-            if let Some(access) = self.access {\n-                s.push_str(&format!(\" {:?}\", access));\n+        let mut actual = String::new();\n+        {\n+            let decl = refs.declaration;\n+            format_to!(actual, \"{} {:?}\", decl.nav.debug_render(), decl.kind);\n+            if let Some(access) = decl.access {\n+                format_to!(actual, \" {:?}\", access)\n             }\n-            s\n+            actual += \"\\n\\n\";\n         }\n \n-        fn assert_match(&self, expected: &str) {\n-            let actual = self.debug_render();\n-            test_utils::assert_eq_text!(expected.trim(), actual.trim(),);\n-        }\n-    }\n-\n-    fn ref_debug_render(r: &Reference) -> String {\n-        let mut s = format!(\"{:?} {:?} {:?}\", r.file_range.file_id, r.file_range.range, r.kind);\n-        if let Some(access) = r.access {\n-            s.push_str(&format!(\" {:?}\", access));\n+        for r in &refs.references {\n+            format_to!(actual, \"{:?} {:?} {:?}\", r.file_range.file_id, r.file_range.range, r.kind);\n+            if let Some(access) = r.access {\n+                format_to!(actual, \" {:?}\", access);\n+            }\n+            actual += \"\\n\";\n         }\n-        s\n-    }\n-\n-    fn ref_assert_match(r: &Reference, expected: &str) {\n-        let actual = ref_debug_render(r);\n-        test_utils::assert_eq_text!(expected.trim(), actual.trim(),);\n+        expect.assert_eq(&actual)\n     }\n }"}]}