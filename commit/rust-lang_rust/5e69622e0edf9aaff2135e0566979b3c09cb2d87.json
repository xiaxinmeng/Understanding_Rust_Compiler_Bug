{"sha": "5e69622e0edf9aaff2135e0566979b3c09cb2d87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlNjk2MjJlMGVkZjlhYWZmMjEzNWUwNTY2OTc5YjNjMDljYjJkODc=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-08-25T08:22:52Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-08-25T11:38:00Z"}, "message": "Rollup merge of #35867 - frewsxcv:rustdoc-cleanup, r=alexcrichton\n\nVarious refactorings in the rustdoc module.\n\nNone", "tree": {"sha": "1602c66d939db003c31c6770264cdf5e46302d87", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1602c66d939db003c31c6770264cdf5e46302d87"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e69622e0edf9aaff2135e0566979b3c09cb2d87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e69622e0edf9aaff2135e0566979b3c09cb2d87", "html_url": "https://github.com/rust-lang/rust/commit/5e69622e0edf9aaff2135e0566979b3c09cb2d87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e69622e0edf9aaff2135e0566979b3c09cb2d87/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0e1954bdc1570d119deddc46be2087b73f62995", "url": "https://api.github.com/repos/rust-lang/rust/commits/e0e1954bdc1570d119deddc46be2087b73f62995", "html_url": "https://github.com/rust-lang/rust/commit/e0e1954bdc1570d119deddc46be2087b73f62995"}, {"sha": "42e8ac87eb013f34db5739bf154a383424595077", "url": "https://api.github.com/repos/rust-lang/rust/commits/42e8ac87eb013f34db5739bf154a383424595077", "html_url": "https://github.com/rust-lang/rust/commit/42e8ac87eb013f34db5739bf154a383424595077"}], "stats": {"total": 324, "additions": 175, "deletions": 149}, "files": [{"sha": "e2e655ce38bccc807f04796d12b39ede5aeb0b24", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 134, "deletions": 104, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/5e69622e0edf9aaff2135e0566979b3c09cb2d87/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e69622e0edf9aaff2135e0566979b3c09cb2d87/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5e69622e0edf9aaff2135e0566979b3c09cb2d87", "patch": "@@ -12,7 +12,6 @@\n //! that clean them.\n \n pub use self::Type::*;\n-pub use self::PrimitiveType::*;\n pub use self::TypeKind::*;\n pub use self::VariantKind::*;\n pub use self::Mutability::*;\n@@ -287,34 +286,34 @@ impl Item {\n         }\n     }\n     pub fn is_mod(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Module\n+        ItemType::from(self) == ItemType::Module\n     }\n     pub fn is_trait(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Trait\n+        ItemType::from(self) == ItemType::Trait\n     }\n     pub fn is_struct(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Struct\n+        ItemType::from(self) == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Module\n+        ItemType::from(self) == ItemType::Module\n     }\n     pub fn is_fn(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Function\n+        ItemType::from(self) == ItemType::Function\n     }\n     pub fn is_associated_type(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::AssociatedType\n+        ItemType::from(self) == ItemType::AssociatedType\n     }\n     pub fn is_associated_const(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::AssociatedConst\n+        ItemType::from(self) == ItemType::AssociatedConst\n     }\n     pub fn is_method(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Method\n+        ItemType::from(self) == ItemType::Method\n     }\n     pub fn is_ty_method(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::TyMethod\n+        ItemType::from(self) == ItemType::TyMethod\n     }\n     pub fn is_primitive(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Primitive\n+        ItemType::from(self) == ItemType::Primitive\n     }\n     pub fn is_stripped(&self) -> bool {\n         match self.inner { StrippedItem(..) => true, _ => false }\n@@ -380,6 +379,23 @@ pub enum ItemEnum {\n     StrippedItem(Box<ItemEnum>),\n }\n \n+impl ItemEnum {\n+    pub fn generics(&self) -> Option<&Generics> {\n+        Some(match *self {\n+            ItemEnum::StructItem(ref s) => &s.generics,\n+            ItemEnum::EnumItem(ref e) => &e.generics,\n+            ItemEnum::FunctionItem(ref f) => &f.generics,\n+            ItemEnum::TypedefItem(ref t, _) => &t.generics,\n+            ItemEnum::TraitItem(ref t) => &t.generics,\n+            ItemEnum::ImplItem(ref i) => &i.generics,\n+            ItemEnum::TyMethodItem(ref i) => &i.generics,\n+            ItemEnum::MethodItem(ref i) => &i.generics,\n+            ItemEnum::ForeignFunctionItem(ref f) => &f.generics,\n+            _ => return None,\n+        })\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Module {\n     pub items: Vec<Item>,\n@@ -1469,8 +1485,8 @@ pub enum PrimitiveType {\n     Str,\n     Slice,\n     Array,\n-    PrimitiveTuple,\n-    PrimitiveRawPointer,\n+    Tuple,\n+    RawPointer,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n@@ -1500,12 +1516,12 @@ impl Type {\n     pub fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n             Primitive(p) | BorrowedRef { type_: box Primitive(p), ..} => Some(p),\n-            Vector(..) | BorrowedRef{ type_: box Vector(..), ..  } => Some(Slice),\n+            Vector(..) | BorrowedRef{ type_: box Vector(..), ..  } => Some(PrimitiveType::Slice),\n             FixedVector(..) | BorrowedRef { type_: box FixedVector(..), .. } => {\n-                Some(Array)\n+                Some(PrimitiveType::Array)\n             }\n-            Tuple(..) => Some(PrimitiveTuple),\n-            RawPointer(..) => Some(PrimitiveRawPointer),\n+            Tuple(..) => Some(PrimitiveType::Tuple),\n+            RawPointer(..) => Some(PrimitiveType::RawPointer),\n             _ => None,\n         }\n     }\n@@ -1530,25 +1546,25 @@ impl GetDefId for Type {\n impl PrimitiveType {\n     fn from_str(s: &str) -> Option<PrimitiveType> {\n         match s {\n-            \"isize\" => Some(Isize),\n-            \"i8\" => Some(I8),\n-            \"i16\" => Some(I16),\n-            \"i32\" => Some(I32),\n-            \"i64\" => Some(I64),\n-            \"usize\" => Some(Usize),\n-            \"u8\" => Some(U8),\n-            \"u16\" => Some(U16),\n-            \"u32\" => Some(U32),\n-            \"u64\" => Some(U64),\n-            \"bool\" => Some(Bool),\n-            \"char\" => Some(Char),\n-            \"str\" => Some(Str),\n-            \"f32\" => Some(F32),\n-            \"f64\" => Some(F64),\n-            \"array\" => Some(Array),\n-            \"slice\" => Some(Slice),\n-            \"tuple\" => Some(PrimitiveTuple),\n-            \"pointer\" => Some(PrimitiveRawPointer),\n+            \"isize\" => Some(PrimitiveType::Isize),\n+            \"i8\" => Some(PrimitiveType::I8),\n+            \"i16\" => Some(PrimitiveType::I16),\n+            \"i32\" => Some(PrimitiveType::I32),\n+            \"i64\" => Some(PrimitiveType::I64),\n+            \"usize\" => Some(PrimitiveType::Usize),\n+            \"u8\" => Some(PrimitiveType::U8),\n+            \"u16\" => Some(PrimitiveType::U16),\n+            \"u32\" => Some(PrimitiveType::U32),\n+            \"u64\" => Some(PrimitiveType::U64),\n+            \"bool\" => Some(PrimitiveType::Bool),\n+            \"char\" => Some(PrimitiveType::Char),\n+            \"str\" => Some(PrimitiveType::Str),\n+            \"f32\" => Some(PrimitiveType::F32),\n+            \"f64\" => Some(PrimitiveType::F64),\n+            \"array\" => Some(PrimitiveType::Array),\n+            \"slice\" => Some(PrimitiveType::Slice),\n+            \"tuple\" => Some(PrimitiveType::Tuple),\n+            \"pointer\" => Some(PrimitiveType::RawPointer),\n             _ => None,\n         }\n     }\n@@ -1568,25 +1584,25 @@ impl PrimitiveType {\n \n     pub fn to_string(&self) -> &'static str {\n         match *self {\n-            Isize => \"isize\",\n-            I8 => \"i8\",\n-            I16 => \"i16\",\n-            I32 => \"i32\",\n-            I64 => \"i64\",\n-            Usize => \"usize\",\n-            U8 => \"u8\",\n-            U16 => \"u16\",\n-            U32 => \"u32\",\n-            U64 => \"u64\",\n-            F32 => \"f32\",\n-            F64 => \"f64\",\n-            Str => \"str\",\n-            Bool => \"bool\",\n-            Char => \"char\",\n-            Array => \"array\",\n-            Slice => \"slice\",\n-            PrimitiveTuple => \"tuple\",\n-            PrimitiveRawPointer => \"pointer\",\n+            PrimitiveType::Isize => \"isize\",\n+            PrimitiveType::I8 => \"i8\",\n+            PrimitiveType::I16 => \"i16\",\n+            PrimitiveType::I32 => \"i32\",\n+            PrimitiveType::I64 => \"i64\",\n+            PrimitiveType::Usize => \"usize\",\n+            PrimitiveType::U8 => \"u8\",\n+            PrimitiveType::U16 => \"u16\",\n+            PrimitiveType::U32 => \"u32\",\n+            PrimitiveType::U64 => \"u64\",\n+            PrimitiveType::F32 => \"f32\",\n+            PrimitiveType::F64 => \"f64\",\n+            PrimitiveType::Str => \"str\",\n+            PrimitiveType::Bool => \"bool\",\n+            PrimitiveType::Char => \"char\",\n+            PrimitiveType::Array => \"array\",\n+            PrimitiveType::Slice => \"slice\",\n+            PrimitiveType::Tuple => \"tuple\",\n+            PrimitiveType::RawPointer => \"pointer\",\n         }\n     }\n \n@@ -1603,6 +1619,38 @@ impl PrimitiveType {\n     }\n }\n \n+impl From<ast::IntTy> for PrimitiveType {\n+    fn from(int_ty: ast::IntTy) -> PrimitiveType {\n+        match int_ty {\n+            ast::IntTy::Is => PrimitiveType::Isize,\n+            ast::IntTy::I8 => PrimitiveType::I8,\n+            ast::IntTy::I16 => PrimitiveType::I16,\n+            ast::IntTy::I32 => PrimitiveType::I32,\n+            ast::IntTy::I64 => PrimitiveType::I64,\n+        }\n+    }\n+}\n+\n+impl From<ast::UintTy> for PrimitiveType {\n+    fn from(uint_ty: ast::UintTy) -> PrimitiveType {\n+        match uint_ty {\n+            ast::UintTy::Us => PrimitiveType::Usize,\n+            ast::UintTy::U8 => PrimitiveType::U8,\n+            ast::UintTy::U16 => PrimitiveType::U16,\n+            ast::UintTy::U32 => PrimitiveType::U32,\n+            ast::UintTy::U64 => PrimitiveType::U64,\n+        }\n+    }\n+}\n+\n+impl From<ast::FloatTy> for PrimitiveType {\n+    fn from(float_ty: ast::FloatTy) -> PrimitiveType {\n+        match float_ty {\n+            ast::FloatTy::F32 => PrimitiveType::F32,\n+            ast::FloatTy::F64 => PrimitiveType::F64,\n+        }\n+    }\n+}\n \n // Poor man's type parameter substitution at HIR level.\n // Used to replace private type aliases in public signatures with their aliased types.\n@@ -1754,21 +1802,12 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match self.sty {\n             ty::TyNever => Never,\n-            ty::TyBool => Primitive(Bool),\n-            ty::TyChar => Primitive(Char),\n-            ty::TyInt(ast::IntTy::Is) => Primitive(Isize),\n-            ty::TyInt(ast::IntTy::I8) => Primitive(I8),\n-            ty::TyInt(ast::IntTy::I16) => Primitive(I16),\n-            ty::TyInt(ast::IntTy::I32) => Primitive(I32),\n-            ty::TyInt(ast::IntTy::I64) => Primitive(I64),\n-            ty::TyUint(ast::UintTy::Us) => Primitive(Usize),\n-            ty::TyUint(ast::UintTy::U8) => Primitive(U8),\n-            ty::TyUint(ast::UintTy::U16) => Primitive(U16),\n-            ty::TyUint(ast::UintTy::U32) => Primitive(U32),\n-            ty::TyUint(ast::UintTy::U64) => Primitive(U64),\n-            ty::TyFloat(ast::FloatTy::F32) => Primitive(F32),\n-            ty::TyFloat(ast::FloatTy::F64) => Primitive(F64),\n-            ty::TyStr => Primitive(Str),\n+            ty::TyBool => Primitive(PrimitiveType::Bool),\n+            ty::TyChar => Primitive(PrimitiveType::Char),\n+            ty::TyInt(int_ty) => Primitive(int_ty.into()),\n+            ty::TyUint(uint_ty) => Primitive(uint_ty.into()),\n+            ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n+            ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TyBox(t) => {\n                 let box_did = cx.tcx_opt().and_then(|tcx| {\n                     tcx.lang_items.owned_box()\n@@ -2421,25 +2460,25 @@ fn build_deref_target_impls(cx: &DocContext,\n             }\n         };\n         let did = match primitive {\n-            Isize => tcx.lang_items.isize_impl(),\n-            I8 => tcx.lang_items.i8_impl(),\n-            I16 => tcx.lang_items.i16_impl(),\n-            I32 => tcx.lang_items.i32_impl(),\n-            I64 => tcx.lang_items.i64_impl(),\n-            Usize => tcx.lang_items.usize_impl(),\n-            U8 => tcx.lang_items.u8_impl(),\n-            U16 => tcx.lang_items.u16_impl(),\n-            U32 => tcx.lang_items.u32_impl(),\n-            U64 => tcx.lang_items.u64_impl(),\n-            F32 => tcx.lang_items.f32_impl(),\n-            F64 => tcx.lang_items.f64_impl(),\n-            Char => tcx.lang_items.char_impl(),\n-            Bool => None,\n-            Str => tcx.lang_items.str_impl(),\n-            Slice => tcx.lang_items.slice_impl(),\n-            Array => tcx.lang_items.slice_impl(),\n-            PrimitiveTuple => None,\n-            PrimitiveRawPointer => tcx.lang_items.const_ptr_impl(),\n+            PrimitiveType::Isize => tcx.lang_items.isize_impl(),\n+            PrimitiveType::I8 => tcx.lang_items.i8_impl(),\n+            PrimitiveType::I16 => tcx.lang_items.i16_impl(),\n+            PrimitiveType::I32 => tcx.lang_items.i32_impl(),\n+            PrimitiveType::I64 => tcx.lang_items.i64_impl(),\n+            PrimitiveType::Usize => tcx.lang_items.usize_impl(),\n+            PrimitiveType::U8 => tcx.lang_items.u8_impl(),\n+            PrimitiveType::U16 => tcx.lang_items.u16_impl(),\n+            PrimitiveType::U32 => tcx.lang_items.u32_impl(),\n+            PrimitiveType::U64 => tcx.lang_items.u64_impl(),\n+            PrimitiveType::F32 => tcx.lang_items.f32_impl(),\n+            PrimitiveType::F64 => tcx.lang_items.f64_impl(),\n+            PrimitiveType::Char => tcx.lang_items.char_impl(),\n+            PrimitiveType::Bool => None,\n+            PrimitiveType::Str => tcx.lang_items.str_impl(),\n+            PrimitiveType::Slice => tcx.lang_items.slice_impl(),\n+            PrimitiveType::Array => tcx.lang_items.slice_impl(),\n+            PrimitiveType::Tuple => None,\n+            PrimitiveType::RawPointer => tcx.lang_items.const_ptr_impl(),\n         };\n         if let Some(did) = did {\n             if !did.is_local() {\n@@ -2722,21 +2761,12 @@ fn resolve_type(cx: &DocContext,\n \n     let is_generic = match def {\n         Def::PrimTy(p) => match p {\n-            hir::TyStr => return Primitive(Str),\n-            hir::TyBool => return Primitive(Bool),\n-            hir::TyChar => return Primitive(Char),\n-            hir::TyInt(ast::IntTy::Is) => return Primitive(Isize),\n-            hir::TyInt(ast::IntTy::I8) => return Primitive(I8),\n-            hir::TyInt(ast::IntTy::I16) => return Primitive(I16),\n-            hir::TyInt(ast::IntTy::I32) => return Primitive(I32),\n-            hir::TyInt(ast::IntTy::I64) => return Primitive(I64),\n-            hir::TyUint(ast::UintTy::Us) => return Primitive(Usize),\n-            hir::TyUint(ast::UintTy::U8) => return Primitive(U8),\n-            hir::TyUint(ast::UintTy::U16) => return Primitive(U16),\n-            hir::TyUint(ast::UintTy::U32) => return Primitive(U32),\n-            hir::TyUint(ast::UintTy::U64) => return Primitive(U64),\n-            hir::TyFloat(ast::FloatTy::F32) => return Primitive(F32),\n-            hir::TyFloat(ast::FloatTy::F64) => return Primitive(F64),\n+            hir::TyStr => return Primitive(PrimitiveType::Str),\n+            hir::TyBool => return Primitive(PrimitiveType::Bool),\n+            hir::TyChar => return Primitive(PrimitiveType::Char),\n+            hir::TyInt(int_ty) => return Primitive(int_ty.into()),\n+            hir::TyUint(uint_ty) => return Primitive(uint_ty.into()),\n+            hir::TyFloat(float_ty) => return Primitive(float_ty.into()),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(keywords::SelfType.name().to_string());"}, {"sha": "65992798ab0995382ef32a4457c53e42347c00a6", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5e69622e0edf9aaff2135e0566979b3c09cb2d87/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e69622e0edf9aaff2135e0566979b3c09cb2d87/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5e69622e0edf9aaff2135e0566979b3c09cb2d87", "patch": "@@ -23,7 +23,7 @@ use rustc::hir::def_id::DefId;\n use syntax::abi::Abi;\n use rustc::hir;\n \n-use clean;\n+use clean::{self, PrimitiveType};\n use core::DocAccessLevels;\n use html::item_type::ItemType;\n use html::escape::Escape;\n@@ -468,39 +468,39 @@ impl fmt::Display for clean::Type {\n             }\n             clean::Tuple(ref typs) => {\n                 match &typs[..] {\n-                    &[] => primitive_link(f, clean::PrimitiveTuple, \"()\"),\n+                    &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n                     &[ref one] => {\n-                        primitive_link(f, clean::PrimitiveTuple, \"(\")?;\n+                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                         write!(f, \"{},\", one)?;\n-                        primitive_link(f, clean::PrimitiveTuple, \")\")\n+                        primitive_link(f, PrimitiveType::Tuple, \")\")\n                     }\n                     many => {\n-                        primitive_link(f, clean::PrimitiveTuple, \"(\")?;\n+                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                         write!(f, \"{}\", CommaSep(&many))?;\n-                        primitive_link(f, clean::PrimitiveTuple, \")\")\n+                        primitive_link(f, PrimitiveType::Tuple, \")\")\n                     }\n                 }\n             }\n             clean::Vector(ref t) => {\n-                primitive_link(f, clean::Slice, &format!(\"[\"))?;\n+                primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n                 write!(f, \"{}\", t)?;\n-                primitive_link(f, clean::Slice, &format!(\"]\"))\n+                primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n             }\n             clean::FixedVector(ref t, ref s) => {\n-                primitive_link(f, clean::PrimitiveType::Array, \"[\")?;\n+                primitive_link(f, PrimitiveType::Array, \"[\")?;\n                 write!(f, \"{}\", t)?;\n-                primitive_link(f, clean::PrimitiveType::Array,\n+                primitive_link(f, PrimitiveType::Array,\n                                &format!(\"; {}]\", Escape(s)))\n             }\n             clean::Never => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {\n                 match **t {\n                     clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n-                        primitive_link(f, clean::PrimitiveType::PrimitiveRawPointer,\n+                        primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                     _ => {\n-                        primitive_link(f, clean::PrimitiveType::PrimitiveRawPointer,\n+                        primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}\", RawMutableSpace(m)))?;\n                         write!(f, \"{}\", t)\n                     }\n@@ -516,12 +516,13 @@ impl fmt::Display for clean::Type {\n                     clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n                         match **bt {\n                             clean::Generic(_) =>\n-                                primitive_link(f, clean::Slice,\n+                                primitive_link(f, PrimitiveType::Slice,\n                                     &format!(\"&amp;{}{}[{}]\", lt, m, **bt)),\n                             _ => {\n-                                primitive_link(f, clean::Slice, &format!(\"&amp;{}{}[\", lt, m))?;\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                               &format!(\"&amp;{}{}[\", lt, m))?;\n                                 write!(f, \"{}\", **bt)?;\n-                                primitive_link(f, clean::Slice, \"]\")\n+                                primitive_link(f, PrimitiveType::Slice, \"]\")\n                             }\n                         }\n                     }"}, {"sha": "be192179284676b9b76fa40162cf22c4ef8ffc31", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5e69622e0edf9aaff2135e0566979b3c09cb2d87/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e69622e0edf9aaff2135e0566979b3c09cb2d87/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=5e69622e0edf9aaff2135e0566979b3c09cb2d87", "patch": "@@ -50,8 +50,8 @@ pub enum NameSpace {\n     Macro,\n }\n \n-impl ItemType {\n-    pub fn from_item(item: &clean::Item) -> ItemType {\n+impl<'a> From<&'a clean::Item> for ItemType {\n+    fn from(item: &'a clean::Item) -> ItemType {\n         let inner = match item.inner {\n             clean::StrippedItem(box ref item) => item,\n             ref inner@_ => inner,\n@@ -83,8 +83,10 @@ impl ItemType {\n             clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n+}\n \n-    pub fn from_type_kind(kind: clean::TypeKind) -> ItemType {\n+impl From<clean::TypeKind> for ItemType {\n+    fn from(kind: clean::TypeKind) -> ItemType {\n         match kind {\n             clean::TypeStruct   => ItemType::Struct,\n             clean::TypeEnum     => ItemType::Enum,\n@@ -97,7 +99,9 @@ impl ItemType {\n             clean::TypeTypedef  => ItemType::Typedef,\n         }\n     }\n+}\n \n+impl ItemType {\n     pub fn css_class(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\","}, {"sha": "6993f85c3d9a47f1a0d39697f0e04191b760a522", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5e69622e0edf9aaff2135e0566979b3c09cb2d87/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e69622e0edf9aaff2135e0566979b3c09cb2d87/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5e69622e0edf9aaff2135e0566979b3c09cb2d87", "patch": "@@ -509,7 +509,7 @@ pub fn run(mut krate: clean::Crate,\n     } = renderinfo;\n \n     let external_paths = external_paths.into_iter()\n-        .map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t))))\n+        .map(|(k, (v, t))| (k, (v, ItemType::from(t))))\n         .collect();\n \n     let mut cache = Cache {\n@@ -833,7 +833,7 @@ fn mkdir(path: &Path) -> io::Result<()> {\n \n /// Returns a documentation-level item type from the item.\n fn item_type(item: &clean::Item) -> ItemType {\n-    ItemType::from_item(item)\n+    ItemType::from(item)\n }\n \n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n@@ -997,17 +997,8 @@ impl DocFolder for Cache {\n \n         // Register any generics to their corresponding string. This is used\n         // when pretty-printing types\n-        match item.inner {\n-            clean::StructItem(ref s)          => self.generics(&s.generics),\n-            clean::EnumItem(ref e)            => self.generics(&e.generics),\n-            clean::FunctionItem(ref f)        => self.generics(&f.generics),\n-            clean::TypedefItem(ref t, _)      => self.generics(&t.generics),\n-            clean::TraitItem(ref t)           => self.generics(&t.generics),\n-            clean::ImplItem(ref i)            => self.generics(&i.generics),\n-            clean::TyMethodItem(ref i)        => self.generics(&i.generics),\n-            clean::MethodItem(ref i)          => self.generics(&i.generics),\n-            clean::ForeignFunctionItem(ref f) => self.generics(&f.generics),\n-            _ => {}\n+        if let Some(generics) = item.inner.generics() {\n+            self.generics(generics);\n         }\n \n         if !self.seen_mod {\n@@ -1362,7 +1353,7 @@ impl Context {\n         // these modules are recursed into, but not rendered normally\n         // (a flag on the context).\n         if !self.render_redirect_pages {\n-            self.render_redirect_pages = self.maybe_ignore_item(&item);\n+            self.render_redirect_pages = maybe_ignore_item(&item);\n         }\n \n         if item.is_mod() {\n@@ -1445,7 +1436,7 @@ impl Context {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map = BTreeMap::new();\n         for item in &m.items {\n-            if self.maybe_ignore_item(item) { continue }\n+            if maybe_ignore_item(item) { continue }\n \n             let short = item_type(item).css_class();\n             let myname = match item.name {\n@@ -1462,17 +1453,6 @@ impl Context {\n         }\n         return map;\n     }\n-\n-    fn maybe_ignore_item(&self, it: &clean::Item) -> bool {\n-        match it.inner {\n-            clean::StrippedItem(..) => true,\n-            clean::ModuleItem(ref m) => {\n-                it.doc_value().is_none() && m.items.is_empty()\n-                                         && it.visibility != Some(clean::Public)\n-            },\n-            _ => false,\n-        }\n-    }\n }\n \n impl<'a> Item<'a> {\n@@ -1715,7 +1695,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         if let clean::DefaultImplItem(..) = items[*i].inner {\n             return false;\n         }\n-        !cx.maybe_ignore_item(&items[*i])\n+        !maybe_ignore_item(&items[*i])\n     }).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n@@ -1863,6 +1843,17 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     Ok(())\n }\n \n+fn maybe_ignore_item(it: &clean::Item) -> bool {\n+    match it.inner {\n+        clean::StrippedItem(..) => true,\n+        clean::ModuleItem(ref m) => {\n+            it.doc_value().is_none() && m.items.is_empty()\n+                                     && it.visibility != Some(clean::Public)\n+        },\n+        _ => false,\n+    }\n+}\n+\n fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<String> {\n     let mut stability = vec![];\n "}]}