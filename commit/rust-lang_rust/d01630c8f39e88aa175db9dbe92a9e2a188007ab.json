{"sha": "d01630c8f39e88aa175db9dbe92a9e2a188007ab", "node_id": "C_kwDOAAsO6NoAKGQwMTYzMGM4ZjM5ZTg4YWExNzVkYjlkYmU5MmE5ZTJhMTg4MDA3YWI", "commit": {"author": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-01-05T12:31:10Z"}, "committer": {"name": "Ryo Yoshida", "email": "low.ryoshida@gmail.com", "date": "2023-01-05T21:07:08Z"}, "message": "Apply fallback to scalar type variables before final obligation resolution", "tree": {"sha": "f3d65b386c6c0838aa37af0e8e8366cfa79b68f0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3d65b386c6c0838aa37af0e8e8366cfa79b68f0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d01630c8f39e88aa175db9dbe92a9e2a188007ab", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEkSbsQIURluxz4rzf4laYqTBYYXEFAmO3O/wACgkQ4laYqTBY\nYXGuPw//TeLbh4McH9ydZUPduZp4SO1f8MdvjfWTe3jmDz48qCWt8Txfp6g4CivK\nwDq2E21UizIQYxD+xs528BX6Qn8J2cOOHEYrV11OvnM7UGeBep9wEs+iLoH1Mt05\nT0SjESjfr4lr9OLM9Snb2BUZZ6qblfTDWj0qLH41wcnDvjcZgH7jpk82g6EmsFrh\nNZerxvFj6ioPTuyKy4UF+eBbZuwtkTueLN6CTA/DQh1qxiie8dLvmTP5tMCzquKL\nH8RJm10LCpjURBabEM092hSExtMN1b5yzuwTEouZCdO+IBgIXa7IKdFhJOqlA+2+\nxUcs6Bg8FzK0Cy5xx5IkNjU38EfnYntKINVS1Q59YasgSqjaQRYkgef1rLKvvfRR\nlZoaHvL0CuYspRE8ZOyMs7oY9d4m1MAK7ltOr/TumZn4i9RsW+F1O0HxJQYRtaOS\nqLz8qKANk2W6zpuwZnPWZMMLI/uraS+lW3MuzkbF686m7tbqxbNpfkTJNDnHGDSd\nDaOue7qQFPvNmFXWcX8r4JIiH01JPxkJldZlHWv+fFVF4ex/hzA0B6ZGMVnr47yr\n/M2WzaSnRqmyG1arqsE8HladslAwq9kkvac1bdPkdiEHL5v7jqAebNDPBcDKKp6e\n39/C5FC/h6jFmoFtoTAgGZoxkGVAX1EbGCITpbEtl+sixhDKjDE=\n=ge3d\n-----END PGP SIGNATURE-----", "payload": "tree f3d65b386c6c0838aa37af0e8e8366cfa79b68f0\nparent b183612610c6383861f9c983a10588124800bac7\nauthor Ryo Yoshida <low.ryoshida@gmail.com> 1672921870 +0900\ncommitter Ryo Yoshida <low.ryoshida@gmail.com> 1672952828 +0900\n\nApply fallback to scalar type variables before final obligation resolution\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d01630c8f39e88aa175db9dbe92a9e2a188007ab", "html_url": "https://github.com/rust-lang/rust/commit/d01630c8f39e88aa175db9dbe92a9e2a188007ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d01630c8f39e88aa175db9dbe92a9e2a188007ab/comments", "author": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lowr", "id": 24381114, "node_id": "MDQ6VXNlcjI0MzgxMTE0", "avatar_url": "https://avatars.githubusercontent.com/u/24381114?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lowr", "html_url": "https://github.com/lowr", "followers_url": "https://api.github.com/users/lowr/followers", "following_url": "https://api.github.com/users/lowr/following{/other_user}", "gists_url": "https://api.github.com/users/lowr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lowr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lowr/subscriptions", "organizations_url": "https://api.github.com/users/lowr/orgs", "repos_url": "https://api.github.com/users/lowr/repos", "events_url": "https://api.github.com/users/lowr/events{/privacy}", "received_events_url": "https://api.github.com/users/lowr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b183612610c6383861f9c983a10588124800bac7", "url": "https://api.github.com/repos/rust-lang/rust/commits/b183612610c6383861f9c983a10588124800bac7", "html_url": "https://github.com/rust-lang/rust/commit/b183612610c6383861f9c983a10588124800bac7"}], "stats": {"total": 112, "additions": 112, "deletions": 0}, "files": [{"sha": "6b59f1c20daa225b9d4f283bfc4a36a48ed0df3d", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d01630c8f39e88aa175db9dbe92a9e2a188007ab/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01630c8f39e88aa175db9dbe92a9e2a188007ab/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=d01630c8f39e88aa175db9dbe92a9e2a188007ab", "patch": "@@ -512,6 +512,8 @@ impl<'a> InferenceContext<'a> {\n     fn resolve_all(self) -> InferenceResult {\n         let InferenceContext { mut table, mut result, .. } = self;\n \n+        table.fallback_if_possible();\n+\n         // FIXME resolve obligations as well (use Guidance if necessary)\n         table.resolve_obligations_as_possible();\n "}, {"sha": "e7ddd1591fe8a52a2cf04c6949e3589cebd5533a", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d01630c8f39e88aa175db9dbe92a9e2a188007ab/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01630c8f39e88aa175db9dbe92a9e2a188007ab/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=d01630c8f39e88aa175db9dbe92a9e2a188007ab", "patch": "@@ -350,6 +350,51 @@ impl<'a> InferenceTable<'a> {\n         self.resolve_with_fallback(t, &|_, _, d, _| d)\n     }\n \n+    /// Apply a fallback to unresolved scalar types. Integer type variables and float type\n+    /// variables are replaced with i32 and f64, respectively.\n+    ///\n+    /// This method is only intended to be called just before returning inference results (i.e. in\n+    /// `InferenceContext::resolve_all()`).\n+    ///\n+    /// FIXME: This method currently doesn't apply fallback to unconstrained general type variables\n+    /// whereas rustc replaces them with `()` or `!`.\n+    pub(super) fn fallback_if_possible(&mut self) {\n+        let int_fallback = TyKind::Scalar(Scalar::Int(IntTy::I32)).intern(Interner);\n+        let float_fallback = TyKind::Scalar(Scalar::Float(FloatTy::F64)).intern(Interner);\n+\n+        let scalar_vars: Vec<_> = self\n+            .type_variable_table\n+            .iter()\n+            .enumerate()\n+            .filter_map(|(index, flags)| {\n+                let kind = if flags.contains(TypeVariableFlags::INTEGER) {\n+                    TyVariableKind::Integer\n+                } else if flags.contains(TypeVariableFlags::FLOAT) {\n+                    TyVariableKind::Float\n+                } else {\n+                    return None;\n+                };\n+\n+                // FIXME: This is not really the nicest way to get `InferenceVar`s. Can we get them\n+                // without directly constructing them from `index`?\n+                let var = InferenceVar::from(index as u32).to_ty(Interner, kind);\n+                Some(var)\n+            })\n+            .collect();\n+\n+        for var in scalar_vars {\n+            let maybe_resolved = self.resolve_ty_shallow(&var);\n+            if let TyKind::InferenceVar(_, kind) = maybe_resolved.kind(Interner) {\n+                let fallback = match kind {\n+                    TyVariableKind::Integer => &int_fallback,\n+                    TyVariableKind::Float => &float_fallback,\n+                    TyVariableKind::General => unreachable!(),\n+                };\n+                self.unify(&var, fallback);\n+            }\n+        }\n+    }\n+\n     /// Unify two relatable values (e.g. `Ty`) and register new trait goals that arise from that.\n     pub(crate) fn unify<T: ?Sized + Zip<Interner>>(&mut self, ty1: &T, ty2: &T) -> bool {\n         let result = match self.try_unify(ty1, ty2) {"}, {"sha": "d01fe0632859c3f295d5e01fbb1a18a002397d3e", "filename": "crates/hir-ty/src/tests/traits.rs", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/d01630c8f39e88aa175db9dbe92a9e2a188007ab/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d01630c8f39e88aa175db9dbe92a9e2a188007ab/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Ftraits.rs?ref=d01630c8f39e88aa175db9dbe92a9e2a188007ab", "patch": "@@ -4100,3 +4100,68 @@ where\n     \"#,\n     );\n }\n+\n+#[test]\n+fn bin_op_with_scalar_fallback() {\n+    // Extra impls are significant so that chalk doesn't give us definite guidances.\n+    check_types(\n+        r#\"\n+//- minicore: add\n+use core::ops::Add;\n+\n+struct Vec2<T>(T, T);\n+\n+impl Add for Vec2<i32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<u32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<f32> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+impl Add for Vec2<f64> {\n+    type Output = Self;\n+    fn add(self, rhs: Self) -> Self::Output { loop {} }\n+}\n+\n+fn test() {\n+    let a = Vec2(1, 2);\n+    let b = Vec2(3, 4);\n+    let c = a + b;\n+      //^ Vec2<i32>\n+    let a = Vec2(1., 2.);\n+    let b = Vec2(3., 4.);\n+    let c = a + b;\n+      //^ Vec2<f64>\n+}\n+\"#,\n+    );\n+}\n+\n+#[test]\n+fn trait_method_with_scalar_fallback() {\n+    check_types(\n+        r#\"\n+trait Trait {\n+    type Output;\n+    fn foo(&self) -> Self::Output;\n+}\n+impl<T> Trait for T {\n+    type Output = T;\n+    fn foo(&self) -> Self::Output { loop {} }\n+}\n+fn test() {\n+    let a = 42;\n+    let b = a.foo();\n+      //^ i32\n+    let a = 3.14;\n+    let b = a.foo();\n+      //^ f64\n+}\n+\"#,\n+    );\n+}"}]}