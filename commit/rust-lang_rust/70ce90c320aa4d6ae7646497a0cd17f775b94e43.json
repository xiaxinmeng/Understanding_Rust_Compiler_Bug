{"sha": "70ce90c320aa4d6ae7646497a0cd17f775b94e43", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcwY2U5MGMzMjBhYTRkNmFlNzY0NjQ5N2EwY2QxN2Y3NzViOTRlNDM=", "commit": {"author": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-08-16T22:02:20Z"}, "committer": {"name": "Jonathan Turner", "email": "jturner@mozilla.com", "date": "2016-08-17T22:24:42Z"}, "message": "Move 'doesn't live long enough' errors to labels", "tree": {"sha": "5180cf947f5caabb01122aedd47b7f9e1be3f862", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5180cf947f5caabb01122aedd47b7f9e1be3f862"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/70ce90c320aa4d6ae7646497a0cd17f775b94e43", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/70ce90c320aa4d6ae7646497a0cd17f775b94e43", "html_url": "https://github.com/rust-lang/rust/commit/70ce90c320aa4d6ae7646497a0cd17f775b94e43", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/70ce90c320aa4d6ae7646497a0cd17f775b94e43/comments", "author": null, "committer": null, "parents": [{"sha": "514d4cef24a3a463d7423bd75d17335547c6a99c", "url": "https://api.github.com/repos/rust-lang/rust/commits/514d4cef24a3a463d7423bd75d17335547c6a99c", "html_url": "https://github.com/rust-lang/rust/commit/514d4cef24a3a463d7423bd75d17335547c6a99c"}], "stats": {"total": 173, "additions": 128, "deletions": 45}, "files": [{"sha": "667bf16874ec4df7165acfc0d41da0076e67334e", "filename": "src/librustc_borrowck/borrowck/gather_loans/lifetime.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Flifetime.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -96,7 +96,7 @@ impl<'a, 'tcx> GuaranteeLifetimeContext<'a, 'tcx> {\n         //! Reports an error if `loan_region` is larger than `max_scope`\n \n         if !self.bccx.is_subregion_of(self.loan_region, max_scope) {\n-            Err(self.report_error(err_out_of_scope(max_scope, self.loan_region)))\n+            Err(self.report_error(err_out_of_scope(max_scope, self.loan_region, self.cause)))\n         } else {\n             Ok(())\n         }"}, {"sha": "7e3466c1ad84ad97d16e3ed86f5b8fe47790e719", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 76, "deletions": 16, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -43,7 +43,7 @@ use std::mem;\n use std::rc::Rc;\n use syntax::ast;\n use syntax::attr::AttrMetaMethods;\n-use syntax_pos::{MultiSpan, Span};\n+use syntax_pos::{MultiSpan, Span, BytePos};\n use errors::DiagnosticBuilder;\n \n use rustc::hir;\n@@ -566,7 +566,7 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n #[derive(PartialEq)]\n pub enum bckerr_code {\n     err_mutbl,\n-    err_out_of_scope(ty::Region, ty::Region), // superscope, subscope\n+    err_out_of_scope(ty::Region, ty::Region, euv::LoanCause), // superscope, subscope, loan cause\n     err_borrowed_pointer_too_short(ty::Region, ty::Region), // loan, ptr\n }\n \n@@ -614,9 +614,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         // Catch and handle some particular cases.\n         match (&err.code, &err.cause) {\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic),\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReStatic, _),\n              &BorrowViolation(euv::ClosureCapture(span))) |\n-            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..)),\n+            (&err_out_of_scope(ty::ReScope(_), ty::ReFree(..), _),\n              &BorrowViolation(euv::ClosureCapture(span))) => {\n                 return self.report_out_of_scope_escaping_closure_capture(&err, span);\n             }\n@@ -963,6 +963,24 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             .emit();\n     }\n \n+    fn convert_region_to_span(&self, region: ty::Region) -> Option<Span> {\n+        match region {\n+            ty::ReScope(scope) => {\n+                match scope.span(&self.tcx.region_maps, &self.tcx.map) {\n+                    Some(s) => {\n+                        let mut last_span = s;\n+                        last_span.lo = BytePos(last_span.hi.0 - 1);\n+                        Some(last_span)\n+                    }\n+                    None => {\n+                        None\n+                    }\n+                }\n+            }\n+            _ => None\n+        }\n+    }\n+\n     pub fn note_and_explain_bckerr(&self, db: &mut DiagnosticBuilder, err: BckError<'tcx>,\n         error_span: Span) {\n         let code = err.code;\n@@ -1003,19 +1021,61 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            err_out_of_scope(super_scope, sub_scope) => {\n-                self.tcx.note_and_explain_region(\n-                    db,\n-                    \"reference must be valid for \",\n-                    sub_scope,\n-                    \"...\");\n-                self.tcx.note_and_explain_region(\n-                    db,\n-                    \"...but borrowed value is only valid for \",\n-                    super_scope,\n-                    \"\");\n+            err_out_of_scope(super_scope, sub_scope, cause) => {\n+                match cause {\n+                    euv::ClosureCapture(s) => {\n+                        match db.span.primary_span() {\n+                            Some(primary) => {\n+                                db.span = MultiSpan::from_span(s);\n+                                db.span_label(primary, &format!(\"capture occurs here\"));\n+                                db.span_label(s, &format!(\"does not live long enough\"));\n+                            }\n+                            None => ()\n+                        }\n+                    }\n+                    _ => {\n+                        db.span_label(error_span, &format!(\"does not live long enough\"));\n+                    }\n+                }\n+\n+                let sub_span = self.convert_region_to_span(sub_scope);\n+                let super_span = self.convert_region_to_span(super_scope);\n+\n+                match (sub_span, super_span) {\n+                    (Some(s1), Some(s2)) if s1 == s2 => {\n+                        db.span_label(s1, &\"borrowed value dropped before borrower\");\n+                        db.note(\"values in a scope are dropped in the opposite order \\\n+                                they are created\");\n+                    }\n+                    _ => {\n+                        match sub_span {\n+                            Some(s) => {\n+                                db.span_label(s, &\"borrowed value must be valid until here\");\n+                            }\n+                            None => {\n+                                self.tcx.note_and_explain_region(\n+                                    db,\n+                                    \"borrowed value must be valid for \",\n+                                    sub_scope,\n+                                    \"...\");\n+                            }\n+                        }\n+                        match super_span {\n+                            Some(s) => {\n+                                db.span_label(s, &\"borrowed value only valid until here\");\n+                            }\n+                            None => {\n+                                self.tcx.note_and_explain_region(\n+                                    db,\n+                                    \"...but borrowed value is only valid for \",\n+                                    super_scope,\n+                                    \"\");\n+                            }\n+                        }\n+                    }\n+                }\n+\n                 if let Some(span) = statement_scope_span(self.tcx, super_scope) {\n-                    db.span_label(error_span, &format!(\"does not live long enough\"));\n                     db.span_help(span,\n                                  \"consider using a `let` binding to increase its lifetime\");\n                 }"}, {"sha": "6c9f67b2b33d45151aba71dce7f1c157f940fdca", "filename": "src/test/compile-fail/borrowck/borrowck-let-suggestion-suffixes.rs", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-let-suggestion-suffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-let-suggestion-suffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-let-suggestion-suffixes.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -13,47 +13,48 @@ fn f() {\n     let mut v1 = Vec::new(); // statement 1\n \n     let mut v2 = Vec::new(); // statement 2\n-    //~^ NOTE reference must be valid for the block suffix following statement 2\n \n     let young = ['y'];       // statement 3\n-    //~^ NOTE ...but borrowed value is only valid for the block suffix following statement 3\n \n     v2.push(&young[0]);      // statement 4\n     //~^ ERROR `young[..]` does not live long enough\n+    //~| NOTE does not live long enough\n+    //~| NOTE values in a scope are dropped in the opposite order they are created\n \n     let mut v3 = Vec::new(); // statement 5\n-    //~^ NOTE reference must be valid for the block suffix following statement 5\n \n     v3.push(&'x');           // statement 6\n     //~^ ERROR borrowed value does not live long enough\n-    //~| does not live long enough\n-    //~| NOTE ...but borrowed value is only valid for the statement\n+    //~| NOTE does not live long enough\n+    //~| NOTE borrowed value only valid until here\n     //~| HELP consider using a `let` binding to increase its lifetime\n \n     {\n \n         let mut v4 = Vec::new(); // (sub) statement 0\n-        //~^ NOTE reference must be valid for the block suffix following statement 0\n \n         v4.push(&'y');\n         //~^ ERROR borrowed value does not live long enough\n-        //~| does not live long enough\n-        //~| NOTE ...but borrowed value is only valid for the statement\n+        //~| NOTE does not live long enough\n+        //~| NOTE borrowed value only valid until here\n         //~| HELP consider using a `let` binding to increase its lifetime\n \n     }                       // (statement 7)\n+    //~^ NOTE borrowed value must be valid until here\n \n     let mut v5 = Vec::new(); // statement 8\n-    //~^ NOTE reference must be valid for the block suffix following statement 8\n \n     v5.push(&'z');\n     //~^ ERROR borrowed value does not live long enough\n-    //~| does not live long enough\n-    //~| NOTE ...but borrowed value is only valid for the statement\n+    //~| NOTE does not live long enough\n+    //~| NOTE borrowed value only valid until here\n     //~| HELP consider using a `let` binding to increase its lifetime\n \n     v1.push(&old[0]);\n }\n+//~^ NOTE borrowed value dropped before borrower\n+//~| NOTE borrowed value must be valid until here\n+//~| NOTE borrowed value must be valid until here\n \n fn main() {\n     f();"}, {"sha": "ef8f44c1df78978c1d0974c6704e33f714ca7c8a", "filename": "src/test/compile-fail/borrowck/borrowck-let-suggestion.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-let-suggestion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-let-suggestion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Fborrowck-let-suggestion.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -11,11 +11,11 @@\n fn f() {\n     let x = [1].iter();\n     //~^ ERROR borrowed value does not live long enough\n-    //~|does not live long enough\n-    //~| NOTE reference must be valid for the block suffix following statement\n+    //~| NOTE does not live long enough\n+    //~| NOTE borrowed value only valid until here\n     //~| HELP consider using a `let` binding to increase its lifetime\n-    //~| NOTE ...but borrowed value is only valid for the statement at 12:4\n }\n+//~^ borrowed value must be valid until here\n \n fn main() {\n     f();"}, {"sha": "8dfcb08cff339b4153037ec430e0aa462a871b78", "filename": "src/test/compile-fail/impl-trait/loan-extend.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Floan-extend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Floan-extend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fimpl-trait%2Floan-extend.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -14,10 +14,10 @@\n fn borrow<'a, T>(_: &'a mut T) -> impl Copy { () }\n \n fn main() {\n-    //~^ NOTE reference must be valid for the block\n     let long;\n     let mut short = 0;\n-    //~^ NOTE but borrowed value is only valid for the block suffix following statement 1\n     long = borrow(&mut short);\n     //~^ ERROR `short` does not live long enough\n-}\n+    //~| NOTE does not live long enough\n+    //~| NOTE values in a scope are dropped in the opposite order they are created\n+} //~ borrowed value dropped before borrower"}, {"sha": "196c233a0b5c3b0ed178d91be611d2894748b2da", "filename": "src/test/compile-fail/region-borrow-params-issue-29793-small.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fregion-borrow-params-issue-29793-small.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -16,15 +16,19 @@\n \n fn escaping_borrow_of_closure_params_1() {\n     let g = |x: usize, y:usize| {\n-        //~^ NOTE reference must be valid for the scope of call-site for function\n-        //~| NOTE ...but borrowed value is only valid for the scope of function body\n-        //~| NOTE reference must be valid for the scope of call-site for function\n-        //~| NOTE ...but borrowed value is only valid for the scope of function body\n         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n         //~^ ERROR `x` does not live long enough\n         //~| ERROR `y` does not live long enough\n+        //~| NOTE capture occurs here\n+        //~| NOTE capture occurs here\n+        //~| NOTE does not live long enough\n+        //~| NOTE does not live long enough\n+        //~| NOTE values in a scope are dropped in the opposite order they are created\n+        //~| NOTE values in a scope are dropped in the opposite order they are created\n         return f;\n     };\n+    //~^ NOTE borrowed value dropped before borrower \n+    //~| NOTE borrowed value dropped before borrower \n \n     // We delberately do not call `g`; this small version of the test,\n     // after adding such a call, was (properly) rejected even when the\n@@ -35,15 +39,19 @@ fn escaping_borrow_of_closure_params_1() {\n \n fn escaping_borrow_of_closure_params_2() {\n     let g = |x: usize, y:usize| {\n-        //~^ NOTE reference must be valid for the scope of call-site for function\n-        //~| NOTE ...but borrowed value is only valid for the scope of function body\n-        //~| NOTE reference must be valid for the scope of call-site for function\n-        //~| NOTE ...but borrowed value is only valid for the scope of function body\n         let f = |t: bool| if t { x } else { y }; // (separate errors for `x` vs `y`)\n         //~^ ERROR `x` does not live long enough\n         //~| ERROR `y` does not live long enough\n+        //~| NOTE capture occurs here\n+        //~| NOTE capture occurs here\n+        //~| NOTE does not live long enough\n+        //~| NOTE does not live long enough\n+        //~| NOTE values in a scope are dropped in the opposite order they are created\n+        //~| NOTE values in a scope are dropped in the opposite order they are created\n         f\n     };\n+    //~^ NOTE borrowed value dropped before borrower \n+    //~| NOTE borrowed value dropped before borrower \n \n     // (we don't call `g`; see above)\n }"}, {"sha": "1b7718d2283a7bfd6a617c112f8a5d19bdd209a6", "filename": "src/test/compile-fail/send-is-not-static-ensures-scoping.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-ensures-scoping.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -26,8 +26,8 @@ fn main() {\n         let y = &x; //~ ERROR `x` does not live long enough\n \n         scoped(|| {\n-            //~^ ERROR `y` does not live long enough\n             let _z = y;\n+            //~^ ERROR `y` does not live long enough\n         })\n     };\n "}, {"sha": "ce60521034ee7cc89b8dc89bbda548497297de34", "filename": "src/test/compile-fail/unboxed-closures-failed-recursive-fn-1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funboxed-closures-failed-recursive-fn-1.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -22,8 +22,8 @@ fn a() {\n     let mut factorial: Option<Box<Fn(u32) -> u32>> = None;\n \n     let f = |x: u32| -> u32 {\n-        //~^ ERROR `factorial` does not live long enough\n         let g = factorial.as_ref().unwrap();\n+        //~^ ERROR `factorial` does not live long enough\n         if x == 0 {1} else {x * g(x-1)}\n     };\n "}, {"sha": "7bea8642cce1409193e89322cccebcf7df7bc6f4", "filename": "src/test/ui/span/issue-11925.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fui%2Fspan%2Fissue-11925.rs", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fui%2Fspan%2Fissue-11925.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-11925.rs?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -15,7 +15,7 @@ fn to_fn_once<A,F:FnOnce<A>>(f: F) -> F { f }\n fn main() {\n     let r = {\n         let x: Box<_> = box 42;\n-        let f = to_fn_once(move|| &x); //~ ERROR: `x` does not live long enough\n+        let f = to_fn_once(move|| &x);\n         f()\n     };\n ", "previous_filename": "src/test/compile-fail/issue-11925.rs"}, {"sha": "d379cfc3d68a7bb870aa61e19d0bf314d0d2bbab", "filename": "src/test/ui/span/issue-11925.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fui%2Fspan%2Fissue-11925.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/70ce90c320aa4d6ae7646497a0cd17f775b94e43/src%2Ftest%2Fui%2Fspan%2Fissue-11925.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fissue-11925.stderr?ref=70ce90c320aa4d6ae7646497a0cd17f775b94e43", "patch": "@@ -0,0 +1,14 @@\n+error: `x` does not live long enough\n+  --> $DIR/issue-11925.rs:18:36\n+   |\n+18 |         let f = to_fn_once(move|| &x);\n+   |                                    ^\n+   |                                    |\n+   |                                    does not live long enough\n+   |                                    borrowed value only valid until here\n+...\n+23 | }\n+   | - borrowed value must be valid until here\n+\n+error: aborting due to previous error\n+"}]}