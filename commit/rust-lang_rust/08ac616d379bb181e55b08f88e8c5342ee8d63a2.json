{"sha": "08ac616d379bb181e55b08f88e8c5342ee8d63a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4YWM2MTZkMzc5YmIxODFlNTViMDhmODhlOGM1MzQyZWU4ZDYzYTI=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-01-11T14:39:32Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-01-11T14:40:23Z"}, "message": "Use the right type for self in methods and remove obsoleted items.\nFixes #7411, #10615.", "tree": {"sha": "7ed762d7302c247b0d5de4b727a4b705b18779c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7ed762d7302c247b0d5de4b727a4b705b18779c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08ac616d379bb181e55b08f88e8c5342ee8d63a2", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08ac616d379bb181e55b08f88e8c5342ee8d63a2", "html_url": "https://github.com/rust-lang/rust/commit/08ac616d379bb181e55b08f88e8c5342ee8d63a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08ac616d379bb181e55b08f88e8c5342ee8d63a2/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a305f9e832901018e5f1aa1901eff04652fdbbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a305f9e832901018e5f1aa1901eff04652fdbbd", "html_url": "https://github.com/rust-lang/rust/commit/7a305f9e832901018e5f1aa1901eff04652fdbbd"}], "stats": {"total": 994, "additions": 472, "deletions": 522}, "files": [{"sha": "261cb15a7aac5d51e61c467c71b6cd1342cbbc58", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -410,7 +410,6 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let inner = parse_ty(st, |x,y| conv(x,y));\n         inner\n       }\n-      'B' => ty::mk_opaque_box(st.tcx),\n       'a' => {\n           assert_eq!(next(st), '[');\n           let did = parse_def(st, NominalType, |x,y| conv(x,y));"}, {"sha": "8a8fdd7265216c46e9bffe4e46dc8490e08ec5a4", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -331,7 +331,6 @@ fn enc_sty(w: &mut MemWriter, cx: @ctxt, st: &ty::sty) {\n             mywrite!(w, \"C&\");\n             enc_sigil(w, p);\n         }\n-        ty::ty_opaque_box => mywrite!(w, \"B\"),\n         ty::ty_struct(def, ref substs) => {\n             mywrite!(w, \"a[{}|\", (cx.ds)(def));\n             enc_substs(w, cx, substs);"}, {"sha": "675d31ebea8d5a3504ab0cba6c912698978efa6f", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -578,9 +578,6 @@ fn encode_method_map_entry(ecx: &e::EncodeContext,\n         ebml_w.emit_struct_field(\"origin\", 1u, |ebml_w| {\n             mme.origin.encode(ebml_w);\n         });\n-        ebml_w.emit_struct_field(\"self_mode\", 3, |ebml_w| {\n-            mme.self_mode.encode(ebml_w);\n-        });\n     })\n }\n \n@@ -602,11 +599,7 @@ impl<'a> read_method_map_entry_helper for reader::Decoder<'a> {\n                     let method_origin: method_origin =\n                         Decodable::decode(this);\n                     method_origin.tr(xcx)\n-                }),\n-                self_mode: this.read_struct_field(\"self_mode\", 3, |this| {\n-                    let self_mode: ty::SelfMode = Decodable::decode(this);\n-                    self_mode\n-                }),\n+                })\n             }\n         })\n     }"}, {"sha": "29c82ef83f8de953254fb3bb887ec11327b82c3c", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 51, "deletions": 42, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -1392,37 +1392,41 @@ fn insert_lllocals<'a>(\n         let llval = match binding_info.trmode {\n             // By value bindings: use the stack slot that we\n             // copied/moved the value into\n-            TrByValue(lldest) => {\n-                if add_cleans {\n-                    add_clean(bcx, lldest, binding_info.ty);\n-                }\n+            TrByValue(lldest) => lldest,\n+            // By ref binding: use the ptr into the matched value\n+            TrByRef => binding_info.llmatch\n+        };\n \n-                lldest\n-            }\n+        let datum = Datum {\n+            val: llval,\n+            ty: binding_info.ty,\n+            mode: ByRef(ZeroMem)\n+        };\n \n-            // By ref binding: use the ptr into the matched value\n-            TrByRef => {\n-                binding_info.llmatch\n+        if add_cleans {\n+            match binding_info.trmode {\n+                TrByValue(_) => datum.add_clean(bcx),\n+                _ => {}\n             }\n-        };\n+        }\n \n         {\n             debug!(\"binding {:?} to {}\",\n                    binding_info.id,\n                    bcx.val_to_str(llval));\n             let mut llmap = bcx.fcx.lllocals.borrow_mut();\n-            llmap.get().insert(binding_info.id, llval);\n+            llmap.get().insert(binding_info.id, datum);\n         }\n \n         if bcx.sess().opts.extra_debuginfo {\n             debuginfo::create_match_binding_metadata(bcx,\n                                                      ident,\n                                                      binding_info.id,\n-                                                     binding_info.ty,\n-                                                     binding_info.span);\n+                                                     binding_info.span,\n+                                                     datum);\n         }\n     }\n-    return bcx;\n+    bcx\n }\n \n fn compile_guard<'r,\n@@ -2032,8 +2036,7 @@ pub fn store_local<'a>(\n                 Some(path) => {\n                     return mk_binding_alloca(\n                         bcx, pat.id, path, BindLocal,\n-                        |bcx, _, llval| expr::trans_into(bcx, init_expr,\n-                                                         expr::SaveIn(llval)));\n+                        |bcx, datum| expr::trans_into(bcx, init_expr, expr::SaveIn(datum.val)));\n                 }\n \n                 None => {}\n@@ -2067,13 +2070,13 @@ pub fn store_local<'a>(\n         pat_bindings(tcx.def_map, pat, |_, p_id, _, path| {\n             bcx = mk_binding_alloca(\n                 bcx, p_id, path, BindLocal,\n-                |bcx, var_ty, llval| { zero_mem(bcx, llval, var_ty); bcx });\n+                |bcx, datum| { datum.cancel_clean(bcx); bcx });\n         });\n         bcx\n     }\n }\n \n-pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, llval: ValueRef)\n+pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, arg: Datum)\n                  -> &'a Block<'a> {\n     /*!\n      * Generates code for argument patterns like `fn foo(<pat>: T)`.\n@@ -2093,13 +2096,12 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, llval: ValueRef)\n     // Note that we cannot do it before for fear of a fn like\n     //    fn getaddr(~ref x: ~uint) -> *uint {....}\n     // (From test `run-pass/func-arg-ref-pattern.rs`)\n-    let arg_ty = node_id_type(bcx, pat.id);\n-    add_clean(bcx, llval, arg_ty);\n+    arg.add_clean(bcx);\n \n     // Debug information (the llvm.dbg.declare intrinsic to be precise) always expects to get an\n     // alloca, which only is the case on the general path, so lets disable the optimized path when\n     // debug info is enabled.\n-    let arg_is_alloca = unsafe { llvm::LLVMIsAAllocaInst(llval) != ptr::null() };\n+    let arg_is_alloca = unsafe { llvm::LLVMIsAAllocaInst(arg.val) != ptr::null() };\n \n     let fast_path = (arg_is_alloca || !bcx.ccx().sess.opts.extra_debuginfo)\n                     && simple_identifier(pat).is_some();\n@@ -2109,37 +2111,42 @@ pub fn store_arg<'a>(mut bcx: &'a Block<'a>, pat: @ast::Pat, llval: ValueRef)\n         // `llval` wholesale as the pointer for `x`, avoiding the\n         // general logic which may copy out of `llval`.\n         let mut llargs = bcx.fcx.llargs.borrow_mut();\n-        llargs.get().insert(pat.id, llval);\n+        llargs.get().insert(pat.id, arg);\n     } else {\n         // General path. Copy out the values that are used in the\n         // pattern.\n-        bcx = bind_irrefutable_pat(bcx, pat, llval, BindArgument);\n+        let llptr = arg.to_ref_llval(bcx);\n+        bcx = bind_irrefutable_pat(bcx, pat, llptr, BindArgument);\n     }\n \n     return bcx;\n }\n \n fn mk_binding_alloca<'a>(\n-                     mut bcx: &'a Block<'a>,\n+                     bcx: &'a Block<'a>,\n                      p_id: ast::NodeId,\n                      path: &ast::Path,\n                      binding_mode: IrrefutablePatternBindingMode,\n-                     populate: |&'a Block<'a>,\n-                                ty::t,\n-                                ValueRef|\n-                                -> &'a Block<'a>)\n+                     populate: |&'a Block<'a>, Datum| -> &'a Block<'a>)\n                      -> &'a Block<'a> {\n     let var_ty = node_id_type(bcx, p_id);\n     let ident = ast_util::path_to_ident(path);\n     let llval = alloc_ty(bcx, var_ty, bcx.ident(ident));\n-    bcx = populate(bcx, var_ty, llval);\n-    let mut llmap = match binding_mode {\n-        BindLocal => bcx.fcx.lllocals.borrow_mut(),\n-        BindArgument => bcx.fcx.llargs.borrow_mut(),\n+    let datum = Datum {\n+        val: llval,\n+        ty: var_ty,\n+        mode: ByRef(ZeroMem)\n     };\n-    llmap.get().insert(p_id, llval);\n-    add_clean(bcx, llval, var_ty);\n-    return bcx;\n+    {\n+        let mut llmap = match binding_mode {\n+            BindLocal => bcx.fcx.lllocals.borrow_mut(),\n+            BindArgument => bcx.fcx.llargs.borrow_mut()\n+        };\n+        llmap.get().insert(p_id, datum);\n+    }\n+    let bcx = populate(bcx, datum);\n+    datum.add_clean(bcx);\n+    bcx\n }\n \n fn bind_irrefutable_pat<'a>(\n@@ -2179,7 +2186,7 @@ fn bind_irrefutable_pat<'a>(\n \n     let _indenter = indenter();\n \n-    let _icx = push_ctxt(\"alt::bind_irrefutable_pat\");\n+    let _icx = push_ctxt(\"match::bind_irrefutable_pat\");\n     let mut bcx = bcx;\n     let tcx = bcx.tcx();\n     let ccx = bcx.ccx();\n@@ -2191,21 +2198,23 @@ fn bind_irrefutable_pat<'a>(\n                 // map.\n                 bcx = mk_binding_alloca(\n                     bcx, pat.id, path, binding_mode,\n-                    |bcx, variable_ty, llvariable_val| {\n+                    |bcx, var_datum| {\n                         match pat_binding_mode {\n                             ast::BindByValue(_) => {\n                                 // By value binding: move the value that `val`\n                                 // points at into the binding's stack slot.\n-                                let datum = Datum {val: val,\n-                                                   ty: variable_ty,\n-                                                   mode: ByRef(ZeroMem)};\n-                                datum.store_to(bcx, INIT, llvariable_val)\n+                                let datum = Datum {\n+                                    val: val,\n+                                    ty: var_datum.ty,\n+                                    mode: ByRef(ZeroMem)\n+                                };\n+                                datum.store_to(bcx, INIT, var_datum.val)\n                             }\n \n                             ast::BindByRef(_) => {\n                                 // By ref binding: the value of the variable\n                                 // is the pointer `val` itself.\n-                                Store(bcx, val, llvariable_val);\n+                                Store(bcx, val, var_datum.val);\n                                 bcx\n                             }\n                         }"}, {"sha": "11f217f3cb4b1ae3885c73fc420273d3dbdaf011", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -20,7 +20,6 @@ use middle::trans::callee;\n use middle::trans::common::*;\n use middle::trans::expr::*;\n use middle::trans::type_of::*;\n-use middle::ty;\n \n use middle::trans::type_::Type;\n \n@@ -56,7 +55,6 @@ pub fn trans_inline_asm<'a>(bcx: &'a Block<'a>, ia: &ast::InlineAsm)\n         unpack_result!(bcx, {\n             callee::trans_arg_expr(bcx,\n                                    expr_ty(bcx, input),\n-                                   ty::ByCopy,\n                                    input,\n                                    &mut cleanups,\n                                    callee::DontAutorefArg)"}, {"sha": "6fa3764fb379bbe1431212d91ef15c84adaa3cb9", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 153, "deletions": 87, "changes": 240, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -53,20 +53,19 @@ use middle::trans::expr;\n use middle::trans::foreign;\n use middle::trans::glue;\n use middle::trans::inline;\n-use middle::trans::llrepr::LlvmRepr;\n use middle::trans::machine;\n use middle::trans::machine::{llalign_of_min, llsize_of};\n use middle::trans::meth;\n use middle::trans::monomorphize;\n use middle::trans::tvec;\n+use middle::trans::type_::Type;\n use middle::trans::type_of;\n use middle::trans::type_of::*;\n use middle::trans::value::Value;\n use middle::ty;\n use util::common::indenter;\n use util::ppaux::{Repr, ty_to_str};\n use util::sha2::Sha256;\n-use middle::trans::type_::Type;\n \n use extra::arena::TypedArena;\n use extra::time;\n@@ -218,7 +217,7 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n         }\n     }\n \n-    let f = decl_rust_fn(ccx, inputs, output, name);\n+    let f = decl_rust_fn(ccx, None, inputs, output, name);\n     csearch::get_item_attrs(ccx.tcx.cstore, did, |meta_items| {\n         set_llvm_fn_attrs(meta_items.iter().map(|&x| attr::mk_attr(x)).to_owned_vec(), f)\n     });\n@@ -228,8 +227,12 @@ fn get_extern_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n     f\n }\n \n-fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str) -> ValueRef {\n-    let llfty = type_of_rust_fn(ccx, inputs, output);\n+fn decl_rust_fn(ccx: &CrateContext,\n+                self_ty: Option<ty::t>,\n+                inputs: &[ty::t],\n+                output: ty::t,\n+                name: &str) -> ValueRef {\n+    let llfty = type_of_rust_fn(ccx, self_ty, inputs, output);\n     let llfn = decl_cdecl_fn(ccx.llmod, name, llfty);\n \n     match ty::get(output).sty {\n@@ -263,7 +266,7 @@ fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str)\n                     llvm::LLVMAddAttribute(llarg, lib::llvm::NoAliasAttribute as c_uint);\n                 }\n             }\n-            _ => ()\n+            _ => {}\n         }\n     }\n \n@@ -281,9 +284,10 @@ fn decl_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t, name: &str)\n     llfn\n }\n \n-pub fn decl_internal_rust_fn(ccx: &CrateContext, inputs: &[ty::t], output: ty::t,\n-                             name: &str) -> ValueRef {\n-    let llfn = decl_rust_fn(ccx, inputs, output, name);\n+pub fn decl_internal_rust_fn(ccx: &CrateContext,\n+                             self_ty: Option<ty::t>, inputs: &[ty::t],\n+                             output: ty::t, name: &str) -> ValueRef {\n+    let llfn = decl_rust_fn(ccx, self_ty, inputs, output, name);\n     lib::llvm::SetLinkage(llfn, lib::llvm::InternalLinkage);\n     llfn\n }\n@@ -913,7 +917,7 @@ pub fn trans_external_path(ccx: &CrateContext, did: ast::DefId, t: ty::t) -> Val\n                 Some(..) | None => {\n                     let c = foreign::llvm_calling_convention(ccx, fn_ty.abis);\n                     let cconv = c.unwrap_or(lib::llvm::CCallConv);\n-                    let llty = type_of_fn_from_ty(ccx, t);\n+                    let llty = type_of_fn_from_ty(ccx, None, t);\n                     let mut externs = ccx.externs.borrow_mut();\n                     get_extern_fn(externs.get(), ccx.llmod, name, cconv, llty)\n                 }\n@@ -1013,7 +1017,7 @@ pub fn need_invoke(bcx: &Block) -> bool {\n                 let cleanups = inf.cleanups.borrow();\n                 for cleanup in cleanups.get().iter() {\n                     match *cleanup {\n-                        clean(_, cleanup_type) | clean_temp(_, _, cleanup_type) => {\n+                        Clean(_, cleanup_type) | CleanTemp(_, _, cleanup_type) => {\n                             if cleanup_type == normal_exit_and_unwind {\n                                 return true;\n                             }\n@@ -1365,7 +1369,7 @@ pub fn trans_block_cleanups_<'a>(\n     let mut bcx = bcx;\n     for cu in cleanups.rev_iter() {\n         match *cu {\n-            clean(cfn, cleanup_type) | clean_temp(_, cfn, cleanup_type) => {\n+            Clean(cfn, cleanup_type) | CleanTemp(_, cfn, cleanup_type) => {\n                 // Some types don't need to be cleaned up during\n                 // landing pads because they can be freed en mass later\n                 if cleanup_type == normal_exit_and_unwind || !is_lpad {\n@@ -1639,7 +1643,7 @@ pub fn zero_mem(cx: &Block, llptr: ValueRef, t: ty::t) {\n // allocation for large data structures, and the generated code will be\n // awful. (A telltale sign of this is large quantities of\n // `mov [byte ptr foo],0` in the generated code.)\n-pub fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n+fn memzero(b: &Builder, llptr: ValueRef, ty: Type) {\n     let _icx = push_ctxt(\"memzero\");\n     let ccx = b.ccx;\n \n@@ -1865,88 +1869,145 @@ pub fn new_fn_ctxt(ccx: @CrateContext,\n // spaces that have been created for them (by code in the llallocas field of\n // the function's fn_ctxt).  create_llargs_for_fn_args populates the llargs\n // field of the fn_ctxt with\n-pub fn create_llargs_for_fn_args(cx: &FunctionContext,\n-                                 self_arg: self_arg,\n-                                 args: &[ast::Arg])\n-                                 -> ~[ValueRef] {\n+fn create_llargs_for_fn_args(cx: &FunctionContext,\n+                             self_arg: Option<ty::t>,\n+                             arg_tys: &[ty::t])\n+                             -> ~[datum::Datum] {\n     let _icx = push_ctxt(\"create_llargs_for_fn_args\");\n \n     match self_arg {\n-      impl_self(tt, self_mode) => {\n-        cx.llself.set(Some(ValSelfData {\n-            v: cx.llenv.get(),\n-            t: tt,\n-            is_copy: self_mode == ty::ByCopy\n-        }));\n-      }\n-      no_self => ()\n+        Some(t) => {\n+            cx.llself.set(Some(datum::Datum {\n+                val: cx.llenv.get(),\n+                ty: t,\n+                mode: if arg_is_indirect(cx.ccx, t) {\n+                    datum::ByRef(datum::ZeroMem)\n+                } else {\n+                    datum::ByValue\n+                }\n+            }));\n+        }\n+        None => {}\n     }\n \n-    // Return an array containing the ValueRefs that we get from\n-    // llvm::LLVMGetParam for each argument.\n-    vec::from_fn(args.len(), |i| {\n-        unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) }\n-    })\n+    // Return an array wrapping the ValueRefs that we get from\n+    // llvm::LLVMGetParam for each argument into datums.\n+    arg_tys.iter().enumerate().map(|(i, &arg_ty)| {\n+        let llarg = unsafe { llvm::LLVMGetParam(cx.llfn, cx.arg_pos(i) as c_uint) };\n+        datum::Datum {\n+            val: llarg,\n+            ty: arg_ty,\n+            mode: if arg_is_indirect(cx.ccx, arg_ty) {\n+                datum::ByRef(datum::ZeroMem)\n+            } else {\n+                datum::ByValue\n+            }\n+        }\n+    }).collect()\n }\n \n-pub fn copy_args_to_allocas<'a>(\n-                            fcx: &FunctionContext<'a>,\n+fn copy_args_to_allocas<'a>(fcx: &FunctionContext<'a>,\n                             bcx: &'a Block<'a>,\n                             args: &[ast::Arg],\n-                            raw_llargs: &[ValueRef],\n-                            arg_tys: &[ty::t])\n+                            method: Option<&ast::Method>,\n+                            raw_llargs: &[datum::Datum])\n                             -> &'a Block<'a> {\n-    debug!(\"copy_args_to_allocas: raw_llargs={} arg_tys={}\",\n-           raw_llargs.llrepr(fcx.ccx),\n-           arg_tys.repr(fcx.ccx.tcx));\n+    debug!(\"copy_args_to_allocas: args=[{}]\",\n+           raw_llargs.map(|d| d.to_str(fcx.ccx)).connect(\", \"));\n \n     let _icx = push_ctxt(\"copy_args_to_allocas\");\n     let mut bcx = bcx;\n \n     match fcx.llself.get() {\n         Some(slf) => {\n-            let self_val = if slf.is_copy\n-                    && datum::appropriate_mode(bcx.ccx(), slf.t).is_by_value() {\n-                let tmp = BitCast(bcx, slf.v, type_of(bcx.ccx(), slf.t));\n-                let alloc = alloc_ty(bcx, slf.t, \"__self\");\n-                Store(bcx, tmp, alloc);\n-                alloc\n+            let needs_indirection = if slf.mode.is_by_value() {\n+                // FIXME(eddyb) #11445 Always needs indirection because of cleanup.\n+                if true {\n+                    true\n+                } else {\n+                    match method {\n+                        Some(method) => {\n+                            match method.explicit_self.node {\n+                                ast::SelfValue(ast::MutMutable) => true,\n+                                _ => false\n+                            }\n+                        }\n+                        None => true\n+                    }\n+                }\n+            } else {\n+                false\n+            };\n+            let slf = if needs_indirection {\n+                // HACK(eddyb) this is just slf.to_ref_datum(bcx) with a named alloca.\n+                let alloc = alloc_ty(bcx, slf.ty, \"__self\");\n+                Store(bcx, slf.val, alloc);\n+                datum::Datum {\n+                    val: alloc,\n+                    ty: slf.ty,\n+                    mode: datum::ByRef(datum::ZeroMem)\n+                }\n             } else {\n-                PointerCast(bcx, slf.v, type_of(bcx.ccx(), slf.t).ptr_to())\n+                slf\n             };\n \n-            fcx.llself.set(Some(ValSelfData {v: self_val, ..slf}));\n-            add_clean(bcx, self_val, slf.t);\n+            fcx.llself.set(Some(slf));\n+            slf.add_clean(bcx);\n \n             if fcx.ccx.sess.opts.extra_debuginfo {\n-                debuginfo::create_self_argument_metadata(bcx, slf.t, self_val);\n+                debuginfo::create_self_argument_metadata(bcx, slf.ty, slf.val);\n             }\n         }\n         _ => {}\n     }\n \n-    for (arg_n, &arg_ty) in arg_tys.iter().enumerate() {\n-        let raw_llarg = raw_llargs[arg_n];\n-\n+    for (i, &arg) in raw_llargs.iter().enumerate() {\n+        let needs_indirection = if arg.mode.is_by_value() {\n+            if fcx.ccx.sess.opts.extra_debuginfo {\n+                true\n+            } else {\n+                // FIXME(eddyb) #11445 Always needs indirection because of cleanup.\n+                if true {\n+                    true\n+                } else {\n+                    match args[i].pat.node {\n+                        ast::PatIdent(ast::BindByValue(ast::MutMutable), _, _) => true,\n+                        _ => false\n+                    }\n+                }\n+            }\n+        } else {\n+            false\n+        };\n         // For certain mode/type combinations, the raw llarg values are passed\n         // by value.  However, within the fn body itself, we want to always\n         // have all locals and arguments be by-ref so that we can cancel the\n         // cleanup and for better interaction with LLVM's debug info.  So, if\n         // the argument would be passed by value, we store it into an alloca.\n         // This alloca should be optimized away by LLVM's mem-to-reg pass in\n         // the event it's not truly needed.\n-        // only by value if immediate:\n-        let llarg = if datum::appropriate_mode(bcx.ccx(), arg_ty).is_by_value() {\n-            let alloc = alloc_ty(bcx, arg_ty, \"__arg\");\n-            Store(bcx, raw_llarg, alloc);\n-            alloc\n+        let arg = if needs_indirection {\n+            // HACK(eddyb) this is just arg.to_ref_datum(bcx) with a named alloca.\n+            let alloc = match args[i].pat.node {\n+                ast::PatIdent(_, ref path, _) => {\n+                    let name = ast_util::path_to_ident(path).name;\n+                    alloc_ty(bcx, arg.ty, token::interner_get(name))\n+                }\n+                _ => alloc_ty(bcx, arg.ty, \"__arg\")\n+            };\n+            Store(bcx, arg.val, alloc);\n+            datum::Datum {\n+                val: alloc,\n+                ty: arg.ty,\n+                mode: datum::ByRef(datum::ZeroMem)\n+            }\n         } else {\n-            raw_llarg\n+            arg\n         };\n-        bcx = _match::store_arg(bcx, args[arg_n].pat, llarg);\n+        bcx = _match::store_arg(bcx, args[i].pat, arg);\n \n         if fcx.ccx.sess.opts.extra_debuginfo {\n-            debuginfo::create_argument_metadata(bcx, &args[arg_n]);\n+            debuginfo::create_argument_metadata(bcx, &args[i]);\n         }\n     }\n \n@@ -2001,8 +2062,6 @@ pub fn build_return_block(fcx: &FunctionContext, ret_cx: &Block) {\n     Ret(ret_cx, retval);\n }\n \n-pub enum self_arg { impl_self(ty::t, ty::SelfMode), no_self, }\n-\n // trans_closure: Builds an LLVM function out of a source function.\n // If the function closes over its environment a closure will be\n // returned.\n@@ -2011,9 +2070,10 @@ pub fn trans_closure(ccx: @CrateContext,\n                      decl: &ast::FnDecl,\n                      body: &ast::Block,\n                      llfndecl: ValueRef,\n-                     self_arg: self_arg,\n+                     self_arg: Option<ty::t>,\n                      param_substs: Option<@param_substs>,\n                      id: ast::NodeId,\n+                     method: Option<&ast::Method>,\n                      _attributes: &[ast::Attribute],\n                      output_type: ty::t,\n                      maybe_load_env: |&FunctionContext|) {\n@@ -2042,9 +2102,9 @@ pub fn trans_closure(ccx: @CrateContext,\n \n     // Set up arguments to the function.\n     let arg_tys = ty::ty_fn_args(node_id_type(bcx, id));\n-    let raw_llargs = create_llargs_for_fn_args(&fcx, self_arg, decl.inputs);\n+    let raw_llargs = create_llargs_for_fn_args(&fcx, self_arg, arg_tys);\n \n-    bcx = copy_args_to_allocas(&fcx, bcx, decl.inputs, raw_llargs, arg_tys);\n+    bcx = copy_args_to_allocas(&fcx, bcx, decl.inputs, method, raw_llargs);\n \n     maybe_load_env(&fcx);\n \n@@ -2089,9 +2149,10 @@ pub fn trans_fn(ccx: @CrateContext,\n                 decl: &ast::FnDecl,\n                 body: &ast::Block,\n                 llfndecl: ValueRef,\n-                self_arg: self_arg,\n+                self_arg: Option<ty::t>,\n                 param_substs: Option<@param_substs>,\n                 id: ast::NodeId,\n+                method: Option<&ast::Method>,\n                 attrs: &[ast::Attribute]) {\n \n     let the_path_str = path_str(ccx.sess, path);\n@@ -2109,6 +2170,7 @@ pub fn trans_fn(ccx: @CrateContext,\n                   self_arg,\n                   param_substs,\n                   id,\n+                  method,\n                   attrs,\n                   output_type,\n                   |_fcx| { });\n@@ -2191,14 +2253,13 @@ impl IdAndTy for ast::StructField {\n     fn ty(&self) -> ast::P<ast::Ty> { self.node.ty }\n }\n \n-pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n+fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n     ccx: @CrateContext,\n     ctor_id: ast::NodeId,\n     args: &[A],\n     disr: ty::Disr,\n     param_substs: Option<@param_substs>,\n-    llfndecl: ValueRef)\n-{\n+    llfndecl: ValueRef) {\n     // Translate variant arguments to function arguments.\n     let fn_args = args.map(|varg| {\n         ast::Arg {\n@@ -2247,12 +2308,12 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n \n     let arg_tys = ty::ty_fn_args(ctor_ty);\n \n-    let raw_llargs = create_llargs_for_fn_args(&fcx, no_self, fn_args);\n+    let raw_llargs = create_llargs_for_fn_args(&fcx, None, arg_tys);\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n \n     insert_synthetic_type_entries(bcx, fn_args, arg_tys);\n-    let bcx = copy_args_to_allocas(&fcx, bcx, fn_args, raw_llargs, arg_tys);\n+    let bcx = copy_args_to_allocas(&fcx, bcx, fn_args, None, raw_llargs);\n \n     let repr = adt::represent_type(ccx, result_ty);\n     adt::trans_start_init(bcx, repr, fcx.llretptr.get().unwrap(), disr);\n@@ -2266,8 +2327,7 @@ pub fn trans_enum_variant_or_tuple_like_struct<A:IdAndTy>(\n             let llargs = fcx.llargs.borrow();\n             llargs.get().get_copy(&fn_arg.pat.id)\n         };\n-        let arg_ty = arg_tys[i];\n-        memcpy_ty(bcx, lldestptr, llarg, arg_ty);\n+        llarg.move_to(bcx, datum::INIT, lldestptr);\n     }\n     finish_fn(&fcx, bcx);\n }\n@@ -2334,9 +2394,10 @@ pub fn trans_item(ccx: @CrateContext, item: &ast::Item) {\n                      decl,\n                      body,\n                      llfndecl,\n-                     no_self,\n+                     None,\n                      None,\n                      item.id,\n+                     None,\n                      item.attrs);\n         } else {\n             // Be sure to travel more than just one layer deep to catch nested\n@@ -2448,12 +2509,13 @@ fn finish_register_fn(ccx: @CrateContext, sp: Span, sym: ~str, node_id: ast::Nod\n     }\n }\n \n-pub fn register_fn(ccx: @CrateContext,\n-                   sp: Span,\n-                   sym: ~str,\n-                   node_id: ast::NodeId,\n-                   node_type: ty::t)\n-                   -> ValueRef {\n+fn register_fn(ccx: @CrateContext,\n+               sp: Span,\n+               sym: ~str,\n+               node_id: ast::NodeId,\n+               node_type: ty::t,\n+               self_ty: Option<ty::t>)\n+               -> ValueRef {\n     let f = match ty::get(node_type).sty {\n         ty::ty_bare_fn(ref f) => {\n             assert!(f.abis.is_rust() || f.abis.is_intrinsic());\n@@ -2462,7 +2524,7 @@ pub fn register_fn(ccx: @CrateContext,\n         _ => fail!(\"expected bare rust fn or an intrinsic\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, f.sig.inputs, f.sig.output, sym);\n+    let llfn = decl_rust_fn(ccx, self_ty, f.sig.inputs, f.sig.output, sym);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2722,7 +2784,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                         ast::ItemFn(_, purity, _, _, _) => {\n                             let llfn = if purity != ast::ExternFn {\n-                                register_fn(ccx, i.span, sym, i.id, ty)\n+                                register_fn(ccx, i.span, sym, i.id, ty, None)\n                             } else {\n                                 foreign::register_rust_fn_with_foreign_abi(ccx,\n                                                                            i.span,\n@@ -2826,7 +2888,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n \n                             llfn = match enm.node {\n                                 ast::ItemEnum(_, _) => {\n-                                    register_fn(ccx, (*v).span, sym, id, ty)\n+                                    register_fn(ccx, (*v).span, sym, id, ty, None)\n                                 }\n                                 _ => fail!(\"NodeVariant, shouldn't happen\")\n                             };\n@@ -2851,7 +2913,7 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n                             let sym = exported_name(ccx, (*struct_path).clone(), ty,\n                                                     struct_item.attrs);\n                             let llfn = register_fn(ccx, struct_item.span,\n-                                                   sym, ctor_id, ty);\n+                                                   sym, ctor_id, ty, None);\n                             set_inline_hint(llfn);\n                             llfn\n                         }\n@@ -2881,18 +2943,22 @@ pub fn get_item_val(ccx: @CrateContext, id: ast::NodeId) -> ValueRef {\n     }\n }\n \n-pub fn register_method(ccx: @CrateContext,\n-                       id: ast::NodeId,\n-                       path: @ast_map::Path,\n-                       m: @ast::Method) -> ValueRef {\n+fn register_method(ccx: @CrateContext,\n+                   id: ast::NodeId,\n+                   path: @ast_map::Path,\n+                   m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx, id);\n \n     let mut path = (*path).clone();\n     path.push(PathPrettyName(m.ident, token::gensym(\"meth\") as u64));\n \n     let sym = exported_name(ccx, path, mty, m.attrs);\n \n-    let llfn = register_fn(ccx, m.span, sym, id, mty);\n+    let self_ty = match m.explicit_self.node {\n+        ast::SelfStatic => None,\n+        _ => Some(ty::node_id_to_type(ccx.tcx, m.self_id))\n+    };\n+    let llfn = register_fn(ccx, m.span, sym, id, mty, self_ty);\n     set_llvm_fn_attrs(m.attrs, llfn);\n     llfn\n }"}, {"sha": "c1451a8fe1e1218f98a51e921a996584c8554c34", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -60,8 +60,7 @@ pub struct FnData {\n pub struct MethodData {\n     llfn: ValueRef,\n     llself: ValueRef,\n-    temp_cleanup: Option<ValueRef>,\n-    self_mode: ty::SelfMode,\n+    temp_cleanup: Option<ValueRef>\n }\n \n pub enum CalleeData {\n@@ -398,7 +397,7 @@ pub fn trans_fn_ref_with_vtables(\n             let ref_ty = common::node_id_type(bcx, ref_id);\n \n             val = PointerCast(\n-                bcx, val, type_of::type_of_fn_from_ty(ccx, ref_ty).ptr_to());\n+                bcx, val, type_of::type_of_fn_from_ty(ccx, None, ref_ty).ptr_to());\n         }\n         return FnData {llfn: val};\n     }\n@@ -437,7 +436,7 @@ pub fn trans_fn_ref_with_vtables(\n     // This can occur on either a crate-local or crate-external\n     // reference. It also occurs when testing libcore and in some\n     // other weird situations. Annoying.\n-    let llty = type_of::type_of_fn_from_ty(ccx, fn_tpt.ty);\n+    let llty = type_of::type_of_fn_from_ty(ccx, None, fn_tpt.ty);\n     let llptrty = llty.ptr_to();\n     if val_ty(val) != llptrty {\n         val = BitCast(bcx, val, llptrty);\n@@ -496,10 +495,7 @@ pub fn trans_method_call<'a>(\n                            call_ex.repr(in_cx.tcx()),\n                            origin.repr(in_cx.tcx()));\n \n-                    meth::trans_method_callee(cx,\n-                                              callee_id,\n-                                              rcvr,\n-                                              origin)\n+                    meth::trans_method_callee(cx, callee_id, rcvr, origin)\n                 }\n                 None => {\n                     cx.tcx().sess.span_bug(call_ex.span, \"method call expr wasn't in method map\")\n@@ -799,7 +795,6 @@ pub fn trans_args<'a>(\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx,\n                                arg_ty,\n-                               ty::ByCopy,\n                                *arg_expr,\n                                &mut temp_cleanups,\n                                autoref_arg)\n@@ -832,17 +827,15 @@ pub enum AutorefArg {\n pub fn trans_arg_expr<'a>(\n                       bcx: &'a Block<'a>,\n                       formal_arg_ty: ty::t,\n-                      self_mode: ty::SelfMode,\n                       arg_expr: &ast::Expr,\n                       temp_cleanups: &mut ~[ValueRef],\n                       autoref_arg: AutorefArg)\n                       -> Result<'a> {\n     let _icx = push_ctxt(\"trans_arg_expr\");\n     let ccx = bcx.ccx();\n \n-    debug!(\"trans_arg_expr(formal_arg_ty=({}), self_mode={:?}, arg_expr={})\",\n+    debug!(\"trans_arg_expr(formal_arg_ty=({}), arg_expr={})\",\n            formal_arg_ty.repr(bcx.tcx()),\n-           self_mode,\n            arg_expr.repr(bcx.tcx()));\n \n     // translate the arg expr to a datum\n@@ -888,16 +881,8 @@ pub fn trans_arg_expr<'a>(\n                     arg_datum\n                 };\n \n-                val = match self_mode {\n-                    ty::ByRef => {\n-                        debug!(\"by ref arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n-                        arg_datum.to_ref_llval(bcx)\n-                    }\n-                    ty::ByCopy => {\n-                        debug!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n-                        arg_datum.to_appropriate_llval(bcx)\n-                    }\n-                }\n+                debug!(\"by copy arg with type {}\", bcx.ty_to_str(arg_datum.ty));\n+                val = arg_datum.to_appropriate_llval(bcx);\n             }\n         }\n "}, {"sha": "25bc968b987dc6146a4294e2a3b0ddc8c7e61089", "filename": "src/librustc/middle/trans/closure.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -405,7 +405,7 @@ pub fn trans_expr_fn<'a>(\n     let s = mangle_internal_name_by_path_and_seq(ccx,\n                                                  sub_path.clone(),\n                                                  \"expr_fn\");\n-    let llfn = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n+    let llfn = decl_internal_rust_fn(ccx, None, f.sig.inputs, f.sig.output, s);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -423,9 +423,10 @@ pub fn trans_expr_fn<'a>(\n                           decl,\n                           body,\n                           llfn,\n-                          no_self,\n+                          None,\n                           bcx.fcx.param_substs,\n                           user_id,\n+                          None,\n                           [],\n                           ty::ty_fn_ret(fty),\n                           |fcx| load_environment(fcx, cdata_ty, cap_vars, sigil));"}, {"sha": "7f6ab2dd9d154a6bb808fcdaeffba30b72112bd9", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 59, "deletions": 71, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -158,13 +158,6 @@ pub fn BuilderRef_res(B: BuilderRef) -> BuilderRef_res {\n \n pub type ExternMap = HashMap<~str, ValueRef>;\n \n-// Types used for llself.\n-pub struct ValSelfData {\n-    v: ValueRef,\n-    t: ty::t,\n-    is_copy: bool,\n-}\n-\n // Here `self_ty` is the real type of the self parameter to this method. It\n // will only be set in the case of default methods.\n pub struct param_substs {\n@@ -227,7 +220,7 @@ pub struct FunctionContext<'a> {\n     // NB: This is the type of the self *variable*, not the self *type*. The\n     // self type is set only for default methods, while the self variable is\n     // set for all methods.\n-    llself: Cell<Option<ValSelfData>>,\n+    llself: Cell<Option<datum::Datum>>,\n     // The a value alloca'd for calls to upcalls.rust_personality. Used when\n     // outputting the resume instruction.\n     personality: Cell<Option<ValueRef>>,\n@@ -238,10 +231,10 @@ pub struct FunctionContext<'a> {\n     caller_expects_out_pointer: bool,\n \n     // Maps arguments to allocas created for them in llallocas.\n-    llargs: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    llargs: RefCell<HashMap<ast::NodeId, datum::Datum>>,\n     // Maps the def_ids for local variables to the allocas created for\n     // them in llallocas.\n-    lllocals: RefCell<HashMap<ast::NodeId, ValueRef>>,\n+    lllocals: RefCell<HashMap<ast::NodeId, datum::Datum>>,\n     // Same as above, but for closure upvars\n     llupvars: RefCell<HashMap<ast::NodeId, ValueRef>>,\n \n@@ -342,28 +335,14 @@ pub trait CleanupFunction {\n }\n \n /// A cleanup function that calls the \"drop glue\" (destructor function) on\n-/// a typed value.\n-pub struct TypeDroppingCleanupFunction {\n-    val: ValueRef,\n-    t: ty::t,\n-}\n-\n-impl CleanupFunction for TypeDroppingCleanupFunction {\n-    fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a> {\n-        glue::drop_ty(block, self.val, self.t)\n-    }\n-}\n-\n-/// A cleanup function that calls the \"drop glue\" (destructor function) on\n-/// an immediate typed value.\n-pub struct ImmediateTypeDroppingCleanupFunction {\n-    val: ValueRef,\n-    t: ty::t,\n+/// a datum.\n+struct DatumDroppingCleanupFunction {\n+    datum: datum::Datum\n }\n \n-impl CleanupFunction for ImmediateTypeDroppingCleanupFunction {\n+impl CleanupFunction for DatumDroppingCleanupFunction {\n     fn clean<'a>(&self, block: &'a Block<'a>) -> &'a Block<'a> {\n-        glue::drop_ty_immediate(block, self.val, self.t)\n+        self.datum.drop_val(block)\n     }\n }\n \n@@ -390,16 +369,16 @@ impl CleanupFunction for ExchangeHeapFreeingCleanupFunction {\n }\n \n pub enum cleanup {\n-    clean(@CleanupFunction, cleantype),\n-    clean_temp(ValueRef, @CleanupFunction, cleantype),\n+    Clean(@CleanupFunction, cleantype),\n+    CleanTemp(ValueRef, @CleanupFunction, cleantype),\n }\n \n // Can't use deriving(Clone) because of the managed closure.\n impl Clone for cleanup {\n     fn clone(&self) -> cleanup {\n         match *self {\n-            clean(f, ct) => clean(f, ct),\n-            clean_temp(v, f, ct) => clean_temp(v, f, ct),\n+            Clean(f, ct) => Clean(f, ct),\n+            CleanTemp(v, f, ct) => CleanTemp(v, f, ct),\n         }\n     }\n }\n@@ -438,42 +417,46 @@ pub fn cleanup_type(cx: ty::ctxt, ty: ty::t) -> cleantype {\n     }\n }\n \n-pub fn add_clean(bcx: &Block, val: ValueRef, t: ty::t) {\n-    if !ty::type_needs_drop(bcx.tcx(), t) {\n-        return\n-    }\n+pub fn add_clean(bcx: &Block, val: ValueRef, ty: ty::t) {\n+    if !ty::type_needs_drop(bcx.tcx(), ty) { return; }\n \n-    debug!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), t.repr(bcx.tcx()));\n+    debug!(\"add_clean({}, {}, {})\", bcx.to_str(), bcx.val_to_str(val), ty.repr(bcx.tcx()));\n \n-    let cleanup_type = cleanup_type(bcx.tcx(), t);\n+    let cleanup_type = cleanup_type(bcx.tcx(), ty);\n     in_scope_cx(bcx, None, |scope_info| {\n         {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean(@TypeDroppingCleanupFunction {\n-                val: val,\n-                t: t,\n+            cleanups.get().push(Clean(@DatumDroppingCleanupFunction {\n+                datum: datum::Datum {\n+                    val: val,\n+                    ty: ty,\n+                    mode: datum::ByRef(datum::ZeroMem)\n+                }\n             } as @CleanupFunction,\n             cleanup_type));\n         }\n         grow_scope_clean(scope_info);\n     })\n }\n \n-pub fn add_clean_temp_immediate(cx: &Block, val: ValueRef, ty: ty::t) {\n-    if !ty::type_needs_drop(cx.tcx(), ty) { return; }\n+pub fn add_clean_temp_immediate(bcx: &Block, val: ValueRef, ty: ty::t) {\n+    if !ty::type_needs_drop(bcx.tcx(), ty) { return; }\n+\n     debug!(\"add_clean_temp_immediate({}, {}, {})\",\n-           cx.to_str(), cx.val_to_str(val),\n-           ty.repr(cx.tcx()));\n-    let cleanup_type = cleanup_type(cx.tcx(), ty);\n-    in_scope_cx(cx, None, |scope_info| {\n+           bcx.to_str(), bcx.val_to_str(val),\n+           ty.repr(bcx.tcx()));\n+    let cleanup_type = cleanup_type(bcx.tcx(), ty);\n+    in_scope_cx(bcx, None, |scope_info| {\n         {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean_temp(val,\n-                @ImmediateTypeDroppingCleanupFunction {\n+            cleanups.get().push(CleanTemp(val, @DatumDroppingCleanupFunction {\n+                datum: datum::Datum {\n                     val: val,\n-                    t: ty,\n-                } as @CleanupFunction,\n-                cleanup_type));\n+                    ty: ty,\n+                    mode: datum::ByValue\n+                }\n+            } as @CleanupFunction,\n+            cleanup_type));\n         }\n         grow_scope_clean(scope_info);\n     })\n@@ -500,12 +483,14 @@ pub fn add_clean_temp_mem_in_scope_(bcx: &Block, scope_id: Option<ast::NodeId>,\n     in_scope_cx(bcx, scope_id, |scope_info| {\n         {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean_temp(val,\n-                @TypeDroppingCleanupFunction {\n+            cleanups.get().push(CleanTemp(val, @DatumDroppingCleanupFunction {\n+                datum: datum::Datum {\n                     val: val,\n-                    t: t,\n-                } as @CleanupFunction,\n-                cleanup_type));\n+                    ty: t,\n+                    mode: datum::ByRef(datum::RevokeClean)\n+                }\n+            } as @CleanupFunction,\n+            cleanup_type));\n         }\n         grow_scope_clean(scope_info);\n     })\n@@ -527,7 +512,7 @@ pub fn add_clean_free(cx: &Block, ptr: ValueRef, heap: heap) {\n     in_scope_cx(cx, None, |scope_info| {\n         {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n-            cleanups.get().push(clean_temp(ptr,\n+            cleanups.get().push(CleanTemp(ptr,\n                                            free_fn,\n                                            normal_exit_and_unwind));\n         }\n@@ -543,22 +528,26 @@ pub fn revoke_clean(cx: &Block, val: ValueRef) {\n     in_scope_cx(cx, None, |scope_info| {\n         let cleanup_pos = {\n             let mut cleanups = scope_info.cleanups.borrow_mut();\n+            debug!(\"revoke_clean({}, {}) revoking {:?} from {:?}\",\n+                   cx.to_str(), cx.val_to_str(val), val, cleanups.get());\n             cleanups.get().iter().position(|cu| {\n                 match *cu {\n-                    clean_temp(v, _, _) if v == val => true,\n+                    CleanTemp(v, _, _) if v == val => true,\n                     _ => false\n                 }\n             })\n         };\n-        for i in cleanup_pos.iter() {\n+        debug!(\"revoke_clean({}, {}) revoking {:?}\",\n+               cx.to_str(), cx.val_to_str(val), cleanup_pos);\n+        for &i in cleanup_pos.iter() {\n             let new_cleanups = {\n                 let cleanups = scope_info.cleanups.borrow();\n-                vec::append(cleanups.get().slice(0u, *i).to_owned(),\n-                            cleanups.get().slice(*i + 1u, cleanups.get()\n-                                                                  .len()))\n+                vec::append(cleanups.get().slice(0u, i).to_owned(),\n+                            cleanups.get().slice(i + 1u, cleanups.get()\n+                                                                 .len()))\n             };\n             scope_info.cleanups.set(new_cleanups);\n-            shrink_scope_clean(scope_info, *i);\n+            shrink_scope_clean(scope_info, i);\n         }\n     })\n }\n@@ -767,16 +756,16 @@ pub fn in_scope_cx<'a>(\n             Some(inf) => match scope_id {\n                 Some(wanted) => match inf.node_info {\n                     Some(NodeInfo { id: actual, .. }) if wanted == actual => {\n-                        debug!(\"in_scope_cx: selected cur={} (cx={})\",\n-                               cur.to_str(), cx.to_str());\n+                        debug!(\"in_scope_cx: selected cur={} (cx={}) info={:?}\",\n+                               cur.to_str(), cx.to_str(), inf.node_info);\n                         f(inf);\n                         return;\n                     },\n                     _ => inf.parent,\n                 },\n                 None => {\n-                    debug!(\"in_scope_cx: selected cur={} (cx={})\",\n-                           cur.to_str(), cx.to_str());\n+                    debug!(\"in_scope_cx: selected cur={} (cx={}) info={:?}\",\n+                           cur.to_str(), cx.to_str(), inf.node_info);\n                     f(inf);\n                     return;\n                 }\n@@ -1042,8 +1031,7 @@ pub enum MonoDataClass {\n pub fn mono_data_classify(t: ty::t) -> MonoDataClass {\n     match ty::get(t).sty {\n         ty::ty_float(_) => MonoFloat,\n-        ty::ty_rptr(..) | ty::ty_uniq(..) |\n-        ty::ty_box(..) | ty::ty_opaque_box(..) |\n+        ty::ty_rptr(..) | ty::ty_uniq(..) | ty::ty_box(..) |\n         ty::ty_str(ty::vstore_uniq) | ty::ty_vec(_, ty::vstore_uniq) |\n         ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_bare_fn(..) => MonoNonNull,"}, {"sha": "e7eab31ac14e7f02f4579aac7d0a3aac8adcc208", "filename": "src/librustc/middle/trans/datum.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdatum.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -113,6 +113,7 @@ pub enum CopyAction {\n     DROP_EXISTING\n }\n \n+#[deriving(Clone)]\n pub struct Datum {\n     /// The llvm value.  This is either a pointer to the Rust value or\n     /// the value itself, depending on `mode` below.\n@@ -130,7 +131,7 @@ pub struct DatumBlock<'a> {\n     datum: Datum,\n }\n \n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum DatumMode {\n     /// `val` is a pointer to the actual value (and thus has type *T).\n     /// The argument indicates how to cancel cleanup of this datum if\n@@ -153,7 +154,7 @@ impl DatumMode {\n }\n \n /// See `Datum cleanup styles` section at the head of this module.\n-#[deriving(Eq, IterBytes)]\n+#[deriving(Clone, Eq, IterBytes)]\n pub enum DatumCleanup {\n     RevokeClean,\n     ZeroMem\n@@ -396,8 +397,7 @@ impl Datum {\n                 add_clean_temp_mem(bcx, self.val, self.ty);\n             }\n             ByRef(ZeroMem) => {\n-                bcx.tcx().sess.bug(\n-                    format!(\"Cannot add clean to a 'zero-mem' datum\"));\n+                add_clean(bcx, self.val, self.ty)\n             }\n         }\n     }\n@@ -413,7 +413,6 @@ impl Datum {\n                     // Lvalues which potentially need to be dropped\n                     // must be passed by ref, so that we can zero them\n                     // out.\n-                    assert!(self.mode.is_by_ref());\n                     zero_mem(bcx, self.val, self.ty);\n                 }\n             }"}, {"sha": "fa620cca35eaf26f9e71088719ecedbad4d5e0bb", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 13, "deletions": 31, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -133,6 +133,7 @@ use middle::trans::adt;\n use middle::trans::base;\n use middle::trans::build;\n use middle::trans::common::*;\n+use middle::trans::datum;\n use middle::trans::machine;\n use middle::trans::type_of;\n use middle::trans::type_::Type;\n@@ -280,12 +281,11 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n \n     pat_util::pat_bindings(def_map, local.pat, |_, node_id, span, path_ref| {\n         let var_ident = ast_util::path_to_ident(path_ref);\n-        let var_type = node_id_type(bcx, node_id);\n \n-        let llptr = {\n+        let datum = {\n             let lllocals = bcx.fcx.lllocals.borrow();\n             match lllocals.get().find_copy(&node_id) {\n-                Some(v) => v,\n+                Some(datum) => datum,\n                 None => {\n                     bcx.tcx().sess.span_bug(span,\n                         format!(\"No entry in lllocals table for {:?}\",\n@@ -298,9 +298,9 @@ pub fn create_local_var_metadata(bcx: &Block, local: &ast::Local) {\n \n         declare_local(bcx,\n                       var_ident,\n-                      var_type,\n+                      datum.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: llptr },\n+                      DirectVariable { alloca: datum.val },\n                       LocalVariable,\n                       span);\n     })\n@@ -382,33 +382,19 @@ pub fn create_captured_var_metadata(bcx: &Block,\n pub fn create_match_binding_metadata(bcx: &Block,\n                                      variable_ident: ast::Ident,\n                                      node_id: ast::NodeId,\n-                                     variable_type: ty::t,\n-                                     span: Span) {\n+                                     span: Span,\n+                                     datum: datum::Datum) {\n     if fn_should_be_ignored(bcx.fcx) {\n         return;\n     }\n \n-    let llptr = {\n-        let lllocals = bcx.fcx.lllocals.borrow();\n-        match lllocals.get().find_copy(&node_id) {\n-            Some(v) => v,\n-            None => {\n-                bcx.tcx()\n-                   .sess\n-                   .span_bug(span,\n-                             format!(\"No entry in lllocals table for {:?}\",\n-                                     node_id));\n-            }\n-        }\n-    };\n-\n     let scope_metadata = scope_metadata(bcx.fcx, node_id, span);\n \n     declare_local(bcx,\n                   variable_ident,\n-                  variable_type,\n+                  datum.ty,\n                   scope_metadata,\n-                  DirectVariable { alloca: llptr },\n+                  DirectVariable { alloca: datum.val },\n                   LocalVariable,\n                   span);\n }\n@@ -506,7 +492,7 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n     let scope_metadata = bcx.fcx.debug_context.get_ref(cx, arg.pat.span).fn_metadata;\n \n     pat_util::pat_bindings(def_map, arg.pat, |_, node_id, span, path_ref| {\n-        let llptr = {\n+        let llarg = {\n             let llargs = bcx.fcx.llargs.borrow();\n             match llargs.get().find_copy(&node_id) {\n                 Some(v) => v,\n@@ -518,12 +504,11 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n             }\n         };\n \n-        if unsafe { llvm::LLVMIsAAllocaInst(llptr) } == ptr::null() {\n+        if unsafe { llvm::LLVMIsAAllocaInst(llarg.val) } == ptr::null() {\n             cx.sess.span_bug(span, \"debuginfo::create_argument_metadata() - \\\n                                     Referenced variable location is not an alloca!\");\n         }\n \n-        let argument_type = node_id_type(bcx, node_id);\n         let argument_ident = ast_util::path_to_ident(path_ref);\n \n         let argument_index = {\n@@ -535,9 +520,9 @@ pub fn create_argument_metadata(bcx: &Block, arg: &ast::Arg) {\n \n         declare_local(bcx,\n                       argument_ident,\n-                      argument_type,\n+                      llarg.ty,\n                       scope_metadata,\n-                      DirectVariable { alloca: llptr },\n+                      DirectVariable { alloca: llarg.val },\n                       ArgumentVariable(argument_index),\n                       span);\n     })\n@@ -2185,9 +2170,6 @@ fn type_metadata(cx: &CrateContext,\n         },\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx, t, *elements, usage_site_span).finalize(cx)\n-        },\n-        ty::ty_opaque_box => {\n-            create_pointer_to_box_metadata(cx, t, ty::mk_nil())\n         }\n         _ => cx.sess.bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\", sty))\n     };"}, {"sha": "1641e4a8bde92bbe9cea34c7e260d49f91c80447", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 10, "deletions": 20, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -1172,7 +1172,7 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n             take_local(bcx, lllocals.get(), nid)\n         }\n         ast::DefSelf(nid, _) => {\n-            let self_info: ValSelfData = match bcx.fcx.llself.get() {\n+            let self_info = match bcx.fcx.llself.get() {\n                 Some(self_info) => self_info,\n                 None => {\n                     bcx.sess().bug(format!(\n@@ -1181,14 +1181,10 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n                 }\n             };\n \n-            debug!(\"def_self() reference, self_info.t={}\",\n-                   self_info.t.repr(bcx.tcx()));\n+            debug!(\"def_self() reference, self_info.ty={}\",\n+                   self_info.ty.repr(bcx.tcx()));\n \n-            Datum {\n-                val: self_info.v,\n-                ty: self_info.t,\n-                mode: ByRef(ZeroMem)\n-            }\n+            self_info\n         }\n         _ => {\n             bcx.sess().unimpl(format!(\n@@ -1197,24 +1193,18 @@ pub fn trans_local_var(bcx: &Block, def: ast::Def) -> Datum {\n     };\n \n     fn take_local(bcx: &Block,\n-                  table: &HashMap<ast::NodeId, ValueRef>,\n-                  nid: ast::NodeId)\n-                  -> Datum {\n-        let v = match table.find(&nid) {\n+                  table: &HashMap<ast::NodeId, Datum>,\n+                  nid: ast::NodeId) -> Datum {\n+        let datum = match table.find(&nid) {\n             Some(&v) => v,\n             None => {\n                 bcx.sess().bug(format!(\n-                    \"trans_local_var: no llval for local/arg {:?} found\", nid));\n+                    \"trans_local_var: no datum for local/arg {:?} found\", nid));\n             }\n         };\n-        let ty = node_id_type(bcx, nid);\n         debug!(\"take_local(nid={:?}, v={}, ty={})\",\n-               nid, bcx.val_to_str(v), bcx.ty_to_str(ty));\n-        Datum {\n-            val: v,\n-            ty: ty,\n-            mode: ByRef(ZeroMem)\n-        }\n+               nid, bcx.val_to_str(datum.val), bcx.ty_to_str(datum.ty));\n+        datum\n     }\n }\n "}, {"sha": "304edb2c31243b1beae71beb0be154ca8930df12", "filename": "src/librustc/middle/trans/foreign.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fforeign.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -489,16 +489,17 @@ pub fn trans_rust_fn_with_foreign_abi(ccx: @CrateContext,\n                id,\n                t.repr(tcx));\n \n-        let llfndecl = base::decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, ps);\n+        let llfndecl = base::decl_internal_rust_fn(ccx, None, f.sig.inputs, f.sig.output, ps);\n         base::set_llvm_fn_attrs(attrs, llfndecl);\n         base::trans_fn(ccx,\n                        (*path).clone(),\n                        decl,\n                        body,\n                        llfndecl,\n-                       base::no_self,\n+                       None,\n                        None,\n                        id,\n+                       None,\n                        []);\n         return llfndecl;\n     }"}, {"sha": "16a761a44db31f05055480aac6a3809c7d8402bd", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 48, "deletions": 86, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -93,84 +93,67 @@ pub fn lazily_emit_all_tydesc_glue(ccx: @CrateContext,\n     lazily_emit_tydesc_glue(ccx, abi::tydesc_field_visit_glue, static_ti);\n }\n \n-pub fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n-    if (field == abi::tydesc_field_take_glue ||\n-        field == abi::tydesc_field_drop_glue) &&\n-        ! ty::type_needs_drop(tcx, t) {\n-          return ty::mk_u32();\n+fn simplified_glue_type(tcx: ty::ctxt, field: uint, t: ty::t) -> ty::t {\n+    if (field == abi::tydesc_field_take_glue || field == abi::tydesc_field_drop_glue)\n+        && !ty::type_needs_drop(tcx, t) {\n+        return ty::mk_nil();\n     }\n \n     if field == abi::tydesc_field_take_glue {\n         match ty::get(t).sty {\n-          ty::ty_unboxed_vec(..) |\n-              ty::ty_uniq(..) |\n-              ty::ty_str(ty::vstore_uniq) |\n-              ty::ty_vec(_, ty::vstore_uniq) => { return ty::mk_u32(); }\n-          _ => ()\n+            ty::ty_str(ty::vstore_uniq) |  ty::ty_vec(_, ty::vstore_uniq) |\n+            ty::ty_unboxed_vec(..) | ty::ty_uniq(..) => return ty::mk_nil(),\n+            _ => {}\n         }\n     }\n \n-    if field == abi::tydesc_field_take_glue &&\n-        ty::type_is_boxed(t) {\n-          return ty::mk_imm_box(tcx, ty::mk_u32());\n+    if field == abi::tydesc_field_take_glue && ty::type_is_boxed(t) {\n+        return ty::mk_imm_box(tcx, ty::mk_nil());\n     }\n \n     if field == abi::tydesc_field_drop_glue {\n         match ty::get(t).sty {\n-          ty::ty_box(typ)\n-          if ! ty::type_needs_drop(tcx, typ) =>\n-          return ty::mk_imm_box(tcx, ty::mk_u32()),\n+            ty::ty_box(typ)\n+                if !ty::type_needs_drop(tcx, typ) =>\n+            return ty::mk_imm_box(tcx, ty::mk_nil()),\n \n-          ty::ty_vec(mt, ty::vstore_box)\n-          if ! ty::type_needs_drop(tcx, mt.ty) =>\n-          return ty::mk_imm_box(tcx, ty::mk_u32()),\n+            ty::ty_vec(mt, ty::vstore_box)\n+                if !ty::type_needs_drop(tcx, mt.ty) =>\n+            return ty::mk_imm_box(tcx, ty::mk_nil()),\n \n-          ty::ty_uniq(mt) |\n-          ty::ty_vec(mt, ty::vstore_uniq)\n-          if ! ty::type_needs_drop(tcx, mt.ty) =>\n-          return ty::mk_imm_uniq(tcx, ty::mk_u32()),\n+            ty::ty_uniq(mt) | ty::ty_vec(mt, ty::vstore_uniq)\n+                if !ty::type_needs_drop(tcx, mt.ty) =>\n+            return ty::mk_imm_uniq(tcx, ty::mk_nil()),\n \n-          _ => ()\n+            _ => {}\n         }\n     }\n \n-    return t;\n+    t\n }\n \n-pub fn lazily_emit_simplified_tydesc_glue(ccx: @CrateContext,\n-                                          field: uint,\n-                                          ti: &tydesc_info)\n-                                          -> bool {\n-    let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n+fn lazily_emit_tydesc_glue(ccx: @CrateContext, field: uint, ti: @tydesc_info) {\n+    let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n+\n     let simpl = simplified_glue_type(ccx.tcx, field, ti.ty);\n     if simpl != ti.ty {\n+        let _icx = push_ctxt(\"lazily_emit_simplified_tydesc_glue\");\n         let simpl_ti = get_tydesc(ccx, simpl);\n         lazily_emit_tydesc_glue(ccx, field, simpl_ti);\n-        {\n-            if field == abi::tydesc_field_take_glue {\n-                ti.take_glue.set(simpl_ti.take_glue.get());\n-            } else if field == abi::tydesc_field_drop_glue {\n-                ti.drop_glue.set(simpl_ti.drop_glue.get());\n-            } else if field == abi::tydesc_field_visit_glue {\n-                ti.visit_glue.set(simpl_ti.visit_glue.get());\n-            }\n-        }\n-        return true;\n-    }\n-    return false;\n-}\n \n+        if field == abi::tydesc_field_take_glue {\n+            ti.take_glue.set(simpl_ti.take_glue.get());\n+        } else if field == abi::tydesc_field_drop_glue {\n+            ti.drop_glue.set(simpl_ti.drop_glue.get());\n+        } else if field == abi::tydesc_field_visit_glue {\n+            ti.visit_glue.set(simpl_ti.visit_glue.get());\n+        }\n \n-pub fn lazily_emit_tydesc_glue(ccx: @CrateContext,\n-                               field: uint,\n-                               ti: @tydesc_info) {\n-    let _icx = push_ctxt(\"lazily_emit_tydesc_glue\");\n-    let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n-\n-    if lazily_emit_simplified_tydesc_glue(ccx, field, ti) {\n         return;\n     }\n \n+    let llfnty = Type::glue_fn(type_of(ccx, ti.ty).ptr_to());\n+\n     if field == abi::tydesc_field_take_glue {\n         match ti.take_glue.get() {\n           Some(_) => (),\n@@ -271,16 +254,12 @@ pub fn call_tydesc_glue_full(bcx: &Block,\n }\n \n // See [Note-arg-mode]\n-pub fn call_tydesc_glue<'a>(\n-                        cx: &'a Block<'a>,\n-                        v: ValueRef,\n-                        t: ty::t,\n-                        field: uint)\n-                        -> &'a Block<'a> {\n+fn call_tydesc_glue<'a>(cx: &'a Block<'a>, v: ValueRef, t: ty::t, field: uint)\n+                    -> &'a Block<'a> {\n     let _icx = push_ctxt(\"call_tydesc_glue\");\n     let ti = get_tydesc(cx.ccx(), t);\n     call_tydesc_glue_full(cx, v, ti.tydesc, field, Some(ti));\n-    return cx;\n+    cx\n }\n \n fn make_visit_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n@@ -308,7 +287,6 @@ pub fn make_free_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t)\n     // NB: v0 is an *alias* of type t here, not a direct value.\n     let _icx = push_ctxt(\"make_free_glue\");\n     match ty::get(t).sty {\n-      ty::ty_opaque_box => bcx.tcx().sess.fatal(\"found ty_opaque_box in make_free_glue\"),\n       ty::ty_box(body_ty) => {\n         let v = Load(bcx, v);\n         let body = GEPi(bcx, v, [0u, abi::box_field_body]);\n@@ -407,7 +385,6 @@ pub fn make_drop_glue<'a>(bcx: &'a Block<'a>, v0: ValueRef, t: ty::t)\n     let _icx = push_ctxt(\"make_drop_glue\");\n     let ccx = bcx.ccx();\n     match ty::get(t).sty {\n-      ty::ty_opaque_box => bcx.tcx().sess.fatal(\"found ty_opaque_box in make_drop_glue\"),\n       ty::ty_box(_) |\n       ty::ty_str(ty::vstore_box) | ty::ty_vec(_, ty::vstore_box) => {\n         decr_refcnt_maybe_free(bcx, v0, Some(t))\n@@ -509,7 +486,6 @@ fn make_take_glue<'a>(bcx: &'a Block<'a>, v: ValueRef, t: ty::t) -> &'a Block<'a\n     let _icx = push_ctxt(\"make_take_glue\");\n     // NB: v is a *pointer* to type t here, not a direct value.\n     match ty::get(t).sty {\n-      ty::ty_opaque_box => bcx.tcx().sess.fatal(\"found ty_opaque_box in make_take_glue\"),\n       ty::ty_box(_) |\n       ty::ty_vec(_, ty::vstore_box) | ty::ty_str(ty::vstore_box) => {\n         incr_refcnt_of_boxed(bcx, Load(bcx, v)); bcx\n@@ -610,11 +586,8 @@ pub fn declare_tydesc(ccx: &CrateContext, t: ty::t) -> @tydesc_info {\n     return inf;\n }\n \n-pub type glue_helper<'a> =\n-    'a |&'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>;\n-\n-pub fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n-                            name: &str) -> ValueRef {\n+fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n+                        name: &str) -> ValueRef {\n     let _icx = push_ctxt(\"declare_generic_glue\");\n     let fn_nm = mangle_internal_name_by_type_and_seq(ccx, t, (~\"glue_\" + name)).to_managed();\n     debug!(\"{} is for type {}\", fn_nm, ppaux::ty_to_str(ccx.tcx, t));\n@@ -623,12 +596,14 @@ pub fn declare_generic_glue(ccx: &CrateContext, t: ty::t, llfnty: Type,\n     return llfn;\n }\n \n-pub fn make_generic_glue_inner(ccx: @CrateContext,\n-                               t: ty::t,\n-                               llfn: ValueRef,\n-                               helper: glue_helper)\n-                            -> ValueRef {\n-    let _icx = push_ctxt(\"make_generic_glue_inner\");\n+pub type glue_helper<'a> =\n+    'a |&'a Block<'a>, ValueRef, ty::t| -> &'a Block<'a>;\n+\n+fn make_generic_glue(ccx: @CrateContext, t: ty::t, llfn: ValueRef,\n+                     helper: glue_helper, name: &str) -> ValueRef {\n+    let _icx = push_ctxt(\"make_generic_glue\");\n+    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n+    let _s = StatRecorder::new(ccx, glue_name);\n \n     let fcx = new_fn_ctxt(ccx, ~[], llfn, ty::mk_nil(), None);\n     init_function(&fcx, false, ty::mk_nil(), None, None);\n@@ -644,25 +619,12 @@ pub fn make_generic_glue_inner(ccx: @CrateContext,\n     // type, so we don't need to explicitly cast the function parameter.\n \n     let bcx = fcx.entry_bcx.get().unwrap();\n-    let rawptr0_arg = fcx.arg_pos(0u);\n-    let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, rawptr0_arg as c_uint) };\n+    let llrawptr0 = unsafe { llvm::LLVMGetParam(llfn, fcx.arg_pos(0) as c_uint) };\n     let bcx = helper(bcx, llrawptr0, t);\n \n     finish_fn(&fcx, bcx);\n \n-    return llfn;\n-}\n-\n-pub fn make_generic_glue(ccx: @CrateContext,\n-                         t: ty::t,\n-                         llfn: ValueRef,\n-                         helper: glue_helper,\n-                         name: &str)\n-                      -> ValueRef {\n-    let _icx = push_ctxt(\"make_generic_glue\");\n-    let glue_name = format!(\"glue {} {}\", name, ty_to_short_str(ccx.tcx, t));\n-    let _s = StatRecorder::new(ccx, glue_name);\n-    make_generic_glue_inner(ccx, t, llfn, helper)\n+    llfn\n }\n \n pub fn emit_tydescs(ccx: &CrateContext) {"}, {"sha": "7d0e5a435441b53e079a60052404e7997b70938d", "filename": "src/librustc/middle/trans/inline.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Finline.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -11,8 +11,7 @@\n use lib::llvm::{AvailableExternallyLinkage, SetLinkage};\n use metadata::csearch;\n use middle::astencode;\n-use middle::trans::base::{push_ctxt, impl_self, no_self};\n-use middle::trans::base::{trans_item, get_item_val, trans_fn};\n+use middle::trans::base::{push_ctxt, trans_item, get_item_val, trans_fn};\n use middle::trans::common::*;\n use middle::ty;\n use util::ppaux::ty_to_str;\n@@ -162,16 +161,13 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n               let path = vec::append_one(\n                   ty::item_path(ccx.tcx, impl_did), PathName(mth.ident));\n               let self_kind = match mth.explicit_self.node {\n-                  ast::SelfStatic => no_self,\n+                  ast::SelfStatic => None,\n                   _ => {\n                       let self_ty = ty::node_id_to_type(ccx.tcx,\n                                                         mth.self_id);\n                       debug!(\"calling inline trans_fn with self_ty {}\",\n                              ty_to_str(ccx.tcx, self_ty));\n-                      match mth.explicit_self.node {\n-                          ast::SelfValue(_) => impl_self(self_ty, ty::ByRef),\n-                          _ => impl_self(self_ty, ty::ByCopy),\n-                      }\n+                      Some(self_ty)\n                   }\n               };\n               trans_fn(ccx,\n@@ -182,6 +178,7 @@ pub fn maybe_instantiate_inline(ccx: @CrateContext, fn_id: ast::DefId)\n                        self_kind,\n                        None,\n                        mth.id,\n+                       Some(&*mth),\n                        []);\n           }\n           local_def(mth.id)"}, {"sha": "126aa9e7be580a2f45ab18c4097414d671cf4724", "filename": "src/librustc/middle/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fintrinsic.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -430,7 +430,7 @@ pub fn trans_intrinsic(ccx: @CrateContext,\n             // XXX This is a hack to grab the address of this particular\n             // native function. There should be a general in-language\n             // way to do this\n-            let llfty = type_of_rust_fn(bcx.ccx(), [], ty::mk_nil());\n+            let llfty = type_of_rust_fn(bcx.ccx(), None, [], ty::mk_nil());\n             let morestack_addr = decl_cdecl_fn(\n                 bcx.ccx().llmod, \"__morestack\", llfty);\n             let morestack_addr = PointerCast(bcx, morestack_addr, Type::nil().ptr_to());"}, {"sha": "2ab495226a8c12ef16310d1f7808bcafcf00ceaf", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 37, "deletions": 54, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -76,7 +76,7 @@ pub fn trans_impl(ccx: @CrateContext,\n                          path,\n                          *method,\n                          None,\n-                         llfn);\n+                         |_| llfn);\n         } else {\n             let mut v = TransItemVisitor{ ccx: ccx };\n             visit::walk_method_helper(&mut v, *method, ());\n@@ -91,20 +91,18 @@ pub fn trans_impl(ccx: @CrateContext,\n /// * `method`: the AST node for the method\n /// * `param_substs`: if this is a generic method, the current values for\n ///   type parameters and so forth, else none\n-/// * `llfn`: the LLVM ValueRef for the method\n+/// * `llfn`: a closure returning the LLVM ValueRef for the method\n /// * `impl_id`: the node ID of the impl this method is inside\n ///\n /// XXX(pcwalton) Can we take `path` by reference?\n pub fn trans_method(ccx: @CrateContext,\n                     path: Path,\n                     method: &ast::Method,\n                     param_substs: Option<@param_substs>,\n-                    llfn: ValueRef) {\n+                    llfn_with_self: |Option<ty::t>| -> ValueRef) -> ValueRef {\n     // figure out how self is being passed\n-    let self_arg = match method.explicit_self.node {\n-      ast::SelfStatic => {\n-        no_self\n-      }\n+    let self_ty = match method.explicit_self.node {\n+      ast::SelfStatic => None,\n       _ => {\n         // determine the (monomorphized) type that `self` maps to for\n         // this method\n@@ -115,43 +113,25 @@ pub fn trans_method(ccx: @CrateContext,\n                 ty::subst_tps(ccx.tcx, *tys, *self_sub, self_ty)\n             }\n         };\n-        debug!(\"calling trans_fn with self_ty {}\",\n-               self_ty.repr(ccx.tcx));\n-        match method.explicit_self.node {\n-          ast::SelfValue(_) => impl_self(self_ty, ty::ByRef),\n-          _ => impl_self(self_ty, ty::ByCopy),\n-        }\n+        debug!(\"calling trans_fn with self_ty {}\", self_ty.repr(ccx.tcx));\n+        Some(self_ty)\n       }\n     };\n \n+    let llfn = llfn_with_self(self_ty);\n+\n     // generate the actual code\n     trans_fn(ccx,\n              path,\n              method.decl,\n              method.body,\n              llfn,\n-             self_arg,\n+             self_ty,\n              param_substs,\n              method.id,\n+             Some(method),\n              []);\n-}\n-\n-pub fn trans_self_arg<'a>(\n-                      bcx: &'a Block<'a>,\n-                      base: &ast::Expr,\n-                      temp_cleanups: &mut ~[ValueRef],\n-                      mentry: typeck::method_map_entry)\n-                      -> Result<'a> {\n-    let _icx = push_ctxt(\"impl::trans_self_arg\");\n-\n-    // self is passed as an opaque box in the environment slot\n-    let self_ty = ty::mk_opaque_box(bcx.tcx());\n-    trans_arg_expr(bcx,\n-                   self_ty,\n-                   mentry.self_mode,\n-                   base,\n-                   temp_cleanups,\n-                   DontAutorefArg)\n+    llfn\n }\n \n pub fn trans_method_callee<'a>(\n@@ -169,16 +149,23 @@ pub fn trans_method_callee<'a>(\n \n     match mentry.origin {\n         typeck::method_static(did) => {\n-            let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n+            let self_ty = monomorphize_type(bcx, mentry.self_ty);\n             let mut temp_cleanups = ~[];\n-            let Result {bcx, val} = trans_self_arg(bcx, this, &mut temp_cleanups, mentry);\n+            let Result {bcx, val} = trans_arg_expr(bcx, self_ty, this,\n+                                                   &mut temp_cleanups,\n+                                                   DontAutorefArg);\n+            // HACK should not need the pointer cast, eventually trans_fn_ref\n+            // should return a function type with the right type for self.\n+            let callee_fn = callee::trans_fn_ref(bcx, did, callee_id);\n+            let fn_ty = node_id_type(bcx, callee_id);\n+            let llfn_ty = type_of_fn_from_ty(bcx.ccx(), Some(self_ty), fn_ty).ptr_to();\n+            let llfn_val = PointerCast(bcx, callee_fn.llfn, llfn_ty);\n             Callee {\n                 bcx: bcx,\n                 data: Method(MethodData {\n-                    llfn: callee_fn.llfn,\n+                    llfn: llfn_val,\n                     llself: val,\n-                    temp_cleanup: temp_cleanups.head_opt().map(|v| *v),\n-                    self_mode: mentry.self_mode,\n+                    temp_cleanup: temp_cleanups.head_opt().map(|v| *v)\n                 })\n             }\n         }\n@@ -194,8 +181,7 @@ pub fn trans_method_callee<'a>(\n                         bcx.tcx(),\n                         trait_id);\n \n-                    let vtbl = find_vtable(bcx.tcx(), substs,\n-                                           p, b);\n+                    let vtbl = find_vtable(bcx.tcx(), substs, p, b);\n                     trans_monomorphized_callee(bcx, callee_id, this, mentry,\n                                                trait_id, off, vtbl)\n                 }\n@@ -276,7 +262,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n             assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n-            let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n+            let mth_id = method_with_name(ccx, impl_did, mname.name);\n             let (callee_substs, callee_origins) =\n                 combine_impl_and_methods_tps(\n                     bcx, mth_id, callee_id,\n@@ -290,7 +276,7 @@ pub fn trans_static_method_callee(bcx: &Block,\n                                           Some(callee_origins));\n \n             let callee_ty = node_id_type(bcx, callee_id);\n-            let llty = type_of_fn_from_ty(ccx, callee_ty).ptr_to();\n+            let llty = type_of_fn_from_ty(ccx, None, callee_ty).ptr_to();\n             FnData {llfn: PointerCast(bcx, lval, llty)}\n         }\n         _ => {\n@@ -340,9 +326,11 @@ pub fn trans_monomorphized_callee<'a>(\n           let mth_id = method_with_name(bcx.ccx(), impl_did, mname.name);\n \n           // obtain the `self` value:\n+          let self_ty = monomorphize_type(bcx, mentry.self_ty);\n           let mut temp_cleanups = ~[];\n-          let Result {bcx, val: llself_val} =\n-              trans_self_arg(bcx, base, &mut temp_cleanups, mentry);\n+          let Result {bcx, val} = trans_arg_expr(bcx, self_ty, base,\n+                                                 &mut temp_cleanups,\n+                                                 DontAutorefArg);\n \n           // create a concatenated set of substitutions which includes\n           // those from the impl and those from the method:\n@@ -359,18 +347,18 @@ pub fn trans_monomorphized_callee<'a>(\n                                                  Some(callee_origins));\n \n           // create a llvalue that represents the fn ptr\n+          // HACK should not need the pointer cast (add self in trans_fn_ref_with_vtables).\n           let fn_ty = node_id_type(bcx, callee_id);\n-          let llfn_ty = type_of_fn_from_ty(ccx, fn_ty).ptr_to();\n+          let llfn_ty = type_of_fn_from_ty(ccx, Some(self_ty), fn_ty).ptr_to();\n           let llfn_val = PointerCast(bcx, callee.llfn, llfn_ty);\n \n           // combine the self environment with the rest\n           Callee {\n               bcx: bcx,\n               data: Method(MethodData {\n                   llfn: llfn_val,\n-                  llself: llself_val,\n-                  temp_cleanup: temp_cleanups.head_opt().map(|v| *v),\n-                  self_mode: mentry.self_mode,\n+                  llself: val,\n+                  temp_cleanup: temp_cleanups.head_opt().map(|v| *v)\n               })\n           }\n       }\n@@ -496,7 +484,7 @@ pub fn trans_trait_callee_from_llval<'a>(\n \n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n-    let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n+    let llcallee_ty = type_of_fn_from_ty(ccx, None, callee_ty);\n     let llvtable = Load(bcx,\n                         PointerCast(bcx,\n                                     GEPi(bcx, llpair,\n@@ -510,12 +498,7 @@ pub fn trans_trait_callee_from_llval<'a>(\n         data: Method(MethodData {\n             llfn: mptr,\n             llself: llself,\n-            temp_cleanup: temp_cleanup,\n-\n-                // We know that the func declaration is &self, ~self,\n-                // or @self, and such functions are always by-copy\n-                // (right now, at least).\n-            self_mode: ty::ByCopy,\n+            temp_cleanup: temp_cleanup\n         })\n     };\n }"}, {"sha": "c7bf618a619c099db076f241098441739848c957", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 19, "deletions": 18, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -13,9 +13,8 @@ use back::link::mangle_exported_name;\n use driver::session;\n use lib::llvm::ValueRef;\n use middle::trans::base::{set_llvm_fn_attrs, set_inline_hint};\n-use middle::trans::base::{trans_enum_variant,push_ctxt};\n+use middle::trans::base::{trans_enum_variant, push_ctxt, get_item_val};\n use middle::trans::base::{trans_fn, decl_internal_rust_fn};\n-use middle::trans::base::{get_item_val, no_self};\n use middle::trans::base;\n use middle::trans::common::*;\n use middle::trans::meth;\n@@ -211,8 +210,8 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n     let s = mangle_exported_name(ccx, pt.clone(), mono_ty);\n     debug!(\"monomorphize_fn mangled to {}\", s);\n \n-    let mk_lldecl = || {\n-        let lldecl = decl_internal_rust_fn(ccx, f.sig.inputs, f.sig.output, s);\n+    let mk_lldecl = |self_ty| {\n+        let lldecl = decl_internal_rust_fn(ccx, self_ty, f.sig.inputs, f.sig.output, s);\n         let mut monomorphized = ccx.monomorphized.borrow_mut();\n         monomorphized.get().insert(hash_id, lldecl);\n         lldecl\n@@ -223,32 +222,33 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n                 node: ast::ItemFn(decl, _, _, _, body),\n                 ..\n             }, _) => {\n-        let d = mk_lldecl();\n+        let d = mk_lldecl(None);\n         set_llvm_fn_attrs(i.attrs, d);\n         trans_fn(ccx,\n                  pt,\n                  decl,\n                  body,\n                  d,\n-                 no_self,\n+                 None,\n                  Some(psubsts),\n                  fn_id.node,\n+                 None,\n                  []);\n         d\n       }\n       ast_map::NodeItem(..) => {\n           ccx.tcx.sess.bug(\"Can't monomorphize this kind of item\")\n       }\n       ast_map::NodeForeignItem(i, _, _, _) => {\n-          let d = mk_lldecl();\n+          let d = mk_lldecl(None);\n           intrinsic::trans_intrinsic(ccx, d, i, pt, psubsts, i.attrs,\n                                      ref_id);\n           d\n       }\n       ast_map::NodeVariant(v, enum_item, _) => {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = *tvs.iter().find(|tv| { tv.id.node == fn_id.node}).unwrap();\n-        let d = mk_lldecl();\n+        let d = mk_lldecl(None);\n         set_inline_hint(d);\n         match v.node.kind {\n             ast::TupleVariantKind(ref args) => {\n@@ -266,20 +266,21 @@ pub fn monomorphic_fn(ccx: @CrateContext,\n         d\n       }\n       ast_map::NodeMethod(mth, _, _) => {\n-        // XXX: What should the self type be here?\n-        let d = mk_lldecl();\n-        set_llvm_fn_attrs(mth.attrs, d);\n-        meth::trans_method(ccx, pt, mth, Some(psubsts), d);\n-        d\n+        meth::trans_method(ccx, pt, mth, Some(psubsts), |self_ty| {\n+            let d = mk_lldecl(self_ty);\n+            set_llvm_fn_attrs(mth.attrs, d);\n+            d\n+        })\n       }\n       ast_map::NodeTraitMethod(@ast::Provided(mth), _, pt) => {\n-        let d = mk_lldecl();\n-        set_llvm_fn_attrs(mth.attrs, d);\n-        meth::trans_method(ccx, (*pt).clone(), mth, Some(psubsts), d);\n-        d\n+        meth::trans_method(ccx, (*pt).clone(), mth, Some(psubsts), |self_ty| {\n+            let d = mk_lldecl(self_ty);\n+            set_llvm_fn_attrs(mth.attrs, d);\n+            d\n+        })\n       }\n       ast_map::NodeStructCtor(struct_def, _, _) => {\n-        let d = mk_lldecl();\n+        let d = mk_lldecl(None);\n         set_inline_hint(d);\n         base::trans_tuple_struct(ccx,\n                                  struct_def.fields,"}, {"sha": "ef9f48d478531e4da956cc5d551b18e464c77ae4", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -295,7 +295,7 @@ impl<'a> Reflector<'a> {\n                                                                sub_path,\n                                                                \"get_disr\");\n \n-                let llfdecl = decl_internal_rust_fn(ccx, [opaqueptrty], ty::mk_u64(), sym);\n+                let llfdecl = decl_internal_rust_fn(ccx, None, [opaqueptrty], ty::mk_u64(), sym);\n                 let fcx = new_fn_ctxt(ccx,\n                                       ~[],\n                                       llfdecl,\n@@ -362,7 +362,6 @@ impl<'a> Reflector<'a> {\n           }\n           ty::ty_self(..) => self.leaf(\"self\"),\n           ty::ty_type => self.leaf(\"type\"),\n-          ty::ty_opaque_box => self.leaf(\"opaque_box\"),\n           ty::ty_opaque_closure_ptr(ck) => {\n               let ckval = ast_sigil_constant(ck);\n               let extra = ~[self.c_uint(ckval)];"}, {"sha": "f59c2acd0274c9e66f2cbcb7f79c119e3042396b", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -44,6 +44,7 @@ pub fn type_of_explicit_args(ccx: &CrateContext,\n }\n \n pub fn type_of_rust_fn(cx: &CrateContext,\n+                       self_ty: Option<ty::t>,\n                        inputs: &[ty::t],\n                        output: ty::t) -> Type {\n     let mut atys: ~[Type] = ~[];\n@@ -57,7 +58,11 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n     }\n \n     // Arg 1: Environment\n-    atys.push(Type::opaque_box(cx).ptr_to());\n+    let env = match self_ty {\n+        Some(t) => type_of_explicit_arg(cx, t),\n+        None => Type::opaque_box(cx).ptr_to()\n+    };\n+    atys.push(env);\n \n     // ... then explicit args.\n     atys.push_all(type_of_explicit_args(cx, inputs));\n@@ -71,14 +76,14 @@ pub fn type_of_rust_fn(cx: &CrateContext,\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n-pub fn type_of_fn_from_ty(cx: &CrateContext, fty: ty::t) -> Type {\n+pub fn type_of_fn_from_ty(cx: &CrateContext, self_ty: Option<ty::t>, fty: ty::t) -> Type {\n     return match ty::get(fty).sty {\n         ty::ty_closure(ref f) => {\n-            type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n+            type_of_rust_fn(cx, None, f.sig.inputs, f.sig.output)\n         }\n         ty::ty_bare_fn(ref f) => {\n             if f.abis.is_rust() || f.abis.is_intrinsic() {\n-                type_of_rust_fn(cx, f.sig.inputs, f.sig.output)\n+                type_of_rust_fn(cx, self_ty, f.sig.inputs, f.sig.output)\n             } else {\n                 foreign::lltype_for_foreign_fn(cx, fty)\n             }\n@@ -122,7 +127,6 @@ pub fn sizing_type_of(cx: &CrateContext, t: ty::t) -> Type {\n         ty::ty_vec(_, ty::vstore_uniq) |\n         ty::ty_vec(_, ty::vstore_box) |\n         ty::ty_box(..) |\n-        ty::ty_opaque_box |\n         ty::ty_uniq(..) |\n         ty::ty_ptr(..) |\n         ty::ty_rptr(..) |\n@@ -240,7 +244,6 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n           let ty = type_of(cx, typ);\n           Type::smart_ptr(cx, &ty).ptr_to()\n       }\n-      ty::ty_opaque_box => Type::opaque_box(cx).ptr_to(),\n       ty::ty_uniq(ref mt) => {\n           let ty = type_of(cx, mt.ty);\n           if ty::type_contents(cx.tcx, mt.ty).owns_managed() {\n@@ -285,10 +288,10 @@ pub fn type_of(cx: &CrateContext, t: ty::t) -> Type {\n       }\n \n       ty::ty_bare_fn(_) => {\n-          type_of_fn_from_ty(cx, t).ptr_to()\n+          type_of_fn_from_ty(cx, None, t).ptr_to()\n       }\n       ty::ty_closure(_) => {\n-          let ty = type_of_fn_from_ty(cx, t);\n+          let ty = type_of_fn_from_ty(cx, None, t);\n           Type::func_pair(cx, &ty)\n       }\n       ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),"}, {"sha": "46dc1bb68b3a048652dbfc2ac802195749d2d6dc", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 11, "deletions": 31, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -151,14 +151,6 @@ pub enum TraitStore {\n     RegionTraitStore(Region),   // &Trait\n }\n \n-// XXX: This should probably go away at some point. Maybe after destructors\n-// do?\n-#[deriving(Clone, Eq, Encodable, Decodable)]\n-pub enum SelfMode {\n-    ByCopy,\n-    ByRef,\n-}\n-\n pub struct field_ty {\n     name: Name,\n     id: DefId,\n@@ -659,8 +651,7 @@ pub enum sty {\n \n     // \"Fake\" types, used for trans purposes\n     ty_type, // type_desc*\n-    ty_opaque_box, // used by monomorphizer to represent any @ box\n-    ty_opaque_closure_ptr(Sigil), // ptr to env for ||, @fn, ~fn\n+    ty_opaque_closure_ptr(Sigil), // ptr to env for || and proc\n     ty_unboxed_vec(mt),\n }\n \n@@ -1078,8 +1069,7 @@ pub fn mk_t(cx: ctxt, st: sty) -> t {\n         flags |= get(mt.ty).flags;\n       }\n       &ty_nil | &ty_bool | &ty_char | &ty_int(_) | &ty_float(_) | &ty_uint(_) |\n-      &ty_str(_) | &ty_type | &ty_opaque_closure_ptr(_) |\n-      &ty_opaque_box => (),\n+      &ty_str(_) | &ty_type | &ty_opaque_closure_ptr(_) => {}\n       // You might think that we could just return ty_err for\n       // any type containing ty_err as a component, and get\n       // rid of the has_ty_err flag -- likewise for ty_bot (with\n@@ -1354,8 +1344,6 @@ pub fn mk_opaque_closure_ptr(cx: ctxt, sigil: ast::Sigil) -> t {\n     mk_t(cx, ty_opaque_closure_ptr(sigil))\n }\n \n-pub fn mk_opaque_box(cx: ctxt) -> t { mk_t(cx, ty_opaque_box) }\n-\n pub fn walk_ty(ty: t, f: |t|) {\n     maybe_walk_ty(ty, |t| { f(t); true });\n }\n@@ -1366,12 +1354,9 @@ pub fn maybe_walk_ty(ty: t, f: |t| -> bool) {\n     }\n     match get(ty).sty {\n       ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-      ty_str(_) | ty_type | ty_opaque_box | ty_self(_) |\n-      ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {\n-      }\n-      ty_box(ref ty) => {\n-        maybe_walk_ty(*ty, f);\n-      }\n+      ty_str(_) | ty_type | ty_self(_) |\n+      ty_opaque_closure_ptr(_) | ty_infer(_) | ty_param(_) | ty_err => {}\n+      ty_box(ref ty) => maybe_walk_ty(*ty, f),\n       ty_vec(ref tm, _) | ty_unboxed_vec(ref tm) | ty_ptr(ref tm) |\n       ty_rptr(_, ref tm) | ty_uniq(ref tm) => {\n         maybe_walk_ty(tm.ty, f);\n@@ -1592,8 +1577,7 @@ pub fn type_is_box(ty: t) -> bool {\n \n pub fn type_is_boxed(ty: t) -> bool {\n     match get(ty).sty {\n-      ty_box(_) | ty_opaque_box |\n-      ty_vec(_, vstore_box) | ty_str(vstore_box) => true,\n+      ty_box(_) | ty_vec(_, vstore_box) | ty_str(vstore_box) => true,\n       _ => false\n     }\n }\n@@ -1699,7 +1683,7 @@ fn type_needs_unwind_cleanup_(cx: ctxt, ty: t,\n     maybe_walk_ty(ty, |ty| {\n         let old_encountered_box = encountered_box;\n         let result = match get(ty).sty {\n-          ty_box(_) | ty_opaque_box => {\n+          ty_box(_) => {\n             encountered_box = true;\n             true\n           }\n@@ -2145,8 +2129,6 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 // times.\n                 TC::All\n             }\n-\n-            ty_opaque_box => TC::Managed,\n             ty_unboxed_vec(mt) => TC::InteriorUnsized | tc_mt(cx, mt, cache),\n             ty_opaque_closure_ptr(sigil) => {\n                 match sigil {\n@@ -2332,7 +2314,6 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             ty_param(_) |\n             ty_self(_) |\n             ty_type |\n-            ty_opaque_box |\n             ty_opaque_closure_ptr(_) |\n             ty_vec(_, _) |\n             ty_unboxed_vec(_) => {\n@@ -2515,7 +2496,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_box(_) | ty_uniq(_) | ty_closure(_) |\n       ty_str(vstore_uniq) | ty_str(vstore_box) |\n       ty_vec(_, vstore_uniq) | ty_vec(_, vstore_box) |\n-      ty_trait(_, _, _, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n+      ty_trait(_, _, _, _, _) | ty_rptr(_,_) => result = false,\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n@@ -3345,7 +3326,7 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n     match get(t).sty {\n       ty_nil | ty_bot | ty_bool | ty_char | ty_int(_) |\n       ty_uint(_) | ty_float(_) | ty_str(_) |\n-      ty_type | ty_opaque_box | ty_opaque_closure_ptr(_) => {\n+      ty_type | ty_opaque_closure_ptr(_) => {\n         ::util::ppaux::ty_to_str(cx, t)\n       }\n \n@@ -4890,13 +4871,12 @@ pub fn hash_crate_independent(tcx: ctxt, t: t, local_hash: @str) -> u64 {\n             ty_infer(_) => unreachable!(),\n             ty_err => hash.input([23]),\n             ty_type => hash.input([24]),\n-            ty_opaque_box => hash.input([25]),\n             ty_opaque_closure_ptr(s) => {\n-                hash.input([26]);\n+                hash.input([25]);\n                 iter(&mut hash, &s);\n             }\n             ty_unboxed_vec(m) => {\n-                hash.input([27]);\n+                hash.input([26]);\n                 mt(&mut hash, m);\n             }\n         }"}, {"sha": "bd1f091b9d6aab8960de413aa4a2db990cd91bac", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -190,7 +190,7 @@ pub fn super_fold_sty<T:TypeFolder>(this: &mut T,\n         ty::ty_int(_) | ty::ty_uint(_) |\n         ty::ty_float(_) | ty::ty_type |\n         ty::ty_opaque_closure_ptr(_) |\n-        ty::ty_err | ty::ty_opaque_box | ty::ty_infer(_) |\n+        ty::ty_err | ty::ty_infer(_) |\n         ty::ty_param(..) | ty::ty_self(_) => {\n             (*sty).clone()\n         }"}, {"sha": "00f8eb6daebb398dc390d1dabcde988d1239f89e", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 11, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -791,7 +791,7 @@ impl<'a> LookupContext<'a> {\n             ty_err => None,\n \n             ty_opaque_closure_ptr(_) | ty_unboxed_vec(_) |\n-            ty_opaque_box | ty_type | ty_infer(TyVar(_)) => {\n+            ty_type | ty_infer(TyVar(_)) => {\n                 self.bug(format!(\"Unexpected type: {}\",\n                               self.ty_to_str(self_ty)));\n             }\n@@ -1020,8 +1020,6 @@ impl<'a> LookupContext<'a> {\n         });\n         debug!(\"after replacing bound regions, fty={}\", self.ty_to_str(fty));\n \n-        let self_mode = get_mode_from_explicit_self(candidate.method_ty.explicit_self);\n-\n         // before we only checked whether self_ty could be a subtype\n         // of rcvr_ty; now we actually make it so (this may cause\n         // variables to unify etc).  Since we checked beforehand, and\n@@ -1041,7 +1039,6 @@ impl<'a> LookupContext<'a> {\n         self.fcx.write_substs(self.callee_id, all_substs);\n         method_map_entry {\n             self_ty: transformed_self_ty,\n-            self_mode: self_mode,\n             explicit_self: candidate.method_ty.explicit_self,\n             origin: candidate.origin,\n         }\n@@ -1375,13 +1372,6 @@ impl<'a> LookupContext<'a> {\n     }\n }\n \n-pub fn get_mode_from_explicit_self(explicit_self: ast::ExplicitSelf_) -> SelfMode {\n-    match explicit_self {\n-        SelfValue(_) => ty::ByRef,\n-        _ => ty::ByCopy,\n-    }\n-}\n-\n impl Repr for RcvrMatchCondition {\n     fn repr(&self, tcx: ty::ctxt) -> ~str {\n         match *self {"}, {"sha": "6e944e82a023a13845514eb9cf300bbb43100cdd", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -21,7 +21,7 @@ use middle::ty::get;\n use middle::ty::{ImplContainer, lookup_item_type, subst};\n use middle::ty::{substs, t, ty_bool, ty_char, ty_bot, ty_box, ty_enum, ty_err};\n use middle::ty::{ty_str, ty_vec, ty_float, ty_infer, ty_int, ty_nil};\n-use middle::ty::{ty_opaque_box, ty_param, ty_param_bounds_and_ty, ty_ptr};\n+use middle::ty::{ty_param, ty_param_bounds_and_ty, ty_ptr};\n use middle::ty::{ty_rptr, ty_self, ty_struct, ty_trait, ty_tup};\n use middle::ty::{ty_type, ty_uint, ty_uniq, ty_bare_fn, ty_closure};\n use middle::ty::{ty_opaque_closure_ptr, ty_unboxed_vec};\n@@ -83,7 +83,7 @@ pub fn get_base_type(inference_context: @InferCtxt,\n \n         ty_nil | ty_bot | ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_closure(..) | ty_tup(..) |\n-        ty_infer(..) | ty_param(..) | ty_self(..) | ty_type | ty_opaque_box |\n+        ty_infer(..) | ty_param(..) | ty_self(..) | ty_type |\n         ty_opaque_closure_ptr(..) | ty_unboxed_vec(..) | ty_err | ty_box(_) |\n         ty_uniq(_) | ty_ptr(_) | ty_rptr(_, _) => {\n             debug!(\"(getting base type) no base type; found {:?}\","}, {"sha": "0a7f7303a3724610202261a1580b96cdd245d818", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -148,9 +148,6 @@ pub struct method_map_entry {\n     // (FIXME #3446)\n     self_ty: ty::t,\n \n-    // the mode of `self`\n-    self_mode: ty::SelfMode,\n-\n     // the type of explicit self on the method\n     explicit_self: ast::ExplicitSelf_,\n "}, {"sha": "509836512c09dcfe8ebc905432f098ff3c6980ff", "filename": "src/librustc/middle/typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fvariance.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -693,8 +693,7 @@ impl<'a> ConstraintContext<'a> {\n             }\n \n             ty::ty_infer(..) | ty::ty_err | ty::ty_type |\n-            ty::ty_opaque_box | ty::ty_opaque_closure_ptr(..) |\n-            ty::ty_unboxed_vec(..) => {\n+            ty::ty_opaque_closure_ptr(..) | ty::ty_unboxed_vec(..) => {\n                 self.tcx().sess.bug(\n                     format!(\"Unexpected type encountered in \\\n                             variance inference: {}\","}, {"sha": "84dece87750a030629a5d2f7710779c735f78119", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -18,7 +18,7 @@ use middle::ty::{ReFree, ReScope, ReInfer, ReStatic, Region,\n                  ReEmpty};\n use middle::ty::{ty_bool, ty_char, ty_bot, ty_box, ty_struct, ty_enum};\n use middle::ty::{ty_err, ty_str, ty_vec, ty_float, ty_bare_fn, ty_closure};\n-use middle::ty::{ty_nil, ty_opaque_box, ty_opaque_closure_ptr, ty_param};\n+use middle::ty::{ty_nil, ty_opaque_closure_ptr, ty_param};\n use middle::ty::{ty_ptr, ty_rptr, ty_self, ty_tup, ty_type, ty_uniq};\n use middle::ty::{ty_trait, ty_int};\n use middle::ty::{ty_uint, ty_unboxed_vec, ty_infer};\n@@ -505,7 +505,6 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         vstore_ty_to_str(cx, mt, vs)\n       }\n       ty_str(vs) => format!(\"{}{}\", vstore_to_str(cx, vs), \"str\"),\n-      ty_opaque_box => ~\"@?\",\n       ty_opaque_closure_ptr(ast::BorrowedSigil) => ~\"&closure\",\n       ty_opaque_closure_ptr(ast::ManagedSigil) => ~\"@closure\",\n       ty_opaque_closure_ptr(ast::OwnedSigil) => ~\"~closure\","}, {"sha": "f2482474073e027ca44bd8502f72a88830412ab5", "filename": "src/test/run-pass/self-in-mut-slot-immediate-value.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08ac616d379bb181e55b08f88e8c5342ee8d63a2/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fself-in-mut-slot-immediate-value.rs?ref=08ac616d379bb181e55b08f88e8c5342ee8d63a2", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Assert that `mut self` on an immediate value doesn't\n+// allow mutating the original - issue #10615.\n+\n+struct Value {\n+    n: int\n+}\n+\n+impl Value {\n+    fn squared(mut self) -> Value {\n+        self.n *= self.n;\n+        self\n+    }\n+}\n+\n+pub fn main() {\n+    let x = Value { n: 3 };\n+    let y = x.squared();\n+    assert_eq!(x.n, 3);\n+    assert_eq!(y.n, 9);\n+}"}]}