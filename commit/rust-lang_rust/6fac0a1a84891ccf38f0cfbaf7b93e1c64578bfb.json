{"sha": "6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZmYWMwYTFhODQ4OTFjY2YzOGYwY2ZiYWY3YjkzZTFjNjQ1NzhiZmI=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-20T00:48:41Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2016-12-21T03:04:43Z"}, "message": "Change *.fcx.ccx to *.ccx", "tree": {"sha": "7e9e5290a6d294ce227ce07c67c572e2cefdf9c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e9e5290a6d294ce227ce07c67c572e2cefdf9c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "html_url": "https://github.com/rust-lang/rust/commit/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15c9e5e35bc3a9675c476ae10eb656df2c2c14ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/15c9e5e35bc3a9675c476ae10eb656df2c2c14ed", "html_url": "https://github.com/rust-lang/rust/commit/15c9e5e35bc3a9675c476ae10eb656df2c2c14ed"}], "stats": {"total": 75, "additions": 34, "deletions": 41}, "files": [{"sha": "3f5cbd68042480a9c35b794fc41a4844ca2dac48", "filename": "src/librustc_trans/base.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fbase.rs?ref=6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "patch": "@@ -424,7 +424,7 @@ pub fn load_ty<'a, 'tcx>(b: &Builder<'a, 'tcx>, ptr: ValueRef, t: Ty<'tcx>) -> V\n pub fn store_ty<'a, 'tcx>(cx: &BlockAndBuilder<'a, 'tcx>, v: ValueRef, dst: ValueRef, t: Ty<'tcx>) {\n     debug!(\"store_ty: {:?} : {:?} <- {:?}\", Value(dst), t, Value(v));\n \n-    if common::type_is_fat_ptr(cx.ccx(), t) {\n+    if common::type_is_fat_ptr(cx.ccx, t) {\n         let lladdr = cx.extract_value(v, abi::FAT_PTR_ADDR);\n         let llextra = cx.extract_value(v, abi::FAT_PTR_EXTRA);\n         store_fat_ptr(cx, lladdr, llextra, dst, t);\n@@ -656,7 +656,7 @@ pub fn trans_ctor_shim<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n         if let Some(cast_ty) = fcx.fn_ty.ret.cast {\n             let load = bcx.load(bcx.pointercast(dest, cast_ty.ptr_to()));\n-            let llalign = llalign_of_min(fcx.ccx, fcx.fn_ty.ret.ty);\n+            let llalign = llalign_of_min(ccx, fcx.fn_ty.ret.ty);\n             unsafe {\n                 llvm::LLVMSetAlignment(load, llalign);\n             }"}, {"sha": "67dc347f21fedb09f0c0765dc4f3aeafa4accdaa", "filename": "src/librustc_trans/cleanup.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcleanup.rs?ref=6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "patch": "@@ -175,9 +175,7 @@ impl<'tcx> CleanupScope<'tcx> {\n             // The landing pad return type (the type being propagated). Not sure\n             // what this represents but it's determined by the personality\n             // function and this is what the EH proposal example uses.\n-            let llretty = Type::struct_(fcx.ccx,\n-                                        &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)],\n-                                        false);\n+            let llretty = Type::struct_(fcx.ccx, &[Type::i8p(fcx.ccx), Type::i32(fcx.ccx)], false);\n \n             // The only landing pad clause will be 'cleanup'\n             let llretval = pad_bcx.landing_pad(llretty, llpersonality, 1, pad_bcx.fcx().llfn);"}, {"sha": "f022aa50184c798cbbff968b881a278739298a5e", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "patch": "@@ -421,17 +421,14 @@ impl<'a, 'tcx> BlockAndBuilder<'a, 'tcx> {\n         r\n     }\n \n-    pub fn ccx(&self) -> &'a CrateContext<'a, 'tcx> {\n-        self.fcx.ccx\n-    }\n     pub fn fcx(&self) -> &'a FunctionContext<'a, 'tcx> {\n         self.fcx\n     }\n     pub fn tcx(&self) -> TyCtxt<'a, 'tcx, 'tcx> {\n-        self.fcx.ccx.tcx()\n+        self.ccx.tcx()\n     }\n     pub fn sess(&self) -> &'a Session {\n-        self.fcx.ccx.sess()\n+        self.ccx.sess()\n     }\n \n     pub fn llbb(&self) -> BasicBlockRef {"}, {"sha": "c9690ee0d1b972edcf7a4ad4be0d29189b323b7a", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "patch": "@@ -474,7 +474,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n         }\n     }\n \n-    let value = if cx.ccx().shared().type_is_sized(t) {\n+    let value = if cx.ccx.shared().type_is_sized(t) {\n         adt::MaybeSizedValue::sized(av)\n     } else {\n         // FIXME(#36457) -- we should pass unsized values as two arguments\n@@ -493,7 +493,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n         }\n         ty::TyArray(_, n) => {\n             let base = get_dataptr(&cx, value.value);\n-            let len = C_uint(cx.ccx(), n);\n+            let len = C_uint(cx.ccx, n);\n             let unit_ty = t.sequence_element_type(cx.tcx());\n             cx = tvec::slice_for_each(&cx, base, unit_ty, len, |bb, vv| drop_ty(bb, vv, unit_ty));\n         }\n@@ -514,7 +514,7 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                 for (i, &Field(_, field_ty)) in fields.iter().enumerate() {\n                     let llfld_a = adt::trans_field_ptr(&cx, t, value, Disr::from(discr), i);\n \n-                    let val = if cx.ccx().shared().type_is_sized(field_ty) {\n+                    let val = if cx.ccx.shared().type_is_sized(field_ty) {\n                         llfld_a\n                     } else {\n                         // FIXME(#36457) -- we should pass unsized values as two arguments\n@@ -530,8 +530,6 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                 bug!(\"Union in `glue::drop_structural_ty`\");\n             }\n             AdtKind::Enum => {\n-                let fcx = cx.fcx();\n-                let ccx = fcx.ccx;\n                 let n_variants = adt.variants.len();\n \n                 // NB: we must hit the discriminant first so that structural\n@@ -562,23 +560,23 @@ fn drop_structural_ty<'a, 'tcx>(cx: BlockAndBuilder<'a, 'tcx>,\n                         // from the outer function, and any other use case will only\n                         // call this for an already-valid enum in which case the `ret\n                         // void` will never be hit.\n-                        let ret_void_cx = fcx.build_new_block(\"enum-iter-ret-void\");\n+                        let ret_void_cx = cx.fcx().build_new_block(\"enum-iter-ret-void\");\n                         ret_void_cx.ret_void();\n                         let llswitch = cx.switch(lldiscrim_a, ret_void_cx.llbb(), n_variants);\n-                        let next_cx = fcx.build_new_block(\"enum-iter-next\");\n+                        let next_cx = cx.fcx().build_new_block(\"enum-iter-next\");\n \n                         for variant in &adt.variants {\n                             let variant_cx_name = format!(\"enum-iter-variant-{}\",\n                                 &variant.disr_val.to_string());\n-                            let variant_cx = fcx.build_new_block(&variant_cx_name);\n+                            let variant_cx = cx.fcx().build_new_block(&variant_cx_name);\n                             let case_val = adt::trans_case(&cx, t, Disr::from(variant.disr_val));\n                             variant_cx.add_case(llswitch, case_val, variant_cx.llbb());\n                             iter_variant(&variant_cx, t, value, variant, substs);\n                             variant_cx.br(next_cx.llbb());\n                         }\n                         cx = next_cx;\n                     }\n-                    _ => ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n+                    _ => cx.ccx.sess().unimpl(\"value from adt::trans_switch in drop_structural_ty\"),\n                 }\n             }\n         },"}, {"sha": "8df24da7135887e4ecdea99dfcf1467ce2d7bc5b", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "patch": "@@ -33,13 +33,13 @@ pub fn lvalue_locals<'a, 'tcx>(mircx: &MirContext<'a, 'tcx>) -> BitVector {\n             ty.is_unique() ||\n             ty.is_region_ptr() ||\n             ty.is_simd() ||\n-            common::type_is_zero_size(mircx.fcx.ccx, ty)\n+            common::type_is_zero_size(mircx.ccx, ty)\n         {\n             // These sorts of types are immediates that we can store\n             // in an ValueRef without an alloca.\n-            assert!(common::type_is_immediate(mircx.fcx.ccx, ty) ||\n-                    common::type_is_fat_ptr(mircx.fcx.ccx, ty));\n-        } else if common::type_is_imm_pair(mircx.fcx.ccx, ty) {\n+            assert!(common::type_is_immediate(mircx.ccx, ty) ||\n+                    common::type_is_fat_ptr(mircx.ccx, ty));\n+        } else if common::type_is_imm_pair(mircx.ccx, ty) {\n             // We allow pairs and uses of any of their 2 fields.\n         } else {\n             // These sorts of types require an alloca. Note that\n@@ -112,7 +112,7 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                     literal: mir::Literal::Item { def_id, .. }, ..\n                 }),\n                 ref args, ..\n-            } if Some(def_id) == self.cx.fcx.ccx.tcx().lang_items.box_free_fn() => {\n+            } if Some(def_id) == self.cx.ccx.tcx().lang_items.box_free_fn() => {\n                 // box_free(x) shares with `drop x` the property that it\n                 // is not guaranteed to be statically dominated by the\n                 // definition of x, so x must always be in an alloca.\n@@ -135,10 +135,10 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n         // Allow uses of projections of immediate pair fields.\n         if let mir::Lvalue::Projection(ref proj) = *lvalue {\n             if let mir::Lvalue::Local(_) = proj.base {\n-                let ty = proj.base.ty(self.cx.mir, self.cx.fcx.ccx.tcx());\n+                let ty = proj.base.ty(self.cx.mir, self.cx.ccx.tcx());\n \n-                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.fcx.ccx.tcx()));\n-                if common::type_is_imm_pair(self.cx.fcx.ccx, ty) {\n+                let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n+                if common::type_is_imm_pair(self.cx.ccx, ty) {\n                     if let mir::ProjectionElem::Field(..) = proj.elem {\n                         if let LvalueContext::Consume = context {\n                             return;\n@@ -166,11 +166,11 @@ impl<'mir, 'a, 'tcx> Visitor<'tcx> for LocalAnalyzer<'mir, 'a, 'tcx> {\n                 }\n \n                 LvalueContext::Drop => {\n-                    let ty = lvalue.ty(self.cx.mir, self.cx.fcx.ccx.tcx());\n-                    let ty = self.cx.monomorphize(&ty.to_ty(self.cx.fcx.ccx.tcx()));\n+                    let ty = lvalue.ty(self.cx.mir, self.cx.ccx.tcx());\n+                    let ty = self.cx.monomorphize(&ty.to_ty(self.cx.ccx.tcx()));\n \n                     // Only need the lvalue if we're actually dropping it.\n-                    if self.cx.fcx.ccx.shared().type_needs_drop(ty) {\n+                    if self.cx.ccx.shared().type_needs_drop(ty) {\n                         self.mark_as_lvalue(index);\n                     }\n                 }"}, {"sha": "b4e9d301039b9e172d4821c39f8aa648f4cae4fa", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "patch": "@@ -838,7 +838,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n             return block;\n         }\n \n-        if base::wants_msvc_seh(self.fcx.ccx.sess()) {\n+        if base::wants_msvc_seh(self.ccx.sess()) {\n             return self.blocks[target_bb];\n         }\n "}, {"sha": "0cd7f007c5df92dda45b67fee48d100b808ac524", "filename": "src/librustc_trans/mir/lvalue.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fmir%2Flvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Flvalue.rs?ref=6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "patch": "@@ -140,7 +140,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                             LvalueTy::Downcast { adt_def: _, substs: _, variant_index: v } => v,\n                         };\n                         let discr = discr as u64;\n-                        let is_sized = self.fcx.ccx.shared().type_is_sized(projected_ty.to_ty(tcx));\n+                        let is_sized = self.ccx.shared().type_is_sized(projected_ty.to_ty(tcx));\n                         let base = if is_sized {\n                             adt::MaybeSizedValue::sized(tr_base.llval)\n                         } else {\n@@ -272,7 +272,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     }\n \n     pub fn monomorphized_lvalue_ty(&self, lvalue: &mir::Lvalue<'tcx>) -> Ty<'tcx> {\n-        let tcx = self.fcx.ccx.tcx();\n+        let tcx = self.ccx.tcx();\n         let lvalue_ty = lvalue.ty(&self.mir, tcx);\n         self.monomorphize(&lvalue_ty.to_ty(tcx))\n     }"}, {"sha": "04e8802cf4e95550cef4a86b0e7ca64c52a31f4a", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=6fac0a1a84891ccf38f0cfbaf7b93e1c64578bfb", "patch": "@@ -48,9 +48,10 @@ pub struct MirContext<'a, 'tcx:'a> {\n \n     debug_context: debuginfo::FunctionDebugContext,\n \n-    /// Function context\n     fcx: &'a common::FunctionContext<'a, 'tcx>,\n \n+    ccx: &'a CrateContext<'a, 'tcx>,\n+\n     /// When unwinding is initiated, we have to store this personality\n     /// value somewhere so that we can load it and re-use it in the\n     /// resume instruction. The personality is (afaik) some kind of\n@@ -100,7 +101,7 @@ pub struct MirContext<'a, 'tcx:'a> {\n impl<'a, 'tcx> MirContext<'a, 'tcx> {\n     pub fn monomorphize<T>(&self, value: &T) -> T\n         where T: TransNormalize<'tcx> {\n-        monomorphize::apply_param_substs(self.fcx.ccx.shared(), self.param_substs, value)\n+        monomorphize::apply_param_substs(self.ccx.shared(), self.param_substs, value)\n     }\n \n     pub fn set_debug_loc(&mut self, bcx: &BlockAndBuilder, source_info: mir::SourceInfo) {\n@@ -123,12 +124,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         // (unless the crate is being compiled with `-Z debug-macros`).\n         if source_info.span.expn_id == NO_EXPANSION ||\n             source_info.span.expn_id == COMMAND_LINE_EXPN ||\n-            self.fcx.ccx.sess().opts.debugging_opts.debug_macros {\n+            self.ccx.sess().opts.debugging_opts.debug_macros {\n \n             let scope = self.scope_metadata_for_loc(source_info.scope, source_info.span.lo);\n             (scope, source_info.span)\n         } else {\n-            let cm = self.fcx.ccx.sess().codemap();\n+            let cm = self.ccx.sess().codemap();\n             // Walk up the macro expansion chain until we reach a non-expanded span.\n             let mut span = source_info.span;\n             while span.expn_id != NO_EXPANSION && span.expn_id != COMMAND_LINE_EXPN {\n@@ -154,10 +155,8 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n         let scope_metadata = self.scopes[scope_id].scope_metadata;\n         if pos < self.scopes[scope_id].file_start_pos ||\n            pos >= self.scopes[scope_id].file_end_pos {\n-            let cm = self.fcx.ccx.sess().codemap();\n-            debuginfo::extend_scope_to_file(self.fcx.ccx,\n-                                            scope_metadata,\n-                                            &cm.lookup_char_pos(pos).file)\n+            let cm = self.ccx.sess().codemap();\n+            debuginfo::extend_scope_to_file(self.ccx, scope_metadata, &cm.lookup_char_pos(pos).file)\n         } else {\n             scope_metadata\n         }\n@@ -225,6 +224,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     let mut mircx = MirContext {\n         mir: mir,\n         fcx: fcx,\n+        ccx: fcx.ccx,\n         llpersonalityslot: None,\n         blocks: block_bcxs,\n         unreachable_block: None,"}]}