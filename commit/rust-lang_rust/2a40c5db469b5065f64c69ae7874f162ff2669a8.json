{"sha": "2a40c5db469b5065f64c69ae7874f162ff2669a8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNDBjNWRiNDY5YjUwNjVmNjRjNjlhZTc4NzRmMTYyZmYyNjY5YTg=", "commit": {"author": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-06-29T14:43:39Z"}, "committer": {"name": "Bj\u00f6rn Steinbrink", "email": "bsteinbr@gmail.com", "date": "2013-06-29T15:08:20Z"}, "message": "Avoid extra casts for \"self\" arguments\n\n\"self\" is always passed as an opaque box, so there's no point in using\nthe concrete self type when translating the argument. All it does it\ncausing the value to be casted back to an opaque box right away.", "tree": {"sha": "947c185ff38fe67420150432167c069fd050905a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/947c185ff38fe67420150432167c069fd050905a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a40c5db469b5065f64c69ae7874f162ff2669a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a40c5db469b5065f64c69ae7874f162ff2669a8", "html_url": "https://github.com/rust-lang/rust/commit/2a40c5db469b5065f64c69ae7874f162ff2669a8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a40c5db469b5065f64c69ae7874f162ff2669a8/comments", "author": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dotdash", "id": 230962, "node_id": "MDQ6VXNlcjIzMDk2Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/230962?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dotdash", "html_url": "https://github.com/dotdash", "followers_url": "https://api.github.com/users/dotdash/followers", "following_url": "https://api.github.com/users/dotdash/following{/other_user}", "gists_url": "https://api.github.com/users/dotdash/gists{/gist_id}", "starred_url": "https://api.github.com/users/dotdash/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dotdash/subscriptions", "organizations_url": "https://api.github.com/users/dotdash/orgs", "repos_url": "https://api.github.com/users/dotdash/repos", "events_url": "https://api.github.com/users/dotdash/events{/privacy}", "received_events_url": "https://api.github.com/users/dotdash/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "08a5278bb5cd11d7a4f986db627a585bdad878d7", "url": "https://api.github.com/repos/rust-lang/rust/commits/08a5278bb5cd11d7a4f986db627a585bdad878d7", "html_url": "https://github.com/rust-lang/rust/commit/08a5278bb5cd11d7a4f986db627a585bdad878d7"}], "stats": {"total": 38, "additions": 8, "deletions": 30}, "files": [{"sha": "6d139130e2be9cc6153eaf50dcec90e2bd4daff7", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/2a40c5db469b5065f64c69ae7874f162ff2669a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a40c5db469b5065f64c69ae7874f162ff2669a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=2a40c5db469b5065f64c69ae7874f162ff2669a8", "patch": "@@ -615,10 +615,7 @@ pub fn trans_call_inner(in_cx: block,\n                 }\n                 Method(d) => {\n                     // Weird but true: we pass self in the *environment* slot!\n-                    let llself = PointerCast(bcx,\n-                                             d.llself,\n-                                             Type::opaque_box(ccx).ptr_to());\n-                    (d.llfn, llself)\n+                    (d.llfn, d.llself)\n                 }\n                 Closure(d) => {\n                     // Closures are represented as (llfn, llclosure) pair:\n@@ -944,10 +941,6 @@ pub fn trans_arg_expr(bcx: block,\n         if formal_arg_ty != arg_datum.ty {\n             // this could happen due to e.g. subtyping\n             let llformal_arg_ty = type_of::type_of_explicit_arg(ccx, &formal_arg_ty);\n-            let llformal_arg_ty = match self_mode {\n-                ty::ByRef => llformal_arg_ty.ptr_to(),\n-                ty::ByCopy => llformal_arg_ty,\n-            };\n             debug!(\"casting actual type (%s) to match formal (%s)\",\n                    bcx.val_to_str(val), bcx.llty_str(llformal_arg_ty));\n             val = PointerCast(bcx, val, llformal_arg_ty);"}, {"sha": "fa32dd5b93ef4a3425b49e7fd76585dad8e25991", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 7, "deletions": 22, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2a40c5db469b5065f64c69ae7874f162ff2669a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a40c5db469b5065f64c69ae7874f162ff2669a8/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=2a40c5db469b5065f64c69ae7874f162ff2669a8", "patch": "@@ -133,8 +133,8 @@ pub fn trans_self_arg(bcx: block,\n     let _icx = push_ctxt(\"impl::trans_self_arg\");\n     let mut temp_cleanups = ~[];\n \n-    // Compute the type of self.\n-    let self_ty = monomorphize_type(bcx, mentry.self_ty);\n+    // self is passed as an opaque box in the environment slot\n+    let self_ty = ty::mk_opaque_box(bcx.tcx());\n     let result = trans_arg_expr(bcx,\n                                 self_ty,\n                                 mentry.self_mode,\n@@ -576,7 +576,6 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n     let llbox = Load(bcx, GEPi(bcx, llpair, [0u, abi::trt_field_box]));\n \n     // Munge `llself` appropriately for the type of `self` in the method.\n-    let self_mode;\n     match explicit_self {\n         ast::sty_static => {\n             bcx.tcx().sess.bug(\"shouldn't see static method here\");\n@@ -597,12 +596,6 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n                     llself = llbox;\n                 }\n             }\n-\n-            let llscratch = alloca(bcx, val_ty(llself));\n-            Store(bcx, llself, llscratch);\n-            llself = llscratch;\n-\n-            self_mode = ty::ByRef;\n         }\n         ast::sty_box(_) => {\n             // Bump the reference count on the box.\n@@ -615,28 +608,20 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n                 ty::BoxTraitStore => llself = llbox,\n                 _ => bcx.tcx().sess.bug(\"@self receiver with non-@Trait\")\n             }\n-\n-            let llscratch = alloca(bcx, val_ty(llself));\n-            Store(bcx, llself, llscratch);\n-            llself = llscratch;\n-\n-            self_mode = ty::ByRef;\n         }\n         ast::sty_uniq(_) => {\n             // Pass the unique pointer.\n             match store {\n                 ty::UniqTraitStore => llself = llbox,\n                 _ => bcx.tcx().sess.bug(\"~self receiver with non-~Trait\")\n             }\n-\n-            let llscratch = alloca(bcx, val_ty(llself));\n-            Store(bcx, llself, llscratch);\n-            llself = llscratch;\n-\n-            self_mode = ty::ByRef;\n         }\n     }\n \n+    let llscratch = alloca(bcx, val_ty(llself));\n+    Store(bcx, llself, llscratch);\n+    llself = PointerCast(bcx, llscratch, Type::opaque_box(ccx).ptr_to());\n+\n     // Load the function from the vtable and cast it to the expected type.\n     debug!(\"(translating trait callee) loading method\");\n     let llcallee_ty = type_of_fn_from_ty(ccx, callee_ty);\n@@ -652,7 +637,7 @@ pub fn trans_trait_callee_from_llval(bcx: block,\n             llfn: mptr,\n             llself: llself,\n             self_ty: ty::mk_opaque_box(bcx.tcx()),\n-            self_mode: self_mode,\n+            self_mode: ty::ByRef,\n             explicit_self: explicit_self\n             /* XXX: Some(llbox) */\n         })"}]}