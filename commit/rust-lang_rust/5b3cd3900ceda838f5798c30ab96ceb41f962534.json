{"sha": "5b3cd3900ceda838f5798c30ab96ceb41f962534", "node_id": "MDY6Q29tbWl0NzI0NzEyOjViM2NkMzkwMGNlZGE4MzhmNTc5OGMzMGFiOTZjZWI0MWY5NjI1MzQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-08T05:35:51Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-08T05:35:51Z"}, "message": "auto merge of #20733 : alexcrichton/rust/rollup, r=alexcrichton", "tree": {"sha": "7593bacffb7c8111eee7fa2a0a05d0357ccba763", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7593bacffb7c8111eee7fa2a0a05d0357ccba763"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5b3cd3900ceda838f5798c30ab96ceb41f962534", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5b3cd3900ceda838f5798c30ab96ceb41f962534", "html_url": "https://github.com/rust-lang/rust/commit/5b3cd3900ceda838f5798c30ab96ceb41f962534", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5b3cd3900ceda838f5798c30ab96ceb41f962534/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f1ead8fadc56bad30dc74f5cc50d78af4fbc972", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f1ead8fadc56bad30dc74f5cc50d78af4fbc972", "html_url": "https://github.com/rust-lang/rust/commit/9f1ead8fadc56bad30dc74f5cc50d78af4fbc972"}, {"sha": "0abf4583486071a958aa1bd14ab8c5b8870fb74d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0abf4583486071a958aa1bd14ab8c5b8870fb74d", "html_url": "https://github.com/rust-lang/rust/commit/0abf4583486071a958aa1bd14ab8c5b8870fb74d"}], "stats": {"total": 11076, "additions": 6281, "deletions": 4795}, "files": [{"sha": "61c737e0fd3afcca25d862fd1d1ac788ca71218a", "filename": "configure", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/configure", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -599,6 +599,18 @@ then\n fi\n putvar CFG_RELEASE_CHANNEL\n \n+# A magic value that allows the compiler to use unstable features\n+# during the bootstrap even when doing so would normally be an error\n+# because of feature staging or because the build turns on\n+# warnings-as-errors and unstable features default to warnings.  The\n+# build has to match this key in an env var. Meant to be a mild\n+# deterrent from users just turning on unstable features on the stable\n+# channel.\n+# Basing CFG_BOOTSTRAP_KEY on CFG_BOOTSTRAP_KEY lets it get picked up\n+# during a Makefile reconfig.\n+CFG_BOOTSTRAP_KEY=\"${CFG_BOOTSTRAP_KEY-`date +%N`}\"\n+putvar CFG_BOOTSTRAP_KEY\n+\n step_msg \"looking for build programs\"\n \n probe_need CFG_PERL        perl"}, {"sha": "99aecc34be9731951003a76d745a8eaf12aab4b4", "filename": "mk/main.mk", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/mk%2Fmain.mk", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/mk%2Fmain.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fmain.mk?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -25,11 +25,13 @@ ifeq ($(CFG_RELEASE_CHANNEL),stable)\n CFG_RELEASE=$(CFG_RELEASE_NUM)\n # This is the string used in dist artifact file names, e.g. \"0.12.0\", \"nightly\"\n CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)\n+CFG_DISABLE_UNSTABLE_FEATURES=1\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),beta)\n # The beta channel is temporarily called 'alpha'\n CFG_RELEASE=$(CFG_RELEASE_NUM)-alpha$(CFG_BETA_CYCLE)\n CFG_PACKAGE_VERS=$(CFG_RELEASE_NUM)-alpha$(CFG_BETA_CYCLE)\n+CFG_DISABLE_UNSTABLE_FEATURES=1\n endif\n ifeq ($(CFG_RELEASE_CHANNEL),nightly)\n CFG_RELEASE=$(CFG_RELEASE_NUM)-nightly\n@@ -121,11 +123,9 @@ CFG_JEMALLOC_FLAGS += $(JEMALLOC_FLAGS)\n \n ifdef CFG_DISABLE_DEBUG\n   CFG_RUSTC_FLAGS += --cfg ndebug\n-  CFG_GCCISH_CFLAGS += -DRUST_NDEBUG\n else\n   $(info cfg: enabling more debugging (CFG_ENABLE_DEBUG))\n   CFG_RUSTC_FLAGS += --cfg debug\n-  CFG_GCCISH_CFLAGS += -DRUST_DEBUG\n endif\n \n ifdef SAVE_TEMPS\n@@ -319,11 +319,20 @@ export CFG_VERSION_WIN\n export CFG_RELEASE\n export CFG_PACKAGE_NAME\n export CFG_BUILD\n+export CFG_RELEASE_CHANNEL\n export CFG_LLVM_ROOT\n export CFG_PREFIX\n export CFG_LIBDIR\n export CFG_LIBDIR_RELATIVE\n export CFG_DISABLE_INJECT_STD_VERSION\n+ifdef CFG_DISABLE_UNSTABLE_FEATURES\n+CFG_INFO := $(info cfg: disabling unstable features (CFG_DISABLE_UNSTABLE_FEATURES))\n+# Turn on feature-staging\n+export CFG_DISABLE_UNSTABLE_FEATURES\n+endif\n+# Subvert unstable feature lints to do the self-build\n+export CFG_BOOTSTRAP_KEY\n+export RUSTC_BOOTSTRAP_KEY:=$(CFG_BOOTSTRAP_KEY)\n \n ######################################################################\n # Per-stage targets and runner"}, {"sha": "9a5665e68393473f4b0e9872de5a2f6c71d332c5", "filename": "src/compiletest/compiletest.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fcompiletest%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fcompiletest%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fcompiletest.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -9,7 +9,9 @@\n // except according to those terms.\n \n #![crate_type = \"bin\"]\n+#![allow(unknown_features)]\n #![feature(slicing_syntax, unboxed_closures)]\n+#![feature(box_syntax)]\n \n #![deny(warnings)]\n "}, {"sha": "5de93c52029226503abbeee5d715f139e36057ca", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -908,8 +908,7 @@ fn check_error_patterns(props: &TestProps,\n     }\n     if done { return; }\n \n-    let missing_patterns =\n-        props.error_patterns.index(&(next_err_idx..));\n+    let missing_patterns = &props.error_patterns[next_err_idx..];\n     if missing_patterns.len() == 1u {\n         fatal_proc_rec(format!(\"error pattern '{}' not found!\",\n                               missing_patterns[0]).as_slice(),"}, {"sha": "f32f2fd443f8e71bff708a5d6d349e461ac1375b", "filename": "src/doc/footer.inc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Ffooter.inc", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Ffooter.inc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ffooter.inc?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -1,5 +1,5 @@\n <footer><p>\n-Copyright &copy; 2011-2014 The Rust Project Developers. Licensed under the\n+Copyright &copy; 2011-2015 The Rust Project Developers. Licensed under the\n <a href=\"http://www.apache.org/licenses/LICENSE-2.0\">Apache License, Version 2.0</a>\n or the <a href=\"http://opensource.org/licenses/MIT\">MIT license</a>, at your option.\n </p><p>"}, {"sha": "98b46511f04584fbfff7f5d6be4b11a8ed28b40e", "filename": "src/doc/guide-error-handling.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-error-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-error-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-error-handling.md?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -147,10 +147,10 @@ for all but the most trivial of situations.\n Here's an example of using `Result`:\n \n ```rust\n-#[deriving(Show)]\n+#[derive(Show)]\n enum Version { Version1, Version2 }\n \n-#[deriving(Show)]\n+#[derive(Show)]\n enum ParseError { InvalidHeaderLength, InvalidVersion }\n \n fn parse_version(header: &[u8]) -> Result<Version, ParseError> {"}, {"sha": "1f12c05f37e34475d9f892eae3274c1f1220343e", "filename": "src/doc/guide-ffi.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-ffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-ffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ffi.md?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -262,6 +262,7 @@ referenced Rust object.\n Rust code:\n \n ~~~~no_run\n+# use std::boxed::Box;\n \n #[repr(C)]\n struct RustObject {\n@@ -286,7 +287,7 @@ extern {\n \n fn main() {\n     // Create the object that will be referenced in the callback\n-    let mut rust_object = box RustObject { a: 5 };\n+    let mut rust_object = Box::new(RustObject { a: 5 });\n \n     unsafe {\n         register_callback(&mut *rust_object, callback);"}, {"sha": "3db4da73f932ebf73d8c13a909ffd8d6702a2eff", "filename": "src/doc/guide-ownership.md", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-ownership.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-ownership.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-ownership.md?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -81,27 +81,29 @@ therefore deallocates the memory for you. Here's the equivalent example in\n Rust:\n \n ```rust\n+# use std::boxed::Box;\n {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n }\n ```\n \n-The `box` keyword creates a `Box<T>` (specifically `Box<int>` in this case) by\n-allocating a small segment of memory on the heap with enough space to fit an\n-`int`. But where in the code is the box deallocated? We said before that we\n-must have a deallocation for each allocation. Rust handles this for you. It\n+The `Box::new` function creates a `Box<T>` (specifically `Box<int>` in this\n+case) by allocating a small segment of memory on the heap with enough space to\n+fit an `int`. But where in the code is the box deallocated? We said before that\n+we must have a deallocation for each allocation. Rust handles this for you. It\n knows that our handle, `x`, is the owning reference to our box. Rust knows that\n `x` will go out of scope at the end of the block, and so it inserts a call to\n deallocate the memory at the end of the scope. Because the compiler does this\n-for us, it's impossible to forget. We always have exactly one deallocation paired\n-with each of our allocations.\n+for us, it's impossible to forget. We always have exactly one deallocation\n+  paired with each of our allocations.\n \n This is pretty straightforward, but what happens when we want to pass our box\n to a function? Let's look at some code:\n \n ```rust\n+# use std::boxed::Box;\n fn main() {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n \n     add_one(x);\n }\n@@ -115,8 +117,9 @@ This code works, but it's not ideal. For example, let's add one more line of\n code, where we print out the value of `x`:\n \n ```{rust,ignore}\n+# use std::boxed::Box;\n fn main() {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n \n     add_one(x);\n \n@@ -148,8 +151,9 @@ To fix this, we can have `add_one` give ownership back when it's done with the\n box:\n \n ```rust\n+# use std::boxed::Box;\n fn main() {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n \n     let y = add_one(x);\n \n@@ -458,7 +462,7 @@ lifetime, and so if you elide a lifetime (like `&T` instead of `&'a T`), Rust\n will do three things to determine what those lifetimes should be.\n \n When talking about lifetime elision, we use the term 'input lifetime' and\n-'output lifetime'. An 'input liftime' is a lifetime associated with a parameter\n+'output lifetime'. An 'input lifetime' is a lifetime associated with a parameter\n of a function, and an 'output lifetime' is a lifetime associated with the return\n value of a function. For example, this function has an input lifetime:\n "}, {"sha": "4c35fae3ecc51d22b7a52a34b545f8e476da8456", "filename": "src/doc/guide-pointers.md", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-pointers.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-pointers.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-pointers.md?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -455,12 +455,13 @@ fn rc_succ(x: Rc<int>) -> int { *x + 1 }\n Note that the caller of your function will have to modify their calls slightly:\n \n ```{rust}\n+# use std::boxed::Box;\n use std::rc::Rc;\n \n fn succ(x: &int) -> int { *x + 1 }\n \n let ref_x = &5i;\n-let box_x = box 5i;\n+let box_x = Box::new(5i);\n let rc_x  = Rc::new(5i);\n \n succ(ref_x);\n@@ -477,24 +478,17 @@ those contents.\n heap allocation in Rust. Creating a box looks like this:\n \n ```{rust}\n-let x = box(std::boxed::HEAP) 5i;\n+# use std::boxed::Box;\n+let x = Box::new(5i);\n ```\n \n-`box` is a keyword that does 'placement new,' which we'll talk about in a bit.\n-`box` will be useful for creating a number of heap-allocated types, but is not\n-quite finished yet. In the meantime, `box`'s type defaults to\n-`std::boxed::HEAP`, and so you can leave it off:\n-\n-```{rust}\n-let x = box 5i;\n-```\n-\n-As you might assume from the `HEAP`, boxes are heap allocated. They are\n-deallocated automatically by Rust when they go out of scope:\n+Boxes are heap allocated and they are deallocated automatically by Rust when\n+they go out of scope:\n \n ```{rust}\n+# use std::boxed::Box;\n {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n \n     // stuff happens\n \n@@ -513,8 +507,9 @@ You don't need to fully grok the theory of affine types or regions to grok\n boxes, though. As a rough approximation, you can treat this Rust code:\n \n ```{rust}\n+# use std::boxed::Box;\n {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n \n     // stuff happens\n }\n@@ -553,12 +548,13 @@ for more detail on how lifetimes work.\n Using boxes and references together is very common. For example:\n \n ```{rust}\n+# use std::boxed::Box;\n fn add_one(x: &int) -> int {\n     *x + 1\n }\n \n fn main() {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n \n     println!(\"{}\", add_one(&*x));\n }\n@@ -570,12 +566,13 @@ function, and since it's only reading the value, allows it.\n We can borrow `x` multiple times, as long as it's not simultaneous:\n \n ```{rust}\n+# use std::boxed::Box;\n fn add_one(x: &int) -> int {\n     *x + 1\n }\n \n fn main() {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n \n     println!(\"{}\", add_one(&*x));\n     println!(\"{}\", add_one(&*x));\n@@ -586,12 +583,13 @@ fn main() {\n Or as long as it's not a mutable borrow. This will error:\n \n ```{rust,ignore}\n+# use std::boxed::Box;\n fn add_one(x: &mut int) -> int {\n     *x + 1\n }\n \n fn main() {\n-    let x = box 5i;\n+    let x = Box::new(5i);\n \n     println!(\"{}\", add_one(&*x)); // error: cannot borrow immutable dereference\n                                   // of `&`-pointer as mutable\n@@ -612,22 +610,23 @@ Sometimes, you need a recursive data structure. The simplest is known as a\n \n \n ```{rust}\n-#[deriving(Show)]\n+# use std::boxed::Box;\n+#[derive(Show)]\n enum List<T> {\n     Cons(T, Box<List<T>>),\n     Nil,\n }\n \n fn main() {\n-    let list: List<int> = List::Cons(1, box List::Cons(2, box List::Cons(3, box List::Nil)));\n+    let list: List<int> = List::Cons(1, Box::new(List::Cons(2, Box::new(List::Cons(3, Box::new(List::Nil))))));\n     println!(\"{:?}\", list);\n }\n ```\n \n This prints:\n \n ```text\n-Cons(1, box Cons(2, box Cons(3, box Nil)))\n+Cons(1, Box(Cons(2, Box(Cons(3, Box(Nil))))))\n ```\n \n The reference to another `List` inside of the `Cons` enum variant must be a box,\n@@ -667,6 +666,7 @@ In many languages with pointers, you'd return a pointer from a function\n so as to avoid copying a large data structure. For example:\n \n ```{rust}\n+# use std::boxed::Box;\n struct BigStruct {\n     one: int,\n     two: int,\n@@ -675,15 +675,15 @@ struct BigStruct {\n }\n \n fn foo(x: Box<BigStruct>) -> Box<BigStruct> {\n-    return box *x;\n+    return Box::new(*x);\n }\n \n fn main() {\n-    let x = box BigStruct {\n+    let x = Box::new(BigStruct {\n         one: 1,\n         two: 2,\n         one_hundred: 100,\n-    };\n+    });\n \n     let y = foo(x);\n }\n@@ -695,6 +695,7 @@ than the hundred `int`s that make up the `BigStruct`.\n This is an antipattern in Rust. Instead, write this:\n \n ```{rust}\n+# use std::boxed::Box;\n struct BigStruct {\n     one: int,\n     two: int,\n@@ -707,13 +708,13 @@ fn foo(x: Box<BigStruct>) -> BigStruct {\n }\n \n fn main() {\n-    let x = box BigStruct {\n+    let x = Box::new(BigStruct {\n         one: 1,\n         two: 2,\n         one_hundred: 100,\n-    };\n+    });\n \n-    let y = box foo(x);\n+    let y = Box::new(foo(x));\n }\n ```\n "}, {"sha": "25ca07ad74fe87047b44e6b48ae337653832dfa6", "filename": "src/doc/guide-unsafe.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-unsafe.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide-unsafe.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide-unsafe.md?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -197,6 +197,7 @@ extern crate libc;\n use libc::{c_void, size_t, malloc, free};\n use std::mem;\n use std::ptr;\n+# use std::boxed::Box;\n \n // Define a wrapper around the handle returned by the foreign code.\n // Unique<T> has the same semantics as Box<T>\n@@ -265,7 +266,7 @@ impl<T: Send> Drop for Unique<T> {\n // A comparison between the built-in `Box` and this reimplementation\n fn main() {\n     {\n-        let mut x = box 5i;\n+        let mut x = Box::new(5i);\n         *x = 10;\n     } // `x` is freed here\n \n@@ -653,7 +654,7 @@ sugar for dynamic allocations via `malloc` and `free`:\n \n ```\n #![no_std]\n-#![feature(lang_items)]\n+#![feature(lang_items, box_syntax)]\n \n extern crate libc;\n "}, {"sha": "5ab3063033fc2123a26bbde921c9e41ba826f0e1", "filename": "src/doc/guide.md", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -3802,18 +3802,19 @@ enum List {             // error: illegal recursive enum type\n \n But the compiler complains that the type is recursive, that is, it could be\n arbitrarily large. To remedy this, Rust provides a fixed-size container called\n-a **box** that can hold any type. You can box up any value with the `box`\n-keyword. Our boxed List gets the type `Box<List>` (more on the notation when we\n+a **Box** that can hold any type. You can box up any value with the `Box::new`\n+function. Our boxed List gets the type `Box<List>` (more on the notation when we\n get to generics):\n \n ```{rust}\n+# use std::boxed::Box;\n enum List {\n     Node(u32, Box<List>),\n     Nil\n }\n \n fn main() {\n-    let list = List::Node(0, box List::Node(1, box List::Nil));\n+    let list = List::Node(0, Box::new(List::Node(1, Box::new(List::Nil))));\n }\n ```\n \n@@ -3826,8 +3827,9 @@ just like regular references. This (rather silly) example dynamically allocates\n an integer `5` and makes `x` a pointer to it:\n \n ```{rust}\n+# use std::boxed::Box;\n {\n-    let x = box 5;\n+    let x = Box::new(5);\n     println!(\"{}\", *x);     // Prints 5\n }\n ```\n@@ -3858,7 +3860,8 @@ Boxes are the sole owner of their contents, so you cannot take a mutable\n reference to them and then use the original box:\n \n ```{rust,ignore}\n-let mut x = box 5;\n+# use std::boxed::Box;\n+let mut x = Box::new(5);\n let y = &mut x;\n \n *x; // you might expect 5, but this is actually an error\n@@ -3879,7 +3882,8 @@ As long as `y` is borrowing the contents, we cannot use `x`. After `y` is\n done borrowing the value, we can use it again. This works fine:\n \n ```{rust}\n-let mut x = box 5;\n+# use std::boxed::Box;\n+let mut x = Box::new(5);\n \n {\n     let y = &mut x;"}, {"sha": "ffe33f41bc733b1c284adcbd4805c63ea42207ca", "filename": "src/doc/intro.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fintro.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Fintro.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fintro.md?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -542,7 +542,7 @@ use std::thread::Thread;\n fn main() {\n     let vec = vec![1i, 2, 3];\n \n-    for i in range(1u, 3) {\n+    for i in range(0u, 3) {\n         Thread::spawn(move || {\n             println!(\"{}\", vec[i]);\n         }).detach();\n@@ -558,7 +558,7 @@ a vector:\n ```{rust}\n let vec = vec![1i, 2, 3];\n \n-for i in range(1u, vec.len()) {\n+for i in range(0u, vec.len()) {\n      println!(\"{}\", vec[i]);\n }\n ```"}, {"sha": "804b6b9f63cf080847ca2c4ba127ab1afb68786e", "filename": "src/doc/reference.md", "status": "modified", "additions": 40, "deletions": 26, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -1588,10 +1588,11 @@ pointer values (pointing to a type for which an implementation of the given\n trait is in scope) to pointers to the trait name, used as a type.\n \n ```\n+# use std::boxed::Box;\n # trait Shape { }\n # impl Shape for int { }\n # let mycircle = 0i;\n-let myshape: Box<Shape> = box mycircle as Box<Shape>;\n+let myshape: Box<Shape> = Box::new(mycircle) as Box<Shape>;\n ```\n \n The resulting value is a box containing the value that was cast, along with\n@@ -1646,12 +1647,13 @@ fn radius_times_area<T: Circle>(c: T) -> f64 {\n Likewise, supertrait methods may also be called on trait objects.\n \n ```{.ignore}\n+# use std::boxed::Box;\n # trait Shape { fn area(&self) -> f64; }\n # trait Circle : Shape { fn radius(&self) -> f64; }\n # impl Shape for int { fn area(&self) -> f64 { 0.0 } }\n # impl Circle for int { fn radius(&self) -> f64 { 0.0 } }\n # let mycircle = 0;\n-let mycircle = box mycircle as Box<Circle>;\n+let mycircle = Box::new(mycircle) as Box<Circle>;\n let nonsense = mycircle.radius() * mycircle.area();\n ```\n \n@@ -3376,14 +3378,17 @@ stands for a *single* data field, whereas a wildcard `..` stands for *all* the\n fields of a particular variant. For example:\n \n ```\n+#![feature(box_syntax)]\n enum List<X> { Nil, Cons(X, Box<List<X>>) }\n \n-let x: List<int> = List::Cons(10, box List::Cons(11, box List::Nil));\n+fn main() {\n+    let x: List<int> = List::Cons(10, box List::Cons(11, box List::Nil));\n \n-match x {\n-    List::Cons(_, box List::Nil) => panic!(\"singleton list\"),\n-    List::Cons(..)               => return,\n-    List::Nil                    => panic!(\"empty list\")\n+    match x {\n+        List::Cons(_, box List::Nil) => panic!(\"singleton list\"),\n+        List::Cons(..)               => return,\n+        List::Nil                    => panic!(\"empty list\")\n+    }\n }\n ```\n \n@@ -3436,25 +3441,28 @@ the inside of the match.\n An example of a `match` expression:\n \n ```\n+#![feature(box_syntax)]\n # fn process_pair(a: int, b: int) { }\n # fn process_ten() { }\n \n enum List<X> { Nil, Cons(X, Box<List<X>>) }\n \n-let x: List<int> = List::Cons(10, box List::Cons(11, box List::Nil));\n+fn main() {\n+    let x: List<int> = List::Cons(10, box List::Cons(11, box List::Nil));\n \n-match x {\n-    List::Cons(a, box List::Cons(b, _)) => {\n-        process_pair(a, b);\n-    }\n-    List::Cons(10, _) => {\n-        process_ten();\n-    }\n-    List::Nil => {\n-        return;\n-    }\n-    _ => {\n-        panic!();\n+    match x {\n+        List::Cons(a, box List::Cons(b, _)) => {\n+            process_pair(a, b);\n+        }\n+        List::Cons(10, _) => {\n+            process_ten();\n+        }\n+        List::Nil => {\n+            return;\n+        }\n+        _ => {\n+            panic!();\n+        }\n     }\n }\n ```\n@@ -3468,6 +3476,8 @@ Subpatterns can also be bound to variables by the use of the syntax `variable @\n subpattern`. For example:\n \n ```\n+#![feature(box_syntax)]\n+\n enum List { Nil, Cons(uint, Box<List>) }\n \n fn is_sorted(list: &List) -> bool {\n@@ -3781,12 +3791,13 @@ enclosing `enum` or `struct` type itself. Such recursion has restrictions:\n An example of a *recursive* type and its use:\n \n ```\n+# use std::boxed::Box;\n enum List<T> {\n-  Nil,\n-  Cons(T, Box<List<T>>)\n+    Nil,\n+    Cons(T, Box<List<T>>)\n }\n \n-let a: List<int> = List::Cons(7, box List::Cons(13, box List::Nil));\n+let a: List<int> = List::Cons(7, Box::new(List::Cons(13, Box::new(List::Nil))));\n ```\n \n ### Pointer types\n@@ -3893,6 +3904,7 @@ implementation of `R`, and the pointer value of `E`.\n An example of an object type:\n \n ```\n+# use std::boxed::Box;\n trait Printable {\n   fn stringify(&self) -> String;\n }\n@@ -3906,7 +3918,7 @@ fn print(a: Box<Printable>) {\n }\n \n fn main() {\n-   print(box 10i as Box<Printable>);\n+   print(Box::new(10i) as Box<Printable>);\n }\n ```\n \n@@ -4100,7 +4112,8 @@ the type of a box is `std::owned::Box<T>`.\n An example of a box type and value:\n \n ```\n-let x: Box<int> = box 10;\n+# use std::boxed::Box;\n+let x: Box<int> = Box::new(10);\n ```\n \n Box values exist in 1:1 correspondence with their heap allocation, copying a\n@@ -4109,7 +4122,8 @@ copy of a box to move ownership of the value. After a value has been moved,\n the source location cannot be used unless it is reinitialized.\n \n ```\n-let x: Box<int> = box 10;\n+# use std::boxed::Box;\n+let x: Box<int> = Box::new(10);\n let y = x;\n // attempting to use `x` will result in an error here\n ```"}, {"sha": "48136bc1d96e240807f1f5caa3e3c4f4232340e8", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -67,21 +67,20 @@\n //! }\n //! ```\n \n+use core::prelude::*;\n+\n use core::atomic;\n use core::atomic::Ordering::{Relaxed, Release, Acquire, SeqCst};\n use core::borrow::BorrowFrom;\n-use core::clone::Clone;\n use core::fmt::{self, Show};\n-use core::cmp::{Eq, Ord, PartialEq, PartialOrd, Ordering};\n+use core::cmp::{Ordering};\n use core::default::Default;\n-use core::marker::{Sync, Send};\n-use core::mem::{min_align_of, size_of, drop};\n+use core::mem::{min_align_of, size_of};\n use core::mem;\n use core::nonzero::NonZero;\n-use core::ops::{Drop, Deref};\n-use core::option::Option;\n-use core::option::Option::{Some, None};\n-use core::ptr::{self, PtrExt};\n+use core::ops::Deref;\n+use core::ptr;\n+use core::hash::{Hash, Hasher};\n use heap::deallocate;\n \n /// An atomically reference counted wrapper for shared state.\n@@ -585,12 +584,25 @@ impl<T: fmt::Show> fmt::Show for Arc<T> {\n     }\n }\n \n+#[stable]\n+impl<T: fmt::String> fmt::String for Arc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(&**self, f)\n+    }\n+}\n+\n #[stable]\n impl<T: Default + Sync + Send> Default for Arc<T> {\n     #[stable]\n     fn default() -> Arc<T> { Arc::new(Default::default()) }\n }\n \n+impl<H: Hasher, T: Hash<H>> Hash<H> for Arc<T> {\n+    fn hash(&self, state: &mut H) {\n+        (**self).hash(state)\n+    }\n+}\n+\n #[cfg(test)]\n #[allow(experimental)]\n mod tests {"}, {"sha": "97b198164ebd8bfe65223bd0fc3ef8c241c8604f", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 35, "deletions": 15, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012-2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -33,12 +33,15 @@ use core::ops::{Deref, DerefMut};\n /// The following two examples are equivalent:\n ///\n /// ```rust\n+/// #![feature(box_syntax)]\n /// use std::boxed::HEAP;\n ///\n+/// fn main() {\n /// # struct Bar;\n /// # impl Bar { fn new(_a: int) { } }\n-/// let foo = box(HEAP) Bar::new(2);\n-/// let foo = box Bar::new(2);\n+///     let foo = box(HEAP) Bar::new(2);\n+///     let foo = box Bar::new(2);\n+/// }\n /// ```\n #[lang = \"exchange_heap\"]\n #[experimental = \"may be renamed; uncertain about custom allocator design\"]\n@@ -49,6 +52,14 @@ pub static HEAP: () = ();\n #[stable]\n pub struct Box<T>(Unique<T>);\n \n+impl<T> Box<T> {\n+    /// Moves `x` into a freshly allocated box on the global exchange heap.\n+    #[stable]\n+    pub fn new(x: T) -> Box<T> {\n+        box x\n+    }\n+}\n+\n #[stable]\n impl<T: Default> Default for Box<T> {\n     #[stable]\n@@ -102,16 +113,24 @@ impl<T: ?Sized + Ord> Ord for Box<T> {\n     fn cmp(&self, other: &Box<T>) -> Ordering {\n         Ord::cmp(&**self, &**other)\n     }\n-\n-#[stable]}\n+}\n+#[stable]\n impl<T: ?Sized + Eq> Eq for Box<T> {}\n \n+#[cfg(stage0)]\n impl<S: hash::Writer, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<S: hash::Hasher, T: ?Sized + Hash<S>> Hash<S> for Box<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n \n /// Extension methods for an owning `Any` trait object.\n #[unstable = \"post-DST and coherence changes, this will not be a trait but \\\n@@ -149,6 +168,7 @@ impl<T: ?Sized + fmt::Show> fmt::Show for Box<T> {\n     }\n }\n \n+#[stable]\n impl<T: ?Sized + fmt::String> fmt::String for Box<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n@@ -177,36 +197,36 @@ impl<T: ?Sized> DerefMut for Box<T> {\n mod test {\n     #[test]\n     fn test_owned_clone() {\n-        let a = box 5i;\n+        let a = Box::new(5i);\n         let b: Box<int> = a.clone();\n         assert!(a == b);\n     }\n \n     #[test]\n     fn any_move() {\n-        let a = box 8u as Box<Any>;\n-        let b = box Test as Box<Any>;\n+        let a = Box::new(8u) as Box<Any>;\n+        let b = Box::new(Test) as Box<Any>;\n \n         match a.downcast::<uint>() {\n-            Ok(a) => { assert!(a == box 8u); }\n+            Ok(a) => { assert!(a == Box::new(8u)); }\n             Err(..) => panic!()\n         }\n         match b.downcast::<Test>() {\n-            Ok(a) => { assert!(a == box Test); }\n+            Ok(a) => { assert!(a == Box::new(Test)); }\n             Err(..) => panic!()\n         }\n \n-        let a = box 8u as Box<Any>;\n-        let b = box Test as Box<Any>;\n+        let a = Box::new(8u) as Box<Any>;\n+        let b = Box::new(Test) as Box<Any>;\n \n         assert!(a.downcast::<Box<Test>>().is_err());\n         assert!(b.downcast::<Box<uint>>().is_err());\n     }\n \n     #[test]\n     fn test_show() {\n-        let a = box 8u as Box<Any>;\n-        let b = box Test as Box<Any>;\n+        let a = Box::new(8u) as Box<Any>;\n+        let b = Box::new(Test) as Box<Any>;\n         let a_str = a.to_str();\n         let b_str = b.to_str();\n         assert_eq!(a_str, \"Box<Any>\");\n@@ -223,6 +243,6 @@ mod test {\n     #[test]\n     fn deref() {\n         fn homura<T: Deref<Target=i32>>(_: T) { }\n-        homura(box 765i32);\n+        homura(Box::new(765i32));\n     }\n }"}, {"sha": "02933c763efe5f56997f72c2fd6feeb91d68fa59", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -115,16 +115,20 @@ unsafe fn exchange_free(ptr: *mut u8, old_size: uint, align: uint) {\n // The minimum alignment guaranteed by the architecture. This value is used to\n // add fast paths for low alignment values. In practice, the alignment is a\n // constant at the call site and the branch will be optimized out.\n-#[cfg(any(target_arch = \"arm\",\n-          target_arch = \"mips\",\n-          target_arch = \"mipsel\"))]\n+#[cfg(all(not(feature = \"external_funcs\"),\n+          not(feature = \"external_crate\"),\n+          any(target_arch = \"arm\",\n+              target_arch = \"mips\",\n+              target_arch = \"mipsel\")))]\n const MIN_ALIGN: uint = 8;\n-#[cfg(any(target_arch = \"x86\",\n-          target_arch = \"x86_64\",\n-          target_arch = \"aarch64\"))]\n+#[cfg(all(not(feature = \"external_funcs\"),\n+          not(feature = \"external_crate\"),\n+          any(target_arch = \"x86\",\n+              target_arch = \"x86_64\",\n+              target_arch = \"aarch64\")))]\n const MIN_ALIGN: uint = 16;\n \n-#[cfg(external_funcs)]\n+#[cfg(feature = \"external_funcs\")]\n mod imp {\n     extern {\n         fn rust_allocate(size: uint, align: uint) -> *mut u8;\n@@ -142,14 +146,13 @@ mod imp {\n     }\n \n     #[inline]\n-    pub unsafe fn reallocate_inplace(ptr: *mut u8, old_size: uint, size: uint,\n-                                     align: uint) -> uint {\n-        rust_reallocate_inplace(ptr, old_size, size, align)\n+    pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n+        rust_deallocate(ptr, old_size, align)\n     }\n \n     #[inline]\n-    pub unsafe fn deallocate(ptr: *mut u8, old_size: uint, align: uint) {\n-        rust_deallocate(ptr, old_size, align)\n+    pub unsafe fn reallocate(ptr: *mut u8, old_size: uint, size: uint, align: uint) -> *mut u8 {\n+        rust_reallocate(ptr, old_size, size, align)\n     }\n \n     #[inline]\n@@ -169,14 +172,16 @@ mod imp {\n     }\n }\n \n-#[cfg(external_crate)]\n+#[cfg(feature = \"external_crate\")]\n mod imp {\n     extern crate external;\n     pub use self::external::{allocate, deallocate, reallocate_inplace, reallocate};\n     pub use self::external::{usable_size, stats_print};\n }\n \n-#[cfg(all(not(external_funcs), not(external_crate), jemalloc))]\n+#[cfg(all(not(feature = \"external_funcs\"),\n+          not(feature = \"external_crate\"),\n+          jemalloc))]\n mod imp {\n     use core::option::Option;\n     use core::option::Option::None;\n@@ -253,7 +258,10 @@ mod imp {\n     }\n }\n \n-#[cfg(all(not(external_funcs), not(external_crate), not(jemalloc), unix))]\n+#[cfg(all(not(feature = \"external_funcs\"),\n+          not(feature = \"external_crate\"),\n+          not(jemalloc),\n+          unix))]\n mod imp {\n     use core::cmp;\n     use core::ptr;\n@@ -314,7 +322,10 @@ mod imp {\n     pub fn stats_print() {}\n }\n \n-#[cfg(all(not(external_funcs), not(external_crate), not(jemalloc), windows))]\n+#[cfg(all(not(feature = \"external_funcs\"),\n+          not(feature = \"external_crate\"),\n+          not(jemalloc),\n+          windows))]\n mod imp {\n     use libc::{c_void, size_t};\n     use libc;"}, {"sha": "0bb8ba669ec25c4c1960f894028f5fdc373297b8", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -58,6 +58,7 @@\n \n #![crate_name = \"alloc\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n@@ -66,9 +67,12 @@\n #![no_std]\n #![allow(unknown_features)]\n #![feature(lang_items, unsafe_destructor)]\n+#![feature(box_syntax)]\n \n #[macro_use]\n extern crate core;\n+\n+#[cfg(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")))]\n extern crate libc;\n \n // Allow testing this library"}, {"sha": "27b3f03002fb9446f1c0c4a471ca5619491aabc0", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -10,23 +10,26 @@\n \n //! Thread-local reference-counted boxes (the `Rc<T>` type).\n //!\n-//! The `Rc<T>` type provides shared ownership of an immutable value. Destruction is deterministic,\n-//! and will occur as soon as the last owner is gone. It is marked as non-sendable because it\n-//! avoids the overhead of atomic reference counting.\n+//! The `Rc<T>` type provides shared ownership of an immutable value.\n+//! Destruction is deterministic, and will occur as soon as the last owner is\n+//! gone. It is marked as non-sendable because it avoids the overhead of atomic\n+//! reference counting.\n //!\n-//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer to the box. A\n-//! `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but will return `None` if the value\n-//! has already been dropped.\n+//! The `downgrade` method can be used to create a non-owning `Weak<T>` pointer\n+//! to the box. A `Weak<T>` pointer can be upgraded to an `Rc<T>` pointer, but\n+//! will return `None` if the value has already been dropped.\n //!\n-//! For example, a tree with parent pointers can be represented by putting the nodes behind strong\n-//! `Rc<T>` pointers, and then storing the parent pointers as `Weak<T>` pointers.\n+//! For example, a tree with parent pointers can be represented by putting the\n+//! nodes behind strong `Rc<T>` pointers, and then storing the parent pointers\n+//! as `Weak<T>` pointers.\n //!\n //! # Examples\n //!\n-//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.  We want to have our\n-//! `Gadget`s point to their `Owner`. We can't do this with unique ownership, because more than one\n-//! gadget may belong to the same `Owner`. `Rc<T>` allows us to share an `Owner` between multiple\n-//! `Gadget`s, and have the `Owner` remain allocated as long as any `Gadget` points at it.\n+//! Consider a scenario where a set of `Gadget`s are owned by a given `Owner`.\n+//! We want to have our `Gadget`s point to their `Owner`. We can't do this with\n+//! unique ownership, because more than one gadget may belong to the same\n+//! `Owner`. `Rc<T>` allows us to share an `Owner` between multiple `Gadget`s,\n+//! and have the `Owner` remain allocated as long as any `Gadget` points at it.\n //!\n //! ```rust\n //! use std::rc::Rc;\n@@ -597,12 +600,20 @@ impl<T: Ord> Ord for Rc<T> {\n }\n \n // FIXME (#18248) Make `T` `Sized?`\n+#[cfg(stage0)]\n impl<S: hash::Writer, T: Hash<S>> Hash<S> for Rc<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         (**self).hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<S: hash::Hasher, T: Hash<S>> Hash<S> for Rc<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        (**self).hash(state);\n+    }\n+}\n \n #[experimental = \"Show is experimental.\"]\n impl<T: fmt::Show> fmt::Show for Rc<T> {\n@@ -611,6 +622,13 @@ impl<T: fmt::Show> fmt::Show for Rc<T> {\n     }\n }\n \n+#[stable]\n+impl<T: fmt::String> fmt::String for Rc<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::String::fmt(&**self, f)\n+    }\n+}\n+\n /// A weak version of `Rc<T>`.\n ///\n /// Weak references do not count when determining if the inner value should be dropped."}, {"sha": "f208ff9dc0517ee096b6b68625a3dd7337aee96b", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -21,14 +21,17 @@\n \n #![crate_name = \"arena\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(unsafe_destructor)]\n #![feature(unboxed_closures)]\n+#![feature(box_syntax)]\n #![allow(missing_docs)]\n \n extern crate alloc;"}, {"sha": "e922feff02bd271cef4be0de0707526ea26aecb0", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -330,7 +330,7 @@ impl Bitv {\n \n         if extra_bytes > 0 {\n             let mut last_word = 0u32;\n-            for (i, &byte) in bytes.index(&((complete_words*4)..)).iter().enumerate() {\n+            for (i, &byte) in bytes[(complete_words*4)..].iter().enumerate() {\n                 last_word |= (reverse_bits(byte) as u32) << (i * 8);\n             }\n             bitv.storage.push(last_word);\n@@ -982,7 +982,7 @@ impl fmt::Show for Bitv {\n }\n \n #[stable]\n-impl<S: hash::Writer> hash::Hash<S> for Bitv {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for Bitv {\n     fn hash(&self, state: &mut S) {\n         self.nbits.hash(state);\n         for elem in self.blocks() {\n@@ -1742,7 +1742,7 @@ impl fmt::Show for BitvSet {\n     }\n }\n \n-impl<S: hash::Writer> hash::Hash<S> for BitvSet {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for BitvSet {\n     fn hash(&self, state: &mut S) {\n         for pos in self.iter() {\n             pos.hash(state);"}, {"sha": "3e1533dd35f598aad43903e14b74774627c0af14", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -23,7 +23,9 @@ use core::borrow::BorrowFrom;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt::Show;\n-use core::hash::{Writer, Hash};\n+use core::hash::{Hash, Hasher};\n+#[cfg(stage0)]\n+use core::hash::Writer;\n use core::iter::{Map, FromIterator};\n use core::ops::{Index, IndexMut};\n use core::{iter, fmt, mem};\n@@ -820,13 +822,23 @@ impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n }\n \n #[stable]\n+#[cfg(stage0)]\n impl<S: Writer, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n     fn hash(&self, state: &mut S) {\n         for elt in self.iter() {\n             elt.hash(state);\n         }\n     }\n }\n+#[stable]\n+#[cfg(not(stage0))]\n+impl<S: Hasher, K: Hash<S>, V: Hash<S>> Hash<S> for BTreeMap<K, V> {\n+    fn hash(&self, state: &mut S) {\n+        for elt in self.iter() {\n+            elt.hash(state);\n+        }\n+    }\n+}\n \n #[stable]\n impl<K: Ord, V> Default for BTreeMap<K, V> {"}, {"sha": "812cff6fab722d223997f813221b98ba5eea399c", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -678,7 +678,7 @@ mod test {\n     use prelude::*;\n \n     use super::BTreeSet;\n-    use std::hash;\n+    use std::hash::{self, SipHasher};\n \n     #[test]\n     fn test_clone_eq() {\n@@ -703,7 +703,7 @@ mod test {\n       y.insert(2);\n       y.insert(1);\n \n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n     }\n \n     struct Counter<'a, 'b> {"}, {"sha": "0b426f6016cb897af0496d139b1364622f125437", "filename": "src/libcollections/dlist.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fdlist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fdlist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fdlist.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -27,7 +27,7 @@ use alloc::boxed::Box;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::hash::{Writer, Hash};\n+use core::hash::{Writer, Hasher, Hash};\n use core::iter::{self, FromIterator};\n use core::mem;\n use core::ptr;\n@@ -675,7 +675,7 @@ impl<A: fmt::Show> fmt::Show for DList<A> {\n }\n \n #[stable]\n-impl<S: Writer, A: Hash<S>> Hash<S> for DList<A> {\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for DList<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self.iter() {\n@@ -688,7 +688,7 @@ impl<S: Writer, A: Hash<S>> Hash<S> for DList<A> {\n mod tests {\n     use prelude::*;\n     use std::rand;\n-    use std::hash;\n+    use std::hash::{self, SipHasher};\n     use std::thread::Thread;\n     use test::Bencher;\n     use test;\n@@ -951,7 +951,7 @@ mod tests {\n       let mut x = DList::new();\n       let mut y = DList::new();\n \n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n \n       x.push_back(1i);\n       x.push_back(2);\n@@ -961,7 +961,7 @@ mod tests {\n       y.push_front(2);\n       y.push_front(1);\n \n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n     }\n \n     #[test]"}, {"sha": "7692c1558a70f7c6797e729a701a162d69f40e61", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -15,6 +15,7 @@\n \n #![crate_name = \"collections\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n@@ -23,8 +24,9 @@\n \n #![allow(unknown_features)]\n #![feature(unsafe_destructor, slicing_syntax)]\n-#![feature(old_impl_check)]\n+#![feature(box_syntax)]\n #![feature(unboxed_closures)]\n+#![feature(old_impl_check)]\n #![no_std]\n \n #[macro_use]\n@@ -101,8 +103,6 @@ mod std {\n     pub use core::option;   // necessary for panic!()\n     pub use core::clone;    // deriving(Clone)\n     pub use core::cmp;      // deriving(Eq, Ord, etc.)\n-    #[cfg(stage0)]\n-    pub use core::marker as kinds;\n     pub use core::marker;  // deriving(Copy)\n     pub use core::hash;     // deriving(Hash)\n }"}, {"sha": "0ff869d618316f9aac4e881eb7e97c80f614ebea", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -10,9 +10,10 @@\n \n /// Creates a `Vec` containing the arguments.\n #[macro_export]\n+#[stable]\n macro_rules! vec {\n     ($($x:expr),*) => ({\n-        let xs: $crate::boxed::Box<[_]> = box [$($x),*];\n+        let xs: $crate::boxed::Box<[_]> = $crate::boxed::Box::new([$($x),*]);\n         $crate::slice::SliceExt::into_vec(xs)\n     });\n     ($($x:expr,)*) => (vec![$($x),*])"}, {"sha": "c3d226758683767deaba45e4811692744076fbae", "filename": "src/libcollections/ring_buf.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fring_buf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fring_buf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fring_buf.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -27,7 +27,7 @@ use core::ops::{Index, IndexMut};\n use core::ptr;\n use core::raw::Slice as RawSlice;\n \n-use std::hash::{Writer, Hash};\n+use std::hash::{Writer, Hash, Hasher};\n use std::cmp;\n \n use alloc::heap;\n@@ -556,7 +556,7 @@ impl<T> RingBuf<T> {\n             let buf = self.buffer_as_slice();\n             if contiguous {\n                 let (empty, buf) = buf.split_at(0);\n-                (buf.index(&(self.tail..self.head)), empty)\n+                (&buf[self.tail..self.head], empty)\n             } else {\n                 let (mid, right) = buf.split_at(self.tail);\n                 let (left, _) = mid.split_at(self.head);\n@@ -1562,7 +1562,7 @@ impl<A: Ord> Ord for RingBuf<A> {\n }\n \n #[stable]\n-impl<S: Writer, A: Hash<S>> Hash<S> for RingBuf<A> {\n+impl<S: Writer + Hasher, A: Hash<S>> Hash<S> for RingBuf<A> {\n     fn hash(&self, state: &mut S) {\n         self.len().hash(state);\n         for elt in self.iter() {\n@@ -1631,7 +1631,7 @@ mod tests {\n     use prelude::*;\n     use core::iter;\n     use std::fmt::Show;\n-    use std::hash;\n+    use std::hash::{self, SipHasher};\n     use test::Bencher;\n     use test;\n \n@@ -2283,7 +2283,7 @@ mod tests {\n       y.push_back(2);\n       y.push_back(3);\n \n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<_, SipHasher>(&x) == hash::hash::<_, SipHasher>(&y));\n     }\n \n     #[test]"}, {"sha": "cb3fbd461cdf6574f0b37db955b053e8c0791fc1", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 16, "deletions": 17, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -55,7 +55,7 @@\n //! #![feature(slicing_syntax)]\n //! fn main() {\n //!     let numbers = [0i, 1i, 2i];\n-//!     let last_numbers = numbers.index(&(1..3));\n+//!     let last_numbers = &numbers[1..3];\n //!     // last_numbers is now &[1i, 2i]\n //! }\n //! ```\n@@ -98,7 +98,7 @@ use core::iter::{range, range_step, MultiplicativeIterator};\n use core::marker::Sized;\n use core::mem::size_of;\n use core::mem;\n-use core::ops::{FnMut, FullRange, Index, IndexMut};\n+use core::ops::{FnMut, FullRange};\n use core::option::Option::{self, Some, None};\n use core::ptr::PtrExt;\n use core::ptr;\n@@ -245,7 +245,7 @@ pub trait SliceExt {\n     /// ```rust\n     /// let v = &[1i, 2, 3, 4];\n     /// for win in v.windows(2) {\n-    ///     println!(\"{}\", win);\n+    ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n     #[stable]\n@@ -268,7 +268,7 @@ pub trait SliceExt {\n     /// ```rust\n     /// let v = &[1i, 2, 3, 4, 5];\n     /// for win in v.chunks(2) {\n-    ///     println!(\"{}\", win);\n+    ///     println!(\"{:?}\", win);\n     /// }\n     /// ```\n     #[stable]\n@@ -554,7 +554,7 @@ pub trait SliceExt {\n     /// let mut perms = v.permutations();\n     ///\n     /// for p in perms {\n-    ///   println!(\"{}\", p);\n+    ///   println!(\"{:?}\", p);\n     /// }\n     /// ```\n     ///\n@@ -1065,12 +1065,12 @@ impl ElementSwaps {\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFrom<Vec<T>> for [T] {\n-    fn borrow_from(owned: &Vec<T>) -> &[T] { owned.index(&FullRange) }\n+    fn borrow_from(owned: &Vec<T>) -> &[T] { &owned[] }\n }\n \n #[unstable = \"trait is unstable\"]\n impl<T> BorrowFromMut<Vec<T>> for [T] {\n-    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { owned.index_mut(&FullRange) }\n+    fn borrow_from_mut(owned: &mut Vec<T>) -> &mut [T] { &mut owned[] }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -1400,7 +1400,6 @@ mod tests {\n     use core::prelude::{Ord, FullRange};\n     use core::default::Default;\n     use core::mem;\n-    use core::ops::Index;\n     use std::iter::RandomAccessIterator;\n     use std::rand::{Rng, thread_rng};\n     use std::rc::Rc;\n@@ -1611,15 +1610,15 @@ mod tests {\n \n         // Test on stack.\n         let vec_stack: &[_] = &[1i, 2, 3];\n-        let v_b = vec_stack.index(&(1u..3u)).to_vec();\n+        let v_b = vec_stack[1u..3u].to_vec();\n         assert_eq!(v_b.len(), 2u);\n         let v_b = v_b.as_slice();\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test `Box<[T]>`\n         let vec_unique = vec![1i, 2, 3, 4, 5, 6];\n-        let v_d = vec_unique.index(&(1u..6u)).to_vec();\n+        let v_d = vec_unique[1u..6u].to_vec();\n         assert_eq!(v_d.len(), 5u);\n         let v_d = v_d.as_slice();\n         assert_eq!(v_d[0], 2);\n@@ -1632,21 +1631,21 @@ mod tests {\n     #[test]\n     fn test_slice_from() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec.index(&(0..)), vec);\n+        assert_eq!(&vec[0..], vec);\n         let b: &[int] = &[3, 4];\n-        assert_eq!(vec.index(&(2..)), b);\n+        assert_eq!(&vec[2..], b);\n         let b: &[int] = &[];\n-        assert_eq!(vec.index(&(4..)), b);\n+        assert_eq!(&vec[4..], b);\n     }\n \n     #[test]\n     fn test_slice_to() {\n         let vec: &[int] = &[1, 2, 3, 4];\n-        assert_eq!(vec.index(&(0..4)), vec);\n+        assert_eq!(&vec[0..4], vec);\n         let b: &[int] = &[1, 2];\n-        assert_eq!(vec.index(&(0..2)), b);\n+        assert_eq!(&vec[0..2], b);\n         let b: &[int] = &[];\n-        assert_eq!(vec.index(&(0..0)), b);\n+        assert_eq!(&vec[0..0], b);\n     }\n \n \n@@ -2572,7 +2571,7 @@ mod tests {\n         }\n         assert_eq!(cnt, 3);\n \n-        for f in v.index(&(1..3)).iter() {\n+        for f in v[1..3].iter() {\n             assert!(*f == Foo);\n             cnt += 1;\n         }"}, {"sha": "ccf654ac0a048a93860f585977c52e2830a15cf5", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 49, "deletions": 49, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -386,7 +386,7 @@ macro_rules! utf8_acc_cont_byte {\n \n #[unstable = \"trait is unstable\"]\n impl BorrowFrom<String> for str {\n-    fn borrow_from(owned: &String) -> &str { owned.index(&FullRange) }\n+    fn borrow_from(owned: &String) -> &str { &owned[] }\n }\n \n #[unstable = \"trait is unstable\"]\n@@ -464,7 +464,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self.index(&FullRange).chars(),\n+            iter: self[].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Canonical\n@@ -477,7 +477,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[unstable = \"this functionality may be moved to libunicode\"]\n     fn nfkd_chars<'a>(&'a self) -> Decompositions<'a> {\n         Decompositions {\n-            iter: self.index(&FullRange).chars(),\n+            iter: self[].chars(),\n             buffer: Vec::new(),\n             sorted: false,\n             kind: Compatible\n@@ -525,7 +525,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn contains(&self, pat: &str) -> bool {\n-        core_str::StrExt::contains(self.index(&FullRange), pat)\n+        core_str::StrExt::contains(&self[], pat)\n     }\n \n     /// Returns true if a string contains a char pattern.\n@@ -541,7 +541,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might get removed in favour of a more generic contains()\"]\n     fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n-        core_str::StrExt::contains_char(self.index(&FullRange), pat)\n+        core_str::StrExt::contains_char(&self[], pat)\n     }\n \n     /// An iterator over the characters of `self`. Note, this iterates\n@@ -555,7 +555,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn chars(&self) -> Chars {\n-        core_str::StrExt::chars(self.index(&FullRange))\n+        core_str::StrExt::chars(&self[])\n     }\n \n     /// An iterator over the bytes of `self`\n@@ -568,13 +568,13 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn bytes(&self) -> Bytes {\n-        core_str::StrExt::bytes(self.index(&FullRange))\n+        core_str::StrExt::bytes(&self[])\n     }\n \n     /// An iterator over the characters of `self` and their byte offsets.\n     #[stable]\n     fn char_indices(&self) -> CharIndices {\n-        core_str::StrExt::char_indices(self.index(&FullRange))\n+        core_str::StrExt::char_indices(&self[])\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -597,7 +597,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n-        core_str::StrExt::split(self.index(&FullRange), pat)\n+        core_str::StrExt::split(&self[], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -624,7 +624,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn splitn<P: CharEq>(&self, count: uint, pat: P) -> SplitN<P> {\n-        core_str::StrExt::splitn(self.index(&FullRange), count, pat)\n+        core_str::StrExt::splitn(&self[], count, pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -653,7 +653,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might get removed\"]\n     fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n-        core_str::StrExt::split_terminator(self.index(&FullRange), pat)\n+        core_str::StrExt::split_terminator(&self[], pat)\n     }\n \n     /// An iterator over substrings of `self`, separated by characters\n@@ -674,7 +674,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn rsplitn<P: CharEq>(&self, count: uint, pat: P) -> RSplitN<P> {\n-        core_str::StrExt::rsplitn(self.index(&FullRange), count, pat)\n+        core_str::StrExt::rsplitn(&self[], count, pat)\n     }\n \n     /// An iterator over the start and end indices of the disjoint\n@@ -699,7 +699,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might have its iterator type changed\"]\n     fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n-        core_str::StrExt::match_indices(self.index(&FullRange), pat)\n+        core_str::StrExt::match_indices(&self[], pat)\n     }\n \n     /// An iterator over the substrings of `self` separated by the pattern `sep`.\n@@ -715,7 +715,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might get removed in the future in favor of a more generic split()\"]\n     fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n-        core_str::StrExt::split_str(self.index(&FullRange), pat)\n+        core_str::StrExt::split_str(&self[], pat)\n     }\n \n     /// An iterator over the lines of a string (subsequences separated\n@@ -731,7 +731,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn lines(&self) -> Lines {\n-        core_str::StrExt::lines(self.index(&FullRange))\n+        core_str::StrExt::lines(&self[])\n     }\n \n     /// An iterator over the lines of a string, separated by either\n@@ -747,7 +747,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn lines_any(&self) -> LinesAny {\n-        core_str::StrExt::lines_any(self.index(&FullRange))\n+        core_str::StrExt::lines_any(&self[])\n     }\n \n     /// Returns a slice of the given string from the byte range\n@@ -782,7 +782,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"use slice notation [a..b] instead\"]\n     fn slice(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice(self.index(&FullRange), begin, end)\n+        core_str::StrExt::slice(&self[], begin, end)\n     }\n \n     /// Returns a slice of the string from `begin` to its end.\n@@ -795,7 +795,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// See also `slice`, `slice_to` and `slice_chars`.\n     #[unstable = \"use slice notation [a..] instead\"]\n     fn slice_from(&self, begin: uint) -> &str {\n-        core_str::StrExt::slice_from(self.index(&FullRange), begin)\n+        core_str::StrExt::slice_from(&self[], begin)\n     }\n \n     /// Returns a slice of the string from the beginning to byte\n@@ -809,7 +809,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// See also `slice`, `slice_from` and `slice_chars`.\n     #[unstable = \"use slice notation [0..a] instead\"]\n     fn slice_to(&self, end: uint) -> &str {\n-        core_str::StrExt::slice_to(self.index(&FullRange), end)\n+        core_str::StrExt::slice_to(&self[], end)\n     }\n \n     /// Returns a slice of the string from the character range\n@@ -837,7 +837,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"may have yet to prove its worth\"]\n     fn slice_chars(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice_chars(self.index(&FullRange), begin, end)\n+        core_str::StrExt::slice_chars(&self[], begin, end)\n     }\n \n     /// Takes a bytewise (not UTF-8) slice from a string.\n@@ -848,7 +848,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// the entire slice as well.\n     #[stable]\n     unsafe fn slice_unchecked(&self, begin: uint, end: uint) -> &str {\n-        core_str::StrExt::slice_unchecked(self.index(&FullRange), begin, end)\n+        core_str::StrExt::slice_unchecked(&self[], begin, end)\n     }\n \n     /// Returns true if the pattern `pat` is a prefix of the string.\n@@ -860,7 +860,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn starts_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::starts_with(self.index(&FullRange), pat)\n+        core_str::StrExt::starts_with(&self[], pat)\n     }\n \n     /// Returns true if the pattern `pat` is a suffix of the string.\n@@ -872,7 +872,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn ends_with(&self, pat: &str) -> bool {\n-        core_str::StrExt::ends_with(self.index(&FullRange), pat)\n+        core_str::StrExt::ends_with(&self[], pat)\n     }\n \n     /// Returns a string with all pre- and suffixes that match\n@@ -892,7 +892,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_matches(self.index(&FullRange), pat)\n+        core_str::StrExt::trim_matches(&self[], pat)\n     }\n \n     /// Returns a string with all prefixes that match\n@@ -912,7 +912,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_left_matches(self.index(&FullRange), pat)\n+        core_str::StrExt::trim_left_matches(&self[], pat)\n     }\n \n     /// Returns a string with all suffixes that match\n@@ -932,7 +932,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n-        core_str::StrExt::trim_right_matches(self.index(&FullRange), pat)\n+        core_str::StrExt::trim_right_matches(&self[], pat)\n     }\n \n     /// Check that `index`-th byte lies at the start and/or end of a\n@@ -960,7 +960,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn is_char_boundary(&self, index: uint) -> bool {\n-        core_str::StrExt::is_char_boundary(self.index(&FullRange), index)\n+        core_str::StrExt::is_char_boundary(&self[], index)\n     }\n \n     /// Pluck a character out of a string and return the index of the next\n@@ -1018,7 +1018,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_range_at(&self, start: uint) -> CharRange {\n-        core_str::StrExt::char_range_at(self.index(&FullRange), start)\n+        core_str::StrExt::char_range_at(&self[], start)\n     }\n \n     /// Given a byte position and a str, return the previous char and its position.\n@@ -1033,7 +1033,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_range_at_reverse(&self, start: uint) -> CharRange {\n-        core_str::StrExt::char_range_at_reverse(self.index(&FullRange), start)\n+        core_str::StrExt::char_range_at_reverse(&self[], start)\n     }\n \n     /// Plucks the character starting at the `i`th byte of a string.\n@@ -1053,7 +1053,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// If `i` is not the index of the beginning of a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_at(&self, i: uint) -> char {\n-        core_str::StrExt::char_at(self.index(&FullRange), i)\n+        core_str::StrExt::char_at(&self[], i)\n     }\n \n     /// Plucks the character ending at the `i`th byte of a string.\n@@ -1064,7 +1064,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// If `i` is not an index following a valid UTF-8 character.\n     #[unstable = \"naming is uncertain with container conventions\"]\n     fn char_at_reverse(&self, i: uint) -> char {\n-        core_str::StrExt::char_at_reverse(self.index(&FullRange), i)\n+        core_str::StrExt::char_at_reverse(&self[], i)\n     }\n \n     /// Work with the byte buffer of a string as a byte slice.\n@@ -1076,7 +1076,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn as_bytes(&self) -> &[u8] {\n-        core_str::StrExt::as_bytes(self.index(&FullRange))\n+        core_str::StrExt::as_bytes(&self[])\n     }\n \n     /// Returns the byte index of the first character of `self` that\n@@ -1104,7 +1104,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn find<P: CharEq>(&self, pat: P) -> Option<uint> {\n-        core_str::StrExt::find(self.index(&FullRange), pat)\n+        core_str::StrExt::find(&self[], pat)\n     }\n \n     /// Returns the byte index of the last character of `self` that\n@@ -1132,7 +1132,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn rfind<P: CharEq>(&self, pat: P) -> Option<uint> {\n-        core_str::StrExt::rfind(self.index(&FullRange), pat)\n+        core_str::StrExt::rfind(&self[], pat)\n     }\n \n     /// Returns the byte index of the first matching substring\n@@ -1156,7 +1156,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"might get removed in favor of a more generic find in the future\"]\n     fn find_str(&self, needle: &str) -> Option<uint> {\n-        core_str::StrExt::find_str(self.index(&FullRange), needle)\n+        core_str::StrExt::find_str(&self[], needle)\n     }\n \n     /// Retrieves the first character from a string slice and returns\n@@ -1179,7 +1179,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"awaiting conventions about shifting and slices\"]\n     fn slice_shift_char(&self) -> Option<(char, &str)> {\n-        core_str::StrExt::slice_shift_char(self.index(&FullRange))\n+        core_str::StrExt::slice_shift_char(&self[])\n     }\n \n     /// Returns the byte offset of an inner slice relative to an enclosing outer slice.\n@@ -1198,7 +1198,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"awaiting convention about comparability of arbitrary slices\"]\n     fn subslice_offset(&self, inner: &str) -> uint {\n-        core_str::StrExt::subslice_offset(self.index(&FullRange), inner)\n+        core_str::StrExt::subslice_offset(&self[], inner)\n     }\n \n     /// Return an unsafe pointer to the strings buffer.\n@@ -1209,13 +1209,13 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[stable]\n     #[inline]\n     fn as_ptr(&self) -> *const u8 {\n-        core_str::StrExt::as_ptr(self.index(&FullRange))\n+        core_str::StrExt::as_ptr(&self[])\n     }\n \n     /// Return an iterator of `u16` over the string encoded as UTF-16.\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn utf16_units(&self) -> Utf16Units {\n-        Utf16Units { encoder: Utf16Encoder::new(self.index(&FullRange).chars()) }\n+        Utf16Units { encoder: Utf16Encoder::new(self[].chars()) }\n     }\n \n     /// Return the number of bytes in this string\n@@ -1229,7 +1229,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[stable]\n     #[inline]\n     fn len(&self) -> uint {\n-        core_str::StrExt::len(self.index(&FullRange))\n+        core_str::StrExt::len(&self[])\n     }\n \n     /// Returns true if this slice contains no bytes\n@@ -1242,7 +1242,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[inline]\n     #[stable]\n     fn is_empty(&self) -> bool {\n-        core_str::StrExt::is_empty(self.index(&FullRange))\n+        core_str::StrExt::is_empty(&self[])\n     }\n \n     /// Parse this string into the specified type.\n@@ -1256,7 +1256,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     #[inline]\n     #[unstable = \"this method was just created\"]\n     fn parse<F: FromStr>(&self) -> Option<F> {\n-        core_str::StrExt::parse(self.index(&FullRange))\n+        core_str::StrExt::parse(&self[])\n     }\n \n     /// Returns an iterator over the\n@@ -1280,7 +1280,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn graphemes(&self, is_extended: bool) -> Graphemes {\n-        UnicodeStr::graphemes(self.index(&FullRange), is_extended)\n+        UnicodeStr::graphemes(&self[], is_extended)\n     }\n \n     /// Returns an iterator over the grapheme clusters of self and their byte offsets.\n@@ -1295,7 +1295,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn grapheme_indices(&self, is_extended: bool) -> GraphemeIndices {\n-        UnicodeStr::grapheme_indices(self.index(&FullRange), is_extended)\n+        UnicodeStr::grapheme_indices(&self[], is_extended)\n     }\n \n     /// An iterator over the words of a string (subsequences separated\n@@ -1311,7 +1311,7 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// ```\n     #[stable]\n     fn words(&self) -> Words {\n-        UnicodeStr::words(self.index(&FullRange))\n+        UnicodeStr::words(&self[])\n     }\n \n     /// Returns a string's displayed width in columns, treating control\n@@ -1325,25 +1325,25 @@ pub trait StrExt: Index<FullRange, Output = str> {\n     /// `is_cjk` = `false`) if the locale is unknown.\n     #[unstable = \"this functionality may only be provided by libunicode\"]\n     fn width(&self, is_cjk: bool) -> uint {\n-        UnicodeStr::width(self.index(&FullRange), is_cjk)\n+        UnicodeStr::width(&self[], is_cjk)\n     }\n \n     /// Returns a string with leading and trailing whitespace removed.\n     #[stable]\n     fn trim(&self) -> &str {\n-        UnicodeStr::trim(self.index(&FullRange))\n+        UnicodeStr::trim(&self[])\n     }\n \n     /// Returns a string with leading whitespace removed.\n     #[stable]\n     fn trim_left(&self) -> &str {\n-        UnicodeStr::trim_left(self.index(&FullRange))\n+        UnicodeStr::trim_left(&self[])\n     }\n \n     /// Returns a string with trailing whitespace removed.\n     #[stable]\n     fn trim_right(&self) -> &str {\n-        UnicodeStr::trim_right(self.index(&FullRange))\n+        UnicodeStr::trim_right(&self[])\n     }\n }\n "}, {"sha": "1bb0be05b1e82e51b956aa6542e9ec19db0f880d", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 24, "deletions": 26, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -168,7 +168,7 @@ impl String {\n \n         if i > 0 {\n             unsafe {\n-                res.as_mut_vec().push_all(v.index(&(0..i)))\n+                res.as_mut_vec().push_all(&v[0..i])\n             };\n         }\n \n@@ -185,7 +185,7 @@ impl String {\n             macro_rules! error { () => ({\n                 unsafe {\n                     if subseqidx != i_ {\n-                        res.as_mut_vec().push_all(v.index(&(subseqidx..i_)));\n+                        res.as_mut_vec().push_all(&v[subseqidx..i_]);\n                     }\n                     subseqidx = i;\n                     res.as_mut_vec().push_all(REPLACEMENT);\n@@ -254,7 +254,7 @@ impl String {\n         }\n         if subseqidx < total {\n             unsafe {\n-                res.as_mut_vec().push_all(v.index(&(subseqidx..total)))\n+                res.as_mut_vec().push_all(&v[subseqidx..total])\n             };\n         }\n         Cow::Owned(res)\n@@ -681,6 +681,7 @@ impl fmt::Show for FromUtf8Error {\n     }\n }\n \n+#[stable]\n impl fmt::String for FromUtf8Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&self.error, f)\n@@ -693,6 +694,7 @@ impl fmt::Show for FromUtf16Error {\n     }\n }\n \n+#[stable]\n impl fmt::String for FromUtf16Error {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(\"invalid utf-16: lone surrogate found\", f)\n@@ -805,7 +807,7 @@ impl Default for String {\n     }\n }\n \n-#[experimental = \"waiting on fmt stabilization\"]\n+#[stable]\n impl fmt::String for String {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::String::fmt(&**self, f)\n@@ -820,12 +822,21 @@ impl fmt::Show for String {\n }\n \n #[experimental = \"waiting on Hash stabilization\"]\n+#[cfg(stage0)]\n impl<H: hash::Writer> hash::Hash<H> for String {\n     #[inline]\n     fn hash(&self, hasher: &mut H) {\n         (**self).hash(hasher)\n     }\n }\n+#[experimental = \"waiting on Hash stabilization\"]\n+#[cfg(not(stage0))]\n+impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for String {\n+    #[inline]\n+    fn hash(&self, hasher: &mut H) {\n+        (**self).hash(hasher)\n+    }\n+}\n \n #[unstable = \"recent addition, needs more experience\"]\n impl<'a> Add<&'a str> for String {\n@@ -841,21 +852,21 @@ impl ops::Index<ops::Range<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::Range<uint>) -> &str {\n-        &self.index(&FullRange)[*index]\n+        &self[][*index]\n     }\n }\n impl ops::Index<ops::RangeTo<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeTo<uint>) -> &str {\n-        &self.index(&FullRange)[*index]\n+        &self[][*index]\n     }\n }\n impl ops::Index<ops::RangeFrom<uint>> for String {\n     type Output = str;\n     #[inline]\n     fn index(&self, index: &ops::RangeFrom<uint>) -> &str {\n-        &self.index(&FullRange)[*index]\n+        &self[][*index]\n     }\n }\n impl ops::Index<ops::FullRange> for String {\n@@ -871,7 +882,7 @@ impl ops::Deref for String {\n     type Target = str;\n \n     fn deref<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(self.vec.index(&FullRange)) }\n+        unsafe { mem::transmute(&self.vec[]) }\n     }\n }\n \n@@ -921,18 +932,6 @@ pub trait ToString {\n     fn to_string(&self) -> String;\n }\n \n-#[cfg(stage0)]\n-impl<T: fmt::Show> ToString for T {\n-    fn to_string(&self) -> String {\n-        use core::fmt::Writer;\n-        let mut buf = String::new();\n-        let _ = buf.write_fmt(format_args!(\"{}\", self));\n-        buf.shrink_to_fit();\n-        buf\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n impl<T: fmt::String> ToString for T {\n     fn to_string(&self) -> String {\n         use core::fmt::Writer;\n@@ -1277,18 +1276,17 @@ mod tests {\n         assert_eq!(2u8.to_string(), \"2\");\n         assert_eq!(true.to_string(), \"true\");\n         assert_eq!(false.to_string(), \"false\");\n-        assert_eq!(().to_string(), \"()\");\n         assert_eq!((\"hi\".to_string()).to_string(), \"hi\");\n     }\n \n     #[test]\n     fn test_vectors() {\n         let x: Vec<int> = vec![];\n-        assert_eq!(x.to_string(), \"[]\");\n-        assert_eq!((vec![1i]).to_string(), \"[1]\");\n-        assert_eq!((vec![1i, 2, 3]).to_string(), \"[1, 2, 3]\");\n-        assert!((vec![vec![], vec![1i], vec![1i, 1]]).to_string() ==\n-               \"[[], [1], [1, 1]]\");\n+        assert_eq!(format!(\"{:?}\", x), \"[]\");\n+        assert_eq!(format!(\"{:?}\", vec![1i]), \"[1i]\");\n+        assert_eq!(format!(\"{:?}\", vec![1i, 2, 3]), \"[1i, 2i, 3i]\");\n+        assert!(format!(\"{:?}\", vec![vec![], vec![1i], vec![1i, 1]]) ==\n+               \"[[], [1i], [1i, 1i]]\");\n     }\n \n     #[test]"}, {"sha": "d9344d130b23ce097b98f830c6b285c4577cd0da", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -1178,17 +1178,25 @@ impl<T:Clone> Clone for Vec<T> {\n \n         // self.len <= other.len due to the truncate above, so the\n         // slice here is always in-bounds.\n-        let slice = other.index(&(self.len()..));\n+        let slice = &other[self.len()..];\n         self.push_all(slice);\n     }\n }\n \n+#[cfg(stage0)]\n impl<S: hash::Writer, T: Hash<S>> Hash<S> for Vec<T> {\n     #[inline]\n     fn hash(&self, state: &mut S) {\n         self.as_slice().hash(state);\n     }\n }\n+#[cfg(not(stage0))]\n+impl<S: hash::Writer + hash::Hasher, T: Hash<S>> Hash<S> for Vec<T> {\n+    #[inline]\n+    fn hash(&self, state: &mut S) {\n+        self.as_slice().hash(state);\n+    }\n+}\n \n #[experimental = \"waiting on Index stability\"]\n impl<T> Index<uint> for Vec<T> {\n@@ -1454,22 +1462,6 @@ impl<T: fmt::Show> fmt::Show for Vec<T> {\n     }\n }\n \n-#[cfg(stage0)]\n-#[experimental = \"waiting on Show stability\"]\n-impl<T: fmt::Show> fmt::String for Vec<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self.as_slice(), f)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n-#[experimental = \"waiting on Show stability\"]\n-impl<T: fmt::String> fmt::String for Vec<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self.as_slice(), f)\n-    }\n-}\n-\n impl<'a> fmt::Writer for Vec<u8> {\n     fn write_str(&mut self, s: &str) -> fmt::Result {\n         self.push_all(s.as_bytes());\n@@ -2039,7 +2031,7 @@ mod tests {\n         v.push(());\n         assert_eq!(v.iter_mut().count(), 4);\n \n-        for &() in v.iter_mut() {}\n+        for &mut () in v.iter_mut() {}\n         unsafe { v.set_len(0); }\n         assert_eq!(v.iter_mut().count(), 0);\n     }"}, {"sha": "d4ce266d3e211b5ed45c7ebc2b7faaba5ab24389", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -18,7 +18,7 @@ use core::prelude::*;\n use core::cmp::Ordering;\n use core::default::Default;\n use core::fmt;\n-use core::hash::{Hash, Writer};\n+use core::hash::{Hash, Writer, Hasher};\n use core::iter::{Enumerate, FilterMap, Map, FromIterator};\n use core::iter;\n use core::mem::replace;\n@@ -85,7 +85,7 @@ impl<V:Clone> Clone for VecMap<V> {\n     }\n }\n \n-impl<S: Writer, V: Hash<S>> Hash<S> for VecMap<V> {\n+impl<S: Writer + Hasher, V: Hash<S>> Hash<S> for VecMap<V> {\n     fn hash(&self, state: &mut S) {\n         // In order to not traverse the `VecMap` twice, count the elements\n         // during iteration.\n@@ -712,7 +712,7 @@ impl<V> DoubleEndedIterator for IntoIter<V> {\n #[cfg(test)]\n mod test_map {\n     use prelude::*;\n-    use core::hash::hash;\n+    use core::hash::{hash, SipHasher};\n \n     use super::VecMap;\n \n@@ -1004,7 +1004,7 @@ mod test_map {\n         let mut x = VecMap::new();\n         let mut y = VecMap::new();\n \n-        assert!(hash(&x) == hash(&y));\n+        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n         x.insert(1, 'a');\n         x.insert(2, 'b');\n         x.insert(3, 'c');\n@@ -1013,12 +1013,12 @@ mod test_map {\n         y.insert(2, 'b');\n         y.insert(1, 'a');\n \n-        assert!(hash(&x) == hash(&y));\n+        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n \n         x.insert(1000, 'd');\n         x.remove(&1000);\n \n-        assert!(hash(&x) == hash(&y));\n+        assert!(hash::<_, SipHasher>(&x) == hash::<_, SipHasher>(&y));\n     }\n \n     #[test]"}, {"sha": "0cea0b3d88e143a69a05b17d7beec5ec44fff99f", "filename": "src/libcore/array.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -18,7 +18,7 @@ use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n use fmt;\n use marker::Copy;\n-use ops::{Deref, FullRange, Index};\n+use ops::{Deref, FullRange};\n use option::Option;\n \n // macro for implementing n-ary tuple functions and operations\n@@ -35,19 +35,19 @@ macro_rules! array_impls {\n             #[unstable = \"waiting for Show to stabilize\"]\n             impl<T:fmt::Show> fmt::Show for [T; $N] {\n                 fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                    fmt::Show::fmt(&self.index(&FullRange), f)\n+                    fmt::Show::fmt(&&self[], f)\n                 }\n             }\n \n             #[stable]\n             impl<A, B> PartialEq<[B; $N]> for [A; $N] where A: PartialEq<B> {\n                 #[inline]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    self.index(&FullRange) == other.index(&FullRange)\n+                    &self[] == &other[]\n                 }\n                 #[inline]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    self.index(&FullRange) != other.index(&FullRange)\n+                    &self[] != &other[]\n                 }\n             }\n \n@@ -58,11 +58,11 @@ macro_rules! array_impls {\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &Rhs) -> bool {\n-                    PartialEq::eq(self.index(&FullRange), &**other)\n+                    PartialEq::eq(&self[], &**other)\n                 }\n                 #[inline(always)]\n                 fn ne(&self, other: &Rhs) -> bool {\n-                    PartialEq::ne(self.index(&FullRange), &**other)\n+                    PartialEq::ne(&self[], &**other)\n                 }\n             }\n \n@@ -73,11 +73,11 @@ macro_rules! array_impls {\n             {\n                 #[inline(always)]\n                 fn eq(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::eq(&**self, other.index(&FullRange))\n+                    PartialEq::eq(&**self, &other[])\n                 }\n                 #[inline(always)]\n                 fn ne(&self, other: &[B; $N]) -> bool {\n-                    PartialEq::ne(&**self, other.index(&FullRange))\n+                    PartialEq::ne(&**self, &other[])\n                 }\n             }\n \n@@ -88,31 +88,31 @@ macro_rules! array_impls {\n             impl<T:PartialOrd> PartialOrd for [T; $N] {\n                 #[inline]\n                 fn partial_cmp(&self, other: &[T; $N]) -> Option<Ordering> {\n-                    PartialOrd::partial_cmp(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::partial_cmp(&&self[], &&other[])\n                 }\n                 #[inline]\n                 fn lt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::lt(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::lt(&&self[], &&other[])\n                 }\n                 #[inline]\n                 fn le(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::le(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::le(&&self[], &&other[])\n                 }\n                 #[inline]\n                 fn ge(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::ge(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::ge(&&self[], &&other[])\n                 }\n                 #[inline]\n                 fn gt(&self, other: &[T; $N]) -> bool {\n-                    PartialOrd::gt(&self.index(&FullRange), &other.index(&FullRange))\n+                    PartialOrd::gt(&&self[], &&other[])\n                 }\n             }\n \n             #[stable]\n             impl<T:Ord> Ord for [T; $N] {\n                 #[inline]\n                 fn cmp(&self, other: &[T; $N]) -> Ordering {\n-                    Ord::cmp(&self.index(&FullRange), &other.index(&FullRange))\n+                    Ord::cmp(&&self[], &&other[])\n                 }\n             }\n         )+"}, {"sha": "4363a0a444113bc72268563dcfa86b2ebd5f9f62", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -133,7 +133,7 @@ impl<T> ToOwned<T> for T where T: Clone {\n ///     }\n /// }\n /// ```\n-//#[deriving(Show)] NOTE(stage0): uncomment after snapshot\n+#[derive(Show)]\n pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     /// Borrowed data.\n     Borrowed(&'a B),\n@@ -142,16 +142,6 @@ pub enum Cow<'a, T, B: ?Sized + 'a> where B: ToOwned<T> {\n     Owned(T)\n }\n \n-//NOTE(stage0): replace with deriving(Show) after snapshot\n-impl<'a, T, B: ?Sized> fmt::Show for Cow<'a, T, B> where\n-    B: fmt::String + ToOwned<T>,\n-    T: fmt::String\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n #[stable]\n impl<'a, T, B: ?Sized> Clone for Cow<'a, T, B> where B: ToOwned<T> {\n     fn clone(&self) -> Cow<'a, T, B> {\n@@ -248,6 +238,7 @@ impl<'a, T, B: ?Sized> PartialOrd for Cow<'a, T, B> where B: PartialOrd + ToOwne\n     }\n }\n \n+#[stable]\n impl<'a, T, B: ?Sized> fmt::String for Cow<'a, T, B> where\n     B: fmt::String + ToOwned<T>,\n     T: fmt::String,"}, {"sha": "0ffcb014c2877f558f6b9e4dc6f41e6b894fa416", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -20,7 +20,7 @@ use fmt;\n use iter::{IteratorExt, range};\n use num::{cast, Float, ToPrimitive};\n use num::FpCategory as Fp;\n-use ops::{FnOnce, Index};\n+use ops::FnOnce;\n use result::Result::Ok;\n use slice::{self, SliceExt};\n use str::{self, StrExt};\n@@ -332,5 +332,5 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         }\n     }\n \n-    f(unsafe { str::from_utf8_unchecked(buf.index(&(0..end))) })\n+    f(unsafe { str::from_utf8_unchecked(&buf[0..end]) })\n }"}, {"sha": "69df413a88c0dec8922df209e89f4e46565c2d7a", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 10, "deletions": 79, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -21,7 +21,7 @@ use mem;\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n-use ops::{Deref, FnOnce, Index};\n+use ops::{Deref, FnOnce};\n use result;\n use slice::SliceExt;\n use slice;\n@@ -219,6 +219,7 @@ impl<'a> Show for Arguments<'a> {\n     }\n }\n \n+#[stable]\n impl<'a> String for Arguments<'a> {\n     fn fmt(&self, fmt: &mut Formatter) -> Result {\n         write(fmt.buf, *self)\n@@ -424,7 +425,7 @@ impl<'a> Formatter<'a> {\n             for c in sign.into_iter() {\n                 let mut b = [0; 4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);\n-                let b = unsafe { str::from_utf8_unchecked(b.index(&(0..n))) };\n+                let b = unsafe { str::from_utf8_unchecked(&b[0..n]) };\n                 try!(f.buf.write_str(b));\n             }\n             if prefixed { f.buf.write_str(prefix) }\n@@ -532,7 +533,7 @@ impl<'a> Formatter<'a> {\n \n         let mut fill = [0u8; 4];\n         let len = self.fill.encode_utf8(&mut fill).unwrap_or(0);\n-        let fill = unsafe { str::from_utf8_unchecked(fill.index(&(..len))) };\n+        let fill = unsafe { str::from_utf8_unchecked(&fill[..len]) };\n \n         for _ in range(0, pre_pad) {\n             try!(self.buf.write_str(fill));\n@@ -627,22 +628,13 @@ impl Show for bool {\n     }\n }\n \n+#[stable]\n impl String for bool {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         String::fmt(if *self { \"true\" } else { \"false\" }, f)\n     }\n }\n \n-#[cfg(stage0)]\n-//NOTE(stage0): remove impl after snapshot\n-impl Show for str {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(self, f)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n-//NOTE(stage0): remove cfg after snapshot\n impl Show for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         try!(write!(f, \"\\\"\"));\n@@ -653,22 +645,13 @@ impl Show for str {\n     }\n }\n \n+#[stable]\n impl String for str {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(self)\n     }\n }\n \n-#[cfg(stage0)]\n-//NOTE(stage0): remove impl after snapshot\n-impl Show for char {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        String::fmt(self, f)\n-    }\n-}\n-\n-#[cfg(not(stage0))]\n-//NOTE(stage0): remove cfg after snapshot\n impl Show for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         use char::CharExt;\n@@ -680,11 +663,12 @@ impl Show for char {\n     }\n }\n \n+#[stable]\n impl String for char {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         let mut utf8 = [0u8; 4];\n         let amt = self.encode_utf8(&mut utf8).unwrap_or(0);\n-        let s: &str = unsafe { mem::transmute(utf8.index(&(0..amt))) };\n+        let s: &str = unsafe { mem::transmute(&utf8[0..amt]) };\n         String::fmt(s, f)\n     }\n }\n@@ -725,6 +709,7 @@ macro_rules! floating { ($ty:ident) => {\n         }\n     }\n \n+    #[stable]\n     impl String for $ty {\n         fn fmt(&self, fmt: &mut Formatter) -> Result {\n             use num::Float;\n@@ -796,15 +781,9 @@ floating! { f64 }\n impl<T> Show for *const T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n-impl<T> String for *const T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n-}\n impl<T> Show for *mut T {\n     fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n }\n-impl<T> String for *mut T {\n-    fn fmt(&self, f: &mut Formatter) -> Result { Pointer::fmt(self, f) }\n-}\n \n macro_rules! peel {\n     ($name:ident, $($other:ident,)*) => (tuple! { $($other,)* })\n@@ -863,61 +842,12 @@ impl<T: Show> Show for [T] {\n     }\n }\n \n-#[cfg(stage0)]\n-impl<T: Show> String for [T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f, \"[\"));\n-        }\n-        let mut is_first = true;\n-        for x in self.iter() {\n-            if is_first {\n-                is_first = false;\n-            } else {\n-                try!(write!(f, \", \"));\n-            }\n-            try!(write!(f, \"{}\", *x))\n-        }\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f, \"]\"));\n-        }\n-        Ok(())\n-    }\n-}\n-#[cfg(not(stage0))]\n-impl<T: String> String for [T] {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f, \"[\"));\n-        }\n-        let mut is_first = true;\n-        for x in self.iter() {\n-            if is_first {\n-                is_first = false;\n-            } else {\n-                try!(write!(f, \", \"));\n-            }\n-            try!(write!(f, \"{}\", *x))\n-        }\n-        if f.flags & (1 << (rt::FlagAlternate as uint)) == 0 {\n-            try!(write!(f, \"]\"));\n-        }\n-        Ok(())\n-    }\n-}\n-\n impl Show for () {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         f.pad(\"()\")\n     }\n }\n \n-impl String for () {\n-    fn fmt(&self, f: &mut Formatter) -> Result {\n-        f.pad(\"()\")\n-    }\n-}\n-\n impl<T: Copy + Show> Show for Cell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         write!(f, \"Cell {{ value: {:?} }}\", self.get())\n@@ -946,6 +876,7 @@ impl<'b, T: Show> Show for RefMut<'b, T> {\n     }\n }\n \n+#[stable]\n impl String for Utf8Error {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match *self {"}, {"sha": "1df6f8452258bb23c5e3e56de6cbe224f1d6a745", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 1, "deletions": 18, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,7 +16,6 @@\n \n use fmt;\n use iter::IteratorExt;\n-use ops::Index;\n use num::{Int, cast};\n use slice::SliceExt;\n use str;\n@@ -62,7 +61,7 @@ trait GenericRadix {\n                 if x == zero { break };                   // No more digits left to accumulate.\n             }\n         }\n-        let buf = unsafe { str::from_utf8_unchecked(buf.index(&(curr..))) };\n+        let buf = unsafe { str::from_utf8_unchecked(&buf[curr..]) };\n         f.pad_integral(is_positive, self.prefix(), buf)\n     }\n }\n@@ -155,14 +154,6 @@ pub fn radix<T>(x: T, base: u8) -> RadixFmt<T, Radix> {\n \n macro_rules! radix_fmt {\n     ($T:ty as $U:ty, $fmt:ident, $S:expr) => {\n-        #[cfg(stage0)]\n-        impl fmt::Show for RadixFmt<$T, Radix> {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                fmt::String::fmt(self, f)\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]\n         impl fmt::Show for RadixFmt<$T, Radix> {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 try!(fmt::String::fmt(self, f));\n@@ -188,14 +179,6 @@ macro_rules! int_base {\n \n macro_rules! show {\n     ($T:ident with $S:expr) => {\n-        #[cfg(stage0)]\n-        impl fmt::Show for $T {\n-            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-                fmt::String::fmt(self, f)\n-            }\n-        }\n-\n-        #[cfg(not(stage0))]\n         impl fmt::Show for $T {\n             fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n                 try!(fmt::String::fmt(self, f));"}, {"sha": "a82ea009e1361d571f8fe0797a15a3ad57e0e90a", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 333, "deletions": 140, "changes": 473, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,8 +16,7 @@\n //! # Examples\n //!\n //! ```rust\n-//! use std::hash;\n-//! use std::hash::Hash;\n+//! use std::hash::{hash, Hash, SipHasher};\n //!\n //! #[derive(Hash)]\n //! struct Person {\n@@ -29,25 +28,23 @@\n //! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n //! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n //!\n-//! assert!(hash::hash(&person1) != hash::hash(&person2));\n+//! assert!(hash::<_, SipHasher>(&person1) != hash::<_, SipHasher>(&person2));\n //! ```\n //!\n //! If you need more control over how a value is hashed, you need to implement\n //! the trait `Hash`:\n //!\n //! ```rust\n-//! use std::hash;\n-//! use std::hash::Hash;\n-//! use std::hash::sip::SipState;\n+//! use std::hash::{hash, Hash, Hasher, Writer, SipHasher};\n //!\n //! struct Person {\n //!     id: uint,\n //!     name: String,\n //!     phone: u64,\n //! }\n //!\n-//! impl Hash for Person {\n-//!     fn hash(&self, state: &mut SipState) {\n+//! impl<H: Hasher + Writer> Hash<H> for Person {\n+//!     fn hash(&self, state: &mut H) {\n //!         self.id.hash(state);\n //!         self.phone.hash(state);\n //!     }\n@@ -56,186 +53,382 @@\n //! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n //! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n //!\n-//! assert!(hash::hash(&person1) == hash::hash(&person2));\n+//! assert_eq!(hash::<_, SipHasher>(&person1), hash::<_, SipHasher>(&person2));\n //! ```\n \n-#![allow(unused_must_use)]\n+#![unstable = \"module was recently redesigned\"]\n \n-use prelude::*;\n+use default::Default;\n \n-use borrow::{Cow, ToOwned};\n-use intrinsics::TypeId;\n-use mem;\n-use num::Int;\n+pub use self::sip::SipHasher;\n \n-/// Reexport the `sip::hash` function as our default hasher.\n-pub use self::sip::hash as hash;\n+mod sip;\n \n-pub mod sip;\n+/// A hashable type.\n+///\n+/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n+/// to compute the hash. Specific implementations of this trait may specialize\n+/// for particular instances of `H` in order to be able to optimize the hashing\n+/// behavior.\n+#[cfg(stage0)]\n+pub trait Hash<H> {\n+    /// Feeds this value into the state given, updating the hasher as necessary.\n+    fn hash(&self, state: &mut H);\n+}\n \n-/// A hashable type. The `S` type parameter is an abstract hash state that is\n-/// used by the `Hash` to compute the hash. It defaults to\n-/// `std::hash::sip::SipState`.\n-pub trait Hash<S = sip::SipState> {\n-    /// Computes the hash of a value.\n-    fn hash(&self, state: &mut S);\n+/// A hashable type.\n+///\n+/// The `H` type parameter is an abstract hash state that is used by the `Hash`\n+/// to compute the hash. Specific implementations of this trait may specialize\n+/// for particular instances of `H` in order to be able to optimize the hashing\n+/// behavior.\n+#[cfg(not(stage0))]\n+pub trait Hash<H: Hasher> {\n+    /// Feeds this value into the state given, updating the hasher as necessary.\n+    fn hash(&self, state: &mut H);\n }\n \n-/// A trait that computes a hash for a value. The main users of this trait are\n-/// containers like `HashMap`, which need a generic way hash multiple types.\n-pub trait Hasher<S> {\n-    /// Compute the hash of a value.\n-    fn hash<T: ?Sized + Hash<S>>(&self, value: &T) -> u64;\n+/// A trait which represents the ability to hash an arbitrary stream of bytes.\n+pub trait Hasher {\n+    /// Result type of one run of hashing generated by this hasher.\n+    type Output;\n+\n+    /// Resets this hasher back to its initial state (as if it were just\n+    /// created).\n+    fn reset(&mut self);\n+\n+    /// Completes a round of hashing, producing the output hash generated.\n+    fn finish(&self) -> Self::Output;\n }\n \n+/// A common bound on the `Hasher` parameter to `Hash` implementations in order\n+/// to generically hash an aggregate.\n+#[experimental = \"this trait will likely be replaced by io::Writer\"]\n #[allow(missing_docs)]\n pub trait Writer {\n     fn write(&mut self, bytes: &[u8]);\n }\n \n+/// Hash a value with the default SipHasher algorithm (two initial keys of 0).\n+///\n+/// The specified value will be hashed with this hasher and then the resulting\n+/// hash will be returned.\n+pub fn hash<T: Hash<H>, H: Hasher + Default>(value: &T) -> H::Output {\n+    let mut h: H = Default::default();\n+    value.hash(&mut h);\n+    h.finish()\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n \n-macro_rules! impl_hash {\n-    ($ty:ident, $uty:ident) => {\n-        impl<S: Writer> Hash<S> for $ty {\n-            #[inline]\n-            fn hash(&self, state: &mut S) {\n-                let a: [u8; ::$ty::BYTES] = unsafe {\n-                    mem::transmute((*self as $uty).to_le() as $ty)\n-                };\n-                state.write(a.as_slice())\n+#[cfg(stage0)]\n+mod impls {\n+    use prelude::*;\n+\n+    use borrow::{Cow, ToOwned};\n+    use intrinsics::TypeId;\n+    use mem;\n+    use super::{Hash, Writer};\n+    use num::Int;\n+\n+    macro_rules! impl_hash {\n+        ($ty:ident, $uty:ident) => {\n+            impl<S: Writer> Hash<S> for $ty {\n+                #[inline]\n+                fn hash(&self, state: &mut S) {\n+                    let a: [u8; ::$ty::BYTES] = unsafe {\n+                        mem::transmute((*self as $uty).to_le() as $ty)\n+                    };\n+                    state.write(a.as_slice())\n+                }\n             }\n         }\n     }\n-}\n \n-impl_hash! { u8, u8 }\n-impl_hash! { u16, u16 }\n-impl_hash! { u32, u32 }\n-impl_hash! { u64, u64 }\n-impl_hash! { uint, uint }\n-impl_hash! { i8, u8 }\n-impl_hash! { i16, u16 }\n-impl_hash! { i32, u32 }\n-impl_hash! { i64, u64 }\n-impl_hash! { int, uint }\n-\n-impl<S: Writer> Hash<S> for bool {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u8).hash(state);\n+    impl_hash! { u8, u8 }\n+    impl_hash! { u16, u16 }\n+    impl_hash! { u32, u32 }\n+    impl_hash! { u64, u64 }\n+    impl_hash! { uint, uint }\n+    impl_hash! { i8, u8 }\n+    impl_hash! { i16, u16 }\n+    impl_hash! { i32, u32 }\n+    impl_hash! { i64, u64 }\n+    impl_hash! { int, uint }\n+\n+    impl<S: Writer> Hash<S> for bool {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u8).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer> Hash<S> for char {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (*self as u32).hash(state);\n+    impl<S: Writer> Hash<S> for char {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u32).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer> Hash<S> for str {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        state.write(self.as_bytes());\n-        0xffu8.hash(state)\n+    impl<S: Writer> Hash<S> for str {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            state.write(self.as_bytes());\n+            0xffu8.hash(state)\n+        }\n     }\n-}\n \n-macro_rules! impl_hash_tuple {\n-    () => (\n-        impl<S: Writer> Hash<S> for () {\n-            #[inline]\n-            fn hash(&self, state: &mut S) {\n-                state.write(&[]);\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            impl<S> Hash<S> for () {\n+                #[inline]\n+                fn hash(&self, _state: &mut S) {}\n             }\n-        }\n-    );\n-\n-    ( $($name:ident)+) => (\n-        impl<S: Writer, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n-            #[inline]\n-            #[allow(non_snake_case)]\n-            fn hash(&self, state: &mut S) {\n-                match *self {\n-                    ($(ref $name,)*) => {\n-                        $(\n-                            $name.hash(state);\n-                        )*\n+        );\n+\n+        ( $($name:ident)+) => (\n+            impl<S, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n+                #[inline]\n+                #[allow(non_snake_case)]\n+                fn hash(&self, state: &mut S) {\n+                    match *self {\n+                        ($(ref $name,)*) => {\n+                            $(\n+                                $name.hash(state);\n+                            )*\n+                        }\n                     }\n                 }\n             }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.len().hash(state);\n+            for elt in self.iter() {\n+                elt.hash(state);\n+            }\n         }\n-    );\n-}\n+    }\n+\n \n-impl_hash_tuple! {}\n-impl_hash_tuple! { A }\n-impl_hash_tuple! { A B }\n-impl_hash_tuple! { A B C }\n-impl_hash_tuple! { A B C D }\n-impl_hash_tuple! { A B C D E }\n-impl_hash_tuple! { A B C D E F }\n-impl_hash_tuple! { A B C D E F G }\n-impl_hash_tuple! { A B C D E F G H }\n-impl_hash_tuple! { A B C D E F G H I }\n-impl_hash_tuple! { A B C D E F G H I J }\n-impl_hash_tuple! { A B C D E F G H I J K }\n-impl_hash_tuple! { A B C D E F G H I J K L }\n-\n-impl<S: Writer, T: Hash<S>> Hash<S> for [T] {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.len().hash(state);\n-        for elt in self.iter() {\n-            elt.hash(state);\n+    impl<'a, S, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n         }\n     }\n-}\n \n+    impl<'a, S, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n+        }\n+    }\n \n-impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n+    impl<S: Writer, T> Hash<S> for *const T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n     }\n-}\n \n-impl<'a, S: Writer, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        (**self).hash(state);\n+    impl<S: Writer, T> Hash<S> for *mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n     }\n-}\n \n-impl<S: Writer, T> Hash<S> for *const T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n+    impl<S: Writer> Hash<S> for TypeId {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.hash().hash(state)\n+        }\n     }\n-}\n \n-impl<S: Writer, T> Hash<S> for *mut T {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        // NB: raw-pointer Hash does _not_ dereference\n-        // to the target; it just gives you the pointer-bytes.\n-        (*self as uint).hash(state);\n+    impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B>\n+        where B: Hash<S> + ToOwned<T>\n+    {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            Hash::hash(&**self, state)\n+        }\n     }\n }\n \n-impl<S: Writer> Hash<S> for TypeId {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        self.hash().hash(state)\n+#[cfg(not(stage0))]\n+mod impls {\n+    use prelude::*;\n+\n+    use borrow::{Cow, ToOwned};\n+    use intrinsics::TypeId;\n+    use mem;\n+    use super::{Hash, Writer, Hasher};\n+    use num::Int;\n+\n+    macro_rules! impl_hash {\n+        ($ty:ident, $uty:ident) => {\n+            impl<S: Writer + Hasher> Hash<S> for $ty {\n+                #[inline]\n+                fn hash(&self, state: &mut S) {\n+                    let a: [u8; ::$ty::BYTES] = unsafe {\n+                        mem::transmute((*self as $uty).to_le() as $ty)\n+                    };\n+                    state.write(a.as_slice())\n+                }\n+            }\n+        }\n+    }\n+\n+    impl_hash! { u8, u8 }\n+    impl_hash! { u16, u16 }\n+    impl_hash! { u32, u32 }\n+    impl_hash! { u64, u64 }\n+    impl_hash! { uint, uint }\n+    impl_hash! { i8, u8 }\n+    impl_hash! { i16, u16 }\n+    impl_hash! { i32, u32 }\n+    impl_hash! { i64, u64 }\n+    impl_hash! { int, uint }\n+\n+    impl<S: Writer + Hasher> Hash<S> for bool {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u8).hash(state);\n+        }\n+    }\n+\n+    impl<S: Writer + Hasher> Hash<S> for char {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (*self as u32).hash(state);\n+        }\n+    }\n+\n+    impl<S: Writer + Hasher> Hash<S> for str {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            state.write(self.as_bytes());\n+            0xffu8.hash(state)\n+        }\n+    }\n+\n+    macro_rules! impl_hash_tuple {\n+        () => (\n+            impl<S: Hasher> Hash<S> for () {\n+                #[inline]\n+                fn hash(&self, _state: &mut S) {}\n+            }\n+        );\n+\n+        ( $($name:ident)+) => (\n+            impl<S: Hasher, $($name: Hash<S>),*> Hash<S> for ($($name,)*) {\n+                #[inline]\n+                #[allow(non_snake_case)]\n+                fn hash(&self, state: &mut S) {\n+                    match *self {\n+                        ($(ref $name,)*) => {\n+                            $(\n+                                $name.hash(state);\n+                            )*\n+                        }\n+                    }\n+                }\n+            }\n+        );\n+    }\n+\n+    impl_hash_tuple! {}\n+    impl_hash_tuple! { A }\n+    impl_hash_tuple! { A B }\n+    impl_hash_tuple! { A B C }\n+    impl_hash_tuple! { A B C D }\n+    impl_hash_tuple! { A B C D E }\n+    impl_hash_tuple! { A B C D E F }\n+    impl_hash_tuple! { A B C D E F G }\n+    impl_hash_tuple! { A B C D E F G H }\n+    impl_hash_tuple! { A B C D E F G H I }\n+    impl_hash_tuple! { A B C D E F G H I J }\n+    impl_hash_tuple! { A B C D E F G H I J K }\n+    impl_hash_tuple! { A B C D E F G H I J K L }\n+\n+    impl<S: Writer + Hasher, T: Hash<S>> Hash<S> for [T] {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.len().hash(state);\n+            for elt in self.iter() {\n+                elt.hash(state);\n+            }\n+        }\n+    }\n+\n+\n+    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n+        }\n+    }\n+\n+    impl<'a, S: Hasher, T: ?Sized + Hash<S>> Hash<S> for &'a mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            (**self).hash(state);\n+        }\n     }\n-}\n \n-impl<'a, T, B: ?Sized, S> Hash<S> for Cow<'a, T, B> where B: Hash<S> + ToOwned<T> {\n-    #[inline]\n-    fn hash(&self, state: &mut S) {\n-        Hash::hash(&**self, state)\n+    impl<S: Writer + Hasher, T> Hash<S> for *const T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n+    }\n+\n+    impl<S: Writer + Hasher, T> Hash<S> for *mut T {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            // NB: raw-pointer Hash does _not_ dereference\n+            // to the target; it just gives you the pointer-bytes.\n+            (*self as uint).hash(state);\n+        }\n+    }\n+\n+    impl<S: Writer + Hasher> Hash<S> for TypeId {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            self.hash().hash(state)\n+        }\n+    }\n+\n+    impl<'a, T, B: ?Sized, S: Hasher> Hash<S> for Cow<'a, T, B>\n+        where B: Hash<S> + ToOwned<T>\n+    {\n+        #[inline]\n+        fn hash(&self, state: &mut S) {\n+            Hash::hash(&**self, state)\n+        }\n     }\n }"}, {"sha": "c20fb8457d26ed6d90d538f90028b50504dbc1f5", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 67, "deletions": 393, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -11,27 +11,27 @@\n // ignore-lexer-test FIXME #15883\n \n //! An implementation of SipHash 2-4.\n-//!\n-//! See: http://131002.net/siphash/\n-//!\n-//! Consider this as a main \"general-purpose\" hash for all hashtables: it\n-//! runs at good speed (competitive with spooky and city) and permits\n-//! strong _keyed_ hashing. Key your hashtables from a strong RNG,\n-//! such as `rand::Rng`.\n-//!\n-//! Although the SipHash algorithm is considered to be cryptographically\n-//! strong, this implementation has not been reviewed for such purposes.\n-//! As such, all cryptographic uses of this implementation are strongly\n-//! discouraged.\n \n use prelude::*;\n use default::Default;\n \n-use super::{Hash, Hasher, Writer};\n-\n-/// `SipState` computes a SipHash 2-4 hash over a stream of bytes.\n-#[derive(Copy)]\n-pub struct SipState {\n+use super::{Hasher, Writer};\n+\n+/// An implementation of SipHash 2-4.\n+///\n+/// See: http://131002.net/siphash/\n+///\n+/// Consider this as a main \"general-purpose\" hash for all hashtables: it\n+/// runs at good speed (competitive with spooky and city) and permits\n+/// strong _keyed_ hashing. Key your hashtables from a strong RNG,\n+/// such as `rand::Rng`.\n+///\n+/// Although the SipHash algorithm is considered to be cryptographically\n+/// strong, this implementation has not been reviewed for such purposes.\n+/// As such, all cryptographic uses of this implementation are strongly\n+/// discouraged.\n+#[allow(missing_copy_implementations)]\n+pub struct SipHasher {\n     k0: u64,\n     k1: u64,\n     length: uint, // how many bytes we've processed\n@@ -86,17 +86,17 @@ macro_rules! compress {\n     })\n }\n \n-impl SipState {\n-    /// Creates a `SipState` that is keyed off the provided keys.\n+impl SipHasher {\n+    /// Creates a new `SipHasher` with the two initial keys set to 0.\n     #[inline]\n-    pub fn new() -> SipState {\n-        SipState::new_with_keys(0, 0)\n+    pub fn new() -> SipHasher {\n+        SipHasher::new_with_keys(0, 0)\n     }\n \n-    /// Creates a `SipState` that is keyed off the provided keys.\n+    /// Creates a `SipHasher` that is keyed off the provided keys.\n     #[inline]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipState {\n-        let mut state = SipState {\n+    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n+        let mut state = SipHasher {\n             k0: key0,\n             k1: key1,\n             length: 0,\n@@ -111,43 +111,12 @@ impl SipState {\n         state\n     }\n \n-    /// Resets the state to its initial state.\n-    #[inline]\n-    pub fn reset(&mut self) {\n-        self.length = 0;\n-        self.v0 = self.k0 ^ 0x736f6d6570736575;\n-        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n-        self.v2 = self.k0 ^ 0x6c7967656e657261;\n-        self.v3 = self.k1 ^ 0x7465646279746573;\n-        self.ntail = 0;\n-    }\n-\n     /// Returns the computed hash.\n-    #[inline]\n-    pub fn result(&self) -> u64 {\n-        let mut v0 = self.v0;\n-        let mut v1 = self.v1;\n-        let mut v2 = self.v2;\n-        let mut v3 = self.v3;\n-\n-        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n-\n-        v3 ^= b;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        v0 ^= b;\n-\n-        v2 ^= 0xff;\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-        compress!(v0, v1, v2, v3);\n-\n-        v0 ^ v1 ^ v2 ^ v3\n-    }\n+    #[deprecated = \"renamed to finish\"]\n+    pub fn result(&self) -> u64 { self.finish() }\n }\n \n-impl Writer for SipState {\n+impl Writer for SipHasher {\n     #[inline]\n     fn write(&mut self, msg: &[u8]) {\n         let length = msg.len();\n@@ -195,355 +164,60 @@ impl Writer for SipState {\n     }\n }\n \n-#[stable]\n-impl Clone for SipState {\n-    #[inline]\n-    fn clone(&self) -> SipState {\n-        *self\n-    }\n-}\n+impl Hasher for SipHasher {\n+    type Output = u64;\n \n-#[stable]\n-impl Default for SipState {\n-    #[inline]\n-    #[stable]\n-    fn default() -> SipState {\n-        SipState::new()\n+    fn reset(&mut self) {\n+        self.length = 0;\n+        self.v0 = self.k0 ^ 0x736f6d6570736575;\n+        self.v1 = self.k1 ^ 0x646f72616e646f6d;\n+        self.v2 = self.k0 ^ 0x6c7967656e657261;\n+        self.v3 = self.k1 ^ 0x7465646279746573;\n+        self.ntail = 0;\n     }\n-}\n \n-/// `SipHasher` computes the SipHash algorithm from a stream of bytes.\n-#[derive(Clone)]\n-#[allow(missing_copy_implementations)]\n-pub struct SipHasher {\n-    k0: u64,\n-    k1: u64,\n-}\n+    fn finish(&self) -> u64 {\n+        let mut v0 = self.v0;\n+        let mut v1 = self.v1;\n+        let mut v2 = self.v2;\n+        let mut v3 = self.v3;\n \n-impl SipHasher {\n-    /// Creates a `Sip`.\n-    #[inline]\n-    pub fn new() -> SipHasher {\n-        SipHasher::new_with_keys(0, 0)\n-    }\n+        let b: u64 = ((self.length as u64 & 0xff) << 56) | self.tail;\n \n-    /// Creates a `Sip` that is keyed off the provided keys.\n-    #[inline]\n-    pub fn new_with_keys(key0: u64, key1: u64) -> SipHasher {\n-        SipHasher {\n-            k0: key0,\n-            k1: key1,\n-        }\n+        v3 ^= b;\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        v0 ^= b;\n+\n+        v2 ^= 0xff;\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+        compress!(v0, v1, v2, v3);\n+\n+        v0 ^ v1 ^ v2 ^ v3\n     }\n }\n \n-impl Hasher<SipState> for SipHasher {\n+impl Clone for SipHasher {\n     #[inline]\n-    fn hash<T: ?Sized + Hash<SipState>>(&self, value: &T) -> u64 {\n-        let mut state = SipState::new_with_keys(self.k0, self.k1);\n-        value.hash(&mut state);\n-        state.result()\n+    fn clone(&self) -> SipHasher {\n+        SipHasher {\n+            k0: self.k0,\n+            k1: self.k1,\n+            length: self.length,\n+            v0: self.v0,\n+            v1: self.v1,\n+            v2: self.v2,\n+            v3: self.v3,\n+            tail: self.tail,\n+            ntail: self.ntail,\n+        }\n     }\n }\n \n impl Default for SipHasher {\n-    #[inline]\n     fn default() -> SipHasher {\n         SipHasher::new()\n     }\n }\n-\n-/// Hashes a value using the SipHash algorithm.\n-#[inline]\n-pub fn hash<T: ?Sized + Hash<SipState>>(value: &T) -> u64 {\n-    let mut state = SipState::new();\n-    value.hash(&mut state);\n-    state.result()\n-}\n-\n-/// Hashes a value with the SipHash algorithm with the provided keys.\n-#[inline]\n-pub fn hash_with_keys<T: ?Sized + Hash<SipState>>(k0: u64, k1: u64, value: &T) -> u64 {\n-    let mut state = SipState::new_with_keys(k0, k1);\n-    value.hash(&mut state);\n-    state.result()\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use test::Bencher;\n-    use prelude::*;\n-    use std::fmt;\n-\n-    use super::super::{Hash, Writer};\n-    use super::{SipState, hash, hash_with_keys};\n-\n-    // Hash just the bytes of the slice, without length prefix\n-    struct Bytes<'a>(&'a [u8]);\n-\n-    impl<'a, S: Writer> Hash<S> for Bytes<'a> {\n-        #[allow(unused_must_use)]\n-        fn hash(&self, state: &mut S) {\n-            let Bytes(v) = *self;\n-            state.write(v);\n-        }\n-    }\n-\n-    #[test]\n-    #[allow(unused_must_use)]\n-    fn test_siphash() {\n-        let vecs : [[u8; 8]; 64] = [\n-            [ 0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72, ],\n-            [ 0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74, ],\n-            [ 0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d, ],\n-            [ 0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85, ],\n-            [ 0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf, ],\n-            [ 0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18, ],\n-            [ 0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb, ],\n-            [ 0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab, ],\n-            [ 0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93, ],\n-            [ 0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e, ],\n-            [ 0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a, ],\n-            [ 0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4, ],\n-            [ 0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75, ],\n-            [ 0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14, ],\n-            [ 0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7, ],\n-            [ 0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1, ],\n-            [ 0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f, ],\n-            [ 0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69, ],\n-            [ 0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b, ],\n-            [ 0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb, ],\n-            [ 0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe, ],\n-            [ 0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0, ],\n-            [ 0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93, ],\n-            [ 0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8, ],\n-            [ 0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8, ],\n-            [ 0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc, ],\n-            [ 0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17, ],\n-            [ 0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f, ],\n-            [ 0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde, ],\n-            [ 0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6, ],\n-            [ 0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad, ],\n-            [ 0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32, ],\n-            [ 0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71, ],\n-            [ 0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7, ],\n-            [ 0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12, ],\n-            [ 0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15, ],\n-            [ 0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31, ],\n-            [ 0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02, ],\n-            [ 0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca, ],\n-            [ 0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a, ],\n-            [ 0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e, ],\n-            [ 0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad, ],\n-            [ 0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18, ],\n-            [ 0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4, ],\n-            [ 0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9, ],\n-            [ 0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9, ],\n-            [ 0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb, ],\n-            [ 0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0, ],\n-            [ 0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6, ],\n-            [ 0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7, ],\n-            [ 0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee, ],\n-            [ 0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1, ],\n-            [ 0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a, ],\n-            [ 0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81, ],\n-            [ 0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f, ],\n-            [ 0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24, ],\n-            [ 0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7, ],\n-            [ 0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea, ],\n-            [ 0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60, ],\n-            [ 0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66, ],\n-            [ 0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c, ],\n-            [ 0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f, ],\n-            [ 0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5, ],\n-            [ 0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95, ]\n-        ];\n-\n-        let k0 = 0x_07_06_05_04_03_02_01_00_u64;\n-        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08_u64;\n-        let mut buf = Vec::new();\n-        let mut t = 0;\n-        let mut state_inc = SipState::new_with_keys(k0, k1);\n-        let mut state_full = SipState::new_with_keys(k0, k1);\n-\n-        fn to_hex_str(r: &[u8; 8]) -> String {\n-            let mut s = String::new();\n-            for b in r.iter() {\n-                s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n-            }\n-            s\n-        }\n-\n-        fn result_bytes(h: u64) -> Vec<u8> {\n-            vec![(h >> 0) as u8,\n-              (h >> 8) as u8,\n-              (h >> 16) as u8,\n-              (h >> 24) as u8,\n-              (h >> 32) as u8,\n-              (h >> 40) as u8,\n-              (h >> 48) as u8,\n-              (h >> 56) as u8,\n-            ]\n-        }\n-\n-        fn result_str(h: u64) -> String {\n-            let r = result_bytes(h);\n-            let mut s = String::new();\n-            for b in r.iter() {\n-                s.push_str(format!(\"{}\", fmt::radix(*b, 16)).as_slice());\n-            }\n-            s\n-        }\n-\n-        while t < 64 {\n-            debug!(\"siphash test {}: {}\", t, buf);\n-            let vec = u8to64_le!(vecs[t], 0);\n-            let out = hash_with_keys(k0, k1, &Bytes(buf.as_slice()));\n-            debug!(\"got {}, expected {}\", out, vec);\n-            assert_eq!(vec, out);\n-\n-            state_full.reset();\n-            state_full.write(buf.as_slice());\n-            let f = result_str(state_full.result());\n-            let i = result_str(state_inc.result());\n-            let v = to_hex_str(&vecs[t]);\n-            debug!(\"{}: ({}) => inc={} full={}\", t, v, i, f);\n-\n-            assert_eq!(f, i);\n-            assert_eq!(f, v);\n-\n-            buf.push(t as u8);\n-            state_inc.write(&[t as u8]);\n-\n-            t += 1;\n-        }\n-    }\n-\n-    #[test] #[cfg(target_arch = \"aarch64\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n-        assert!(hash(&(val as u32)) != hash(&(val as uint)));\n-    }\n-    #[test] #[cfg(target_arch = \"arm\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-        assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n-    }\n-    #[test] #[cfg(target_arch = \"x86_64\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&(val as u64)), hash(&(val as uint)));\n-        assert!(hash(&(val as u32)) != hash(&(val as uint)));\n-    }\n-    #[test] #[cfg(target_arch = \"x86\")]\n-    fn test_hash_uint() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-        assert!(hash(&(val as u64)) != hash(&(val as uint)));\n-        assert_eq!(hash(&(val as u32)), hash(&(val as uint)));\n-    }\n-\n-    #[test]\n-    fn test_hash_idempotent() {\n-        let val64 = 0xdeadbeef_deadbeef_u64;\n-        assert_eq!(hash(&val64), hash(&val64));\n-        let val32 = 0xdeadbeef_u32;\n-        assert_eq!(hash(&val32), hash(&val32));\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_64() {\n-        let val = 0xdeadbeef_deadbeef_u64;\n-\n-        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 4)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 5)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 6)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 7)));\n-\n-        fn zero_byte(val: u64, byte: uint) -> u64 {\n-            assert!(byte < 8);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_bytes_dropped_32() {\n-        let val = 0xdeadbeef_u32;\n-\n-        assert!(hash(&val) != hash(&zero_byte(val, 0)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 1)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 2)));\n-        assert!(hash(&val) != hash(&zero_byte(val, 3)));\n-\n-        fn zero_byte(val: u32, byte: uint) -> u32 {\n-            assert!(byte < 4);\n-            val & !(0xff << (byte * 8))\n-        }\n-    }\n-\n-    #[test]\n-    fn test_hash_no_concat_alias() {\n-        let s = (\"aa\", \"bb\");\n-        let t = (\"aabb\", \"\");\n-        let u = (\"a\", \"abb\");\n-\n-        assert!(s != t && t != u);\n-        assert!(hash(&s) != hash(&t) && hash(&s) != hash(&u));\n-\n-        let v: (&[u8], &[u8], &[u8]) = (&[1u8], &[0u8, 0], &[0u8]);\n-        let w: (&[u8], &[u8], &[u8]) = (&[1u8, 0, 0, 0], &[], &[]);\n-\n-        assert!(v != w);\n-        assert!(hash(&v) != hash(&w));\n-    }\n-\n-    #[bench]\n-    fn bench_str_under_8_bytes(b: &mut Bencher) {\n-        let s = \"foo\";\n-        b.iter(|| {\n-            assert_eq!(hash(&s), 16262950014981195938);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_str_of_8_bytes(b: &mut Bencher) {\n-        let s = \"foobar78\";\n-        b.iter(|| {\n-            assert_eq!(hash(&s), 4898293253460910787);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_str_over_8_bytes(b: &mut Bencher) {\n-        let s = \"foobarbaz0\";\n-        b.iter(|| {\n-            assert_eq!(hash(&s), 10581415515220175264);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_long_str(b: &mut Bencher) {\n-        let s = \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor \\\n-incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud \\\n-exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute \\\n-irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla \\\n-pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui \\\n-officia deserunt mollit anim id est laborum.\";\n-        b.iter(|| {\n-            assert_eq!(hash(&s), 17717065544121360093);\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_u64(b: &mut Bencher) {\n-        let u = 16262950014981195938u64;\n-        b.iter(|| {\n-            assert_eq!(hash(&u), 5254097107239593357);\n-        })\n-    }\n-}"}, {"sha": "c8b3616a4042e293b40b033c41cf2be957e9de63", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -42,6 +42,9 @@\n #![experimental]\n #![allow(missing_docs)]\n \n+#[cfg(not(stage0))]\n+use marker::Sized;\n+\n pub type GlueFn = extern \"Rust\" fn(*const i8);\n \n #[lang=\"ty_desc\"]\n@@ -200,6 +203,10 @@ extern \"rust-intrinsic\" {\n     /// Gets an identifier which is globally unique to the specified type. This\n     /// function will return the same value for a type regardless of whichever\n     /// crate it is invoked in.\n+    #[cfg(not(stage0))]\n+    pub fn type_id<T: ?Sized + 'static>() -> TypeId;\n+\n+    #[cfg(stage0)]\n     pub fn type_id<T: 'static>() -> TypeId;\n \n     /// Create a value initialized to zero.\n@@ -551,8 +558,15 @@ pub struct TypeId {\n \n impl TypeId {\n     /// Returns the `TypeId` of the type this generic function has been instantiated with\n+    #[cfg(not(stage0))]\n+    pub fn of<T: ?Sized + 'static>() -> TypeId {\n+        unsafe { type_id::<T>() }\n+    }\n+\n+    #[cfg(stage0)]\n     pub fn of<T: 'static>() -> TypeId {\n         unsafe { type_id::<T>() }\n     }\n+\n     pub fn hash(&self) -> u64 { self.t }\n }"}, {"sha": "273a51665ce8aaad77befe2df0c668fe39c0e95c", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -2344,7 +2344,7 @@ impl<A, I, F> RandomAccessIterator for Inspect<A, I, F> where\n ///\n /// // This iterator will yield up to the last Fibonacci number before the max value of `u32`.\n /// // You can simply change `u32` to `u64` in this line if you want higher values than that.\n-/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)), |&(ref mut x2, ref mut x1)| {\n+/// let mut fibonacci = Unfold::new((Some(0u32), Some(1u32)), |&mut (ref mut x2, ref mut x1)| {\n ///     // Attempt to get the next Fibonacci number\n ///     // `x1` will be `None` if previously overflowed.\n ///     let next = match (*x2, *x1) {\n@@ -2749,9 +2749,9 @@ macro_rules! step_impl_no_between {\n }\n \n step_impl!(uint u8 u16 u32 int i8 i16 i32);\n-#[cfg(target_word_size = \"64\")]\n+#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n step_impl!(u64 i64);\n-#[cfg(target_word_size = \"32\")]\n+#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n step_impl_no_between!(u64 i64);\n \n \n@@ -2804,7 +2804,7 @@ pub fn iterate<T, F>(seed: T, f: F) -> Iterate<T, F> where\n         T: Clone,\n         F: FnMut(T) -> T,\n     {\n-        let &(ref mut f, ref mut val, ref mut first) = st;\n+        let &mut (ref mut f, ref mut val, ref mut first) = st;\n         if *first {\n             *first = false;\n         } else {"}, {"sha": "af5aba53bf4787bc54717213514b7e8766a2fd75", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -49,6 +49,7 @@\n \n #![crate_name = \"core\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n@@ -57,6 +58,7 @@\n \n #![no_std]\n #![allow(unknown_features, raw_pointer_derive)]\n+#![cfg_attr(stage0, allow(unused_attributes))]\n #![feature(intrinsics, lang_items)]\n #![feature(simd, unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n@@ -78,12 +80,14 @@ mod int_macros;\n mod uint_macros;\n \n #[path = \"num/int.rs\"]  pub mod int;\n+#[path = \"num/isize.rs\"]  pub mod isize;\n #[path = \"num/i8.rs\"]   pub mod i8;\n #[path = \"num/i16.rs\"]  pub mod i16;\n #[path = \"num/i32.rs\"]  pub mod i32;\n #[path = \"num/i64.rs\"]  pub mod i64;\n \n #[path = \"num/uint.rs\"] pub mod uint;\n+#[path = \"num/usize.rs\"] pub mod usize;\n #[path = \"num/u8.rs\"]   pub mod u8;\n #[path = \"num/u16.rs\"]  pub mod u16;\n #[path = \"num/u32.rs\"]  pub mod u32;\n@@ -146,8 +150,6 @@ mod core {\n mod std {\n     pub use clone;\n     pub use cmp;\n-    #[cfg(stage0)]\n-    pub use marker as kinds;\n     pub use marker;\n     pub use option;\n     pub use fmt;"}, {"sha": "065763a0d8ed4394a95f938053e7724e8ded1eab", "filename": "src/libcore/num/int.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -8,10 +8,16 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Operations and constants for architecture-sized signed integers (`int` type)\n+//! Deprecated: replaced by `isize`.\n+//!\n+//! The rollout of the new type will gradually take place over the\n+//! alpha cycle along with the development of clearer conventions\n+//! around integer types.\n \n-#![stable]\n-#![doc(primitive = \"int\")]\n+#![deprecated = \"replaced by isize\"]\n \n-#[cfg(target_word_size = \"32\")] int_module! { int, 32 }\n-#[cfg(target_word_size = \"64\")] int_module! { int, 64 }\n+#[cfg(stage0)] #[cfg(target_word_size = \"32\")] int_module! { int, 32 }\n+#[cfg(stage0)] #[cfg(target_word_size = \"64\")] int_module! { int, 64 }\n+\n+#[cfg(not(stage0))] #[cfg(target_pointer_width = \"32\")] int_module! { int, 32 }\n+#[cfg(not(stage0))] #[cfg(target_pointer_width = \"64\")] int_module! { int, 64 }"}, {"sha": "c1cf3c6213148c35c5306b570fb61a24555e7e96", "filename": "src/libcore/num/isize.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for pointer-sized signed integers (`isize` type)\n+//!\n+//! This type was recently added to replace `int`. The rollout of the\n+//! new type will gradually take place over the alpha cycle along with\n+//! the development of clearer conventions around integer types.\n+\n+#![stable]\n+#![doc(primitive = \"isize\")]\n+\n+#[cfg(any(all(stage0, target_word_size = \"32\"),\n+          all(not(stage0), target_pointer_width = \"32\")))]\n+int_module! { isize, 32 }\n+#[cfg(any(all(stage0, target_word_size = \"64\"),\n+          all(not(stage0), target_pointer_width = \"64\")))]\n+int_module! { isize, 64 }"}, {"sha": "91fed8a31bd40b086faa86aed422446318c20c37", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -24,7 +24,7 @@ use iter::IteratorExt;\n use marker::Copy;\n use mem::size_of;\n use ops::{Add, Sub, Mul, Div, Rem, Neg};\n-use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr, Index};\n+use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n use option::Option::{Some, None};\n use str::{FromStr, StrExt};\n@@ -496,7 +496,7 @@ uint_impl! { u64 = u64, 64,\n     intrinsics::u64_sub_with_overflow,\n     intrinsics::u64_mul_with_overflow }\n \n-#[cfg(target_word_size = \"32\")]\n+#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n uint_impl! { uint = u32, 32,\n     intrinsics::ctpop32,\n     intrinsics::ctlz32,\n@@ -506,7 +506,7 @@ uint_impl! { uint = u32, 32,\n     intrinsics::u32_sub_with_overflow,\n     intrinsics::u32_mul_with_overflow }\n \n-#[cfg(target_word_size = \"64\")]\n+#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n uint_impl! { uint = u64, 64,\n     intrinsics::ctpop64,\n     intrinsics::ctlz64,\n@@ -601,13 +601,13 @@ int_impl! { i64 = i64, u64, 64,\n     intrinsics::i64_sub_with_overflow,\n     intrinsics::i64_mul_with_overflow }\n \n-#[cfg(target_word_size = \"32\")]\n+#[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n int_impl! { int = i32, u32, 32,\n     intrinsics::i32_add_with_overflow,\n     intrinsics::i32_sub_with_overflow,\n     intrinsics::i32_mul_with_overflow }\n \n-#[cfg(target_word_size = \"64\")]\n+#[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n int_impl! { int = i64, u64, 64,\n     intrinsics::i64_add_with_overflow,\n     intrinsics::i64_sub_with_overflow,\n@@ -1577,7 +1577,7 @@ macro_rules! from_str_radix_float_impl {\n                         };\n \n                         // Parse the exponent as decimal integer\n-                        let src = src.index(&(offset..));\n+                        let src = &src[offset..];\n                         let (is_positive, exp) = match src.slice_shift_char() {\n                             Some(('-', src)) => (false, src.parse::<uint>()),\n                             Some(('+', src)) => (true,  src.parse::<uint>()),"}, {"sha": "7931890ca5efbe2166262cace53f5fd9ae51dd08", "filename": "src/libcore/num/uint.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -8,9 +8,12 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! Operations and constants for architecture-sized unsigned integers (`uint` type)\n+//! Deprecated: replaced by `usize`.\n+//!\n+//! The rollout of the new type will gradually take place over the\n+//! alpha cycle along with the development of clearer conventions\n+//! around integer types.\n \n-#![stable]\n-#![doc(primitive = \"uint\")]\n+#![deprecated = \"replaced by usize\"]\n \n uint_module! { uint, int, ::int::BITS }"}, {"sha": "5eebcd51a7765d0ac7d6114a5a5e087e566ab961", "filename": "src/libcore/num/usize.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Operations and constants for pointer-sized unsigned integers (`usize` type)\n+//!\n+//! This type was recently added to replace `uint`. The rollout of the\n+//! new type will gradually take place over the alpha cycle along with\n+//! the development of clearer conventions around integer types.\n+\n+#![stable]\n+#![doc(primitive = \"usize\")]\n+\n+uint_module! { usize, isize, ::isize::BITS }"}, {"sha": "ab956587d8248045d0d680322c530dbd5e1a3869", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 33, "deletions": 4, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -65,6 +65,7 @@ use clone::Clone;\n use iter::{Step, Iterator,DoubleEndedIterator,ExactSizeIterator};\n use marker::Sized;\n use option::Option::{self, Some, None};\n+use fmt;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope. This\n /// is sometimes called a 'destructor'.\n@@ -847,13 +848,20 @@ pub trait IndexMut<Index: ?Sized> {\n }\n \n /// An unbounded range.\n-#[derive(Copy)]\n+#[derive(Copy, PartialEq, Eq)]\n #[lang=\"full_range\"]\n #[unstable = \"API still in development\"]\n pub struct FullRange;\n \n+#[unstable = \"API still in development\"]\n+impl fmt::Show for FullRange {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Show::fmt(\"..\", fmt)\n+    }\n+}\n+\n /// A (half-open) range which is bounded at both ends.\n-#[derive(Copy)]\n+#[derive(Copy, PartialEq, Eq)]\n #[lang=\"range\"]\n #[unstable = \"API still in development\"]\n pub struct Range<Idx> {\n@@ -904,8 +912,15 @@ impl<Idx: Clone + Step> DoubleEndedIterator for Range<Idx> {\n #[unstable = \"API still in development\"]\n impl<Idx: Clone + Step> ExactSizeIterator for Range<Idx> {}\n \n+#[unstable = \"API still in development\"]\n+impl<Idx: fmt::Show> fmt::Show for Range<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}..{:?}\", self.start, self.end)\n+    }\n+}\n+\n /// A range which is only bounded below.\n-#[derive(Copy)]\n+#[derive(Copy, PartialEq, Eq)]\n #[lang=\"range_from\"]\n #[unstable = \"API still in development\"]\n pub struct RangeFrom<Idx> {\n@@ -926,15 +941,29 @@ impl<Idx: Clone + Step> Iterator for RangeFrom<Idx> {\n     }\n }\n \n+#[unstable = \"API still in development\"]\n+impl<Idx: fmt::Show> fmt::Show for RangeFrom<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"{:?}..\", self.start)\n+    }\n+}\n+\n /// A range which is only bounded above.\n-#[derive(Copy)]\n+#[derive(Copy, PartialEq, Eq)]\n #[lang=\"range_to\"]\n #[unstable = \"API still in development\"]\n pub struct RangeTo<Idx> {\n     /// The upper bound of the range (exclusive).\n     pub end: Idx,\n }\n \n+#[unstable = \"API still in development\"]\n+impl<Idx: fmt::Show> fmt::Show for RangeTo<Idx> {\n+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n+        write!(fmt, \"..{:?}\", self.end)\n+    }\n+}\n+\n \n /// The `Deref` trait is used to specify the functionality of dereferencing\n /// operations like `*v`."}, {"sha": "deee67b6d2fd7ba1237ee780d8956a75f06b12d2", "filename": "src/libcore/option.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -66,10 +66,11 @@\n //! not (`None`).\n //!\n //! ```\n+//! # use std::boxed::Box;\n //! let optional: Option<Box<int>> = None;\n //! check_optional(&optional);\n //!\n-//! let optional: Option<Box<int>> = Some(box 9000);\n+//! let optional: Option<Box<int>> = Some(Box::new(9000));\n //! check_optional(&optional);\n //!\n //! fn check_optional(optional: &Option<Box<int>>) {\n@@ -145,17 +146,17 @@\n \n use self::Option::*;\n \n+use clone::Clone;\n use cmp::{Eq, Ord};\n use default::Default;\n-use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator};\n use iter::{ExactSizeIterator};\n+use iter::{Iterator, IteratorExt, DoubleEndedIterator, FromIterator};\n use mem;\n-use result::Result;\n+use ops::{Deref, FnOnce};\n use result::Result::{Ok, Err};\n-use slice;\n+use result::Result;\n use slice::AsSlice;\n-use clone::Clone;\n-use ops::{Deref, FnOnce};\n+use slice;\n \n // Note that this is not a lang item per se, but it has a hidden dependency on\n // `Iterator`, which is one. The compiler assumes that the `next` method of\n@@ -533,7 +534,7 @@ impl<T> Option<T> {\n     /// ```\n     /// let mut x = Some(4u);\n     /// match x.iter_mut().next() {\n-    ///     Some(&ref mut v) => *v = 42u,\n+    ///     Some(&mut ref mut v) => *v = 42u,\n     ///     None => {},\n     /// }\n     /// assert_eq!(x, Some(42));\n@@ -762,7 +763,6 @@ impl<T> AsSlice<T> for Option<T> {\n \n #[stable]\n impl<T> Default for Option<T> {\n-    #[stable]\n     #[inline]\n     #[stable]\n     fn default() -> Option<T> { None }"}, {"sha": "a17cd410303a56ef06965cd00ae38ac24f10358b", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -46,12 +46,13 @@\n //! though unsafely, transformed from one type to the other.\n //!\n //! ```\n+//! # use std::boxed::Box;\n //! use std::mem;\n //!\n //! unsafe {\n-//!     let my_num: Box<int> = box 10;\n+//!     let my_num: Box<int> = Box::new(10);\n //!     let my_num: *const int = mem::transmute(my_num);\n-//!     let my_speed: Box<int> = box 88;\n+//!     let my_speed: Box<int> = Box::new(88);\n //!     let my_speed: *mut int = mem::transmute(my_speed);\n //!\n //!     // By taking ownership of the original `Box<T>` though"}, {"sha": "7868ec67c8a3adfa915b3d90cd7a17c17f86f29b", "filename": "src/libcore/result.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -383,8 +383,8 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// fn mutate(r: &mut Result<int, int>) {\n     ///     match r.as_mut() {\n-    ///         Ok(&ref mut v) => *v = 42,\n-    ///         Err(&ref mut e) => *e = 0,\n+    ///         Ok(&mut ref mut v) => *v = 42,\n+    ///         Err(&mut ref mut e) => *e = 0,\n     ///     }\n     /// }\n     ///\n@@ -529,7 +529,7 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// let mut x: Result<uint, &str> = Ok(7);\n     /// match x.iter_mut().next() {\n-    ///     Some(&ref mut x) => *x = 40,\n+    ///     Some(&mut ref mut x) => *x = 40,\n     ///     None => {},\n     /// }\n     /// assert_eq!(x, Ok(40));"}, {"sha": "6c62bfda1fecc98d0d9c3c97ab00d5bbd2930c5e", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -159,7 +159,7 @@ impl<T> SliceExt for [T] {\n \n     #[inline]\n     fn split_at(&self, mid: uint) -> (&[T], &[T]) {\n-        (self.index(&(0..mid)), self.index(&(mid..)))\n+        (&self[0..mid], &self[mid..])\n     }\n \n     #[inline]\n@@ -236,11 +236,11 @@ impl<T> SliceExt for [T] {\n     }\n \n     #[inline]\n-    fn tail(&self) -> &[T] { self.index(&(1..)) }\n+    fn tail(&self) -> &[T] { &self[1..] }\n \n     #[inline]\n     fn init(&self) -> &[T] {\n-        self.index(&(0..(self.len() - 1)))\n+        &self[0..(self.len() - 1)]\n     }\n \n     #[inline]\n@@ -443,13 +443,13 @@ impl<T> SliceExt for [T] {\n     #[inline]\n     fn starts_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let n = needle.len();\n-        self.len() >= n && needle == self.index(&(0..n))\n+        self.len() >= n && needle == &self[0..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &[T]) -> bool where T: PartialEq {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle == self.index(&((m-n)..))\n+        m >= n && needle == &self[(m-n)..]\n     }\n \n     #[unstable]\n@@ -972,8 +972,8 @@ impl<'a, T, P> Iterator for Split<'a, T, P> where P: FnMut(&T) -> bool {\n         match self.v.iter().position(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v.index(&(0..idx)));\n-                self.v = self.v.index(&((idx + 1)..));\n+                let ret = Some(&self.v[0..idx]);\n+                self.v = &self.v[(idx + 1)..];\n                 ret\n             }\n         }\n@@ -998,8 +998,8 @@ impl<'a, T, P> DoubleEndedIterator for Split<'a, T, P> where P: FnMut(&T) -> boo\n         match self.v.iter().rposition(|x| (self.pred)(x)) {\n             None => self.finish(),\n             Some(idx) => {\n-                let ret = Some(self.v.index(&((idx + 1)..)));\n-                self.v = self.v.index(&(0..idx));\n+                let ret = Some(&self.v[(idx + 1)..]);\n+                self.v = &self.v[0..idx];\n                 ret\n             }\n         }\n@@ -1195,8 +1195,8 @@ impl<'a, T> Iterator for Windows<'a, T> {\n         if self.size > self.v.len() {\n             None\n         } else {\n-            let ret = Some(self.v.index(&(0..self.size)));\n-            self.v = self.v.index(&(1..));\n+            let ret = Some(&self.v[0..self.size]);\n+            self.v = &self.v[1..];\n             ret\n         }\n     }\n@@ -1283,7 +1283,7 @@ impl<'a, T> RandomAccessIterator for Chunks<'a, T> {\n             let mut hi = lo + self.size;\n             if hi < lo || hi > self.v.len() { hi = self.v.len(); }\n \n-            Some(self.v.index(&(lo..hi)))\n+            Some(&self.v[lo..hi])\n         } else {\n             None\n         }"}, {"sha": "6051c68b116ba1d808912582fa3c21f90a48c21f", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -26,7 +26,7 @@ use iter::{Map, Iterator, IteratorExt, DoubleEndedIterator};\n use marker::Sized;\n use mem;\n use num::Int;\n-use ops::{Fn, FnMut, Index};\n+use ops::{Fn, FnMut};\n use option::Option::{self, None, Some};\n use ptr::PtrExt;\n use raw::{Repr, Slice};\n@@ -580,7 +580,7 @@ impl NaiveSearcher {\n \n     fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(uint, uint)> {\n         while self.position + needle.len() <= haystack.len() {\n-            if haystack.index(&(self.position .. self.position + needle.len())) == needle {\n+            if &haystack[self.position .. self.position + needle.len()] == needle {\n                 let match_pos = self.position;\n                 self.position += needle.len(); // add 1 for all matches\n                 return Some((match_pos, match_pos + needle.len()));\n@@ -701,10 +701,10 @@ impl TwoWaySearcher {\n         //\n         // What's going on is we have some critical factorization (u, v) of the\n         // needle, and we want to determine whether u is a suffix of\n-        // v.index(&(0..period)). If it is, we use \"Algorithm CP1\". Otherwise we use\n+        // &v[0..period]. If it is, we use \"Algorithm CP1\". Otherwise we use\n         // \"Algorithm CP2\", which is optimized for when the period of the needle\n         // is large.\n-        if needle.index(&(0..crit_pos)) == needle.index(&(period.. period + crit_pos)) {\n+        if &needle[0..crit_pos] == &needle[period.. period + crit_pos] {\n             TwoWaySearcher {\n                 crit_pos: crit_pos,\n                 period: period,\n@@ -1412,13 +1412,13 @@ impl StrExt for str {\n     #[inline]\n     fn starts_with(&self, needle: &str) -> bool {\n         let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == self.as_bytes().index(&(0..n))\n+        self.len() >= n && needle.as_bytes() == &self.as_bytes()[0..n]\n     }\n \n     #[inline]\n     fn ends_with(&self, needle: &str) -> bool {\n         let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == self.as_bytes().index(&((m-n)..))\n+        m >= n && needle.as_bytes() == &self.as_bytes()[(m-n)..]\n     }\n \n     #[inline]"}, {"sha": "e6a7170aceafb40ad57d559305f45f3c7b28fed4", "filename": "src/libcoretest/any.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fany.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -101,12 +101,12 @@ fn any_downcast_mut() {\n     }\n \n     match a_r.downcast_mut::<uint>() {\n-        Some(&612) => {}\n+        Some(&mut 612) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n \n     match b_r.downcast_mut::<uint>() {\n-        Some(&413) => {}\n+        Some(&mut 413) => {}\n         x => panic!(\"Unexpected value {:?}\", x)\n     }\n }"}, {"sha": "7b6b4f848085e75a49d2c578e83b9662a3c50aa0", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -167,7 +167,7 @@ fn test_encode_utf8() {\n     fn check(input: char, expect: &[u8]) {\n         let mut buf = [0u8; 4];\n         let n = input.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf.index(&(0..n)), expect);\n+        assert_eq!(&buf[0..n], expect);\n     }\n \n     check('x', &[0x78]);\n@@ -181,7 +181,7 @@ fn test_encode_utf16() {\n     fn check(input: char, expect: &[u16]) {\n         let mut buf = [0u16; 2];\n         let n = input.encode_utf16(buf.as_mut_slice()).unwrap_or(0);\n-        assert_eq!(buf.index(&(0..n)), expect);\n+        assert_eq!(&buf[0..n], expect);\n     }\n \n     check('x', &[0x0078]);"}, {"sha": "d48820aee06408541fc81615827d0546876b64c7", "filename": "src/libcoretest/hash/mod.rs", "status": "modified", "additions": 60, "deletions": 44, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fhash%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -7,27 +7,22 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-use core::marker::Sized;\n-use std::mem;\n-\n-use core::slice::SliceExt;\n-use core::hash::{Hash, Hasher, Writer};\n \n-struct MyWriterHasher;\n+use std::mem;\n+use std::hash::{Hash, Hasher, Writer};\n+use std::default::Default;\n \n-impl Hasher<MyWriter> for MyWriterHasher {\n-    fn hash<T: ?Sized + Hash<MyWriter>>(&self, value: &T) -> u64 {\n-        let mut state = MyWriter { hash: 0 };\n-        value.hash(&mut state);\n-        state.hash\n-    }\n+struct MyHasher {\n+    hash: u64,\n }\n \n-struct MyWriter {\n-    hash: u64,\n+impl Default for MyHasher {\n+    fn default() -> MyHasher {\n+        MyHasher { hash: 0 }\n+    }\n }\n \n-impl Writer for MyWriter {\n+impl Writer for MyHasher {\n     // Most things we'll just add up the bytes.\n     fn write(&mut self, buf: &[u8]) {\n         for byte in buf.iter() {\n@@ -36,66 +31,87 @@ impl Writer for MyWriter {\n     }\n }\n \n+impl Hasher for MyHasher {\n+    type Output = u64;\n+    fn reset(&mut self) { self.hash = 0; }\n+    fn finish(&self) -> u64 { self.hash }\n+}\n+\n+\n #[test]\n fn test_writer_hasher() {\n-    let hasher = MyWriterHasher;\n+    fn hash<T: Hash<MyHasher>>(t: &T) -> u64 {\n+        ::std::hash::hash::<_, MyHasher>(t)\n+    }\n \n-    assert_eq!(hasher.hash(&()), 0);\n+    assert_eq!(hash(&()), 0);\n \n-    assert_eq!(hasher.hash(&5u8), 5);\n-    assert_eq!(hasher.hash(&5u16), 5);\n-    assert_eq!(hasher.hash(&5u32), 5);\n-    assert_eq!(hasher.hash(&5u64), 5);\n-    assert_eq!(hasher.hash(&5u), 5);\n+    assert_eq!(hash(&5u8), 5);\n+    assert_eq!(hash(&5u16), 5);\n+    assert_eq!(hash(&5u32), 5);\n+    assert_eq!(hash(&5u64), 5);\n+    assert_eq!(hash(&5u), 5);\n \n-    assert_eq!(hasher.hash(&5i8), 5);\n-    assert_eq!(hasher.hash(&5i16), 5);\n-    assert_eq!(hasher.hash(&5i32), 5);\n-    assert_eq!(hasher.hash(&5i64), 5);\n-    assert_eq!(hasher.hash(&5i), 5);\n+    assert_eq!(hash(&5i8), 5);\n+    assert_eq!(hash(&5i16), 5);\n+    assert_eq!(hash(&5i32), 5);\n+    assert_eq!(hash(&5i64), 5);\n+    assert_eq!(hash(&5i), 5);\n \n-    assert_eq!(hasher.hash(&false), 0);\n-    assert_eq!(hasher.hash(&true), 1);\n+    assert_eq!(hash(&false), 0);\n+    assert_eq!(hash(&true), 1);\n \n-    assert_eq!(hasher.hash(&'a'), 97);\n+    assert_eq!(hash(&'a'), 97);\n \n     let s: &str = \"a\";\n-    assert_eq!(hasher.hash(& s), 97 + 0xFF);\n+    assert_eq!(hash(& s), 97 + 0xFF);\n     // FIXME (#18283) Enable test\n     //let s: Box<str> = box \"a\";\n     //assert_eq!(hasher.hash(& s), 97 + 0xFF);\n     let cs: &[u8] = &[1u8, 2u8, 3u8];\n-    assert_eq!(hasher.hash(& cs), 9);\n+    assert_eq!(hash(& cs), 9);\n     let cs: Box<[u8]> = box [1u8, 2u8, 3u8];\n-    assert_eq!(hasher.hash(& cs), 9);\n+    assert_eq!(hash(& cs), 9);\n \n     // FIXME (#18248) Add tests for hashing Rc<str> and Rc<[T]>\n \n     unsafe {\n         let ptr: *const int = mem::transmute(5i);\n-        assert_eq!(hasher.hash(&ptr), 5);\n+        assert_eq!(hash(&ptr), 5);\n     }\n \n     unsafe {\n         let ptr: *mut int = mem::transmute(5i);\n-        assert_eq!(hasher.hash(&ptr), 5);\n+        assert_eq!(hash(&ptr), 5);\n     }\n }\n \n-struct Custom {\n-    hash: u64\n+struct Custom { hash: u64 }\n+struct CustomHasher { output: u64 }\n+\n+impl Hasher for CustomHasher {\n+    type Output = u64;\n+    fn reset(&mut self) { self.output = 0; }\n+    fn finish(&self) -> u64 { self.output }\n+}\n+\n+impl Default for CustomHasher {\n+    fn default() -> CustomHasher {\n+        CustomHasher { output: 0 }\n+    }\n }\n \n-impl Hash<u64> for Custom {\n-    fn hash(&self, state: &mut u64) {\n-        *state = self.hash;\n+impl Hash<CustomHasher> for Custom {\n+    fn hash(&self, state: &mut CustomHasher) {\n+        state.output = self.hash;\n     }\n }\n \n #[test]\n fn test_custom_state() {\n-    let custom = Custom { hash: 5 };\n-    let mut state = 0;\n-    custom.hash(&mut state);\n-    assert_eq!(state, 5);\n+    fn hash<T: Hash<CustomHasher>>(t: &T) -> u64 {\n+        ::std::hash::hash::<_, CustomHasher>(t)\n+    }\n+\n+    assert_eq!(hash(&Custom { hash: 5 }), 5);\n }"}, {"sha": "bcf8a6a433b94dd699807427720c0ef2b42b956a", "filename": "src/libcoretest/intrinsics.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fintrinsics.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use core::intrinsics::TypeId;\n+\n+#[test]\n+fn test_typeid_sized_types() {\n+    struct X; struct Y(uint);\n+\n+    assert_eq!(TypeId::of::<X>(), TypeId::of::<X>());\n+    assert_eq!(TypeId::of::<Y>(), TypeId::of::<Y>());\n+    assert!(TypeId::of::<X>() != TypeId::of::<Y>());\n+}\n+\n+#[test]\n+fn test_typeid_unsized_types() {\n+    trait Z {}\n+    struct X(str); struct Y(Z + 'static);\n+\n+    assert_eq!(TypeId::of::<X>(), TypeId::of::<X>());\n+    assert_eq!(TypeId::of::<Y>(), TypeId::of::<Y>());\n+    assert!(TypeId::of::<X>() != TypeId::of::<Y>());\n+}\n+"}, {"sha": "c12981b7d24847a0458b2aba8531c42bf8498621", "filename": "src/libcoretest/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -7,8 +7,10 @@\n // <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n-#![feature(globs, unsafe_destructor, slicing_syntax, default_type_params)]\n+\n+#![feature(unsafe_destructor, slicing_syntax)]\n #![feature(unboxed_closures)]\n+#![feature(box_syntax)]\n \n extern crate core;\n extern crate test;"}, {"sha": "485549cc552ac504a080e96bb9b915d831ab5f0d", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use core::iter::range;\n-\n pub fn op1() -> Result<int, &'static str> { Ok(666) }\n pub fn op2() -> Result<int, &'static str> { Err(\"sadface\") }\n "}, {"sha": "6fae384763f843a3010ea7c6b68624f3593f3014", "filename": "src/libcoretest/slice.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibcoretest%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fslice.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -57,17 +57,17 @@ fn iterator_to_slice() {\n             }\n             {\n                 let mut iter = data.iter_mut();\n-                assert_eq!(iter.index(&FullRange), other_data.index(&FullRange));\n+                assert_eq!(&iter[], &other_data[]);\n                 // mutability:\n                 assert!(&mut iter[] == other_data);\n \n                 iter.next();\n-                assert_eq!(iter.index(&FullRange), other_data.index(&(1..)));\n+                assert_eq!(&iter[], &other_data[1..]);\n                 assert!(&mut iter[] == &mut other_data[1..]);\n \n                 iter.next_back();\n \n-                assert_eq!(iter.index(&FullRange), other_data.index(&(1..2)));\n+                assert_eq!(&iter[], &other_data[1..2]);\n                 assert!(&mut iter[] == &mut other_data[1..2]);\n \n                 let s = iter.into_slice();"}, {"sha": "1896bdd182ae01e3b586ddd10bd495e2a5943d0b", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,6 +16,7 @@\n \n #![crate_name = \"flate\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "02eea5d024c7a990ac40800dc9aa1642343a1d1f", "filename": "src/libfmt_macros/lib.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibfmt_macros%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibfmt_macros%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibfmt_macros%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,6 +16,7 @@\n \n #![crate_name = \"fmt_macros\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -211,12 +212,12 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n             }\n             Some((_, other)) => {\n-                self.err(format!(\"expected `{:?}`, found `{:?}`\", c,\n-                                 other).index(&FullRange));\n+                self.err(&format!(\"expected `{:?}`, found `{:?}`\", c,\n+                                  other)[]);\n             }\n             None => {\n-                self.err(format!(\"expected `{:?}` but string was terminated\",\n-                                 c).index(&FullRange));\n+                self.err(&format!(\"expected `{:?}` but string was terminated\",\n+                                  c)[]);\n             }\n         }\n     }\n@@ -239,12 +240,12 @@ impl<'a> Parser<'a> {\n             // we may not consume the character, so clone the iterator\n             match self.cur.clone().next() {\n                 Some((pos, '}')) | Some((pos, '{')) => {\n-                    return self.input.index(&(start..pos));\n+                    return &self.input[start..pos];\n                 }\n                 Some(..) => { self.cur.next(); }\n                 None => {\n                     self.cur.next();\n-                    return self.input.index(&(start..self.input.len()));\n+                    return &self.input[start..self.input.len()];\n                 }\n             }\n         }\n@@ -284,7 +285,7 @@ impl<'a> Parser<'a> {\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n-            ty: self.input.index(&(0..0)),\n+            ty: &self.input[0..0],\n         };\n         if !self.consume(':') { return spec }\n \n@@ -393,7 +394,7 @@ impl<'a> Parser<'a> {\n                 self.cur.next();\n                 pos\n             }\n-            Some(..) | None => { return self.input.index(&(0..0)); }\n+            Some(..) | None => { return &self.input[0..0]; }\n         };\n         let mut end;\n         loop {\n@@ -405,7 +406,7 @@ impl<'a> Parser<'a> {\n                 None => { end = self.input.len(); break }\n             }\n         }\n-        self.input.index(&(start..end))\n+        &self.input[start..end]\n     }\n \n     /// Optionally parses an integer at the current position. This doesn't deal"}, {"sha": "1d6c99542b58ec014c2aa4ede0d752056176f767", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -79,6 +79,7 @@\n \n #![crate_name = \"getopts\"]\n #![experimental = \"use the crates.io `getopts` library instead\"]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -280,7 +281,7 @@ impl OptGroup {\n \n impl Matches {\n     fn opt_vals(&self, nm: &str) -> Vec<Optval> {\n-        match find_opt(self.opts.index(&FullRange), Name::from_str(nm)) {\n+        match find_opt(&self.opts[], Name::from_str(nm)) {\n             Some(id) => self.vals[id].clone(),\n             None => panic!(\"No option '{}' defined\", nm)\n         }\n@@ -308,7 +309,7 @@ impl Matches {\n     /// Returns true if any of several options were matched.\n     pub fn opts_present(&self, names: &[String]) -> bool {\n         for nm in names.iter() {\n-            match find_opt(self.opts.as_slice(), Name::from_str(nm.index(&FullRange))) {\n+            match find_opt(self.opts.as_slice(), Name::from_str(&nm[])) {\n                 Some(id) if !self.vals[id].is_empty() => return true,\n                 _ => (),\n             };\n@@ -319,7 +320,7 @@ impl Matches {\n     /// Returns the string argument supplied to one of several matching options or `None`.\n     pub fn opts_str(&self, names: &[String]) -> Option<String> {\n         for nm in names.iter() {\n-            match self.opt_val(nm.index(&FullRange)) {\n+            match self.opt_val(&nm[]) {\n                 Some(Val(ref s)) => return Some(s.clone()),\n                 _ => ()\n             }\n@@ -584,7 +585,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n     while i < l {\n         let cur = args[i].clone();\n         let curlen = cur.len();\n-        if !is_arg(cur.index(&FullRange)) {\n+        if !is_arg(&cur[]) {\n             free.push(cur);\n         } else if cur == \"--\" {\n             let mut j = i + 1;\n@@ -594,7 +595,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n             let mut names;\n             let mut i_arg = None;\n             if cur.as_bytes()[1] == b'-' {\n-                let tail = cur.index(&(2..curlen));\n+                let tail = &cur[2..curlen];\n                 let tail_eq: Vec<&str> = tail.split('=').collect();\n                 if tail_eq.len() <= 1 {\n                     names = vec!(Long(tail.to_string()));\n@@ -630,7 +631,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                     };\n \n                     if arg_follows && range.next < curlen {\n-                        i_arg = Some(cur.index(&(range.next..curlen)).to_string());\n+                        i_arg = Some((&cur[range.next..curlen]).to_string());\n                         break;\n                     }\n \n@@ -658,7 +659,7 @@ pub fn getopts(args: &[String], optgrps: &[OptGroup]) -> Result {\n                         v.push(Val((i_arg.clone())\n                             .unwrap()));\n                     } else if name_pos < names.len() || i + 1 == l ||\n-                            is_arg(args[i + 1].index(&FullRange)) {\n+                            is_arg(&args[i + 1][]) {\n                         let v = &mut vals[optid];\n                         v.push(Given);\n                     } else {\n@@ -721,7 +722,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             1 => {\n                 row.push('-');\n-                row.push_str(short_name.index(&FullRange));\n+                row.push_str(&short_name[]);\n                 row.push(' ');\n             }\n             _ => panic!(\"the short name should only be 1 ascii char long\"),\n@@ -732,18 +733,18 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n             0 => {}\n             _ => {\n                 row.push_str(\"--\");\n-                row.push_str(long_name.index(&FullRange));\n+                row.push_str(&long_name[]);\n                 row.push(' ');\n             }\n         }\n \n         // arg\n         match hasarg {\n             No => {}\n-            Yes => row.push_str(hint.index(&FullRange)),\n+            Yes => row.push_str(&hint[]),\n             Maybe => {\n                 row.push('[');\n-                row.push_str(hint.index(&FullRange));\n+                row.push_str(&hint[]);\n                 row.push(']');\n             }\n         }\n@@ -756,7 +757,7 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n                 row.push(' ');\n             }\n         } else {\n-            row.push_str(desc_sep.index(&FullRange));\n+            row.push_str(&desc_sep[]);\n         }\n \n         // Normalize desc to contain words separated by one space character\n@@ -768,14 +769,14 @@ pub fn usage(brief: &str, opts: &[OptGroup]) -> String {\n \n         // FIXME: #5516 should be graphemes not codepoints\n         let mut desc_rows = Vec::new();\n-        each_split_within(desc_normalized_whitespace.index(&FullRange), 54, |substr| {\n+        each_split_within(&desc_normalized_whitespace[], 54, |substr| {\n             desc_rows.push(substr.to_string());\n             true\n         });\n \n         // FIXME: #5516 should be graphemes not codepoints\n         // wrapped description\n-        row.push_str(desc_rows.connect(desc_sep.index(&FullRange)).index(&FullRange));\n+        row.push_str(&desc_rows.connect(&desc_sep[])[]);\n \n         row\n     });\n@@ -794,18 +795,18 @@ fn format_option(opt: &OptGroup) -> String {\n     // Use short_name is possible, but fallback to long_name.\n     if opt.short_name.len() > 0 {\n         line.push('-');\n-        line.push_str(opt.short_name.index(&FullRange));\n+        line.push_str(&opt.short_name[]);\n     } else {\n         line.push_str(\"--\");\n-        line.push_str(opt.long_name.index(&FullRange));\n+        line.push_str(&opt.long_name[]);\n     }\n \n     if opt.hasarg != No {\n         line.push(' ');\n         if opt.hasarg == Maybe {\n             line.push('[');\n         }\n-        line.push_str(opt.hint.index(&FullRange));\n+        line.push_str(&opt.hint[]);\n         if opt.hasarg == Maybe {\n             line.push(']');\n         }\n@@ -824,10 +825,10 @@ fn format_option(opt: &OptGroup) -> String {\n /// Derive a short one-line usage summary from a set of long options.\n pub fn short_usage(program_name: &str, opts: &[OptGroup]) -> String {\n     let mut line = format!(\"Usage: {} \", program_name);\n-    line.push_str(opts.iter()\n-                      .map(format_option)\n-                      .collect::<Vec<String>>()\n-                      .connect(\" \").index(&FullRange));\n+    line.push_str(&opts.iter()\n+                       .map(format_option)\n+                       .collect::<Vec<String>>()\n+                       .connect(\" \")[]);\n     line\n }\n \n@@ -890,9 +891,9 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             (B, Cr, UnderLim) => { B }\n             (B, Cr, OverLim)  if (i - last_start + 1) > lim\n                             => panic!(\"word starting with {} longer than limit!\",\n-                                    ss.index(&(last_start..(i + 1)))),\n+                                      &ss[last_start..(i + 1)]),\n             (B, Cr, OverLim)  => {\n-                *cont = it(ss.index(&(slice_start..last_end)));\n+                *cont = it(&ss[slice_start..last_end]);\n                 slice_start = last_start;\n                 B\n             }\n@@ -902,7 +903,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n             }\n             (B, Ws, OverLim)  => {\n                 last_end = i;\n-                *cont = it(ss.index(&(slice_start..last_end)));\n+                *cont = it(&ss[slice_start..last_end]);\n                 A\n             }\n \n@@ -911,14 +912,14 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n                 B\n             }\n             (C, Cr, OverLim)  => {\n-                *cont = it(ss.index(&(slice_start..last_end)));\n+                *cont = it(&ss[slice_start..last_end]);\n                 slice_start = i;\n                 last_start = i;\n                 last_end = i;\n                 B\n             }\n             (C, Ws, OverLim)  => {\n-                *cont = it(ss.index(&(slice_start..last_end)));\n+                *cont = it(&ss[slice_start..last_end]);\n                 A\n             }\n             (C, Ws, UnderLim) => {"}, {"sha": "9d2318e253e72672d35faaba9a36a2bebaab3a29", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -266,6 +266,7 @@\n \n #![crate_name = \"graphviz\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -452,7 +453,7 @@ impl<'a> LabelText<'a> {\n     pub fn escape(&self) -> String {\n         match self {\n             &LabelStr(ref s) => s.escape_default(),\n-            &EscStr(ref s) => LabelText::escape_str(s.index(&FullRange)),\n+            &EscStr(ref s) => LabelText::escape_str(&s[]),\n         }\n     }\n \n@@ -481,7 +482,7 @@ impl<'a> LabelText<'a> {\n         let mut prefix = self.pre_escaped_content().into_owned();\n         let suffix = suffix.pre_escaped_content();\n         prefix.push_str(r\"\\n\\n\");\n-        prefix.push_str(suffix.index(&FullRange));\n+        prefix.push_str(&suffix[]);\n         EscStr(prefix.into_cow())\n     }\n }\n@@ -675,7 +676,7 @@ mod tests {\n \n     impl<'a> Labeller<'a, Node, &'a Edge> for LabelledGraph {\n         fn graph_id(&'a self) -> Id<'a> {\n-            Id::new(self.name.index(&FullRange)).unwrap()\n+            Id::new(&self.name[]).unwrap()\n         }\n         fn node_id(&'a self, n: &Node) -> Id<'a> {\n             id_name(n)"}, {"sha": "c39fd074387f51aba0633ce6a1069f1f7d36f039", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -11,6 +11,7 @@\n #![crate_name = \"libc\"]\n #![crate_type = \"rlib\"]\n #![cfg_attr(not(feature = \"cargo-build\"), experimental)]\n+#![cfg_attr(not(feature = \"cargo-build\"), staged_api)]\n #![no_std]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n@@ -5065,7 +5066,5 @@ pub fn issue_14344_workaround() {} // FIXME #14344 force linkage to happen corre\n #[doc(hidden)]\n #[cfg(not(test))]\n mod std {\n-    #[cfg(stage0)]\n-    pub use core::marker as kinds;\n     pub use core::marker;\n }"}, {"sha": "0d5f6b65827a495cfa0ff9eb6be72598134901bc", "filename": "src/liblog/lib.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliblog%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Fliblog%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblog%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -157,13 +157,17 @@\n \n #![crate_name = \"log\"]\n #![experimental = \"use the crates.io `log` library instead\"]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n+\n+#![allow(unknown_features)]\n #![feature(slicing_syntax)]\n+#![feature(box_syntax)]\n #![deny(missing_docs)]\n \n extern crate regex;\n@@ -287,7 +291,7 @@ pub fn log(level: u32, loc: &'static LogLocation, args: fmt::Arguments) {\n     // Test the literal string from args against the current filter, if there\n     // is one.\n     match unsafe { FILTER.as_ref() } {\n-        Some(filter) if !filter.is_match(args.to_string().index(&FullRange)) => return,\n+        Some(filter) if !filter.is_match(&args.to_string()[]) => return,\n         _ => {}\n     }\n \n@@ -382,7 +386,7 @@ fn enabled(level: u32,\n     // Search for the longest match, the vector is assumed to be pre-sorted.\n     for directive in iter.rev() {\n         match directive.name {\n-            Some(ref name) if !module.starts_with(name.index(&FullRange)) => {},\n+            Some(ref name) if !module.starts_with(&name[]) => {},\n             Some(..) | None => {\n                 return level <= directive.level\n             }\n@@ -397,7 +401,7 @@ fn enabled(level: u32,\n /// `Once` primitive (and this function is called from that primitive).\n fn init() {\n     let (mut directives, filter) = match os::getenv(\"RUST_LOG\") {\n-        Some(spec) => directive::parse_logging_spec(spec.index(&FullRange)),\n+        Some(spec) => directive::parse_logging_spec(&spec[]),\n         None => (Vec::new(), None),\n     };\n "}, {"sha": "497e339b316c1f0096940329a7e5a732f67b96d7", "filename": "src/librand/lib.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrand%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrand%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -25,6 +25,7 @@\n \n #![no_std]\n #![experimental]\n+#![staged_api]\n \n #[macro_use]\n extern crate core;\n@@ -193,7 +194,7 @@ pub trait Rng : Sized {\n     ///\n     /// let mut rng = thread_rng();\n     /// let x = rng.gen_iter::<uint>().take(10).collect::<Vec<uint>>();\n-    /// println!(\"{}\", x);\n+    /// println!(\"{:?}\", x);\n     /// println!(\"{:?}\", rng.gen_iter::<(f64, bool)>().take(5)\n     ///                     .collect::<Vec<(f64, bool)>>());\n     /// ```\n@@ -270,7 +271,7 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// println!(\"{:?}\", rng.choose(&choices));\n     /// # // uncomment when slicing syntax is stable\n-    /// //assert_eq!(rng.choose(choices.index(&(0..0))), None);\n+    /// //assert_eq!(rng.choose(&choices[0..0]), None);\n     /// ```\n     fn choose<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n         if values.is_empty() {\n@@ -290,9 +291,9 @@ pub trait Rng : Sized {\n     /// let mut rng = thread_rng();\n     /// let mut y = [1i, 2, 3];\n     /// rng.shuffle(&mut y);\n-    /// println!(\"{}\", y.as_slice());\n+    /// println!(\"{:?}\", y.as_slice());\n     /// rng.shuffle(&mut y);\n-    /// println!(\"{}\", y.as_slice());\n+    /// println!(\"{:?}\", y.as_slice());\n     /// ```\n     fn shuffle<T>(&mut self, values: &mut [T]) {\n         let mut i = values.len();\n@@ -495,8 +496,6 @@ pub struct Closed01<F>(pub F);\n mod std {\n     pub use core::{option, fmt}; // panic!()\n     pub use core::clone; // derive Clone\n-    #[cfg(stage0)]\n-    pub use core::marker as kinds;\n     pub use core::marker;\n }\n "}, {"sha": "bdc00d7db97fe8e22da8b66d50826f459683b3ea", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -95,7 +95,7 @@ impl Writer for SeekableMemWriter {\n             // there (left), and what will be appended on the end (right)\n             let cap = self.buf.len() - self.pos;\n             let (left, right) = if cap <= buf.len() {\n-                (buf.index(&(0..cap)), buf.index(&(cap..)))\n+                (&buf[0..cap], &buf[cap..])\n             } else {\n                 let result: (_, &[_]) = (buf, &[]);\n                 result"}, {"sha": "da803aa50119cfbf33d19b93d6ca94ac03589236", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -17,6 +17,7 @@\n \n #![crate_name = \"rbml\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -56,7 +57,7 @@ impl<'doc> Doc<'doc> {\n     }\n \n     pub fn as_str_slice<'a>(&'a self) -> &'a str {\n-        str::from_utf8(self.data.index(&(self.start..self.end))).unwrap()\n+        str::from_utf8(&self.data[self.start..self.end]).unwrap()\n     }\n \n     pub fn as_str(&self) -> String {\n@@ -291,7 +292,7 @@ pub mod reader {\n     pub fn with_doc_data<T, F>(d: Doc, f: F) -> T where\n         F: FnOnce(&[u8]) -> T,\n     {\n-        f(d.data.index(&(d.start..d.end)))\n+        f(&d.data[d.start..d.end])\n     }\n \n "}, {"sha": "d29a7a425c1164d1825549f49a99305377d89a95", "filename": "src/libregex/compile.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fcompile.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -105,7 +105,7 @@ impl Program {\n         // This is a bit hacky since we have to skip over the initial\n         // 'Save' instruction.\n         let mut pre = String::with_capacity(5);\n-        for inst in c.insts.index(&(1..)).iter() {\n+        for inst in c.insts[1..].iter() {\n             match *inst {\n                 OneChar(c, FLAG_EMPTY) => pre.push(c),\n                 _ => break"}, {"sha": "d19ce3b460ae5c10bd1286ff2aa8ffae2dde5bd6", "filename": "src/libregex/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -17,13 +17,15 @@\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![experimental = \"use the crates.io `regex` library instead\"]\n+#![staged_api]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n \n #![allow(unknown_features)]\n #![feature(slicing_syntax)]\n+#![feature(box_syntax)]\n #![deny(missing_docs)]\n \n #[cfg(test)]"}, {"sha": "1cc2b271e9ccda688ff3cdbdaffb75ee2c10a29f", "filename": "src/libregex/parse.rs", "status": "modified", "additions": 51, "deletions": 52, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fparse.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -18,7 +18,6 @@ use std::cmp;\n use std::fmt;\n use std::iter;\n use std::num;\n-use std::ops::Index;\n \n /// Static data containing Unicode ranges for general categories and scripts.\n use unicode::regex::{UNICODE_CLASSES, PERLD, PERLS, PERLW};\n@@ -285,20 +284,20 @@ impl<'a> Parser<'a> {\n         match self.next_char() {\n             true => Ok(()),\n             false => {\n-                self.err(format!(\"Expected {:?} but got EOF.\",\n-                                 expected).index(&FullRange))\n+                self.err(&format!(\"Expected {:?} but got EOF.\",\n+                                  expected)[])\n             }\n         }\n     }\n \n     fn expect(&mut self, expected: char) -> Result<(), Error> {\n         match self.next_char() {\n             true if self.cur() == expected => Ok(()),\n-            true => self.err(format!(\"Expected '{:?}' but got '{:?}'.\",\n-                                     expected, self.cur()).index(&FullRange)),\n+            true => self.err(&format!(\"Expected '{:?}' but got '{:?}'.\",\n+                                      expected, self.cur())[]),\n             false => {\n-                self.err(format!(\"Expected '{:?}' but got EOF.\",\n-                                 expected).index(&FullRange))\n+                self.err(&format!(\"Expected '{:?}' but got EOF.\",\n+                                  expected)[])\n             }\n         }\n     }\n@@ -443,15 +442,15 @@ impl<'a> Parser<'a> {\n                     match try!(self.parse_escape()) {\n                         Literal(c3, _) => c2 = c3, // allow literal escapes below\n                         ast =>\n-                            return self.err(format!(\"Expected a literal, but got {:?}.\",\n-                                                    ast).index(&FullRange)),\n+                            return self.err(&format!(\"Expected a literal, but got {:?}.\",\n+                                                     ast)[]),\n                     }\n                 }\n                 if c2 < c {\n-                    return self.err(format!(\"Invalid character class \\\n-                                             range '{}-{}'\",\n-                                            c,\n-                                            c2).index(&FullRange))\n+                    return self.err(&format!(\"Invalid character class \\\n+                                              range '{}-{}'\",\n+                                             c,\n+                                             c2)[])\n                 }\n                 ranges.push((c, self.cur()))\n             } else {\n@@ -489,7 +488,7 @@ impl<'a> Parser<'a> {\n                 FLAG_EMPTY\n             };\n         let name = self.slice(name_start, closer - 1);\n-        match find_class(ASCII_CLASSES, name.index(&FullRange)) {\n+        match find_class(ASCII_CLASSES, &name[]) {\n             None => None,\n             Some(ranges) => {\n                 self.chari = closer;\n@@ -511,21 +510,21 @@ impl<'a> Parser<'a> {\n             match self.pos('}') {\n                 Some(i) => i,\n                 None => {\n-                    return self.err(format!(\"No closing brace for counted \\\n-                                             repetition starting at position \\\n-                                             {:?}.\",\n-                                            start).index(&FullRange))\n+                    return self.err(&format!(\"No closing brace for counted \\\n+                                              repetition starting at position \\\n+                                              {:?}.\",\n+                                             start)[])\n                 }\n             };\n         self.chari = closer;\n         let greed = try!(self.get_next_greedy());\n-        let inner = self.chars.index(&((start+1)..closer)).iter().cloned()\n+        let inner = self.chars[(start+1)..closer].iter().cloned()\n                                                .collect::<String>();\n \n         // Parse the min and max values from the regex.\n         let (mut min, mut max): (uint, Option<uint>);\n         if !inner.contains(\",\") {\n-            min = try!(self.parse_uint(inner.index(&FullRange)));\n+            min = try!(self.parse_uint(&inner[]));\n             max = Some(min);\n         } else {\n             let pieces: Vec<&str> = inner.splitn(1, ',').collect();\n@@ -545,21 +544,21 @@ impl<'a> Parser<'a> {\n \n         // Do some bounds checking and make sure max >= min.\n         if min > MAX_REPEAT {\n-            return self.err(format!(\n+            return self.err(&format!(\n                 \"{} exceeds maximum allowed repetitions ({})\",\n-                min, MAX_REPEAT).index(&FullRange));\n+                min, MAX_REPEAT)[]);\n         }\n         if max.is_some() {\n             let m = max.unwrap();\n             if m > MAX_REPEAT {\n-                return self.err(format!(\n+                return self.err(&format!(\n                     \"{} exceeds maximum allowed repetitions ({})\",\n-                    m, MAX_REPEAT).index(&FullRange));\n+                    m, MAX_REPEAT)[]);\n             }\n             if m < min {\n-                return self.err(format!(\n+                return self.err(&format!(\n                     \"Max repetitions ({}) cannot be smaller than min \\\n-                     repetitions ({}).\", m, min).index(&FullRange));\n+                     repetitions ({}).\", m, min)[]);\n             }\n         }\n \n@@ -623,7 +622,7 @@ impl<'a> Parser<'a> {\n                 Ok(AstClass(ranges, flags))\n             }\n             _ => {\n-                self.err(format!(\"Invalid escape sequence '\\\\\\\\{}'\", c).index(&FullRange))\n+                self.err(&format!(\"Invalid escape sequence '\\\\\\\\{}'\", c)[])\n             }\n         }\n     }\n@@ -641,9 +640,9 @@ impl<'a> Parser<'a> {\n             let closer =\n                 match self.pos('}') {\n                     Some(i) => i,\n-                    None => return self.err(format!(\n+                    None => return self.err(&format!(\n                         \"Missing '}}' for unclosed '{{' at position {}\",\n-                        self.chari).index(&FullRange)),\n+                        self.chari)[]),\n                 };\n             if closer - self.chari + 1 == 0 {\n                 return self.err(\"No Unicode class name found.\")\n@@ -657,10 +656,10 @@ impl<'a> Parser<'a> {\n             name = self.slice(self.chari + 1, self.chari + 2);\n             self.chari += 1;\n         }\n-        match find_class(UNICODE_CLASSES, name.index(&FullRange)) {\n+        match find_class(UNICODE_CLASSES, &name[]) {\n             None => {\n-                return self.err(format!(\"Could not find Unicode class '{}'\",\n-                                        name).index(&FullRange))\n+                return self.err(&format!(\"Could not find Unicode class '{}'\",\n+                                        name)[])\n             }\n             Some(ranges) => {\n                 Ok(AstClass(ranges, negated | (self.flags & FLAG_NOCASE)))\n@@ -683,11 +682,11 @@ impl<'a> Parser<'a> {\n             }\n         }\n         let s = self.slice(start, end);\n-        match num::from_str_radix::<u32>(s.index(&FullRange), 8) {\n+        match num::from_str_radix::<u32>(&s[], 8) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{:?}' as octal number.\",\n-                                 s).index(&FullRange))\n+                self.err(&format!(\"Could not parse '{:?}' as octal number.\",\n+                                 s)[])\n             }\n         }\n     }\n@@ -703,14 +702,14 @@ impl<'a> Parser<'a> {\n         let closer =\n             match self.pos('}') {\n                 None => {\n-                    return self.err(format!(\"Missing '}}' for unclosed \\\n+                    return self.err(&format!(\"Missing '}}' for unclosed \\\n                                              '{{' at position {}\",\n-                                            start).index(&FullRange))\n+                                            start)[])\n                 }\n                 Some(i) => i,\n             };\n         self.chari = closer;\n-        self.parse_hex_digits(self.slice(start, closer).index(&FullRange))\n+        self.parse_hex_digits(&self.slice(start, closer)[])\n     }\n \n     // Parses a two-digit hex number.\n@@ -730,7 +729,7 @@ impl<'a> Parser<'a> {\n         match num::from_str_radix::<u32>(s, 16) {\n             Some(n) => Ok(Literal(try!(self.char_from_u32(n)), FLAG_EMPTY)),\n             None => {\n-                self.err(format!(\"Could not parse '{}' as hex number.\", s).index(&FullRange))\n+                self.err(&format!(\"Could not parse '{}' as hex number.\", s)[])\n             }\n         }\n     }\n@@ -755,8 +754,8 @@ impl<'a> Parser<'a> {\n                 \"Capture names can only have underscores, letters and digits.\")\n         }\n         if self.names.contains(&name) {\n-            return self.err(format!(\"Duplicate capture group name '{}'.\",\n-                                    name).index(&FullRange))\n+            return self.err(&format!(\"Duplicate capture group name '{}'.\",\n+                                    name)[])\n         }\n         self.names.push(name.clone());\n         self.chari = closer;\n@@ -788,9 +787,9 @@ impl<'a> Parser<'a> {\n                 'U' => { flags = flags | FLAG_SWAP_GREED; saw_flag = true},\n                 '-' => {\n                     if sign < 0 {\n-                        return self.err(format!(\n+                        return self.err(&format!(\n                             \"Cannot negate flags twice in '{}'.\",\n-                            self.slice(start, self.chari + 1)).index(&FullRange))\n+                            self.slice(start, self.chari + 1))[])\n                     }\n                     sign = -1;\n                     saw_flag = false;\n@@ -799,9 +798,9 @@ impl<'a> Parser<'a> {\n                 ':' | ')' => {\n                     if sign < 0 {\n                         if !saw_flag {\n-                            return self.err(format!(\n+                            return self.err(&format!(\n                                 \"A valid flag does not follow negation in '{}'\",\n-                                self.slice(start, self.chari + 1)).index(&FullRange))\n+                                self.slice(start, self.chari + 1))[])\n                         }\n                         flags = flags ^ flags;\n                     }\n@@ -812,8 +811,8 @@ impl<'a> Parser<'a> {\n                     self.flags = flags;\n                     return Ok(())\n                 }\n-                _ => return self.err(format!(\n-                    \"Unrecognized flag '{}'.\", self.cur()).index(&FullRange)),\n+                _ => return self.err(&format!(\n+                    \"Unrecognized flag '{}'.\", self.cur())[]),\n             }\n         }\n     }\n@@ -910,8 +909,8 @@ impl<'a> Parser<'a> {\n         match s.parse::<uint>() {\n             Some(i) => Ok(i),\n             None => {\n-                self.err(format!(\"Expected an unsigned integer but got '{}'.\",\n-                                 s).index(&FullRange))\n+                self.err(&format!(\"Expected an unsigned integer but got '{}'.\",\n+                                 s)[])\n             }\n         }\n     }\n@@ -920,8 +919,8 @@ impl<'a> Parser<'a> {\n         match char::from_u32(n) {\n             Some(c) => Ok(c),\n             None => {\n-                self.err(format!(\"Could not decode '{}' to unicode \\\n-                                  character.\", n).index(&FullRange))\n+                self.err(&format!(\"Could not decode '{}' to unicode \\\n+                                  character.\", n)[])\n             }\n         }\n     }\n@@ -954,7 +953,7 @@ impl<'a> Parser<'a> {\n     }\n \n     fn slice(&self, start: uint, end: uint) -> String {\n-        self.chars.index(&(start..end)).iter().cloned().collect()\n+        self.chars[start..end].iter().cloned().collect()\n     }\n }\n "}, {"sha": "16dd32b6be220692e295a96db5cda2804fc790f8", "filename": "src/libregex/re.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Fre.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Fre.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fre.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -90,15 +90,6 @@ impl Clone for ExNative {\n     }\n }\n \n-#[cfg(stage0)]\n-//FIXME: remove after stage0 snapshot\n-impl fmt::Show for Regex {\n-    /// Shows the original regular expression.\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self.as_str(), f)\n-    }\n-}\n-\n impl fmt::String for Regex {\n     /// Shows the original regular expression.\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -247,19 +238,19 @@ impl Regex {\n             }\n \n             let (s, e) = cap.pos(0).unwrap(); // captures only reports matches\n-            new.push_str(text.index(&(last_match..s)));\n-            new.push_str(rep.reg_replace(&cap).index(&FullRange));\n+            new.push_str(&text[last_match..s]);\n+            new.push_str(&rep.reg_replace(&cap)[]);\n             last_match = e;\n         }\n-        new.push_str(text.index(&(last_match..text.len())));\n+        new.push_str(&text[last_match..text.len()]);\n         return new;\n     }\n \n     /// Returns the original string of this regex.\n     pub fn as_str<'a>(&'a self) -> &'a str {\n         match *self {\n-            Dynamic(ExDynamic { ref original, .. }) => original.index(&FullRange),\n-            Native(ExNative { ref original, .. }) => original.index(&FullRange),\n+            Dynamic(ExDynamic { ref original, .. }) => &original[],\n+            Native(ExNative { ref original, .. }) => &original[],\n         }\n     }\n \n@@ -356,13 +347,13 @@ impl<'r, 't> Iterator for RegexSplits<'r, 't> {\n                 if self.last >= text.len() {\n                     None\n                 } else {\n-                    let s = text.index(&(self.last..text.len()));\n+                    let s = &text[self.last..text.len()];\n                     self.last = text.len();\n                     Some(s)\n                 }\n             }\n             Some((s, e)) => {\n-                let matched = text.index(&(self.last..s));\n+                let matched = &text[self.last..s];\n                 self.last = e;\n                 Some(matched)\n             }\n@@ -393,7 +384,7 @@ impl<'r, 't> Iterator for RegexSplitsN<'r, 't> {\n         } else {\n             self.cur += 1;\n             if self.cur >= self.limit {\n-                Some(text.index(&(self.splits.last..text.len())))\n+                Some(&text[self.splits.last..text.len()])\n             } else {\n                 self.splits.next()\n             }\n@@ -526,7 +517,7 @@ impl<'t> Captures<'t> {\n             })\n         });\n         let re = Regex::new(r\"\\$\\$\").unwrap();\n-        re.replace_all(text.index(&FullRange), NoExpand(\"$\"))\n+        re.replace_all(&text[], NoExpand(\"$\"))\n     }\n \n     /// Returns the number of captured groups."}, {"sha": "9605536a052c04d3135888e754e0c18269b128d5", "filename": "src/libregex/vm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Fvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibregex%2Fvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibregex%2Fvm.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -152,7 +152,7 @@ impl<'r, 't> Nfa<'r, 't> {\n                 // out early.\n                 if self.prog.prefix.len() > 0 && clist.size == 0 {\n                     let needle = self.prog.prefix.as_bytes();\n-                    let haystack = self.input.as_bytes().index(&(self.ic..));\n+                    let haystack = &self.input.as_bytes()[self.ic..];\n                     match find_prefix(needle, haystack) {\n                         None => break,\n                         Some(i) => {"}, {"sha": "e0143917a7cff203d76eed0fb1e85a0afd3981c5", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,6 +16,7 @@\n \n #![crate_name = \"rustc\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -25,6 +26,7 @@\n #![allow(unknown_features)]\n #![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![feature(old_impl_check)]\n "}, {"sha": "7d893f3a106cc7180af782f813563b8132ec228a", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 95, "deletions": 38, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -34,7 +34,7 @@ use middle::{def, pat_util, stability};\n use middle::const_eval::{eval_const_expr_partial, const_int, const_uint};\n use util::ppaux::{ty_to_string};\n use util::nodemap::{FnvHashMap, NodeSet};\n-use lint::{Context, LintPass, LintArray};\n+use lint::{Context, LintPass, LintArray, Lint};\n \n use std::collections::hash_map::Entry::{Occupied, Vacant};\n use std::num::SignedInt;\n@@ -506,7 +506,7 @@ impl BoxPointers {\n         if n_uniq > 0 {\n             let s = ty_to_string(cx.tcx, ty);\n             let m = format!(\"type uses owned (Box type) pointers: {}\", s);\n-            cx.span_lint(BOX_POINTERS, span, m.index(&FullRange));\n+            cx.span_lint(BOX_POINTERS, span, &m[]);\n         }\n     }\n }\n@@ -586,7 +586,7 @@ impl LintPass for RawPointerDerive {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        if !attr::contains_name(item.attrs.index(&FullRange), \"automatically_derived\") {\n+        if !attr::contains_name(&item.attrs[], \"automatically_derived\") {\n             return\n         }\n         let did = match item.node {\n@@ -770,11 +770,11 @@ impl LintPass for UnusedResults {\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, it.attrs.index(&FullRange), s.span);\n+                        warned |= check_must_use(cx, &it.attrs[], s.span);\n                     }\n                 } else {\n                     csearch::get_item_attrs(&cx.sess().cstore, did, |attrs| {\n-                        warned |= check_must_use(cx, attrs.index(&FullRange), s.span);\n+                        warned |= check_must_use(cx, &attrs[], s.span);\n                     });\n                 }\n             }\n@@ -796,7 +796,7 @@ impl LintPass for UnusedResults {\n                             msg.push_str(s.get());\n                         }\n                     }\n-                    cx.span_lint(UNUSED_MUST_USE, sp, msg.index(&FullRange));\n+                    cx.span_lint(UNUSED_MUST_USE, sp, &msg[]);\n                     return true;\n                 }\n             }\n@@ -842,7 +842,7 @@ impl NonCamelCaseTypes {\n             } else {\n                 format!(\"{} `{}` should have a camel case name such as `{}`\", sort, s, c)\n             };\n-            cx.span_lint(NON_CAMEL_CASE_TYPES, span, m.index(&FullRange));\n+            cx.span_lint(NON_CAMEL_CASE_TYPES, span, &m[]);\n         }\n     }\n }\n@@ -981,8 +981,8 @@ impl NonSnakeCase {\n \n         if !is_snake_case(ident) {\n             cx.span_lint(NON_SNAKE_CASE, span,\n-                format!(\"{} `{}` should have a snake case name such as `{}`\",\n-                        sort, s, to_snake_case(s.get())).index(&FullRange));\n+                &format!(\"{} `{}` should have a snake case name such as `{}`\",\n+                        sort, s, to_snake_case(s.get()))[]);\n         }\n     }\n }\n@@ -1066,10 +1066,10 @@ impl LintPass for NonUpperCaseGlobals {\n                 // upper/lowercase)\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n                     cx.span_lint(NON_UPPER_CASE_GLOBALS, it.span,\n-                        format!(\"static constant `{}` should have an uppercase name \\\n+                        &format!(\"static constant `{}` should have an uppercase name \\\n                                  such as `{}`\",\n-                                s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                .collect::<String>().index(&FullRange)).index(&FullRange));\n+                                s.get(), &s.get().chars().map(|c| c.to_uppercase())\n+                                .collect::<String>()[])[]);\n                 }\n             }\n             _ => {}\n@@ -1083,10 +1083,10 @@ impl LintPass for NonUpperCaseGlobals {\n                 let s = token::get_ident(path1.node);\n                 if s.get().chars().any(|c| c.is_lowercase()) {\n                     cx.span_lint(NON_UPPER_CASE_GLOBALS, path1.span,\n-                        format!(\"static constant in pattern `{}` should have an uppercase \\\n+                        &format!(\"static constant in pattern `{}` should have an uppercase \\\n                                  name such as `{}`\",\n-                                s.get(), s.get().chars().map(|c| c.to_uppercase())\n-                                    .collect::<String>().index(&FullRange)).index(&FullRange));\n+                                s.get(), &s.get().chars().map(|c| c.to_uppercase())\n+                                    .collect::<String>()[])[]);\n                 }\n             }\n             _ => {}\n@@ -1110,8 +1110,8 @@ impl UnusedParens {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n-                             format!(\"unnecessary parentheses around {}\",\n-                                     msg).index(&FullRange))\n+                             &format!(\"unnecessary parentheses around {}\",\n+                                     msg)[])\n             }\n         }\n \n@@ -1213,7 +1213,7 @@ impl LintPass for UnusedImportBraces {\n                                     let m = format!(\"braces around {} is unnecessary\",\n                                                     token::get_ident(*name).get());\n                                     cx.span_lint(UNUSED_IMPORT_BRACES, view_item.span,\n-                                                 m.index(&FullRange));\n+                                                 &m[]);\n                                 },\n                                 _ => ()\n                             }\n@@ -1251,8 +1251,8 @@ impl LintPass for NonShorthandFieldPatterns {\n                 if let ast::PatIdent(_, ident, None) = fieldpat.node.pat.node {\n                     if ident.node.as_str() == fieldpat.node.ident.as_str() {\n                         cx.span_lint(NON_SHORTHAND_FIELD_PATTERNS, fieldpat.span,\n-                                     format!(\"the `{}:` in this pattern is redundant and can \\\n-                                              be removed\", ident.node.as_str()).index(&FullRange))\n+                                     &format!(\"the `{}:` in this pattern is redundant and can \\\n+                                              be removed\", ident.node.as_str())[])\n                     }\n                 }\n             }\n@@ -1356,7 +1356,7 @@ impl LintPass for UnusedMut {\n     fn check_expr(&mut self, cx: &Context, e: &ast::Expr) {\n         if let ast::ExprMatch(_, ref arms, _) = e.node {\n             for a in arms.iter() {\n-                self.check_unused_mut_pat(cx, a.pats.index(&FullRange))\n+                self.check_unused_mut_pat(cx, &a.pats[])\n             }\n         }\n     }\n@@ -1477,7 +1477,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                format!(\"missing documentation for {}\", desc).index(&FullRange));\n+                &format!(\"missing documentation for {}\", desc)[]);\n         }\n     }\n }\n@@ -1491,7 +1491,7 @@ impl LintPass for MissingDoc {\n         let doc_hidden = self.doc_hidden() || attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") && match attr.meta_item_list() {\n                 None => false,\n-                Some(l) => attr::contains_name(l.index(&FullRange), \"hidden\"),\n+                Some(l) => attr::contains_name(&l[], \"hidden\"),\n             }\n         });\n         self.doc_hidden_stack.push(doc_hidden);\n@@ -1513,7 +1513,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, krate.attrs.index(&FullRange),\n+        self.check_missing_docs_attrs(cx, None, &krate.attrs[],\n                                      krate.span, \"crate\");\n     }\n \n@@ -1527,7 +1527,7 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), it.attrs.index(&FullRange),\n+        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs[],\n                                      it.span, desc);\n     }\n \n@@ -1540,13 +1540,13 @@ impl LintPass for MissingDoc {\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), m.attrs.index(&FullRange),\n+            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs[],\n                                           m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), tm.attrs.index(&FullRange),\n+        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs[],\n                                      tm.span, \"a type method\");\n     }\n \n@@ -1556,14 +1556,14 @@ impl LintPass for MissingDoc {\n                 let cur_struct_def = *self.struct_def_stack.last()\n                     .expect(\"empty struct_def_stack\");\n                 self.check_missing_docs_attrs(cx, Some(cur_struct_def),\n-                                              sf.node.attrs.index(&FullRange), sf.span,\n+                                              &sf.node.attrs[], sf.span,\n                                               \"a struct field\")\n             }\n         }\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), v.node.attrs.index(&FullRange),\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs[],\n                                      v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n@@ -1643,19 +1643,27 @@ declare_lint! {\n     \"detects use of #[unstable] items (incl. items with no stability attribute)\"\n }\n \n+declare_lint!(STAGED_EXPERIMENTAL, Warn,\n+              \"detects use of #[experimental] items in staged builds\");\n+\n+declare_lint!(STAGED_UNSTABLE, Warn,\n+              \"detects use of #[unstable] items (incl. items with no stability attribute) \\\n+               in staged builds\");\n+\n /// Checks for use of items with `#[deprecated]`, `#[experimental]` and\n /// `#[unstable]` attributes, or no stability attribute.\n #[derive(Copy)]\n pub struct Stability;\n \n impl Stability {\n     fn lint(&self, cx: &Context, id: ast::DefId, span: Span) {\n-        let stability = stability::lookup(cx.tcx, id);\n+\n+        let ref stability = stability::lookup(cx.tcx, id);\n         let cross_crate = !ast_util::is_local(id);\n \n         // stability attributes are promises made across crates; only\n         // check DEPRECATED for crate-local usage.\n-        let (lint, label) = match stability {\n+        let (lint, label) = match *stability {\n             // no stability attributes == Unstable\n             None if cross_crate => (UNSTABLE, \"unmarked\"),\n             Some(attr::Stability { level: attr::Unstable, .. }) if cross_crate =>\n@@ -1667,24 +1675,53 @@ impl Stability {\n             _ => return\n         };\n \n-        let msg = match stability {\n-            Some(attr::Stability { text: Some(ref s), .. }) => {\n-                format!(\"use of {} item: {}\", label, *s)\n+        output(cx, span, stability, lint, label);\n+        if cross_crate && stability::is_staged_api(cx.tcx, id) {\n+            if lint.name == UNSTABLE.name {\n+                output(cx, span, stability, STAGED_UNSTABLE, label);\n+            } else if lint.name == EXPERIMENTAL.name {\n+                output(cx, span, stability, STAGED_EXPERIMENTAL, label);\n             }\n-            _ => format!(\"use of {} item\", label)\n-        };\n+        }\n+\n+        fn output(cx: &Context, span: Span, stability: &Option<attr::Stability>,\n+                  lint: &'static Lint, label: &'static str) {\n+            let msg = match *stability {\n+                Some(attr::Stability { text: Some(ref s), .. }) => {\n+                    format!(\"use of {} item: {}\", label, *s)\n+                }\n+                _ => format!(\"use of {} item\", label)\n+            };\n \n-        cx.span_lint(lint, span, msg.index(&FullRange));\n+            cx.span_lint(lint, span, &msg[]);\n+        }\n     }\n \n+\n     fn is_internal(&self, cx: &Context, span: Span) -> bool {\n         cx.tcx.sess.codemap().span_is_internal(span)\n     }\n+\n }\n \n impl LintPass for Stability {\n     fn get_lints(&self) -> LintArray {\n-        lint_array!(DEPRECATED, EXPERIMENTAL, UNSTABLE)\n+        lint_array!(DEPRECATED, EXPERIMENTAL, UNSTABLE, STAGED_EXPERIMENTAL, STAGED_UNSTABLE)\n+    }\n+\n+    fn check_crate(&mut self, _: &Context, c: &ast::Crate) {\n+        // Just mark the #[staged_api] attribute used, though nothing else is done\n+        // with it during this pass over the source.\n+        for attr in c.attrs.iter() {\n+            if attr.name().get() == \"staged_api\" {\n+                match attr.node.value.node {\n+                    ast::MetaWord(_) => {\n+                        attr::mark_used(attr);\n+                    }\n+                    _ => (/*pass*/)\n+                }\n+            }\n+        }\n     }\n \n     fn check_view_item(&mut self, cx: &Context, item: &ast::ViewItem) {\n@@ -1746,6 +1783,7 @@ impl LintPass for Stability {\n             }\n             _ => return\n         };\n+\n         self.lint(cx, id, span);\n     }\n \n@@ -1878,3 +1916,22 @@ impl LintPass for HardwiredLints {\n         )\n     }\n }\n+\n+/// Forbids using the `#[feature(...)]` attribute\n+#[derive(Copy)]\n+pub struct UnstableFeatures;\n+\n+declare_lint!(UNSTABLE_FEATURES, Allow,\n+              \"enabling unstable features\");\n+\n+impl LintPass for UnstableFeatures {\n+    fn get_lints(&self) -> LintArray {\n+        lint_array!(UNSTABLE_FEATURES)\n+    }\n+    fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n+        use syntax::attr;\n+        if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n+            ctx.span_lint(UNSTABLE_FEATURES, attr.span, \"unstable feature\");\n+        }\n+    }\n+}"}, {"sha": "db4d99fe4940d6669bb06668e2315edc2b77bd72", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 71, "deletions": 31, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -28,8 +28,9 @@ use self::TargetLint::*;\n use middle::privacy::ExportedItems;\n use middle::ty::{self, Ty};\n use session::{early_error, Session};\n+use session::config::UnstableFeatures;\n use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass, LintPassObject};\n-use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid};\n+use lint::{Default, CommandLine, Node, Allow, Warn, Deny, Forbid, ReleaseChannel};\n use lint::builtin;\n use util::nodemap::FnvHashMap;\n \n@@ -104,7 +105,7 @@ impl LintStore {\n     }\n \n     pub fn get_lints<'t>(&'t self) -> &'t [(&'static Lint, bool)] {\n-        self.lints.index(&FullRange)\n+        &self.lints[]\n     }\n \n     pub fn get_lint_groups<'t>(&'t self) -> Vec<(&'static str, Vec<LintId>, bool)> {\n@@ -124,11 +125,11 @@ impl LintStore {\n                 match (sess, from_plugin) {\n                     // We load builtin lints first, so a duplicate is a compiler bug.\n                     // Use early_error when handling -W help with no crate.\n-                    (None, _) => early_error(msg.index(&FullRange)),\n-                    (Some(sess), false) => sess.bug(msg.index(&FullRange)),\n+                    (None, _) => early_error(&msg[]),\n+                    (Some(sess), false) => sess.bug(&msg[]),\n \n                     // A duplicate name from a plugin is a user error.\n-                    (Some(sess), true)  => sess.err(msg.index(&FullRange)),\n+                    (Some(sess), true)  => sess.err(&msg[]),\n                 }\n             }\n \n@@ -149,11 +150,11 @@ impl LintStore {\n             match (sess, from_plugin) {\n                 // We load builtin lints first, so a duplicate is a compiler bug.\n                 // Use early_error when handling -W help with no crate.\n-                (None, _) => early_error(msg.index(&FullRange)),\n-                (Some(sess), false) => sess.bug(msg.index(&FullRange)),\n+                (None, _) => early_error(&msg[]),\n+                (Some(sess), false) => sess.bug(&msg[]),\n \n                 // A duplicate name from a plugin is a user error.\n-                (Some(sess), true)  => sess.err(msg.index(&FullRange)),\n+                (Some(sess), true)  => sess.err(&msg[]),\n             }\n         }\n     }\n@@ -210,6 +211,7 @@ impl LintStore {\n                      UnusedAllocation,\n                      Stability,\n                      MissingCopyImplementations,\n+                     UnstableFeatures,\n         );\n \n         add_builtin_with_new!(sess,\n@@ -267,8 +269,8 @@ impl LintStore {\n                 let warning = format!(\"lint {} has been renamed to {}\",\n                                       lint_name, new_name);\n                 match span {\n-                    Some(span) => sess.span_warn(span, warning.index(&FullRange)),\n-                    None => sess.warn(warning.index(&FullRange)),\n+                    Some(span) => sess.span_warn(span, &warning[]),\n+                    None => sess.warn(&warning[]),\n                 };\n                 Some(lint_id)\n             }\n@@ -278,26 +280,49 @@ impl LintStore {\n \n     pub fn process_command_line(&mut self, sess: &Session) {\n         for &(ref lint_name, level) in sess.opts.lint_opts.iter() {\n-            match self.find_lint(lint_name.index(&FullRange), sess, None) {\n+            match self.find_lint(&lint_name[], sess, None) {\n                 Some(lint_id) => self.set_level(lint_id, (level, CommandLine)),\n                 None => {\n                     match self.lint_groups.iter().map(|(&x, pair)| (x, pair.0.clone()))\n                                                  .collect::<FnvHashMap<&'static str,\n                                                                        Vec<LintId>>>()\n-                                                 .get(lint_name.index(&FullRange)) {\n+                                                 .get(&lint_name[]) {\n                         Some(v) => {\n                             v.iter()\n                              .map(|lint_id: &LintId|\n                                      self.set_level(*lint_id, (level, CommandLine)))\n                              .collect::<Vec<()>>();\n                         }\n-                        None => sess.err(format!(\"unknown {} flag: {}\",\n-                                                 level.as_str(), lint_name).index(&FullRange)),\n+                        None => sess.err(&format!(\"unknown {} flag: {}\",\n+                                                 level.as_str(), lint_name)[]),\n                     }\n                 }\n             }\n         }\n     }\n+\n+    fn maybe_stage_features(&mut self, sess: &Session) {\n+        let lvl = match sess.opts.unstable_features {\n+            UnstableFeatures::Default => return,\n+            UnstableFeatures::Disallow => Warn,\n+            UnstableFeatures::Cheat => Allow\n+        };\n+        match self.by_name.get(\"unstable_features\") {\n+            Some(&Id(lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n+            Some(&Renamed(_, lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n+            None => unreachable!()\n+        }\n+        match self.by_name.get(\"staged_unstable\") {\n+            Some(&Id(lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n+            Some(&Renamed(_, lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n+            None => unreachable!()\n+        }\n+        match self.by_name.get(\"staged_experimental\") {\n+            Some(&Id(lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n+            Some(&Renamed(_, lint_id)) => self.set_level(lint_id, (lvl, ReleaseChannel)),\n+            None => unreachable!()\n+        }\n+    }\n }\n \n /// Context for lint checking.\n@@ -380,6 +405,7 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Allow { return }\n \n     let name = lint.name_lower();\n+    let mut def = None;\n     let mut note = None;\n     let msg = match source {\n         Default => {\n@@ -394,7 +420,13 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n                     }, name.replace(\"_\", \"-\"))\n         },\n         Node(src) => {\n-            note = Some(src);\n+            def = Some(src);\n+            msg.to_string()\n+        }\n+        ReleaseChannel => {\n+            let release_channel = option_env!(\"CFG_RELEASE_CHANNEL\").unwrap_or(\"(unknown)\");\n+            note = Some(format!(\"this feature may not be used in the {} release channel\",\n+                                release_channel));\n             msg.to_string()\n         }\n     };\n@@ -403,14 +435,18 @@ pub fn raw_emit_lint(sess: &Session, lint: &'static Lint,\n     if level == Forbid { level = Deny; }\n \n     match (level, span) {\n-        (Warn, Some(sp)) => sess.span_warn(sp, msg.index(&FullRange)),\n-        (Warn, None)     => sess.warn(msg.index(&FullRange)),\n-        (Deny, Some(sp)) => sess.span_err(sp, msg.index(&FullRange)),\n-        (Deny, None)     => sess.err(msg.index(&FullRange)),\n+        (Warn, Some(sp)) => sess.span_warn(sp, &msg[]),\n+        (Warn, None)     => sess.warn(&msg[]),\n+        (Deny, Some(sp)) => sess.span_err(sp, &msg[]),\n+        (Deny, None)     => sess.err(&msg[]),\n         _ => sess.bug(\"impossible level in raw_emit_lint\"),\n     }\n \n-    for span in note.into_iter() {\n+    for note in note.into_iter() {\n+        sess.note(&note[]);\n+    }\n+\n+    for span in def.into_iter() {\n         sess.span_note(span, \"lint level defined here\");\n     }\n }\n@@ -513,9 +549,9 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n                 if now == Forbid && level != Forbid {\n                     let lint_name = lint_id.as_str();\n                     self.tcx.sess.span_err(span,\n-                                           format!(\"{}({}) overruled by outer forbid({})\",\n+                                           &format!(\"{}({}) overruled by outer forbid({})\",\n                                                    level.as_str(), lint_name,\n-                                                   lint_name).index(&FullRange));\n+                                                   lint_name)[]);\n                 } else if now != level {\n                     let src = self.lints.get_level_source(lint_id).1;\n                     self.level_stack.push((lint_id, (now, src)));\n@@ -550,22 +586,22 @@ impl<'a, 'tcx> Context<'a, 'tcx> {\n \n impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     fn visit_item(&mut self, it: &ast::Item) {\n-        self.with_lint_attrs(it.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&it.attrs[], |cx| {\n             run_lints!(cx, check_item, it);\n             cx.visit_ids(|v| v.visit_item(it));\n             visit::walk_item(cx, it);\n         })\n     }\n \n     fn visit_foreign_item(&mut self, it: &ast::ForeignItem) {\n-        self.with_lint_attrs(it.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&it.attrs[], |cx| {\n             run_lints!(cx, check_foreign_item, it);\n             visit::walk_foreign_item(cx, it);\n         })\n     }\n \n     fn visit_view_item(&mut self, i: &ast::ViewItem) {\n-        self.with_lint_attrs(i.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&i.attrs[], |cx| {\n             run_lints!(cx, check_view_item, i);\n             cx.visit_ids(|v| v.visit_view_item(i));\n             visit::walk_view_item(cx, i);\n@@ -591,7 +627,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n                 body: &'v ast::Block, span: Span, id: ast::NodeId) {\n         match fk {\n             visit::FkMethod(_, _, m) => {\n-                self.with_lint_attrs(m.attrs.index(&FullRange), |cx| {\n+                self.with_lint_attrs(&m.attrs[], |cx| {\n                     run_lints!(cx, check_fn, fk, decl, body, span, id);\n                     cx.visit_ids(|v| {\n                         v.visit_fn(fk, decl, body, span, id);\n@@ -607,7 +643,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_ty_method(&mut self, t: &ast::TypeMethod) {\n-        self.with_lint_attrs(t.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&t.attrs[], |cx| {\n             run_lints!(cx, check_ty_method, t);\n             visit::walk_ty_method(cx, t);\n         })\n@@ -624,14 +660,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Context<'a, 'tcx> {\n     }\n \n     fn visit_struct_field(&mut self, s: &ast::StructField) {\n-        self.with_lint_attrs(s.node.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&s.node.attrs[], |cx| {\n             run_lints!(cx, check_struct_field, s);\n             visit::walk_struct_field(cx, s);\n         })\n     }\n \n     fn visit_variant(&mut self, v: &ast::Variant, g: &ast::Generics) {\n-        self.with_lint_attrs(v.node.attrs.index(&FullRange), |cx| {\n+        self.with_lint_attrs(&v.node.attrs[], |cx| {\n             run_lints!(cx, check_variant, v, g);\n             visit::walk_variant(cx, v, g);\n             run_lints!(cx, check_variant_post, v, g);\n@@ -725,7 +761,7 @@ impl<'a, 'tcx> IdVisitingOperation for Context<'a, 'tcx> {\n             None => {}\n             Some(lints) => {\n                 for (lint_id, span, msg) in lints.into_iter() {\n-                    self.span_lint(lint_id.lint, span, msg.index(&FullRange))\n+                    self.span_lint(lint_id.lint, span, &msg[])\n                 }\n             }\n         }\n@@ -767,11 +803,15 @@ impl LintPass for GatherNodeLevels {\n /// Consumes the `lint_store` field of the `Session`.\n pub fn check_crate(tcx: &ty::ctxt,\n                    exported_items: &ExportedItems) {\n+\n+    // If this is a feature-staged build of rustc then flip several lints to 'forbid'\n+    tcx.sess.lint_store.borrow_mut().maybe_stage_features(&tcx.sess);\n+\n     let krate = tcx.map.krate();\n     let mut cx = Context::new(tcx, krate, exported_items);\n \n     // Visit the whole crate.\n-    cx.with_lint_attrs(krate.attrs.index(&FullRange), |cx| {\n+    cx.with_lint_attrs(&krate.attrs[], |cx| {\n         cx.visit_id(ast::CRATE_NODE_ID);\n         cx.visit_ids(|v| {\n             v.visited_outermost = true;"}, {"sha": "8a266a2530b53a94ce64cdfeea76d0ab0c91a0bb", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -186,7 +186,7 @@ impl PartialEq for LintId {\n \n impl Eq for LintId { }\n \n-impl<S: hash::Writer> hash::Hash<S> for LintId {\n+impl<S: hash::Writer + hash::Hasher> hash::Hash<S> for LintId {\n     fn hash(&self, state: &mut S) {\n         let ptr = self.lint as *const Lint;\n         ptr.hash(state);\n@@ -248,6 +248,9 @@ pub enum LintSource {\n \n     /// Lint level was set by a command-line flag.\n     CommandLine,\n+\n+    /// Lint level was set by the release channel.\n+    ReleaseChannel\n }\n \n pub type LevelSource = (Level, LintSource);"}, {"sha": "310874c311b121f0c848de8afb445773b19c4bc7", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -65,7 +65,7 @@ fn dump_crates(cstore: &CStore) {\n }\n \n fn should_link(i: &ast::ViewItem) -> bool {\n-    !attr::contains_name(i.attrs.index(&FullRange), \"no_link\")\n+    !attr::contains_name(&i.attrs[], \"no_link\")\n \n }\n \n@@ -90,7 +90,7 @@ pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n     for c in s.chars() {\n         if c.is_alphanumeric() { continue }\n         if c == '_' || c == '-' { continue }\n-        err(format!(\"invalid character `{}` in crate name: `{}`\", c, s).index(&FullRange));\n+        err(&format!(\"invalid character `{}` in crate name: `{}`\", c, s)[]);\n     }\n     match sess {\n         Some(sess) => sess.abort_if_errors(),\n@@ -189,8 +189,8 @@ impl<'a> CrateReader<'a> {\n         match self.extract_crate_info(i) {\n             Some(info) => {\n                 let (cnum, _, _) = self.resolve_crate(&None,\n-                                                      info.ident.index(&FullRange),\n-                                                      info.name.index(&FullRange),\n+                                                      &info.ident[],\n+                                                      &info.name[],\n                                                       None,\n                                                       i.span,\n                                                       PathKind::Crate);\n@@ -209,7 +209,7 @@ impl<'a> CrateReader<'a> {\n                 let name = match *path_opt {\n                     Some((ref path_str, _)) => {\n                         let name = path_str.get().to_string();\n-                        validate_crate_name(Some(self.sess), name.index(&FullRange),\n+                        validate_crate_name(Some(self.sess), &name[],\n                                             Some(i.span));\n                         name\n                     }\n@@ -275,8 +275,8 @@ impl<'a> CrateReader<'a> {\n                                         cstore::NativeUnknown\n                                     } else {\n                                         self.sess.span_err(m.span,\n-                                            format!(\"unknown kind: `{}`\",\n-                                                    k).index(&FullRange));\n+                                            &format!(\"unknown kind: `{}`\",\n+                                                    k)[]);\n                                         cstore::NativeUnknown\n                                     }\n                                 }\n@@ -330,7 +330,7 @@ impl<'a> CrateReader<'a> {\n             match self.sess.opts.externs.get(name) {\n                 Some(locs) => {\n                     let found = locs.iter().any(|l| {\n-                        let l = fs::realpath(&Path::new(l.index(&FullRange))).ok();\n+                        let l = fs::realpath(&Path::new(&l[])).ok();\n                         l == source.dylib || l == source.rlib\n                     });\n                     if found {\n@@ -409,7 +409,7 @@ impl<'a> CrateReader<'a> {\n                     crate_name: name,\n                     hash: hash.map(|a| &*a),\n                     filesearch: self.sess.target_filesearch(kind),\n-                    triple: self.sess.opts.target_triple.index(&FullRange),\n+                    triple: &self.sess.opts.target_triple[],\n                     root: root,\n                     rejected_via_hash: vec!(),\n                     rejected_via_triple: vec!(),\n@@ -435,8 +435,8 @@ impl<'a> CrateReader<'a> {\n         decoder::get_crate_deps(cdata).iter().map(|dep| {\n             debug!(\"resolving dep crate {} hash: `{}`\", dep.name, dep.hash);\n             let (local_cnum, _, _) = self.resolve_crate(root,\n-                                                   dep.name.index(&FullRange),\n-                                                   dep.name.index(&FullRange),\n+                                                   &dep.name[],\n+                                                   &dep.name[],\n                                                    Some(&dep.hash),\n                                                    span,\n                                                    PathKind::Dependency);\n@@ -447,7 +447,7 @@ impl<'a> CrateReader<'a> {\n     pub fn read_plugin_metadata<'b>(&'b mut self,\n                                     vi: &'b ast::ViewItem) -> PluginMetadata<'b> {\n         let info = self.extract_crate_info(vi).unwrap();\n-        let target_triple = self.sess.opts.target_triple.index(&FullRange);\n+        let target_triple = &self.sess.opts.target_triple[];\n         let is_cross = target_triple != config::host_triple();\n         let mut should_link = info.should_link && !is_cross;\n         let mut target_only = false;\n@@ -456,8 +456,8 @@ impl<'a> CrateReader<'a> {\n         let mut load_ctxt = loader::Context {\n             sess: self.sess,\n             span: vi.span,\n-            ident: ident.index(&FullRange),\n-            crate_name: name.index(&FullRange),\n+            ident: &ident[],\n+            crate_name: &name[],\n             hash: None,\n             filesearch: self.sess.host_filesearch(PathKind::Crate),\n             triple: config::host_triple(),\n@@ -485,8 +485,8 @@ impl<'a> CrateReader<'a> {\n         let register = should_link && self.existing_match(info.name.as_slice(), None).is_none();\n         let metadata = if register {\n             // Register crate now to avoid double-reading metadata\n-            let (_, cmd, _) = self.register_crate(&None, info.ident.index(&FullRange),\n-                                info.name.index(&FullRange), vi.span, library);\n+            let (_, cmd, _) = self.register_crate(&None, &info.ident[],\n+                                &info.name[], vi.span, library);\n             PMDSource::Registered(cmd)\n         } else {\n             // Not registering the crate; just hold on to the metadata\n@@ -507,8 +507,8 @@ impl<'a> CrateReader<'a> {\n impl<'a> PluginMetadata<'a> {\n     /// Read exported macros\n     pub fn exported_macros(&self) -> Vec<ast::MacroDef> {\n-        let imported_from = Some(token::intern(self.info.ident.index(&FullRange)).ident());\n-        let source_name = format!(\"<{} macros>\", self.info.ident.index(&FullRange));\n+        let imported_from = Some(token::intern(&self.info.ident[]).ident());\n+        let source_name = format!(\"<{} macros>\", &self.info.ident[]);\n         let mut macros = vec![];\n         decoder::each_exported_macro(self.metadata.as_slice(),\n                                      &*self.sess.cstore.intr,\n@@ -550,7 +550,7 @@ impl<'a> PluginMetadata<'a> {\n                                   self.info.ident,\n                                   config::host_triple(),\n                                   self.sess.opts.target_triple);\n-            self.sess.span_err(self.vi_span, message.index(&FullRange));\n+            self.sess.span_err(self.vi_span, &message[]);\n             self.sess.abort_if_errors();\n         }\n \n@@ -563,7 +563,7 @@ impl<'a> PluginMetadata<'a> {\n                 let message = format!(\"plugin crate `{}` only found in rlib format, \\\n                                        but must be available in dylib format\",\n                                        self.info.ident);\n-                self.sess.span_err(self.vi_span, message.index(&FullRange));\n+                self.sess.span_err(self.vi_span, &message[]);\n                 // No need to abort because the loading code will just ignore this\n                 // empty dylib.\n                 None"}, {"sha": "cfff7c9935bc8ddefd18986be22f2710964d550c", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -27,6 +27,7 @@ use std::rc::Rc;\n use syntax::ast;\n use syntax::ast_map;\n use syntax::attr;\n+use syntax::attr::AttrMetaMethods;\n use syntax::diagnostic::expect;\n use syntax::parse::token;\n \n@@ -95,7 +96,7 @@ pub fn get_item_path(tcx: &ty::ctxt, def: ast::DefId) -> Vec<ast_map::PathElem>\n \n     // FIXME #1920: This path is not always correct if the crate is not linked\n     // into the root namespace.\n-    let mut r = vec![ast_map::PathMod(token::intern(cdata.name.index(&FullRange)))];\n+    let mut r = vec![ast_map::PathMod(token::intern(&cdata.name[]))];\n     r.push_all(path.as_slice());\n     r\n }\n@@ -375,6 +376,18 @@ pub fn get_stability(cstore: &cstore::CStore,\n     decoder::get_stability(&*cdata, def.node)\n }\n \n+pub fn is_staged_api(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n+    let cdata = cstore.get_crate_data(def.krate);\n+    let attrs = decoder::get_crate_attributes(cdata.data());\n+    for attr in attrs.iter() {\n+        if attr.name().get() == \"staged_api\" {\n+            match attr.node.value.node { ast::MetaWord(_) => return true, _ => (/*pass*/) }\n+        }\n+    }\n+\n+    return false;\n+}\n+\n pub fn get_repr_attrs(cstore: &cstore::CStore, def: ast::DefId)\n                       -> Vec<attr::ReprAttr> {\n     let cdata = cstore.get_crate_data(def.krate);"}, {"sha": "5ac8f908bf1642360d3e4f2ab461786eb573fefe", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -33,8 +33,7 @@ use middle::ty::{self, Ty};\n use middle::astencode::vtable_decoder_helpers;\n \n use std::collections::HashMap;\n-use std::hash::Hash;\n-use std::hash;\n+use std::hash::{self, Hash, SipHasher};\n use std::io::extensions::u64_from_be_bytes;\n use std::io;\n use std::num::FromPrimitive;\n@@ -75,7 +74,7 @@ fn lookup_hash<'a, F>(d: rbml::Doc<'a>, mut eq_fn: F, hash: u64) -> Option<rbml:\n     let mut ret = None;\n     reader::tagged_docs(tagged_doc.doc, belt, |elt| {\n         let pos = u64_from_be_bytes(elt.data, elt.start, 4) as uint;\n-        if eq_fn(elt.data.index(&((elt.start + 4) .. elt.end))) {\n+        if eq_fn(&elt.data[(elt.start + 4) .. elt.end]) {\n             ret = Some(reader::doc_at(d.data, pos).unwrap().doc);\n             false\n         } else {\n@@ -89,12 +88,12 @@ pub fn maybe_find_item<'a>(item_id: ast::NodeId,\n                            items: rbml::Doc<'a>) -> Option<rbml::Doc<'a>> {\n     fn eq_item(bytes: &[u8], item_id: ast::NodeId) -> bool {\n         return u64_from_be_bytes(\n-            bytes.index(&(0u..4u)), 0u, 4u) as ast::NodeId\n+            &bytes[0u..4u], 0u, 4u) as ast::NodeId\n             == item_id;\n     }\n     lookup_hash(items,\n                 |a| eq_item(a, item_id),\n-                hash::hash(&(item_id as i64)))\n+                hash::hash::<i64, SipHasher>(&(item_id as i64)))\n }\n \n fn find_item<'a>(item_id: ast::NodeId, items: rbml::Doc<'a>) -> rbml::Doc<'a> {\n@@ -1191,7 +1190,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n     }\n     reader::tagged_docs(depsdoc, tag_crate_dep, |depdoc| {\n         let name = docstr(depdoc, tag_crate_dep_crate_name);\n-        let hash = Svh::new(docstr(depdoc, tag_crate_dep_hash).index(&FullRange));\n+        let hash = Svh::new(&docstr(depdoc, tag_crate_dep_hash)[]);\n         deps.push(CrateDep {\n             cnum: crate_num,\n             name: name,"}, {"sha": "c8921f1b2fb934787752c4b0423da8da8da0aa08", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -29,8 +29,7 @@ use util::nodemap::{FnvHashMap, NodeMap, NodeSet};\n \n use serialize::Encodable;\n use std::cell::RefCell;\n-use std::hash::Hash;\n-use std::hash;\n+use std::hash::{Hash, Hasher, SipHasher};\n use syntax::abi;\n use syntax::ast::{self, DefId, NodeId};\n use syntax::ast_map::{PathElem, PathElems};\n@@ -95,7 +94,7 @@ fn encode_impl_type_basename(rbml_w: &mut Encoder, name: ast::Ident) {\n }\n \n pub fn encode_def_id(rbml_w: &mut Encoder, id: DefId) {\n-    rbml_w.wr_tagged_str(tag_def_id, def_to_string(id).index(&FullRange));\n+    rbml_w.wr_tagged_str(tag_def_id, &def_to_string(id)[]);\n }\n \n #[derive(Clone)]\n@@ -154,7 +153,7 @@ fn encode_variant_id(rbml_w: &mut Encoder, vid: DefId) {\n     rbml_w.end_tag();\n \n     rbml_w.start_tag(tag_mod_child);\n-    rbml_w.wr_str(s.index(&FullRange));\n+    rbml_w.wr_str(&s[]);\n     rbml_w.end_tag();\n }\n \n@@ -264,7 +263,7 @@ fn encode_symbol(ecx: &EncodeContext,\n         }\n         None => {\n             ecx.diag.handler().bug(\n-                format!(\"encode_symbol: id not found {}\", id).index(&FullRange));\n+                &format!(\"encode_symbol: id not found {}\", id)[]);\n         }\n     }\n     rbml_w.end_tag();\n@@ -332,8 +331,8 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n         encode_name(rbml_w, variant.node.name.name);\n         encode_parent_item(rbml_w, local_def(id));\n         encode_visibility(rbml_w, variant.node.vis);\n-        encode_attributes(rbml_w, variant.node.attrs.index(&FullRange));\n-        encode_repr_attrs(rbml_w, ecx, variant.node.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &variant.node.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, &variant.node.attrs[]);\n \n         let stab = stability::lookup(ecx.tcx, ast_util::local_def(variant.node.id));\n         encode_stability(rbml_w, stab);\n@@ -344,9 +343,9 @@ fn encode_enum_variant_info(ecx: &EncodeContext,\n                 let fields = ty::lookup_struct_fields(ecx.tcx, def_id);\n                 let idx = encode_info_for_struct(ecx,\n                                                  rbml_w,\n-                                                 fields.index(&FullRange),\n+                                                 &fields[],\n                                                  index);\n-                encode_struct_fields(rbml_w, fields.index(&FullRange), def_id);\n+                encode_struct_fields(rbml_w, &fields[], def_id);\n                 encode_index(rbml_w, idx, write_i64);\n             }\n         }\n@@ -386,12 +385,12 @@ fn encode_reexported_static_method(rbml_w: &mut Encoder,\n             exp.name, token::get_name(method_name));\n     rbml_w.start_tag(tag_items_data_item_reexport);\n     rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-    rbml_w.wr_str(def_to_string(method_def_id).index(&FullRange));\n+    rbml_w.wr_str(&def_to_string(method_def_id)[]);\n     rbml_w.end_tag();\n     rbml_w.start_tag(tag_items_data_item_reexport_name);\n-    rbml_w.wr_str(format!(\"{}::{}\",\n+    rbml_w.wr_str(&format!(\"{}::{}\",\n                           exp.name,\n-                          token::get_name(method_name)).index(&FullRange));\n+                          token::get_name(method_name))[]);\n     rbml_w.end_tag();\n     rbml_w.end_tag();\n }\n@@ -529,7 +528,7 @@ fn encode_reexports(ecx: &EncodeContext,\n                        id);\n                 rbml_w.start_tag(tag_items_data_item_reexport);\n                 rbml_w.start_tag(tag_items_data_item_reexport_def_id);\n-                rbml_w.wr_str(def_to_string(exp.def_id).index(&FullRange));\n+                rbml_w.wr_str(&def_to_string(exp.def_id)[]);\n                 rbml_w.end_tag();\n                 rbml_w.start_tag(tag_items_data_item_reexport_name);\n                 rbml_w.wr_str(exp.name.as_str());\n@@ -562,13 +561,13 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     // Encode info about all the module children.\n     for item in md.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id)).index(&FullRange));\n+        rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id)).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(local_def(\n+                        auxiliary_node_id))[]);\n             rbml_w.end_tag();\n             true\n         });\n@@ -580,7 +579,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                    did, ecx.tcx.map.node_to_string(did));\n \n             rbml_w.start_tag(tag_mod_impl);\n-            rbml_w.wr_str(def_to_string(local_def(did)).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(local_def(did))[]);\n             rbml_w.end_tag();\n         }\n     }\n@@ -615,7 +614,7 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n         ast::Public => 'y',\n         ast::Inherited => 'i',\n     };\n-    rbml_w.wr_str(ch.to_string().index(&FullRange));\n+    rbml_w.wr_str(&ch.to_string()[]);\n     rbml_w.end_tag();\n }\n \n@@ -627,7 +626,7 @@ fn encode_unboxed_closure_kind(rbml_w: &mut Encoder,\n         ty::FnMutUnboxedClosureKind => 'm',\n         ty::FnOnceUnboxedClosureKind => 'o',\n     };\n-    rbml_w.wr_str(ch.to_string().index(&FullRange));\n+    rbml_w.wr_str(&ch.to_string()[]);\n     rbml_w.end_tag();\n }\n \n@@ -788,7 +787,7 @@ fn encode_generics<'a, 'tcx>(rbml_w: &mut Encoder,\n         rbml_w.end_tag();\n \n         rbml_w.wr_tagged_str(tag_region_param_def_def_id,\n-                             def_to_string(param.def_id).index(&FullRange));\n+                             &def_to_string(param.def_id)[]);\n \n         rbml_w.wr_tagged_u64(tag_region_param_def_space,\n                              param.space.to_uint() as u64);\n@@ -864,9 +863,9 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     encode_path(rbml_w, impl_path.chain(Some(elem).into_iter()));\n     match ast_item_opt {\n         Some(&ast::MethodImplItem(ref ast_method)) => {\n-            encode_attributes(rbml_w, ast_method.attrs.index(&FullRange));\n+            encode_attributes(rbml_w, &ast_method.attrs[]);\n             let any_types = !pty.generics.types.is_empty();\n-            if any_types || is_default_impl || should_inline(ast_method.attrs.index(&FullRange)) {\n+            if any_types || is_default_impl || should_inline(&ast_method.attrs[]) {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                ast_item_opt.unwrap()));\n             }\n@@ -912,7 +911,7 @@ fn encode_info_for_associated_type(ecx: &EncodeContext,\n     match typedef_opt {\n         None => {}\n         Some(typedef) => {\n-            encode_attributes(rbml_w, typedef.attrs.index(&FullRange));\n+            encode_attributes(rbml_w, &typedef.attrs[]);\n             encode_type(ecx, rbml_w, ty::node_id_to_type(ecx.tcx,\n                                                          typedef.id));\n         }\n@@ -1046,7 +1045,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_path(rbml_w, path);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n         rbml_w.end_tag();\n       }\n       ast::ItemConst(_, _) => {\n@@ -1072,8 +1071,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n-        if tps_len > 0u || should_inline(item.attrs.index(&FullRange)) {\n+        encode_attributes(rbml_w, &item.attrs[]);\n+        if tps_len > 0u || should_inline(&item.attrs[]) {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n@@ -1089,7 +1088,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_info_for_mod(ecx,\n                             rbml_w,\n                             m,\n-                            item.attrs.index(&FullRange),\n+                            &item.attrs[],\n                             item.id,\n                             path,\n                             item.ident,\n@@ -1106,7 +1105,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         // Encode all the items in this module.\n         for foreign_item in fm.items.iter() {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(foreign_item.id)).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(local_def(foreign_item.id))[]);\n             rbml_w.end_tag();\n         }\n         encode_visibility(rbml_w, vis);\n@@ -1134,8 +1133,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n-        encode_repr_attrs(rbml_w, ecx, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n+        encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n         for v in (*enum_definition).variants.iter() {\n             encode_variant_id(rbml_w, local_def(v.node.id));\n         }\n@@ -1152,7 +1151,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_enum_variant_info(ecx,\n                                  rbml_w,\n                                  item.id,\n-                                 (*enum_definition).variants.index(&FullRange),\n+                                 &(*enum_definition).variants[],\n                                  index);\n       }\n       ast::ItemStruct(ref struct_def, _) => {\n@@ -1164,7 +1163,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n            class itself */\n         let idx = encode_info_for_struct(ecx,\n                                          rbml_w,\n-                                         fields.index(&FullRange),\n+                                         &fields[],\n                                          index);\n \n         /* Index the class*/\n@@ -1178,16 +1177,16 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n         encode_item_variances(rbml_w, ecx, item.id);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n         encode_path(rbml_w, path.clone());\n         encode_stability(rbml_w, stab);\n         encode_visibility(rbml_w, vis);\n-        encode_repr_attrs(rbml_w, ecx, item.attrs.index(&FullRange));\n+        encode_repr_attrs(rbml_w, ecx, &item.attrs[]);\n \n         /* Encode def_ids for each field and method\n          for methods, write all the stuff get_trait_method\n         needs to know*/\n-        encode_struct_fields(rbml_w, fields.index(&FullRange), def_id);\n+        encode_struct_fields(rbml_w, &fields[], def_id);\n \n         encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n \n@@ -1219,7 +1218,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_family(rbml_w, 'i');\n         encode_bounds_and_type(rbml_w, ecx, &lookup_item_type(tcx, def_id));\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n         encode_unsafety(rbml_w, unsafety);\n         encode_polarity(rbml_w, polarity);\n         match ty.node {\n@@ -1323,7 +1322,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_generics(rbml_w, ecx, &trait_def.generics, tag_item_generics);\n         encode_trait_ref(rbml_w, ecx, &*trait_def.trait_ref, tag_item_trait_ref);\n         encode_name(rbml_w, item.ident.name);\n-        encode_attributes(rbml_w, item.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &item.attrs[]);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         for &method_def_id in ty::trait_item_def_ids(tcx, def_id).iter() {\n@@ -1341,7 +1340,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             rbml_w.end_tag();\n \n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(method_def_id.def_id()).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(method_def_id.def_id())[]);\n             rbml_w.end_tag();\n         }\n         encode_path(rbml_w, path.clone());\n@@ -1433,14 +1432,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             };\n             match trait_item {\n                 &ast::RequiredMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs.index(&FullRange));\n+                    encode_attributes(rbml_w, &m.attrs[]);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'r');\n                     encode_method_argument_names(rbml_w, &*m.decl);\n                 }\n \n                 &ast::ProvidedMethod(ref m) => {\n-                    encode_attributes(rbml_w, m.attrs.index(&FullRange));\n+                    encode_attributes(rbml_w, &m.attrs[]);\n                     encode_trait_item(rbml_w);\n                     encode_item_sort(rbml_w, 'p');\n                     encode_inlined_item(ecx, rbml_w, IITraitItemRef(def_id, trait_item));\n@@ -1449,7 +1448,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n \n                 &ast::TypeTraitItem(ref associated_type) => {\n                     encode_attributes(rbml_w,\n-                                      associated_type.attrs.index(&FullRange));\n+                                      &associated_type.attrs[]);\n                     encode_item_sort(rbml_w, 't');\n                 }\n             }\n@@ -1598,11 +1597,13 @@ fn encode_info_for_items(ecx: &EncodeContext,\n \n fn encode_index<T, F>(rbml_w: &mut Encoder, index: Vec<entry<T>>, mut write_fn: F) where\n     F: FnMut(&mut SeekableMemWriter, &T),\n-    T: Hash,\n+    T: Hash<SipHasher>,\n {\n     let mut buckets: Vec<Vec<entry<T>>> = range(0, 256u16).map(|_| Vec::new()).collect();\n     for elt in index.into_iter() {\n-        let h = hash::hash(&elt.val) as uint;\n+        let mut s = SipHasher::new();\n+        elt.val.hash(&mut s);\n+        let h = s.finish() as uint;\n         (&mut buckets[h % 256]).push(elt);\n     }\n \n@@ -1826,10 +1827,10 @@ fn encode_macro_defs(rbml_w: &mut Encoder,\n         rbml_w.start_tag(tag_macro_def);\n \n         encode_name(rbml_w, def.ident.name);\n-        encode_attributes(rbml_w, def.attrs.index(&FullRange));\n+        encode_attributes(rbml_w, &def.attrs[]);\n \n         rbml_w.start_tag(tag_macro_def_body);\n-        rbml_w.wr_str(pprust::tts_to_string(def.body.index(&FullRange)).index(&FullRange));\n+        rbml_w.wr_str(&pprust::tts_to_string(&def.body[])[]);\n         rbml_w.end_tag();\n \n         rbml_w.end_tag();\n@@ -1869,7 +1870,7 @@ fn encode_struct_field_attrs(rbml_w: &mut Encoder, krate: &ast::Crate) {\n         fn visit_struct_field(&mut self, field: &ast::StructField) {\n             self.rbml_w.start_tag(tag_struct_field);\n             self.rbml_w.wr_tagged_u32(tag_struct_field_id, field.node.id);\n-            encode_attributes(self.rbml_w, field.node.attrs.index(&FullRange));\n+            encode_attributes(self.rbml_w, &field.node.attrs[]);\n             self.rbml_w.end_tag();\n         }\n     }\n@@ -1941,13 +1942,13 @@ fn encode_misc_info(ecx: &EncodeContext,\n     rbml_w.start_tag(tag_misc_info_crate_items);\n     for item in krate.module.items.iter() {\n         rbml_w.start_tag(tag_mod_child);\n-        rbml_w.wr_str(def_to_string(local_def(item.id)).index(&FullRange));\n+        rbml_w.wr_str(&def_to_string(local_def(item.id))[]);\n         rbml_w.end_tag();\n \n         each_auxiliary_node_id(&**item, |auxiliary_node_id| {\n             rbml_w.start_tag(tag_mod_child);\n-            rbml_w.wr_str(def_to_string(local_def(\n-                        auxiliary_node_id)).index(&FullRange));\n+            rbml_w.wr_str(&def_to_string(local_def(\n+                        auxiliary_node_id))[]);\n             rbml_w.end_tag();\n             true\n         });\n@@ -2116,17 +2117,17 @@ fn encode_metadata_inner(wr: &mut SeekableMemWriter,\n \n     let mut rbml_w = writer::Encoder::new(wr);\n \n-    encode_crate_name(&mut rbml_w, ecx.link_meta.crate_name.index(&FullRange));\n+    encode_crate_name(&mut rbml_w, &ecx.link_meta.crate_name[]);\n     encode_crate_triple(&mut rbml_w,\n-                        tcx.sess\n+                        &tcx.sess\n                            .opts\n                            .target_triple\n-                           .index(&FullRange));\n+                           []);\n     encode_hash(&mut rbml_w, &ecx.link_meta.crate_hash);\n     encode_dylib_dependency_formats(&mut rbml_w, &ecx);\n \n     let mut i = rbml_w.writer.tell().unwrap();\n-    encode_attributes(&mut rbml_w, krate.attrs.index(&FullRange));\n+    encode_attributes(&mut rbml_w, &krate.attrs[]);\n     stats.attr_bytes = rbml_w.writer.tell().unwrap() - i;\n \n     i = rbml_w.writer.tell().unwrap();"}, {"sha": "e8160487e16f73f1a7c36048a4e57c82498e4984", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -272,12 +272,12 @@ fn find_libdir(sysroot: &Path) -> String {\n         }\n     }\n \n-    #[cfg(target_word_size = \"64\")]\n+    #[cfg(any(all(stage0, target_word_size = \"64\"), all(not(stage0), target_pointer_width = \"64\")))]\n     fn primary_libdir_name() -> String {\n         \"lib64\".to_string()\n     }\n \n-    #[cfg(target_word_size = \"32\")]\n+    #[cfg(any(all(stage0, target_word_size = \"32\"), all(not(stage0), target_pointer_width = \"32\")))]\n     fn primary_libdir_name() -> String {\n         \"lib32\".to_string()\n     }"}, {"sha": "3a925aba0b7c3d6caa0f6fe8ae6b7604e4b1496c", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -315,14 +315,14 @@ impl<'a> Context<'a> {\n             &Some(ref r) => format!(\"{} which `{}` depends on\",\n                                     message, r.ident)\n         };\n-        self.sess.span_err(self.span, message.index(&FullRange));\n+        self.sess.span_err(self.span, &message[]);\n \n         if self.rejected_via_triple.len() > 0 {\n             let mismatches = self.rejected_via_triple.iter();\n             for (i, &CrateMismatch{ ref path, ref got }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n-                    format!(\"crate `{}`, path #{}, triple {}: {}\",\n-                            self.ident, i+1, got, path.display()).index(&FullRange));\n+                    &format!(\"crate `{}`, path #{}, triple {}: {}\",\n+                            self.ident, i+1, got, path.display())[]);\n             }\n         }\n         if self.rejected_via_hash.len() > 0 {\n@@ -331,16 +331,16 @@ impl<'a> Context<'a> {\n             let mismatches = self.rejected_via_hash.iter();\n             for (i, &CrateMismatch{ ref path, .. }) in mismatches.enumerate() {\n                 self.sess.fileline_note(self.span,\n-                    format!(\"crate `{}` path {}{}: {}\",\n-                            self.ident, \"#\", i+1, path.display()).index(&FullRange));\n+                    &format!(\"crate `{}` path {}{}: {}\",\n+                            self.ident, \"#\", i+1, path.display())[]);\n             }\n             match self.root {\n                 &None => {}\n                 &Some(ref r) => {\n                     for (i, path) in r.paths().iter().enumerate() {\n                         self.sess.fileline_note(self.span,\n-                            format!(\"crate `{}` path #{}: {}\",\n-                                    r.ident, i+1, path.display()).index(&FullRange));\n+                            &format!(\"crate `{}` path #{}: {}\",\n+                                    r.ident, i+1, path.display())[]);\n                     }\n                 }\n             }\n@@ -386,7 +386,7 @@ impl<'a> Context<'a> {\n                 None => return FileDoesntMatch,\n                 Some(file) => file,\n             };\n-            let (hash, rlib) = if file.starts_with(rlib_prefix.index(&FullRange)) &&\n+            let (hash, rlib) = if file.starts_with(&rlib_prefix[]) &&\n                     file.ends_with(\".rlib\") {\n                 (file.slice(rlib_prefix.len(), file.len() - \".rlib\".len()),\n                  true)\n@@ -445,27 +445,27 @@ impl<'a> Context<'a> {\n             1 => Some(libraries.into_iter().next().unwrap()),\n             _ => {\n                 self.sess.span_err(self.span,\n-                    format!(\"multiple matching crates for `{}`\",\n-                            self.crate_name).index(&FullRange));\n+                    &format!(\"multiple matching crates for `{}`\",\n+                            self.crate_name)[]);\n                 self.sess.note(\"candidates:\");\n                 for lib in libraries.iter() {\n                     match lib.dylib {\n                         Some(ref p) => {\n-                            self.sess.note(format!(\"path: {}\",\n-                                                   p.display()).index(&FullRange));\n+                            self.sess.note(&format!(\"path: {}\",\n+                                                   p.display())[]);\n                         }\n                         None => {}\n                     }\n                     match lib.rlib {\n                         Some(ref p) => {\n-                            self.sess.note(format!(\"path: {}\",\n-                                                   p.display()).index(&FullRange));\n+                            self.sess.note(&format!(\"path: {}\",\n+                                                   p.display())[]);\n                         }\n                         None => {}\n                     }\n                     let data = lib.metadata.as_slice();\n                     let name = decoder::get_crate_name(data);\n-                    note_crate_name(self.sess.diagnostic(), name.index(&FullRange));\n+                    note_crate_name(self.sess.diagnostic(), &name[]);\n                 }\n                 None\n             }\n@@ -516,22 +516,22 @@ impl<'a> Context<'a> {\n             };\n             if ret.is_some() {\n                 self.sess.span_err(self.span,\n-                                   format!(\"multiple {} candidates for `{}` \\\n+                                   &format!(\"multiple {} candidates for `{}` \\\n                                             found\",\n                                            flavor,\n-                                           self.crate_name).index(&FullRange));\n+                                           self.crate_name)[]);\n                 self.sess.span_note(self.span,\n-                                    format!(r\"candidate #1: {}\",\n+                                    &format!(r\"candidate #1: {}\",\n                                             ret.as_ref().unwrap()\n-                                               .display()).index(&FullRange));\n+                                               .display())[]);\n                 error = 1;\n                 ret = None;\n             }\n             if error > 0 {\n                 error += 1;\n                 self.sess.span_note(self.span,\n-                                    format!(r\"candidate #{}: {}\", error,\n-                                            lib.display()).index(&FullRange));\n+                                    &format!(r\"candidate #{}: {}\", error,\n+                                            lib.display())[]);\n                 continue\n             }\n             *slot = Some(metadata);\n@@ -606,31 +606,31 @@ impl<'a> Context<'a> {\n         let mut rlibs = HashSet::new();\n         let mut dylibs = HashSet::new();\n         {\n-            let mut locs = locs.iter().map(|l| Path::new(l.index(&FullRange))).filter(|loc| {\n+            let mut locs = locs.iter().map(|l| Path::new(&l[])).filter(|loc| {\n                 if !loc.exists() {\n-                    sess.err(format!(\"extern location for {} does not exist: {}\",\n-                                     self.crate_name, loc.display()).index(&FullRange));\n+                    sess.err(&format!(\"extern location for {} does not exist: {}\",\n+                                     self.crate_name, loc.display())[]);\n                     return false;\n                 }\n                 let file = match loc.filename_str() {\n                     Some(file) => file,\n                     None => {\n-                        sess.err(format!(\"extern location for {} is not a file: {}\",\n-                                         self.crate_name, loc.display()).index(&FullRange));\n+                        sess.err(&format!(\"extern location for {} is not a file: {}\",\n+                                         self.crate_name, loc.display())[]);\n                         return false;\n                     }\n                 };\n                 if file.starts_with(\"lib\") && file.ends_with(\".rlib\") {\n                     return true\n                 } else {\n                     let (ref prefix, ref suffix) = dylibname;\n-                    if file.starts_with(prefix.index(&FullRange)) &&\n-                       file.ends_with(suffix.index(&FullRange)) {\n+                    if file.starts_with(&prefix[]) &&\n+                       file.ends_with(&suffix[]) {\n                         return true\n                     }\n                 }\n-                sess.err(format!(\"extern location for {} is of an unknown type: {}\",\n-                                 self.crate_name, loc.display()).index(&FullRange));\n+                sess.err(&format!(\"extern location for {} is of an unknown type: {}\",\n+                                 self.crate_name, loc.display())[]);\n                 false\n             });\n \n@@ -663,7 +663,7 @@ impl<'a> Context<'a> {\n }\n \n pub fn note_crate_name(diag: &SpanHandler, name: &str) {\n-    diag.handler().note(format!(\"crate name: {}\", name).index(&FullRange));\n+    diag.handler().note(&format!(\"crate name: {}\", name)[]);\n }\n \n impl ArchiveMetadata {"}, {"sha": "5aacaa04e46d049ec8e42c3882481db22f5b82ba", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -98,7 +98,7 @@ fn scan<R, F, G>(st: &mut PState, mut is_last: F, op: G) -> R where\n     }\n     let end_pos = st.pos;\n     st.pos += 1;\n-    return op(st.data.index(&(start_pos..end_pos)));\n+    return op(&st.data[start_pos..end_pos]);\n }\n \n pub fn parse_ident(st: &mut PState, last: char) -> ast::Ident {\n@@ -250,8 +250,8 @@ fn parse_trait_store_<F>(st: &mut PState, conv: &mut F) -> ty::TraitStore where\n         '~' => ty::UniqTraitStore,\n         '&' => ty::RegionTraitStore(parse_region_(st, conv), parse_mutability(st)),\n         c => {\n-            st.tcx.sess.bug(format!(\"parse_trait_store(): bad input '{}'\",\n-                                    c).index(&FullRange))\n+            st.tcx.sess.bug(&format!(\"parse_trait_store(): bad input '{}'\",\n+                                    c)[])\n         }\n     }\n }\n@@ -318,7 +318,7 @@ fn parse_bound_region_<F>(st: &mut PState, conv: &mut F) -> ty::BoundRegion wher\n         }\n         '[' => {\n             let def = parse_def_(st, RegionParameter, conv);\n-            let ident = token::str_to_ident(parse_str(st, ']').index(&FullRange));\n+            let ident = token::str_to_ident(&parse_str(st, ']')[]);\n             ty::BrNamed(def, ident.name)\n         }\n         'f' => {\n@@ -357,7 +357,7 @@ fn parse_region_<F>(st: &mut PState, conv: &mut F) -> ty::Region where\n         assert_eq!(next(st), '|');\n         let index = parse_u32(st);\n         assert_eq!(next(st), '|');\n-        let nm = token::str_to_ident(parse_str(st, ']').index(&FullRange));\n+        let nm = token::str_to_ident(&parse_str(st, ']')[]);\n         ty::ReEarlyBound(node_id, space, index, nm.name)\n       }\n       'f' => {\n@@ -481,7 +481,7 @@ fn parse_ty_<'a, 'tcx, F>(st: &mut PState<'a, 'tcx>, conv: &mut F) -> Ty<'tcx> w\n         assert_eq!(next(st), '|');\n         let space = parse_param_space(st);\n         assert_eq!(next(st), '|');\n-        let name = token::intern(parse_str(st, ']').index(&FullRange));\n+        let name = token::intern(&parse_str(st, ']')[]);\n         return ty::mk_param(tcx, space, index, name);\n       }\n       '~' => return ty::mk_uniq(tcx, parse_ty_(st, conv)),\n@@ -637,7 +637,7 @@ fn parse_abi_set(st: &mut PState) -> abi::Abi {\n     assert_eq!(next(st), '[');\n     scan(st, |c| c == ']', |bytes| {\n         let abi_str = str::from_utf8(bytes).unwrap();\n-        abi::lookup(abi_str.index(&FullRange)).expect(abi_str)\n+        abi::lookup(&abi_str[]).expect(abi_str)\n     })\n }\n \n@@ -733,8 +733,8 @@ pub fn parse_def_id(buf: &[u8]) -> ast::DefId {\n         panic!();\n     }\n \n-    let crate_part = buf.index(&(0u..colon_idx));\n-    let def_part = buf.index(&((colon_idx + 1u)..len));\n+    let crate_part = &buf[0u..colon_idx];\n+    let def_part = &buf[(colon_idx + 1u)..len];\n \n     let crate_num = match str::from_utf8(crate_part).ok().and_then(|s| s.parse::<uint>()) {\n        Some(cn) => cn as ast::CrateNum,"}, {"sha": "8cd3795580e8bccf24d76d40ae2ffc59fb23efaf", "filename": "src/librustc/middle/astconv_util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastconv_util.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -47,8 +47,8 @@ pub fn ast_ty_to_prim_ty<'tcx>(tcx: &ty::ctxt<'tcx>, ast_ty: &ast::Ty)\n             let a_def = match tcx.def_map.borrow().get(&id) {\n                 None => {\n                     tcx.sess.span_bug(ast_ty.span,\n-                                      format!(\"unbound path {}\",\n-                                              path.repr(tcx)).index(&FullRange))\n+                                      &format!(\"unbound path {}\",\n+                                              path.repr(tcx))[])\n                 }\n                 Some(&d) => d\n             };"}, {"sha": "550c0f34cafec6d53782098d387d566a15b9fd40", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -132,7 +132,7 @@ pub fn decode_inlined_item<'tcx>(cdata: &cstore::crate_metadata,\n             // Do an Option dance to use the path after it is moved below.\n             let s = ast_map::path_to_string(ast_map::Values(path.iter()));\n             path_as_str = Some(s);\n-            path_as_str.as_ref().map(|x| x.index(&FullRange))\n+            path_as_str.as_ref().map(|x| &x[])\n         });\n         let mut ast_dsr = reader::Decoder::new(ast_doc);\n         let from_id_range = Decodable::decode(&mut ast_dsr).unwrap();\n@@ -1876,8 +1876,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n         match c::astencode_tag::from_uint(tag) {\n             None => {\n                 dcx.tcx.sess.bug(\n-                    format!(\"unknown tag found in side tables: {:x}\",\n-                            tag).index(&FullRange));\n+                    &format!(\"unknown tag found in side tables: {:x}\",\n+                            tag)[]);\n             }\n             Some(value) => {\n                 let val_doc = entry_doc.get(c::tag_table_val as uint);\n@@ -1961,8 +1961,8 @@ fn decode_side_tables(dcx: &DecodeContext,\n                     }\n                     _ => {\n                         dcx.tcx.sess.bug(\n-                            format!(\"unknown tag found in side tables: {:x}\",\n-                                    tag).index(&FullRange));\n+                            &format!(\"unknown tag found in side tables: {:x}\",\n+                                    tag)[]);\n                     }\n                 }\n             }"}, {"sha": "b601ea59486ce6ee32e67218530700b0c20e75f4", "filename": "src/librustc/middle/cfg/construct.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fconstruct.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -362,7 +362,7 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                 let mut cond_exit = discr_exit;\n                 for arm in arms.iter() {\n                     cond_exit = self.add_dummy_node(&[cond_exit]);        // 2\n-                    let pats_exit = self.pats_any(arm.pats.index(&FullRange),\n+                    let pats_exit = self.pats_any(&arm.pats[],\n                                                   cond_exit);            // 3\n                     let guard_exit = self.opt_expr(&arm.guard,\n                                                    pats_exit);           // 4\n@@ -615,15 +615,15 @@ impl<'a, 'tcx> CFGBuilder<'a, 'tcx> {\n                         }\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"no loop scope for id {}\",\n-                                    loop_id).index(&FullRange));\n+                            &format!(\"no loop scope for id {}\",\n+                                    loop_id)[]);\n                     }\n \n                     r => {\n                         self.tcx.sess.span_bug(\n                             expr.span,\n-                            format!(\"bad entry `{:?}` in def_map for label\",\n-                                    r).index(&FullRange));\n+                            &format!(\"bad entry `{:?}` in def_map for label\",\n+                                    r)[]);\n                     }\n                 }\n             }"}, {"sha": "f4db2b6e61db2d7ba6bcf8e98a18a447f3c15f2e", "filename": "src/librustc/middle/cfg/graphviz.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcfg%2Fgraphviz.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -52,7 +52,7 @@ fn replace_newline_with_backslash_l(s: String) -> String {\n }\n \n impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n-    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(self.name.index(&FullRange)).unwrap() }\n+    fn graph_id(&'a self) -> dot::Id<'a> { dot::Id::new(&self.name[]).unwrap() }\n \n     fn node_id(&'a self, &(i,_): &Node<'a>) -> dot::Id<'a> {\n         dot::Id::new(format!(\"N{}\", i.node_id())).unwrap()\n@@ -85,9 +85,9 @@ impl<'a, 'ast> dot::Labeller<'a, Node<'a>, Edge<'a>> for LabelledCFG<'a, 'ast> {\n             let s = self.ast_map.node_to_string(node_id);\n             // left-aligns the lines\n             let s = replace_newline_with_backslash_l(s);\n-            label.push_str(format!(\"exiting scope_{} {}\",\n+            label.push_str(&format!(\"exiting scope_{} {}\",\n                                    i,\n-                                   s.index(&FullRange)).index(&FullRange));\n+                                   &s[])[]);\n         }\n         dot::LabelText::EscStr(label.into_cow())\n     }"}, {"sha": "1f779acac2503b10285a8f9762fa2becad809772", "filename": "src/librustc/middle/check_loop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_loop.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -74,11 +74,11 @@ impl<'a> CheckLoopVisitor<'a> {\n             Loop => {}\n             Closure => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` inside of a closure\", name).index(&FullRange));\n+                                   &format!(\"`{}` inside of a closure\", name)[]);\n             }\n             Normal => {\n                 self.sess.span_err(span,\n-                                   format!(\"`{}` outside of loop\", name).index(&FullRange));\n+                                   &format!(\"`{}` outside of loop\", name)[]);\n             }\n         }\n     }"}, {"sha": "43f39a67f5c41b1d78b34b74a602d0965c2d9f40", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -47,7 +47,7 @@ struct Matrix<'a>(Vec<Vec<&'a Pat>>);\n \n /// Pretty-printer for matrices of patterns, example:\n /// ++++++++++++++++++++++++++\n-/// + _     + .index(&FullRange)             +\n+/// + _     + []             +\n /// ++++++++++++++++++++++++++\n /// + true  + [First]        +\n /// ++++++++++++++++++++++++++\n@@ -161,7 +161,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n                 // First, check legality of move bindings.\n                 check_legality_of_move_bindings(cx,\n                                                 arm.guard.is_some(),\n-                                                arm.pats.index(&FullRange));\n+                                                &arm.pats[]);\n \n                 // Second, if there is a guard on each arm, make sure it isn't\n                 // assigning or borrowing anything mutably.\n@@ -198,7 +198,7 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             }\n \n             // Fourth, check for unreachable arms.\n-            check_arms(cx, inlined_arms.index(&FullRange), source);\n+            check_arms(cx, &inlined_arms[], source);\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n@@ -228,9 +228,9 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &ast::Expr) {\n             is_refutable(cx, &*static_inliner.fold_pat((*pat).clone()), |uncovered_pat| {\n                 cx.tcx.sess.span_err(\n                     pat.span,\n-                    format!(\"refutable pattern in `for` loop binding: \\\n+                    &format!(\"refutable pattern in `for` loop binding: \\\n                             `{}` not covered\",\n-                            pat_to_string(uncovered_pat)).index(&FullRange));\n+                            pat_to_string(uncovered_pat))[]);\n             });\n \n             // Check legality of move bindings.\n@@ -303,7 +303,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n         for pat in pats.iter() {\n             let v = vec![&**pat];\n \n-            match is_useful(cx, &seen, v.index(&FullRange), LeaveOutWitness) {\n+            match is_useful(cx, &seen, &v[], LeaveOutWitness) {\n                 NotUseful => {\n                     match source {\n                         ast::MatchSource::IfLetDesugar { .. } => {\n@@ -355,7 +355,7 @@ fn raw_pat<'a>(p: &'a Pat) -> &'a Pat {\n fn check_exhaustive(cx: &MatchCheckCtxt, sp: Span, matrix: &Matrix) {\n     match is_useful(cx, matrix, &[DUMMY_WILD_PAT], ConstructWitness) {\n         UsefulWithWitness(pats) => {\n-            let witness = match pats.index(&FullRange) {\n+            let witness = match &pats[] {\n                 [ref witness] => &**witness,\n                 [] => DUMMY_WILD_PAT,\n                 _ => unreachable!()\n@@ -609,7 +609,7 @@ fn is_useful(cx: &MatchCheckCtxt,\n                         UsefulWithWitness(pats) => UsefulWithWitness({\n                             let arity = constructor_arity(cx, &c, left_ty);\n                             let mut result = {\n-                                let pat_slice = pats.index(&FullRange);\n+                                let pat_slice = &pats[];\n                                 let subpats: Vec<_> = range(0, arity).map(|i| {\n                                     pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n                                 }).collect();\n@@ -656,10 +656,10 @@ fn is_useful_specialized(cx: &MatchCheckCtxt, &Matrix(ref m): &Matrix,\n                          witness: WitnessPreference) -> Usefulness {\n     let arity = constructor_arity(cx, &ctor, lty);\n     let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, r.index(&FullRange), &ctor, 0u, arity)\n+        specialize(cx, &r[], &ctor, 0u, arity)\n     }).collect());\n     match specialize(cx, v, &ctor, 0u, arity) {\n-        Some(v) => is_useful(cx, &matrix, v.index(&FullRange), witness),\n+        Some(v) => is_useful(cx, &matrix, &v[], witness),\n         None => NotUseful\n     }\n }\n@@ -729,7 +729,7 @@ fn pat_constructors(cx: &MatchCheckCtxt, p: &Pat,\n /// This computes the arity of a constructor. The arity of a constructor\n /// is how many subpattern patterns of that constructor should be expanded to.\n ///\n-/// For instance, a tuple pattern (_, 42u, Some(.index(&FullRange))) has the arity of 3.\n+/// For instance, a tuple pattern (_, 42u, Some([])) has the arity of 3.\n /// A struct pattern's arity is the number of fields it contains, etc.\n pub fn constructor_arity(cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> uint {\n     match ty.sty {\n@@ -926,8 +926,8 @@ pub fn specialize<'a>(cx: &MatchCheckCtxt, r: &[&'a Pat],\n         }\n     };\n     head.map(|mut head| {\n-        head.push_all(r.index(&(0..col)));\n-        head.push_all(r.index(&((col + 1)..)));\n+        head.push_all(&r[0..col]);\n+        head.push_all(&r[(col + 1)..]);\n         head\n     })\n }\n@@ -1041,10 +1041,10 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                     _ => {\n                         cx.tcx.sess.span_bug(\n                             p.span,\n-                            format!(\"binding pattern {} is not an \\\n+                            &format!(\"binding pattern {} is not an \\\n                                      identifier: {:?}\",\n                                     p.id,\n-                                    p.node).index(&FullRange));\n+                                    p.node)[]);\n                     }\n                 }\n             }"}, {"sha": "154272d2deb41caefec580c198a041ed889d8cbe", "filename": "src/librustc/middle/check_static.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -111,8 +111,8 @@ impl<'a, 'tcx> CheckStaticVisitor<'a, 'tcx> {\n             return\n         };\n \n-        self.tcx.sess.span_err(e.span, format!(\"mutable statics are not allowed \\\n-                                                to have {}\", suffix).index(&FullRange));\n+        self.tcx.sess.span_err(e.span, &format!(\"mutable statics are not allowed \\\n+                                                to have {}\", suffix)[]);\n     }\n \n     fn check_static_type(&self, e: &ast::Expr) {\n@@ -169,8 +169,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) if ty::has_dtor(self.tcx, did) => {\n                 self.tcx.sess.span_err(e.span,\n-                                       format!(\"{} are not allowed to have \\\n-                                                destructors\", self.msg()).index(&FullRange))\n+                                       &format!(\"{} are not allowed to have \\\n+                                                destructors\", self.msg())[])\n             }\n             _ => {}\n         }\n@@ -234,7 +234,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckStaticVisitor<'a, 'tcx> {\n                         let msg = \"constants cannot refer to other statics, \\\n                                    insert an intermediate constant \\\n                                    instead\";\n-                        self.tcx.sess.span_err(e.span, msg.index(&FullRange));\n+                        self.tcx.sess.span_err(e.span, &msg[]);\n                     }\n                     _ => {}\n                 }"}, {"sha": "e2a0738def180dd2c47a28e5968c7d14a21bb511", "filename": "src/librustc/middle/check_static_recursion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_static_recursion.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -104,8 +104,8 @@ impl<'a, 'ast, 'v> Visitor<'v> for CheckItemRecursionVisitor<'a, 'ast> {\n                           ast_map::NodeForeignItem(_) => {},\n                           _ => {\n                             self.sess.span_err(e.span,\n-                              format!(\"expected item, found {}\",\n-                                      self.ast_map.node_to_string(def_id.node)).index(&FullRange));\n+                              &format!(\"expected item, found {}\",\n+                                      self.ast_map.node_to_string(def_id.node))[]);\n                             return;\n                           },\n                         }"}, {"sha": "04d4b41b21aa4a273407b8390854ed8009cf71c0", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -48,7 +48,7 @@ use std::rc::Rc;\n //     target uses\". This _includes_ integer-constants, plus the following\n //     constructors:\n //\n-//        fixed-size vectors and strings: .index(&FullRange) and \"\"/_\n+//        fixed-size vectors and strings: [] and \"\"/_\n //        vector and string slices: &[] and &\"\"\n //        tuples: (,)\n //        enums: foo(...)\n@@ -117,7 +117,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n             None => None,\n             Some(ast_map::NodeItem(it)) => match it.node {\n                 ast::ItemEnum(ast::EnumDef { ref variants }, _) => {\n-                    variant_expr(variants.index(&FullRange), variant_def.node)\n+                    variant_expr(&variants[], variant_def.node)\n                 }\n                 _ => None\n             },\n@@ -138,7 +138,7 @@ fn lookup_variant_by_id<'a>(tcx: &'a ty::ctxt,\n                     // NOTE this doesn't do the right thing, it compares inlined\n                     // NodeId's to the original variant_def's NodeId, but they\n                     // come from different crates, so they will likely never match.\n-                    variant_expr(variants.index(&FullRange), variant_def.node).map(|e| e.id)\n+                    variant_expr(&variants[], variant_def.node).map(|e| e.id)\n                 }\n                 _ => None\n             },\n@@ -364,7 +364,7 @@ pub fn const_expr_to_pat(tcx: &ty::ctxt, expr: &Expr) -> P<ast::Pat> {\n pub fn eval_const_expr(tcx: &ty::ctxt, e: &Expr) -> const_val {\n     match eval_const_expr_partial(tcx, e) {\n         Ok(r) => r,\n-        Err(s) => tcx.sess.span_fatal(e.span, s.index(&FullRange))\n+        Err(s) => tcx.sess.span_fatal(e.span, &s[])\n     }\n }\n "}, {"sha": "4ae0aa434065fcc34fc338b01e52515b56994f2c", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -312,7 +312,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let mut t = on_entry.to_vec();\n                 self.apply_gen_kill(cfgidx, t.as_mut_slice());\n                 temp_bits = t;\n-                temp_bits.index(&FullRange)\n+                &temp_bits[]\n             }\n         };\n         debug!(\"{} each_bit_for_node({:?}, cfgidx={:?}) bits={}\",\n@@ -421,7 +421,7 @@ impl<'a, 'tcx, O:DataFlowOperator> DataFlowContext<'a, 'tcx, O> {\n                 let bits = self.kills.slice_mut(start, end);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [before]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n-                bits.clone_from_slice(orig_kills.index(&FullRange));\n+                bits.clone_from_slice(&orig_kills[]);\n                 debug!(\"{} add_kills_from_flow_exits flow_exit={:?} bits={} [after]\",\n                        self.analysis_name, flow_exit, mut_bits_to_string(bits));\n             }\n@@ -554,7 +554,7 @@ fn bits_to_string(words: &[uint]) -> String {\n         let mut v = word;\n         for _ in range(0u, uint::BYTES) {\n             result.push(sep);\n-            result.push_str(format!(\"{:02x}\", v & 0xFF).index(&FullRange));\n+            result.push_str(&format!(\"{:02x}\", v & 0xFF)[]);\n             v >>= 8;\n             sep = '-';\n         }"}, {"sha": "cca0b7d9ad02337e1c0cf049ffca1c0177d39334", "filename": "src/librustc/middle/dependency_format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdependency_format.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -117,8 +117,8 @@ fn calculate_type(sess: &session::Session,\n             sess.cstore.iter_crate_data(|cnum, data| {\n                 let src = sess.cstore.get_used_crate_source(cnum).unwrap();\n                 if src.rlib.is_some() { return }\n-                sess.err(format!(\"dependency `{}` not found in rlib format\",\n-                                 data.name).index(&FullRange));\n+                sess.err(&format!(\"dependency `{}` not found in rlib format\",\n+                                 data.name)[]);\n             });\n             return Vec::new();\n         }\n@@ -191,13 +191,13 @@ fn calculate_type(sess: &session::Session,\n             Some(cstore::RequireDynamic) if src.dylib.is_some() => continue,\n             Some(kind) => {\n                 let data = sess.cstore.get_crate_data(cnum + 1);\n-                sess.err(format!(\"crate `{}` required to be available in {}, \\\n+                sess.err(&format!(\"crate `{}` required to be available in {}, \\\n                                   but it was not available in this form\",\n                                  data.name,\n                                  match kind {\n                                      cstore::RequireStatic => \"rlib\",\n                                      cstore::RequireDynamic => \"dylib\",\n-                                 }).index(&FullRange));\n+                                 })[]);\n             }\n         }\n     }\n@@ -220,9 +220,9 @@ fn add_library(sess: &session::Session,\n             // can be refined over time.\n             if link2 != link || link == cstore::RequireStatic {\n                 let data = sess.cstore.get_crate_data(cnum);\n-                sess.err(format!(\"cannot satisfy dependencies so `{}` only \\\n+                sess.err(&format!(\"cannot satisfy dependencies so `{}` only \\\n                                   shows up once\",\n-                                 data.name).index(&FullRange));\n+                                 data.name)[]);\n                 sess.help(\"having upstream crates all available in one format \\\n                            will likely make this go away\");\n             }"}, {"sha": "e5eb439d42c75a3fa6f20bb8b22e8bab50cc7059", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -857,8 +857,8 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     let (m, r) = match self_ty.sty {\n                         ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                         _ => self.tcx().sess.span_bug(expr.span,\n-                                format!(\"bad overloaded deref type {}\",\n-                                    method_ty.repr(self.tcx())).index(&FullRange))\n+                                &format!(\"bad overloaded deref type {}\",\n+                                    method_ty.repr(self.tcx()))[])\n                     };\n                     let bk = ty::BorrowKind::from_mutbl(m);\n                     self.delegate.borrow(expr.id, expr.span, cmt,\n@@ -1180,7 +1180,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                                 let msg = format!(\"Pattern has unexpected def: {:?} and type {}\",\n                                                   def,\n                                                   cmt_pat.ty.repr(tcx));\n-                                tcx.sess.span_bug(pat.span, msg.index(&FullRange))\n+                                tcx.sess.span_bug(pat.span, &msg[])\n                             }\n                         }\n                     }"}, {"sha": "4a4328fa98bafbc059da8edf2e5223be23fdb986", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -142,7 +142,7 @@ pub trait Combine<'tcx> : Sized {\n                             for _ in a_regions.iter() {\n                                 invariance.push(ty::Invariant);\n                             }\n-                            invariance.index(&FullRange)\n+                            &invariance[]\n                         }\n                     };\n \n@@ -427,6 +427,16 @@ impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> Combineable<'tcx> for Ty<'tcx> {\n+    fn combine<C:Combine<'tcx>>(combiner: &C,\n+                                a: &Ty<'tcx>,\n+                                b: &Ty<'tcx>)\n+                                -> cres<'tcx, Ty<'tcx>>\n+    {\n+        combiner.tys(*a, *b)\n+    }\n+}\n+\n impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n     fn combine<C:Combine<'tcx>>(combiner: &C,\n                                 a: &ty::ProjectionPredicate<'tcx>,\n@@ -477,10 +487,10 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n       (&ty::ty_infer(TyVar(_)), _) |\n       (_, &ty::ty_infer(TyVar(_))) => {\n         tcx.sess.bug(\n-            format!(\"{}: bot and var types should have been handled ({},{})\",\n+            &format!(\"{}: bot and var types should have been handled ({},{})\",\n                     this.tag(),\n                     a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx)).index(&FullRange));\n+                    b.repr(this.infcx().tcx))[]);\n       }\n \n       (&ty::ty_err, _) | (_, &ty::ty_err) => {\n@@ -855,8 +865,8 @@ impl<'cx, 'tcx> ty_fold::TypeFolder<'tcx> for Generalizer<'cx, 'tcx> {\n             ty::ReEarlyBound(..) => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    format!(\"Encountered early bound region when generalizing: {}\",\n-                            r.repr(self.tcx())).index(&FullRange));\n+                    &format!(\"Encountered early bound region when generalizing: {}\",\n+                            r.repr(self.tcx()))[]);\n             }\n \n             // Always make a fresh region variable for skolemized regions;"}, {"sha": "bbd12c9671d2855c7a58dd79d01264acb1546bbf", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -200,9 +200,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                 ref trace_origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(var_origins.index(&FullRange),\n-                                                     trace_origins.index(&FullRange),\n-                                                     same_regions.index(&FullRange));\n+                        self.report_processed_errors(&var_origins[],\n+                                                     &trace_origins[],\n+                                                     &same_regions[]);\n                     }\n                 }\n             }\n@@ -373,10 +373,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n         self.tcx.sess.span_err(\n             trace.origin.span(),\n-            format!(\"{}: {} ({})\",\n+            &format!(\"{}: {} ({})\",\n                  message_root_str,\n                  expected_found_str,\n-                 ty::type_err_to_str(self.tcx, terr)).index(&FullRange));\n+                 ty::type_err_to_str(self.tcx, terr))[]);\n \n         match trace.origin {\n             infer::MatchExpressionArm(_, arm_span) =>\n@@ -445,42 +445,42 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\"{} may not live long enough\", labeled_user_string).index(&FullRange));\n+                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n-                    format!(\n+                    &format!(\n                         \"consider adding an explicit lifetime bound `{}: {}`...\",\n                         bound_kind.user_string(self.tcx),\n-                        sub.user_string(self.tcx)).index(&FullRange));\n+                        sub.user_string(self.tcx))[]);\n             }\n \n             ty::ReStatic => {\n                 // Does the required lifetime have a nice name we can print?\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\"{} may not live long enough\", labeled_user_string).index(&FullRange));\n+                    &format!(\"{} may not live long enough\", labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n-                    format!(\n+                    &format!(\n                         \"consider adding an explicit lifetime bound `{}: 'static`...\",\n-                        bound_kind.user_string(self.tcx)).index(&FullRange));\n+                        bound_kind.user_string(self.tcx))[]);\n             }\n \n             _ => {\n                 // If not, be less specific.\n                 self.tcx.sess.span_err(\n                     origin.span(),\n-                    format!(\n+                    &format!(\n                         \"{} may not live long enough\",\n-                        labeled_user_string).index(&FullRange));\n+                        labeled_user_string)[]);\n                 self.tcx.sess.span_help(\n                     origin.span(),\n-                    format!(\n+                    &format!(\n                         \"consider adding an explicit lifetime bound for `{}`\",\n-                        bound_kind.user_string(self.tcx)).index(&FullRange));\n+                        bound_kind.user_string(self.tcx))[]);\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"{} must be valid for \", labeled_user_string).index(&FullRange),\n+                    &format!(\"{} must be valid for \", labeled_user_string)[],\n                     sub,\n                     \"...\");\n             }\n@@ -517,24 +517,24 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"lifetime of borrowed pointer outlives \\\n+                    &format!(\"lifetime of borrowed pointer outlives \\\n                             lifetime of captured variable `{}`...\",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string()).index(&FullRange));\n+                                .to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"...the borrowed pointer is valid for \",\n                     sub,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but `{}` is only valid for \",\n+                    &format!(\"...but `{}` is only valid for \",\n                             ty::local_var_name_str(self.tcx,\n                                                    upvar_id.var_id)\n                                 .get()\n-                                .to_string()).index(&FullRange),\n+                                .to_string())[],\n                     sup,\n                     \"\");\n             }\n@@ -576,11 +576,11 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::FreeVariable(span, id) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"captured variable `{}` does not \\\n+                    &format!(\"captured variable `{}` does not \\\n                             outlive the enclosing closure\",\n                             ty::local_var_name_str(self.tcx,\n                                                    id).get()\n-                                                      .to_string()).index(&FullRange));\n+                                                      .to_string())[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"captured variable is valid for \",\n@@ -620,9 +620,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::RelateParamBound(span, ty) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"the type `{}` does not fulfill the \\\n+                    &format!(\"the type `{}` does not fulfill the \\\n                              required lifetime\",\n-                            self.ty_to_string(ty)).index(&FullRange));\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -646,9 +646,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::RelateDefaultParamBound(span, ty) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"the type `{}` (provided as the value of \\\n+                    &format!(\"the type `{}` (provided as the value of \\\n                              a type parameter) is not valid at this point\",\n-                            self.ty_to_string(ty)).index(&FullRange));\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(self.tcx,\n                                         \"type must outlive \",\n                                         sub,\n@@ -712,9 +712,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ExprTypeIsNotInScope(t, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"type of expression contains references \\\n+                    &format!(\"type of expression contains references \\\n                              that are not valid during the expression: `{}`\",\n-                            self.ty_to_string(t)).index(&FullRange));\n+                            self.ty_to_string(t))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"type is only valid for \",\n@@ -734,9 +734,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"in type `{}`, reference has a longer lifetime \\\n+                    &format!(\"in type `{}`, reference has a longer lifetime \\\n                              than the data it references\",\n-                            self.ty_to_string(ty)).index(&FullRange));\n+                            self.ty_to_string(ty))[]);\n                 note_and_explain_region(\n                     self.tcx,\n                     \"the pointer is valid for \",\n@@ -861,7 +861,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n         let (fn_decl, generics, unsafety, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n         let taken = lifetimes_in_scope(self.tcx, scope_id);\n-        let life_giver = LifeGiver::with_taken(taken.index(&FullRange));\n+        let life_giver = LifeGiver::with_taken(&taken[]);\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n@@ -937,7 +937,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n             }\n             expl_self_opt = self.rebuild_expl_self(expl_self_opt, lifetime,\n                                                    &anon_nums, &region_names);\n-            inputs = self.rebuild_args_ty(inputs.index(&FullRange), lifetime,\n+            inputs = self.rebuild_args_ty(&inputs[], lifetime,\n                                           &anon_nums, &region_names);\n             output = self.rebuild_output(&output, lifetime, &anon_nums, &region_names);\n             ty_params = self.rebuild_ty_params(ty_params, lifetime,\n@@ -972,7 +972,7 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                 names.push(lt_name);\n             }\n             names.sort();\n-            let name = token::str_to_ident(names[0].index(&FullRange)).name;\n+            let name = token::str_to_ident(&names[0][]).name;\n             return (name_to_dummy_lifetime(name), Kept);\n         }\n         return (self.life_giver.give_lifetime(), Fresh);\n@@ -1220,9 +1220,9 @@ impl<'a, 'tcx> Rebuilder<'a, 'tcx> {\n                         None => {\n                             self.tcx\n                                 .sess\n-                                .fatal(format!(\n+                                .fatal(&format!(\n                                         \"unbound path {}\",\n-                                        pprust::path_to_string(path)).index(&FullRange))\n+                                        pprust::path_to_string(path))[])\n                         }\n                         Some(&d) => d\n                     };\n@@ -1420,7 +1420,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                                               opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n-        self.tcx.sess.span_help(span, msg.index(&FullRange));\n+        self.tcx.sess.span_help(span, &msg[]);\n     }\n \n     fn report_inference_failure(&self,\n@@ -1461,9 +1461,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n \n         self.tcx.sess.span_err(\n             var_origin.span(),\n-            format!(\"cannot infer an appropriate lifetime{} \\\n+            &format!(\"cannot infer an appropriate lifetime{} \\\n                     due to conflicting requirements\",\n-                    var_description).index(&FullRange));\n+                    var_description)[]);\n     }\n \n     fn note_region_origin(&self, origin: &SubregionOrigin<'tcx>) {\n@@ -1510,8 +1510,8 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                     Some(values_str) => {\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {} ({})\",\n-                                    desc, values_str).index(&FullRange));\n+                            &format!(\"...so that {} ({})\",\n+                                    desc, values_str)[]);\n                     }\n                     None => {\n                         // Really should avoid printing this error at\n@@ -1520,7 +1520,7 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n                         // doing right now. - nmatsakis\n                         self.tcx.sess.span_note(\n                             trace.origin.span(),\n-                            format!(\"...so that {}\", desc).index(&FullRange));\n+                            &format!(\"...so that {}\", desc)[]);\n                     }\n                 }\n             }\n@@ -1533,11 +1533,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\n+                    &format!(\n                         \"...so that closure can access `{}`\",\n                         ty::local_var_name_str(self.tcx, upvar_id.var_id)\n                             .get()\n-                            .to_string()).index(&FullRange))\n+                            .to_string())[])\n             }\n             infer::InfStackClosure(span) => {\n                 self.tcx.sess.span_note(\n@@ -1558,11 +1558,11 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::FreeVariable(span, id) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that captured variable `{}` \\\n+                    &format!(\"...so that captured variable `{}` \\\n                             does not outlive the enclosing closure\",\n                             ty::local_var_name_str(\n                                 self.tcx,\n-                                id).get().to_string()).index(&FullRange));\n+                                id).get().to_string())[]);\n             }\n             infer::IndexSlice(span) => {\n                 self.tcx.sess.span_note(\n@@ -1604,9 +1604,9 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ExprTypeIsNotInScope(t, span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so type `{}` of expression is valid during the \\\n+                    &format!(\"...so type `{}` of expression is valid during the \\\n                              expression\",\n-                            self.ty_to_string(t)).index(&FullRange));\n+                            self.ty_to_string(t))[]);\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 self.tcx.sess.span_note(\n@@ -1616,30 +1616,30 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that the reference type `{}` \\\n+                    &format!(\"...so that the reference type `{}` \\\n                              does not outlive the data it points at\",\n-                            self.ty_to_string(ty)).index(&FullRange));\n+                            self.ty_to_string(ty))[]);\n             }\n             infer::RelateParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that the type `{}` \\\n+                    &format!(\"...so that the type `{}` \\\n                              will meet the declared lifetime bounds\",\n-                            self.ty_to_string(t)).index(&FullRange));\n+                            self.ty_to_string(t))[]);\n             }\n             infer::RelateDefaultParamBound(span, t) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that type parameter \\\n+                    &format!(\"...so that type parameter \\\n                              instantiated with `{}`, \\\n                              will meet its declared lifetime bounds\",\n-                            self.ty_to_string(t)).index(&FullRange));\n+                            self.ty_to_string(t))[]);\n             }\n             infer::RelateRegionParamBound(span) => {\n                 self.tcx.sess.span_note(\n                     span,\n-                    format!(\"...so that the declared lifetime parameter bounds \\\n-                                are satisfied\").index(&FullRange));\n+                    &format!(\"...so that the declared lifetime parameter bounds \\\n+                                are satisfied\")[]);\n             }\n         }\n     }\n@@ -1691,15 +1691,15 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n                 ast::ItemFn(_, _, _, ref gen, _) => {\n-                    taken.push_all(gen.lifetimes.index(&FullRange));\n+                    taken.push_all(&gen.lifetimes[]);\n                     None\n                 },\n                 _ => None\n             },\n             ast_map::NodeImplItem(ii) => {\n                 match *ii {\n                     ast::MethodImplItem(ref m) => {\n-                        taken.push_all(m.pe_generics().lifetimes.index(&FullRange));\n+                        taken.push_all(&m.pe_generics().lifetimes[]);\n                         Some(m.id)\n                     }\n                     ast::TypeImplItem(_) => None,\n@@ -1758,10 +1758,10 @@ impl LifeGiver {\n         let mut lifetime;\n         loop {\n             let mut s = String::from_str(\"'\");\n-            s.push_str(num_to_string(self.counter.get()).index(&FullRange));\n+            s.push_str(&num_to_string(self.counter.get())[]);\n             if !self.taken.contains(&s) {\n                 lifetime = name_to_dummy_lifetime(\n-                                    token::str_to_ident(s.index(&FullRange)).name);\n+                                    token::str_to_ident(&s[]).name);\n                 self.generated.borrow_mut().push(lifetime);\n                 break;\n             }"}, {"sha": "6bc424fdf9528f3d6a78629a4d249dfff655ea1f", "filename": "src/librustc/middle/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ffreshen.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -135,10 +135,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n                 t\n             }\n \n-            ty::ty_open(..) => {\n-                self.tcx().sess.bug(\"Cannot freshen an open existential type\");\n-            }\n-\n+            ty::ty_open(..) |\n             ty::ty_bool |\n             ty::ty_char |\n             ty::ty_int(..) |"}, {"sha": "0df84323ae53f4d64aa07df1acce62989a1aa1df", "filename": "src/librustc/middle/infer/higher_ranked/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -187,9 +187,9 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n \n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"region {:?} is not associated with \\\n+                &format!(\"region {:?} is not associated with \\\n                          any bound region from A!\",\n-                        r0).index(&FullRange))\n+                        r0)[])\n         }\n     }\n \n@@ -322,7 +322,7 @@ impl<'tcx,C> HigherRankedRelations<'tcx> for C\n             }\n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"could not find original bound region for {:?}\", r).index(&FullRange));\n+                &format!(\"could not find original bound region for {:?}\", r)[]);\n         }\n \n         fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n@@ -339,7 +339,7 @@ fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n             r => {\n                 combiner.infcx().tcx.sess.span_bug(\n                     combiner.trace().origin.span(),\n-                    format!(\"found non-region-vid: {:?}\", r).index(&FullRange));\n+                    &format!(\"found non-region-vid: {:?}\", r)[]);\n             }\n         }).collect()\n }\n@@ -468,7 +468,7 @@ pub fn skolemize_late_bound_regions<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n      * when higher-ranked things are involved. See `doc.rs` for more details.\n      */\n \n-    let (result, map) = ty::replace_late_bound_regions(infcx.tcx, binder, |br, _| {\n+    let (result, map) = ty::replace_late_bound_regions(infcx.tcx, binder, |br| {\n         infcx.region_vars.new_skolemized(br, &snapshot.region_vars_snapshot)\n     });\n "}, {"sha": "ab1c41f69683eb074ecb8dd5a9eaa857bdebd84a", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 24, "deletions": 15, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -39,7 +39,7 @@ use util::ppaux::{ty_to_string};\n use util::ppaux::{Repr, UserString};\n \n use self::coercion::Coerce;\n-use self::combine::{Combine, CombineFields};\n+use self::combine::{Combine, Combineable, CombineFields};\n use self::region_inference::{RegionVarBindings, RegionSnapshot};\n use self::equate::Equate;\n use self::sub::Sub;\n@@ -360,17 +360,9 @@ pub fn can_mk_subty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     })\n }\n \n-pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n-                             a: Ty<'tcx>, b: Ty<'tcx>)\n-                             -> ures<'tcx> {\n-    debug!(\"can_mk_subty({} <: {})\", a.repr(cx.tcx), b.repr(cx.tcx));\n-    cx.probe(|_| {\n-        let trace = TypeTrace {\n-            origin: Misc(codemap::DUMMY_SP),\n-            values: Types(expected_found(true, a, b))\n-        };\n-        cx.equate(true, trace).tys(a, b)\n-    }).to_ures()\n+pub fn can_mk_eqty<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>, a: Ty<'tcx>, b: Ty<'tcx>) -> ures<'tcx>\n+{\n+    cx.can_equate(&a, &b)\n }\n \n pub fn mk_subr<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n@@ -1000,9 +992,9 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     format!(\" ({})\", ty::type_err_to_str(self.tcx, t_err))\n                 });\n \n-                self.tcx.sess.span_err(sp, format!(\"{}{}\",\n+                self.tcx.sess.span_err(sp, &format!(\"{}{}\",\n                     mk_msg(resolved_expected.map(|t| self.ty_to_string(t)), actual_ty),\n-                    error_str).index(&FullRange));\n+                    error_str)[]);\n \n                 for err in err.iter() {\n                     ty::note_and_explain_type_err(self.tcx, *err)\n@@ -1056,7 +1048,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         ty::replace_late_bound_regions(\n             self.tcx,\n             value,\n-            |br, _| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n+            |br| self.next_region_var(LateBoundRegion(span, br, lbrct)))\n     }\n \n     /// See `verify_generic_bound` method in `region_inference`\n@@ -1072,6 +1064,23 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         self.region_vars.verify_generic_bound(origin, kind, a, bs);\n     }\n+\n+    pub fn can_equate<T>(&self, a: &T, b: &T) -> ures<'tcx>\n+        where T : Combineable<'tcx> + Repr<'tcx>\n+    {\n+        debug!(\"can_equate({}, {})\", a.repr(self.tcx), b.repr(self.tcx));\n+        self.probe(|_| {\n+            // Gin up a dummy trace, since this won't be committed\n+            // anyhow. We should make this typetrace stuff more\n+            // generic so we don't have to do anything quite this\n+            // terrible.\n+            let e = self.tcx.types.err;\n+            let trace = TypeTrace { origin: Misc(codemap::DUMMY_SP),\n+                                    values: Types(expected_found(true, e, e)) };\n+            let eq = self.equate(true, trace);\n+            Combineable::combine(&eq, a, b)\n+        }).to_ures()\n+    }\n }\n \n impl<'tcx> TypeTrace<'tcx> {"}, {"sha": "d54d0ae87aec0e44cf7b5b8d6139d1d5ef94be6a", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -473,9 +473,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (_, ReLateBound(..)) => {\n             self.tcx.sess.span_bug(\n                 origin.span(),\n-                format!(\"cannot relate bound region: {} <= {}\",\n+                &format!(\"cannot relate bound region: {} <= {}\",\n                         sub.repr(self.tcx),\n-                        sup.repr(self.tcx)).index(&FullRange));\n+                        sup.repr(self.tcx))[]);\n           }\n           (_, ReStatic) => {\n             // all regions are subregions of static, so we can ignore this\n@@ -734,9 +734,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (ReEarlyBound(..), _) |\n           (_, ReEarlyBound(..)) => {\n             self.tcx.sess.bug(\n-                format!(\"cannot relate bound region: LUB({}, {})\",\n+                &format!(\"cannot relate bound region: LUB({}, {})\",\n                         a.repr(self.tcx),\n-                        b.repr(self.tcx)).index(&FullRange));\n+                        b.repr(self.tcx))[]);\n           }\n \n           (ReStatic, _) | (_, ReStatic) => {\n@@ -750,10 +750,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n           (ReInfer(ReVar(v_id)), _) | (_, ReInfer(ReVar(v_id))) => {\n             self.tcx.sess.span_bug(\n                 (*self.var_origins.borrow())[v_id.index as uint].span(),\n-                format!(\"lub_concrete_regions invoked with \\\n+                &format!(\"lub_concrete_regions invoked with \\\n                          non-concrete regions: {:?}, {:?}\",\n                         a,\n-                        b).index(&FullRange));\n+                        b)[]);\n           }\n \n           (ReFree(ref fr), ReScope(s_id)) |\n@@ -834,9 +834,9 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (ReEarlyBound(..), _) |\n             (_, ReEarlyBound(..)) => {\n               self.tcx.sess.bug(\n-                  format!(\"cannot relate bound region: GLB({}, {})\",\n+                  &format!(\"cannot relate bound region: GLB({}, {})\",\n                           a.repr(self.tcx),\n-                          b.repr(self.tcx)).index(&FullRange));\n+                          b.repr(self.tcx))[]);\n             }\n \n             (ReStatic, r) | (r, ReStatic) => {\n@@ -853,10 +853,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n             (_, ReInfer(ReVar(v_id))) => {\n                 self.tcx.sess.span_bug(\n                     (*self.var_origins.borrow())[v_id.index as uint].span(),\n-                    format!(\"glb_concrete_regions invoked with \\\n+                    &format!(\"glb_concrete_regions invoked with \\\n                              non-concrete regions: {:?}, {:?}\",\n                             a,\n-                            b).index(&FullRange));\n+                            b)[]);\n             }\n \n             (ReFree(ref fr), ReScope(s_id)) |\n@@ -977,7 +977,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n         self.expansion(var_data.as_mut_slice());\n         self.contraction(var_data.as_mut_slice());\n         let values =\n-            self.extract_values_and_collect_conflicts(var_data.index(&FullRange),\n+            self.extract_values_and_collect_conflicts(&var_data[],\n                                                       errors);\n         self.collect_concrete_region_errors(&values, errors);\n         values\n@@ -1411,11 +1411,11 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as uint].span(),\n-            format!(\"collect_error_for_expanding_node() could not find error \\\n+            &format!(\"collect_error_for_expanding_node() could not find error \\\n                     for var {:?}, lower_bounds={}, upper_bounds={}\",\n                     node_idx,\n                     lower_bounds.repr(self.tcx),\n-                    upper_bounds.repr(self.tcx)).index(&FullRange));\n+                    upper_bounds.repr(self.tcx))[]);\n     }\n \n     fn collect_error_for_contracting_node(\n@@ -1456,10 +1456,10 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n \n         self.tcx.sess.span_bug(\n             (*self.var_origins.borrow())[node_idx.index as uint].span(),\n-            format!(\"collect_error_for_contracting_node() could not find error \\\n+            &format!(\"collect_error_for_contracting_node() could not find error \\\n                      for var {:?}, upper_bounds={}\",\n                     node_idx,\n-                    upper_bounds.repr(self.tcx)).index(&FullRange));\n+                    upper_bounds.repr(self.tcx))[]);\n     }\n \n     fn collect_concrete_regions(&self,"}, {"sha": "7bb3106b0ba6ccfa3bfce9fccf199aff5c46e1a6", "filename": "src/librustc/middle/infer/resolve.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fresolve.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -95,8 +95,8 @@ impl<'a, 'tcx> ty_fold::TypeFolder<'tcx> for FullTypeResolver<'a, 'tcx> {\n                 }\n                 ty::ty_infer(_) => {\n                     self.infcx.tcx.sess.bug(\n-                        format!(\"Unexpected type in full type resolver: {}\",\n-                                t.repr(self.infcx.tcx)).index(&FullRange));\n+                        &format!(\"Unexpected type in full type resolver: {}\",\n+                                t.repr(self.infcx.tcx))[]);\n                 }\n                 _ => {\n                     ty_fold::super_fold_ty(self, t)"}, {"sha": "1b1dca004228eafb3d9e6074f254ae19b7128b15", "filename": "src/librustc/middle/liveness.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fliveness.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -326,8 +326,8 @@ impl<'a, 'tcx> IrMaps<'a, 'tcx> {\n           None => {\n             self.tcx\n                 .sess\n-                .span_bug(span, format!(\"no variable registered for id {}\",\n-                                        node_id).index(&FullRange));\n+                .span_bug(span, &format!(\"no variable registered for id {}\",\n+                                        node_id)[]);\n           }\n         }\n     }\n@@ -597,8 +597,8 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             // creating liveness nodes for.\n             self.ir.tcx.sess.span_bug(\n                 span,\n-                format!(\"no live node registered for node {}\",\n-                        node_id).index(&FullRange));\n+                &format!(\"no live node registered for node {}\",\n+                        node_id)[]);\n           }\n         }\n     }\n@@ -1133,7 +1133,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n           // Uninteresting cases: just propagate in rev exec order\n \n           ast::ExprVec(ref exprs) => {\n-            self.propagate_through_exprs(exprs.index(&FullRange), succ)\n+            self.propagate_through_exprs(&exprs[], succ)\n           }\n \n           ast::ExprRepeat(ref element, ref count) => {\n@@ -1157,7 +1157,7 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            let succ = self.propagate_through_exprs(args.index(&FullRange), succ);\n+            let succ = self.propagate_through_exprs(&args[], succ);\n             self.propagate_through_expr(&**f, succ)\n           }\n \n@@ -1170,11 +1170,11 @@ impl<'a, 'tcx> Liveness<'a, 'tcx> {\n             } else {\n                 succ\n             };\n-            self.propagate_through_exprs(args.index(&FullRange), succ)\n+            self.propagate_through_exprs(&args[], succ)\n           }\n \n           ast::ExprTup(ref exprs) => {\n-            self.propagate_through_exprs(exprs.index(&FullRange), succ)\n+            self.propagate_through_exprs(&exprs[], succ)\n           }\n \n           ast::ExprBinary(op, ref l, ref r) if ast_util::lazy_binop(op) => {"}, {"sha": "fb9a16f86e5bcb730a4805155de58a871d969d4d", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -584,9 +584,9 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                   _ => {\n                       self.tcx().sess.span_bug(\n                           span,\n-                          format!(\"Upvar of non-closure {} - {}\",\n+                          &format!(\"Upvar of non-closure {} - {}\",\n                                   fn_node_id,\n-                                  ty.repr(self.tcx())).index(&FullRange));\n+                                  ty.repr(self.tcx()))[]);\n                   }\n               }\n           }"}, {"sha": "aa37c2fe348b586c178e121114ac47d79b41d027", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -615,10 +615,10 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match result {\n             None => true,\n             Some((span, msg, note)) => {\n-                self.tcx.sess.span_err(span, msg.index(&FullRange));\n+                self.tcx.sess.span_err(span, &msg[]);\n                 match note {\n                     Some((span, msg)) => {\n-                        self.tcx.sess.span_note(span, msg.index(&FullRange))\n+                        self.tcx.sess.span_note(span, &msg[])\n                     }\n                     None => {},\n                 }\n@@ -720,7 +720,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n             UnnamedField(idx) => format!(\"field #{} of {} is private\",\n                                          idx + 1, struct_desc),\n         };\n-        self.tcx.sess.span_err(span, msg.index(&FullRange));\n+        self.tcx.sess.span_err(span, &msg[]);\n     }\n \n     // Given the ID of a method, checks to ensure it's in scope.\n@@ -741,8 +741,8 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         self.report_error(self.ensure_public(span,\n                                              method_id,\n                                              None,\n-                                             format!(\"method `{}`\",\n-                                                     string).index(&FullRange)));\n+                                             &format!(\"method `{}`\",\n+                                                     string)[]));\n     }\n \n     // Checks that a path is in scope.\n@@ -756,7 +756,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n                 self.ensure_public(span,\n                                    def,\n                                    Some(origdid),\n-                                   format!(\"{} `{}`\", tyname, name).index(&FullRange))\n+                                   &format!(\"{} `{}`\", tyname, name)[])\n             };\n \n             match self.last_private_map[path_id] {"}, {"sha": "906607ddc5ba14e77e205064b5f67a2425fb914c", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -50,7 +50,7 @@ fn generics_require_inlining(generics: &ast::Generics) -> bool {\n // monomorphized or it was marked with `#[inline]`. This will only return\n // true for functions.\n fn item_might_be_inlined(item: &ast::Item) -> bool {\n-    if attributes_specify_inlining(item.attrs.index(&FullRange)) {\n+    if attributes_specify_inlining(&item.attrs[]) {\n         return true\n     }\n \n@@ -65,7 +65,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n fn method_might_be_inlined(tcx: &ty::ctxt, method: &ast::Method,\n                            impl_src: ast::DefId) -> bool {\n-    if attributes_specify_inlining(method.attrs.index(&FullRange)) ||\n+    if attributes_specify_inlining(&method.attrs[]) ||\n         generics_require_inlining(method.pe_generics()) {\n         return true\n     }\n@@ -202,7 +202,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                     ast::MethodImplItem(ref method) => {\n                         if generics_require_inlining(method.pe_generics()) ||\n                                 attributes_specify_inlining(\n-                                    method.attrs.index(&FullRange)) {\n+                                    &method.attrs[]) {\n                             true\n                         } else {\n                             let impl_did = self.tcx\n@@ -247,9 +247,9 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n                 Some(ref item) => self.propagate_node(item, search_item),\n                 None if search_item == ast::CRATE_NODE_ID => {}\n                 None => {\n-                    self.tcx.sess.bug(format!(\"found unmapped ID in worklist: \\\n+                    self.tcx.sess.bug(&format!(\"found unmapped ID in worklist: \\\n                                                {}\",\n-                                              search_item).index(&FullRange))\n+                                              search_item)[])\n                 }\n             }\n         }\n@@ -338,10 +338,10 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             _ => {\n                 self.tcx\n                     .sess\n-                    .bug(format!(\"found unexpected thingy in worklist: {}\",\n+                    .bug(&format!(\"found unexpected thingy in worklist: {}\",\n                                  self.tcx\n                                      .map\n-                                     .node_to_string(search_item)).index(&FullRange))\n+                                     .node_to_string(search_item))[])\n             }\n         }\n     }"}, {"sha": "5d33a7efd3bee4c60eab14348c520feeee5e5cbc", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -643,7 +643,7 @@ fn resolve_local(visitor: &mut RegionResolutionVisitor, local: &ast::Local) {\n     // A, but the inner rvalues `a()` and `b()` have an extended lifetime\n     // due to rule C.\n     //\n-    // FIXME(#6308) -- Note that `.index(&FullRange)` patterns work more smoothly post-DST.\n+    // FIXME(#6308) -- Note that `[]` patterns work more smoothly post-DST.\n \n     match local.init {\n         Some(ref expr) => {"}, {"sha": "b670099ff962a37f9470fcd5326cfe6b081b5855", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -398,8 +398,8 @@ impl<'a> LifetimeContext<'a> {\n     fn unresolved_lifetime_ref(&self, lifetime_ref: &ast::Lifetime) {\n         self.sess.span_err(\n             lifetime_ref.span,\n-            format!(\"use of undeclared lifetime name `{}`\",\n-                    token::get_name(lifetime_ref.name)).index(&FullRange));\n+            &format!(\"use of undeclared lifetime name `{}`\",\n+                    token::get_name(lifetime_ref.name))[]);\n     }\n \n     fn check_lifetime_defs(&mut self, old_scope: Scope, lifetimes: &Vec<ast::LifetimeDef>) {\n@@ -411,9 +411,9 @@ impl<'a> LifetimeContext<'a> {\n                 if special_idents.iter().any(|&i| i.name == lifetime.lifetime.name) {\n                     self.sess.span_err(\n                         lifetime.lifetime.span,\n-                        format!(\"illegal lifetime parameter name: `{}`\",\n+                        &format!(\"illegal lifetime parameter name: `{}`\",\n                                 token::get_name(lifetime.lifetime.name))\n-                            .index(&FullRange));\n+                        []);\n                 }\n             }\n \n@@ -424,10 +424,10 @@ impl<'a> LifetimeContext<'a> {\n                 if lifetime_i.lifetime.name == lifetime_j.lifetime.name {\n                     self.sess.span_err(\n                         lifetime_j.lifetime.span,\n-                        format!(\"lifetime name `{}` declared twice in \\\n+                        &format!(\"lifetime name `{}` declared twice in \\\n                                 the same scope\",\n                                 token::get_name(lifetime_j.lifetime.name))\n-                            .index(&FullRange));\n+                        []);\n                 }\n             }\n "}, {"sha": "e712f510d9dc825c63a5c96e2f2a803c5a81e70a", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -189,3 +189,19 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n         }\n     })\n }\n+\n+pub fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n+    match ty::trait_item_of_item(tcx, id) {\n+        Some(ty::MethodTraitItemId(trait_method_id))\n+            if trait_method_id != id => {\n+                is_staged_api(tcx, trait_method_id)\n+            }\n+        _ if is_local(id) => {\n+            // Unused case\n+            unreachable!()\n+        }\n+        _ => {\n+            csearch::is_staged_api(&tcx.sess.cstore, id)\n+        }\n+    }\n+}"}, {"sha": "5fbae6c359dc147661c70d544267c57b9263189c", "filename": "src/librustc/middle/subst.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fsubst.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -394,7 +394,7 @@ impl<T> VecPerParamSpace<T> {\n         self.content.as_slice()\n     }\n \n-    pub fn to_vec(self) -> Vec<T> {\n+    pub fn into_vec(self) -> Vec<T> {\n         self.content\n     }\n \n@@ -599,12 +599,12 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n                                 let span = self.span.unwrap_or(DUMMY_SP);\n                                 self.tcx().sess.span_bug(\n                                     span,\n-                                    format!(\"Type parameter out of range \\\n+                                    &format!(\"Type parameter out of range \\\n                                      when substituting in region {} (root type={}) \\\n                                      (space={:?}, index={})\",\n                                     region_name.as_str(),\n                                     self.root_ty.repr(self.tcx()),\n-                                    space, i).index(&FullRange));\n+                                    space, i)[]);\n                             }\n                         }\n                 }\n@@ -654,14 +654,14 @@ impl<'a,'tcx> SubstFolder<'a,'tcx> {\n                 let span = self.span.unwrap_or(DUMMY_SP);\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n+                    &format!(\"Type parameter `{}` ({}/{:?}/{}) out of range \\\n                                  when substituting (root type={}) substs={}\",\n                             p.repr(self.tcx()),\n                             source_ty.repr(self.tcx()),\n                             p.space,\n                             p.idx,\n                             self.root_ty.repr(self.tcx()),\n-                            self.substs.repr(self.tcx())).index(&FullRange));\n+                            self.substs.repr(self.tcx()))[]);\n             }\n         };\n "}, {"sha": "489731e755489227b8b260cb451c3ebf0b319752", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -136,8 +136,8 @@ fn ty_is_local_constructor<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::ty_open(..) |\n         ty::ty_err => {\n             tcx.sess.bug(\n-                format!(\"ty_is_local invoked on unexpected type: {}\",\n-                        ty.repr(tcx)).index(&FullRange))\n+                &format!(\"ty_is_local invoked on unexpected type: {}\",\n+                        ty.repr(tcx))[])\n         }\n     }\n }"}, {"sha": "02c913a9e81ae34991cb6405824558085ee6a936", "filename": "src/librustc/middle/traits/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ferror_reporting.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -337,7 +337,7 @@ pub fn suggest_new_overflow_limit(tcx: &ty::ctxt, span: Span) {\n     let suggested_limit = current_limit * 2;\n     tcx.sess.span_note(\n         span,\n-        format!(\n+        &format!(\n             \"consider adding a `#![recursion_limit=\\\"{}\\\"]` attribute to your crate\",\n-            suggested_limit).index(&FullRange));\n+            suggested_limit)[]);\n }"}, {"sha": "c3b9be85eb5058cd8e92658d12ab3249ee1b24a4", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -227,7 +227,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n     }\n \n     pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n-        self.predicates.index(&FullRange)\n+        &self.predicates[]\n     }\n \n     /// Attempts to select obligations using `selcx`. If `only_new_obligations` is true, then it"}, {"sha": "c0399112c33a9a62a2c6db76a1588a3bb8d500d4", "filename": "src/librustc/middle/traits/object_safety.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fobject_safety.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -178,7 +178,7 @@ fn object_safety_violations_for_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // The `Self` type is erased, so it should not appear in list of\n     // arguments or return type apart from the receiver.\n     let ref sig = method.fty.sig;\n-    for &input_ty in sig.0.inputs.index(&(1..)).iter() {\n+    for &input_ty in sig.0.inputs[1..].iter() {\n         if contains_illegal_self_type_reference(tcx, trait_def_id, input_ty) {\n             return Some(MethodViolationCode::ReferencesSelf);\n         }"}, {"sha": "aaf5df4ce4a56ab5dd69f50da09484953be556c3", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -649,7 +649,7 @@ fn confirm_candidate<'cx,'tcx>(\n             }\n \n             match impl_ty {\n-                Some(ty) => (ty, impl_vtable.nested.to_vec()),\n+                Some(ty) => (ty, impl_vtable.nested.into_vec()),\n                 None => {\n                     // This means that the impl is missing a\n                     // definition for the associated type. This error"}, {"sha": "f42f43d25764d8bb92a6bd84a3cd7ba0825ff9b6", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 26, "deletions": 11, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -835,7 +835,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                bounds.repr(self.tcx()));\n \n         let matching_bound =\n-            util::elaborate_predicates(self.tcx(), bounds.predicates.to_vec())\n+            util::elaborate_predicates(self.tcx(), bounds.predicates.into_vec())\n             .filter_to_traits()\n             .find(\n                 |bound| self.infcx.probe(\n@@ -903,7 +903,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let all_bounds =\n             util::transitive_bounds(\n-                self.tcx(), caller_trait_refs.index(&FullRange));\n+                self.tcx(), &caller_trait_refs[]);\n \n         let matching_bounds =\n             all_bounds.filter(\n@@ -1457,17 +1457,32 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(AmbiguousBuiltin)\n             }\n \n+            ty::ty_open(ty) => {\n+                // these only crop up in trans, and represent an\n+                // \"opened\" unsized/existential type (one that has\n+                // been dereferenced)\n+                match bound {\n+                    ty::BoundCopy |\n+                    ty::BoundSync |\n+                    ty::BoundSend => {\n+                        Ok(If(vec!(ty)))\n+                    }\n+\n+                    ty::BoundSized => {\n+                        Err(Unimplemented)\n+                    }\n+                }\n+            }\n             ty::ty_err => {\n                 Ok(If(Vec::new()))\n             }\n \n-            ty::ty_open(_) |\n             ty::ty_infer(ty::FreshTy(_)) |\n             ty::ty_infer(ty::FreshIntTy(_)) => {\n                 self.tcx().sess.bug(\n-                    format!(\n+                    &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n-                        self_ty.repr(self.tcx())).index(&FullRange));\n+                        self_ty.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1636,8 +1651,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             AmbiguousBuiltin | ParameterBuiltin => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n-                    format!(\"builtin bound for {} was ambig\",\n-                            obligation.repr(self.tcx())).index(&FullRange));\n+                    &format!(\"builtin bound for {} was ambig\",\n+                            obligation.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -1815,8 +1830,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             _ => {\n                 self.tcx().sess.span_bug(\n                     obligation.cause.span,\n-                    format!(\"Fn pointer candidate for inappropriate self type: {}\",\n-                            self_ty.repr(self.tcx())).index(&FullRange));\n+                    &format!(\"Fn pointer candidate for inappropriate self type: {}\",\n+                            self_ty.repr(self.tcx()))[]);\n             }\n         };\n \n@@ -1944,9 +1959,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n             Err(()) => {\n                 self.tcx().sess.bug(\n-                    format!(\"Impl {} was matchable against {} but now is not\",\n+                    &format!(\"Impl {} was matchable against {} but now is not\",\n                             impl_def_id.repr(self.tcx()),\n-                            obligation.repr(self.tcx())).index(&FullRange));\n+                            obligation.repr(self.tcx()))[]);\n             }\n         }\n     }"}, {"sha": "64f0bcb1c88db280d4bc73b44f0fcc260bba4fa2", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 128, "deletions": 79, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -72,7 +72,7 @@ use std::borrow::BorrowFrom;\n use std::cell::{Cell, RefCell};\n use std::cmp::{self, Ordering};\n use std::fmt::{self, Show};\n-use std::hash::{Hash, sip, Writer};\n+use std::hash::{Hash, Writer, SipHasher, Hasher};\n use std::mem;\n use std::ops;\n use std::rc::Rc;\n@@ -107,7 +107,7 @@ pub struct CrateAnalysis<'tcx> {\n     pub glob_map: Option<GlobMap>,\n }\n \n-#[derive(Copy, PartialEq, Eq, Hash)]\n+#[derive(Copy, Clone, PartialEq, Eq, Hash)]\n pub struct field<'tcx> {\n     pub name: ast::Name,\n     pub mt: mt<'tcx>\n@@ -946,11 +946,18 @@ impl<'tcx> PartialEq for TyS<'tcx> {\n }\n impl<'tcx> Eq for TyS<'tcx> {}\n \n+#[cfg(stage0)]\n impl<'tcx, S: Writer> Hash<S> for TyS<'tcx> {\n     fn hash(&self, s: &mut S) {\n         (self as *const _).hash(s)\n     }\n }\n+#[cfg(not(stage0))]\n+impl<'tcx, S: Writer + Hasher> Hash<S> for TyS<'tcx> {\n+    fn hash(&self, s: &mut S) {\n+        (self as *const _).hash(s)\n+    }\n+}\n \n pub type Ty<'tcx> = &'tcx TyS<'tcx>;\n \n@@ -968,7 +975,7 @@ impl<'tcx> PartialEq for InternedTy<'tcx> {\n \n impl<'tcx> Eq for InternedTy<'tcx> {}\n \n-impl<'tcx, S: Writer> Hash<S> for InternedTy<'tcx> {\n+impl<'tcx, S: Writer + Hasher> Hash<S> for InternedTy<'tcx> {\n     fn hash(&self, s: &mut S) {\n         self.ty.sty.hash(s)\n     }\n@@ -1491,10 +1498,12 @@ impl<'tcx> PolyTraitRef<'tcx> {\n     }\n \n     pub fn substs(&self) -> &'tcx Substs<'tcx> {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.substs\n     }\n \n     pub fn input_types(&self) -> &[Ty<'tcx>] {\n+        // FIXME(#20664) every use of this fn is probably a bug, it should yield Binder<>\n         self.0.input_types()\n     }\n \n@@ -2036,8 +2045,8 @@ impl<'tcx> Predicate<'tcx> {\n ///     struct Foo<T,U:Bar<T>> { ... }\n ///\n /// Here, the `Generics` for `Foo` would contain a list of bounds like\n-/// `[.index(&FullRange), [U:Bar<T>]]`.  Now if there were some particular reference\n-/// like `Foo<int,uint>`, then the `GenericBounds` would be `[.index(&FullRange),\n+/// `[[], [U:Bar<T>]]`.  Now if there were some particular reference\n+/// like `Foo<int,uint>`, then the `GenericBounds` would be `[[],\n /// [uint:Bar<int>]]`.\n #[derive(Clone, Show)]\n pub struct GenericBounds<'tcx> {\n@@ -2212,9 +2221,9 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n                 ParameterEnvironment::for_item(cx, cx.map.get_parent(id))\n             }\n             _ => {\n-                cx.sess.bug(format!(\"ParameterEnvironment::from_item(): \\\n+                cx.sess.bug(&format!(\"ParameterEnvironment::from_item(): \\\n                                      `{}` is not an item\",\n-                                    cx.map.node_to_string(id)).index(&FullRange))\n+                                    cx.map.node_to_string(id))[])\n             }\n         }\n     }\n@@ -2299,7 +2308,7 @@ impl UnboxedClosureKind {\n         };\n         match result {\n             Ok(trait_did) => trait_did,\n-            Err(err) => cx.sess.fatal(err.index(&FullRange)),\n+            Err(err) => cx.sess.fatal(&err[]),\n         }\n     }\n }\n@@ -2620,7 +2629,7 @@ impl FlagComputation {\n             }\n \n             &ty_tup(ref ts) => {\n-                self.add_tys(ts.index(&FullRange));\n+                self.add_tys(&ts[]);\n             }\n \n             &ty_bare_fn(_, ref f) => {\n@@ -2643,7 +2652,7 @@ impl FlagComputation {\n     fn add_fn_sig(&mut self, fn_sig: &PolyFnSig) {\n         let mut computation = FlagComputation::new();\n \n-        computation.add_tys(fn_sig.0.inputs.index(&FullRange));\n+        computation.add_tys(&fn_sig.0.inputs[]);\n \n         if let ty::FnConverging(output) = fn_sig.0.output {\n             computation.add_ty(output);\n@@ -2812,7 +2821,7 @@ pub fn mk_trait<'tcx>(cx: &ctxt<'tcx>,\n \n fn bound_list_is_sorted(bounds: &[ty::PolyProjectionPredicate]) -> bool {\n     bounds.len() == 0 ||\n-        bounds.index(&(1..)).iter().enumerate().all(\n+        bounds[1..].iter().enumerate().all(\n             |(index, bound)| bounds[index].sort_key() <= bound.sort_key())\n }\n \n@@ -3066,8 +3075,8 @@ pub fn sequence_element_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         ty_vec(ty, _) => ty,\n         ty_str => mk_mach_uint(cx, ast::TyU8),\n         ty_open(ty) => sequence_element_type(cx, ty),\n-        _ => cx.sess.bug(format!(\"sequence_element_type called on non-sequence value: {}\",\n-                                 ty_to_string(cx, ty)).index(&FullRange)),\n+        _ => cx.sess.bug(&format!(\"sequence_element_type called on non-sequence value: {}\",\n+                                 ty_to_string(cx, ty))[]),\n     }\n }\n \n@@ -3401,7 +3410,7 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             ty_struct(did, substs) => {\n                 let flds = struct_fields(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(flds.index(&FullRange),\n+                    TypeContents::union(&flds[],\n                                         |f| tc_mt(cx, f.mt, cache));\n \n                 if !lookup_repr_hints(cx, did).contains(&attr::ReprExtern) {\n@@ -3425,15 +3434,15 @@ pub fn type_contents<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> TypeContents {\n             }\n \n             ty_tup(ref tys) => {\n-                TypeContents::union(tys.index(&FullRange),\n+                TypeContents::union(&tys[],\n                                     |ty| tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, substs) => {\n                 let variants = substd_enum_variants(cx, did, substs);\n                 let mut res =\n-                    TypeContents::union(variants.index(&FullRange), |variant| {\n-                        TypeContents::union(variant.args.index(&FullRange),\n+                    TypeContents::union(&variants[], |variant| {\n+                        TypeContents::union(&variant.args[],\n                                             |arg_ty| {\n                             tc_ty(cx, *arg_ty, cache)\n                         })\n@@ -4017,8 +4026,8 @@ pub fn deref<'tcx>(ty: Ty<'tcx>, explicit: bool) -> Option<mt<'tcx>> {\n pub fn close_type<'tcx>(cx: &ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n     match ty.sty {\n         ty_open(ty) => mk_rptr(cx, cx.mk_region(ReStatic), mt {ty: ty, mutbl:ast::MutImmutable}),\n-        _ => cx.sess.bug(format!(\"Trying to close a non-open type {}\",\n-                                 ty_to_string(cx, ty)).index(&FullRange))\n+        _ => cx.sess.bug(&format!(\"Trying to close a non-open type {}\",\n+                                 ty_to_string(cx, ty))[])\n     }\n }\n \n@@ -4118,8 +4127,8 @@ pub fn node_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n     match cx.trait_refs.borrow().get(&id) {\n         Some(ty) => ty.clone(),\n         None => cx.sess.bug(\n-            format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n-                    cx.map.node_to_string(id)).index(&FullRange))\n+            &format!(\"node_id_to_trait_ref: no trait ref for node `{}`\",\n+                    cx.map.node_to_string(id))[])\n     }\n }\n \n@@ -4131,8 +4140,8 @@ pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     match try_node_id_to_type(cx, id) {\n        Some(ty) => ty,\n        None => cx.sess.bug(\n-           format!(\"node_id_to_type: no type for node `{}`\",\n-                   cx.map.node_to_string(id)).index(&FullRange))\n+           &format!(\"node_id_to_type: no type for node `{}`\",\n+                   cx.map.node_to_string(id))[])\n     }\n }\n \n@@ -4218,8 +4227,8 @@ pub fn ty_region(tcx: &ctxt,\n         ref s => {\n             tcx.sess.span_bug(\n                 span,\n-                format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n-                        s).index(&FullRange));\n+                &format!(\"ty_region() invoked on an inappropriate ty: {:?}\",\n+                        s)[]);\n         }\n     }\n }\n@@ -4278,13 +4287,13 @@ pub fn expr_span(cx: &ctxt, id: NodeId) -> Span {\n             e.span\n         }\n         Some(f) => {\n-            cx.sess.bug(format!(\"Node id {} is not an expr: {:?}\",\n+            cx.sess.bug(&format!(\"Node id {} is not an expr: {:?}\",\n                                 id,\n-                                f).index(&FullRange));\n+                                f)[]);\n         }\n         None => {\n-            cx.sess.bug(format!(\"Node id {} is not present \\\n-                                in the node map\", id).index(&FullRange));\n+            cx.sess.bug(&format!(\"Node id {} is not present \\\n+                                in the node map\", id)[]);\n         }\n     }\n }\n@@ -4298,16 +4307,16 @@ pub fn local_var_name_str(cx: &ctxt, id: NodeId) -> InternedString {\n                 }\n                 _ => {\n                     cx.sess.bug(\n-                        format!(\"Variable id {} maps to {:?}, not local\",\n+                        &format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                pat).index(&FullRange));\n+                                pat)[]);\n                 }\n             }\n         }\n         r => {\n-            cx.sess.bug(format!(\"Variable id {} maps to {:?}, not local\",\n+            cx.sess.bug(&format!(\"Variable id {} maps to {:?}, not local\",\n                                 id,\n-                                r).index(&FullRange));\n+                                r)[]);\n         }\n     }\n }\n@@ -4336,9 +4345,9 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                         }\n                         ref b => {\n                             cx.sess.bug(\n-                                format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n+                                &format!(\"AdjustReifyFnPointer adjustment on non-fn-item: \\\n                                          {:?}\",\n-                                        b).index(&FullRange));\n+                                        b)[]);\n                         }\n                     }\n                 }\n@@ -4365,11 +4374,11 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                 None => {\n                                     cx.sess.span_bug(\n                                         span,\n-                                        format!(\"the {}th autoderef failed: \\\n+                                        &format!(\"the {}th autoderef failed: \\\n                                                 {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n-                                                          .index(&FullRange));\n+                                        []);\n                                 }\n                             }\n                         }\n@@ -4431,8 +4440,8 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                 mk_vec(cx, ty, None)\n             }\n             _ => cx.sess.span_bug(span,\n-                                  format!(\"UnsizeLength with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty)).index(&FullRange))\n+                                  &format!(\"UnsizeLength with bad sty: {:?}\",\n+                                          ty_to_string(cx, ty))[])\n         },\n         &UnsizeStruct(box ref k, tp_index) => match ty.sty {\n             ty_struct(did, substs) => {\n@@ -4443,8 +4452,8 @@ pub fn unsize_ty<'tcx>(cx: &ctxt<'tcx>,\n                 mk_struct(cx, did, cx.mk_substs(unsized_substs))\n             }\n             _ => cx.sess.span_bug(span,\n-                                  format!(\"UnsizeStruct with bad sty: {:?}\",\n-                                          ty_to_string(cx, ty)).index(&FullRange))\n+                                  &format!(\"UnsizeStruct with bad sty: {:?}\",\n+                                          ty_to_string(cx, ty))[])\n         },\n         &UnsizeVtable(TyTrait { ref principal, ref bounds }, _) => {\n             mk_trait(cx, principal.clone(), bounds.clone())\n@@ -4456,8 +4465,8 @@ pub fn resolve_expr(tcx: &ctxt, expr: &ast::Expr) -> def::Def {\n     match tcx.def_map.borrow().get(&expr.id) {\n         Some(&def) => def,\n         None => {\n-            tcx.sess.span_bug(expr.span, format!(\n-                \"no def-map entry for expr {}\", expr.id).index(&FullRange));\n+            tcx.sess.span_bug(expr.span, &format!(\n+                \"no def-map entry for expr {}\", expr.id)[]);\n         }\n     }\n }\n@@ -4550,9 +4559,9 @@ pub fn expr_kind(tcx: &ctxt, expr: &ast::Expr) -> ExprKind {\n                 def => {\n                     tcx.sess.span_bug(\n                         expr.span,\n-                        format!(\"uncategorized def for expr {}: {:?}\",\n+                        &format!(\"uncategorized def for expr {}: {:?}\",\n                                 expr.id,\n-                                def).index(&FullRange));\n+                                def)[]);\n                 }\n             }\n         }\n@@ -4672,12 +4681,12 @@ pub fn field_idx_strict(tcx: &ctxt, name: ast::Name, fields: &[field])\n                      -> uint {\n     let mut i = 0u;\n     for f in fields.iter() { if f.name == name { return i; } i += 1u; }\n-    tcx.sess.bug(format!(\n+    tcx.sess.bug(&format!(\n         \"no field named `{}` found in the list of fields `{:?}`\",\n         token::get_name(name),\n         fields.iter()\n               .map(|f| token::get_name(f.name).get().to_string())\n-              .collect::<Vec<String>>()).index(&FullRange));\n+              .collect::<Vec<String>>())[]);\n }\n \n pub fn impl_or_trait_item_idx(id: ast::Name, trait_items: &[ImplOrTraitItem])\n@@ -4932,7 +4941,7 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                 match item.node {\n                     ItemTrait(_, _, _, ref ms) => {\n                         let (_, p) =\n-                            ast_util::split_trait_methods(ms.index(&FullRange));\n+                            ast_util::split_trait_methods(&ms[]);\n                         p.iter()\n                          .map(|m| {\n                             match impl_or_trait_item(\n@@ -4949,16 +4958,16 @@ pub fn provided_trait_methods<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                          }).collect()\n                     }\n                     _ => {\n-                        cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is \\\n+                        cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is \\\n                                              not a trait\",\n-                                            id).index(&FullRange))\n+                                            id)[])\n                     }\n                 }\n             }\n             _ => {\n-                cx.sess.bug(format!(\"provided_trait_methods: `{:?}` is not a \\\n+                cx.sess.bug(&format!(\"provided_trait_methods: `{:?}` is not a \\\n                                      trait\",\n-                                    id).index(&FullRange))\n+                                    id)[])\n             }\n         }\n     } else {\n@@ -5196,7 +5205,7 @@ impl<'tcx> VariantInfo<'tcx> {\n                 };\n             },\n             ast::StructVariantKind(ref struct_def) => {\n-                let fields: &[StructField] = struct_def.fields.index(&FullRange);\n+                let fields: &[StructField] = &struct_def.fields[];\n \n                 assert!(fields.len() > 0);\n \n@@ -5346,8 +5355,8 @@ pub fn enum_variants<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                             Err(ref err) => {\n                                                 cx.sess\n                                                   .span_err(e.span,\n-                                                            format!(\"expected constant: {}\",\n-                                                                    *err).index(&FullRange));\n+                                                            &format!(\"expected constant: {}\",\n+                                                                    *err)[]);\n                                             }\n                                         },\n                                     None => {}\n@@ -5636,8 +5645,8 @@ pub fn lookup_struct_fields(cx: &ctxt, did: ast::DefId) -> Vec<field_ty> {\n             Some(fields) => (**fields).clone(),\n             _ => {\n                 cx.sess.bug(\n-                    format!(\"ID not mapped to struct fields: {}\",\n-                            cx.map.node_to_string(did.node)).index(&FullRange));\n+                    &format!(\"ID not mapped to struct fields: {}\",\n+                            cx.map.node_to_string(did.node))[]);\n             }\n         }\n     } else {\n@@ -5670,7 +5679,7 @@ pub fn struct_fields<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId, substs: &Substs<'tc\n pub fn tup_fields<'tcx>(v: &[Ty<'tcx>]) -> Vec<field<'tcx>> {\n     v.iter().enumerate().map(|(i, &f)| {\n        field {\n-            name: token::intern(i.to_string().index(&FullRange)),\n+            name: token::intern(&i.to_string()[]),\n             mt: mt {\n                 ty: f,\n                 mutbl: MutImmutable\n@@ -5845,9 +5854,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 const_eval::const_binary(_) =>\n                     \"binary array\"\n             };\n-            tcx.sess.span_err(count_expr.span, format!(\n+            tcx.sess.span_err(count_expr.span, &format!(\n                 \"expected positive integer for repeat count, found {}\",\n-                found).index(&FullRange));\n+                found)[]);\n         }\n         Err(_) => {\n             let found = match count_expr.node {\n@@ -5860,9 +5869,9 @@ pub fn eval_repeat_count(tcx: &ctxt, count_expr: &ast::Expr) -> uint {\n                 _ =>\n                     \"non-constant expression\"\n             };\n-            tcx.sess.span_err(count_expr.span, format!(\n+            tcx.sess.span_err(count_expr.span, &format!(\n                 \"expected constant integer for repeat count, found {}\",\n-                found).index(&FullRange));\n+                found)[]);\n         }\n     }\n     0\n@@ -6168,15 +6177,16 @@ pub fn trait_item_of_item(tcx: &ctxt, def_id: ast::DefId)\n /// Creates a hash of the type `Ty` which will be the same no matter what crate\n /// context it's calculated within. This is used by the `type_id` intrinsic.\n pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -> u64 {\n-    let mut state = sip::SipState::new();\n+    let mut state = SipHasher::new();\n     helper(tcx, ty, svh, &mut state);\n-    return state.result();\n+    return state.finish();\n \n-    fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh, state: &mut sip::SipState) {\n+    fn helper<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh,\n+                    state: &mut SipHasher) {\n         macro_rules! byte { ($b:expr) => { ($b as u8).hash(state) } }\n         macro_rules! hash { ($e:expr) => { $e.hash(state) }  }\n \n-        let region = |&: state: &mut sip::SipState, r: Region| {\n+        let region = |&: state: &mut SipHasher, r: Region| {\n             match r {\n                 ReStatic => {}\n                 ReLateBound(db, BrAnon(i)) => {\n@@ -6193,7 +6203,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 }\n             }\n         };\n-        let did = |&: state: &mut sip::SipState, did: DefId| {\n+        let did = |&: state: &mut SipHasher, did: DefId| {\n             let h = if ast_util::is_local(did) {\n                 svh.clone()\n             } else {\n@@ -6202,10 +6212,10 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n             h.as_str().hash(state);\n             did.node.hash(state);\n         };\n-        let mt = |&: state: &mut sip::SipState, mt: mt| {\n+        let mt = |&: state: &mut SipHasher, mt: mt| {\n             mt.mutbl.hash(state);\n         };\n-        let fn_sig = |&: state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n+        let fn_sig = |&: state: &mut SipHasher, sig: &Binder<FnSig<'tcx>>| {\n             let sig = anonymize_late_bound_regions(tcx, sig).0;\n             for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {\n@@ -6646,7 +6656,7 @@ pub fn with_freevars<T, F>(tcx: &ty::ctxt, fid: ast::NodeId, f: F) -> T where\n {\n     match tcx.freevars.borrow().get(&fid) {\n         None => f(&[]),\n-        Some(d) => f(d.index(&FullRange))\n+        Some(d) => f(&d[])\n     }\n }\n \n@@ -6676,7 +6686,7 @@ pub fn liberate_late_bound_regions<'tcx, T>(\n {\n     replace_late_bound_regions(\n         tcx, value,\n-        |br, _| ty::ReFree(ty::FreeRegion{scope: scope, bound_region: br})).0\n+        |br| ty::ReFree(ty::FreeRegion{scope: scope, bound_region: br})).0\n }\n \n pub fn count_late_bound_regions<'tcx, T>(\n@@ -6685,7 +6695,7 @@ pub fn count_late_bound_regions<'tcx, T>(\n     -> uint\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-    let (_, skol_map) = replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic);\n+    let (_, skol_map) = replace_late_bound_regions(tcx, value, |_| ty::ReStatic);\n     skol_map.len()\n }\n \n@@ -6716,7 +6726,7 @@ pub fn erase_late_bound_regions<'tcx, T>(\n     -> T\n     where T : TypeFoldable<'tcx> + Repr<'tcx>\n {\n-    replace_late_bound_regions(tcx, value, |_, _| ty::ReStatic).0\n+    replace_late_bound_regions(tcx, value, |_| ty::ReStatic).0\n }\n \n /// Rewrite any late-bound regions so that they are anonymous.  Region numbers are\n@@ -6734,9 +6744,9 @@ pub fn anonymize_late_bound_regions<'tcx, T>(\n     where T : TypeFoldable<'tcx> + Repr<'tcx>,\n {\n     let mut counter = 0;\n-    ty::Binder(replace_late_bound_regions(tcx, sig, |_, db| {\n+    ty::Binder(replace_late_bound_regions(tcx, sig, |_| {\n         counter += 1;\n-        ReLateBound(db, BrAnon(counter))\n+        ReLateBound(ty::DebruijnIndex::new(1), BrAnon(counter))\n     }).0)\n }\n \n@@ -6747,7 +6757,7 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n     mut mapf: F)\n     -> (T, FnvHashMap<ty::BoundRegion,ty::Region>)\n     where T : TypeFoldable<'tcx> + Repr<'tcx>,\n-          F : FnMut(BoundRegion, DebruijnIndex) -> ty::Region,\n+          F : FnMut(BoundRegion) -> ty::Region,\n {\n     debug!(\"replace_late_bound_regions({})\", binder.repr(tcx));\n \n@@ -6759,8 +6769,19 @@ pub fn replace_late_bound_regions<'tcx, T, F>(\n         debug!(\"region={}\", region.repr(tcx));\n         match region {\n             ty::ReLateBound(debruijn, br) if debruijn.depth == current_depth => {\n-                * map.entry(br).get().unwrap_or_else(\n-                      |vacant_entry| vacant_entry.insert(mapf(br, debruijn)))\n+                let region =\n+                    * map.entry(br).get().unwrap_or_else(\n+                        |vacant_entry| vacant_entry.insert(mapf(br)));\n+\n+                if let ty::ReLateBound(debruijn1, br) = region {\n+                    // If the callback returns a late-bound region,\n+                    // that region should always use depth 1. Then we\n+                    // adjust it to the correct depth.\n+                    assert_eq!(debruijn1.depth, 1);\n+                    ty::ReLateBound(debruijn, br)\n+                } else {\n+                    region\n+                }\n             }\n             _ => {\n                 region\n@@ -6907,6 +6928,7 @@ pub enum CopyImplementationError {\n     FieldDoesNotImplementCopy(ast::Name),\n     VariantDoesNotImplementCopy(ast::Name),\n     TypeIsStructural,\n+    TypeHasDestructor,\n }\n \n pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tcx>,\n@@ -6916,14 +6938,15 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n {\n     let tcx = param_env.tcx;\n \n-    match self_type.sty {\n+    let did = match self_type.sty {\n         ty::ty_struct(struct_did, substs) => {\n             let fields = ty::struct_fields(tcx, struct_did, substs);\n             for field in fields.iter() {\n                 if type_moves_by_default(param_env, span, field.mt.ty) {\n                     return Err(FieldDoesNotImplementCopy(field.name))\n                 }\n             }\n+            struct_did\n         }\n         ty::ty_enum(enum_did, substs) => {\n             let enum_variants = ty::enum_variants(tcx, enum_did);\n@@ -6936,8 +6959,13 @@ pub fn can_type_implement_copy<'a,'tcx>(param_env: &ParameterEnvironment<'a, 'tc\n                     }\n                 }\n             }\n+            enum_did\n         }\n         _ => return Err(TypeIsStructural),\n+    };\n+\n+    if ty::has_dtor(tcx, did) {\n+        return Err(TypeHasDestructor)\n     }\n \n     Ok(())\n@@ -6962,6 +6990,13 @@ impl<'tcx> RegionEscape for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx> RegionEscape for Substs<'tcx> {\n+    fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n+        self.types.has_regions_escaping_depth(depth) ||\n+            self.regions.has_regions_escaping_depth(depth)\n+    }\n+}\n+\n impl<'tcx,T:RegionEscape> RegionEscape for VecPerParamSpace<T> {\n     fn has_regions_escaping_depth(&self, depth: u32) -> bool {\n         self.iter_enumerated().any(|(space, _, t)| {\n@@ -7216,6 +7251,12 @@ impl<'tcx> HasProjectionTypes for FnSig<'tcx> {\n     }\n }\n \n+impl<'tcx> HasProjectionTypes for field<'tcx> {\n+    fn has_projection_types(&self) -> bool {\n+        self.mt.ty.has_projection_types()\n+    }\n+}\n+\n impl<'tcx> HasProjectionTypes for BareFnTy<'tcx> {\n     fn has_projection_types(&self) -> bool {\n         self.sig.has_projection_types()\n@@ -7315,3 +7356,11 @@ impl<'tcx> Repr<'tcx> for UnboxedClosureUpvar<'tcx> {\n                 self.ty.repr(tcx))\n     }\n }\n+\n+impl<'tcx> Repr<'tcx> for field<'tcx> {\n+    fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n+        format!(\"field({},{})\",\n+                self.name.repr(tcx),\n+                self.mt.repr(tcx))\n+    }\n+}"}, {"sha": "b81a4ed2f58ff79f76a0f197111056e75346a64d", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -273,6 +273,15 @@ impl<'tcx> TypeFoldable<'tcx> for ty::TraitRef<'tcx> {\n     }\n }\n \n+impl<'tcx> TypeFoldable<'tcx> for ty::field<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::field<'tcx> {\n+        ty::field {\n+            name: self.name,\n+            mt: self.mt.fold_with(folder),\n+        }\n+    }\n+}\n+\n impl<'tcx> TypeFoldable<'tcx> for ty::Region {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::Region {\n         folder.fold_region(*self)\n@@ -853,7 +862,10 @@ impl<'a, 'tcx> TypeFolder<'tcx> for RegionFolder<'a, 'tcx>\n ///////////////////////////////////////////////////////////////////////////\n // Region eraser\n //\n-// Replaces all free regions with 'static. Useful in trans.\n+// Replaces all free regions with 'static. Useful in contexts, such as\n+// method probing, where precise region relationships are not\n+// important. Note that in trans you should use\n+// `common::erase_regions` instead.\n \n pub struct RegionEraser<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,"}, {"sha": "87f5ba0246fc3d86c848a7e263ce1488376dc1fb", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -223,17 +223,17 @@ impl<'a> PluginLoader<'a> {\n             // this is fatal: there are almost certainly macros we need\n             // inside this crate, so continue would spew \"macro undefined\"\n             // errors\n-            Err(err) => self.sess.span_fatal(vi.span, err.index(&FullRange))\n+            Err(err) => self.sess.span_fatal(vi.span, &err[])\n         };\n \n         unsafe {\n             let registrar =\n-                match lib.symbol(symbol.index(&FullRange)) {\n+                match lib.symbol(&symbol[]) {\n                     Ok(registrar) => {\n                         mem::transmute::<*mut u8,PluginRegistrarFun>(registrar)\n                     }\n                     // again fatal if we can't register macros\n-                    Err(err) => self.sess.span_fatal(vi.span, err.index(&FullRange))\n+                    Err(err) => self.sess.span_fatal(vi.span, &err[])\n                 };\n \n             // Intentionally leak the dynamic library. We can't ever unload it"}, {"sha": "72b1669843a672d586799a058db132b94207b186", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 59, "deletions": 40, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -111,7 +111,24 @@ pub struct Options {\n     /// An optional name to use as the crate for std during std injection,\n     /// written `extern crate std = \"name\"`. Default to \"std\". Used by\n     /// out-of-tree drivers.\n-    pub alt_std_name: Option<String>\n+    pub alt_std_name: Option<String>,\n+    /// Indicates how the compiler should treat unstable features\n+    pub unstable_features: UnstableFeatures\n+}\n+\n+#[derive(Clone, Copy)]\n+pub enum UnstableFeatures {\n+    /// Hard errors for unstable features are active, as on\n+    /// beta/stable channels.\n+    Disallow,\n+    /// Use the default lint levels\n+    Default,\n+    /// Errors are bypassed for bootstrapping. This is required any time\n+    /// during the build that feature-related lints are set to warn or above\n+    /// because the build turns on warnings-as-errors and uses lots of unstable\n+    /// features. As a result, this this is always required for building Rust\n+    /// itself.\n+    Cheat\n }\n \n #[derive(Clone, PartialEq, Eq)]\n@@ -217,6 +234,7 @@ pub fn basic_options() -> Options {\n         crate_name: None,\n         alt_std_name: None,\n         libs: Vec::new(),\n+        unstable_features: UnstableFeatures::Disallow\n     }\n }\n \n@@ -558,18 +576,18 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n             if !setter(&mut cg, value) {\n                 match (value, opt_type_desc) {\n                     (Some(..), None) => {\n-                        early_error(format!(\"codegen option `{}` takes no \\\n-                                             value\", key).index(&FullRange))\n+                        early_error(&format!(\"codegen option `{}` takes no \\\n+                                             value\", key)[])\n                     }\n                     (None, Some(type_desc)) => {\n-                        early_error(format!(\"codegen option `{0}` requires \\\n+                        early_error(&format!(\"codegen option `{0}` requires \\\n                                              {1} (-C {0}=<value>)\",\n-                                            key, type_desc).index(&FullRange))\n+                                            key, type_desc)[])\n                     }\n                     (Some(value), Some(type_desc)) => {\n-                        early_error(format!(\"incorrect value `{}` for codegen \\\n+                        early_error(&format!(\"incorrect value `{}` for codegen \\\n                                              option `{}` - {} was expected\",\n-                                             value, key, type_desc).index(&FullRange))\n+                                             value, key, type_desc)[])\n                     }\n                     (None, None) => unreachable!()\n                 }\n@@ -578,8 +596,8 @@ pub fn build_codegen_options(matches: &getopts::Matches) -> CodegenOptions\n             break;\n         }\n         if !found {\n-            early_error(format!(\"unknown codegen option: `{}`\",\n-                                key).index(&FullRange));\n+            early_error(&format!(\"unknown codegen option: `{}`\",\n+                                key)[]);\n         }\n     }\n     return cg;\n@@ -592,10 +610,10 @@ pub fn default_lib_output() -> CrateType {\n pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n     use syntax::parse::token::intern_and_get_ident as intern;\n \n-    let end = sess.target.target.target_endian.index(&FullRange);\n-    let arch = sess.target.target.arch.index(&FullRange);\n-    let wordsz = sess.target.target.target_word_size.index(&FullRange);\n-    let os = sess.target.target.target_os.index(&FullRange);\n+    let end = &sess.target.target.target_endian[];\n+    let arch = &sess.target.target.arch[];\n+    let wordsz = &sess.target.target.target_pointer_width[];\n+    let os = &sess.target.target.target_os[];\n \n     let fam = match sess.target.target.options.is_like_windows {\n         true  => InternedString::new(\"windows\"),\n@@ -609,7 +627,7 @@ pub fn default_configuration(sess: &Session) -> ast::CrateConfig {\n          mk(InternedString::new(\"target_family\"), fam),\n          mk(InternedString::new(\"target_arch\"), intern(arch)),\n          mk(InternedString::new(\"target_endian\"), intern(end)),\n-         mk(InternedString::new(\"target_word_size\"),\n+         mk(InternedString::new(\"target_pointer_width\"),\n             intern(wordsz))\n     );\n }\n@@ -631,23 +649,23 @@ pub fn build_configuration(sess: &Session) -> ast::CrateConfig {\n         append_configuration(&mut user_cfg, InternedString::new(\"test\"))\n     }\n     let mut v = user_cfg.into_iter().collect::<Vec<_>>();\n-    v.push_all(default_cfg.index(&FullRange));\n+    v.push_all(&default_cfg[]);\n     v\n }\n \n pub fn build_target_config(opts: &Options, sp: &SpanHandler) -> Config {\n-    let target = match Target::search(opts.target_triple.index(&FullRange)) {\n+    let target = match Target::search(&opts.target_triple[]) {\n         Ok(t) => t,\n         Err(e) => {\n             sp.handler().fatal((format!(\"Error loading target specification: {}\", e)).as_slice());\n     }\n     };\n \n-    let (int_type, uint_type) = match target.target_word_size.index(&FullRange) {\n+    let (int_type, uint_type) = match &target.target_pointer_width[] {\n         \"32\" => (ast::TyI32, ast::TyU32),\n         \"64\" => (ast::TyI64, ast::TyU64),\n-        w    => sp.handler().fatal((format!(\"target specification was invalid: unrecognized \\\n-                                            target-word-size {}\", w)).index(&FullRange))\n+        w    => sp.handler().fatal(&format!(\"target specification was invalid: unrecognized \\\n+                                            target-word-size {}\", w)[])\n     };\n \n     Config {\n@@ -845,7 +863,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let unparsed_crate_types = matches.opt_strs(\"crate-type\");\n     let crate_types = parse_crate_types_from_list(unparsed_crate_types)\n-        .unwrap_or_else(|e| early_error(e.index(&FullRange)));\n+        .unwrap_or_else(|e| early_error(&e[]));\n \n     let mut lint_opts = vec!();\n     let mut describe_lints = false;\n@@ -872,8 +890,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             }\n         }\n         if this_bit == 0 {\n-            early_error(format!(\"unknown debug flag: {}\",\n-                                *debug_flag).index(&FullRange))\n+            early_error(&format!(\"unknown debug flag: {}\",\n+                                *debug_flag)[])\n         }\n         debugging_opts |= this_bit;\n     }\n@@ -917,8 +935,8 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     \"link\" => OutputTypeExe,\n                     \"dep-info\" => OutputTypeDepInfo,\n                     _ => {\n-                        early_error(format!(\"unknown emission type: `{}`\",\n-                                            part).index(&FullRange))\n+                        early_error(&format!(\"unknown emission type: `{}`\",\n+                                            part)[])\n                     }\n                 };\n                 output_types.push(output_type)\n@@ -955,9 +973,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                 Some(\"2\") => Default,\n                 Some(\"3\") => Aggressive,\n                 Some(arg) => {\n-                    early_error(format!(\"optimization level needs to be \\\n+                    early_error(&format!(\"optimization level needs to be \\\n                                          between 0-3 (instead was `{}`)\",\n-                                        arg).index(&FullRange));\n+                                        arg)[]);\n                 }\n             }\n         } else {\n@@ -993,9 +1011,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             None      |\n             Some(\"2\") => FullDebugInfo,\n             Some(arg) => {\n-                early_error(format!(\"debug info level needs to be between \\\n+                early_error(&format!(\"debug info level needs to be between \\\n                                      0-2 (instead was `{}`)\",\n-                                    arg).index(&FullRange));\n+                                    arg)[]);\n             }\n         }\n     } else {\n@@ -1013,7 +1031,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n \n     let mut search_paths = SearchPaths::new();\n     for s in matches.opt_strs(\"L\").iter() {\n-        search_paths.add_path(s.index(&FullRange));\n+        search_paths.add_path(&s[]);\n     }\n \n     let libs = matches.opt_strs(\"l\").into_iter().map(|s| {\n@@ -1043,9 +1061,9 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n             (Some(name), \"framework\") => (name, cstore::NativeFramework),\n             (Some(name), \"static\") => (name, cstore::NativeStatic),\n             (_, s) => {\n-                early_error(format!(\"unknown library kind `{}`, expected \\\n+                early_error(&format!(\"unknown library kind `{}`, expected \\\n                                      one of dylib, framework, or static\",\n-                                    s).index(&FullRange));\n+                                    s)[]);\n             }\n         };\n         (name.to_string(), kind)\n@@ -1089,17 +1107,17 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n                     --debuginfo\");\n     }\n \n-    let color = match matches.opt_str(\"color\").as_ref().map(|s| s.index(&FullRange)) {\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &s[]) {\n         Some(\"auto\")   => Auto,\n         Some(\"always\") => Always,\n         Some(\"never\")  => Never,\n \n         None => Auto,\n \n         Some(arg) => {\n-            early_error(format!(\"argument for --color must be auto, always \\\n+            early_error(&format!(\"argument for --color must be auto, always \\\n                                  or never (instead was `{}`)\",\n-                                arg).index(&FullRange))\n+                                arg)[])\n         }\n     };\n \n@@ -1149,6 +1167,7 @@ pub fn build_session_options(matches: &getopts::Matches) -> Options {\n         crate_name: crate_name,\n         alt_std_name: None,\n         libs: libs,\n+        unstable_features: UnstableFeatures::Disallow\n     }\n }\n \n@@ -1201,15 +1220,15 @@ mod test {\n     #[test]\n     fn test_switch_implies_cfg_test() {\n         let matches =\n-            &match getopts(&[\"--test\".to_string()], optgroups().index(&FullRange)) {\n+            &match getopts(&[\"--test\".to_string()], &optgroups()[]) {\n               Ok(m) => m,\n               Err(f) => panic!(\"test_switch_implies_cfg_test: {}\", f)\n             };\n         let registry = diagnostics::registry::Registry::new(&[]);\n         let sessopts = build_session_options(matches);\n         let sess = build_session(sessopts, None, registry);\n         let cfg = build_configuration(&sess);\n-        assert!((attr::contains_name(cfg.index(&FullRange), \"test\")));\n+        assert!((attr::contains_name(&cfg[], \"test\")));\n     }\n \n     // When the user supplies --test and --cfg test, don't implicitly add\n@@ -1218,7 +1237,7 @@ mod test {\n     fn test_switch_implies_cfg_test_unless_cfg_test() {\n         let matches =\n             &match getopts(&[\"--test\".to_string(), \"--cfg=test\".to_string()],\n-                           optgroups().index(&FullRange)) {\n+                           &optgroups()[]) {\n               Ok(m) => m,\n               Err(f) => {\n                 panic!(\"test_switch_implies_cfg_test_unless_cfg_test: {}\", f)\n@@ -1238,7 +1257,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string()\n-            ], optgroups().index(&FullRange)).unwrap();\n+            ], &optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1249,7 +1268,7 @@ mod test {\n             let matches = getopts(&[\n                 \"-Awarnings\".to_string(),\n                 \"-Dwarnings\".to_string()\n-            ], optgroups().index(&FullRange)).unwrap();\n+            ], &optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);\n@@ -1259,7 +1278,7 @@ mod test {\n         {\n             let matches = getopts(&[\n                 \"-Adead_code\".to_string()\n-            ], optgroups().index(&FullRange)).unwrap();\n+            ], &optgroups()[]).unwrap();\n             let registry = diagnostics::registry::Registry::new(&[]);\n             let sessopts = build_session_options(&matches);\n             let sess = build_session(sessopts, None, registry);"}, {"sha": "65dac1a5fac886ed8d6b7d72459ff49e1122d5a8", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -174,7 +174,7 @@ impl Session {\n     // cases later on\n     pub fn impossible_case(&self, sp: Span, msg: &str) -> ! {\n         self.span_bug(sp,\n-                      format!(\"impossible case reached: {}\", msg).index(&FullRange));\n+                      &format!(\"impossible case reached: {}\", msg)[]);\n     }\n     pub fn verbose(&self) -> bool { self.debugging_opt(config::VERBOSE) }\n     pub fn time_passes(&self) -> bool { self.debugging_opt(config::TIME_PASSES) }\n@@ -216,7 +216,7 @@ impl Session {\n     }\n     pub fn target_filesearch(&self, kind: PathKind) -> filesearch::FileSearch {\n         filesearch::FileSearch::new(self.sysroot(),\n-                                    self.opts.target_triple.index(&FullRange),\n+                                    &self.opts.target_triple[],\n                                     &self.opts.search_paths,\n                                     kind)\n     }"}, {"sha": "c505e9e311256309a77b5458002a8514fa525bcf", "filename": "src/librustc/util/common.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fcommon.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,6 +16,7 @@ use std::fmt::Show;\n use std::hash::{Hash, Hasher};\n use std::iter::repeat;\n use std::time::Duration;\n+use std::collections::hash_state::HashState;\n \n use syntax::ast;\n use syntax::visit;\n@@ -140,11 +141,11 @@ pub fn block_query<P>(b: &ast::Block, p: P) -> bool where P: FnMut(&ast::Expr) -\n /// Efficiency note: This is implemented in an inefficient way because it is typically invoked on\n /// very small graphs. If the graphs become larger, a more efficient graph representation and\n /// algorithm would probably be advised.\n-pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n-    edges_map: &HashMap<T,Vec<T>,H>,\n-    source: T,\n-    destination: T)\n-    -> bool\n+pub fn can_reach<T, S>(edges_map: &HashMap<T, Vec<T>, S>, source: T,\n+                       destination: T) -> bool\n+    where S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>,\n+          T: Hash< <S as HashState>::Hasher> + Eq + Clone,\n {\n     if source == destination {\n         return true;\n@@ -202,11 +203,12 @@ pub fn can_reach<S,H:Hasher<S>,T:Eq+Clone+Hash<S>>(\n /// }\n /// ```\n #[inline(always)]\n-pub fn memoized<T, U, S, H, F>(cache: &RefCell<HashMap<T, U, H>>, arg: T, f: F) -> U where\n-    T: Clone + Hash<S> + Eq,\n-    U: Clone,\n-    H: Hasher<S>,\n-    F: FnOnce(T) -> U,\n+pub fn memoized<T, U, S, F>(cache: &RefCell<HashMap<T, U, S>>, arg: T, f: F) -> U\n+    where T: Clone + Hash<<S as HashState>::Hasher> + Eq,\n+          U: Clone,\n+          S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>,\n+          F: FnOnce(T) -> U,\n {\n     let key = arg.clone();\n     let result = cache.borrow().get(&key).map(|result| result.clone());"}, {"sha": "ec840498ae6618eb86a8521b243fd01e9ada0024", "filename": "src/librustc/util/lev_distance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Flev_distance.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -48,7 +48,7 @@ fn test_lev_distance() {\n     for c in range(0u32, MAX as u32)\n              .filter_map(|i| from_u32(i))\n              .map(|i| i.to_string()) {\n-        assert_eq!(lev_distance(c.index(&FullRange), c.index(&FullRange)), 0);\n+        assert_eq!(lev_distance(&c[], &c[]), 0);\n     }\n \n     let a = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";"}, {"sha": "044534ae8523651a509cfa0d02a22449ebe5209a", "filename": "src/librustc/util/nodemap.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Fnodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Fnodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fnodemap.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -12,12 +12,14 @@\n \n #![allow(non_snake_case)]\n \n+use std::collections::hash_state::{DefaultState};\n use std::collections::{HashMap, HashSet};\n-use std::hash::{Hasher, Hash, Writer};\n+use std::default::Default;\n+use std::hash::{Hasher, Writer};\n use syntax::ast;\n \n-pub type FnvHashMap<K, V> = HashMap<K, V, FnvHasher>;\n-pub type FnvHashSet<V> = HashSet<V, FnvHasher>;\n+pub type FnvHashMap<K, V> = HashMap<K, V, DefaultState<FnvHasher>>;\n+pub type FnvHashSet<V> = HashSet<V, DefaultState<FnvHasher>>;\n \n pub type NodeMap<T> = FnvHashMap<ast::NodeId, T>;\n pub type DefIdMap<T> = FnvHashMap<ast::DefId, T>;\n@@ -28,16 +30,16 @@ pub type DefIdSet = FnvHashSet<ast::DefId>;\n // Hacks to get good names\n pub mod FnvHashMap {\n     use std::hash::Hash;\n-    use std::collections::HashMap;\n-    pub fn new<K: Hash<super::FnvState> + Eq, V>() -> super::FnvHashMap<K, V> {\n-        HashMap::with_hasher(super::FnvHasher)\n+    use std::default::Default;\n+    pub fn new<K: Hash<super::FnvHasher> + Eq, V>() -> super::FnvHashMap<K, V> {\n+        Default::default()\n     }\n }\n pub mod FnvHashSet {\n     use std::hash::Hash;\n-    use std::collections::HashSet;\n-    pub fn new<V: Hash<super::FnvState> + Eq>() -> super::FnvHashSet<V> {\n-        HashSet::with_hasher(super::FnvHasher)\n+    use std::default::Default;\n+    pub fn new<V: Hash<super::FnvHasher> + Eq>() -> super::FnvHashSet<V> {\n+        Default::default()\n     }\n }\n pub mod NodeMap {\n@@ -68,28 +70,26 @@ pub mod DefIdSet {\n ///\n /// This uses FNV hashing, as described here:\n /// http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function\n-#[derive(Clone, Copy, Default)]\n-pub struct FnvHasher;\n-\n #[allow(missing_copy_implementations)]\n-pub struct FnvState(u64);\n+pub struct FnvHasher(u64);\n \n-impl Hasher<FnvState> for FnvHasher {\n-    fn hash<T: ?Sized + Hash<FnvState>>(&self, t: &T) -> u64 {\n-        let mut state = FnvState(0xcbf29ce484222325);\n-        t.hash(&mut state);\n-        let FnvState(ret) = state;\n-        return ret;\n-    }\n+impl Default for FnvHasher {\n+    fn default() -> FnvHasher { FnvHasher(0xcbf29ce484222325) }\n+}\n+\n+impl Hasher for FnvHasher {\n+    type Output = u64;\n+    fn reset(&mut self) { *self = Default::default(); }\n+    fn finish(&self) -> u64 { self.0 }\n }\n \n-impl Writer for FnvState {\n+impl Writer for FnvHasher {\n     fn write(&mut self, bytes: &[u8]) {\n-        let FnvState(mut hash) = *self;\n+        let FnvHasher(mut hash) = *self;\n         for byte in bytes.iter() {\n             hash = hash ^ (*byte as u64);\n             hash = hash * 0x100000001b3;\n         }\n-        *self = FnvState(hash);\n+        *self = FnvHasher(hash);\n     }\n }"}, {"sha": "559ec533baa9eca1ed0a67d7bbca462541c5ad9f", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -26,6 +26,7 @@ use middle::ty;\n use middle::ty_fold::TypeFoldable;\n \n use std::collections::HashMap;\n+use std::collections::hash_state::HashState;\n use std::hash::{Hash, Hasher};\n use std::rc::Rc;\n use syntax::abi;\n@@ -55,12 +56,12 @@ pub fn note_and_explain_region(cx: &ctxt,\n       (ref str, Some(span)) => {\n         cx.sess.span_note(\n             span,\n-            format!(\"{}{}{}\", prefix, *str, suffix).index(&FullRange));\n+            &format!(\"{}{}{}\", prefix, *str, suffix)[]);\n         Some(span)\n       }\n       (ref str, None) => {\n         cx.sess.note(\n-            format!(\"{}{}{}\", prefix, *str, suffix).index(&FullRange));\n+            &format!(\"{}{}{}\", prefix, *str, suffix)[]);\n         None\n       }\n     }\n@@ -271,7 +272,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         };\n \n         if abi != abi::Rust {\n-            s.push_str(format!(\"extern {} \", abi.to_string()).index(&FullRange));\n+            s.push_str(&format!(\"extern {} \", abi.to_string())[]);\n         };\n \n         s.push_str(\"fn\");\n@@ -290,7 +291,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             Some(def_id) => {\n                 s.push_str(\" {\");\n                 let path_str = ty::item_path_str(cx, def_id);\n-                s.push_str(path_str.index(&FullRange));\n+                s.push_str(&path_str[]);\n                 s.push_str(\"}\");\n             }\n             None => { }\n@@ -305,7 +306,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         match cty.store {\n             ty::UniqTraitStore => {}\n             ty::RegionTraitStore(region, _) => {\n-                s.push_str(region_to_string(cx, \"\", true, region).index(&FullRange));\n+                s.push_str(&region_to_string(cx, \"\", true, region)[]);\n             }\n         }\n \n@@ -324,15 +325,15 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 assert_eq!(cty.onceness, ast::Once);\n                 s.push_str(\"proc\");\n                 push_sig_to_string(cx, &mut s, '(', ')', &cty.sig,\n-                                   bounds_str.index(&FullRange));\n+                                   &bounds_str[]);\n             }\n             ty::RegionTraitStore(..) => {\n                 match cty.onceness {\n                     ast::Many => {}\n                     ast::Once => s.push_str(\"once \")\n                 }\n                 push_sig_to_string(cx, &mut s, '|', '|', &cty.sig,\n-                                   bounds_str.index(&FullRange));\n+                                   &bounds_str[]);\n             }\n         }\n \n@@ -365,7 +366,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n             ty::FnConverging(t) => {\n                 if !ty::type_is_nil(t) {\n                    s.push_str(\" -> \");\n-                   s.push_str(ty_to_string(cx, t).index(&FullRange));\n+                   s.push_str(&ty_to_string(cx, t)[]);\n                 }\n             }\n             ty::FnDiverging => {\n@@ -402,7 +403,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n         }\n         ty_rptr(r, ref tm) => {\n             let mut buf = region_ptr_to_string(cx, *r);\n-            buf.push_str(mt_to_string(cx, tm).index(&FullRange));\n+            buf.push_str(&mt_to_string(cx, tm)[]);\n             buf\n         }\n         ty_open(typ) =>\n@@ -412,7 +413,7 @@ pub fn ty_to_string<'tcx>(cx: &ctxt<'tcx>, typ: &ty::TyS<'tcx>) -> String {\n                 .iter()\n                 .map(|elem| ty_to_string(cx, *elem))\n                 .collect::<Vec<_>>();\n-            match strs.index(&FullRange) {\n+            match &strs[] {\n                 [ref string] => format!(\"({},)\", string),\n                 strs => format!(\"({})\", strs.connect(\", \"))\n             }\n@@ -541,19 +542,19 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n         0\n     };\n \n-    for t in tps.index(&(0..(tps.len() - num_defaults))).iter() {\n+    for t in tps[0..(tps.len() - num_defaults)].iter() {\n         strs.push(ty_to_string(cx, *t))\n     }\n \n     if cx.lang_items.fn_trait_kind(did).is_some() {\n         format!(\"{}({}){}\",\n                 base,\n                 if strs[0].starts_with(\"(\") && strs[0].ends_with(\",)\") {\n-                    strs[0].index(&(1 .. (strs[0].len() - 2))) // Remove '(' and ',)'\n+                    &strs[0][1 .. (strs[0].len() - 2)] // Remove '(' and ',)'\n                 } else if strs[0].starts_with(\"(\") && strs[0].ends_with(\")\") {\n-                    strs[0].index(&(1 .. (strs[0].len() - 1))) // Remove '(' and ')'\n+                    &strs[0][1 .. (strs[0].len() - 1)] // Remove '(' and ')'\n                 } else {\n-                    strs[0].index(&FullRange)\n+                    &strs[0][]\n                 },\n                 if &*strs[1] == \"()\" { String::new() } else { format!(\" -> {}\", strs[1]) })\n     } else if strs.len() > 0 {\n@@ -566,7 +567,7 @@ pub fn parameterized<'tcx>(cx: &ctxt<'tcx>,\n pub fn ty_to_short_str<'tcx>(cx: &ctxt<'tcx>, typ: Ty<'tcx>) -> String {\n     let mut s = typ.repr(cx).to_string();\n     if s.len() >= 32u {\n-        s = s.index(&(0u..32u)).to_string();\n+        s = (&s[0u..32u]).to_string();\n     }\n     return s;\n }\n@@ -631,15 +632,15 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for [T] {\n \n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for OwnedSlice<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self.index(&FullRange))\n+        repr_vec(tcx, &self[])\n     }\n }\n \n // This is necessary to handle types like Option<~[T]>, for which\n // autoderef cannot convert the &[T] handler\n impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for Vec<T> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        repr_vec(tcx, self.index(&FullRange))\n+        repr_vec(tcx, &self[])\n     }\n }\n \n@@ -1182,8 +1183,8 @@ impl<'tcx, T> UserString<'tcx> for ty::Binder<T>\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give.\n         let mut names = Vec::new();\n-        let (unbound_value, _) = ty::replace_late_bound_regions(tcx, self, |br, debruijn| {\n-            ty::ReLateBound(debruijn, match br {\n+        let (unbound_value, _) = ty::replace_late_bound_regions(tcx, self, |br| {\n+            ty::ReLateBound(ty::DebruijnIndex::new(1), match br {\n                 ty::BrNamed(_, name) => {\n                     names.push(token::get_name(name));\n                     br\n@@ -1350,11 +1351,11 @@ impl<'tcx, T:Repr<'tcx>> Repr<'tcx> for ty::Binder<T> {\n     }\n }\n \n-#[old_impl_check]\n-impl<'tcx, S, H, K, V> Repr<'tcx> for HashMap<K,V,H>\n-    where K : Hash<S> + Eq + Repr<'tcx>,\n-          V : Repr<'tcx>,\n-          H : Hasher<S>\n+impl<'tcx, S, K, V> Repr<'tcx> for HashMap<K, V, S>\n+    where K: Hash<<S as HashState>::Hasher> + Eq + Repr<'tcx>,\n+          V: Repr<'tcx>,\n+          S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>,\n {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n         format!(\"HashMap({})\","}, {"sha": "8fc95529bc08796f37013b9778f8847b7ea11e5a", "filename": "src/librustc/util/snapshot_vec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fsnapshot_vec.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -116,7 +116,7 @@ impl<T,U,D:SnapshotVecDelegate<T,U>> SnapshotVec<T,U,D> {\n     pub fn actions_since_snapshot(&self,\n                                   snapshot: &Snapshot)\n                                   -> &[UndoLog<T,U>] {\n-        self.undo_log.index(&(snapshot.length..))\n+        &self.undo_log[snapshot.length..]\n     }\n \n     fn assert_open_snapshot(&self, snapshot: &Snapshot) {"}, {"sha": "7ea192b8d6bc882ba37697bfd7d8ebc49172b633", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 24, "deletions": 27, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -53,7 +53,7 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n           args: &str, cwd: Option<&Path>,\n           paths: &[&Path]) -> ProcessOutput {\n     let ar = match *maybe_ar_prog {\n-        Some(ref ar) => ar.index(&FullRange),\n+        Some(ref ar) => &ar[],\n         None => \"ar\"\n     };\n     let mut cmd = Command::new(ar);\n@@ -73,24 +73,21 @@ fn run_ar(handler: &ErrorHandler, maybe_ar_prog: &Option<String>,\n         Ok(prog) => {\n             let o = prog.wait_with_output().unwrap();\n             if !o.status.success() {\n-                handler.err(format!(\"{} failed with: {}\",\n+                handler.err(&format!(\"{} failed with: {}\",\n                                  cmd,\n-                                 o.status).index(&FullRange));\n-                handler.note(format!(\"stdout ---\\n{}\",\n-                                  str::from_utf8(o.output\n-                                                  .index(&FullRange)).unwrap())\n-                          .index(&FullRange));\n-                handler.note(format!(\"stderr ---\\n{}\",\n-                                  str::from_utf8(o.error\n-                                                  .index(&FullRange)).unwrap())\n-                          .index(&FullRange));\n+                                 o.status)[]);\n+                handler.note(&format!(\"stdout ---\\n{}\",\n+                                  str::from_utf8(&o.output[]).unwrap())[]);\n+                handler.note(&format!(\"stderr ---\\n{}\",\n+                                  str::from_utf8(&o.error[]).unwrap())\n+                             []);\n                 handler.abort_if_errors();\n             }\n             o\n         },\n         Err(e) => {\n-            handler.err(format!(\"could not exec `{}`: {}\", ar.index(&FullRange),\n-                             e).index(&FullRange));\n+            handler.err(&format!(\"could not exec `{}`: {}\", &ar[],\n+                             e)[]);\n             handler.abort_if_errors();\n             panic!(\"rustc::back::archive::run_ar() should not reach this point\");\n         }\n@@ -106,16 +103,16 @@ pub fn find_library(name: &str, osprefix: &str, ossuffix: &str,\n \n     for path in search_paths.iter() {\n         debug!(\"looking for {} inside {:?}\", name, path.display());\n-        let test = path.join(oslibname.index(&FullRange));\n+        let test = path.join(&oslibname[]);\n         if test.exists() { return test }\n         if oslibname != unixlibname {\n-            let test = path.join(unixlibname.index(&FullRange));\n+            let test = path.join(&unixlibname[]);\n             if test.exists() { return test }\n         }\n     }\n-    handler.fatal(format!(\"could not find native static library `{}`, \\\n+    handler.fatal(&format!(\"could not find native static library `{}`, \\\n                            perhaps an -L flag is missing?\",\n-                          name).index(&FullRange));\n+                          name)[]);\n }\n \n impl<'a> Archive<'a> {\n@@ -147,7 +144,7 @@ impl<'a> Archive<'a> {\n     /// Lists all files in an archive\n     pub fn files(&self) -> Vec<String> {\n         let output = run_ar(self.handler, &self.maybe_ar_prog, \"t\", None, &[&self.dst]);\n-        let output = str::from_utf8(output.output.index(&FullRange)).unwrap();\n+        let output = str::from_utf8(&output.output[]).unwrap();\n         // use lines_any because windows delimits output with `\\r\\n` instead of\n         // just `\\n`\n         output.lines_any().map(|s| s.to_string()).collect()\n@@ -179,9 +176,9 @@ impl<'a> ArchiveBuilder<'a> {\n     /// search in the relevant locations for a library named `name`.\n     pub fn add_native_library(&mut self, name: &str) -> io::IoResult<()> {\n         let location = find_library(name,\n-                                    self.archive.slib_prefix.index(&FullRange),\n-                                    self.archive.slib_suffix.index(&FullRange),\n-                                    self.archive.lib_search_paths.index(&FullRange),\n+                                    &self.archive.slib_prefix[],\n+                                    &self.archive.slib_suffix[],\n+                                    &self.archive.lib_search_paths[],\n                                     self.archive.handler);\n         self.add_archive(&location, name, |_| false)\n     }\n@@ -197,12 +194,12 @@ impl<'a> ArchiveBuilder<'a> {\n         // as simple comparison is not enough - there\n         // might be also an extra name suffix\n         let obj_start = format!(\"{}\", name);\n-        let obj_start = obj_start.index(&FullRange);\n+        let obj_start = &obj_start[];\n         // Ignoring all bytecode files, no matter of\n         // name\n         let bc_ext = \".bytecode.deflate\";\n \n-        self.add_archive(rlib, name.index(&FullRange), |fname: &str| {\n+        self.add_archive(rlib, &name[], |fname: &str| {\n             let skip_obj = lto && fname.starts_with(obj_start)\n                 && fname.ends_with(\".o\");\n             skip_obj || fname.ends_with(bc_ext) || fname == METADATA_FILENAME\n@@ -239,7 +236,7 @@ impl<'a> ArchiveBuilder<'a> {\n             // allow running `ar s file.a` to update symbols only.\n             if self.should_update_symbols {\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"s\", Some(self.work_dir.path()), args.index(&FullRange));\n+                       \"s\", Some(self.work_dir.path()), &args[]);\n             }\n             return self.archive;\n         }\n@@ -259,7 +256,7 @@ impl<'a> ArchiveBuilder<'a> {\n                 // Add the archive members seen so far, without updating the\n                 // symbol table (`S`).\n                 run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-                       \"cruS\", Some(self.work_dir.path()), args.index(&FullRange));\n+                       \"cruS\", Some(self.work_dir.path()), &args[]);\n \n                 args.clear();\n                 args.push(&abs_dst);\n@@ -274,7 +271,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // necessary.\n         let flags = if self.should_update_symbols { \"crus\" } else { \"cruS\" };\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n-               flags, Some(self.work_dir.path()), args.index(&FullRange));\n+               flags, Some(self.work_dir.path()), &args[]);\n \n         self.archive\n     }\n@@ -316,7 +313,7 @@ impl<'a> ArchiveBuilder<'a> {\n             } else {\n                 filename\n             };\n-            let new_filename = self.work_dir.path().join(filename.index(&FullRange));\n+            let new_filename = self.work_dir.path().join(&filename[]);\n             try!(fs::rename(file, &new_filename));\n             self.members.push(Path::new(filename));\n         }"}, {"sha": "fcd20158c0a2919fcc296b8773b8dc90d03e159b", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -23,12 +23,14 @@\n \n #![crate_name = \"rustc_back\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n-#![feature(slicing_syntax)]\n+#![allow(unknown_features)]\n+#![feature(slicing_syntax, box_syntax)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "d24fd6a5b3f0558bf8d0961d0bb83f866dc8a4da", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -44,15 +44,15 @@ pub fn get_rpath_flags<F, G>(config: RPathConfig<F, G>) -> Vec<String> where\n         l.map(|p| p.clone())\n     }).collect::<Vec<_>>();\n \n-    let rpaths = get_rpaths(config, libs.index(&FullRange));\n-    flags.push_all(rpaths_to_flags(rpaths.index(&FullRange)).index(&FullRange));\n+    let rpaths = get_rpaths(config, &libs[]);\n+    flags.push_all(&rpaths_to_flags(&rpaths[])[]);\n     flags\n }\n \n fn rpaths_to_flags(rpaths: &[String]) -> Vec<String> {\n     let mut ret = Vec::new();\n     for rpath in rpaths.iter() {\n-        ret.push(format!(\"-Wl,-rpath,{}\", (*rpath).index(&FullRange)));\n+        ret.push(format!(\"-Wl,-rpath,{}\", &(*rpath)[]));\n     }\n     return ret;\n }\n@@ -82,14 +82,14 @@ fn get_rpaths<F, G>(mut config: RPathConfig<F, G>, libs: &[Path]) -> Vec<String>\n         }\n     }\n \n-    log_rpaths(\"relative\", rel_rpaths.index(&FullRange));\n-    log_rpaths(\"fallback\", fallback_rpaths.index(&FullRange));\n+    log_rpaths(\"relative\", &rel_rpaths[]);\n+    log_rpaths(\"fallback\", &fallback_rpaths[]);\n \n     let mut rpaths = rel_rpaths;\n-    rpaths.push_all(fallback_rpaths.index(&FullRange));\n+    rpaths.push_all(&fallback_rpaths[]);\n \n     // Remove duplicates\n-    let rpaths = minimize_rpaths(rpaths.index(&FullRange));\n+    let rpaths = minimize_rpaths(&rpaths[]);\n     return rpaths;\n }\n \n@@ -140,7 +140,7 @@ fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {\n     let mut set = HashSet::new();\n     let mut minimized = Vec::new();\n     for rpath in rpaths.iter() {\n-        if set.insert(rpath.index(&FullRange)) {\n+        if set.insert(&rpath[]) {\n             minimized.push(rpath.clone());\n         }\n     }"}, {"sha": "ac5662f534c86c4fa229ac14eb590f679b6348af", "filename": "src/librustc_back/sha2.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Fsha2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Fsha2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsha2.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -140,7 +140,7 @@ impl FixedBuffer for FixedBuffer64 {\n             if input.len() >= buffer_remaining {\n                     copy_memory(\n                         self.buffer.slice_mut(self.buffer_idx, size),\n-                        input.index(&(0..buffer_remaining)));\n+                        &input[0..buffer_remaining]);\n                 self.buffer_idx = 0;\n                 func(&self.buffer);\n                 i += buffer_remaining;\n@@ -156,7 +156,7 @@ impl FixedBuffer for FixedBuffer64 {\n         // While we have at least a full buffer size chunk's worth of data, process that data\n         // without copying it into the buffer\n         while input.len() - i >= size {\n-            func(input.index(&(i..(i + size))));\n+            func(&input[i..(i + size)]);\n             i += size;\n         }\n \n@@ -166,7 +166,7 @@ impl FixedBuffer for FixedBuffer64 {\n         let input_remaining = input.len() - i;\n         copy_memory(\n             self.buffer.slice_to_mut(input_remaining),\n-            input.index(&(i..)));\n+            &input[i..]);\n         self.buffer_idx += input_remaining;\n     }\n \n@@ -188,7 +188,7 @@ impl FixedBuffer for FixedBuffer64 {\n     fn full_buffer<'s>(&'s mut self) -> &'s [u8] {\n         assert!(self.buffer_idx == 64);\n         self.buffer_idx = 0;\n-        return self.buffer.index(&(0..64));\n+        return &self.buffer[0..64];\n     }\n \n     fn position(&self) -> uint { self.buffer_idx }"}, {"sha": "4e260da2e4dedd3ff176f35473410da6b1894f28", "filename": "src/librustc_back/svh.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Fsvh.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Fsvh.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Fsvh.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -47,8 +47,7 @@\n //! Original issue: https://github.com/rust-lang/rust/issues/10207\n \n use std::fmt;\n-use std::hash::Hash;\n-use std::hash::sip::SipState;\n+use std::hash::{Hash, SipHasher, Hasher};\n use std::iter::range_step;\n use syntax::ast;\n use syntax::visit;\n@@ -65,7 +64,7 @@ impl Svh {\n     }\n \n     pub fn as_str<'a>(&'a self) -> &'a str {\n-        self.hash.index(&FullRange)\n+        &self.hash[]\n     }\n \n     pub fn calculate(metadata: &Vec<String>, krate: &ast::Crate) -> Svh {\n@@ -78,7 +77,7 @@ impl Svh {\n \n         // FIXME: this should use SHA1, not SipHash. SipHash is not built to\n         //        avoid collisions.\n-        let mut state = SipState::new();\n+        let mut state = SipHasher::new();\n \n         for data in metadata.iter() {\n             data.hash(&mut state);\n@@ -102,7 +101,7 @@ impl Svh {\n             attr.node.value.hash(&mut state);\n         }\n \n-        let hash = state.result();\n+        let hash = state.finish();\n         return Svh {\n             hash: range_step(0u, 64u, 4u).map(|i| hex(hash >> i)).collect()\n         };\n@@ -120,9 +119,7 @@ impl Svh {\n \n impl fmt::Show for Svh {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        //NOTE(stage0): uncomment after snapshot\n-        //write!(f, \"Svh {{ {} }}\", self.as_str())\n-        fmt::String::fmt(self, f)\n+        write!(f, \"Svh {{ {} }}\", self.as_str())\n     }\n }\n \n@@ -149,14 +146,13 @@ mod svh_visitor {\n     use syntax::visit;\n     use syntax::visit::{Visitor, FnKind};\n \n-    use std::hash::Hash;\n-    use std::hash::sip::SipState;\n+    use std::hash::{Hash, SipHasher};\n \n     pub struct StrictVersionHashVisitor<'a> {\n-        pub st: &'a mut SipState,\n+        pub st: &'a mut SipHasher,\n     }\n \n-    pub fn make<'a>(st: &'a mut SipState) -> StrictVersionHashVisitor<'a> {\n+    pub fn make<'a>(st: &'a mut SipHasher) -> StrictVersionHashVisitor<'a> {\n         StrictVersionHashVisitor { st: st }\n     }\n \n@@ -366,7 +362,7 @@ mod svh_visitor {\n             fn macro_name(mac: &Mac) -> token::InternedString {\n                 match &mac.node {\n                     &MacInvocTT(ref path, ref _tts, ref _stx_ctxt) => {\n-                        let s = path.segments.index(&FullRange);\n+                        let s = &path.segments[];\n                         assert_eq!(s.len(), 1);\n                         content(s[0].identifier)\n                     }\n@@ -400,7 +396,7 @@ mod svh_visitor {\n         }\n \n         // All of the remaining methods just record (in the hash\n-        // SipState) that the visitor saw that particular variant\n+        // SipHasher) that the visitor saw that particular variant\n         // (with its payload), and continue walking as the default\n         // visitor would.\n         //"}, {"sha": "a3ef6372f0648b9e1046b1ea1cd14584f9ab1749", "filename": "src/librustc_back/target/aarch64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Faarch64_unknown_linux_gnu.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> Target {\n                       n32:64-S128\".to_string(),\n         llvm_target: \"aarch64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"64\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n         arch: \"aarch64\".to_string(),\n         target_os: \"linux\".to_string(),\n         options: base,"}, {"sha": "e0afef6e3904f235faa475bcb24609e1c7bfdf93", "filename": "src/librustc_back/target/arm_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_apple_ios.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -19,7 +19,7 @@ pub fn target() -> Target {\n                       -a:0:64-n32\".to_string(),\n         llvm_target: \"arm-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"ios\".to_string(),\n         options: TargetOptions {"}, {"sha": "6fc77a715a55667b672a7edafa1f23229360bf28", "filename": "src/librustc_back/target/arm_linux_androideabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_linux_androideabi.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -27,7 +27,7 @@ pub fn target() -> Target {\n                       -a:0:64-n32\".to_string(),\n         llvm_target: \"arm-linux-androideabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"android\".to_string(),\n         options: base,"}, {"sha": "32eccaf54b038816e01c02207fb35e558863f1e1", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabi.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabi.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -20,7 +20,7 @@ pub fn target() -> Target {\n                       -a:0:64-n32\".to_string(),\n         llvm_target: \"arm-unknown-linux-gnueabi\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"linux\".to_string(),\n "}, {"sha": "eff3601250f875c58e4aaee59261ee4d2ce99c0a", "filename": "src/librustc_back/target/arm_unknown_linux_gnueabihf.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Farm_unknown_linux_gnueabihf.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -20,7 +20,7 @@ pub fn target() -> Target {\n                       -a:0:64-n32\".to_string(),\n         llvm_target: \"arm-unknown-linux-gnueabihf\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"arm\".to_string(),\n         target_os: \"linux\".to_string(),\n "}, {"sha": "a1fcc9ac53fb226b4ce546f33ddf5fd40c9235a9", "filename": "src/librustc_back/target/i386_apple_ios.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi386_apple_ios.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -19,7 +19,7 @@ pub fn target() -> Target {\n                       -n8:16:32\".to_string(),\n         llvm_target: \"i386-apple-ios\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"ios\".to_string(),\n "}, {"sha": "1b079323bf9ca7e4de47a8ab4ff23d73adc5bdc2", "filename": "src/librustc_back/target/i686_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_apple_darwin.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -22,7 +22,7 @@ pub fn target() -> Target {\n                       -n8:16:32\".to_string(),\n         llvm_target: \"i686-apple-darwin\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"macos\".to_string(),\n         options: base,"}, {"sha": "c2ab68ee05256d048ac27874e053a06be463556e", "filename": "src/librustc_back/target/i686_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_pc_windows_gnu.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -26,7 +26,7 @@ pub fn target() -> Target {\n         data_layout: \"e-p:32:32-f64:64:64-i64:64:64-f80:32:32-n8:16:32\".to_string(),\n         llvm_target: \"i686-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"windows\".to_string(),\n         options: options,"}, {"sha": "7910eba7ea1249e479a9fe30341ca225b16a334f", "filename": "src/librustc_back/target/i686_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_dragonfly.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> Target {\n         data_layout: \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string(),\n         llvm_target: \"i686-unknown-dragonfly\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"dragonfly\".to_string(),\n         options: base,"}, {"sha": "c93a564fef5f44164fc3a5e6ffa861891a12cf89", "filename": "src/librustc_back/target/i686_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fi686_unknown_linux_gnu.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -18,7 +18,7 @@ pub fn target() -> Target {\n         data_layout: \"e-p:32:32-f64:32:64-i64:32:64-f80:32:32-n8:16:32\".to_string(),\n         llvm_target: \"i686-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"x86\".to_string(),\n         target_os: \"linux\".to_string(),\n         options: base,"}, {"sha": "8acc248e23410105c134612cf65f5822c6804a6d", "filename": "src/librustc_back/target/mips_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmips_unknown_linux_gnu.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -19,7 +19,7 @@ pub fn target() -> Target {\n                       -a:0:64-n32\".to_string(),\n         llvm_target: \"mips-unknown-linux-gnu\".to_string(),\n         target_endian: \"big\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"mips\".to_string(),\n         target_os: \"linux\".to_string(),\n         options: super::linux_base::opts()"}, {"sha": "604c62eb69f0f753fffe2e628f29ddbb076d55da", "filename": "src/librustc_back/target/mipsel_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmipsel_unknown_linux_gnu.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -19,7 +19,7 @@ pub fn target() -> Target {\n                       -a:0:64-n32\".to_string(),\n         llvm_target: \"mipsel-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"32\".to_string(),\n+        target_pointer_width: \"32\".to_string(),\n         arch: \"mips\".to_string(),\n         target_os: \"linux\".to_string(),\n "}, {"sha": "069e798887b93f8eb45146670a415b3e9551ab36", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -85,8 +85,8 @@ pub struct Target {\n     pub llvm_target: String,\n     /// String to use as the `target_endian` `cfg` variable.\n     pub target_endian: String,\n-    /// String to use as the `target_word_size` `cfg` variable.\n-    pub target_word_size: String,\n+    /// String to use as the `target_pointer_width` `cfg` variable.\n+    pub target_pointer_width: String,\n     /// OS name to use for conditional compilation.\n     pub target_os: String,\n     /// Architecture to use for ABI considerations. Valid options: \"x86\", \"x86_64\", \"arm\",\n@@ -224,16 +224,15 @@ impl Target {\n                      .and_then(|os| os.map(|s| s.to_string())) {\n                 Some(val) => val,\n                 None =>\n-                    handler.fatal((format!(\"Field {} in target specification is required\", name))\n-                                  .index(&FullRange))\n+                    handler.fatal(&format!(\"Field {} in target specification is required\", name)[])\n             }\n         };\n \n         let mut base = Target {\n             data_layout: get_req_field(\"data-layout\"),\n             llvm_target: get_req_field(\"llvm-target\"),\n             target_endian: get_req_field(\"target-endian\"),\n-            target_word_size: get_req_field(\"target-word-size\"),\n+            target_pointer_width: get_req_field(\"target-word-size\"),\n             arch: get_req_field(\"arch\"),\n             target_os: get_req_field(\"os\"),\n             options: Default::default(),\n@@ -242,18 +241,18 @@ impl Target {\n         macro_rules! key {\n             ($key_name:ident) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name.index(&FullRange)).map(|o| o.as_string()\n+                obj.find(&name[]).map(|o| o.as_string()\n                                     .map(|s| base.options.$key_name = s.to_string()));\n             } );\n             ($key_name:ident, bool) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name.index(&FullRange))\n+                obj.find(&name[])\n                     .map(|o| o.as_boolean()\n                          .map(|s| base.options.$key_name = s));\n             } );\n             ($key_name:ident, list) => ( {\n                 let name = (stringify!($key_name)).replace(\"_\", \"-\");\n-                obj.find(name.index(&FullRange)).map(|o| o.as_array()\n+                obj.find(&name[]).map(|o| o.as_array()\n                     .map(|v| base.options.$key_name = v.iter()\n                         .map(|a| a.as_string().unwrap().to_string()).collect()\n                         )\n@@ -369,7 +368,7 @@ impl Target {\n \n         let target_path = os::getenv(\"RUST_TARGET_PATH\").unwrap_or(String::new());\n \n-        let paths = os::split_paths(target_path.index(&FullRange));\n+        let paths = os::split_paths(&target_path[]);\n         // FIXME 16351: add a sane default search path?\n \n         for dir in paths.iter() {"}, {"sha": "0ebd3bd321583aa17186ae3f55cf6d84899a4019", "filename": "src/librustc_back/target/x86_64_apple_darwin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_apple_darwin.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -21,7 +21,7 @@ pub fn target() -> Target {\n                       s0:64:64-f80:128:128-n8:16:32:64\".to_string(),\n         llvm_target: \"x86_64-apple-darwin\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"64\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"macos\".to_string(),\n         options: base,"}, {"sha": "9e1294a89625fbc5ef112acfc95be0a0ec3baeef", "filename": "src/librustc_back/target/x86_64_pc_windows_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_pc_windows_gnu.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -23,7 +23,7 @@ pub fn target() -> Target {\n                       s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n         llvm_target: \"x86_64-pc-windows-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"64\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"windows\".to_string(),\n         options: base,"}, {"sha": "6635306b0e193b57376664139c316d59c580c30d", "filename": "src/librustc_back/target/x86_64_unknown_dragonfly.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_dragonfly.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -20,7 +20,7 @@ pub fn target() -> Target {\n                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n         llvm_target: \"x86_64-unknown-dragonfly\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"64\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"dragonfly\".to_string(),\n         options: base,"}, {"sha": "2aba2b8defbdc1385043851fc3c34c4d1b85c6dd", "filename": "src/librustc_back/target/x86_64_unknown_freebsd.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_freebsd.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -20,7 +20,7 @@ pub fn target() -> Target {\n                      s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n         llvm_target: \"x86_64-unknown-freebsd\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"64\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"freebsd\".to_string(),\n         options: base,"}, {"sha": "d7a6df3a8b0beddd8be12612ed074e3e385d6328", "filename": "src/librustc_back/target/x86_64_unknown_linux_gnu.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fx86_64_unknown_linux_gnu.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -20,7 +20,7 @@ pub fn target() -> Target {\n                       s0:64:64-f80:128:128-n8:16:32:64-S128\".to_string(),\n         llvm_target: \"x86_64-unknown-linux-gnu\".to_string(),\n         target_endian: \"little\".to_string(),\n-        target_word_size: \"64\".to_string(),\n+        target_pointer_width: \"64\".to_string(),\n         arch: \"x86_64\".to_string(),\n         target_os: \"linux\".to_string(),\n         options: base,"}, {"sha": "d5ad201eabfaaa959768054b73f5568d893acb0f", "filename": "src/librustc_borrowck/borrowck/check_loans.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fcheck_loans.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -463,47 +463,47 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 (ty::MutBorrow, ty::MutBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}`{} as mutable \\\n+                        &format!(\"cannot borrow `{}`{} as mutable \\\n                                 more than once at a time\",\n-                                nl, new_loan_msg).index(&FullRange))\n+                                nl, new_loan_msg)[])\n                 }\n \n                 (ty::UniqueImmBorrow, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"closure requires unique access to `{}` \\\n+                        &format!(\"closure requires unique access to `{}` \\\n                                 but {} is already borrowed{}\",\n-                                nl, ol_pronoun, old_loan_msg).index(&FullRange));\n+                                nl, ol_pronoun, old_loan_msg)[]);\n                 }\n \n                 (_, ty::UniqueImmBorrow) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}`{} as {} because \\\n+                        &format!(\"cannot borrow `{}`{} as {} because \\\n                                 previous closure requires unique access\",\n-                                nl, new_loan_msg, new_loan.kind.to_user_str()).index(&FullRange));\n+                                nl, new_loan_msg, new_loan.kind.to_user_str())[]);\n                 }\n \n                 (_, _) => {\n                     self.bccx.span_err(\n                         new_loan.span,\n-                        format!(\"cannot borrow `{}`{} as {} because \\\n+                        &format!(\"cannot borrow `{}`{} as {} because \\\n                                 {} is also borrowed as {}{}\",\n                                 nl,\n                                 new_loan_msg,\n                                 new_loan.kind.to_user_str(),\n                                 ol_pronoun,\n                                 old_loan.kind.to_user_str(),\n-                                old_loan_msg).index(&FullRange));\n+                                old_loan_msg)[]);\n                 }\n             }\n \n             match new_loan.cause {\n                 euv::ClosureCapture(span) => {\n                     self.bccx.span_note(\n                         span,\n-                        format!(\"borrow occurs due to use of `{}` in closure\",\n-                                nl).index(&FullRange));\n+                        &format!(\"borrow occurs due to use of `{}` in closure\",\n+                                nl)[]);\n                 }\n                 _ => { }\n             }\n@@ -552,7 +552,7 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n \n             self.bccx.span_note(\n                 old_loan.span,\n-                format!(\"{}; {}\", borrow_summary, rule_summary).index(&FullRange));\n+                &format!(\"{}; {}\", borrow_summary, rule_summary)[]);\n \n             let old_loan_span = self.tcx().map.span(old_loan.kill_scope.node_id());\n             self.bccx.span_end_note(old_loan_span,\n@@ -621,14 +621,14 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n             UseWhileBorrowed(loan_path, loan_span) => {\n                 self.bccx.span_err(\n                     span,\n-                    format!(\"cannot use `{}` because it was mutably borrowed\",\n-                            self.bccx.loan_path_to_string(copy_path).index(&FullRange))\n-                    .index(&FullRange));\n+                    &format!(\"cannot use `{}` because it was mutably borrowed\",\n+                            &self.bccx.loan_path_to_string(copy_path)[])\n+                    []);\n                 self.bccx.span_note(\n                     loan_span,\n-                    format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path).index(&FullRange))\n-                    .index(&FullRange));\n+                    &format!(\"borrow of `{}` occurs here\",\n+                            &self.bccx.loan_path_to_string(&*loan_path)[])\n+                    []);\n             }\n         }\n     }\n@@ -647,20 +647,20 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 let err_message = match move_kind {\n                     move_data::Captured =>\n                         format!(\"cannot move `{}` into closure because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path).index(&FullRange)),\n+                                &self.bccx.loan_path_to_string(move_path)[]),\n                     move_data::Declared |\n                     move_data::MoveExpr |\n                     move_data::MovePat =>\n                         format!(\"cannot move out of `{}` because it is borrowed\",\n-                                self.bccx.loan_path_to_string(move_path).index(&FullRange))\n+                                &self.bccx.loan_path_to_string(move_path)[])\n                 };\n \n-                self.bccx.span_err(span, err_message.index(&FullRange));\n+                self.bccx.span_err(span, &err_message[]);\n                 self.bccx.span_note(\n                     loan_span,\n-                    format!(\"borrow of `{}` occurs here\",\n-                            self.bccx.loan_path_to_string(&*loan_path).index(&FullRange))\n-                    .index(&FullRange));\n+                    &format!(\"borrow of `{}` occurs here\",\n+                            &self.bccx.loan_path_to_string(&*loan_path)[])\n+                    []);\n             }\n         }\n     }\n@@ -809,34 +809,34 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                 if kind == ty::FnUnboxedClosureKind {\n                     self.bccx.span_err(\n                         assignment_span,\n-                        format!(\"cannot assign to {}\",\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n+                        &format!(\"cannot assign to {}\",\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                     self.bccx.span_help(\n                         self.tcx().map.span(upvar_id.closure_expr_id),\n                         \"consider changing this closure to take self by mutable reference\");\n                 } else {\n                     self.bccx.span_err(\n                         assignment_span,\n-                        format!(\"cannot assign to {} {}\",\n+                        &format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                 }\n             }\n             _ => match opt_loan_path(&assignee_cmt) {\n                 Some(lp) => {\n                     self.bccx.span_err(\n                         assignment_span,\n-                        format!(\"cannot assign to {} {} `{}`\",\n+                        &format!(\"cannot assign to {} {} `{}`\",\n                                 assignee_cmt.mutbl.to_user_str(),\n                                 self.bccx.cmt_to_string(&*assignee_cmt),\n-                                self.bccx.loan_path_to_string(&*lp)).index(&FullRange));\n+                                self.bccx.loan_path_to_string(&*lp))[]);\n                 }\n                 None => {\n                     self.bccx.span_err(\n                         assignment_span,\n-                        format!(\"cannot assign to {} {}\",\n+                        &format!(\"cannot assign to {} {}\",\n                                 assignee_cmt.mutbl.to_user_str(),\n-                                self.bccx.cmt_to_string(&*assignee_cmt)).index(&FullRange));\n+                                self.bccx.cmt_to_string(&*assignee_cmt))[]);\n                 }\n             }\n         }\n@@ -955,11 +955,11 @@ impl<'a, 'tcx> CheckLoanCtxt<'a, 'tcx> {\n                                    loan: &Loan) {\n         self.bccx.span_err(\n             span,\n-            format!(\"cannot assign to `{}` because it is borrowed\",\n-                    self.bccx.loan_path_to_string(loan_path)).index(&FullRange));\n+            &format!(\"cannot assign to `{}` because it is borrowed\",\n+                    self.bccx.loan_path_to_string(loan_path))[]);\n         self.bccx.span_note(\n             loan.span,\n-            format!(\"borrow of `{}` occurs here\",\n-                    self.bccx.loan_path_to_string(loan_path)).index(&FullRange));\n+            &format!(\"borrow of `{}` occurs here\",\n+                    self.bccx.loan_path_to_string(loan_path))[]);\n     }\n }"}, {"sha": "1b1202082177112e35ba939fa52196442f8d111c", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -38,7 +38,7 @@ enum Fragment {\n     // This represents the collection of all but one of the elements\n     // from an array at the path described by the move path index.\n     // Note that attached MovePathIndex should have mem_categorization\n-    // of InteriorElement (i.e. array dereference `.index(&FullRange)`).\n+    // of InteriorElement (i.e. array dereference `&foo[]`).\n     AllButOneFrom(MovePathIndex),\n }\n \n@@ -123,12 +123,12 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         let attrs : &[ast::Attribute];\n         attrs = match tcx.map.find(id) {\n             Some(ast_map::NodeItem(ref item)) =>\n-                item.attrs.index(&FullRange),\n+                &item.attrs[],\n             Some(ast_map::NodeImplItem(&ast::MethodImplItem(ref m))) =>\n-                m.attrs.index(&FullRange),\n+                &m.attrs[],\n             Some(ast_map::NodeTraitItem(&ast::ProvidedMethod(ref m))) =>\n-                m.attrs.index(&FullRange),\n-            _ => [].index(&FullRange),\n+                &m.attrs[],\n+            _ => &[][],\n         };\n \n         let span_err =\n@@ -144,7 +144,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, mpi) in vec_rc.iter().enumerate() {\n             let render = |&:| this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).index(&FullRange));\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render())[]);\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -156,7 +156,7 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         for (i, f) in vec_rc.iter().enumerate() {\n             let render = |&:| f.loan_path_user_string(this, tcx);\n             if span_err {\n-                tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render()).index(&FullRange));\n+                tcx.sess.span_err(sp, &format!(\"{}: `{}`\", kind, render())[]);\n             }\n             if print {\n                 println!(\"id:{} {}[{}] `{}`\", id, kind, i, render());\n@@ -198,11 +198,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     // First, filter out duplicates\n     moved.sort();\n     moved.dedup();\n-    debug!(\"fragments 1 moved: {:?}\", path_lps(moved.index(&FullRange)));\n+    debug!(\"fragments 1 moved: {:?}\", path_lps(&moved[]));\n \n     assigned.sort();\n     assigned.dedup();\n-    debug!(\"fragments 1 assigned: {:?}\", path_lps(assigned.index(&FullRange)));\n+    debug!(\"fragments 1 assigned: {:?}\", path_lps(&assigned[]));\n \n     // Second, build parents from the moved and assigned.\n     for m in moved.iter() {\n@@ -222,14 +222,14 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     parents.sort();\n     parents.dedup();\n-    debug!(\"fragments 2 parents: {:?}\", path_lps(parents.index(&FullRange)));\n+    debug!(\"fragments 2 parents: {:?}\", path_lps(&parents[]));\n \n     // Third, filter the moved and assigned fragments down to just the non-parents\n-    moved.retain(|f| non_member(*f, parents.index(&FullRange)));\n-    debug!(\"fragments 3 moved: {:?}\", path_lps(moved.index(&FullRange)));\n+    moved.retain(|f| non_member(*f, &parents[]));\n+    debug!(\"fragments 3 moved: {:?}\", path_lps(&moved[]));\n \n-    assigned.retain(|f| non_member(*f, parents.index(&FullRange)));\n-    debug!(\"fragments 3 assigned: {:?}\", path_lps(assigned.index(&FullRange)));\n+    assigned.retain(|f| non_member(*f, &parents[]));\n+    debug!(\"fragments 3 assigned: {:?}\", path_lps(&assigned[]));\n \n     // Fourth, build the leftover from the moved, assigned, and parents.\n     for m in moved.iter() {\n@@ -247,16 +247,16 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n \n     unmoved.sort();\n     unmoved.dedup();\n-    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(unmoved.index(&FullRange)));\n+    debug!(\"fragments 4 unmoved: {:?}\", frag_lps(&unmoved[]));\n \n     // Fifth, filter the leftover fragments down to its core.\n     unmoved.retain(|f| match *f {\n         AllButOneFrom(_) => true,\n-        Just(mpi) => non_member(mpi, parents.index(&FullRange)) &&\n-            non_member(mpi, moved.index(&FullRange)) &&\n-            non_member(mpi, assigned.index(&FullRange))\n+        Just(mpi) => non_member(mpi, &parents[]) &&\n+            non_member(mpi, &moved[]) &&\n+            non_member(mpi, &assigned[])\n     });\n-    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(unmoved.index(&FullRange)));\n+    debug!(\"fragments 5 unmoved: {:?}\", frag_lps(&unmoved[]));\n \n     // Swap contents back in.\n     fragments.unmoved_fragments = unmoved;\n@@ -433,7 +433,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n             let msg = format!(\"type {} ({:?}) is not fragmentable\",\n                               parent_ty.repr(tcx), sty_and_variant_info);\n             let opt_span = origin_id.and_then(|id|tcx.map.opt_span(id));\n-            tcx.sess.opt_span_bug(opt_span, msg.index(&FullRange))\n+            tcx.sess.opt_span_bug(opt_span, &msg[])\n         }\n     }\n }"}, {"sha": "889a359b019cd84abac5882e2ffc8e03fffc02e6", "filename": "src/librustc_borrowck/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -306,8 +306,8 @@ impl<'a, 'tcx> GatherLoanCtxt<'a, 'tcx> {\n                     ty::ReInfer(..) => {\n                         self.tcx().sess.span_bug(\n                             cmt.span,\n-                            format!(\"invalid borrow lifetime: {:?}\",\n-                                    loan_region).index(&FullRange));\n+                            &format!(\"invalid borrow lifetime: {:?}\",\n+                                    loan_region)[]);\n                     }\n                 };\n                 debug!(\"loan_scope = {:?}\", loan_scope);"}, {"sha": "a7771fefec412c4453643eee6d4b70a60d7682e0", "filename": "src/librustc_borrowck/borrowck/gather_loans/move_error.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Fmove_error.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -119,8 +119,8 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n         mc::cat_static_item => {\n             bccx.span_err(\n                 move_from.span,\n-                format!(\"cannot move out of {}\",\n-                        bccx.cmt_to_string(&*move_from)).index(&FullRange));\n+                &format!(\"cannot move out of {}\",\n+                        bccx.cmt_to_string(&*move_from))[]);\n         }\n \n         mc::cat_downcast(ref b, _) |\n@@ -130,9 +130,9 @@ fn report_cannot_move_out_of<'a, 'tcx>(bccx: &BorrowckCtxt<'a, 'tcx>,\n                 | ty::ty_enum(did, _) if ty::has_dtor(bccx.tcx, did) => {\n                     bccx.span_err(\n                         move_from.span,\n-                        format!(\"cannot move out of type `{}`, \\\n+                        &format!(\"cannot move out of type `{}`, \\\n                                  which defines the `Drop` trait\",\n-                                b.ty.user_string(bccx.tcx)).index(&FullRange));\n+                                b.ty.user_string(bccx.tcx))[]);\n                 },\n                 _ => panic!(\"this path should not cause illegal move\")\n             }\n@@ -152,13 +152,13 @@ fn note_move_destination(bccx: &BorrowckCtxt,\n             \"attempting to move value to here\");\n         bccx.span_help(\n             move_to_span,\n-            format!(\"to prevent the move, \\\n+            &format!(\"to prevent the move, \\\n                      use `ref {0}` or `ref mut {0}` to capture value by \\\n                      reference\",\n-                    pat_name).index(&FullRange));\n+                    pat_name)[]);\n     } else {\n         bccx.span_note(move_to_span,\n-                       format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n-                               pat_name).index(&FullRange));\n+                       &format!(\"and here (use `ref {0}` or `ref mut {0}`)\",\n+                               pat_name)[]);\n     }\n }"}, {"sha": "e734e8fb6ffb70c24b668becfb587d4485d4aeb1", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 28, "deletions": 28, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -137,7 +137,7 @@ fn borrowck_fn(this: &mut BorrowckCtxt,\n     check_loans::check_loans(this,\n                              &loan_dfcx,\n                              flowed_moves,\n-                             all_loans.index(&FullRange),\n+                             &all_loans[],\n                              id,\n                              decl,\n                              body);\n@@ -505,7 +505,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n     pub fn report(&self, err: BckError<'tcx>) {\n         self.span_err(\n             err.span,\n-            self.bckerr_to_string(&err).index(&FullRange));\n+            &self.bckerr_to_string(&err)[]);\n         self.note_and_explain_bckerr(err);\n     }\n \n@@ -525,9 +525,9 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             move_data::Declared => {\n                 self.tcx.sess.span_err(\n                     use_span,\n-                    format!(\"{} of possibly uninitialized variable: `{}`\",\n+                    &format!(\"{} of possibly uninitialized variable: `{}`\",\n                             verb,\n-                            self.loan_path_to_string(lp)).index(&FullRange));\n+                            self.loan_path_to_string(lp))[]);\n                 (self.loan_path_to_string(moved_lp),\n                  String::new())\n             }\n@@ -566,10 +566,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                           else { \"\" };\n                 self.tcx.sess.span_err(\n                     use_span,\n-                    format!(\"{} of {}moved value: `{}`\",\n+                    &format!(\"{} of {}moved value: `{}`\",\n                             verb,\n                             msg,\n-                            nl).index(&FullRange));\n+                            nl)[]);\n                 (ol, moved_lp_msg)\n             }\n         };\n@@ -585,32 +585,32 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(format!(\"MoveExpr({}) maps to \\\n+                        self.tcx.sess.bug(&format!(\"MoveExpr({}) maps to \\\n                                                    {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r).index(&FullRange))\n+                                                  r)[])\n                     }\n                 };\n                 let (suggestion, _) =\n                     move_suggestion(param_env, expr_span, expr_ty, (\"moved by default\", \"\"));\n                 self.tcx.sess.span_note(\n                     expr_span,\n-                    format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n+                    &format!(\"`{}` moved here{} because it has type `{}`, which is {}\",\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion).index(&FullRange));\n+                            suggestion)[]);\n             }\n \n             move_data::MovePat => {\n                 let pat_ty = ty::node_id_to_type(self.tcx, the_move.id);\n                 let span = self.tcx.map.span(the_move.id);\n                 self.tcx.sess.span_note(span,\n-                    format!(\"`{}` moved here{} because it has type `{}`, \\\n+                    &format!(\"`{}` moved here{} because it has type `{}`, \\\n                              which is moved by default\",\n                             ol,\n                             moved_lp_msg,\n-                            pat_ty.user_string(self.tcx)).index(&FullRange));\n+                            pat_ty.user_string(self.tcx))[]);\n                 self.tcx.sess.span_help(span,\n                     \"use `ref` to override\");\n             }\n@@ -623,10 +623,10 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                         (ty::expr_ty_adjusted(self.tcx, &*expr), expr.span)\n                     }\n                     r => {\n-                        self.tcx.sess.bug(format!(\"Captured({}) maps to \\\n+                        self.tcx.sess.bug(&format!(\"Captured({}) maps to \\\n                                                    {:?}, not Expr\",\n                                                   the_move.id,\n-                                                  r).index(&FullRange))\n+                                                  r)[])\n                     }\n                 };\n                 let (suggestion, help) =\n@@ -637,12 +637,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                      \"make a copy and capture that instead to override\"));\n                 self.tcx.sess.span_note(\n                     expr_span,\n-                    format!(\"`{}` moved into closure environment here{} because it \\\n+                    &format!(\"`{}` moved into closure environment here{} because it \\\n                             has type `{}`, which is {}\",\n                             ol,\n                             moved_lp_msg,\n                             expr_ty.user_string(self.tcx),\n-                            suggestion).index(&FullRange));\n+                            suggestion)[]);\n                 self.tcx.sess.span_help(expr_span, help);\n             }\n         }\n@@ -672,8 +672,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                                                 &move_data::Assignment) {\n         self.tcx.sess.span_err(\n             span,\n-            format!(\"re-assignment of immutable variable `{}`\",\n-                    self.loan_path_to_string(lp)).index(&FullRange));\n+            &format!(\"re-assignment of immutable variable `{}`\",\n+                    self.loan_path_to_string(lp))[]);\n         self.tcx.sess.span_note(assign.span, \"prior assignment occurs here\");\n     }\n \n@@ -798,8 +798,8 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             mc::AliasableOther => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in an aliasable location\",\n-                             prefix).index(&FullRange));\n+                    &format!(\"{} in an aliasable location\",\n+                             prefix)[]);\n             }\n             mc::AliasableClosure(id) => {\n                 self.tcx.sess.span_err(span,\n@@ -812,12 +812,12 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n             mc::AliasableStaticMut(..) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a static location\", prefix).index(&FullRange));\n+                    &format!(\"{} in a static location\", prefix)[]);\n             }\n             mc::AliasableBorrowed => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&` reference\", prefix).index(&FullRange));\n+                    &format!(\"{} in a `&` reference\", prefix)[]);\n             }\n         }\n \n@@ -884,13 +884,13 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 };\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"{} would have to be valid for \",\n-                            descr).index(&FullRange),\n+                    &format!(\"{} would have to be valid for \",\n+                            descr)[],\n                     loan_scope,\n                     \"...\");\n                 note_and_explain_region(\n                     self.tcx,\n-                    format!(\"...but {} is only valid for \", descr).index(&FullRange),\n+                    &format!(\"...but {} is only valid for \", descr)[],\n                     ptr_scope,\n                     \"\");\n             }\n@@ -910,7 +910,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_loan_path_to_string(&**lp_base, out);\n                 out.push_str(DOWNCAST_PRINTED_OPERATOR);\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id).index(&FullRange));\n+                out.push_str(&ty::item_path_str(self.tcx, variant_def_id)[]);\n                 out.push(')');\n             }\n \n@@ -924,7 +924,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                     }\n                     mc::PositionalField(idx) => {\n                         out.push('.');\n-                        out.push_str(idx.to_string().index(&FullRange));\n+                        out.push_str(&idx.to_string()[]);\n                     }\n                 }\n             }\n@@ -956,7 +956,7 @@ impl<'a, 'tcx> BorrowckCtxt<'a, 'tcx> {\n                 out.push('(');\n                 self.append_autoderefd_loan_path_to_string(&**lp_base, out);\n                 out.push(':');\n-                out.push_str(ty::item_path_str(self.tcx, variant_def_id).index(&FullRange));\n+                out.push_str(&ty::item_path_str(self.tcx, variant_def_id)[]);\n                 out.push(')');\n             }\n "}, {"sha": "20ad1307da3e2bbde98f72e5b639835914141500", "filename": "src/librustc_borrowck/graphviz.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fgraphviz.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -60,7 +60,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n             if seen_one { sets.push_str(\" \"); } else { seen_one = true; }\n             sets.push_str(variant.short_name());\n             sets.push_str(\": \");\n-            sets.push_str(self.dataflow_for_variant(e, n, variant).index(&FullRange));\n+            sets.push_str(&self.dataflow_for_variant(e, n, variant)[]);\n         }\n         sets\n     }\n@@ -89,7 +89,7 @@ impl<'a, 'tcx> DataflowLabeller<'a, 'tcx> {\n                 set.push_str(\", \");\n             }\n             let loan_str = self.borrowck_ctxt.loan_path_to_string(&*lp);\n-            set.push_str(loan_str.index(&FullRange));\n+            set.push_str(&loan_str[]);\n             saw_some = true;\n             true\n         });"}, {"sha": "452eaaaa52dab7bb6e4b58f46403a25b5b51e347", "filename": "src/librustc_borrowck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_borrowck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -10,6 +10,7 @@\n \n #![crate_name = \"rustc_borrowck\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\","}, {"sha": "019691c1e1027bc7c55fd914030fd21607efd77e", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -58,12 +58,12 @@ pub fn compile_input(sess: Session,\n             let outputs = build_output_filenames(input,\n                                                  outdir,\n                                                  output,\n-                                                 krate.attrs.index(&FullRange),\n+                                                 &krate.attrs[],\n                                                  &sess);\n-            let id = link::find_crate_name(Some(&sess), krate.attrs.index(&FullRange),\n+            let id = link::find_crate_name(Some(&sess), &krate.attrs[],\n                                            input);\n             let expanded_crate\n-                = match phase_2_configure_and_expand(&sess, krate, id.index(&FullRange),\n+                = match phase_2_configure_and_expand(&sess, krate, &id[],\n                                                      addl_plugins) {\n                     None => return,\n                     Some(k) => k\n@@ -75,7 +75,7 @@ pub fn compile_input(sess: Session,\n         let mut forest = ast_map::Forest::new(expanded_crate);\n         let ast_map = assign_node_ids_and_map(&sess, &mut forest);\n \n-        write_out_deps(&sess, input, &outputs, id.index(&FullRange));\n+        write_out_deps(&sess, input, &outputs, &id[]);\n \n         if stop_after_phase_2(&sess) { return; }\n \n@@ -171,9 +171,9 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n     let time_passes = sess.time_passes();\n \n     *sess.crate_types.borrow_mut() =\n-        collect_crate_types(sess, krate.attrs.index(&FullRange));\n+        collect_crate_types(sess, &krate.attrs[]);\n     *sess.crate_metadata.borrow_mut() =\n-        collect_crate_metadata(sess, krate.attrs.index(&FullRange));\n+        collect_crate_metadata(sess, &krate.attrs[]);\n \n     time(time_passes, \"recursion limit\", (), |_| {\n         middle::recursion_limit::update_recursion_limit(sess, &krate);\n@@ -268,8 +268,8 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = os::getenv(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(os::split_paths(_old_path.index(&FullRange)).into_iter());\n-                os::setenv(\"PATH\", os::join_paths(new_path.index(&FullRange)).unwrap());\n+                new_path.extend(os::split_paths(&_old_path[]).into_iter());\n+                os::setenv(\"PATH\", os::join_paths(&new_path[]).unwrap());\n             }\n             let cfg = syntax::ext::expand::ExpansionConfig {\n                 crate_name: crate_name.to_string(),\n@@ -533,7 +533,7 @@ pub fn phase_5_run_llvm_passes(sess: &Session,\n         time(sess.time_passes(), \"LLVM passes\", (), |_|\n             write::run_passes(sess,\n                               trans,\n-                              sess.opts.output_types.index(&FullRange),\n+                              &sess.opts.output_types[],\n                               outputs));\n     }\n \n@@ -547,14 +547,14 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = os::getenv(\"PATH\").unwrap_or_else(||String::new());\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(os::split_paths(old_path.index(&FullRange)).into_iter());\n-    os::setenv(\"PATH\", os::join_paths(new_path.index(&FullRange)).unwrap());\n+    new_path.extend(os::split_paths(&old_path[]).into_iter());\n+    os::setenv(\"PATH\", os::join_paths(&new_path[]).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|\n          link::link_binary(sess,\n                            trans,\n                            outputs,\n-                           trans.link.crate_name.index(&FullRange)));\n+                           &trans.link.crate_name[]));\n \n     os::setenv(\"PATH\", old_path);\n }\n@@ -643,7 +643,7 @@ fn write_out_deps(sess: &Session,\n         // write Makefile-compatible dependency rules\n         let files: Vec<String> = sess.codemap().files.borrow()\n                                    .iter().filter(|fmap| fmap.is_real_file())\n-                                   .map(|fmap| escape_dep_filename(fmap.name.index(&FullRange)))\n+                                   .map(|fmap| escape_dep_filename(&fmap.name[]))\n                                    .collect();\n         let mut file = try!(io::File::create(&deps_filename));\n         for path in out_filenames.iter() {\n@@ -656,8 +656,8 @@ fn write_out_deps(sess: &Session,\n     match result {\n         Ok(()) => {}\n         Err(e) => {\n-            sess.fatal(format!(\"error writing dependencies to `{}`: {}\",\n-                               deps_filename.display(), e).index(&FullRange));\n+            sess.fatal(&format!(\"error writing dependencies to `{}`: {}\",\n+                               deps_filename.display(), e)[]);\n         }\n     }\n }\n@@ -726,9 +726,9 @@ pub fn collect_crate_types(session: &Session,\n         let res = !link::invalid_output_for_target(session, *crate_type);\n \n         if !res {\n-            session.warn(format!(\"dropping unsupported crate type `{:?}` \\\n+            session.warn(&format!(\"dropping unsupported crate type `{:?}` \\\n                                    for target `{}`\",\n-                                 *crate_type, session.opts.target_triple).index(&FullRange));\n+                                 *crate_type, session.opts.target_triple)[]);\n         }\n \n         res"}, {"sha": "27e1eaacdfd993d2798c0ac7218269f4707c1f93", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,14 +16,17 @@\n \n #![crate_name = \"rustc_driver\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n \n extern crate arena;\n@@ -46,7 +49,7 @@ pub use syntax::diagnostic;\n \n use rustc_trans::back::link;\n use rustc::session::{config, Session, build_session};\n-use rustc::session::config::{Input, PrintRequest};\n+use rustc::session::config::{Input, PrintRequest, UnstableFeatures};\n use rustc::lint::Lint;\n use rustc::lint;\n use rustc::metadata;\n@@ -89,12 +92,12 @@ fn run_compiler(args: &[String]) {\n     let descriptions = diagnostics::registry::Registry::new(&DIAGNOSTICS);\n     match matches.opt_str(\"explain\") {\n         Some(ref code) => {\n-            match descriptions.find_description(code.index(&FullRange)) {\n+            match descriptions.find_description(&code[]) {\n                 Some(ref description) => {\n                     println!(\"{}\", description);\n                 }\n                 None => {\n-                    early_error(format!(\"no extended information for {}\", code).index(&FullRange));\n+                    early_error(&format!(\"no extended information for {}\", code)[]);\n                 }\n             }\n             return;\n@@ -120,7 +123,7 @@ fn run_compiler(args: &[String]) {\n             early_error(\"no input filename given\");\n         }\n         1u => {\n-            let ifile = matches.free[0].index(&FullRange);\n+            let ifile = &matches.free[0][];\n             if ifile == \"-\" {\n                 let contents = io::stdin().read_to_end().unwrap();\n                 let src = String::from_utf8(contents).unwrap();\n@@ -132,7 +135,11 @@ fn run_compiler(args: &[String]) {\n         _ => early_error(\"multiple input filenames provided\")\n     };\n \n+    let mut sopts = sopts;\n+    sopts.unstable_features = get_unstable_features_setting();\n+\n     let mut sess = build_session(sopts, input_file_path, descriptions);\n+\n     let cfg = config::build_configuration(&sess);\n     if print_crate_info(&sess, Some(&input), &odir, &ofile) {\n         return\n@@ -181,6 +188,21 @@ fn run_compiler(args: &[String]) {\n     driver::compile_input(sess, cfg, &input, &odir, &ofile, None);\n }\n \n+pub fn get_unstable_features_setting() -> UnstableFeatures {\n+    // Whether this is a feature-staged build, i.e. on the beta or stable channel\n+    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+    // The secret key needed to get through the rustc build itself by\n+    // subverting the unstable features lints\n+    let bootstrap_secret_key = option_env!(\"CFG_BOOTSTRAP_KEY\");\n+    // The matching key to the above, only known by the build system\n+    let bootstrap_provided_key = os::getenv(\"RUSTC_BOOTSTRAP_KEY\");\n+    match (disable_unstable_features, bootstrap_secret_key, bootstrap_provided_key) {\n+        (_, Some(ref s), Some(ref p)) if s == p => UnstableFeatures::Cheat,\n+        (true, _, _) => UnstableFeatures::Disallow,\n+        (false, _, _) => UnstableFeatures::Default\n+    }\n+}\n+\n /// Returns a version string such as \"0.12.0-dev\".\n pub fn release_str() -> Option<&'static str> {\n     option_env!(\"CFG_RELEASE\")\n@@ -297,7 +319,7 @@ Available lint options:\n         for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n-                     padded(name.index(&FullRange)), lint.default_level.as_str(), lint.desc);\n+                     padded(&name[]), lint.default_level.as_str(), lint.desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -327,7 +349,7 @@ Available lint options:\n             let desc = to.into_iter().map(|x| x.as_str().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>().connect(\", \");\n             println!(\"    {}  {}\",\n-                     padded(name.index(&FullRange)), desc);\n+                     padded(&name[]), desc);\n         }\n         println!(\"\\n\");\n     };\n@@ -393,7 +415,7 @@ pub fn handle_options(mut args: Vec<String>) -> Option<getopts::Matches> {\n     }\n \n     let matches =\n-        match getopts::getopts(args.index(&FullRange), config::optgroups().index(&FullRange)) {\n+        match getopts::getopts(&args[], &config::optgroups()[]) {\n             Ok(m) => m,\n             Err(f_stable_attempt) => {\n                 // redo option parsing, including unstable options this time,\n@@ -567,15 +589,15 @@ pub fn monitor<F:FnOnce()+Send>(f: F) {\n                     \"run with `RUST_BACKTRACE=1` for a backtrace\".to_string(),\n                 ];\n                 for note in xs.iter() {\n-                    emitter.emit(None, note.index(&FullRange), None, diagnostic::Note)\n+                    emitter.emit(None, &note[], None, diagnostic::Note)\n                 }\n \n                 match r.read_to_string() {\n                     Ok(s) => println!(\"{}\", s),\n                     Err(e) => {\n                         emitter.emit(None,\n-                                     format!(\"failed to read internal \\\n-                                              stderr: {}\", e).index(&FullRange),\n+                                     &format!(\"failed to read internal \\\n+                                              stderr: {}\", e)[],\n                                      None,\n                                      diagnostic::Error)\n                     }"}, {"sha": "7592fbc05b3383afcf52457473095e2cec1d1f27", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -294,9 +294,9 @@ impl<'tcx> pprust::PpAnn for TypedAnnotation<'tcx> {\n                 try!(pp::word(&mut s.s, \"as\"));\n                 try!(pp::space(&mut s.s));\n                 try!(pp::word(&mut s.s,\n-                              ppaux::ty_to_string(\n+                              &ppaux::ty_to_string(\n                                   tcx,\n-                                  ty::expr_ty(tcx, expr)).index(&FullRange)));\n+                                  ty::expr_ty(tcx, expr))[]));\n                 s.pclose()\n             }\n             _ => Ok(())\n@@ -350,8 +350,8 @@ impl<'a, 'ast> Iterator for NodesMatchingUII<'a, 'ast> {\n \n     fn next(&mut self) -> Option<ast::NodeId> {\n         match self {\n-            &NodesMatchingDirect(ref mut iter) => iter.next(),\n-            &NodesMatchingSuffix(ref mut iter) => iter.next(),\n+            &mut NodesMatchingDirect(ref mut iter) => iter.next(),\n+            &mut NodesMatchingSuffix(ref mut iter) => iter.next(),\n         }\n     }\n }\n@@ -370,7 +370,7 @@ impl UserIdentifiedItem {\n             ItemViaNode(node_id) =>\n                 NodesMatchingDirect(Some(node_id).into_iter()),\n             ItemViaPath(ref parts) =>\n-                NodesMatchingSuffix(map.nodes_matching_suffix(parts.index(&FullRange))),\n+                NodesMatchingSuffix(map.nodes_matching_suffix(&parts[])),\n         }\n     }\n \n@@ -382,7 +382,7 @@ impl UserIdentifiedItem {\n                         user_option,\n                         self.reconstructed_input(),\n                         is_wrong_because);\n-            sess.fatal(message.index(&FullRange))\n+            sess.fatal(&message[])\n         };\n \n         let mut saw_node = ast::DUMMY_NODE_ID;\n@@ -509,7 +509,7 @@ pub fn pretty_print_input(sess: Session,\n     let is_expanded = needs_expansion(&ppm);\n     let compute_ast_map = needs_ast_map(&ppm, &opt_uii);\n     let krate = if compute_ast_map {\n-        match driver::phase_2_configure_and_expand(&sess, krate, id.index(&FullRange), None) {\n+        match driver::phase_2_configure_and_expand(&sess, krate, &id[], None) {\n             None => return,\n             Some(k) => k\n         }\n@@ -528,7 +528,7 @@ pub fn pretty_print_input(sess: Session,\n     };\n \n     let src_name = driver::source_name(input);\n-    let src = sess.codemap().get_filemap(src_name.index(&FullRange))\n+    let src = sess.codemap().get_filemap(&src_name[])\n                             .src.as_bytes().to_vec();\n     let mut rdr = MemReader::new(src);\n \n@@ -588,16 +588,16 @@ pub fn pretty_print_input(sess: Session,\n         (PpmFlowGraph, opt_uii) => {\n             debug!(\"pretty printing flow graph for {:?}\", opt_uii);\n             let uii = opt_uii.unwrap_or_else(|| {\n-                sess.fatal(format!(\"`pretty flowgraph=..` needs NodeId (int) or\n-                                     unique path suffix (b::c::d)\").index(&FullRange))\n+                sess.fatal(&format!(\"`pretty flowgraph=..` needs NodeId (int) or\n+                                     unique path suffix (b::c::d)\")[])\n \n             });\n             let ast_map = ast_map.expect(\"--pretty flowgraph missing ast_map\");\n             let nodeid = uii.to_one_node_id(\"--pretty\", &sess, &ast_map);\n \n             let node = ast_map.find(nodeid).unwrap_or_else(|| {\n-                sess.fatal(format!(\"--pretty flowgraph couldn't find id: {}\",\n-                                   nodeid).index(&FullRange))\n+                sess.fatal(&format!(\"--pretty flowgraph couldn't find id: {}\",\n+                                   nodeid)[])\n             });\n \n             let code = blocks::Code::from_node(node);\n@@ -615,8 +615,8 @@ pub fn pretty_print_input(sess: Session,\n                     // point to what was found, if there's an\n                     // accessible span.\n                     match ast_map.opt_span(nodeid) {\n-                        Some(sp) => sess.span_fatal(sp, message.index(&FullRange)),\n-                        None => sess.fatal(message.index(&FullRange))\n+                        Some(sp) => sess.span_fatal(sp, &message[]),\n+                        None => sess.fatal(&message[])\n                     }\n                 }\n             }"}, {"sha": "a798ec9aaf76059c00087c6995507597410ac8e6", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -61,7 +61,7 @@ fn remove_message(e: &mut ExpectErrorEmitter, msg: &str, lvl: Level) {\n             e.messages.remove(i);\n         }\n         None => {\n-            panic!(\"Unexpected error: {} Expected: {}\",\n+            panic!(\"Unexpected error: {} Expected: {:?}\",\n                   msg, e.messages);\n         }\n     }\n@@ -279,7 +279,7 @@ impl<'a, 'tcx> Env<'a, 'tcx> {\n \n     pub fn t_param(&self, space: subst::ParamSpace, index: u32) -> Ty<'tcx> {\n         let name = format!(\"T{}\", index);\n-        ty::mk_param(self.infcx.tcx, space, index, token::intern(name.index(&FullRange)))\n+        ty::mk_param(self.infcx.tcx, space, index, token::intern(&name[]))\n     }\n \n     pub fn re_early_bound(&self,"}, {"sha": "4a281c413d6fc11991c1e767d6f4f62ab4cfda46", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -15,13 +15,16 @@\n \n #![crate_name = \"rustc_llvm\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(link_args)]\n+#![feature(box_syntax)]\n \n extern crate libc;\n "}, {"sha": "466bd608736ce52096ae12a3e1e12bf44b995f2c", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -219,16 +219,16 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     // had the duplicate.\n                     let ns = ns.unwrap();\n                     self.resolve_error(sp,\n-                        format!(\"duplicate definition of {} `{}`\",\n+                        &format!(\"duplicate definition of {} `{}`\",\n                              namespace_error_to_string(duplicate_type),\n-                             token::get_name(name)).index(&FullRange));\n+                             token::get_name(name))[]);\n                     {\n                         let r = child.span_for_namespace(ns);\n                         for sp in r.iter() {\n                             self.session.span_note(*sp,\n-                                 format!(\"first definition of {} `{}` here\",\n+                                 &format!(\"first definition of {} `{}` here\",\n                                       namespace_error_to_string(duplicate_type),\n-                                      token::get_name(name)).index(&FullRange));\n+                                      token::get_name(name))[]);\n                         }\n                     }\n                 }\n@@ -1200,8 +1200,8 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n             SingleImport(target, _) => {\n                 debug!(\"(building import directive) building import \\\n                         directive: {}::{}\",\n-                       self.names_to_string(module_.imports.borrow().last().unwrap()\n-                                                 .module_path.index(&FullRange)),\n+                       self.names_to_string(&module_.imports.borrow().last().unwrap().\n+                                                             module_path[]),\n                        token::get_name(target));\n \n                 let mut import_resolutions = module_.import_resolutions"}, {"sha": "a1ae96490cad7c679a4f799d014b206797d63c8d", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 79, "deletions": 76, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -10,6 +10,7 @@\n \n #![crate_name = \"rustc_resolve\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n@@ -1057,11 +1058,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     };\n                     let msg = format!(\"unresolved import `{}`{}\",\n                                       self.import_path_to_string(\n-                                          import_directive.module_path\n-                                                          .index(&FullRange),\n+                                          &import_directive.module_path[],\n                                           import_directive.subclass),\n                                       help);\n-                    self.resolve_error(span, msg.index(&FullRange));\n+                    self.resolve_error(span, &msg[]);\n                 }\n                 Indeterminate => break, // Bail out. We'll come around next time.\n                 Success(()) => () // Good. Continue.\n@@ -1091,7 +1091,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         .iter()\n                                         .map(|seg| seg.identifier.name)\n                                         .collect();\n-        self.names_to_string(names.index(&FullRange))\n+        self.names_to_string(&names[])\n     }\n \n     fn import_directive_subclass_to_string(&mut self,\n@@ -1155,7 +1155,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let module_path = &import_directive.module_path;\n \n         debug!(\"(resolving import for module) resolving import `{}::...` in `{}`\",\n-               self.names_to_string(module_path.index(&FullRange)),\n+               self.names_to_string(&module_path[]),\n                self.module_to_string(&*module_));\n \n         // First, resolve the module path for the directive, if necessary.\n@@ -1164,7 +1164,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Some((self.graph_root.get_module(), LastMod(AllPublic)))\n         } else {\n             match self.resolve_module_path(module_.clone(),\n-                                           module_path.index(&FullRange),\n+                                           &module_path[],\n                                            DontUseLexicalScope,\n                                            import_directive.span,\n                                            ImportSearch) {\n@@ -1761,7 +1761,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     ValueNS => \"value\",\n                                   },\n                                   token::get_name(name).get());\n-                self.session.span_err(import_span, msg.index(&FullRange));\n+                self.session.span_err(import_span, &msg[]);\n             }\n             Some(_) | None => {}\n         }\n@@ -1776,7 +1776,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if !name_bindings.defined_in_namespace_with(namespace, IMPORTABLE) {\n             let msg = format!(\"`{}` is not directly importable\",\n                               token::get_name(name));\n-            self.session.span_err(import_span, msg.index(&FullRange));\n+            self.session.span_err(import_span, &msg[]);\n         }\n     }\n \n@@ -1801,7 +1801,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                        crate in this module \\\n                                        (maybe you meant `use {0}::*`?)\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg.index(&FullRange));\n+                    self.session.span_err(import_span, &msg[]);\n                 }\n                 Some(_) | None => {}\n             }\n@@ -1823,7 +1823,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let msg = format!(\"import `{}` conflicts with value \\\n                                        in this module\",\n                                       token::get_name(name).get());\n-                    self.session.span_err(import_span, msg.index(&FullRange));\n+                    self.session.span_err(import_span, &msg[]);\n                     if let Some(span) = value.value_span {\n                         self.session.span_note(span,\n                                                \"conflicting value here\");\n@@ -1841,7 +1841,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                             let msg = format!(\"import `{}` conflicts with type in \\\n                                                this module\",\n                                               token::get_name(name).get());\n-                            self.session.span_err(import_span, msg.index(&FullRange));\n+                            self.session.span_err(import_span, &msg[]);\n                             if let Some(span) = ty.type_span {\n                                 self.session.span_note(span,\n                                                        \"note conflicting type here\")\n@@ -1854,7 +1854,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         let msg = format!(\"inherent implementations \\\n                                                            are only allowed on types \\\n                                                            defined in the current module\");\n-                                        self.session.span_err(span, msg.index(&FullRange));\n+                                        self.session.span_err(span, &msg[]);\n                                         self.session.span_note(import_span,\n                                                                \"import from other module here\")\n                                     }\n@@ -1863,7 +1863,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     let msg = format!(\"import `{}` conflicts with existing \\\n                                                        submodule\",\n                                                       token::get_name(name).get());\n-                                    self.session.span_err(import_span, msg.index(&FullRange));\n+                                    self.session.span_err(import_span, &msg[]);\n                                     if let Some(span) = ty.type_span {\n                                         self.session.span_note(span,\n                                                                \"note conflicting module here\")\n@@ -1891,9 +1891,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n             self.session\n                 .span_err(span,\n-                          format!(\"an external crate named `{}` has already \\\n+                          &format!(\"an external crate named `{}` has already \\\n                                    been imported into this module\",\n-                                  token::get_name(name).get()).index(&FullRange));\n+                                  token::get_name(name).get())[]);\n         }\n     }\n \n@@ -1909,10 +1909,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if module.external_module_children.borrow().contains_key(&name) {\n             self.session\n                 .span_err(span,\n-                          format!(\"the name `{}` conflicts with an external \\\n+                          &format!(\"the name `{}` conflicts with an external \\\n                                    crate that has been imported into this \\\n                                    module\",\n-                                  token::get_name(name).get()).index(&FullRange));\n+                                  token::get_name(name).get())[]);\n         }\n     }\n \n@@ -1960,7 +1960,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     let segment_name = token::get_name(name);\n                     let module_name = self.module_to_string(&*search_module);\n                     let mut span = span;\n-                    let msg = if \"???\" == module_name.index(&FullRange) {\n+                    let msg = if \"???\" == &module_name[] {\n                         span.hi = span.lo + Pos::from_uint(segment_name.get().len());\n \n                         match search_parent_externals(name,\n@@ -2073,14 +2073,14 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match module_prefix_result {\n             Failed(None) => {\n                 let mpath = self.names_to_string(module_path);\n-                let mpath = mpath.index(&FullRange);\n+                let mpath = &mpath[];\n                 match mpath.rfind(':') {\n                     Some(idx) => {\n                         let msg = format!(\"Could not find `{}` in `{}`\",\n                                             // idx +- 1 to account for the\n                                             // colons on either side\n-                                            mpath.index(&((idx + 1)..)),\n-                                            mpath.index(&(0..(idx - 1))));\n+                                            &mpath[(idx + 1)..],\n+                                            &mpath[0..(idx - 1)]);\n                         return Failed(Some((span, msg)));\n                     },\n                     None => {\n@@ -2254,8 +2254,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                               PathSearch,\n                                               true) {\n                 Failed(Some((span, msg))) =>\n-                    self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                     msg).index(&FullRange)),\n+                    self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                     msg)[]),\n                 Failed(None) => (), // Continue up the search chain.\n                 Indeterminate => {\n                     // We couldn't see through the higher scope because of an\n@@ -2515,7 +2515,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             } else {\n                 let err = format!(\"unresolved import (maybe you meant `{}::*`?)\",\n                                   sn);\n-                self.resolve_error((*imports)[index].span, err.index(&FullRange));\n+                self.resolve_error((*imports)[index].span, &err[]);\n             }\n         }\n \n@@ -2607,7 +2607,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         match def_like {\n             DlDef(d @ DefUpvar(..)) => {\n                 self.session.span_bug(span,\n-                    format!(\"unexpected {:?} in bindings\", d).index(&FullRange))\n+                    &format!(\"unexpected {:?} in bindings\", d)[])\n             }\n             DlDef(d @ DefLocal(_)) => {\n                 let node_id = d.def_id().node;\n@@ -2753,7 +2753,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         for (i, rib) in ribs.iter().enumerate().rev() {\n             match rib.bindings.get(&name).cloned() {\n                 Some(def_like) => {\n-                    return self.upvarify(ribs.index(&((i + 1)..)), def_like, span);\n+                    return self.upvarify(&ribs[(i + 1)..], def_like, span);\n                 }\n                 None => {\n                     // Continue.\n@@ -2846,7 +2846,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                             generics,\n                                             implemented_traits,\n                                             &**self_type,\n-                                            impl_items.index(&FullRange));\n+                                            &impl_items[]);\n             }\n \n             ItemTrait(_, ref generics, ref bounds, ref trait_items) => {\n@@ -2924,7 +2924,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             ItemStruct(ref struct_def, ref generics) => {\n                 self.resolve_struct(item.id,\n                                     generics,\n-                                    struct_def.fields.index(&FullRange));\n+                                    &struct_def.fields[]);\n             }\n \n             ItemMod(ref module_) => {\n@@ -2943,8 +2943,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     HasTypeParameters(\n                                         generics, FnSpace, foreign_item.id,\n                                         ItemRibKind),\n-                                    |this| visit::walk_foreign_item(this,\n-                                                                    &**foreign_item));\n+                                    |this| {\n+                                        this.resolve_type_parameters(&generics.ty_params);\n+                                        this.resolve_where_clause(&generics.where_clause);\n+                                        visit::walk_foreign_item(this, &**foreign_item)\n+                                    });\n                             }\n                             ForeignItemStatic(..) => {\n                                 visit::walk_foreign_item(this,\n@@ -2992,12 +2995,12 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n                     if seen_bindings.contains(&name) {\n                         self.resolve_error(type_parameter.span,\n-                                           format!(\"the name `{}` is already \\\n+                                           &format!(\"the name `{}` is already \\\n                                                     used for a type \\\n                                                     parameter in this type \\\n                                                     parameter list\",\n                                                    token::get_name(\n-                                                       name)).index(&FullRange))\n+                                                       name))[])\n                     }\n                     seen_bindings.insert(name);\n \n@@ -3169,7 +3172,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 };\n \n                 let msg = format!(\"attempt to {} a nonexistent trait `{}`\", usage_str, path_str);\n-                self.resolve_error(trait_reference.path.span, msg.index(&FullRange));\n+                self.resolve_error(trait_reference.path.span, &msg[]);\n             }\n             Some(def) => {\n                 match def {\n@@ -3179,16 +3182,16 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                     (def, _) => {\n                         self.resolve_error(trait_reference.path.span,\n-                                           format!(\"`{}` is not a trait\",\n+                                           &format!(\"`{}` is not a trait\",\n                                                    self.path_names_to_string(\n-                                                       &trait_reference.path)).index(&FullRange));\n+                                                       &trait_reference.path))[]);\n \n                         // If it's a typedef, give a note\n                         if let DefTy(..) = def {\n                             self.session.span_note(\n                                 trait_reference.path.span,\n-                                format!(\"`type` aliases cannot be used for traits\")\n-                                    .index(&FullRange));\n+                                &format!(\"`type` aliases cannot be used for traits\")\n+                                []);\n                         }\n                     }\n                 }\n@@ -3383,9 +3386,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             if self.trait_item_map.get(&(name, did)).is_none() {\n                 let path_str = self.path_names_to_string(&trait_ref.path);\n                 self.resolve_error(span,\n-                                    format!(\"method `{}` is not a member of trait `{}`\",\n+                                    &format!(\"method `{}` is not a member of trait `{}`\",\n                                             token::get_name(name),\n-                                            path_str).index(&FullRange));\n+                                            path_str)[]);\n             }\n         }\n     }\n@@ -3451,19 +3454,19 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                   None => {\n                     self.resolve_error(\n                         p.span,\n-                        format!(\"variable `{}` from pattern #1 is \\\n+                        &format!(\"variable `{}` from pattern #1 is \\\n                                   not bound in pattern #{}\",\n                                 token::get_name(key),\n-                                i + 1).index(&FullRange));\n+                                i + 1)[]);\n                   }\n                   Some(binding_i) => {\n                     if binding_0.binding_mode != binding_i.binding_mode {\n                         self.resolve_error(\n                             binding_i.span,\n-                            format!(\"variable `{}` is bound with different \\\n+                            &format!(\"variable `{}` is bound with different \\\n                                       mode in pattern #{} than in pattern #1\",\n                                     token::get_name(key),\n-                                    i + 1).index(&FullRange));\n+                                    i + 1)[]);\n                     }\n                   }\n                 }\n@@ -3473,10 +3476,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 if !map_0.contains_key(&key) {\n                     self.resolve_error(\n                         binding.span,\n-                        format!(\"variable `{}` from pattern {}{} is \\\n+                        &format!(\"variable `{}` from pattern {}{} is \\\n                                   not bound in pattern {}1\",\n                                 token::get_name(key),\n-                                \"#\", i + 1, \"#\").index(&FullRange));\n+                                \"#\", i + 1, \"#\")[]);\n                 }\n             }\n         }\n@@ -3591,7 +3594,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         let msg = format!(\"use of undeclared type name `{}`\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(ty.span, msg.index(&FullRange));\n+                        self.resolve_error(ty.span, &msg[]);\n                     }\n                 }\n             }\n@@ -3660,10 +3663,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                         FoundStructOrEnumVariant(..) => {\n                             self.resolve_error(\n                                 pattern.span,\n-                                format!(\"declaration of `{}` shadows an enum \\\n+                                &format!(\"declaration of `{}` shadows an enum \\\n                                          variant or unit-like struct in \\\n                                          scope\",\n-                                        token::get_name(renamed)).index(&FullRange));\n+                                        token::get_name(renamed))[]);\n                         }\n                         FoundConst(ref def, lp) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `{}` to \\\n@@ -3708,23 +3711,23 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 // Forbid duplicate bindings in the same\n                                 // parameter list.\n                                 self.resolve_error(pattern.span,\n-                                                   format!(\"identifier `{}` \\\n+                                                   &format!(\"identifier `{}` \\\n                                                             is bound more \\\n                                                             than once in \\\n                                                             this parameter \\\n                                                             list\",\n                                                            token::get_ident(\n                                                                ident))\n-                                                   .index(&FullRange))\n+                                                   [])\n                             } else if bindings_list.get(&renamed) ==\n                                     Some(&pat_id) {\n                                 // Then this is a duplicate variable in the\n                                 // same disjunction, which is an error.\n                                 self.resolve_error(pattern.span,\n-                                    format!(\"identifier `{}` is bound \\\n+                                    &format!(\"identifier `{}` is bound \\\n                                              more than once in the same \\\n                                              pattern\",\n-                                            token::get_ident(ident)).index(&FullRange));\n+                                            token::get_ident(ident))[]);\n                             }\n                             // Else, not bound in the same pattern: do\n                             // nothing.\n@@ -3787,7 +3790,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                     def: {:?}\", result);\n                             let msg = format!(\"`{}` does not name a structure\",\n                                               self.path_names_to_string(path));\n-                            self.resolve_error(path.span, msg.index(&FullRange));\n+                            self.resolve_error(path.span, &msg[]);\n                         }\n                     }\n                 }\n@@ -3848,8 +3851,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) => {\n-                        self.resolve_error(span, format!(\"failed to resolve: {}\",\n-                                                         msg).index(&FullRange));\n+                        self.resolve_error(span, &format!(\"failed to resolve: {}\",\n+                                                         msg)[]);\n                     }\n                     None => ()\n                 }\n@@ -4044,7 +4047,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let last_private;\n         let module = self.current_module.clone();\n         match self.resolve_module_path(module,\n-                                       module_path.index(&FullRange),\n+                                       &module_path[],\n                                        UseLexicalScope,\n                                        path.span,\n                                        PathSearch) {\n@@ -4058,8 +4061,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     }\n                 };\n \n-                self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg).index(&FullRange));\n+                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                 msg)[]);\n                 return None;\n             }\n             Indeterminate => panic!(\"indeterminate unexpected\"),\n@@ -4102,7 +4105,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let containing_module;\n         let last_private;\n         match self.resolve_module_path_from_root(root_module,\n-                                                 module_path.index(&FullRange),\n+                                                 &module_path[],\n                                                  0,\n                                                  path.span,\n                                                  PathSearch,\n@@ -4112,13 +4115,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     Some((span, msg)) => (span, msg),\n                     None => {\n                         let msg = format!(\"Use of undeclared module `::{}`\",\n-                                          self.names_to_string(module_path.index(&FullRange)));\n+                                          self.names_to_string(&module_path[]));\n                         (path.span, msg)\n                     }\n                 };\n \n-                self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                 msg).index(&FullRange));\n+                self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                 msg)[]);\n                 return None;\n             }\n \n@@ -4159,7 +4162,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             }\n             TypeNS => {\n                 let name = ident.name;\n-                self.search_ribs(self.type_ribs.index(&FullRange), name, span)\n+                self.search_ribs(&self.type_ribs[], name, span)\n             }\n         };\n \n@@ -4213,8 +4216,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             Failed(err) => {\n                 match err {\n                     Some((span, msg)) =>\n-                        self.resolve_error(span, format!(\"failed to resolve. {}\",\n-                                                         msg).index(&FullRange)),\n+                        self.resolve_error(span, &format!(\"failed to resolve. {}\",\n+                                                         msg)[]),\n                     None => ()\n                 }\n \n@@ -4271,7 +4274,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                name_path.index(&FullRange),\n+                                                &name_path[],\n                                                 UseLexicalScope,\n                                                 span,\n                                                 PathSearch) {\n@@ -4309,7 +4312,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let name_path = path.segments.iter().map(|seg| seg.identifier.name).collect::<Vec<_>>();\n \n         // Look for a method in the current self type's impl module.\n-        match get_module(self, path.span, name_path.index(&FullRange)) {\n+        match get_module(self, path.span, &name_path[]) {\n             Some(module) => match module.children.borrow().get(&name) {\n                 Some(binding) => {\n                     let p_str = self.path_names_to_string(&path);\n@@ -4520,7 +4523,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 def: {:?}\", result);\n                         let msg = format!(\"`{}` does not name a structure\",\n                                           self.path_names_to_string(path));\n-                        self.resolve_error(path.span, msg.index(&FullRange));\n+                        self.resolve_error(path.span, &msg[]);\n                     }\n                 }\n \n@@ -4580,8 +4583,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     None => {\n                         self.resolve_error(\n                             expr.span,\n-                            format!(\"use of undeclared label `{}`\",\n-                                    token::get_ident(label)).index(&FullRange))\n+                            &format!(\"use of undeclared label `{}`\",\n+                                    token::get_ident(label))[])\n                     }\n                     Some(DlDef(def @ DefLabel(_))) => {\n                         // Since this def is a label, it is never read.\n@@ -4716,11 +4719,11 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             // the same conclusion! - nmatsakis\n             Occupied(entry) => if def != *entry.get() {\n                 self.session\n-                    .bug(format!(\"node_id {} resolved first to {:?} and \\\n+                    .bug(&format!(\"node_id {} resolved first to {:?} and \\\n                                   then {:?}\",\n                                  node_id,\n                                  *entry.get(),\n-                                 def).index(&FullRange));\n+                                 def)[]);\n             },\n             Vacant(entry) => { entry.insert(def); },\n         }\n@@ -4734,9 +4737,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             BindByValue(_) => {}\n             BindByRef(..) => {\n                 self.resolve_error(pat.span,\n-                                   format!(\"cannot use `ref` binding mode \\\n+                                   &format!(\"cannot use `ref` binding mode \\\n                                             with {}\",\n-                                           descr).index(&FullRange));\n+                                           descr)[]);\n             }\n         }\n     }\n@@ -4771,8 +4774,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         if names.len() == 0 {\n             return \"???\".to_string();\n         }\n-        self.names_to_string(names.into_iter().rev()\n-                                  .collect::<Vec<ast::Name>>().index(&FullRange))\n+        self.names_to_string(&names.into_iter().rev()\n+                                  .collect::<Vec<ast::Name>>()[])\n     }\n \n     #[allow(dead_code)]   // useful for debugging"}, {"sha": "43f8c677e303bfd6c80476f6adde4a4c0bdf213a", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 76, "deletions": 76, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -128,7 +128,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n     let validate = |&: s: String, span: Option<Span>| {\n-        creader::validate_crate_name(sess, s.index(&FullRange), span);\n+        creader::validate_crate_name(sess, &s[], span);\n         s\n     };\n \n@@ -146,7 +146,7 @@ pub fn find_crate_name(sess: Option<&Session>,\n                     let msg = format!(\"--crate-name and #[crate_name] are \\\n                                        required to match, but `{}` != `{}`\",\n                                       s, name);\n-                    sess.span_err(attr.span, msg.index(&FullRange));\n+                    sess.span_err(attr.span, &msg[]);\n                 }\n             }\n             return validate(s.clone(), None);\n@@ -192,17 +192,17 @@ fn symbol_hash<'tcx>(tcx: &ty::ctxt<'tcx>,\n     // to be independent of one another in the crate.\n \n     symbol_hasher.reset();\n-    symbol_hasher.input_str(link_meta.crate_name.index(&FullRange));\n+    symbol_hasher.input_str(&link_meta.crate_name[]);\n     symbol_hasher.input_str(\"-\");\n     symbol_hasher.input_str(link_meta.crate_hash.as_str());\n     for meta in tcx.sess.crate_metadata.borrow().iter() {\n-        symbol_hasher.input_str(meta.index(&FullRange));\n+        symbol_hasher.input_str(&meta[]);\n     }\n     symbol_hasher.input_str(\"-\");\n-    symbol_hasher.input_str(encoder::encoded_ty(tcx, t).index(&FullRange));\n+    symbol_hasher.input_str(&encoder::encoded_ty(tcx, t)[]);\n     // Prefix with 'h' so that it never blends into adjacent digits\n     let mut hash = String::from_str(\"h\");\n-    hash.push_str(truncated_hash_result(symbol_hasher).index(&FullRange));\n+    hash.push_str(&truncated_hash_result(symbol_hasher)[]);\n     hash\n }\n \n@@ -251,7 +251,7 @@ pub fn sanitize(s: &str) -> String {\n                 let mut tstr = String::new();\n                 for c in c.escape_unicode() { tstr.push(c) }\n                 result.push('$');\n-                result.push_str(tstr.index(&(1..)));\n+                result.push_str(&tstr[1..]);\n             }\n         }\n     }\n@@ -260,7 +260,7 @@ pub fn sanitize(s: &str) -> String {\n     if result.len() > 0u &&\n         result.as_bytes()[0] != '_' as u8 &&\n         ! (result.as_bytes()[0] as char).is_xid_start() {\n-        return format!(\"_{}\", result.index(&FullRange));\n+        return format!(\"_{}\", &result[]);\n     }\n \n     return result;\n@@ -286,12 +286,12 @@ pub fn mangle<PI: Iterator<Item=PathElem>>(mut path: PI,\n \n     fn push(n: &mut String, s: &str) {\n         let sani = sanitize(s);\n-        n.push_str(format!(\"{}{}\", sani.len(), sani).index(&FullRange));\n+        n.push_str(&format!(\"{}{}\", sani.len(), sani)[]);\n     }\n \n     // First, connect each component with <len, name> pairs.\n     for e in path {\n-        push(&mut n, token::get_name(e.name()).get().index(&FullRange))\n+        push(&mut n, &token::get_name(e.name()).get()[])\n     }\n \n     match hash {\n@@ -329,17 +329,17 @@ pub fn mangle_exported_name<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, path: PathEl\n     hash.push(EXTRA_CHARS.as_bytes()[extra2] as char);\n     hash.push(EXTRA_CHARS.as_bytes()[extra3] as char);\n \n-    exported_name(path, hash.index(&FullRange))\n+    exported_name(path, &hash[])\n }\n \n pub fn mangle_internal_name_by_type_and_seq<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                                       t: Ty<'tcx>,\n                                                       name: &str) -> String {\n     let s = ppaux::ty_to_string(ccx.tcx(), t);\n-    let path = [PathName(token::intern(s.index(&FullRange))),\n+    let path = [PathName(token::intern(&s[])),\n                 gensym_name(name)];\n     let hash = get_symbol_hash(ccx, t);\n-    mangle(ast_map::Values(path.iter()), Some(hash.index(&FullRange)))\n+    mangle(ast_map::Values(path.iter()), Some(&hash[]))\n }\n \n pub fn mangle_internal_name_by_path_and_seq(path: PathElems, flav: &str) -> String {\n@@ -357,9 +357,9 @@ pub fn remove(sess: &Session, path: &Path) {\n     match fs::unlink(path) {\n         Ok(..) => {}\n         Err(e) => {\n-            sess.err(format!(\"failed to remove {}: {}\",\n+            sess.err(&format!(\"failed to remove {}: {}\",\n                              path.display(),\n-                             e).index(&FullRange));\n+                             e)[]);\n         }\n     }\n }\n@@ -373,8 +373,8 @@ pub fn link_binary(sess: &Session,\n     let mut out_filenames = Vec::new();\n     for &crate_type in sess.crate_types.borrow().iter() {\n         if invalid_output_for_target(sess, crate_type) {\n-            sess.bug(format!(\"invalid output type `{:?}` for target os `{}`\",\n-                             crate_type, sess.opts.target_triple).index(&FullRange));\n+            sess.bug(&format!(\"invalid output type `{:?}` for target os `{}`\",\n+                             crate_type, sess.opts.target_triple)[]);\n         }\n         let out_file = link_binary_output(sess, trans, crate_type, outputs,\n                                           crate_name);\n@@ -439,8 +439,8 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.rlib\", libname))\n         }\n         config::CrateTypeDylib => {\n-            let (prefix, suffix) = (sess.target.target.options.dll_prefix.index(&FullRange),\n-                                    sess.target.target.options.dll_suffix.index(&FullRange));\n+            let (prefix, suffix) = (&sess.target.target.options.dll_prefix[],\n+                                    &sess.target.target.options.dll_suffix[]);\n             out_filename.with_filename(format!(\"{}{}{}\",\n                                                prefix,\n                                                libname,\n@@ -450,7 +450,7 @@ pub fn filename_for_input(sess: &Session,\n             out_filename.with_filename(format!(\"lib{}.a\", libname))\n         }\n         config::CrateTypeExecutable => {\n-            let suffix = sess.target.target.options.exe_suffix.index(&FullRange);\n+            let suffix = &sess.target.target.options.exe_suffix[];\n             out_filename.with_filename(format!(\"{}{}\", libname, suffix))\n         }\n     }\n@@ -477,14 +477,14 @@ fn link_binary_output(sess: &Session,\n     let obj_is_writeable = is_writeable(&obj_filename);\n     let out_is_writeable = is_writeable(&out_filename);\n     if !out_is_writeable {\n-        sess.fatal(format!(\"output file {} is not writeable -- check its \\\n+        sess.fatal(&format!(\"output file {} is not writeable -- check its \\\n                             permissions.\",\n-                           out_filename.display()).index(&FullRange));\n+                           out_filename.display())[]);\n     }\n     else if !obj_is_writeable {\n-        sess.fatal(format!(\"object file {} is not writeable -- check its \\\n+        sess.fatal(&format!(\"object file {} is not writeable -- check its \\\n                             permissions.\",\n-                           obj_filename.display()).index(&FullRange));\n+                           obj_filename.display())[]);\n     }\n \n     match crate_type {\n@@ -539,7 +539,7 @@ fn link_rlib<'a>(sess: &'a Session,\n     for &(ref l, kind) in sess.cstore.get_used_libraries().borrow().iter() {\n         match kind {\n             cstore::NativeStatic => {\n-                ab.add_native_library(l.index(&FullRange)).unwrap();\n+                ab.add_native_library(&l[]).unwrap();\n             }\n             cstore::NativeFramework | cstore::NativeUnknown => {}\n         }\n@@ -586,13 +586,13 @@ fn link_rlib<'a>(sess: &'a Session,\n             // the same filename for metadata (stomping over one another)\n             let tmpdir = TempDir::new(\"rustc\").ok().expect(\"needs a temp dir\");\n             let metadata = tmpdir.path().join(METADATA_FILENAME);\n-            match fs::File::create(&metadata).write(trans.metadata\n-                                                         .index(&FullRange)) {\n+            match fs::File::create(&metadata).write(&trans.metadata\n+                                                    []) {\n                 Ok(..) => {}\n                 Err(e) => {\n-                    sess.err(format!(\"failed to write {}: {}\",\n+                    sess.err(&format!(\"failed to write {}: {}\",\n                                      metadata.display(),\n-                                     e).index(&FullRange));\n+                                     e)[]);\n                     sess.abort_if_errors();\n                 }\n             }\n@@ -610,34 +610,34 @@ fn link_rlib<'a>(sess: &'a Session,\n                 // was exactly 16 bytes.\n                 let bc_filename = obj_filename.with_extension(format!(\"{}.bc\", i).as_slice());\n                 let bc_deflated_filename = obj_filename.with_extension(\n-                    format!(\"{}.bytecode.deflate\", i).index(&FullRange));\n+                    &format!(\"{}.bytecode.deflate\", i)[]);\n \n                 let bc_data = match fs::File::open(&bc_filename).read_to_end() {\n                     Ok(buffer) => buffer,\n-                    Err(e) => sess.fatal(format!(\"failed to read bytecode: {}\",\n-                                                 e).index(&FullRange))\n+                    Err(e) => sess.fatal(&format!(\"failed to read bytecode: {}\",\n+                                                 e)[])\n                 };\n \n-                let bc_data_deflated = match flate::deflate_bytes(bc_data.index(&FullRange)) {\n+                let bc_data_deflated = match flate::deflate_bytes(&bc_data[]) {\n                     Some(compressed) => compressed,\n-                    None => sess.fatal(format!(\"failed to compress bytecode from {}\",\n-                                               bc_filename.display()).index(&FullRange))\n+                    None => sess.fatal(&format!(\"failed to compress bytecode from {}\",\n+                                               bc_filename.display())[])\n                 };\n \n                 let mut bc_file_deflated = match fs::File::create(&bc_deflated_filename) {\n                     Ok(file) => file,\n                     Err(e) => {\n-                        sess.fatal(format!(\"failed to create compressed bytecode \\\n-                                            file: {}\", e).index(&FullRange))\n+                        sess.fatal(&format!(\"failed to create compressed bytecode \\\n+                                            file: {}\", e)[])\n                     }\n                 };\n \n                 match write_rlib_bytecode_object_v1(&mut bc_file_deflated,\n                                                     bc_data_deflated.as_slice()) {\n                     Ok(()) => {}\n                     Err(e) => {\n-                        sess.err(format!(\"failed to write compressed bytecode: \\\n-                                          {}\", e).index(&FullRange));\n+                        sess.err(&format!(\"failed to write compressed bytecode: \\\n+                                          {}\", e)[]);\n                         sess.abort_if_errors()\n                     }\n                 };\n@@ -677,7 +677,7 @@ fn write_rlib_bytecode_object_v1<T: Writer>(writer: &mut T,\n     try! { writer.write(RLIB_BYTECODE_OBJECT_MAGIC) };\n     try! { writer.write_le_u32(1) };\n     try! { writer.write_le_u64(bc_data_deflated_size) };\n-    try! { writer.write(bc_data_deflated.index(&FullRange)) };\n+    try! { writer.write(&bc_data_deflated[]) };\n \n     let number_of_bytes_written_so_far =\n         RLIB_BYTECODE_OBJECT_MAGIC.len() +                // magic id\n@@ -727,12 +727,12 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n         let ref name = sess.cstore.get_crate_data(cnum).name;\n         let p = match *path {\n             Some(ref p) => p.clone(), None => {\n-                sess.err(format!(\"could not find rlib for: `{}`\",\n-                                 name).index(&FullRange));\n+                sess.err(&format!(\"could not find rlib for: `{}`\",\n+                                 name)[]);\n                 continue\n             }\n         };\n-        ab.add_rlib(&p, name.index(&FullRange), sess.lto()).unwrap();\n+        ab.add_rlib(&p, &name[], sess.lto()).unwrap();\n \n         let native_libs = csearch::get_native_libraries(&sess.cstore, cnum);\n         all_native_libs.extend(native_libs.into_iter());\n@@ -754,7 +754,7 @@ fn link_staticlib(sess: &Session, obj_filename: &Path, out_filename: &Path) {\n             cstore::NativeUnknown => \"library\",\n             cstore::NativeFramework => \"framework\",\n         };\n-        sess.note(format!(\"{}: {}\", name, *lib).index(&FullRange));\n+        sess.note(&format!(\"{}: {}\", name, *lib)[]);\n     }\n }\n \n@@ -768,12 +768,12 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n \n     // The invocations of cc share some flags across platforms\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname.index(&FullRange));\n+    let mut cmd = Command::new(&pname[]);\n \n-    cmd.args(sess.target.target.options.pre_link_args.index(&FullRange));\n+    cmd.args(&sess.target.target.options.pre_link_args[]);\n     link_args(&mut cmd, sess, dylib, tmpdir.path(),\n               trans, obj_filename, out_filename);\n-    cmd.args(sess.target.target.options.post_link_args.index(&FullRange));\n+    cmd.args(&sess.target.target.options.post_link_args[]);\n     if !sess.target.target.options.no_compiler_rt {\n         cmd.arg(\"-lcompiler-rt\");\n     }\n@@ -791,22 +791,22 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n     match prog {\n         Ok(prog) => {\n             if !prog.status.success() {\n-                sess.err(format!(\"linking with `{}` failed: {}\",\n+                sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status).index(&FullRange));\n-                sess.note(format!(\"{}\", &cmd).index(&FullRange));\n+                                 prog.status)[]);\n+                sess.note(&format!(\"{}\", &cmd)[]);\n                 let mut output = prog.error.clone();\n-                output.push_all(prog.output.index(&FullRange));\n-                sess.note(str::from_utf8(output.index(&FullRange)).unwrap());\n+                output.push_all(&prog.output[]);\n+                sess.note(str::from_utf8(&output[]).unwrap());\n                 sess.abort_if_errors();\n             }\n             debug!(\"linker stderr:\\n{}\", String::from_utf8(prog.error).unwrap());\n             debug!(\"linker stdout:\\n{}\", String::from_utf8(prog.output).unwrap());\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec the linker `{}`: {}\",\n+            sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e).index(&FullRange));\n+                             e)[]);\n             sess.abort_if_errors();\n         }\n     }\n@@ -818,7 +818,7 @@ fn link_natively(sess: &Session, trans: &CrateTranslation, dylib: bool,\n         match Command::new(\"dsymutil\").arg(out_filename).output() {\n             Ok(..) => {}\n             Err(e) => {\n-                sess.err(format!(\"failed to run dsymutil: {}\", e).index(&FullRange));\n+                sess.err(&format!(\"failed to run dsymutil: {}\", e)[]);\n                 sess.abort_if_errors();\n             }\n         }\n@@ -867,7 +867,7 @@ fn link_args(cmd: &mut Command,\n \n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(morestack.as_vec());\n-            cmd.arg(v.index(&FullRange));\n+            cmd.arg(&v[]);\n         } else {\n             cmd.args(&[\"-Wl,--whole-archive\", \"-lmorestack\", \"-Wl,--no-whole-archive\"]);\n         }\n@@ -992,7 +992,7 @@ fn link_args(cmd: &mut Command,\n             if sess.opts.cg.rpath {\n                 let mut v = \"-Wl,-install_name,@rpath/\".as_bytes().to_vec();\n                 v.push_all(out_filename.filename().unwrap());\n-                cmd.arg(v.index(&FullRange));\n+                cmd.arg(&v[]);\n             }\n         } else {\n             cmd.arg(\"-shared\");\n@@ -1004,7 +1004,7 @@ fn link_args(cmd: &mut Command,\n     // addl_lib_search_paths\n     if sess.opts.cg.rpath {\n         let sysroot = sess.sysroot();\n-        let target_triple = sess.opts.target_triple.index(&FullRange);\n+        let target_triple = &sess.opts.target_triple[];\n         let get_install_prefix_lib_path = |:| {\n             let install_prefix = option_env!(\"CFG_PREFIX\").expect(\"CFG_PREFIX\");\n             let tlib = filesearch::relative_target_lib_path(sysroot, target_triple);\n@@ -1021,14 +1021,14 @@ fn link_args(cmd: &mut Command,\n             get_install_prefix_lib_path: get_install_prefix_lib_path,\n             realpath: ::util::fs::realpath\n         };\n-        cmd.args(rpath::get_rpath_flags(rpath_config).index(&FullRange));\n+        cmd.args(&rpath::get_rpath_flags(rpath_config)[]);\n     }\n \n     // Finally add all the linker arguments provided on the command line along\n     // with any #[link_args] attributes found inside the crate\n     let empty = Vec::new();\n-    cmd.args(sess.opts.cg.link_args.as_ref().unwrap_or(&empty).index(&FullRange));\n-    cmd.args(used_link_args.index(&FullRange));\n+    cmd.args(&sess.opts.cg.link_args.as_ref().unwrap_or(&empty)[]);\n+    cmd.args(&used_link_args[]);\n }\n \n // # Native library linking\n@@ -1082,14 +1082,14 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n         } else {\n             // -force_load is the OSX equivalent of --whole-archive, but it\n             // involves passing the full path to the library to link.\n-            let lib = archive::find_library(l.index(&FullRange),\n+            let lib = archive::find_library(&l[],\n                                             sess.target.target.options.staticlib_prefix.as_slice(),\n                                             sess.target.target.options.staticlib_suffix.as_slice(),\n-                                            search_path.index(&FullRange),\n+                                            &search_path[],\n                                             &sess.diagnostic().handler);\n             let mut v = b\"-Wl,-force_load,\".to_vec();\n             v.push_all(lib.as_vec());\n-            cmd.arg(v.index(&FullRange));\n+            cmd.arg(&v[]);\n         }\n     }\n     if takes_hints {\n@@ -1102,7 +1102,7 @@ fn add_local_native_libraries(cmd: &mut Command, sess: &Session) {\n                 cmd.arg(format!(\"-l{}\", l));\n             }\n             cstore::NativeFramework => {\n-                cmd.arg(\"-framework\").arg(l.index(&FullRange));\n+                cmd.arg(\"-framework\").arg(&l[]);\n             }\n             cstore::NativeStatic => unreachable!(),\n         }\n@@ -1158,7 +1158,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n     // Converts a library file-stem into a cc -l argument\n     fn unlib<'a>(config: &config::Config, stem: &'a [u8]) -> &'a [u8] {\n         if stem.starts_with(\"lib\".as_bytes()) && !config.target.options.is_like_windows {\n-            stem.index(&(3..))\n+            &stem[3..]\n         } else {\n             stem\n         }\n@@ -1183,18 +1183,18 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n         // against the archive.\n         if sess.lto() {\n             let name = cratepath.filename_str().unwrap();\n-            let name = name.index(&(3..(name.len() - 5))); // chop off lib/.rlib\n+            let name = &name[3..(name.len() - 5)]; // chop off lib/.rlib\n             time(sess.time_passes(),\n-                 format!(\"altering {}.rlib\", name).index(&FullRange),\n+                 &format!(\"altering {}.rlib\", name)[],\n                  (), |()| {\n                 let dst = tmpdir.join(cratepath.filename().unwrap());\n                 match fs::copy(&cratepath, &dst) {\n                     Ok(..) => {}\n                     Err(e) => {\n-                        sess.err(format!(\"failed to copy {} to {}: {}\",\n+                        sess.err(&format!(\"failed to copy {} to {}: {}\",\n                                          cratepath.display(),\n                                          dst.display(),\n-                                         e).index(&FullRange));\n+                                         e)[]);\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1204,9 +1204,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                 match fs::chmod(&dst, io::USER_READ | io::USER_WRITE) {\n                     Ok(..) => {}\n                     Err(e) => {\n-                        sess.err(format!(\"failed to chmod {} when preparing \\\n+                        sess.err(&format!(\"failed to chmod {} when preparing \\\n                                           for LTO: {}\", dst.display(),\n-                                         e).index(&FullRange));\n+                                         e)[]);\n                         sess.abort_if_errors();\n                     }\n                 }\n@@ -1220,9 +1220,9 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n                     maybe_ar_prog: sess.opts.cg.ar.clone()\n                 };\n                 let mut archive = Archive::open(config);\n-                archive.remove_file(format!(\"{}.o\", name).index(&FullRange));\n+                archive.remove_file(&format!(\"{}.o\", name)[]);\n                 let files = archive.files();\n-                if files.iter().any(|s| s.index(&FullRange).ends_with(\".o\")) {\n+                if files.iter().any(|s| s[].ends_with(\".o\")) {\n                     cmd.arg(dst);\n                 }\n             });\n@@ -1244,7 +1244,7 @@ fn add_upstream_rust_crates(cmd: &mut Command, sess: &Session,\n \n         let mut v = \"-l\".as_bytes().to_vec();\n         v.push_all(unlib(&sess.target, cratepath.filestem().unwrap()));\n-        cmd.arg(v.index(&FullRange));\n+        cmd.arg(&v[]);\n     }\n }\n \n@@ -1286,7 +1286,7 @@ fn add_upstream_native_libraries(cmd: &mut Command, sess: &Session) {\n                 }\n                 cstore::NativeFramework => {\n                     cmd.arg(\"-framework\");\n-                    cmd.arg(lib.index(&FullRange));\n+                    cmd.arg(&lib[]);\n                 }\n                 cstore::NativeStatic => {\n                     sess.bug(\"statics shouldn't be propagated\");"}, {"sha": "e457de6bc771b0106e0ae84cea1fadd2d5b5d91b", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -53,30 +53,30 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n         let path = match path {\n             Some(p) => p,\n             None => {\n-                sess.fatal(format!(\"could not find rlib for: `{}`\",\n-                                   name).index(&FullRange));\n+                sess.fatal(&format!(\"could not find rlib for: `{}`\",\n+                                   name)[]);\n             }\n         };\n \n         let archive = ArchiveRO::open(&path).expect(\"wanted an rlib\");\n         let file = path.filename_str().unwrap();\n-        let file = file.index(&(3..(file.len() - 5))); // chop off lib/.rlib\n+        let file = &file[3..(file.len() - 5)]; // chop off lib/.rlib\n         debug!(\"reading {}\", file);\n         for i in iter::count(0u, 1) {\n             let bc_encoded = time(sess.time_passes(),\n                                   format!(\"check for {}.{}.bytecode.deflate\", name, i).as_slice(),\n                                   (),\n                                   |_| {\n-                                      archive.read(format!(\"{}.{}.bytecode.deflate\",\n-                                                           file, i).index(&FullRange))\n+                                      archive.read(&format!(\"{}.{}.bytecode.deflate\",\n+                                                           file, i)[])\n                                   });\n             let bc_encoded = match bc_encoded {\n                 Some(data) => data,\n                 None => {\n                     if i == 0 {\n                         // No bitcode was found at all.\n-                        sess.fatal(format!(\"missing compressed bytecode in {}\",\n-                                           path.display()).index(&FullRange));\n+                        sess.fatal(&format!(\"missing compressed bytecode in {}\",\n+                                           path.display())[]);\n                     }\n                     // No more bitcode files to read.\n                     break;\n@@ -91,20 +91,20 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     if version == 1 {\n                         // The only version existing so far\n                         let data_size = extract_compressed_bytecode_size_v1(bc_encoded);\n-                        let compressed_data = bc_encoded.index(&(\n+                        let compressed_data = &bc_encoded[\n                             link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET..\n-                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)));\n+                            (link::RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET + data_size as uint)];\n \n                         match flate::inflate_bytes(compressed_data) {\n                             Some(inflated) => inflated,\n                             None => {\n-                                sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                                   name).index(&FullRange))\n+                                sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n+                                                   name)[])\n                             }\n                         }\n                     } else {\n-                        sess.fatal(format!(\"Unsupported bytecode format version {}\",\n-                                           version).index(&FullRange))\n+                        sess.fatal(&format!(\"Unsupported bytecode format version {}\",\n+                                           version)[])\n                     }\n                 })\n             } else {\n@@ -114,8 +114,8 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n                     match flate::inflate_bytes(bc_encoded) {\n                         Some(bc) => bc,\n                         None => {\n-                            sess.fatal(format!(\"failed to decompress bc of `{}`\",\n-                                               name).index(&FullRange))\n+                            sess.fatal(&format!(\"failed to decompress bc of `{}`\",\n+                                               name)[])\n                         }\n                     }\n                 })\n@@ -124,15 +124,15 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n             let ptr = bc_decoded.as_slice().as_ptr();\n             debug!(\"linking {}, part {}\", name, i);\n             time(sess.time_passes(),\n-                 format!(\"ll link {}.{}\", name, i).index(&FullRange),\n+                 &format!(\"ll link {}.{}\", name, i)[],\n                  (),\n                  |()| unsafe {\n                 if !llvm::LLVMRustLinkInExternalBitcode(llmod,\n                                                         ptr as *const libc::c_char,\n                                                         bc_decoded.len() as libc::size_t) {\n                     write::llvm_err(sess.diagnostic().handler(),\n                                     format!(\"failed to load bc of `{}`\",\n-                                            name.index(&FullRange)));\n+                                            &name[]));\n                 }\n             });\n         }\n@@ -186,7 +186,7 @@ pub fn run(sess: &session::Session, llmod: ModuleRef,\n fn is_versioned_bytecode_format(bc: &[u8]) -> bool {\n     let magic_id_byte_count = link::RLIB_BYTECODE_OBJECT_MAGIC.len();\n     return bc.len() > magic_id_byte_count &&\n-           bc.index(&(0..magic_id_byte_count)) == link::RLIB_BYTECODE_OBJECT_MAGIC;\n+           &bc[0..magic_id_byte_count] == link::RLIB_BYTECODE_OBJECT_MAGIC;\n }\n \n fn extract_bytecode_format_version(bc: &[u8]) -> u32 {\n@@ -198,8 +198,7 @@ fn extract_compressed_bytecode_size_v1(bc: &[u8]) -> u64 {\n }\n \n fn read_from_le_bytes<T: Int>(bytes: &[u8], position_in_bytes: uint) -> T {\n-    let byte_data = bytes.index(&(position_in_bytes..\n-                                  (position_in_bytes + mem::size_of::<T>())));\n+    let byte_data = &bytes[position_in_bytes..(position_in_bytes + mem::size_of::<T>())];\n     let data = unsafe {\n         *(byte_data.as_ptr() as *const T)\n     };"}, {"sha": "e0ba6d569cc031cf7cabc5e82f85c3876635d1de", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -47,14 +47,14 @@ pub fn llvm_err(handler: &diagnostic::Handler, msg: String) -> ! {\n     unsafe {\n         let cstr = llvm::LLVMRustGetLastError();\n         if cstr == ptr::null() {\n-            handler.fatal(msg.index(&FullRange));\n+            handler.fatal(&msg[]);\n         } else {\n             let err = ffi::c_str_to_bytes(&cstr);\n             let err = String::from_utf8_lossy(err.as_slice()).to_string();\n             libc::free(cstr as *mut _);\n-            handler.fatal(format!(\"{}: {}\",\n-                                  msg.index(&FullRange),\n-                                  err.index(&FullRange)).index(&FullRange));\n+            handler.fatal(&format!(\"{}: {}\",\n+                                  &msg[],\n+                                  &err[])[]);\n         }\n     }\n }\n@@ -104,13 +104,13 @@ impl SharedEmitter {\n             match diag.code {\n                 Some(ref code) => {\n                     handler.emit_with_code(None,\n-                                           diag.msg.index(&FullRange),\n-                                           code.index(&FullRange),\n+                                           &diag.msg[],\n+                                           &code[],\n                                            diag.lvl);\n                 },\n                 None => {\n                     handler.emit(None,\n-                                 diag.msg.index(&FullRange),\n+                                 &diag.msg[],\n                                  diag.lvl);\n                 },\n             }\n@@ -165,19 +165,19 @@ fn get_llvm_opt_level(optimize: config::OptLevel) -> llvm::CodeGenOptLevel {\n \n fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let reloc_model_arg = match sess.opts.cg.relocation_model {\n-        Some(ref s) => s.index(&FullRange),\n-        None => sess.target.target.options.relocation_model.index(&FullRange)\n+        Some(ref s) => &s[],\n+        None => &sess.target.target.options.relocation_model[]\n     };\n     let reloc_model = match reloc_model_arg {\n         \"pic\" => llvm::RelocPIC,\n         \"static\" => llvm::RelocStatic,\n         \"default\" => llvm::RelocDefault,\n         \"dynamic-no-pic\" => llvm::RelocDynamicNoPic,\n         _ => {\n-            sess.err(format!(\"{:?} is not a valid relocation mode\",\n+            sess.err(&format!(\"{:?} is not a valid relocation mode\",\n                              sess.opts\n                                  .cg\n-                                 .relocation_model).index(&FullRange));\n+                                 .relocation_model)[]);\n             sess.abort_if_errors();\n             unreachable!();\n         }\n@@ -198,8 +198,8 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n     let fdata_sections = ffunction_sections;\n \n     let code_model_arg = match sess.opts.cg.code_model {\n-        Some(ref s) => s.index(&FullRange),\n-        None => sess.target.target.options.code_model.index(&FullRange)\n+        Some(ref s) => &s[],\n+        None => &sess.target.target.options.code_model[]\n     };\n \n     let code_model = match code_model_arg {\n@@ -209,16 +209,16 @@ fn create_target_machine(sess: &Session) -> TargetMachineRef {\n         \"medium\" => llvm::CodeModelMedium,\n         \"large\" => llvm::CodeModelLarge,\n         _ => {\n-            sess.err(format!(\"{:?} is not a valid code model\",\n+            sess.err(&format!(\"{:?} is not a valid code model\",\n                              sess.opts\n                                  .cg\n-                                 .code_model).index(&FullRange));\n+                                 .code_model)[]);\n             sess.abort_if_errors();\n             unreachable!();\n         }\n     };\n \n-    let triple = sess.target.target.llvm_target.index(&FullRange);\n+    let triple = &sess.target.target.llvm_target[];\n \n     let tm = unsafe {\n         let triple = CString::from_slice(triple.as_bytes());\n@@ -350,13 +350,13 @@ unsafe extern \"C\" fn inline_asm_handler(diag: SMDiagnosticRef,\n     match cgcx.lto_ctxt {\n         Some((sess, _)) => {\n             sess.codemap().with_expn_info(ExpnId::from_llvm_cookie(cookie), |info| match info {\n-                Some(ei) => sess.span_err(ei.call_site, msg.index(&FullRange)),\n-                None     => sess.err(msg.index(&FullRange)),\n+                Some(ei) => sess.span_err(ei.call_site, &msg[]),\n+                None     => sess.err(&msg[]),\n             });\n         }\n \n         None => {\n-            cgcx.handler.err(msg.index(&FullRange));\n+            cgcx.handler.err(&msg[]);\n             cgcx.handler.note(\"build without -C codegen-units for more exact errors\");\n         }\n     }\n@@ -518,14 +518,14 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n         }\n \n         if config.emit_asm {\n-            let path = output_names.with_extension(format!(\"{}.s\", name_extra).index(&FullRange));\n+            let path = output_names.with_extension(&format!(\"{}.s\", name_extra)[]);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::AssemblyFileType);\n             });\n         }\n \n         if config.emit_obj {\n-            let path = output_names.with_extension(format!(\"{}.o\", name_extra).index(&FullRange));\n+            let path = output_names.with_extension(&format!(\"{}.o\", name_extra)[]);\n             with_codegen(tm, llmod, config.no_builtins, |cpm| {\n                 write_output_file(cgcx.handler, tm, cpm, llmod, &path, llvm::ObjectFileType);\n             });\n@@ -639,7 +639,7 @@ pub fn run_passes(sess: &Session,\n \n     // Process the work items, optionally using worker threads.\n     if sess.opts.cg.codegen_units == 1 {\n-        run_work_singlethreaded(sess, trans.reachable.index(&FullRange), work_items);\n+        run_work_singlethreaded(sess, &trans.reachable[], work_items);\n     } else {\n         run_work_multithreaded(sess, work_items, sess.opts.cg.codegen_units);\n     }\n@@ -666,8 +666,8 @@ pub fn run_passes(sess: &Session,\n             if crate_output.single_output_file.is_some() {\n                 // 2) Multiple codegen units, with `-o some_name`.  We have\n                 //    no good solution for this case, so warn the user.\n-                sess.warn(format!(\"ignoring -o because multiple .{} files were produced\",\n-                                  ext).index(&FullRange));\n+                sess.warn(&format!(\"ignoring -o because multiple .{} files were produced\",\n+                                  ext)[]);\n             } else {\n                 // 3) Multiple codegen units, but no `-o some_name`.  We\n                 //    just leave the `foo.0.x` files in place.\n@@ -700,20 +700,20 @@ pub fn run_passes(sess: &Session,\n             };\n \n         let pname = get_cc_prog(sess);\n-        let mut cmd = Command::new(pname.index(&FullRange));\n+        let mut cmd = Command::new(&pname[]);\n \n-        cmd.args(sess.target.target.options.pre_link_args.index(&FullRange));\n+        cmd.args(&sess.target.target.options.pre_link_args[]);\n         cmd.arg(\"-nostdlib\");\n \n         for index in range(0, trans.modules.len()) {\n-            cmd.arg(crate_output.with_extension(format!(\"{}.o\", index).index(&FullRange)));\n+            cmd.arg(crate_output.with_extension(&format!(\"{}.o\", index)[]));\n         }\n \n         cmd.arg(\"-r\")\n            .arg(\"-o\")\n            .arg(windows_output_path.as_ref().unwrap_or(output_path));\n \n-        cmd.args(sess.target.target.options.post_link_args.index(&FullRange));\n+        cmd.args(&sess.target.target.options.post_link_args[]);\n \n         if (sess.opts.debugging_opts & config::PRINT_LINK_ARGS) != 0 {\n             println!(\"{}\", &cmd);\n@@ -725,15 +725,15 @@ pub fn run_passes(sess: &Session,\n         match cmd.status() {\n             Ok(status) => {\n                 if !status.success() {\n-                    sess.err(format!(\"linking of {} with `{}` failed\",\n-                                     output_path.display(), cmd).index(&FullRange));\n+                    sess.err(&format!(\"linking of {} with `{}` failed\",\n+                                     output_path.display(), cmd)[]);\n                     sess.abort_if_errors();\n                 }\n             },\n             Err(e) => {\n-                sess.err(format!(\"could not exec the linker `{}`: {}\",\n+                sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                                  pname,\n-                                 e).index(&FullRange));\n+                                 e)[]);\n                 sess.abort_if_errors();\n             },\n         }\n@@ -818,12 +818,12 @@ pub fn run_passes(sess: &Session,\n         for i in range(0, trans.modules.len()) {\n             if modules_config.emit_obj {\n                 let ext = format!(\"{}.o\", i);\n-                remove(sess, &crate_output.with_extension(ext.index(&FullRange)));\n+                remove(sess, &crate_output.with_extension(&ext[]));\n             }\n \n             if modules_config.emit_bc && !keep_numbered_bitcode {\n                 let ext = format!(\"{}.bc\", i);\n-                remove(sess, &crate_output.with_extension(ext.index(&FullRange)));\n+                remove(sess, &crate_output.with_extension(&ext[]));\n             }\n         }\n \n@@ -949,7 +949,7 @@ fn run_work_multithreaded(sess: &Session,\n \n pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     let pname = get_cc_prog(sess);\n-    let mut cmd = Command::new(pname.index(&FullRange));\n+    let mut cmd = Command::new(&pname[]);\n \n     cmd.arg(\"-c\").arg(\"-o\").arg(outputs.path(config::OutputTypeObject))\n                            .arg(outputs.temp_path(config::OutputTypeAssembly));\n@@ -958,20 +958,20 @@ pub fn run_assembler(sess: &Session, outputs: &OutputFilenames) {\n     match cmd.output() {\n         Ok(prog) => {\n             if !prog.status.success() {\n-                sess.err(format!(\"linking with `{}` failed: {}\",\n+                sess.err(&format!(\"linking with `{}` failed: {}\",\n                                  pname,\n-                                 prog.status).index(&FullRange));\n-                sess.note(format!(\"{}\", &cmd).index(&FullRange));\n+                                 prog.status)[]);\n+                sess.note(&format!(\"{}\", &cmd)[]);\n                 let mut note = prog.error.clone();\n-                note.push_all(prog.output.index(&FullRange));\n-                sess.note(str::from_utf8(note.index(&FullRange)).unwrap());\n+                note.push_all(&prog.output[]);\n+                sess.note(str::from_utf8(&note[]).unwrap());\n                 sess.abort_if_errors();\n             }\n         },\n         Err(e) => {\n-            sess.err(format!(\"could not exec the linker `{}`: {}\",\n+            sess.err(&format!(\"could not exec the linker `{}`: {}\",\n                              pname,\n-                             e).index(&FullRange));\n+                             e)[]);\n             sess.abort_if_errors();\n         }\n     }\n@@ -1004,7 +1004,7 @@ unsafe fn configure_llvm(sess: &Session) {\n         if sess.print_llvm_passes() { add(\"-debug-pass=Structure\"); }\n \n         for arg in sess.opts.cg.llvm_args.iter() {\n-            add((*arg).index(&FullRange));\n+            add(&(*arg)[]);\n         }\n     }\n "}, {"sha": "5da51697d2fee0d5f2abf8021ba97ab33e7a2cc1", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,14 +16,17 @@\n \n #![crate_name = \"rustc_trans\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n \n extern crate arena;"}, {"sha": "eb163ed7406f25597654631f13b9bfe80fb5fbea", "filename": "src/librustc_trans/save/mod.rs", "status": "modified", "additions": 86, "deletions": 86, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fsave%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -94,7 +94,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n \n         // dump info about all the external crates referenced from this crate\n         self.sess.cstore.iter_crate_data(|n, cmd| {\n-            self.fmt.external_crate_str(krate.span, cmd.name.index(&FullRange), n);\n+            self.fmt.external_crate_str(krate.span, &cmd.name[], n);\n         });\n         self.fmt.recorder.record(\"end_external_crates\\n\");\n     }\n@@ -143,7 +143,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.index(&FullRange),\n+                                     &qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -161,7 +161,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.index(&FullRange),\n+                                     &qualname[],\n                                      self.cur_scope);\n         }\n     }\n@@ -180,26 +180,26 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         let (ref span, ref qualname) = sub_paths[len-2];\n         self.fmt.sub_type_ref_str(path.span,\n                                   *span,\n-                                  qualname.index(&FullRange));\n+                                  &qualname[]);\n \n         // write the other sub-paths\n         if len <= 2 {\n             return;\n         }\n-        let sub_paths = sub_paths.index(&(0..(len-2)));\n+        let sub_paths = &sub_paths[0..(len-2)];\n         for &(ref span, ref qualname) in sub_paths.iter() {\n             self.fmt.sub_mod_ref_str(path.span,\n                                      *span,\n-                                     qualname.index(&FullRange),\n+                                     &qualname[],\n                                      self.cur_scope);\n         }\n     }\n \n     // looks up anything, not just a type\n     fn lookup_type_ref(&self, ref_id: NodeId) -> Option<DefId> {\n         if !self.analysis.ty_cx.def_map.borrow().contains_key(&ref_id) {\n-            self.sess.bug(format!(\"def_map has no key for {} in lookup_type_ref\",\n-                                  ref_id).index(&FullRange));\n+            self.sess.bug(&format!(\"def_map has no key for {} in lookup_type_ref\",\n+                                  ref_id)[]);\n         }\n         let def = (*self.analysis.ty_cx.def_map.borrow())[ref_id];\n         match def {\n@@ -211,8 +211,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n     fn lookup_def_kind(&self, ref_id: NodeId, span: Span) -> Option<recorder::Row> {\n         let def_map = self.analysis.ty_cx.def_map.borrow();\n         if !def_map.contains_key(&ref_id) {\n-            self.sess.span_bug(span, format!(\"def_map has no key for {} in lookup_def_kind\",\n-                                             ref_id).index(&FullRange));\n+            self.sess.span_bug(span, &format!(\"def_map has no key for {} in lookup_def_kind\",\n+                                             ref_id)[]);\n         }\n         let def = (*def_map)[ref_id];\n         match def {\n@@ -240,8 +240,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             def::DefUse(_) |\n             def::DefMethod(..) |\n             def::DefPrimTy(_) => {\n-                self.sess.span_bug(span, format!(\"lookup_def_kind for unexpected item: {:?}\",\n-                                                 def).index(&FullRange));\n+                self.sess.span_bug(span, &format!(\"lookup_def_kind for unexpected item: {:?}\",\n+                                                 def)[]);\n             },\n         }\n     }\n@@ -262,8 +262,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                     span_utils.span_for_last_ident(p.span),\n                                     id,\n                                     qualname,\n-                                    path_to_string(p).index(&FullRange),\n-                                    typ.index(&FullRange));\n+                                    &path_to_string(p)[],\n+                                    &typ[]);\n             }\n             self.collected_paths.clear();\n         }\n@@ -285,7 +285,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     match item.node {\n                         ast::ItemImpl(_, _, _, _, ref ty, _) => {\n                             let mut result = String::from_str(\"<\");\n-                            result.push_str(ty_to_string(&**ty).index(&FullRange));\n+                            result.push_str(&ty_to_string(&**ty)[]);\n \n                             match ty::trait_of_item(&self.analysis.ty_cx,\n                                                     ast_util::local_def(method.id)) {\n@@ -301,18 +301,18 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n-                                               format!(\"Container {} for method {} not an impl?\",\n-                                                       impl_id.node, method.id).index(&FullRange));\n+                                               &format!(\"Container {} for method {} not an impl?\",\n+                                                       impl_id.node, method.id)[]);\n                         },\n                     }\n                 },\n                 _ => {\n                     self.sess.span_bug(method.span,\n-                                       format!(\"Container {} for method {} is not a node item {:?}\",\n-                                               impl_id.node,\n-                                               method.id,\n-                                               self.analysis.ty_cx.map.get(impl_id.node)\n-                                              ).index(&FullRange));\n+                                       &format!(\n+                                           \"Container {} for method {} is not a node item {:?}\",\n+                                           impl_id.node,\n+                                           method.id,\n+                                           self.analysis.ty_cx.map.get(impl_id.node))[]);\n                 },\n             },\n             None => match ty::trait_of_item(&self.analysis.ty_cx,\n@@ -327,21 +327,21 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         }\n                         _ => {\n                             self.sess.span_bug(method.span,\n-                                               format!(\"Could not find container {} for method {}\",\n-                                                       def_id.node, method.id).index(&FullRange));\n+                                               &format!(\"Could not find container {} for method {}\",\n+                                                       def_id.node, method.id)[]);\n                         }\n                     }\n                 },\n                 None => {\n                     self.sess.span_bug(method.span,\n-                                       format!(\"Could not find container for method {}\",\n-                                               method.id).index(&FullRange));\n+                                       &format!(\"Could not find container for method {}\",\n+                                               method.id)[]);\n                 },\n             },\n         };\n \n         qualname.push_str(get_ident(method.pe_ident()).get());\n-        let qualname = qualname.index(&FullRange);\n+        let qualname = &qualname[];\n \n         // record the decl for this def (if it has one)\n         let decl_id = ty::trait_item_of_item(&self.analysis.ty_cx,\n@@ -430,13 +430,13 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sub_span) => self.fmt.field_str(field.span,\n                                                          Some(sub_span),\n                                                          field.node.id,\n-                                                         name.get().index(&FullRange),\n-                                                         qualname.index(&FullRange),\n-                                                         typ.index(&FullRange),\n+                                                         &name.get()[],\n+                                                         &qualname[],\n+                                                         &typ[],\n                                                          scope_id),\n                     None => self.sess.span_bug(field.span,\n-                                               format!(\"Could not find sub-span for field {}\",\n-                                                       qualname).index(&FullRange)),\n+                                               &format!(\"Could not find sub-span for field {}\",\n+                                                       qualname)[]),\n                 }\n             },\n             _ => (),\n@@ -463,7 +463,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             self.fmt.typedef_str(full_span,\n                                  Some(*param_ss),\n                                  param.id,\n-                                 name.index(&FullRange),\n+                                 &name[],\n                                  \"\");\n         }\n         self.visit_generics(generics);\n@@ -480,10 +480,10 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.fn_str(item.span,\n                         sub_span,\n                         item.id,\n-                        qualname.index(&FullRange),\n+                        &qualname[],\n                         self.cur_scope);\n \n-        self.process_formals(&decl.inputs, qualname.index(&FullRange));\n+        self.process_formals(&decl.inputs, &qualname[]);\n \n         // walk arg and return types\n         for arg in decl.inputs.iter() {\n@@ -497,7 +497,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         // walk the body\n         self.nest(item.id, |v| v.visit_block(&*body));\n \n-        self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n+        self.process_generic_params(ty_params, item.span, &qualname[], item.id);\n     }\n \n     fn process_static(&mut self,\n@@ -519,9 +519,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname.index(&FullRange),\n-                            value.index(&FullRange),\n-                            ty_to_string(&*typ).index(&FullRange),\n+                            &qualname[],\n+                            &value[],\n+                            &ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -542,9 +542,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             get_ident(item.ident).get(),\n-                            qualname.index(&FullRange),\n+                            &qualname[],\n                             \"\",\n-                            ty_to_string(&*typ).index(&FullRange),\n+                            &ty_to_string(&*typ)[],\n                             self.cur_scope);\n \n         // walk type and init value\n@@ -568,17 +568,17 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                             sub_span,\n                             item.id,\n                             ctor_id,\n-                            qualname.index(&FullRange),\n+                            &qualname[],\n                             self.cur_scope,\n-                            val.index(&FullRange));\n+                            &val[]);\n \n         // fields\n         for field in def.fields.iter() {\n-            self.process_struct_field_def(field, qualname.index(&FullRange), item.id);\n+            self.process_struct_field_def(field, &qualname[], item.id);\n             self.visit_ty(&*field.node.ty);\n         }\n \n-        self.process_generic_params(ty_params, item.span, qualname.index(&FullRange), item.id);\n+        self.process_generic_params(ty_params, item.span, &qualname[], item.id);\n     }\n \n     fn process_enum(&mut self,\n@@ -591,12 +591,12 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             Some(sub_span) => self.fmt.enum_str(item.span,\n                                                 Some(sub_span),\n                                                 item.id,\n-                                                enum_name.index(&FullRange),\n+                                                &enum_name[],\n                                                 self.cur_scope,\n-                                                val.index(&FullRange)),\n+                                                &val[]),\n             None => self.sess.span_bug(item.span,\n-                                       format!(\"Could not find subspan for enum {}\",\n-                                               enum_name).index(&FullRange)),\n+                                       &format!(\"Could not find subspan for enum {}\",\n+                                               enum_name)[]),\n         }\n         for variant in enum_definition.variants.iter() {\n             let name = get_ident(variant.node.name);\n@@ -612,9 +612,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                self.span.span_for_first_ident(variant.span),\n                                                variant.node.id,\n                                                name,\n-                                               qualname.index(&FullRange),\n-                                               enum_name.index(&FullRange),\n-                                               val.index(&FullRange),\n+                                               &qualname[],\n+                                               &enum_name[],\n+                                               &val[],\n                                                item.id);\n                     for arg in args.iter() {\n                         self.visit_ty(&*arg.ty);\n@@ -630,9 +630,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                         self.span.span_for_first_ident(variant.span),\n                         variant.node.id,\n                         ctor_id,\n-                        qualname.index(&FullRange),\n-                        enum_name.index(&FullRange),\n-                        val.index(&FullRange),\n+                        &qualname[],\n+                        &enum_name[],\n+                        &val[],\n                         item.id);\n \n                     for field in struct_def.fields.iter() {\n@@ -643,7 +643,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n             }\n         }\n \n-        self.process_generic_params(ty_params, item.span, enum_name.index(&FullRange), item.id);\n+        self.process_generic_params(ty_params, item.span, &enum_name[], item.id);\n     }\n \n     fn process_impl(&mut self,\n@@ -703,9 +703,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.trait_str(item.span,\n                            sub_span,\n                            item.id,\n-                           qualname.index(&FullRange),\n+                           &qualname[],\n                            self.cur_scope,\n-                           val.index(&FullRange));\n+                           &val[]);\n \n         // super-traits\n         for super_bound in trait_refs.iter() {\n@@ -737,7 +737,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         }\n \n         // walk generics and methods\n-        self.process_generic_params(generics, item.span, qualname.index(&FullRange), item.id);\n+        self.process_generic_params(generics, item.span, &qualname[], item.id);\n         for method in methods.iter() {\n             self.visit_trait_item(method)\n         }\n@@ -755,9 +755,9 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n         self.fmt.mod_str(item.span,\n                          sub_span,\n                          item.id,\n-                         qualname.index(&FullRange),\n+                         &qualname[],\n                          self.cur_scope,\n-                         filename.index(&FullRange));\n+                         &filename[]);\n \n         self.nest(item.id, |v| visit::walk_mod(v, m));\n     }\n@@ -840,8 +840,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                                           def_id,\n                                                           self.cur_scope),\n             _ => self.sess.span_bug(span,\n-                                    format!(\"Unexpected def kind while looking up path in '{}'\",\n-                                            self.span.snippet(span)).index(&FullRange)),\n+                                    &format!(\"Unexpected def kind while looking up path in '{}'\",\n+                                            self.span.snippet(span))[]),\n         }\n         // modules or types in the path prefix\n         match *def {\n@@ -959,7 +959,7 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                                self.cur_scope);\n \n         // walk receiver and args\n-        visit::walk_exprs(self, args.index(&FullRange));\n+        visit::walk_exprs(self, &args[]);\n     }\n \n     fn process_pat(&mut self, p:&ast::Pat) {\n@@ -975,8 +975,8 @@ impl <'l, 'tcx> DxrVisitor<'l, 'tcx> {\n                     Some(sd) => sd,\n                     None => {\n                         self.sess.span_bug(p.span,\n-                                           format!(\"Could not find struct_def for `{}`\",\n-                                                   self.span.snippet(p.span)).index(&FullRange));\n+                                           &format!(\"Could not find struct_def for `{}`\",\n+                                                   self.span.snippet(p.span))[]);\n                     }\n                 };\n                 for &Spanned { node: ref field, span } in fields.iter() {\n@@ -1061,8 +1061,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 self.fmt.typedef_str(item.span,\n                                      sub_span,\n                                      item.id,\n-                                     qualname.index(&FullRange),\n-                                     value.index(&FullRange));\n+                                     &qualname[],\n+                                     &value[]);\n \n                 self.visit_ty(&**ty);\n                 self.process_generic_params(ty_params, item.span, qualname.as_slice(), item.id);\n@@ -1121,13 +1121,13 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     },\n                     None => {\n                         self.sess.span_bug(method_type.span,\n-                                           format!(\"Could not find trait for method {}\",\n-                                                   method_type.id).index(&FullRange));\n+                                           &format!(\"Could not find trait for method {}\",\n+                                                   method_type.id)[]);\n                     },\n                 };\n \n                 qualname.push_str(get_ident(method_type.ident).get());\n-                let qualname = qualname.index(&FullRange);\n+                let qualname = &qualname[];\n \n                 let sub_span = self.span.sub_span_after_keyword(method_type.span, keywords::Fn);\n                 self.fmt.method_decl_str(method_type.span,\n@@ -1262,7 +1262,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                                           id,\n                                           cnum,\n                                           name,\n-                                          s.index(&FullRange),\n+                                          &s[],\n                                           self.cur_scope);\n             },\n         }\n@@ -1371,8 +1371,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                 }\n \n                 let mut id = String::from_str(\"$\");\n-                id.push_str(ex.id.to_string().index(&FullRange));\n-                self.process_formals(&decl.inputs, id.index(&FullRange));\n+                id.push_str(&ex.id.to_string()[]);\n+                self.process_formals(&decl.inputs, &id[]);\n \n                 // walk arg and return types\n                 for arg in decl.inputs.iter() {\n@@ -1418,8 +1418,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             let def_map = self.analysis.ty_cx.def_map.borrow();\n             if !def_map.contains_key(&id) {\n                 self.sess.span_bug(p.span,\n-                                   format!(\"def_map has no key for {} in visit_arm\",\n-                                           id).index(&FullRange));\n+                                   &format!(\"def_map has no key for {} in visit_arm\",\n+                                           id)[]);\n             }\n             let def = &(*def_map)[id];\n             match *def {\n@@ -1434,8 +1434,8 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n                     self.fmt.variable_str(p.span,\n                                           Some(p.span),\n                                           id,\n-                                          path_to_string(p).index(&FullRange),\n-                                          value.index(&FullRange),\n+                                          &path_to_string(p)[],\n+                                          &value[],\n                                           \"\")\n                 }\n                 def::DefVariant(..) => {\n@@ -1490,9 +1490,9 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DxrVisitor<'l, 'tcx> {\n             self.fmt.variable_str(p.span,\n                                   sub_span,\n                                   id,\n-                                  path_to_string(p).index(&FullRange),\n-                                  value.index(&FullRange),\n-                                  typ.index(&FullRange));\n+                                  &path_to_string(p)[],\n+                                  &value[],\n+                                  &typ[]);\n         }\n         self.collected_paths.clear();\n \n@@ -1511,7 +1511,7 @@ pub fn process_crate(sess: &Session,\n     }\n \n     assert!(analysis.glob_map.is_some());\n-    let cratename = match attr::find_crate_name(krate.attrs.index(&FullRange)) {\n+    let cratename = match attr::find_crate_name(&krate.attrs[]) {\n         Some(name) => name.get().to_string(),\n         None => {\n             info!(\"Could not find crate name, using 'unknown_crate'\");\n@@ -1531,8 +1531,8 @@ pub fn process_crate(sess: &Session,\n     };\n \n     match fs::mkdir_recursive(&root_path, io::USER_RWX) {\n-        Err(e) => sess.err(format!(\"Could not create directory {}: {}\",\n-                           root_path.display(), e).index(&FullRange)),\n+        Err(e) => sess.err(&format!(\"Could not create directory {}: {}\",\n+                           root_path.display(), e)[]),\n         _ => (),\n     }\n \n@@ -1549,7 +1549,7 @@ pub fn process_crate(sess: &Session,\n         Ok(f) => box f,\n         Err(e) => {\n             let disp = root_path.display();\n-            sess.fatal(format!(\"Could not open {}: {}\", disp, e).index(&FullRange));\n+            sess.fatal(&format!(\"Could not open {}: {}\", disp, e)[]);\n         }\n     };\n     root_path.pop();\n@@ -1575,7 +1575,7 @@ pub fn process_crate(sess: &Session,\n         cur_scope: 0\n     };\n \n-    visitor.dump_crate_info(cratename.index(&FullRange), krate);\n+    visitor.dump_crate_info(&cratename[], krate);\n \n     visit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "23598751c08d73c724f0947d6bd0c312bc361723", "filename": "src/librustc_trans/save/recorder.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fsave%2Frecorder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Frecorder.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -41,7 +41,7 @@ impl Recorder {\n         assert!(self.dump_spans);\n         let result = format!(\"span,kind,{},{},text,\\\"{}\\\"\\n\",\n                              kind, su.extent_str(span), escape(su.snippet(span)));\n-        self.record(result.index(&FullRange));\n+        self.record(&result[]);\n     }\n }\n \n@@ -158,17 +158,17 @@ impl<'a> FmtStrs<'a> {\n                            values: Vec<String>,\n                            span: Span) -> Option<String> {\n         if values.len() != fields.len() {\n-            self.span.sess.span_bug(span, format!(\n+            self.span.sess.span_bug(span, &format!(\n                 \"Mismatch between length of fields for '{}', expected '{}', found '{}'\",\n-                kind, fields.len(), values.len()).index(&FullRange));\n+                kind, fields.len(), values.len())[]);\n         }\n \n         let values = values.iter().map(|s| {\n             // Never take more than 1020 chars\n             if s.len() > 1020 {\n-                s.index(&(0..1020))\n+                &s[0..1020]\n             } else {\n-                s.index(&FullRange)\n+                &s[]\n             }\n         });\n \n@@ -184,7 +184,7 @@ impl<'a> FmtStrs<'a> {\n             }\n         )));\n         Some(strs.fold(String::new(), |mut s, ss| {\n-            s.push_str(ss.index(&FullRange));\n+            s.push_str(&ss[]);\n             s\n         }))\n     }\n@@ -196,9 +196,9 @@ impl<'a> FmtStrs<'a> {\n         let (label, ref fields, needs_span, dump_spans) = FmtStrs::lookup_row(kind);\n \n         if needs_span {\n-            self.span.sess.span_bug(span, format!(\n+            self.span.sess.span_bug(span, &format!(\n                 \"Called record_without_span for '{}' which does requires a span\",\n-                label).index(&FullRange));\n+                label)[]);\n         }\n         assert!(!dump_spans);\n \n@@ -212,9 +212,9 @@ impl<'a> FmtStrs<'a> {\n         };\n \n         let mut result = String::from_str(label);\n-        result.push_str(values_str.index(&FullRange));\n+        result.push_str(&values_str[]);\n         result.push_str(\"\\n\");\n-        self.recorder.record(result.index(&FullRange));\n+        self.recorder.record(&result[]);\n     }\n \n     pub fn record_with_span(&mut self,\n@@ -245,7 +245,7 @@ impl<'a> FmtStrs<'a> {\n             None => return,\n         };\n         let result = format!(\"{},{}{}\\n\", label, self.span.extent_str(sub_span), values_str);\n-        self.recorder.record(result.index(&FullRange));\n+        self.recorder.record(&result[]);\n     }\n \n     pub fn check_and_record(&mut self,\n@@ -275,7 +275,7 @@ impl<'a> FmtStrs<'a> {\n         // variable def's node id\n         let mut qualname = String::from_str(name);\n         qualname.push_str(\"$\");\n-        qualname.push_str(id.to_string().index(&FullRange));\n+        qualname.push_str(&id.to_string()[]);\n         self.check_and_record(Variable,\n                               span,\n                               sub_span,"}, {"sha": "77343612ac88bd0010e3ee69eda2c8a0a536f517", "filename": "src/librustc_trans/save/span_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fspan_utils.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -217,8 +217,8 @@ impl<'a> SpanUtils<'a> {\n         if bracket_count != 0 {\n             let loc = self.sess.codemap().lookup_char_pos(span.lo);\n             self.sess.span_bug(span,\n-                format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                        self.snippet(span), loc.file.name, loc.line).index(&FullRange));\n+                &format!(\"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n+                        self.snippet(span), loc.file.name, loc.line)[]);\n         }\n         if result.is_none() && prev.tok.is_ident() && bracket_count == 0 {\n             return self.make_sub_span(span, Some(prev.sp));\n@@ -242,9 +242,9 @@ impl<'a> SpanUtils<'a> {\n             if ts.tok == token::Eof {\n                 if bracket_count != 0 {\n                     let loc = self.sess.codemap().lookup_char_pos(span.lo);\n-                    self.sess.span_bug(span, format!(\n+                    self.sess.span_bug(span, &format!(\n                         \"Mis-counted brackets when breaking path? Parsing '{}' in {}, line {}\",\n-                         self.snippet(span), loc.file.name, loc.line).index(&FullRange));\n+                         self.snippet(span), loc.file.name, loc.line)[]);\n                 }\n                 return result\n             }"}, {"sha": "fc19a582db2f5d070381891f816ee0bd699eb874", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -427,7 +427,7 @@ fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n     let _indenter = indenter();\n \n     m.iter().filter_map(|br| {\n-        e(br.pats.index(&FullRange)).map(|pats| {\n+        e(&br.pats[]).map(|pats| {\n             let this = br.pats[col];\n             let mut bound_ptrs = br.bound_ptrs.clone();\n             match this.node {\n@@ -471,8 +471,8 @@ fn enter_default<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // Collect all of the matches that can match against anything.\n     enter_match(bcx, dm, m, col, val, |pats| {\n         if pat_is_binding_or_wild(dm, &*pats[col]) {\n-            let mut r = pats.index(&(0..col)).to_vec();\n-            r.push_all(pats.index(&((col + 1)..)));\n+            let mut r = pats[0..col].to_vec();\n+            r.push_all(&pats[(col + 1)..]);\n             Some(r)\n         } else {\n             None\n@@ -548,7 +548,7 @@ fn enter_opt<'a, 'p, 'blk, 'tcx>(\n         param_env: param_env,\n     };\n     enter_match(bcx, dm, m, col, val, |pats|\n-        check_match::specialize(&mcx, pats.index(&FullRange), &ctor, col, variant_size)\n+        check_match::specialize(&mcx, &pats[], &ctor, col, variant_size)\n     )\n }\n \n@@ -789,8 +789,8 @@ fn compare_values<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                -> Result<'blk, 'tcx> {\n         let did = langcall(cx,\n                            None,\n-                           format!(\"comparison of `{}`\",\n-                                   cx.ty_to_string(rhs_t)).index(&FullRange),\n+                           &format!(\"comparison of `{}`\",\n+                                   cx.ty_to_string(rhs_t))[],\n                            StrEqFnLangItem);\n         callee::trans_lang_call(cx, did, &[lhs, rhs], None)\n     }\n@@ -945,7 +945,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             if has_nested_bindings(m, col) {\n                 let expanded = expand_nested_bindings(bcx, m, col, val);\n                 compile_submatch_continue(bcx,\n-                                          expanded.index(&FullRange),\n+                                          &expanded[],\n                                           vals,\n                                           chk,\n                                           col,\n@@ -967,7 +967,7 @@ fn compile_submatch<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     bcx = compile_guard(bcx,\n                                         &**guard_expr,\n                                         m[0].data,\n-                                        m.index(&(1..m.len())),\n+                                        &m[1..m.len()],\n                                         vals,\n                                         chk,\n                                         has_genuine_default);\n@@ -990,8 +990,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n     let tcx = bcx.tcx();\n     let dm = &tcx.def_map;\n \n-    let mut vals_left = vals.index(&(0u..col)).to_vec();\n-    vals_left.push_all(vals.index(&((col + 1u)..)));\n+    let mut vals_left = vals[0u..col].to_vec();\n+    vals_left.push_all(&vals[(col + 1u)..]);\n     let ccx = bcx.fcx.ccx;\n \n     // Find a real id (we're adding placeholder wildcard patterns, but\n@@ -1191,10 +1191,10 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         }\n         let opt_ms = enter_opt(opt_cx, pat_id, dm, m, opt, col, size, val);\n         let mut opt_vals = unpacked;\n-        opt_vals.push_all(vals_left.index(&FullRange));\n+        opt_vals.push_all(&vals_left[]);\n         compile_submatch(opt_cx,\n-                         opt_ms.index(&FullRange),\n-                         opt_vals.index(&FullRange),\n+                         &opt_ms[],\n+                         &opt_vals[],\n                          branch_chk.as_ref().unwrap_or(chk),\n                          has_genuine_default);\n     }\n@@ -1213,8 +1213,8 @@ fn compile_submatch_continue<'a, 'p, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n             _ => {\n                 compile_submatch(else_cx,\n-                                 defaults.index(&FullRange),\n-                                 vals_left.index(&FullRange),\n+                                 &defaults[],\n+                                 &vals_left[],\n                                  chk,\n                                  has_genuine_default);\n             }\n@@ -1333,21 +1333,21 @@ fn create_bindings_map<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, pat: &ast::Pat,\n                                  \"__llmatch\");\n                 trmode = TrByCopy(alloca_no_lifetime(bcx,\n                                          llvariable_ty,\n-                                         bcx.ident(ident).index(&FullRange)));\n+                                         &bcx.ident(ident)[]));\n             }\n             ast::BindByValue(_) => {\n                 // in this case, the final type of the variable will be T,\n                 // but during matching we need to store a *T as explained\n                 // above\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty.ptr_to(),\n-                                 bcx.ident(ident).index(&FullRange));\n+                                 &bcx.ident(ident)[]);\n                 trmode = TrByMove;\n             }\n             ast::BindByRef(_) => {\n                 llmatch = alloca_no_lifetime(bcx,\n                                  llvariable_ty,\n-                                 bcx.ident(ident).index(&FullRange));\n+                                 &bcx.ident(ident)[]);\n                 trmode = TrByRef;\n             }\n         };\n@@ -1415,7 +1415,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         && arm.pats.last().unwrap().node == ast::PatWild(ast::PatWildSingle)\n     });\n \n-    compile_submatch(bcx, matches.index(&FullRange), &[discr_datum.val], &chk, has_default);\n+    compile_submatch(bcx, &matches[], &[discr_datum.val], &chk, has_default);\n \n     let mut arm_cxs = Vec::new();\n     for arm_data in arm_datas.iter() {\n@@ -1429,7 +1429,7 @@ fn trans_match_inner<'blk, 'tcx>(scope_cx: Block<'blk, 'tcx>,\n         arm_cxs.push(bcx);\n     }\n \n-    bcx = scope_cx.fcx.join_blocks(match_id, arm_cxs.index(&FullRange));\n+    bcx = scope_cx.fcx.join_blocks(match_id, &arm_cxs[]);\n     return bcx;\n }\n \n@@ -1582,7 +1582,7 @@ fn mk_binding_alloca<'blk, 'tcx, A, F>(bcx: Block<'blk, 'tcx>,\n     let var_ty = node_id_type(bcx, p_id);\n \n     // Allocate memory on stack for the binding.\n-    let llval = alloc_ty(bcx, var_ty, bcx.ident(*ident).index(&FullRange));\n+    let llval = alloc_ty(bcx, var_ty, &bcx.ident(*ident)[]);\n \n     // Subtle: be sure that we *populate* the memory *before*\n     // we schedule the cleanup.\n@@ -1619,8 +1619,8 @@ fn bind_irrefutable_pat<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n            pat.repr(bcx.tcx()));\n \n     if bcx.sess().asm_comments() {\n-        add_comment(bcx, format!(\"bind_irrefutable_pat(pat={})\",\n-                                 pat.repr(bcx.tcx())).index(&FullRange));\n+        add_comment(bcx, &format!(\"bind_irrefutable_pat(pat={})\",\n+                                 pat.repr(bcx.tcx()))[]);\n     }\n \n     let _indenter = indenter();"}, {"sha": "92883371ec9db815c0a2448bbd4b5dfd92a85626", "filename": "src/librustc_trans/trans/adt.rs", "status": "modified", "additions": 44, "deletions": 43, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fadt.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -51,21 +51,21 @@ use std::rc::Rc;\n use llvm::{ValueRef, True, IntEQ, IntNE};\n use back::abi::FAT_PTR_ADDR;\n use middle::subst;\n-use middle::subst::Subst;\n+use middle::ty::{self, Ty, UnboxedClosureTyper};\n+use middle::ty::Disr;\n+use syntax::ast;\n+use syntax::attr;\n+use syntax::attr::IntType;\n use trans::_match;\n use trans::build::*;\n use trans::cleanup;\n use trans::cleanup::CleanupMethods;\n use trans::common::*;\n use trans::datum;\n use trans::machine;\n+use trans::monomorphize;\n use trans::type_::Type;\n use trans::type_of;\n-use middle::ty::{self, Ty, UnboxedClosureTyper};\n-use middle::ty::Disr;\n-use syntax::ast;\n-use syntax::attr;\n-use syntax::attr::IntType;\n use util::ppaux::ty_to_string;\n \n type Hint = attr::ReprAttr;\n@@ -154,28 +154,29 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                      t: Ty<'tcx>) -> Repr<'tcx> {\n     match t.sty {\n         ty::ty_tup(ref elems) => {\n-            Univariant(mk_struct(cx, elems.index(&FullRange), false, t), false)\n+            Univariant(mk_struct(cx, &elems[], false, t), false)\n         }\n         ty::ty_struct(def_id, substs) => {\n             let fields = ty::lookup_struct_fields(cx.tcx(), def_id);\n             let mut ftys = fields.iter().map(|field| {\n-                ty::lookup_field_type(cx.tcx(), def_id, field.id, substs)\n+                let fty = ty::lookup_field_type(cx.tcx(), def_id, field.id, substs);\n+                monomorphize::normalize_associated_type(cx.tcx(), &fty)\n             }).collect::<Vec<_>>();\n             let packed = ty::lookup_packed(cx.tcx(), def_id);\n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n             if dtor { ftys.push(cx.tcx().types.bool); }\n \n-            Univariant(mk_struct(cx, ftys.index(&FullRange), packed, t), dtor)\n+            Univariant(mk_struct(cx, &ftys[], packed, t), dtor)\n         }\n         ty::ty_unboxed_closure(def_id, _, substs) => {\n             let typer = NormalizingUnboxedClosureTyper::new(cx.tcx());\n             let upvars = typer.unboxed_closure_upvars(def_id, substs).unwrap();\n             let upvar_types = upvars.iter().map(|u| u.ty).collect::<Vec<_>>();\n-            Univariant(mk_struct(cx, upvar_types.index(&FullRange), false, t), false)\n+            Univariant(mk_struct(cx, &upvar_types[], false, t), false)\n         }\n         ty::ty_enum(def_id, substs) => {\n             let cases = get_cases(cx.tcx(), def_id, substs);\n-            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id).index(&FullRange).get(0)\n+            let hint = *ty::lookup_repr_hints(cx.tcx(), def_id)[].get(0)\n                 .unwrap_or(&attr::ReprAny);\n \n             let dtor = ty::ty_dtor(cx.tcx(), def_id).has_drop_flag();\n@@ -185,7 +186,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 // (Typechecking will reject discriminant-sizing attrs.)\n                 assert_eq!(hint, attr::ReprAny);\n                 let ftys = if dtor { vec!(cx.tcx().types.bool) } else { vec!() };\n-                return Univariant(mk_struct(cx, ftys.index(&FullRange), false, t),\n+                return Univariant(mk_struct(cx, &ftys[], false, t),\n                                   dtor);\n             }\n \n@@ -205,10 +206,10 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // non-empty body, explicit discriminants should have\n             // been rejected by a checker before this point.\n             if !cases.iter().enumerate().all(|(i,c)| c.discr == (i as Disr)) {\n-                cx.sess().bug(format!(\"non-C-like enum {} with specified \\\n+                cx.sess().bug(&format!(\"non-C-like enum {} with specified \\\n                                       discriminants\",\n                                       ty::item_path_str(cx.tcx(),\n-                                                        def_id)).index(&FullRange));\n+                                                        def_id))[]);\n             }\n \n             if cases.len() == 1 {\n@@ -217,7 +218,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 assert_eq!(hint, attr::ReprAny);\n                 let mut ftys = cases[0].tys.clone();\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                return Univariant(mk_struct(cx, ftys.index(&FullRange), false, t),\n+                return Univariant(mk_struct(cx, &ftys[], false, t),\n                                   dtor);\n             }\n \n@@ -226,7 +227,7 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 let mut discr = 0;\n                 while discr < 2 {\n                     if cases[1 - discr].is_zerolen(cx, t) {\n-                        let st = mk_struct(cx, cases[discr].tys.index(&FullRange),\n+                        let st = mk_struct(cx, &cases[discr].tys[],\n                                            false, t);\n                         match cases[discr].find_ptr(cx) {\n                             Some(ref df) if df.len() == 1 && st.fields.len() == 1 => {\n@@ -316,17 +317,17 @@ fn represent_type_uncached<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n             let fields : Vec<_> = cases.iter().map(|c| {\n                 let mut ftys = vec!(ty_of_inttype(cx.tcx(), ity));\n-                ftys.push_all(c.tys.index(&FullRange));\n+                ftys.push_all(&c.tys[]);\n                 if dtor { ftys.push(cx.tcx().types.bool); }\n-                mk_struct(cx, ftys.index(&FullRange), false, t)\n+                mk_struct(cx, &ftys[], false, t)\n             }).collect();\n \n-            ensure_enum_fits_in_address_space(cx, ity, fields.index(&FullRange), t);\n+            ensure_enum_fits_in_address_space(cx, ity, &fields[], t);\n \n             General(ity, fields, dtor)\n         }\n-        _ => cx.sess().bug(format!(\"adt::represent_type called on non-ADT type: {}\",\n-                           ty_to_string(cx.tcx(), t)).index(&FullRange))\n+        _ => cx.sess().bug(&format!(\"adt::represent_type called on non-ADT type: {}\",\n+                           ty_to_string(cx.tcx(), t))[])\n     }\n }\n \n@@ -412,7 +413,7 @@ fn find_discr_field_candidate<'tcx>(tcx: &ty::ctxt<'tcx>,\n \n impl<'tcx> Case<'tcx> {\n     fn is_zerolen<'a>(&self, cx: &CrateContext<'a, 'tcx>, scapegoat: Ty<'tcx>) -> bool {\n-        mk_struct(cx, self.tys.index(&FullRange), false, scapegoat).size == 0\n+        mk_struct(cx, &self.tys[], false, scapegoat).size == 0\n     }\n \n     fn find_ptr<'a>(&self, cx: &CrateContext<'a, 'tcx>) -> Option<DiscrField> {\n@@ -432,7 +433,7 @@ fn get_cases<'tcx>(tcx: &ty::ctxt<'tcx>,\n                    -> Vec<Case<'tcx>> {\n     ty::enum_variants(tcx, def_id).iter().map(|vi| {\n         let arg_tys = vi.args.iter().map(|&raw_ty| {\n-            raw_ty.subst(tcx, substs)\n+            monomorphize::apply_param_substs(tcx, substs, &raw_ty)\n         }).collect();\n         Case { discr: vi.disr_val, tys: arg_tys }\n     }).collect()\n@@ -451,9 +452,9 @@ fn mk_struct<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n            .map(|&ty| type_of::sizing_type_of(cx, ty)).collect()\n     };\n \n-    ensure_struct_fits_in_address_space(cx, lltys.index(&FullRange), packed, scapegoat);\n+    ensure_struct_fits_in_address_space(cx, &lltys[], packed, scapegoat);\n \n-    let llty_rec = Type::struct_(cx, lltys.index(&FullRange), packed);\n+    let llty_rec = Type::struct_(cx, &lltys[], packed);\n     Struct {\n         size: machine::llsize_of_alloc(cx, llty_rec),\n         align: machine::llalign_of_min(cx, llty_rec),\n@@ -502,7 +503,7 @@ fn range_to_inttype(cx: &CrateContext, hint: Hint, bounds: &IntBounds) -> IntTyp\n             return ity;\n         }\n         attr::ReprExtern => {\n-            attempts = match cx.sess().target.target.arch.index(&FullRange) {\n+            attempts = match &cx.sess().target.target.arch[] {\n                 // WARNING: the ARM EABI has two variants; the one corresponding to `at_least_32`\n                 // appears to be used on Linux and NetBSD, but some systems may use the variant\n                 // corresponding to `choose_shortest`.  However, we don't run on those yet...?\n@@ -628,7 +629,7 @@ pub fn finish_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     match *r {\n         CEnum(..) | General(..) | RawNullablePointer { .. } => { }\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } =>\n-            llty.set_struct_body(struct_llfields(cx, st, false, false).index(&FullRange),\n+            llty.set_struct_body(&struct_llfields(cx, st, false, false)[],\n                                  st.packed)\n     }\n }\n@@ -644,7 +645,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         Univariant(ref st, _) | StructWrappedNullablePointer { nonnull: ref st, .. } => {\n             match name {\n                 None => {\n-                    Type::struct_(cx, struct_llfields(cx, st, sizing, dst).index(&FullRange),\n+                    Type::struct_(cx, &struct_llfields(cx, st, sizing, dst)[],\n                                   st.packed)\n                 }\n                 Some(name) => { assert_eq!(sizing, false); Type::named_struct(cx, name) }\n@@ -663,7 +664,7 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             // of the size.\n             //\n             // FIXME #10604: this breaks when vector types are present.\n-            let (size, align) = union_size_and_align(sts.index(&FullRange));\n+            let (size, align) = union_size_and_align(&sts[]);\n             let align_s = align as u64;\n             let discr_ty = ll_inttype(cx, ity);\n             let discr_size = machine::llsize_of_alloc(cx, discr_ty);\n@@ -684,10 +685,10 @@ fn generic_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                           Type::array(&discr_ty, align_s / discr_size - 1),\n                           fill_ty];\n             match name {\n-                None => Type::struct_(cx, fields.index(&FullRange), false),\n+                None => Type::struct_(cx, &fields[], false),\n                 Some(name) => {\n                     let mut llty = Type::named_struct(cx, name);\n-                    llty.set_struct_body(fields.index(&FullRange), false);\n+                    llty.set_struct_body(&fields[], false);\n                     llty\n                 }\n             }\n@@ -765,7 +766,7 @@ pub fn trans_get_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n \n fn struct_wrapped_nullable_bitdiscr(bcx: Block, nndiscr: Disr, discrfield: &DiscrField,\n                                     scrutinee: ValueRef) -> ValueRef {\n-    let llptrptr = GEPi(bcx, scrutinee, discrfield.index(&FullRange));\n+    let llptrptr = GEPi(bcx, scrutinee, &discrfield[]);\n     let llptr = Load(bcx, llptrptr);\n     let cmp = if nndiscr == 0 { IntEQ } else { IntNE };\n     ICmp(bcx, cmp, llptr, C_null(val_ty(llptr)))\n@@ -853,7 +854,7 @@ pub fn trans_set_discr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, r: &Repr<'tcx>,\n         }\n         StructWrappedNullablePointer { nndiscr, ref discrfield, .. } => {\n             if discr != nndiscr {\n-                let llptrptr = GEPi(bcx, val, discrfield.index(&FullRange));\n+                let llptrptr = GEPi(bcx, val, &discrfield[]);\n                 let llptrty = val_ty(llptrptr).element_type();\n                 Store(bcx, C_null(llptrty), llptrptr)\n             }\n@@ -935,7 +936,7 @@ pub fn struct_field_ptr<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, st: &Struct<'tcx>, v\n     let val = if needs_cast {\n         let ccx = bcx.ccx();\n         let fields = st.fields.iter().map(|&ty| type_of::type_of(ccx, ty)).collect::<Vec<_>>();\n-        let real_ty = Type::struct_(ccx, fields.index(&FullRange), st.packed);\n+        let real_ty = Type::struct_(ccx, &fields[], st.packed);\n         PointerCast(bcx, val, real_ty.ptr_to())\n     } else {\n         val\n@@ -967,14 +968,14 @@ pub fn fold_variants<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n             for (discr, case) in cases.iter().enumerate() {\n                 let mut variant_cx = fcx.new_temp_block(\n-                    format!(\"enum-variant-iter-{}\", discr.to_string()).index(&FullRange)\n+                    &format!(\"enum-variant-iter-{}\", &discr.to_string())[]\n                 );\n                 let rhs_val = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n                 AddCase(llswitch, rhs_val, variant_cx.llbb);\n \n                 let fields = case.fields.iter().map(|&ty|\n                     type_of::type_of(bcx.ccx(), ty)).collect::<Vec<_>>();\n-                let real_ty = Type::struct_(ccx, fields.index(&FullRange), case.packed);\n+                let real_ty = Type::struct_(ccx, &fields[], case.packed);\n                 let variant_value = PointerCast(variant_cx, value, real_ty.ptr_to());\n \n                 variant_cx = f(variant_cx, case, variant_value);\n@@ -1051,14 +1052,14 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n             let lldiscr = C_integral(ll_inttype(ccx, ity), discr as u64, true);\n             let mut f = vec![lldiscr];\n             f.push_all(vals);\n-            let mut contents = build_const_struct(ccx, case, f.index(&FullRange));\n+            let mut contents = build_const_struct(ccx, case, &f[]);\n             contents.push_all(&[padding(ccx, max_sz - case.size)]);\n-            C_struct(ccx, contents.index(&FullRange), false)\n+            C_struct(ccx, &contents[], false)\n         }\n         Univariant(ref st, _dro) => {\n             assert!(discr == 0);\n             let contents = build_const_struct(ccx, st, vals);\n-            C_struct(ccx, contents.index(&FullRange), st.packed)\n+            C_struct(ccx, &contents[], st.packed)\n         }\n         RawNullablePointer { nndiscr, nnty, .. } => {\n             if discr == nndiscr {\n@@ -1070,19 +1071,19 @@ pub fn trans_const<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, r: &Repr<'tcx>, discr\n         }\n         StructWrappedNullablePointer { ref nonnull, nndiscr, .. } => {\n             if discr == nndiscr {\n-                C_struct(ccx, build_const_struct(ccx,\n+                C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals).index(&FullRange),\n+                                                 vals)[],\n                          false)\n             } else {\n                 let vals = nonnull.fields.iter().map(|&ty| {\n                     // Always use null even if it's not the `discrfield`th\n                     // field; see #8506.\n                     C_null(type_of::sizing_type_of(ccx, ty))\n                 }).collect::<Vec<ValueRef>>();\n-                C_struct(ccx, build_const_struct(ccx,\n+                C_struct(ccx, &build_const_struct(ccx,\n                                                  nonnull,\n-                                                 vals.index(&FullRange)).index(&FullRange),\n+                                                 &vals[])[],\n                          false)\n             }\n         }"}, {"sha": "9b6fa32405ffb9c2247318779d675967f65a67a2", "filename": "src/librustc_trans/trans/asm.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fasm.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -71,7 +71,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n                                     callee::DontAutorefArg)\n         })\n     }).collect::<Vec<_>>();\n-    inputs.push_all(ext_inputs.index(&FullRange));\n+    inputs.push_all(&ext_inputs[]);\n \n     // no failure occurred preparing operands, no need to cleanup\n     fcx.pop_custom_cleanup_scope(temp_scope);\n@@ -91,18 +91,18 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n         if !clobbers.is_empty() {\n             clobbers.push(',');\n         }\n-        clobbers.push_str(more_clobbers.index(&FullRange));\n+        clobbers.push_str(&more_clobbers[]);\n     }\n \n     // Add the clobbers to our constraints list\n     if clobbers.len() != 0 && constraints.len() != 0 {\n         constraints.push(',');\n-        constraints.push_str(clobbers.index(&FullRange));\n+        constraints.push_str(&clobbers[]);\n     } else {\n-        constraints.push_str(clobbers.index(&FullRange));\n+        constraints.push_str(&clobbers[]);\n     }\n \n-    debug!(\"Asm Constraints: {}\", constraints.index(&FullRange));\n+    debug!(\"Asm Constraints: {}\", &constraints[]);\n \n     let num_outputs = outputs.len();\n \n@@ -112,7 +112,7 @@ pub fn trans_inline_asm<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, ia: &ast::InlineAsm)\n     } else if num_outputs == 1 {\n         output_types[0]\n     } else {\n-        Type::struct_(bcx.ccx(), output_types.index(&FullRange), false)\n+        Type::struct_(bcx.ccx(), &output_types[], false)\n     };\n \n     let dialect = match ia.dialect {"}, {"sha": "74071a1de4c3d080c797133c0db7a5d1577a1342", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 71, "deletions": 63, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -249,7 +249,7 @@ fn get_extern_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<'tcx>,\n     let f = decl_rust_fn(ccx, fn_ty, name);\n \n     csearch::get_item_attrs(&ccx.sess().cstore, did, |attrs| {\n-        set_llvm_fn_attrs(ccx, attrs.index(&FullRange), f)\n+        set_llvm_fn_attrs(ccx, &attrs[], f)\n     });\n \n     ccx.externs().borrow_mut().insert(name.to_string(), f);\n@@ -281,8 +281,15 @@ pub fn kind_for_unboxed_closure(ccx: &CrateContext, closure_id: ast::DefId)\n \n pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                               fn_ty: Ty<'tcx>, name: &str) -> ValueRef {\n+    debug!(\"decl_rust_fn(fn_ty={}, name={:?})\",\n+           fn_ty.repr(ccx.tcx()),\n+           name);\n+\n     let fn_ty = monomorphize::normalize_associated_type(ccx.tcx(), &fn_ty);\n \n+    debug!(\"decl_rust_fn: fn_ty={} (after normalized associated types)\",\n+           fn_ty.repr(ccx.tcx()));\n+\n     let function_type; // placeholder so that the memory ownership works out ok\n \n     let (sig, abi, env) = match fn_ty.sty {\n@@ -305,10 +312,12 @@ pub fn decl_rust_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let sig = ty::erase_late_bound_regions(ccx.tcx(), sig);\n     let sig = ty::Binder(sig);\n \n+    debug!(\"decl_rust_fn: sig={} (after erasing regions)\",\n+           sig.repr(ccx.tcx()));\n+\n     let llfty = type_of_rust_fn(ccx, env, &sig, abi);\n \n-    debug!(\"decl_rust_fn(sig={}, type={})\",\n-           sig.repr(ccx.tcx()),\n+    debug!(\"decl_rust_fn: llfty={}\",\n            ccx.tn().type_to_string(llfty));\n \n     let llfn = decl_fn(ccx, name, llvm::CCallConv, llfty, sig.0.output /* (1) */);\n@@ -372,9 +381,9 @@ fn require_alloc_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     match bcx.tcx().lang_items.require(it) {\n         Ok(id) => id,\n         Err(s) => {\n-            bcx.sess().fatal(format!(\"allocation of `{}` {}\",\n+            bcx.sess().fatal(&format!(\"allocation of `{}` {}\",\n                                      bcx.ty_to_string(info_ty),\n-                                     s).index(&FullRange));\n+                                     s)[]);\n         }\n     }\n }\n@@ -493,7 +502,7 @@ pub fn unset_split_stack(f: ValueRef) {\n // silently mangles such symbols, breaking our linkage model.\n pub fn note_unique_llvm_symbol(ccx: &CrateContext, sym: String) {\n     if ccx.all_llvm_symbols().borrow().contains(&sym) {\n-        ccx.sess().bug(format!(\"duplicate LLVM symbol: {}\", sym).index(&FullRange));\n+        ccx.sess().bug(&format!(\"duplicate LLVM symbol: {}\", sym)[]);\n     }\n     ccx.all_llvm_symbols().borrow_mut().insert(sym);\n }\n@@ -530,7 +539,7 @@ pub fn get_res_dtor<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      ty::mk_nil(ccx.tcx()));\n         get_extern_fn(ccx,\n                       &mut *ccx.externs().borrow_mut(),\n-                      name.index(&FullRange),\n+                      &name[],\n                       llvm::CCallConv,\n                       llty,\n                       dtor_ty)\n@@ -778,9 +787,9 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n                   for variant in (*variants).iter() {\n                       let variant_cx =\n                           fcx.new_temp_block(\n-                              format!(\"enum-iter-variant-{}\",\n-                                      variant.disr_val.to_string().index(&FullRange))\n-                                     .index(&FullRange));\n+                              &format!(\"enum-iter-variant-{}\",\n+                                      &variant.disr_val.to_string()[])\n+                              []);\n                       match adt::trans_case(cx, &*repr, variant.disr_val) {\n                           _match::SingleResult(r) => {\n                               AddCase(llswitch, r.val, variant_cx.llbb)\n@@ -804,8 +813,8 @@ pub fn iter_structural_ty<'blk, 'tcx, F>(cx: Block<'blk, 'tcx>,\n           }\n       }\n       _ => {\n-          cx.sess().unimpl(format!(\"type in iter_structural_ty: {}\",\n-                                   ty_to_string(cx.tcx(), t)).index(&FullRange))\n+          cx.sess().unimpl(&format!(\"type in iter_structural_ty: {}\",\n+                                   ty_to_string(cx.tcx(), t))[])\n       }\n     }\n     return cx;\n@@ -886,8 +895,8 @@ pub fn fail_if_zero_or_overflows<'blk, 'tcx>(\n             (ICmp(cx, llvm::IntEQ, rhs, zero), false)\n         }\n         _ => {\n-            cx.sess().bug(format!(\"fail-if-zero on unexpected type: {}\",\n-                                  ty_to_string(cx.tcx(), rhs_t)).index(&FullRange));\n+            cx.sess().bug(&format!(\"fail-if-zero on unexpected type: {}\",\n+                                  ty_to_string(cx.tcx(), rhs_t))[]);\n         }\n     };\n     let bcx = with_cond(cx, is_zero, |bcx| {\n@@ -941,14 +950,14 @@ pub fn trans_external_path<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ty::ty_bare_fn(_, ref fn_ty) => {\n             match ccx.sess().target.target.adjust_abi(fn_ty.abi) {\n                 Rust | RustCall => {\n-                    get_extern_rust_fn(ccx, t, name.index(&FullRange), did)\n+                    get_extern_rust_fn(ccx, t, &name[], did)\n                 }\n                 RustIntrinsic => {\n                     ccx.sess().bug(\"unexpected intrinsic in trans_external_path\")\n                 }\n                 _ => {\n                     foreign::register_foreign_item_fn(ccx, fn_ty.abi, t,\n-                                                      name.index(&FullRange))\n+                                                      &name[])\n                 }\n             }\n         }\n@@ -995,7 +1004,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n         let llresult = Invoke(bcx,\n                               llfn,\n-                              llargs.index(&FullRange),\n+                              &llargs[],\n                               normal_bcx.llbb,\n                               landing_pad,\n                               Some(attributes));\n@@ -1011,7 +1020,7 @@ pub fn invoke<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             None => debuginfo::clear_source_location(bcx.fcx)\n         };\n \n-        let llresult = Call(bcx, llfn, llargs.index(&FullRange), Some(attributes));\n+        let llresult = Call(bcx, llfn, &llargs[], Some(attributes));\n         return (llresult, bcx);\n     }\n }\n@@ -1128,7 +1137,7 @@ pub fn call_lifetime_end(cx: Block, ptr: ValueRef) {\n pub fn call_memcpy(cx: Block, dst: ValueRef, src: ValueRef, n_bytes: ValueRef, align: u32) {\n     let _icx = push_ctxt(\"call_memcpy\");\n     let ccx = cx.ccx();\n-    let key = match ccx.sess().target.target.target_word_size.index(&FullRange) {\n+    let key = match &ccx.sess().target.target.target_pointer_width[] {\n         \"32\" => \"llvm.memcpy.p0i8.p0i8.i32\",\n         \"64\" => \"llvm.memcpy.p0i8.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memcpy: {}\", tws),\n@@ -1175,7 +1184,7 @@ fn memzero<'a, 'tcx>(b: &Builder<'a, 'tcx>, llptr: ValueRef, ty: Ty<'tcx>) {\n \n     let llty = type_of::type_of(ccx, ty);\n \n-    let intrinsic_key = match ccx.sess().target.target.target_word_size.index(&FullRange) {\n+    let intrinsic_key = match &ccx.sess().target.target.target_pointer_width[] {\n         \"32\" => \"llvm.memset.p0i8.i32\",\n         \"64\" => \"llvm.memset.p0i8.i64\",\n         tws => panic!(\"Unsupported target word size for memset: {}\", tws),\n@@ -1663,7 +1672,7 @@ fn copy_unboxed_closure_args_to_allocas<'blk, 'tcx>(\n                                                          \"argtuple\",\n                                                          arg_scope_id));\n     let untupled_arg_types = match monomorphized_arg_types[0].sty {\n-        ty::ty_tup(ref types) => types.index(&FullRange),\n+        ty::ty_tup(ref types) => &types[],\n         _ => {\n             bcx.tcx().sess.span_bug(args[0].pat.span,\n                                     \"first arg to `rust-call` ABI function \\\n@@ -1851,29 +1860,29 @@ pub fn trans_closure<'a, 'b, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let arg_datums = if abi != RustCall {\n         create_datums_for_fn_args(&fcx,\n-                                  monomorphized_arg_types.index(&FullRange))\n+                                  &monomorphized_arg_types[])\n     } else {\n         create_datums_for_fn_args_under_call_abi(\n             bcx,\n             arg_scope,\n-            monomorphized_arg_types.index(&FullRange))\n+            &monomorphized_arg_types[])\n     };\n \n     bcx = match closure_env.kind {\n         closure::NotClosure | closure::BoxedClosure(..) => {\n             copy_args_to_allocas(&fcx,\n                                  arg_scope,\n                                  bcx,\n-                                 decl.inputs.index(&FullRange),\n+                                 &decl.inputs[],\n                                  arg_datums)\n         }\n         closure::UnboxedClosure(..) => {\n             copy_unboxed_closure_args_to_allocas(\n                 bcx,\n                 arg_scope,\n-                decl.inputs.index(&FullRange),\n+                &decl.inputs[],\n                 arg_datums,\n-                monomorphized_arg_types.index(&FullRange))\n+                &monomorphized_arg_types[])\n         }\n     };\n \n@@ -1990,9 +1999,9 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             ty::erase_late_bound_regions(bcx.tcx(), &bft.sig.output()).unwrap()\n         }\n         _ => ccx.sess().bug(\n-            format!(\"trans_enum_variant_constructor: \\\n+            &format!(\"trans_enum_variant_constructor: \\\n                      unexpected ctor return type {}\",\n-                     ctor_ty.repr(tcx)).index(&FullRange))\n+                     ctor_ty.repr(tcx))[])\n     };\n \n     // Get location to store the result. If the user does not care about\n@@ -2015,7 +2024,7 @@ pub fn trans_named_tuple_constructor<'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 bcx = expr::trans_adt(bcx,\n                                       result_ty,\n                                       disr,\n-                                      fields.index(&FullRange),\n+                                      &fields[],\n                                       None,\n                                       expr::SaveIn(llresult),\n                                       call_info);\n@@ -2064,9 +2073,9 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n             ty::erase_late_bound_regions(ccx.tcx(), &bft.sig.output())\n         }\n         _ => ccx.sess().bug(\n-            format!(\"trans_enum_variant_or_tuple_like_struct: \\\n+            &format!(\"trans_enum_variant_or_tuple_like_struct: \\\n                      unexpected ctor return type {}\",\n-                    ty_to_string(ccx.tcx(), ctor_ty)).index(&FullRange))\n+                    ty_to_string(ccx.tcx(), ctor_ty))[])\n     };\n \n     let arena = TypedArena::new();\n@@ -2080,7 +2089,7 @@ fn trans_enum_variant_or_tuple_like_struct<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx\n         ty::erase_late_bound_regions(\n             ccx.tcx(), &ty::ty_fn_args(ctor_ty));\n \n-    let arg_datums = create_datums_for_fn_args(&fcx, arg_tys.index(&FullRange));\n+    let arg_datums = create_datums_for_fn_args(&fcx, &arg_tys[]);\n \n     if !type_is_zero_size(fcx.ccx, result_ty.unwrap()) {\n         let dest = fcx.get_ret_slot(bcx, result_ty, \"eret_slot\");\n@@ -2164,9 +2173,9 @@ fn enum_variant_size_lint(ccx: &CrateContext, enum_def: &ast::EnumDef, sp: Span,\n         // pass for the latter already ran.\n         lint::raw_emit_lint(&ccx.tcx().sess, lint::builtin::VARIANT_SIZE_DIFFERENCES,\n                             *lvlsrc.unwrap(), Some(sp),\n-                            format!(\"enum variant is more than three times larger \\\n+                            &format!(\"enum variant is more than three times larger \\\n                                      ({} bytes) than the next largest (ignoring padding)\",\n-                                    largest).index(&FullRange));\n+                                    largest)[]);\n \n         ccx.sess().span_note(enum_def.variants[largest_index].span,\n                              \"this variant is the largest\");\n@@ -2284,7 +2293,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     match item.node {\n       ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n-            let trans_everywhere = attr::requests_inline(item.attrs.index(&FullRange));\n+            let trans_everywhere = attr::requests_inline(&item.attrs[]);\n             // Ignore `trans_everywhere` for cross-crate inlined items\n             // (`from_external`).  `trans_item` will be called once for each\n             // compilation unit that references the item, so it will still get\n@@ -2295,7 +2304,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                     foreign::trans_rust_fn_with_foreign_abi(ccx,\n                                                             &**decl,\n                                                             &**body,\n-                                                            item.attrs.index(&FullRange),\n+                                                            &item.attrs[],\n                                                             llfn,\n                                                             &Substs::trans_empty(),\n                                                             item.id,\n@@ -2307,7 +2316,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n                              llfn,\n                              &Substs::trans_empty(),\n                              item.id,\n-                             item.attrs.index(&FullRange));\n+                             &item.attrs[]);\n                 }\n                 update_linkage(ccx,\n                                llfn,\n@@ -2324,7 +2333,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n       ast::ItemImpl(_, _, ref generics, _, _, ref impl_items) => {\n         meth::trans_impl(ccx,\n                          item.ident,\n-                         impl_items.index(&FullRange),\n+                         &impl_items[],\n                          generics,\n                          item.id);\n       }\n@@ -2354,7 +2363,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n \n           // Do static_assert checking. It can't really be done much earlier\n           // because we need to get the value of the bool out of LLVM\n-          if attr::contains_name(item.attrs.index(&FullRange), \"static_assert\") {\n+          if attr::contains_name(&item.attrs[], \"static_assert\") {\n               if m == ast::MutMutable {\n                   ccx.sess().span_fatal(expr.span,\n                                         \"cannot have static_assert on a mutable \\\n@@ -2431,7 +2440,7 @@ fn register_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         _ => panic!(\"expected bare rust fn\")\n     };\n \n-    let llfn = decl_rust_fn(ccx, node_type, sym.index(&FullRange));\n+    let llfn = decl_rust_fn(ccx, node_type, &sym[]);\n     finish_register_fn(ccx, sp, sym, node_id, llfn);\n     llfn\n }\n@@ -2476,7 +2485,7 @@ pub fn get_fn_llvm_attributes<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, fn_ty: Ty<\n \n             match fn_sig.inputs[1].sty {\n                 ty::ty_tup(ref t_in) => {\n-                    inputs.push_all(t_in.index(&FullRange));\n+                    inputs.push_all(&t_in[]);\n                     inputs\n                 }\n                 _ => ccx.sess().bug(\"expected tuple'd inputs\")\n@@ -2612,7 +2621,7 @@ pub fn register_fn_llvmty(ccx: &CrateContext,\n     debug!(\"register_fn_llvmty id={} sym={}\", node_id, sym);\n \n     let llfn = decl_fn(ccx,\n-                       sym.index(&FullRange),\n+                       &sym[],\n                        cc,\n                        llfty,\n                        ty::FnConverging(ty::mk_nil(ccx.tcx())));\n@@ -2668,7 +2677,7 @@ pub fn create_entry_wrapper(ccx: &CrateContext,\n             let (start_fn, args) = if use_start_lang_item {\n                 let start_def_id = match ccx.tcx().lang_items.require(StartFnLangItem) {\n                     Ok(id) => id,\n-                    Err(s) => { ccx.sess().fatal(s.index(&FullRange)); }\n+                    Err(s) => { ccx.sess().fatal(&s[]); }\n                 };\n                 let start_fn = if start_def_id.krate == ast::LOCAL_CRATE {\n                     get_item_val(ccx, start_def_id.node)\n@@ -2760,7 +2769,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = |&:| exported_name(ccx, id, ty, i.attrs.index(&FullRange));\n+            let sym = |&:| exported_name(ccx, id, ty, &i.attrs[]);\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -2783,16 +2792,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                         } else {\n                             llvm::LLVMTypeOf(v)\n                         };\n-                        if contains_null(sym.index(&FullRange)) {\n+                        if contains_null(&sym[]) {\n                             ccx.sess().fatal(\n-                                format!(\"Illegal null byte in export_name \\\n-                                         value: `{}`\", sym).index(&FullRange));\n+                                &format!(\"Illegal null byte in export_name \\\n+                                         value: `{}`\", sym)[]);\n                         }\n                         let buf = CString::from_slice(sym.as_bytes());\n                         let g = llvm::LLVMAddGlobal(ccx.llmod(), llty,\n                                                     buf.as_ptr());\n \n-                        if attr::contains_name(i.attrs.index(&FullRange),\n+                        if attr::contains_name(&i.attrs[],\n                                                \"thread_local\") {\n                             llvm::set_thread_local(g, true);\n                         }\n@@ -2817,19 +2826,19 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                                                                    sym,\n                                                                    i.id)\n                     };\n-                    set_llvm_fn_attrs(ccx, i.attrs.index(&FullRange), llfn);\n+                    set_llvm_fn_attrs(ccx, &i.attrs[], llfn);\n                     llfn\n                 }\n \n                 _ => panic!(\"get_item_val: weird result in table\")\n             };\n \n-            match attr::first_attr_value_str_by_name(i.attrs.index(&FullRange),\n+            match attr::first_attr_value_str_by_name(&i.attrs[],\n                                                      \"link_section\") {\n                 Some(sect) => {\n                     if contains_null(sect.get()) {\n-                        ccx.sess().fatal(format!(\"Illegal null byte in link_section value: `{}`\",\n-                                                 sect.get()).index(&FullRange));\n+                        ccx.sess().fatal(&format!(\"Illegal null byte in link_section value: `{}`\",\n+                                                 sect.get())[]);\n                     }\n                     unsafe {\n                         let buf = CString::from_slice(sect.get().as_bytes());\n@@ -2872,7 +2881,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     let abi = ccx.tcx().map.get_foreign_abi(id);\n                     let ty = ty::node_id_to_type(ccx.tcx(), ni.id);\n                     let name = foreign::link_name(&*ni);\n-                    foreign::register_foreign_item_fn(ccx, abi, ty, name.get().index(&FullRange))\n+                    foreign::register_foreign_item_fn(ccx, abi, ty, &name.get()[])\n                 }\n                 ast::ForeignItemStatic(..) => {\n                     foreign::register_static(ccx, &*ni)\n@@ -2895,7 +2904,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    enm.attrs.index(&FullRange));\n+                                    &enm.attrs[]);\n \n             llfn = match enm.node {\n                 ast::ItemEnum(_, _) => {\n@@ -2922,17 +2931,16 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n             let sym = exported_name(ccx,\n                                     id,\n                                     ty,\n-                                    struct_item.attrs\n-                                               .index(&FullRange));\n+                                    &struct_item.attrs[]);\n             let llfn = register_fn(ccx, struct_item.span,\n                                    sym, ctor_id, ty);\n             set_inline_hint(llfn);\n             llfn\n         }\n \n         ref variant => {\n-            ccx.sess().bug(format!(\"get_item_val(): unexpected variant: {:?}\",\n-                                   variant).index(&FullRange))\n+            ccx.sess().bug(&format!(\"get_item_val(): unexpected variant: {:?}\",\n+                                   variant)[])\n         }\n     };\n \n@@ -2953,10 +2961,10 @@ fn register_method(ccx: &CrateContext, id: ast::NodeId,\n                    m: &ast::Method) -> ValueRef {\n     let mty = ty::node_id_to_type(ccx.tcx(), id);\n \n-    let sym = exported_name(ccx, id, mty, m.attrs.index(&FullRange));\n+    let sym = exported_name(ccx, id, mty, &m.attrs[]);\n \n     let llfn = register_fn(ccx, m.span, sym, id, mty);\n-    set_llvm_fn_attrs(ccx, m.attrs.index(&FullRange), llfn);\n+    set_llvm_fn_attrs(ccx, &m.attrs[], llfn);\n     llfn\n }\n \n@@ -2995,7 +3003,7 @@ pub fn write_metadata(cx: &SharedCrateContext, krate: &ast::Crate) -> Vec<u8> {\n         Some(compressed) => compressed,\n         None => cx.sess().fatal(\"failed to compress metadata\"),\n     }.as_slice());\n-    let llmeta = C_bytes_in_context(cx.metadata_llcx(), compressed.index(&FullRange));\n+    let llmeta = C_bytes_in_context(cx.metadata_llcx(), &compressed[]);\n     let llconst = C_struct_in_context(cx.metadata_llcx(), &[llmeta], false);\n     let name = format!(\"rust_metadata_{}_{}\",\n                        cx.link_meta().crate_name,\n@@ -3124,7 +3132,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n     let link_meta = link::build_link_meta(&tcx.sess, krate, name);\n \n     let codegen_units = tcx.sess.opts.cg.codegen_units;\n-    let shared_ccx = SharedCrateContext::new(link_meta.crate_name.index(&FullRange),\n+    let shared_ccx = SharedCrateContext::new(&link_meta.crate_name[],\n                                              codegen_units,\n                                              tcx,\n                                              export_map,\n@@ -3226,7 +3234,7 @@ pub fn trans_crate<'tcx>(analysis: ty::CrateAnalysis<'tcx>)\n         llmod: shared_ccx.metadata_llmod(),\n     };\n     let formats = shared_ccx.tcx().dependency_formats.borrow().clone();\n-    let no_builtins = attr::contains_name(krate.attrs.index(&FullRange), \"no_builtins\");\n+    let no_builtins = attr::contains_name(&krate.attrs[], \"no_builtins\");\n \n     let translation = CrateTranslation {\n         modules: modules,"}, {"sha": "b80088e4690c966024257b8584535db71a0ad824", "filename": "src/librustc_trans/trans/builder.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbuilder.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -552,11 +552,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             for (small_vec_e, &ix) in small_vec.iter_mut().zip(ixs.iter()) {\n                 *small_vec_e = C_i32(self.ccx, ix as i32);\n             }\n-            self.inbounds_gep(base, small_vec.index(&(0..ixs.len())))\n+            self.inbounds_gep(base, &small_vec[0..ixs.len()])\n         } else {\n             let v = ixs.iter().map(|i| C_i32(self.ccx, *i as i32)).collect::<Vec<ValueRef>>();\n             self.count_insn(\"gepi\");\n-            self.inbounds_gep(base, v.index(&FullRange))\n+            self.inbounds_gep(base, &v[])\n         }\n     }\n \n@@ -764,8 +764,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n             let s = format!(\"{} ({})\",\n                             text,\n                             self.ccx.sess().codemap().span_to_string(sp));\n-            debug!(\"{}\", s.index(&FullRange));\n-            self.add_comment(s.index(&FullRange));\n+            debug!(\"{}\", &s[]);\n+            self.add_comment(&s[]);\n         }\n     }\n \n@@ -802,7 +802,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }).collect::<Vec<_>>();\n \n         debug!(\"Asm Output Type: {}\", self.ccx.tn().type_to_string(output));\n-        let fty = Type::func(argtys.index(&FullRange), &output);\n+        let fty = Type::func(&argtys[], &output);\n         unsafe {\n             let v = llvm::LLVMInlineAsm(\n                 fty.to_ref(), asm, cons, volatile, alignstack, dia as c_uint);"}, {"sha": "8a2a2534cabd2c51a7cbcc2cf4063412ca81d119", "filename": "src/librustc_trans/trans/cabi.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -108,7 +108,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n                         atys: &[Type],\n                         rty: Type,\n                         ret_def: bool) -> FnType {\n-    match ccx.sess().target.target.arch.index(&FullRange) {\n+    match &ccx.sess().target.target.arch[] {\n         \"x86\" => cabi_x86::compute_abi_info(ccx, atys, rty, ret_def),\n         \"x86_64\" => if ccx.sess().target.target.options.is_like_windows {\n             cabi_x86_win64::compute_abi_info(ccx, atys, rty, ret_def)\n@@ -118,7 +118,7 @@ pub fn compute_abi_info(ccx: &CrateContext,\n         \"arm\" => cabi_arm::compute_abi_info(ccx, atys, rty, ret_def),\n         \"aarch64\" => cabi_aarch64::compute_abi_info(ccx, atys, rty, ret_def),\n         \"mips\" => cabi_mips::compute_abi_info(ccx, atys, rty, ret_def),\n-        a => ccx.sess().fatal((format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n-                              .index(&FullRange)),\n+        a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a)\n+                              []),\n     }\n }"}, {"sha": "86190b1e56639f708253b4c803ab49414a67626a", "filename": "src/librustc_trans/trans/cabi_x86_64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcabi_x86_64.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -318,7 +318,7 @@ fn llreg_ty(ccx: &CrateContext, cls: &[RegClass]) -> Type {\n                 tys.push(Type::i64(ccx));\n             }\n             SSEFv => {\n-                let vec_len = llvec_len(cls.index(&((i + 1u)..)));\n+                let vec_len = llvec_len(&cls[(i + 1u)..]);\n                 let vec_ty = Type::vector(&Type::f32(ccx), (vec_len * 2u) as u64);\n                 tys.push(vec_ty);\n                 i += vec_len;"}, {"sha": "6196f9e5eab65eff401594f9cfad0699ecfd9378", "filename": "src/librustc_trans/trans/callee.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcallee.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -112,9 +112,9 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             _ => {\n                 bcx.tcx().sess.span_bug(\n                     expr.span,\n-                    format!(\"type of callee is neither bare-fn nor closure: \\\n+                    &format!(\"type of callee is neither bare-fn nor closure: \\\n                              {}\",\n-                            bcx.ty_to_string(datum.ty)).index(&FullRange));\n+                            bcx.ty_to_string(datum.ty))[]);\n             }\n         }\n     }\n@@ -206,8 +206,8 @@ fn trans<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, expr: &ast::Expr)\n             def::DefSelfTy(..) | def::DefAssociatedPath(..) => {\n                 bcx.tcx().sess.span_bug(\n                     ref_expr.span,\n-                    format!(\"cannot translate def {:?} \\\n-                             to a callable thing!\", def).index(&FullRange));\n+                    &format!(\"cannot translate def {:?} \\\n+                             to a callable thing!\", def)[]);\n             }\n         }\n     }\n@@ -265,7 +265,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let _icx = push_ctxt(\"trans_fn_pointer_shim\");\n     let tcx = ccx.tcx();\n \n-    let bare_fn_ty = normalize_ty(tcx, bare_fn_ty);\n+    let bare_fn_ty = erase_regions(tcx, &bare_fn_ty);\n     match ccx.fn_pointer_shims().borrow().get(&bare_fn_ty) {\n         Some(&llval) => { return llval; }\n         None => { }\n@@ -289,8 +289,8 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n             }\n \n             _ => {\n-                tcx.sess.bug(format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n-                                           bare_fn_ty.repr(tcx)).index(&FullRange));\n+                tcx.sess.bug(&format!(\"trans_fn_pointer_shim invoked on invalid type: {}\",\n+                                           bare_fn_ty.repr(tcx))[]);\n             }\n         };\n     let sig = ty::erase_late_bound_regions(tcx, sig);\n@@ -315,7 +315,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n     let llfn =\n         decl_internal_rust_fn(ccx,\n                               tuple_fn_ty,\n-                              function_name.index(&FullRange));\n+                              &function_name[]);\n \n     //\n     let block_arena = TypedArena::new();\n@@ -350,7 +350,7 @@ pub fn trans_fn_pointer_shim<'a, 'tcx>(\n                            None,\n                            bare_fn_ty,\n                            |bcx, _| Callee { bcx: bcx, data: Fn(llfnpointer) },\n-                           ArgVals(llargs.index(&FullRange)),\n+                           ArgVals(&llargs[]),\n                            dest).bcx;\n \n     finish_fn(&fcx, bcx, sig.output);\n@@ -776,7 +776,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n         // Invoke the actual rust fn and update bcx/llresult.\n         let (llret, b) = base::invoke(bcx,\n                                       llfn,\n-                                      llargs.index(&FullRange),\n+                                      &llargs[],\n                                       callee_ty,\n                                       call_info);\n         bcx = b;\n@@ -815,7 +815,7 @@ pub fn trans_call_inner<'a, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n \n         bcx = foreign::trans_native_call(bcx, callee_ty,\n                                          llfn, opt_llretslot.unwrap(),\n-                                         llargs.index(&FullRange), arg_tys);\n+                                         &llargs[], arg_tys);\n     }\n \n     fcx.pop_and_trans_custom_cleanup_scope(bcx, arg_cleanup_scope);"}, {"sha": "5658889aaf36856c4ee28d457997c6d33fd4aacb", "filename": "src/librustc_trans/trans/cleanup.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcleanup.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -403,8 +403,8 @@ impl<'blk, 'tcx> CleanupMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx> {\n         }\n \n         self.ccx.sess().bug(\n-            format!(\"no cleanup scope {} found\",\n-                    self.ccx.tcx().map.node_to_string(cleanup_scope)).index(&FullRange));\n+            &format!(\"no cleanup scope {} found\",\n+                    self.ccx.tcx().map.node_to_string(cleanup_scope))[]);\n     }\n \n     /// Schedules a cleanup to occur in the top-most scope, which must be a temporary scope.\n@@ -584,9 +584,9 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                     }\n \n                     LoopExit(id, _) => {\n-                        self.ccx.sess().bug(format!(\n+                        self.ccx.sess().bug(&format!(\n                                 \"cannot exit from scope {}, \\\n-                                not in scope\", id).index(&FullRange));\n+                                not in scope\", id)[]);\n                     }\n                 }\n             }\n@@ -655,7 +655,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 let name = scope.block_name(\"clean\");\n                 debug!(\"generating cleanups for {}\", name);\n                 let bcx_in = self.new_block(label.is_unwind(),\n-                                            name.index(&FullRange),\n+                                            &name[],\n                                             None);\n                 let mut bcx_out = bcx_in;\n                 for cleanup in scope.cleanups.iter().rev() {\n@@ -702,7 +702,7 @@ impl<'blk, 'tcx> CleanupHelperMethods<'blk, 'tcx> for FunctionContext<'blk, 'tcx\n                 Some(llbb) => { return llbb; }\n                 None => {\n                     let name = last_scope.block_name(\"unwind\");\n-                    pad_bcx = self.new_block(true, name.index(&FullRange), None);\n+                    pad_bcx = self.new_block(true, &name[], None);\n                     last_scope.cached_landing_pad = Some(pad_bcx.llbb);\n                 }\n             }\n@@ -1022,8 +1022,8 @@ pub fn temporary_scope(tcx: &ty::ctxt,\n             r\n         }\n         None => {\n-            tcx.sess.bug(format!(\"no temporary scope available for expr {}\",\n-                                 id).index(&FullRange))\n+            tcx.sess.bug(&format!(\"no temporary scope available for expr {}\",\n+                                 id)[])\n         }\n     }\n }"}, {"sha": "8989dfd493236a80c186f4dcb5105b1d0819b7a8", "filename": "src/librustc_trans/trans/closure.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fclosure.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -154,7 +154,7 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let tcx = ccx.tcx();\n \n     // compute the type of the closure\n-    let cdata_ty = mk_closure_tys(tcx, bound_values.index(&FullRange));\n+    let cdata_ty = mk_closure_tys(tcx, &bound_values[]);\n \n     // cbox_ty has the form of a tuple: (a, b, c) we want a ptr to a\n     // tuple.  This could be a ptr in uniq or a box or on stack,\n@@ -182,8 +182,8 @@ pub fn store_environment<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         debug!(\"Copy {} into closure\", bv.to_string(ccx));\n \n         if ccx.sess().asm_comments() {\n-            add_comment(bcx, format!(\"Copy {} into closure\",\n-                                     bv.to_string(ccx)).index(&FullRange));\n+            add_comment(bcx, &format!(\"Copy {} into closure\",\n+                                     bv.to_string(ccx))[]);\n         }\n \n         let bound_data = GEPi(bcx, llbox, &[0u, abi::BOX_FIELD_BODY, i]);\n@@ -420,7 +420,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let s = tcx.map.with_path(id, |path| {\n         mangle_internal_name_by_path_and_seq(path, \"closure\")\n     });\n-    let llfn = decl_internal_rust_fn(ccx, fty, s.index(&FullRange));\n+    let llfn = decl_internal_rust_fn(ccx, fty, &s[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -444,7 +444,7 @@ pub fn trans_expr_fn<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                   &[],\n                   ty::erase_late_bound_regions(ccx.tcx(), &ty::ty_fn_ret(fty)),\n                   ty::ty_fn_abi(fty),\n-                  ClosureEnv::new(freevars.index(&FullRange),\n+                  ClosureEnv::new(&freevars[],\n                                   BoxedClosure(cdata_ty, store)));\n     fill_fn_pair(bcx, dest_addr, llfn, llbox);\n     bcx\n@@ -466,7 +466,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n \n     // Normalize type so differences in regions and typedefs don't cause\n     // duplicate declarations\n-    let function_type = normalize_ty(ccx.tcx(), function_type);\n+    let function_type = erase_regions(ccx.tcx(), &function_type);\n     let params = match function_type.sty {\n         ty::ty_unboxed_closure(_, _, ref substs) => substs.types.clone(),\n         _ => unreachable!()\n@@ -489,7 +489,7 @@ pub fn get_or_create_declaration_if_unboxed_closure<'a, 'tcx>(ccx: &CrateContext\n         mangle_internal_name_by_path_and_seq(path, \"unboxed_closure\")\n     });\n \n-    let llfn = decl_internal_rust_fn(ccx, function_type, symbol.index(&FullRange));\n+    let llfn = decl_internal_rust_fn(ccx, function_type, &symbol[]);\n \n     // set an inline hint for all closures\n     set_inline_hint(llfn);\n@@ -544,7 +544,7 @@ pub fn trans_unboxed_closure<'blk, 'tcx>(\n                   &[],\n                   sig.output,\n                   function_type.abi,\n-                  ClosureEnv::new(freevars.index(&FullRange),\n+                  ClosureEnv::new(&freevars[],\n                                   UnboxedClosure(freevar_mode)));\n \n     // Don't hoist this to the top of the function. It's perfectly legitimate"}, {"sha": "ab5b563b99c7259ada392acf0ac6b1e427515d45", "filename": "src/librustc_trans/trans/common.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcommon.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -50,24 +50,29 @@ use std::vec::Vec;\n use syntax::ast::Ident;\n use syntax::ast;\n use syntax::ast_map::{PathElem, PathName};\n-use syntax::codemap::Span;\n+use syntax::codemap::{DUMMY_SP, Span};\n use syntax::parse::token::InternedString;\n use syntax::parse::token;\n use util::common::memoized;\n use util::nodemap::FnvHashSet;\n \n pub use trans::context::CrateContext;\n \n-/// Returns an equivalent type with all the typedefs and self regions removed.\n-pub fn normalize_ty<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n-    let u = TypeNormalizer(cx).fold_ty(ty);\n-    debug!(\"normalize_ty({}) = {}\",\n-           ty.repr(cx), u.repr(cx));\n-    return u;\n+/// Returns an equivalent value with all free regions removed (note\n+/// that late-bound regions remain, because they are important for\n+/// subtyping, but they are anonymized and normalized as well). This\n+/// is a stronger, caching version of `ty_fold::erase_regions`.\n+pub fn erase_regions<'tcx,T>(cx: &ty::ctxt<'tcx>, value: &T) -> T\n+    where T : TypeFoldable<'tcx> + Repr<'tcx>\n+{\n+    let value1 = value.fold_with(&mut RegionEraser(cx));\n+    debug!(\"erase_regions({}) = {}\",\n+           value.repr(cx), value1.repr(cx));\n+    return value1;\n \n-    struct TypeNormalizer<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n+    struct RegionEraser<'a, 'tcx: 'a>(&'a ty::ctxt<'tcx>);\n \n-    impl<'a, 'tcx> TypeFolder<'tcx> for TypeNormalizer<'a, 'tcx> {\n+    impl<'a, 'tcx> TypeFolder<'tcx> for RegionEraser<'a, 'tcx> {\n         fn tcx(&self) -> &ty::ctxt<'tcx> { self.0 }\n \n         fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n@@ -84,7 +89,6 @@ pub fn normalize_ty<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n         fn fold_binder<T>(&mut self, t: &ty::Binder<T>) -> ty::Binder<T>\n             where T : TypeFoldable<'tcx> + Repr<'tcx>\n         {\n-            // FIXME(#20526) this should replace `enter_region_binder`/`exit_region_binder`.\n             let u = ty::anonymize_late_bound_regions(self.tcx(), t);\n             ty_fold::super_fold_binder(self, &u)\n         }\n@@ -114,8 +118,9 @@ pub fn normalize_ty<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> Ty<'tcx> {\n }\n \n // Is the type's representation size known at compile time?\n-pub fn type_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n-ty::type_contents(cx, ty).is_sized(cx)\n+pub fn type_is_sized<'tcx>(tcx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n+    let param_env = ty::empty_parameter_environment(tcx);\n+    ty::type_is_sized(&param_env, DUMMY_SP, ty)\n }\n \n pub fn lltype_is_sized<'tcx>(cx: &ty::ctxt<'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -273,7 +278,7 @@ pub fn gensym_name(name: &str) -> PathElem {\n let num = token::gensym(name).uint();\n // use one colon which will get translated to a period by the mangler, and\n // we're guaranteed that `num` is globally unique for this crate.\n-PathName(token::gensym(format!(\"{}:{}\", name, num).index(&FullRange)))\n+PathName(token::gensym(&format!(\"{}:{}\", name, num)[]))\n }\n \n #[derive(Copy)]\n@@ -600,8 +605,8 @@ pub fn def(&self, nid: ast::NodeId) -> def::Def {\n     match self.tcx().def_map.borrow().get(&nid) {\n         Some(v) => v.clone(),\n         None => {\n-            self.tcx().sess.bug(format!(\n-                \"no def associated with node id {}\", nid).index(&FullRange));\n+            self.tcx().sess.bug(&format!(\n+                \"no def associated with node id {}\", nid)[]);\n         }\n     }\n }\n@@ -988,7 +993,7 @@ pub fn fulfill_obligation<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n let tcx = ccx.tcx();\n \n // Remove any references to regions; this helps improve caching.\n-let trait_ref = ty_fold::erase_regions(tcx, trait_ref);\n+let trait_ref = erase_regions(tcx, &trait_ref);\n \n // First check the cache.\n match ccx.trait_cache().borrow().get(&trait_ref) {\n@@ -1029,9 +1034,9 @@ let selection = match selcx.select(&obligation) {\n     Err(e) => {\n         tcx.sess.span_bug(\n             span,\n-            format!(\"Encountered error `{}` selecting `{}` during trans\",\n+            &format!(\"Encountered error `{}` selecting `{}` during trans\",\n                     e.repr(tcx),\n-                    trait_ref.repr(tcx)).index(&FullRange))\n+                    trait_ref.repr(tcx))[])\n     }\n };\n \n@@ -1123,8 +1128,8 @@ match fulfill_cx.select_all_or_error(infcx, &typer) {\n         } else {\n             infcx.tcx.sess.span_bug(\n                 span,\n-                format!(\"Encountered errors `{}` fulfilling during trans\",\n-                        errors.repr(infcx.tcx)).index(&FullRange));\n+                &format!(\"Encountered errors `{}` fulfilling during trans\",\n+                        errors.repr(infcx.tcx))[]);\n         }\n     }\n }\n@@ -1163,8 +1168,8 @@ let substs = match node {\n };\n \n if substs.types.any(|t| ty::type_needs_infer(*t)) {\n-        tcx.sess.bug(format!(\"type parameters for node {:?} include inference types: {:?}\",\n-                             node, substs.repr(tcx)).index(&FullRange));\n+        tcx.sess.bug(&format!(\"type parameters for node {:?} include inference types: {:?}\",\n+                             node, substs.repr(tcx))[]);\n     }\n \n     monomorphize::apply_param_substs(tcx,\n@@ -1182,8 +1187,8 @@ pub fn langcall(bcx: Block,\n         Err(s) => {\n             let msg = format!(\"{} {}\", msg, s);\n             match span {\n-                Some(span) => bcx.tcx().sess.span_fatal(span, msg.index(&FullRange)),\n-                None => bcx.tcx().sess.fatal(msg.index(&FullRange)),\n+                Some(span) => bcx.tcx().sess.span_fatal(span, &msg[]),\n+                None => bcx.tcx().sess.fatal(&msg[]),\n             }\n         }\n     }"}, {"sha": "00b97286de36780519e0471448cce156cb580991", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -52,9 +52,9 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n                     C_integral(Type::uint_from_ty(cx, t), i as u64, false)\n                 }\n                 _ => cx.sess().span_bug(lit.span,\n-                        format!(\"integer literal has type {} (expected int \\\n+                        &format!(\"integer literal has type {} (expected int \\\n                                  or uint)\",\n-                                ty_to_string(cx.tcx(), lit_int_ty)).index(&FullRange))\n+                                ty_to_string(cx.tcx(), lit_int_ty))[])\n             }\n         }\n         ast::LitFloat(ref fs, t) => {\n@@ -74,7 +74,7 @@ pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n         }\n         ast::LitBool(b) => C_bool(cx, b),\n         ast::LitStr(ref s, _) => C_str_slice(cx, (*s).clone()),\n-        ast::LitBinary(ref data) => C_binary_slice(cx, data.index(&FullRange)),\n+        ast::LitBinary(ref data) => C_binary_slice(cx, &data[]),\n     }\n }\n \n@@ -93,9 +93,9 @@ fn const_vec(cx: &CrateContext, e: &ast::Expr,\n                       .collect::<Vec<_>>();\n     // If the vector contains enums, an LLVM array won't work.\n     let v = if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-        C_struct(cx, vs.index(&FullRange), false)\n+        C_struct(cx, &vs[], false)\n     } else {\n-        C_array(llunitty, vs.index(&FullRange))\n+        C_array(llunitty, &vs[])\n     };\n     (v, llunitty)\n }\n@@ -148,14 +148,14 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, v: ValueRef,\n                     (const_deref_newtype(cx, v, t), mt.ty)\n                 }\n                 _ => {\n-                    cx.sess().bug(format!(\"unexpected dereferenceable type {}\",\n-                                          ty_to_string(cx.tcx(), t)).index(&FullRange))\n+                    cx.sess().bug(&format!(\"unexpected dereferenceable type {}\",\n+                                          ty_to_string(cx.tcx(), t))[])\n                 }\n             }\n         }\n         None => {\n-            cx.sess().bug(format!(\"cannot dereference const of type {}\",\n-                                  ty_to_string(cx.tcx(), t)).index(&FullRange))\n+            cx.sess().bug(&format!(\"cannot dereference const of type {}\",\n+                                  ty_to_string(cx.tcx(), t))[])\n         }\n     }\n }\n@@ -251,16 +251,16 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n                                             ], false);\n                                         }\n                                         _ => cx.sess().span_bug(e.span,\n-                                            format!(\"unimplemented type in const unsize: {}\",\n-                                                    ty_to_string(cx.tcx(), ty)).index(&FullRange))\n+                                            &format!(\"unimplemented type in const unsize: {}\",\n+                                                    ty_to_string(cx.tcx(), ty))[])\n                                     }\n                                 }\n                                 _ => {\n                                     cx.sess()\n                                       .span_bug(e.span,\n-                                                format!(\"unimplemented const \\\n+                                                &format!(\"unimplemented const \\\n                                                          autoref {:?}\",\n-                                                        autoref).index(&FullRange))\n+                                                        autoref)[])\n                                 }\n                             }\n                         }\n@@ -279,9 +279,9 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n             llvm::LLVMDumpValue(llconst);\n             llvm::LLVMDumpValue(C_undef(llty));\n         }\n-        cx.sess().bug(format!(\"const {} of type {} has size {} instead of {}\",\n+        cx.sess().bug(&format!(\"const {} of type {} has size {} instead of {}\",\n                          e.repr(cx.tcx()), ty_to_string(cx.tcx(), ety),\n-                         csize, tsize).index(&FullRange));\n+                         csize, tsize)[]);\n     }\n     (llconst, ety_adjusted)\n }\n@@ -429,23 +429,23 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           (const_deref_ptr(cx, e1), const_get_elt(cx, bv, &[1]))\n                       },\n                       _ => cx.sess().span_bug(base.span,\n-                                              format!(\"index-expr base must be a vector \\\n+                                              &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)).index(&FullRange))\n+                                                      ty_to_string(cx.tcx(), bt))[])\n                   },\n                   ty::ty_rptr(_, mt) => match mt.ty.sty {\n                       ty::ty_vec(_, Some(u)) => {\n                           (const_deref_ptr(cx, bv), C_uint(cx, u))\n                       },\n                       _ => cx.sess().span_bug(base.span,\n-                                              format!(\"index-expr base must be a vector \\\n+                                              &format!(\"index-expr base must be a vector \\\n                                                        or string type, found {}\",\n-                                                      ty_to_string(cx.tcx(), bt)).index(&FullRange))\n+                                                      ty_to_string(cx.tcx(), bt))[])\n                   },\n                   _ => cx.sess().span_bug(base.span,\n-                                          format!(\"index-expr base must be a vector \\\n+                                          &format!(\"index-expr base must be a vector \\\n                                                    or string type, found {}\",\n-                                                  ty_to_string(cx.tcx(), bt)).index(&FullRange))\n+                                                  ty_to_string(cx.tcx(), bt))[])\n               };\n \n               let len = llvm::LLVMConstIntGetZExtValue(len) as u64;\n@@ -546,8 +546,8 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n           ast::ExprTup(ref es) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n               let repr = adt::represent_type(cx, ety);\n-              let vals = map_list(es.index(&FullRange));\n-              adt::trans_const(cx, &*repr, 0, vals.index(&FullRange))\n+              let vals = map_list(&es[]);\n+              adt::trans_const(cx, &*repr, 0, &vals[])\n           }\n           ast::ExprStruct(_, ref fs, ref base_opt) => {\n               let ety = ty::expr_ty(cx.tcx(), e);\n@@ -578,7 +578,7 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                           }\n                       }\n                   }).collect::<Vec<_>>();\n-                  adt::trans_const(cx, &*repr, discr, cs.index(&FullRange))\n+                  adt::trans_const(cx, &*repr, discr, &cs[])\n               })\n           }\n           ast::ExprVec(ref es) => {\n@@ -595,9 +595,9 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n             };\n             let vs: Vec<_> = repeat(const_expr(cx, &**elem).0).take(n).collect();\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n-                C_struct(cx, vs.index(&FullRange), false)\n+                C_struct(cx, &vs[], false)\n             } else {\n-                C_array(llunitty, vs.index(&FullRange))\n+                C_array(llunitty, &vs[])\n             }\n           }\n           ast::ExprPath(_) => {\n@@ -645,20 +645,20 @@ fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n                   Some(def::DefStruct(_)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n-                      let arg_vals = map_list(args.index(&FullRange));\n-                      adt::trans_const(cx, &*repr, 0, arg_vals.index(&FullRange))\n+                      let arg_vals = map_list(&args[]);\n+                      adt::trans_const(cx, &*repr, 0, &arg_vals[])\n                   }\n                   Some(def::DefVariant(enum_did, variant_did, _)) => {\n                       let ety = ty::expr_ty(cx.tcx(), e);\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n                                                            variant_did);\n-                      let arg_vals = map_list(args.index(&FullRange));\n+                      let arg_vals = map_list(&args[]);\n                       adt::trans_const(cx,\n                                        &*repr,\n                                        vinfo.disr_val,\n-                                       arg_vals.index(&FullRange))\n+                                       &arg_vals[])\n                   }\n                   _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n               }"}, {"sha": "1abf3b0b886cca3b5387f47590181f54f1679c83", "filename": "src/librustc_trans/trans/context.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontext.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -284,7 +284,7 @@ impl<'tcx> SharedCrateContext<'tcx> {\n             // such as a function name in the module.\n             // 1. http://llvm.org/bugs/show_bug.cgi?id=11479\n             let llmod_id = format!(\"{}.{}.rs\", crate_name, i);\n-            let local_ccx = LocalCrateContext::new(&shared_ccx, llmod_id.index(&FullRange));\n+            let local_ccx = LocalCrateContext::new(&shared_ccx, &llmod_id[]);\n             shared_ccx.local_ccxs.push(local_ccx);\n         }\n \n@@ -369,12 +369,12 @@ impl<'tcx> LocalCrateContext<'tcx> {\n         unsafe {\n             let (llcx, llmod) = create_context_and_module(&shared.tcx.sess, name);\n \n-            let td = mk_target_data(shared.tcx\n+            let td = mk_target_data(&shared.tcx\n                                           .sess\n                                           .target\n                                           .target\n                                           .data_layout\n-                                          .index(&FullRange));\n+                                          []);\n \n             let dbg_cx = if shared.tcx.sess.opts.debuginfo != NoDebugInfo {\n                 Some(debuginfo::CrateDebugContext::new(llmod))\n@@ -721,7 +721,7 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n     /// currently conservatively bounded to 1 << 47 as that is enough to cover the current usable\n     /// address space on 64-bit ARMv8 and x86_64.\n     pub fn obj_size_bound(&self) -> u64 {\n-        match self.sess().target.target.target_word_size.index(&FullRange) {\n+        match &self.sess().target.target.target_pointer_width[] {\n             \"32\" => 1 << 31,\n             \"64\" => 1 << 47,\n             _ => unreachable!() // error handled by config::build_target_config\n@@ -730,8 +730,8 @@ impl<'b, 'tcx> CrateContext<'b, 'tcx> {\n \n     pub fn report_overbig_object(&self, obj: Ty<'tcx>) -> ! {\n         self.sess().fatal(\n-            format!(\"the type `{}` is too big for the current architecture\",\n-                    obj.repr(self.tcx())).index(&FullRange))\n+            &format!(\"the type `{}` is too big for the current architecture\",\n+                    obj.repr(self.tcx()))[])\n     }\n }\n "}, {"sha": "adf302501cd1f48b2c2a2bd50c3777db0ff4474d", "filename": "src/librustc_trans/trans/controlflow.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fcontrolflow.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -48,7 +48,7 @@ pub fn trans_stmt<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n     debug!(\"trans_stmt({})\", s.repr(cx.tcx()));\n \n     if cx.sess().asm_comments() {\n-        add_span_comment(cx, s.span, s.repr(cx.tcx()).index(&FullRange));\n+        add_span_comment(cx, s.span, &s.repr(cx.tcx())[]);\n     }\n \n     let mut bcx = cx;\n@@ -188,7 +188,7 @@ pub fn trans_if<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }\n \n     let name = format!(\"then-block-{}-\", thn.id);\n-    let then_bcx_in = bcx.fcx.new_id_block(name.index(&FullRange), thn.id);\n+    let then_bcx_in = bcx.fcx.new_id_block(&name[], thn.id);\n     let then_bcx_out = trans_block(then_bcx_in, &*thn, dest);\n     trans::debuginfo::clear_source_location(bcx.fcx);\n \n@@ -439,8 +439,8 @@ pub fn trans_break_cont<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.tcx().def_map.borrow().get(&expr_id) {\n                 Some(&def::DefLabel(loop_id)) => loop_id,\n                 ref r => {\n-                    bcx.tcx().sess.bug(format!(\"{:?} in def-map for label\",\n-                                               r).index(&FullRange))\n+                    bcx.tcx().sess.bug(&format!(\"{:?} in def-map for label\",\n+                                               r)[])\n                 }\n             }\n         }\n@@ -504,7 +504,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let v_str = C_str_slice(ccx, fail_str);\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.index(&FullRange));\n+    let filename = token::intern_and_get_ident(&loc.file.name[]);\n     let filename = C_str_slice(ccx, filename);\n     let line = C_uint(ccx, loc.line);\n     let expr_file_line_const = C_struct(ccx, &[v_str, filename, line], false);\n@@ -513,7 +513,7 @@ pub fn trans_fail<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args.index(&FullRange),\n+                                      &args[],\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;\n@@ -529,7 +529,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     // Extract the file/line from the span\n     let loc = bcx.sess().codemap().lookup_char_pos(sp.lo);\n-    let filename = token::intern_and_get_ident(loc.file.name.index(&FullRange));\n+    let filename = token::intern_and_get_ident(&loc.file.name[]);\n \n     // Invoke the lang item\n     let filename = C_str_slice(ccx,  filename);\n@@ -540,7 +540,7 @@ pub fn trans_fail_bounds_check<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let did = langcall(bcx, Some(sp), \"\", PanicBoundsCheckFnLangItem);\n     let bcx = callee::trans_lang_call(bcx,\n                                       did,\n-                                      args.index(&FullRange),\n+                                      &args[],\n                                       Some(expr::Ignore)).bcx;\n     Unreachable(bcx);\n     return bcx;"}, {"sha": "8b52732f4ee972c7718cd4a26d5d1779d5e39b28", "filename": "src/librustc_trans/trans/datum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdatum.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -463,8 +463,8 @@ impl<'tcx> Datum<'tcx, Lvalue> {\n                 gep(base)\n             }\n             _ => bcx.tcx().sess.bug(\n-                format!(\"Unexpected unsized type in get_element: {}\",\n-                        bcx.ty_to_string(self.ty)).index(&FullRange))\n+                &format!(\"Unexpected unsized type in get_element: {}\",\n+                        bcx.ty_to_string(self.ty))[])\n         };\n         Datum {\n             val: val,"}, {"sha": "3a6f4b47e4e1e7b2837be07b251e1a0727c61585", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 90, "deletions": 91, "changes": 181, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -284,8 +284,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                        type_: Ty<'tcx>,\n                                        metadata: DIType) {\n         if self.type_to_metadata.insert(type_, metadata).is_some() {\n-            cx.sess().bug(format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n-                                   ppaux::ty_to_string(cx.tcx(), type_)).index(&FullRange));\n+            cx.sess().bug(&format!(\"Type metadata for Ty '{}' is already in the TypeMap!\",\n+                                   ppaux::ty_to_string(cx.tcx(), type_))[]);\n         }\n     }\n \n@@ -297,8 +297,8 @@ impl<'tcx> TypeMap<'tcx> {\n                                         metadata: DIType) {\n         if self.unique_id_to_metadata.insert(unique_type_id, metadata).is_some() {\n             let unique_type_id_str = self.get_unique_type_id_as_string(unique_type_id);\n-            cx.sess().bug(format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n-                                  unique_type_id_str.index(&FullRange)).index(&FullRange));\n+            cx.sess().bug(&format!(\"Type metadata for unique id '{}' is already in the TypeMap!\",\n+                                  &unique_type_id_str[])[]);\n         }\n     }\n \n@@ -335,13 +335,13 @@ impl<'tcx> TypeMap<'tcx> {\n         // unique ptr (~)       -> {~ :pointee-uid:}\n         // @-ptr (@)            -> {@ :pointee-uid:}\n         // sized vec ([T; x])   -> {[:size:] :element-uid:}\n-        // unsized vec ([T])    -> {.index(&FullRange) :element-uid:}\n+        // unsized vec ([T])    -> {[] :element-uid:}\n         // trait (T)            -> {trait_:svh: / :node-id:_<(:param-uid:),*> }\n         // closure              -> {<unsafe_> <once_> :store-sigil: |(:param-uid:),* <,_...>| -> \\\n         //                             :return-type-uid: : (:bounds:)*}\n         // function             -> {<unsafe_> <abi_> fn( (:param-uid:)* <,_...> ) -> \\\n         //                             :return-type-uid:}\n-        // unique vec box (~.index(&FullRange)) -> {HEAP_VEC_BOX<:pointee-uid:>}\n+        // unique vec box (~[]) -> {HEAP_VEC_BOX<:pointee-uid:>}\n         // gc box               -> {GC_BOX<:pointee-uid:>}\n \n         match self.type_to_unique_id.get(&type_).cloned() {\n@@ -379,14 +379,14 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, component_type);\n                     let component_type_id =\n                         self.get_unique_type_id_as_string(component_type_id);\n-                    unique_type_id.push_str(component_type_id.index(&FullRange));\n+                    unique_type_id.push_str(&component_type_id[]);\n                 }\n             },\n             ty::ty_uniq(inner_type) => {\n                 unique_type_id.push('~');\n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.index(&FullRange));\n+                unique_type_id.push_str(&inner_type_id[]);\n             },\n             ty::ty_ptr(ty::mt { ty: inner_type, mutbl } ) => {\n                 unique_type_id.push('*');\n@@ -396,7 +396,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.index(&FullRange));\n+                unique_type_id.push_str(&inner_type_id[]);\n             },\n             ty::ty_rptr(_, ty::mt { ty: inner_type, mutbl }) => {\n                 unique_type_id.push('&');\n@@ -406,12 +406,12 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.index(&FullRange));\n+                unique_type_id.push_str(&inner_type_id[]);\n             },\n             ty::ty_vec(inner_type, optional_length) => {\n                 match optional_length {\n                     Some(len) => {\n-                        unique_type_id.push_str(format!(\"[{}]\", len).index(&FullRange));\n+                        unique_type_id.push_str(&format!(\"[{}]\", len)[]);\n                     }\n                     None => {\n                         unique_type_id.push_str(\"[]\");\n@@ -420,7 +420,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n                 let inner_type_id = self.get_unique_type_id_of_type(cx, inner_type);\n                 let inner_type_id = self.get_unique_type_id_as_string(inner_type_id);\n-                unique_type_id.push_str(inner_type_id.index(&FullRange));\n+                unique_type_id.push_str(&inner_type_id[]);\n             },\n             ty::ty_trait(ref trait_data) => {\n                 unique_type_id.push_str(\"trait \");\n@@ -451,7 +451,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         self.get_unique_type_id_of_type(cx, parameter_type);\n                     let parameter_type_id =\n                         self.get_unique_type_id_as_string(parameter_type_id);\n-                    unique_type_id.push_str(parameter_type_id.index(&FullRange));\n+                    unique_type_id.push_str(&parameter_type_id[]);\n                     unique_type_id.push(',');\n                 }\n \n@@ -464,7 +464,7 @@ impl<'tcx> TypeMap<'tcx> {\n                     ty::FnConverging(ret_ty) => {\n                         let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                         let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                        unique_type_id.push_str(return_type_id.index(&FullRange));\n+                        unique_type_id.push_str(&return_type_id[]);\n                     }\n                     ty::FnDiverging => {\n                         unique_type_id.push_str(\"!\");\n@@ -479,9 +479,9 @@ impl<'tcx> TypeMap<'tcx> {\n                                                         &mut unique_type_id);\n             },\n             _ => {\n-                cx.sess().bug(format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n-                                      ppaux::ty_to_string(cx.tcx(), type_).index(&FullRange),\n-                                      type_.sty).index(&FullRange))\n+                cx.sess().bug(&format!(\"get_unique_type_id_of_type() - unexpected type: {}, {:?}\",\n+                                      &ppaux::ty_to_string(cx.tcx(), type_)[],\n+                                      type_.sty)[])\n             }\n         };\n \n@@ -524,7 +524,7 @@ impl<'tcx> TypeMap<'tcx> {\n \n             output.push_str(crate_hash.as_str());\n             output.push_str(\"/\");\n-            output.push_str(format!(\"{:x}\", def_id.node).index(&FullRange));\n+            output.push_str(&format!(\"{:x}\", def_id.node)[]);\n \n             // Maybe check that there is no self type here.\n \n@@ -537,7 +537,7 @@ impl<'tcx> TypeMap<'tcx> {\n                         type_map.get_unique_type_id_of_type(cx, type_parameter);\n                     let param_type_id =\n                         type_map.get_unique_type_id_as_string(param_type_id);\n-                    output.push_str(param_type_id.index(&FullRange));\n+                    output.push_str(&param_type_id[]);\n                     output.push(',');\n                 }\n \n@@ -581,7 +581,7 @@ impl<'tcx> TypeMap<'tcx> {\n                 self.get_unique_type_id_of_type(cx, parameter_type);\n             let parameter_type_id =\n                 self.get_unique_type_id_as_string(parameter_type_id);\n-            unique_type_id.push_str(parameter_type_id.index(&FullRange));\n+            unique_type_id.push_str(&parameter_type_id[]);\n             unique_type_id.push(',');\n         }\n \n@@ -595,7 +595,7 @@ impl<'tcx> TypeMap<'tcx> {\n             ty::FnConverging(ret_ty) => {\n                 let return_type_id = self.get_unique_type_id_of_type(cx, ret_ty);\n                 let return_type_id = self.get_unique_type_id_as_string(return_type_id);\n-                unique_type_id.push_str(return_type_id.index(&FullRange));\n+                unique_type_id.push_str(&return_type_id[]);\n             }\n             ty::FnDiverging => {\n                 unique_type_id.push_str(\"!\");\n@@ -625,8 +625,7 @@ impl<'tcx> TypeMap<'tcx> {\n                                               -> UniqueTypeId {\n         let enum_type_id = self.get_unique_type_id_of_type(cx, enum_type);\n         let enum_variant_type_id = format!(\"{}::{}\",\n-                                           self.get_unique_type_id_as_string(enum_type_id)\n-                                               .index(&FullRange),\n+                                           &self.get_unique_type_id_as_string(enum_type_id)[],\n                                            variant_name);\n         let interner_key = self.unique_id_interner.intern(Rc::new(enum_variant_type_id));\n         UniqueTypeId(interner_key)\n@@ -803,23 +802,23 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                 _ => {\n                     cx.sess()\n                       .span_bug(item.span,\n-                                format!(\"debuginfo::\\\n+                                &format!(\"debuginfo::\\\n                                          create_global_var_metadata() -\n                                          Captured var-id refers to \\\n                                          unexpected ast_item variant: {:?}\",\n-                                        var_item).index(&FullRange))\n+                                        var_item)[])\n                 }\n             }\n         },\n-        _ => cx.sess().bug(format!(\"debuginfo::create_global_var_metadata() \\\n+        _ => cx.sess().bug(&format!(\"debuginfo::create_global_var_metadata() \\\n                                     - Captured var-id refers to unexpected \\\n                                     ast_map variant: {:?}\",\n-                                   var_item).index(&FullRange))\n+                                   var_item)[])\n     };\n \n     let (file_metadata, line_number) = if span != codemap::DUMMY_SP {\n         let loc = span_start(cx, span);\n-        (file_metadata(cx, loc.file.name.index(&FullRange)), loc.line as c_uint)\n+        (file_metadata(cx, &loc.file.name[]), loc.line as c_uint)\n     } else {\n         (UNKNOWN_FILE_METADATA, UNKNOWN_LINE_NUMBER)\n     };\n@@ -830,7 +829,7 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n     let namespace_node = namespace_for_item(cx, ast_util::local_def(node_id));\n     let var_name = token::get_ident(ident).get().to_string();\n     let linkage_name =\n-        namespace_node.mangled_name_of_contained_item(var_name.index(&FullRange));\n+        namespace_node.mangled_name_of_contained_item(&var_name[]);\n     let var_scope = namespace_node.scope;\n \n     let var_name = CString::from_slice(var_name.as_bytes());\n@@ -868,8 +867,8 @@ pub fn create_local_var_metadata(bcx: Block, local: &ast::Local) {\n             Some(datum) => datum,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {}\",\n-                            node_id).index(&FullRange));\n+                    &format!(\"no entry in lllocals table for {}\",\n+                            node_id)[]);\n             }\n         };\n \n@@ -919,21 +918,21 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 _ => {\n                     cx.sess()\n                       .span_bug(span,\n-                                format!(\n+                                &format!(\n                                 \"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                 ast_item).index(&FullRange));\n+                                 ast_item)[]);\n                 }\n             }\n         }\n         _ => {\n             cx.sess()\n               .span_bug(span,\n-                        format!(\"debuginfo::create_captured_var_metadata() - \\\n+                        &format!(\"debuginfo::create_captured_var_metadata() - \\\n                                  Captured var-id refers to unexpected \\\n                                  ast_map variant: {:?}\",\n-                                ast_item).index(&FullRange));\n+                                ast_item)[]);\n         }\n     };\n \n@@ -963,7 +962,7 @@ pub fn create_captured_var_metadata<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let variable_access = IndirectVariable {\n         alloca: env_pointer,\n-        address_operations: address_operations.index(&(0..address_op_count))\n+        address_operations: &address_operations[0..address_op_count]\n     };\n \n     declare_local(bcx,\n@@ -1039,8 +1038,8 @@ pub fn create_argument_metadata(bcx: Block, arg: &ast::Arg) {\n             Some(v) => v,\n             None => {\n                 bcx.sess().span_bug(span,\n-                    format!(\"no entry in lllocals table for {}\",\n-                            node_id).index(&FullRange));\n+                    &format!(\"no entry in lllocals table for {}\",\n+                            node_id)[]);\n             }\n         };\n \n@@ -1154,7 +1153,7 @@ pub fn get_cleanup_debug_loc_for_ast_node<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         if let Some(code_snippet) = code_snippet {\n             let bytes = code_snippet.as_bytes();\n \n-            if bytes.len() > 0 && bytes.index(&((bytes.len()-1)..)) == b\"}\" {\n+            if bytes.len() > 0 && &bytes[(bytes.len()-1)..] == b\"}\" {\n                 cleanup_span = Span {\n                     lo: node_span.hi - codemap::BytePos(1),\n                     hi: node_span.hi,\n@@ -1298,7 +1297,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             match expr.node {\n                 ast::ExprClosure(_, _, ref fn_decl, ref top_level_block) => {\n                     let name = format!(\"fn{}\", token::gensym(\"fn\"));\n-                    let name = token::str_to_ident(name.index(&FullRange));\n+                    let name = token::str_to_ident(&name[]);\n                     (name, &**fn_decl,\n                         // This is not quite right. It should actually inherit\n                         // the generics of the enclosing function.\n@@ -1328,9 +1327,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 }\n                 _ => {\n                     cx.sess()\n-                      .bug(format!(\"create_function_debug_context: \\\n+                      .bug(&format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                    fnitem).index(&FullRange))\n+                                    fnitem)[])\n                 }\n             }\n         }\n@@ -1339,9 +1338,9 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeStructCtor(..) => {\n             return FunctionDebugContext::FunctionWithoutDebugInfo;\n         }\n-        _ => cx.sess().bug(format!(\"create_function_debug_context: \\\n+        _ => cx.sess().bug(&format!(\"create_function_debug_context: \\\n                                     unexpected sort of node: {:?}\",\n-                                   fnitem).index(&FullRange))\n+                                   fnitem)[])\n     };\n \n     // This can be the case for functions inlined from another crate\n@@ -1350,7 +1349,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+    let file_metadata = file_metadata(cx, &loc.file.name[]);\n \n     let function_type_metadata = unsafe {\n         let fn_signature = get_function_signature(cx,\n@@ -1377,7 +1376,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let (linkage_name, containing_scope) = if has_path {\n         let namespace_node = namespace_for_item(cx, ast_util::local_def(fn_ast_id));\n         let linkage_name = namespace_node.mangled_name_of_contained_item(\n-            function_name.index(&FullRange));\n+            &function_name[]);\n         let containing_scope = namespace_node.scope;\n         (linkage_name, containing_scope)\n     } else {\n@@ -1465,7 +1464,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             signature.push(type_metadata(cx, arg_type, codemap::DUMMY_SP));\n         }\n \n-        return create_DIArray(DIB(cx), signature.index(&FullRange));\n+        return create_DIArray(DIB(cx), &signature[]);\n     }\n \n     fn get_template_parameters<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n@@ -1500,7 +1499,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 actual_self_type,\n                 true);\n \n-            name_to_append_suffix_to.push_str(actual_self_type_name.index(&FullRange));\n+            name_to_append_suffix_to.push_str(&actual_self_type_name[]);\n \n             if generics.is_type_parameterized() {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1539,7 +1538,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let actual_type_name = compute_debuginfo_type_name(cx,\n                                                                actual_type,\n                                                                true);\n-            name_to_append_suffix_to.push_str(actual_type_name.index(&FullRange));\n+            name_to_append_suffix_to.push_str(&actual_type_name[]);\n \n             if index != generics.ty_params.len() - 1 {\n                 name_to_append_suffix_to.push_str(\",\");\n@@ -1566,7 +1565,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n         name_to_append_suffix_to.push('>');\n \n-        return create_DIArray(DIB(cx), template_params.index(&FullRange));\n+        return create_DIArray(DIB(cx), &template_params[]);\n     }\n }\n \n@@ -1660,7 +1659,7 @@ fn declare_local<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     let cx: &CrateContext = bcx.ccx();\n \n     let filename = span_start(cx, span).file.name.clone();\n-    let file_metadata = file_metadata(cx, filename.index(&FullRange));\n+    let file_metadata = file_metadata(cx, &filename[]);\n \n     let name = token::get_ident(variable_ident);\n     let loc = span_start(cx, span);\n@@ -1746,7 +1745,7 @@ fn file_metadata(cx: &CrateContext, full_path: &str) -> DIFile {\n     let work_dir = cx.sess().working_dir.as_str().unwrap();\n     let file_name =\n         if full_path.starts_with(work_dir) {\n-            full_path.index(&((work_dir.len() + 1u)..full_path.len()))\n+            &full_path[(work_dir.len() + 1u)..full_path.len()]\n         } else {\n             full_path\n         };\n@@ -1777,8 +1776,8 @@ fn scope_metadata(fcx: &FunctionContext,\n             let node = fcx.ccx.tcx().map.get(node_id);\n \n             fcx.ccx.sess().span_bug(error_reporting_span,\n-                format!(\"debuginfo: Could not find scope info for node {:?}\",\n-                        node).index(&FullRange));\n+                &format!(\"debuginfo: Could not find scope info for node {:?}\",\n+                        node)[]);\n         }\n     }\n }\n@@ -1971,10 +1970,10 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                     let type_map = debug_context(cx).type_map.borrow();\n                     if type_map.find_metadata_for_unique_id(unique_type_id).is_none() ||\n                        type_map.find_metadata_for_type(unfinished_type).is_none() {\n-                        cx.sess().bug(format!(\"Forward declaration of potentially recursive type \\\n+                        cx.sess().bug(&format!(\"Forward declaration of potentially recursive type \\\n                                               '{}' was not found in TypeMap!\",\n                                               ppaux::ty_to_string(cx.tcx(), unfinished_type))\n-                                      .index(&FullRange));\n+                                      []);\n                     }\n                 }\n \n@@ -1986,7 +1985,7 @@ impl<'tcx> RecursiveTypeDescription<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               metadata_stub,\n                                               llvm_type,\n-                                              member_descriptions.index(&FullRange));\n+                                              &member_descriptions[]);\n                 return MetadataCreationResult::new(metadata_stub, true);\n             }\n         }\n@@ -2058,7 +2057,7 @@ fn prepare_struct_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let struct_metadata_stub = create_struct_stub(cx,\n                                                   struct_llvm_type,\n-                                                  struct_name.index(&FullRange),\n+                                                  &struct_name[],\n                                                   unique_type_id,\n                                                   containing_scope);\n \n@@ -2119,7 +2118,7 @@ fn prepare_tuple_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         unique_type_id,\n         create_struct_stub(cx,\n                            tuple_llvm_type,\n-                           tuple_name.index(&FullRange),\n+                           &tuple_name[],\n                            unique_type_id,\n                            UNKNOWN_SCOPE_METADATA),\n         tuple_llvm_type,\n@@ -2179,7 +2178,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                         set_members_of_composite_type(cx,\n                                                       variant_type_metadata,\n                                                       variant_llvm_type,\n-                                                      member_descriptions.index(&FullRange));\n+                                                      &member_descriptions[]);\n                         MemberDescription {\n                             name: \"\".to_string(),\n                             llvm_type: variant_llvm_type,\n@@ -2212,7 +2211,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                     set_members_of_composite_type(cx,\n                                                   variant_type_metadata,\n                                                   variant_llvm_type,\n-                                                  member_descriptions.index(&FullRange));\n+                                                  &member_descriptions[]);\n                     vec![\n                         MemberDescription {\n                             name: \"\".to_string(),\n@@ -2312,7 +2311,7 @@ impl<'tcx> EnumMemberDescriptionFactory<'tcx> {\n                 set_members_of_composite_type(cx,\n                                               variant_type_metadata,\n                                               variant_llvm_type,\n-                                              variant_member_descriptions.index(&FullRange));\n+                                              &variant_member_descriptions[]);\n \n                 // Encode the information about the null variant in the union\n                 // member's name.\n@@ -2387,11 +2386,11 @@ fn describe_enum_variant<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    span: Span)\n                                    -> (DICompositeType, Type, MemberDescriptionFactory<'tcx>) {\n     let variant_llvm_type =\n-        Type::struct_(cx, struct_def.fields\n+        Type::struct_(cx, &struct_def.fields\n                                     .iter()\n                                     .map(|&t| type_of::type_of(cx, t))\n                                     .collect::<Vec<_>>()\n-                                    .index(&FullRange),\n+                                    [],\n                       struct_def.packed);\n     // Could do some consistency checks here: size, align, field count, discr type\n \n@@ -2458,7 +2457,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let (containing_scope, definition_span) = get_namespace_and_span_for_item(cx, enum_def_id);\n     let loc = span_start(cx, definition_span);\n-    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+    let file_metadata = file_metadata(cx, &loc.file.name[]);\n \n     let variants = ty::enum_variants(cx.tcx(), enum_def_id);\n \n@@ -2638,14 +2637,14 @@ fn set_members_of_composite_type(cx: &CrateContext,\n             let min_supported_llvm_version = 3 * 1000000 + 4 * 1000;\n \n             if actual_llvm_version < min_supported_llvm_version {\n-                cx.sess().warn(format!(\"This version of rustc was built with LLVM \\\n+                cx.sess().warn(&format!(\"This version of rustc was built with LLVM \\\n                                         {}.{}. Rustc just ran into a known \\\n                                         debuginfo corruption problem thatoften \\\n                                         occurs with LLVM versions below 3.4. \\\n                                         Please use a rustc built with anewer \\\n                                         version of LLVM.\",\n                                        llvm_version_major,\n-                                       llvm_version_minor).index(&FullRange));\n+                                       llvm_version_minor)[]);\n             } else {\n                 cx.sess().bug(\"debuginfo::set_members_of_composite_type() - \\\n                                Already completed forward declaration re-encountered.\");\n@@ -2683,7 +2682,7 @@ fn set_members_of_composite_type(cx: &CrateContext,\n         .collect();\n \n     unsafe {\n-        let type_array = create_DIArray(DIB(cx), member_metadata.index(&FullRange));\n+        let type_array = create_DIArray(DIB(cx), &member_metadata[]);\n         llvm::LLVMDICompositeTypeSetTypeArray(composite_type_metadata, type_array);\n     }\n }\n@@ -2782,7 +2781,7 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     let member_llvm_types = slice_llvm_type.field_types();\n     assert!(slice_layout_is_correct(cx,\n-                                    member_llvm_types.index(&FullRange),\n+                                    &member_llvm_types[],\n                                     element_type));\n     let member_descriptions = [\n         MemberDescription {\n@@ -2804,11 +2803,11 @@ fn vec_slice_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     assert!(member_descriptions.len() == member_llvm_types.len());\n \n     let loc = span_start(cx, span);\n-    let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+    let file_metadata = file_metadata(cx, &loc.file.name[]);\n \n     let metadata = composite_type_metadata(cx,\n                                            slice_llvm_type,\n-                                           slice_type_name.index(&FullRange),\n+                                           &slice_type_name[],\n                                            unique_type_id,\n                                            &member_descriptions,\n                                            UNKNOWN_SCOPE_METADATA,\n@@ -2857,7 +2856,7 @@ fn subroutine_type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             llvm::LLVMDIBuilderCreateSubroutineType(\n                 DIB(cx),\n                 UNKNOWN_FILE_METADATA,\n-                create_DIArray(DIB(cx), signature_metadata.index(&FullRange)))\n+                create_DIArray(DIB(cx), &signature_metadata[]))\n         },\n         false);\n }\n@@ -2881,9 +2880,9 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_trait(ref data) => data.principal_def_id(),\n         _ => {\n             let pp_type_name = ppaux::ty_to_string(cx.tcx(), trait_type);\n-            cx.sess().bug(format!(\"debuginfo: Unexpected trait-object type in \\\n+            cx.sess().bug(&format!(\"debuginfo: Unexpected trait-object type in \\\n                                    trait_pointer_metadata(): {}\",\n-                                   pp_type_name.index(&FullRange)).index(&FullRange));\n+                                   &pp_type_name[])[]);\n         }\n     };\n \n@@ -2897,7 +2896,7 @@ fn trait_pointer_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n \n     composite_type_metadata(cx,\n                             trait_llvm_type,\n-                            trait_type_name.index(&FullRange),\n+                            &trait_type_name[],\n                             unique_type_id,\n                             &[],\n                             containing_scope,\n@@ -3017,13 +3016,13 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_tup(ref elements) => {\n             prepare_tuple_metadata(cx,\n                                    t,\n-                                   elements.index(&FullRange),\n+                                   &elements[],\n                                    unique_type_id,\n                                    usage_site_span).finalize(cx)\n         }\n         _ => {\n-            cx.sess().bug(format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n-                                  sty).index(&FullRange))\n+            cx.sess().bug(&format!(\"debuginfo: unexpected type in type_metadata: {:?}\",\n+                                  sty)[])\n         }\n     };\n \n@@ -3041,9 +3040,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                  type id '{}' to already be in \\\n                                                  the debuginfo::TypeMap but it \\\n                                                  was not. (Ty = {})\",\n-                                                unique_type_id_str.index(&FullRange),\n+                                                &unique_type_id_str[],\n                                                 ppaux::ty_to_string(cx.tcx(), t));\n-                    cx.sess().span_bug(usage_site_span, error_message.index(&FullRange));\n+                    cx.sess().span_bug(usage_site_span, &error_message[]);\n                 }\n             };\n \n@@ -3056,9 +3055,9 @@ fn type_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                                      UniqueTypeId maps in \\\n                                                      debuginfo::TypeMap. \\\n                                                      UniqueTypeId={}, Ty={}\",\n-                            unique_type_id_str.index(&FullRange),\n+                            &unique_type_id_str[],\n                             ppaux::ty_to_string(cx.tcx(), t));\n-                        cx.sess().span_bug(usage_site_span, error_message.index(&FullRange));\n+                        cx.sess().span_bug(usage_site_span, &error_message[]);\n                     }\n                 }\n                 None => {\n@@ -3264,7 +3263,7 @@ fn create_scope_map(cx: &CrateContext,\n     {\n         // Create a new lexical scope and push it onto the stack\n         let loc = cx.sess().codemap().lookup_char_pos(scope_span.lo);\n-        let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+        let file_metadata = file_metadata(cx, &loc.file.name[]);\n         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n         let scope_metadata = unsafe {\n@@ -3386,7 +3385,7 @@ fn create_scope_map(cx: &CrateContext,\n                     if need_new_scope {\n                         // Create a new lexical scope and push it onto the stack\n                         let loc = cx.sess().codemap().lookup_char_pos(pat.span.lo);\n-                        let file_metadata = file_metadata(cx, loc.file.name.index(&FullRange));\n+                        let file_metadata = file_metadata(cx, &loc.file.name[]);\n                         let parent_scope = scope_stack.last().unwrap().scope_metadata;\n \n                         let scope_metadata = unsafe {\n@@ -3861,8 +3860,8 @@ fn push_debuginfo_type_name<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         ty::ty_open(_) |\n         ty::ty_projection(..) |\n         ty::ty_param(_) => {\n-            cx.sess().bug(format!(\"debuginfo: Trying to create type name for \\\n-                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange));\n+            cx.sess().bug(&format!(\"debuginfo: Trying to create type name for \\\n+                unexpected type: {}\", ppaux::ty_to_string(cx.tcx(), t))[]);\n         }\n     }\n \n@@ -3945,21 +3944,21 @@ impl NamespaceTreeNode {\n                 None => {}\n             }\n             let string = token::get_name(node.name);\n-            output.push_str(format!(\"{}\", string.get().len()).index(&FullRange));\n+            output.push_str(&format!(\"{}\", string.get().len())[]);\n             output.push_str(string.get());\n         }\n \n         let mut name = String::from_str(\"_ZN\");\n         fill_nested(self, &mut name);\n-        name.push_str(format!(\"{}\", item_name.len()).index(&FullRange));\n+        name.push_str(&format!(\"{}\", item_name.len())[]);\n         name.push_str(item_name);\n         name.push('E');\n         name\n     }\n }\n \n fn crate_root_namespace<'a>(cx: &'a CrateContext) -> &'a str {\n-    cx.link_meta().crate_name.index(&FullRange)\n+    &cx.link_meta().crate_name[]\n }\n \n fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTreeNode> {\n@@ -4034,9 +4033,9 @@ fn namespace_for_item(cx: &CrateContext, def_id: ast::DefId) -> Rc<NamespaceTree\n         match parent_node {\n             Some(node) => node,\n             None => {\n-                cx.sess().bug(format!(\"debuginfo::namespace_for_item(): \\\n+                cx.sess().bug(&format!(\"debuginfo::namespace_for_item(): \\\n                                        path too short for {:?}\",\n-                                      def_id).index(&FullRange));\n+                                      def_id)[]);\n             }\n         }\n     })"}, {"sha": "ac50445be2f9b41adea0427d9c49b003b83bad36", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 44, "deletions": 42, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -50,6 +50,7 @@ use trans::debuginfo;\n use trans::glue;\n use trans::machine;\n use trans::meth;\n+use trans::monomorphize;\n use trans::inline;\n use trans::tvec;\n use trans::type_of;\n@@ -317,8 +318,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     // should just be the identity function.\n                     unsized_info(bcx, k, id, ty_substs[tp_index], identity)\n                 }\n-                _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n-                                          bcx.ty_to_string(unadjusted_ty)).index(&FullRange))\n+                _ => bcx.sess().bug(&format!(\"UnsizeStruct with bad sty: {}\",\n+                                          bcx.ty_to_string(unadjusted_ty))[])\n             },\n             &ty::UnsizeVtable(ty::TyTrait { ref principal, .. }, _) => {\n                 // Note that we preserve binding levels here:\n@@ -450,8 +451,8 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         let datum_ty = datum.ty;\n         let unboxed_ty = match datum_ty.sty {\n             ty::ty_uniq(t) => t,\n-            _ => bcx.sess().bug(format!(\"Expected ty_uniq, found {}\",\n-                                        bcx.ty_to_string(datum_ty)).index(&FullRange))\n+            _ => bcx.sess().bug(&format!(\"Expected ty_uniq, found {}\",\n+                                        bcx.ty_to_string(datum_ty))[])\n         };\n         let result_ty = ty::mk_uniq(tcx, ty::unsize_ty(tcx, unboxed_ty, k, expr.span));\n \n@@ -622,9 +623,9 @@ fn trans_datum_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"trans_rvalue_datum_unadjusted reached \\\n+                &format!(\"trans_rvalue_datum_unadjusted reached \\\n                          fall-through case: {:?}\",\n-                        expr.node).index(&FullRange));\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -975,9 +976,9 @@ fn trans_rvalue_stmt_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"trans_rvalue_stmt_unadjusted reached \\\n+                &format!(\"trans_rvalue_stmt_unadjusted reached \\\n                          fall-through case: {:?}\",\n-                        expr.node).index(&FullRange));\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1003,14 +1004,14 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             controlflow::trans_if(bcx, expr.id, &**cond, &**thn, els.as_ref().map(|e| &**e), dest)\n         }\n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            _match::trans_match(bcx, expr, &**discr, arms.index(&FullRange), dest)\n+            _match::trans_match(bcx, expr, &**discr, &arms[], dest)\n         }\n         ast::ExprBlock(ref blk) => {\n             controlflow::trans_block(bcx, &**blk, dest)\n         }\n         ast::ExprStruct(_, ref fields, ref base) => {\n             trans_struct(bcx,\n-                         fields.index(&FullRange),\n+                         &fields[],\n                          base.as_ref().map(|e| &**e),\n                          expr.span,\n                          expr.id,\n@@ -1075,7 +1076,7 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             trans_adt(bcx,\n                       expr_ty(bcx, expr),\n                       0,\n-                      numbered_fields.index(&FullRange),\n+                      &numbered_fields[],\n                       None,\n                       dest,\n                       Some(NodeInfo { id: expr.id, span: expr.span }))\n@@ -1119,21 +1120,21 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                 trans_overloaded_call(bcx,\n                                       expr,\n                                       &**f,\n-                                      args.index(&FullRange),\n+                                      &args[],\n                                       Some(dest))\n             } else {\n                 callee::trans_call(bcx,\n                                    expr,\n                                    &**f,\n-                                   callee::ArgExprs(args.index(&FullRange)),\n+                                   callee::ArgExprs(&args[]),\n                                    dest)\n             }\n         }\n         ast::ExprMethodCall(_, _, ref args) => {\n             callee::trans_method_call(bcx,\n                                       expr,\n                                       &*args[0],\n-                                      callee::ArgExprs(args.index(&FullRange)),\n+                                      callee::ArgExprs(&args[]),\n                                       dest)\n         }\n         ast::ExprBinary(op, ref lhs, ref rhs) => {\n@@ -1180,9 +1181,9 @@ fn trans_rvalue_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n+                &format!(\"trans_rvalue_dps_unadjusted reached fall-through \\\n                          case: {:?}\",\n-                        expr.node).index(&FullRange));\n+                        expr.node)[]);\n         }\n     }\n }\n@@ -1230,9 +1231,9 @@ fn trans_def_dps_unadjusted<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             bcx\n         }\n         _ => {\n-            bcx.tcx().sess.span_bug(ref_expr.span, format!(\n+            bcx.tcx().sess.span_bug(ref_expr.span, &format!(\n                 \"Non-DPS def {:?} referened by {}\",\n-                def, bcx.node_id_to_string(ref_expr.id)).index(&FullRange));\n+                def, bcx.node_id_to_string(ref_expr.id))[]);\n         }\n     }\n }\n@@ -1258,10 +1259,10 @@ pub fn trans_def_fn_unadjusted<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                              param_substs)\n         }\n         _ => {\n-            ccx.tcx().sess.span_bug(ref_expr.span, format!(\n+            ccx.tcx().sess.span_bug(ref_expr.span, &format!(\n                     \"trans_def_fn_unadjusted invoked on: {:?} for {}\",\n                     def,\n-                    ref_expr.repr(ccx.tcx())).index(&FullRange));\n+                    ref_expr.repr(ccx.tcx()))[]);\n         }\n     }\n }\n@@ -1279,29 +1280,29 @@ pub fn trans_local_var<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             match bcx.fcx.llupvars.borrow().get(&nid) {\n                 Some(&val) => Datum::new(val, local_ty, Lvalue),\n                 None => {\n-                    bcx.sess().bug(format!(\n+                    bcx.sess().bug(&format!(\n                         \"trans_local_var: no llval for upvar {} found\",\n-                        nid).index(&FullRange));\n+                        nid)[]);\n                 }\n             }\n         }\n         def::DefLocal(nid) => {\n             let datum = match bcx.fcx.lllocals.borrow().get(&nid) {\n                 Some(&v) => v,\n                 None => {\n-                    bcx.sess().bug(format!(\n+                    bcx.sess().bug(&format!(\n                         \"trans_local_var: no datum for local/arg {} found\",\n-                        nid).index(&FullRange));\n+                        nid)[]);\n                 }\n             };\n             debug!(\"take_local(nid={}, v={}, ty={})\",\n                    nid, bcx.val_to_string(datum.val), bcx.ty_to_string(datum.ty));\n             datum\n         }\n         _ => {\n-            bcx.sess().unimpl(format!(\n+            bcx.sess().unimpl(&format!(\n                 \"unsupported def type in trans_local_var: {:?}\",\n-                def).index(&FullRange));\n+                def)[]);\n         }\n     }\n }\n@@ -1318,32 +1319,33 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n {\n     match ty.sty {\n         ty::ty_struct(did, substs) => {\n-            op(0, struct_fields(tcx, did, substs).index(&FullRange))\n+            let fields = struct_fields(tcx, did, substs);\n+            let fields = monomorphize::normalize_associated_type(tcx, &fields);\n+            op(0, &fields[])\n         }\n \n         ty::ty_tup(ref v) => {\n-            op(0, tup_fields(v.index(&FullRange)).index(&FullRange))\n+            op(0, &tup_fields(&v[])[])\n         }\n \n         ty::ty_enum(_, substs) => {\n             // We want the *variant* ID here, not the enum ID.\n             match node_id_opt {\n                 None => {\n-                    tcx.sess.bug(format!(\n+                    tcx.sess.bug(&format!(\n                         \"cannot get field types from the enum type {} \\\n                          without a node ID\",\n-                        ty.repr(tcx)).index(&FullRange));\n+                        ty.repr(tcx))[]);\n                 }\n                 Some(node_id) => {\n                     let def = tcx.def_map.borrow()[node_id].clone();\n                     match def {\n                         def::DefVariant(enum_id, variant_id, _) => {\n                             let variant_info = ty::enum_variant_with_id(\n                                 tcx, enum_id, variant_id);\n-                            op(variant_info.disr_val,\n-                               struct_fields(tcx,\n-                                             variant_id,\n-                                             substs).index(&FullRange))\n+                            let fields = struct_fields(tcx, variant_id, substs);\n+                            let fields = monomorphize::normalize_associated_type(tcx, &fields);\n+                            op(variant_info.disr_val, &fields[])\n                         }\n                         _ => {\n                             tcx.sess.bug(\"resolve didn't map this expr to a \\\n@@ -1355,9 +1357,9 @@ pub fn with_field_tys<'tcx, R, F>(tcx: &ty::ctxt<'tcx>,\n         }\n \n         _ => {\n-            tcx.sess.bug(format!(\n+            tcx.sess.bug(&format!(\n                 \"cannot get field types from the type {}\",\n-                ty.repr(tcx)).index(&FullRange));\n+                ty.repr(tcx))[]);\n         }\n     }\n }\n@@ -2045,21 +2047,21 @@ fn trans_imm_cast<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                           lldiscrim_a, true),\n                 cast_float => SIToFP(bcx, lldiscrim_a, ll_t_out),\n                 _ => {\n-                    ccx.sess().bug(format!(\"translating unsupported cast: \\\n+                    ccx.sess().bug(&format!(\"translating unsupported cast: \\\n                                             {} ({:?}) -> {} ({:?})\",\n                                             t_in.repr(bcx.tcx()),\n                                             k_in,\n                                             t_out.repr(bcx.tcx()),\n-                                            k_out).index(&FullRange))\n+                                            k_out)[])\n                 }\n             }\n         }\n-        _ => ccx.sess().bug(format!(\"translating unsupported cast: \\\n+        _ => ccx.sess().bug(&format!(\"translating unsupported cast: \\\n                                     {} ({:?}) -> {} ({:?})\",\n                                     t_in.repr(bcx.tcx()),\n                                     k_in,\n                                     t_out.repr(bcx.tcx()),\n-                                    k_out).index(&FullRange))\n+                                    k_out)[])\n     };\n     return immediate_rvalue_bcx(bcx, newval, t_out).to_expr_datumblock();\n }\n@@ -2224,8 +2226,8 @@ fn deref_once<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => {\n             bcx.tcx().sess.span_bug(\n                 expr.span,\n-                format!(\"deref invoked on expr of illegal type {}\",\n-                        datum.ty.repr(bcx.tcx())).index(&FullRange));\n+                &format!(\"deref invoked on expr of illegal type {}\",\n+                        datum.ty.repr(bcx.tcx()))[]);\n         }\n     };\n "}, {"sha": "3dfb36c854b72bb775abed0dc7ab0b64b95961f8", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -109,7 +109,7 @@ pub fn register_static(ccx: &CrateContext,\n     let llty = type_of::type_of(ccx, ty);\n \n     let ident = link_name(foreign_item);\n-    match attr::first_attr_value_str_by_name(foreign_item.attrs.index(&FullRange),\n+    match attr::first_attr_value_str_by_name(&foreign_item.attrs[],\n                                              \"linkage\") {\n         // If this is a static with a linkage specified, then we need to handle\n         // it a little specially. The typesystem prevents things like &T and\n@@ -235,13 +235,13 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         _ => ccx.sess().bug(\"trans_native_call called on non-function type\")\n     };\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n-    let llsig = foreign_signature(ccx, &fn_sig, passed_arg_tys.index(&FullRange));\n+    let llsig = foreign_signature(ccx, &fn_sig, &passed_arg_tys[]);\n     let fn_type = cabi::compute_abi_info(ccx,\n-                                         llsig.llarg_tys.index(&FullRange),\n+                                         &llsig.llarg_tys[],\n                                          llsig.llret_ty,\n                                          llsig.ret_def);\n \n-    let arg_tys: &[cabi::ArgType] = fn_type.arg_tys.index(&FullRange);\n+    let arg_tys: &[cabi::ArgType] = &fn_type.arg_tys[];\n \n     let mut llargs_foreign = Vec::new();\n \n@@ -367,7 +367,7 @@ pub fn trans_native_call<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n     let llforeign_retval = CallWithConv(bcx,\n                                         llfn,\n-                                        llargs_foreign.index(&FullRange),\n+                                        &llargs_foreign[],\n                                         cc,\n                                         Some(attrs));\n \n@@ -437,7 +437,7 @@ pub fn trans_foreign_mod(ccx: &CrateContext, foreign_mod: &ast::ForeignMod) {\n                 abi => {\n                     let ty = ty::node_id_to_type(ccx.tcx(), foreign_item.id);\n                     register_foreign_item_fn(ccx, abi, ty,\n-                                             lname.get().index(&FullRange));\n+                                             &lname.get()[]);\n                     // Unlike for other items, we shouldn't call\n                     // `base::update_linkage` here.  Foreign items have\n                     // special linkage requirements, which are handled\n@@ -566,18 +566,18 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                 assert!(f.abi != Rust && f.abi != RustIntrinsic);\n             }\n             _ => {\n-                ccx.sess().bug(format!(\"build_rust_fn: extern fn {} has ty {}, \\\n+                ccx.sess().bug(&format!(\"build_rust_fn: extern fn {} has ty {}, \\\n                                         expected a bare fn ty\",\n                                        ccx.tcx().map.path_to_string(id),\n-                                       t.repr(tcx)).index(&FullRange));\n+                                       t.repr(tcx))[]);\n             }\n         };\n \n         debug!(\"build_rust_fn: path={} id={} t={}\",\n                ccx.tcx().map.path_to_string(id),\n                id, t.repr(tcx));\n \n-        let llfn = base::decl_internal_rust_fn(ccx, t, ps.index(&FullRange));\n+        let llfn = base::decl_internal_rust_fn(ccx, t, &ps[]);\n         base::set_llvm_fn_attrs(ccx, attrs, llfn);\n         base::trans_fn(ccx, decl, body, llfn, param_substs, id, &[]);\n         llfn\n@@ -817,9 +817,9 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n // the massive simplifications that have occurred.\n \n pub fn link_name(i: &ast::ForeignItem) -> InternedString {\n-    match attr::first_attr_value_str_by_name(i.attrs.index(&FullRange), \"link_name\") {\n+    match attr::first_attr_value_str_by_name(&i.attrs[], \"link_name\") {\n         Some(ln) => ln.clone(),\n-        None => match weak_lang_items::link_name(i.attrs.index(&FullRange)) {\n+        None => match weak_lang_items::link_name(&i.attrs[]) {\n             Some(name) => name,\n             None => token::get_ident(i.ident),\n         }\n@@ -862,7 +862,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let fn_sig = ty::erase_late_bound_regions(ccx.tcx(), fn_sig);\n     let llsig = foreign_signature(ccx, &fn_sig, fn_sig.inputs.as_slice());\n     let fn_ty = cabi::compute_abi_info(ccx,\n-                                       llsig.llarg_tys.index(&FullRange),\n+                                       &llsig.llarg_tys[],\n                                        llsig.llret_ty,\n                                        llsig.ret_def);\n     debug!(\"foreign_types_for_fn_ty(\\\n@@ -871,7 +871,7 @@ fn foreign_types_for_fn_ty<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n            fn_ty={} -> {}, \\\n            ret_def={}\",\n            ty.repr(ccx.tcx()),\n-           ccx.tn().types_to_str(llsig.llarg_tys.index(&FullRange)),\n+           ccx.tn().types_to_str(&llsig.llarg_tys[]),\n            ccx.tn().type_to_string(llsig.llret_ty),\n            ccx.tn().types_to_str(fn_ty.arg_tys.iter().map(|t| t.ty).collect::<Vec<_>>().as_slice()),\n            ccx.tn().type_to_string(fn_ty.ret_ty.ty),\n@@ -923,7 +923,7 @@ fn lltype_for_fn_from_foreign_types(ccx: &CrateContext, tys: &ForeignTypes) -> T\n     if tys.fn_sig.variadic {\n         Type::variadic_func(llargument_tys.as_slice(), &llreturn_ty)\n     } else {\n-        Type::func(llargument_tys.index(&FullRange), &llreturn_ty)\n+        Type::func(&llargument_tys[], &llreturn_ty)\n     }\n }\n "}, {"sha": "2219cd59263cc2648ecde6821500127d67e25735", "filename": "src/librustc_trans/trans/glue.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fglue.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -161,7 +161,7 @@ pub fn get_drop_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Val\n \n     let (glue, new_sym) = match ccx.available_drop_glues().borrow().get(&t) {\n         Some(old_sym) => {\n-            let glue = decl_cdecl_fn(ccx, old_sym.index(&FullRange), llfnty, ty::mk_nil(ccx.tcx()));\n+            let glue = decl_cdecl_fn(ccx, &old_sym[], llfnty, ty::mk_nil(ccx.tcx()));\n             (glue, None)\n         },\n         None => {\n@@ -233,8 +233,8 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             assert!(sig.inputs.len() == 1);\n             sig.inputs[0]\n         }\n-        _ => bcx.sess().bug(format!(\"Expected function type, found {}\",\n-                                    bcx.ty_to_string(fty)).index(&FullRange))\n+        _ => bcx.sess().bug(&format!(\"Expected function type, found {}\",\n+                                    bcx.ty_to_string(fty))[])\n     };\n \n     let (struct_data, info) = if type_is_sized(bcx.tcx(), t) {\n@@ -295,7 +295,7 @@ fn trans_struct_drop<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                                      class_did,\n                                      &[get_drop_glue_type(bcx.ccx(), t)],\n                                      ty::mk_nil(bcx.tcx()));\n-        let (_, variant_cx) = invoke(variant_cx, dtor_addr, args.index(&FullRange), dtor_ty, None);\n+        let (_, variant_cx) = invoke(variant_cx, dtor_addr, &args[], dtor_ty, None);\n \n         variant_cx.fcx.pop_and_trans_custom_cleanup_scope(variant_cx, field_scope);\n         variant_cx\n@@ -353,8 +353,8 @@ fn size_and_align_of_dst<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, t: Ty<'tcx>, info:\n             let unit_size = llsize_of_alloc(bcx.ccx(), llunit_ty);\n             (Mul(bcx, info, C_uint(bcx.ccx(), unit_size)), C_uint(bcx.ccx(), 8u))\n         }\n-        _ => bcx.sess().bug(format!(\"Unexpected unsized type, found {}\",\n-                                    bcx.ty_to_string(t)).index(&FullRange))\n+        _ => bcx.sess().bug(&format!(\"Unexpected unsized type, found {}\",\n+                                    bcx.ty_to_string(t))[])\n     }\n }\n \n@@ -423,10 +423,10 @@ fn make_drop_glue<'blk, 'tcx>(bcx: Block<'blk, 'tcx>, v0: ValueRef, t: Ty<'tcx>)\n                     } else {\n                         // Give the user a heads up that we are doing something\n                         // stupid and dangerous.\n-                        bcx.sess().warn(format!(\"Ignoring drop flag in destructor for {}\\\n+                        bcx.sess().warn(&format!(\"Ignoring drop flag in destructor for {}\\\n                                                  because the struct is unsized. See issue\\\n                                                  #16758\",\n-                                                bcx.ty_to_string(t)).index(&FullRange));\n+                                                bcx.ty_to_string(t))[]);\n                         trans_struct_drop(bcx, t, v0, dtor, did, substs)\n                     }\n                 }\n@@ -496,7 +496,7 @@ pub fn declare_tydesc<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>)\n     note_unique_llvm_symbol(ccx, name);\n \n     let ty_name = token::intern_and_get_ident(\n-        ppaux::ty_to_string(ccx.tcx(), t).index(&FullRange));\n+        &ppaux::ty_to_string(ccx.tcx(), t)[]);\n     let ty_name = C_str_slice(ccx, ty_name);\n \n     debug!(\"--- declare_tydesc {}\", ppaux::ty_to_string(ccx.tcx(), t));\n@@ -515,8 +515,8 @@ fn declare_generic_glue<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>,\n     let fn_nm = mangle_internal_name_by_type_and_seq(\n         ccx,\n         t,\n-        format!(\"glue_{}\", name).index(&FullRange));\n-    let llfn = decl_cdecl_fn(ccx, fn_nm.index(&FullRange), llfnty, ty::mk_nil(ccx.tcx()));\n+        &format!(\"glue_{}\", name)[]);\n+    let llfn = decl_cdecl_fn(ccx, &fn_nm[], llfnty, ty::mk_nil(ccx.tcx()));\n     note_unique_llvm_symbol(ccx, fn_nm.clone());\n     return (fn_nm, llfn);\n }"}, {"sha": "b22c7f763f035a50d3c1b76b5230c05730717fe0", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -313,7 +313,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n         (_, \"size_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);\n             let lltp_ty = type_of::type_of(ccx, tp_ty);\n-            C_uint(ccx, machine::llsize_of_real(ccx, lltp_ty))\n+            C_uint(ccx, machine::llsize_of_alloc(ccx, lltp_ty))\n         }\n         (_, \"min_align_of\") => {\n             let tp_ty = *substs.types.get(FnSpace, 0);"}, {"sha": "95d67cd54c124e59a38eaf5a31c8a004f1212a84", "filename": "src/librustc_trans/trans/machine.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmachine.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -43,8 +43,10 @@ pub fn llsize_of_alloc(cx: &CrateContext, ty: Type) -> llsize {\n \n // Returns, as near as we can figure, the \"real\" size of a type. As in, the\n // bits in this number of bytes actually carry data related to the datum\n-// with the type. Not junk, padding, accidentally-damaged words, or\n-// whatever. Rounds up to the nearest byte though, so if you have a 1-bit\n+// with the type. Not junk, accidentally-damaged words, or whatever.\n+// Note that padding of the type will be included for structs, but not for the\n+// other types (i.e. SIMD types).\n+// Rounds up to the nearest byte though, so if you have a 1-bit\n // value, we return 1 here, not 0. Most of rustc works in bytes. Be warned\n // that LLVM *does* distinguish between e.g. a 1-bit value and an 8-bit value\n // at the codegen level! In general you should prefer `llbitsize_of_real`"}, {"sha": "7ac062108f3fb2c2f14d141ab2c07fadbdb19e89", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -77,7 +77,7 @@ pub fn trans_impl(ccx: &CrateContext,\n         match *impl_item {\n             ast::MethodImplItem(ref method) => {\n                 if method.pe_generics().ty_params.len() == 0u {\n-                    let trans_everywhere = attr::requests_inline(method.attrs.index(&FullRange));\n+                    let trans_everywhere = attr::requests_inline(&method.attrs[]);\n                     for (ref ccx, is_origin) in ccx.maybe_iter(trans_everywhere) {\n                         let llfn = get_item_val(ccx, method.id);\n                         trans_fn(ccx,\n@@ -229,7 +229,7 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     // Here, in this call, which I've written with explicit UFCS\n     // notation, the set of type parameters will be:\n     //\n-    //     rcvr_type: .index(&FullRange) <-- nothing declared on the trait itself\n+    //     rcvr_type: [] <-- nothing declared on the trait itself\n     //     rcvr_self: [Vec<int>] <-- the self type\n     //     rcvr_method: [String] <-- method type parameter\n     //\n@@ -268,11 +268,11 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             //\n             // Recall that we matched `<Vec<int> as Convert>`. Trait\n             // resolution will have given us a substitution\n-            // containing `impl_substs=[[T=int],.index(&FullRange),.index(&FullRange)]` (the type\n+            // containing `impl_substs=[[T=int],[],[]]` (the type\n             // parameters defined on the impl). We combine\n             // that with the `rcvr_method` from before, which tells us\n             // the type parameters from the *method*, to yield\n-            // `callee_substs=[[T=int],.index(&FullRange),[U=String]]`.\n+            // `callee_substs=[[T=int],[],[U=String]]`.\n             let subst::SeparateVecsPerParamSpace {\n                 types: impl_type,\n                 selfs: impl_self,\n@@ -289,8 +289,8 @@ pub fn trans_static_method_callee<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                      callee_substs)\n         }\n         _ => {\n-            tcx.sess.bug(format!(\"static call to invalid vtable: {}\",\n-                                 vtbl.repr(tcx)).index(&FullRange));\n+            tcx.sess.bug(&format!(\"static call to invalid vtable: {}\",\n+                                 vtbl.repr(tcx))[]);\n         }\n     }\n }\n@@ -377,8 +377,8 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n         traits::VtableBuiltin(..) |\n         traits::VtableParam(..) => {\n             bcx.sess().bug(\n-                format!(\"resolved vtable bad vtable {} in trans\",\n-                        vtable.repr(bcx.tcx())).index(&FullRange));\n+                &format!(\"resolved vtable bad vtable {} in trans\",\n+                        vtable.repr(bcx.tcx()))[]);\n         }\n     }\n }\n@@ -738,9 +738,9 @@ pub fn get_vtable<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n             }\n             traits::VtableParam => {\n                 bcx.sess().bug(\n-                    format!(\"resolved vtable for {} to bad vtable {} in trans\",\n+                    &format!(\"resolved vtable for {} to bad vtable {} in trans\",\n                             trait_ref.repr(bcx.tcx()),\n-                            vtable.repr(bcx.tcx())).index(&FullRange));\n+                            vtable.repr(bcx.tcx()))[]);\n             }\n         }\n     });\n@@ -772,7 +772,7 @@ pub fn make_vtable<I: Iterator<Item=ValueRef>>(ccx: &CrateContext,\n     let components: Vec<_> = head.into_iter().chain(ptrs).collect();\n \n     unsafe {\n-        let tbl = C_struct(ccx, components.index(&FullRange), false);\n+        let tbl = C_struct(ccx, &components[], false);\n         let sym = token::gensym(\"vtable\");\n         let buf = CString::from_vec(format!(\"vtable{}\", sym.uint()).into_bytes());\n         let vt_gvar = llvm::LLVMAddGlobal(ccx.llmod(), val_ty(tbl).to_ref(),"}, {"sha": "93076260349abd5c81aee5d5801823a800ec4a2d", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -32,7 +32,7 @@ use syntax::ast_map;\n use syntax::ast_util::{local_def, PostExpansionMethod};\n use syntax::attr;\n use syntax::codemap::DUMMY_SP;\n-use std::hash::{sip, Hash};\n+use std::hash::{Hasher, Hash, SipHasher};\n \n pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 fn_id: ast::DefId,\n@@ -125,13 +125,13 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     let hash;\n     let s = {\n-        let mut state = sip::SipState::new();\n+        let mut state = SipHasher::new();\n         hash_id.hash(&mut state);\n         mono_ty.hash(&mut state);\n \n-        hash = format!(\"h{}\", state.result());\n+        hash = format!(\"h{}\", state.finish());\n         ccx.tcx().map.with_path(fn_id.node, |path| {\n-            exported_name(path, hash.index(&FullRange))\n+            exported_name(path, &hash[])\n         })\n     };\n \n@@ -141,9 +141,9 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n     let mut hash_id = Some(hash_id);\n     let mut mk_lldecl = |&mut : abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n-            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s.index(&FullRange))\n+            foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, &s[])\n         } else {\n-            decl_internal_rust_fn(ccx, mono_ty, s.index(&FullRange))\n+            decl_internal_rust_fn(ccx, mono_ty, &s[])\n         };\n \n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n@@ -177,12 +177,12 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);\n-                  let needs_body = setup_lldecl(d, i.attrs.index(&FullRange));\n+                  let needs_body = setup_lldecl(d, &i.attrs[]);\n                   if needs_body {\n                       if abi != abi::Rust {\n                           foreign::trans_rust_fn_with_foreign_abi(\n                               ccx, &**decl, &**body, &[], d, psubsts, fn_id.node,\n-                              Some(hash.index(&FullRange)));\n+                              Some(&hash[]));\n                       } else {\n                           trans_fn(ccx, &**decl, &**body, d, psubsts, fn_id.node, &[]);\n                       }\n@@ -206,7 +206,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     trans_enum_variant(ccx,\n                                        parent,\n                                        &*v,\n-                                       args.index(&FullRange),\n+                                       &args[],\n                                        this_tv.disr_val,\n                                        psubsts,\n                                        d);\n@@ -220,7 +220,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *ii {\n                 ast::MethodImplItem(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs.index(&FullRange));\n+                    let needs_body = setup_lldecl(d, &mth.attrs[]);\n                     if needs_body {\n                         trans_fn(ccx,\n                                  mth.pe_fn_decl(),\n@@ -241,24 +241,24 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n             match *method {\n                 ast::ProvidedMethod(ref mth) => {\n                     let d = mk_lldecl(abi::Rust);\n-                    let needs_body = setup_lldecl(d, mth.attrs.index(&FullRange));\n+                    let needs_body = setup_lldecl(d, &mth.attrs[]);\n                     if needs_body {\n                         trans_fn(ccx, mth.pe_fn_decl(), mth.pe_body(), d,\n                                  psubsts, mth.id, &[]);\n                     }\n                     d\n                 }\n                 _ => {\n-                    ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n-                                           map_node).index(&FullRange))\n+                    ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n+                                           map_node)[])\n                 }\n             }\n         }\n         ast_map::NodeStructCtor(struct_def) => {\n             let d = mk_lldecl(abi::Rust);\n             set_inline_hint(d);\n             base::trans_tuple_struct(ccx,\n-                                     struct_def.fields.index(&FullRange),\n+                                     &struct_def.fields[],\n                                      struct_def.ctor_id.expect(\"ast-mapped tuple struct \\\n                                                                 didn't have a ctor id\"),\n                                      psubsts,\n@@ -275,8 +275,8 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeBlock(..) |\n         ast_map::NodePat(..) |\n         ast_map::NodeLocal(..) => {\n-            ccx.sess().bug(format!(\"can't monomorphize a {:?}\",\n-                                   map_node).index(&FullRange))\n+            ccx.sess().bug(&format!(\"can't monomorphize a {:?}\",\n+                                   map_node)[])\n         }\n     };\n \n@@ -300,8 +300,6 @@ pub fn apply_param_substs<'tcx,T>(tcx: &ty::ctxt<'tcx>,\n                                   -> T\n     where T : TypeFoldable<'tcx> + Repr<'tcx> + HasProjectionTypes + Clone\n {\n-    assert!(param_substs.regions.is_erased());\n-\n     let substituted = value.subst(tcx, param_substs);\n     normalize_associated_type(tcx, &substituted)\n }\n@@ -315,8 +313,10 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n {\n     debug!(\"normalize_associated_type(t={})\", value.repr(tcx));\n \n+    let value = erase_regions(tcx, value);\n+\n     if !value.has_projection_types() {\n-        return value.clone();\n+        return value;\n     }\n \n     // FIXME(#20304) -- cache\n@@ -326,7 +326,7 @@ pub fn normalize_associated_type<'tcx,T>(tcx: &ty::ctxt<'tcx>, value: &T) -> T\n     let mut selcx = traits::SelectionContext::new(&infcx, &typer);\n     let cause = traits::ObligationCause::dummy();\n     let traits::Normalized { value: result, obligations } =\n-        traits::normalize(&mut selcx, cause, value);\n+        traits::normalize(&mut selcx, cause, &value);\n \n     debug!(\"normalize_associated_type: result={} obligations={}\",\n            result.repr(tcx),"}, {"sha": "e2ed275d4c0ccf278f25542f6159d0f3130678b5", "filename": "src/librustc_trans/trans/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -103,7 +103,7 @@ impl Type {\n     }\n \n     pub fn int(ccx: &CrateContext) -> Type {\n-        match ccx.tcx().sess.target.target.target_word_size.index(&FullRange) {\n+        match &ccx.tcx().sess.target.target.target_pointer_width[] {\n             \"32\" => Type::i32(ccx),\n             \"64\" => Type::i64(ccx),\n             tws => panic!(\"Unsupported target word size for int: {}\", tws),"}, {"sha": "034a1ee8be5925ef2903803cb4de9def9da020ec", "filename": "src/librustc_trans/trans/type_of.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Ftype_of.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -140,7 +140,7 @@ pub fn type_of_rust_fn<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     let input_tys = inputs.iter().map(|&arg_ty| type_of_explicit_arg(cx, arg_ty));\n     atys.extend(input_tys);\n \n-    Type::func(atys.index(&FullRange), &lloutputtype)\n+    Type::func(&atys[], &lloutputtype)\n }\n \n // Given a function type and a count of ty params, construct an llvm type\n@@ -180,8 +180,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n \n     let llsizingty = match t.sty {\n         _ if !lltype_is_sized(cx.tcx(), t) => {\n-            cx.sess().bug(format!(\"trying to take the sizing type of {}, an unsized type\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n+            cx.sess().bug(&format!(\"trying to take the sizing type of {}, an unsized type\",\n+                                  ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n \n         ty::ty_bool => Type::bool(cx),\n@@ -233,8 +233,8 @@ pub fn sizing_type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Typ\n         }\n \n         ty::ty_projection(..) | ty::ty_infer(..) | ty::ty_param(..) | ty::ty_err(..) => {\n-            cx.sess().bug(format!(\"fictitious type {} in sizing_type_of()\",\n-                                  ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n+            cx.sess().bug(&format!(\"fictitious type {} in sizing_type_of()\",\n+                                  ppaux::ty_to_string(cx.tcx(), t))[])\n         }\n         ty::ty_vec(_, None) | ty::ty_trait(..) | ty::ty_str => panic!(\"unreachable\")\n     };\n@@ -285,7 +285,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n     // Rust types are defined as the same LLVM types.  If we don't do\n     // this then, e.g. `Option<{myfield: bool}>` would be a different\n     // type than `Option<myrec>`.\n-    let t_norm = normalize_ty(cx.tcx(), t);\n+    let t_norm = erase_regions(cx.tcx(), &t);\n \n     if t != t_norm {\n         let llty = type_of(cx, t_norm);\n@@ -313,7 +313,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           let repr = adt::represent_type(cx, t);\n           let tps = substs.types.get_slice(subst::TypeSpace);\n           let name = llvm_type_name(cx, an_enum, did, tps);\n-          adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n+          adt::incomplete_type_of(cx, &*repr, &name[])\n       }\n       ty::ty_unboxed_closure(did, _, ref substs) => {\n           // Only create the named struct, but don't fill it in. We\n@@ -324,7 +324,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n           // contents of the VecPerParamSpace to to construct the llvm\n           // name\n           let name = llvm_type_name(cx, an_unboxed_closure, did, substs.types.as_slice());\n-          adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n+          adt::incomplete_type_of(cx, &*repr, &name[])\n       }\n \n       ty::ty_uniq(ty) | ty::ty_rptr(_, ty::mt{ty, ..}) | ty::ty_ptr(ty::mt{ty, ..}) => {\n@@ -380,7 +380,7 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               let repr = adt::represent_type(cx, t);\n               let tps = substs.types.get_slice(subst::TypeSpace);\n               let name = llvm_type_name(cx, a_struct, did, tps);\n-              adt::incomplete_type_of(cx, &*repr, name.index(&FullRange))\n+              adt::incomplete_type_of(cx, &*repr, &name[])\n           }\n       }\n \n@@ -398,8 +398,8 @@ pub fn type_of<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, t: Ty<'tcx>) -> Type {\n               Type::struct_(cx, &[p_ty, type_of_unsize_info(cx, t)], false)\n           }\n           ty::ty_trait(..) => Type::opaque_trait(cx),\n-          _ => cx.sess().bug(format!(\"ty_open with sized type: {}\",\n-                                     ppaux::ty_to_string(cx.tcx(), t)).index(&FullRange))\n+          _ => cx.sess().bug(&format!(\"ty_open with sized type: {}\",\n+                                     ppaux::ty_to_string(cx.tcx(), t))[])\n       },\n \n       ty::ty_infer(..) => cx.sess().bug(\"type_of with ty_infer\"),"}, {"sha": "2046ee015f685faafb8c95d22db9cc1c5d824170", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 34, "deletions": 79, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -52,7 +52,6 @@ use middle::const_eval;\n use middle::def;\n use middle::resolve_lifetime as rl;\n use middle::subst::{FnSpace, TypeSpace, SelfSpace, Subst, Substs};\n-use middle::subst::{VecPerParamSpace};\n use middle::traits;\n use middle::ty::{self, RegionEscape, ToPolyTraitRef, Ty};\n use rscope::{self, UnelidableRscope, RegionScope, SpecificRscope,\n@@ -193,11 +192,11 @@ pub fn opt_ast_region_to_region<'tcx>(\n                                     format!(\"`{}`\", name)\n                                 };\n \n-                                m.push_str(if n == 1 {\n+                                m.push_str(&(if n == 1 {\n                                     help_name\n                                 } else {\n                                     format!(\"one of {}'s {} elided lifetimes\", help_name, n)\n-                                }.index(&FullRange));\n+                                })[]);\n \n                                 if len == 2 && i == 0 {\n                                     m.push_str(\" or \");\n@@ -244,7 +243,7 @@ pub fn opt_ast_region_to_region<'tcx>(\n \n /// Given a path `path` that refers to an item `I` with the declared generics `decl_generics`,\n /// returns an appropriate set of substitutions for this particular reference to `I`.\n-fn ast_path_substs_for_ty<'tcx>(\n+pub fn ast_path_substs_for_ty<'tcx>(\n     this: &AstConv<'tcx>,\n     rscope: &RegionScope,\n     decl_generics: &ty::Generics<'tcx>,\n@@ -344,21 +343,21 @@ fn create_substs_for_ast_path<'tcx>(\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(span,\n-                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            required_ty_param_count,\n-                                           supplied_ty_param_count).index(&FullRange));\n+                                           supplied_ty_param_count)[]);\n     } else if supplied_ty_param_count > formal_ty_param_count {\n         let expected = if required_ty_param_count < formal_ty_param_count {\n             \"expected at most\"\n         } else {\n             \"expected\"\n         };\n         this.tcx().sess.span_fatal(span,\n-                                   format!(\"wrong number of type arguments: {} {}, found {}\",\n+                                   &format!(\"wrong number of type arguments: {} {}, found {}\",\n                                            expected,\n                                            formal_ty_param_count,\n-                                           supplied_ty_param_count).index(&FullRange));\n+                                           supplied_ty_param_count)[]);\n     }\n \n     let mut substs = Substs::new_type(types, regions);\n@@ -377,7 +376,7 @@ fn create_substs_for_ast_path<'tcx>(\n         }\n     }\n \n-    for param in ty_param_defs.index(&(supplied_ty_param_count..)).iter() {\n+    for param in ty_param_defs[supplied_ty_param_count..].iter() {\n         match param.default {\n             Some(default) => {\n                 // This is a default type parameter.\n@@ -556,8 +555,8 @@ pub fn instantiate_trait_ref<'tcx>(\n         _ => {\n             this.tcx().sess.span_fatal(\n                 ast_trait_ref.path.span,\n-                format!(\"`{}` is not a trait\",\n-                        ast_trait_ref.path.user_string(this.tcx())).index(&FullRange));\n+                &format!(\"`{}` is not a trait\",\n+                        ast_trait_ref.path.user_string(this.tcx()))[]);\n         }\n     }\n }\n@@ -762,50 +761,6 @@ pub fn ast_path_to_ty<'tcx>(\n     TypeAndSubsts { substs: substs, ty: ty }\n }\n \n-/// Returns the type that this AST path refers to. If the path has no type\n-/// parameters and the corresponding type has type parameters, fresh type\n-/// and/or region variables are substituted.\n-///\n-/// This is used when checking the constructor in struct literals.\n-pub fn ast_path_to_ty_relaxed<'tcx>(\n-    this: &AstConv<'tcx>,\n-    rscope: &RegionScope,\n-    did: ast::DefId,\n-    path: &ast::Path)\n-    -> TypeAndSubsts<'tcx>\n-{\n-    let tcx = this.tcx();\n-    let ty::TypeScheme {\n-        generics,\n-        ty: decl_ty\n-    } = this.get_item_type_scheme(did);\n-\n-    let wants_params =\n-        generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n-\n-    let needs_defaults =\n-        wants_params &&\n-        path.segments.iter().all(|s| s.parameters.is_empty());\n-\n-    let substs = if needs_defaults {\n-        let type_params: Vec<_> = range(0, generics.types.len(TypeSpace))\n-                                      .map(|_| this.ty_infer(path.span)).collect();\n-        let region_params =\n-            rscope.anon_regions(path.span, generics.regions.len(TypeSpace))\n-                  .unwrap();\n-        Substs::new(VecPerParamSpace::params_from_type(type_params),\n-                    VecPerParamSpace::params_from_type(region_params))\n-    } else {\n-        ast_path_substs_for_ty(this, rscope, &generics, path)\n-    };\n-\n-    let ty = decl_ty.subst(tcx, &substs);\n-    TypeAndSubsts {\n-        substs: substs,\n-        ty: ty,\n-    }\n-}\n-\n /// Converts the given AST type to a built-in type. A \"built-in type\" is, at\n /// present, either a core numeric type, a string, or `Box`.\n pub fn ast_ty_to_builtin_ty<'tcx>(\n@@ -825,8 +780,8 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                     this.tcx()\n                         .sess\n                         .span_bug(ast_ty.span,\n-                                  format!(\"unbound path {}\",\n-                                          path.repr(this.tcx())).index(&FullRange))\n+                                  &format!(\"unbound path {}\",\n+                                          path.repr(this.tcx()))[])\n                 }\n                 Some(&d) => d\n             };\n@@ -847,8 +802,8 @@ pub fn ast_ty_to_builtin_ty<'tcx>(\n                         _ => {\n                             this.tcx().sess.span_bug(\n                                 path.span,\n-                                format!(\"converting `Box` to `{}`\",\n-                                        ty.repr(this.tcx())).index(&FullRange));\n+                                &format!(\"converting `Box` to `{}`\",\n+                                        ty.repr(this.tcx()))[]);\n                         }\n                     }\n                 }\n@@ -1068,14 +1023,14 @@ pub fn ast_ty_to_ty<'tcx>(\n                 ty::mk_vec(tcx, ast_ty_to_ty(this, rscope, &**ty), None)\n             }\n             ast::TyObjectSum(ref ty, ref bounds) => {\n-                match ast_ty_to_trait_ref(this, rscope, &**ty, bounds.index(&FullRange)) {\n+                match ast_ty_to_trait_ref(this, rscope, &**ty, &bounds[]) {\n                     Ok((trait_ref, projection_bounds)) => {\n                         trait_ref_to_object_type(this,\n                                                  rscope,\n                                                  ast_ty.span,\n                                                  trait_ref,\n                                                  projection_bounds,\n-                                                 bounds.index(&FullRange))\n+                                                 &bounds[])\n                     }\n                     Err(ErrorReported) => {\n                         this.tcx().types.err\n@@ -1110,15 +1065,15 @@ pub fn ast_ty_to_ty<'tcx>(\n                 ty::mk_bare_fn(tcx, None, tcx.mk_bare_fn(bare_fn))\n             }\n             ast::TyPolyTraitRef(ref bounds) => {\n-                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, bounds.index(&FullRange))\n+                conv_ty_poly_trait_ref(this, rscope, ast_ty.span, &bounds[])\n             }\n             ast::TyPath(ref path, id) => {\n                 let a_def = match tcx.def_map.borrow().get(&id) {\n                     None => {\n                         tcx.sess\n                            .span_bug(ast_ty.span,\n-                                     format!(\"unbound path {}\",\n-                                             path.repr(tcx)).index(&FullRange))\n+                                     &format!(\"unbound path {}\",\n+                                             path.repr(tcx))[])\n                     }\n                     Some(&d) => d\n                 };\n@@ -1156,8 +1111,8 @@ pub fn ast_ty_to_ty<'tcx>(\n                     }\n                     def::DefMod(id) => {\n                         tcx.sess.span_fatal(ast_ty.span,\n-                            format!(\"found module name used as a type: {}\",\n-                                    tcx.map.node_to_string(id.node)).index(&FullRange));\n+                            &format!(\"found module name used as a type: {}\",\n+                                    tcx.map.node_to_string(id.node))[]);\n                     }\n                     def::DefPrimTy(_) => {\n                         panic!(\"DefPrimTy arm missed in previous ast_ty_to_prim_ty call\");\n@@ -1166,7 +1121,7 @@ pub fn ast_ty_to_ty<'tcx>(\n                         let path_str = tcx.map.path_to_string(\n                             tcx.map.get_parent(trait_type_id.node));\n                         tcx.sess.span_err(ast_ty.span,\n-                                          format!(\"ambiguous associated \\\n+                                          &format!(\"ambiguous associated \\\n                                                    type; specify the type \\\n                                                    using the syntax `<Type \\\n                                                    as {}>::{}`\",\n@@ -1176,17 +1131,17 @@ pub fn ast_ty_to_ty<'tcx>(\n                                                           .last()\n                                                           .unwrap()\n                                                           .identifier)\n-                                                  .get()).index(&FullRange));\n+                                                  .get())[]);\n                         this.tcx().types.err\n                     }\n                     def::DefAssociatedPath(provenance, assoc_ident) => {\n                         associated_path_def_to_ty(this, ast_ty, provenance, assoc_ident.name)\n                     }\n                     _ => {\n                         tcx.sess.span_fatal(ast_ty.span,\n-                                            format!(\"found value name used \\\n+                                            &format!(\"found value name used \\\n                                                      as a type: {:?}\",\n-                                                    a_def).index(&FullRange));\n+                                                    a_def)[]);\n                     }\n                 }\n             }\n@@ -1212,9 +1167,9 @@ pub fn ast_ty_to_ty<'tcx>(\n                     Err(ref r) => {\n                         tcx.sess.span_fatal(\n                             ast_ty.span,\n-                            format!(\"expected constant expr for array \\\n+                            &format!(\"expected constant expr for array \\\n                                      length: {}\",\n-                                    *r).index(&FullRange));\n+                                    *r)[]);\n                     }\n                 }\n             }\n@@ -1336,7 +1291,7 @@ fn ty_of_method_or_bare_fn<'a, 'tcx>(this: &AstConv<'tcx>,\n     let input_params = if self_ty.is_some() {\n         decl.inputs.slice_from(1)\n     } else {\n-        decl.inputs.index(&FullRange)\n+        &decl.inputs[]\n     };\n     let input_tys = input_params.iter().map(|a| ty_of_arg(this, &rb, a, None));\n     let input_pats: Vec<String> = input_params.iter()\n@@ -1551,7 +1506,7 @@ fn conv_ty_poly_trait_ref<'tcx>(\n     ast_bounds: &[ast::TyParamBound])\n     -> Ty<'tcx>\n {\n-    let mut partitioned_bounds = partition_bounds(this.tcx(), span, ast_bounds.index(&FullRange));\n+    let mut partitioned_bounds = partition_bounds(this.tcx(), span, &ast_bounds[]);\n \n     let mut projection_bounds = Vec::new();\n     let main_trait_bound = if !partitioned_bounds.trait_bounds.is_empty() {\n@@ -1600,8 +1555,8 @@ pub fn conv_existential_bounds_from_partitioned_bounds<'tcx>(\n         let b = &trait_bounds[0];\n         this.tcx().sess.span_err(\n             b.trait_ref.path.span,\n-            format!(\"only the builtin traits can be used \\\n-                     as closure or object bounds\").index(&FullRange));\n+            &format!(\"only the builtin traits can be used \\\n+                     as closure or object bounds\")[]);\n     }\n \n     let region_bound = compute_region_bound(this,\n@@ -1673,8 +1628,8 @@ fn compute_opt_region_bound<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if derived_region_bounds.slice_from(1).iter().any(|r1| r != *r1) {\n         tcx.sess.span_err(\n             span,\n-            format!(\"ambiguous lifetime bound, \\\n-                     explicit lifetime bound required\").index(&FullRange));\n+            &format!(\"ambiguous lifetime bound, \\\n+                     explicit lifetime bound required\")[]);\n     }\n     return Some(r);\n }\n@@ -1700,7 +1655,7 @@ fn compute_region_bound<'tcx>(\n                 None => {\n                     this.tcx().sess.span_err(\n                         span,\n-                        format!(\"explicit lifetime bound required\").index(&FullRange));\n+                        &format!(\"explicit lifetime bound required\")[]);\n                     ty::ReStatic\n                 }\n             }"}, {"sha": "cacf9bb19d20faeabcedd73894b7b4ebe8bd7256", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -195,14 +195,6 @@ pub fn check_pat<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,\n         ast::PatRegion(ref inner, mutbl) => {\n             let inner_ty = fcx.infcx().next_ty_var();\n \n-            // SNAP 340ac04 remove this `if`-`else` entirely after next snapshot\n-            let mutbl = if mutbl == ast::MutImmutable {\n-                ty::deref(fcx.infcx().shallow_resolve(expected), true)\n-                   .map(|mt| mt.mutbl).unwrap_or(ast::MutImmutable)\n-            } else {\n-                mutbl\n-            };\n-\n             let mt = ty::mt { ty: inner_ty, mutbl: mutbl };\n             let region = fcx.infcx().next_region_var(infer::PatternRegion(pat.span));\n             let rptr_ty = ty::mk_rptr(tcx, tcx.mk_region(region), mt);"}, {"sha": "7e72f300f417847ba7f071564d4710c5ae46d87a", "filename": "src/librustc_typeck/check/method/confirm.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fconfirm.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -314,8 +314,8 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             None => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n-                            self_ty.repr(self.tcx())).index(&FullRange))\n+                    &format!(\"self-type `{}` for ObjectPick never dereferenced to an object\",\n+                            self_ty.repr(self.tcx()))[])\n             }\n         }\n     }\n@@ -367,10 +367,10 @@ impl<'a,'tcx> ConfirmContext<'a,'tcx> {\n             Err(_) => {\n                 self.tcx().sess.span_bug(\n                     self.span,\n-                    format!(\n+                    &format!(\n                         \"{} was a subtype of {} but now is not?\",\n                         self_ty.repr(self.tcx()),\n-                        method_self_ty.repr(self.tcx())).index(&FullRange));\n+                        method_self_ty.repr(self.tcx()))[]);\n             }\n         }\n     }"}, {"sha": "bb000742def9290918c004e8273a133abfa136a5", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -264,19 +264,19 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n                         _ => {\n                             fcx.tcx().sess.span_bug(\n                                 span,\n-                                format!(\n+                                &format!(\n                                     \"trait method is &self but first arg is: {}\",\n-                                    transformed_self_ty.repr(fcx.tcx())).index(&FullRange));\n+                                    transformed_self_ty.repr(fcx.tcx()))[]);\n                         }\n                     }\n                 }\n \n                 _ => {\n                     fcx.tcx().sess.span_bug(\n                         span,\n-                        format!(\n+                        &format!(\n                             \"unexpected explicit self type in operator method: {:?}\",\n-                            method_ty.explicit_self).index(&FullRange));\n+                            method_ty.explicit_self)[]);\n                 }\n             }\n         }\n@@ -329,8 +329,8 @@ pub fn report_error<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             // If the method has the name of a field, give a help note\n             if is_field {\n                 cx.sess.span_note(span,\n-                    format!(\"use `(s.{0})(...)` if you meant to call the \\\n-                            function stored in the `{0}` field\", method_ustring).index(&FullRange));\n+                    &format!(\"use `(s.{0})(...)` if you meant to call the \\\n+                            function stored in the `{0}` field\", method_ustring)[]);\n             }\n \n             if static_sources.len() > 0 {"}, {"sha": "dc4d6c9a826c9912d0b6fb6994016a6f56233d9a", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 111, "deletions": 32, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -18,7 +18,7 @@ use middle::fast_reject;\n use middle::subst;\n use middle::subst::Subst;\n use middle::traits;\n-use middle::ty::{self, Ty, ToPolyTraitRef};\n+use middle::ty::{self, RegionEscape, Ty, ToPolyTraitRef};\n use middle::ty_fold::TypeFoldable;\n use middle::infer;\n use middle::infer::InferCtxt;\n@@ -62,6 +62,7 @@ enum CandidateKind<'tcx> {\n                            subst::Substs<'tcx>, MethodIndex),\n     UnboxedClosureCandidate(/* Trait */ ast::DefId, MethodIndex),\n     WhereClauseCandidate(ty::PolyTraitRef<'tcx>, MethodIndex),\n+    ProjectionCandidate(ast::DefId, MethodIndex),\n }\n \n pub struct Pick<'tcx> {\n@@ -309,18 +310,20 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         // argument type like `&Trait`.\n         let trait_ref = data.principal_trait_ref_with_self_ty(self.tcx(), self_ty);\n         self.elaborate_bounds(&[trait_ref.clone()], false, |this, new_trait_ref, m, method_num| {\n+            let new_trait_ref = this.erase_late_bound_regions(&new_trait_ref);\n+\n             let vtable_index =\n                 traits::get_vtable_index_of_object_method(tcx,\n                                                           trait_ref.clone(),\n-                                                          new_trait_ref.def_id(),\n+                                                          new_trait_ref.def_id,\n                                                           method_num);\n \n-            let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs());\n+            let xform_self_ty = this.xform_self_ty(&m, new_trait_ref.substs);\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: m,\n-                kind: ObjectCandidate(new_trait_ref.def_id(), method_num, vtable_index)\n+                kind: ObjectCandidate(new_trait_ref.def_id, method_num, vtable_index)\n             });\n         });\n     }\n@@ -353,34 +356,37 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             })\n             .collect();\n \n-        self.elaborate_bounds(bounds.as_slice(), true, |this, trait_ref, m, method_num| {\n+        self.elaborate_bounds(bounds.as_slice(), true, |this, poly_trait_ref, m, method_num| {\n+            let trait_ref =\n+                this.erase_late_bound_regions(&poly_trait_ref);\n+\n             let xform_self_ty =\n-                this.xform_self_ty(&m, trait_ref.substs());\n+                this.xform_self_ty(&m, trait_ref.substs);\n \n             debug!(\"found match: trait_ref={} substs={} m={}\",\n                    trait_ref.repr(this.tcx()),\n-                   trait_ref.substs().repr(this.tcx()),\n+                   trait_ref.substs.repr(this.tcx()),\n                    m.repr(this.tcx()));\n             assert_eq!(m.generics.types.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs().types.get_slice(subst::TypeSpace).len());\n+                       trait_ref.substs.types.get_slice(subst::TypeSpace).len());\n             assert_eq!(m.generics.regions.get_slice(subst::TypeSpace).len(),\n-                       trait_ref.substs().regions().get_slice(subst::TypeSpace).len());\n+                       trait_ref.substs.regions().get_slice(subst::TypeSpace).len());\n             assert_eq!(m.generics.types.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs().types.get_slice(subst::SelfSpace).len());\n+                       trait_ref.substs.types.get_slice(subst::SelfSpace).len());\n             assert_eq!(m.generics.regions.get_slice(subst::SelfSpace).len(),\n-                       trait_ref.substs().regions().get_slice(subst::SelfSpace).len());\n+                       trait_ref.substs.regions().get_slice(subst::SelfSpace).len());\n \n             // Because this trait derives from a where-clause, it\n             // should not contain any inference variables or other\n             // artifacts. This means it is safe to put into the\n             // `WhereClauseCandidate` and (eventually) into the\n             // `WhereClausePick`.\n-            assert!(trait_ref.substs().types.iter().all(|&t| !ty::type_needs_infer(t)));\n+            assert!(trait_ref.substs.types.iter().all(|&t| !ty::type_needs_infer(t)));\n \n             this.inherent_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: m,\n-                kind: WhereClauseCandidate(trait_ref, method_num)\n+                kind: WhereClauseCandidate(poly_trait_ref, method_num)\n             });\n         });\n     }\n@@ -474,6 +480,10 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                                                  method.clone(),\n                                                  matching_index);\n \n+        self.assemble_projection_candidates(trait_def_id,\n+                                            method.clone(),\n+                                            matching_index);\n+\n         self.assemble_where_clause_candidates(trait_def_id,\n                                               method,\n                                               matching_index);\n@@ -575,8 +585,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                 None => {\n                     self.tcx().sess.span_bug(\n                         self.span,\n-                        format!(\"No entry for unboxed closure: {}\",\n-                                closure_def_id.repr(self.tcx())).index(&FullRange));\n+                        &format!(\"No entry for unboxed closure: {}\",\n+                                closure_def_id.repr(self.tcx()))[]);\n                 }\n             };\n \n@@ -603,6 +613,64 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         }\n     }\n \n+    fn assemble_projection_candidates(&mut self,\n+                                      trait_def_id: ast::DefId,\n+                                      method: Rc<ty::Method<'tcx>>,\n+                                      method_index: uint)\n+    {\n+        debug!(\"assemble_projection_candidates(\\\n+               trait_def_id={}, \\\n+               method={}, \\\n+               method_index={})\",\n+               trait_def_id.repr(self.tcx()),\n+               method.repr(self.tcx()),\n+               method_index);\n+\n+        for step in self.steps.iter() {\n+            debug!(\"assemble_projection_candidates: step={}\",\n+                   step.repr(self.tcx()));\n+\n+            let projection_trait_ref = match step.self_ty.sty {\n+                ty::ty_projection(ref data) => &data.trait_ref,\n+                _ => continue,\n+            };\n+\n+            debug!(\"assemble_projection_candidates: projection_trait_ref={}\",\n+                   projection_trait_ref.repr(self.tcx()));\n+\n+            let trait_def = ty::lookup_trait_def(self.tcx(), projection_trait_ref.def_id);\n+            let bounds = trait_def.generics.to_bounds(self.tcx(), projection_trait_ref.substs);\n+            let predicates = bounds.predicates.into_vec();\n+            debug!(\"assemble_projection_candidates: predicates={}\",\n+                   predicates.repr(self.tcx()));\n+            for poly_bound in\n+                traits::elaborate_predicates(self.tcx(), predicates)\n+                .filter_map(|p| p.to_opt_poly_trait_ref())\n+                .filter(|b| b.def_id() == trait_def_id)\n+            {\n+                let bound = self.erase_late_bound_regions(&poly_bound);\n+\n+                debug!(\"assemble_projection_candidates: projection_trait_ref={} bound={}\",\n+                       projection_trait_ref.repr(self.tcx()),\n+                       bound.repr(self.tcx()));\n+\n+                if self.infcx().can_equate(&step.self_ty, &bound.self_ty()).is_ok() {\n+                    let xform_self_ty = self.xform_self_ty(&method, bound.substs);\n+\n+                    debug!(\"assemble_projection_candidates: bound={} xform_self_ty={}\",\n+                           bound.repr(self.tcx()),\n+                           xform_self_ty.repr(self.tcx()));\n+\n+                    self.extension_candidates.push(Candidate {\n+                        xform_self_ty: xform_self_ty,\n+                        method_ty: method.clone(),\n+                        kind: ProjectionCandidate(trait_def_id, method_index)\n+                    });\n+                }\n+            }\n+        }\n+    }\n+\n     fn assemble_where_clause_candidates(&mut self,\n                                         trait_def_id: ast::DefId,\n                                         method_ty: Rc<ty::Method<'tcx>>,\n@@ -611,14 +679,14 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"assemble_where_clause_candidates(trait_def_id={})\",\n                trait_def_id.repr(self.tcx()));\n \n-        // Check whether there are any where-clauses pertaining to this trait.\n         let caller_predicates =\n             self.fcx.inh.param_env.caller_bounds.predicates.as_slice().to_vec();\n-        for bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n-                     .filter_map(|p| p.to_opt_poly_trait_ref())\n-                     .filter(|b| b.def_id() == trait_def_id)\n+        for poly_bound in traits::elaborate_predicates(self.tcx(), caller_predicates)\n+                          .filter_map(|p| p.to_opt_poly_trait_ref())\n+                          .filter(|b| b.def_id() == trait_def_id)\n         {\n-            let xform_self_ty = self.xform_self_ty(&method_ty, bound.substs());\n+            let bound = self.erase_late_bound_regions(&poly_bound);\n+            let xform_self_ty = self.xform_self_ty(&method_ty, bound.substs);\n \n             debug!(\"assemble_where_clause_candidates: bound={} xform_self_ty={}\",\n                    bound.repr(self.tcx()),\n@@ -627,7 +695,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             self.extension_candidates.push(Candidate {\n                 xform_self_ty: xform_self_ty,\n                 method_ty: method_ty.clone(),\n-                kind: WhereClauseCandidate(bound, method_index)\n+                kind: WhereClauseCandidate(poly_bound, method_index)\n             });\n         }\n     }\n@@ -745,15 +813,15 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"pick_method(self_ty={})\", self.infcx().ty_to_string(self_ty));\n \n         debug!(\"searching inherent candidates\");\n-        match self.consider_candidates(self_ty, self.inherent_candidates.index(&FullRange)) {\n+        match self.consider_candidates(self_ty, &self.inherent_candidates[]) {\n             None => {}\n             Some(pick) => {\n                 return Some(pick);\n             }\n         }\n \n         debug!(\"searching extension candidates\");\n-        self.consider_candidates(self_ty, self.extension_candidates.index(&FullRange))\n+        self.consider_candidates(self_ty, &self.extension_candidates[])\n     }\n \n     fn consider_candidates(&self,\n@@ -768,7 +836,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n         debug!(\"applicable_candidates: {}\", applicable_candidates.repr(self.tcx()));\n \n         if applicable_candidates.len() > 1 {\n-            match self.collapse_candidates_to_trait_pick(applicable_candidates.index(&FullRange)) {\n+            match self.collapse_candidates_to_trait_pick(&applicable_candidates[]) {\n                 Some(pick) => { return Some(Ok(pick)); }\n                 None => { }\n             }\n@@ -829,6 +897,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                         norm_obligations.iter().all(|o| selcx.evaluate_obligation(o))\n                 }\n \n+                ProjectionCandidate(..) |\n                 ObjectCandidate(..) |\n                 UnboxedClosureCandidate(..) |\n                 WhereClauseCandidate(..) => {\n@@ -864,7 +933,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             Some(data) => data,\n             None => return None,\n         };\n-        if probes.index(&(1..)).iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n+        if probes[1..].iter().any(|p| p.to_trait_data() != Some(trait_data)) {\n             return None;\n         }\n \n@@ -920,6 +989,8 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n                method.fty.sig.0.inputs[0].repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n+        assert!(!substs.has_escaping_regions());\n+\n         // It is possible for type parameters or early-bound lifetimes\n         // to appear in the signature of `self`. The substitutions we\n         // are given do not include type/lifetime parameters for the\n@@ -949,14 +1020,13 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             substs = &placeholder;\n         }\n \n-        // Replace early-bound regions and types.\n-        let xform_self_ty = method.fty.sig.0.inputs[0].subst(self.tcx(), substs);\n+        // Erase any late-bound regions from the method and substitute\n+        // in the values from the substitution.\n+        let xform_self_ty = method.fty.sig.input(0);\n+        let xform_self_ty = self.erase_late_bound_regions(&xform_self_ty);\n+        let xform_self_ty = xform_self_ty.subst(self.tcx(), substs);\n \n-        // Replace late-bound regions bound in the impl or\n-        // where-clause (2 levels of binding) and method (1 level of binding).\n-        self.erase_late_bound_regions(\n-            &self.erase_late_bound_regions(\n-                &ty::Binder(ty::Binder(xform_self_ty))))\n+        xform_self_ty\n     }\n \n     fn impl_substs(&self,\n@@ -1065,6 +1135,9 @@ impl<'tcx> Candidate<'tcx> {\n \n                     WhereClausePick((*trait_ref).clone(), index)\n                 }\n+                ProjectionCandidate(def_id, index) => {\n+                    TraitPick(def_id, index)\n+                }\n             }\n         }\n     }\n@@ -1076,6 +1149,7 @@ impl<'tcx> Candidate<'tcx> {\n             ExtensionImplCandidate(def_id, _, _, _) => ImplSource(def_id),\n             UnboxedClosureCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n             WhereClauseCandidate(ref trait_ref, _) => TraitSource(trait_ref.def_id()),\n+            ProjectionCandidate(trait_def_id, _) => TraitSource(trait_def_id),\n         }\n     }\n \n@@ -1094,6 +1168,9 @@ impl<'tcx> Candidate<'tcx> {\n             WhereClauseCandidate(ref trait_ref, method_num) => {\n                 Some((trait_ref.def_id(), method_num))\n             }\n+            ProjectionCandidate(trait_def_id, method_num) => {\n+                Some((trait_def_id, method_num))\n+            }\n         }\n     }\n }\n@@ -1120,6 +1197,8 @@ impl<'tcx> Repr<'tcx> for CandidateKind<'tcx> {\n                 format!(\"UnboxedClosureCandidate({},{})\", a.repr(tcx), b),\n             WhereClauseCandidate(ref a, ref b) =>\n                 format!(\"WhereClauseCandidate({},{})\", a.repr(tcx), b),\n+            ProjectionCandidate(ref a, ref b) =>\n+                format!(\"ProjectionCandidate({},{})\", a.repr(tcx), b),\n         }\n     }\n }"}, {"sha": "b98b327100cdb7e1abb2e8344298679638cca359", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 86, "deletions": 51, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -90,7 +90,7 @@ use middle::mem_categorization as mc;\n use middle::mem_categorization::McResult;\n use middle::pat_util::{self, pat_id_map};\n use middle::region::CodeExtent;\n-use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace};\n+use middle::subst::{self, Subst, Substs, VecPerParamSpace, ParamSpace, TypeSpace};\n use middle::traits;\n use middle::ty::{FnSig, VariantInfo, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n@@ -593,7 +593,7 @@ fn check_fn<'a, 'tcx>(ccx: &'a CrateCtxt<'a, 'tcx>,\n     let tcx = ccx.tcx;\n     let err_count_on_creation = tcx.sess.err_count();\n \n-    let arg_tys = fn_sig.inputs.index(&FullRange);\n+    let arg_tys = &fn_sig.inputs[];\n     let ret_ty = fn_sig.output;\n \n     debug!(\"check_fn(arg_tys={}, ret_ty={}, fn_id={})\",\n@@ -691,7 +691,7 @@ pub fn check_item(ccx: &CrateCtxt, it: &ast::Item) {\n       ast::ItemEnum(ref enum_definition, _) => {\n         check_enum_variants(ccx,\n                             it.span,\n-                            enum_definition.variants.index(&FullRange),\n+                            &enum_definition.variants[],\n                             it.id);\n       }\n       ast::ItemFn(ref decl, _, _, _, ref body) => {\n@@ -985,21 +985,21 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         (&ty::StaticExplicitSelfCategory, _) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the impl, \\\n+                &format!(\"method `{}` has a `{}` declaration in the impl, \\\n                         but not in the trait\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &impl_m.explicit_self)).index(&FullRange));\n+                            &impl_m.explicit_self))[]);\n             return;\n         }\n         (_, &ty::StaticExplicitSelfCategory) => {\n             tcx.sess.span_err(\n                 impl_m_span,\n-                format!(\"method `{}` has a `{}` declaration in the trait, \\\n+                &format!(\"method `{}` has a `{}` declaration in the trait, \\\n                         but not in the impl\",\n                         token::get_name(trait_m.name),\n                         ppaux::explicit_self_category_to_str(\n-                            &trait_m.explicit_self)).index(&FullRange));\n+                            &trait_m.explicit_self))[]);\n             return;\n         }\n         _ => {\n@@ -1358,9 +1358,9 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n         if trait_params.len() != impl_params.len() {\n             tcx.sess.span_err(\n                 span,\n-                format!(\"lifetime parameters or bounds on method `{}` do \\\n+                &format!(\"lifetime parameters or bounds on method `{}` do \\\n                          not match the trait declaration\",\n-                        token::get_name(impl_m.name)).index(&FullRange));\n+                        token::get_name(impl_m.name))[]);\n             return false;\n         }\n \n@@ -1406,13 +1406,13 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             let err = if missing.len() != 0 || extra.len() != 0 {\n                 tcx.sess.span_err(\n                     span,\n-                    format!(\n+                    &format!(\n                         \"the lifetime parameter `{}` declared in the impl \\\n                          has a distinct set of bounds \\\n                          from its counterpart `{}` \\\n                          declared in the trait\",\n                         impl_param.name.user_string(tcx),\n-                        trait_param.name.user_string(tcx)).index(&FullRange));\n+                        trait_param.name.user_string(tcx))[]);\n                 true\n             } else {\n                 false\n@@ -1421,15 +1421,15 @@ fn compare_impl_method<'tcx>(tcx: &ty::ctxt<'tcx>,\n             if missing.len() != 0 {\n                 tcx.sess.span_note(\n                     span,\n-                    format!(\"the impl is missing the following bounds: `{}`\",\n-                            missing.user_string(tcx)).index(&FullRange));\n+                    &format!(\"the impl is missing the following bounds: `{}`\",\n+                            missing.user_string(tcx))[]);\n             }\n \n             if extra.len() != 0 {\n                 tcx.sess.span_note(\n                     span,\n-                    format!(\"the impl has the following extra bounds: `{}`\",\n-                            extra.user_string(tcx)).index(&FullRange));\n+                    &format!(\"the impl has the following extra bounds: `{}`\",\n+                            extra.user_string(tcx))[]);\n             }\n \n             if err {\n@@ -1699,8 +1699,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             None => {\n                 self.tcx().sess.span_bug(\n                     span,\n-                    format!(\"no type for local variable {}\",\n-                            nid).index(&FullRange));\n+                    &format!(\"no type for local variable {}\",\n+                            nid)[]);\n             }\n         }\n     }\n@@ -1709,7 +1709,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// ! gets replaced with (), unconstrained ints with i32, and unconstrained floats with f64.\n     pub fn default_type_parameters(&self) {\n         use middle::ty::UnconstrainedNumeric::{UnconstrainedInt, UnconstrainedFloat, Neither};\n-        for (_, &ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n+        for (_, &mut ref ty) in self.inh.node_types.borrow_mut().iter_mut() {\n             let resolved = self.infcx().resolve_type_vars_if_possible(ty);\n             if self.infcx().type_var_diverges(resolved) {\n                 demand::eqtype(self, codemap::DUMMY_SP, *ty, ty::mk_nil(self.tcx()));\n@@ -1947,6 +1947,43 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n+    /// Returns the type that this AST path refers to. If the path has no type\n+    /// parameters and the corresponding type has type parameters, fresh type\n+    /// and/or region variables are substituted.\n+    ///\n+    /// This is used when checking the constructor in struct literals.\n+    fn instantiate_struct_literal_ty(&self,\n+                                     did: ast::DefId,\n+                                     path: &ast::Path)\n+                                     -> TypeAndSubsts<'tcx>\n+    {\n+        let tcx = self.tcx();\n+\n+        let ty::TypeScheme { generics, ty: decl_ty } = ty::lookup_item_type(tcx, did);\n+\n+        let wants_params =\n+            generics.has_type_params(TypeSpace) || generics.has_region_params(TypeSpace);\n+\n+        let needs_defaults =\n+            wants_params &&\n+            path.segments.iter().all(|s| s.parameters.is_empty());\n+\n+        let substs = if needs_defaults {\n+            let tps =\n+                self.infcx().next_ty_vars(generics.types.len(TypeSpace));\n+            let rps =\n+                self.infcx().region_vars_for_defs(path.span,\n+                                                  generics.regions.get_slice(TypeSpace));\n+            Substs::new_type(tps, rps)\n+        } else {\n+            astconv::ast_path_substs_for_ty(self, self, &generics, path)\n+        };\n+\n+        let ty = self.instantiate_type_scheme(path.span, &substs, &decl_ty);\n+\n+        TypeAndSubsts { substs: substs, ty: ty }\n+    }\n+\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, ty::mk_nil(self.tcx()));\n     }\n@@ -2033,8 +2070,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         match self.inh.node_types.borrow().get(&ex.id) {\n             Some(&t) => t,\n             None => {\n-                self.tcx().sess.bug(format!(\"no type for expr in fcx {}\",\n-                                            self.tag()).index(&FullRange));\n+                self.tcx().sess.bug(&format!(\"no type for expr in fcx {}\",\n+                                            self.tag())[]);\n             }\n         }\n     }\n@@ -2062,9 +2099,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Some(&t) => t,\n             None => {\n                 self.tcx().sess.bug(\n-                    format!(\"no type for node {}: {} in fcx {}\",\n+                    &format!(\"no type for node {}: {} in fcx {}\",\n                             id, self.tcx().map.node_to_string(id),\n-                            self.tag()).index(&FullRange));\n+                            self.tag())[]);\n             }\n         }\n     }\n@@ -2466,7 +2503,7 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         Ok(trait_did) => trait_did,\n         Err(ref err_string) => {\n             fcx.tcx().sess.span_err(iterator_expr.span,\n-                                    err_string.index(&FullRange));\n+                                    &err_string[]);\n             return fcx.tcx().types.err\n         }\n     };\n@@ -2490,10 +2527,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n             if !ty::type_is_error(true_expr_type) {\n                 let ty_string = fcx.infcx().ty_to_string(true_expr_type);\n                 fcx.tcx().sess.span_err(iterator_expr.span,\n-                                        format!(\"`for` loop expression has type `{}` which does \\\n+                                        &format!(\"`for` loop expression has type `{}` which does \\\n                                                 not implement the `Iterator` trait; \\\n                                                 maybe try .iter()\",\n-                                                ty_string).index(&FullRange));\n+                                                ty_string)[]);\n             }\n             fcx.tcx().types.err\n         }\n@@ -2528,10 +2565,10 @@ fn lookup_method_for_for_loop<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 }\n                 _ => {\n                     fcx.tcx().sess.span_err(iterator_expr.span,\n-                                            format!(\"`next` method of the `Iterator` \\\n+                                            &format!(\"`next` method of the `Iterator` \\\n                                                     trait has an unexpected type `{}`\",\n                                                     fcx.infcx().ty_to_string(return_type))\n-                                            .index(&FullRange));\n+                                            []);\n                     fcx.tcx().types.err\n                 }\n             }\n@@ -2558,7 +2595,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n \n         check_argument_types(fcx,\n                              sp,\n-                             err_inputs.index(&FullRange),\n+                             &err_inputs[],\n                              args_no_rcvr,\n                              autoref_args,\n                              false,\n@@ -3010,7 +3047,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args.index(&(1..)).iter().map(|x| x).collect();\n+        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,\n@@ -3328,7 +3365,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     ty::ty_struct(base_id, substs) => {\n                         debug!(\"struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                         let fields = ty::lookup_struct_fields(tcx, base_id);\n-                        lookup_field_ty(tcx, base_id, fields.index(&FullRange),\n+                        lookup_field_ty(tcx, base_id, &fields[],\n                                         field.node.name, &(*substs))\n                     }\n                     _ => None\n@@ -3391,7 +3428,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                         if tuple_like {\n                             debug!(\"tuple struct named {}\", ppaux::ty_to_string(tcx, base_t));\n                             let fields = ty::lookup_struct_fields(tcx, base_id);\n-                            lookup_tup_field_ty(tcx, base_id, fields.index(&FullRange),\n+                            lookup_tup_field_ty(tcx, base_id, &fields[],\n                                                 idx.node, &(*substs))\n                         } else {\n                             None\n@@ -3490,17 +3527,18 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     expected_field_type =\n                         ty::lookup_field_type(\n                             tcx, class_id, field_id, substitutions);\n+                    expected_field_type =\n+                        fcx.normalize_associated_types_in(\n+                            field.span, &expected_field_type);\n                     class_field_map.insert(\n                         field.ident.node.name, (field_id, true));\n                     fields_found += 1;\n                 }\n             }\n+\n             // Make sure to give a type to the field even if there's\n             // an error, so we can continue typechecking\n-            check_expr_coercable_to_type(\n-                    fcx,\n-                    &*field.expr,\n-                    expected_field_type);\n+            check_expr_coercable_to_type(fcx, &*field.expr, expected_field_type);\n         }\n \n         if error_happened {\n@@ -3556,7 +3594,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        class_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(struct_substs),\n-                                       class_fields.index(&FullRange),\n+                                       &class_fields[],\n                                        fields,\n                                        base_expr.is_none(),\n                                        None);\n@@ -3599,7 +3637,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                        variant_id,\n                                        id,\n                                        fcx.ccx.tcx.mk_substs(substitutions),\n-                                       variant_fields.index(&FullRange),\n+                                       &variant_fields[],\n                                        fields,\n                                        true,\n                                        Some(enum_id));\n@@ -4066,7 +4104,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let expected = expected.only_has_type();\n         let flds = expected.map_to_option(fcx, |ty| {\n             match ty.sty {\n-                ty::ty_tup(ref flds) => Some(flds.index(&FullRange)),\n+                ty::ty_tup(ref flds) => Some(&flds[]),\n                 _ => None\n             }\n         });\n@@ -4100,7 +4138,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         let struct_id = match def {\n             Some(def::DefVariant(enum_id, variant_id, true)) => {\n                 check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, fields.index(&FullRange));\n+                                          variant_id, &fields[]);\n                 enum_id\n             }\n             Some(def::DefTrait(def_id)) => {\n@@ -4109,7 +4147,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     pprust::path_to_string(path));\n                 check_struct_fields_on_error(fcx,\n                                              id,\n-                                             fields.index(&FullRange),\n+                                             &fields[],\n                                              base_expr);\n                 def_id\n             },\n@@ -4122,7 +4160,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                                  id,\n                                                  expr.span,\n                                                  struct_did,\n-                                                 fields.index(&FullRange),\n+                                                 &fields[],\n                                                  base_expr.as_ref().map(|e| &**e));\n                     }\n                     _ => {\n@@ -4131,7 +4169,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                             pprust::path_to_string(path));\n                         check_struct_fields_on_error(fcx,\n                                                      id,\n-                                                     fields.index(&FullRange),\n+                                                     &fields[],\n                                                      base_expr);\n                     }\n                 }\n@@ -4149,10 +4187,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         // parameters correctly.\n         let actual_structure_type = fcx.expr_ty(&*expr);\n         if !ty::type_is_error(actual_structure_type) {\n-            let type_and_substs = astconv::ast_path_to_ty_relaxed(fcx,\n-                                                                  fcx,\n-                                                                  struct_id,\n-                                                                  path);\n+            let type_and_substs = fcx.instantiate_struct_literal_ty(struct_id, path);\n             match fcx.mk_subty(false,\n                                infer::Misc(path.span),\n                                actual_structure_type,\n@@ -4164,15 +4199,15 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                     fcx.tcx()\n                        .sess\n                        .span_err(path.span,\n-                                 format!(\"structure constructor specifies a \\\n+                                 &format!(\"structure constructor specifies a \\\n                                          structure of type `{}`, but this \\\n                                          structure has type `{}`: {}\",\n                                          fcx.infcx()\n                                             .ty_to_string(type_and_substs.ty),\n                                          fcx.infcx()\n                                             .ty_to_string(\n                                                 actual_structure_type),\n-                                         type_error_description).index(&FullRange));\n+                                         type_error_description)[]);\n                     ty::note_and_explain_type_err(tcx, &type_error);\n                 }\n             }\n@@ -4847,7 +4882,7 @@ pub fn check_enum_variants(ccx: &CrateCtxt,\n     }\n \n     let hint = *ty::lookup_repr_hints(ccx.tcx, ast::DefId { krate: ast::LOCAL_CRATE, node: id })\n-                    .index(&FullRange).get(0).unwrap_or(&attr::ReprAny);\n+        [].get(0).unwrap_or(&attr::ReprAny);\n \n     if hint != attr::ReprAny && vs.len() <= 1 {\n         if vs.len() == 1 {\n@@ -5518,7 +5553,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n             \"get_tydesc\" => {\n               let tydesc_ty = match ty::get_tydesc_ty(ccx.tcx) {\n                   Ok(t) => t,\n-                  Err(s) => { tcx.sess.span_fatal(it.span, s.index(&FullRange)); }\n+                  Err(s) => { tcx.sess.span_fatal(it.span, &s[]); }\n               };\n               let td_ptr = ty::mk_ptr(ccx.tcx, ty::mt {\n                   ty: tydesc_ty,\n@@ -5534,7 +5569,7 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n                                 ty::mk_struct(ccx.tcx, did,\n                                               ccx.tcx.mk_substs(subst::Substs::empty()))),\n                     Err(msg) => {\n-                        tcx.sess.span_fatal(it.span, msg.index(&FullRange));\n+                        tcx.sess.span_fatal(it.span, &msg[]);\n                     }\n                 }\n             },"}, {"sha": "112e00536422c2f26556addc082e2d29380c3771", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -188,8 +188,8 @@ fn region_of_def(fcx: &FnCtxt, def: def::Def) -> ty::Region {\n             }\n         }\n         _ => {\n-            tcx.sess.bug(format!(\"unexpected def in region_of_def: {:?}\",\n-                                 def).index(&FullRange))\n+            tcx.sess.bug(&format!(\"unexpected def in region_of_def: {:?}\",\n+                                 def)[])\n         }\n     }\n }\n@@ -282,13 +282,13 @@ impl<'a, 'tcx> Rcx<'a, 'tcx> {\n             Some(f) => f,\n             None => {\n                 self.tcx().sess.bug(\n-                    format!(\"No fn-sig entry for id={}\", id).index(&FullRange));\n+                    &format!(\"No fn-sig entry for id={}\", id)[]);\n             }\n         };\n \n         let len = self.region_bound_pairs.len();\n-        self.relate_free_regions(fn_sig.index(&FullRange), body.id);\n-        link_fn_args(self, CodeExtent::from_node_id(body.id), fn_decl.inputs.index(&FullRange));\n+        self.relate_free_regions(&fn_sig[], body.id);\n+        link_fn_args(self, CodeExtent::from_node_id(body.id), &fn_decl.inputs[]);\n         self.visit_block(body);\n         self.visit_region_obligations(body.id);\n         self.region_bound_pairs.truncate(len);\n@@ -629,7 +629,7 @@ fn visit_expr(rcx: &mut Rcx, expr: &ast::Expr) {\n         }\n \n         ast::ExprMatch(ref discr, ref arms, _) => {\n-            link_match(rcx, &**discr, arms.index(&FullRange));\n+            link_match(rcx, &**discr, &arms[]);\n \n             visit::walk_expr(rcx, expr);\n         }\n@@ -953,8 +953,8 @@ fn constrain_autoderefs<'a, 'tcx>(rcx: &mut Rcx<'a, 'tcx>,\n                 let (m, r) = match self_ty.sty {\n                     ty::ty_rptr(r, ref m) => (m.mutbl, r),\n                     _ => rcx.tcx().sess.span_bug(deref_expr.span,\n-                            format!(\"bad overloaded deref type {}\",\n-                                    method.ty.repr(rcx.tcx())).index(&FullRange))\n+                            &format!(\"bad overloaded deref type {}\",\n+                                    method.ty.repr(rcx.tcx()))[])\n                 };\n                 {\n                     let mc = mc::MemCategorizationContext::new(rcx.fcx);\n@@ -1318,9 +1318,9 @@ fn link_reborrowed_region<'a, 'tcx>(rcx: &Rcx<'a, 'tcx>,\n                 None => {\n                     rcx.tcx().sess.span_bug(\n                         span,\n-                        format!(\"Illegal upvar id: {}\",\n+                        &format!(\"Illegal upvar id: {}\",\n                                 upvar_id.repr(\n-                                    rcx.tcx())).index(&FullRange));\n+                                    rcx.tcx()))[]);\n                 }\n             }\n         }"}, {"sha": "8730858f66e7ced94b5c74ecc906b3517804ca87", "filename": "src/librustc_typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionmanip.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -146,8 +146,8 @@ impl<'a, 'tcx> Wf<'a, 'tcx> {\n \n             ty::ty_open(_) => {\n                 self.tcx.sess.bug(\n-                    format!(\"Unexpected type encountered while doing wf check: {}\",\n-                            ty.repr(self.tcx)).index(&FullRange));\n+                    &format!(\"Unexpected type encountered while doing wf check: {}\",\n+                            ty.repr(self.tcx))[]);\n             }\n         }\n     }"}, {"sha": "3940092eb729100a2f579ad2c2a7e5ecc0864d46", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -72,17 +72,17 @@ pub fn check_object_cast<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         (_, &ty::ty_uniq(..)) => {\n             fcx.ccx.tcx.sess.span_err(\n                 source_expr.span,\n-                format!(\"can only cast an boxed pointer \\\n+                &format!(\"can only cast an boxed pointer \\\n                          to a boxed object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty)).index(&FullRange));\n+                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n         }\n \n         (_, &ty::ty_rptr(..)) => {\n             fcx.ccx.tcx.sess.span_err(\n                 source_expr.span,\n-                format!(\"can only cast a &-pointer \\\n+                &format!(\"can only cast a &-pointer \\\n                          to an &-object, not a {}\",\n-                        ty::ty_sort_string(fcx.tcx(), source_ty)).index(&FullRange));\n+                        ty::ty_sort_string(fcx.tcx(), source_ty))[]);\n         }\n \n         _ => {"}, {"sha": "b17ecdaf59c61c20e981227a13c9d1ead7b86fa6", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 87, "deletions": 11, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -24,6 +24,7 @@ use syntax::ast;\n use syntax::ast_util::{local_def};\n use syntax::attr;\n use syntax::codemap::Span;\n+use syntax::parse::token;\n use syntax::visit;\n use syntax::visit::Visitor;\n \n@@ -77,6 +78,14 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                     enum_variants(fcx, enum_def)\n                 });\n             }\n+            ast::ItemTrait(..) => {\n+                let trait_def =\n+                    ty::lookup_trait_def(ccx.tcx, local_def(item.id));\n+                reject_non_type_param_bounds(\n+                    ccx.tcx,\n+                    item.span,\n+                    &trait_def.generics);\n+            }\n             _ => {}\n         }\n     }\n@@ -237,21 +246,32 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                       span: Span,\n                                       generics: &ty::Generics<'tcx>) {\n+\n     for predicate in generics.predicates.iter() {\n         match predicate {\n             &ty::Predicate::Trait(ty::Binder(ref tr)) => {\n-                let self_ty = tr.self_ty();\n-                if !self_ty.walk().any(|t| is_ty_param(t)) {\n-                    tcx.sess.span_err(\n-                        span,\n-                        format!(\"cannot bound type `{}`, where clause \\\n-                                 bounds may only be attached to types involving \\\n-                                 type parameters\",\n-                                 self_ty.repr(tcx)).as_slice())\n-                }\n+                let found_param = tr.input_types().iter()\n+                                    .flat_map(|ty| ty.walk())\n+                                    .any(is_ty_param);\n+                if !found_param { report_bound_error(tcx, span, tr.self_ty() )}\n+            }\n+            &ty::Predicate::TypeOutlives(ty::Binder(ty::OutlivesPredicate(ty, _))) => {\n+                let found_param = ty.walk().any(|t| is_ty_param(t));\n+                if !found_param { report_bound_error(tcx, span, ty) }\n             }\n             _ => {}\n-        }\n+        };\n+    }\n+\n+    fn report_bound_error<'t>(tcx: &ty::ctxt<'t>,\n+                          span: Span,\n+                          bounded_ty: ty::Ty<'t>) {\n+        tcx.sess.span_err(\n+            span,\n+            format!(\"cannot bound type `{}`, where clause \\\n+                bounds may only be attached to types involving \\\n+                type parameters\",\n+                bounded_ty.repr(tcx)).as_slice())\n     }\n \n     fn is_ty_param(ty: ty::Ty) -> bool {\n@@ -262,11 +282,68 @@ fn reject_non_type_param_bounds<'tcx>(tcx: &ty::ctxt<'tcx>,\n     }\n }\n \n+fn reject_shadowing_type_parameters<'tcx>(tcx: &ty::ctxt<'tcx>,\n+                                          span: Span,\n+                                          generics: &ty::Generics<'tcx>) {\n+    let impl_params = generics.types.get_slice(subst::TypeSpace).iter()\n+        .map(|tp| tp.name).collect::<HashSet<_>>();\n+\n+    for method_param in generics.types.get_slice(subst::FnSpace).iter() {\n+        if impl_params.contains(&method_param.name) {\n+            tcx.sess.span_err(\n+                span,\n+                &*format!(\"type parameter `{}` shadows another type parameter of the same name\",\n+                          token::get_name(method_param.name)));\n+        }\n+    }\n+}\n+\n impl<'ccx, 'tcx, 'v> Visitor<'v> for CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n     fn visit_item(&mut self, i: &ast::Item) {\n         self.check_item_well_formed(i);\n         visit::walk_item(self, i);\n     }\n+\n+    fn visit_fn(&mut self,\n+                fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n+                b: &'v ast::Block, span: Span, id: ast::NodeId) {\n+        match fk {\n+            visit::FkFnBlock | visit::FkItemFn(..) => {}\n+            visit::FkMethod(..) => {\n+                match ty::impl_or_trait_item(self.ccx.tcx, local_def(id)) {\n+                    ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n+                        reject_shadowing_type_parameters(self.ccx.tcx, span, &ty_method.generics)\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+        visit::walk_fn(self, fk, fd, b, span)\n+    }\n+\n+    fn visit_trait_item(&mut self, t: &'v ast::TraitItem) {\n+        match t {\n+            &ast::TraitItem::ProvidedMethod(_) |\n+            &ast::TraitItem::TypeTraitItem(_) => {},\n+            &ast::TraitItem::RequiredMethod(ref method) => {\n+                match ty::impl_or_trait_item(self.ccx.tcx, local_def(method.id)) {\n+                    ty::ImplOrTraitItem::MethodTraitItem(ty_method) => {\n+                        reject_non_type_param_bounds(\n+                            self.ccx.tcx,\n+                            method.span,\n+                            &ty_method.generics);\n+                        reject_shadowing_type_parameters(\n+                            self.ccx.tcx,\n+                            method.span,\n+                            &ty_method.generics);\n+                    }\n+                    _ => {}\n+                }\n+            }\n+        }\n+\n+        visit::walk_trait_item(self, t)\n+    }\n }\n \n pub struct BoundsChecker<'cx,'tcx:'cx> {\n@@ -455,7 +532,6 @@ fn enum_variants<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     let arg_tys =\n                         ty::assert_no_late_bound_regions(\n                             fcx.tcx(), &ty::ty_fn_args(ctor_ty));\n-\n                     AdtVariant {\n                         fields: args.iter().enumerate().map(|(index, arg)| {\n                             let arg_ty = arg_tys[index];"}, {"sha": "9d4aa23960db957fd83c15bc34a3d50cbc547f4e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -68,9 +68,13 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             Some(t.principal_def_id())\n         }\n \n+        ty_uniq(_) => {\n+            inference_context.tcx.lang_items.owned_box()\n+        }\n+\n         ty_bool | ty_char | ty_int(..) | ty_uint(..) | ty_float(..) |\n         ty_str(..) | ty_vec(..) | ty_bare_fn(..) | ty_tup(..) |\n-        ty_param(..) | ty_err | ty_open(..) | ty_uniq(_) |\n+        ty_param(..) | ty_err | ty_open(..) |\n         ty_ptr(_) | ty_rptr(_, _) | ty_projection(..) => {\n             None\n         }\n@@ -80,8 +84,8 @@ fn get_base_type_def_id<'a, 'tcx>(inference_context: &InferCtxt<'a, 'tcx>,\n             // that the user can type\n             inference_context.tcx.sess.span_bug(\n                 span,\n-                format!(\"coherence encountered unexpected type searching for base type: {}\",\n-                        ty.repr(inference_context.tcx)).index(&FullRange));\n+                &format!(\"coherence encountered unexpected type searching for base type: {}\",\n+                        ty.repr(inference_context.tcx))[]);\n         }\n     }\n }\n@@ -487,18 +491,18 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                 Err(ty::FieldDoesNotImplementCopy(name)) => {\n                     tcx.sess\n                        .span_err(span,\n-                                 format!(\"the trait `Copy` may not be \\\n+                                 &format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; field \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name)).index(&FullRange))\n+                                         token::get_name(name))[])\n                 }\n                 Err(ty::VariantDoesNotImplementCopy(name)) => {\n                     tcx.sess\n                        .span_err(span,\n-                                 format!(\"the trait `Copy` may not be \\\n+                                 &format!(\"the trait `Copy` may not be \\\n                                           implemented for this type; variant \\\n                                           `{}` does not implement `Copy`\",\n-                                         token::get_name(name)).index(&FullRange))\n+                                         token::get_name(name))[])\n                 }\n                 Err(ty::TypeIsStructural) => {\n                     tcx.sess\n@@ -507,6 +511,11 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                   for this type; type is not a structure or \\\n                                   enumeration\")\n                 }\n+                Err(ty::TypeHasDestructor) => {\n+                    span_err!(tcx.sess, span, E0184,\n+                              \"the trait `Copy` may not be implemented for this type; \\\n+                               the type has a destructor\");\n+                }\n             }\n         }\n     }"}, {"sha": "c56952abc4419f12bc9eba5b48b71ae1a93f9f2b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -212,7 +212,7 @@ fn get_enum_variant_types<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n             ast::TupleVariantKind(ref args) if args.len() > 0 => {\n                 let rs = ExplicitRscope;\n                 let input_tys: Vec<_> = args.iter().map(|va| ccx.to_ty(&rs, &*va.ty)).collect();\n-                ty::mk_ctor_fn(tcx, variant_def_id, input_tys.index(&FullRange), enum_ty)\n+                ty::mk_ctor_fn(tcx, variant_def_id, &input_tys[], enum_ty)\n             }\n \n             ast::TupleVariantKind(_) => {\n@@ -259,7 +259,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n-                                    trait_items.index(&FullRange),\n+                                    &trait_items[],\n                                     &m.id,\n                                     &m.ident.name,\n                                     &m.explicit_self,\n@@ -273,7 +273,7 @@ fn collect_trait_methods<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                     ccx,\n                                     trait_id,\n                                     &trait_def.generics,\n-                                    trait_items.index(&FullRange),\n+                                    &trait_items[],\n                                     &m.id,\n                                     &m.pe_ident().name,\n                                     m.pe_explicit_self(),\n@@ -607,6 +607,11 @@ fn convert(ccx: &CollectCtxt, it: &ast::Item) {\n                         methods.push(&**method);\n                     }\n                     ast::TypeImplItem(ref typedef) => {\n+                        if opt_trait_ref.is_none() {\n+                            tcx.sess.span_err(typedef.span,\n+                                              \"associated items are not allowed in inherent impls\");\n+                        }\n+\n                         let typ = ccx.to_ty(&ExplicitRscope, &*typedef.typ);\n                         tcx.tcache\n                            .borrow_mut()\n@@ -779,7 +784,7 @@ fn convert_struct<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                             local_def(field.node.id)].ty).collect();\n                 let ctor_fn_ty = ty::mk_ctor_fn(tcx,\n                                                 local_def(ctor_id),\n-                                                inputs.index(&FullRange),\n+                                                &inputs[],\n                                                 selfty);\n                 write_ty_to_tcx(tcx, ctor_id, ctor_fn_ty);\n                 tcx.tcache.borrow_mut().insert(local_def(ctor_id),\n@@ -819,8 +824,8 @@ fn get_trait_def<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     match ccx.tcx.map.get(trait_id.node) {\n         ast_map::NodeItem(item) => trait_def_of_item(ccx, &*item),\n         _ => {\n-            ccx.tcx.sess.bug(format!(\"get_trait_def({}): not an item\",\n-                                     trait_id.node).index(&FullRange))\n+            ccx.tcx.sess.bug(&format!(\"get_trait_def({}): not an item\",\n+                                     trait_id.node)[])\n         }\n     }\n }\n@@ -845,7 +850,7 @@ fn trait_def_of_item<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n         ref s => {\n             tcx.sess.span_bug(\n                 it.span,\n-                format!(\"trait_def_of_item invoked on {:?}\", s).index(&FullRange));\n+                &format!(\"trait_def_of_item invoked on {:?}\", s)[]);\n         }\n     };\n \n@@ -1030,8 +1035,8 @@ fn ty_generics_for_type_or_impl<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n                                           -> ty::Generics<'tcx> {\n     ty_generics(ccx,\n                 subst::TypeSpace,\n-                generics.lifetimes.index(&FullRange),\n-                generics.ty_params.index(&FullRange),\n+                &generics.lifetimes[],\n+                &generics.ty_params[],\n                 ty::Generics::empty(),\n                 &generics.where_clause)\n }\n@@ -1049,8 +1054,8 @@ fn ty_generics_for_trait<'a, 'tcx>(ccx: &CollectCtxt<'a, 'tcx>,\n     let mut generics =\n         ty_generics(ccx,\n                     subst::TypeSpace,\n-                    ast_generics.lifetimes.index(&FullRange),\n-                    ast_generics.ty_params.index(&FullRange),\n+                    &ast_generics.lifetimes[],\n+                    &ast_generics.ty_params[],\n                     ty::Generics::empty(),\n                     &ast_generics.where_clause);\n \n@@ -1135,8 +1140,8 @@ fn ty_generics_for_fn_or_method<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let early_lifetimes = resolve_lifetime::early_bound_lifetimes(generics);\n     ty_generics(ccx,\n                 subst::FnSpace,\n-                early_lifetimes.index(&FullRange),\n-                generics.ty_params.index(&FullRange),\n+                &early_lifetimes[],\n+                &generics.ty_params[],\n                 base_generics,\n                 &generics.where_clause)\n }\n@@ -1323,7 +1328,7 @@ fn get_or_create_type_parameter_def<'a,'tcx>(ccx: &CollectCtxt<'a,'tcx>,\n     let param_ty = ty::ParamTy::new(space, index, param.ident.name);\n     let bounds = compute_bounds(ccx,\n                                 param_ty.to_ty(ccx.tcx),\n-                                param.bounds.index(&FullRange),\n+                                &param.bounds[],\n                                 SizedByDefault::Yes,\n                                 param.span);\n     let default = match param.default {\n@@ -1404,7 +1409,7 @@ fn check_bounds_compatible<'tcx>(tcx: &ty::ctxt<'tcx>,\n     if !param_bounds.builtin_bounds.contains(&ty::BoundSized) {\n         ty::each_bound_trait_and_supertraits(\n             tcx,\n-            param_bounds.trait_bounds.index(&FullRange),\n+            &param_bounds.trait_bounds[],\n             |trait_ref| {\n                 let trait_def = ty::lookup_trait_def(tcx, trait_ref.def_id());\n                 if trait_def.bounds.builtin_bounds.contains(&ty::BoundSized) {"}, {"sha": "c9e15b93ad4c5fa2dda4bbbdd97ff1bf408692b4", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -157,5 +157,6 @@ register_diagnostics! {\n     E0180,\n     E0181,\n     E0182,\n-    E0183\n+    E0183,\n+    E0184\n }"}, {"sha": "76ac4b2e8af4c004156531bb5a803e7870e673ad", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -65,14 +65,17 @@ This API is completely unstable and subject to change.\n \n #![crate_name = \"rustc_typeck\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n       html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"http://doc.rust-lang.org/nightly/\")]\n \n+#![allow(unknown_features)]\n #![feature(quote)]\n #![feature(slicing_syntax, unsafe_destructor)]\n+#![feature(box_syntax)]\n #![feature(rustc_diagnostic_macros)]\n #![allow(non_camel_case_types)]\n \n@@ -190,10 +193,10 @@ fn require_same_types<'a, 'tcx, M>(tcx: &ty::ctxt<'tcx>,\n         Ok(_) => true,\n         Err(ref terr) => {\n             tcx.sess.span_err(span,\n-                              format!(\"{}: {}\",\n+                              &format!(\"{}: {}\",\n                                       msg(),\n                                       ty::type_err_to_str(tcx,\n-                                                          terr)).index(&FullRange));\n+                                                          terr))[]);\n             ty::note_and_explain_type_err(tcx, terr);\n             false\n         }\n@@ -239,10 +242,10 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n         }\n         _ => {\n             tcx.sess.span_bug(main_span,\n-                              format!(\"main has a non-function type: found \\\n+                              &format!(\"main has a non-function type: found \\\n                                        `{}`\",\n                                       ppaux::ty_to_string(tcx,\n-                                                       main_t)).index(&FullRange));\n+                                                       main_t))[]);\n         }\n     }\n }\n@@ -291,9 +294,9 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n         }\n         _ => {\n             tcx.sess.span_bug(start_span,\n-                              format!(\"start has a non-function type: found \\\n+                              &format!(\"start has a non-function type: found \\\n                                        `{}`\",\n-                                      ppaux::ty_to_string(tcx, start_t)).index(&FullRange));\n+                                      ppaux::ty_to_string(tcx, start_t))[]);\n         }\n     }\n }"}, {"sha": "b33921e07e8ddc444b9500e1e65acf687dd4fcc0", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -562,9 +562,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         match self.terms_cx.inferred_map.get(&param_id) {\n             Some(&index) => index,\n             None => {\n-                self.tcx().sess.bug(format!(\n+                self.tcx().sess.bug(&format!(\n                         \"no inferred index entry for {}\",\n-                        self.tcx().map.node_to_string(param_id)).index(&FullRange));\n+                        self.tcx().map.node_to_string(param_id))[]);\n             }\n         }\n     }\n@@ -837,9 +837,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n \n             ty::ty_infer(..) | ty::ty_err => {\n                 self.tcx().sess.bug(\n-                    format!(\"unexpected type encountered in \\\n+                    &format!(\"unexpected type encountered in \\\n                             variance inference: {}\",\n-                            ty.repr(self.tcx())).index(&FullRange));\n+                            ty.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -917,9 +917,9 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                 // regions when visiting member types or method types.\n                 self.tcx()\n                     .sess\n-                    .bug(format!(\"unexpected region encountered in variance \\\n+                    .bug(&format!(\"unexpected region encountered in variance \\\n                                   inference: {}\",\n-                                 region.repr(self.tcx())).index(&FullRange));\n+                                 region.repr(self.tcx()))[]);\n             }\n         }\n     }\n@@ -1055,7 +1055,7 @@ impl<'a, 'tcx> SolveContext<'a, 'tcx> {\n             // attribute and report an error with various results if found.\n             if ty::has_attr(tcx, item_def_id, \"rustc_variance\") {\n                 let found = item_variances.repr(tcx);\n-                tcx.sess.span_err(tcx.map.span(item_id), found.index(&FullRange));\n+                tcx.sess.span_err(tcx.map.span(item_id), &found[]);\n             }\n \n             let newly_added = tcx.item_variance_map.borrow_mut()"}, {"sha": "fbb3c40ee99f659d62a5e93382f3876fd344ab34", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -530,7 +530,8 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n                 _ => {\n                     return PathParameters::AngleBracketed {\n                         lifetimes: lifetimes,\n-                        types: types.clean(cx)\n+                        types: types.clean(cx),\n+                        bindings: vec![]\n                     }\n                 }\n             };\n@@ -547,6 +548,7 @@ fn external_path_params(cx: &DocContext, trait_did: Option<ast::DefId>,\n             PathParameters::AngleBracketed {\n                 lifetimes: lifetimes,\n                 types: types.clean(cx),\n+                bindings: vec![] // FIXME(#20646)\n             }\n         }\n     }\n@@ -798,7 +800,7 @@ impl Clean<Item> for ast::Method {\n         let all_inputs = &self.pe_fn_decl().inputs;\n         let inputs = match self.pe_explicit_self().node {\n             ast::SelfStatic => all_inputs.as_slice(),\n-            _ => all_inputs.index(&(1..))\n+            _ => &all_inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -836,7 +838,7 @@ impl Clean<Item> for ast::TypeMethod {\n     fn clean(&self, cx: &DocContext) -> Item {\n         let inputs = match self.explicit_self.node {\n             ast::SelfStatic => self.decl.inputs.as_slice(),\n-            _ => self.decl.inputs.index(&(1..))\n+            _ => &self.decl.inputs[1..]\n         };\n         let decl = FnDecl {\n             inputs: Arguments {\n@@ -1132,7 +1134,7 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n                                                self.fty.sig.clone()),\n             s => {\n                 let sig = ty::Binder(ty::FnSig {\n-                    inputs: self.fty.sig.0.inputs.index(&(1..)).to_vec(),\n+                    inputs: self.fty.sig.0.inputs[1..].to_vec(),\n                     ..self.fty.sig.0.clone()\n                 });\n                 let s = match s {\n@@ -1766,6 +1768,7 @@ pub enum PathParameters {\n     AngleBracketed {\n         lifetimes: Vec<Lifetime>,\n         types: Vec<Type>,\n+        bindings: Vec<TypeBinding>\n     },\n     Parenthesized {\n         inputs: Vec<Type>,\n@@ -1779,7 +1782,8 @@ impl Clean<PathParameters> for ast::PathParameters {\n             ast::AngleBracketedParameters(ref data) => {\n                 PathParameters::AngleBracketed {\n                     lifetimes: data.lifetimes.clean(cx),\n-                    types: data.types.clean(cx)\n+                    types: data.types.clean(cx),\n+                    bindings: data.bindings.clean(cx)\n                 }\n             }\n \n@@ -2442,8 +2446,25 @@ fn lang_struct(cx: &DocContext, did: Option<ast::DefId>,\n                 params: PathParameters::AngleBracketed {\n                     lifetimes: vec![],\n                     types: vec![t.clean(cx)],\n+                    bindings: vec![]\n                 }\n             }],\n         },\n     }\n }\n+\n+/// An equality constraint on an associated type, e.g. `A=Bar` in `Foo<A=Bar>`\n+#[derive(Clone, PartialEq, RustcDecodable, RustcEncodable, Show)]\n+pub struct TypeBinding {\n+    pub name: String,\n+    pub ty: Type\n+}\n+\n+impl Clean<TypeBinding> for ast::TypeBinding {\n+    fn clean(&self, cx: &DocContext) -> TypeBinding {\n+        TypeBinding {\n+            name: self.ident.clean(cx),\n+            ty: self.ty.clean(cx)\n+        }\n+    }\n+}"}, {"sha": "4885bd373eb1dfd74e57fa43062be708ec013d0f", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -11,6 +11,7 @@ pub use self::MaybeTyped::*;\n \n use rustc_driver::driver;\n use rustc::session::{self, config};\n+use rustc::session::config::UnstableFeatures;\n use rustc::session::search_paths::SearchPaths;\n use rustc::middle::{privacy, ty};\n use rustc::lint;\n@@ -95,10 +96,11 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         externs: externs,\n         target_triple: triple.unwrap_or(config::host_triple().to_string()),\n         cfg: config::parse_cfgspecs(cfgs),\n+        // Ensure that rustdoc works even if rustc is feature-staged\n+        unstable_features: UnstableFeatures::Default,\n         ..config::basic_options().clone()\n     };\n \n-\n     let codemap = codemap::CodeMap::new();\n     let diagnostic_handler = diagnostic::default_handler(diagnostic::Auto, None);\n     let span_diagnostic_handler ="}, {"sha": "6fb78d9a8334b285ad09cbc74445bd0912d1c8ab", "filename": "src/librustdoc/html/escape.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fescape.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -19,14 +19,6 @@ use std::fmt;\n /// string when passed to a format string.\n pub struct Escape<'a>(pub &'a str);\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for Escape<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for Escape<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Because the internet is always right, turns out there's not that many"}, {"sha": "2ae22b8fc0d81dd5b4eb95ba9ac007ccb6baf946", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 30, "deletions": 192, "changes": 222, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -51,6 +51,8 @@ pub struct ConciseStability<'a>(pub &'a Option<clean::Stability>);\n pub struct WhereClause<'a>(pub &'a clean::Generics);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n+/// Wrapper struct for emitting a comma-separated list of items\n+pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n \n impl VisSpace {\n     pub fn get(&self) -> Option<ast::Visibility> {\n@@ -64,11 +66,13 @@ impl UnsafetySpace {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for TyParamBounds<'a> {\n+impl<'a, T: fmt::String> fmt::String for CommaSep<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        for (i, item) in self.0.iter().enumerate() {\n+            if i != 0 { try!(write!(f, \", \")); }\n+            try!(write!(f, \"{}\", item));\n+        }\n+        Ok(())\n     }\n }\n \n@@ -85,14 +89,6 @@ impl<'a> fmt::String for TyParamBounds<'a> {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::Generic {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::Generics {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() == 0 && self.type_params.len() == 0 { return Ok(()) }\n@@ -130,14 +126,6 @@ impl fmt::String for clean::Generics {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for WhereClause<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let &WhereClause(gens) = self;\n@@ -175,29 +163,13 @@ impl<'a> fmt::String for WhereClause<'a> {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::Lifetime {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::Lifetime {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(f.write_str(self.get_ref()));\n         Ok(())\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::PolyTrait {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::PolyTrait {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.lifetimes.len() > 0 {\n@@ -214,14 +186,6 @@ impl fmt::String for clean::PolyTrait {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::TyParamBound {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::TyParamBound {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -239,19 +203,13 @@ impl fmt::String for clean::TyParamBound {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::PathParameters {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::PathParameters {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n-            clean::PathParameters::AngleBracketed { ref lifetimes, ref types } => {\n-                if lifetimes.len() > 0 || types.len() > 0 {\n+            clean::PathParameters::AngleBracketed {\n+                ref lifetimes, ref types, ref bindings\n+            } => {\n+                if lifetimes.len() > 0 || types.len() > 0 || bindings.len() > 0 {\n                     try!(f.write_str(\"&lt;\"));\n                     let mut comma = false;\n                     for lifetime in lifetimes.iter() {\n@@ -268,6 +226,13 @@ impl fmt::String for clean::PathParameters {\n                         comma = true;\n                         try!(write!(f, \"{}\", *ty));\n                     }\n+                    for binding in bindings.iter() {\n+                        if comma {\n+                            try!(f.write_str(\", \"));\n+                        }\n+                        comma = true;\n+                        try!(write!(f, \"{}\", *binding));\n+                    }\n                     try!(f.write_str(\"&gt;\"));\n                 }\n             }\n@@ -292,29 +257,13 @@ impl fmt::String for clean::PathParameters {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::PathSegment {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::PathSegment {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(f.write_str(self.name.as_slice()));\n         write!(f, \"{}\", self.params)\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::Path {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::Path {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         if self.global {\n@@ -383,7 +332,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n         match rel_root {\n             Some(root) => {\n                 let mut root = String::from_str(root.as_slice());\n-                for seg in path.segments.index(&(0..amt)).iter() {\n+                for seg in path.segments[0..amt].iter() {\n                     if \"super\" == seg.name ||\n                             \"self\" == seg.name {\n                         try!(write!(w, \"{}::\", seg.name));\n@@ -398,7 +347,7 @@ fn path<F, G>(w: &mut fmt::Formatter,\n                 }\n             }\n             None => {\n-                for seg in path.segments.index(&(0..amt)).iter() {\n+                for seg in path.segments[0..amt].iter() {\n                     try!(write!(w, \"{}::\", seg.name));\n                 }\n             }\n@@ -501,14 +450,6 @@ fn tybounds(w: &mut fmt::Formatter,\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::Type {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::Type {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -530,7 +471,8 @@ impl fmt::String for clean::Type {\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_string()\n                        } else {\n-                           format!(\"for &lt;{:#}&gt;\", decl.lifetimes)\n+                           format!(\"for &lt;{}&gt;\",\n+                                   CommaSep(decl.lifetimes.as_slice()))\n                        },\n                        args = decl.decl.inputs,\n                        arrow = decl.decl.output,\n@@ -562,7 +504,8 @@ impl fmt::String for clean::Type {\n                        lifetimes = if decl.lifetimes.len() == 0 {\n                            \"\".to_string()\n                        } else {\n-                           format!(\"for &lt;{:#}&gt;\", decl.lifetimes)\n+                           format!(\"for &lt;{}&gt;\",\n+                                   CommaSep(decl.lifetimes.as_slice()))\n                        },\n                        args = decl.decl.inputs,\n                        bounds = if decl.bounds.len() == 0 {\n@@ -592,7 +535,8 @@ impl fmt::String for clean::Type {\n                 primitive_link(f, clean::PrimitiveTuple,\n                                match typs.as_slice() {\n                                     [ref one] => format!(\"({},)\", one),\n-                                    many => format!(\"({:#})\", many)\n+                                    many => format!(\"({})\",\n+                                                    CommaSep(many.as_slice()))\n                                }.as_slice())\n             }\n             clean::Vector(ref t) => {\n@@ -650,15 +594,6 @@ impl fmt::String for clean::Type {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::Arguments {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n-\n impl fmt::String for clean::Arguments {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, input) in self.values.iter().enumerate() {\n@@ -672,14 +607,6 @@ impl fmt::String for clean::Arguments {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::FunctionRetTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::FunctionRetTy {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -690,28 +617,12 @@ impl fmt::String for clean::FunctionRetTy {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::FnDecl {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::FnDecl {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"({args}){arrow}\", args = self.inputs, arrow = self.output)\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for Method<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for Method<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Method(selfty, d) = *self;\n@@ -742,14 +653,6 @@ impl<'a> fmt::String for Method<'a> {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for VisSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for VisSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n@@ -759,14 +662,6 @@ impl fmt::String for VisSpace {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for UnsafetySpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for UnsafetySpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.get() {\n@@ -776,14 +671,6 @@ impl fmt::String for UnsafetySpace {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::ViewPath {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::ViewPath {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -811,14 +698,6 @@ impl fmt::String for clean::ViewPath {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::ImportSource {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::ImportSource {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.did {\n@@ -836,14 +715,6 @@ impl fmt::String for clean::ImportSource {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for clean::ViewListIdent {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for clean::ViewListIdent {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.source {\n@@ -855,6 +726,7 @@ impl fmt::String for clean::ViewListIdent {\n                         params: clean::PathParameters::AngleBracketed {\n                             lifetimes: Vec::new(),\n                             types: Vec::new(),\n+                            bindings: Vec::new()\n                         }\n                     })\n                 };\n@@ -865,11 +737,9 @@ impl fmt::String for clean::ViewListIdent {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for MutableSpace {\n+impl fmt::String for clean::TypeBinding {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n+        write!(f, \"{}={}\", self.name, self.ty)\n     }\n }\n \n@@ -882,14 +752,6 @@ impl fmt::String for MutableSpace {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for RawMutableSpace {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for RawMutableSpace {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {\n@@ -899,14 +761,6 @@ impl fmt::String for RawMutableSpace {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for Stability<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for Stability<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Stability(stab) = *self;\n@@ -921,14 +775,6 @@ impl<'a> fmt::String for Stability<'a> {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for ConciseStability<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for ConciseStability<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let ConciseStability(stab) = *self;\n@@ -946,14 +792,6 @@ impl<'a> fmt::String for ConciseStability<'a> {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for ModuleSummary {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for ModuleSummary {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fn fmt_inner<'a>(f: &mut fmt::Formatter,"}, {"sha": "885017152de4f53ca1d8101ea6a9a986e813952e", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -34,7 +34,7 @@ pub fn highlight(src: &str, class: Option<&str>, id: Option<&str>) -> String {\n          class,\n          id,\n          &mut out).unwrap();\n-    String::from_utf8_lossy(out.index(&FullRange)).into_owned()\n+    String::from_utf8_lossy(&out[]).into_owned()\n }\n \n /// Exhausts the `lexer` writing the output into `out`."}, {"sha": "db3319eb7659c912541d693b5ccaeaf2f5e3a7c9", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -103,14 +103,6 @@ impl ItemType {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl fmt::Show for ItemType {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for ItemType {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         self.to_static_str().fmt(f)"}, {"sha": "a063191a12fd6c505715954910808de554da3220", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -435,14 +435,6 @@ pub fn reset_headers() {\n     TEST_IDX.with(|s| s.set(0));\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for Markdown<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for Markdown<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Markdown(md) = *self;\n@@ -452,14 +444,6 @@ impl<'a> fmt::String for Markdown<'a> {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for MarkdownWithToc<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for MarkdownWithToc<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let MarkdownWithToc(md) = *self;"}, {"sha": "839dfa339b328763237add6af32db3fb238a98db", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -1351,14 +1351,6 @@ impl<'a> Item<'a> {\n }\n \n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for Item<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for Item<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         // Write the breadcrumb trail header for the top\n@@ -1634,14 +1626,6 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n struct Initializer<'a>(&'a str);\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for Initializer<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for Initializer<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         let Initializer(s) = *self;\n@@ -2204,14 +2188,6 @@ fn item_typedef(w: &mut fmt::Formatter, it: &clean::Item,\n     document(w, it)\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for Sidebar<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for Sidebar<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let cx = self.cx;\n@@ -2267,14 +2243,6 @@ impl<'a> fmt::String for Sidebar<'a> {\n     }\n }\n \n-//NOTE(stage0): remove impl after snapshot\n-#[cfg(stage0)]\n-impl<'a> fmt::Show for Source<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a> fmt::String for Source<'a> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         let Source(s) = *self;"}, {"sha": "5951ac2bae71a3ea942da23b10cd6d45b462e7b4", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -157,7 +157,6 @@ nav.sub {\n     left: 0;\n     top: 0;\n     min-height: 100%;\n-    z-index: -1;\n }\n \n .content, nav { max-width: 960px; }\n@@ -221,6 +220,7 @@ nav.sub {\n .content pre.line-numbers {\n     float: left;\n     border: none;\n+    position: relative;\n \n     -webkit-user-select: none;\n     -moz-user-select: none;"}, {"sha": "56f5c23f6f1bbbb8f2122ebbaabff5632b846e5f", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -10,13 +10,15 @@\n \n #![crate_name = \"rustdoc\"]\n #![experimental]\n+#![staged_api]\n #![crate_type = \"dylib\"]\n #![crate_type = \"rlib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![feature(slicing_syntax)]\n+#![feature(box_syntax)]\n \n extern crate arena;\n extern crate getopts;"}, {"sha": "8e0f4b2d4436486954a80901f54c89a9d46e0f26", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -22,6 +22,7 @@ use std::collections::{HashSet, HashMap};\n use testing;\n use rustc::session::{self, config};\n use rustc::session::search_paths::{SearchPaths, PathKind};\n+use rustc_driver::get_unstable_features_setting;\n use rustc_driver::driver;\n use syntax::ast;\n use syntax::codemap::{CodeMap, dummy_spanned};\n@@ -52,6 +53,7 @@ pub fn run(input: &str,\n         search_paths: libs.clone(),\n         crate_types: vec!(config::CrateTypeDylib),\n         externs: externs.clone(),\n+        unstable_features: get_unstable_features_setting(),\n         ..config::basic_options().clone()\n     };\n \n@@ -128,6 +130,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n             .. config::basic_codegen_options()\n         },\n         test: as_test_harness,\n+        unstable_features: get_unstable_features_setting(),\n         ..config::basic_options().clone()\n     };\n "}, {"sha": "10698259739996a1943b9dbd7900e984cfa98cf3", "filename": "src/libserialize/collection_impls.rs", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibserialize%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibserialize%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fcollection_impls.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -13,6 +13,7 @@\n use std::uint;\n use std::default::Default;\n use std::hash::{Hash, Hasher};\n+use std::collections::hash_state::HashState;\n \n use {Decodable, Encodable, Decoder, Encoder};\n use std::collections::{DList, RingBuf, BTreeMap, BTreeSet, HashMap, HashSet, VecMap};\n@@ -156,14 +157,13 @@ impl<\n     }\n }\n \n-#[old_impl_check]\n-impl<\n-    K: Encodable + Hash<X> + Eq,\n-    V: Encodable,\n-    X,\n-    H: Hasher<X>\n-> Encodable for HashMap<K, V, H> {\n-    fn encode<S: Encoder>(&self, e: &mut S) -> Result<(), S::Error> {\n+impl<K, V, S> Encodable for HashMap<K, V, S>\n+    where K: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n+          V: Encodable,\n+          S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>\n+{\n+    fn encode<E: Encoder>(&self, e: &mut E) -> Result<(), E::Error> {\n         e.emit_map(self.len(), |e| {\n             let mut i = 0;\n             for (key, val) in self.iter() {\n@@ -176,17 +176,16 @@ impl<\n     }\n }\n \n-#[old_impl_check]\n-impl<\n-    K: Decodable + Hash<S> + Eq,\n-    V: Decodable,\n-    S,\n-    H: Hasher<S> + Default\n-> Decodable for HashMap<K, V, H> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, H>, D::Error> {\n+impl<K, V, S> Decodable for HashMap<K, V, S>\n+    where K: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n+          V: Decodable,\n+          S: HashState + Default,\n+          <S as HashState>::Hasher: Hasher<Output=u64>\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashMap<K, V, S>, D::Error> {\n         d.read_map(|d, len| {\n-            let hasher = Default::default();\n-            let mut map = HashMap::with_capacity_and_hasher(len, hasher);\n+            let state = Default::default();\n+            let mut map = HashMap::with_capacity_and_hash_state(len, state);\n             for i in range(0u, len) {\n                 let key = try!(d.read_map_elt_key(i, |d| Decodable::decode(d)));\n                 let val = try!(d.read_map_elt_val(i, |d| Decodable::decode(d)));\n@@ -197,13 +196,12 @@ impl<\n     }\n }\n \n-#[old_impl_check]\n-impl<\n-    T: Encodable + Hash<X> + Eq,\n-    X,\n-    H: Hasher<X>\n-> Encodable for HashSet<T, H> {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+impl<T, S> Encodable for HashSet<T, S>\n+    where T: Encodable + Hash< <S as HashState>::Hasher> + Eq,\n+          S: HashState,\n+          <S as HashState>::Hasher: Hasher<Output=u64>\n+{\n+    fn encode<E: Encoder>(&self, s: &mut E) -> Result<(), E::Error> {\n         s.emit_seq(self.len(), |s| {\n             let mut i = 0;\n             for e in self.iter() {\n@@ -215,15 +213,15 @@ impl<\n     }\n }\n \n-#[old_impl_check]\n-impl<\n-    T: Decodable + Hash<S> + Eq,\n-    S,\n-    H: Hasher<S> + Default\n-> Decodable for HashSet<T, H> {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, H>, D::Error> {\n+impl<T, S> Decodable for HashSet<T, S>\n+    where T: Decodable + Hash< <S as HashState>::Hasher> + Eq,\n+          S: HashState + Default,\n+          <S as HashState>::Hasher: Hasher<Output=u64>\n+{\n+    fn decode<D: Decoder>(d: &mut D) -> Result<HashSet<T, S>, D::Error> {\n         d.read_seq(|d, len| {\n-            let mut set = HashSet::with_capacity_and_hasher(len, Default::default());\n+            let state = Default::default();\n+            let mut set = HashSet::with_capacity_and_hash_state(len, state);\n             for i in range(0u, len) {\n                 set.insert(try!(d.read_seq_elt(i, |d| Decodable::decode(d))));\n             }"}, {"sha": "62acef2ca1cc75476f1cc27a13200f0784988b33", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -383,7 +383,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n         };\n \n         if start < i {\n-            try!(wr.write_str(v.index(&(start..i))));\n+            try!(wr.write_str(&v[start..i]));\n         }\n \n         try!(wr.write_str(escaped));\n@@ -392,7 +392,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n     }\n \n     if start != v.len() {\n-        try!(wr.write_str(v.index(&(start..))));\n+        try!(wr.write_str(&v[start..]));\n     }\n \n     wr.write_str(\"\\\"\")\n@@ -401,7 +401,7 @@ fn escape_str(wr: &mut fmt::Writer, v: &str) -> fmt::Result {\n fn escape_char(writer: &mut fmt::Writer, v: char) -> fmt::Result {\n     let mut buf = [0; 4];\n     let n = v.encode_utf8(&mut buf).unwrap();\n-    let buf = unsafe { str::from_utf8_unchecked(buf.index(&(0..n))) };\n+    let buf = unsafe { str::from_utf8_unchecked(&buf[0..n]) };\n     escape_str(writer, buf)\n }\n \n@@ -414,7 +414,7 @@ fn spaces(wr: &mut fmt::Writer, mut n: uint) -> fmt::Result {\n     }\n \n     if n > 0 {\n-        wr.write_str(BUF.index(&(0..n)))\n+        wr.write_str(&BUF[0..n])\n     } else {\n         Ok(())\n     }\n@@ -623,7 +623,7 @@ impl<'a> ::Encoder for Encoder<'a> {\n             let mut check_encoder = Encoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf.index(&FullRange)).unwrap();\n+        let out = str::from_utf8(&buf[]).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -894,7 +894,7 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n             let mut check_encoder = PrettyEncoder::new(&mut buf);\n             try!(f(transmute(&mut check_encoder)));\n         }\n-        let out = str::from_utf8(buf.index(&FullRange)).unwrap();\n+        let out = str::from_utf8(&buf[]).unwrap();\n         let needs_wrapping = out.char_at(0) != '\"' && out.char_at_reverse(out.len()) != '\"';\n         if needs_wrapping { try!(write!(self.writer, \"\\\"\")); }\n         try!(f(self));\n@@ -1027,7 +1027,7 @@ impl Json {\n     /// Returns None otherwise.\n     pub fn as_string<'a>(&'a self) -> Option<&'a str> {\n         match *self {\n-            Json::String(ref s) => Some(s.index(&FullRange)),\n+            Json::String(ref s) => Some(&s[]),\n             _ => None\n         }\n     }\n@@ -1137,7 +1137,7 @@ impl Index<uint> for Json {\n \n     fn index<'a>(&'a self, idx: &uint) -> &'a Json {\n         match self {\n-            &Json::Array(ref v) => v.index(idx),\n+            &Json::Array(ref v) => &v[*idx],\n             _ => panic!(\"can only index Json with uint if it is an array\")\n         }\n     }\n@@ -1222,7 +1222,7 @@ impl Stack {\n             InternalIndex(i) => StackElement::Index(i),\n             InternalKey(start, size) => {\n                 StackElement::Key(str::from_utf8(\n-                    self.str_buffer.index(&((start as uint) .. (start as uint + size as uint))))\n+                    &self.str_buffer[(start as uint) .. (start as uint + size as uint)])\n                         .unwrap())\n             }\n         }\n@@ -1265,7 +1265,7 @@ impl Stack {\n             Some(&InternalIndex(i)) => Some(StackElement::Index(i)),\n             Some(&InternalKey(start, size)) => {\n                 Some(StackElement::Key(str::from_utf8(\n-                    self.str_buffer.index(&((start as uint) .. (start+size) as uint))\n+                    &self.str_buffer[(start as uint) .. (start+size) as uint]\n                 ).unwrap()))\n             }\n         }\n@@ -1396,7 +1396,7 @@ impl<T: Iterator<Item=char>> Parser<T> {\n         self.ch == Some(c)\n     }\n \n-    fn error<T>(&self, reason: ErrorCode) -> Result<T, ParserError> {\n+    fn error<U>(&self, reason: ErrorCode) -> Result<U, ParserError> {\n         Err(SyntaxError(reason, self.line, self.col))\n     }\n \n@@ -2144,7 +2144,7 @@ impl ::Decoder for Decoder {\n                 return Err(ExpectedError(\"String or Object\".to_string(), format!(\"{}\", json)))\n             }\n         };\n-        let idx = match names.iter().position(|n| *n == name.index(&FullRange)) {\n+        let idx = match names.iter().position(|n| *n == &name[]) {\n             Some(idx) => idx,\n             None => return Err(UnknownVariantError(name))\n         };\n@@ -2458,14 +2458,6 @@ impl<'a> fmt::String for PrettyJson<'a> {\n     }\n }\n \n-#[cfg(stage0)]\n-//NOTE(stage0): remove impl after snapshot\n-impl<'a, T: Encodable> fmt::Show for AsJson<'a, T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl<'a, T: Encodable> fmt::String for AsJson<'a, T> {\n     /// Encodes a json value into a string\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n@@ -2519,7 +2511,6 @@ mod tests {\n     use std::{i64, u64, f32, f64, io};\n     use std::collections::BTreeMap;\n     use std::num::Float;\n-    use std::ops::Index;\n     use std::string;\n \n     #[derive(RustcDecodable, Eq, PartialEq, Show)]\n@@ -3361,7 +3352,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(mem_buf.index(&FullRange)).unwrap();\n+        let json_str = from_utf8(&mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3377,7 +3368,7 @@ mod tests {\n         hm.insert(1, true);\n         let mut mem_buf = Vec::new();\n         write!(&mut mem_buf, \"{}\", super::as_pretty_json(&hm)).unwrap();\n-        let json_str = from_utf8(mem_buf.index(&FullRange)).unwrap();\n+        let json_str = from_utf8(&mem_buf[]).unwrap();\n         match from_str(json_str) {\n             Err(_) => panic!(\"Unable to parse json_str: {:?}\", json_str),\n             _ => {} // it parsed and we are good to go\n@@ -3417,7 +3408,7 @@ mod tests {\n             write!(&mut writer, \"{}\",\n                    super::as_pretty_json(&json).indent(i)).unwrap();\n \n-            let printed = from_utf8(writer.index(&FullRange)).unwrap();\n+            let printed = from_utf8(&writer[]).unwrap();\n \n             // Check for indents at each line\n             let lines: Vec<&str> = printed.lines().collect();\n@@ -3481,7 +3472,7 @@ mod tests {\n         }\n     }\n     #[test]\n-    #[cfg_attr(target_word_size = \"32\", ignore)] // FIXME(#14064)\n+    #[cfg_attr(target_pointer_width = \"32\", ignore)] // FIXME(#14064)\n     fn test_streaming_parser() {\n         assert_stream_equal(\n             r#\"{ \"foo\":\"bar\", \"array\" : [0, 1, 2, 3, 4, 5], \"idents\":[null,true,false]}\"#,\n@@ -3520,7 +3511,7 @@ mod tests {\n     }\n \n     #[test]\n-    #[cfg_attr(target_word_size = \"32\", ignore)] // FIXME(#14064)\n+    #[cfg_attr(target_pointer_width = \"32\", ignore)] // FIXME(#14064)\n     fn test_read_object_streaming() {\n         assert_eq!(last_event(\"{ \"),      Error(SyntaxError(EOFWhileParsingObject, 1, 3)));\n         assert_eq!(last_event(\"{1\"),      Error(SyntaxError(KeyMustBeAString,      1, 2)));\n@@ -3604,7 +3595,7 @@ mod tests {\n         );\n     }\n     #[test]\n-    #[cfg_attr(target_word_size = \"32\", ignore)] // FIXME(#14064)\n+    #[cfg_attr(target_pointer_width = \"32\", ignore)] // FIXME(#14064)\n     fn test_read_array_streaming() {\n         assert_stream_equal(\n             \"[]\","}, {"sha": "b3c4cec2ef13f5ef01b800f5161cc4048f2b0015", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -16,16 +16,18 @@ Core encoding and decoding interfaces.\n \n #![crate_name = \"serialize\"]\n #![unstable = \"deprecated in favor of rustc-serialize on crates.io\"]\n+#![staged_api]\n #![crate_type = \"rlib\"]\n #![crate_type = \"dylib\"]\n #![doc(html_logo_url = \"http://www.rust-lang.org/logos/rust-logo-128x128-blk-v2.png\",\n        html_favicon_url = \"http://www.rust-lang.org/favicon.ico\",\n        html_root_url = \"http://doc.rust-lang.org/nightly/\",\n        html_playground_url = \"http://play.rust-lang.org/\")]\n #![allow(unknown_features)]\n-#![feature(slicing_syntax)]\n-#![feature(old_impl_check)]\n #![cfg_attr(stage0, allow(unused_attributes))]\n+#![feature(box_syntax)]\n+#![feature(old_impl_check)]\n+#![feature(slicing_syntax)]\n \n // test harness access\n #[cfg(test)] extern crate test;"}, {"sha": "fe2d57486a88ec0e4d305c9679df347e220c4fa9", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -326,7 +326,7 @@ impl Encodable for str {\n \n impl Encodable for String {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_str(self.index(&FullRange))\n+        s.emit_str(&self[])\n     }\n }\n "}, {"sha": "8dc41368e7f92d40ea64d9d57da763c02f3ca60e", "filename": "src/libstd/bitflags.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fbitflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fbitflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbitflags.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -273,7 +273,7 @@ macro_rules! bitflags {\n #[cfg(test)]\n #[allow(non_upper_case_globals)]\n mod tests {\n-    use hash;\n+    use hash::{self, SipHasher};\n     use option::Option::{Some, None};\n \n     bitflags! {\n@@ -467,9 +467,9 @@ mod tests {\n     fn test_hash() {\n       let mut x = Flags::empty();\n       let mut y = Flags::empty();\n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n       x = Flags::all();\n       y = FlagABC;\n-      assert!(hash::hash(&x) == hash::hash(&y));\n+      assert!(hash::hash::<Flags, SipHasher>(&x) == hash::hash::<Flags, SipHasher>(&y));\n     }\n }"}, {"sha": "c3bdfbb12d88d46a1e97c7cca365389a0a82d818", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 145, "deletions": 61, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -19,16 +19,15 @@ use clone::Clone;\n use cmp::{max, Eq, PartialEq};\n use default::Default;\n use fmt::{self, Show};\n-use hash::{Hash, Hasher, RandomSipHasher};\n+use hash::{self, Hash, SipHasher};\n use iter::{self, Iterator, IteratorExt, FromIterator, Extend, Map};\n use marker::Sized;\n use mem::{self, replace};\n use num::{Int, UnsignedInt};\n use ops::{Deref, FnMut, Index, IndexMut};\n-use option::Option;\n-use option::Option::{Some, None};\n-use result::Result;\n-use result::Result::{Ok, Err};\n+use option::Option::{self, Some, None};\n+use rand::{self, Rng};\n+use result::Result::{self, Ok, Err};\n \n use super::table::{\n     self,\n@@ -44,6 +43,7 @@ use super::table::BucketState::{\n     Empty,\n     Full,\n };\n+use super::state::HashState;\n \n const INITIAL_LOG2_CAP: uint = 5;\n pub const INITIAL_CAPACITY: uint = 1 << INITIAL_LOG2_CAP; // 2^5\n@@ -297,9 +297,9 @@ fn test_resize_policy() {\n /// ```\n #[derive(Clone)]\n #[stable]\n-pub struct HashMap<K, V, H = RandomSipHasher> {\n+pub struct HashMap<K, V, S = RandomState> {\n     // All hashes are keyed on these values, to prevent hash collision attacks.\n-    hasher: H,\n+    hash_state: S,\n \n     table: RawTable<K, V>,\n \n@@ -439,25 +439,28 @@ impl<K, V, M> SearchResult<K, V, M> {\n     }\n }\n \n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n-    fn make_hash<X: ?Sized + Hash<S>>(&self, x: &X) -> SafeHash {\n-        table::make_hash(&self.hasher, x)\n+impl<K, V, S, H> HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn make_hash<X: ?Sized>(&self, x: &X) -> SafeHash where X: Hash<H> {\n+        table::make_hash(&self.hash_state, x)\n     }\n \n     /// Search for a key, yielding the index if it's found in the hashtable.\n     /// If you already have the hash for the key lying around, use\n     /// search_hashed.\n     fn search<'a, Q: ?Sized>(&'a self, q: &Q) -> Option<FullBucketImm<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<S>\n+        where Q: BorrowFrom<K> + Eq + Hash<H>\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n             .into_option()\n     }\n \n     fn search_mut<'a, Q: ?Sized>(&'a mut self, q: &Q) -> Option<FullBucketMut<'a, K, V>>\n-        where Q: BorrowFrom<K> + Eq + Hash<S>\n+        where Q: BorrowFrom<K> + Eq + Hash<H>\n     {\n         let hash = self.make_hash(q);\n         search_hashed(&mut self.table, hash, |k| q.eq(BorrowFrom::borrow_from(k)))\n@@ -486,7 +489,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     }\n }\n \n-impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n+impl<K: Hash<Hasher> + Eq, V> HashMap<K, V, RandomState> {\n     /// Create an empty HashMap.\n     ///\n     /// # Example\n@@ -497,9 +500,8 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn new() -> HashMap<K, V, RandomSipHasher> {\n-        let hasher = RandomSipHasher::new();\n-        HashMap::with_hasher(hasher)\n+    pub fn new() -> HashMap<K, V, RandomState> {\n+        Default::default()\n     }\n \n     /// Creates an empty hash map with the given initial capacity.\n@@ -512,14 +514,16 @@ impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n-        let hasher = RandomSipHasher::new();\n-        HashMap::with_capacity_and_hasher(capacity, hasher)\n+    pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomState> {\n+        HashMap::with_capacity_and_hash_state(capacity, Default::default())\n     }\n }\n \n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n+impl<K, V, S, H> HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     /// Creates an empty hashmap which will use the given hasher to hash keys.\n     ///\n     /// The creates map has the default initial capacity.\n@@ -528,17 +532,17 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// use std::hash::sip::SipHasher;\n+    /// use std::collections::hash_map::RandomState;\n     ///\n-    /// let h = SipHasher::new();\n-    /// let mut map = HashMap::with_hasher(h);\n+    /// let s = RandomState::new();\n+    /// let mut map = HashMap::with_hash_state(s);\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n-    pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n+    pub fn with_hash_state(hash_state: S) -> HashMap<K, V, S> {\n         HashMap {\n-            hasher:        hasher,\n+            hash_state:    hash_state,\n             resize_policy: DefaultResizePolicy::new(),\n             table:         RawTable::new(0),\n         }\n@@ -556,21 +560,22 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     ///\n     /// ```\n     /// use std::collections::HashMap;\n-    /// use std::hash::sip::SipHasher;\n+    /// use std::collections::hash_map::RandomState;\n     ///\n-    /// let h = SipHasher::new();\n-    /// let mut map = HashMap::with_capacity_and_hasher(10, h);\n+    /// let s = RandomState::new();\n+    /// let mut map = HashMap::with_capacity_and_hash_state(10, s);\n     /// map.insert(1i, 2u);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n-    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n+    pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n+                                        -> HashMap<K, V, S> {\n         let resize_policy = DefaultResizePolicy::new();\n         let min_cap = max(INITIAL_CAPACITY, resize_policy.min_capacity(capacity));\n         let internal_cap = min_cap.checked_next_power_of_two().expect(\"capacity overflow\");\n         assert!(internal_cap >= capacity, \"capacity overflow\");\n         HashMap {\n-            hasher:        hasher,\n+            hash_state:    hash_state,\n             resize_policy: resize_policy,\n             table:         RawTable::new(internal_cap),\n         }\n@@ -1031,7 +1036,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[stable]\n     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>\n-        where Q: Hash<S> + Eq + BorrowFrom<K>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n         self.search(k).map(|bucket| bucket.into_refs().1)\n     }\n@@ -1054,7 +1059,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[stable]\n     pub fn contains_key<Q: ?Sized>(&self, k: &Q) -> bool\n-        where Q: Hash<S> + Eq + BorrowFrom<K>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n         self.search(k).is_some()\n     }\n@@ -1080,7 +1085,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[stable]\n     pub fn get_mut<Q: ?Sized>(&mut self, k: &Q) -> Option<&mut V>\n-        where Q: Hash<S> + Eq + BorrowFrom<K>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n         self.search_mut(k).map(|bucket| bucket.into_mut_refs().1)\n     }\n@@ -1132,7 +1137,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// ```\n     #[stable]\n     pub fn remove<Q: ?Sized>(&mut self, k: &Q) -> Option<V>\n-        where Q: Hash<S> + Eq + BorrowFrom<K>\n+        where Q: Hash<H> + Eq + BorrowFrom<K>\n     {\n         if self.table.size() == 0 {\n             return None\n@@ -1189,10 +1194,12 @@ fn search_entry_hashed<'a, K: Eq, V>(table: &'a mut RawTable<K,V>, hash: SafeHas\n     }\n }\n \n-#[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V, H> {\n-    fn eq(&self, other: &HashMap<K, V, H>) -> bool {\n+impl<K, V, S, H> PartialEq for HashMap<K, V, S>\n+    where K: Eq + Hash<H>, V: PartialEq,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn eq(&self, other: &HashMap<K, V, S>) -> bool {\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|(key, value)|\n@@ -1202,12 +1209,18 @@ impl<K: Eq + Hash<S>, V: PartialEq, S, H: Hasher<S>> PartialEq for HashMap<K, V,\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V: Eq, S, H: Hasher<S>> Eq for HashMap<K, V, H> {}\n+impl<K, V, S, H> Eq for HashMap<K, V, S>\n+    where K: Eq + Hash<H>, V: Eq,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{}\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H> {\n+impl<K, V, S, H> Show for HashMap<K, V, S>\n+    where K: Eq + Hash<H> + Show, V: Show,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"HashMap {{\"));\n \n@@ -1221,18 +1234,22 @@ impl<K: Eq + Hash<S> + Show, V: Show, S, H: Hasher<S>> Show for HashMap<K, V, H>\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> Default for HashMap<K, V, H> {\n-    #[stable]\n-    fn default() -> HashMap<K, V, H> {\n-        HashMap::with_hasher(Default::default())\n+impl<K, V, S, H> Default for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn default() -> HashMap<K, V, S> {\n+        HashMap::with_hash_state(Default::default())\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V, H>\n-    where Q: BorrowFrom<K> + Hash<S> + Eq\n+impl<K, Q: ?Sized, V, S, H> Index<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          Q: Eq + Hash<H> + BorrowFrom<K>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Output = V;\n \n@@ -1243,9 +1260,11 @@ impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> Index<Q> for HashMap<K, V,\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Hash<S> + Eq, Q: ?Sized, V, S, H: Hasher<S>> IndexMut<Q> for HashMap<K, V, H>\n-    where Q: BorrowFrom<K> + Hash<S> + Eq\n+impl<K, V, S, H, Q: ?Sized> IndexMut<Q> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          Q: Eq + Hash<H> + BorrowFrom<K>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Output = V;\n \n@@ -1473,26 +1492,91 @@ impl<'a, K: 'a, V: 'a> VacantEntry<'a, K, V> {\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S> + Default> FromIterator<(K, V)> for HashMap<K, V, H> {\n-    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, H> {\n+impl<K, V, S, H> FromIterator<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn from_iter<T: Iterator<Item=(K, V)>>(iter: T) -> HashMap<K, V, S> {\n         let lower = iter.size_hint().0;\n-        let mut map = HashMap::with_capacity_and_hasher(lower, Default::default());\n+        let mut map = HashMap::with_capacity_and_hash_state(lower,\n+                                                            Default::default());\n         map.extend(iter);\n         map\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> Extend<(K, V)> for HashMap<K, V, H> {\n+impl<K, V, S, H> Extend<(K, V)> for HashMap<K, V, S>\n+    where K: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     fn extend<T: Iterator<Item=(K, V)>>(&mut self, mut iter: T) {\n         for (k, v) in iter {\n             self.insert(k, v);\n         }\n     }\n }\n \n+\n+/// `RandomState` is the default state for `HashMap` types.\n+///\n+/// A particular instance `RandomState` will create the same instances of\n+/// `Hasher`, but the hashers created by two different `RandomState`\n+/// instances are unlikely to produce the same result for the same values.\n+#[derive(Clone)]\n+#[allow(missing_copy_implementations)]\n+#[unstable = \"hashing an hash maps may be altered\"]\n+pub struct RandomState {\n+    k0: u64,\n+    k1: u64,\n+}\n+\n+#[unstable = \"hashing an hash maps may be altered\"]\n+impl RandomState {\n+    /// Construct a new `RandomState` that is initialized with random keys.\n+    #[inline]\n+    pub fn new() -> RandomState {\n+        let mut r = rand::thread_rng();\n+        RandomState { k0: r.gen(), k1: r.gen() }\n+    }\n+}\n+\n+#[unstable = \"hashing an hash maps may be altered\"]\n+impl HashState for RandomState {\n+    type Hasher = Hasher;\n+    fn hasher(&self) -> Hasher {\n+        Hasher { inner: SipHasher::new_with_keys(self.k0, self.k1) }\n+    }\n+}\n+\n+#[unstable = \"hashing an hash maps may be altered\"]\n+impl Default for RandomState {\n+    #[inline]\n+    fn default() -> RandomState {\n+        RandomState::new()\n+    }\n+}\n+\n+/// A hasher implementation which is generated from `RandomState` instances.\n+///\n+/// This is the default hasher used in a `HashMap` to hash keys. Types do not\n+/// typically declare an ability to explicitly hash into this particular type,\n+/// but rather in a `H: hash::Writer` type parameter.\n+#[allow(missing_copy_implementations)]\n+pub struct Hasher { inner: SipHasher }\n+\n+impl hash::Writer for Hasher {\n+    fn write(&mut self, data: &[u8]) { self.inner.write(data) }\n+}\n+\n+impl hash::Hasher for Hasher {\n+    type Output = u64;\n+    fn reset(&mut self) { self.inner.reset() }\n+    fn finish(&self) -> u64 { self.inner.finish() }\n+}\n+\n #[cfg(test)]\n mod test_map {\n     use prelude::v1::*;"}, {"sha": "47e300af26981da7cd395a6b361bf63704358cb6", "filename": "src/libstd/collections/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -11,6 +11,7 @@\n //! Unordered containers, implemented as hash-tables\n \n mod bench;\n+mod table;\n pub mod map;\n pub mod set;\n-mod table;\n+pub mod state;"}, {"sha": "4003d3addf13949f74b415521b188f9b6edd587e", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 127, "deletions": 90, "changes": 217, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -17,12 +17,13 @@ use core::marker::Sized;\n use default::Default;\n use fmt::Show;\n use fmt;\n-use hash::{Hash, Hasher, RandomSipHasher};\n+use hash::{self, Hash};\n use iter::{Iterator, IteratorExt, FromIterator, Map, Chain, Extend};\n use ops::{BitOr, BitAnd, BitXor, Sub};\n use option::Option::{Some, None, self};\n \n-use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n+use super::map::{self, HashMap, Keys, INITIAL_CAPACITY, RandomState, Hasher};\n+use super::state::HashState;\n \n // Future Optimization (FIXME!)\n // =============================\n@@ -90,11 +91,11 @@ use super::map::{self, HashMap, Keys, INITIAL_CAPACITY};\n /// ```\n #[derive(Clone)]\n #[stable]\n-pub struct HashSet<T, H = RandomSipHasher> {\n-    map: HashMap<T, (), H>\n+pub struct HashSet<T, S = RandomState> {\n+    map: HashMap<T, (), S>\n }\n \n-impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n+impl<T: Hash<Hasher> + Eq> HashSet<T, RandomState> {\n     /// Create an empty HashSet.\n     ///\n     /// # Example\n@@ -105,7 +106,7 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn new() -> HashSet<T, RandomSipHasher> {\n+    pub fn new() -> HashSet<T, RandomState> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n@@ -120,13 +121,16 @@ impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n+    pub fn with_capacity(capacity: uint) -> HashSet<T, RandomState> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n }\n \n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n+impl<T, S, H> HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     /// Creates a new empty hash set which will use the given hasher to hash\n     /// keys.\n     ///\n@@ -136,16 +140,16 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// use std::hash::sip::SipHasher;\n+    /// use std::collections::hash_map::RandomState;\n     ///\n-    /// let h = SipHasher::new();\n-    /// let mut set = HashSet::with_hasher(h);\n+    /// let s = RandomState::new();\n+    /// let mut set = HashSet::with_hash_state(s);\n     /// set.insert(2u);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n-    pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n-        HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n+    pub fn with_hash_state(hash_state: S) -> HashSet<T, S> {\n+        HashSet::with_capacity_and_hash_state(INITIAL_CAPACITY, hash_state)\n     }\n \n     /// Create an empty HashSet with space for at least `capacity`\n@@ -160,16 +164,19 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     ///\n     /// ```\n     /// use std::collections::HashSet;\n-    /// use std::hash::sip::SipHasher;\n+    /// use std::collections::hash_map::RandomState;\n     ///\n-    /// let h = SipHasher::new();\n-    /// let mut set = HashSet::with_capacity_and_hasher(10u, h);\n+    /// let s = RandomState::new();\n+    /// let mut set = HashSet::with_capacity_and_hash_state(10u, s);\n     /// set.insert(1i);\n     /// ```\n     #[inline]\n     #[unstable = \"hasher stuff is unclear\"]\n-    pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n-        HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n+    pub fn with_capacity_and_hash_state(capacity: uint, hash_state: S)\n+                                        -> HashSet<T, S> {\n+        HashSet {\n+            map: HashMap::with_capacity_and_hash_state(capacity, hash_state),\n+        }\n     }\n \n     /// Returns the number of elements the set can hold without reallocating.\n@@ -300,7 +307,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [4i].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n-    pub fn difference<'a>(&'a self, other: &'a HashSet<T, H>) -> Difference<'a, T, H> {\n+    pub fn difference<'a>(&'a self, other: &'a HashSet<T, S>) -> Difference<'a, T, S> {\n         Difference {\n             iter: self.iter(),\n             other: other,\n@@ -328,8 +335,8 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff1, [1i, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n-    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, H>)\n-        -> SymmetricDifference<'a, T, H> {\n+    pub fn symmetric_difference<'a>(&'a self, other: &'a HashSet<T, S>)\n+        -> SymmetricDifference<'a, T, S> {\n         SymmetricDifference { iter: self.difference(other).chain(other.difference(self)) }\n     }\n \n@@ -351,7 +358,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [2i, 3].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n-    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, H>) -> Intersection<'a, T, H> {\n+    pub fn intersection<'a>(&'a self, other: &'a HashSet<T, S>) -> Intersection<'a, T, S> {\n         Intersection {\n             iter: self.iter(),\n             other: other,\n@@ -376,7 +383,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(diff, [1i, 2, 3, 4].iter().map(|&x| x).collect());\n     /// ```\n     #[stable]\n-    pub fn union<'a>(&'a self, other: &'a HashSet<T, H>) -> Union<'a, T, H> {\n+    pub fn union<'a>(&'a self, other: &'a HashSet<T, S>) -> Union<'a, T, S> {\n         Union { iter: self.iter().chain(other.difference(self)) }\n     }\n \n@@ -452,7 +459,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[stable]\n     pub fn contains<Q: ?Sized>(&self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash<S> + Eq\n+        where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n         self.map.contains_key(value)\n     }\n@@ -475,7 +482,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(a.is_disjoint(&b), false);\n     /// ```\n     #[stable]\n-    pub fn is_disjoint(&self, other: &HashSet<T, H>) -> bool {\n+    pub fn is_disjoint(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| !other.contains(v))\n     }\n \n@@ -496,7 +503,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// assert_eq!(set.is_subset(&sup), false);\n     /// ```\n     #[stable]\n-    pub fn is_subset(&self, other: &HashSet<T, H>) -> bool {\n+    pub fn is_subset(&self, other: &HashSet<T, S>) -> bool {\n         self.iter().all(|v| other.contains(v))\n     }\n \n@@ -521,7 +528,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[inline]\n     #[stable]\n-    pub fn is_superset(&self, other: &HashSet<T, H>) -> bool {\n+    pub fn is_superset(&self, other: &HashSet<T, S>) -> bool {\n         other.is_subset(self)\n     }\n \n@@ -562,29 +569,38 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// ```\n     #[stable]\n     pub fn remove<Q: ?Sized>(&mut self, value: &Q) -> bool\n-        where Q: BorrowFrom<T> + Hash<S> + Eq\n+        where Q: BorrowFrom<T> + Hash<H> + Eq\n     {\n         self.map.remove(value).is_some()\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> PartialEq for HashSet<T, H> {\n-    fn eq(&self, other: &HashSet<T, H>) -> bool {\n+impl<T, S, H> PartialEq for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn eq(&self, other: &HashSet<T, S>) -> bool {\n         if self.len() != other.len() { return false; }\n \n         self.iter().all(|key| other.contains(key))\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Eq for HashSet<T, H> {}\n+impl<T, S, H> Eq for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{}\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n+impl<T, S, H> fmt::Show for HashSet<T, S>\n+    where T: Eq + Hash<H> + fmt::Show,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         try!(write!(f, \"HashSet {{\"));\n \n@@ -598,19 +614,25 @@ impl<T: Eq + Hash<S> + fmt::Show, S, H: Hasher<S>> fmt::Show for HashSet<T, H> {\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> FromIterator<T> for HashSet<T, H> {\n-    fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, H> {\n+impl<T, S, H> FromIterator<T> for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    fn from_iter<I: Iterator<Item=T>>(iter: I) -> HashSet<T, S> {\n         let lower = iter.size_hint().0;\n-        let mut set = HashSet::with_capacity_and_hasher(lower, Default::default());\n+        let mut set = HashSet::with_capacity_and_hash_state(lower, Default::default());\n         set.extend(iter);\n         set\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S>> Extend<T> for HashSet<T, H> {\n+impl<T, S, H> Extend<T> for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n+{\n     fn extend<I: Iterator<Item=T>>(&mut self, mut iter: I) {\n         for k in iter {\n             self.insert(k);\n@@ -619,21 +641,26 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> Extend<T> for HashSet<T, H> {\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<T: Eq + Hash<S>, S, H: Hasher<S> + Default> Default for HashSet<T, H> {\n+impl<T, S, H> Default for HashSet<T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n     #[stable]\n-    fn default() -> HashSet<T, H> {\n-        HashSet::with_hasher(Default::default())\n+    fn default() -> HashSet<T, S> {\n+        HashSet::with_hash_state(Default::default())\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitOr<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n-    type Output = HashSet<T, H>;\n+impl<'a, 'b, T, S, H> BitOr<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n \n-    /// Returns the union of `self` and `rhs` as a new `HashSet<T, H>`.\n+    /// Returns the union of `self` and `rhs` as a new `HashSet<T, S>`.\n     ///\n     /// # Examples\n     ///\n@@ -653,18 +680,20 @@ BitOr<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n     /// }\n     /// assert_eq!(i, expected.len());\n     /// ```\n-    fn bitor(self, rhs: &HashSet<T, H>) -> HashSet<T, H> {\n+    fn bitor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n         self.union(rhs).cloned().collect()\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitAnd<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n-    type Output = HashSet<T, H>;\n+impl<'a, 'b, T, S, H> BitAnd<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n \n-    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, H>`.\n+    /// Returns the intersection of `self` and `rhs` as a new `HashSet<T, S>`.\n     ///\n     /// # Examples\n     ///\n@@ -684,18 +713,20 @@ BitAnd<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n     /// }\n     /// assert_eq!(i, expected.len());\n     /// ```\n-    fn bitand(self, rhs: &HashSet<T, H>) -> HashSet<T, H> {\n+    fn bitand(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n         self.intersection(rhs).cloned().collect()\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-BitXor<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n-    type Output = HashSet<T, H>;\n+impl<'a, 'b, T, S, H> BitXor<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n \n-    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, H>`.\n+    /// Returns the symmetric difference of `self` and `rhs` as a new `HashSet<T, S>`.\n     ///\n     /// # Examples\n     ///\n@@ -715,18 +746,20 @@ BitXor<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n     /// }\n     /// assert_eq!(i, expected.len());\n     /// ```\n-    fn bitxor(self, rhs: &HashSet<T, H>) -> HashSet<T, H> {\n+    fn bitxor(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n         self.symmetric_difference(rhs).cloned().collect()\n     }\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, 'b, T: Eq + Hash<S> + Clone, S, H: Hasher<S> + Default>\n-Sub<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n-    type Output = HashSet<T, H>;\n+impl<'a, 'b, T, S, H> Sub<&'b HashSet<T, S>> for &'a HashSet<T, S>\n+    where T: Eq + Hash<H> + Clone,\n+          S: HashState<Hasher=H> + Default,\n+          H: hash::Hasher<Output=u64>\n+{\n+    type Output = HashSet<T, S>;\n \n-    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, H>`.\n+    /// Returns the difference of `self` and `rhs` as a new `HashSet<T, S>`.\n     ///\n     /// # Examples\n     ///\n@@ -746,7 +779,7 @@ Sub<&'b HashSet<T, H>> for &'a HashSet<T, H> {\n     /// }\n     /// assert_eq!(i, expected.len());\n     /// ```\n-    fn sub(self, rhs: &HashSet<T, H>) -> HashSet<T, H> {\n+    fn sub(self, rhs: &HashSet<T, S>) -> HashSet<T, S> {\n         self.difference(rhs).cloned().collect()\n     }\n }\n@@ -771,32 +804,32 @@ pub struct Drain<'a, K: 'a> {\n \n /// Intersection iterator\n #[stable]\n-pub struct Intersection<'a, T: 'a, H: 'a> {\n+pub struct Intersection<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n     // the second set\n-    other: &'a HashSet<T, H>,\n+    other: &'a HashSet<T, S>,\n }\n \n /// Difference iterator\n #[stable]\n-pub struct Difference<'a, T: 'a, H: 'a> {\n+pub struct Difference<'a, T: 'a, S: 'a> {\n     // iterator of the first set\n     iter: Iter<'a, T>,\n     // the second set\n-    other: &'a HashSet<T, H>,\n+    other: &'a HashSet<T, S>,\n }\n \n /// Symmetric difference iterator.\n #[stable]\n-pub struct SymmetricDifference<'a, T: 'a, H: 'a> {\n-    iter: Chain<Difference<'a, T, H>, Difference<'a, T, H>>\n+pub struct SymmetricDifference<'a, T: 'a, S: 'a> {\n+    iter: Chain<Difference<'a, T, S>, Difference<'a, T, S>>\n }\n \n /// Set union iterator.\n #[stable]\n-pub struct Union<'a, T: 'a, H: 'a> {\n-    iter: Chain<Iter<'a, T>, Difference<'a, T, H>>\n+pub struct Union<'a, T: 'a, S: 'a> {\n+    iter: Chain<Iter<'a, T>, Difference<'a, T, S>>\n }\n \n #[stable]\n@@ -824,9 +857,10 @@ impl<'a, K: 'a> Iterator for Drain<'a, K> {\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, T, S, H> Iterator for Intersection<'a, T, H>\n-    where T: Eq + Hash<S>, H: Hasher<S>\n+impl<'a, T, S, H> Iterator for Intersection<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Item = &'a T;\n \n@@ -848,9 +882,10 @@ impl<'a, T, S, H> Iterator for Intersection<'a, T, H>\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, T, S, H> Iterator for Difference<'a, T, H>\n-    where T: Eq + Hash<S>, H: Hasher<S>\n+impl<'a, T, S, H> Iterator for Difference<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Item = &'a T;\n \n@@ -872,9 +907,10 @@ impl<'a, T, S, H> Iterator for Difference<'a, T, H>\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, H>\n-    where T: Eq + Hash<S>, H: Hasher<S>\n+impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Item = &'a T;\n \n@@ -883,9 +919,10 @@ impl<'a, T, S, H> Iterator for SymmetricDifference<'a, T, H>\n }\n \n #[stable]\n-#[old_impl_check]\n-impl<'a, T, S, H> Iterator for Union<'a, T, H>\n-    where T: Eq + Hash<S>, H: Hasher<S>\n+impl<'a, T, S, H> Iterator for Union<'a, T, S>\n+    where T: Eq + Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: hash::Hasher<Output=u64>\n {\n     type Item = &'a T;\n "}, {"sha": "ffbc958f179f5adfcccbdb9fd04d0060ab974455", "filename": "src/libstd/collections/hash/state.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fstate.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use clone::Clone;\n+use default::Default;\n+use hash;\n+\n+/// A trait representing stateful hashes which can be used to hash keys in a\n+/// `HashMap`.\n+///\n+/// A HashState is used as a factory for instances of `Hasher` which a `HashMap`\n+/// can then use to hash keys independently. A `HashMap` by default uses a state\n+/// which will create instances of a `SipHasher`, but a custom state factory can\n+/// be provided to the `with_hash_state` function.\n+///\n+/// If a hashing algorithm has no initial state, then the `Hasher` type for that\n+/// algorithm can implement the `Default` trait and create hash maps with the\n+/// `DefaultState` structure. This state is 0-sized and will simply delegate\n+/// to `Default` when asked to create a hasher.\n+pub trait HashState {\n+    type Hasher: hash::Hasher;\n+\n+    /// Creates a new hasher based on the given state of this object.\n+    fn hasher(&self) -> Self::Hasher;\n+}\n+\n+/// A structure which is a factory for instances of `Hasher` which implement the\n+/// default trait.\n+///\n+/// This struct has is 0-sized and does not need construction.\n+pub struct DefaultState<H>;\n+\n+impl<H: Default + hash::Hasher> HashState for DefaultState<H> {\n+    type Hasher = H;\n+    fn hasher(&self) -> H { Default::default() }\n+}\n+\n+impl<H> Clone for DefaultState<H> {\n+    fn clone(&self) -> DefaultState<H> { DefaultState }\n+}\n+\n+impl<H> Default for DefaultState<H> {\n+    fn default() -> DefaultState<H> { DefaultState }\n+}"}, {"sha": "e43cc053ba07904883cabd7c23e61d6bd215c5a4", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -26,6 +26,7 @@ use option::Option::{Some, None};\n use ptr::{Unique, PtrExt, copy_nonoverlapping_memory, zero_memory};\n use ptr;\n use rt::heap::{allocate, deallocate};\n+use collections::hash_state::HashState;\n \n const EMPTY_BUCKET: u64 = 0u64;\n \n@@ -138,12 +139,18 @@ impl SafeHash {\n /// We need to remove hashes of 0. That's reserved for empty buckets.\n /// This function wraps up `hash_keyed` to be the only way outside this\n /// module to generate a SafeHash.\n-pub fn make_hash<T: ?Sized + Hash<S>, S, H: Hasher<S>>(hasher: &H, t: &T) -> SafeHash {\n+pub fn make_hash<T: ?Sized, S, H>(hash_state: &S, t: &T) -> SafeHash\n+    where T: Hash<H>,\n+          S: HashState<Hasher=H>,\n+          H: Hasher<Output=u64>\n+{\n+    let mut state = hash_state.hasher();\n+    t.hash(&mut state);\n     // We need to avoid 0u64 in order to prevent collisions with\n     // EMPTY_HASH. We can maintain our precious uniform distribution\n     // of initial indexes by unconditionally setting the MSB,\n     // effectively reducing 64-bits hashes to 63 bits.\n-    SafeHash { hash: 0x8000_0000_0000_0000 | hasher.hash(t) }\n+    SafeHash { hash: 0x8000_0000_0000_0000 | state.finish() }\n }\n \n // `replace` casts a `*u64` to a `*SafeHash`. Since we statically"}, {"sha": "71ab89027ff4c88d73611fe27b419b4e356534ed", "filename": "src/libstd/collections/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fcollections%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -333,3 +333,10 @@ pub mod hash_set {\n     //! A hashset\n     pub use super::hash::set::*;\n }\n+\n+/// Experimental support for providing custom hash algorithms to a HashMap and\n+/// HashSet.\n+#[unstable = \"module was recently added\"]\n+pub mod hash_state {\n+    pub use super::hash::state::*;\n+}"}, {"sha": "dbc88ddf0a0404c131fb6779f7a61b54ecb4fb02", "filename": "src/libstd/failure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Ffailure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Ffailure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffailure.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -37,7 +37,7 @@ pub fn on_fail(obj: &(Any+Send), file: &'static str, line: uint) {\n     let msg = match obj.downcast_ref::<&'static str>() {\n         Some(s) => *s,\n         None => match obj.downcast_ref::<String>() {\n-            Some(s) => s.index(&FullRange),\n+            Some(s) => &s[],\n             None => \"Box<Any>\",\n         }\n     };"}, {"sha": "96fff64d2214d9e5ac20a388fcb9b4fdac7082ee", "filename": "src/libstd/fmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -175,7 +175,7 @@\n //! use std::f64;\n //! use std::num::Float;\n //!\n-//! #[deriving(Show)]\n+//! #[derive(Show)]\n //! struct Vector2D {\n //!     x: int,\n //!     y: int,"}, {"sha": "69e7e429d07da01b5d7726415d17f08b1163d626", "filename": "src/libstd/hash.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/9f1ead8fadc56bad30dc74f5cc50d78af4fbc972/src%2Flibstd%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f1ead8fadc56bad30dc74f5cc50d78af4fbc972/src%2Flibstd%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhash.rs?ref=9f1ead8fadc56bad30dc74f5cc50d78af4fbc972", "patch": "@@ -1,105 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! Generic hashing support.\n-//!\n-//! This module provides a generic way to compute the hash of a value. The\n-//! simplest way to make a type hashable is to use `#[derive(Hash)]`:\n-//!\n-//! # Example\n-//!\n-//! ```rust\n-//! use std::hash;\n-//! use std::hash::Hash;\n-//!\n-//! #[derive(Hash)]\n-//! struct Person {\n-//!     id: uint,\n-//!     name: String,\n-//!     phone: u64,\n-//! }\n-//!\n-//! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n-//! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n-//!\n-//! assert!(hash::hash(&person1) != hash::hash(&person2));\n-//! ```\n-//!\n-//! If you need more control over how a value is hashed, you need to implement\n-//! the trait `Hash`:\n-//!\n-//! ```rust\n-//! use std::hash;\n-//! use std::hash::Hash;\n-//! use std::hash::sip::SipState;\n-//!\n-//! struct Person {\n-//!     id: uint,\n-//!     name: String,\n-//!     phone: u64,\n-//! }\n-//!\n-//! impl Hash for Person {\n-//!     fn hash(&self, state: &mut SipState) {\n-//!         self.id.hash(state);\n-//!         self.phone.hash(state);\n-//!     }\n-//! }\n-//!\n-//! let person1 = Person { id: 5, name: \"Janet\".to_string(), phone: 555_666_7777 };\n-//! let person2 = Person { id: 5, name: \"Bob\".to_string(), phone: 555_666_7777 };\n-//!\n-//! assert!(hash::hash(&person1) == hash::hash(&person2));\n-//! ```\n-\n-#![experimental]\n-\n-pub use core::hash::{Hash, Hasher, Writer, hash, sip};\n-\n-use core::marker::Sized;\n-use default::Default;\n-use rand::Rng;\n-use rand;\n-\n-/// `RandomSipHasher` computes the SipHash algorithm from a stream of bytes\n-/// initialized with random keys.\n-#[derive(Clone)]\n-pub struct RandomSipHasher {\n-    hasher: sip::SipHasher,\n-}\n-\n-impl RandomSipHasher {\n-    /// Construct a new `RandomSipHasher` that is initialized with random keys.\n-    #[inline]\n-    pub fn new() -> RandomSipHasher {\n-        let mut r = rand::thread_rng();\n-        let r0 = r.gen();\n-        let r1 = r.gen();\n-        RandomSipHasher {\n-            hasher: sip::SipHasher::new_with_keys(r0, r1),\n-        }\n-    }\n-}\n-\n-impl Hasher<sip::SipState> for RandomSipHasher {\n-    #[inline]\n-    fn hash<T: ?Sized + Hash<sip::SipState>>(&self, value: &T) -> u64 {\n-        self.hasher.hash(value)\n-    }\n-}\n-\n-#[stable]\n-impl Default for RandomSipHasher {\n-    #[stable]\n-    #[inline]\n-    fn default() -> RandomSipHasher {\n-        RandomSipHasher::new()\n-    }\n-}"}, {"sha": "ba13bd05dc5dc1334879c128f18ed61d0c682799", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -15,7 +15,7 @@\n use cmp;\n use io::{Reader, Writer, Stream, Buffer, DEFAULT_BUF_SIZE, IoResult};\n use iter::{IteratorExt, ExactSizeIterator};\n-use ops::{Drop, Index};\n+use ops::Drop;\n use option::Option;\n use option::Option::{Some, None};\n use result::Result::Ok;\n@@ -97,7 +97,7 @@ impl<R: Reader> Buffer for BufferedReader<R> {\n             self.cap = try!(self.inner.read(self.buf.as_mut_slice()));\n             self.pos = 0;\n         }\n-        Ok(self.buf.index(&(self.pos..self.cap)))\n+        Ok(&self.buf[self.pos..self.cap])\n     }\n \n     fn consume(&mut self, amt: uint) {\n@@ -114,7 +114,7 @@ impl<R: Reader> Reader for BufferedReader<R> {\n         let nread = {\n             let available = try!(self.fill_buf());\n             let nread = cmp::min(available.len(), buf.len());\n-            slice::bytes::copy_memory(buf, available.index(&(0..nread)));\n+            slice::bytes::copy_memory(buf, &available[0..nread]);\n             nread\n         };\n         self.pos += nread;\n@@ -168,7 +168,7 @@ impl<W: Writer> BufferedWriter<W> {\n \n     fn flush_buf(&mut self) -> IoResult<()> {\n         if self.pos != 0 {\n-            let ret = self.inner.as_mut().unwrap().write(self.buf.index(&(0..self.pos)));\n+            let ret = self.inner.as_mut().unwrap().write(&self.buf[0..self.pos]);\n             self.pos = 0;\n             ret\n         } else {\n@@ -260,9 +260,9 @@ impl<W: Writer> Writer for LineBufferedWriter<W> {\n     fn write(&mut self, buf: &[u8]) -> IoResult<()> {\n         match buf.iter().rposition(|&b| b == b'\\n') {\n             Some(i) => {\n-                try!(self.inner.write(buf.index(&(0..(i + 1)))));\n+                try!(self.inner.write(&buf[0..(i + 1)]));\n                 try!(self.inner.flush());\n-                try!(self.inner.write(buf.index(&((i + 1)..))));\n+                try!(self.inner.write(&buf[(i + 1)..]));\n                 Ok(())\n             }\n             None => self.inner.write(buf),\n@@ -510,7 +510,7 @@ mod test {\n         assert_eq!(a, &w.get_ref()[]);\n         let w = w.into_inner();\n         let a: &[_] = &[0, 1];\n-        assert_eq!(a, w.index(&FullRange));\n+        assert_eq!(a, &w[]);\n     }\n \n     // This is just here to make sure that we don't infinite loop in the\n@@ -607,14 +607,14 @@ mod test {\n     #[test]\n     fn read_char_buffered() {\n         let buf = [195u8, 159u8];\n-        let mut reader = BufferedReader::with_capacity(1, buf.index(&FullRange));\n+        let mut reader = BufferedReader::with_capacity(1, &buf[]);\n         assert_eq!(reader.read_char(), Ok('\u00df'));\n     }\n \n     #[test]\n     fn test_chars() {\n         let buf = [195u8, 159u8, b'a'];\n-        let mut reader = BufferedReader::with_capacity(1, buf.index(&FullRange));\n+        let mut reader = BufferedReader::with_capacity(1, &buf[]);\n         let mut it = reader.chars();\n         assert_eq!(it.next(), Some(Ok('\u00df')));\n         assert_eq!(it.next(), Some(Ok('a')));"}, {"sha": "b578f4d5adcba81f5f84491abf8b60fa54256414", "filename": "src/libstd/io/comm_adapters.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fcomm_adapters.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fcomm_adapters.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -13,7 +13,6 @@ use cmp;\n use sync::mpsc::{Sender, Receiver};\n use io;\n use option::Option::{None, Some};\n-use ops::Index;\n use result::Result::{Ok, Err};\n use slice::{bytes, SliceExt};\n use super::{Buffer, Reader, Writer, IoResult};\n@@ -91,7 +90,7 @@ impl Reader for ChanReader {\n                 Some(src) => {\n                     let dst = buf.slice_from_mut(num_read);\n                     let count = cmp::min(src.len(), dst.len());\n-                    bytes::copy_memory(dst, src.index(&(0..count)));\n+                    bytes::copy_memory(dst, &src[0..count]);\n                     count\n                 },\n                 None => 0,"}, {"sha": "dbccc81c4cc72ea45a5fa218c43de82d4453259a", "filename": "src/libstd/io/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ffs.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -889,7 +889,7 @@ mod test {\n             let mut read_buf = [0; 1028];\n             let read_str = match check!(read_stream.read(&mut read_buf)) {\n                 -1|0 => panic!(\"shouldn't happen\"),\n-                n => str::from_utf8(read_buf.index(&(0..n))).unwrap().to_string()\n+                n => str::from_utf8(&read_buf[0..n]).unwrap().to_string()\n             };\n             assert_eq!(read_str.as_slice(), message);\n         }"}, {"sha": "c5e289398e0466bc5faa2fa9a2f5da4feb8b516a", "filename": "src/libstd/io/mem.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmem.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -13,7 +13,6 @@\n //! Readers and Writers for in-memory buffers\n \n use cmp::min;\n-use ops::Index;\n use option::Option::None;\n use result::Result::{Err, Ok};\n use io;\n@@ -160,7 +159,7 @@ impl Reader for MemReader {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf.index(&(self.pos.. (self.pos + write_len)));\n+            let input = &self.buf[self.pos.. (self.pos + write_len)];\n             let output = buf.slice_to_mut(write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n@@ -188,7 +187,7 @@ impl Buffer for MemReader {\n     #[inline]\n     fn fill_buf<'a>(&'a mut self) -> IoResult<&'a [u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf.index(&(self.pos..)))\n+            Ok(&self.buf[self.pos..])\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -205,7 +204,7 @@ impl<'a> Reader for &'a [u8] {\n \n         let write_len = min(buf.len(), self.len());\n         {\n-            let input = self.index(&(0..write_len));\n+            let input = &self[0..write_len];\n             let output = buf.slice_to_mut(write_len);\n             slice::bytes::copy_memory(output, input);\n         }\n@@ -228,7 +227,7 @@ impl<'a> Buffer for &'a [u8] {\n \n     #[inline]\n     fn consume(&mut self, amt: uint) {\n-        *self = self.index(&(amt..));\n+        *self = &self[amt..];\n     }\n }\n \n@@ -287,7 +286,7 @@ impl<'a> Writer for BufWriter<'a> {\n \n             Ok(())\n         } else {\n-            slice::bytes::copy_memory(dst, src.index(&(0..dst_len)));\n+            slice::bytes::copy_memory(dst, &src[0..dst_len]);\n \n             self.pos += dst_len;\n \n@@ -350,7 +349,7 @@ impl<'a> Reader for BufReader<'a> {\n \n         let write_len = min(buf.len(), self.buf.len() - self.pos);\n         {\n-            let input = self.buf.index(&(self.pos.. (self.pos + write_len)));\n+            let input = &self.buf[self.pos.. (self.pos + write_len)];\n             let output = buf.slice_to_mut(write_len);\n             assert_eq!(input.len(), output.len());\n             slice::bytes::copy_memory(output, input);\n@@ -378,7 +377,7 @@ impl<'a> Buffer for BufReader<'a> {\n     #[inline]\n     fn fill_buf(&mut self) -> IoResult<&[u8]> {\n         if self.pos < self.buf.len() {\n-            Ok(self.buf.index(&(self.pos..)))\n+            Ok(&self.buf[self.pos..])\n         } else {\n             Err(io::standard_error(io::EndOfFile))\n         }\n@@ -393,7 +392,7 @@ mod test {\n     extern crate \"test\" as test_crate;\n     use io::{SeekSet, SeekCur, SeekEnd, Reader, Writer, Seek};\n     use prelude::v1::{Ok, Err, range,  Vec, Buffer,  AsSlice, SliceExt};\n-    use prelude::v1::{IteratorExt, Index};\n+    use prelude::v1::IteratorExt;\n     use io;\n     use iter::repeat;\n     use self::test_crate::Bencher;\n@@ -499,7 +498,7 @@ mod test {\n         assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.index(&(0..3)), b);\n+        assert_eq!(&buf[0..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -525,7 +524,7 @@ mod test {\n         assert_eq!(buf.as_slice(), b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.index(&(0..3)), b);\n+        assert_eq!(&buf[0..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = &mut in_buf.as_slice();\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n@@ -552,7 +551,7 @@ mod test {\n         assert_eq!(buf, b);\n         assert_eq!(reader.read(&mut buf), Ok(3));\n         let b: &[_] = &[5, 6, 7];\n-        assert_eq!(buf.index(&(0..3)), b);\n+        assert_eq!(&buf[0..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = BufReader::new(in_buf.as_slice());\n         assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));"}, {"sha": "1c48b20c4447f0eba091a41dfa2b3d0bcda8731d", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -236,7 +236,7 @@ use int;\n use iter::{Iterator, IteratorExt};\n use marker::Sized;\n use mem::transmute;\n-use ops::{FnOnce, Index};\n+use ops::FnOnce;\n use option::Option;\n use option::Option::{Some, None};\n use os;\n@@ -1069,7 +1069,7 @@ pub trait Writer {\n     fn write_char(&mut self, c: char) -> IoResult<()> {\n         let mut buf = [0u8; 4];\n         let n = c.encode_utf8(buf.as_mut_slice()).unwrap_or(0);\n-        self.write(buf.index(&(0..n)))\n+        self.write(&buf[0..n])\n     }\n \n     /// Write the result of passing n through `int::to_str_bytes`.\n@@ -1284,7 +1284,7 @@ impl<'a> Writer for &'a mut (Writer+'a) {\n ///     process_input(tee);\n /// }\n ///\n-/// println!(\"input processed: {}\", output);\n+/// println!(\"input processed: {:?}\", output);\n /// # }\n /// ```\n pub struct RefWriter<'a, W:'a> {\n@@ -1454,7 +1454,7 @@ pub trait Buffer: Reader {\n                 };\n                 match available.iter().position(|&b| b == byte) {\n                     Some(i) => {\n-                        res.push_all(available.index(&(0..(i + 1))));\n+                        res.push_all(&available[0..(i + 1)]);\n                         used = i + 1;\n                         break\n                     }\n@@ -1493,7 +1493,7 @@ pub trait Buffer: Reader {\n                 }\n             }\n         }\n-        match str::from_utf8(buf.index(&(0..width))).ok() {\n+        match str::from_utf8(&buf[0..width]).ok() {\n             Some(s) => Ok(s.char_at(0)),\n             None => Err(standard_error(InvalidInput))\n         }\n@@ -1783,9 +1783,8 @@ pub struct UnstableFileStat {\n }\n \n \n-// NOTE(stage0): change this one last #[doc=..] to /// after the next snapshot\n bitflags! {\n-    #[doc = \"A set of permissions for a file or directory is represented by a set of\"]\n+    /// A set of permissions for a file or directory is represented by a set of\n     /// flags which are or'd together.\n     flags FilePermission: u32 {\n         const USER_READ     = 0o400,"}, {"sha": "d09afea94dcc1023827c4157f49062bd69e04195", "filename": "src/libstd/io/net/ip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fip.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -22,7 +22,7 @@ use fmt;\n use io::{self, IoResult, IoError};\n use io::net;\n use iter::{Iterator, IteratorExt};\n-use ops::{FnOnce, FnMut, Index};\n+use ops::{FnOnce, FnMut};\n use option::Option;\n use option::Option::{None, Some};\n use result::Result::{Ok, Err};\n@@ -313,7 +313,7 @@ impl<'a> Parser<'a> {\n \n         let mut tail = [0u16; 8];\n         let (tail_size, _) = read_groups(self, &mut tail, 8 - head_size);\n-        Some(ipv6_addr_from_head_tail(head.index(&(0..head_size)), tail.index(&(0..tail_size))))\n+        Some(ipv6_addr_from_head_tail(&head[0..head_size], &tail[0..tail_size]))\n     }\n \n     fn read_ipv6_addr(&mut self) -> Option<IpAddr> {"}, {"sha": "f824d821601256baef22483f5deeb90351c7d45d", "filename": "src/libstd/io/process.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fprocess.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -34,7 +34,7 @@ use sys::process::Process as ProcessImp;\n use sys;\n use thread::Thread;\n \n-#[cfg(windows)] use std::hash::sip::SipState;\n+#[cfg(windows)] use hash;\n #[cfg(windows)] use str;\n \n /// Signal a process to exit, without forcibly killing it. Corresponds to\n@@ -98,7 +98,7 @@ pub struct Process {\n /// A representation of environment variable name\n /// It compares case-insensitive on Windows and case-sensitive everywhere else.\n #[cfg(not(windows))]\n-#[derive(PartialEq, Eq, Hash, Clone, Show)]\n+#[derive(Hash, PartialEq, Eq, Clone, Show)]\n struct EnvKey(CString);\n \n #[doc(hidden)]\n@@ -107,8 +107,8 @@ struct EnvKey(CString);\n struct EnvKey(CString);\n \n #[cfg(windows)]\n-impl Hash for EnvKey {\n-    fn hash(&self, state: &mut SipState) {\n+impl<H: hash::Writer + hash::Hasher> hash::Hash<H> for EnvKey {\n+    fn hash(&self, state: &mut H) {\n         let &EnvKey(ref x) = self;\n         match str::from_utf8(x.as_bytes()) {\n             Ok(s) => for ch in s.chars() {\n@@ -395,13 +395,6 @@ impl Command {\n     }\n }\n \n-#[cfg(stage0)]\n-impl fmt::Show for Command {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fmt::String::fmt(self, f)\n-    }\n-}\n-\n impl fmt::String for Command {\n     /// Format the program and arguments of a Command for display. Any\n     /// non-utf8 data is lossily converted using the utf8 replacement"}, {"sha": "5a7219495f56264833faa6df1b07ca7ed7b292bf", "filename": "src/libstd/io/util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fio%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Futil.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534", "patch": "@@ -59,7 +59,7 @@ impl<R: Reader> Reader for LimitReader<R> {\n impl<R: Buffer> Buffer for LimitReader<R> {\n     fn fill_buf<'a>(&'a mut self) -> io::IoResult<&'a [u8]> {\n         let amt = try!(self.inner.fill_buf());\n-        let buf = amt.index(&(0..cmp::min(amt.len(), self.limit)));\n+        let buf = &amt[0..cmp::min(amt.len(), self.limit)];\n         if buf.len() == 0 {\n             Err(io::standard_error(io::EndOfFile))\n         } else {\n@@ -220,7 +220,7 @@ impl<R: Reader, W: Writer> TeeReader<R, W> {\n impl<R: Reader, W: Writer> Reader for TeeReader<R, W> {\n     fn read(&mut self, buf: &mut [u8]) -> io::IoResult<uint> {\n         self.reader.read(buf).and_then(|len| {\n-            self.writer.write(buf.index_mut(&(0..len))).map(|()| len)\n+            self.writer.write(&mut buf[0..len]).map(|()| len)\n         })\n     }\n }\n@@ -234,7 +234,7 @@ pub fn copy<R: Reader, W: Writer>(r: &mut R, w: &mut W) -> io::IoResult<()> {\n             Err(ref e) if e.kind == io::EndOfFile => return Ok(()),\n             Err(e) => return Err(e),\n         };\n-        try!(w.write(buf.index(&(0..len))));\n+        try!(w.write(&buf[0..len]));\n     }\n }\n "}, {"sha": "71221a654e8c1d155b43126513b4cd99ee02c8a6", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "0594b711ad62e418945f13edf95dc4ba9eb4890c", "filename": "src/libstd/macros.rs", "status": "modified", "additions": 30, "deletions": 46, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fmacros.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "69439f85115fac2042dafd250de0f1d015d58014", "filename": "src/libstd/num/int.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fint.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "22395a1c0ff5dbddc33e1c64206fcd7e5e663f15", "filename": "src/libstd/num/isize.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fisize.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "9c6911cf4d14a83b3cdb2957fdc4170ebae854e8", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "0e12eff205ffd26fa478df97774f3fb2da827d3f", "filename": "src/libstd/num/uint.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fuint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fuint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fuint.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "74dd38e13c5820f9fe997fd5a467bbfb0bbe2e18", "filename": "src/libstd/num/usize.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fusize.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "b474ae4e37195b78bb4b3376edbac6b36c751a8f", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "293696d5ccada853d2393f525e3460527d3fa89e", "filename": "src/libstd/path/posix.rs", "status": "modified", "additions": 12, "deletions": 13, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fpath%2Fposix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fpath%2Fposix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fposix.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "2a1f1794e49e7c059342940d02c006b9f17fffd7", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 65, "deletions": 66, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "d9c942c0185140df57c11893b69a8c5768a77938", "filename": "src/libstd/prelude/v1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude%2Fv1.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "3fa1efe1ccdfe569d4707209951efc6364761c02", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "03876189da9ccd6bf393538dc1909c3e7a2fe50c", "filename": "src/libstd/rt/unwind.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Frt%2Funwind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Frt%2Funwind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Funwind.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "c076f0a7c6ca026f494c1e26a10cab7b49cc076a", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "f4b20c7b74235613c9334d974a7636a183e89c16", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "f6161ec193d52c27b233e230919b2d821af1e567", "filename": "src/libstd/sys/common/backtrace.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fbacktrace.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "4cf891ac4985eba360859a1cff038719ce3ca9a8", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "1d523ed6eddace4426c7c710070d4d58892a18c9", "filename": "src/libstd/sys/unix/c.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Funix%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fc.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "36bf696dba5503da7cb02b613ee782cf941be89d", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "48a51813ba4ab5a44f3b55f8ca77444322eda640", "filename": "src/libstd/sys/unix/stack_overflow.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fstack_overflow.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "ee2dd14955b6983ae862be709036746ac0e4f047", "filename": "src/libstd/sys/windows/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fbacktrace.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "a7330f7c67c91f772fdc4b3f3dfa860cf498e3d5", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "064633f321c19b1ed4689258eacb60f9ff4f5e65", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "9996909f2f5bbc18a9781018bd4dd4aaaf952fd1", "filename": "src/libstd/sys/windows/pipe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fpipe.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "1b837385d1eb60a37512b2ad9d210e4ab955d3d9", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "1ae3979cd9accac8679f91c7c8f02ffc6ebcd080", "filename": "src/libstd/sys/windows/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftimer.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "0a9e0aedd3da886090240d604cdfb2726361d1f8", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "3ef572791752bfd7420ed17ec5b4622cda88ba45", "filename": "src/libsyntax/ast_map/mod.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fast_map%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fast_map%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "b4e917e28cb24a9ed0c849b780a8daeae70839de", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "2cea55dfc55efa6ae5bf890fac8296ef8e2ca804", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "d1768867f0da2a613947dc2cee44282547a9e29c", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "7e57709f33d0af07bc929752c0f730d504486def", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "1469c50061cc75dc449bb1e11e339c24d7b9a159", "filename": "src/libsyntax/diagnostics/plugin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "fd3bac5b2fc7bce38d0304d2880e1e685593f6b3", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "9b9d8a9ceb395bf7cf0024fe3ceb17030de165f7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "27523ea453585aa180cbb5b21407608772dfd782", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "9f225d55b444fe787bf7d8f73ce40798f4f8fd9e", "filename": "src/libsyntax/ext/bytes.rs", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/9f1ead8fadc56bad30dc74f5cc50d78af4fbc972/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f1ead8fadc56bad30dc74f5cc50d78af4fbc972/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=9f1ead8fadc56bad30dc74f5cc50d78af4fbc972"}, {"sha": "39895a3946a564397fa4c5fbceb991cfe6b9e125", "filename": "src/libsyntax/ext/concat.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "1af3ba1d326bc7ae062f565a38ea91e58b83a60b", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "784a92b9a0e555fea760a56daf81a7ff64278aaa", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "7c65d2b4ff483d55a1d3b101a83f6c6e1c9f8a52", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "616390467f06fc2b897dd646ef7022d1974ed0f4", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "47b29a4db3e27fbffd18dc6bb635aef05bd20883", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "db99c14244324569e63c86e56d399933ae56c93f", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "603c44780071623200b34c1ed820e7f007e2d9c6", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 12, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "48034ce50ab51b1b67bf1c0c1722f96b23960c59", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "9b54e259761db82f42d35d24bd7c9fef6abf497f", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "9ef996ac3179b15e4acb483cd13579b1709b2311", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 37, "deletions": 53, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "5352cfaf749b0904c7ac75d6bd218efa52e14f15", "filename": "src/libsyntax/ext/fmt.rs", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/9f1ead8fadc56bad30dc74f5cc50d78af4fbc972/src%2Flibsyntax%2Fext%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f1ead8fadc56bad30dc74f5cc50d78af4fbc972/src%2Flibsyntax%2Fext%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ffmt.rs?ref=9f1ead8fadc56bad30dc74f5cc50d78af4fbc972"}, {"sha": "637b6d4649d209a9c45a9a71eb3bbe1b131506b8", "filename": "src/libsyntax/ext/format.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fformat.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "ae8ff118fcc0fefced187de569f65a8a1d016318", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "2dbf29c145c8ab1dea9d534284b644ca6f20aacf", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "31a1a838b133db55bc1052022994cf86993efd5a", "filename": "src/libsyntax/ext/source_util.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fsource_util.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "9eda4bcef9942fcfa442588b327a96df47a8ea00", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "fc341e3bd8559e623f51cbc86874a328e563a83e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}, {"sha": "94b8356130aeb576ecd7d53445f5186d2e404005", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5b3cd3900ceda838f5798c30ab96ceb41f962534/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=5b3cd3900ceda838f5798c30ab96ceb41f962534"}]}