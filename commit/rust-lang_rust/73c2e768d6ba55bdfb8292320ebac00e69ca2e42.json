{"sha": "73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczYzJlNzY4ZDZiYTU1YmRmYjgyOTIzMjBlYmFjMDBlNjljYTJlNDI=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-10T00:25:40Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2015-04-14T09:55:42Z"}, "message": "Rebased", "tree": {"sha": "fb6f8a5f718bcaa8729d21a4f2526604a17d8994", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb6f8a5f718bcaa8729d21a4f2526604a17d8994"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "html_url": "https://github.com/rust-lang/rust/commit/73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e8e64140ff60d1a20d7e54369db714a9fcd8b96", "html_url": "https://github.com/rust-lang/rust/commit/4e8e64140ff60d1a20d7e54369db714a9fcd8b96"}], "stats": {"total": 128, "additions": 56, "deletions": 72}, "files": [{"sha": "c756d3cb9c28cdf73d02af142f7b87a090d48956", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -70,7 +70,7 @@ use option::Option::{self, Some, None};\n use marker::Sized;\n use usize;\n \n-fn _assert_is_object_safe(_: &Iterator) {}\n+fn _assert_is_object_safe(_: &Iterator<Item=()>) {}\n \n /// An interface for dealing with \"external iterators\". These types of iterators\n /// can be resumed at any time as all state is stored internally as opposed to"}, {"sha": "4f9ac3dd8ef221534a2299bae8551d88fb3e87d0", "filename": "src/librustc/middle/expr_use_visitor.rs", "status": "modified", "additions": 21, "deletions": 46, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fexpr_use_visitor.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -799,18 +799,7 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n                     self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 }\n                 ty::AdjustDerefRef(ref adj) => {\n-                    self.walk_autoderefs(expr, adj.autoderefs);\n-                    if let Some(ref r) = adj.autoref {\n-                        self.walk_autoref(expr, r, adj.autoderefs);\n-                    } else if adj.unsize.is_some() {\n-                        assert!(adj.autoderefs == 0,\n-                                format!(\"Expected no derefs with \\\n-                                         unsize AutoRefs, found: {}\",\n-                                         adj.repr(self.tcx())));\n-                        let cmt_unadjusted =\n-                            return_if_err!(self.mc.cat_expr_unadjusted(expr));\n-                        self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n-                    }\n+                    self.walk_autoderefref(expr, adj);\n                 }\n             }\n         }\n@@ -860,29 +849,29 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n         self.walk_autoderefs(expr, adj.autoderefs);\n \n         // Weird hacky special case: AutoUnsizeUniq, which converts\n-        // from a ~T to a ~Trait etc, always comes in a stylized\n+        // from a Box<T> to a Box<Trait> etc, always comes in a stylized\n         // fashion. In particular, we want to consume the ~ pointer\n         // being dereferenced, not the dereferenced content (as the\n         // content is, at least for upcasts, unsized).\n-        match adj.autoref {\n-            Some(ty::AutoUnsizeUniq(_)) => {\n-                assert!(adj.autoderefs == 1,\n-                        format!(\"Expected exactly 1 deref with Uniq AutoRefs, found: {}\",\n-                                adj.autoderefs));\n+        if let Some(ty) = adj.unsize {\n+            if let ty::ty_uniq(_) = ty.sty {\n+                assert!(adj.autoderefs == 0,\n+                        format!(\"Expected no derefs with unsize AutoRefs, found: {}\",\n+                                 adj.repr(self.tcx())));\n                 let cmt_unadjusted =\n                     return_if_err!(self.mc.cat_expr_unadjusted(expr));\n                 self.delegate_consume(expr.id, expr.span, cmt_unadjusted);\n                 return;\n             }\n-            _ => { }\n         }\n \n-        let autoref = adj.autoref.as_ref();\n+        //let autoref = adj.autoref.as_ref();\n         let cmt_derefd = return_if_err!(\n             self.mc.cat_expr_autoderefd(expr, adj.autoderefs));\n-        self.walk_autoref(expr, &cmt_derefd, autoref);\n+        self.walk_autoref(expr, cmt_derefd, adj.autoref);\n     }\n \n+\n     /// Walks the autoref `opt_autoref` applied to the autoderef'd\n     /// `expr`. `cmt_derefd` is the mem-categorized form of `expr`\n     /// after all relevant autoderefs have occurred. Because AutoRefs\n@@ -893,25 +882,25 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n     /// autoref.\n     fn walk_autoref(&mut self,\n                     expr: &ast::Expr,\n-                    cmt_derefd: &mc::cmt<'tcx>,\n-                    opt_autoref: Option<&ty::AutoRef<'tcx>>)\n+                    cmt_base: mc::cmt<'tcx>,\n+                    opt_autoref: Option<ty::AutoRef<'tcx>>)\n                     -> mc::cmt<'tcx>\n     {\n         debug!(\"walk_autoref(expr.id={} cmt_derefd={} opt_autoref={:?})\",\n                expr.id,\n-               cmt_derefd.repr(self.tcx()),\n+               cmt_base.repr(self.tcx()),\n                opt_autoref);\n \n+        let cmt_base_ty = cmt_base.ty;\n+\n         let autoref = match opt_autoref {\n-            Some(autoref) => autoref,\n+            Some(ref autoref) => autoref,\n             None => {\n-                // No recursive step here, this is a base case.\n-                return cmt_derefd.clone();\n+                // No AutoRef.\n+                return cmt_base;\n             }\n         };\n \n-        let cmt_base = self.walk_autoref_recursively(expr, cmt_derefd, baseref);\n-\n         debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n                expr.id,\n                cmt_base.repr(self.tcx()));\n@@ -920,15 +909,13 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n             ty::AutoPtr(r, m) => {\n                 self.delegate.borrow(expr.id,\n                                      expr.span,\n-                                     cmt_derefd,\n+                                     cmt_base,\n                                      *r,\n                                      ty::BorrowKind::from_mutbl(m),\n                                      AutoRef);\n             }\n \n-            ty::AutoUnsafe(m, ref baseref) => {\n-                let cmt_base = self.walk_autoref_recursively(expr, cmt_derefd, baseref);\n-\n+            ty::AutoUnsafe(m) => {\n                 debug!(\"walk_autoref: expr.id={} cmt_base={}\",\n                        expr.id,\n                        cmt_base.repr(self.tcx()));\n@@ -953,24 +940,12 @@ impl<'d,'t,'tcx,TYPER:mc::Typer<'tcx>> ExprUseVisitor<'d,'t,'tcx,TYPER> {\n \n         let adj_ty =\n             ty::adjust_ty_for_autoref(self.tcx(),\n-                                      expr.span,\n-                                      cmt_derefd.ty,\n+                                      cmt_base_ty,\n                                       opt_autoref);\n \n         self.mc.cat_rvalue_node(expr.id, expr.span, adj_ty)\n     }\n \n-    fn walk_autoref_recursively(&mut self,\n-                                expr: &ast::Expr,\n-                                cmt_derefd: &mc::cmt<'tcx>,\n-                                autoref: &Option<Box<ty::AutoRef<'tcx>>>)\n-                                -> mc::cmt<'tcx>\n-    {\n-        // Shuffle from a ref to an optional box to an optional ref.\n-        let autoref: Option<&ty::AutoRef<'tcx>> = autoref.as_ref().map(|b| &**b);\n-        self.walk_autoref(expr, cmt_derefd, autoref)\n-    }\n-\n \n     // When this returns true, it means that the expression *is* a\n     // method-call (i.e. via the operator-overload).  This true result"}, {"sha": "e0b32ed06a4043db7c6a00a3d92d6910e23343ce", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -290,6 +290,12 @@ pub enum AutoAdjustment<'tcx> {\n \n #[derive(Copy, Clone, Debug)]\n pub struct AutoDerefRef<'tcx> {\n+    // FIXME with more powerful date structures we could have a better design\n+    // here. Some constraints:\n+    //  unsize => autoref\n+    //  unsize => autodefs == 0\n+\n+\n     /// Apply a number of dereferences, producing an lvalue.\n     pub autoderefs: usize,\n \n@@ -303,11 +309,11 @@ pub struct AutoDerefRef<'tcx> {\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum AutoRef<'tcx> {\n-    /// Convert from T to &T\n+    /// Convert from T to &T.\n     AutoPtr(&'tcx Region, ast::Mutability),\n \n-    /// Convert from T to *T\n-    /// Value to thin pointer\n+    /// Convert from T to *T.\n+    /// Value to thin pointer.\n     AutoUnsafe(ast::Mutability),\n }\n \n@@ -407,7 +413,7 @@ impl MethodCall {\n         }\n     }\n \n-    pub fn autoderef(expr_id: ast::NodeId, autoderef: usize) -> MethodCall {\n+    pub fn autoderef(expr_id: ast::NodeId, autoderef: u32) -> MethodCall {\n         MethodCall {\n             expr_id: expr_id,\n             autoderef: 1 + autoderef\n@@ -4487,8 +4493,8 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                             let method_call = MethodCall::autoderef(expr_id, i as u32);\n                             match method_type(method_call) {\n                                 Some(method_ty) => {\n-                                    // overloaded deref operators have all late-bound\n-                                    // regions fully instantiated and coverge\n+                                    // Overloaded deref operators have all late-bound\n+                                    // regions fully instantiated and coverge.\n                                     let fn_ret =\n                                         ty::no_late_bound_regions(cx,\n                                                                   &ty_fn_ret(method_ty)).unwrap();\n@@ -4501,8 +4507,7 @@ pub fn adjust_ty<'tcx, F>(cx: &ctxt<'tcx>,\n                                 None => {\n                                     cx.sess.span_bug(\n                                         span,\n-                                        &format!(\"the {}th autoderef failed: \\\n-                                                {}\",\n+                                        &format!(\"the {}th autoderef failed: {}\",\n                                                 i,\n                                                 ty_to_string(cx, adjusted_ty))\n                                         );"}, {"sha": "28df1c21595777591bb6424743bcc8c7247fc608", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -79,7 +79,6 @@ use syntax::ast;\n struct Coerce<'a, 'tcx: 'a> {\n     fcx: &'a FnCtxt<'a, 'tcx>,\n     origin: infer::TypeOrigin,\n-    trace: TypeTrace<'tcx>,\n     unsizing_obligation: Cell<Option<Ty<'tcx>>>\n }\n \n@@ -266,7 +265,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                 if let Some(target) = self.unsize_ty(mt_a.ty, mt_b.ty) {\n                     try!(coerce_mutbls(mt_a.mutbl, mt_b.mutbl));\n \n-                    let coercion = Coercion(self.trace.clone());\n+                    let coercion = Coercion(self.origin.span());\n                     let r_borrow = self.fcx.infcx().next_region_var(coercion);\n                     let region = self.tcx().mk_region(r_borrow);\n                     (Some(ty::AutoPtr(region, mt_b.mutbl)), target)\n@@ -293,7 +292,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         };\n \n         let target = ty::adjust_ty_for_autoref(self.tcx(), target, reborrow);\n-        try!(self.fcx.infcx().try(|_| self.subtype(target, b)));\n+        try!(self.subtype(target, b));\n         let adjustment = AutoDerefRef {\n             autoderefs: if reborrow.is_some() { 1 } else { 0 },\n             autoref: reborrow,\n@@ -374,7 +373,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n                     assert!(ty_substs_a.len() == ty_substs_b.len());\n \n                     let tps = ty_substs_a.iter().zip(ty_substs_b.iter()).enumerate();\n-                    for (i, (&tp_a, &tp_b)) in tps {\n+                    for (i, (tp_a, tp_b)) in tps {\n                         if self.subtype(*tp_a, *tp_b).is_ok() {\n                             continue;\n                         }\n@@ -498,12 +497,10 @@ pub fn mk_assignty<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                              -> RelateResult<'tcx, ()> {\n     debug!(\"mk_assignty({} -> {})\", a.repr(fcx.tcx()), b.repr(fcx.tcx()));\n     let (adjustment, unsizing_obligation) = try!(indent(|| {\n-        fcx.infcx().commit_if_ok(|| {\n-            let origin = infer::ExprAssignable(expr.span);\n+        fcx.infcx().commit_if_ok(|_| {\n             let coerce = Coerce {\n                 fcx: fcx,\n                 origin: infer::ExprAssignable(expr.span),\n-                trace: infer::TypeTrace::types(origin, false, a, b),\n                 unsizing_obligation: Cell::new(None)\n             };\n             Ok((try!(coerce.coerce(expr, a, b)),"}, {"sha": "b4000788d1998db97ce0b5c197782efca7f6529e", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -313,9 +313,15 @@ fn lookup_op_method<'a, 'tcx>(fcx: &'a FnCtxt<'a, 'tcx>,\n \n     let method = match trait_did {\n         Some(trait_did) => {\n-            let noop = ty::AutoDerefRef { autoderefs: 0, autoref: None };\n-            method::lookup_in_trait_adjusted(fcx, expr.span, Some(lhs_expr), opname,\n-                                             trait_did, noop, lhs_ty, Some(other_tys))\n+            method::lookup_in_trait_adjusted(fcx,\n+                                             expr.span,\n+                                             Some(lhs_expr),\n+                                             opname,\n+                                             trait_did,\n+                                             0,\n+                                             false,\n+                                             lhs_ty,\n+                                             Some(other_tys))\n         }\n         None => None\n     };"}, {"sha": "6dfc1e0ea6c2651598ba03f01462a3f74102bbf1", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -1134,7 +1134,7 @@ fn link_autoref(rcx: &Rcx,\n \n         ty::AutoUnsafe(m) => {\n             let r = ty::ReScope(CodeExtent::from_node_id(expr.id));\n-            link_region(rcx, expr.span, r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n+            link_region(rcx, expr.span, &r, ty::BorrowKind::from_mutbl(m), expr_cmt);\n         }\n     }\n }"}, {"sha": "a9094fce57c61e24f4c42a468d7dac9fa0ebd02f", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -13,7 +13,6 @@ use middle::traits::{self, ObjectSafetyViolation, MethodViolationCode};\n use middle::traits::{Obligation, ObligationCause};\n use middle::traits::report_fulfillment_errors;\n use middle::ty::{self, Ty, AsPredicate};\n-use syntax::ast;\n use syntax::codemap::Span;\n use util::ppaux::{Repr, UserString};\n "}, {"sha": "2b34fcab24c04728918afa4130549f1f2b393a0c", "filename": "src/test/compile-fail/associated-type-projection-from-multiple-supertraits.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fassociated-type-projection-from-multiple-supertraits.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -34,8 +34,9 @@ fn dent<C:BoxCar>(c: C, color: C::Color) {\n \n fn dent_object<COLOR>(c: BoxCar<Color=COLOR>) {\n     //~^ ERROR ambiguous associated type\n-    //~| ERROR the associated type `Color` (from the trait `Box`) must be specified\n-    //~| ERROR the associated type `Color` (from the trait `Vehicle`) must be specified\n+    //~| ERROR the value of the associated type `Color` (from the trait `Vehicle`) must be specified\n+    //~| NOTE could derive from `Vehicle`\n+    //~| NOTE could derive from `Box`\n }\n \n fn paint<C:BoxCar>(c: C, d: C::Color) {"}, {"sha": "a05bbe4960e7c3fc691e7ff975f07fad121b8ad5", "filename": "src/test/compile-fail/issue-22560.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-22560.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -14,6 +14,7 @@ use std::ops::{Add, Sub};\n \n type Test = Add +\n             //~^ ERROR the type parameter `RHS` must be explicitly specified in an object type because its default value `Self` references the type `Self`\n+            //~^^ ERROR the value of the associated type `Output` (from the trait `core::ops::Add`) must be specified [E0191]\n             Sub;\n             //~^ ERROR only the builtin traits can be used as closure or object bounds\n "}, {"sha": "56da6693939eb5f503cbeb2ac50cf1c749702235", "filename": "src/test/run-make/save-analysis/foo.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/73c2e768d6ba55bdfb8292320ebac00e69ca2e42/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fsave-analysis%2Ffoo.rs?ref=73c2e768d6ba55bdfb8292320ebac00e69ca2e42", "patch": "@@ -10,7 +10,7 @@\n \n #![ crate_name = \"test\" ]\n #![allow(unstable)]\n-#![feature(box_syntax, old_io, rustc_private, core)]\n+#![feature(box_syntax, old_io, rustc_private, core, zero_one)]\n \n extern crate graphviz;\n // A simple rust project\n@@ -25,7 +25,7 @@ use std::old_io::stdio::println;\n use sub::sub2 as msalias;\n use sub::sub2;\n use sub::sub2::nested_struct as sub_struct;\n-use std::num::Float;\n+use std::num::One;\n use std::num::cast;\n use std::num::{from_int,from_i8,from_i32};\n \n@@ -42,7 +42,7 @@ fn test_alias<I: Iterator>(i: Option<<I as Iterator>::Item>) {\n     let s = sub_struct{ field2: 45, };\n \n     // import tests\n-    fn foo(x: &Float) {}\n+    fn foo(x: &One) {}\n     let _: Option<u8> = from_i32(45);\n \n     let x = 42;"}]}