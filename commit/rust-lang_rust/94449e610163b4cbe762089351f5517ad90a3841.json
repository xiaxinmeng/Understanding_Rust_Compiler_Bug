{"sha": "94449e610163b4cbe762089351f5517ad90a3841", "node_id": "C_kwDOAAsO6NoAKDk0NDQ5ZTYxMDE2M2I0Y2JlNzYyMDg5MzUxZjU1MTdhZDkwYTM4NDE", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-02-07T21:58:30Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-30T11:55:13Z"}, "message": "Store all generic bounds as where predicates.", "tree": {"sha": "7123532c91fd5cab9a2a7642b05b61a8a06a0f4d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7123532c91fd5cab9a2a7642b05b61a8a06a0f4d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/94449e610163b4cbe762089351f5517ad90a3841", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/94449e610163b4cbe762089351f5517ad90a3841", "html_url": "https://github.com/rust-lang/rust/commit/94449e610163b4cbe762089351f5517ad90a3841", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/94449e610163b4cbe762089351f5517ad90a3841/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "05b29f9a9295caf71fedfc24e6d7062bba434171", "url": "https://api.github.com/repos/rust-lang/rust/commits/05b29f9a9295caf71fedfc24e6d7062bba434171", "html_url": "https://github.com/rust-lang/rust/commit/05b29f9a9295caf71fedfc24e6d7062bba434171"}], "stats": {"total": 1721, "additions": 769, "deletions": 952}, "files": [{"sha": "125acdcc27d9723e208799e511b88af77b543c85", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 93, "deletions": 15, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -267,9 +267,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n                     let (generics, decl) =\n-                        this.add_implicit_generics(generics, id, |this, idty| {\n+                        this.add_implicit_generics(generics, id, |this, idty, idpb| {\n                             let ret_id = asyncness.opt_return_id();\n-                            this.lower_fn_decl(&decl, Some((id, idty)), FnDeclKind::Fn, ret_id)\n+                            this.lower_fn_decl(\n+                                &decl,\n+                                Some((id, idty, idpb)),\n+                                FnDeclKind::Fn,\n+                                ret_id,\n+                            )\n                         });\n                     let sig = hir::FnSig {\n                         decl,\n@@ -384,7 +389,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n                 let (generics, (trait_ref, lowered_ty)) =\n-                    self.add_implicit_generics(ast_generics, id, |this, _| {\n+                    self.add_implicit_generics(ast_generics, id, |this, _, _| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n@@ -649,7 +654,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n                     let fdec = &sig.decl;\n                     let (generics, (fn_dec, fn_args)) =\n-                        self.add_implicit_generics(generics, i.id, |this, _| {\n+                        self.add_implicit_generics(generics, i.id, |this, _, _| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, FnDeclKind::ExternFn, None),\n@@ -1228,8 +1233,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         is_async: Option<NodeId>,\n     ) -> (&'hir hir::Generics<'hir>, hir::FnSig<'hir>) {\n         let header = self.lower_fn_header(sig.header);\n-        let (generics, decl) = self.add_implicit_generics(generics, id, |this, idty| {\n-            this.lower_fn_decl(&sig.decl, Some((id, idty)), kind, is_async)\n+        let (generics, decl) = self.add_implicit_generics(generics, id, |this, idty, idpb| {\n+            this.lower_fn_decl(&sig.decl, Some((id, idty, idpb)), kind, is_async)\n         });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n     }\n@@ -1289,7 +1294,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     pub(super) fn lower_generics_mut(\n         &mut self,\n         generics: &Generics,\n-        itctx: ImplTraitContext<'_, 'hir>,\n+        mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> GenericsCtor<'hir> {\n         // Error if `?Trait` bounds in where clauses don't refer directly to type parameters.\n         // Note: we used to clone these bounds directly onto the type parameter (and avoid lowering\n@@ -1338,7 +1343,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n         }\n \n-        let predicates = self.arena.alloc_from_iter(\n+        let mut predicates = SmallVec::new();\n+        predicates.extend(generics.params.iter().filter_map(|param| {\n+            let bounds = self.lower_param_bounds(&param.bounds, itctx.reborrow());\n+            self.lower_generic_bound_predicate(param.ident, param.id, &param.kind, bounds)\n+        }));\n+        predicates.extend(\n             generics\n                 .where_clause\n                 .predicates\n@@ -1347,8 +1357,9 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         );\n \n         GenericsCtor {\n-            params: self.lower_generic_params_mut(&generics.params, itctx).collect(),\n+            params: self.lower_generic_params_mut(&generics.params).collect(),\n             predicates,\n+            has_where_clause: !generics.where_clause.predicates.is_empty(),\n             where_clause_span: self.lower_span(generics.where_clause.span),\n             span: self.lower_span(generics.span),\n         }\n@@ -1363,6 +1374,72 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         generics_ctor.into_generics(self.arena)\n     }\n \n+    pub(super) fn lower_generic_bound_predicate(\n+        &mut self,\n+        ident: Ident,\n+        id: NodeId,\n+        kind: &GenericParamKind,\n+        bounds: &'hir [hir::GenericBound<'hir>],\n+    ) -> Option<hir::WherePredicate<'hir>> {\n+        // Do not create a clause if we do not have anything inside it.\n+        if bounds.is_empty() {\n+            return None;\n+        }\n+        let ident = self.lower_ident(ident);\n+        let param_span = ident.span;\n+        let span = bounds\n+            .iter()\n+            .fold(Some(param_span.shrink_to_hi()), |span: Option<Span>, bound| {\n+                let bound_span = bound.span();\n+                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n+                // as we use this method to get a span appropriate for suggestions.\n+                if !bound_span.can_be_used_for_suggestions() {\n+                    None\n+                } else if let Some(span) = span {\n+                    Some(span.to(bound_span))\n+                } else {\n+                    Some(bound_span)\n+                }\n+            })\n+            .unwrap_or(param_span.shrink_to_hi());\n+        match kind {\n+            GenericParamKind::Const { .. } => None,\n+            GenericParamKind::Type { .. } => {\n+                let def_id = self.resolver.local_def_id(id).to_def_id();\n+                let ty_path = self.arena.alloc(hir::Path {\n+                    span: param_span,\n+                    res: Res::Def(DefKind::TyParam, def_id),\n+                    segments: self.arena.alloc_from_iter([hir::PathSegment::from_ident(ident)]),\n+                });\n+                let ty_id = self.next_id();\n+                let bounded_ty =\n+                    self.ty_path(ty_id, param_span, hir::QPath::Resolved(None, ty_path));\n+                Some(hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n+                    bounded_ty: self.arena.alloc(bounded_ty),\n+                    bounds,\n+                    span,\n+                    bound_generic_params: &[],\n+                    in_where_clause: false,\n+                }))\n+            }\n+            GenericParamKind::Lifetime => {\n+                let ident_span = self.lower_span(ident.span);\n+                let ident = self.lower_ident(ident);\n+                let res = self.resolver.get_lifetime_res(id).unwrap_or_else(|| {\n+                    panic!(\"Missing resolution for lifetime {:?} at {:?}\", id, ident.span)\n+                });\n+                let lt_id = self.resolver.next_node_id();\n+                let lifetime = self.new_named_lifetime_with_res(lt_id, ident_span, ident, res);\n+                Some(hir::WherePredicate::RegionPredicate(hir::WhereRegionPredicate {\n+                    lifetime,\n+                    span,\n+                    bounds,\n+                    in_where_clause: false,\n+                }))\n+            }\n+        }\n+    }\n+\n     fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {\n         match *pred {\n             WherePredicate::BoundPredicate(WhereBoundPredicate {\n@@ -1371,10 +1448,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 ref bounds,\n                 span,\n             }) => hir::WherePredicate::BoundPredicate(hir::WhereBoundPredicate {\n-                bound_generic_params: self.lower_generic_params(\n-                    bound_generic_params,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                ),\n+                bound_generic_params: self.lower_generic_params(bound_generic_params),\n                 bounded_ty: self\n                     .lower_ty(bounded_ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type)),\n                 bounds: self.arena.alloc_from_iter(bounds.iter().map(|bound| {\n@@ -1384,6 +1458,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     )\n                 })),\n                 span: self.lower_span(span),\n+                in_where_clause: true,\n             }),\n             WherePredicate::RegionPredicate(WhereRegionPredicate {\n                 ref lifetime,\n@@ -1396,6 +1471,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     bounds,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Bound),\n                 ),\n+                in_where_clause: true,\n             }),\n             WherePredicate::EqPredicate(WhereEqPredicate { id, ref lhs_ty, ref rhs_ty, span }) => {\n                 hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n@@ -1414,7 +1490,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n /// Helper struct for delayed construction of Generics.\n pub(super) struct GenericsCtor<'hir> {\n     pub(super) params: SmallVec<[hir::GenericParam<'hir>; 4]>,\n-    predicates: &'hir [hir::WherePredicate<'hir>],\n+    pub(super) predicates: SmallVec<[hir::WherePredicate<'hir>; 4]>,\n+    has_where_clause: bool,\n     where_clause_span: Span,\n     span: Span,\n }\n@@ -1423,7 +1500,8 @@ impl<'hir> GenericsCtor<'hir> {\n     pub(super) fn into_generics(self, arena: &'hir Arena<'hir>) -> &'hir hir::Generics<'hir> {\n         arena.alloc(hir::Generics {\n             params: arena.alloc_from_iter(self.params),\n-            predicates: self.predicates,\n+            predicates: arena.alloc_from_iter(self.predicates),\n+            has_where_clause: self.has_where_clause,\n             where_clause_span: self.where_clause_span,\n             span: self.span,\n         })"}, {"sha": "6abb3d03e83d9bb908591e8e862af2c323aab6c9", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -259,7 +259,7 @@ enum ImplTraitContext<'b, 'a> {\n     /// equivalent to a fresh universal parameter like `fn foo<T: Debug>(x: T)`.\n     ///\n     /// Newly generated parameters should be inserted into the given `Vec`.\n-    Universal(&'b mut Vec<hir::GenericParam<'a>>, LocalDefId),\n+    Universal(&'b mut Vec<hir::GenericParam<'a>>, &'b mut Vec<hir::WherePredicate<'a>>, LocalDefId),\n \n     /// Treat `impl Trait` as shorthand for a new opaque type.\n     /// Example: `fn foo() -> impl Debug`, where `impl Debug` is conceptually\n@@ -303,7 +303,7 @@ impl<'a> ImplTraitContext<'_, 'a> {\n     fn reborrow<'this>(&'this mut self) -> ImplTraitContext<'this, 'a> {\n         use self::ImplTraitContext::*;\n         match self {\n-            Universal(params, parent) => Universal(params, *parent),\n+            Universal(params, bounds, parent) => Universal(params, bounds, *parent),\n             ReturnPositionOpaqueTy { origin } => ReturnPositionOpaqueTy { origin: *origin },\n             TypeAliasesOpaqueTy => TypeAliasesOpaqueTy,\n             Disallowed(pos) => Disallowed(*pos),\n@@ -704,7 +704,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         Some(hir::GenericParam {\n             hir_id,\n             name,\n-            bounds: &[],\n             span: self.lower_span(ident.span),\n             pure_wrt_drop: false,\n             kind: hir::GenericParamKind::Lifetime { kind },\n@@ -718,14 +717,23 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         &mut self,\n         generics: &Generics,\n         parent_node_id: NodeId,\n-        f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n+        f: impl FnOnce(\n+            &mut Self,\n+            &mut Vec<hir::GenericParam<'hir>>,\n+            &mut Vec<hir::WherePredicate<'hir>>,\n+        ) -> T,\n     ) -> (&'hir hir::Generics<'hir>, T) {\n         let mut impl_trait_defs = Vec::new();\n+        let mut impl_trait_bounds = Vec::new();\n         let mut lowered_generics = self.lower_generics_mut(\n             generics,\n-            ImplTraitContext::Universal(&mut impl_trait_defs, self.current_hir_id_owner),\n+            ImplTraitContext::Universal(\n+                &mut impl_trait_defs,\n+                &mut impl_trait_bounds,\n+                self.current_hir_id_owner,\n+            ),\n         );\n-        let res = f(self, &mut impl_trait_defs);\n+        let res = f(self, &mut impl_trait_defs, &mut impl_trait_bounds);\n \n         let extra_lifetimes = self.resolver.take_extra_lifetime_params(parent_node_id);\n         lowered_generics.params.extend(\n@@ -736,6 +744,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 })\n                 .chain(impl_trait_defs),\n         );\n+        lowered_generics.predicates.extend(impl_trait_bounds);\n \n         let lowered_generics = lowered_generics.into_generics(self.arena);\n         (lowered_generics, res)\n@@ -999,7 +1008,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     // so desugar to\n                     //\n                     //     fn foo(x: dyn Iterator<Item = impl Debug>)\n-                    ImplTraitContext::Universal(_, parent) if self.is_in_dyn_type => {\n+                    ImplTraitContext::Universal(_, _, parent) if self.is_in_dyn_type => {\n                         parent_def_id = parent;\n                         (true, itctx)\n                     }\n@@ -1188,10 +1197,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             }\n             TyKind::BareFn(ref f) => self.with_lifetime_binder(t.id, |this| {\n                 hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n-                    generic_params: this.lower_generic_params(\n-                        &f.generic_params,\n-                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                    ),\n+                    generic_params: this.lower_generic_params(&f.generic_params),\n                     unsafety: this.lower_unsafety(f.unsafety),\n                     abi: this.lower_extern(f.ext),\n                     decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n@@ -1274,24 +1280,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                             |this| this.lower_param_bounds(bounds, nested_itctx),\n                         )\n                     }\n-                    ImplTraitContext::Universal(in_band_ty_params, parent_def_id) => {\n+                    ImplTraitContext::Universal(\n+                        in_band_ty_params,\n+                        in_band_ty_bounds,\n+                        parent_def_id,\n+                    ) => {\n                         // Add a definition for the in-band `Param`.\n                         let def_id = self.resolver.local_def_id(def_node_id);\n \n                         let hir_bounds = self.lower_param_bounds(\n                             bounds,\n-                            ImplTraitContext::Universal(in_band_ty_params, parent_def_id),\n+                            ImplTraitContext::Universal(\n+                                in_band_ty_params,\n+                                in_band_ty_bounds,\n+                                parent_def_id,\n+                            ),\n                         );\n                         // Set the name to `impl Bound1 + Bound2`.\n                         let ident = Ident::from_str_and_span(&pprust::ty_to_string(t), span);\n                         in_band_ty_params.push(hir::GenericParam {\n                             hir_id: self.lower_node_id(def_node_id),\n                             name: ParamName::Plain(self.lower_ident(ident)),\n                             pure_wrt_drop: false,\n-                            bounds: hir_bounds,\n                             span: self.lower_span(span),\n                             kind: hir::GenericParamKind::Type { default: None, synthetic: true },\n                         });\n+                        if let Some(preds) = self.lower_generic_bound_predicate(\n+                            ident,\n+                            def_node_id,\n+                            &GenericParamKind::Type { default: None },\n+                            hir_bounds,\n+                        ) {\n+                            in_band_ty_bounds.push(preds)\n+                        }\n \n                         hir::TyKind::Path(hir::QPath::Resolved(\n                             None,\n@@ -1374,7 +1395,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name: p_name,\n                         span,\n                         pure_wrt_drop: false,\n-                        bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n                     }\n                 },\n@@ -1386,6 +1406,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 generics: self.arena.alloc(hir::Generics {\n                     params: lifetime_defs,\n                     predicates: &[],\n+                    has_where_clause: false,\n                     where_clause_span: lctx.lower_span(span),\n                     span: lctx.lower_span(span),\n                 }),\n@@ -1463,7 +1484,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        mut in_band_ty_params: Option<(NodeId, &mut Vec<hir::GenericParam<'hir>>)>,\n+        mut in_band_ty_params: Option<(\n+            NodeId,\n+            &mut Vec<hir::GenericParam<'hir>>,\n+            &mut Vec<hir::WherePredicate<'hir>>,\n+        )>,\n         kind: FnDeclKind,\n         make_ret_async: Option<NodeId>,\n     ) -> &'hir hir::FnDecl<'hir> {\n@@ -1486,10 +1511,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             inputs = &inputs[..inputs.len() - 1];\n         }\n         let inputs = self.arena.alloc_from_iter(inputs.iter().map(|param| {\n-            if let Some((_, ibty)) = &mut in_band_ty_params {\n+            if let Some((_, ibty, ibpb)) = &mut in_band_ty_params {\n                 self.lower_ty_direct(\n                     &param.ty,\n-                    ImplTraitContext::Universal(ibty, self.current_hir_id_owner),\n+                    ImplTraitContext::Universal(ibty, ibpb, self.current_hir_id_owner),\n                 )\n             } else {\n                 self.lower_ty_direct(\n@@ -1518,7 +1543,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             match decl.output {\n                 FnRetTy::Ty(ref ty) => {\n                     let context = match in_band_ty_params {\n-                        Some((node_id, _)) if kind.impl_trait_return_allowed() => {\n+                        Some((node_id, _, _)) if kind.impl_trait_return_allowed() => {\n                             let fn_def_id = self.resolver.local_def_id(node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n                                 origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n@@ -1709,7 +1734,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         name: p_name,\n                         span,\n                         pure_wrt_drop: false,\n-                        bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n                     }\n                 }));\n@@ -1719,6 +1743,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 generics: this.arena.alloc(hir::Generics {\n                     params: generic_params,\n                     predicates: &[],\n+                    has_where_clause: false,\n                     where_clause_span: this.lower_span(span),\n                     span: this.lower_span(span),\n                 }),\n@@ -1925,26 +1950,15 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_generic_params_mut<'s>(\n         &'s mut self,\n         params: &'s [GenericParam],\n-        mut itctx: ImplTraitContext<'s, 'hir>,\n     ) -> impl Iterator<Item = hir::GenericParam<'hir>> + Captures<'a> + Captures<'s> {\n-        params.iter().map(move |param| self.lower_generic_param(param, itctx.reborrow()))\n+        params.iter().map(move |param| self.lower_generic_param(param))\n     }\n \n-    fn lower_generic_params(\n-        &mut self,\n-        params: &[GenericParam],\n-        itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> &'hir [hir::GenericParam<'hir>] {\n-        self.arena.alloc_from_iter(self.lower_generic_params_mut(params, itctx))\n+    fn lower_generic_params(&mut self, params: &[GenericParam]) -> &'hir [hir::GenericParam<'hir>] {\n+        self.arena.alloc_from_iter(self.lower_generic_params_mut(params))\n     }\n \n-    fn lower_generic_param(\n-        &mut self,\n-        param: &GenericParam,\n-        mut itctx: ImplTraitContext<'_, 'hir>,\n-    ) -> hir::GenericParam<'hir> {\n-        let bounds: Vec<_> = self.lower_param_bounds_mut(&param.bounds, itctx.reborrow()).collect();\n-\n+    fn lower_generic_param(&mut self, param: &GenericParam) -> hir::GenericParam<'hir> {\n         let (name, kind) = match param.kind {\n             GenericParamKind::Lifetime => {\n                 let param_name = if param.ident.name == kw::StaticLifetime\n@@ -1991,7 +2005,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             name,\n             span: self.lower_span(param.span()),\n             pure_wrt_drop: self.sess.contains_name(&param.attrs, sym::may_dangle),\n-            bounds: self.arena.alloc_from_iter(bounds),\n             kind,\n         }\n     }\n@@ -2014,8 +2027,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         p: &PolyTraitRef,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::PolyTraitRef<'hir> {\n-        let bound_generic_params =\n-            self.lower_generic_params(&p.bound_generic_params, itctx.reborrow());\n+        let bound_generic_params = self.lower_generic_params(&p.bound_generic_params);\n \n         let trait_ref = self.with_lifetime_binder(p.trait_ref.ref_id, |this| {\n             this.lower_trait_ref(&p.trait_ref, itctx.reborrow())"}, {"sha": "a5c8088a279a865f1be7993cc78e750141e9bf77", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 159, "deletions": 27, "changes": 186, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -496,27 +496,24 @@ pub enum GenericParamKind<'hir> {\n pub struct GenericParam<'hir> {\n     pub hir_id: HirId,\n     pub name: ParamName,\n-    pub bounds: GenericBounds<'hir>,\n     pub span: Span,\n     pub pure_wrt_drop: bool,\n     pub kind: GenericParamKind<'hir>,\n }\n \n impl<'hir> GenericParam<'hir> {\n-    pub fn bounds_span_for_suggestions(&self) -> Option<Span> {\n-        self.bounds\n-            .iter()\n-            .fold(None, |span: Option<Span>, bound| {\n-                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n-                // as we use this method to get a span appropriate for suggestions.\n-                if !bound.span().can_be_used_for_suggestions() {\n-                    None\n-                } else {\n-                    let span = span.map(|s| s.to(bound.span())).unwrap_or_else(|| bound.span());\n-                    Some(span)\n-                }\n-            })\n-            .map(|sp| sp.shrink_to_hi())\n+    /// Synthetic type-parameters are inserted after normal ones.\n+    /// In order for normal parameters to be able to refer to synthetic ones,\n+    /// scans them first.\n+    pub fn is_impl_trait(&self) -> bool {\n+        matches!(self.kind, GenericParamKind::Type { synthetic: true, .. })\n+    }\n+\n+    /// This can happen for `async fn`, e.g. `async fn f<'_>(&'_ self)`.\n+    ///\n+    /// See `lifetime_to_generic_param` in `rustc_ast_lowering` for more information.\n+    pub fn is_elided_lifetime(&self) -> bool {\n+        matches!(self.kind, GenericParamKind::Lifetime { kind: LifetimeParamKind::Elided })\n     }\n \n     /// Returns the span of `:` after a generic parameter.\n@@ -568,14 +565,20 @@ pub struct GenericParamCount {\n pub struct Generics<'hir> {\n     pub params: &'hir [GenericParam<'hir>],\n     pub predicates: &'hir [WherePredicate<'hir>],\n+    pub has_where_clause: bool,\n     pub where_clause_span: Span,\n     pub span: Span,\n }\n \n impl<'hir> Generics<'hir> {\n     pub const fn empty() -> &'hir Generics<'hir> {\n-        const NOPE: Generics<'_> =\n-            Generics { params: &[], predicates: &[], where_clause_span: DUMMY_SP, span: DUMMY_SP };\n+        const NOPE: Generics<'_> = Generics {\n+            params: &[],\n+            predicates: &[],\n+            has_where_clause: false,\n+            where_clause_span: DUMMY_SP,\n+            span: DUMMY_SP,\n+        };\n         &NOPE\n     }\n \n@@ -596,6 +599,19 @@ impl<'hir> Generics<'hir> {\n         }\n     }\n \n+    /// If there are generic parameters, return wher to introduce a new one, and false.\n+    /// If there is none, return where to introduce `<>` and true.\n+    pub fn span_for_param_suggestion(&self) -> Option<Span> {\n+        if self.params.iter().any(|p| self.span.contains(p.span)) {\n+            // `fn foo<A>(t: impl Trait)`\n+            //          ^ suggest `, T: Trait` here\n+            let span = self.span.with_lo(self.span.hi() - BytePos(1)).shrink_to_lo();\n+            Some(span)\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn where_clause_span(&self) -> Option<Span> {\n         if self.predicates.is_empty() { None } else { Some(self.where_clause_span) }\n     }\n@@ -610,7 +626,95 @@ impl<'hir> Generics<'hir> {\n     ///  in `fn foo<T>(t: T) where T: Foo,` so we don't suggest two trailing commas.\n     pub fn tail_span_for_predicate_suggestion(&self) -> Span {\n         let end = self.span_for_predicates_or_empty_place().shrink_to_hi();\n-        self.predicates.last().map_or(end, |p| p.span()).shrink_to_hi().to(end)\n+        if self.has_where_clause {\n+            self.predicates\n+                .iter()\n+                .filter(|p| p.in_where_clause())\n+                .last()\n+                .map_or(end, |p| p.span())\n+                .shrink_to_hi()\n+                .to(end)\n+        } else {\n+            end\n+        }\n+    }\n+\n+    pub fn bounds_for_param(\n+        &self,\n+        param_def_id: LocalDefId,\n+    ) -> impl Iterator<Item = &WhereBoundPredicate<'_>> {\n+        self.predicates.iter().filter_map(move |pred| match pred {\n+            WherePredicate::BoundPredicate(bp) if bp.is_param_bound(param_def_id.to_def_id()) => {\n+                Some(bp)\n+            }\n+            _ => None,\n+        })\n+    }\n+\n+    pub fn bounds_span_for_suggestions(&self, param_def_id: LocalDefId) -> Option<Span> {\n+        self.bounds_for_param(param_def_id).flat_map(|bp| bp.bounds.iter().rev()).find_map(\n+            |bound| {\n+                // We include bounds that come from a `#[derive(_)]` but point at the user's code,\n+                // as we use this method to get a span appropriate for suggestions.\n+                let bs = bound.span();\n+                if bs.can_be_used_for_suggestions() { Some(bs.shrink_to_hi()) } else { None }\n+            },\n+        )\n+    }\n+\n+    pub fn span_for_predicate_removal(&self, pos: usize) -> Span {\n+        let predicate = &self.predicates[pos];\n+        let span = predicate.span();\n+\n+        if !predicate.in_where_clause() {\n+            // <T: ?Sized, U>\n+            //   ^^^^^^^^\n+            return span;\n+        }\n+\n+        // We need to find out which comma to remove.\n+        if pos < self.predicates.len() - 1 {\n+            let next_pred = &self.predicates[pos + 1];\n+            if next_pred.in_where_clause() {\n+                // where T: ?Sized, Foo: Bar,\n+                //       ^^^^^^^^^^^\n+                return span.until(next_pred.span());\n+            }\n+        }\n+\n+        if pos > 0 {\n+            let prev_pred = &self.predicates[pos - 1];\n+            if prev_pred.in_where_clause() {\n+                // where Foo: Bar, T: ?Sized,\n+                //               ^^^^^^^^^^^\n+                return prev_pred.span().shrink_to_hi().to(span);\n+            }\n+        }\n+\n+        // This is the only predicate in the where clause.\n+        // where T: ?Sized\n+        // ^^^^^^^^^^^^^^^\n+        self.where_clause_span\n+    }\n+\n+    pub fn span_for_bound_removal(&self, predicate_pos: usize, bound_pos: usize) -> Span {\n+        let predicate = &self.predicates[predicate_pos];\n+        let bounds = predicate.bounds();\n+\n+        if bounds.len() == 1 {\n+            return self.span_for_predicate_removal(predicate_pos);\n+        }\n+\n+        let span = bounds[bound_pos].span();\n+        if bound_pos == 0 {\n+            // where T: ?Sized + Bar, Foo: Bar,\n+            //          ^^^^^^^^^\n+            span.to(bounds[1].span().shrink_to_lo())\n+        } else {\n+            // where T: Bar + ?Sized, Foo: Bar,\n+            //             ^^^^^^^^^\n+            bounds[bound_pos - 1].span().shrink_to_hi().to(span)\n+        }\n     }\n }\n \n@@ -633,12 +737,29 @@ impl<'hir> WherePredicate<'hir> {\n             WherePredicate::EqPredicate(p) => p.span,\n         }\n     }\n+\n+    pub fn in_where_clause(&self) -> bool {\n+        match self {\n+            WherePredicate::BoundPredicate(p) => p.in_where_clause,\n+            WherePredicate::RegionPredicate(p) => p.in_where_clause,\n+            WherePredicate::EqPredicate(_) => false,\n+        }\n+    }\n+\n+    pub fn bounds(&self) -> GenericBounds<'hir> {\n+        match self {\n+            WherePredicate::BoundPredicate(p) => p.bounds,\n+            WherePredicate::RegionPredicate(p) => p.bounds,\n+            WherePredicate::EqPredicate(_) => &[],\n+        }\n+    }\n }\n \n /// A type bound (e.g., `for<'c> Foo: Send + Clone + 'c`).\n #[derive(Debug, HashStable_Generic)]\n pub struct WhereBoundPredicate<'hir> {\n     pub span: Span,\n+    pub in_where_clause: bool,\n     /// Any generics from a `for` binding.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],\n     /// The type being bounded.\n@@ -650,21 +771,15 @@ pub struct WhereBoundPredicate<'hir> {\n impl<'hir> WhereBoundPredicate<'hir> {\n     /// Returns `true` if `param_def_id` matches the `bounded_ty` of this predicate.\n     pub fn is_param_bound(&self, param_def_id: DefId) -> bool {\n-        let TyKind::Path(QPath::Resolved(None, path)) = self.bounded_ty.kind else {\n-            return false;\n-        };\n-        match path.res {\n-            Res::Def(DefKind::TyParam, def_id)\n-            | Res::SelfTy { trait_: Some(def_id), alias_to: None } => def_id == param_def_id,\n-            _ => false,\n-        }\n+        self.bounded_ty.as_generic_param().map_or(false, |(def_id, _)| def_id == param_def_id)\n     }\n }\n \n /// A lifetime predicate (e.g., `'a: 'b + 'c`).\n #[derive(Debug, HashStable_Generic)]\n pub struct WhereRegionPredicate<'hir> {\n     pub span: Span,\n+    pub in_where_clause: bool,\n     pub lifetime: Lifetime,\n     pub bounds: GenericBounds<'hir>,\n }\n@@ -2230,6 +2345,23 @@ pub struct Ty<'hir> {\n     pub span: Span,\n }\n \n+impl<'hir> Ty<'hir> {\n+    /// Returns `true` if `param_def_id` matches the `bounded_ty` of this predicate.\n+    pub fn as_generic_param(&self) -> Option<(DefId, Ident)> {\n+        let TyKind::Path(QPath::Resolved(None, path)) = self.kind else {\n+            return None;\n+        };\n+        let [segment] = &path.segments else {\n+            return None;\n+        };\n+        match path.res {\n+            Res::Def(DefKind::TyParam, def_id)\n+            | Res::SelfTy { trait_: Some(def_id), alias_to: None } => Some((def_id, segment.ident)),\n+            _ => None,\n+        }\n+    }\n+}\n+\n /// Not represented directly in the AST; referred to by name through a `ty_path`.\n #[derive(Copy, Clone, PartialEq, Eq, Encodable, Decodable, Hash, Debug)]\n #[derive(HashStable_Generic)]\n@@ -3315,7 +3447,7 @@ mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n     rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n     rustc_data_structures::static_assert_size!(super::GenericBound<'_>, 48);\n-    rustc_data_structures::static_assert_size!(super::Generics<'static>, 48);\n+    rustc_data_structures::static_assert_size!(super::Generics<'static>, 56);\n     rustc_data_structures::static_assert_size!(super::Impl<'static>, 80);\n \n     rustc_data_structures::static_assert_size!(super::Item<'static>, 80);"}, {"sha": "d41b85fd20f7b24085ea7bd6add6000dc497bea5", "filename": "compiler/rustc_hir/src/intravisit.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fintravisit.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -899,7 +899,6 @@ pub fn walk_generic_param<'v, V: Visitor<'v>>(visitor: &mut V, param: &'v Generi\n             }\n         }\n     }\n-    walk_list!(visitor, visit_param_bound, param.bounds);\n }\n \n pub fn walk_const_param_default<'v, V: Visitor<'v>>(visitor: &mut V, ct: &'v AnonConst) {"}, {"sha": "7af9622b2cf76753b142dd3d1fcfeceaabb5a4da", "filename": "compiler/rustc_hir_pretty/src/lib.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_pretty%2Fsrc%2Flib.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -2096,21 +2096,8 @@ impl<'a> State<'a> {\n         self.print_ident(param.name.ident());\n \n         match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                let mut sep = \":\";\n-                for bound in param.bounds {\n-                    match bound {\n-                        GenericBound::Outlives(ref lt) => {\n-                            self.word(sep);\n-                            self.print_lifetime(lt);\n-                            sep = \"+\";\n-                        }\n-                        _ => panic!(),\n-                    }\n-                }\n-            }\n+            GenericParamKind::Lifetime { .. } => {}\n             GenericParamKind::Type { ref default, .. } => {\n-                self.print_bounds(\":\", param.bounds);\n                 if let Some(default) = default {\n                     self.space();\n                     self.word_space(\"=\");"}, {"sha": "2e50dbff51089a9df7a52808e293bc115f198c27", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 23, "deletions": 44, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -2327,6 +2327,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => span,\n         };\n \n+        // type_param_span is (span, has_bounds)\n         let type_param_span = match (generics, bound_kind) {\n             (Some((_, ref generics, _)), GenericKind::Param(ref param)) => {\n                 // Account for the case where `param` corresponds to `Self`,\n@@ -2337,25 +2338,18 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                         // instead we suggest `T: 'a + 'b` in that case.\n-                        let id = hir.local_def_id_to_hir_id(def_id);\n-                        let mut has_bounds = false;\n-                        if let Node::GenericParam(param) = hir.get(id) {\n-                            has_bounds = !param.bounds.is_empty();\n-                        }\n-                        let sp = self.tcx.def_span(def_id);\n+                        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n+                        let ast_generics = self.tcx.hir().get_generics(hir_id.owner);\n+                        let bounds =\n+                            ast_generics.and_then(|g| g.bounds_span_for_suggestions(def_id));\n                         // `sp` only covers `T`, change it so that it covers\n                         // `T:` when appropriate\n-                        let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n-                        let sp = if has_bounds && !is_impl_trait {\n-                            sp.to(self\n-                                .tcx\n-                                .sess\n-                                .source_map()\n-                                .next_point(self.tcx.sess.source_map().next_point(sp)))\n+                        if let Some(span) = bounds {\n+                            (span, true)\n                         } else {\n-                            sp\n-                        };\n-                        (sp, has_bounds, is_impl_trait)\n+                            let sp = self.tcx.def_span(def_id);\n+                            (sp.shrink_to_hi(), false)\n+                        }\n                     })\n                 } else {\n                     None\n@@ -2411,52 +2405,37 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n         fn binding_suggestion<'tcx, S: fmt::Display>(\n             err: &mut Diagnostic,\n-            type_param_span: Option<(Span, bool, bool)>,\n+            type_param_span: Option<(Span, bool)>,\n             bound_kind: GenericKind<'tcx>,\n             sub: S,\n         ) {\n             let msg = \"consider adding an explicit lifetime bound\";\n-            if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n-                let suggestion = if is_impl_trait {\n-                    format!(\"{} + {}\", bound_kind, sub)\n-                } else {\n-                    let tail = if has_lifetimes { \" + \" } else { \"\" };\n-                    format!(\"{}: {}{}\", bound_kind, sub, tail)\n-                };\n-                err.span_suggestion(\n+            if let Some((sp, has_lifetimes)) = type_param_span {\n+                let suggestion =\n+                    if has_lifetimes { format!(\" + {}\", sub) } else { format!(\": {}\", sub) };\n+                err.span_suggestion_verbose(\n                     sp,\n                     &format!(\"{}...\", msg),\n                     suggestion,\n                     Applicability::MaybeIncorrect, // Issue #41966\n                 );\n             } else {\n-                let consider = format!(\n-                    \"{} {}...\",\n-                    msg,\n-                    if type_param_span.map_or(false, |(_, _, is_impl_trait)| is_impl_trait) {\n-                        format!(\" `{}` to `{}`\", sub, bound_kind)\n-                    } else {\n-                        format!(\"`{}: {}`\", bound_kind, sub)\n-                    },\n-                );\n+                let consider = format!(\"{} `{}: {}`...\", msg, bound_kind, sub,);\n                 err.help(&consider);\n             }\n         }\n \n         let new_binding_suggestion =\n-            |err: &mut Diagnostic,\n-             type_param_span: Option<(Span, bool, bool)>,\n-             bound_kind: GenericKind<'tcx>| {\n+            |err: &mut Diagnostic, type_param_span: Option<(Span, bool)>| {\n                 let msg = \"consider introducing an explicit lifetime bound\";\n-                if let Some((sp, has_lifetimes, is_impl_trait)) = type_param_span {\n-                    let suggestion = if is_impl_trait {\n-                        (sp.shrink_to_hi(), format!(\" + {}\", new_lt))\n+                if let Some((sp, has_lifetimes)) = type_param_span {\n+                    let suggestion = if has_lifetimes {\n+                        format!(\" + {}\", new_lt)\n                     } else {\n-                        let tail = if has_lifetimes { \" +\" } else { \"\" };\n-                        (sp, format!(\"{}: {}{}\", bound_kind, new_lt, tail))\n+                        format!(\": {}\", new_lt)\n                     };\n                     let mut sugg =\n-                        vec![suggestion, (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n+                        vec![(sp, suggestion), (span.shrink_to_hi(), format!(\" + {}\", new_lt))];\n                     if let Some(lt) = add_lt_sugg {\n                         sugg.push(lt);\n                         sugg.rotate_right(1);\n@@ -2615,7 +2594,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // suggest:\n                         // fn get_later<'a, G: 'a, T>(g: G, dest: &mut T) -> impl FnOnce() + '_ + 'a\n                         ty::Closure(_, _substs) | ty::Opaque(_, _substs) if return_impl_trait => {\n-                            new_binding_suggestion(&mut err, type_param_span, bound_kind);\n+                            new_binding_suggestion(&mut err, type_param_span);\n                         }\n                         _ => {\n                             binding_suggestion(&mut err, type_param_span, bound_kind, new_lt);"}, {"sha": "3564f15e210ad74efa7a99aa7dcf71fcbca60719", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 61, "deletions": 105, "changes": 166, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -1517,58 +1517,61 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n             // Bounds are respected for `type X = impl Trait`\n             return;\n         }\n-        let mut suggested_changing_assoc_types = false;\n         // There must not be a where clause\n-        if !type_alias_generics.predicates.is_empty() {\n-            cx.lint(\n-                TYPE_ALIAS_BOUNDS,\n-                |lint| {\n-                    let mut err = lint.build(\"where clauses are not enforced in type aliases\");\n-                    let spans: Vec<_> = type_alias_generics\n-                        .predicates\n-                        .iter()\n-                        .map(|pred| pred.span())\n-                        .collect();\n-                    err.set_span(spans);\n-                    err.span_suggestion(\n-                        type_alias_generics.span_for_predicates_or_empty_place(),\n-                        \"the clause will not be checked when the type alias is used, and should be removed\",\n-                        String::new(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    if !suggested_changing_assoc_types {\n-                        TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                        suggested_changing_assoc_types = true;\n-                    }\n-                    err.emit();\n-                },\n-            );\n+        if type_alias_generics.predicates.is_empty() {\n+            return;\n         }\n-        // The parameters must not have bounds\n-        for param in type_alias_generics.params.iter() {\n-            let spans: Vec<_> = param.bounds.iter().map(|b| b.span()).collect();\n-            let suggestion = spans\n-                .iter()\n-                .map(|sp| {\n-                    let start = param.span.between(*sp); // Include the `:` in `T: Bound`.\n-                    (start.to(*sp), String::new())\n-                })\n-                .collect();\n-            if !spans.is_empty() {\n-                cx.struct_span_lint(TYPE_ALIAS_BOUNDS, spans, |lint| {\n-                    let mut err =\n-                        lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n-                    let msg = \"the bound will not be checked when the type alias is used, \\\n-                                   and should be removed\";\n-                    err.multipart_suggestion(msg, suggestion, Applicability::MachineApplicable);\n-                    if !suggested_changing_assoc_types {\n-                        TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n-                        suggested_changing_assoc_types = true;\n-                    }\n-                    err.emit();\n-                });\n+\n+        let mut where_spans = Vec::new();\n+        let mut inline_spans = Vec::new();\n+        let mut inline_sugg = Vec::new();\n+        for p in type_alias_generics.predicates {\n+            let span = p.span();\n+            if p.in_where_clause() {\n+                where_spans.push(span);\n+            } else {\n+                for b in p.bounds() {\n+                    inline_spans.push(b.span());\n+                }\n+                inline_sugg.push((span, String::new()));\n             }\n         }\n+\n+        let mut suggested_changing_assoc_types = false;\n+        if !where_spans.is_empty() {\n+            cx.lint(TYPE_ALIAS_BOUNDS, |lint| {\n+                let mut err = lint.build(\"where clauses are not enforced in type aliases\");\n+                err.set_span(where_spans);\n+                err.span_suggestion(\n+                    type_alias_generics.where_clause_span,\n+                    \"the clause will not be checked when the type alias is used, and should be removed\",\n+                    String::new(),\n+                    Applicability::MachineApplicable,\n+                );\n+                if !suggested_changing_assoc_types {\n+                    TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                    suggested_changing_assoc_types = true;\n+                }\n+                err.emit();\n+            });\n+        }\n+\n+        if !inline_spans.is_empty() {\n+            cx.lint(TYPE_ALIAS_BOUNDS, |lint| {\n+                let mut err =\n+                    lint.build(\"bounds on generic parameters are not enforced in type aliases\");\n+                err.set_span(inline_spans);\n+                err.multipart_suggestion(\n+                    \"the bound will not be checked when the type alias is used, and should be removed\",\n+                    inline_sugg,\n+                    Applicability::MachineApplicable,\n+                );\n+                if !suggested_changing_assoc_types {\n+                    TypeAliasBounds::suggest_changing_assoc_types(ty, &mut err);\n+                }\n+                err.emit();\n+            });\n+        }\n     }\n }\n \n@@ -2084,27 +2087,6 @@ impl ExplicitOutlivesRequirements {\n             .collect()\n     }\n \n-    fn collect_outlived_lifetimes<'tcx>(\n-        &self,\n-        param: &'tcx hir::GenericParam<'tcx>,\n-        tcx: TyCtxt<'tcx>,\n-        inferred_outlives: &'tcx [(ty::Predicate<'tcx>, Span)],\n-        ty_generics: &'tcx ty::Generics,\n-    ) -> Vec<ty::Region<'tcx>> {\n-        let index =\n-            ty_generics.param_def_id_to_index[&tcx.hir().local_def_id(param.hir_id).to_def_id()];\n-\n-        match param.kind {\n-            hir::GenericParamKind::Lifetime { .. } => {\n-                Self::lifetimes_outliving_lifetime(inferred_outlives, index)\n-            }\n-            hir::GenericParamKind::Type { .. } => {\n-                Self::lifetimes_outliving_type(inferred_outlives, index)\n-            }\n-            hir::GenericParamKind::Const { .. } => Vec::new(),\n-        }\n-    }\n-\n     fn collect_outlives_bound_spans<'tcx>(\n         &self,\n         tcx: TyCtxt<'tcx>,\n@@ -2212,41 +2194,11 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n \n             let mut bound_count = 0;\n             let mut lint_spans = Vec::new();\n-\n-            for param in hir_generics.params {\n-                let has_lifetime_bounds = param\n-                    .bounds\n-                    .iter()\n-                    .any(|bound| matches!(bound, hir::GenericBound::Outlives(_)));\n-                if !has_lifetime_bounds {\n-                    continue;\n-                }\n-\n-                let relevant_lifetimes =\n-                    self.collect_outlived_lifetimes(param, cx.tcx, inferred_outlives, ty_generics);\n-                if relevant_lifetimes.is_empty() {\n-                    continue;\n-                }\n-\n-                let bound_spans = self.collect_outlives_bound_spans(\n-                    cx.tcx,\n-                    &param.bounds,\n-                    &relevant_lifetimes,\n-                    infer_static,\n-                );\n-                bound_count += bound_spans.len();\n-                lint_spans.extend(self.consolidate_outlives_bound_spans(\n-                    param.span.shrink_to_hi(),\n-                    &param.bounds,\n-                    bound_spans,\n-                ));\n-            }\n-\n             let mut where_lint_spans = Vec::new();\n             let mut dropped_predicate_count = 0;\n             let num_predicates = hir_generics.predicates.len();\n             for (i, where_predicate) in hir_generics.predicates.iter().enumerate() {\n-                let (relevant_lifetimes, bounds, span) = match where_predicate {\n+                let (relevant_lifetimes, bounds, span, in_where_clause) = match where_predicate {\n                     hir::WherePredicate::RegionPredicate(predicate) => {\n                         if let Some(Region::EarlyBound(index, ..)) =\n                             cx.tcx.named_region(predicate.lifetime.hir_id)\n@@ -2255,6 +2207,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                                 Self::lifetimes_outliving_lifetime(inferred_outlives, index),\n                                 &predicate.bounds,\n                                 predicate.span,\n+                                predicate.in_where_clause,\n                             )\n                         } else {\n                             continue;\n@@ -2273,6 +2226,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                                     Self::lifetimes_outliving_type(inferred_outlives, index),\n                                     &predicate.bounds,\n                                     predicate.span,\n+                                    predicate.in_where_clause,\n                                 )\n                             }\n                             _ => {\n@@ -2299,9 +2253,11 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                     dropped_predicate_count += 1;\n                 }\n \n-                // If all the bounds on a predicate were inferable and there are\n-                // further predicates, we want to eat the trailing comma.\n-                if drop_predicate && i + 1 < num_predicates {\n+                if drop_predicate && !in_where_clause {\n+                    lint_spans.push(span);\n+                } else if drop_predicate && i + 1 < num_predicates {\n+                    // If all the bounds on a predicate were inferable and there are\n+                    // further predicates, we want to eat the trailing comma.\n                     let next_predicate_span = hir_generics.predicates[i + 1].span();\n                     where_lint_spans.push(span.to(next_predicate_span.shrink_to_lo()));\n                 } else {\n@@ -2315,7 +2271,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n \n             // If all predicates are inferable, drop the entire clause\n             // (including the `where`)\n-            if num_predicates > 0 && dropped_predicate_count == num_predicates {\n+            if hir_generics.has_where_clause && dropped_predicate_count == num_predicates {\n                 let where_span = hir_generics\n                     .where_clause_span()\n                     .expect(\"span of (nonempty) where clause should exist\");\n@@ -2344,7 +2300,7 @@ impl<'tcx> LateLintPass<'tcx> for ExplicitOutlivesRequirements {\n                             },\n                             lint_spans\n                                 .into_iter()\n-                                .map(|span| (span, \"\".to_owned()))\n+                                .map(|span| (span, String::new()))\n                                 .collect::<Vec<_>>(),\n                             Applicability::MachineApplicable,\n                         )"}, {"sha": "aeeab677ae06b676ed6ba90b7f4dafed313414b4", "filename": "compiler/rustc_middle/src/ty/diagnostics.rs", "status": "modified", "additions": 95, "deletions": 239, "changes": 334, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fdiagnostics.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -11,7 +11,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticArgValue, IntoDiagnosticArg};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::{QPath, TyKind, WhereBoundPredicate, WherePredicate};\n+use rustc_hir::WherePredicate;\n use rustc_span::Span;\n \n impl<'tcx> IntoDiagnosticArg for Ty<'tcx> {\n@@ -156,10 +156,10 @@ pub fn suggest_arbitrary_trait_bound(\n         _ => {}\n     }\n     // Suggest a where clause bound for a non-type parameter.\n-    let (action, prefix) = if generics.predicates.is_empty() {\n-        (\"introducing a\", \" where \")\n-    } else {\n+    let (action, prefix) = if generics.has_where_clause {\n         (\"extending the\", \", \")\n+    } else {\n+        (\"introducing a\", \" where \")\n     };\n     err.span_suggestion_verbose(\n         generics.tail_span_for_predicate_suggestion(),\n@@ -183,95 +183,37 @@ enum SuggestChangingConstraintsMessage<'a> {\n }\n \n fn suggest_removing_unsized_bound(\n+    tcx: TyCtxt<'_>,\n     generics: &hir::Generics<'_>,\n     suggestions: &mut Vec<(Span, String, SuggestChangingConstraintsMessage<'_>)>,\n-    param_name: &str,\n     param: &hir::GenericParam<'_>,\n     def_id: Option<DefId>,\n ) {\n     // See if there's a `?Sized` bound that can be removed to suggest that.\n     // First look at the `where` clause because we can have `where T: ?Sized`,\n     // then look at params.\n+    let param_def_id = tcx.hir().local_def_id(param.hir_id);\n     for (where_pos, predicate) in generics.predicates.iter().enumerate() {\n-        match predicate {\n-            WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                bounded_ty:\n-                    hir::Ty {\n-                        kind:\n-                            hir::TyKind::Path(hir::QPath::Resolved(\n-                                None,\n-                                hir::Path {\n-                                    segments: [segment],\n-                                    res: hir::def::Res::Def(hir::def::DefKind::TyParam, _),\n-                                    ..\n-                                },\n-                            )),\n-                        ..\n-                    },\n-                bounds,\n-                span,\n-                ..\n-            }) if segment.ident.as_str() == param_name => {\n-                for (pos, bound) in bounds.iter().enumerate() {\n-                    match bound {\n-                        hir::GenericBound::Trait(poly, hir::TraitBoundModifier::Maybe)\n-                            if poly.trait_ref.trait_def_id() == def_id => {}\n-                        _ => continue,\n-                    }\n-                    let sp = match (bounds.len(), pos, generics.predicates.len(), where_pos) {\n-                        // where T: ?Sized\n-                        // ^^^^^^^^^^^^^^^\n-                        (1, _, 1, _) => generics.where_clause_span,\n-                        // where Foo: Bar, T: ?Sized,\n-                        //               ^^^^^^^^^^^\n-                        (1, _, len, pos) if pos == len - 1 => {\n-                            generics.predicates[pos - 1].span().shrink_to_hi().to(*span)\n-                        }\n-                        // where T: ?Sized, Foo: Bar,\n-                        //       ^^^^^^^^^^^\n-                        (1, _, _, pos) => span.until(generics.predicates[pos + 1].span()),\n-                        // where T: ?Sized + Bar, Foo: Bar,\n-                        //          ^^^^^^^^^\n-                        (_, 0, _, _) => bound.span().to(bounds[1].span().shrink_to_lo()),\n-                        // where T: Bar + ?Sized, Foo: Bar,\n-                        //             ^^^^^^^^^\n-                        (_, pos, _, _) => bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n-                    };\n+        let WherePredicate::BoundPredicate(predicate) = predicate else {\n+            continue;\n+        };\n+        if !predicate.is_param_bound(param_def_id.to_def_id()) {\n+            continue;\n+        };\n \n-                    suggestions.push((\n-                        sp,\n-                        String::new(),\n-                        SuggestChangingConstraintsMessage::RemovingQSized,\n-                    ));\n-                }\n+        for (pos, bound) in predicate.bounds.iter().enumerate() {\n+            let    hir::GenericBound::Trait(poly, hir::TraitBoundModifier::Maybe) = bound else {\n+                continue;\n+            };\n+            if poly.trait_ref.trait_def_id() != def_id {\n+                continue;\n             }\n-            _ => {}\n-        }\n-    }\n-    for (pos, bound) in param.bounds.iter().enumerate() {\n-        match bound {\n-            hir::GenericBound::Trait(poly, hir::TraitBoundModifier::Maybe)\n-                if poly.trait_ref.trait_def_id() == def_id =>\n-            {\n-                let sp = match (param.bounds.len(), pos) {\n-                    // T: ?Sized,\n-                    //  ^^^^^^^^\n-                    (1, _) => param.span.shrink_to_hi().to(bound.span()),\n-                    // T: ?Sized + Bar,\n-                    //    ^^^^^^^^^\n-                    (_, 0) => bound.span().to(param.bounds[1].span().shrink_to_lo()),\n-                    // T: Bar + ?Sized,\n-                    //       ^^^^^^^^^\n-                    (_, pos) => param.bounds[pos - 1].span().shrink_to_hi().to(bound.span()),\n-                };\n-\n-                suggestions.push((\n-                    sp,\n-                    String::new(),\n-                    SuggestChangingConstraintsMessage::RemovingQSized,\n-                ));\n-            }\n-            _ => {}\n+            let sp = generics.span_for_bound_removal(where_pos, pos);\n+            suggestions.push((\n+                sp,\n+                String::new(),\n+                SuggestChangingConstraintsMessage::RemovingQSized,\n+            ));\n         }\n     }\n }\n@@ -322,13 +264,7 @@ pub fn suggest_constraining_type_params<'a>(\n                     param.span,\n                     &format!(\"this type parameter needs to be `{}`\", constraint),\n                 );\n-                suggest_removing_unsized_bound(\n-                    generics,\n-                    &mut suggestions,\n-                    param_name,\n-                    param,\n-                    def_id,\n-                );\n+                suggest_removing_unsized_bound(tcx, generics, &mut suggestions, param, def_id);\n             }\n         }\n \n@@ -349,76 +285,45 @@ pub fn suggest_constraining_type_params<'a>(\n             ))\n         };\n \n-        if param_name.starts_with(\"impl \") {\n-            // If there's an `impl Trait` used in argument position, suggest\n-            // restricting it:\n-            //\n-            //   fn foo(t: impl Foo) { ... }\n-            //             --------\n-            //             |\n-            //             help: consider further restricting this bound with `+ Bar`\n-            //\n-            // Suggestion for tools in this case is:\n-            //\n-            //   fn foo(t: impl Foo) { ... }\n-            //             --------\n-            //             |\n-            //             replace with: `impl Foo + Bar`\n-\n-            // `impl Trait` must have at least one trait in the list\n-            let bound_list_non_empty = true;\n-\n-            suggest_restrict(param.span.shrink_to_hi(), bound_list_non_empty);\n+        // When the type parameter has been provided bounds\n+        //\n+        //    Message:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                            ^^^^^^\n+        //                            |\n+        //                            help: consider further restricting this bound with `+ Bar`\n+        //\n+        //    Suggestion:\n+        //      fn foo<T>(t: T) where T: Foo { ... }\n+        //                                  ^\n+        //                                  |\n+        //                                  replace with: ` + Bar`\n+        //\n+        // Or, if user has provided some bounds, suggest restricting them:\n+        //\n+        //   fn foo<T: Foo>(t: T) { ... }\n+        //             ---\n+        //             |\n+        //             help: consider further restricting this bound with `+ Bar`\n+        //\n+        // Suggestion for tools in this case is:\n+        //\n+        //   fn foo<T: Foo>(t: T) { ... }\n+        //          --\n+        //          |\n+        //          replace with: `T: Bar +`\n+        let param_def_id = tcx.hir().local_def_id(param.hir_id);\n+        if let Some(span) = generics.bounds_span_for_suggestions(param_def_id) {\n+            suggest_restrict(span, true);\n             continue;\n         }\n \n-        if generics.predicates.is_empty()\n-        // Given `trait Base<T = String>: Super<T>` where `T: Copy`, suggest restricting in the\n-        // `where` clause instead of `trait Base<T: Copy = String>: Super<T>`.\n-        && !matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-        {\n-            if let Some(span) = param.bounds_span_for_suggestions() {\n-                // If user has provided some bounds, suggest restricting them:\n-                //\n-                //   fn foo<T: Foo>(t: T) { ... }\n-                //             ---\n-                //             |\n-                //             help: consider further restricting this bound with `+ Bar`\n-                //\n-                // Suggestion for tools in this case is:\n-                //\n-                //   fn foo<T: Foo>(t: T) { ... }\n-                //          --\n-                //          |\n-                //          replace with: `T: Bar +`\n-\n-                // `bounds_span_for_suggestions` returns `None` if the list is empty\n-                let bound_list_non_empty = true;\n-\n-                suggest_restrict(span, bound_list_non_empty);\n-            } else {\n-                let (colon, span) = match param.colon_span_for_suggestions(tcx.sess.source_map()) {\n-                    // If there is already a colon after generic, do not suggest adding it again\n-                    Some(sp) => (\"\", sp.shrink_to_hi()),\n-                    None => (\":\", param.span.shrink_to_hi()),\n-                };\n-\n-                // If user hasn't provided any bounds, suggest adding a new one:\n-                //\n-                //   fn foo<T>(t: T) { ... }\n-                //          - help: consider restricting this type parameter with `T: Foo`\n-                suggestions.push((\n-                    span,\n-                    format!(\"{colon} {constraint}\"),\n-                    SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n-                ));\n-            }\n-        } else {\n+        if generics.has_where_clause {\n             // This part is a bit tricky, because using the `where` clause user can\n             // provide zero, one or many bounds for the same type parameter, so we\n             // have following cases to consider:\n             //\n-            // 1) When the type parameter has been provided zero bounds\n+            // When the type parameter has been provided zero bounds\n             //\n             //    Message:\n             //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n@@ -427,95 +332,46 @@ pub fn suggest_constraining_type_params<'a>(\n             //    Suggestion:\n             //      fn foo<X, Y>(x: X, y: Y) where Y: Foo { ... }\n             //                                           - insert: `, X: Bar`\n-            //\n-            //\n-            // 2) When the type parameter has been provided one bound\n-            //\n-            //    Message:\n-            //      fn foo<T>(t: T) where T: Foo { ... }\n-            //                            ^^^^^^\n-            //                            |\n-            //                            help: consider further restricting this bound with `+ Bar`\n-            //\n-            //    Suggestion:\n-            //      fn foo<T>(t: T) where T: Foo { ... }\n-            //                            ^^\n-            //                            |\n-            //                            replace with: `T: Bar +`\n-            //\n-            //\n-            // 3) When the type parameter has been provided many bounds\n-            //\n-            //    Message:\n-            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-            //             - help: consider further restricting this type parameter with `where T: Zar`\n-            //\n-            //    Suggestion:\n-            //      fn foo<T>(t: T) where T: Foo, T: Bar {... }\n-            //                                          - insert: `, T: Zar`\n-            //\n-            // Additionally, there may be no `where` clause whatsoever in the case that this was\n-            // reached because the generic parameter has a default:\n-            //\n-            //    Message:\n-            //      trait Foo<T=()> {... }\n-            //             - help: consider further restricting this type parameter with `where T: Zar`\n-            //\n-            //    Suggestion:\n-            //      trait Foo<T=()> where T: Zar {... }\n-            //                     - insert: `where T: Zar`\n-\n-            if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. })\n-                && generics.predicates.len() == 0\n-            {\n-                // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n-                // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n-                suggestions.push((\n-                    generics.tail_span_for_predicate_suggestion(),\n-                    format!(\" where {}: {}\", param_name, constraint),\n-                    SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n-                ));\n-            } else {\n-                let mut param_spans = Vec::new();\n-                let mut non_empty = false;\n-\n-                for predicate in generics.predicates {\n-                    if let WherePredicate::BoundPredicate(WhereBoundPredicate {\n-                        span,\n-                        bounded_ty,\n-                        bounds,\n-                        ..\n-                    }) = predicate\n-                    {\n-                        if let TyKind::Path(QPath::Resolved(_, path)) = &bounded_ty.kind {\n-                            if let Some(segment) = path.segments.first() {\n-                                if segment.ident.to_string() == param_name {\n-                                    non_empty = !bounds.is_empty();\n-\n-                                    param_spans.push(span);\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n+            suggestions.push((\n+                generics.tail_span_for_predicate_suggestion(),\n+                constraints\n+                    .iter()\n+                    .map(|&(constraint, _)| format!(\", {}: {}\", param_name, constraint))\n+                    .collect::<String>(),\n+                SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n+            ));\n+            continue;\n+        }\n \n-                match param_spans[..] {\n-                    [&param_span] => suggest_restrict(param_span.shrink_to_hi(), non_empty),\n-                    _ => {\n-                        suggestions.push((\n-                            generics.tail_span_for_predicate_suggestion(),\n-                            constraints\n-                                .iter()\n-                                .map(|&(constraint, _)| format!(\", {}: {}\", param_name, constraint))\n-                                .collect::<String>(),\n-                            SuggestChangingConstraintsMessage::RestrictTypeFurther {\n-                                ty: param_name,\n-                            },\n-                        ));\n-                    }\n-                }\n-            }\n+        // Additionally, there may be no `where` clause but the generic parameter has a default:\n+        //\n+        //    Message:\n+        //      trait Foo<T=()> {... }\n+        //                - help: consider further restricting this type parameter with `where T: Zar`\n+        //\n+        //    Suggestion:\n+        //      trait Foo<T=()> {... }\n+        //                     - insert: `where T: Zar`\n+        if matches!(param.kind, hir::GenericParamKind::Type { default: Some(_), .. }) {\n+            // Suggest a bound, but there is no existing `where` clause *and* the type param has a\n+            // default (`<T=Foo>`), so we suggest adding `where T: Bar`.\n+            suggestions.push((\n+                generics.tail_span_for_predicate_suggestion(),\n+                format!(\" where {}: {}\", param_name, constraint),\n+                SuggestChangingConstraintsMessage::RestrictTypeFurther { ty: param_name },\n+            ));\n+            continue;\n         }\n+\n+        // If user hasn't provided any bounds, suggest adding a new one:\n+        //\n+        //   fn foo<T>(t: T) { ... }\n+        //          - help: consider restricting this type parameter with `T: Foo`\n+        suggestions.push((\n+            param.span.shrink_to_hi(),\n+            format!(\": {}\", constraint),\n+            SuggestChangingConstraintsMessage::RestrictType { ty: param_name },\n+        ));\n     }\n \n     if suggestions.len() == 1 {"}, {"sha": "da0934b67c5df70d0c87e5245fad7957c0c586c2", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 15, "deletions": 44, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -602,53 +602,24 @@ impl<T> Trait<T> for X {\n                 } else {\n                     return false;\n                 };\n+                let Some(def_id) = def_id.as_local() else {\n+                    return false;\n+                };\n \n                 // First look in the `where` clause, as this might be\n                 // `fn foo<T>(x: T) where T: Trait`.\n-                for predicate in hir_generics.predicates {\n-                    if let hir::WherePredicate::BoundPredicate(pred) = predicate {\n-                        if let hir::TyKind::Path(hir::QPath::Resolved(None, path)) =\n-                            pred.bounded_ty.kind\n-                        {\n-                            if path.res.opt_def_id() == Some(def_id) {\n-                                // This predicate is binding type param `A` in `<A as T>::Foo` to\n-                                // something, potentially `T`.\n-                            } else {\n-                                continue;\n-                            }\n-                        } else {\n-                            continue;\n-                        }\n-\n-                        if self.constrain_generic_bound_associated_type_structured_suggestion(\n-                            diag,\n-                            &trait_ref,\n-                            pred.bounds,\n-                            &assoc,\n-                            assoc_substs,\n-                            ty,\n-                            msg,\n-                            false,\n-                        ) {\n-                            return true;\n-                        }\n-                    }\n-                }\n-                for param in hir_generics.params {\n-                    if self.hir().opt_local_def_id(param.hir_id).map(|id| id.to_def_id())\n-                        == Some(def_id)\n-                    {\n-                        // This is type param `A` in `<A as T>::Foo`.\n-                        return self.constrain_generic_bound_associated_type_structured_suggestion(\n-                            diag,\n-                            &trait_ref,\n-                            param.bounds,\n-                            &assoc,\n-                            assoc_substs,\n-                            ty,\n-                            msg,\n-                            false,\n-                        );\n+                for pred in hir_generics.bounds_for_param(def_id) {\n+                    if self.constrain_generic_bound_associated_type_structured_suggestion(\n+                        diag,\n+                        &trait_ref,\n+                        pred.bounds,\n+                        &assoc,\n+                        assoc_substs,\n+                        ty,\n+                        msg,\n+                        false,\n+                    ) {\n+                        return true;\n                     }\n                 }\n             }"}, {"sha": "619e0d0341f07c0ca65cf99ce898712cc1f3b1fa", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -1585,11 +1585,6 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_generics(&mut self, generics: &'tcx hir::Generics<'tcx>) {\n-        for param in generics.params {\n-            for bound in param.bounds {\n-                self.check_generic_bound(bound);\n-            }\n-        }\n         for predicate in generics.predicates {\n             match predicate {\n                 hir::WherePredicate::BoundPredicate(bound_pred) => {"}, {"sha": "787536d2a38ed04ecf40649f7dbcb809f1ef0bc6", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 26, "deletions": 60, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -1328,13 +1328,11 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 match param.kind {\n                     GenericParamKind::Lifetime { .. } => {}\n                     GenericParamKind::Type { ref default, .. } => {\n-                        walk_list!(this, visit_param_bound, param.bounds);\n                         if let Some(ref ty) = default {\n                             this.visit_ty(&ty);\n                         }\n                     }\n                     GenericParamKind::Const { ref ty, default } => {\n-                        walk_list!(this, visit_param_bound, param.bounds);\n                         this.visit_ty(&ty);\n                         if let Some(default) = default {\n                             this.visit_body(this.tcx.hir().body(default.body));\n@@ -1393,6 +1391,32 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }) => {\n                         this.visit_lifetime(lifetime);\n                         walk_list!(this, visit_param_bound, bounds);\n+\n+                        if lifetime.name != hir::LifetimeName::Static {\n+                            for bound in bounds {\n+                                let hir::GenericBound::Outlives(ref lt) = bound else {\n+                                    continue;\n+                                };\n+                                if lt.name != hir::LifetimeName::Static {\n+                                    continue;\n+                                }\n+                                this.insert_lifetime(lt, Region::Static);\n+                                this.tcx\n+                                    .sess\n+                                    .struct_span_warn(\n+                                        lifetime.span,\n+                                        &format!(\n+                                            \"unnecessary lifetime parameter `{}`\",\n+                                            lifetime.name.ident(),\n+                                        ),\n+                                    )\n+                                    .help(&format!(\n+                                        \"you can use the `'static` lifetime directly, in place of `{}`\",\n+                                        lifetime.name.ident(),\n+                                    ))\n+                                    .emit();\n+                            }\n+                        }\n                     }\n                     &hir::WherePredicate::EqPredicate(hir::WhereEqPredicate {\n                         ref lhs_ty,\n@@ -1714,8 +1738,6 @@ fn object_lifetime_defaults_for_item<'tcx>(\n         GenericParamKind::Type { .. } => {\n             let mut set = Set1::Empty;\n \n-            add_bounds(&mut set, &param.bounds);\n-\n             let param_def_id = tcx.hir().local_def_id(param.hir_id);\n             for predicate in generics.predicates {\n                 // Look for `type: ...` where clauses.\n@@ -3124,50 +3146,6 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             // It is a soft error to shadow a lifetime within a parent scope.\n             self.check_lifetime_param_for_shadowing(old_scope, &lifetime_i);\n-\n-            for bound in lifetime_i.bounds {\n-                match bound {\n-                    hir::GenericBound::Outlives(ref lt) => match lt.name {\n-                        hir::LifetimeName::Underscore => {\n-                            self.tcx.sess.delay_span_bug(\n-                                lt.span,\n-                                \"use of `'_` in illegal place, but not caught by lowering\",\n-                            );\n-                        }\n-                        hir::LifetimeName::Static => {\n-                            self.insert_lifetime(lt, Region::Static);\n-                            self.tcx\n-                                .sess\n-                                .struct_span_warn(\n-                                    lifetime_i.span.to(lt.span),\n-                                    &format!(\n-                                        \"unnecessary lifetime parameter `{}`\",\n-                                        lifetime_i.name.ident(),\n-                                    ),\n-                                )\n-                                .help(&format!(\n-                                    \"you can use the `'static` lifetime directly, in place of `{}`\",\n-                                    lifetime_i.name.ident(),\n-                                ))\n-                                .emit();\n-                        }\n-                        hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n-                            self.resolve_lifetime_ref(lt);\n-                        }\n-                        hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n-                            self.tcx.sess.delay_span_bug(\n-                                lt.span,\n-                                \"lowering generated `ImplicitObjectLifetimeDefault` \\\n-                                 outside of an object type\",\n-                            );\n-                        }\n-                        hir::LifetimeName::Error => {\n-                            // No need to do anything, error already reported.\n-                        }\n-                    },\n-                    _ => bug!(),\n-                }\n-            }\n         }\n     }\n \n@@ -3326,18 +3304,6 @@ fn insert_late_bound_lifetimes(\n     // ignore binders here and scrape up all names we see.\n     let mut appears_in_where_clause = AllCollector::default();\n     appears_in_where_clause.visit_generics(generics);\n-\n-    for param in generics.params {\n-        if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-            if !param.bounds.is_empty() {\n-                // `'a: 'b` means both `'a` and `'b` are referenced\n-                appears_in_where_clause\n-                    .regions\n-                    .insert(hir::LifetimeName::Param(param.name.normalize_to_macros_2_0()));\n-            }\n-        }\n-    }\n-\n     debug!(?appears_in_where_clause.regions);\n \n     // Late bound regions are those that:"}, {"sha": "b4230a144f813384d5bbf018f2951f94379167ac", "filename": "compiler/rustc_save_analysis/src/dump_visitor.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fdump_visitor.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -1267,13 +1267,11 @@ impl<'tcx> Visitor<'tcx> for DumpVisitor<'tcx> {\n             match param.kind {\n                 hir::GenericParamKind::Lifetime { .. } => {}\n                 hir::GenericParamKind::Type { ref default, .. } => {\n-                    self.process_bounds(param.bounds);\n                     if let Some(ref ty) = default {\n                         self.visit_ty(ty);\n                     }\n                 }\n                 hir::GenericParamKind::Const { ref ty, ref default } => {\n-                    self.process_bounds(param.bounds);\n                     self.visit_ty(ty);\n                     if let Some(default) = default {\n                         self.visit_anon_const(default);"}, {"sha": "d1286c9b8b0dfeb083a4e2585f57aa3d4d8eb1a5", "filename": "compiler/rustc_save_analysis/src/sig.rs", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_save_analysis%2Fsrc%2Fsig.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -630,31 +630,6 @@ impl<'hir> Sig for hir::Generics<'hir> {\n                     param_text.push_str(&id_to_string(&scx.tcx.hir(), default.hir_id));\n                 }\n             }\n-            if !param.bounds.is_empty() {\n-                param_text.push_str(\": \");\n-                match param.kind {\n-                    hir::GenericParamKind::Lifetime { .. } => {\n-                        let bounds = param\n-                            .bounds\n-                            .iter()\n-                            .map(|bound| match bound {\n-                                hir::GenericBound::Outlives(lt) => lt.name.ident().to_string(),\n-                                _ => panic!(),\n-                            })\n-                            .collect::<Vec<_>>()\n-                            .join(\" + \");\n-                        param_text.push_str(&bounds);\n-                        // FIXME add lifetime bounds refs.\n-                    }\n-                    hir::GenericParamKind::Type { .. } => {\n-                        param_text.push_str(&bounds_to_string(param.bounds));\n-                        // FIXME descend properly into bounds.\n-                    }\n-                    hir::GenericParamKind::Const { .. } => {\n-                        // Const generics cannot contain bounds.\n-                    }\n-                }\n-            }\n             text.push_str(&param_text);\n             text.push(',');\n         }"}, {"sha": "7a3579eb1cc853193bbda3e3ecdb74c3c5d65cf6", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -2420,25 +2420,14 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n         let sized_trait = self.tcx.lang_items().sized_trait();\n         debug!(\"maybe_suggest_unsized_generics: generics.params={:?}\", generics.params);\n         debug!(\"maybe_suggest_unsized_generics: generics.predicates={:?}\", generics.predicates);\n-        let param = generics.params.iter().filter(|param| param.span == span).find(|param| {\n-            // Check that none of the explicit trait bounds is `Sized`. Assume that an explicit\n-            // `Sized` bound is there intentionally and we don't need to suggest relaxing it.\n-            param\n-                .bounds\n-                .iter()\n-                .all(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) != sized_trait)\n-        });\n-        let Some(param) = param else {\n+        let Some(param) = generics.params.iter().find(|param| param.span == span) else {\n             return;\n         };\n-        let param_def_id = self.tcx.hir().local_def_id(param.hir_id).to_def_id();\n-        let preds = generics.predicates.iter();\n-        let explicitly_sized = preds\n-            .filter_map(|pred| match pred {\n-                hir::WherePredicate::BoundPredicate(bp) => Some(bp),\n-                _ => None,\n-            })\n-            .filter(|bp| bp.is_param_bound(param_def_id))\n+        let param_def_id = self.tcx.hir().local_def_id(param.hir_id);\n+        // Check that none of the explicit trait bounds is `Sized`. Assume that an explicit\n+        // `Sized` bound is there intentionally and we don't need to suggest relaxing it.\n+        let explicitly_sized = generics\n+            .bounds_for_param(param_def_id)\n             .flat_map(|bp| bp.bounds)\n             .any(|bound| bound.trait_ref().and_then(|tr| tr.trait_def_id()) == sized_trait);\n         if explicitly_sized {\n@@ -2461,9 +2450,11 @@ impl<'a, 'tcx> InferCtxtPrivExt<'a, 'tcx> for InferCtxt<'a, 'tcx> {\n             _ => {}\n         };\n         // Didn't add an indirection suggestion, so add a general suggestion to relax `Sized`.\n-        let (span, separator) = match param.bounds {\n-            [] => (span.shrink_to_hi(), \":\"),\n-            [.., bound] => (bound.span().shrink_to_hi(), \" +\"),\n+        let (span, separator) = if let Some(s) = generics.bounds_span_for_suggestions(param_def_id)\n+        {\n+            (s, \" +\")\n+        } else {\n+            (span.shrink_to_hi(), \":\")\n         };\n         err.span_suggestion_verbose(\n             span,"}, {"sha": "446b14a17ae92ff268e276cbb5238a98d99e4323", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -320,7 +320,7 @@ pub trait InferCtxtExt<'tcx> {\n fn predicate_constraint(generics: &hir::Generics<'_>, pred: String) -> (Span, String) {\n     (\n         generics.tail_span_for_predicate_suggestion(),\n-        format!(\"{} {}\", if !generics.predicates.is_empty() { \",\" } else { \" where\" }, pred,),\n+        format!(\"{} {}\", if generics.has_where_clause { \",\" } else { \" where\" }, pred,),\n     )\n }\n \n@@ -392,21 +392,10 @@ fn suggest_restriction<'tcx>(\n         let pred = trait_pred.to_predicate(tcx).to_string();\n         let pred = pred.replace(&impl_trait_str, &type_param_name);\n         let mut sugg = vec![\n-            // Find the last of the generic parameters contained within the span of\n-            // the generics\n-            match generics\n-                .params\n-                .iter()\n-                .map(|p| p.bounds_span_for_suggestions().unwrap_or(p.span.shrink_to_hi()))\n-                .filter(|&span| generics.span.contains(span) && span.can_be_used_for_suggestions())\n-                .max_by_key(|span| span.hi())\n-            {\n-                // `fn foo(t: impl Trait)`\n-                //        ^ suggest `<T: Trait>` here\n-                None => (generics.span, format!(\"<{}>\", type_param)),\n-                // `fn foo<A>(t: impl Trait)`\n-                //        ^^^ suggest `<A, T: Trait>` here\n-                Some(span) => (span, format!(\", {}\", type_param)),\n+            if let Some(span) = generics.span_for_param_suggestion() {\n+                (span, format!(\", {}\", type_param))\n+            } else {\n+                (generics.span, format!(\"<{}>\", type_param))\n             },\n             // `fn foo(t: impl Trait)`\n             //                       ^ suggest `where <T as Trait>::A: Bound`"}, {"sha": "b8422ce3208f136b18b458c011a5f4e9e3f080df", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -924,14 +924,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             let self_ty_def_id = tcx.hir().local_def_id(self_ty).to_def_id();\n             for clause in where_clause {\n                 if let hir::WherePredicate::BoundPredicate(pred) = clause {\n-                    match pred.bounded_ty.kind {\n-                        hir::TyKind::Path(hir::QPath::Resolved(_, path)) => match path.res {\n-                            Res::Def(DefKind::TyParam, def_id) if def_id == self_ty_def_id => {}\n-                            _ => continue,\n-                        },\n-                        _ => continue,\n+                    if pred.is_param_bound(self_ty_def_id) {\n+                        search_bounds(pred.bounds);\n                     }\n-                    search_bounds(pred.bounds);\n                 }\n             }\n         }\n@@ -2389,7 +2384,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     bf.unsafety,\n                     bf.abi,\n                     bf.decl,\n-                    &hir::Generics::empty(),\n                     None,\n                     Some(ast_ty),\n                 ))\n@@ -2551,8 +2545,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n         decl: &hir::FnDecl<'_>,\n-        generics: &hir::Generics<'_>,\n-        ident_span: Option<Span>,\n+        generics: Option<&hir::Generics<'_>>,\n         hir_ty: Option<&hir::Ty<'_>>,\n     ) -> ty::PolyFnSig<'tcx> {\n         debug!(\"ty_of_fn\");\n@@ -2565,7 +2558,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let mut visitor = HirPlaceholderCollector::default();\n         let mut infer_replacements = vec![];\n \n-        walk_generics(&mut visitor, generics);\n+        if let Some(generics) = generics {\n+            walk_generics(&mut visitor, generics);\n+        }\n \n         let input_tys: Vec<_> = decl\n             .inputs\n@@ -2617,8 +2612,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             let mut diag = crate::collect::placeholder_type_error_diag(\n                 tcx,\n-                ident_span.map(|sp| sp.shrink_to_hi()),\n-                generics.params,\n+                generics,\n                 visitor.0,\n                 infer_replacements.iter().map(|(s, _)| *s).collect(),\n                 true,"}, {"sha": "6d78a863d54cf97bdf0911899899684441f1e1d7", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -804,7 +804,8 @@ fn compare_synthetic_generics<'tcx>(\n         iter::zip(impl_m_type_params, trait_m_type_params)\n     {\n         if impl_synthetic != trait_synthetic {\n-            let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_def_id.expect_local());\n+            let impl_def_id = impl_def_id.expect_local();\n+            let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_def_id);\n             let impl_span = tcx.hir().span(impl_hir_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(\n@@ -868,14 +869,14 @@ fn compare_synthetic_generics<'tcx>(\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n                             _ => unreachable!(),\n                         };\n-                        struct Visitor(Option<Span>, hir::def_id::DefId);\n+                        struct Visitor(Option<Span>, hir::def_id::LocalDefId);\n                         impl<'v> intravisit::Visitor<'v> for Visitor {\n                             fn visit_ty(&mut self, ty: &'v hir::Ty<'v>) {\n                                 intravisit::walk_ty(self, ty);\n                                 if let hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) =\n                                     ty.kind\n                                     && let Res::Def(DefKind::TyParam, def_id) = path.res\n-                                    && def_id == self.1\n+                                    && def_id == self.1.to_def_id()\n                                 {\n                                     self.0 = Some(ty.span);\n                                 }\n@@ -887,17 +888,7 @@ fn compare_synthetic_generics<'tcx>(\n                         }\n                         let span = visitor.0?;\n \n-                        let bounds =\n-                            impl_m.generics.params.iter().find_map(|param| match param.kind {\n-                                GenericParamKind::Lifetime { .. } => None,\n-                                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n-                                    if param.hir_id == impl_hir_id {\n-                                        Some(&param.bounds)\n-                                    } else {\n-                                        None\n-                                    }\n-                                }\n-                            })?;\n+                        let bounds = impl_m.generics.bounds_for_param(impl_def_id).next()?.bounds;\n                         let bounds = bounds.first()?.span().to(bounds.last()?.span());\n                         let bounds = tcx.sess.source_map().span_to_snippet(bounds).ok()?;\n "}, {"sha": "681d1e37f86f1317486616e91aa7b887a29f7ca8", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/suggestions.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fsuggestions.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -605,7 +605,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             ..\n         })) = fn_node else { return };\n \n-        let Some(expected_generic_param) = params.get(expected_ty_as_param.index as usize) else { return };\n+        if params.get(expected_ty_as_param.index as usize).is_none() {\n+            return;\n+        };\n \n         // get all where BoundPredicates here, because they are used in to cases below\n         let where_predicates = predicates\n@@ -639,10 +641,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             where_predicates.iter().flatten().flat_map(|bounds| bounds.iter());\n \n         // extract all bounds from the source code using their spans\n-        let all_matching_bounds_strs = expected_generic_param\n-            .bounds\n-            .iter()\n-            .chain(predicates_from_where)\n+        let all_matching_bounds_strs = predicates_from_where\n             .filter_map(|bound| match bound {\n                 GenericBound::Trait(_, _) => {\n                     self.tcx.sess.source_map().span_to_snippet(bound.span()).ok()"}, {"sha": "e931dadbee7184b4f112f6f428599d2c5660aae6", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -1868,37 +1868,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // instead we suggest `T: Foo + Bar` in that case.\n                     match hir.get(id) {\n                         Node::GenericParam(param) => {\n-                            let mut impl_trait = false;\n-                            let has_bounds =\n-                                if let hir::GenericParamKind::Type { synthetic: true, .. } =\n-                                    &param.kind\n-                                {\n-                                    // We've found `fn foo(x: impl Trait)` instead of\n-                                    // `fn foo<T>(x: T)`. We want to suggest the correct\n-                                    // `fn foo(x: impl Trait + TraitBound)` instead of\n-                                    // `fn foo<T: TraitBound>(x: T)`. (#63706)\n-                                    impl_trait = true;\n-                                    param.bounds.get(1)\n-                                } else {\n-                                    param.bounds.get(0)\n-                                };\n-                            let sp = hir.span(id);\n-                            let sp = if let Some(first_bound) = has_bounds {\n-                                sp.until(first_bound.span())\n-                            } else if let Some(colon_sp) =\n-                                // If the generic param is declared with a colon but without bounds:\n-                                // fn foo<T:>(t: T) { ... }\n-                                param.colon_span_for_suggestions(\n-                                    self.inh.tcx.sess.source_map(),\n-                                )\n+                            let impl_trait = matches!(\n+                                param.kind,\n+                                hir::GenericParamKind::Type { synthetic: true, .. },\n+                            );\n+                            let ast_generics = hir.get_generics(id.owner).unwrap();\n+                            let (sp, has_bounds) = if let Some(span) =\n+                                ast_generics.bounds_span_for_suggestions(def_id)\n                             {\n-                                sp.to(colon_sp)\n+                                (span, true)\n                             } else {\n-                                sp\n+                                (hir.span(id).shrink_to_hi(), false)\n                             };\n-                            let trait_def_ids: FxHashSet<DefId> = param\n-                                .bounds\n-                                .iter()\n+                            let trait_def_ids: FxHashSet<DefId> = ast_generics\n+                                .bounds_for_param(def_id)\n+                                .flat_map(|bp| bp.bounds.iter())\n                                 .filter_map(|bound| bound.trait_ref()?.trait_def_id())\n                                 .collect();\n                             if !candidates.iter().any(|t| trait_def_ids.contains(&t.def_id)) {\n@@ -1910,11 +1894,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                     )),\n                                     candidates.iter().map(|t| {\n                                         format!(\n-                                            \"{}{} {}{}\",\n-                                            param.name.ident(),\n-                                            if impl_trait { \" +\" } else { \":\" },\n+                                            \"{} {}\",\n+                                            if has_bounds || impl_trait { \" +\" } else { \":\" },\n                                             self.tcx.def_path_str(t.def_id),\n-                                            if has_bounds.is_some() { \" + \" } else { \"\" },\n                                         )\n                                     }),\n                                     Applicability::MaybeIncorrect,"}, {"sha": "76c955d6f690d672319217ce765caf9cf3ae6206", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -373,16 +373,7 @@ fn typeck_with_fallback<'tcx>(\n         let (fcx, wf_tys) = if let Some(hir::FnSig { header, decl, .. }) = fn_sig {\n             let fn_sig = if crate::collect::get_infer_ret_ty(&decl.output).is_some() {\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n-                <dyn AstConv<'_>>::ty_of_fn(\n-                    &fcx,\n-                    id,\n-                    header.unsafety,\n-                    header.abi,\n-                    decl,\n-                    &hir::Generics::empty(),\n-                    None,\n-                    None,\n-                )\n+                <dyn AstConv<'_>>::ty_of_fn(&fcx, id, header.unsafety, header.abi, decl, None, None)\n             } else {\n                 tcx.fn_sig(def_id)\n             };"}, {"sha": "ec2b7c13ff33c5325ae7ddeed69ab67ae8eaea8e", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -1755,8 +1755,7 @@ fn check_variances_for_type_defn<'tcx>(\n         match param.name {\n             hir::ParamName::Error => {}\n             _ => {\n-                let has_explicit_bounds =\n-                    !param.bounds.is_empty() || explicitly_bounded_params.contains(&parameter);\n+                let has_explicit_bounds = explicitly_bounded_params.contains(&parameter);\n                 report_bivariance(tcx, param, has_explicit_bounds);\n             }\n         }"}, {"sha": "f85735ec57bf7ab43a999d8a7ca81b1fdc312561", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 42, "deletions": 123, "changes": 165, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -1,4 +1,3 @@\n-// ignore-tidy-filelength\n //! \"Collection\" is the process of determining the type and other external\n //! details of each item in Rust. Collection is specifically concerned\n //! with *inter-procedural* things -- for example, for a function\n@@ -149,8 +148,7 @@ struct CollectItemTypesVisitor<'tcx> {\n /// all already existing generic type parameters to avoid suggesting a name that is already in use.\n crate fn placeholder_type_error<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    span: Option<Span>,\n-    generics: &[hir::GenericParam<'_>],\n+    generics: Option<&hir::Generics<'_>>,\n     placeholder_types: Vec<Span>,\n     suggest: bool,\n     hir_ty: Option<&hir::Ty<'_>>,\n@@ -160,23 +158,13 @@ crate fn placeholder_type_error<'tcx>(\n         return;\n     }\n \n-    placeholder_type_error_diag(\n-        tcx,\n-        span,\n-        generics,\n-        placeholder_types,\n-        vec![],\n-        suggest,\n-        hir_ty,\n-        kind,\n-    )\n-    .emit();\n+    placeholder_type_error_diag(tcx, generics, placeholder_types, vec![], suggest, hir_ty, kind)\n+        .emit();\n }\n \n crate fn placeholder_type_error_diag<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    span: Option<Span>,\n-    generics: &[hir::GenericParam<'_>],\n+    generics: Option<&hir::Generics<'_>>,\n     placeholder_types: Vec<Span>,\n     additional_spans: Vec<Span>,\n     suggest: bool,\n@@ -187,26 +175,24 @@ crate fn placeholder_type_error_diag<'tcx>(\n         return bad_placeholder(tcx, additional_spans, kind);\n     }\n \n-    let type_name = generics.next_type_param_name(None);\n+    let params = generics.map(|g| g.params).unwrap_or_default();\n+    let type_name = params.next_type_param_name(None);\n     let mut sugg: Vec<_> =\n         placeholder_types.iter().map(|sp| (*sp, (*type_name).to_string())).collect();\n \n-    if generics.is_empty() {\n-        if let Some(span) = span {\n-            sugg.push((span, format!(\"<{}>\", type_name)));\n+    if let Some(generics) = generics {\n+        if let Some(arg) = params.iter().find(|arg| {\n+            matches!(arg.name, hir::ParamName::Plain(Ident { name: kw::Underscore, .. }))\n+        }) {\n+            // Account for `_` already present in cases like `struct S<_>(_);` and suggest\n+            // `struct S<T>(T);` instead of `struct S<_, T>(T);`.\n+            sugg.push((arg.span, (*type_name).to_string()));\n+        } else if let Some(span) = generics.span_for_param_suggestion() {\n+            // Account for bounds, we want `fn foo<T: E, K>(_: K)` not `fn foo<T, K: E>(_: K)`.\n+            sugg.push((span, format!(\", {}\", type_name)));\n+        } else {\n+            sugg.push((generics.span, format!(\"<{}>\", type_name)));\n         }\n-    } else if let Some(arg) = generics\n-        .iter()\n-        .find(|arg| matches!(arg.name, hir::ParamName::Plain(Ident { name: kw::Underscore, .. })))\n-    {\n-        // Account for `_` already present in cases like `struct S<_>(_);` and suggest\n-        // `struct S<T>(T);` instead of `struct S<_, T>(T);`.\n-        sugg.push((arg.span, (*type_name).to_string()));\n-    } else {\n-        let last = generics.iter().last().unwrap();\n-        // Account for bounds, we want `fn foo<T: E, K>(_: K)` not `fn foo<T, K: E>(_: K)`.\n-        let span = last.bounds_span_for_suggestions().unwrap_or(last.span.shrink_to_hi());\n-        sugg.push((span, format!(\", {}\", type_name)));\n     }\n \n     let mut err =\n@@ -270,15 +256,7 @@ fn reject_placeholder_type_signatures_in_item<'tcx>(\n     let mut visitor = HirPlaceholderCollector::default();\n     visitor.visit_item(item);\n \n-    placeholder_type_error(\n-        tcx,\n-        Some(generics.span),\n-        generics.params,\n-        visitor.0,\n-        suggest,\n-        None,\n-        item.kind.descr(),\n-    );\n+    placeholder_type_error(tcx, Some(generics), visitor.0, suggest, None, item.kind.descr());\n }\n \n impl<'tcx> Visitor<'tcx> for CollectItemTypesVisitor<'tcx> {\n@@ -680,26 +658,8 @@ impl<'tcx> ItemCtxt<'tcx> {\n         only_self_bounds: OnlySelfBounds,\n         assoc_name: Option<Ident>,\n     ) -> Vec<(ty::Predicate<'tcx>, Span)> {\n-        let from_ty_params = ast_generics\n-            .params\n-            .iter()\n-            .filter_map(|param| match param.kind {\n-                GenericParamKind::Type { .. } | GenericParamKind::Const { .. }\n-                    if param.hir_id == param_id =>\n-                {\n-                    Some(&param.bounds)\n-                }\n-                _ => None,\n-            })\n-            .flat_map(|bounds| bounds.iter())\n-            .filter(|b| match assoc_name {\n-                Some(assoc_name) => self.bound_defines_assoc_item(b, assoc_name),\n-                None => true,\n-            })\n-            .flat_map(|b| predicates_from_bound(self, ty, b, ty::List::empty()));\n-\n         let param_def_id = self.tcx.hir().local_def_id(param_id).to_def_id();\n-        let from_where_clauses = ast_generics\n+        ast_generics\n             .predicates\n             .iter()\n             .filter_map(|wp| match *wp {\n@@ -724,9 +684,8 @@ impl<'tcx> ItemCtxt<'tcx> {\n                     })\n                     .filter_map(move |b| bt.map(|bt| (bt, b, bvars)))\n             })\n-            .flat_map(|(bt, b, bvars)| predicates_from_bound(self, bt, b, bvars));\n-\n-        from_ty_params.chain(from_where_clauses).collect()\n+            .flat_map(|(bt, b, bvars)| predicates_from_bound(self, bt, b, bvars))\n+            .collect()\n     }\n \n     fn bound_defines_assoc_item(&self, b: &hir::GenericBound<'_>, assoc_name: Ident) -> bool {\n@@ -772,7 +731,6 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                         placeholder_type_error(\n                             tcx,\n                             None,\n-                            &[],\n                             visitor.0,\n                             false,\n                             None,\n@@ -852,15 +810,7 @@ fn convert_item(tcx: TyCtxt<'_>, item_id: hir::ItemId) {\n                     if let hir::TyKind::TraitObject(..) = ty.kind {\n                         let mut visitor = HirPlaceholderCollector::default();\n                         visitor.visit_item(it);\n-                        placeholder_type_error(\n-                            tcx,\n-                            None,\n-                            &[],\n-                            visitor.0,\n-                            false,\n-                            None,\n-                            it.kind.descr(),\n-                        );\n+                        placeholder_type_error(tcx, None, visitor.0, false, None, it.kind.descr());\n                     }\n                 }\n                 _ => (),\n@@ -888,7 +838,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n             // Account for `const C: _;`.\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"constant\");\n+            placeholder_type_error(tcx, None, visitor.0, false, None, \"constant\");\n         }\n \n         hir::TraitItemKind::Type(_, Some(_)) => {\n@@ -897,7 +847,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n             // Account for `type T = _;`.\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n-            placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n+            placeholder_type_error(tcx, None, visitor.0, false, None, \"associated type\");\n         }\n \n         hir::TraitItemKind::Type(_, None) => {\n@@ -907,7 +857,7 @@ fn convert_trait_item(tcx: TyCtxt<'_>, trait_item_id: hir::TraitItemId) {\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_trait_item(trait_item);\n \n-            placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n+            placeholder_type_error(tcx, None, visitor.0, false, None, \"associated type\");\n         }\n     };\n \n@@ -929,7 +879,7 @@ fn convert_impl_item(tcx: TyCtxt<'_>, impl_item_id: hir::ImplItemId) {\n             let mut visitor = HirPlaceholderCollector::default();\n             visitor.visit_impl_item(impl_item);\n \n-            placeholder_type_error(tcx, None, &[], visitor.0, false, None, \"associated type\");\n+            placeholder_type_error(tcx, None, visitor.0, false, None, \"associated type\");\n         }\n         hir::ImplItemKind::Const(..) => {}\n     }\n@@ -1892,15 +1842,14 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     match tcx.hir().get(hir_id) {\n         TraitItem(hir::TraitItem {\n             kind: TraitItemKind::Fn(sig, TraitFn::Provided(_)),\n-            ident,\n             generics,\n             ..\n         })\n-        | Item(hir::Item { kind: ItemKind::Fn(sig, generics, _), ident, .. }) => {\n-            infer_return_ty_for_fn_sig(tcx, sig, *ident, generics, def_id, &icx)\n+        | Item(hir::Item { kind: ItemKind::Fn(sig, generics, _), .. }) => {\n+            infer_return_ty_for_fn_sig(tcx, sig, generics, def_id, &icx)\n         }\n \n-        ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), ident, generics, .. }) => {\n+        ImplItem(hir::ImplItem { kind: ImplItemKind::Fn(sig, _), generics, .. }) => {\n             // Do not try to inference the return type for a impl method coming from a trait\n             if let Item(hir::Item { kind: ItemKind::Impl(i), .. }) =\n                 tcx.hir().get(tcx.hir().get_parent_node(hir_id))\n@@ -1912,18 +1861,16 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                     sig.header.unsafety,\n                     sig.header.abi,\n                     sig.decl,\n-                    generics,\n-                    Some(ident.span),\n+                    Some(generics),\n                     None,\n                 )\n             } else {\n-                infer_return_ty_for_fn_sig(tcx, sig, *ident, generics, def_id, &icx)\n+                infer_return_ty_for_fn_sig(tcx, sig, generics, def_id, &icx)\n             }\n         }\n \n         TraitItem(hir::TraitItem {\n             kind: TraitItemKind::Fn(FnSig { header, decl, span: _ }, _),\n-            ident,\n             generics,\n             ..\n         }) => <dyn AstConv<'_>>::ty_of_fn(\n@@ -1932,16 +1879,13 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             header.unsafety,\n             header.abi,\n             decl,\n-            generics,\n-            Some(ident.span),\n+            Some(generics),\n             None,\n         ),\n \n-        ForeignItem(&hir::ForeignItem {\n-            kind: ForeignItemKind::Fn(fn_decl, _, _), ident, ..\n-        }) => {\n+        ForeignItem(&hir::ForeignItem { kind: ForeignItemKind::Fn(fn_decl, _, _), .. }) => {\n             let abi = tcx.hir().get_foreign_abi(hir_id);\n-            compute_sig_of_foreign_fn_decl(tcx, def_id.to_def_id(), fn_decl, abi, ident)\n+            compute_sig_of_foreign_fn_decl(tcx, def_id.to_def_id(), fn_decl, abi)\n         }\n \n         Ctor(data) | Variant(hir::Variant { data, .. }) if data.ctor_hir_id().is_some() => {\n@@ -1982,7 +1926,6 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n fn infer_return_ty_for_fn_sig<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     sig: &hir::FnSig<'_>,\n-    ident: Ident,\n     generics: &hir::Generics<'_>,\n     def_id: LocalDefId,\n     icx: &ItemCtxt<'tcx>,\n@@ -2037,8 +1980,7 @@ fn infer_return_ty_for_fn_sig<'tcx>(\n             sig.header.unsafety,\n             sig.header.abi,\n             sig.decl,\n-            generics,\n-            Some(ident.span),\n+            Some(generics),\n             None,\n         ),\n     }\n@@ -2301,29 +2243,9 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n     // Collect the region predicates that were declared inline as\n     // well. In the case of parameters declared on a fn or method, we\n     // have to be careful to only iterate over early-bound regions.\n-    let mut index = parent_count + has_own_self as u32;\n-    for param in early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics) {\n-        let region = tcx.mk_region(ty::ReEarlyBound(ty::EarlyBoundRegion {\n-            def_id: tcx.hir().local_def_id(param.hir_id).to_def_id(),\n-            index,\n-            name: param.name.ident().name,\n-        }));\n-        index += 1;\n-\n-        match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                param.bounds.iter().for_each(|bound| match bound {\n-                    hir::GenericBound::Outlives(lt) => {\n-                        let bound = <dyn AstConv<'_>>::ast_region_to_region(&icx, lt, None);\n-                        let outlives = ty::Binder::dummy(ty::OutlivesPredicate(region, bound));\n-                        predicates.insert((outlives.to_predicate(tcx), lt.span));\n-                    }\n-                    _ => bug!(),\n-                });\n-            }\n-            _ => bug!(),\n-        }\n-    }\n+    let mut index = parent_count\n+        + has_own_self as u32\n+        + early_bound_lifetimes_from_generics(tcx, hir_id.owner, ast_generics).count() as u32;\n \n     // Collect the predicates that were written inline by the user on each\n     // type parameter (e.g., `<T: Foo>`).\n@@ -2336,20 +2258,19 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                 let param_ty = ty::ParamTy::new(index, name).to_ty(tcx);\n                 index += 1;\n \n-                let mut bounds = <dyn AstConv<'_>>::compute_bounds(&icx, param_ty, param.bounds);\n+                let mut bounds = Bounds::default();\n                 // Params are implicitly sized unless a `?Sized` bound is found\n                 <dyn AstConv<'_>>::add_implicitly_sized(\n                     &icx,\n                     &mut bounds,\n-                    param.bounds,\n+                    &[],\n                     Some((param.hir_id, ast_generics.predicates)),\n                     param.span,\n                 );\n                 predicates.extend(bounds.predicates(tcx, param_ty));\n             }\n             GenericParamKind::Const { .. } => {\n                 // Bounds on const parameters are currently not possible.\n-                debug_assert!(param.bounds.is_empty());\n                 index += 1;\n             }\n         }\n@@ -2614,7 +2535,6 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     def_id: DefId,\n     decl: &'tcx hir::FnDecl<'tcx>,\n     abi: abi::Abi,\n-    ident: Ident,\n ) -> ty::PolyFnSig<'tcx> {\n     let unsafety = if abi == abi::Abi::RustIntrinsic {\n         intrinsic_operation_unsafety(tcx.item_name(def_id))\n@@ -2628,8 +2548,7 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n         unsafety,\n         abi,\n         decl,\n-        &hir::Generics::empty(),\n-        Some(ident.span),\n+        None,\n         None,\n     );\n "}, {"sha": "343dd0387f47987c011c2334c80f0c8d0f914ea4", "filename": "src/etc/check_missing_items.py", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/src%2Fetc%2Fcheck_missing_items.py", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/src%2Fetc%2Fcheck_missing_items.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcheck_missing_items.py?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -49,8 +49,6 @@ def check_generic_param(param):\n         ty = param[\"kind\"][\"type\"]\n         if ty[\"default\"]:\n             check_type(ty[\"default\"])\n-        for bound in ty[\"bounds\"]:\n-            check_generic_bound(bound)\n     elif \"const\" in param[\"kind\"]:\n         check_type(param[\"kind\"][\"const\"])\n "}, {"sha": "d458deddae335afc44724e5290ff9e42d981b335", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 77, "deletions": 42, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -238,9 +238,12 @@ impl Clean<Option<Lifetime>> for ty::Region<'_> {\n     }\n }\n \n-impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> WherePredicate {\n-        match *self {\n+impl Clean<Option<WherePredicate>> for hir::WherePredicate<'_> {\n+    fn clean(&self, cx: &mut DocContext<'_>) -> Option<WherePredicate> {\n+        if !self.in_where_clause() {\n+            return None;\n+        }\n+        Some(match *self {\n             hir::WherePredicate::BoundPredicate(ref wbp) => {\n                 let bound_params = wbp\n                     .bound_generic_params\n@@ -250,11 +253,7 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n                         // Higher-ranked lifetimes can't have bounds.\n                         assert_matches!(\n                             param,\n-                            hir::GenericParam {\n-                                kind: hir::GenericParamKind::Lifetime { .. },\n-                                bounds: [],\n-                                ..\n-                            }\n+                            hir::GenericParam { kind: hir::GenericParamKind::Lifetime { .. }, .. }\n                         );\n                         Lifetime(param.name.ident().name)\n                     })\n@@ -275,7 +274,7 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n                 lhs: wrp.lhs_ty.clean(cx),\n                 rhs: wrp.rhs_ty.clean(cx).into(),\n             },\n-        }\n+        })\n     }\n }\n \n@@ -456,44 +455,75 @@ impl Clean<GenericParamDef> for ty::GenericParamDef {\n     }\n }\n \n-impl Clean<GenericParamDef> for hir::GenericParam<'_> {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> GenericParamDef {\n-        let (name, kind) = match self.kind {\n-            hir::GenericParamKind::Lifetime { .. } => {\n-                let outlives = self\n-                    .bounds\n+fn clean_generic_param(\n+    cx: &mut DocContext<'_>,\n+    generics: Option<&hir::Generics<'_>>,\n+    param: &hir::GenericParam<'_>,\n+) -> GenericParamDef {\n+    let (name, kind) = match param.kind {\n+        hir::GenericParamKind::Lifetime { .. } => {\n+            let outlives = if let Some(generics) = generics {\n+                generics\n+                    .predicates\n                     .iter()\n+                    .flat_map(|pred| {\n+                        match pred {\n+                            hir::WherePredicate::RegionPredicate(rp)\n+                                if rp.lifetime.name == hir::LifetimeName::Param(param.name)\n+                                    && !rp.in_where_clause =>\n+                            {\n+                                rp.bounds\n+                            }\n+                            _ => &[],\n+                        }\n+                        .iter()\n+                    })\n                     .map(|bound| match bound {\n                         hir::GenericBound::Outlives(lt) => lt.clean(cx),\n                         _ => panic!(),\n                     })\n-                    .collect();\n-                (self.name.ident().name, GenericParamDefKind::Lifetime { outlives })\n-            }\n-            hir::GenericParamKind::Type { ref default, synthetic } => (\n-                self.name.ident().name,\n+                    .collect()\n+            } else {\n+                Vec::new()\n+            };\n+            (param.name.ident().name, GenericParamDefKind::Lifetime { outlives })\n+        }\n+        hir::GenericParamKind::Type { ref default, synthetic } => {\n+            let did = cx.tcx.hir().local_def_id(param.hir_id);\n+            let bounds = if let Some(generics) = generics {\n+                generics\n+                    .bounds_for_param(did)\n+                    .filter(|bp| !bp.in_where_clause)\n+                    .flat_map(|bp| bp.bounds)\n+                    .filter_map(|x| x.clean(cx))\n+                    .collect()\n+            } else {\n+                Vec::new()\n+            };\n+            (\n+                param.name.ident().name,\n                 GenericParamDefKind::Type {\n-                    did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n-                    bounds: self.bounds.iter().filter_map(|x| x.clean(cx)).collect(),\n+                    did: did.to_def_id(),\n+                    bounds,\n                     default: default.map(|t| t.clean(cx)).map(Box::new),\n                     synthetic,\n                 },\n-            ),\n-            hir::GenericParamKind::Const { ref ty, default } => (\n-                self.name.ident().name,\n-                GenericParamDefKind::Const {\n-                    did: cx.tcx.hir().local_def_id(self.hir_id).to_def_id(),\n-                    ty: Box::new(ty.clean(cx)),\n-                    default: default.map(|ct| {\n-                        let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n-                        Box::new(ty::Const::from_anon_const(cx.tcx, def_id).to_string())\n-                    }),\n-                },\n-            ),\n-        };\n+            )\n+        }\n+        hir::GenericParamKind::Const { ref ty, default } => (\n+            param.name.ident().name,\n+            GenericParamDefKind::Const {\n+                did: cx.tcx.hir().local_def_id(param.hir_id).to_def_id(),\n+                ty: Box::new(ty.clean(cx)),\n+                default: default.map(|ct| {\n+                    let def_id = cx.tcx.hir().local_def_id(ct.hir_id);\n+                    Box::new(ty::Const::from_anon_const(cx.tcx, def_id).to_string())\n+                }),\n+            },\n+        ),\n+    };\n \n-        GenericParamDef { name, kind }\n-    }\n+    GenericParamDef { name, kind }\n }\n \n impl Clean<Generics> for hir::Generics<'_> {\n@@ -524,7 +554,7 @@ impl Clean<Generics> for hir::Generics<'_> {\n             .iter()\n             .filter(|param| is_impl_trait(param))\n             .map(|param| {\n-                let param: GenericParamDef = param.clean(cx);\n+                let param = clean_generic_param(cx, Some(self), param);\n                 match param.kind {\n                     GenericParamDefKind::Lifetime { .. } => unreachable!(),\n                     GenericParamDefKind::Type { did, ref bounds, .. } => {\n@@ -538,14 +568,14 @@ impl Clean<Generics> for hir::Generics<'_> {\n \n         let mut params = Vec::with_capacity(self.params.len());\n         for p in self.params.iter().filter(|p| !is_impl_trait(p) && !is_elided_lifetime(p)) {\n-            let p = p.clean(cx);\n+            let p = clean_generic_param(cx, Some(self), p);\n             params.push(p);\n         }\n         params.extend(impl_trait_params);\n \n         let mut generics = Generics {\n             params,\n-            where_predicates: self.predicates.iter().map(|x| x.clean(cx)).collect(),\n+            where_predicates: self.predicates.iter().filter_map(|x| x.clean(cx)).collect(),\n         };\n \n         // Some duplicates are generated for ?Sized bounds between type params and where\n@@ -954,7 +984,11 @@ impl Clean<PolyTrait> for hir::PolyTraitRef<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> PolyTrait {\n         PolyTrait {\n             trait_: self.trait_ref.clean(cx),\n-            generic_params: self.bound_generic_params.iter().map(|x| x.clean(cx)).collect(),\n+            generic_params: self\n+                .bound_generic_params\n+                .iter()\n+                .map(|x| clean_generic_param(cx, None, x))\n+                .collect(),\n         }\n     }\n }\n@@ -1823,7 +1857,8 @@ impl Clean<BareFunctionDecl> for hir::BareFnTy<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> BareFunctionDecl {\n         let (generic_params, decl) = enter_impl_trait(cx, |cx| {\n             // NOTE: generics must be cleaned before args\n-            let generic_params = self.generic_params.iter().map(|x| x.clean(cx)).collect();\n+            let generic_params =\n+                self.generic_params.iter().map(|x| clean_generic_param(cx, None, x)).collect();\n             let args = clean_args_from_types_and_names(cx, self.decl.inputs, self.param_names);\n             let decl = clean_fn_decl_with_args(cx, self.decl, args);\n             (generic_params, decl)"}, {"sha": "b5502309560eeb8712b6bc926b3183ec04234485", "filename": "src/librustdoc/html/render/span_map.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fspan_map.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -5,7 +5,7 @@ use rustc_data_structures::fx::FxHashMap;\n use rustc_hir::def::{DefKind, Res};\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, Visitor};\n-use rustc_hir::{ExprKind, GenericParam, GenericParamKind, HirId, Mod, Node};\n+use rustc_hir::{ExprKind, GenericParam, HirId, Mod, Node};\n use rustc_middle::hir::nested_filter;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::Span;\n@@ -100,16 +100,7 @@ impl<'tcx> Visitor<'tcx> for SpanMapVisitor<'tcx> {\n         self.tcx.hir()\n     }\n \n-    fn visit_generic_param(&mut self, p: &'tcx GenericParam<'tcx>) {\n-        if !matches!(p.kind, GenericParamKind::Type { .. }) {\n-            return;\n-        }\n-        for bound in p.bounds {\n-            if let Some(trait_ref) = bound.trait_ref() {\n-                self.handle_path(trait_ref.path, None);\n-            }\n-        }\n-    }\n+    fn visit_generic_param(&mut self, _: &'tcx GenericParam<'tcx>) {}\n \n     fn visit_path(&mut self, path: &'tcx rustc_hir::Path<'tcx>, _id: HirId) {\n         self.handle_path(path, None);"}, {"sha": "29ed654f238a3943ec0531c346636082c8739e08", "filename": "src/test/ui/regions/regions-free-region-outlives-static-outlives-free-region.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-free-region-outlives-static-outlives-free-region.stderr?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -0,0 +1,10 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/regions-free-region-outlives-static-outlives-free-region.rs:13:5\n+   |\n+LL |     'a: 'static,\n+   |     ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: 1 warning emitted\n+"}, {"sha": "202c56a545609f40b840fc6e3fa0ff0017515b54", "filename": "src/test/ui/regions/regions-static-bound-rpass.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-static-bound-rpass.stderr?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -0,0 +1,26 @@\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/regions-static-bound-rpass.rs:5:5\n+   |\n+LL |     'a: 'static,\n+   |     ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: unnecessary lifetime parameter `'a`\n+  --> $DIR/regions-static-bound-rpass.rs:12:5\n+   |\n+LL |     'a: 'static,\n+   |     ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'a`\n+\n+warning: unnecessary lifetime parameter `'b`\n+  --> $DIR/regions-static-bound-rpass.rs:20:5\n+   |\n+LL |     'b: 'static,\n+   |     ^^\n+   |\n+   = help: you can use the `'static` lifetime directly, in place of `'b`\n+\n+warning: 3 warnings emitted\n+"}, {"sha": "662a561f171e91c49450f05d4818ff68ce973531", "filename": "src/tools/clippy/clippy_lints/src/lifetimes.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flifetimes.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -139,28 +139,35 @@ fn check_fn_inner<'tcx>(\n         .iter()\n         .filter(|param| matches!(param.kind, GenericParamKind::Type { .. }));\n     for typ in types {\n-        for bound in typ.bounds {\n-            let mut visitor = RefVisitor::new(cx);\n-            walk_param_bound(&mut visitor, bound);\n-            if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n-                return;\n+        for pred in generics.bounds_for_param(cx.tcx.hir().local_def_id(typ.hir_id)) {\n+            if pred.in_where_clause {\n+                // has_where_lifetimes checked that this predicate contains no lifetime.\n+                continue;\n             }\n-            if let GenericBound::Trait(ref trait_ref, _) = *bound {\n-                let params = &trait_ref\n-                    .trait_ref\n-                    .path\n-                    .segments\n-                    .last()\n-                    .expect(\"a path must have at least one segment\")\n-                    .args;\n-                if let Some(params) = *params {\n-                    let lifetimes = params.args.iter().filter_map(|arg| match arg {\n-                        GenericArg::Lifetime(lt) => Some(lt),\n-                        _ => None,\n-                    });\n-                    for bound in lifetimes {\n-                        if bound.name != LifetimeName::Static && !bound.is_elided() {\n-                            return;\n+\n+            for bound in pred.bounds {\n+                let mut visitor = RefVisitor::new(cx);\n+                walk_param_bound(&mut visitor, bound);\n+                if visitor.lts.iter().any(|lt| matches!(lt, RefLt::Named(_))) {\n+                    return;\n+                }\n+                if let GenericBound::Trait(ref trait_ref, _) = *bound {\n+                    let params = &trait_ref\n+                        .trait_ref\n+                        .path\n+                        .segments\n+                        .last()\n+                        .expect(\"a path must have at least one segment\")\n+                        .args;\n+                    if let Some(params) = *params {\n+                        let lifetimes = params.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Lifetime(lt) => Some(lt),\n+                            _ => None,\n+                        });\n+                        for bound in lifetimes {\n+                            if bound.name != LifetimeName::Static && !bound.is_elided() {\n+                                return;\n+                            }\n                         }\n                     }\n                 }\n@@ -322,9 +329,7 @@ fn allowed_lts_from(named_generics: &[GenericParam<'_>]) -> FxHashSet<RefLt> {\n     let mut allowed_lts = FxHashSet::default();\n     for par in named_generics.iter() {\n         if let GenericParamKind::Lifetime { .. } = par.kind {\n-            if par.bounds.is_empty() {\n-                allowed_lts.insert(RefLt::Named(par.name.ident().name));\n-            }\n+            allowed_lts.insert(RefLt::Named(par.name.ident().name));\n         }\n     }\n     allowed_lts.insert(RefLt::Unnamed);"}, {"sha": "3d1b2ee925bcebfd9d5511895d51e7ebf1f8c987", "filename": "src/tools/clippy/clippy_lints/src/trait_bounds.rs", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftrait_bounds.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -8,8 +8,7 @@ use rustc_data_structures::unhash::UnhashMap;\n use rustc_errors::Applicability;\n use rustc_hir::def::Res;\n use rustc_hir::{\n-    GenericBound, Generics, Item, ItemKind, Node, ParamName, Path, PathSegment, QPath, TraitItem, Ty, TyKind,\n-    WherePredicate,\n+    GenericBound, Generics, Item, ItemKind, Node, Path, PathSegment, QPath, TraitItem, Ty, TyKind, WherePredicate,\n };\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -219,30 +218,19 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n         return;\n     }\n \n-    let mut map = FxHashMap::default();\n-    for param in gen.params {\n-        if let ParamName::Plain(ref ident) = param.name {\n-            let res = param\n-                .bounds\n-                .iter()\n-                .filter_map(get_trait_info_from_bound)\n-                .collect::<Vec<_>>();\n-            map.insert(*ident, res);\n-        }\n-    }\n-\n+    let mut map = FxHashMap::<_, Vec<_>>::default();\n     for predicate in gen.predicates {\n         if_chain! {\n             if let WherePredicate::BoundPredicate(ref bound_predicate) = predicate;\n             if !bound_predicate.span.from_expansion();\n             if let TyKind::Path(QPath::Resolved(_, Path { segments, .. })) = bound_predicate.bounded_ty.kind;\n             if let Some(segment) = segments.first();\n-            if let Some(trait_resolutions_direct) = map.get(&segment.ident);\n             then {\n-                for (res_where, _,  _) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n-                    if let Some((_, _, span_direct)) = trait_resolutions_direct\n+                for (res_where, _, span_where) in bound_predicate.bounds.iter().filter_map(get_trait_info_from_bound) {\n+                    let trait_resolutions_direct = map.entry(segment.ident).or_default();\n+                    if let Some((_, span_direct)) = trait_resolutions_direct\n                                                 .iter()\n-                                                .find(|(res_direct, _, _)| *res_direct == res_where) {\n+                                                .find(|(res_direct, _)| *res_direct == res_where) {\n                         span_lint_and_help(\n                             cx,\n                             TRAIT_DUPLICATION_IN_BOUNDS,\n@@ -252,6 +240,9 @@ fn check_trait_bound_duplication(cx: &LateContext<'_>, gen: &'_ Generics<'_>) {\n                             \"consider removing this trait bound\",\n                         );\n                     }\n+                    else {\n+                        trait_resolutions_direct.push((res_where, span_where))\n+                    }\n                 }\n             }\n         }"}, {"sha": "f35f44eda5679fb34f365965dac7433983875010", "filename": "src/tools/clippy/clippy_lints/src/types/borrowed_box.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "raw_url": "https://github.com/rust-lang/rust/raw/94449e610163b4cbe762089351f5517ad90a3841/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ftypes%2Fborrowed_box.rs?ref=94449e610163b4cbe762089351f5517ad90a3841", "patch": "@@ -104,8 +104,10 @@ fn get_bounds_if_impl_trait<'tcx>(cx: &LateContext<'tcx>, qpath: &QPath<'_>, id:\n         if let Some(Node::GenericParam(generic_param)) = cx.tcx.hir().get_if_local(did);\n         if let GenericParamKind::Type { synthetic, .. } = generic_param.kind;\n         if synthetic;\n+        if let Some(generics) = cx.tcx.hir().get_generics(id.owner);\n+        if let Some(pred) = generics.bounds_for_param(did.expect_local()).next();\n         then {\n-            Some(generic_param.bounds)\n+            Some(pred.bounds)\n         } else {\n             None\n         }"}]}