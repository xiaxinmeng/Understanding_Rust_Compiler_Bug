{"sha": "3b50a4e286e81426862867d8ce31ebbd9bcc930c", "node_id": "C_kwDOAAsO6NoAKDNiNTBhNGUyODZlODE0MjY4NjI4NjdkOGNlMzFlYmJkOWJjYzkzMGM", "commit": {"author": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-06T01:17:18Z"}, "committer": {"name": "Noah Lev", "email": "camelidcamel@gmail.com", "date": "2022-01-06T19:48:46Z"}, "message": "Use `DefId`s instead of names in `UrlFragment`\n\nThis is the next step in computing more \"semantic\" information during\nintra-doc link collection and then doing rendering all at the end.", "tree": {"sha": "5d40942ad75670da2278558de083a4190dc02ee7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5d40942ad75670da2278558de083a4190dc02ee7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3b50a4e286e81426862867d8ce31ebbd9bcc930c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3b50a4e286e81426862867d8ce31ebbd9bcc930c", "html_url": "https://github.com/rust-lang/rust/commit/3b50a4e286e81426862867d8ce31ebbd9bcc930c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3b50a4e286e81426862867d8ce31ebbd9bcc930c/comments", "author": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camelid", "id": 37223377, "node_id": "MDQ6VXNlcjM3MjIzMzc3", "avatar_url": "https://avatars.githubusercontent.com/u/37223377?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camelid", "html_url": "https://github.com/camelid", "followers_url": "https://api.github.com/users/camelid/followers", "following_url": "https://api.github.com/users/camelid/following{/other_user}", "gists_url": "https://api.github.com/users/camelid/gists{/gist_id}", "starred_url": "https://api.github.com/users/camelid/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camelid/subscriptions", "organizations_url": "https://api.github.com/users/camelid/orgs", "repos_url": "https://api.github.com/users/camelid/repos", "events_url": "https://api.github.com/users/camelid/events{/privacy}", "received_events_url": "https://api.github.com/users/camelid/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f89e2dd935d86bf2da3e4181e47ecaf56b5de026", "url": "https://api.github.com/repos/rust-lang/rust/commits/f89e2dd935d86bf2da3e4181e47ecaf56b5de026", "html_url": "https://github.com/rust-lang/rust/commit/f89e2dd935d86bf2da3e4181e47ecaf56b5de026"}], "stats": {"total": 95, "additions": 49, "deletions": 46}, "files": [{"sha": "f278c6c17bbba058f238a1e57df6b9986f8b8e32", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/3b50a4e286e81426862867d8ce31ebbd9bcc930c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b50a4e286e81426862867d8ce31ebbd9bcc930c/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=3b50a4e286e81426862867d8ce31ebbd9bcc930c", "patch": "@@ -1,6 +1,5 @@\n use std::cell::RefCell;\n use std::default::Default;\n-use std::fmt::Write;\n use std::hash::Hash;\n use std::lazy::SyncOnceCell as OnceCell;\n use std::path::PathBuf;\n@@ -496,7 +495,7 @@ impl Item {\n                 if let Ok((mut href, ..)) = href(*did, cx) {\n                     debug!(?href);\n                     if let Some(ref fragment) = *fragment {\n-                        write!(href, \"{}\", fragment).unwrap()\n+                        fragment.render(&mut href, cx.tcx()).unwrap()\n                     }\n                     Some(RenderedLink {\n                         original_text: s.clone(),"}, {"sha": "08193bd765ab76408b33cbc415bdde215f2c27f5", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 48, "deletions": 44, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/3b50a4e286e81426862867d8ce31ebbd9bcc930c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3b50a4e286e81426862867d8ce31ebbd9bcc930c/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=3b50a4e286e81426862867d8ce31ebbd9bcc930c", "patch": "@@ -13,7 +13,7 @@ use rustc_hir::def::{\n     PerNS,\n };\n use rustc_hir::def_id::{CrateNum, DefId};\n-use rustc_middle::ty::{Ty, TyCtxt};\n+use rustc_middle::ty::{DefIdTree, Ty, TyCtxt};\n use rustc_middle::{bug, span_bug, ty};\n use rustc_resolve::ParentScope;\n use rustc_session::lint::Lint;\n@@ -27,6 +27,7 @@ use pulldown_cmark::LinkType;\n use std::borrow::Cow;\n use std::cell::Cell;\n use std::convert::{TryFrom, TryInto};\n+use std::fmt::Write;\n use std::mem;\n use std::ops::Range;\n \n@@ -240,53 +241,61 @@ enum AnchorFailure {\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n crate enum UrlFragment {\n-    Method(Symbol),\n-    TyMethod(Symbol),\n-    AssociatedConstant(Symbol),\n-    AssociatedType(Symbol),\n+    Def(FragmentKind, DefId),\n+    UserWritten(String),\n+}\n \n-    StructField(Symbol),\n-    Variant(Symbol),\n-    VariantField { variant: Symbol, field: Symbol },\n+#[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n+crate enum FragmentKind {\n+    Method,\n+    TyMethod,\n+    AssociatedConstant,\n+    AssociatedType,\n \n-    UserWritten(String),\n+    StructField,\n+    Variant,\n+    VariantField,\n }\n \n impl UrlFragment {\n     /// Create a fragment for an associated item.\n     ///\n     /// `is_prototype` is whether this associated item is a trait method\n     /// without a default definition.\n-    fn from_assoc_item(name: Symbol, kind: ty::AssocKind, is_prototype: bool) -> Self {\n+    fn from_assoc_item(def_id: DefId, kind: ty::AssocKind, is_prototype: bool) -> Self {\n         match kind {\n             ty::AssocKind::Fn => {\n                 if is_prototype {\n-                    UrlFragment::TyMethod(name)\n+                    UrlFragment::Def(FragmentKind::TyMethod, def_id)\n                 } else {\n-                    UrlFragment::Method(name)\n+                    UrlFragment::Def(FragmentKind::Method, def_id)\n                 }\n             }\n-            ty::AssocKind::Const => UrlFragment::AssociatedConstant(name),\n-            ty::AssocKind::Type => UrlFragment::AssociatedType(name),\n+            ty::AssocKind::Const => UrlFragment::Def(FragmentKind::AssociatedConstant, def_id),\n+            ty::AssocKind::Type => UrlFragment::Def(FragmentKind::AssociatedType, def_id),\n         }\n     }\n-}\n \n-/// Render the fragment, including the leading `#`.\n-impl std::fmt::Display for UrlFragment {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        write!(f, \"#\")?;\n-        match self {\n-            UrlFragment::Method(name) => write!(f, \"method.{}\", name),\n-            UrlFragment::TyMethod(name) => write!(f, \"tymethod.{}\", name),\n-            UrlFragment::AssociatedConstant(name) => write!(f, \"associatedconstant.{}\", name),\n-            UrlFragment::AssociatedType(name) => write!(f, \"associatedtype.{}\", name),\n-            UrlFragment::StructField(name) => write!(f, \"structfield.{}\", name),\n-            UrlFragment::Variant(name) => write!(f, \"variant.{}\", name),\n-            UrlFragment::VariantField { variant, field } => {\n-                write!(f, \"variant.{}.field.{}\", variant, field)\n+    /// Render the fragment, including the leading `#`.\n+    crate fn render(&self, s: &mut String, tcx: TyCtxt<'_>) -> std::fmt::Result {\n+        write!(s, \"#\")?;\n+        match *self {\n+            UrlFragment::Def(kind, def_id) => {\n+                let name = tcx.item_name(def_id);\n+                match kind {\n+                    FragmentKind::Method => write!(s, \"method.{}\", name),\n+                    FragmentKind::TyMethod => write!(s, \"tymethod.{}\", name),\n+                    FragmentKind::AssociatedConstant => write!(s, \"associatedconstant.{}\", name),\n+                    FragmentKind::AssociatedType => write!(s, \"associatedtype.{}\", name),\n+                    FragmentKind::StructField => write!(s, \"structfield.{}\", name),\n+                    FragmentKind::Variant => write!(s, \"variant.{}\", name),\n+                    FragmentKind::VariantField => {\n+                        let variant = tcx.item_name(tcx.parent(def_id).unwrap());\n+                        write!(s, \"variant.{}.field.{}\", variant, name)\n+                    }\n+                }\n             }\n-            UrlFragment::UserWritten(raw) => write!(f, \"{}\", raw),\n+            UrlFragment::UserWritten(ref raw) => write!(s, \"{}\", raw),\n         }\n     }\n }\n@@ -387,13 +396,12 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 }\n                 match tcx.type_of(did).kind() {\n                     ty::Adt(def, _) if def.is_enum() => {\n-                        if def.all_fields().any(|item| item.ident.name == variant_field_name) {\n+                        if let Some(field) =\n+                            def.all_fields().find(|f| f.ident.name == variant_field_name)\n+                        {\n                             Ok((\n                                 ty_res,\n-                                Some(UrlFragment::VariantField {\n-                                    variant: variant_name,\n-                                    field: variant_field_name,\n-                                }),\n+                                Some(UrlFragment::Def(FragmentKind::VariantField, field.did)),\n                             ))\n                         } else {\n                             Err(ResolutionFailure::NotResolved {\n@@ -430,7 +438,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, impl_)\n                 .map(|item| {\n                     let kind = item.kind;\n-                    let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n+                    let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n                     (Res::Primitive(prim_ty), fragment, Some((kind.as_def_kind(), item.def_id)))\n                 })\n         })\n@@ -683,7 +691,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n                     assoc_item.map(|item| {\n                         let kind = item.kind;\n-                        let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n+                        let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n                         // HACK(jynelson): `clean` expects the type, not the associated item\n                         // but the disambiguator logic expects the associated item.\n                         // Store the kind in a side channel so that only the disambiguator logic looks at it.\n@@ -737,7 +745,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n \n                 if let Some(item) = assoc_item {\n                     let kind = item.kind;\n-                    let fragment = UrlFragment::from_assoc_item(item_name, kind, false);\n+                    let fragment = UrlFragment::from_assoc_item(item.def_id, kind, false);\n                     // HACK(jynelson): `clean` expects the type, not the associated item\n                     // but the disambiguator logic expects the associated item.\n                     // Store the kind in a side channel so that only the disambiguator logic looks at it.\n@@ -774,7 +782,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                     .find(|item| item.ident.name == item_name)?;\n                 Some((\n                     root_res,\n-                    UrlFragment::StructField(field.ident.name),\n+                    UrlFragment::Def(FragmentKind::StructField, field.did),\n                     Some((DefKind::Field, field.did)),\n                 ))\n             }\n@@ -783,7 +791,7 @@ impl<'a, 'tcx> LinkCollector<'a, 'tcx> {\n                 .find_by_name_and_namespace(tcx, Ident::with_dummy_span(item_name), ns, did)\n                 .map(|item| {\n                     let fragment = UrlFragment::from_assoc_item(\n-                        item_name,\n+                        item.def_id,\n                         item.kind,\n                         !item.defaultness.has_value(),\n                     );\n@@ -919,8 +927,6 @@ fn is_derive_trait_collision<T>(ns: &PerNS<Result<(Res, T), ResolutionFailure<'_\n \n impl<'a, 'tcx> DocVisitor for LinkCollector<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-        use rustc_middle::ty::DefIdTree;\n-\n         let parent_node =\n             item.def_id.as_def_id().and_then(|did| find_nearest_parent_module(self.cx.tcx, did));\n         if parent_node.is_some() {\n@@ -2280,14 +2286,12 @@ fn handle_variant(\n     cx: &DocContext<'_>,\n     res: Res,\n ) -> Result<(Res, Option<UrlFragment>), ErrorKind<'static>> {\n-    use rustc_middle::ty::DefIdTree;\n-\n     cx.tcx\n         .parent(res.def_id(cx.tcx))\n         .map(|parent| {\n             let parent_def = Res::Def(DefKind::Enum, parent);\n             let variant = cx.tcx.expect_variant_res(res.as_hir_res().unwrap());\n-            (parent_def, Some(UrlFragment::Variant(variant.ident.name)))\n+            (parent_def, Some(UrlFragment::Def(FragmentKind::Variant, variant.def_id)))\n         })\n         .ok_or_else(|| ResolutionFailure::NoParentItem.into())\n }"}]}