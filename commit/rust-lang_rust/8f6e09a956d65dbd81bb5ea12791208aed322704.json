{"sha": "8f6e09a956d65dbd81bb5ea12791208aed322704", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhmNmUwOWE5NTZkNjVkYmQ4MWJiNWVhMTI3OTEyMDhhZWQzMjI3MDQ=", "commit": {"author": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-02-28T11:11:13Z"}, "committer": {"name": "mitaa", "email": "mitaa.ceb@gmail.com", "date": "2016-03-04T18:07:35Z"}, "message": "Simplify `if let`/`match` expressions", "tree": {"sha": "09ee854c43f378e46dd6b1e9d4a689ee845a8b5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09ee854c43f378e46dd6b1e9d4a689ee845a8b5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8f6e09a956d65dbd81bb5ea12791208aed322704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8f6e09a956d65dbd81bb5ea12791208aed322704", "html_url": "https://github.com/rust-lang/rust/commit/8f6e09a956d65dbd81bb5ea12791208aed322704", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8f6e09a956d65dbd81bb5ea12791208aed322704/comments", "author": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mitaa", "id": 6785936, "node_id": "MDQ6VXNlcjY3ODU5MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/6785936?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mitaa", "html_url": "https://github.com/mitaa", "followers_url": "https://api.github.com/users/mitaa/followers", "following_url": "https://api.github.com/users/mitaa/following{/other_user}", "gists_url": "https://api.github.com/users/mitaa/gists{/gist_id}", "starred_url": "https://api.github.com/users/mitaa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mitaa/subscriptions", "organizations_url": "https://api.github.com/users/mitaa/orgs", "repos_url": "https://api.github.com/users/mitaa/repos", "events_url": "https://api.github.com/users/mitaa/events{/privacy}", "received_events_url": "https://api.github.com/users/mitaa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62267470f630c6bf8553feb65d5c130e6890ba70", "url": "https://api.github.com/repos/rust-lang/rust/commits/62267470f630c6bf8553feb65d5c130e6890ba70", "html_url": "https://github.com/rust-lang/rust/commit/62267470f630c6bf8553feb65d5c130e6890ba70"}], "stats": {"total": 530, "additions": 211, "deletions": 319}, "files": [{"sha": "6fd80feaac747b9fc42c8f61d482c0c27c399ae0", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 9, "deletions": 16, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=8f6e09a956d65dbd81bb5ea12791208aed322704", "patch": "@@ -138,13 +138,10 @@ pub fn load_attrs(cx: &DocContext, tcx: &TyCtxt,\n /// These names are used later on by HTML rendering to generate things like\n /// source links back to the original item.\n pub fn record_extern_fqn(cx: &DocContext, did: DefId, kind: clean::TypeKind) {\n-    match cx.tcx_opt() {\n-        Some(tcx) => {\n-            let fqn = tcx.sess.cstore.extern_item_path(did);\n-            let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n-            cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n-        }\n-        None => {}\n+    if let Some(tcx) = cx.tcx_opt() {\n+        let fqn = tcx.sess.cstore.extern_item_path(did);\n+        let fqn = fqn.into_iter().map(|i| i.to_string()).collect();\n+        cx.external_paths.borrow_mut().as_mut().unwrap().insert(did, (fqn, kind));\n     }\n }\n \n@@ -230,12 +227,9 @@ pub fn build_impls(cx: &DocContext, tcx: &TyCtxt,\n     tcx.populate_inherent_implementations_for_type_if_necessary(did);\n     let mut impls = Vec::new();\n \n-    match tcx.inherent_impls.borrow().get(&did) {\n-        None => {}\n-        Some(i) => {\n-            for &did in i.iter() {\n-                build_impl(cx, tcx, did, &mut impls);\n-            }\n+    if let Some(i) = tcx.inherent_impls.borrow().get(&did) {\n+        for &did in i.iter() {\n+            build_impl(cx, tcx, did, &mut impls);\n         }\n     }\n \n@@ -464,9 +458,8 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n                 }\n                 cstore::DlDef(def) if item.vis == hir::Public => {\n                     if !visited.insert(def) { continue }\n-                    match try_inline_def(cx, tcx, def) {\n-                        Some(i) => items.extend(i),\n-                        None => {}\n+                    if let Some(i) = try_inline_def(cx, tcx, def) {\n+                        items.extend(i)\n                     }\n                 }\n                 cstore::DlDef(..) => {}"}, {"sha": "96a56a7c113f30b097444ed2cdab1f405f48b1c5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 29, "deletions": 54, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=8f6e09a956d65dbd81bb5ea12791208aed322704", "patch": "@@ -100,10 +100,7 @@ impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n \n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     fn clean(&self, cx: &DocContext) -> Option<U> {\n-        match self {\n-            &None => None,\n-            &Some(ref v) => Some(v.clean(cx))\n-        }\n+        self.as_ref().map(|v| v.clean(cx))\n     }\n }\n \n@@ -332,27 +329,20 @@ impl Item {\n     }\n \n     pub fn stability_class(&self) -> String {\n-        match self.stability {\n-            Some(ref s) => {\n-                let mut base = match s.level {\n-                    stability::Unstable => \"unstable\".to_string(),\n-                    stability::Stable => String::new(),\n-                };\n-                if !s.deprecated_since.is_empty() {\n-                    base.push_str(\" deprecated\");\n-                }\n-                base\n+        self.stability.as_ref().map(|ref s| {\n+            let mut base = match s.level {\n+                stability::Unstable => \"unstable\".to_string(),\n+                stability::Stable => String::new(),\n+            };\n+            if !s.deprecated_since.is_empty() {\n+                base.push_str(\" deprecated\");\n             }\n-            _ => String::new(),\n-        }\n+            base\n+        }).unwrap_or(String::new())\n     }\n \n     pub fn stable_since(&self) -> Option<&str> {\n-        if let Some(ref s) = self.stability {\n-            return Some(&s.since[..]);\n-        }\n-\n-        None\n+        self.stability.as_ref().map(|s| &s.since[..])\n     }\n }\n \n@@ -711,7 +701,7 @@ impl<'tcx> Clean<TyParamBound> for ty::TraitRef<'tcx> {\n                         if let &ty::Region::ReLateBound(_, _) = *reg {\n                             debug!(\"  hit an ReLateBound {:?}\", reg);\n                             if let Some(lt) = reg.clean(cx) {\n-                                late_bounds.push(lt)\n+                                late_bounds.push(lt);\n                             }\n                         }\n                     }\n@@ -780,8 +770,7 @@ impl Clean<Option<Lifetime>> for ty::Region {\n     fn clean(&self, cx: &DocContext) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n-            ty::ReLateBound(_, ty::BrNamed(_, name)) =>\n-                Some(Lifetime(name.to_string())),\n+            ty::ReLateBound(_, ty::BrNamed(_, name)) => Some(Lifetime(name.to_string())),\n             ty::ReEarlyBound(ref data) => Some(Lifetime(data.name.clean(cx))),\n \n             ty::ReLateBound(..) |\n@@ -1151,12 +1140,12 @@ impl<'tcx> Clean<Type> for ty::FnOutput<'tcx> {\n impl<'a, 'tcx> Clean<FnDecl> for (DefId, &'a ty::PolyFnSig<'tcx>) {\n     fn clean(&self, cx: &DocContext) -> FnDecl {\n         let (did, sig) = *self;\n-        let mut names = if let Some(_) = cx.map.as_local_node_id(did) {\n+        let mut names = if cx.map.as_local_node_id(did).is_some() {\n             vec![].into_iter()\n         } else {\n             cx.tcx().sess.cstore.method_arg_names(did).into_iter()\n         }.peekable();\n-        if names.peek().map(|s| &**s) == Some(\"self\") {\n+        if let Some(\"self\") = names.peek().map(|s| &s[..]) {\n             let _ = names.next();\n         }\n         FnDecl {\n@@ -1627,15 +1616,9 @@ impl Clean<Type> for hir::Ty {\n                 }\n             }\n             TyBareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n-            TyPolyTraitRef(ref bounds) => {\n-                PolyTraitRef(bounds.clean(cx))\n-            },\n-            TyInfer => {\n-                Infer\n-            },\n-            TyTypeof(..) => {\n-                panic!(\"Unimplemented type {:?}\", self.node)\n-            },\n+            TyPolyTraitRef(ref bounds) => PolyTraitRef(bounds.clean(cx)),\n+            TyInfer => Infer,\n+            TyTypeof(..) => panic!(\"Unimplemented type {:?}\", self.node),\n         }\n     }\n }\n@@ -2253,7 +2236,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n                 polarity: Some(self.polarity.clean(cx)),\n             }),\n         });\n-        return ret;\n+        ret\n     }\n }\n \n@@ -2393,9 +2376,8 @@ impl Clean<Vec<Item>> for doctree::Import {\n             }\n             hir::ViewPathSimple(name, ref p) => {\n                 if !denied {\n-                    match inline::try_inline(cx, self.id, Some(name)) {\n-                        Some(items) => return items,\n-                        None => {}\n+                    if let Some(items) = inline::try_inline(cx, self.id, Some(name)) {\n+                        return items;\n                     }\n                 }\n                 (vec![], SimpleImport(name.clean(cx),\n@@ -2460,9 +2442,8 @@ impl Clean<Vec<Item>> for hir::ForeignMod {\n     fn clean(&self, cx: &DocContext) -> Vec<Item> {\n         let mut items = self.items.clean(cx);\n         for item in &mut items {\n-            match item.inner {\n-                ForeignFunctionItem(ref mut f) => f.abi = self.abi,\n-                _ => {}\n+            if let ForeignFunctionItem(ref mut f) = item.inner {\n+                f.abi = self.abi;\n             }\n         }\n         items\n@@ -2598,11 +2579,7 @@ fn resolve_type(cx: &DocContext,\n             };\n         }\n     };\n-    let def = match tcx.def_map.borrow().get(&id) {\n-        Some(k) => k.full_def(),\n-        None => panic!(\"unresolved id not in defmap\")\n-    };\n-\n+    let def = tcx.def_map.borrow().get(&id).expect(\"unresolved id not in defmap\").full_def();\n     debug!(\"resolve_type: def={:?}\", def);\n \n     let is_generic = match def {\n@@ -2659,7 +2636,7 @@ fn register_def(cx: &DocContext, def: Def) -> DefId {\n         let t = inline::build_external_trait(cx, tcx, did);\n         cx.external_traits.borrow_mut().as_mut().unwrap().insert(did, t);\n     }\n-    return did;\n+    did\n }\n \n fn resolve_use_source(cx: &DocContext, path: Path, id: ast::NodeId) -> ImportSource {\n@@ -2732,12 +2709,10 @@ impl Clean<Stability> for attr::Stability {\n                 _=> \"\".to_string(),\n             },\n             reason: {\n-                if let Some(ref depr) = self.rustc_depr {\n-                    depr.reason.to_string()\n-                } else if let attr::Unstable {reason: Some(ref reason), ..} = self.level {\n-                    reason.to_string()\n-                } else {\n-                    \"\".to_string()\n+                match (&self.rustc_depr, &self.level) {\n+                    (&Some(ref depr), _) => depr.reason.to_string(),\n+                    (&None, &attr::Unstable {reason: Some(ref reason), ..}) => reason.to_string(),\n+                    _ => \"\".to_string(),\n                 }\n             },\n             issue: match self.level {"}, {"sha": "afe1387ad9fe6750ecc970c80056b71d27903a2c", "filename": "src/librustdoc/fold.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ffold.rs?ref=8f6e09a956d65dbd81bb5ea12791208aed322704", "patch": "@@ -81,6 +81,7 @@ pub trait DocFolder : Sized {\n         c.module = match replace(&mut c.module, None) {\n             Some(module) => self.fold_item(module), None => None\n         };\n+\n         let external_traits = replace(&mut c.external_traits, HashMap::new());\n         c.external_traits = external_traits.into_iter().map(|(k, mut v)| {\n             let items = replace(&mut v.items, Vec::new());"}, {"sha": "319c9d7d18560182c62d73520b2639bf2a4ded90", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 134, "deletions": 172, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=8f6e09a956d65dbd81bb5ea12791208aed322704", "patch": "@@ -433,41 +433,38 @@ pub fn run(mut krate: clean::Crate,\n     // Crawl the crate attributes looking for attributes which control how we're\n     // going to emit HTML\n     let default: &[_] = &[];\n-    match krate.module.as_ref().map(|m| m.doc_list().unwrap_or(default)) {\n-        Some(attrs) => {\n-            for attr in attrs {\n-                match *attr {\n-                    clean::NameValue(ref x, ref s)\n-                            if \"html_favicon_url\" == *x => {\n-                        cx.layout.favicon = s.to_string();\n-                    }\n-                    clean::NameValue(ref x, ref s)\n-                            if \"html_logo_url\" == *x => {\n-                        cx.layout.logo = s.to_string();\n-                    }\n-                    clean::NameValue(ref x, ref s)\n-                            if \"html_playground_url\" == *x => {\n-                        cx.layout.playground_url = s.to_string();\n-                        markdown::PLAYGROUND_KRATE.with(|slot| {\n-                            if slot.borrow().is_none() {\n-                                let name = krate.name.clone();\n-                                *slot.borrow_mut() = Some(Some(name));\n-                            }\n-                        });\n-                    }\n-                    clean::NameValue(ref x, ref s)\n-                            if \"issue_tracker_base_url\" == *x => {\n-                        cx.issue_tracker_base_url = Some(s.to_string());\n-                    }\n-                    clean::Word(ref x)\n-                            if \"html_no_source\" == *x => {\n-                        cx.include_sources = false;\n-                    }\n-                    _ => {}\n+    if let Some(attrs) = krate.module.as_ref().map(|m| m.doc_list().unwrap_or(default)) {\n+        for attr in attrs {\n+            match *attr {\n+                clean::NameValue(ref x, ref s)\n+                        if \"html_favicon_url\" == *x => {\n+                    cx.layout.favicon = s.to_string();\n+                }\n+                clean::NameValue(ref x, ref s)\n+                        if \"html_logo_url\" == *x => {\n+                    cx.layout.logo = s.to_string();\n+                }\n+                clean::NameValue(ref x, ref s)\n+                        if \"html_playground_url\" == *x => {\n+                    cx.layout.playground_url = s.to_string();\n+                    markdown::PLAYGROUND_KRATE.with(|slot| {\n+                        if slot.borrow().is_none() {\n+                            let name = krate.name.clone();\n+                            *slot.borrow_mut() = Some(Some(name));\n+                        }\n+                    });\n+                }\n+                clean::NameValue(ref x, ref s)\n+                        if \"issue_tracker_base_url\" == *x => {\n+                    cx.issue_tracker_base_url = Some(s.to_string());\n+                }\n+                clean::Word(ref x)\n+                        if \"html_no_source\" == *x => {\n+                    cx.include_sources = false;\n                 }\n+                _ => {}\n             }\n         }\n-        None => {}\n     }\n \n     // Crawl the crate to build various caches used for the output\n@@ -986,15 +983,12 @@ impl DocFolder for Cache {\n \n         // Collect all the implementors of traits.\n         if let clean::ImplItem(ref i) = item.inner {\n-            match i.trait_ {\n-                Some(clean::ResolvedPath{ did, .. }) => {\n-                    self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n-                        def_id: item.def_id,\n-                        stability: item.stability.clone(),\n-                        impl_: i.clone(),\n-                    });\n-                }\n-                Some(..) | None => {}\n+            if let Some(clean::ResolvedPath{ did, .. }) = i.trait_ {\n+                self.implementors.entry(did).or_insert(vec![]).push(Implementor {\n+                    def_id: item.def_id,\n+                    stability: item.stability.clone(),\n+                    impl_: i.clone(),\n+                });\n             }\n         }\n \n@@ -1054,6 +1048,9 @@ impl DocFolder for Cache {\n                         }\n                     });\n \n+                    // A crate has a module at its root, containing all items,\n+                    // which should not be indexed. The crate-item itself is\n+                    // inserted later on when serializing the search-index.\n                     if item.def_id.index != CRATE_DEF_INDEX {\n                         self.search_index.push(IndexItem {\n                             ty: shortty(&item),\n@@ -1078,13 +1075,14 @@ impl DocFolder for Cache {\n         }\n \n         // Keep track of the fully qualified path for this item.\n-        let pushed = if item.name.is_some() {\n-            let n = item.name.as_ref().unwrap();\n-            if !n.is_empty() {\n+        let pushed = match item.name {\n+            Some(ref n) if !n.is_empty() => {\n                 self.stack.push(n.to_string());\n                 true\n-            } else { false }\n-        } else { false };\n+            }\n+            _ => false,\n+        };\n+\n         match item.inner {\n             clean::StructItem(..) | clean::EnumItem(..) |\n             clean::TypedefItem(..) | clean::TraitItem(..) |\n@@ -1153,60 +1151,53 @@ impl DocFolder for Cache {\n \n         // Once we've recursively found all the generics, then hoard off all the\n         // implementations elsewhere\n-        let ret = match self.fold_item_recur(item) {\n-            Some(item) => {\n-                match item {\n-                    clean::Item{ attrs, inner: clean::ImplItem(i), .. } => {\n-                        // extract relevant documentation for this impl\n-                        let dox = match attrs.into_iter().find(|a| {\n-                            match *a {\n-                                clean::NameValue(ref x, _)\n-                                        if \"doc\" == *x => {\n-                                    true\n-                                }\n-                                _ => false\n-                            }\n-                        }) {\n-                            Some(clean::NameValue(_, dox)) => Some(dox),\n-                            Some(..) | None => None,\n-                        };\n-\n-                        // Figure out the id of this impl. This may map to a\n-                        // primitive rather than always to a struct/enum.\n-                        let did = match i.for_ {\n-                            clean::ResolvedPath { did, .. } |\n-                            clean::BorrowedRef {\n-                                type_: box clean::ResolvedPath { did, .. }, ..\n-                            } => {\n-                                Some(did)\n-                            }\n-\n-                            ref t => {\n-                                t.primitive_type().and_then(|t| {\n-                                    self.primitive_locations.get(&t).map(|n| {\n-                                        let id = t.to_def_index();\n-                                        DefId { krate: *n, index: id }\n-                                    })\n-                                })\n-                            }\n-                        };\n-\n-                        if let Some(did) = did {\n-                            self.impls.entry(did).or_insert(vec![]).push(Impl {\n-                                impl_: i,\n-                                dox: dox,\n-                                stability: item.stability.clone(),\n-                            });\n+        let ret = self.fold_item_recur(item).and_then(|item| {\n+            if let clean::Item { attrs, inner: clean::ImplItem(i), .. } = item {\n+                // extract relevant documentation for this impl\n+                let dox = match attrs.into_iter().find(|a| {\n+                    match *a {\n+                        clean::NameValue(ref x, _)\n+                                if \"doc\" == *x => {\n+                            true\n                         }\n+                        _ => false\n+                    }\n+                }) {\n+                    Some(clean::NameValue(_, dox)) => Some(dox),\n+                    Some(..) | None => None,\n+                };\n+                // Figure out the id of this impl. This may map to a\n+                // primitive rather than always to a struct/enum.\n+                let did = match i.for_ {\n+                    clean::ResolvedPath { did, .. } |\n+                    clean::BorrowedRef {\n+                        type_: box clean::ResolvedPath { did, .. }, ..\n+                    } => {\n+                        Some(did)\n+                    }\n \n-                        None\n+                    ref t => {\n+                        t.primitive_type().and_then(|t| {\n+                            self.primitive_locations.get(&t).map(|n| {\n+                                let id = t.to_def_index();\n+                                DefId { krate: *n, index: id }\n+                            })\n+                        })\n                     }\n+                };\n \n-                    i => Some(i),\n+                if let Some(did) = did {\n+                    self.impls.entry(did).or_insert(vec![]).push(Impl {\n+                        impl_: i,\n+                        dox: dox,\n+                        stability: item.stability.clone(),\n+                    });\n                 }\n+                None\n+            } else {\n+                Some(item)\n             }\n-            i => i,\n-        };\n+        });\n \n         if pushed { self.stack.pop().unwrap(); }\n         if parent_pushed { self.parent_stack.pop().unwrap(); }\n@@ -1581,13 +1572,10 @@ impl<'a> fmt::Display for Item<'a> {\n         // this page, and this link will be auto-clicked. The `id` attribute is\n         // used to find the link to auto-click.\n         if self.cx.include_sources && !is_primitive {\n-            match self.href() {\n-                Some(l) => {\n-                    try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n-                                       href='{}' title='{}'>[src]</a>\",\n-                                self.item.def_id.index.as_usize(), l, \"goto source code\"));\n-                }\n-                None => {}\n+            if let Some(l) = self.href() {\n+                try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n+                                   href='{}' title='{}'>[src]</a>\",\n+                            self.item.def_id.index.as_usize(), l, \"goto source code\"));\n             }\n         }\n \n@@ -1801,7 +1789,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n }\n \n fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Option<String> {\n-    let mut result = item.stability.as_ref().and_then(|stab| {\n+    item.stability.as_ref().and_then(|stab| {\n         let reason = if show_reason && !stab.reason.is_empty() {\n             format!(\": {}\", stab.reason)\n         } else {\n@@ -1836,10 +1824,8 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n         };\n         Some(format!(\"<em class='stab {}'>{}</em>\",\n                      item.stability_class(), text))\n-    });\n-\n-    if result.is_none() {\n-        result = item.deprecation.as_ref().and_then(|depr| {\n+    }).or_else(|| {\n+        item.deprecation.as_ref().and_then(|depr| {\n             let note = if show_reason && !depr.note.is_empty() {\n                 format!(\": {}\", depr.note)\n             } else {\n@@ -1853,10 +1839,8 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Optio\n \n             let text = format!(\"Deprecated{}{}\", since, Markdown(&note));\n             Some(format!(\"<em class='stab deprecated'>{}</em>\", text))\n-        });\n-    }\n-\n-    result\n+        })\n+    })\n }\n \n struct Initializer<'a>(&'a str);\n@@ -2108,17 +2092,12 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n fn render_stability_since_raw<'a>(w: &mut fmt::Formatter,\n                                   ver: Option<&'a str>,\n                                   containing_ver: Option<&'a str>) -> fmt::Result {\n-    if containing_ver != ver {\n-        match ver {\n-            Some(v) =>\n-                if v.len() > 0 {\n-                        try!(write!(w, \"<span class=\\\"since\\\">{}</span>\",\n-                                    v))\n-                },\n-            None => {}\n+    if let Some(v) = ver {\n+        if containing_ver != ver && v.len() > 0 {\n+            try!(write!(w, \"<span class=\\\"since\\\">{}</span>\",\n+                        v))\n         }\n     }\n-\n     Ok(())\n }\n \n@@ -2289,43 +2268,33 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n             try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n                           name = variant.name.as_ref().unwrap()));\n             try!(document(w, cx, variant));\n-            match variant.inner {\n-                clean::VariantItem(ref var) => {\n-                    match var.kind {\n-                        clean::StructVariant(ref s) => {\n-                            let fields = s.fields.iter().filter(|f| {\n-                                match f.inner {\n-                                    clean::StructFieldItem(ref t) => match *t {\n-                                        clean::HiddenStructField => false,\n-                                        clean::TypedStructField(..) => true,\n-                                    },\n-                                    _ => false,\n-                                }\n-                            });\n-                            try!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n-                                              <table>\"));\n-                            for field in fields {\n-                                try!(write!(w, \"<tr><td \\\n-                                                  id='variant.{v}.field.{f}'>\\\n-                                                  <code>{f}</code></td><td>\",\n-                                              v = variant.name.as_ref().unwrap(),\n-                                              f = field.name.as_ref().unwrap()));\n-                                try!(document(w, cx, field));\n-                                try!(write!(w, \"</td></tr>\"));\n-                            }\n-                            try!(write!(w, \"</table>\"));\n-                        }\n-                        _ => ()\n+\n+            use clean::{Variant, StructVariant};\n+            if let clean::VariantItem( Variant { kind: StructVariant(ref s) } ) = variant.inner {\n+                let fields = s.fields.iter().filter(|f| {\n+                    match f.inner {\n+                        clean::StructFieldItem(clean::TypedStructField(..)) => true,\n+                        _ => false,\n                     }\n+                });\n+                try!(write!(w, \"<h3 class='fields'>Fields</h3>\\n\n+                                  <table>\"));\n+                for field in fields {\n+                    try!(write!(w, \"<tr><td \\\n+                                      id='variant.{v}.field.{f}'>\\\n+                                      <code>{f}</code></td><td>\",\n+                                  v = variant.name.as_ref().unwrap(),\n+                                  f = field.name.as_ref().unwrap()));\n+                    try!(document(w, cx, field));\n+                    try!(write!(w, \"</td></tr>\"));\n                 }\n-                _ => ()\n+                try!(write!(w, \"</table>\"));\n             }\n             try!(write!(w, \"</td><td>\"));\n             try!(render_stability_since(w, variant, it));\n             try!(write!(w, \"</td></tr>\"));\n         }\n         try!(write!(w, \"</table>\"));\n-\n     }\n     try!(render_assoc_items(w, cx, it, it.def_id, AssocItemRender::All));\n     Ok(())\n@@ -2356,9 +2325,8 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                   VisSpace(it.visibility),\n                   if structhead {\"struct \"} else {\"\"},\n                   it.name.as_ref().unwrap()));\n-    match g {\n-        Some(g) => try!(write!(w, \"{}{}\", *g, WhereClause(g))),\n-        None => {}\n+    if let Some(g) = g {\n+        try!(write!(w, \"{}{}\", *g, WhereClause(g)))\n     }\n     match ty {\n         doctree::Plain => {\n@@ -2452,7 +2420,7 @@ fn render_assoc_items(w: &mut fmt::Formatter,\n         }\n     }\n     if let AssocItemRender::DerefFor { .. } = what {\n-        return Ok(())\n+        return Ok(());\n     }\n     if !traits.is_empty() {\n         let deref_impl = traits.iter().find(|t| {\n@@ -2533,10 +2501,17 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                     link: AssocItemLink, render_static: bool,\n                     outer_version: Option<&str>) -> fmt::Result {\n         let name = item.name.as_ref().unwrap();\n+\n+        let is_static = match item.inner {\n+            clean::MethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n+            clean::TyMethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n+            _ => false\n+        };\n+\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n                 // Only render when the method is not static or we allow static methods\n-                if !is_static_method(item) || render_static {\n+                if !is_static || render_static {\n                     let id = derive_id(format!(\"method.{}\", name));\n                     try!(write!(w, \"<h4 id='{}' class='{}'>\", id, shortty(item)));\n                     try!(render_stability_since_raw(w, item.stable_since(), outer_version));\n@@ -2572,22 +2547,11 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n \n-        return if let AssocItemLink::Anchor = link {\n-            if is_static_method(item) && !render_static {\n-                Ok(())\n-            } else {\n+        match link {\n+            AssocItemLink::Anchor if !is_static || render_static => {\n                 document(w, cx, item)\n-            }\n-        } else {\n-            Ok(())\n-        };\n-\n-        fn is_static_method(item: &clean::Item) -> bool {\n-            match item.inner {\n-                clean::MethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n-                clean::TyMethodItem(ref method) => method.self_ == SelfTy::SelfStatic,\n-                _ => false\n-            }\n+            },\n+            _ => Ok(()),\n         }\n     }\n \n@@ -2605,9 +2569,8 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n                               outer_version: Option<&str>) -> fmt::Result {\n         for trait_item in &t.items {\n             let n = trait_item.name.clone();\n-            match i.items.iter().find(|m| { m.name == n }) {\n-                Some(..) => continue,\n-                None => {}\n+            if i.items.iter().find(|m| { m.name == n }).is_some() {\n+                continue;\n             }\n \n             try!(doctraititem(w, cx, trait_item, AssocItemLink::GotoSource(did), render_static,\n@@ -2623,7 +2586,6 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n     if let Some(clean::ResolvedPath { did, .. }) = i.impl_.trait_ {\n         if let Some(t) = cache().traits.get(&did) {\n             try!(render_default_items(w, cx, did, t, &i.impl_, render_header, outer_version));\n-\n         }\n     }\n     try!(write!(w, \"</div>\"));"}, {"sha": "53003c5ee52adc9d3abdc9f271b7218e5f5d31b7", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 17, "deletions": 38, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=8f6e09a956d65dbd81bb5ea12791208aed322704", "patch": "@@ -283,19 +283,15 @@ pub fn main_args(args: &[String]) -> isize {\n     info!(\"going to format\");\n     match matches.opt_str(\"w\").as_ref().map(|s| &**s) {\n         Some(\"html\") | None => {\n-            match html::render::run(krate, &external_html,\n-                                    output.unwrap_or(PathBuf::from(\"doc\")),\n-                                    passes.into_iter().collect()) {\n-                Ok(()) => {}\n-                Err(e) => panic!(\"failed to generate documentation: {}\", e),\n-            }\n+            html::render::run(krate, &external_html,\n+                              output.unwrap_or(PathBuf::from(\"doc\")),\n+                              passes.into_iter().collect())\n+                .expect(\"failed to generate documentation\")\n         }\n         Some(\"json\") => {\n-            match json_output(krate, json_plugins,\n-                              output.unwrap_or(PathBuf::from(\"doc.json\"))) {\n-                Ok(()) => {}\n-                Err(e) => panic!(\"failed to write json: {}\", e),\n-            }\n+            json_output(krate, json_plugins,\n+                        output.unwrap_or(PathBuf::from(\"doc.json\")))\n+                .expect(\"failed to write json\")\n         }\n         Some(s) => {\n             println!(\"unknown output format: {}\", s);\n@@ -332,18 +328,10 @@ fn parse_externs(matches: &getopts::Matches) -> Result<core::Externs, String> {\n     let mut externs = HashMap::new();\n     for arg in &matches.opt_strs(\"extern\") {\n         let mut parts = arg.splitn(2, '=');\n-        let name = match parts.next() {\n-            Some(s) => s,\n-            None => {\n-                return Err(\"--extern value must not be empty\".to_string());\n-            }\n-        };\n-        let location = match parts.next() {\n-            Some(s) => s,\n-            None => {\n-                return Err(\"--extern value must be of the format `foo=bar`\".to_string());\n-            }\n-        };\n+        let name = try!(parts.next().ok_or(\"--extern value must not be empty\".to_string()));\n+        let location = try!(parts.next()\n+                                 .ok_or(\"--extern value must be of the format `foo=bar`\"\n+                                    .to_string()));\n         let name = name.to_string();\n         externs.entry(name).or_insert(vec![]).push(location.to_string());\n     }\n@@ -448,17 +436,16 @@ fn rust_input(cratefile: &str, externs: core::Externs, matches: &getopts::Matche\n     // Run everything!\n     info!(\"Executing passes/plugins\");\n     let (krate, json) = pm.run_plugins(krate);\n-    return Output { krate: krate, json_plugins: json, passes: passes, };\n+    Output { krate: krate, json_plugins: json, passes: passes }\n }\n \n /// This input format purely deserializes the json output file. No passes are\n /// run over the deserialized output.\n fn json_input(input: &str) -> Result<Output, String> {\n     let mut bytes = Vec::new();\n-    match File::open(input).and_then(|mut f| f.read_to_end(&mut bytes)) {\n-        Ok(_) => {}\n-        Err(e) => return Err(format!(\"couldn't open {}: {}\", input, e)),\n-    };\n+    if let Err(e) = File::open(input).and_then(|mut f| f.read_to_end(&mut bytes)) {\n+        return Err(format!(\"couldn't open {}: {}\", input, e))\n+    }\n     match json::from_reader(&mut &bytes[..]) {\n         Err(s) => Err(format!(\"{:?}\", s)),\n         Ok(Json::Object(obj)) => {\n@@ -507,21 +494,13 @@ fn json_output(krate: clean::Crate, res: Vec<plugins::PluginJson> ,\n     json.insert(\"schema\".to_string(), Json::String(SCHEMA_VERSION.to_string()));\n     let plugins_json = res.into_iter()\n                           .filter_map(|opt| {\n-                              match opt {\n-                                  None => None,\n-                                  Some((string, json)) => {\n-                                      Some((string.to_string(), json))\n-                                  }\n-                              }\n+                              opt.map(|(string, json)| (string.to_string(), json))\n                           }).collect();\n \n     // FIXME #8335: yuck, Rust -> str -> JSON round trip! No way to .encode\n     // straight to the Rust JSON representation.\n     let crate_json_str = format!(\"{}\", json::as_json(&krate));\n-    let crate_json = match json::from_str(&crate_json_str) {\n-        Ok(j) => j,\n-        Err(e) => panic!(\"Rust generated JSON is invalid: {:?}\", e)\n-    };\n+    let crate_json = json::from_str(&crate_json_str).expect(\"Rust generated JSON is invalid\");\n \n     json.insert(\"crate\".to_string(), crate_json);\n     json.insert(\"plugins\".to_string(), Json::Object(plugins_json));"}, {"sha": "46e801631bf5b1a2274c667a87af879e9455b5bf", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 14, "deletions": 19, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=8f6e09a956d65dbd81bb5ea12791208aed322704", "patch": "@@ -205,22 +205,19 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             self.fold_item_recur(i)\n         };\n \n-        match i {\n-            Some(i) => {\n-                match i.inner {\n-                    // emptied modules/impls have no need to exist\n-                    clean::ModuleItem(ref m)\n-                        if m.items.is_empty() &&\n-                           i.doc_value().is_none() => None,\n-                    clean::ImplItem(ref i) if i.items.is_empty() => None,\n-                    _ => {\n-                        self.retained.insert(i.def_id);\n-                        Some(i)\n-                    }\n+        i.and_then(|i| {\n+            match i.inner {\n+                // emptied modules/impls have no need to exist\n+                clean::ModuleItem(ref m)\n+                    if m.items.is_empty() &&\n+                       i.doc_value().is_none() => None,\n+                clean::ImplItem(ref i) if i.items.is_empty() => None,\n+                _ => {\n+                    self.retained.insert(i.def_id);\n+                    Some(i)\n                 }\n             }\n-            None => None,\n-        }\n+        })\n     }\n }\n \n@@ -275,13 +272,11 @@ pub fn collapse_docs(krate: clean::Crate) -> plugins::PluginResult {\n             let mut docstr = String::new();\n             let mut i = i;\n             for attr in &i.attrs {\n-                match *attr {\n-                    clean::NameValue(ref x, ref s)\n-                            if \"doc\" == *x => {\n+                if let clean::NameValue(ref x, ref s) = *attr {\n+                    if \"doc\" == *x {\n                         docstr.push_str(s);\n                         docstr.push('\\n');\n-                    },\n-                    _ => ()\n+                    }\n                 }\n             }\n             let mut a: Vec<clean::Attribute> = i.attrs.iter().filter(|&a| match a {"}, {"sha": "e97357f98898b47f90d52b6f4526a08cb8b903d4", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=8f6e09a956d65dbd81bb5ea12791208aed322704", "patch": "@@ -121,9 +121,8 @@ pub fn run(input: &str,\n     let mut v = RustdocVisitor::new(&ctx, None);\n     v.visit(ctx.map.krate());\n     let mut krate = v.clean(&ctx);\n-    match crate_name {\n-        Some(name) => krate.name = name,\n-        None => {}\n+    if let Some(name) = crate_name {\n+        krate.name = name;\n     }\n     let (krate, _) = passes::collapse_docs(krate);\n     let (krate, _) = passes::unindent_comments(krate);\n@@ -334,13 +333,10 @@ pub fn maketest(s: &str, cratename: Option<&str>, dont_insert_main: bool,\n     // Don't inject `extern crate std` because it's already injected by the\n     // compiler.\n     if !s.contains(\"extern crate\") && !opts.no_crate_inject && cratename != Some(\"std\") {\n-        match cratename {\n-            Some(cratename) => {\n-                if s.contains(cratename) {\n-                    prog.push_str(&format!(\"extern crate {};\\n\", cratename));\n-                }\n+        if let Some(cratename) = cratename {\n+            if s.contains(cratename) {\n+                prog.push_str(&format!(\"extern crate {};\\n\", cratename));\n             }\n-            None => {}\n         }\n     }\n     if dont_insert_main || s.contains(\"fn main\") {\n@@ -476,12 +472,7 @@ impl DocFolder for Collector {\n             _ => typename_if_impl(&item)\n         };\n \n-        let pushed = if let Some(name) = current_name {\n-            self.names.push(name);\n-            true\n-        } else {\n-            false\n-        };\n+        let pushed = current_name.map(|name| self.names.push(name)).is_some();\n \n         if let Some(doc) = item.doc_value() {\n             self.cnt = 0;"}, {"sha": "bc6b4f83984b04f695ad5b4e46acb963524bda5e", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8f6e09a956d65dbd81bb5ea12791208aed322704/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=8f6e09a956d65dbd81bb5ea12791208aed322704", "patch": "@@ -263,13 +263,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let name = renamed.unwrap_or(item.name);\n         match item.node {\n             hir::ItemExternCrate(ref p) => {\n-                let path = match *p {\n-                    None => None,\n-                    Some(x) => Some(x.to_string()),\n-                };\n                 om.extern_crates.push(ExternCrate {\n                     name: name,\n-                    path: path,\n+                    path: p.map(|x|x.to_string()),\n                     vis: item.vis,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,"}]}