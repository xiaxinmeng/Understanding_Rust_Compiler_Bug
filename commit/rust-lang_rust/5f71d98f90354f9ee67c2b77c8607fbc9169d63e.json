{"sha": "5f71d98f90354f9ee67c2b77c8607fbc9169d63e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmNzFkOThmOTAzNTRmOWVlNjdjMmI3N2M4NjA3ZmJjOTE2OWQ2M2U=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-21T16:20:18Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-21T19:21:31Z"}, "message": "Deduplicate test and primary range_search definitions\n\nThis ensures that what we test is what we get for final results as well.", "tree": {"sha": "0482b32e9a4ffadb13873905794c65050931ec3b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0482b32e9a4ffadb13873905794c65050931ec3b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f71d98f90354f9ee67c2b77c8607fbc9169d63e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f71d98f90354f9ee67c2b77c8607fbc9169d63e", "html_url": "https://github.com/rust-lang/rust/commit/5f71d98f90354f9ee67c2b77c8607fbc9169d63e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7b29b70d6ea52e9324f9328bed9beb6cf516c1ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/7b29b70d6ea52e9324f9328bed9beb6cf516c1ce", "html_url": "https://github.com/rust-lang/rust/commit/7b29b70d6ea52e9324f9328bed9beb6cf516c1ce"}], "stats": {"total": 204, "additions": 103, "deletions": 101}, "files": [{"sha": "94a2507e26ccb728dae520e836603ff861bf3585", "filename": "src/libcore/unicode/mod.rs", "status": "modified", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/src%2Flibcore%2Funicode%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/src%2Flibcore%2Funicode%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Fmod.rs?ref=5f71d98f90354f9ee67c2b77c8607fbc9169d63e", "patch": "@@ -32,48 +32,3 @@ pub use unicode_data::lowercase::lookup as Lowercase;\n pub use unicode_data::n::lookup as N;\n pub use unicode_data::uppercase::lookup as Uppercase;\n pub use unicode_data::white_space::lookup as White_Space;\n-\n-#[inline(always)]\n-fn range_search<\n-    const N: usize,\n-    const CHUNK_SIZE: usize,\n-    const N1: usize,\n-    const CANONICAL: usize,\n-    const CANONICALIZED: usize,\n->(\n-    needle: u32,\n-    chunk_idx_map: &[u8; N],\n-    (last_chunk_idx, last_chunk_mapping): (u16, u8),\n-    bitset_chunk_idx: &[[u8; CHUNK_SIZE]; N1],\n-    bitset_canonical: &[u64; CANONICAL],\n-    bitset_canonicalized: &[(u8, u8); CANONICALIZED],\n-) -> bool {\n-    let bucket_idx = (needle / 64) as usize;\n-    let chunk_map_idx = bucket_idx / CHUNK_SIZE;\n-    let chunk_piece = bucket_idx % CHUNK_SIZE;\n-    let chunk_idx = if chunk_map_idx >= N {\n-        if chunk_map_idx == last_chunk_idx as usize {\n-            last_chunk_mapping\n-        } else {\n-            return false;\n-        }\n-    } else {\n-        chunk_idx_map[chunk_map_idx]\n-    };\n-    let idx = bitset_chunk_idx[(chunk_idx as usize)][chunk_piece] as usize;\n-    let word = if idx < CANONICAL {\n-        bitset_canonical[idx]\n-    } else {\n-        let (real_idx, mapping) = bitset_canonicalized[idx - CANONICAL];\n-        let mut word = bitset_canonical[real_idx as usize];\n-        let should_invert = mapping & (1 << 6) != 0;\n-        if should_invert {\n-            word = !word;\n-        }\n-        // Unset the inversion bit\n-        let rotate_by = mapping & !(1 << 6);\n-        word = word.rotate_left(rotate_by as u32);\n-        word\n-    };\n-    (word & (1 << (needle % 64) as u64)) != 0\n-}"}, {"sha": "5b1efbaa28fe7bd94cc7fd83ed5d6114a33316df", "filename": "src/libcore/unicode/unicode_data.rs", "status": "modified", "additions": 50, "deletions": 1, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/src%2Flibcore%2Funicode%2Funicode_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/src%2Flibcore%2Funicode%2Funicode_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Funicode%2Funicode_data.rs?ref=5f71d98f90354f9ee67c2b77c8607fbc9169d63e", "patch": "@@ -1,5 +1,54 @@\n ///! This file is generated by src/tools/unicode-table-generator; do not edit manually!\n-use super::range_search;\n+\n+#[inline(always)]\n+fn range_search<\n+    const N: usize,\n+    const CHUNK_SIZE: usize,\n+    const N1: usize,\n+    const CANONICAL: usize,\n+    const CANONICALIZED: usize,\n+>(\n+    needle: u32,\n+    chunk_idx_map: &[u8; N],\n+    (last_chunk_idx, last_chunk_mapping): (u16, u8),\n+    bitset_chunk_idx: &[[u8; CHUNK_SIZE]; N1],\n+    bitset_canonical: &[u64; CANONICAL],\n+    bitset_canonicalized: &[(u8, u8); CANONICALIZED],\n+) -> bool {\n+    let bucket_idx = (needle / 64) as usize;\n+    let chunk_map_idx = bucket_idx / CHUNK_SIZE;\n+    let chunk_piece = bucket_idx % CHUNK_SIZE;\n+    let chunk_idx = if chunk_map_idx >= N {\n+        if chunk_map_idx == last_chunk_idx as usize {\n+            last_chunk_mapping\n+        } else {\n+            return false;\n+        }\n+    } else {\n+        chunk_idx_map[chunk_map_idx]\n+    };\n+    let idx = bitset_chunk_idx[(chunk_idx as usize)][chunk_piece] as usize;\n+    let word = if idx < CANONICAL {\n+        bitset_canonical[idx]\n+    } else {\n+        let (real_idx, mapping) = bitset_canonicalized[idx - CANONICAL];\n+        let mut word = bitset_canonical[real_idx as usize];\n+        let should_invert = mapping & (1 << 6) != 0;\n+        if should_invert {\n+            word = !word;\n+        }\n+        // Lower 6 bits\n+        let quantity = mapping & ((1 << 6) - 1);\n+        if mapping & (1 << 7) != 0 {\n+            // shift\n+            word >>= quantity as u64;\n+        } else {\n+            word = word.rotate_left(quantity as u32);\n+        }\n+        word\n+    };\n+    (word & (1 << (needle % 64) as u64)) != 0\n+}\n \n pub const UNICODE_VERSION: (u32, u32, u32) = (13, 0, 0);\n "}, {"sha": "af23c166871e1cce8f8c0148d63cb23012531347", "filename": "src/tools/unicode-table-generator/src/main.rs", "status": "modified", "additions": 4, "deletions": 55, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Fmain.rs?ref=5f71d98f90354f9ee67c2b77c8607fbc9169d63e", "patch": "@@ -181,7 +181,10 @@ fn main() {\n         \"///! This file is generated by src/tools/unicode-table-generator; do not edit manually!\\n\",\n     );\n \n-    table_file.push_str(\"use super::range_search;\\n\\n\");\n+    // Include the range search function\n+    table_file.push('\\n');\n+    table_file.push_str(include_str!(\"range_search.rs\"));\n+    table_file.push('\\n');\n \n     table_file.push_str(&version());\n \n@@ -251,60 +254,6 @@ fn generate_tests(data_path: &str, ranges: &[(&str, Vec<Range<u32>>)]) -> String\n     s.push_str(&format!(\"#[path = \\\"{}\\\"]\\n\", data_path));\n     s.push_str(\"mod unicode_data;\\n\\n\");\n \n-    s.push_str(\n-        \"\n-#[inline(always)]\n-fn range_search<\n-    const N: usize,\n-    const CHUNK_SIZE: usize,\n-    const N1: usize,\n-    const CANONICAL: usize,\n-    const CANONICALIZED: usize,\n->(\n-    needle: u32,\n-    chunk_idx_map: &[u8; N],\n-    (last_chunk_idx, last_chunk_mapping): (u16, u8),\n-    bitset_chunk_idx: &[[u8; CHUNK_SIZE]; N1],\n-    bitset_canonical: &[u64; CANONICAL],\n-    bitset_canonicalized: &[(u8, u8); CANONICALIZED],\n-) -> bool {\n-    let bucket_idx = (needle / 64) as usize;\n-    let chunk_map_idx = bucket_idx / CHUNK_SIZE;\n-    let chunk_piece = bucket_idx % CHUNK_SIZE;\n-    let chunk_idx = if chunk_map_idx >= N {\n-        if chunk_map_idx == last_chunk_idx as usize {\n-            last_chunk_mapping\n-        } else {\n-            return false;\n-        }\n-    } else {\n-        chunk_idx_map[chunk_map_idx]\n-    };\n-    let idx = bitset_chunk_idx[(chunk_idx as usize)][chunk_piece] as usize;\n-    let word = if idx < CANONICAL {\n-        bitset_canonical[idx]\n-    } else {\n-        let (real_idx, mapping) = bitset_canonicalized[idx - CANONICAL];\n-        let mut word = bitset_canonical[real_idx as usize];\n-        let should_invert = mapping & (1 << 6) != 0;\n-        if should_invert {\n-            word = !word;\n-        }\n-        // Lower 6 bits\n-        let quantity = mapping & ((1 << 6) - 1);\n-        if mapping & (1 << 7) != 0 {\n-            // shift\n-            word >>= quantity as u64;\n-        } else {\n-            word = word.rotate_left(quantity as u32);\n-        }\n-        word\n-    };\n-    (word & (1 << (needle % 64) as u64)) != 0\n-}\n-    \",\n-    );\n-\n     s.push_str(\"\\nfn main() {\\n\");\n \n     for (property, ranges) in ranges {"}, {"sha": "a0bc1e6aec53a9b3317e1115e882450fb5f4dc9d", "filename": "src/tools/unicode-table-generator/src/range_search.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/src%2Ftools%2Funicode-table-generator%2Fsrc%2Frange_search.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f71d98f90354f9ee67c2b77c8607fbc9169d63e/src%2Ftools%2Funicode-table-generator%2Fsrc%2Frange_search.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Funicode-table-generator%2Fsrc%2Frange_search.rs?ref=5f71d98f90354f9ee67c2b77c8607fbc9169d63e", "patch": "@@ -0,0 +1,49 @@\n+#[inline(always)]\n+fn range_search<\n+    const N: usize,\n+    const CHUNK_SIZE: usize,\n+    const N1: usize,\n+    const CANONICAL: usize,\n+    const CANONICALIZED: usize,\n+>(\n+    needle: u32,\n+    chunk_idx_map: &[u8; N],\n+    (last_chunk_idx, last_chunk_mapping): (u16, u8),\n+    bitset_chunk_idx: &[[u8; CHUNK_SIZE]; N1],\n+    bitset_canonical: &[u64; CANONICAL],\n+    bitset_canonicalized: &[(u8, u8); CANONICALIZED],\n+) -> bool {\n+    let bucket_idx = (needle / 64) as usize;\n+    let chunk_map_idx = bucket_idx / CHUNK_SIZE;\n+    let chunk_piece = bucket_idx % CHUNK_SIZE;\n+    let chunk_idx = if chunk_map_idx >= N {\n+        if chunk_map_idx == last_chunk_idx as usize {\n+            last_chunk_mapping\n+        } else {\n+            return false;\n+        }\n+    } else {\n+        chunk_idx_map[chunk_map_idx]\n+    };\n+    let idx = bitset_chunk_idx[(chunk_idx as usize)][chunk_piece] as usize;\n+    let word = if idx < CANONICAL {\n+        bitset_canonical[idx]\n+    } else {\n+        let (real_idx, mapping) = bitset_canonicalized[idx - CANONICAL];\n+        let mut word = bitset_canonical[real_idx as usize];\n+        let should_invert = mapping & (1 << 6) != 0;\n+        if should_invert {\n+            word = !word;\n+        }\n+        // Lower 6 bits\n+        let quantity = mapping & ((1 << 6) - 1);\n+        if mapping & (1 << 7) != 0 {\n+            // shift\n+            word >>= quantity as u64;\n+        } else {\n+            word = word.rotate_left(quantity as u32);\n+        }\n+        word\n+    };\n+    (word & (1 << (needle % 64) as u64)) != 0\n+}"}]}