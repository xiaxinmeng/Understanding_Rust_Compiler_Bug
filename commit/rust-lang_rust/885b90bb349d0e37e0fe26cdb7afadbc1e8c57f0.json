{"sha": "885b90bb349d0e37e0fe26cdb7afadbc1e8c57f0", "node_id": "C_kwDOAAsO6NoAKDg4NWI5MGJiMzQ5ZDBlMzdlMGZlMjZjZGI3YWZhZGJjMWU4YzU3ZjA", "commit": {"author": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-07T19:03:04Z"}, "committer": {"name": "Miguel Guarniz", "email": "mi9uel9@gmail.com", "date": "2022-05-13T15:46:06Z"}, "message": "remove DebuggerVisualizerCollector\n\nSigned-off-by: Miguel Guarniz <mi9uel9@gmail.com>", "tree": {"sha": "c95a2f83fd123e1c1b0993ff363c4a90fd9ed7eb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c95a2f83fd123e1c1b0993ff363c4a90fd9ed7eb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/885b90bb349d0e37e0fe26cdb7afadbc1e8c57f0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/885b90bb349d0e37e0fe26cdb7afadbc1e8c57f0", "html_url": "https://github.com/rust-lang/rust/commit/885b90bb349d0e37e0fe26cdb7afadbc1e8c57f0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/885b90bb349d0e37e0fe26cdb7afadbc1e8c57f0/comments", "author": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kckeiks", "id": 24687641, "node_id": "MDQ6VXNlcjI0Njg3NjQx", "avatar_url": "https://avatars.githubusercontent.com/u/24687641?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kckeiks", "html_url": "https://github.com/kckeiks", "followers_url": "https://api.github.com/users/kckeiks/followers", "following_url": "https://api.github.com/users/kckeiks/following{/other_user}", "gists_url": "https://api.github.com/users/kckeiks/gists{/gist_id}", "starred_url": "https://api.github.com/users/kckeiks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kckeiks/subscriptions", "organizations_url": "https://api.github.com/users/kckeiks/orgs", "repos_url": "https://api.github.com/users/kckeiks/repos", "events_url": "https://api.github.com/users/kckeiks/events{/privacy}", "received_events_url": "https://api.github.com/users/kckeiks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "52d721c3fa87b828b9b311e2c2fe69bf3209cd54", "url": "https://api.github.com/repos/rust-lang/rust/commits/52d721c3fa87b828b9b311e2c2fe69bf3209cd54", "html_url": "https://github.com/rust-lang/rust/commit/52d721c3fa87b828b9b311e2c2fe69bf3209cd54"}], "stats": {"total": 158, "additions": 68, "deletions": 90}, "files": [{"sha": "e8a508da52d03cd739cbe919af2e3479ce07f9eb", "filename": "compiler/rustc_passes/src/debugger_visualizer.rs", "status": "modified", "additions": 68, "deletions": 90, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/885b90bb349d0e37e0fe26cdb7afadbc1e8c57f0/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/885b90bb349d0e37e0fe26cdb7afadbc1e8c57f0/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdebugger_visualizer.rs?ref=885b90bb349d0e37e0fe26cdb7afadbc1e8c57f0", "patch": "@@ -5,7 +5,6 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_expand::base::resolve_path;\n use rustc_hir as hir;\n use rustc_hir::def_id::CrateNum;\n-use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::{HirId, Target};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n@@ -14,96 +13,71 @@ use rustc_span::{sym, DebuggerVisualizerFile, DebuggerVisualizerType};\n \n use std::sync::Arc;\n \n-struct DebuggerVisualizerCollector<'tcx> {\n-    debugger_visualizers: FxHashSet<DebuggerVisualizerFile>,\n+fn check_for_debugger_visualizer<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-}\n-\n-impl<'v, 'tcx> ItemLikeVisitor<'v> for DebuggerVisualizerCollector<'tcx> {\n-    fn visit_item(&mut self, item: &hir::Item<'_>) {\n-        let target = Target::from_item(item);\n-        match target {\n-            Target::Mod => {\n-                self.check_for_debugger_visualizer(item.hir_id());\n-            }\n-            _ => {}\n-        }\n-    }\n-\n-    fn visit_trait_item(&mut self, _: &hir::TraitItem<'_>) {}\n-\n-    fn visit_impl_item(&mut self, _: &hir::ImplItem<'_>) {}\n-\n-    fn visit_foreign_item(&mut self, _: &hir::ForeignItem<'_>) {}\n-}\n-\n-impl<'tcx> DebuggerVisualizerCollector<'tcx> {\n-    fn new(tcx: TyCtxt<'tcx>) -> DebuggerVisualizerCollector<'tcx> {\n-        DebuggerVisualizerCollector { tcx, debugger_visualizers: FxHashSet::default() }\n-    }\n-\n-    fn check_for_debugger_visualizer(&mut self, hir_id: HirId) {\n-        let attrs = self.tcx.hir().attrs(hir_id);\n-        for attr in attrs {\n-            if attr.has_name(sym::debugger_visualizer) {\n-                let list = match attr.meta_item_list() {\n-                    Some(list) => list,\n-                    _ => continue,\n-                };\n-\n-                let meta_item = match list.len() {\n-                    1 => match list[0].meta_item() {\n-                        Some(meta_item) => meta_item,\n-                        _ => continue,\n-                    },\n+    hir_id: HirId,\n+    debugger_visualizers: &mut FxHashSet<DebuggerVisualizerFile>\n+) {\n+    let attrs = tcx.hir().attrs(hir_id);\n+    for attr in attrs {\n+        if attr.has_name(sym::debugger_visualizer) {\n+            let list = match attr.meta_item_list() {\n+                Some(list) => list,\n+                _ => continue,\n+            };\n+\n+            let meta_item = match list.len() {\n+                1 => match list[0].meta_item() {\n+                    Some(meta_item) => meta_item,\n                     _ => continue,\n-                };\n-\n-                let file = match (meta_item.name_or_empty(), meta_item.value_str()) {\n-                    (sym::natvis_file, Some(value)) => {\n-                        match resolve_path(&self.tcx.sess.parse_sess, value.as_str(), attr.span) {\n-                            Ok(file) => file,\n-                            Err(mut err) => {\n-                                err.emit();\n-                                continue;\n-                            }\n+                },\n+                _ => continue,\n+            };\n+\n+            let file = match (meta_item.name_or_empty(), meta_item.value_str()) {\n+                (sym::natvis_file, Some(value)) => {\n+                    match resolve_path(&tcx.sess.parse_sess, value.as_str(), attr.span) {\n+                        Ok(file) => file,\n+                        Err(mut err) => {\n+                            err.emit();\n+                            continue;\n                         }\n                     }\n-                    (_, _) => continue,\n+                }\n+                (_, _) => continue,\n+            };\n+\n+            if file.is_file() {\n+                let contents = match std::fs::read(&file) {\n+                    Ok(contents) => contents,\n+                    Err(err) => {\n+                        tcx\n+                            .sess\n+                            .struct_span_err(\n+                                attr.span,\n+                                &format!(\n+                                    \"Unable to read contents of file `{}`. {}\",\n+                                    file.display(),\n+                                    err\n+                                ),\n+                            )\n+                            .emit();\n+                        continue;\n+                    }\n                 };\n \n-                if file.is_file() {\n-                    let contents = match std::fs::read(&file) {\n-                        Ok(contents) => contents,\n-                        Err(err) => {\n-                            self.tcx\n-                                .sess\n-                                .struct_span_err(\n-                                    attr.span,\n-                                    &format!(\n-                                        \"Unable to read contents of file `{}`. {}\",\n-                                        file.display(),\n-                                        err\n-                                    ),\n-                                )\n-                                .emit();\n-                            continue;\n-                        }\n-                    };\n-\n-                    self.debugger_visualizers.insert(DebuggerVisualizerFile::new(\n-                        Arc::from(contents),\n-                        DebuggerVisualizerType::Natvis,\n-                    ));\n-                } else {\n-                    self.tcx\n-                        .sess\n-                        .struct_span_err(\n-                            attr.span,\n-                            &format!(\"{} is not a valid file\", file.display()),\n-                        )\n-                        .emit();\n-                }\n+                debugger_visualizers.insert(DebuggerVisualizerFile::new(\n+                    Arc::from(contents),\n+                    DebuggerVisualizerType::Natvis,\n+                ));\n+            } else {\n+                tcx\n+                    .sess\n+                    .struct_span_err(\n+                        attr.span,\n+                        &format!(\"{} is not a valid file\", file.display()),\n+                    )\n+                    .emit();\n             }\n         }\n     }\n@@ -114,17 +88,21 @@ fn debugger_visualizers<'tcx>(tcx: TyCtxt<'tcx>, cnum: CrateNum) -> Vec<Debugger\n     assert_eq!(cnum, LOCAL_CRATE);\n \n     // Initialize the collector.\n-    let mut collector = DebuggerVisualizerCollector::new(tcx);\n+    let mut debugger_visualizers = FxHashSet::default();\n \n     // Collect debugger visualizers in this crate.\n-    tcx.hir().visit_all_item_likes(&mut collector);\n+    for id in tcx.hir().items() {\n+        let target = Target::from_def_kind(tcx.def_kind(id.def_id));\n+        if let Target::Mod = target {\n+            check_for_debugger_visualizer(tcx, id.hir_id(), &mut debugger_visualizers);\n+        }\n+    }\n \n     // Collect debugger visualizers on the crate attributes.\n-    collector.check_for_debugger_visualizer(CRATE_HIR_ID);\n+    check_for_debugger_visualizer(tcx, CRATE_HIR_ID, &mut debugger_visualizers);\n \n-    // Extract out the found debugger_visualizer items.\n-    let DebuggerVisualizerCollector { debugger_visualizers, .. } = collector;\n \n+    // Extract out the found debugger_visualizer items.\n     let mut visualizers = debugger_visualizers.into_iter().collect::<Vec<_>>();\n \n     // Sort the visualizers so we always get a deterministic query result."}]}