{"sha": "4511f936b1b4766962d01a80f6887eecb30e89f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ1MTFmOTM2YjFiNDc2Njk2MmQwMWE4MGY2ODg3ZWVjYjMwZTg5Zjk=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-08T15:10:25Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-15T08:26:54Z"}, "message": "Hugely simplify iface handling\n\nWith the assumption of monomorphization", "tree": {"sha": "48b28b06700535ea112e7c8ea78dc088b7c2885d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48b28b06700535ea112e7c8ea78dc088b7c2885d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4511f936b1b4766962d01a80f6887eecb30e89f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4511f936b1b4766962d01a80f6887eecb30e89f9", "html_url": "https://github.com/rust-lang/rust/commit/4511f936b1b4766962d01a80f6887eecb30e89f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4511f936b1b4766962d01a80f6887eecb30e89f9/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "168398bb3dc01f8efecf734342af60a959a74b8d", "url": "https://api.github.com/repos/rust-lang/rust/commits/168398bb3dc01f8efecf734342af60a959a74b8d", "html_url": "https://github.com/rust-lang/rust/commit/168398bb3dc01f8efecf734342af60a959a74b8d"}], "stats": {"total": 457, "additions": 136, "deletions": 321}, "files": [{"sha": "40900e755b957b4167b4d1696b3cdf6570ec7b57", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=4511f936b1b4766962d01a80f6887eecb30e89f9", "patch": "@@ -548,11 +548,14 @@ fn encode_dict_origin(ecx: @e::encode_ctxt,\n                 }\n             }\n           }\n-          typeck::dict_iface(def_id) {\n+          typeck::dict_iface(def_id, tys) {\n             ebml_w.emit_enum_variant(\"dict_iface\", 1u, 3u) {||\n                 ebml_w.emit_enum_variant_arg(0u) {||\n                     ebml_w.emit_def_id(def_id)\n                 }\n+                ebml_w.emit_enum_variant_arg(1u) {||\n+                    ebml_w.emit_tys(ecx, tys);\n+                }\n             }\n           }\n         }\n@@ -596,6 +599,9 @@ impl helpers for ebml::ebml_deserializer {\n                     typeck::dict_iface(\n                         self.read_enum_variant_arg(0u) {||\n                             self.read_def_id(xcx)\n+                        },\n+                        self.read_enum_variant_arg(1u) {||\n+                            self.read_tys(xcx)\n                         }\n                     )\n                   }"}, {"sha": "f78c0ade6f1e4cbb704df71dc7eb5ee4549cb3ba", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=4511f936b1b4766962d01a80f6887eecb30e89f9", "patch": "@@ -258,7 +258,7 @@ fn get_impl_iface(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n }\n \n fn get_impl_method(cdata: cmd, id: ast::node_id, name: str) -> ast::def_id {\n-    let items = ebml::get_doc(ebml::new_doc(cdata.data), tag_items);\n+    let items = ebml::get_doc(ebml::doc(cdata.data), tag_items);\n     let found = none;\n     ebml::tagged_docs(find_item(id, items), tag_item_method) {|mid|\n         let m_did = parse_def_id(ebml::doc_data(mid));"}, {"sha": "e87e79be9229b1a5df6fefcad7354793507fe5be", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 16, "deletions": 52, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=4511f936b1b4766962d01a80f6887eecb30e89f9", "patch": "@@ -2070,7 +2070,6 @@ enum callee_env {\n     null_env,\n     is_closure,\n     self_env(ValueRef, ty::t),\n-    dict_env(ValueRef, ValueRef),\n }\n type lval_maybe_callee = {bcx: block,\n                           val: ValueRef,\n@@ -2117,8 +2116,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, substs: [ty::t],\n         }\n     });\n     let hash_id = @{def: fn_id, substs: substs, dicts: alt dicts {\n-      some(os) { vec::map(*os, {|o| impl::dict_id(ccx.tcx, o)}) }\n-      none { [] }\n+      some(os) { some_dicts(vec::map(*os, impl::vtable_id)) }\n+      none { no_dicts }\n     }};\n     alt ccx.monomorphized.find(hash_id) {\n       some(val) { ret some(val); }\n@@ -2258,10 +2257,8 @@ fn lval_static_fn(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n           none {\n             alt ccx.maps.dict_map.find(id) {\n               some(dicts) {\n-                alt impl::resolve_dicts_in_fn_ctxt(bcx.fcx, dicts) {\n-                  some(dicts) { monomorphic_fn(ccx, fn_id, tys, some(dicts)) }\n-                  none { none }\n-                }\n+                let rdicts = impl::resolve_vtables_in_fn_ctxt(bcx.fcx, dicts);\n+                monomorphic_fn(ccx, fn_id, tys, some(rdicts))\n               }\n               none { monomorphic_fn(ccx, fn_id, tys, none) }\n             }\n@@ -2567,7 +2564,7 @@ fn trans_lval(cx: block, e: @ast::expr) -> lval_result {\n \n fn lval_maybe_callee_to_lval(c: lval_maybe_callee, ty: ty::t) -> lval_result {\n     let must_bind = alt c.generic { generic_full(_) { true } _ { false } } ||\n-        alt c.env { self_env(_, _) | dict_env(_, _) { true } _ { false } };\n+        alt c.env { self_env(_, _) { true } _ { false } };\n     if must_bind {\n         let n_args = ty::ty_fn_args(ty).len();\n         let args = vec::from_elem(n_args, none);\n@@ -2779,28 +2776,7 @@ fn trans_args(cx: block, llenv: ValueRef,\n \n     let retty = ty::ty_fn_ret(fn_ty), full_retty = retty;\n     alt gen {\n-      generic_full(g) {\n-        lazily_emit_all_generic_info_tydesc_glues(ccx, g);\n-        let i = 0u, n_orig = 0u;\n-        for param in *g.param_bounds {\n-            lltydescs += [g.tydescs[i]];\n-            for bound in *param {\n-                alt bound {\n-                  ty::bound_iface(_) {\n-                    let res = impl::get_dict(\n-                        bcx, option::get(g.origins)[n_orig]);\n-                    lltydescs += [res.val];\n-                    bcx = res.bcx;\n-                    n_orig += 1u;\n-                  }\n-                  _ {}\n-                }\n-            }\n-            i += 1u;\n-        }\n-        args = ty::ty_fn_args(g.item_type);\n-        retty = ty::ty_fn_ret(g.item_type);\n-      }\n+      generic_full(g) { fail; }\n       generic_mono(t) {\n         args = ty::ty_fn_args(t);\n         retty = ty::ty_fn_ret(t);\n@@ -2884,17 +2860,12 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n         let bcx = f_res.bcx, ccx = cx.ccx();\n \n         let faddr = f_res.val;\n-        let llenv, dict_param = none;\n-        alt f_res.env {\n+        let llenv = alt f_res.env {\n           null_env {\n-            llenv = llvm::LLVMGetUndef(T_opaque_box_ptr(ccx));\n+            llvm::LLVMGetUndef(T_opaque_box_ptr(ccx))\n           }\n           self_env(e, _) {\n-            llenv = PointerCast(bcx, e, T_opaque_box_ptr(ccx));\n-          }\n-          dict_env(dict, e) {\n-            llenv = PointerCast(bcx, e, T_opaque_box_ptr(ccx));\n-            dict_param = some(dict);\n+            PointerCast(bcx, e, T_opaque_box_ptr(ccx))\n           }\n           is_closure {\n             // It's a closure. Have to fetch the elements\n@@ -2905,16 +2876,15 @@ fn trans_call_inner(in_cx: block, fn_expr_ty: ty::t,\n             faddr = GEPi(bcx, pair, [0, abi::fn_field_code]);\n             faddr = Load(bcx, faddr);\n             let llclosure = GEPi(bcx, pair, [0, abi::fn_field_box]);\n-            llenv = Load(bcx, llclosure);\n+            Load(bcx, llclosure)\n           }\n-        }\n+        };\n \n         let ret_ty = node_id_type(bcx, id);\n         let args_res =\n             trans_args(bcx, llenv, f_res.generic, args, fn_expr_ty, dest);\n         bcx = args_res.bcx;\n         let llargs = args_res.args;\n-        option::may(dict_param) {|dict| llargs = [dict] + llargs}\n         let llretslot = args_res.retslot;\n \n         /* If the block is terminated,\n@@ -2955,6 +2925,10 @@ fn invoke_(bcx: block, llfn: ValueRef, llargs: [ValueRef],\n     // cleanups to run\n     if bcx.unreachable { ret bcx; }\n     let normal_bcx = sub_block(bcx, \"normal return\");\n+    /*std::io::println(\"fn: \" + lib::llvm::type_to_str(bcx.ccx().tn, val_ty(llfn)));\n+    for a in llargs {\n+        std::io::println(\" a: \" + lib::llvm::type_to_str(bcx.ccx().tn, val_ty(a)));\n+    }*/\n     invoker(bcx, llfn, llargs, normal_bcx.llbb, get_landing_pad(bcx));\n     ret normal_bcx;\n }\n@@ -4791,16 +4765,6 @@ fn trans_constant(ccx: @crate_ctxt, it: @ast::item) {\n             i += 1;\n         }\n       }\n-      ast::item_impl(tps, some(@{node: ast::ty_path(_, id), _}), _, ms) {\n-        let i_did = ast_util::def_id_of_def(ccx.tcx.def_map.get(id));\n-        impl::trans_impl_vtable(ccx, item_path(ccx, it), i_did, ms, tps, it);\n-      }\n-      ast::item_iface(_, _) {\n-        if !vec::any(*ty::iface_methods(ccx.tcx, local_def(it.id)), {|m|\n-            ty::type_has_vars(ty::mk_fn(ccx.tcx, m.fty))}) {\n-            impl::trans_iface_vtable(ccx, item_path(ccx, it), it);\n-        }\n-      }\n       _ { }\n     }\n }\n@@ -5032,9 +4996,9 @@ fn trans_crate(sess: session::session, crate: @ast::crate, tcx: ty::ctxt,\n           discrims: ast_util::new_def_id_hash::<ValueRef>(),\n           discrim_symbols: int_hash::<str>(),\n           tydescs: ty::new_ty_hash(),\n-          dicts: map::hashmap(hash_dict_id, {|a, b| a == b}),\n           external: util::common::new_def_hash(),\n           monomorphized: map::hashmap(hash_mono_id, {|a, b| a == b}),\n+          vtables: map::hashmap(hash_mono_id, {|a, b| a == b}),\n           module_data: str_hash::<ValueRef>(),\n           lltypes: ty::new_ty_hash(),\n           names: new_namegen(),"}, {"sha": "63a3c067c5c89bb20ccc1d0a792ea6eeac1a221b", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=4511f936b1b4766962d01a80f6887eecb30e89f9", "patch": "@@ -515,26 +515,7 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n \n     // Figure out which tydescs we need to pass, if any.\n     let (outgoing_fty_real, lltydescs, param_bounds) = alt f_res.generic {\n-      generic_full(ginfo) {\n-        let tds = [], orig = 0u;\n-        vec::iter2(ginfo.tydescs, *ginfo.param_bounds) {|td, bounds|\n-            tds += [td];\n-            for bound in *bounds {\n-                alt bound {\n-                  ty::bound_iface(_) {\n-                    let dict = impl::get_dict(\n-                        bcx, option::get(ginfo.origins)[orig]);\n-                    tds += [PointerCast(bcx, dict.val, val_ty(td))];\n-                    orig += 1u;\n-                    bcx = dict.bcx;\n-                  }\n-                  _ {}\n-                }\n-            }\n-        }\n-        lazily_emit_all_generic_info_tydesc_glues(ccx, ginfo);\n-        (ginfo.item_type, tds, ginfo.param_bounds)\n-      }\n+      generic_full(ginfo) { fail; }\n       _ { (outgoing_fty, [], @[]) }\n     };\n \n@@ -560,9 +541,6 @@ fn trans_bind_1(cx: block, outgoing_fty: ty::t,\n       self_env(slf, slf_t) {\n         ([env_copy(slf, slf_t, owned)], target_self(f_res.val))\n       }\n-      dict_env(_, _) {\n-        ccx.sess.unimpl(\"binding of dynamic method calls\");\n-      }\n     };\n \n     // Actually construct the closure"}, {"sha": "7ee791f6213795da61ba571a676cdaace1eafdea", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=4511f936b1b4766962d01a80f6887eecb30e89f9", "patch": "@@ -90,11 +90,12 @@ type crate_ctxt = {\n      discrims: hashmap<ast::def_id, ValueRef>,\n      discrim_symbols: hashmap<ast::node_id, str>,\n      tydescs: hashmap<ty::t, @tydesc_info>,\n-     dicts: hashmap<dict_id, ValueRef>,\n      // Track mapping of external ids to local items imported for inlining\n      external: hashmap<ast::def_id, option<ast::node_id>>,\n      // Cache instances of monomorphized functions\n      monomorphized: hashmap<mono_id, {llfn: ValueRef, fty: ty::t}>,\n+     // Cache generated vtables\n+     vtables: hashmap<mono_id, ValueRef>,\n      module_data: hashmap<str, ValueRef>,\n      lltypes: hashmap<ty::t, TypeRef>,\n      names: namegen,\n@@ -846,30 +847,16 @@ pure fn type_has_static_size(cx: @crate_ctxt, t: ty::t) -> bool {\n     !ty::type_has_dynamic_size(cx.tcx, t)\n }\n \n-// Used to identify cached dictionaries\n-enum dict_param {\n-    dict_param_dict(dict_id),\n-    dict_param_ty(ty::t),\n-}\n-type dict_id = @{def: ast::def_id, params: [dict_param]};\n-fn hash_dict_id(&&dp: dict_id) -> uint {\n-    let h = syntax::ast_util::hash_def_id(dp.def);\n-    for param in dp.params {\n-        h = h << 2u;\n-        alt param {\n-          dict_param_dict(d) { h += hash_dict_id(d); }\n-          dict_param_ty(t) { h += ty::type_id(t); }\n-        }\n-    }\n-    h\n-}\n-\n // Used to identify cached monomorphized functions\n-type mono_id = @{def: ast::def_id, substs: [ty::t], dicts: [dict_id]};\n+enum mono_dicts { some_dicts([mono_id]), no_dicts }\n+type mono_id = @{def: ast::def_id, substs: [ty::t], dicts: mono_dicts};\n fn hash_mono_id(&&mi: mono_id) -> uint {\n     let h = syntax::ast_util::hash_def_id(mi.def);\n     for ty in mi.substs { h = (h << 2u) + ty::type_id(ty); }\n-    for dict in mi.dicts { h = (h << 2u) + hash_dict_id(dict); }\n+    alt mi.dicts {\n+      some_dicts(ds) { for d in ds { h = (h << 2u) + hash_mono_id(d); } }\n+      _ {}\n+    }\n     h\n }\n "}, {"sha": "ad37fee317c295554c437ef8ba21970e549cc7e7", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 91, "deletions": 220, "changes": 311, "blob_url": "https://github.com/rust-lang/rust/blob/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=4511f936b1b4766962d01a80f6887eecb30e89f9", "patch": "@@ -14,36 +14,6 @@ import lib::llvm::llvm::LLVMGetParam;\n import ast_map::{path, path_mod, path_name};\n import std::map::hashmap;\n \n-// Translation functionality related to impls and ifaces\n-//\n-// Terminology:\n-//  vtable:  a table of function pointers pointing to method wrappers\n-//           of an impl that implements an iface\n-//  dict:    a record containing a vtable pointer along with pointers to\n-//           all tydescs and other dicts needed to run methods in this vtable\n-//           (i.e. corresponding to the type parameters of the impl)\n-//  wrapper: a function that takes a dict as first argument, along\n-//           with the method-specific tydescs for a method (and all\n-//           other args the method expects), which fetches the extra\n-//           tydescs and dicts from the dict, splices them into the\n-//           arglist, and calls through to the actual method\n-//\n-// Generic functions take, along with their normal arguments, a number\n-// of extra tydesc and dict arguments -- one tydesc for each type\n-// parameter, one dict (following the tydesc in the arg order) for\n-// each interface bound on a type parameter.\n-//\n-// Most dicts are completely static, and are allocated and filled at\n-// compile time. Dicts that depend on run-time values (tydescs or\n-// dicts for type parameter types) are built at run-time, and interned\n-// through upcall_intern_dict in the runtime. This means that dict\n-// pointers are self-contained things that do not need to be cleaned\n-// up.\n-//\n-// The trans_constants pass in trans.rs outputs the vtables. Typeck\n-// annotates nodes with information about the methods and dicts that\n-// are referenced (ccx.method_map and ccx.dict_map).\n-\n fn trans_impl(ccx: @crate_ctxt, path: path, name: ast::ident,\n               methods: [@ast::method], tps: [ast::ty_param]) {\n     if tps.len() > 0u { ret; }\n@@ -81,18 +51,15 @@ fn trans_method_callee(bcx: block, callee_id: ast::node_id,\n         trans_static_callee(bcx, callee_id, self, did, none)\n       }\n       typeck::method_param(iid, off, p, b) {\n-        alt bcx.fcx.param_substs {\n+        alt check bcx.fcx.param_substs {\n           some(substs) {\n             trans_monomorphized_callee(bcx, callee_id, self,\n                                        iid, off, p, b, substs)\n           }\n-          none {\n-            trans_param_callee(bcx, callee_id, self, iid, off, p, b)\n-          }\n         }\n       }\n-      typeck::method_iface(iid, off) {\n-        trans_iface_callee(bcx, callee_id, self, iid, off)\n+      typeck::method_iface(_, off) {\n+        trans_iface_callee(bcx, self, callee_id, off)\n       }\n     }\n }\n@@ -115,39 +82,20 @@ fn wrapper_fn_ty(ccx: @crate_ctxt, dict_ty: TypeRef, fty: ty::t,\n }\n \n fn trans_vtable_callee(bcx: block, env: callee_env, dict: ValueRef,\n-                       callee_id: ast::node_id, iface_id: ast::def_id,\n-                       n_method: uint) -> lval_maybe_callee {\n+                       callee_id: ast::node_id, n_method: uint)\n+    -> lval_maybe_callee {\n     let bcx = bcx, ccx = bcx.ccx(), tcx = ccx.tcx;\n-    let method = ty::iface_methods(tcx, iface_id)[n_method];\n-    let method_ty = ty::mk_fn(tcx, method.fty);\n-    let {ty: fty, llty: llfty} =\n-        wrapper_fn_ty(ccx, val_ty(dict), method_ty, method.tps);\n-    let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n+    let fty = node_id_type(bcx, callee_id);\n+    let llfty = type_of::type_of_fn_from_ty(ccx, fty, []);\n+    let vtable = PointerCast(bcx, dict,\n                              T_ptr(T_array(T_ptr(llfty), n_method + 1u)));\n     let mptr = Load(bcx, GEPi(bcx, vtable, [0, n_method as int]));\n-    let generic = generic_none;\n-    if (*method.tps).len() > 0u || ty::type_has_params(fty) {\n-        let tydescs = [], tis = [];\n-        let tptys = node_id_type_params(bcx, callee_id);\n-        for t in vec::tailn(tptys, tptys.len() - (*method.tps).len()) {\n-            let ti = none;\n-            let td = get_tydesc(bcx, t, true, ti);\n-            tis += [ti];\n-            tydescs += [td.val];\n-            bcx = td.bcx;\n-        }\n-        generic = generic_full({item_type: fty,\n-                                static_tis: tis,\n-                                tydescs: tydescs,\n-                                param_bounds: method.tps,\n-                                origins: ccx.maps.dict_map.find(callee_id)});\n-    }\n     {bcx: bcx, val: mptr, kind: owned,\n      env: env,\n-     generic: generic}\n+     generic: generic_none}\n }\n \n-fn method_with_name(ccx: crate_ctxt, impl_id: ast::def_id,\n+fn method_with_name(ccx: @crate_ctxt, impl_id: ast::def_id,\n                     name: ast::ident) -> ast::def_id {\n     if impl_id.crate == ast::local_crate {\n         alt check ccx.tcx.items.get(impl_id.node) {\n@@ -172,38 +120,27 @@ fn trans_monomorphized_callee(bcx: block, callee_id: ast::node_id,\n         ret trans_static_callee(bcx, callee_id, base, mth_id,\n                                 some((tys, sub_origins)));\n       }\n-      typeck::dict_iface(iid) {\n-        ret trans_iface_callee(bcx, callee_id, base, iid, n_method);\n+      typeck::dict_iface(iid, tps) {\n+        ret trans_iface_callee(bcx, base, callee_id, n_method);\n       }\n       typeck::dict_param(n_param, n_bound) {\n         fail \"dict_param left in monomorphized function's dict substs\";\n       }\n     }\n }\n \n-\n-// Method callee where the dict comes from a type param\n-fn trans_param_callee(bcx: block, callee_id: ast::node_id,\n-                      base: @ast::expr, iface_id: ast::def_id, n_method: uint,\n-                      n_param: uint, n_bound: uint) -> lval_maybe_callee {\n-    let {bcx, val} = trans_self_arg(bcx, base);\n-    let dict = option::get(bcx.fcx.lltyparams[n_param].dicts)[n_bound];\n-    trans_vtable_callee(bcx, dict_env(dict, val), dict,\n-                        callee_id, iface_id, n_method)\n-}\n-\n // Method callee where the dict comes from a boxed iface\n-fn trans_iface_callee(bcx: block, callee_id: ast::node_id,\n-                      base: @ast::expr, iface_id: ast::def_id, n_method: uint)\n+fn trans_iface_callee(bcx: block, base: @ast::expr,\n+                      callee_id: ast::node_id, n_method: uint)\n     -> lval_maybe_callee {\n     let {bcx, val} = trans_temp_expr(bcx, base);\n     let dict = Load(bcx, PointerCast(bcx, GEPi(bcx, val, [0, 0]),\n                                      T_ptr(T_ptr(T_dict()))));\n     let box = Load(bcx, GEPi(bcx, val, [0, 1]));\n     // FIXME[impl] I doubt this is alignment-safe\n     let self = GEPi(bcx, box, [0, abi::box_field_body]);\n-    trans_vtable_callee(bcx, dict_env(dict, self), dict,\n-                        callee_id, iface_id, n_method)\n+    trans_vtable_callee(bcx, self_env(self, expr_ty(bcx, base)), dict,\n+                        callee_id, n_method)\n }\n \n fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n@@ -214,18 +151,6 @@ fn llfn_arg_tys(ft: TypeRef) -> {inputs: [TypeRef], output: TypeRef} {\n     {inputs: args, output: out_ty}\n }\n \n-fn trans_vtable(ccx: @crate_ctxt, id: ast::node_id, name: str,\n-                ptrs: [ValueRef]) {\n-    let tbl = C_struct(ptrs);\n-    let vt_gvar = str::as_c_str(name, {|buf|\n-        llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n-    });\n-    llvm::LLVMSetInitializer(vt_gvar, tbl);\n-    llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n-    ccx.item_vals.insert(id, vt_gvar);\n-    ccx.item_symbols.insert(id, name);\n-}\n-\n fn find_dict_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     -> typeck::dict_origin {\n     let dict_off = n_bound, i = 0u;\n@@ -241,150 +166,93 @@ fn find_dict_in_fn_ctxt(ps: param_substs, n_param: uint, n_bound: uint)\n     option::get(ps.dicts)[dict_off]\n }\n \n-fn resolve_dicts_in_fn_ctxt(fcx: fn_ctxt, dicts: typeck::dict_res)\n-    -> option<typeck::dict_res> {\n-    let result = [];\n-    for dict in *dicts {\n-        result += [alt dict {\n-          typeck::dict_static(iid, tys, sub) {\n-            alt resolve_dicts_in_fn_ctxt(fcx, sub) {\n-              some(sub) {\n-                let tys = alt fcx.param_substs {\n-                  some(substs) {\n-                    vec::map(tys, {|t|\n-                        ty::substitute_type_params(fcx.ccx.tcx, substs.tys, t)\n-                    })\n-                  }\n-                  _ { tys }\n-                };\n-                typeck::dict_static(iid, tys, sub)\n-              }\n-              none { ret none; }\n-            }\n+fn resolve_vtables_in_fn_ctxt(fcx: fn_ctxt, vts: typeck::dict_res)\n+    -> typeck::dict_res {\n+    @vec::map(*vts, {|d| resolve_vtable_in_fn_ctxt(fcx, d)})\n+}\n+\n+fn resolve_vtable_in_fn_ctxt(fcx: fn_ctxt, vt: typeck::dict_origin)\n+    -> typeck::dict_origin {\n+    alt vt {\n+      typeck::dict_static(iid, tys, sub) {\n+        let tys = alt fcx.param_substs {\n+          some(substs) {\n+            vec::map(tys, {|t|\n+                ty::substitute_type_params(fcx.ccx.tcx, substs.tys, t)\n+            })\n           }\n-          typeck::dict_param(n_param, n_bound) {\n-            alt fcx.param_substs {\n-              some(substs) {\n-                find_dict_in_fn_ctxt(substs, n_param, n_bound)\n-              }\n-              none { ret none; }\n-            }\n+          _ { tys }\n+        };\n+        typeck::dict_static(iid, tys, resolve_vtables_in_fn_ctxt(fcx, sub))\n+      }\n+      typeck::dict_param(n_param, n_bound) {\n+        alt check fcx.param_substs {\n+          some(substs) {\n+            find_dict_in_fn_ctxt(substs, n_param, n_bound)\n           }\n-          _ { dict }\n-        }];\n+        }\n+      }\n+      _ { vt }\n     }\n-    some(@result)\n }\n \n-fn trans_wrapper(ccx: @crate_ctxt, pt: path, llfty: TypeRef,\n-                 fill: fn(ValueRef, block) -> block)\n-    -> ValueRef {\n-    let name = link::mangle_internal_name_by_path(ccx, pt);\n-    let llfn = decl_internal_cdecl_fn(ccx.llmod, name, llfty);\n-    let fcx = new_fn_ctxt(ccx, [], llfn, none);\n-    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n-    let bcx = fill(llfn, bcx);\n-    build_return(bcx);\n-    finish_fn(fcx, lltop);\n-    ret llfn;\n+fn vtable_id(origin: typeck::dict_origin) -> mono_id {\n+    alt check origin {\n+      typeck::dict_static(impl_id, substs, sub_dicts) {\n+        @{def: impl_id, substs: substs,\n+          dicts: if (*sub_dicts).len() == 0u { no_dicts }\n+                 else { some_dicts(vec::map(*sub_dicts, vtable_id)) } }\n+      }\n+      typeck::dict_iface(iface_id, substs) {\n+        @{def: iface_id, substs: substs, dicts: no_dicts}\n+      }\n+    }\n }\n \n-fn trans_impl_wrapper(ccx: @crate_ctxt, pt: path,\n-                      extra_tps: [ty::param_bounds], real_fn: ValueRef)\n+fn get_vtable(ccx: @crate_ctxt, origin: typeck::dict_origin)\n     -> ValueRef {\n-    let {inputs: real_args, output: real_ret} =\n-        llfn_arg_tys(llvm::LLVMGetElementType(val_ty(real_fn)));\n-    let extra_ptrs = [];\n-    for tp in extra_tps {\n-        extra_ptrs += [T_ptr(ccx.tydesc_type)];\n-        for bound in *tp {\n-            alt bound {\n-              ty::bound_iface(_) { extra_ptrs += [T_ptr(T_dict())]; }\n-              _ {}\n-            }\n+    let hash_id = vtable_id(origin);\n+    alt ccx.vtables.find(hash_id) {\n+      some(val) { val }\n+      none {\n+        alt check origin {\n+          typeck::dict_static(id, substs, sub_dicts) {\n+            make_impl_vtable(ccx, id, substs, sub_dicts)\n+          }\n         }\n+      }\n     }\n-    let env_ty = T_ptr(T_struct([T_ptr(T_i8())] + extra_ptrs));\n-    let n_extra_ptrs = extra_ptrs.len();\n-\n-    let wrap_args = [T_ptr(T_dict())] +\n-        vec::slice(real_args, 0u, first_tp_arg) +\n-        vec::slice(real_args, first_tp_arg + n_extra_ptrs, real_args.len());\n-    let llfn_ty = T_fn(wrap_args, real_ret);\n-    trans_wrapper(ccx, pt, llfn_ty, {|llfn, bcx|\n-        let dict = PointerCast(bcx, LLVMGetParam(llfn, 0 as c_uint), env_ty);\n-        // retptr, self\n-        let args = [LLVMGetParam(llfn, 1 as c_uint),\n-                    LLVMGetParam(llfn, 2 as c_uint)];\n-        let i = 0u;\n-        // saved tydescs/dicts\n-        while i < n_extra_ptrs {\n-            i += 1u;\n-            args += [load_inbounds(bcx, dict, [0, i as int])];\n-        }\n-        // the rest of the parameters\n-        let j = 3u as c_uint;\n-        let params_total = llvm::LLVMCountParamTypes(llfn_ty);\n-        while j < params_total {\n-            args += [LLVMGetParam(llfn, j)];\n-            j += 1u as c_uint;\n-        }\n-        Call(bcx, real_fn, args);\n-        bcx\n-    })\n }\n \n-fn trans_impl_vtable(ccx: @crate_ctxt, pt: path,\n-                     iface_id: ast::def_id, ms: [@ast::method],\n-                     tps: [ast::ty_param], it: @ast::item) {\n-    if tps.len() > 0u { ret; }\n-    let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id)),\n-                       path_name(\"wrap\")];\n-    let extra_tps = param_bounds(ccx, tps);\n-    let ptrs = vec::map(*ty::iface_methods(ccx.tcx, iface_id), {|im|\n-        alt vec::find(ms, {|m| m.ident == im.ident}) {\n-          some(m) {\n-            trans_impl_wrapper(ccx, new_pt + [path_name(m.ident)],\n-                               extra_tps, get_item_val(ccx, m.id))\n-          }\n-          _ {\n-            ccx.sess.span_bug(it.span, \"no matching method \\\n-                                        in trans_impl_vtable\");\n-          }\n-        }\n+fn make_vtable(ccx: @crate_ctxt, ptrs: [ValueRef]) -> ValueRef {\n+    let tbl = C_struct(ptrs);\n+    let vt_gvar = str::as_c_str(ccx.names(\"vtable\"), {|buf|\n+        llvm::LLVMAddGlobal(ccx.llmod, val_ty(tbl), buf)\n     });\n-    let s = link::mangle_internal_name_by_path(\n-        ccx, new_pt + [path_name(\"!vtable\")]);\n-    trans_vtable(ccx, it.id, s, ptrs);\n+    llvm::LLVMSetInitializer(vt_gvar, tbl);\n+    llvm::LLVMSetGlobalConstant(vt_gvar, lib::llvm::True);\n+    lib::llvm::SetLinkage(vt_gvar, lib::llvm::InternalLinkage);\n+    vt_gvar\n }\n \n-fn trans_iface_wrapper(ccx: @crate_ctxt, pt: path, m: ty::method,\n-                       n: uint) -> ValueRef {\n-    let {llty: llfty, _} = wrapper_fn_ty(ccx, T_ptr(T_i8()),\n-                                         ty::mk_fn(ccx.tcx, m.fty), m.tps);\n-    trans_wrapper(ccx, pt, llfty, {|llfn, bcx|\n-        let param = PointerCast(bcx, LLVMGetParam(llfn, 2u as c_uint),\n-                                T_ptr(T_opaque_iface(ccx)));\n-        let dict = Load(bcx, GEPi(bcx, param, [0, 0]));\n-        let box = Load(bcx, GEPi(bcx, param, [0, 1]));\n-        let self = GEPi(bcx, box, [0, abi::box_field_body]);\n-        let vtable = PointerCast(bcx, Load(bcx, GEPi(bcx, dict, [0, 0])),\n-                                 T_ptr(T_array(T_ptr(llfty), n + 1u)));\n-        let mptr = Load(bcx, GEPi(bcx, vtable, [0, n as int]));\n-        let args = [PointerCast(bcx, dict, T_ptr(T_i8())),\n-                    LLVMGetParam(llfn, 1u as c_uint),\n-                    PointerCast(bcx, self, T_opaque_cbox_ptr(ccx))];\n-        let i = 3u as c_uint, total = llvm::LLVMCountParamTypes(llfty);\n-        while i < total {\n-            args += [LLVMGetParam(llfn, i)];\n-            i += 1u as c_uint;\n+fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n+                    dicts: typeck::dict_res) -> ValueRef {\n+    let tcx = ccx.tcx;\n+    let ifce_id = ty::ty_to_def_id(option::get(ty::impl_iface(tcx, impl_id)));\n+    make_vtable(ccx, vec::map(*ty::iface_methods(tcx, ifce_id), {|im|\n+        let fty = ty::substitute_type_params(tcx, substs,\n+                                             ty::mk_fn(tcx, im.fty));\n+        if (*im.tps).len() > 0u || ty::type_has_vars(fty) {\n+            C_null(type_of_fn_from_ty(ccx, fty, []))\n+        } else {\n+            let m_id = method_with_name(ccx, impl_id, im.ident);\n+            option::get(monomorphic_fn(ccx, m_id, substs, some(dicts))).llfn\n         }\n-        Call(bcx, mptr, args);\n-        bcx\n-    })\n+    }))\n }\n \n-fn trans_iface_vtable(ccx: @crate_ctxt, pt: path, it: @ast::item) {\n+/*\n+fn make_iface_vtable(ccx: @crate_ctxt, pt: path, it: @ast::item) {\n     let new_pt = pt + [path_name(it.ident), path_name(int::str(it.id))];\n     let i_did = local_def(it.id), i = 0u;\n     let ptrs = vec::map(*ty::iface_methods(ccx.tcx, i_did), {|m|\n@@ -528,6 +396,7 @@ fn get_dict_ptrs(bcx: block, origin: typeck::dict_origin)\n       }\n     }\n }\n+}*/\n \n fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     -> block {\n@@ -541,8 +410,10 @@ fn trans_cast(bcx: block, val: @ast::expr, id: ast::node_id, dest: dest)\n     let result = get_dest_addr(dest);\n     Store(bcx, box, PointerCast(bcx, GEPi(bcx, result, [0, 1]),\n                                 T_ptr(val_ty(box))));\n-    let {bcx, val: dict} = get_dict(bcx, ccx.maps.dict_map.get(id)[0]);\n-    Store(bcx, dict, PointerCast(bcx, GEPi(bcx, result, [0, 0]),\n-                                 T_ptr(val_ty(dict))));\n+    let orig = ccx.maps.dict_map.get(id)[0];\n+    let orig = resolve_vtable_in_fn_ctxt(bcx.fcx, orig);\n+    let vtable = get_vtable(bcx.ccx(), orig);\n+    Store(bcx, vtable, PointerCast(bcx, GEPi(bcx, result, [0, 0]),\n+                                   T_ptr(val_ty(vtable))));\n     bcx\n }"}, {"sha": "dc4ebe69d3a71a7b17c322a920ece6f6d1b7e7c9", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=4511f936b1b4766962d01a80f6887eecb30e89f9", "patch": "@@ -92,6 +92,7 @@ export region, re_named, re_caller, re_block, re_inferred;\n export get, type_has_params, type_has_vars, type_has_rptrs, type_id;\n export same_type;\n export ty_var_id;\n+export ty_to_def_id;\n export ty_fn_args;\n export type_constr;\n export kind, kind_sendable, kind_copyable, kind_noncopyable;\n@@ -2290,6 +2291,14 @@ fn impl_iface(cx: ctxt, id: ast::def_id) -> option<t> {\n     }\n }\n \n+fn ty_to_def_id(ty: t) -> ast::def_id {\n+    alt check get(ty).struct {\n+      ty_iface(id, _) | ty_class(id, _) | ty_res(id, _, _) | ty_enum(id, _) {\n+        id\n+      }\n+    }\n+}\n+\n // Enum information\n type variant_info = @{args: [t], ctor_ty: t, name: str,\n                       id: ast::def_id, disr_val: int};"}, {"sha": "9f1a2b73d9e63fb206c01b01dca31435dbd7f57e", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4511f936b1b4766962d01a80f6887eecb30e89f9/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=4511f936b1b4766962d01a80f6887eecb30e89f9", "patch": "@@ -34,7 +34,7 @@ enum dict_origin {\n     dict_static(ast::def_id, [ty::t], dict_res),\n     // Param number, bound number\n     dict_param(uint, uint),\n-    dict_iface(ast::def_id),\n+    dict_iface(ast::def_id, [ty::t]),\n }\n type dict_map = hashmap<ast::node_id, dict_res>;\n \n@@ -3361,8 +3361,8 @@ mod dict {\n                 }\n             }\n           }\n-          ty::ty_iface(did, _) if iface_id == did {\n-            ret dict_iface(did);\n+          ty::ty_iface(did, tps) if iface_id == did {\n+            ret dict_iface(did, tps);\n           }\n           _ {\n             let found = none;"}]}