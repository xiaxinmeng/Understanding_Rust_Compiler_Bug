{"sha": "f9be79603a90d4c30ad1ccadb82c4f3a772b432a", "node_id": "C_kwDOAAsO6NoAKGY5YmU3OTYwM2E5MGQ0YzMwYWQxY2NhZGI4MmM0ZjNhNzcyYjQzMmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-18T09:09:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-18T09:09:06Z"}, "message": "Auto merge of #14820 - HKalbasi:format-args, r=HKalbasi\n\nExpand `format_args!` with more details", "tree": {"sha": "bbd41d28c8ef9faffb4e6648de68db44da562c6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbd41d28c8ef9faffb4e6648de68db44da562c6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9be79603a90d4c30ad1ccadb82c4f3a772b432a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9be79603a90d4c30ad1ccadb82c4f3a772b432a", "html_url": "https://github.com/rust-lang/rust/commit/f9be79603a90d4c30ad1ccadb82c4f3a772b432a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9be79603a90d4c30ad1ccadb82c4f3a772b432a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4977e74de2bc9bf0913a56ceb1ec3b5aa5182ec", "url": "https://api.github.com/repos/rust-lang/rust/commits/e4977e74de2bc9bf0913a56ceb1ec3b5aa5182ec", "html_url": "https://github.com/rust-lang/rust/commit/e4977e74de2bc9bf0913a56ceb1ec3b5aa5182ec"}, {"sha": "5c83e222a3e001488a313e84a3e584ac0c773d8a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5c83e222a3e001488a313e84a3e584ac0c773d8a", "html_url": "https://github.com/rust-lang/rust/commit/5c83e222a3e001488a313e84a3e584ac0c773d8a"}], "stats": {"total": 272, "additions": 237, "deletions": 35}, "files": [{"sha": "f5346898c2029e80a8148291d7c47153200badc0", "filename": "crates/hir-def/src/macro_expansion_tests/builtin_fn_macro.rs", "status": "modified", "additions": 77, "deletions": 10, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/f9be79603a90d4c30ad1ccadb82c4f3a772b432a/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9be79603a90d4c30ad1ccadb82c4f3a772b432a/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fmacro_expansion_tests%2Fbuiltin_fn_macro.rs?ref=f9be79603a90d4c30ad1ccadb82c4f3a772b432a", "patch": "@@ -193,17 +193,17 @@ fn main() {\n     format_args!(\"{} {:?}\", arg1(a, b, c), arg2);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(arg2), $crate::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[\"\", \" \", ], &[$crate::fmt::ArgumentV1::new(&(arg1(a, b, c)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(arg2), $crate::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n     );\n }\n \n@@ -221,17 +221,84 @@ fn main() {\n     format_args!(\"{} {:?}\", a::<A,B>(), b);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n     ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n }\n \n fn main() {\n-    $crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Display::fmt), ]);\n+    $crate::fmt::Arguments::new_v1(&[\"\", \" \", ], &[$crate::fmt::ArgumentV1::new(&(a::<A, B>()), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_format_args_expand_with_raw_strings() {\n+    check(\n+        r##\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    format_args!(\n+        r#\"{},mismatch,\"{}\",\"{}\"\"#,\n+        location_csv_pat(db, &analysis, vfs, &sm, pat_id),\n+        mismatch.expected.display(db),\n+        mismatch.actual.display(db)\n+    );\n+}\n+\"##,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    $crate::fmt::Arguments::new_v1(&[r#\"\"#, r#\",mismatch,\"\"#, r#\"\",\"\"#, r#\"\"\"#, ], &[$crate::fmt::ArgumentV1::new(&(location_csv_pat(db, &analysis, vfs, &sm, pat_id)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(mismatch.expected.display(db)), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(mismatch.actual.display(db)), $crate::fmt::Display::fmt), ]);\n+}\n+\"##]],\n+    );\n+}\n+\n+#[test]\n+fn test_format_args_expand_eager() {\n+    check(\n+        r#\"\n+#[rustc_builtin_macro]\n+macro_rules! concat {}\n+\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    format_args!(concat!(\"xxx{}y\", \"{:?}zzz\"), 2, b);\n+}\n+\"#,\n+        expect![[r##\"\n+#[rustc_builtin_macro]\n+macro_rules! concat {}\n+\n+#[rustc_builtin_macro]\n+macro_rules! format_args {\n+    ($fmt:expr) => ({ /* compiler built-in */ });\n+    ($fmt:expr, $($args:tt)*) => ({ /* compiler built-in */ })\n+}\n+\n+fn main() {\n+    $crate::fmt::Arguments::new_v1(&[\"xxx\", \"y\", \"zzz\", ], &[$crate::fmt::ArgumentV1::new(&(2), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(b), $crate::fmt::Debug::fmt), ]);\n+}\n+\"##]],\n     );\n }\n \n@@ -250,7 +317,7 @@ fn main() {\n         format_args!/*+errors*/(\"{} {:?}\", a.);\n }\n \"#,\n-        expect![[r#\"\n+        expect![[r##\"\n #[rustc_builtin_macro]\n macro_rules! format_args {\n     ($fmt:expr) => ({ /* compiler built-in */ });\n@@ -259,10 +326,10 @@ macro_rules! format_args {\n \n fn main() {\n     let _ =\n-        /* parse error: expected field name or number */\n-$crate::fmt::Arguments::new_v1(&[], &[$crate::fmt::ArgumentV1::new(&(a.), $crate::fmt::Display::fmt), ]);\n+        /* error: no rule matches input tokens *//* parse error: expected field name or number */\n+$crate::fmt::Arguments::new_v1(&[\"\", \" \", ], &[$crate::fmt::ArgumentV1::new(&(a.), $crate::fmt::Display::fmt), $crate::fmt::ArgumentV1::new(&(), $crate::fmt::Debug::fmt), ]);\n }\n-\"#]],\n+\"##]],\n     );\n }\n "}, {"sha": "e9e1c6c3b3340a3296c0034dd591103b8f1954cd", "filename": "crates/hir-expand/src/builtin_fn_macro.rs", "status": "modified", "additions": 159, "deletions": 24, "changes": 183, "blob_url": "https://github.com/rust-lang/rust/blob/f9be79603a90d4c30ad1ccadb82c4f3a772b432a/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9be79603a90d4c30ad1ccadb82c4f3a772b432a/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fbuiltin_fn_macro.rs?ref=f9be79603a90d4c30ad1ccadb82c4f3a772b432a", "patch": "@@ -1,9 +1,13 @@\n //! Builtin macro\n \n+use std::mem;\n+\n+use ::tt::Ident;\n use base_db::{AnchoredPath, Edition, FileId};\n use cfg::CfgExpr;\n use either::Either;\n use mbe::{parse_exprs_with_sep, parse_to_token_tree, TokenMap};\n+use rustc_hash::FxHashMap;\n use syntax::{\n     ast::{self, AstToken},\n     SmolStr,\n@@ -90,11 +94,6 @@ register_builtin! {\n     (module_path, ModulePath) => module_path_expand,\n     (assert, Assert) => assert_expand,\n     (stringify, Stringify) => stringify_expand,\n-    (format_args, FormatArgs) => format_args_expand,\n-    (const_format_args, ConstFormatArgs) => format_args_expand,\n-    // format_args_nl only differs in that it adds a newline in the end,\n-    // so we use the same stub expansion for now\n-    (format_args_nl, FormatArgsNl) => format_args_expand,\n     (llvm_asm, LlvmAsm) => asm_expand,\n     (asm, Asm) => asm_expand,\n     (global_asm, GlobalAsm) => global_asm_expand,\n@@ -106,6 +105,9 @@ register_builtin! {\n     (trace_macros, TraceMacros) => trace_macros_expand,\n \n     EAGER:\n+    (format_args, FormatArgs) => format_args_expand,\n+    (const_format_args, ConstFormatArgs) => format_args_expand,\n+    (format_args_nl, FormatArgsNl) => format_args_nl_expand,\n     (compile_error, CompileError) => compile_error_expand,\n     (concat, Concat) => concat_expand,\n     (concat_idents, ConcatIdents) => concat_idents_expand,\n@@ -232,42 +234,175 @@ fn file_expand(\n }\n \n fn format_args_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<ExpandedEager> {\n+    format_args_expand_general(db, id, tt, \"\")\n+        .map(|x| ExpandedEager { subtree: x, included_file: None })\n+}\n+\n+fn format_args_nl_expand(\n+    db: &dyn ExpandDatabase,\n+    id: MacroCallId,\n+    tt: &tt::Subtree,\n+) -> ExpandResult<ExpandedEager> {\n+    format_args_expand_general(db, id, tt, \"\\\\n\")\n+        .map(|x| ExpandedEager { subtree: x, included_file: None })\n+}\n+\n+fn format_args_expand_general(\n     _db: &dyn ExpandDatabase,\n     _id: MacroCallId,\n     tt: &tt::Subtree,\n+    end_string: &str,\n ) -> ExpandResult<tt::Subtree> {\n-    // We expand `format_args!(\"\", a1, a2)` to\n-    // ```\n-    // $crate::fmt::Arguments::new_v1(&[], &[\n-    //   $crate::fmt::ArgumentV1::new(&arg1,$crate::fmt::Display::fmt),\n-    //   $crate::fmt::ArgumentV1::new(&arg2,$crate::fmt::Display::fmt),\n-    // ])\n-    // ```,\n-    // which is still not really correct, but close enough for now\n-    let mut args = parse_exprs_with_sep(tt, ',');\n+    let args = parse_exprs_with_sep(tt, ',');\n+\n+    let expand_error =\n+        ExpandResult::new(tt::Subtree::empty(), mbe::ExpandError::NoMatchingRule.into());\n \n     if args.is_empty() {\n-        return ExpandResult::new(tt::Subtree::empty(), mbe::ExpandError::NoMatchingRule.into());\n+        return expand_error;\n     }\n-    for arg in &mut args {\n+    let mut key_args = FxHashMap::default();\n+    let mut args = args.into_iter().filter_map(|mut arg| {\n         // Remove `key =`.\n         if matches!(arg.token_trees.get(1), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=')\n         {\n             // but not with `==`\n-            if !matches!(arg.token_trees.get(2), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=' )\n+            if !matches!(arg.token_trees.get(2), Some(tt::TokenTree::Leaf(tt::Leaf::Punct(p))) if p.char == '=')\n             {\n-                arg.token_trees.drain(..2);\n+                let key = arg.token_trees.drain(..2).next().unwrap();\n+                key_args.insert(key.to_string(), arg);\n+                return None;\n             }\n         }\n+        Some(arg)\n+    }).collect::<Vec<_>>().into_iter();\n+    // ^^^^^^^ we need this collect, to enforce the side effect of the filter_map closure (building the `key_args`)\n+    let format_subtree = args.next().unwrap();\n+    let format_string = (|| {\n+        let token_tree = format_subtree.token_trees.get(0)?;\n+        match token_tree {\n+            tt::TokenTree::Leaf(l) => match l {\n+                tt::Leaf::Literal(l) => {\n+                    if let Some(mut text) = l.text.strip_prefix('r') {\n+                        let mut raw_sharps = String::new();\n+                        while let Some(t) = text.strip_prefix('#') {\n+                            text = t;\n+                            raw_sharps.push('#');\n+                        }\n+                        text =\n+                            text.strip_suffix(&raw_sharps)?.strip_prefix('\"')?.strip_suffix('\"')?;\n+                        Some((text, l.span, Some(raw_sharps)))\n+                    } else {\n+                        let text = l.text.strip_prefix('\"')?.strip_suffix('\"')?;\n+                        let span = l.span;\n+                        Some((text, span, None))\n+                    }\n+                }\n+                _ => None,\n+            },\n+            tt::TokenTree::Subtree(_) => None,\n+        }\n+    })();\n+    let Some((format_string, _format_string_span, raw_sharps)) = format_string else {\n+        return expand_error;\n+    };\n+    let mut format_iter = format_string.chars().peekable();\n+    let mut parts = vec![];\n+    let mut last_part = String::new();\n+    let mut arg_tts = vec![];\n+    let mut err = None;\n+    while let Some(c) = format_iter.next() {\n+        // Parsing the format string. See https://doc.rust-lang.org/std/fmt/index.html#syntax for the grammar and more info\n+        match c {\n+            '{' => {\n+                if format_iter.peek() == Some(&'{') {\n+                    format_iter.next();\n+                    last_part.push('{');\n+                    continue;\n+                }\n+                let mut argument = String::new();\n+                while ![Some(&'}'), Some(&':')].contains(&format_iter.peek()) {\n+                    argument.push(match format_iter.next() {\n+                        Some(c) => c,\n+                        None => return expand_error,\n+                    });\n+                }\n+                let format_spec = match format_iter.next().unwrap() {\n+                    '}' => \"\".to_owned(),\n+                    ':' => {\n+                        let mut s = String::new();\n+                        while let Some(c) = format_iter.next() {\n+                            if c == '}' {\n+                                break;\n+                            }\n+                            s.push(c);\n+                        }\n+                        s\n+                    }\n+                    _ => unreachable!(),\n+                };\n+                parts.push(mem::take(&mut last_part));\n+                let arg_tree = if argument.is_empty() {\n+                    match args.next() {\n+                        Some(x) => x,\n+                        None => {\n+                            err = Some(mbe::ExpandError::NoMatchingRule.into());\n+                            tt::Subtree::empty()\n+                        }\n+                    }\n+                } else if let Some(tree) = key_args.get(&argument) {\n+                    tree.clone()\n+                } else {\n+                    // FIXME: we should pick the related substring of the `_format_string_span` as the span. You\n+                    // can use `.char_indices()` instead of `.char()` for `format_iter` to find the substring interval.\n+                    let ident = Ident::new(argument, tt::TokenId::unspecified());\n+                    quote!(#ident)\n+                };\n+                let formatter = match &*format_spec {\n+                    \"?\" => quote!(#DOLLAR_CRATE::fmt::Debug::fmt),\n+                    \"\" => quote!(#DOLLAR_CRATE::fmt::Display::fmt),\n+                    _ => {\n+                        // FIXME: implement the rest and return expand error here\n+                        quote!(#DOLLAR_CRATE::fmt::Display::fmt)\n+                    }\n+                };\n+                arg_tts.push(\n+                    quote! { #DOLLAR_CRATE::fmt::ArgumentV1::new(&(#arg_tree), #formatter), },\n+                );\n+            }\n+            '}' => {\n+                if format_iter.peek() == Some(&'}') {\n+                    format_iter.next();\n+                    last_part.push('}');\n+                } else {\n+                    return expand_error;\n+                }\n+            }\n+            _ => last_part.push(c),\n+        }\n+    }\n+    last_part += end_string;\n+    if !last_part.is_empty() {\n+        parts.push(last_part);\n     }\n-    let _format_string = args.remove(0);\n-    let arg_tts = args.into_iter().flat_map(|arg| {\n-        quote! { #DOLLAR_CRATE::fmt::ArgumentV1::new(&(#arg), #DOLLAR_CRATE::fmt::Display::fmt), }\n-    }.token_trees);\n+    let part_tts = parts.into_iter().map(|x| {\n+        let text = if let Some(raw) = &raw_sharps {\n+            format!(\"r{raw}\\\"{}\\\"{raw}\", x).into()\n+        } else {\n+            format!(\"\\\"{}\\\"\", x).into()\n+        };\n+        let l = tt::Literal { span: tt::TokenId::unspecified(), text };\n+        quote!(#l ,)\n+    });\n+    let arg_tts = arg_tts.into_iter().flat_map(|arg| arg.token_trees);\n     let expanded = quote! {\n-        #DOLLAR_CRATE::fmt::Arguments::new_v1(&[], &[##arg_tts])\n+        #DOLLAR_CRATE::fmt::Arguments::new_v1(&[##part_tts], &[##arg_tts])\n     };\n-    ExpandResult::ok(expanded)\n+    ExpandResult { value: expanded, err }\n }\n \n fn asm_expand("}, {"sha": "327e1502d19e0a08b42482645c44ef6512e3109e", "filename": "crates/ide/src/syntax_highlighting/test_data/highlight_strings.html", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f9be79603a90d4c30ad1ccadb82c4f3a772b432a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "raw_url": "https://github.com/rust-lang/rust/raw/f9be79603a90d4c30ad1ccadb82c4f3a772b432a/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsyntax_highlighting%2Ftest_data%2Fhighlight_strings.html?ref=f9be79603a90d4c30ad1ccadb82c4f3a772b432a", "patch": "@@ -171,5 +171,5 @@\n     <span class=\"macro\">assert</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"bool_literal macro\">true</span><span class=\"comma macro\">,</span> <span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\"> asdasd\"</span><span class=\"comma macro\">,</span> <span class=\"numeric_literal macro\">1</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n     <span class=\"macro\">toho</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">fmt\"</span><span class=\"comma macro\">,</span> <span class=\"numeric_literal macro\">0</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n     <span class=\"macro unsafe\">asm</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"string_literal macro\">\"mov eax, </span><span class=\"format_specifier\">{</span><span class=\"numeric_literal\">0</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">\"</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n-    <span class=\"macro\">format_args</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"none macro\">concat</span><span class=\"punctuation macro\">!</span><span class=\"parenthesis macro\">(</span><span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">\"</span><span class=\"parenthesis macro\">)</span><span class=\"comma macro\">,</span> <span class=\"string_literal macro\">\"{}\"</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n+    <span class=\"macro\">format_args</span><span class=\"macro_bang\">!</span><span class=\"parenthesis macro\">(</span><span class=\"none macro\">concat</span><span class=\"punctuation macro\">!</span><span class=\"parenthesis macro\">(</span><span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">\"</span><span class=\"parenthesis macro\">)</span><span class=\"comma macro\">,</span> <span class=\"string_literal macro\">\"</span><span class=\"format_specifier\">{</span><span class=\"format_specifier\">}</span><span class=\"string_literal macro\">\"</span><span class=\"parenthesis macro\">)</span><span class=\"semicolon\">;</span>\n <span class=\"brace\">}</span></code></pre>\n\\ No newline at end of file"}]}