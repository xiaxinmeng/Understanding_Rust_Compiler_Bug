{"sha": "3c04fda751352fe00884782e7adf792a5e2a91c4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNjMDRmZGE3NTEzNTJmZTAwODg0NzgyZTdhZGY3OTJhNWUyYTkxYzQ=", "commit": {"author": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-18T14:45:35Z"}, "committer": {"name": "Mark Rousskov", "email": "mark.simulacrum@gmail.com", "date": "2020-03-20T13:43:40Z"}, "message": "Make functions dependent only on shared root avoidance safe", "tree": {"sha": "2def34d13f373442fd22b31ae1e37637452d45c9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2def34d13f373442fd22b31ae1e37637452d45c9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3c04fda751352fe00884782e7adf792a5e2a91c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3c04fda751352fe00884782e7adf792a5e2a91c4", "html_url": "https://github.com/rust-lang/rust/commit/3c04fda751352fe00884782e7adf792a5e2a91c4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3c04fda751352fe00884782e7adf792a5e2a91c4/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1c44f852df205ae6d363cc9a2b12f8093b3ed342", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c44f852df205ae6d363cc9a2b12f8093b3ed342", "html_url": "https://github.com/rust-lang/rust/commit/1c44f852df205ae6d363cc9a2b12f8093b3ed342"}], "stats": {"total": 116, "additions": 58, "deletions": 58}, "files": [{"sha": "21f99257d81d0fea68778e113a4285dfc510ee61", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3c04fda751352fe00884782e7adf792a5e2a91c4/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c04fda751352fe00884782e7adf792a5e2a91c4/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=3c04fda751352fe00884782e7adf792a5e2a91c4", "patch": "@@ -1349,7 +1349,8 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         self.fix_top();\n     }\n \n-    /// If the root node is the shared root node, allocate our own node.\n+    /// If the root node is the empty (non-allocated) root node, allocate our\n+    /// own node.\n     fn ensure_root_is_owned(&mut self) {\n         if self.root.is_none() {\n             self.root = Some(node::Root::new_leaf());\n@@ -1509,7 +1510,6 @@ impl<K, V> Drop for IntoIter<K, V> {\n                 // don't have to care about panics this time (they'll abort).\n                 while let Some(_) = self.0.next() {}\n \n-                // No need to avoid the shared root, because the tree was definitely not empty.\n                 unsafe {\n                     let mut node =\n                         unwrap_unchecked(ptr::read(&self.0.front)).into_node().forget_type();"}, {"sha": "99f531264ba2076bbe951ff5a97e49f8de24102e", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 54, "deletions": 53, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/3c04fda751352fe00884782e7adf792a5e2a91c4/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c04fda751352fe00884782e7adf792a5e2a91c4/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=3c04fda751352fe00884782e7adf792a5e2a91c4", "patch": "@@ -169,8 +169,9 @@ impl<K, V> BoxedNode<K, V> {\n     }\n }\n \n-/// Either an owned tree or a shared, empty tree.  Note that this does not have a destructor,\n-/// and must be cleaned up manually if it is an owned tree.\n+/// An owned tree.\n+///\n+/// Note that this does not have a destructor, and must be cleaned up manually.\n pub struct Root<K, V> {\n     node: BoxedNode<K, V>,\n     /// The number of levels below the root node.\n@@ -278,10 +279,7 @@ impl<K, V> Root<K, V> {\n ///   `Leaf`, the `NodeRef` points to a leaf node, when this is `Internal` the\n ///   `NodeRef` points to an internal node, and when this is `LeafOrInternal` the\n ///   `NodeRef` could be pointing to either type of node.\n-///   Note that in case of a leaf node, this might still be the shared root!\n-///   Only turn this into a `LeafNode` reference if you know it is not the shared root!\n-///   Shared references must be dereferenceable *for the entire size of their pointee*,\n-///   so '&LeafNode` or `&InternalNode` pointing to the shared root is undefined behavior.\n+///\n ///   Turning this into a `NodeHeader` reference is always safe.\n pub struct NodeRef<BorrowType, K, V, Type> {\n     /// The number of levels below the node.\n@@ -344,29 +342,28 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n         NodeRef { height: self.height, node: self.node, root: self.root, _marker: PhantomData }\n     }\n \n-    /// Exposes the leaf \"portion\" of any leaf or internal node that is not the shared root.\n+    /// Exposes the leaf \"portion\" of any leaf or internal node.\n     /// If the node is a leaf, this function simply opens up its data.\n     /// If the node is an internal node, so not a leaf, it does have all the data a leaf has\n     /// (header, keys and values), and this function exposes that.\n-    /// Unsafe because the node must not be the shared root. For more information,\n-    /// see the `NodeRef` comments.\n-    unsafe fn as_leaf(&self) -> &LeafNode<K, V> {\n-        self.node.as_ref()\n+    fn as_leaf(&self) -> &LeafNode<K, V> {\n+        // The node must be valid for at least the LeafNode portion.\n+        // This is not a reference in the NodeRef type because we don't know if\n+        // it should be unique or shared.\n+        unsafe { self.node.as_ref() }\n     }\n \n     fn as_header(&self) -> &NodeHeader<K, V> {\n         unsafe { &*(self.node.as_ptr() as *const NodeHeader<K, V>) }\n     }\n \n     /// Borrows a view into the keys stored in the node.\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    pub unsafe fn keys(&self) -> &[K] {\n+    pub fn keys(&self) -> &[K] {\n         self.reborrow().into_key_slice()\n     }\n \n     /// Borrows a view into the values stored in the node.\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn vals(&self) -> &[V] {\n+    fn vals(&self) -> &[V] {\n         self.reborrow().into_val_slice()\n     }\n \n@@ -470,39 +467,37 @@ impl<'a, K, V, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n     /// (header, keys and values), and this function exposes that.\n     ///\n     /// Returns a raw ptr to avoid asserting exclusive access to the entire node.\n-    /// This also implies you can invoke this member on the shared root, but the resulting pointer\n-    /// might not be properly aligned and definitely would not allow accessing keys and values.\n     fn as_leaf_mut(&mut self) -> *mut LeafNode<K, V> {\n         self.node.as_ptr()\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn keys_mut(&mut self) -> &mut [K] {\n-        self.reborrow_mut().into_key_slice_mut()\n+    fn keys_mut(&mut self) -> &mut [K] {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the key slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.reborrow_mut().into_key_slice_mut() }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn vals_mut(&mut self) -> &mut [V] {\n-        self.reborrow_mut().into_val_slice_mut()\n+    fn vals_mut(&mut self) -> &mut [V] {\n+        // SAFETY: the caller will not be able to call further methods on self\n+        // until the value slice reference is dropped, as we have unique access\n+        // for the lifetime of the borrow.\n+        unsafe { self.reborrow_mut().into_val_slice_mut() }\n     }\n }\n \n impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Immut<'a>, K, V, Type> {\n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_key_slice(self) -> &'a [K] {\n-        // We cannot be the shared root, so `as_leaf` is okay.\n-        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len())\n+    fn into_key_slice(self) -> &'a [K] {\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().keys), self.len()) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_val_slice(self) -> &'a [V] {\n-        // We cannot be the shared root, so `as_leaf` is okay.\n-        slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len())\n+    fn into_val_slice(self) -> &'a [V] {\n+        unsafe { slice::from_raw_parts(MaybeUninit::first_ptr(&self.as_leaf().vals), self.len()) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_slices(self) -> (&'a [K], &'a [V]) {\n-        let k = ptr::read(&self);\n+    fn into_slices(self) -> (&'a [K], &'a [V]) {\n+        // SAFETY: equivalent to reborrow() except not requiring Type: 'a\n+        let k = unsafe { ptr::read(&self) };\n         (k.into_key_slice(), self.into_val_slice())\n     }\n }\n@@ -514,34 +509,41 @@ impl<'a, K: 'a, V: 'a, Type> NodeRef<marker::Mut<'a>, K, V, Type> {\n         unsafe { &mut *(self.root as *mut Root<K, V>) }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_key_slice_mut(mut self) -> &'a mut [K] {\n-        // We cannot be the shared root, so `as_leaf_mut` is okay.\n-        slice::from_raw_parts_mut(\n-            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n-            self.len(),\n-        )\n+    fn into_key_slice_mut(mut self) -> &'a mut [K] {\n+        // SAFETY: The keys of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).keys),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_val_slice_mut(mut self) -> &'a mut [V] {\n-        slice::from_raw_parts_mut(\n-            MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n-            self.len(),\n-        )\n+    fn into_val_slice_mut(mut self) -> &'a mut [V] {\n+        // SAFETY: The values of a node must always be initialized up to length.\n+        unsafe {\n+            slice::from_raw_parts_mut(\n+                MaybeUninit::first_ptr_mut(&mut (*self.as_leaf_mut()).vals),\n+                self.len(),\n+            )\n+        }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n+    fn into_slices_mut(mut self) -> (&'a mut [K], &'a mut [V]) {\n         // We cannot use the getters here, because calling the second one\n         // invalidates the reference returned by the first.\n         // More precisely, it is the call to `len` that is the culprit,\n         // because that creates a shared reference to the header, which *can*\n         // overlap with the keys (and even the values, for ZST keys).\n         let len = self.len();\n         let leaf = self.as_leaf_mut();\n-        let keys = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len);\n-        let vals = slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len);\n+        // SAFETY: The keys and values of a node must always be initialized up to length.\n+        let keys = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).keys), len)\n+        };\n+        let vals = unsafe {\n+            slice::from_raw_parts_mut(MaybeUninit::first_ptr_mut(&mut (*leaf).vals), len)\n+        };\n         (keys, vals)\n     }\n }\n@@ -698,8 +700,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal> {\n         }\n     }\n \n-    /// Unsafe because the caller must ensure that the node is not the shared root.\n-    unsafe fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n+    fn into_kv_pointers_mut(mut self) -> (*mut K, *mut V) {\n         (self.keys_mut().as_mut_ptr(), self.vals_mut().as_mut_ptr())\n     }\n }"}, {"sha": "4e80f7f21ebff5c6817a82f9e9436acf3ea5d9d2", "filename": "src/liballoc/collections/btree/search.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3c04fda751352fe00884782e7adf792a5e2a91c4/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3c04fda751352fe00884782e7adf792a5e2a91c4/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fsearch.rs?ref=3c04fda751352fe00884782e7adf792a5e2a91c4", "patch": "@@ -67,12 +67,11 @@ where\n     Q: Ord,\n     K: Borrow<Q>,\n {\n-    // This function is defined over all borrow types (immutable, mutable, owned),\n-    // and may be called on the shared root in each case.\n+    // This function is defined over all borrow types (immutable, mutable, owned).\n     // Using `keys()` is fine here even if BorrowType is mutable, as all we return\n     // is an index -- not a reference.\n     let len = node.len();\n-    let keys = unsafe { node.keys() }; // safe because a non-empty node cannot be the shared root\n+    let keys = node.keys();\n     for (i, k) in keys.iter().enumerate() {\n         match key.cmp(k.borrow()) {\n             Ordering::Greater => {}"}]}