{"sha": "a1bb0a182c94595f8af6cb84b27f6121b59d0ac8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmExYmIwYTE4MmM5NDU5NWY4YWY2Y2I4NGIyN2Y2MTIxYjU5ZDBhYzg=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-17T12:44:39Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-17T13:31:28Z"}, "message": "Rollup merge of #24475 - arielb1:i24363-hacky-hack, r=pnkfelix\n\n Fix #24363", "tree": {"sha": "572ad93abdbdb723ccf3807c4cfc6de477c92eed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/572ad93abdbdb723ccf3807c4cfc6de477c92eed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8", "html_url": "https://github.com/rust-lang/rust/commit/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c4995f694ef38283d631fd4c242417360fc78ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c4995f694ef38283d631fd4c242417360fc78ee", "html_url": "https://github.com/rust-lang/rust/commit/9c4995f694ef38283d631fd4c242417360fc78ee"}, {"sha": "fd8c592757144b8d0655aaf1ff3dd3c5b8b16a80", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd8c592757144b8d0655aaf1ff3dd3c5b8b16a80", "html_url": "https://github.com/rust-lang/rust/commit/fd8c592757144b8d0655aaf1ff3dd3c5b8b16a80"}], "stats": {"total": 136, "additions": 77, "deletions": 59}, "files": [{"sha": "650f40a8291b40cb4739af888af78109a6092ef0", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=a1bb0a182c94595f8af6cb84b27f6121b59d0ac8", "patch": "@@ -810,8 +810,12 @@ impl<'tcx> Repr<'tcx> for ty::TraitRef<'tcx> {\n         // to enumerate the `for<...>` etc because the debruijn index\n         // tells you everything you need to know.\n         let base = ty::item_path_str(tcx, self.def_id);\n-        parameterized(tcx, &base, self.substs, self.def_id, &[],\n-                      || ty::lookup_trait_def(tcx, self.def_id).generics.clone())\n+        let result = parameterized(tcx, &base, self.substs, self.def_id, &[],\n+                      || ty::lookup_trait_def(tcx, self.def_id).generics.clone());\n+        match self.substs.self_ty() {\n+            None => result,\n+            Some(sty) => format!(\"<{} as {}>\", sty.repr(tcx), result)\n+        }\n     }\n }\n \n@@ -1504,8 +1508,7 @@ impl<'tcx> UserString<'tcx> for ty::ProjectionPredicate<'tcx> {\n \n impl<'tcx> Repr<'tcx> for ty::ProjectionTy<'tcx> {\n     fn repr(&self, tcx: &ctxt<'tcx>) -> String {\n-        format!(\"<{} as {}>::{}\",\n-                self.trait_ref.substs.self_ty().repr(tcx),\n+        format!(\"{}::{}\",\n                 self.trait_ref.repr(tcx),\n                 self.item_name.repr(tcx))\n     }"}, {"sha": "fa76dc167f2abe2eaf59f2694c185f6583f84359", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=a1bb0a182c94595f8af6cb84b27f6121b59d0ac8", "patch": "@@ -3542,34 +3542,34 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n       }\n       ast::ExprIndex(ref base, ref idx) => {\n           check_expr_with_lvalue_pref(fcx, &**base, lvalue_pref);\n+          check_expr(fcx, &**idx);\n+\n           let base_t = fcx.expr_ty(&**base);\n+          let idx_t = fcx.expr_ty(&**idx);\n+\n           if ty::type_is_error(base_t) {\n               fcx.write_ty(id, base_t);\n+          } else if ty::type_is_error(idx_t) {\n+              fcx.write_ty(id, idx_t);\n           } else {\n-              check_expr(fcx, &**idx);\n-              let idx_t = fcx.expr_ty(&**idx);\n-              if ty::type_is_error(idx_t) {\n-                  fcx.write_ty(id, idx_t);\n-              } else {\n-                  let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n-                  match lookup_indexing(fcx, expr, base, base_t, idx_t, lvalue_pref) {\n-                      Some((index_ty, element_ty)) => {\n-                          let idx_expr_ty = fcx.expr_ty(idx);\n-                          demand::eqtype(fcx, expr.span, index_ty, idx_expr_ty);\n-                          fcx.write_ty(id, element_ty);\n-                      }\n-                      None => {\n-                          check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n-                          fcx.type_error_message(\n-                              expr.span,\n-                              |actual| {\n-                                  format!(\"cannot index a value of type `{}`\",\n-                                          actual)\n-                              },\n-                              base_t,\n-                              None);\n-                          fcx.write_ty(id, fcx.tcx().types.err);\n-                      }\n+              let base_t = structurally_resolved_type(fcx, expr.span, base_t);\n+              match lookup_indexing(fcx, expr, base, base_t, idx_t, lvalue_pref) {\n+                  Some((index_ty, element_ty)) => {\n+                      let idx_expr_ty = fcx.expr_ty(idx);\n+                      demand::eqtype(fcx, expr.span, index_ty, idx_expr_ty);\n+                      fcx.write_ty(id, element_ty);\n+                  }\n+                  None => {\n+                      check_expr_has_type(fcx, &**idx, fcx.tcx().types.err);\n+                      fcx.type_error_message(\n+                          expr.span,\n+                          |actual| {\n+                              format!(\"cannot index a value of type `{}`\",\n+                                      actual)\n+                          },\n+                          base_t,\n+                          None);\n+                      fcx.write_ty(id, fcx.tcx().types.err);\n                   }\n               }\n           }"}, {"sha": "889975f0eb2f97e2f2c4701b1c5b6c2d147a4d9d", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 30, "deletions": 31, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=a1bb0a182c94595f8af6cb84b27f6121b59d0ac8", "patch": "@@ -85,6 +85,32 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn tcx(&self) -> &'cx ty::ctxt<'tcx> {\n         self.fcx.tcx()\n     }\n+\n+    // Hacky hack: During type-checking, we treat *all* operators\n+    // as potentially overloaded. But then, during writeback, if\n+    // we observe that something like `a+b` is (known to be)\n+    // operating on scalars, we clear the overload.\n+    fn fix_scalar_binary_expr(&mut self, e: &ast::Expr) {\n+        if let ast::ExprBinary(ref op, ref lhs, ref rhs) = e.node {\n+            let lhs_ty = self.fcx.node_ty(lhs.id);\n+            let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n+\n+            let rhs_ty = self.fcx.node_ty(rhs.id);\n+            let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n+\n+            if ty::type_is_scalar(lhs_ty) && ty::type_is_scalar(rhs_ty) {\n+                self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n+\n+                // weird but true: the by-ref binops put an\n+                // adjustment on the lhs but not the rhs; the\n+                // adjustment for rhs is kind of baked into the\n+                // system.\n+                if !ast_util::is_by_value_binop(op.node) {\n+                    self.fcx.inh.adjustments.borrow_mut().remove(&lhs.id);\n+                }\n+            }\n+        }\n+    }\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -114,43 +140,16 @@ impl<'cx, 'tcx, 'v> Visitor<'v> for WritebackCx<'cx, 'tcx> {\n             return;\n         }\n \n-        // Hacky hack: During type-checking, we treat *all* operators\n-        // as potentially overloaded. But then, during writeback, if\n-        // we observe that something like `a+b` is (known to be)\n-        // operating on scalars, we clear the overload.\n-        match e.node {\n-            ast::ExprBinary(ref op, ref lhs, ref rhs) => {\n-                let lhs_ty = self.fcx.expr_ty(lhs);\n-                let lhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&lhs_ty);\n-                let rhs_ty = self.fcx.expr_ty(rhs);\n-                let rhs_ty = self.fcx.infcx().resolve_type_vars_if_possible(&rhs_ty);\n-                if ty::type_is_scalar(lhs_ty) && ty::type_is_scalar(rhs_ty) {\n-                    self.fcx.inh.method_map.borrow_mut().remove(&MethodCall::expr(e.id));\n-\n-                    // weird but true: the by-ref binops put an\n-                    // adjustment on the lhs but not the rhs; the\n-                    // adjustment for rhs is kind of baked into the\n-                    // system.\n-                    if !ast_util::is_by_value_binop(op.node) {\n-                        self.fcx.inh.adjustments.borrow_mut().remove(&lhs.id);\n-                    }\n-                }\n-            }\n-            _ => { }\n-        }\n+        self.fix_scalar_binary_expr(e);\n \n         self.visit_node_id(ResolvingExpr(e.span), e.id);\n         self.visit_method_map_entry(ResolvingExpr(e.span),\n                                     MethodCall::expr(e.id));\n \n-        match e.node {\n-            ast::ExprClosure(_, ref decl, _) => {\n-                for input in &decl.inputs {\n-                    let _ = self.visit_node_id(ResolvingExpr(e.span),\n-                                               input.id);\n-                }\n+        if let ast::ExprClosure(_, ref decl, _) = e.node {\n+            for input in &decl.inputs {\n+                self.visit_node_id(ResolvingExpr(e.span), input.id);\n             }\n-            _ => {}\n         }\n \n         visit::walk_expr(self, e);"}, {"sha": "590c464371c0608e79ddf91316710d1c3d8b20a6", "filename": "src/test/compile-fail/issue-24363.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/src%2Ftest%2Fcompile-fail%2Fissue-24363.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a1bb0a182c94595f8af6cb84b27f6121b59d0ac8/src%2Ftest%2Fcompile-fail%2Fissue-24363.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-24363.rs?ref=a1bb0a182c94595f8af6cb84b27f6121b59d0ac8", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    1.create_a_type_error[ //~ ERROR attempted access of field\n+        ()+() //~ ERROR binary operation `+` cannot be applied\n+              //   ^ ensure that we typeck the inner expression ^\n+    ];\n+}"}]}