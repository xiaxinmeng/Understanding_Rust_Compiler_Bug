{"sha": "fab2d46d24b4c3328ebdf0ffecc8b67ad7990392", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZhYjJkNDZkMjRiNGMzMzI4ZWJkZjBmZmVjYzhiNjdhZDc5OTAzOTI=", "commit": {"author": {"name": "Timoth\u00e9e Delabrouille", "email": "timothee.delabrouille@musicworldmedia.com", "date": "2021-04-09T10:34:30Z"}, "committer": {"name": "Timoth\u00e9e Delabrouille", "email": "timothee.delabrouille@musicworldmedia.com", "date": "2021-04-09T10:34:30Z"}, "message": "remove allow_fail and uncomment the [feature(asm)] on every example", "tree": {"sha": "1d30f4a3f905f4ae946630285a6c0b540dd7c88e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d30f4a3f905f4ae946630285a6c0b540dd7c88e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fab2d46d24b4c3328ebdf0ffecc8b67ad7990392", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fab2d46d24b4c3328ebdf0ffecc8b67ad7990392", "html_url": "https://github.com/rust-lang/rust/commit/fab2d46d24b4c3328ebdf0ffecc8b67ad7990392", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fab2d46d24b4c3328ebdf0ffecc8b67ad7990392/comments", "author": null, "committer": null, "parents": [{"sha": "1ddddca57e74ac8dc78630e6522f86462a6e61fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ddddca57e74ac8dc78630e6522f86462a6e61fe", "html_url": "https://github.com/rust-lang/rust/commit/1ddddca57e74ac8dc78630e6522f86462a6e61fe"}], "stats": {"total": 60, "additions": 30, "deletions": 30}, "files": [{"sha": "3edad008020014c71d368a9106af0d0706421ed6", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fab2d46d24b4c3328ebdf0ffecc8b67ad7990392/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/fab2d46d24b4c3328ebdf0ffecc8b67ad7990392/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=fab2d46d24b4c3328ebdf0ffecc8b67ad7990392", "patch": "@@ -34,8 +34,8 @@ Inline assembly is currently supported on the following architectures:\n \n Let us start with the simplest possible example:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n unsafe {\n     asm!(\"nop\");\n }\n@@ -51,8 +51,8 @@ in the first argument of the `asm!` macro as a string literal.\n Now inserting an instruction that does nothing is rather boring. Let us do something that\n actually acts on data:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let x: u64;\n unsafe {\n     asm!(\"mov {}, 5\", out(reg) x);\n@@ -73,8 +73,8 @@ the template and will read the variable from there after the inline assembly fin\n \n Let us see another example that also uses an input:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let i: u64 = 3;\n let o: u64;\n unsafe {\n@@ -113,8 +113,8 @@ readability, and allows reordering instructions without changing the argument or\n \n We can further refine the above example to avoid the `mov` instruction:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let mut x: u64 = 3;\n unsafe {\n     asm!(\"add {0}, {number}\", inout(reg) x, number = const 5);\n@@ -127,8 +127,8 @@ This is different from specifying an input and output separately in that it is g\n \n It is also possible to specify different variables for the input and output parts of an `inout` operand:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let x: u64 = 3;\n let y: u64;\n unsafe {\n@@ -149,8 +149,8 @@ There is also a `inlateout` variant of this specifier.\n \n Here is an example where `inlateout` *cannot* be used:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n let c: u64 = 4;\n@@ -170,8 +170,8 @@ Here the compiler is free to allocate the same register for inputs `b` and `c` s\n \n However the following example can use `inlateout` since the output is only modified after all input registers have been read:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n unsafe {\n@@ -189,8 +189,8 @@ Therefore, Rust inline assembly provides some more specific constraint specifier\n While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`\n among others can be addressed by their name.\n \n-```rust,allow_fail,no_run\n-# #![feature(asm)]\n+```rust,no_run\n+#![feature(asm)]\n let cmd = 0xd1;\n unsafe {\n     asm!(\"out 0x64, eax\", in(\"eax\") cmd);\n@@ -205,8 +205,8 @@ Note that unlike other operand types, explicit register operands cannot be used\n \n Consider this example which uses the x86 `mul` instruction:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n fn mul(a: u64, b: u64) -> u128 {\n     let lo: u64;\n     let hi: u64;\n@@ -241,8 +241,8 @@ This state is generally referred to as being \"clobbered\".\n We need to tell the compiler about this since it may need to save and restore this state\n around the inline assembly block.\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let ebx: u32;\n let ecx: u32;\n \n@@ -271,8 +271,8 @@ However we still need to tell the compiler that `eax` and `edx` have been modifi\n \n This can also be used with a general register class (e.g. `reg`) to obtain a scratch register for use inside the asm code:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n // Multiply x by 6 using shifts and adds\n let mut x: u64 = 4;\n unsafe {\n@@ -293,8 +293,8 @@ assert_eq!(x, 4 * 6);\n A special operand type, `sym`, allows you to use the symbol name of a `fn` or `static` in inline assembly code.\n This allows you to call a function or access a global variable without needing to keep its address in a register.\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n extern \"C\" fn foo(arg: i32) {\n     println!(\"arg = {}\", arg);\n }\n@@ -335,8 +335,8 @@ By default the compiler will always choose the name that refers to the full regi\n \n This default can be overriden by using modifiers on the template string operands, just like you would with format strings:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let mut x: u16 = 0xab;\n \n unsafe {\n@@ -360,7 +360,7 @@ You have to manually use the memory address syntax specified by the respectively\n For example, in x86/x86_64 and intel assembly syntax, you should wrap inputs/outputs in `[]`\n to indicate they are memory operands:\n \n-```rust,allow_fail\n+```rust\n # #![feature(asm, llvm_asm)]\n # fn load_fpu_control_word(control: u16) {\n unsafe {\n@@ -378,7 +378,7 @@ The compiler is allowed to instantiate multiple copies an `asm!` block, for exam\n \n Moreover, due to [an llvm bug], you shouldn't use labels exclusively make of `0` and `1` digits, e.g. `0`, `11` or `101010`, as they may end up being interpreted as binary values.\n \n-```rust,allow_fail\n+```rust\n #![feature(asm)]\n \n let mut a = 0;\n@@ -415,8 +415,8 @@ By default, an inline assembly block is treated the same way as an external FFI\n \n Let's take our previous example of an `add` instruction:\n \n-```rust,allow_fail\n-# #![feature(asm)]\n+```rust\n+#![feature(asm)]\n let mut a: u64 = 4;\n let b: u64 = 4;\n unsafe {"}]}