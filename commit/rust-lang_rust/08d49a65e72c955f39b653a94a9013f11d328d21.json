{"sha": "08d49a65e72c955f39b653a94a9013f11d328d21", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA4ZDQ5YTY1ZTcyYzk1NWYzOWI2NTNhOTRhOTAxM2YxMWQzMjhkMjE=", "commit": {"author": {"name": "varkor", "email": "github@varkor.com", "date": "2018-07-24T00:43:30Z"}, "committer": {"name": "varkor", "email": "github@varkor.com", "date": "2018-08-19T19:02:33Z"}, "message": "Refactor mod/check (part viii)", "tree": {"sha": "6dbb271f10a4fff9ae2471cf71e5758bd222ccc5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6dbb271f10a4fff9ae2471cf71e5758bd222ccc5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/08d49a65e72c955f39b653a94a9013f11d328d21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/08d49a65e72c955f39b653a94a9013f11d328d21", "html_url": "https://github.com/rust-lang/rust/commit/08d49a65e72c955f39b653a94a9013f11d328d21", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/08d49a65e72c955f39b653a94a9013f11d328d21/comments", "author": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "varkor", "id": 3943692, "node_id": "MDQ6VXNlcjM5NDM2OTI=", "avatar_url": "https://avatars.githubusercontent.com/u/3943692?v=4", "gravatar_id": "", "url": "https://api.github.com/users/varkor", "html_url": "https://github.com/varkor", "followers_url": "https://api.github.com/users/varkor/followers", "following_url": "https://api.github.com/users/varkor/following{/other_user}", "gists_url": "https://api.github.com/users/varkor/gists{/gist_id}", "starred_url": "https://api.github.com/users/varkor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/varkor/subscriptions", "organizations_url": "https://api.github.com/users/varkor/orgs", "repos_url": "https://api.github.com/users/varkor/repos", "events_url": "https://api.github.com/users/varkor/events{/privacy}", "received_events_url": "https://api.github.com/users/varkor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f2588f020c3da7b1d5c6ec089b833ca424ad403", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f2588f020c3da7b1d5c6ec089b833ca424ad403", "html_url": "https://github.com/rust-lang/rust/commit/5f2588f020c3da7b1d5c6ec089b833ca424ad403"}], "stats": {"total": 120, "additions": 69, "deletions": 51}, "files": [{"sha": "a6ff979f472af46bd7b4ee1c677e7237510237a0", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/08d49a65e72c955f39b653a94a9013f11d328d21/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d49a65e72c955f39b653a94a9013f11d328d21/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=08d49a65e72c955f39b653a94a9013f11d328d21", "patch": "@@ -226,9 +226,9 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     }\n \n     fn fill_item<F>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>,\n-                        tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                        defs: &ty::Generics,\n-                        mk_kind: &mut F)\n+                    tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                    defs: &ty::Generics,\n+                    mk_kind: &mut F)\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n         if let Some(def_id) = defs.parent {\n@@ -238,7 +238,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         Substs::fill_single(substs, defs, mk_kind)\n     }\n \n-    pub fn fill_single<F>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>,\n+    fn fill_single<F>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>,\n                       defs: &ty::Generics,\n                       mk_kind: &mut F)\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>"}, {"sha": "1ef296774ea83a963307233436d6502b66b26025", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 65, "deletions": 47, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/08d49a65e72c955f39b653a94a9013f11d328d21/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/08d49a65e72c955f39b653a94a9013f11d328d21/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=08d49a65e72c955f39b653a94a9013f11d328d21", "patch": "@@ -4909,6 +4909,7 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // segment belong to, let's sort out the parameters that the user\n         // provided (if any) into their appropriate spaces. We'll also report\n         // errors if type parameters are provided in an inappropriate place.\n+\n         let mut generic_segs = HashSet::new();\n         for PathSeg(_, index) in &path_segs {\n             generic_segs.insert(index);\n@@ -4937,104 +4938,115 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n         // variables. If the user provided some types, we may still need\n         // to add defaults. If the user provided *too many* types, that's\n         // a problem.\n-        let mut infer_lifetimes = FxHashMap();\n+\n         let mut supress_errors = FxHashMap();\n         for &PathSeg(def_id, index) in &path_segs {\n             let seg = &segments[index];\n             let generics = self.tcx.generics_of(def_id);\n+            // `impl Trait` is treated as a normal generic parameter internally,\n+            // but we don't allow users to specify the parameter's value\n+            // explicitly, so we have to do some error-checking here.\n             let supress_mismatch = self.check_impl_trait(span, seg, &generics);\n             supress_errors.insert(index,\n                 self.check_generic_arg_count(span, seg, &generics, false, supress_mismatch));\n-            let inferred_lifetimes = if if let Some(ref data) = seg.args {\n-                !data.args.iter().any(|arg| match arg {\n-                    GenericArg::Lifetime(_) => true,\n-                    _ => false,\n-                })\n-            } else {\n-                true\n-            } {\n-                generics.own_counts().lifetimes\n-            } else {\n-                0\n-            };\n-            infer_lifetimes.insert(index, inferred_lifetimes);\n         }\n \n         let has_self = path_segs.last().map(|PathSeg(def_id, _)| {\n             self.tcx.generics_of(*def_id).has_self\n         }).unwrap_or(false);\n \n+        // Collect the segments of the path: we need to substitute arguments\n+        // for parameters throughout the entire path (wherever there are\n+        // generic parameters).\n         let def_id = def.def_id();\n         let mut parent_defs = self.tcx.generics_of(def_id);\n         let count = parent_defs.count();\n-        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n-            AccumulateVec::Array(ArrayVec::new())\n-        } else {\n-            AccumulateVec::Heap(Vec::with_capacity(count))\n-        };\n         let mut stack = vec![(def_id, parent_defs)];\n         while let Some(def_id) = parent_defs.parent {\n             parent_defs = self.tcx.generics_of(def_id);\n             stack.push((def_id, parent_defs));\n         }\n-        macro_rules! push_to_substs {\n-            ($kind:expr) => {\n-                let k = $kind;\n-                match substs {\n-                    AccumulateVec::Array(ref mut arr) => arr.push(k),\n-                    AccumulateVec::Heap(ref mut vec) => vec.push(k),\n-                }\n-            }\n+\n+        // We manually build up the substitution, rather than using convenience\n+        // methods in subst.rs so that we can iterate over the arguments and\n+        // parameters in lock-step linearly, rather than trying to match each pair.\n+        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n+            AccumulateVec::Array(ArrayVec::new())\n+        } else {\n+            AccumulateVec::Heap(Vec::with_capacity(count))\n         };\n+        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n+            match substs {\n+                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n+                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n+            }\n+        }\n+\n+        // Iterate over each segment of the path.\n         while let Some((def_id, defs)) = stack.pop() {\n             let mut params = defs.params.iter();\n             let mut next_param = params.next();\n+\n+            // `Self` is handled first.\n             if has_self {\n                 if let Some(param) = next_param {\n                     if param.index == 0 {\n                         if let GenericParamDefKind::Type { .. } = param.kind {\n-                            // Handle `Self` first, so we can adjust the index to match the AST.\n-                            push_to_substs!(opt_self_ty.map(|ty| ty.into()).unwrap_or_else(|| {\n-                                self.var_for_def(span, param)\n-                            }));\n+                            push_kind(&mut substs, opt_self_ty.map(|ty| ty.into())\n+                                .unwrap_or_else(|| self.var_for_def(span, param)));\n                             next_param = params.next();\n                         }\n                     }\n                 }\n             }\n \n             let mut infer_types = true;\n+            // Check whether this segment takes generic arguments.\n             if let Some(&PathSeg(_, index)) = path_segs\n                 .iter()\n                 .find(|&PathSeg(did, _)| *did == def_id) {\n+                // If we've encountered an `impl Trait`-related error, we're just\n+                // going to infer the arguments for better error messages.\n                 if !supress_errors[&index] {\n                     infer_types = segments[index].infer_types;\n+                    // Check whether the user has provided generic arguments.\n                     if let Some(ref data) = segments[index].args {\n                         let args = &data.args;\n+                        // We're going to iterate through the generic arguments that the user\n+                        // provided, matching them with the generic parameters we expect.\n+                        // Mismatches can occur as a result of elided lifetimes, or for malformed\n+                        // input. We try to handle both sensibly.\n                         'args: for arg in args {\n                             while let Some(param) = next_param {\n                                 match param.kind {\n                                     GenericParamDefKind::Lifetime => match arg {\n                                         GenericArg::Lifetime(lt) => {\n-                                            push_to_substs!(AstConv::ast_region_to_region(self,\n-                                                lt, Some(param)).into());\n+                                            push_kind(&mut substs,\n+                                                AstConv::ast_region_to_region(self, lt, Some(param))\n+                                                .into());\n                                             next_param = params.next();\n                                             continue 'args;\n                                         }\n                                         GenericArg::Type(_) => {\n-                                            // We're inferring a lifetime.\n-                                            push_to_substs!(\n+                                            // We expected a lifetime argument, but got a type\n+                                            // argument. That means we're inferring the lifetimes.\n+                                            push_kind(&mut substs,\n                                                 self.re_infer(span, Some(param)).unwrap().into());\n                                             next_param = params.next();\n                                         }\n                                     }\n                                     GenericParamDefKind::Type { .. } => match arg {\n                                         GenericArg::Type(ty) => {\n-                                            push_to_substs!(self.to_ty(ty).into());\n+                                            push_kind(&mut substs, self.to_ty(ty).into());\n                                             next_param = params.next();\n                                             continue 'args;\n                                         }\n                                         GenericArg::Lifetime(_) => {\n+                                            // We expected a type argument, but got a lifetime\n+                                            // argument. This is an error, but we need to handle it\n+                                            // gracefully so we can report sensible errors. In this\n+                                            // case, we're simply going to infer the remaining\n+                                            // arguments.\n                                             self.tcx.sess.delay_span_bug(span,\n                                                 \"found a GenericArg::Lifetime where a \\\n                                                  GenericArg::Type was expected\");\n@@ -5043,34 +5055,40 @@ impl<'a, 'gcx, 'tcx> FnCtxt<'a, 'gcx, 'tcx> {\n                                     }\n                                 }\n                             }\n-                            // If we get to this point, we have a GenericArg that is not matched\n-                            // by a GenericParamDef: i.e. the user supplied too many generic args.\n+                            // We should never be able to reach this point with well-formed input.\n+                            // Getting to this point means the user supplied more arguments than\n+                            // there are parameters.\n                             self.tcx.sess.delay_span_bug(span,\n                                 \"GenericArg did not have matching GenericParamDef\");\n                         }\n                     }\n                 }\n             }\n \n+            // If there are fewer arguments than parameters, it means\n+            // we're inferring the remaining arguments.\n             while let Some(param) = next_param {\n                 match param.kind {\n                     GenericParamDefKind::Lifetime => {\n-                        push_to_substs!(self.re_infer(span, Some(param)).unwrap().into());\n+                        push_kind(&mut substs, self.re_infer(span, Some(param)).unwrap().into());\n                     }\n                     GenericParamDefKind::Type { has_default, .. } => {\n                         if !infer_types && has_default {\n-                            // No type parameter provided, but a default exists.\n+                            // If we have a default, then we it doesn't matter that we're not\n+                            // inferring the type arguments: we provide the default where any\n+                            // is missing.\n                             let default = self.tcx.type_of(param.def_id);\n-                            push_to_substs!(self.normalize_ty(\n+                            let kind = self.normalize_ty(\n                                 span,\n                                 default.subst_spanned(self.tcx, &substs, Some(span))\n-                            ).into());\n+                            ).into();\n+                            push_kind(&mut substs, kind);\n                         } else {\n-                            // No type parameters were provided, we can infer all.\n-                            // This can also be reached in some error cases:\n-                            // We prefer to use inference variables instead of\n-                            // TyError to let type inference recover somewhat.\n-                            push_to_substs!(self.var_for_def(span, param));\n+                            // If no type arguments were provided, we have to infer them.\n+                            // This case also occurs as a result of some malformed input, e.g.\n+                            // a lifetime argument being given instead of a type paramter.\n+                            // Using inference instead of `TyError` gives better error messages.\n+                            push_kind(&mut substs, self.var_for_def(span, param));\n                         }\n                     }\n                 }"}]}