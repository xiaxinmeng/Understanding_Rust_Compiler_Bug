{"sha": "9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmNWUyMWRhNGVmOTVlNWQyOTE0YTc2YjA5ODQ4ZWJjMjUwNGM1M2Q=", "commit": {"author": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-03T07:47:30Z"}, "committer": {"name": "Corey Richardson", "email": "corey@octayn.net", "date": "2014-07-09T07:06:29Z"}, "message": "syntax: don't process string/char/byte/binary lits\n\nThis shuffles things around a bit so that LIT_CHAR and co store an Ident\nwhich is the original, unaltered literal in the source. When creating the AST,\nunescape and postprocess them.\n\nThis changes how syntax extensions can work, slightly, but otherwise poses no\nvisible changes. To get a useful value out of one of these tokens, call\n`parse::{char_lit, byte_lit, bin_lit, str_lit}`\n\n[breaking-change]", "tree": {"sha": "0bfb591a37cc94423938fd634fc3c8605addfd5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0bfb591a37cc94423938fd634fc3c8605addfd5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "html_url": "https://github.com/rust-lang/rust/commit/9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/comments", "author": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "committer": {"login": "emberian", "id": 704250, "node_id": "MDQ6VXNlcjcwNDI1MA==", "avatar_url": "https://avatars.githubusercontent.com/u/704250?v=4", "gravatar_id": "", "url": "https://api.github.com/users/emberian", "html_url": "https://github.com/emberian", "followers_url": "https://api.github.com/users/emberian/followers", "following_url": "https://api.github.com/users/emberian/following{/other_user}", "gists_url": "https://api.github.com/users/emberian/gists{/gist_id}", "starred_url": "https://api.github.com/users/emberian/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/emberian/subscriptions", "organizations_url": "https://api.github.com/users/emberian/orgs", "repos_url": "https://api.github.com/users/emberian/repos", "events_url": "https://api.github.com/users/emberian/events{/privacy}", "received_events_url": "https://api.github.com/users/emberian/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bf04a7ccb1c1d23478885ea4f67fad374ffe0a72", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf04a7ccb1c1d23478885ea4f67fad374ffe0a72", "html_url": "https://github.com/rust-lang/rust/commit/bf04a7ccb1c1d23478885ea4f67fad374ffe0a72"}], "stats": {"total": 408, "additions": 327, "deletions": 81}, "files": [{"sha": "1dbbe3b973c83f7e0b49ce78ced52b2cd828cb84", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "patch": "@@ -579,9 +579,9 @@ pub fn get_single_str_from_tts(cx: &ExtCtxt,\n         cx.span_err(sp, format!(\"{} takes 1 argument.\", name).as_slice());\n     } else {\n         match tts[0] {\n-            ast::TTTok(_, token::LIT_STR(ident))\n-            | ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => {\n-                return Some(token::get_ident(ident).get().to_string())\n+            ast::TTTok(_, token::LIT_STR(ident)) => return Some(parse::str_lit(ident.as_str())),\n+            ast::TTTok(_, token::LIT_STR_RAW(ident, _)) => {\n+                return Some(parse::raw_str_lit(ident.as_str()))\n             }\n             _ => {\n                 cx.span_err(sp,"}, {"sha": "f950a0d3340ff6b62034dda27d9f256cb1f6721b", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "patch": "@@ -401,13 +401,13 @@ fn mk_token(cx: &ExtCtxt, sp: Span, tok: &token::Token) -> Gc<ast::Expr> {\n         }\n \n         LIT_BYTE(i) => {\n-            let e_byte = cx.expr_lit(sp, ast::LitByte(i));\n+            let e_byte = mk_ident(cx, sp, i);\n \n             return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_BYTE\"), vec!(e_byte));\n         }\n \n         LIT_CHAR(i) => {\n-            let e_char = cx.expr_lit(sp, ast::LitChar(i));\n+            let e_char = mk_ident(cx, sp, i);\n \n             return cx.expr_call(sp, mk_token_path(cx, sp, \"LIT_CHAR\"), vec!(e_char));\n         }"}, {"sha": "e1317e0ed35ca3c3d8a4ce6bbae89f3434a6e79f", "filename": "src/libsyntax/parse/lexer/mod.rs", "status": "modified", "additions": 53, "deletions": 47, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "patch": "@@ -685,7 +685,7 @@ impl<'a> StringReader<'a> {\n     }\n \n \n-    fn scan_numeric_escape(&mut self, n_hex_digits: uint, delim: char) -> char {\n+    fn scan_numeric_escape(&mut self, n_hex_digits: uint, delim: char) -> bool {\n         let mut accum_int = 0u32;\n         let start_bpos = self.last_pos;\n         for _ in range(0, n_hex_digits) {\n@@ -709,20 +709,22 @@ impl<'a> StringReader<'a> {\n         }\n \n         match char::from_u32(accum_int) {\n-            Some(x) => x,\n+            Some(_) => true,\n             None => {\n                 let last_bpos = self.last_pos;\n                 self.err_span_(start_bpos, last_bpos, \"illegal numeric character escape\");\n-                '?'\n+                false\n             }\n         }\n     }\n \n     /// Scan for a single (possibly escaped) byte or char\n     /// in a byte, (non-raw) byte string, char, or (non-raw) string literal.\n     /// `start` is the position of `first_source_char`, which is already consumed.\n+    ///\n+    /// Returns true if there was a valid char/byte, false otherwise.\n     fn scan_char_or_byte(&mut self, start: BytePos, first_source_char: char,\n-                         ascii_only: bool, delim: char) -> Option<char> {\n+                         ascii_only: bool, delim: char) -> bool {\n         match first_source_char {\n             '\\\\' => {\n                 // '\\X' for some X must be a character constant:\n@@ -732,24 +734,18 @@ impl<'a> StringReader<'a> {\n                 match escaped {\n                     None => {},  // EOF here is an error that will be checked later.\n                     Some(e) => {\n-                        return Some(match e {\n-                            'n' => '\\n',\n-                            'r' => '\\r',\n-                            't' => '\\t',\n-                            '\\\\' => '\\\\',\n-                            '\\'' => '\\'',\n-                            '\"' => '\"',\n-                            '0' => '\\x00',\n+                        return match e {\n+                            'n' | 'r' | 't' | '\\\\' | '\\'' | '\"' | '0' => true,\n                             'x' => self.scan_numeric_escape(2u, delim),\n                             'u' if !ascii_only => self.scan_numeric_escape(4u, delim),\n                             'U' if !ascii_only => self.scan_numeric_escape(8u, delim),\n                             '\\n' if delim == '\"' => {\n                                 self.consume_whitespace();\n-                                return None\n+                                true\n                             },\n                             '\\r' if delim == '\"' && self.curr_is('\\n') => {\n                                 self.consume_whitespace();\n-                                return None\n+                                true\n                             }\n                             c => {\n                                 let last_pos = self.last_pos;\n@@ -758,9 +754,9 @@ impl<'a> StringReader<'a> {\n                                     if ascii_only { \"unknown byte escape\" }\n                                     else { \"unknown character escape\" },\n                                     c);\n-                                c\n+                                false\n                             }\n-                        })\n+                        }\n                     }\n                 }\n             }\n@@ -771,14 +767,16 @@ impl<'a> StringReader<'a> {\n                     if ascii_only { \"byte constant must be escaped\" }\n                     else { \"character constant must be escaped\" },\n                     first_source_char);\n+                return false;\n             }\n             '\\r' => {\n                 if self.curr_is('\\n') {\n                     self.bump();\n-                    return Some('\\n');\n+                    return true;\n                 } else {\n                     self.err_span_(start, self.last_pos,\n                                    \"bare CR not allowed in string, use \\\\r instead\");\n+                    return false;\n                 }\n             }\n             _ => if ascii_only && first_source_char > '\\x7F' {\n@@ -787,9 +785,10 @@ impl<'a> StringReader<'a> {\n                     start, last_pos,\n                     \"byte constant must be ASCII. \\\n                      Use a \\\\xHH escape for a non-ASCII byte\", first_source_char);\n+                return false;\n             }\n         }\n-        Some(first_source_char)\n+        true\n     }\n \n     fn binop(&mut self, op: token::BinOp) -> token::Token {\n@@ -924,7 +923,7 @@ impl<'a> StringReader<'a> {\n             let start = self.last_pos;\n \n             // the eof will be picked up by the final `'` check below\n-            let mut c2 = self.curr.unwrap_or('\\x00');\n+            let c2 = self.curr.unwrap_or('\\x00');\n             self.bump();\n \n             // If the character is an ident start not followed by another single\n@@ -967,7 +966,7 @@ impl<'a> StringReader<'a> {\n             }\n \n             // Otherwise it is a character constant:\n-            c2 = self.scan_char_or_byte(start, c2, /* ascii_only = */ false, '\\'').unwrap();\n+            let valid = self.scan_char_or_byte(start, c2, /* ascii_only = */ false, '\\'');\n             if !self.curr_is('\\'') {\n                 let last_bpos = self.last_pos;\n                 self.fatal_span_verbose(\n@@ -977,8 +976,9 @@ impl<'a> StringReader<'a> {\n                                    start - BytePos(1), last_bpos,\n                                    \"unterminated character constant\".to_string());\n             }\n+            let id = if valid { self.ident_from(start) } else { str_to_ident(\"0\") };\n             self.bump(); // advance curr past token\n-            return token::LIT_CHAR(c2);\n+            return token::LIT_CHAR(id);\n           }\n           'b' => {\n             self.bump();\n@@ -991,8 +991,8 @@ impl<'a> StringReader<'a> {\n \n           }\n           '\"' => {\n-            let mut accum_str = String::new();\n             let start_bpos = self.last_pos;\n+            let mut valid = true;\n             self.bump();\n             while !self.curr_is('\"') {\n                 if self.is_eof() {\n@@ -1003,11 +1003,13 @@ impl<'a> StringReader<'a> {\n                 let ch_start = self.last_pos;\n                 let ch = self.curr.unwrap();\n                 self.bump();\n-                self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ false, '\"')\n-                    .map(|ch| accum_str.push_char(ch));\n+                valid &= self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ false, '\"');\n             }\n+            // adjust for the ACSII \" at the start of the literal\n+            let id = if valid { self.ident_from(start_bpos + BytePos(1)) }\n+                     else { str_to_ident(\"??\") };\n             self.bump();\n-            return token::LIT_STR(str_to_ident(accum_str.as_slice()));\n+            return token::LIT_STR(id);\n           }\n           'r' => {\n             let start_bpos = self.last_pos;\n@@ -1032,7 +1034,7 @@ impl<'a> StringReader<'a> {\n             self.bump();\n             let content_start_bpos = self.last_pos;\n             let mut content_end_bpos;\n-            let mut has_cr = false;\n+            let mut valid = true;\n             'outer: loop {\n                 if self.is_eof() {\n                     let last_bpos = self.last_pos;\n@@ -1055,23 +1057,26 @@ impl<'a> StringReader<'a> {\n                             }\n                         }\n                         break;\n-                    }\n+                    },\n                     '\\r' => {\n-                        has_cr = true;\n+                        if !self.nextch_is('\\n') {\n+                            let last_bpos = self.last_pos;\n+                            self.err_span_(start_bpos, last_bpos, \"bare CR not allowed in raw \\\n+                                           string, use \\\\r instead\");\n+                            valid = false;\n+                        }\n                     }\n                     _ => ()\n                 }\n                 self.bump();\n             }\n             self.bump();\n-            let str_content = self.with_str_from_to(content_start_bpos, content_end_bpos, |string| {\n-                let string = if has_cr {\n-                    self.translate_crlf(content_start_bpos, string,\n-                                        \"bare CR not allowed in raw string\")\n-                } else { string.into_maybe_owned() };\n-                str_to_ident(string.as_slice())\n-            });\n-            return token::LIT_STR_RAW(str_content, hash_count);\n+            let id = if valid {\n+                self.ident_from_to(content_start_bpos, content_end_bpos)\n+            } else {\n+                str_to_ident(\"??\")\n+            };\n+            return token::LIT_STR_RAW(id, hash_count);\n           }\n           '-' => {\n             if self.nextch_is('>') {\n@@ -1145,10 +1150,10 @@ impl<'a> StringReader<'a> {\n         let start = self.last_pos;\n \n         // the eof will be picked up by the final `'` check below\n-        let mut c2 = self.curr.unwrap_or('\\x00');\n+        let c2 = self.curr.unwrap_or('\\x00');\n         self.bump();\n \n-        c2 = self.scan_char_or_byte(start, c2, /* ascii_only = */ true, '\\'').unwrap();\n+        let valid = self.scan_char_or_byte(start, c2, /* ascii_only = */ true, '\\'');\n         if !self.curr_is('\\'') {\n             // Byte offsetting here is okay because the\n             // character before position `start` are an\n@@ -1158,14 +1163,17 @@ impl<'a> StringReader<'a> {\n                 start - BytePos(2), last_pos,\n                 \"unterminated byte constant\".to_string());\n         }\n+\n+        let id = if valid { self.ident_from(start) } else { str_to_ident(\"??\") };\n         self.bump(); // advance curr past token\n-        return token::LIT_BYTE(c2 as u8);\n+        return token::LIT_BYTE(id);\n     }\n \n     fn scan_byte_string(&mut self) -> token::Token {\n         self.bump();\n         let start = self.last_pos;\n-        let mut value = Vec::new();\n+        let mut valid = true;\n+\n         while !self.curr_is('\"') {\n             if self.is_eof() {\n                 let last_pos = self.last_pos;\n@@ -1176,11 +1184,11 @@ impl<'a> StringReader<'a> {\n             let ch_start = self.last_pos;\n             let ch = self.curr.unwrap();\n             self.bump();\n-            self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ true, '\"')\n-                .map(|ch| value.push(ch as u8));\n+            valid &= self.scan_char_or_byte(ch_start, ch, /* ascii_only = */ true, '\"');\n         }\n+        let id = if valid { self.ident_from(start) } else { str_to_ident(\"??\") };\n         self.bump();\n-        return token::LIT_BINARY(Rc::new(value));\n+        return token::LIT_BINARY(id);\n     }\n \n     fn scan_raw_byte_string(&mut self) -> token::Token {\n@@ -1231,10 +1239,8 @@ impl<'a> StringReader<'a> {\n             self.bump();\n         }\n         self.bump();\n-        let bytes = self.with_str_from_to(content_start_bpos,\n-                                           content_end_bpos,\n-                                           |s| s.as_bytes().to_owned());\n-        return token::LIT_BINARY_RAW(Rc::new(bytes), hash_count);\n+        return token::LIT_BINARY_RAW(self.ident_from_to(content_start_bpos, content_end_bpos),\n+                                     hash_count);\n     }\n }\n "}, {"sha": "62750e60bf8ef8dff23baea5e8aefc18c84dc2a1", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "patch": "@@ -272,7 +272,239 @@ pub fn maybe_aborted<T>(result: T, mut p: Parser) -> T {\n     result\n }\n \n+/// Parse a string representing a character literal into its final form.\n+/// Rather than just accepting/rejecting a given literal, unescapes it as\n+/// well. Can take any slice prefixed by a character escape. Returns the\n+/// character and the number of characters consumed.\n+pub fn char_lit(lit: &str) -> (char, int) {\n+    use std::{num, char};\n+\n+    let mut chars = lit.chars();\n+    let c = match (chars.next(), chars.next()) {\n+        (Some(c), None) if c != '\\\\' => return (c, 1),\n+        (Some('\\\\'), Some(c)) => match c {\n+            '\"' => Some('\"'),\n+            'n' => Some('\\n'),\n+            'r' => Some('\\r'),\n+            't' => Some('\\t'),\n+            '\\\\' => Some('\\\\'),\n+            '\\'' => Some('\\''),\n+            '0' => Some('\\0'),\n+            _ => { None }\n+        },\n+        _ => fail!(\"lexer accepted invalid char escape `{}`\", lit)\n+    };\n+\n+    match c {\n+        Some(x) => return (x, 2),\n+        None => { }\n+    }\n+\n+    let msg = format!(\"lexer should have rejected a bad character escape {}\", lit);\n+    let msg2 = msg.as_slice();\n+\n+    let esc: |uint| -> Option<(char, int)> = |len|\n+        num::from_str_radix(lit.slice(2, len), 16)\n+        .and_then(char::from_u32)\n+        .map(|x| (x, len as int));\n+\n+    // Unicode escapes\n+    return match lit.as_bytes()[1] as char {\n+        'x' | 'X' => esc(4),\n+        'u' => esc(6),\n+        'U' => esc(10),\n+        _ => None,\n+    }.expect(msg2);\n+}\n+\n+/// Parse a string representing a string literal into its final form. Does\n+/// unescaping.\n+pub fn str_lit(lit: &str) -> String {\n+    debug!(\"parse_str_lit: given {}\", lit.escape_default());\n+    let mut res = String::with_capacity(lit.len());\n+\n+    // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n+    let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n+\n+    /// Eat everything up to a non-whitespace\n+    fn eat<'a>(it: &mut ::std::iter::Peekable<(uint, char), ::std::str::CharOffsets<'a>>) {\n+        loop {\n+            match it.peek().map(|x| x.val1()) {\n+                Some(' ') | Some('\\n') | Some('\\r') | Some('\\t') => {\n+                    it.next();\n+                },\n+                _ => { break; }\n+            }\n+        }\n+    }\n+\n+    let mut chars = lit.char_indices().peekable();\n+    loop {\n+        match chars.next() {\n+            Some((i, c)) => {\n+                let em = error(i);\n+                match c {\n+                    '\\\\' => {\n+                        if chars.peek().expect(em.as_slice()).val1() == '\\n' {\n+                            eat(&mut chars);\n+                        } else if chars.peek().expect(em.as_slice()).val1() == '\\r' {\n+                            chars.next();\n+                            if chars.peek().expect(em.as_slice()).val1() != '\\n' {\n+                                fail!(\"lexer accepted bare CR\");\n+                            }\n+                            eat(&mut chars);\n+                        } else {\n+                            // otherwise, a normal escape\n+                            let (c, n) = char_lit(lit.slice_from(i));\n+                            for _ in range(0, n - 1) { // we don't need to move past the first \\\n+                                chars.next();\n+                            }\n+                            res.push_char(c);\n+                        }\n+                    },\n+                    '\\r' => {\n+                        if chars.peek().expect(em.as_slice()).val1() != '\\n' {\n+                            fail!(\"lexer accepted bare CR\");\n+                        }\n+                        chars.next();\n+                        res.push_char('\\n');\n+                    }\n+                    c => res.push_char(c),\n+                }\n+            },\n+            None => break\n+        }\n+    }\n+\n+    res.shrink_to_fit(); // probably not going to do anything, unless there was an escape.\n+    debug!(\"parse_str_lit: returning {}\", res);\n+    res\n+}\n+\n+/// Parse a string representing a raw string literal into its final form. The\n+/// only operation this does is convert embedded CRLF into a single LF.\n+pub fn raw_str_lit(lit: &str) -> String {\n+    debug!(\"raw_str_lit: given {}\", lit.escape_default());\n+    let mut res = String::with_capacity(lit.len());\n+\n+    // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n+    let mut chars = lit.chars().peekable();\n+    loop {\n+        match chars.next() {\n+            Some(c) => {\n+                if c == '\\r' {\n+                    if *chars.peek().unwrap() != '\\n' {\n+                        fail!(\"lexer accepted bare CR\");\n+                    }\n+                    chars.next();\n+                    res.push_char('\\n');\n+                } else {\n+                    res.push_char(c);\n+                }\n+            },\n+            None => break\n+        }\n+    }\n \n+    res.shrink_to_fit();\n+    res\n+}\n+\n+pub fn float_lit(s: &str) -> ast::Lit_ {\n+    debug!(\"float_lit: {}\", s);\n+    // FIXME #2252: bounds checking float literals is defered until trans\n+    let s2 = s.chars().filter(|&c| c != '_').collect::<String>();\n+    let s = s2.as_slice();\n+\n+    let mut ty = None;\n+\n+    if s.ends_with(\"f32\") {\n+        ty = Some(ast::TyF32);\n+    } else if s.ends_with(\"f64\") {\n+        ty = Some(ast::TyF64);\n+    }\n+\n+\n+    match ty {\n+        Some(t) => {\n+            ast::LitFloat(token::intern_and_get_ident(s.slice_to(s.len() - t.suffix_len())), t)\n+        },\n+        None => ast::LitFloatUnsuffixed(token::intern_and_get_ident(s))\n+    }\n+}\n+\n+/// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n+pub fn byte_lit(lit: &str) -> (u8, uint) {\n+    let err = |i| format!(\"lexer accepted invalid byte literal {} step {}\", lit, i);\n+\n+    if lit.len() == 1 {\n+        (lit.as_bytes()[0], 1)\n+    } else {\n+        assert!(lit.as_bytes()[0] == b'\\\\', err(0i));\n+        let b = match lit.as_bytes()[1] {\n+            b'\"' => b'\"',\n+            b'n' => b'\\n',\n+            b'r' => b'\\r',\n+            b't' => b'\\t',\n+            b'\\\\' => b'\\\\',\n+            b'\\'' => b'\\'',\n+            b'0' => b'\\0',\n+            _ => {\n+                match ::std::num::from_str_radix::<u64>(lit.slice(2, 4), 16) {\n+                    Some(c) =>\n+                        if c > 0xFF {\n+                            fail!(err(2))\n+                        } else {\n+                            return (c as u8, 4)\n+                        },\n+                    None => fail!(err(3))\n+                }\n+            }\n+        };\n+        return (b, 2);\n+    }\n+}\n+\n+pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n+    let mut res = Vec::with_capacity(lit.len());\n+\n+    // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n+    let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n+\n+    // binary literals *must* be ASCII, but the escapes don't have to be\n+    let mut chars = lit.as_bytes().iter().enumerate().peekable();\n+    loop {\n+        match chars.next() {\n+            Some((i, &c)) => {\n+                if c == b'\\\\' {\n+                    if *chars.peek().expect(error(i).as_slice()).val1() == b'\\n' {\n+                        loop {\n+                            // eat everything up to a non-whitespace\n+                            match chars.peek().map(|x| *x.val1()) {\n+                                Some(b' ') | Some(b'\\n') | Some(b'\\r') | Some(b'\\t') => {\n+                                    chars.next();\n+                                },\n+                                _ => { break; }\n+                            }\n+                        }\n+                    } else {\n+                        // otherwise, a normal escape\n+                        let (c, n) = byte_lit(lit.slice_from(i));\n+                        for _ in range(0, n - 1) { // we don't need to move past the first \\\n+                            chars.next();\n+                        }\n+                        res.push(c);\n+                    }\n+                } else {\n+                    res.push(c);\n+                }\n+            },\n+            None => { break; }\n+        }\n+    }\n+\n+    Rc::new(res)\n+}\n \n #[cfg(test)]\n mod test {"}, {"sha": "553e685bddecef13c24389dd6085881293a03969", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "patch": "@@ -61,6 +61,7 @@ use ast_util::{as_prec, ident_to_path, lit_is_str, operator_prec};\n use ast_util;\n use codemap::{Span, BytePos, Spanned, spanned, mk_sp};\n use codemap;\n+use parse;\n use parse::attr::ParserAttr;\n use parse::classify;\n use parse::common::{SeqSep, seq_sep_none};\n@@ -1543,8 +1544,8 @@ impl<'a> Parser<'a> {\n     /// Matches token_lit = LIT_INT | ...\n     pub fn lit_from_token(&mut self, tok: &token::Token) -> Lit_ {\n         match *tok {\n-            token::LIT_BYTE(i) => LitByte(i),\n-            token::LIT_CHAR(i) => LitChar(i),\n+            token::LIT_BYTE(i) => LitByte(parse::byte_lit(i.as_str()).val0()),\n+            token::LIT_CHAR(i) => LitChar(parse::char_lit(i.as_str()).val0()),\n             token::LIT_INT(i, it) => LitInt(i, it),\n             token::LIT_UINT(u, ut) => LitUint(u, ut),\n             token::LIT_INT_UNSUFFIXED(i) => LitIntUnsuffixed(i),\n@@ -1555,13 +1556,17 @@ impl<'a> Parser<'a> {\n                 LitFloatUnsuffixed(self.id_to_interned_str(s))\n             }\n             token::LIT_STR(s) => {\n-                LitStr(self.id_to_interned_str(s), ast::CookedStr)\n+                LitStr(token::intern_and_get_ident(parse::str_lit(s.as_str()).as_slice()),\n+                       ast::CookedStr)\n             }\n             token::LIT_STR_RAW(s, n) => {\n-                LitStr(self.id_to_interned_str(s), ast::RawStr(n))\n+                LitStr(token::intern_and_get_ident(parse::raw_str_lit(s.as_str()).as_slice()),\n+                       ast::RawStr(n))\n             }\n-            token::LIT_BINARY_RAW(ref v, _) |\n-            token::LIT_BINARY(ref v) => LitBinary(v.clone()),\n+            token::LIT_BINARY(i) =>\n+                LitBinary(parse::binary_lit(self.id_to_interned_str(i).get())),\n+            token::LIT_BINARY_RAW(i, _) =>\n+                LitBinary(Rc::new(i.as_str().as_bytes().iter().map(|&x| x).collect())),\n             token::LPAREN => { self.expect(&token::RPAREN); LitNil },\n             _ => { self.unexpected_last(tok); }\n         }"}, {"sha": "bb6183b7e9ea37374fb872a8fa168c206da9de2e", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 11, "deletions": 23, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "patch": "@@ -79,17 +79,17 @@ pub enum Token {\n     QUESTION,\n \n     /* Literals */\n-    LIT_BYTE(u8),\n-    LIT_CHAR(char),\n+    LIT_BYTE(Ident),\n+    LIT_CHAR(Ident),\n     LIT_INT(i64, ast::IntTy),\n     LIT_UINT(u64, ast::UintTy),\n     LIT_INT_UNSUFFIXED(i64),\n     LIT_FLOAT(Ident, ast::FloatTy),\n     LIT_FLOAT_UNSUFFIXED(Ident),\n     LIT_STR(Ident),\n     LIT_STR_RAW(Ident, uint), /* raw str delimited by n hash symbols */\n-    LIT_BINARY(Rc<Vec<u8>>),\n-    LIT_BINARY_RAW(Rc<Vec<u8>>, uint), /* raw binary str delimited by n hash symbols */\n+    LIT_BINARY(Ident),\n+    LIT_BINARY_RAW(Ident, uint), /* raw binary str delimited by n hash symbols */\n \n     /* Name components */\n     /// An identifier contains an \"is_mod_name\" boolean,\n@@ -201,20 +201,10 @@ pub fn to_string(t: &Token) -> String {\n \n       /* Literals */\n       LIT_BYTE(b) => {\n-          let mut res = String::from_str(\"b'\");\n-          (b as char).escape_default(|c| {\n-              res.push_char(c);\n-          });\n-          res.push_char('\\'');\n-          res\n+          format!(\"b'{}'\", get_ident(b).get())\n       }\n       LIT_CHAR(c) => {\n-          let mut res = String::from_str(\"'\");\n-          c.escape_default(|c| {\n-              res.push_char(c);\n-          });\n-          res.push_char('\\'');\n-          res\n+          format!(\"'{}'\", get_ident(c).get())\n       }\n       LIT_INT(i, t) => ast_util::int_ty_to_string(t, Some(i)),\n       LIT_UINT(u, t) => ast_util::uint_ty_to_string(t, Some(u)),\n@@ -235,20 +225,18 @@ pub fn to_string(t: &Token) -> String {\n         body\n       }\n       LIT_STR(s) => {\n-          format!(\"\\\"{}\\\"\", get_ident(s).get().escape_default())\n+          format!(\"\\\"{}\\\"\", get_ident(s).get())\n       }\n       LIT_STR_RAW(s, n) => {\n         format!(\"r{delim}\\\"{string}\\\"{delim}\",\n                  delim=\"#\".repeat(n), string=get_ident(s))\n       }\n-      LIT_BINARY(ref v) => {\n-          format!(\n-            \"b\\\"{}\\\"\",\n-            v.iter().map(|&b| b as char).collect::<String>().escape_default())\n+      LIT_BINARY(v) => {\n+          format!(\"b\\\"{}\\\"\", get_ident(v).get())\n       }\n-      LIT_BINARY_RAW(ref s, n) => {\n+      LIT_BINARY_RAW(s, n) => {\n         format!(\"br{delim}\\\"{string}\\\"{delim}\",\n-                 delim=\"#\".repeat(n), string=s.as_slice().to_ascii().as_str_ascii())\n+                 delim=\"#\".repeat(n), string=get_ident(s).get())\n       }\n \n       /* Name components */"}, {"sha": "7abe8276a97823b67e314c2b8b304b9fa2d5f294", "filename": "src/test/run-pass/string-escapes.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Ftest%2Frun-pass%2Fstring-escapes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f5e21da4ef95e5d2914a76b09848ebc2504c53d/src%2Ftest%2Frun-pass%2Fstring-escapes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstring-escapes.rs?ref=9f5e21da4ef95e5d2914a76b09848ebc2504c53d", "patch": "@@ -0,0 +1,15 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+fn main() {\n+    let x = \"\\\\\\\\\\\n+    \";\n+    assert!(x == r\"\\\\\"); // extraneous whitespace stripped\n+}"}]}