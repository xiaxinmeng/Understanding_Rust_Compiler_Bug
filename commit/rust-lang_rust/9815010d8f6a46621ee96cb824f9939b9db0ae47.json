{"sha": "9815010d8f6a46621ee96cb824f9939b9db0ae47", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MTUwMTBkOGY2YTQ2NjIxZWU5NmNiODI0Zjk5MzliOWRiMGFlNDc=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-07-06T03:38:31Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-09-03T13:29:22Z"}, "message": "Remove disambiguators from link text\n\nRelated to https://github.com/rust-lang/rust/issues/65354\n\n- Pass through the replacement text to `markdown.rs`\n- Add some tests\n- Add a state machine that actually replaces the text when parsing Markdown", "tree": {"sha": "67ccb95bcf975568ac1effacda46513b34db2418", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/67ccb95bcf975568ac1effacda46513b34db2418"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9815010d8f6a46621ee96cb824f9939b9db0ae47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9815010d8f6a46621ee96cb824f9939b9db0ae47", "html_url": "https://github.com/rust-lang/rust/commit/9815010d8f6a46621ee96cb824f9939b9db0ae47", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9815010d8f6a46621ee96cb824f9939b9db0ae47/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "31a7b6e8323b6e9880f4691e624cf6aa6289f6a7", "url": "https://api.github.com/repos/rust-lang/rust/commits/31a7b6e8323b6e9880f4691e624cf6aa6289f6a7", "html_url": "https://github.com/rust-lang/rust/commit/31a7b6e8323b6e9880f4691e624cf6aa6289f6a7"}], "stats": {"total": 163, "additions": 141, "deletions": 22}, "files": [{"sha": "05c90a7c4034f7653916cfe5d2bfa7d9386211a5", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=9815010d8f6a46621ee96cb824f9939b9db0ae47", "patch": "@@ -436,6 +436,11 @@ pub struct Attributes {\n pub struct ItemLink {\n     /// The original link written in the markdown\n     pub(crate) link: String,\n+    /// The link text displayed in the HTML.\n+    ///\n+    /// This may not be the same as `link` if there was a disambiguator\n+    /// in an intra-doc link (e.g. [`fn@f`])\n+    pub(crate) link_text: String,\n     pub(crate) did: Option<DefId>,\n     /// The url fragment to append to the link\n     pub(crate) fragment: Option<String>,\n@@ -444,6 +449,8 @@ pub struct ItemLink {\n pub struct RenderedLink {\n     /// The text the link was original written as\n     pub(crate) original_text: String,\n+    /// The text to display in the HTML\n+    pub(crate) new_text: String,\n     /// The URL to put in the `href`\n     pub(crate) href: String,\n }\n@@ -630,15 +637,19 @@ impl Attributes {\n \n         self.links\n             .iter()\n-            .filter_map(|ItemLink { link: s, did, fragment }| {\n+            .filter_map(|ItemLink { link: s, link_text, did, fragment }| {\n                 match *did {\n                     Some(did) => {\n                         if let Some((mut href, ..)) = href(did) {\n                             if let Some(ref fragment) = *fragment {\n                                 href.push_str(\"#\");\n                                 href.push_str(fragment);\n                             }\n-                            Some(RenderedLink { original_text: s.clone(), href })\n+                            Some(RenderedLink {\n+                                original_text: s.clone(),\n+                                new_text: link_text.clone(),\n+                                href,\n+                            })\n                         } else {\n                             None\n                         }\n@@ -660,6 +671,7 @@ impl Attributes {\n                             let tail = fragment.find('#').unwrap_or_else(|| fragment.len());\n                             Some(RenderedLink {\n                                 original_text: s.clone(),\n+                                new_text: link_text.clone(),\n                                 href: format!(\n                                     \"{}{}std/primitive.{}.html{}\",\n                                     url,"}, {"sha": "6d634bac7622ded9ae69348e4a25ae58914d2cb0", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 73, "deletions": 16, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=9815010d8f6a46621ee96cb824f9939b9db0ae47", "patch": "@@ -340,29 +340,86 @@ impl<'a, I: Iterator<Item = Event<'a>>> Iterator for CodeBlocks<'_, 'a, I> {\n /// Make headings links with anchor IDs and build up TOC.\n struct LinkReplacer<'a, 'b, I: Iterator<Item = Event<'a>>> {\n     inner: I,\n-    links: &'b [RenderedLink],\n+    links: &'a [RenderedLink],\n+    shortcut_link: Option<&'b RenderedLink>,\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, 'b, I> {\n-    fn new(iter: I, links: &'b [RenderedLink]) -> Self {\n-        LinkReplacer { inner: iter, links }\n+impl<'a, I: Iterator<Item = Event<'a>>> LinkReplacer<'a, '_, I> {\n+    fn new(iter: I, links: &'a [RenderedLink]) -> Self {\n+        LinkReplacer { inner: iter, links, shortcut_link: None }\n     }\n }\n \n-impl<'a, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I> {\n+impl<'a: 'b, 'b, I: Iterator<Item = Event<'a>>> Iterator for LinkReplacer<'a, 'b, I> {\n     type Item = Event<'a>;\n \n     fn next(&mut self) -> Option<Self::Item> {\n-        let event = self.inner.next();\n-        if let Some(Event::Start(Tag::Link(kind, dest, text))) = event {\n-            if let Some(link) = self.links.iter().find(|link| link.original_text == *dest) {\n-                Some(Event::Start(Tag::Link(kind, link.href.clone().into(), text)))\n-            } else {\n-                Some(Event::Start(Tag::Link(kind, dest, text)))\n+        let mut event = self.inner.next();\n+\n+        // Remove disambiguators from shortcut links (`[fn@f]`)\n+        match &mut event {\n+            Some(Event::Start(Tag::Link(\n+                pulldown_cmark::LinkType::ShortcutUnknown,\n+                dest,\n+                title,\n+            ))) => {\n+                debug!(\"saw start of shortcut link to {} with title {}\", dest, title);\n+                let link = if let Some(link) =\n+                    self.links.iter().find(|&link| *link.original_text == **dest)\n+                {\n+                    // Not sure why this is necessary - maybe the broken_link_callback doesn't always work?\n+                    *dest = CowStr::Borrowed(link.href.as_ref());\n+                    Some(link)\n+                } else {\n+                    self.links.iter().find(|&link| *link.href == **dest)\n+                };\n+                if let Some(link) = link {\n+                    trace!(\"it matched\");\n+                    assert!(self.shortcut_link.is_none(), \"shortcut links cannot be nested\");\n+                    self.shortcut_link = Some(link);\n+                }\n             }\n-        } else {\n-            event\n+            Some(Event::End(Tag::Link(pulldown_cmark::LinkType::ShortcutUnknown, dest, _))) => {\n+                debug!(\"saw end of shortcut link to {}\", dest);\n+                if let Some(_link) = self.links.iter().find(|&link| *link.href == **dest) {\n+                    assert!(self.shortcut_link.is_some(), \"saw closing link without opening tag\");\n+                    self.shortcut_link = None;\n+                }\n+            }\n+            // Handle backticks in inline code blocks\n+            Some(Event::Code(text)) => {\n+                trace!(\"saw code {}\", text);\n+                if let Some(link) = self.shortcut_link {\n+                    trace!(\"original text was {}\", link.original_text);\n+                    if **text == link.original_text[1..link.original_text.len() - 1] {\n+                        debug!(\"replacing {} with {}\", text, link.new_text);\n+                        *text = link.new_text.clone().into();\n+                    }\n+                }\n+            }\n+            // Replace plain text in links\n+            Some(Event::Text(text)) => {\n+                trace!(\"saw text {}\", text);\n+                if let Some(link) = self.shortcut_link {\n+                    trace!(\"original text was {}\", link.original_text);\n+                    if **text == *link.original_text {\n+                        debug!(\"replacing {} with {}\", text, link.new_text);\n+                        *text = link.new_text.clone().into();\n+                    }\n+                }\n+            }\n+            Some(Event::Start(Tag::Link(_, dest, _))) => {\n+                if let Some(link) = self.links.iter().find(|&link| *link.original_text == **dest) {\n+                    // Not sure why this is necessary - maybe the broken_link_callback doesn't always work?\n+                    *dest = CowStr::Borrowed(link.href.as_ref());\n+                }\n+            }\n+            // Anything else couldn't have been a valid Rust path\n+            _ => {}\n         }\n+\n+        // Yield the modified event\n+        event\n     }\n }\n \n@@ -857,7 +914,7 @@ impl Markdown<'_> {\n         }\n         let replacer = |_: &str, s: &str| {\n             if let Some(link) = links.iter().find(|link| &*link.original_text == s) {\n-                Some((link.original_text.clone(), link.href.clone()))\n+                Some((link.href.clone(), link.new_text.clone()))\n             } else {\n                 None\n             }\n@@ -934,8 +991,8 @@ impl MarkdownSummaryLine<'_> {\n         }\n \n         let replacer = |_: &str, s: &str| {\n-            if let Some(rendered_link) = links.iter().find(|link| &*link.original_text == s) {\n-                Some((rendered_link.original_text.clone(), rendered_link.href.clone()))\n+            if let Some(link) = links.iter().find(|link| &*link.original_text == s) {\n+                Some((link.href.clone(), link.new_text.clone()))\n             } else {\n                 None\n             }"}, {"sha": "318b10e2af2b3f2221ce52ff45014c45d0a0bfc9", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=9815010d8f6a46621ee96cb824f9939b9db0ae47", "patch": "@@ -64,8 +64,7 @@ use serde::ser::SerializeSeq;\n use serde::{Serialize, Serializer};\n \n use crate::clean::{self, AttributesExt, Deprecation, GetDefId, RenderedLink, SelfTy, TypeKind};\n-use crate::config::RenderInfo;\n-use crate::config::RenderOptions;\n+use crate::config::{RenderInfo, RenderOptions};\n use crate::docfs::{DocFS, PathError};\n use crate::doctree;\n use crate::error::Error;"}, {"sha": "ff3c19da3cf7598dfca3de7f886c37b549719ee4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=9815010d8f6a46621ee96cb824f9939b9db0ae47", "patch": "@@ -685,6 +685,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 continue;\n             }\n \n+            //let had_backticks = ori_link.contains(\"`\");\n             let link = ori_link.replace(\"`\", \"\");\n             let parts = link.split('#').collect::<Vec<_>>();\n             let (link, extra_fragment) = if parts.len() > 2 {\n@@ -700,6 +701,7 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 (parts[0], None)\n             };\n             let resolved_self;\n+            let link_text;\n             let mut path_str;\n             let disambiguator;\n             let (mut res, mut fragment) = {\n@@ -716,6 +718,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     continue;\n                 }\n \n+                // We stripped ` characters for `path_str`.\n+                // The original link might have had multiple pairs of backticks,\n+                // but we don't handle this case.\n+                //link_text = if had_backticks { format!(\"`{}`\", path_str) } else { path_str.to_owned() };\n+                link_text = path_str.to_owned();\n+\n                 // In order to correctly resolve intra-doc-links we need to\n                 // pick a base AST node to work from.  If the documentation for\n                 // this module came from an inner comment (//!) then we anchor\n@@ -904,7 +912,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n             if let Res::PrimTy(_) = res {\n                 match disambiguator {\n                     Some(Disambiguator::Primitive | Disambiguator::Namespace(_)) | None => {\n-                        item.attrs.links.push(ItemLink { link: ori_link, did: None, fragment });\n+                        item.attrs.links.push(ItemLink {\n+                            link: ori_link,\n+                            link_text: path_str.to_owned(),\n+                            did: None,\n+                            fragment,\n+                        });\n                     }\n                     Some(other) => {\n                         report_mismatch(other, Disambiguator::Primitive);\n@@ -955,7 +968,12 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                     }\n                 }\n                 let id = register_res(cx, res);\n-                item.attrs.links.push(ItemLink { link: ori_link, did: Some(id), fragment });\n+                item.attrs.links.push(ItemLink {\n+                    link: ori_link,\n+                    link_text,\n+                    did: Some(id),\n+                    fragment,\n+                });\n             }\n         }\n "}, {"sha": "74411870e9f8a50681320800b912ae1b03dbcbb5", "filename": "src/test/rustdoc/disambiguator_removed.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Ftest%2Frustdoc%2Fdisambiguator_removed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9815010d8f6a46621ee96cb824f9939b9db0ae47/src%2Ftest%2Frustdoc%2Fdisambiguator_removed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fdisambiguator_removed.rs?ref=9815010d8f6a46621ee96cb824f9939b9db0ae47", "patch": "@@ -0,0 +1,33 @@\n+#![deny(intra_doc_link_resolution_failure)]\n+// first try backticks\n+/// Trait: [`trait@Name`], fn: [`fn@Name`], [`Name`][`macro@Name`]\n+// @has disambiguator_removed/struct.AtDisambiguator.html\n+// @has - '//a[@href=\"../disambiguator_removed/trait.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"../disambiguator_removed/fn.Name.html\"][code]' \"Name\"\n+// @has - '//a[@href=\"../disambiguator_removed/macro.Name.html\"][code]' \"Name\"\n+pub struct AtDisambiguator;\n+\n+/// fn: [`Name()`], macro: [`Name!`]\n+// @has disambiguator_removed/struct.SymbolDisambiguator.html\n+// @has - '//a[@href=\"../disambiguator_removed/fn.Name.html\"][code]' \"Name()\"\n+// @has - '//a[@href=\"../disambiguator_removed/macro.Name.html\"][code]' \"Name!\"\n+pub struct SymbolDisambiguator;\n+\n+// Now make sure that backticks aren't added if they weren't already there\n+/// [fn@Name]\n+// @has disambiguator_removed/trait.Name.html\n+// @has - '//a[@href=\"../disambiguator_removed/fn.Name.html\"]' \"Name\"\n+// @!has - '//a[@href=\"../disambiguator_removed/fn.Name.html\"][code]' \"Name\"\n+\n+// FIXME: this will turn !() into ! alone\n+/// [Name!()]\n+// @has - '//a[@href=\"../disambiguator_removed/macro.Name.html\"]' \"Name!\"\n+pub trait Name {}\n+\n+#[allow(non_snake_case)]\n+pub fn Name() {}\n+\n+#[macro_export]\n+macro_rules! Name {\n+    () => ()\n+}"}]}