{"sha": "2b61be297568015de5d038f31a304c7a69679bc7", "node_id": "C_kwDOAAsO6NoAKDJiNjFiZTI5NzU2ODAxNWRlNWQwMzhmMzFhMzA0YzdhNjk2NzliYzc", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-14T22:39:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-09-14T22:39:31Z"}, "message": "Auto merge of #13232 - jplatte:mbe-refactor, r=Veykril\n\nRefactor macro-by-example code\n\nI had a look at the MBE code because of #7857. I found some easy readability wins, that might also _marginally_ improve perf.", "tree": {"sha": "e98232fee1709694858d662240550f81c0fdd95e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e98232fee1709694858d662240550f81c0fdd95e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b61be297568015de5d038f31a304c7a69679bc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b61be297568015de5d038f31a304c7a69679bc7", "html_url": "https://github.com/rust-lang/rust/commit/2b61be297568015de5d038f31a304c7a69679bc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b61be297568015de5d038f31a304c7a69679bc7/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbb8fedf8b887adfde3b445f9ec4bdf11da9ae9f", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb8fedf8b887adfde3b445f9ec4bdf11da9ae9f", "html_url": "https://github.com/rust-lang/rust/commit/dbb8fedf8b887adfde3b445f9ec4bdf11da9ae9f"}, {"sha": "c4a87ee0cefb57640a9d5219d221e8578a1e6733", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4a87ee0cefb57640a9d5219d221e8578a1e6733", "html_url": "https://github.com/rust-lang/rust/commit/c4a87ee0cefb57640a9d5219d221e8578a1e6733"}], "stats": {"total": 37, "additions": 14, "deletions": 23}, "files": [{"sha": "139a8cb8cbe589b9e586cdf6c8c0f94c36126e54", "filename": "crates/mbe/src/expander/matcher.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/2b61be297568015de5d038f31a304c7a69679bc7/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b61be297568015de5d038f31a304c7a69679bc7/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fmbe%2Fsrc%2Fexpander%2Fmatcher.rs?ref=2b61be297568015de5d038f31a304c7a69679bc7", "patch": "@@ -203,17 +203,16 @@ impl BindingsBuilder {\n     }\n \n     fn build(self, idx: &BindingsIdx) -> Bindings {\n-        let mut bindings = Bindings::default();\n-        self.build_inner(&mut bindings, &self.nodes[idx.0]);\n-        bindings\n+        self.build_inner(&self.nodes[idx.0])\n     }\n \n-    fn build_inner(&self, bindings: &mut Bindings, link_nodes: &[LinkNode<Rc<BindingKind>>]) {\n+    fn build_inner(&self, link_nodes: &[LinkNode<Rc<BindingKind>>]) -> Bindings {\n+        let mut bindings = Bindings::default();\n         let mut nodes = Vec::new();\n         self.collect_nodes(link_nodes, &mut nodes);\n \n         for cmd in nodes {\n-            match &**cmd {\n+            match cmd {\n                 BindingKind::Empty(name) => {\n                     bindings.push_empty(name);\n                 }\n@@ -246,13 +245,15 @@ impl BindingsBuilder {\n                 }\n             }\n         }\n+\n+        bindings\n     }\n \n     fn collect_nested_ref<'a>(\n         &'a self,\n         id: usize,\n         len: usize,\n-        nested_refs: &mut Vec<&'a Vec<LinkNode<Rc<BindingKind>>>>,\n+        nested_refs: &mut Vec<&'a [LinkNode<Rc<BindingKind>>]>,\n     ) {\n         self.nested[id].iter().take(len).for_each(|it| match it {\n             LinkNode::Node(id) => nested_refs.push(&self.nodes[*id]),\n@@ -262,26 +263,16 @@ impl BindingsBuilder {\n \n     fn collect_nested(&self, idx: usize, nested_idx: usize, nested: &mut Vec<Bindings>) {\n         let last = &self.nodes[idx];\n-        let mut nested_refs = Vec::new();\n+        let mut nested_refs: Vec<&[_]> = Vec::new();\n         self.nested[nested_idx].iter().for_each(|it| match *it {\n             LinkNode::Node(idx) => nested_refs.push(&self.nodes[idx]),\n             LinkNode::Parent { idx, len } => self.collect_nested_ref(idx, len, &mut nested_refs),\n         });\n         nested_refs.push(last);\n-\n-        nested_refs.into_iter().for_each(|iter| {\n-            let mut child_bindings = Bindings::default();\n-            self.build_inner(&mut child_bindings, iter);\n-            nested.push(child_bindings)\n-        })\n+        nested.extend(nested_refs.into_iter().map(|iter| self.build_inner(iter)));\n     }\n \n-    fn collect_nodes_ref<'a>(\n-        &'a self,\n-        id: usize,\n-        len: usize,\n-        nodes: &mut Vec<&'a Rc<BindingKind>>,\n-    ) {\n+    fn collect_nodes_ref<'a>(&'a self, id: usize, len: usize, nodes: &mut Vec<&'a BindingKind>) {\n         self.nodes[id].iter().take(len).for_each(|it| match it {\n             LinkNode::Node(it) => nodes.push(it),\n             LinkNode::Parent { idx, len } => self.collect_nodes_ref(*idx, *len, nodes),\n@@ -291,7 +282,7 @@ impl BindingsBuilder {\n     fn collect_nodes<'a>(\n         &'a self,\n         link_nodes: &'a [LinkNode<Rc<BindingKind>>],\n-        nodes: &mut Vec<&'a Rc<BindingKind>>,\n+        nodes: &mut Vec<&'a BindingKind>,\n     ) {\n         link_nodes.iter().for_each(|it| match it {\n             LinkNode::Node(it) => nodes.push(it),\n@@ -386,10 +377,10 @@ fn match_loop_inner<'t>(\n         let op = match item.dot.peek() {\n             None => {\n                 // We are at or past the end of the matcher of `item`.\n-                if item.up.is_some() {\n+                if let Some(up) = &item.up {\n                     if item.sep_parsed.is_none() {\n                         // Get the `up` matcher\n-                        let mut new_pos = *item.up.clone().unwrap();\n+                        let mut new_pos = (**up).clone();\n                         new_pos.bindings = bindings_builder.copy(&new_pos.bindings);\n                         // Add matches from this repetition to the `matches` of `up`\n                         bindings_builder.push_nested(&mut new_pos.bindings, &item.bindings);\n@@ -402,7 +393,7 @@ fn match_loop_inner<'t>(\n \n                     // Check if we need a separator.\n                     // We check the separator one by one\n-                    let sep_idx = *item.sep_parsed.as_ref().unwrap_or(&0);\n+                    let sep_idx = item.sep_parsed.unwrap_or(0);\n                     let sep_len = item.sep.as_ref().map_or(0, Separator::tt_count);\n                     if item.sep.is_some() && sep_idx != sep_len {\n                         let sep = item.sep.as_ref().unwrap();"}]}