{"sha": "5cd1599fc9d012e6337501239a1f10e7b9ca0ee1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjZDE1OTlmYzlkMDEyZTYzMzc1MDEyMzlhMWYxMGU3YjljYTBlZTE=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2020-04-10T10:48:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-10T10:48:47Z"}, "message": "Rollup merge of #70932 - mark-i-m:de-abuse-err-2, r=Centril\n\nDe-abuse TyKind::Error in pattern type checking\n\nr? @eddyb\n\ncc https://github.com/rust-lang/rust/issues/70866\n\nIn particular, I would appreciate extra scrutiny over the soundness of these changes.\n\nAlso, this will go a bit slowly because I'm going to use my other PR (#70551) to check if I missed anything.", "tree": {"sha": "5086e6d8bd6ff8e2e98e06959e68569328bbb225", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5086e6d8bd6ff8e2e98e06959e68569328bbb225"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5cd1599fc9d012e6337501239a1f10e7b9ca0ee1", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJekE8PCRBK7hj4Ov3rIwAAdHIIAAIYAEAlz8cpB5ZloSWO3RpE\n+x7eib/h0gxlg60nH3rFatqq3hJmgsjakPMSwJKfaaTsLaGEfeqnBA9Fg3zYjb/f\na2HiTA6HGdLgoHkUzhKf6uGXmLcTOxNiLbaRLN9O0N3LzZJ/Gpw5rcM5MIPBo2NN\nc5iLycxuZwTXjc9c4t+Lozf75Y0jksf18OEDq9A4QirK8RTR+Cdlm0IxYKXNnDzY\nv7Bx+PX04Ng1W5v9i93mQJx18GetTEDVFDFqWv13HVjCBG/cU/QCsl4wE0/WFADw\nFC+9oc9Is93DHxT/wpyDzQga2xM1fHyoPoNgrW16uTBjLegYAENnSBp7piS8IvE=\n=x9m+\n-----END PGP SIGNATURE-----\n", "payload": "tree 5086e6d8bd6ff8e2e98e06959e68569328bbb225\nparent 74e93bb8e6cd15dd262868b5e13605e9c595bef7\nparent f2e4709f2252103a2461991dba209f8ab4d76aca\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1586515727 +0200\ncommitter GitHub <noreply@github.com> 1586515727 +0200\n\nRollup merge of #70932 - mark-i-m:de-abuse-err-2, r=Centril\n\nDe-abuse TyKind::Error in pattern type checking\n\nr? @eddyb\n\ncc https://github.com/rust-lang/rust/issues/70866\n\nIn particular, I would appreciate extra scrutiny over the soundness of these changes.\n\nAlso, this will go a bit slowly because I'm going to use my other PR (#70551) to check if I missed anything.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5cd1599fc9d012e6337501239a1f10e7b9ca0ee1", "html_url": "https://github.com/rust-lang/rust/commit/5cd1599fc9d012e6337501239a1f10e7b9ca0ee1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5cd1599fc9d012e6337501239a1f10e7b9ca0ee1/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "74e93bb8e6cd15dd262868b5e13605e9c595bef7", "url": "https://api.github.com/repos/rust-lang/rust/commits/74e93bb8e6cd15dd262868b5e13605e9c595bef7", "html_url": "https://github.com/rust-lang/rust/commit/74e93bb8e6cd15dd262868b5e13605e9c595bef7"}, {"sha": "f2e4709f2252103a2461991dba209f8ab4d76aca", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2e4709f2252103a2461991dba209f8ab4d76aca", "html_url": "https://github.com/rust-lang/rust/commit/f2e4709f2252103a2461991dba209f8ab4d76aca"}], "stats": {"total": 38, "additions": 22, "deletions": 16}, "files": [{"sha": "0335aba914460150bff0ca9710e618c5c412e393", "filename": "src/librustc_typeck/check/pat.rs", "status": "modified", "additions": 22, "deletions": 16, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/5cd1599fc9d012e6337501239a1f10e7b9ca0ee1/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5cd1599fc9d012e6337501239a1f10e7b9ca0ee1/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fpat.rs?ref=5cd1599fc9d012e6337501239a1f10e7b9ca0ee1", "patch": "@@ -1353,23 +1353,26 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         def_bm: BindingMode,\n         ti: TopInfo<'tcx>,\n     ) -> Ty<'tcx> {\n-        let err = self.tcx.types.err;\n         let expected = self.structurally_resolved_type(span, expected);\n-        let (element_ty, slice_ty, inferred) = match expected.kind {\n+        let (element_ty, opt_slice_ty, inferred) = match expected.kind {\n             // An array, so we might have something like `let [a, b, c] = [0, 1, 2];`.\n             ty::Array(element_ty, len) => {\n                 let min = before.len() as u64 + after.len() as u64;\n-                let (slice_ty, expected) =\n+                let (opt_slice_ty, expected) =\n                     self.check_array_pat_len(span, element_ty, expected, slice, len, min);\n-                (element_ty, slice_ty, expected)\n+                // `opt_slice_ty.is_none()` => `slice.is_none()`.\n+                // Note, though, that opt_slice_ty could be `Some(error_ty)`.\n+                assert!(opt_slice_ty.is_some() || slice.is_none());\n+                (element_ty, opt_slice_ty, expected)\n             }\n-            ty::Slice(element_ty) => (element_ty, expected, expected),\n+            ty::Slice(element_ty) => (element_ty, Some(expected), expected),\n             // The expected type must be an array or slice, but was neither, so error.\n             _ => {\n                 if !expected.references_error() {\n                     self.error_expected_array_or_slice(span, expected);\n                 }\n-                (err, err, err)\n+                let err = self.tcx.types.err;\n+                (err, Some(err), err)\n             }\n         };\n \n@@ -1379,7 +1382,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         // Type check the `slice`, if present, against its expected type.\n         if let Some(slice) = slice {\n-            self.check_pat(&slice, slice_ty, def_bm, ti);\n+            self.check_pat(&slice, opt_slice_ty.unwrap(), def_bm, ti);\n         }\n         // Type check the elements after `slice`, if present.\n         for elt in after {\n@@ -1390,9 +1393,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     /// Type check the length of an array pattern.\n     ///\n-    /// Returns both the type of the variable length pattern\n-    /// (or `tcx.err` in case there is none),\n-    /// and the potentially inferred array type.\n+    /// Returns both the type of the variable length pattern (or `None`), and the potentially\n+    /// inferred array type. We only return `None` for the slice type if `slice.is_none()`.\n     fn check_array_pat_len(\n         &self,\n         span: Span,\n@@ -1401,20 +1403,22 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         slice: Option<&'tcx Pat<'tcx>>,\n         len: &ty::Const<'tcx>,\n         min_len: u64,\n-    ) -> (Ty<'tcx>, Ty<'tcx>) {\n+    ) -> (Option<Ty<'tcx>>, Ty<'tcx>) {\n         if let Some(len) = len.try_eval_usize(self.tcx, self.param_env) {\n             // Now we know the length...\n             if slice.is_none() {\n                 // ...and since there is no variable-length pattern,\n                 // we require an exact match between the number of elements\n                 // in the array pattern and as provided by the matched type.\n-                if min_len != len {\n-                    self.error_scrutinee_inconsistent_length(span, min_len, len);\n+                if min_len == len {\n+                    return (None, arr_ty);\n                 }\n+\n+                self.error_scrutinee_inconsistent_length(span, min_len, len);\n             } else if let Some(pat_len) = len.checked_sub(min_len) {\n                 // The variable-length pattern was there,\n                 // so it has an array type with the remaining elements left as its size...\n-                return (self.tcx.mk_array(element_ty, pat_len), arr_ty);\n+                return (Some(self.tcx.mk_array(element_ty, pat_len)), arr_ty);\n             } else {\n                 // ...however, in this case, there were no remaining elements.\n                 // That is, the slice pattern requires more than the array type offers.\n@@ -1425,14 +1429,16 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             // which we can use to infer the length of the array.\n             let updated_arr_ty = self.tcx.mk_array(element_ty, min_len);\n             self.demand_eqtype(span, updated_arr_ty, arr_ty);\n-            return (self.tcx.types.err, updated_arr_ty);\n+            return (None, updated_arr_ty);\n         } else {\n             // We have a variable-length pattern and don't know the array length.\n             // This happens if we have e.g.,\n             // `let [a, b, ..] = arr` where `arr: [T; N]` where `const N: usize`.\n             self.error_scrutinee_unfixed_length(span);\n         }\n-        (self.tcx.types.err, arr_ty)\n+\n+        // If we get here, we must have emitted an error.\n+        (Some(self.tcx.types.err), arr_ty)\n     }\n \n     fn error_scrutinee_inconsistent_length(&self, span: Span, min_len: u64, size: u64) {"}]}