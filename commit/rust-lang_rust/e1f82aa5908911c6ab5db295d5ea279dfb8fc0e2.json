{"sha": "e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUxZjgyYWE1OTA4OTExYzZhYjVkYjI5NWQ1ZWEyNzlkZmI4ZmMwZTI=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-07T00:48:13Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-04-15T11:06:29Z"}, "message": "determine whether a borrow is active based solely on the location", "tree": {"sha": "c64511ba250cfc6fdd3ec3ededbacc449f74ae9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c64511ba250cfc6fdd3ec3ededbacc449f74ae9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2", "html_url": "https://github.com/rust-lang/rust/commit/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f93d5d30bd0d141f7c5acabb5d612897eaf83303", "url": "https://api.github.com/repos/rust-lang/rust/commits/f93d5d30bd0d141f7c5acabb5d612897eaf83303", "html_url": "https://github.com/rust-lang/rust/commit/f93d5d30bd0d141f7c5acabb5d612897eaf83303"}], "stats": {"total": 119, "additions": 111, "deletions": 8}, "files": [{"sha": "c525c4ed651f244faf93df66289f4884629441c3", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2", "patch": "@@ -1991,7 +1991,7 @@ impl Location {\n         Location { block: self.block, statement_index: self.statement_index + 1 }\n     }\n \n-    pub fn dominates(&self, other: &Location, dominators: &Dominators<BasicBlock>) -> bool {\n+    pub fn dominates(&self, other: Location, dominators: &Dominators<BasicBlock>) -> bool {\n         if self.block == other.block {\n             self.statement_index <= other.statement_index\n         } else {"}, {"sha": "2e64626e2ea401930f0ce5cf270dab5043593b0a", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 76, "deletions": 7, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2", "patch": "@@ -22,6 +22,7 @@ use rustc::mir::{Mir, Mutability, Operand, Projection, ProjectionElem, Rvalue};\n use rustc::mir::{Field, Statement, StatementKind, Terminator, TerminatorKind};\n use rustc::mir::ClosureRegionRequirements;\n \n+use rustc_data_structures::control_flow_graph::dominators::Dominators;\n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_set::IdxSetBuf;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -66,8 +67,6 @@ pub fn provide(providers: &mut Providers) {\n     };\n }\n \n-struct IsActive(bool);\n-\n fn mir_borrowck<'a, 'tcx>(\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     def_id: DefId,\n@@ -234,6 +233,8 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         _ => false,\n     };\n \n+    let dominators = mir.dominators();\n+\n     let mut mbcx = MirBorrowckCtxt {\n         tcx: tcx,\n         mir: mir,\n@@ -250,6 +251,7 @@ fn do_mir_borrowck<'a, 'gcx, 'tcx>(\n         moved_error_reported: FxHashSet(),\n         nonlexical_regioncx: opt_regioncx,\n         nonlexical_cause_info: None,\n+        dominators,\n     };\n \n     let mut state = Flows::new(\n@@ -302,6 +304,7 @@ pub struct MirBorrowckCtxt<'cx, 'gcx: 'tcx, 'tcx: 'cx> {\n     /// find out which CFG points are contained in each borrow region.\n     nonlexical_regioncx: Option<Rc<RegionInferenceContext<'tcx>>>,\n     nonlexical_cause_info: Option<RegionCausalInfo>,\n+    dominators: Dominators<BasicBlock>,\n }\n \n // Check that:\n@@ -856,7 +859,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             context,\n             (sd, place_span.0),\n             flow_state,\n-            |this, borrow_index, is_active, borrow| match (rw, borrow.kind) {\n+            |this, borrow_index, borrow| match (rw, borrow.kind) {\n                 // Obviously an activation is compatible with its own\n                 // reservation (or even prior activating uses of same\n                 // borrow); so don't check if they interfere.\n@@ -881,7 +884,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n                 (Read(kind), BorrowKind::Unique) | (Read(kind), BorrowKind::Mut { .. }) => {\n                     // Reading from mere reservations of mutable-borrows is OK.\n-                    if this.allow_two_phase_borrow(borrow.kind) && !is_active.0 {\n+                    if !this.is_active(borrow, context.loc) {\n+                        assert!(this.allow_two_phase_borrow(borrow.kind));\n                         return Control::Continue;\n                     }\n \n@@ -2234,7 +2238,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         flow_state: &Flows<'cx, 'gcx, 'tcx>,\n         mut op: F,\n     ) where\n-        F: FnMut(&mut Self, BorrowIndex, IsActive, &BorrowData<'tcx>) -> Control,\n+        F: FnMut(&mut Self, BorrowIndex, &BorrowData<'tcx>) -> Control,\n     {\n         let (access, place) = access_place;\n \n@@ -2247,21 +2251,86 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // borrows of P, P.a.b, etc.\n         let mut iter_incoming = flow_state.borrows.iter_incoming();\n         while let Some(i) = iter_incoming.next() {\n+            // TODO -- for now, just skip activations, since\n+            // everywhere that activation is set, reservation should\n+            // be set\n+            if i.is_activation() {\n+                continue;\n+            }\n+\n             let borrowed = &data[i.borrow_index()];\n \n             if self.places_conflict(&borrowed.borrowed_place, place, access) {\n                 debug!(\n                     \"each_borrow_involving_path: {:?} @ {:?} vs. {:?}/{:?}\",\n                     i, borrowed, place, access\n                 );\n-                let is_active = IsActive(i.is_activation());\n-                let ctrl = op(self, i.borrow_index(), is_active, borrowed);\n+                let ctrl = op(self, i.borrow_index(), borrowed);\n                 if ctrl == Control::Break {\n                     return;\n                 }\n             }\n         }\n     }\n+\n+    fn is_active(\n+        &self,\n+        borrow_data: &BorrowData<'tcx>,\n+        location: Location\n+    ) -> bool {\n+        debug!(\"is_active(borrow_data={:?}, location={:?})\", borrow_data, location);\n+\n+        // If this is not a 2-phase borrow, it is always active.\n+        let activation_location = match borrow_data.activation_location {\n+            Some(v) => v,\n+            None => return true,\n+        };\n+\n+        // Otherwise, it is active for every location *except* in between\n+        // the reservation and the activation:\n+        //\n+        //       X\n+        //      /\n+        //     R      <--+ Except for this\n+        //    / \\        | diamond\n+        //    \\ /        |\n+        //     A  <------+\n+        //     |\n+        //     Z\n+        //\n+        // Note that we assume that:\n+        // - the reservation R dominates the activation A\n+        // - the activation A post-dominates the reservation R (ignoring unwinding edges).\n+        //\n+        // This means that there can't be an edge that leaves A and\n+        // comes back into that diamond unless it passes through R.\n+        //\n+        // Suboptimal: In some cases, this code walks the dominator\n+        // tree twice when it only has to be walked once. I am\n+        // lazy. -nmatsakis\n+\n+        // If dominated by the activation A, then it is active. The\n+        // activation occurs upon entering the point A, so this is\n+        // also true if location == activation_location.\n+        if activation_location.dominates(location, &self.dominators) {\n+            return true;\n+        }\n+\n+        // The reservation starts *on exiting* the reservation block,\n+        // so check if the location is dominated by R.successor. If so,\n+        // this point falls in between the reservation and location.\n+        let reserve_location = borrow_data.reserve_location.successor_within_block();\n+        if reserve_location.dominates(location, &self.dominators) {\n+            false\n+        } else {\n+            // Otherwise, this point is outside the diamond, so\n+            // consider the borrow active. This could happen for\n+            // example if the borrow remains active around a loop (in\n+            // which case it would be active also for the point R,\n+            // which would generate an error).\n+            true\n+        }\n+    }\n }\n \n impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {"}, {"sha": "e03a0355b48d6ea60b7b7633e9f17e0ee70d5814", "filename": "src/test/compile-fail/borrowck/two-phase-across-loop.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-across-loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-across-loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck%2Ftwo-phase-across-loop.rs?ref=e1f82aa5908911c6ab5db295d5ea279dfb8fc0e2", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that a borrow which starts as a 2-phase borrow and gets\n+// carried around a loop winds up conflicting with itself.\n+\n+#![feature(nll)]\n+\n+struct Foo { x: String }\n+\n+impl Foo {\n+    fn get_string(&mut self) -> &str {\n+        &self.x\n+    }\n+}\n+\n+fn main() {\n+    let mut foo = Foo { x: format!(\"Hello, world\") };\n+    let mut strings = vec![];\n+\n+    loop {\n+        strings.push(foo.get_string()); //~ ERROR cannot borrow `foo` as mutable\n+        if strings.len() > 2 { break; }\n+    }\n+\n+    println!(\"{:?}\", strings);\n+}"}]}