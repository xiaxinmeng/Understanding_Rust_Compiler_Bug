{"sha": "a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyNjFiYzVmYWRjM2M3MmZkODgyOGQ2NGM0MjgxMDk3YjJlN2MwYjA=", "commit": {"author": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-02T18:32:56Z"}, "committer": {"name": "Jason Newcomb", "email": "jsnewcomb@pm.me", "date": "2021-03-13T13:39:48Z"}, "message": "Make `explicit_deref_methods` check for multiple deref calls\nFix suggestion for `explicit_deref_methods`. Sometimes `&**` is needed, sometimes nothing is needed.\nAllow `explicit_deref_methods` to trigger in a few new contexts.\n`explicit_deref_methods` will now consider ufcs calls", "tree": {"sha": "3ae786e6aab05bda25c5998b18c77bedb97a5ea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ae786e6aab05bda25c5998b18c77bedb97a5ea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nComment: Created with Krypton\n\niF4EABYKAAYFAmBMwKoACgkQ2lnoZDo37QYyoAD/Ug0+qWRRMS3AP1Q0MINTy+7T\n/ZPL1j566B8Z7hnWarIBAPmm5zuKfz9+PBECVNvUQcBuSJQ+Fn10GSZDC8We7OID\n=E1C5\n-----END PGP SIGNATURE-----", "payload": "tree 3ae786e6aab05bda25c5998b18c77bedb97a5ea8\nparent 65d046c9addea00de5b7cc0e33cffdec465dade8\nauthor Jason Newcomb <jsnewcomb@pm.me> 1614709976 -0500\ncommitter Jason Newcomb <jsnewcomb@pm.me> 1615642788 -0500\n\nMake `explicit_deref_methods` check for multiple deref calls\nFix suggestion for `explicit_deref_methods`. Sometimes `&**` is needed, sometimes nothing is needed.\nAllow `explicit_deref_methods` to trigger in a few new contexts.\n`explicit_deref_methods` will now consider ufcs calls\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "html_url": "https://github.com/rust-lang/rust/commit/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/comments", "author": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Jarcho", "id": 7761774, "node_id": "MDQ6VXNlcjc3NjE3NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/7761774?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Jarcho", "html_url": "https://github.com/Jarcho", "followers_url": "https://api.github.com/users/Jarcho/followers", "following_url": "https://api.github.com/users/Jarcho/following{/other_user}", "gists_url": "https://api.github.com/users/Jarcho/gists{/gist_id}", "starred_url": "https://api.github.com/users/Jarcho/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Jarcho/subscriptions", "organizations_url": "https://api.github.com/users/Jarcho/orgs", "repos_url": "https://api.github.com/users/Jarcho/repos", "events_url": "https://api.github.com/users/Jarcho/events{/privacy}", "received_events_url": "https://api.github.com/users/Jarcho/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "65d046c9addea00de5b7cc0e33cffdec465dade8", "url": "https://api.github.com/repos/rust-lang/rust/commits/65d046c9addea00de5b7cc0e33cffdec465dade8", "html_url": "https://github.com/rust-lang/rust/commit/65d046c9addea00de5b7cc0e33cffdec465dade8"}], "stats": {"total": 584, "additions": 461, "deletions": 123}, "files": [{"sha": "a33634ca34ee6c54f9f5a845833c05b42c9d5a9d", "filename": "clippy_lints/src/dereference.rs", "status": "modified", "additions": 304, "deletions": 65, "changes": 369, "blob_url": "https://github.com/rust-lang/rust/blob/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_lints%2Fsrc%2Fdereference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_lints%2Fsrc%2Fdereference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fdereference.rs?ref=a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "patch": "@@ -1,11 +1,13 @@\n-use crate::utils::{get_parent_expr, implements_trait, snippet, span_lint_and_sugg};\n-use if_chain::if_chain;\n-use rustc_ast::util::parser::{ExprPrecedence, PREC_POSTFIX, PREC_PREFIX};\n+use crate::utils::{\n+    get_node_span, get_parent_node, in_macro, is_allowed, peel_mid_ty_refs, snippet_with_context, span_lint_and_sugg,\n+};\n+use rustc_ast::util::parser::PREC_PREFIX;\n use rustc_errors::Applicability;\n-use rustc_hir::{Expr, ExprKind};\n+use rustc_hir::{BorrowKind, Destination, Expr, ExprKind, HirId, MatchSource, Mutability, Node, UnOp};\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_session::{declare_lint_pass, declare_tool_lint};\n-use rustc_span::source_map::Span;\n+use rustc_middle::ty::{self, adjustment::Adjustment, Ty, TyCtxt, TyS, TypeckResults};\n+use rustc_session::{declare_tool_lint, impl_lint_pass};\n+use rustc_span::{symbol::sym, Span};\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for explicit `deref()` or `deref_mut()` method calls.\n@@ -34,76 +36,313 @@ declare_clippy_lint! {\n     \"Explicit use of deref or deref_mut method while not in a method chain.\"\n }\n \n-declare_lint_pass!(Dereferencing => [\n-    EXPLICIT_DEREF_METHODS\n+impl_lint_pass!(Dereferencing => [\n+    EXPLICIT_DEREF_METHODS,\n ]);\n \n+#[derive(Default)]\n+pub struct Dereferencing {\n+    state: Option<(State, StateData)>,\n+\n+    // While parsing a `deref` method call in ufcs form, the path to the function is itself an\n+    // expression. This is to store the id of that expression so it can be skipped when\n+    // `check_expr` is called for it.\n+    skip_expr: Option<HirId>,\n+}\n+\n+struct StateData {\n+    /// Span of the top level expression\n+    span: Span,\n+    /// The required mutability\n+    target_mut: Mutability,\n+}\n+\n+enum State {\n+    // Any number of deref method calls.\n+    DerefMethod {\n+        // The number of calls in a sequence which changed the referenced type\n+        ty_changed_count: usize,\n+        is_final_ufcs: bool,\n+    },\n+}\n+\n+// A reference operation considered by this lint pass\n+enum RefOp {\n+    Method,\n+    Deref,\n+    AddrOf,\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for Dereferencing {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n-        if_chain! {\n-            if !expr.span.from_expansion();\n-            if let ExprKind::MethodCall(ref method_name, _, ref args, _) = &expr.kind;\n-            if args.len() == 1;\n-\n-            then {\n-                if let Some(parent_expr) = get_parent_expr(cx, expr) {\n-                    // Check if we have the whole call chain here\n-                    if let ExprKind::MethodCall(..) = parent_expr.kind {\n-                        return;\n-                    }\n-                    // Check for Expr that we don't want to be linted\n-                    let precedence = parent_expr.precedence();\n-                    match precedence {\n-                        // Lint a Call is ok though\n-                        ExprPrecedence::Call | ExprPrecedence::AddrOf => (),\n-                        _ => {\n-                            if precedence.order() >= PREC_PREFIX && precedence.order() <= PREC_POSTFIX {\n-                                return;\n-                            }\n-                        }\n+        // Skip path expressions from deref calls. e.g. `Deref::deref(e)`\n+        if Some(expr.hir_id) == self.skip_expr.take() {\n+            return;\n+        }\n+\n+        // Stop processing sub expressions when a macro call is seen\n+        if in_macro(expr.span) {\n+            if let Some((state, data)) = self.state.take() {\n+                report(cx, expr, state, data);\n+            }\n+            return;\n+        }\n+\n+        let typeck = cx.typeck_results();\n+        let (kind, sub_expr) = if let Some(x) = try_parse_ref_op(cx.tcx, typeck, expr) {\n+            x\n+        } else {\n+            // The whole chain of reference operations has been seen\n+            if let Some((state, data)) = self.state.take() {\n+                report(cx, expr, state, data);\n+            }\n+            return;\n+        };\n+\n+        match (self.state.take(), kind) {\n+            (None, kind) => {\n+                let parent = get_parent_node(cx.tcx, expr.hir_id);\n+                // This is an odd case. The expression is a macro argument, but the top level\n+                // address of expression is inserted by the compiler.\n+                if matches!(kind, RefOp::AddrOf) && parent.and_then(get_node_span).map_or(false, in_macro) {\n+                    return;\n+                }\n+\n+                let expr_adjustments = find_adjustments(cx.tcx, typeck, expr);\n+                let expr_ty = typeck.expr_ty(expr);\n+                let target_mut =\n+                    if let ty::Ref(_, _, mutability) = *expr_adjustments.last().map_or(expr_ty, |a| a.target).kind() {\n+                        mutability\n+                    } else {\n+                        Mutability::Not\n+                    };\n+\n+                match kind {\n+                    RefOp::Method\n+                        if !is_allowed(cx, EXPLICIT_DEREF_METHODS, expr.hir_id)\n+                            && is_linted_explicit_deref_position(parent, expr.hir_id) =>\n+                    {\n+                        self.state = Some((\n+                            State::DerefMethod {\n+                                ty_changed_count: if deref_method_same_type(expr_ty, typeck.expr_ty(sub_expr)) {\n+                                    0\n+                                } else {\n+                                    1\n+                                },\n+                                is_final_ufcs: matches!(expr.kind, ExprKind::Call(..)),\n+                            },\n+                            StateData {\n+                                span: expr.span,\n+                                target_mut,\n+                            },\n+                        ));\n                     }\n+                    _ => (),\n                 }\n-                let name = method_name.ident.as_str();\n-                lint_deref(cx, &*name, &args[0], args[0].span, expr.span);\n-            }\n+            },\n+            (Some((State::DerefMethod { ty_changed_count, .. }, data)), RefOp::Method) => {\n+                self.state = Some((\n+                    State::DerefMethod {\n+                        ty_changed_count: if deref_method_same_type(typeck.expr_ty(expr), typeck.expr_ty(sub_expr)) {\n+                            ty_changed_count\n+                        } else {\n+                            ty_changed_count + 1\n+                        },\n+                        is_final_ufcs: matches!(expr.kind, ExprKind::Call(..)),\n+                    },\n+                    data,\n+                ));\n+            },\n+\n+            (Some((state, data)), _) => report(cx, expr, state, data),\n         }\n     }\n }\n \n-fn lint_deref(cx: &LateContext<'_>, method_name: &str, call_expr: &Expr<'_>, var_span: Span, expr_span: Span) {\n-    match method_name {\n-        \"deref\" => {\n-            let impls_deref_trait = cx.tcx.lang_items().deref_trait().map_or(false, |id| {\n-                implements_trait(cx, cx.typeck_results().expr_ty(&call_expr), id, &[])\n-            });\n-            if impls_deref_trait {\n-                span_lint_and_sugg(\n-                    cx,\n-                    EXPLICIT_DEREF_METHODS,\n-                    expr_span,\n-                    \"explicit deref method call\",\n-                    \"try this\",\n-                    format!(\"&*{}\", &snippet(cx, var_span, \"..\")),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n+fn try_parse_ref_op(\n+    tcx: TyCtxt<'tcx>,\n+    typeck: &'tcx TypeckResults<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> Option<(RefOp, &'tcx Expr<'tcx>)> {\n+    let (def_id, arg) = match expr.kind {\n+        ExprKind::MethodCall(_, _, [arg], _) => (typeck.type_dependent_def_id(expr.hir_id)?, arg),\n+        ExprKind::Call(\n+            Expr {\n+                kind: ExprKind::Path(path),\n+                hir_id,\n+                ..\n+            },\n+            [arg],\n+        ) => (typeck.qpath_res(path, *hir_id).opt_def_id()?, arg),\n+        ExprKind::Unary(UnOp::Deref, sub_expr) if !typeck.expr_ty(sub_expr).is_unsafe_ptr() => {\n+            return Some((RefOp::Deref, sub_expr));\n         },\n-        \"deref_mut\" => {\n-            let impls_deref_mut_trait = cx.tcx.lang_items().deref_mut_trait().map_or(false, |id| {\n-                implements_trait(cx, cx.typeck_results().expr_ty(&call_expr), id, &[])\n-            });\n-            if impls_deref_mut_trait {\n-                span_lint_and_sugg(\n-                    cx,\n-                    EXPLICIT_DEREF_METHODS,\n-                    expr_span,\n-                    \"explicit deref_mut method call\",\n-                    \"try this\",\n-                    format!(\"&mut *{}\", &snippet(cx, var_span, \"..\")),\n-                    Applicability::MachineApplicable,\n-                );\n-            }\n+        ExprKind::AddrOf(BorrowKind::Ref, _, sub_expr) => return Some((RefOp::AddrOf, sub_expr)),\n+        _ => return None,\n+    };\n+    (tcx.is_diagnostic_item(sym::deref_method, def_id)\n+        || tcx.trait_of_item(def_id)? == tcx.lang_items().deref_mut_trait()?)\n+    .then(|| (RefOp::Method, arg))\n+}\n+\n+// Checks whether the type for a deref call actually changed the type, not just the mutability of\n+// the reference.\n+fn deref_method_same_type(result_ty: Ty<'tcx>, arg_ty: Ty<'tcx>) -> bool {\n+    match (result_ty.kind(), arg_ty.kind()) {\n+        (ty::Ref(_, result_ty, _), ty::Ref(_, arg_ty, _)) => TyS::same_type(result_ty, arg_ty),\n+\n+        // The result type for a deref method is always a reference\n+        // Not matching the previous pattern means the argument type is not a reference\n+        // This means that the type did change\n+        _ => false,\n+    }\n+}\n+\n+// Adjustments are sometimes made in the parent block rather than the expression itself.\n+fn find_adjustments(\n+    tcx: TyCtxt<'tcx>,\n+    typeck: &'tcx TypeckResults<'_>,\n+    expr: &'tcx Expr<'_>,\n+) -> &'tcx [Adjustment<'tcx>] {\n+    let map = tcx.hir();\n+    let mut iter = map.parent_iter(expr.hir_id);\n+    let mut prev = expr;\n+\n+    loop {\n+        match typeck.expr_adjustments(prev) {\n+            [] => (),\n+            a => break a,\n+        };\n+\n+        match iter.next().map(|(_, x)| x) {\n+            Some(Node::Block(_)) => {\n+                if let Some((_, Node::Expr(e))) = iter.next() {\n+                    prev = e;\n+                } else {\n+                    // This shouldn't happen. Blocks are always contained in an expression.\n+                    break &[];\n+                }\n+            },\n+            Some(Node::Expr(&Expr {\n+                kind: ExprKind::Break(Destination { target_id: Ok(id), .. }, _),\n+                ..\n+            })) => {\n+                if let Some(Node::Expr(e)) = map.find(id) {\n+                    prev = e;\n+                    iter = map.parent_iter(id);\n+                    continue;\n+                }\n+                // This shouldn't happen. The destination should definitely exist at this point.\n+                break &[];\n+            },\n+            _ => break &[],\n+        }\n+    }\n+}\n+\n+// Checks whether the parent node is a suitable context for switching from a deref method to the\n+// deref operator.\n+fn is_linted_explicit_deref_position(parent: Option<Node<'_>>, child_id: HirId) -> bool {\n+    let parent = match parent {\n+        Some(Node::Expr(e)) => e,\n+        _ => return true,\n+    };\n+    match parent.kind {\n+        // Leave deref calls in the middle of a method chain.\n+        // e.g. x.deref().foo()\n+        ExprKind::MethodCall(_, _, [self_arg, ..], _) if self_arg.hir_id == child_id => false,\n+\n+        // Leave deref calls resulting in a called function\n+        // e.g. (x.deref())()\n+        ExprKind::Call(func_expr, _) if func_expr.hir_id == child_id => false,\n+\n+        // Makes an ugly suggestion\n+        // e.g. *x.deref() => *&*x\n+        ExprKind::Unary(UnOp::Deref, _)\n+        // Postfix expressions would require parens\n+        | ExprKind::Match(_, _, MatchSource::TryDesugar | MatchSource::AwaitDesugar)\n+        | ExprKind::Field(..)\n+        | ExprKind::Index(..)\n+        | ExprKind::Err => false,\n+\n+        ExprKind::Box(..)\n+        | ExprKind::ConstBlock(..)\n+        | ExprKind::Array(_)\n+        | ExprKind::Call(..)\n+        | ExprKind::MethodCall(..)\n+        | ExprKind::Tup(..)\n+        | ExprKind::Binary(..)\n+        | ExprKind::Unary(..)\n+        | ExprKind::Lit(..)\n+        | ExprKind::Cast(..)\n+        | ExprKind::Type(..)\n+        | ExprKind::DropTemps(..)\n+        | ExprKind::If(..)\n+        | ExprKind::Loop(..)\n+        | ExprKind::Match(..)\n+        | ExprKind::Closure(..)\n+        | ExprKind::Block(..)\n+        | ExprKind::Assign(..)\n+        | ExprKind::AssignOp(..)\n+        | ExprKind::Path(..)\n+        | ExprKind::AddrOf(..)\n+        | ExprKind::Break(..)\n+        | ExprKind::Continue(..)\n+        | ExprKind::Ret(..)\n+        | ExprKind::InlineAsm(..)\n+        | ExprKind::LlvmInlineAsm(..)\n+        | ExprKind::Struct(..)\n+        | ExprKind::Repeat(..)\n+        | ExprKind::Yield(..) => true,\n+    }\n+}\n+\n+#[allow(clippy::needless_pass_by_value)]\n+fn report(cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>, state: State, data: StateData) {\n+    match state {\n+        State::DerefMethod {\n+            ty_changed_count,\n+            is_final_ufcs,\n+        } => {\n+            let mut app = Applicability::MachineApplicable;\n+            let (expr_str, expr_is_macro_call) = snippet_with_context(cx, expr.span, data.span.ctxt(), \"..\", &mut app);\n+            let ty = cx.typeck_results().expr_ty(expr);\n+            let (_, ref_count) = peel_mid_ty_refs(ty);\n+            let deref_str = if ty_changed_count >= ref_count && ref_count != 0 {\n+                // a deref call changing &T -> &U requires two deref operators the first time\n+                // this occurs. One to remove the reference, a second to call the deref impl.\n+                \"*\".repeat(ty_changed_count + 1)\n+            } else {\n+                \"*\".repeat(ty_changed_count)\n+            };\n+            let addr_of_str = if ty_changed_count < ref_count {\n+                // Check if a reborrow from &mut T -> &T is required.\n+                if data.target_mut == Mutability::Not && matches!(ty.kind(), ty::Ref(_, _, Mutability::Mut)) {\n+                    \"&*\"\n+                } else {\n+                    \"\"\n+                }\n+            } else if data.target_mut == Mutability::Mut {\n+                \"&mut \"\n+            } else {\n+                \"&\"\n+            };\n+\n+            let expr_str = if !expr_is_macro_call && is_final_ufcs && expr.precedence().order() < PREC_PREFIX {\n+                format!(\"({})\", expr_str)\n+            } else {\n+                expr_str.into_owned()\n+            };\n+\n+            span_lint_and_sugg(\n+                cx,\n+                EXPLICIT_DEREF_METHODS,\n+                data.span,\n+                \"explicit `deref` method call\",\n+                \"try this\",\n+                format!(\"{}{}{}\", addr_of_str, deref_str, expr_str),\n+                app,\n+            );\n         },\n-        _ => (),\n     }\n }"}, {"sha": "bf5688aa95c8b943a47f70f0e26055702b7e6461", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "patch": "@@ -1241,7 +1241,7 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box verbose_file_reads::VerboseFileReads);\n     store.register_late_pass(|| box redundant_pub_crate::RedundantPubCrate::default());\n     store.register_late_pass(|| box unnamed_address::UnnamedAddress);\n-    store.register_late_pass(|| box dereference::Dereferencing);\n+    store.register_late_pass(|| box dereference::Dereferencing::default());\n     store.register_late_pass(|| box option_if_let_else::OptionIfLetElse);\n     store.register_late_pass(|| box future_not_send::FutureNotSend);\n     store.register_late_pass(|| box if_let_mutex::IfLetMutex);"}, {"sha": "ea4cedc67545b725ad622fb917fe3fcb32e2786f", "filename": "clippy_lints/src/manual_map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_lints%2Fsrc%2Fmanual_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_lints%2Fsrc%2Fmanual_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmanual_map.rs?ref=a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "patch": "@@ -129,7 +129,7 @@ impl LateLintPass<'_> for ManualMap {\n             // Remove address-of expressions from the scrutinee. Either `as_ref` will be called, or\n             // it's being passed by value.\n             let scrutinee = peel_hir_expr_refs(scrutinee).0;\n-            let scrutinee_str = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n+            let (scrutinee_str, _) = snippet_with_context(cx, scrutinee.span, expr_ctxt, \"..\", &mut app);\n             let scrutinee_str =\n                 if scrutinee.span.ctxt() == expr.span.ctxt() && scrutinee.precedence().order() < PREC_POSTFIX {\n                     format!(\"({})\", scrutinee_str)\n@@ -160,16 +160,16 @@ impl LateLintPass<'_> for ManualMap {\n                             \"|{}{}| {}\",\n                             annotation,\n                             some_binding,\n-                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n+                            snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n                         )\n                     },\n                 }\n             } else if !is_wild_none && explicit_ref.is_none() {\n                 // TODO: handle explicit reference annotations.\n                 format!(\n                     \"|{}| {}\",\n-                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app),\n-                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app)\n+                    snippet_with_context(cx, some_pat.span, expr_ctxt, \"..\", &mut app).0,\n+                    snippet_with_context(cx, some_expr.span, expr_ctxt, \"..\", &mut app).0\n                 )\n             } else {\n                 // Refutable bindings and mixed reference annotations can't be handled by `map`."}, {"sha": "029583720d2f3309b6007f0914228612c147ad67", "filename": "clippy_lints/src/redundant_deref.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_lints%2Fsrc%2Fredundant_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_lints%2Fsrc%2Fredundant_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_deref.rs?ref=a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "patch": "@@ -0,0 +1,63 @@\n+// use crate::utils::{get_parent_expr, snippet_with_applicability, span_lint_and_sugg};\n+// use if_chain::if_chain;\n+// use rustc_errors::Applicability;\n+// use rustc_hir::{Expr, ExprKind, UnOp};\n+// use rustc_lint::{LateContext, LateLintPass, LintContext};\n+// use rustc_middle::lint::in_external_macro;\n+// use rustc_session::{declare_lint_pass, declare_tool_lint};\n+\n+// declare_clippy_lint! {\n+//     /// **What it does:** Checks for uses of the dereference operator which would be covered by\n+//     /// auto-dereferencing.\n+//     ///\n+//     /// **Why is this bad?** This unnecessarily complicates the code.\n+//     ///\n+//     /// **Known problems:** None.\n+//     ///\n+//     /// **Example:**\n+//     ///\n+//     /// ```rust\n+//     /// fn foo(_: &str) {}\n+//     /// foo(&*String::new())\n+//     /// ```\n+//     /// Use instead:\n+//     /// ```rust\n+//     /// fn foo(_: &str) {}\n+//     /// foo(&String::new())\n+//     /// ```\n+//     pub REDUNDANT_DEREF,\n+//     style,\n+//     \"default lint description\"\n+// }\n+\n+// declare_lint_pass!(RedundantDeref => [REDUNDANT_DEREF]);\n+\n+// impl LateLintPass<'_> for RedundantDeref {\n+//     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx Expr<'_>) {\n+//         if_chain! {\n+//             if let ExprKind::AddrOf(_, _, addr_expr) = expr.kind;\n+//             if let ExprKind::Unary(UnOp::UnDeref, deref_expr) = addr_expr.kind;\n+//             if !in_external_macro(cx.sess(), expr.span);\n+//             if let Some(parent_expr) = get_parent_expr(cx, expr);\n+//             if match parent_expr.kind {\n+//                 ExprKind::Call(func, _) => func.hir_id != expr.hir_id,\n+//                 ExprKind::MethodCall(..) => true,\n+//                 _ => false,\n+//             };\n+//             if !cx.typeck_results().expr_ty(deref_expr).is_unsafe_ptr();\n+//             then {\n+//                 let mut app = Applicability::MachineApplicable;\n+//                 let sugg = format!(\"&{}\", snippet_with_applicability(cx, deref_expr.span, \"_\", &mut app));\n+//                 span_lint_and_sugg(\n+//                     cx,\n+//                     REDUNDANT_DEREF,\n+//                     expr.span,\n+//                     \"redundant dereference\",\n+//                     \"remove the dereference\",\n+//                     sugg,\n+//                     app,\n+//                 );\n+//             }\n+//         }\n+//     }\n+// }"}, {"sha": "2ac2298ff7497eba9bc3ce69e044f27a16405273", "filename": "clippy_utils/src/lib.rs", "status": "modified", "additions": 59, "deletions": 23, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/clippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Flib.rs?ref=a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "patch": "@@ -61,11 +61,11 @@ use rustc_hir as hir;\n use rustc_hir::def::{CtorKind, CtorOf, DefKind, Res};\n use rustc_hir::def_id::{DefId, LOCAL_CRATE};\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n-use rustc_hir::Node;\n use rustc_hir::{\n-    def, Arm, Block, Body, Constness, Expr, ExprKind, FnDecl, GenericArgs, HirId, Impl, ImplItem, ImplItemKind, Item,\n-    ItemKind, LangItem, MatchSource, Param, Pat, PatKind, Path, PathSegment, QPath, TraitItem, TraitItemKind, TraitRef,\n-    TyKind, Unsafety,\n+    def, Arm, Block, Body, Constness, CrateItem, Expr, ExprKind, FnDecl, ForeignItem, GenericArgs, GenericParam, HirId,\n+    Impl, ImplItem, ImplItemKind, Item, ItemKind, LangItem, Lifetime, Local, MacroDef, MatchSource, Node, Param, Pat,\n+    PatKind, Path, PathSegment, QPath, Stmt, StructField, TraitItem, TraitItemKind, TraitRef, TyKind, Unsafety,\n+    Variant, Visibility,\n };\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, Level, Lint, LintContext};\n@@ -78,7 +78,7 @@ use rustc_session::Session;\n use rustc_span::hygiene::{self, ExpnKind, MacroKind};\n use rustc_span::source_map::original_sp;\n use rustc_span::sym;\n-use rustc_span::symbol::{kw, Symbol};\n+use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{BytePos, Pos, Span, SyntaxContext, DUMMY_SP};\n use rustc_target::abi::Integer;\n use rustc_trait_selection::traits::query::normalize::AtExt;\n@@ -852,26 +852,31 @@ pub fn snippet_block_with_applicability<'a, T: LintContext>(\n /// e.g. Given the expression `&vec![]`, getting a snippet from the span for `vec![]` as a HIR node\n /// would result in `box []`. If given the context of the address of expression, this function will\n /// correctly get a snippet of `vec![]`.\n+///\n+/// This will also return whether or not the snippet is a macro call.\n pub fn snippet_with_context(\n     cx: &LateContext<'_>,\n     span: Span,\n     outer: SyntaxContext,\n     default: &'a str,\n     applicability: &mut Applicability,\n-) -> Cow<'a, str> {\n+) -> (Cow<'a, str>, bool) {\n     let outer_span = hygiene::walk_chain(span, outer);\n-    let span = if outer_span.ctxt() == outer {\n-        outer_span\n+    let (span, is_macro_call) = if outer_span.ctxt() == outer {\n+        (outer_span, span.ctxt() != outer)\n     } else {\n         // The span is from a macro argument, and the outer context is the macro using the argument\n         if *applicability != Applicability::Unspecified {\n             *applicability = Applicability::MaybeIncorrect;\n         }\n         // TODO: get the argument span.\n-        span\n+        (span, false)\n     };\n \n-    snippet_with_applicability(cx, span, default, applicability)\n+    (\n+        snippet_with_applicability(cx, span, default, applicability),\n+        is_macro_call,\n+    )\n }\n \n /// Returns a new Span that extends the original Span to the first non-whitespace char of the first\n@@ -1013,21 +1018,52 @@ fn reindent_multiline_inner(s: &str, ignore_first: bool, indent: Option<usize>,\n         .join(\"\\n\")\n }\n \n+/// Gets the span of the node, if there is one.\n+pub fn get_node_span(node: Node<'_>) -> Option<Span> {\n+    match node {\n+        Node::Param(Param { span, .. })\n+        | Node::Item(Item { span, .. })\n+        | Node::ForeignItem(ForeignItem { span, .. })\n+        | Node::TraitItem(TraitItem { span, .. })\n+        | Node::ImplItem(ImplItem { span, .. })\n+        | Node::Variant(Variant { span, .. })\n+        | Node::Field(StructField { span, .. })\n+        | Node::Expr(Expr { span, .. })\n+        | Node::Stmt(Stmt { span, .. })\n+        | Node::PathSegment(PathSegment {\n+            ident: Ident { span, .. },\n+            ..\n+        })\n+        | Node::Ty(hir::Ty { span, .. })\n+        | Node::TraitRef(TraitRef {\n+            path: Path { span, .. },\n+            ..\n+        })\n+        | Node::Binding(Pat { span, .. })\n+        | Node::Pat(Pat { span, .. })\n+        | Node::Arm(Arm { span, .. })\n+        | Node::Block(Block { span, .. })\n+        | Node::Local(Local { span, .. })\n+        | Node::MacroDef(MacroDef { span, .. })\n+        | Node::Lifetime(Lifetime { span, .. })\n+        | Node::GenericParam(GenericParam { span, .. })\n+        | Node::Visibility(Visibility { span, .. })\n+        | Node::Crate(CrateItem { span, .. }) => Some(*span),\n+        Node::Ctor(_) | Node::AnonConst(_) => None,\n+    }\n+}\n+\n+/// Gets the parent node, if any.\n+pub fn get_parent_node(tcx: TyCtxt<'_>, id: HirId) -> Option<Node<'_>> {\n+    tcx.hir().parent_iter(id).next().map(|(_, node)| node)\n+}\n+\n /// Gets the parent expression, if any \u2013- this is useful to constrain a lint.\n pub fn get_parent_expr<'tcx>(cx: &LateContext<'tcx>, e: &Expr<'_>) -> Option<&'tcx Expr<'tcx>> {\n-    let map = &cx.tcx.hir();\n-    let hir_id = e.hir_id;\n-    let parent_id = map.get_parent_node(hir_id);\n-    if hir_id == parent_id {\n-        return None;\n-    }\n-    map.find(parent_id).and_then(|node| {\n-        if let Node::Expr(parent) = node {\n-            Some(parent)\n-        } else {\n-            None\n-        }\n-    })\n+    match get_parent_node(cx.tcx, e.hir_id) {\n+        Some(Node::Expr(parent)) => Some(parent),\n+        _ => None,\n+    }\n }\n \n pub fn get_enclosing_block<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId) -> Option<&'tcx Block<'tcx>> {"}, {"sha": "8155fdf995037663bb8836d86f5534bc63001186", "filename": "tests/ui/explicit_deref_methods.fixed", "status": "renamed", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/tests%2Fui%2Fexplicit_deref_methods.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/tests%2Fui%2Fexplicit_deref_methods.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.fixed?ref=a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "patch": "@@ -29,7 +29,7 @@ fn main() {\n \n     let b: &str = &*a;\n \n-    let b: &mut str = &mut *a;\n+    let b: &mut str = &mut **a;\n \n     // both derefs should get linted here\n     let b: String = format!(\"{}, {}\", &*a, &*a);\n@@ -43,11 +43,11 @@ fn main() {\n \n     let b: String = concat(&*a);\n \n-    let b = &*just_return(a);\n+    let b = just_return(a);\n \n-    let b: String = concat(&*just_return(a));\n+    let b: String = concat(just_return(a));\n \n-    let b: &str = &*a.deref();\n+    let b: &str = &**a;\n \n     let opt_a = Some(a.clone());\n     let b = &*opt_a.unwrap();", "previous_filename": "tests/ui/dereference.fixed"}, {"sha": "8dc5272e67fa529fb5afc0bc8a6d1db62a51bdc1", "filename": "tests/ui/explicit_deref_methods.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/tests%2Fui%2Fexplicit_deref_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/tests%2Fui%2Fexplicit_deref_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.rs?ref=a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "previous_filename": "tests/ui/dereference.rs"}, {"sha": "35db6ef0905d42aacb756069d2d17dd7c5cbe2f4", "filename": "tests/ui/explicit_deref_methods.stderr", "status": "renamed", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/tests%2Fui%2Fexplicit_deref_methods.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a261bc5fadc3c72fd8828d64c4281097b2e7c0b0/tests%2Fui%2Fexplicit_deref_methods.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fexplicit_deref_methods.stderr?ref=a261bc5fadc3c72fd8828d64c4281097b2e7c0b0", "patch": "@@ -1,67 +1,67 @@\n-error: explicit deref method call\n-  --> $DIR/dereference.rs:30:19\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:30:19\n    |\n LL |     let b: &str = a.deref();\n    |                   ^^^^^^^^^ help: try this: `&*a`\n    |\n    = note: `-D clippy::explicit-deref-methods` implied by `-D warnings`\n \n-error: explicit deref_mut method call\n-  --> $DIR/dereference.rs:32:23\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:32:23\n    |\n LL |     let b: &mut str = a.deref_mut();\n-   |                       ^^^^^^^^^^^^^ help: try this: `&mut *a`\n+   |                       ^^^^^^^^^^^^^ help: try this: `&mut **a`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:35:39\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:35:39\n    |\n LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n    |                                       ^^^^^^^^^ help: try this: `&*a`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:35:50\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:35:50\n    |\n LL |     let b: String = format!(\"{}, {}\", a.deref(), a.deref());\n    |                                                  ^^^^^^^^^ help: try this: `&*a`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:37:20\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:37:20\n    |\n LL |     println!(\"{}\", a.deref());\n    |                    ^^^^^^^^^ help: try this: `&*a`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:40:11\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:40:11\n    |\n LL |     match a.deref() {\n    |           ^^^^^^^^^ help: try this: `&*a`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:44:28\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:44:28\n    |\n LL |     let b: String = concat(a.deref());\n    |                            ^^^^^^^^^ help: try this: `&*a`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:46:13\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:46:13\n    |\n LL |     let b = just_return(a).deref();\n-   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*just_return(a)`\n+   |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:48:28\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:48:28\n    |\n LL |     let b: String = concat(just_return(a).deref());\n-   |                            ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*just_return(a)`\n+   |                            ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `just_return(a)`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:50:19\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:50:19\n    |\n LL |     let b: &str = a.deref().deref();\n-   |                   ^^^^^^^^^^^^^^^^^ help: try this: `&*a.deref()`\n+   |                   ^^^^^^^^^^^^^^^^^ help: try this: `&**a`\n \n-error: explicit deref method call\n-  --> $DIR/dereference.rs:53:13\n+error: explicit `deref` method call\n+  --> $DIR/explicit_deref_methods.rs:53:13\n    |\n LL |     let b = opt_a.unwrap().deref();\n    |             ^^^^^^^^^^^^^^^^^^^^^^ help: try this: `&*opt_a.unwrap()`", "previous_filename": "tests/ui/dereference.stderr"}]}