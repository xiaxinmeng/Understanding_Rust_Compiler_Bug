{"sha": "b247402666d1c149005de1d341f3fa49fb2943a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyNDc0MDI2NjZkMWMxNDkwMDVkZTFkMzQxZjNmYTQ5ZmIyOTQzYTQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-21T18:40:07Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-08-21T18:40:07Z"}, "message": "nits from pnkfelix", "tree": {"sha": "3826d22ffcae7ea1515cbf27e8b06a39f0f8c6f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3826d22ffcae7ea1515cbf27e8b06a39f0f8c6f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b247402666d1c149005de1d341f3fa49fb2943a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b247402666d1c149005de1d341f3fa49fb2943a4", "html_url": "https://github.com/rust-lang/rust/commit/b247402666d1c149005de1d341f3fa49fb2943a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b247402666d1c149005de1d341f3fa49fb2943a4/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10b8941bce6d678fafe437bacaf25499d8c6ecf9", "url": "https://api.github.com/repos/rust-lang/rust/commits/10b8941bce6d678fafe437bacaf25499d8c6ecf9", "html_url": "https://github.com/rust-lang/rust/commit/10b8941bce6d678fafe437bacaf25499d8c6ecf9"}], "stats": {"total": 121, "additions": 76, "deletions": 45}, "files": [{"sha": "6be1b9a71f9e44e5955f9525d255612959d4dd50", "filename": "src/librustc/middle/free_region.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b247402666d1c149005de1d341f3fa49fb2943a4/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b247402666d1c149005de1d341f3fa49fb2943a4/src%2Flibrustc%2Fmiddle%2Ffree_region.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ffree_region.rs?ref=b247402666d1c149005de1d341f3fa49fb2943a4", "patch": "@@ -16,6 +16,7 @@ use rustc_data_structures::transitive_relation::TransitiveRelation;\n \n #[derive(Clone)]\n pub struct FreeRegionMap {\n+    // Stores the relation `a < b`, where `a` and `b` are regions.\n     relation: TransitiveRelation<Region>\n }\n "}, {"sha": "f26307fd8c58e202a3372e19c4de0c857ae98bfe", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 30, "deletions": 23, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b247402666d1c149005de1d341f3fa49fb2943a4/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b247402666d1c149005de1d341f3fa49fb2943a4/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=b247402666d1c149005de1d341f3fa49fb2943a4", "patch": "@@ -52,14 +52,15 @@ impl BitVector {\n \n /// A \"bit matrix\" is basically a square matrix of booleans\n /// represented as one gigantic bitvector. In other words, it is as if\n-/// you have N bitvectors, each of length N.\n+/// you have N bitvectors, each of length N. Note that `elements` here is `N`/\n #[derive(Clone)]\n pub struct BitMatrix {\n     elements: usize,\n     vector: Vec<u64>,\n }\n \n impl BitMatrix {\n+    // Create a new `elements x elements` matrix, initially empty.\n     pub fn new(elements: usize) -> BitMatrix {\n         // For every element, we need one bit for every other\n         // element. Round up to an even number of u64s.\n@@ -88,15 +89,17 @@ impl BitMatrix {\n     }\n \n     /// Do the bits from `source` contain `target`?\n-    /// Put another way, can `source` reach `target`?\n+    ///\n+    /// Put another way, if the matrix represents (transitive)\n+    /// reachability, can `source` reach `target`?\n     pub fn contains(&self, source: usize, target: usize) -> bool {\n         let (start, _) = self.range(source);\n         let (word, mask) = word_mask(target);\n         (self.vector[start+word] & mask) != 0\n     }\n \n-    /// Returns those indices that are reachable from both source and\n-    /// target. This is an O(n) operation where `n` is the number of\n+    /// Returns those indices that are reachable from both `a` and\n+    /// `b`. This is an O(n) operation where `n` is the number of\n     /// elements (somewhat independent from the actual size of the\n     /// intersection, in particular).\n     pub fn intersection(&self, a: usize, b: usize) -> Vec<usize> {\n@@ -114,24 +117,24 @@ impl BitMatrix {\n         result\n     }\n \n-    /// Add the bits from source to the bits from destination,\n+    /// Add the bits from `read` to the bits from `write`,\n     /// return true if anything changed.\n     ///\n-    /// This is used when computing reachability because if you have\n-    /// an edge `destination -> source`, because in that case\n-    /// `destination` can reach everything that `source` can (and\n+    /// This is used when computing transitive reachability because if\n+    /// you have an edge `write -> read`, because in that case\n+    /// `write` can reach everything that `read` can (and\n     /// potentially more).\n-    pub fn merge(&mut self, source: usize, destination: usize) -> bool {\n-        let (source_start, source_end) = self.range(source);\n-        let (destination_start, destination_end) = self.range(destination);\n+    pub fn merge(&mut self, read: usize, write: usize) -> bool {\n+        let (read_start, read_end) = self.range(read);\n+        let (write_start, write_end) = self.range(write);\n         let vector = &mut self.vector[..];\n         let mut changed = false;\n-        for (source_index, destination_index) in\n-            (source_start..source_end).zip(destination_start..destination_end)\n+        for (read_index, write_index) in\n+            (read_start..read_end).zip(write_start..write_end)\n         {\n-            let v1 = vector[destination_index];\n-            let v2 = v1 | vector[source_index];\n-            vector[destination_index] = v2;\n+            let v1 = vector[write_index];\n+            let v2 = v1 | vector[read_index];\n+            vector[write_index] = v2;\n             changed = changed | (v1 != v2);\n         }\n         changed\n@@ -183,25 +186,29 @@ fn grow() {\n fn matrix_intersection() {\n     let mut vec1 = BitMatrix::new(200);\n \n+    // (*) Elements reachable from both 2 and 65.\n+\n     vec1.add(2, 3);\n     vec1.add(2, 6);\n-    vec1.add(2, 10);\n-    vec1.add(2, 64);\n+    vec1.add(2, 10); // (*)\n+    vec1.add(2, 64); // (*)\n     vec1.add(2, 65);\n     vec1.add(2, 130);\n-    vec1.add(2, 160);\n+    vec1.add(2, 160); // (*)\n+\n+    vec1.add(64, 133);\n \n     vec1.add(65, 2);\n     vec1.add(65, 8);\n-    vec1.add(65, 10); // X\n-    vec1.add(65, 64); // X\n+    vec1.add(65, 10); // (*)\n+    vec1.add(65, 64); // (*)\n     vec1.add(65, 68);\n     vec1.add(65, 133);\n-    vec1.add(65, 160); // X\n+    vec1.add(65, 160); // (*)\n \n     let intersection = vec1.intersection(2, 64);\n     assert!(intersection.is_empty());\n \n     let intersection = vec1.intersection(2, 65);\n-    assert_eq!(intersection, vec![10, 64, 160]);\n+    assert_eq!(intersection, &[10, 64, 160]);\n }"}, {"sha": "3c93e85cd550d408db986d488c627c3b00217b68", "filename": "src/librustc_data_structures/transitive_relation.rs", "status": "modified", "additions": 45, "deletions": 22, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b247402666d1c149005de1d341f3fa49fb2943a4/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b247402666d1c149005de1d341f3fa49fb2943a4/src%2Flibrustc_data_structures%2Ftransitive_relation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Ftransitive_relation.rs?ref=b247402666d1c149005de1d341f3fa49fb2943a4", "patch": "@@ -61,6 +61,10 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n             Some(i) => i,\n             None => {\n                 self.elements.push(a);\n+\n+                // if we changed the dimensions, clear the cache\n+                *self.closure.borrow_mut() = None;\n+\n                 Index(self.elements.len() - 1)\n             }\n         }\n@@ -73,17 +77,17 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n         let edge = Edge { source: a, target: b };\n         if !self.edges.contains(&edge) {\n             self.edges.push(edge);\n-        }\n \n-        // clear cached closure, if any\n-        *self.closure.borrow_mut() = None;\n+            // added an edge, clear the cache\n+            *self.closure.borrow_mut() = None;\n+        }\n     }\n \n     /// Check whether `a < target` (transitively)\n     pub fn contains(&self, a: &T, b: &T) -> bool {\n         match (self.index(a), self.index(b)) {\n             (Some(a), Some(b)) =>\n-                self.take_closure(|closure| closure.contains(a.0, b.0)),\n+                self.with_closure(|closure| closure.contains(a.0, b.0)),\n             (None, _) | (_, None) =>\n                 false,\n         }\n@@ -102,7 +106,8 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n     /// itself is not fully sufficient).\n     ///\n     /// Examples are probably clearer than any prose I could write\n-    /// (there are corresponding tests below, btw):\n+    /// (there are corresponding tests below, btw). In each case,\n+    /// the query is `best_upper_bound(a, b)`:\n     ///\n     /// ```\n     /// // returns Some(x), which is also LUB\n@@ -140,7 +145,11 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n     /// Returns the set of bounds `X` such that:\n     ///\n     /// - `a < X` and `b < X`\n-    /// - there is no `Y` such that `a < Y` and `Y < X`\n+    /// - there is no `Y != X` such that `a < Y` and `Y < X`\n+    ///   - except for the case where `X < a` (i.e., a strongly connected\n+    ///     component in the graph). In that case, the smallest\n+    ///     representative of the SCC is returned (as determined by the\n+    ///     internal indices).\n     ///\n     /// Note that this set can, in principle, have any size.\n     pub fn minimal_upper_bounds(&self, a: &T, b: &T) -> Vec<&T> {\n@@ -157,7 +166,7 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n             mem::swap(&mut a, &mut b);\n         }\n \n-        let lub_indices = self.take_closure(|closure| {\n+        let lub_indices = self.with_closure(|closure| {\n             // Easy case is when either a < b or b < a:\n             if closure.contains(a.0, b.0) {\n                 return vec![b.0];\n@@ -178,18 +187,28 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n             //    to the steps below.\n             //    - This vector contains upper bounds, but they are\n             //      not minimal upper bounds. So you may have e.g.\n-            //      `[a, b, tcx, x]` where `a < tcx` and `b < tcx` and\n-            //      `x < a` and `x < b`. This could be reduced to\n-            //      just `[x]`.\n+            //      `[x, y, tcx, z]` where `x < tcx` and `y < tcx` and\n+            //      `z < x` and `z < y`:\n+            //\n+            //           z --+---> x ----+----> tcx\n+            //               |           |\n+            //               |           |\n+            //               +---> y ----+\n+            //\n+            //      In this case, we really want to return just `[z]`.\n+            //      The following steps below achieve this by gradually\n+            //      reducing the list.\n             // 2. Pare down the vector using `pare_down`. This will\n             //    remove elements from the vector that can be reached\n             //    by an earlier element.\n-            //    - In the example above, this would convert\n-            //      `[a, b, tcx, x]` to `[a, b, x]`. Note that `x`\n-            //      remains because `x < a` but not `a < x.`\n+            //    - In the example above, this would convert `[x, y,\n+            //      tcx, z]` to `[x, y, z]`. Note that `x` and `y` are\n+            //      still in the vector; this is because while `z < x`\n+            //      (and `z < y`) holds, `z` comes after them in the\n+            //      vector.\n             // 3. Reverse the vector and repeat the pare down process.\n             //    - In the example above, we would reverse to\n-            //      `[x, b, a]` and then pare down to `[x]`.\n+            //      `[z, y, x]` and then pare down to `[z]`.\n             // 4. Reverse once more just so that we yield a vector in\n             //    increasing order of index. Maybe this is silly.\n             //\n@@ -213,7 +232,7 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n                    .collect()\n     }\n \n-    fn take_closure<OP,R>(&self, op: OP) -> R\n+    fn with_closure<OP,R>(&self, op: OP) -> R\n         where OP: FnOnce(&BitMatrix) -> R\n     {\n         let mut closure_cell = self.closure.borrow_mut();\n@@ -248,7 +267,8 @@ impl<T:Debug+PartialEq> TransitiveRelation<T> {\n /// there exists an earlier element i<j such that i -> j. That is,\n /// after you run `pare_down`, you know that for all elements that\n /// remain in candidates, they cannot reach any of the elements that\n-/// come after them.\n+/// come after them. (Note that it may permute the ordering in some\n+/// cases.)\n ///\n /// Examples follow. Assume that a -> b -> c and x -> y -> z.\n ///\n@@ -264,9 +284,13 @@ fn pare_down(candidates: &mut Vec<usize>, closure: &BitMatrix) {\n         let mut j = i;\n         while j < candidates.len() {\n             if closure.contains(candidate, candidates[j]) {\n-                // if i can reach j, then we can remove j\n-                println!(\"pare_down: candidates[{:?}]={:?} candidates[{:?}] = {:?}\",\n-                         i-1, candidate, j, candidates[j]);\n+                // If `i` can reach `j`, then we can remove `j`. Given\n+                // how careful this algorithm is about ordering, it\n+                // may seem odd to use swap-remove. The reason it is\n+                // ok is that we are swapping two elements (`j` and\n+                // `max`) that are both to the right of our cursor\n+                // `i`, and the invariant that we are establishing\n+                // continues to hold for everything left of `i`.\n                 candidates.swap_remove(j);\n             } else {\n                 j += 1;\n@@ -371,9 +395,8 @@ fn mubs_best_choice2() {\n \n #[test]\n fn mubs_no_best_choice() {\n-    // in this case, the intersection yields [1, 2],\n-    // and we need the first \"pare down\" call to narrow\n-    // this down to [2]\n+    // in this case, the intersection yields [1, 2], and the \"pare\n+    // down\" calls find nothing to remove.\n     let mut relation = TransitiveRelation::new();\n     relation.add(\"0\", \"1\");\n     relation.add(\"0\", \"2\");"}]}