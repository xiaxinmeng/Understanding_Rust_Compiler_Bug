{"sha": "052ba6c5df9d67dd56ec069f588ab6efba0fadd0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1MmJhNmM1ZGY5ZDY3ZGQ1NmVjMDY5ZjU4OGFiNmVmYmEwZmFkZDA=", "commit": {"author": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T23:02:55Z"}, "committer": {"name": "Seiichi Uchida", "email": "seuchida@gmail.com", "date": "2018-09-29T23:05:45Z"}, "message": "Move maybe_get_args_offset to overflow.rs", "tree": {"sha": "42eaba7c5181ece8d2b21e6f5f3ab692b883cae1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42eaba7c5181ece8d2b21e6f5f3ab692b883cae1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/052ba6c5df9d67dd56ec069f588ab6efba0fadd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/052ba6c5df9d67dd56ec069f588ab6efba0fadd0", "html_url": "https://github.com/rust-lang/rust/commit/052ba6c5df9d67dd56ec069f588ab6efba0fadd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/052ba6c5df9d67dd56ec069f588ab6efba0fadd0/comments", "author": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "committer": {"login": "topecongiro", "id": 21980157, "node_id": "MDQ6VXNlcjIxOTgwMTU3", "avatar_url": "https://avatars.githubusercontent.com/u/21980157?v=4", "gravatar_id": "", "url": "https://api.github.com/users/topecongiro", "html_url": "https://github.com/topecongiro", "followers_url": "https://api.github.com/users/topecongiro/followers", "following_url": "https://api.github.com/users/topecongiro/following{/other_user}", "gists_url": "https://api.github.com/users/topecongiro/gists{/gist_id}", "starred_url": "https://api.github.com/users/topecongiro/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/topecongiro/subscriptions", "organizations_url": "https://api.github.com/users/topecongiro/orgs", "repos_url": "https://api.github.com/users/topecongiro/repos", "events_url": "https://api.github.com/users/topecongiro/events{/privacy}", "received_events_url": "https://api.github.com/users/topecongiro/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "63387824b31667b9830e8e84cdd4884162534aea", "url": "https://api.github.com/repos/rust-lang/rust/commits/63387824b31667b9830e8e84cdd4884162534aea", "html_url": "https://github.com/rust-lang/rust/commit/63387824b31667b9830e8e84cdd4884162534aea"}], "stats": {"total": 105, "additions": 54, "deletions": 51}, "files": [{"sha": "09ab3da6920a99cfcaf9d2b15a8d2034d479eadd", "filename": "src/expr.rs", "status": "modified", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/052ba6c5df9d67dd56ec069f588ab6efba0fadd0/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/052ba6c5df9d67dd56ec069f588ab6efba0fadd0/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=052ba6c5df9d67dd56ec069f588ab6efba0fadd0", "patch": "@@ -1259,54 +1259,6 @@ fn rewrite_string_lit(context: &RewriteContext, span: Span, shape: Shape) -> Opt\n     )\n }\n \n-/// In case special-case style is required, returns an offset from which we start horizontal layout.\n-pub fn maybe_get_args_offset(callee_str: &str, args: &[OverflowableItem]) -> Option<(bool, usize)> {\n-    if let Some(&(_, num_args_before)) = SPECIAL_MACRO_WHITELIST\n-        .iter()\n-        .find(|&&(s, _)| s == callee_str)\n-    {\n-        let all_simple = args.len() > num_args_before && is_every_expr_simple(args);\n-\n-        Some((all_simple, num_args_before))\n-    } else {\n-        None\n-    }\n-}\n-\n-/// A list of `format!`-like macros, that take a long format string and a list of arguments to\n-/// format.\n-///\n-/// Organized as a list of `(&str, usize)` tuples, giving the name of the macro and the number of\n-/// arguments before the format string (none for `format!(\"format\", ...)`, one for `assert!(result,\n-/// \"format\", ...)`, two for `assert_eq!(left, right, \"format\", ...)`).\n-const SPECIAL_MACRO_WHITELIST: &[(&str, usize)] = &[\n-    // format! like macros\n-    // From the Rust Standard Library.\n-    (\"eprint!\", 0),\n-    (\"eprintln!\", 0),\n-    (\"format!\", 0),\n-    (\"format_args!\", 0),\n-    (\"print!\", 0),\n-    (\"println!\", 0),\n-    (\"panic!\", 0),\n-    (\"unreachable!\", 0),\n-    // From the `log` crate.\n-    (\"debug!\", 0),\n-    (\"error!\", 0),\n-    (\"info!\", 0),\n-    (\"warn!\", 0),\n-    // write! like macros\n-    (\"assert!\", 1),\n-    (\"debug_assert!\", 1),\n-    (\"write!\", 1),\n-    (\"writeln!\", 1),\n-    // assert_eq! like macros\n-    (\"assert_eq!\", 2),\n-    (\"assert_ne!\", 2),\n-    (\"debug_assert_eq!\", 2),\n-    (\"debug_assert_ne!\", 2),\n-];\n-\n fn choose_separator_tactic(context: &RewriteContext, span: Span) -> Option<SeparatorTactic> {\n     if context.inside_macro() {\n         if span_ends_with_comma(context, span) {"}, {"sha": "47979fa119cacd8a1b37d227647d95bd63e589f0", "filename": "src/overflow.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/052ba6c5df9d67dd56ec069f588ab6efba0fadd0/src%2Foverflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/052ba6c5df9d67dd56ec069f588ab6efba0fadd0/src%2Foverflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foverflow.rs?ref=052ba6c5df9d67dd56ec069f588ab6efba0fadd0", "patch": "@@ -18,7 +18,6 @@ use syntax::{ast, ptr};\n use closures;\n use expr::{\n     can_be_overflowed_expr, is_every_expr_simple, is_method_call, is_nested_call, is_simple_expr,\n-    maybe_get_args_offset,\n };\n use lists::{definitive_tactic, itemize_list, write_list, ListFormatting, ListItem, Separator};\n use macros::MacroArg;\n@@ -32,6 +31,42 @@ use utils::{count_newlines, extra_offset, first_line_width, last_line_width, mk_\n \n use std::cmp::min;\n \n+const SHORT_ITEM_THRESHOLD: usize = 10;\n+\n+/// A list of `format!`-like macros, that take a long format string and a list of arguments to\n+/// format.\n+///\n+/// Organized as a list of `(&str, usize)` tuples, giving the name of the macro and the number of\n+/// arguments before the format string (none for `format!(\"format\", ...)`, one for `assert!(result,\n+/// \"format\", ...)`, two for `assert_eq!(left, right, \"format\", ...)`).\n+const SPECIAL_MACRO_WHITELIST: &[(&str, usize)] = &[\n+    // format! like macros\n+    // From the Rust Standard Library.\n+    (\"eprint!\", 0),\n+    (\"eprintln!\", 0),\n+    (\"format!\", 0),\n+    (\"format_args!\", 0),\n+    (\"print!\", 0),\n+    (\"println!\", 0),\n+    (\"panic!\", 0),\n+    (\"unreachable!\", 0),\n+    // From the `log` crate.\n+    (\"debug!\", 0),\n+    (\"error!\", 0),\n+    (\"info!\", 0),\n+    (\"warn!\", 0),\n+    // write! like macros\n+    (\"assert!\", 1),\n+    (\"debug_assert!\", 1),\n+    (\"write!\", 1),\n+    (\"writeln!\", 1),\n+    // assert_eq! like macros\n+    (\"assert_eq!\", 2),\n+    (\"assert_ne!\", 2),\n+    (\"debug_assert_eq!\", 2),\n+    (\"debug_assert_ne!\", 2),\n+];\n+\n pub enum OverflowableItem<'a> {\n     Expr(&'a ast::Expr),\n     GenericParam(&'a ast::GenericParam),\n@@ -178,8 +213,6 @@ where\n     iter.map(|x| IntoOverflowableItem::into_overflowable_item(x))\n }\n \n-const SHORT_ITEM_THRESHOLD: usize = 10;\n-\n pub fn rewrite_with_parens<'a, T: 'a + IntoOverflowableItem<'a>>(\n     context: &'a RewriteContext,\n     ident: &'a str,\n@@ -661,3 +694,21 @@ fn no_long_items(list: &[ListItem]) -> bool {\n     list.iter()\n         .all(|item| item.inner_as_ref().len() <= SHORT_ITEM_THRESHOLD)\n }\n+\n+/// In case special-case style is required, returns an offset from which we start horizontal layout.\n+pub fn maybe_get_args_offset(callee_str: &str, args: &[OverflowableItem]) -> Option<(bool, usize)> {\n+    if let Some(&(_, num_args_before)) = args\n+        .get(0)?\n+        .whitelist()\n+        .iter()\n+        .find(|&&(s, _)| s == callee_str)\n+    {\n+        let all_simple = args.len() > num_args_before\n+            && is_every_expr_simple(&args[0..num_args_before])\n+            && is_every_expr_simple(&args[num_args_before + 1..]);\n+\n+        Some((all_simple, num_args_before))\n+    } else {\n+        None\n+    }\n+}"}]}