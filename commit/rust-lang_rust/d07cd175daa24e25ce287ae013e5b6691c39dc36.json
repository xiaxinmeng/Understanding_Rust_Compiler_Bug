{"sha": "d07cd175daa24e25ce287ae013e5b6691c39dc36", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQwN2NkMTc1ZGFhMjRlMjVjZTI4N2FlMDEzZTViNjY5MWMzOWRjMzY=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-09-30T21:00:59Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2014-10-02T13:36:01Z"}, "message": "std: remove gc module.", "tree": {"sha": "d9fbfefbf978f02b414a3fd7e841f32943c94cc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9fbfefbf978f02b414a3fd7e841f32943c94cc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d07cd175daa24e25ce287ae013e5b6691c39dc36", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d07cd175daa24e25ce287ae013e5b6691c39dc36", "html_url": "https://github.com/rust-lang/rust/commit/d07cd175daa24e25ce287ae013e5b6691c39dc36", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d07cd175daa24e25ce287ae013e5b6691c39dc36/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2487e164aeeeedaba78f597724a137959b1fb299", "url": "https://api.github.com/repos/rust-lang/rust/commits/2487e164aeeeedaba78f597724a137959b1fb299", "html_url": "https://github.com/rust-lang/rust/commit/2487e164aeeeedaba78f597724a137959b1fb299"}], "stats": {"total": 160, "additions": 0, "deletions": 160}, "files": [{"sha": "ecef8e9ed902231f2f70f0fabc9399d23b71b1c0", "filename": "src/libstd/gc.rs", "status": "removed", "additions": 0, "deletions": 156, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/2487e164aeeeedaba78f597724a137959b1fb299/src%2Flibstd%2Fgc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2487e164aeeeedaba78f597724a137959b1fb299/src%2Flibstd%2Fgc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fgc.rs?ref=2487e164aeeeedaba78f597724a137959b1fb299", "patch": "@@ -1,156 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-/*! Task-local garbage-collected boxes\n-\n-The `Gc` type provides shared ownership of an immutable value. Destruction is not deterministic, and\n-will occur some time between every `Gc` handle being gone and the end of the task. The garbage\n-collector is task-local so `Gc<T>` is not sendable.\n-\n-*/\n-\n-#![experimental]\n-#![allow(experimental)]\n-\n-use clone::Clone;\n-use cmp::{Ord, PartialOrd, Ordering, Eq, PartialEq};\n-use default::Default;\n-use fmt;\n-use hash;\n-use kinds::marker;\n-use option::Option;\n-use ops::Deref;\n-use raw;\n-\n-/// Immutable garbage-collected pointer type\n-#[lang=\"gc\"]\n-#[experimental = \"Gc is currently based on reference-counting and will not collect cycles until \\\n-                  task annihilation. For now, cycles need to be broken manually by using `Rc<T>` \\\n-                  with a non-owning `Weak<T>` pointer. A tracing garbage collector is planned.\"]\n-pub struct Gc<T> {\n-    _ptr: *mut T,\n-    marker: marker::NoSend,\n-}\n-\n-#[unstable]\n-impl<T> Clone for Gc<T> {\n-    /// Clone the pointer only\n-    #[inline]\n-    fn clone(&self) -> Gc<T> { *self }\n-}\n-\n-/// An value that represents the task-local managed heap.\n-///\n-/// Use this like `let foo = box(GC) Bar::new(...);`\n-#[lang=\"managed_heap\"]\n-#[cfg(not(test))]\n-pub static GC: () = ();\n-\n-impl<T: PartialEq + 'static> PartialEq for Gc<T> {\n-    #[inline]\n-    fn eq(&self, other: &Gc<T>) -> bool { *(*self) == *(*other) }\n-    #[inline]\n-    fn ne(&self, other: &Gc<T>) -> bool { *(*self) != *(*other) }\n-}\n-impl<T: PartialOrd + 'static> PartialOrd for Gc<T> {\n-    #[inline]\n-    fn partial_cmp(&self, other: &Gc<T>) -> Option<Ordering> {\n-        (**self).partial_cmp(&**other)\n-    }\n-    #[inline]\n-    fn lt(&self, other: &Gc<T>) -> bool { *(*self) < *(*other) }\n-    #[inline]\n-    fn le(&self, other: &Gc<T>) -> bool { *(*self) <= *(*other) }\n-    #[inline]\n-    fn ge(&self, other: &Gc<T>) -> bool { *(*self) >= *(*other) }\n-    #[inline]\n-    fn gt(&self, other: &Gc<T>) -> bool { *(*self) > *(*other) }\n-}\n-impl<T: Ord + 'static> Ord for Gc<T> {\n-    #[inline]\n-    fn cmp(&self, other: &Gc<T>) -> Ordering { (**self).cmp(&**other) }\n-}\n-impl<T: Eq + 'static> Eq for Gc<T> {}\n-\n-impl<T: 'static> Deref<T> for Gc<T> {\n-    fn deref<'a>(&'a self) -> &'a T { &**self }\n-}\n-\n-impl<T: Default + 'static> Default for Gc<T> {\n-    fn default() -> Gc<T> {\n-        box(GC) Default::default()\n-    }\n-}\n-\n-impl<T: 'static> raw::Repr<*const raw::GcBox<T>> for Gc<T> {}\n-\n-impl<S: hash::Writer, T: hash::Hash<S> + 'static> hash::Hash<S> for Gc<T> {\n-    fn hash(&self, s: &mut S) {\n-        (**self).hash(s)\n-    }\n-}\n-\n-impl<T: 'static + fmt::Show> fmt::Show for Gc<T> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (**self).fmt(f)\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use prelude::*;\n-    use super::*;\n-    use cell::RefCell;\n-\n-    #[test]\n-    fn test_managed_clone() {\n-        let a = box(GC) 5i;\n-        let b: Gc<int> = a.clone();\n-        assert!(a == b);\n-    }\n-\n-    #[test]\n-    fn test_clone() {\n-        let x = Gc::new(RefCell::new(5));\n-        let y = x.clone();\n-        *x.borrow().borrow_mut() = 20;\n-        assert_eq!(*y.borrow().borrow(), 20);\n-    }\n-\n-    #[test]\n-    fn test_simple() {\n-        let x = Gc::new(5);\n-        assert_eq!(*x.borrow(), 5);\n-    }\n-\n-    #[test]\n-    fn test_simple_clone() {\n-        let x = Gc::new(5);\n-        let y = x.clone();\n-        assert_eq!(*x.borrow(), 5);\n-        assert_eq!(*y.borrow(), 5);\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let x = Gc::new(5);\n-        let y = x.clone();\n-        let z = Gc::new(7);\n-        assert!(x.ptr_eq(&x));\n-        assert!(x.ptr_eq(&y));\n-        assert!(!x.ptr_eq(&z));\n-    }\n-\n-    #[test]\n-    fn test_destructor() {\n-        let x = Gc::new(box 5);\n-        assert_eq!(**x.borrow(), 5);\n-    }\n-}"}, {"sha": "f6c37b6cfc349881ddac66bcf5e53d9f4513cd0b", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d07cd175daa24e25ce287ae013e5b6691c39dc36/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d07cd175daa24e25ce287ae013e5b6691c39dc36/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=d07cd175daa24e25ce287ae013e5b6691c39dc36", "patch": "@@ -137,7 +137,6 @@ extern crate rustrt;\n #[cfg(test)] pub use realstd::cmp;\n #[cfg(test)] pub use realstd::ty;\n #[cfg(test)] pub use realstd::boxed;\n-#[cfg(test)] pub use realstd::gc;\n \n \n // NB: These reexports are in the order they should be listed in rustdoc\n@@ -220,9 +219,6 @@ pub mod rand;\n \n pub mod ascii;\n \n-#[cfg(not(test))]\n-pub mod gc;\n-\n pub mod time;\n \n /* Common traits */"}]}