{"sha": "6d992728c331128810704d16d8026aa4fa2e0c87", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkOTkyNzI4YzMzMTEyODgxMDcwNGQxNmQ4MDI2YWE0ZmEyZTBjODc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-17T21:02:47Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-17T21:02:47Z"}, "message": "Auto merge of #27833 - arielb1:robust-construction, r=eddyb\n\nFixes #27815\r\n\r\nr? @eddyb", "tree": {"sha": "b70d7527bc454421a6fe71a2b9c601a7a089d99c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b70d7527bc454421a6fe71a2b9c601a7a089d99c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d992728c331128810704d16d8026aa4fa2e0c87", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d992728c331128810704d16d8026aa4fa2e0c87", "html_url": "https://github.com/rust-lang/rust/commit/6d992728c331128810704d16d8026aa4fa2e0c87", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d992728c331128810704d16d8026aa4fa2e0c87/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47ea0cfb6bd250c970e3a61d62bfa1b1c7bb27d4", "url": "https://api.github.com/repos/rust-lang/rust/commits/47ea0cfb6bd250c970e3a61d62bfa1b1c7bb27d4", "html_url": "https://github.com/rust-lang/rust/commit/47ea0cfb6bd250c970e3a61d62bfa1b1c7bb27d4"}, {"sha": "44f41063dd241320cbe19b078862fc29eb66c097", "url": "https://api.github.com/repos/rust-lang/rust/commits/44f41063dd241320cbe19b078862fc29eb66c097", "html_url": "https://github.com/rust-lang/rust/commit/44f41063dd241320cbe19b078862fc29eb66c097"}], "stats": {"total": 555, "additions": 257, "deletions": 298}, "files": [{"sha": "0ac9e0a9c59a0c37d4bad64af3ceedf843af1b53", "filename": "src/librustc_typeck/check/_match.rs", "status": "modified", "additions": 14, "deletions": 43, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Flibrustc_typeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2F_match.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -528,60 +528,31 @@ pub fn check_pat_struct<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>, pat: &'tcx ast::Pat,\n     let tcx = pcx.fcx.ccx.tcx;\n \n     let def = tcx.def_map.borrow().get(&pat.id).unwrap().full_def();\n-    let (adt_def, variant) = match def {\n-        def::DefTrait(_) => {\n+    let variant = match fcx.def_struct_variant(def) {\n+        Some((_, variant)) => variant,\n+        None => {\n             let name = pprust::path_to_string(path);\n-            span_err!(tcx.sess, pat.span, E0168,\n-                \"use of trait `{}` in a struct pattern\", name);\n+            span_err!(tcx.sess, pat.span, E0163,\n+                      \"`{}` does not name a struct or a struct variant\", name);\n             fcx.write_error(pat.id);\n \n             for field in fields {\n-                check_pat(pcx, &*field.node.pat, tcx.types.err);\n+                check_pat(pcx, &field.node.pat, tcx.types.err);\n             }\n             return;\n-        },\n-        _ => {\n-            let def_type = tcx.lookup_item_type(def.def_id());\n-            match def_type.ty.sty {\n-                ty::TyStruct(struct_def, _) =>\n-                    (struct_def, struct_def.struct_variant()),\n-                ty::TyEnum(enum_def, _)\n-                    if def == def::DefVariant(enum_def.did, def.def_id(), true) =>\n-                    (enum_def, enum_def.variant_of_def(def)),\n-                _ => {\n-                    let name = pprust::path_to_string(path);\n-                    span_err!(tcx.sess, pat.span, E0163,\n-                        \"`{}` does not name a struct or a struct variant\", name);\n-                    fcx.write_error(pat.id);\n-\n-                    for field in fields {\n-                        check_pat(pcx, &*field.node.pat, tcx.types.err);\n-                    }\n-                    return;\n-                }\n-            }\n         }\n     };\n \n-    instantiate_path(pcx.fcx,\n-                     &path.segments,\n-                     adt_def.type_scheme(tcx),\n-                     &adt_def.predicates(tcx),\n-                     None,\n-                     def,\n-                     pat.span,\n-                     pat.id);\n-\n-    let pat_ty = fcx.node_ty(pat.id);\n+    let pat_ty = pcx.fcx.instantiate_type(def.def_id(), path);\n+    let item_substs = match pat_ty.sty {\n+        ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n+        _ => tcx.sess.span_bug(pat.span, \"struct variant is not an ADT\")\n+    };\n     demand::eqtype(fcx, pat.span, expected, pat_ty);\n-\n-    let item_substs = fcx\n-        .item_substs()\n-        .get(&pat.id)\n-        .map(|substs| substs.substs.clone())\n-        .unwrap_or_else(|| Substs::empty());\n-\n     check_struct_pat_fields(pcx, pat.span, fields, variant, &item_substs, etc);\n+\n+    fcx.write_ty(pat.id, pat_ty);\n+    fcx.write_substs(pat.id, ty::ItemSubsts { substs: item_substs.clone() });\n }\n \n pub fn check_pat_enum<'a, 'tcx>(pcx: &pat_ctxt<'a, 'tcx>,"}, {"sha": "be008d522858ce35591be59fd60d0b0a9a2fe335", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 94, "deletions": 195, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -1409,68 +1409,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                        cause)\n     }\n \n-    /// Returns the type of `def_id` with all generics replaced by by fresh type/region variables.\n-    /// Also returns the substitution from the type parameters on `def_id` to the fresh variables.\n-    /// Registers any trait obligations specified on `def_id` at the same time.\n+    /// Instantiates the type in `did` with the generics in `path` and returns\n+    /// it (registering the necessary trait obligations along the way).\n     ///\n-    /// Note that function is only intended to be used with types (notably, not fns). This is\n-    /// because it doesn't do any instantiation of late-bound regions.\n+    /// Note that this function is only intended to be used with type-paths,\n+    /// not with value-paths.\n     pub fn instantiate_type(&self,\n-                            span: Span,\n-                            def_id: ast::DefId)\n-                            -> TypeAndSubsts<'tcx>\n+                            did: ast::DefId,\n+                            path: &ast::Path)\n+                            -> Ty<'tcx>\n     {\n+        debug!(\"instantiate_type(did={:?}, path={:?})\", did, path);\n         let type_scheme =\n-            self.tcx().lookup_item_type(def_id);\n+            self.tcx().lookup_item_type(did);\n         let type_predicates =\n-            self.tcx().lookup_predicates(def_id);\n-        let substs =\n-            self.infcx().fresh_substs_for_generics(\n-                span,\n-                &type_scheme.generics);\n+            self.tcx().lookup_predicates(did);\n+        let substs = astconv::ast_path_substs_for_ty(self, self,\n+                                                     path.span,\n+                                                     PathParamMode::Optional,\n+                                                     &type_scheme.generics,\n+                                                     path.segments.last().unwrap());\n+        debug!(\"instantiate_type: ty={:?} substs={:?}\", &type_scheme.ty, &substs);\n         let bounds =\n-            self.instantiate_bounds(span, &substs, &type_predicates);\n+            self.instantiate_bounds(path.span, &substs, &type_predicates);\n         self.add_obligations_for_parameters(\n             traits::ObligationCause::new(\n-                span,\n+                path.span,\n                 self.body_id,\n-                traits::ItemObligation(def_id)),\n+                traits::ItemObligation(did)),\n             &bounds);\n-        let monotype =\n-            self.instantiate_type_scheme(span, &substs, &type_scheme.ty);\n \n-        TypeAndSubsts {\n-            ty: monotype,\n-            substs: substs\n-        }\n+        self.instantiate_type_scheme(path.span, &substs, &type_scheme.ty)\n     }\n \n-    /// Returns the type that this AST path refers to. If the path has no type\n-    /// parameters and the corresponding type has type parameters, fresh type\n-    /// and/or region variables are substituted.\n-    ///\n-    /// This is used when checking the constructor in struct literals.\n-    fn instantiate_struct_literal_ty(&self,\n-                                     did: ast::DefId,\n-                                     path: &ast::Path)\n-                                     -> TypeAndSubsts<'tcx>\n+    /// Return the dict-like variant corresponding to a given `Def`.\n+    pub fn def_struct_variant(&self,\n+                              def: def::Def)\n+                              -> Option<(ty::AdtDef<'tcx>, ty::VariantDef<'tcx>)>\n     {\n-        let tcx = self.tcx();\n-\n-        let ty::TypeScheme { generics, ty: decl_ty } =\n-            tcx.lookup_item_type(did);\n-\n-        let substs = astconv::ast_path_substs_for_ty(self, self,\n-                                                     path.span,\n-                                                     PathParamMode::Optional,\n-                                                     &generics,\n-                                                     path.segments.last().unwrap());\n-\n-        let ty = self.instantiate_type_scheme(path.span, &substs, &decl_ty);\n+        let (adt, variant) = match def {\n+            def::DefVariant(enum_id, variant_id, true) => {\n+                let adt = self.tcx().lookup_adt_def(enum_id);\n+                (adt, adt.variant_with_id(variant_id))\n+            }\n+            def::DefTy(did, _) | def::DefStruct(did) => {\n+                let typ = self.tcx().lookup_item_type(did);\n+                if let ty::TyStruct(adt, _) = typ.ty.sty {\n+                    (adt, adt.struct_variant())\n+                } else {\n+                    return None;\n+                }\n+            }\n+            _ => return None\n+        };\n \n-        TypeAndSubsts { substs: substs, ty: ty }\n+        if let ty::VariantKind::Dict = variant.kind() {\n+            Some((adt, variant))\n+        } else {\n+            None\n+        }\n     }\n \n+\n     pub fn write_nil(&self, node_id: ast::NodeId) {\n         self.write_ty(node_id, self.tcx().mk_nil());\n     }\n@@ -3100,18 +3100,17 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n     }\n \n \n-    fn check_struct_or_variant_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n-                                                adt_ty: Ty<'tcx>,\n-                                                span: Span,\n-                                                variant_id: ast::DefId,\n-                                                ast_fields: &'tcx [ast::Field],\n-                                                check_completeness: bool) -> Result<(),()> {\n+    fn check_expr_struct_fields<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n+                                          adt_ty: Ty<'tcx>,\n+                                          span: Span,\n+                                          variant: ty::VariantDef<'tcx>,\n+                                          ast_fields: &'tcx [ast::Field],\n+                                          check_completeness: bool) {\n         let tcx = fcx.ccx.tcx;\n-        let (adt_def, substs) = match adt_ty.sty {\n-            ty::TyStruct(def, substs) | ty::TyEnum(def, substs) => (def, substs),\n-            _ => tcx.sess.span_bug(span, \"non-ADT passed to check_struct_or_variant_fields\")\n+        let substs = match adt_ty.sty {\n+            ty::TyStruct(_, substs) | ty::TyEnum(_, substs) => substs,\n+            _ => tcx.sess.span_bug(span, \"non-ADT passed to check_expr_struct_fields\")\n         };\n-        let variant = adt_def.variant_with_id(variant_id);\n \n         let mut remaining_fields = FnvHashMap();\n         for field in &variant.fields {\n@@ -3148,7 +3147,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             !error_happened &&\n             !remaining_fields.is_empty()\n         {\n-            error_happened = true;\n             span_err!(tcx.sess, span, E0063,\n                       \"missing field{}: {}\",\n                       if remaining_fields.len() == 1 {\"\"} else {\"s\"},\n@@ -3157,68 +3155,6 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                       .collect::<Vec<_>>()\n                                       .join(\", \"));\n         }\n-\n-        if error_happened { Err(()) } else { Ok(()) }\n-    }\n-\n-    fn check_struct_constructor<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                         id: ast::NodeId,\n-                                         span: codemap::Span,\n-                                         struct_def: ty::AdtDef<'tcx>,\n-                                         fields: &'tcx [ast::Field],\n-                                         base_expr: Option<&'tcx ast::Expr>) {\n-        let tcx = fcx.ccx.tcx;\n-\n-        // Generate the struct type.\n-        let TypeAndSubsts {\n-            ty: mut struct_type,\n-            substs: _\n-        } = fcx.instantiate_type(span, struct_def.did);\n-\n-        // Look up and check the fields.\n-        let res = check_struct_or_variant_fields(fcx,\n-                                                 struct_type,\n-                                                 span,\n-                                                 struct_def.did,\n-                                                 fields,\n-                                                 base_expr.is_none());\n-        if res.is_err() {\n-            struct_type = tcx.types.err;\n-        }\n-\n-        // Check the base expression if necessary.\n-        match base_expr {\n-            None => {}\n-            Some(base_expr) => {\n-                check_expr_has_type(fcx, &*base_expr, struct_type);\n-            }\n-        }\n-\n-        // Write in the resulting type.\n-        fcx.write_ty(id, struct_type);\n-    }\n-\n-    fn check_struct_enum_variant<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n-                                          id: ast::NodeId,\n-                                          span: codemap::Span,\n-                                          enum_id: ast::DefId,\n-                                          variant_id: ast::DefId,\n-                                          fields: &'tcx [ast::Field]) {\n-        // Look up the number of type parameters and the raw type, and\n-        // determine whether the enum is region-parameterized.\n-        let TypeAndSubsts {\n-            ty: enum_type,\n-            substs: _\n-        } = fcx.instantiate_type(span, enum_id);\n-\n-        // Look up and check the enum variant fields.\n-        let _ = check_struct_or_variant_fields(fcx,\n-                                               enum_type,\n-                                               span,\n-                                               variant_id,\n-                                               fields,\n-                                               true);\n-        fcx.write_ty(id, enum_type);\n     }\n \n     fn check_struct_fields_on_error<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n@@ -3237,6 +3173,42 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n+    fn check_expr_struct<'a, 'tcx>(fcx: &FnCtxt<'a,'tcx>,\n+                                   expr: &ast::Expr,\n+                                   path: &ast::Path,\n+                                   fields: &'tcx [ast::Field],\n+                                   base_expr: &'tcx Option<P<ast::Expr>>)\n+    {\n+        let tcx = fcx.tcx();\n+\n+        // Find the relevant variant\n+        let def = lookup_full_def(tcx, path.span, expr.id);\n+        let (adt, variant) = match fcx.def_struct_variant(def) {\n+            Some((adt, variant)) => (adt, variant),\n+            None => {\n+                span_err!(fcx.tcx().sess, path.span, E0071,\n+                          \"`{}` does not name a structure\",\n+                          pprust::path_to_string(path));\n+                check_struct_fields_on_error(fcx, expr.id, fields, base_expr);\n+                return;\n+            }\n+        };\n+\n+        let expr_ty = fcx.instantiate_type(def.def_id(), path);\n+        fcx.write_ty(expr.id, expr_ty);\n+\n+        check_expr_struct_fields(fcx, expr_ty, expr.span, variant, fields,\n+                                 base_expr.is_none());\n+\n+        if let &Some(ref base_expr) = base_expr {\n+            check_expr_has_type(fcx, base_expr, expr_ty);\n+            if adt.adt_kind() == ty::AdtKind::Enum {\n+                span_err!(tcx.sess, base_expr.span, E0436,\n+                          \"functional record update syntax requires a struct\");\n+            }\n+        }\n+    }\n+\n     type ExprCheckerWithTy = fn(&FnCtxt, &ast::Expr, Ty);\n \n     let tcx = fcx.ccx.tcx;\n@@ -3689,83 +3661,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n       }\n       ast::ExprStruct(ref path, ref fields, ref base_expr) => {\n-        // Resolve the path.\n-        let def = lookup_full_def(tcx, path.span, id);\n-        let struct_id = match def {\n-            def::DefVariant(enum_id, variant_id, true) => {\n-                if let &Some(ref base_expr) = base_expr {\n-                    span_err!(tcx.sess, base_expr.span, E0436,\n-                              \"functional record update syntax requires a struct\");\n-                    fcx.write_error(base_expr.id);\n-                }\n-                check_struct_enum_variant(fcx, id, expr.span, enum_id,\n-                                          variant_id, &fields[..]);\n-                enum_id\n-            }\n-            def::DefTrait(def_id) => {\n-                span_err!(tcx.sess, path.span, E0159,\n-                    \"use of trait `{}` as a struct constructor\",\n-                    pprust::path_to_string(path));\n-                check_struct_fields_on_error(fcx,\n-                                             id,\n-                                             &fields[..],\n-                                             base_expr);\n-                def_id\n-            },\n-            def => {\n-                // Verify that this was actually a struct.\n-                let typ = fcx.ccx.tcx.lookup_item_type(def.def_id());\n-                match typ.ty.sty {\n-                    ty::TyStruct(struct_def, _) => {\n-                        check_struct_constructor(fcx,\n-                                                 id,\n-                                                 expr.span,\n-                                                 struct_def,\n-                                                 &fields[..],\n-                                                 base_expr.as_ref().map(|e| &**e));\n-                    }\n-                    _ => {\n-                        span_err!(tcx.sess, path.span, E0071,\n-                            \"`{}` does not name a structure\",\n-                            pprust::path_to_string(path));\n-                        check_struct_fields_on_error(fcx,\n-                                                     id,\n-                                                     &fields[..],\n-                                                     base_expr);\n-                    }\n-                }\n-\n-                def.def_id()\n-            }\n-        };\n-\n-        // Turn the path into a type and verify that that type unifies with\n-        // the resulting structure type. This is needed to handle type\n-        // parameters correctly.\n-        let actual_structure_type = fcx.expr_ty(&*expr);\n-        if !actual_structure_type.references_error() {\n-            let type_and_substs = fcx.instantiate_struct_literal_ty(struct_id, path);\n-            match fcx.mk_subty(false,\n-                               infer::Misc(path.span),\n-                               actual_structure_type,\n-                               type_and_substs.ty) {\n-                Ok(()) => {}\n-                Err(type_error) => {\n-                    span_err!(fcx.tcx().sess, path.span, E0235,\n-                                 \"structure constructor specifies a \\\n-                                         structure of type `{}`, but this \\\n-                                         structure has type `{}`: {}\",\n-                                         fcx.infcx()\n-                                            .ty_to_string(type_and_substs.ty),\n-                                         fcx.infcx()\n-                                            .ty_to_string(\n-                                                actual_structure_type),\n-                                         type_error);\n-                    tcx.note_and_explain_type_err(&type_error, path.span);\n-                }\n-            }\n-        }\n-\n+        check_expr_struct(fcx, expr, path, fields, base_expr);\n         fcx.require_expr_have_sized_type(expr, traits::StructInitializerSized);\n       }\n       ast::ExprField(ref base, ref field) => {\n@@ -4745,6 +4641,9 @@ pub fn instantiate_path<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         }\n     }\n \n+    debug!(\"instantiate_path: type of {:?} is {:?}\",\n+           node_id,\n+           ty_substituted);\n     fcx.write_ty(node_id, ty_substituted);\n     fcx.write_substs(node_id, ty::ItemSubsts { substs: substs });\n     return;"}, {"sha": "7d3fea7813c23722006cc08874b4e94fa5f0693a", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 15, "deletions": 43, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -735,39 +735,34 @@ fn some_func(x: &mut i32) {\n \"##,\n \n E0071: r##\"\n-You tried to use a structure initialization with a non-structure type.\n+You tried to use structure-literal syntax to create an item that is\n+not a struct-style structure or enum variant.\n+\n Example of erroneous code:\n \n ```\n-enum Foo { FirstValue };\n+enum Foo { FirstValue(i32) };\n \n let u = Foo::FirstValue { value: 0i32 }; // error: Foo::FirstValue\n                                          // isn't a structure!\n-// or even simpler, if the structure wasn't defined at all:\n-let u = RandomName { random_field: 0i32 }; // error: RandomName\n-                                           // isn't a structure!\n+// or even simpler, if the name doesn't refer to a structure at all.\n+let t = u32 { value: 4 }; // error: `u32` does not name a structure.\n ```\n \n-To fix this, please check:\n- * Did you spell it right?\n- * Did you accidentaly used an enum as a struct?\n- * Did you accidentaly make an enum when you intended to use a struct?\n+To fix this, ensure that the name was correctly spelled, and that\n+the correct form of initializer was used.\n \n-Here is the previous code with all missing information:\n+For example, the code above can be fixed to:\n \n ```\n-struct Inner {\n-    value: i32\n-}\n-\n enum Foo {\n-    FirstValue(Inner)\n+    FirstValue(i32)\n }\n \n fn main() {\n-    let u = Foo::FirstValue(Inner { value: 0i32 });\n+    let u = Foo::FirstValue(0i32);\n \n-    let t = Inner { value: 0i32 };\n+    let t = 4;\n }\n ```\n \"##,\n@@ -1636,30 +1631,6 @@ fn(isize, *const *const u8) -> isize\n ```\n \"##,\n \n-E0159: r##\"\n-You tried to use a trait as a struct constructor. Erroneous code example:\n-\n-```\n-trait TraitNotAStruct {}\n-\n-TraitNotAStruct{ value: 0 }; // error: use of trait `TraitNotAStruct` as a\n-                             //        struct constructor\n-```\n-\n-Please verify you used the correct type name or please implement the trait\n-on a struct and use this struct constructor. Example:\n-\n-```\n-trait TraitNotAStruct {}\n-\n-struct Foo {\n-    value: i32\n-}\n-\n-Foo{ value: 0 }; // ok!\n-```\n-\"##,\n-\n E0166: r##\"\n This error means that the compiler found a return expression in a function\n marked as diverging. A function diverges if it has `!` in the place of the\n@@ -2728,10 +2699,11 @@ register_diagnostics! {\n     E0127,\n     E0129,\n     E0141,\n+//  E0159, // use of trait `{}` as struct constructor\n     E0163,\n     E0164,\n     E0167,\n-    E0168,\n+//  E0168,\n     E0173, // manual implementations of unboxed closure traits are experimental\n     E0174, // explicit use of unboxed closure methods are experimental\n     E0182,\n@@ -2764,7 +2736,7 @@ register_diagnostics! {\n     E0231, // only named substitution parameters are allowed\n     E0233,\n     E0234,\n-    E0235, // structure constructor specifies a structure of type but\n+//  E0235, // structure constructor specifies a structure of type but\n     E0236, // no lang item for range syntax\n     E0237, // no lang item for range syntax\n     E0238, // parenthesized parameters may only be used with a trait"}, {"sha": "5f7752bb203c2574da6986722d4ce348665c272e", "filename": "src/test/compile-fail-fulldeps/issue-18986.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fissue-18986.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -15,6 +15,6 @@ pub use use_from_trait_xc::Trait;\n \n fn main() {\n     match () {\n-        Trait { x: 42 } => () //~ ERROR use of trait `Trait` in a struct pattern\n+        Trait { x: 42 } => () //~ ERROR `Trait` does not name a struct\n     }\n }"}, {"sha": "69e10b90bfeba917a6e89378512172d9d93fcb19", "filename": "src/test/compile-fail/issue-15034.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-15034.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -25,7 +25,7 @@ struct Parser<'a> {\n impl<'a> Parser<'a> {\n     pub fn new(lexer: &'a mut Lexer) -> Parser<'a> {\n         Parser { lexer: lexer }\n-        //~^ ERROR cannot infer an appropriate lifetime for lifetime parameter\n+        //~^ ERROR cannot infer an appropriate lifetime\n     }\n }\n "}, {"sha": "b1ac2dfd1c414b14b564f7f3b9f24ea4d5c2884a", "filename": "src/test/compile-fail/issue-27815.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27815.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+mod A {}\n+\n+fn main() {\n+    let u = A { x: 1 }; //~ ERROR `A` does not name a structure\n+    let v = u32 { x: 1 }; //~ ERROR `u32` does not name a structure\n+    match () {\n+        A { x: 1 } => {} //~ ERROR `A` does not name a struct\n+        u32 { x: 1 } => {} //~ ERROR `u32` does not name a struct\n+    }\n+}"}, {"sha": "336368cf8a49d73e948893533dcfea9091bafc6e", "filename": "src/test/compile-fail/issue-27831.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-27831.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Foo(u32);\n+struct Bar;\n+\n+enum Enum {\n+    Foo(u32),\n+    Bar\n+}\n+\n+fn main() {\n+    let x = Foo(1);\n+    Foo { ..x }; //~ ERROR `Foo` does not name a structure\n+    let Foo { .. } = x; //~ ERROR `Foo` does not name a struct\n+\n+    let x = Bar;\n+    Bar { ..x }; //~ ERROR `Bar` does not name a structure\n+    let Bar { .. } = x; //~ ERROR `Bar` does not name a struct\n+\n+    match Enum::Bar {\n+        Enum::Bar { .. } //~ ERROR `Enum::Bar` does not name a struct\n+           => {}\n+        Enum::Foo { .. } //~ ERROR `Enum::Foo` does not name a struct\n+           => {}\n+    }\n+}"}, {"sha": "843ff38df49cb6527e53e5b6af644f1b6e6bb444", "filename": "src/test/compile-fail/issue-4736.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-4736.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -11,5 +11,5 @@\n struct NonCopyable(());\n \n fn main() {\n-    let z = NonCopyable{ p: () }; //~ ERROR structure `NonCopyable` has no field named `p`\n+    let z = NonCopyable{ p: () }; //~ ERROR `NonCopyable` does not name a structure\n }"}, {"sha": "7a6b8ff662240314cfa9086b1055639a24bbc544", "filename": "src/test/compile-fail/structure-constructor-type-mismatch.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstructure-constructor-type-mismatch.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -24,41 +24,66 @@ type PairF<U> = Pair<f32,U>;\n \n fn main() {\n     let pt = PointF {\n-        //~^ ERROR structure constructor specifies a structure of type\n+        x: 1,\n+        //~^ ERROR mismatched types\n         //~| expected f32\n         //~| found integral variable\n-        x: 1,\n         y: 2,\n+        //~^ ERROR mismatched types\n+        //~| expected f32\n+        //~| found integral variable\n     };\n \n     let pt2 = Point::<f32> {\n-        //~^ ERROR structure constructor specifies a structure of type\n+        x: 3,\n+        //~^ ERROR mismatched types\n         //~| expected f32\n         //~| found integral variable\n-        x: 3,\n         y: 4,\n+        //~^ ERROR mismatched types\n+        //~| expected f32\n+        //~| found integral variable\n     };\n \n     let pair = PairF {\n-        //~^ ERROR structure constructor specifies a structure of type\n+        x: 5,\n+        //~^ ERROR mismatched types\n         //~| expected f32\n         //~| found integral variable\n-        x: 5,\n         y: 6,\n     };\n \n     let pair2 = PairF::<i32> {\n-        //~^ ERROR structure constructor specifies a structure of type\n+        x: 7,\n+        //~^ ERROR mismatched types\n         //~| expected f32\n         //~| found integral variable\n-        x: 7,\n         y: 8,\n     };\n \n-    let pt3 = PointF::<i32> {\n-        //~^ ERROR wrong number of type arguments\n-        //~| ERROR structure constructor specifies a structure of type\n-        x: 9,\n-        y: 10,\n+    let pt3 = PointF::<i32> { //~ ERROR wrong number of type arguments\n+        x: 9,  //~ ERROR mismatched types\n+        y: 10, //~ ERROR mismatched types\n     };\n+\n+    match (Point { x: 1, y: 2 }) {\n+        PointF::<u32> { .. } => {} //~ ERROR wrong number of type arguments\n+        //~^ ERROR mismatched types\n+    }\n+\n+    match (Point { x: 1, y: 2 }) {\n+        PointF { .. } => {} //~ ERROR mismatched types\n+    }\n+\n+    match (Point { x: 1.0, y: 2.0 }) {\n+        PointF { .. } => {} // ok\n+    }\n+\n+    match (Pair { x: 1, y: 2 }) {\n+        PairF::<u32> { .. } => {} //~ ERROR mismatched types\n+    }\n+\n+    match (Pair { x: 1.0, y: 2 }) {\n+        PairF::<u32> { .. } => {} // ok\n+    }\n }"}, {"sha": "67ccd6b7cd058dd787c75c09230f58a45b72359c", "filename": "src/test/compile-fail/trait-as-struct-constructor.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ftrait-as-struct-constructor.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -12,5 +12,5 @@ trait TraitNotAStruct {}\n \n fn main() {\n     TraitNotAStruct{ value: 0 };\n-    //~^ ERROR: use of trait `TraitNotAStruct` as a struct constructor [E0159]\n+    //~^ ERROR: `TraitNotAStruct` does not name a structure [E0071]\n }"}, {"sha": "f1337a5b0797408784c42635cecd67d3ea1ef33d", "filename": "src/test/run-pass/struct-aliases.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-pass%2Fstruct-aliases.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d992728c331128810704d16d8026aa4fa2e0c87/src%2Ftest%2Frun-pass%2Fstruct-aliases.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstruct-aliases.rs?ref=6d992728c331128810704d16d8026aa4fa2e0c87", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::mem;\n \n struct S {\n     x: isize,\n@@ -16,6 +17,13 @@ struct S {\n \n type S2 = S;\n \n+struct S3<U,V> {\n+    x: U,\n+    y: V\n+}\n+\n+type S4<U> = S3<U, char>;\n+\n fn main() {\n     let s = S2 {\n         x: 1,\n@@ -30,4 +38,34 @@ fn main() {\n             assert_eq!(y, 2);\n         }\n     }\n+    // check that generics can be specified from the pattern\n+    let s = S4 {\n+        x: 4,\n+        y: 'a'\n+    };\n+    match s {\n+        S4::<u8> {\n+            x: x,\n+            y: y\n+        } => {\n+            assert_eq!(x, 4);\n+            assert_eq!(y, 'a');\n+            assert_eq!(mem::size_of_val(&x), 1);\n+        }\n+    };\n+    // check that generics can be specified from the constructor\n+    let s = S4::<u16> {\n+        x: 5,\n+        y: 'b'\n+    };\n+    match s {\n+        S4 {\n+            x: x,\n+            y: y\n+        } => {\n+            assert_eq!(x, 5);\n+            assert_eq!(y, 'b');\n+            assert_eq!(mem::size_of_val(&x), 2);\n+        }\n+    };\n }"}]}