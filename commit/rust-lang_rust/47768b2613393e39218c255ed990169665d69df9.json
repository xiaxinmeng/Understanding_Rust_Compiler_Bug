{"sha": "47768b2613393e39218c255ed990169665d69df9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3NzY4YjI2MTMzOTNlMzkyMThjMjU1ZWQ5OTAxNjk2NjVkNjlkZjk=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-08T01:05:32Z"}, "committer": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-08T13:31:09Z"}, "message": "Document + Cleanup lang_items.rs", "tree": {"sha": "3fd456daaf3dbe137076721fe9bcf2a5bc6fc42c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3fd456daaf3dbe137076721fe9bcf2a5bc6fc42c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47768b2613393e39218c255ed990169665d69df9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47768b2613393e39218c255ed990169665d69df9", "html_url": "https://github.com/rust-lang/rust/commit/47768b2613393e39218c255ed990169665d69df9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47768b2613393e39218c255ed990169665d69df9/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b92d360c6cf029bd98c154cb510ec9e11b39bad6", "url": "https://api.github.com/repos/rust-lang/rust/commits/b92d360c6cf029bd98c154cb510ec9e11b39bad6", "html_url": "https://github.com/rust-lang/rust/commit/b92d360c6cf029bd98c154cb510ec9e11b39bad6"}], "stats": {"total": 97, "additions": 60, "deletions": 37}, "files": [{"sha": "0e283ca6b1cf15170e231ebc86fc1ad0b72723dc", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 60, "deletions": 37, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/47768b2613393e39218c255ed990169665d69df9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47768b2613393e39218c255ed990169665d69df9/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=47768b2613393e39218c255ed990169665d69df9", "patch": "@@ -1,13 +1,13 @@\n-// Detecting language items.\n-//\n-// Language items are items that represent concepts intrinsic to the language\n-// itself. Examples are:\n-//\n-// * Traits that specify \"kinds\"; e.g., \"Sync\", \"Send\".\n-//\n-// * Traits that represent operators; e.g., \"Add\", \"Sub\", \"Index\".\n-//\n-// * Functions called by the compiler itself.\n+//! Detecting language items.\n+//!\n+//! Language items are items that represent concepts intrinsic to the language\n+//! itself. Examples are:\n+//!\n+//! * Traits that specify \"kinds\"; e.g., \"Sync\", \"Send\".\n+//!\n+//! * Traits that represent operators; e.g., \"Add\", \"Sub\", \"Index\".\n+//!\n+//! * Functions called by the compiler itself.\n \n pub use self::LangItem::*;\n \n@@ -32,13 +32,17 @@ macro_rules! language_item_table {\n     ) => {\n \n enum_from_u32! {\n+    /// A representation of all the valid language items in Rust.\n     #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash, RustcEncodable, RustcDecodable)]\n     pub enum LangItem {\n         $($variant,)*\n     }\n }\n \n impl LangItem {\n+    /// Returns the `name` in `#[lang = \"$name\"]`.\n+    /// For example, `LangItem::EqTraitLangItem`,\n+    /// that is `#[lang = \"eq\"]` would result in `\"eq\"`.\n     fn name(self) -> &'static str {\n         match self {\n             $( $variant => $name, )*\n@@ -48,28 +52,38 @@ impl LangItem {\n \n #[derive(HashStable)]\n pub struct LanguageItems {\n+    /// Mappings from lang items to their possibly found `DefId`s.\n+    /// The index corresponds to the order in `LangItem`.\n     pub items: Vec<Option<DefId>>,\n+    /// Lang items that were not found during collection.\n     pub missing: Vec<LangItem>,\n }\n \n impl LanguageItems {\n-    pub fn new() -> LanguageItems {\n-        fn foo(_: LangItem) -> Option<DefId> { None }\n+    /// Construct an empty collection of lang items and no missing ones.\n+    pub fn new() -> Self {\n+        fn init_none(_: LangItem) -> Option<DefId> { None }\n \n-        LanguageItems {\n-            items: vec![$(foo($variant)),*],\n+        Self {\n+            items: vec![$(init_none($variant)),*],\n             missing: Vec::new(),\n         }\n     }\n \n+    /// Returns the mappings to the possibly found `DefId`s for each lang item.\n     pub fn items(&self) -> &[Option<DefId>] {\n         &*self.items\n     }\n \n+    /// Requires that a given `LangItem` was bound and returns the corresponding `DefId`.\n+    /// If it wasn't bound, e.g. due to a missing `#[lang = \"<it.name()>\"]`,\n+    /// returns an error message as a string.\n     pub fn require(&self, it: LangItem) -> Result<DefId, String> {\n         self.items[it as usize].ok_or_else(|| format!(\"requires `{}` lang_item\", it.name()))\n     }\n \n+    /// Returns the kind of closure that `id`, which is one of the `Fn*` traits, corresponds to.\n+    /// If `id` is not one of the `Fn*` traits, `None` is returned.\n     pub fn fn_trait_kind(&self, id: DefId) -> Option<ty::ClosureKind> {\n         match Some(id) {\n             x if x == self.fn_trait() => Some(ty::ClosureKind::Fn),\n@@ -80,6 +94,9 @@ impl LanguageItems {\n     }\n \n     $(\n+        /// Returns the corresponding `DefId` for the lang item\n+        #[doc = $name]\n+        /// if it exists.\n         #[allow(dead_code)]\n         pub fn $method(&self) -> Option<DefId> {\n             self.items[$variant as usize]\n@@ -90,6 +107,7 @@ impl LanguageItems {\n struct LanguageItemCollector<'a, 'tcx: 'a> {\n     items: LanguageItems,\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    /// A mapping from the name of the lang item to its order and the form it must be of.\n     item_refs: FxHashMap<&'static str, (usize, Target)>,\n }\n \n@@ -105,32 +123,28 @@ impl<'a, 'v, 'tcx> ItemLikeVisitor<'v> for LanguageItemCollector<'a, 'tcx> {\n                 },\n                 // Known lang item with attribute on incorrect target.\n                 Some((_, expected_target)) => {\n-                    let mut err = struct_span_err!(\n+                    struct_span_err!(\n                         self.tcx.sess, span, E0718,\n                         \"`{}` language item must be applied to a {}\",\n                         value, expected_target,\n-                    );\n-                    err.span_label(\n+                    ).span_label(\n                         span,\n                         format!(\n                             \"attribute should be applied to a {}, not a {}\",\n                             expected_target, actual_target,\n                         ),\n-                    );\n-                    err.emit();\n+                    ).emit();\n                 },\n                 // Unknown lang item.\n                 _ => {\n-                    let mut err = struct_span_err!(\n+                    struct_span_err!(\n                         self.tcx.sess, span, E0522,\n                         \"definition of an unknown language item: `{}`\",\n                         value\n-                    );\n-                    err.span_label(\n+                    ).span_label(\n                         span,\n                         format!(\"definition of unknown language item `{}`\", value)\n-                    );\n-                    err.emit();\n+                    ).emit();\n                 },\n             }\n         }\n@@ -190,32 +204,39 @@ impl<'a, 'tcx> LanguageItemCollector<'a, 'tcx> {\n     }\n }\n \n+/// Extract the first `lang = \"$name\"` out of a list of attributes.\n+/// The attributes `#[panic_handler]` and `#[alloc_error_handler]`\n+/// are also extracted out when found.\n pub fn extract(attrs: &[ast::Attribute]) -> Option<(Symbol, Span)> {\n-    for attribute in attrs {\n-        if attribute.check_name(\"lang\") {\n-            if let Some(value) = attribute.value_str() {\n-                return Some((value, attribute.span));\n-            }\n-        } else if attribute.check_name(\"panic_handler\") {\n-            return Some((Symbol::intern(\"panic_impl\"), attribute.span))\n-        } else if attribute.check_name(\"alloc_error_handler\") {\n-            return Some((Symbol::intern(\"oom\"), attribute.span))\n-        }\n-    }\n-\n-    None\n+    attrs.iter().find_map(|attr| Some(match attr {\n+        _ if attr.check_name(\"lang\") => (attr.value_str()?, attr.span),\n+        _ if attr.check_name(\"panic_handler\") => (Symbol::intern(\"panic_impl\"), attr.span),\n+        _ if attr.check_name(\"alloc_error_handler\") => (Symbol::intern(\"oom\"), attr.span),\n+        _ => return None,\n+    }))\n }\n \n+/// Traverse and collect all the lang items in all crates.\n pub fn collect<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) -> LanguageItems {\n+    // Initialize the collector.\n     let mut collector = LanguageItemCollector::new(tcx);\n+\n+    // Collect lang items in other crates.\n     for &cnum in tcx.crates().iter() {\n         for &(def_id, item_index) in tcx.defined_lang_items(cnum).iter() {\n             collector.collect_item(item_index, def_id);\n         }\n     }\n+\n+    // Collect lang items in this crate.\n     tcx.hir().krate().visit_all_item_likes(&mut collector);\n+\n+    // Extract out the found lang items.\n     let LanguageItemCollector { mut items, .. } = collector;\n+\n+    // Find all required but not-yet-defined lang items.\n     weak_lang_items::check_crate(tcx, &mut items);\n+\n     items\n }\n \n@@ -382,6 +403,8 @@ language_item_table! {\n }\n \n impl<'a, 'tcx, 'gcx> TyCtxt<'a, 'tcx, 'gcx> {\n+    /// Returns the `DefId` for a given `LangItem`.\n+    /// If not found, fatally abort compilation.\n     pub fn require_lang_item(&self, lang_item: LangItem) -> DefId {\n         self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n             self.sess.fatal(&msg)"}]}