{"sha": "ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlODU3ZTNkNjBkYTFiNWVmZjVkODMwZGJkMDNmMzJhODg5MGFkMTY=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-17T19:16:30Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2013-06-23T18:40:14Z"}, "message": "Parse and typecheck (not kindcheck) bounds on trait paths.", "tree": {"sha": "0874080aaf00735050a07a541f3f72b31818117d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0874080aaf00735050a07a541f3f72b31818117d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "html_url": "https://github.com/rust-lang/rust/commit/ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "394f455b5edfe96b51bc713ccc65ad3db6bed92f", "url": "https://api.github.com/repos/rust-lang/rust/commits/394f455b5edfe96b51bc713ccc65ad3db6bed92f", "html_url": "https://github.com/rust-lang/rust/commit/394f455b5edfe96b51bc713ccc65ad3db6bed92f"}], "stats": {"total": 318, "additions": 197, "deletions": 121}, "files": [{"sha": "94cad18ece2cdcf8f702bf8be515e1c0e0ffe4b1", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -954,7 +954,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(ecx, ebml_w, item.ident);\n         encode_attributes(ebml_w, item.attrs);\n         match ty.node {\n-            ast::ty_path(path, _) if path.idents.len() == 1 => {\n+            ast::ty_path(path, bounds, _) if path.idents.len() == 1 => {\n+                assert!(bounds.is_empty());\n                 encode_impl_type_basename(ecx, ebml_w,\n                                           ast_util::path_to_ident(path));\n             }"}, {"sha": "b53bdcc9bbe0bf2870e880c6fe6aeb3585a34b79", "filename": "src/librustc/metadata/tydecode.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmetadata%2Ftydecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftydecode.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -311,8 +311,9 @@ fn parse_ty(st: &mut PState, conv: conv_did) -> ty::t {\n         let substs = parse_substs(st, conv);\n         let store = parse_trait_store(st);\n         let mt = parse_mutability(st);\n+        let bounds = parse_bounds(st, conv);\n         assert_eq!(next(st), ']');\n-        return ty::mk_trait(st.tcx, def, substs, store, mt);\n+        return ty::mk_trait(st.tcx, def, substs, store, mt, bounds.builtin_bounds);\n       }\n       'p' => {\n         let did = parse_def(st, TypeParameter, conv);"}, {"sha": "dd62a8e11cb7f797bfdc052bcad007cbdc0dda89", "filename": "src/librustc/metadata/tyencode.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmetadata%2Ftyencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ftyencode.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -261,13 +261,16 @@ fn enc_sty(w: @io::Writer, cx: @ctxt, st: ty::sty) {\n         enc_substs(w, cx, substs);\n         w.write_char(']');\n       }\n-      ty::ty_trait(def, ref substs, store, mt) => {\n+      ty::ty_trait(def, ref substs, store, mt, bounds) => {\n         w.write_str(&\"x[\");\n         w.write_str((cx.ds)(def));\n         w.write_char('|');\n         enc_substs(w, cx, substs);\n         enc_trait_store(w, cx, store);\n         enc_mutability(w, mt);\n+        let bounds = ty::ParamBounds {builtin_bounds: bounds,\n+                                      trait_bounds: ~[]};\n+        enc_bounds(w, cx, &bounds);\n         w.write_char(']');\n       }\n       ty::ty_tup(ts) => {"}, {"sha": "1768852bb3031e8e6db186a3ea079cd670170142", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -129,7 +129,8 @@ fn check_item(item: @item, (cx, visitor): (Context, visit::vt<Context>)) {\n                         if cx.tcx.lang_items.drop_trait() == trait_def_id {\n                             // Yes, it's a destructor.\n                             match self_type.node {\n-                                ty_path(_, path_node_id) => {\n+                                ty_path(_, bounds, path_node_id) => {\n+                                    assert!(bounds.is_empty());\n                                     let struct_def = cx.tcx.def_map.get_copy(\n                                         &path_node_id);\n                                     let struct_did =\n@@ -307,7 +308,7 @@ pub fn check_expr(e: @expr, (cx, v): (Context, visit::vt<Context>)) {\n \n fn check_ty(aty: @Ty, (cx, v): (Context, visit::vt<Context>)) {\n     match aty.node {\n-      ty_path(_, id) => {\n+      ty_path(_, _, id) => {\n           let r = cx.tcx.node_type_substs.find(&id);\n           for r.iter().advance |ts| {\n               let did = ast_util::def_id_of_def(cx.tcx.def_map.get_copy(&id));\n@@ -533,7 +534,8 @@ pub fn check_cast_for_escaping_regions(\n pub fn check_kind_bounds_of_cast(cx: Context, source: @expr, target: @expr) {\n     let target_ty = ty::expr_ty(cx.tcx, target);\n     match ty::get(target_ty).sty {\n-        ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n+        // FIXME(#3569) kind check bounds here\n+        ty::ty_trait(_, _, ty::UniqTraitStore, _, _bounds) => {\n             let source_ty = ty::expr_ty(cx.tcx, source);\n             if !ty::type_is_owned(cx.tcx, source_ty) {\n                 cx.tcx.sess.span_err("}, {"sha": "821aed731c2298d108cd36308e26d721b90b5713", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -714,7 +714,7 @@ fn check_item_ctypes(cx: &Context, it: @ast::item) {\n         let tys = vec::map(decl.inputs, |a| a.ty );\n         for vec::each(vec::append_one(tys, decl.output)) |ty| {\n             match ty.node {\n-              ast::ty_path(_, id) => {\n+              ast::ty_path(_, _, id) => {\n                 match cx.tcx.def_map.get_copy(&id) {\n                   ast::def_prim_ty(ast::ty_int(ast::ty_i)) => {\n                     cx.span_lint(ctypes, ty.span,"}, {"sha": "0e6d8617ba424003c580b886d4326a77cb719055", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -804,7 +804,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n     // then check whether it is region-parameterized and consider\n     // that as a direct dependency.\n     match ty.node {\n-      ast::ty_path(path, id) => {\n+      ast::ty_path(path, _bounds, id) => {\n         match cx.def_map.find(&id) {\n           Some(&ast::def_ty(did)) |\n           Some(&ast::def_trait(did)) |\n@@ -840,7 +840,7 @@ pub fn determine_rp_in_ty(ty: @ast::Ty,\n         visit_mt(mt, (cx, visitor));\n       }\n \n-      ast::ty_path(path, _) => {\n+      ast::ty_path(path, _bounds, _) => {\n         // type parameters are---for now, anyway---always invariant\n         do cx.with_ambient_variance(rv_invariant) {\n             for path.types.iter().advance |tp| {"}, {"sha": "eed0b12b9e123a0f89807336c05e60e94babb1d6", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -1250,7 +1250,7 @@ impl Resolver {\n                 // If there are static methods, then create the module\n                 // and add them.\n                 match (trait_ref_opt, ty) {\n-                    (None, @Ty { node: ty_path(path, _), _ }) if\n+                    (None, @Ty { node: ty_path(path, _, _), _ }) if\n                             has_static_methods && path.idents.len() == 1 => {\n                         let name = path_to_ident(path);\n \n@@ -4120,7 +4120,7 @@ impl Resolver {\n             // Like path expressions, the interpretation of path types depends\n             // on whether the path has multiple elements in it or not.\n \n-            ty_path(path, path_id) => {\n+            ty_path(path, bounds, path_id) => {\n                 // This is a path in the type namespace. Walk through scopes\n                 // scopes looking for it.\n                 let mut result_def = None;\n@@ -4179,6 +4179,10 @@ impl Resolver {\n                                            self.idents_to_str(path.idents)));\n                     }\n                 }\n+\n+                for bounds.each |bound| {\n+                    self.resolve_type_parameter_bound(bound, visitor);\n+                }\n             }\n \n             ty_closure(c) => {"}, {"sha": "11eecf82bacaf7416ed26b1916cb55e8b5573feb", "filename": "src/librustc/middle/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fdebuginfo.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -561,7 +561,7 @@ fn create_ty(cx: @mut CrateContext, t: ty::t, span: span) -> DIType {\n             cx.sess.span_note(span, \"debuginfo for closure NYI\");\n             create_unimpl_ty(cx, t)\n         },\n-        ty::ty_trait(_did, ref _substs, ref _vstore, _) => {\n+        ty::ty_trait(_did, ref _substs, ref _vstore, _, _bounds) => {\n             cx.sess.span_note(span, \"debuginfo for trait NYI\");\n             create_unimpl_ty(cx, t)\n         },"}, {"sha": "7d86f743a8e48a92529692c9b5756dc774c416a2", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -683,7 +683,7 @@ fn trans_rvalue_dps_unadjusted(bcx: block, expr: @ast::expr,\n         }\n         ast::expr_cast(val, _) => {\n             match ty::get(node_id_type(bcx, expr.id)).sty {\n-                ty::ty_trait(_, _, store, _) => {\n+                ty::ty_trait(_, _, store, _, _) => {\n                     return meth::trans_trait_cast(bcx, val, expr.id, dest,\n                                                   store);\n                 }"}, {"sha": "d8ba524b2bd117657629874255251df39c57b0ea", "filename": "src/librustc/middle/trans/glue.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fglue.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -486,13 +486,13 @@ pub fn make_drop_glue(bcx: block, v0: ValueRef, t: ty::t) {\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v0, t, drop_ty)\n       }\n-      ty::ty_trait(_, _, ty::BoxTraitStore, _) => {\n+      ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n           let llbox_ptr = GEPi(bcx, v0, [0u, abi::trt_field_box]);\n           let llbox = Load(bcx, llbox_ptr);\n           decr_refcnt_maybe_free(bcx, llbox, Some(llbox_ptr),\n                                  ty::mk_opaque_box(ccx.tcx))\n       }\n-      ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n+      ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n           let lluniquevalue = GEPi(bcx, v0, [0, abi::trt_field_box]);\n           // Only drop the value when it is non-null\n           do with_cond(bcx, IsNotNull(bcx, Load(bcx, lluniquevalue))) |bcx| {\n@@ -571,12 +571,12 @@ pub fn make_take_glue(bcx: block, v: ValueRef, t: ty::t) {\n       ty::ty_closure(_) => {\n         closure::make_closure_glue(bcx, v, t, take_ty)\n       }\n-      ty::ty_trait(_, _, ty::BoxTraitStore, _) => {\n+      ty::ty_trait(_, _, ty::BoxTraitStore, _, _) => {\n         let llbox = Load(bcx, GEPi(bcx, v, [0u, abi::trt_field_box]));\n         incr_refcnt_of_boxed(bcx, llbox);\n         bcx\n       }\n-      ty::ty_trait(_, _, ty::UniqTraitStore, _) => {\n+      ty::ty_trait(_, _, ty::UniqTraitStore, _, _) => {\n           let lluniquevalue = GEPi(bcx, v, [0, abi::trt_field_box]);\n           let llvtable = Load(bcx, GEPi(bcx, v, [0, abi::trt_field_vtable]));\n "}, {"sha": "4f4bbf84a72bff5cf9eff4e11fbc8330f12a484d", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -293,7 +293,7 @@ pub fn normalize_for_monomorphization(tcx: ty::ctxt,\n         ty::ty_closure(ref fty) => {\n             Some(normalized_closure_ty(tcx, fty.sigil))\n         }\n-        ty::ty_trait(_, _, ref store, _) => {\n+        ty::ty_trait(_, _, ref store, _, _) => {\n             let sigil = match *store {\n                 ty::UniqTraitStore => ast::OwnedSigil,\n                 ty::BoxTraitStore => ast::ManagedSigil,"}, {"sha": "6a40c1f75e9eee41f6ea2e0d9faeb4888a268e93", "filename": "src/librustc/middle/trans/reachable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freachable.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -160,7 +160,7 @@ fn traverse_ty<'a>(ty: @Ty, (cx, v): (@mut ctx<'a>, visit::vt<@mut ctx<'a>>)) {\n     }\n \n     match ty.node {\n-      ty_path(p, p_id) => {\n+      ty_path(p, _bounds, p_id) => {\n         match cx.tcx.def_map.find(&p_id) {\n           // Kind of a hack to check this here, but I'm not sure what else\n           // to do"}, {"sha": "316eb6893f25b8111fefbbae7977f7d606b096f8", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -335,7 +335,7 @@ impl Reflector {\n           }\n \n           // Miscallaneous extra types\n-          ty::ty_trait(_, _, _, _) => self.leaf(~\"trait\"),\n+          ty::ty_trait(_, _, _, _, _) => self.leaf(~\"trait\"),\n           ty::ty_infer(_) => self.leaf(~\"infer\"),\n           ty::ty_err => self.leaf(~\"err\"),\n           ty::ty_param(ref p) => {"}, {"sha": "3699314a1d2cf561d051c826af90b003f0b81f47", "filename": "src/librustc/middle/trans/type_of.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_of.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -140,7 +140,7 @@ pub fn sizing_type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n \n         ty::ty_bare_fn(*) => Type::i8p(),\n         ty::ty_closure(*) => Type::struct_([Type::i8p(), Type::i8p()], false),\n-        ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n+        ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n \n         ty::ty_estr(ty::vstore_fixed(size)) => Type::array(&Type::i8(), size as u64),\n         ty::ty_evec(mt, ty::vstore_fixed(size)) => {\n@@ -271,7 +271,7 @@ pub fn type_of(cx: &mut CrateContext, t: ty::t) -> Type {\n           let ty = type_of_fn_from_ty(cx, t);\n           Type::func_pair(cx, &ty)\n       }\n-      ty::ty_trait(_, _, store, _) => Type::opaque_trait(cx, store),\n+      ty::ty_trait(_, _, store, _, _) => Type::opaque_trait(cx, store),\n       ty::ty_type => cx.tydesc_type.ptr_to(),\n       ty::ty_tup(*) => {\n           let repr = adt::represent_type(cx, t);"}, {"sha": "f2446d1a11536e71359152be9b57e725505a069b", "filename": "src/librustc/middle/trans/type_use.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -208,7 +208,7 @@ pub fn type_needs_inner(cx: Context,\n                 ty::ty_bare_fn(*) |\n                 ty::ty_ptr(_) |\n                 ty::ty_rptr(_, _) |\n-                ty::ty_trait(_, _, _, _) => false,\n+                ty::ty_trait(*) => false,\n \n               ty::ty_enum(did, ref substs) => {\n                 if list::find(enums_seen, |id| *id == did).is_none() {"}, {"sha": "b76f30a704108ab511e94b137c2be2ec555de60e", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 28, "deletions": 20, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -419,7 +419,8 @@ impl to_bytes::IterBytes for ClosureTy {\n         self.sigil.iter_bytes(lsb0, f) &&\n         self.onceness.iter_bytes(lsb0, f) &&\n         self.region.iter_bytes(lsb0, f) &&\n-        self.sig.iter_bytes(lsb0, f)\n+        self.sig.iter_bytes(lsb0, f) &&\n+        self.bounds.iter_bytes(lsb0, f)\n     }\n }\n \n@@ -600,7 +601,7 @@ pub enum sty {\n     ty_rptr(Region, mt),\n     ty_bare_fn(BareFnTy),\n     ty_closure(ClosureTy),\n-    ty_trait(def_id, substs, TraitStore, ast::mutability),\n+    ty_trait(def_id, substs, TraitStore, ast::mutability, BuiltinBounds),\n     ty_struct(def_id, substs),\n     ty_tup(~[t]),\n \n@@ -1046,7 +1047,7 @@ fn mk_t(cx: ctxt, st: sty) -> t {\n       &ty_infer(_) => flags |= needs_infer as uint,\n       &ty_self(_) => flags |= has_self as uint,\n       &ty_enum(_, ref substs) | &ty_struct(_, ref substs) |\n-      &ty_trait(_, ref substs, _, _) => {\n+      &ty_trait(_, ref substs, _, _, _) => {\n         flags |= sflags(substs);\n       }\n       &ty_box(ref m) | &ty_uniq(ref m) | &ty_evec(ref m, _) |\n@@ -1268,10 +1269,11 @@ pub fn mk_trait(cx: ctxt,\n                 did: ast::def_id,\n                 substs: substs,\n                 store: TraitStore,\n-                mutability: ast::mutability)\n+                mutability: ast::mutability,\n+                bounds: BuiltinBounds)\n              -> t {\n     // take a copy of substs so that we own the vectors inside\n-    mk_t(cx, ty_trait(did, substs, store, mutability))\n+    mk_t(cx, ty_trait(did, substs, store, mutability, bounds))\n }\n \n pub fn mk_struct(cx: ctxt, struct_id: ast::def_id, substs: substs) -> t {\n@@ -1319,7 +1321,7 @@ pub fn maybe_walk_ty(ty: t, f: &fn(t) -> bool) {\n         maybe_walk_ty(tm.ty, f);\n       }\n       ty_enum(_, ref substs) | ty_struct(_, ref substs) |\n-      ty_trait(_, ref substs, _, _) => {\n+      ty_trait(_, ref substs, _, _, _) => {\n         for (*substs).tps.iter().advance |subty| { maybe_walk_ty(*subty, f); }\n       }\n       ty_tup(ref ts) => { for ts.iter().advance |tt| { maybe_walk_ty(*tt, f); } }\n@@ -1380,8 +1382,8 @@ fn fold_sty(sty: &sty, fldop: &fn(t) -> t) -> sty {\n         ty_enum(tid, ref substs) => {\n             ty_enum(tid, fold_substs(substs, fldop))\n         }\n-        ty_trait(did, ref substs, st, mutbl) => {\n-            ty_trait(did, fold_substs(substs, fldop), st, mutbl)\n+        ty_trait(did, ref substs, st, mutbl, bounds) => {\n+            ty_trait(did, fold_substs(substs, fldop), st, mutbl, bounds)\n         }\n         ty_tup(ref ts) => {\n             let new_ts = ts.map(|tt| fldop(*tt));\n@@ -1470,8 +1472,12 @@ pub fn fold_regions_and_ty(\n       ty_struct(def_id, ref substs) => {\n         ty::mk_struct(cx, def_id, fold_substs(substs, fldr, fldt))\n       }\n-      ty_trait(def_id, ref substs, st, mutbl) => {\n-        ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), st, mutbl)\n+      ty_trait(def_id, ref substs, st, mutbl, bounds) => {\n+        let st = match st {\n+            RegionTraitStore(region) => RegionTraitStore(fldr(region)),\n+            st => st,\n+        };\n+        ty::mk_trait(cx, def_id, fold_substs(substs, fldr, fldt), st, mutbl, bounds)\n       }\n       ty_bare_fn(ref f) => {\n           ty::mk_bare_fn(cx, BareFnTy {sig: fold_sig(&f.sig, fldfnt),\n@@ -2054,18 +2060,18 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                 TC_MANAGED + statically_sized(nonowned(tc_mt(cx, mt, cache)))\n             }\n \n-            ty_trait(_, _, UniqTraitStore, _) => {\n+            ty_trait(_, _, UniqTraitStore, _, _bounds) => {\n                 TC_OWNED_CLOSURE\n             }\n \n-            ty_trait(_, _, BoxTraitStore, mutbl) => {\n+            ty_trait(_, _, BoxTraitStore, mutbl, _bounds) => {\n                 match mutbl {\n                     ast::m_mutbl => TC_MANAGED + TC_MUTABLE,\n                     _ => TC_MANAGED\n                 }\n             }\n \n-            ty_trait(_, _, RegionTraitStore(r), mutbl) => {\n+            ty_trait(_, _, RegionTraitStore(r), mutbl, _bounds) => {\n                 borrowed_contents(r, mutbl)\n             }\n \n@@ -2347,7 +2353,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n                 false           // unsafe ptrs can always be NULL\n             }\n \n-            ty_trait(_, _, _, _) => {\n+            ty_trait(_, _, _, _, _) => {\n                 false\n             }\n \n@@ -2500,7 +2506,7 @@ pub fn type_is_pod(cx: ctxt, ty: t) -> bool {\n       ty_box(_) | ty_uniq(_) | ty_closure(_) |\n       ty_estr(vstore_uniq) | ty_estr(vstore_box) |\n       ty_evec(_, vstore_uniq) | ty_evec(_, vstore_box) |\n-      ty_trait(_, _, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n+      ty_trait(_, _, _, _, _) | ty_rptr(_,_) | ty_opaque_box => result = false,\n       // Structural types\n       ty_enum(did, ref substs) => {\n         let variants = enum_variants(cx, did);\n@@ -2791,12 +2797,13 @@ impl to_bytes::IterBytes for sty {\n \n             ty_uniq(ref mt) => 19u8.iter_bytes(lsb0, f) && mt.iter_bytes(lsb0, f),\n \n-            ty_trait(ref did, ref substs, ref v, ref mutbl) => {\n+            ty_trait(ref did, ref substs, ref v, ref mutbl, bounds) => {\n                 20u8.iter_bytes(lsb0, f) &&\n                 did.iter_bytes(lsb0, f) &&\n                 substs.iter_bytes(lsb0, f) &&\n                 v.iter_bytes(lsb0, f) &&\n-                mutbl.iter_bytes(lsb0, f)\n+                mutbl.iter_bytes(lsb0, f) &&\n+                bounds.iter_bytes(lsb0, f)\n             }\n \n             ty_opaque_closure_ptr(ref ck) => 21u8.iter_bytes(lsb0, f) && ck.iter_bytes(lsb0, f),\n@@ -3440,7 +3447,7 @@ pub fn ty_sort_str(cx: ctxt, t: t) -> ~str {\n       ty_rptr(_, _) => ~\"&-ptr\",\n       ty_bare_fn(_) => ~\"extern fn\",\n       ty_closure(_) => ~\"fn\",\n-      ty_trait(id, _, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n+      ty_trait(id, _, _, _, _) => fmt!(\"trait %s\", item_path_str(cx, id)),\n       ty_struct(id, _) => fmt!(\"struct %s\", item_path_str(cx, id)),\n       ty_tup(_) => ~\"tuple\",\n       ty_infer(TyVar(_)) => ~\"inferred type\",\n@@ -3774,7 +3781,7 @@ pub fn impl_trait_ref(cx: ctxt, id: ast::def_id) -> Option<@TraitRef> {\n \n pub fn ty_to_def_id(ty: t) -> Option<ast::def_id> {\n     match get(ty).sty {\n-      ty_trait(id, _, _, _) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n+      ty_trait(id, _, _, _, _) | ty_struct(id, _) | ty_enum(id, _) => Some(id),\n       _ => None\n     }\n }\n@@ -4454,5 +4461,6 @@ pub fn visitor_object_ty(tcx: ctxt) -> (@TraitRef, t) {\n     assert!(tcx.intrinsic_traits.contains_key(&ty_visitor_name));\n     let trait_ref = tcx.intrinsic_traits.get_copy(&ty_visitor_name);\n     (trait_ref,\n-     mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs, BoxTraitStore, ast::m_imm))\n+     mk_trait(tcx, trait_ref.def_id, copy trait_ref.substs,\n+              BoxTraitStore, ast::m_imm, EmptyBuiltinBounds()))\n }"}, {"sha": "3b651451db84777061eb7dd700711caf9d678d28", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -277,7 +277,10 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                 }\n                 return ty::mk_evec(tcx, mt, vst);\n             }\n-            ast::ty_path(path, id) => {\n+            ast::ty_path(path, bounds, id) => {\n+                // Note that the \"bounds must be empty if path is not a trait\"\n+                // restriction is enforced in the below case for ty_path, which\n+                // will run after this as long as the path isn't a trait.\n                 match tcx.def_map.find(&id) {\n                     Some(&ast::def_prim_ty(ast::ty_str)) if a_seq_ty.mutbl == ast::m_imm => {\n                         check_path_args(tcx, path, NO_TPS | NO_REGIONS);\n@@ -300,11 +303,13 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                 ty::BoxTraitStore\n                             }\n                         };\n+                        let bounds = conv_builtin_bounds(this.tcx(), bounds);\n                         return ty::mk_trait(tcx,\n                                             result.def_id,\n                                             copy result.substs,\n                                             trait_store,\n-                                            a_seq_ty.mutbl);\n+                                            a_seq_ty.mutbl,\n+                                            bounds);\n                     }\n                     _ => {}\n                 }\n@@ -395,13 +400,22 @@ pub fn ast_ty_to_ty<AC:AstConv, RS:region_scope + Copy + 'static>(\n                                       ast_ty.span);\n           ty::mk_closure(tcx, fn_decl)\n       }\n-      ast::ty_path(path, id) => {\n+      ast::ty_path(path, bounds, id) => {\n         let a_def = match tcx.def_map.find(&id) {\n           None => tcx.sess.span_fatal(\n               ast_ty.span, fmt!(\"unbound path %s\",\n                                 path_to_str(path, tcx.sess.intr()))),\n           Some(&d) => d\n         };\n+        // Kind bounds on path types are only supported for traits.\n+        match a_def {\n+            // But don't emit the error if the user meant to do a trait anyway.\n+            ast::def_trait(*) => { },\n+            _ if !bounds.is_empty() =>\n+                tcx.sess.span_err(ast_ty.span,\n+                    \"kind bounds can only be used on trait types\"),\n+            _ => { },\n+        }\n         match a_def {\n           ast::def_trait(_) => {\n               let path_str = path_to_str(path, tcx.sess.intr());"}, {"sha": "60855e6cd96987b7415fc11854a6c6155d6c83e2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -292,7 +292,7 @@ impl<'self> LookupContext<'self> {\n                 ty_param(p) => {\n                     self.push_inherent_candidates_from_param(self_ty, p);\n                 }\n-                ty_trait(did, ref substs, store, _) => {\n+                ty_trait(did, ref substs, store, _, _) => {\n                     self.push_inherent_candidates_from_trait(\n                         self_ty, did, substs, store);\n                     self.push_inherent_impl_candidates_for_type(did);"}, {"sha": "69d4d82d15f28e5b49ae9e29c152f79ec5b6b6ba", "filename": "src/librustc/middle/typeck/check/regionck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionck.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -360,7 +360,7 @@ fn visit_expr(expr: @ast::expr, (rcx, v): (@mut Rcx, rvt)) {\n             // explaining how it goes about doing that.\n             let target_ty = rcx.resolve_node_type(expr.id);\n             match ty::get(target_ty).sty {\n-                ty::ty_trait(_, _, ty::RegionTraitStore(trait_region), _) => {\n+                ty::ty_trait(_, _, ty::RegionTraitStore(trait_region), _, _) => {\n                     let source_ty = rcx.fcx.expr_ty(source);\n                     constrain_regions_in_type(rcx, trait_region,\n                                               expr.span, source_ty);"}, {"sha": "bd78e9cc5fb46cbb98dc187580dc3a172f0f53e8", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -139,10 +139,11 @@ fn fixup_substs(vcx: &VtableContext, location_info: &LocationInfo,\n     let t = ty::mk_trait(tcx,\n                          id, substs,\n                          ty::RegionTraitStore(ty::re_static),\n-                         ast::m_imm);\n+                         ast::m_imm,\n+                         ty::EmptyBuiltinBounds());\n     do fixup_ty(vcx, location_info, t, is_early).map |t_f| {\n         match ty::get(*t_f).sty {\n-          ty::ty_trait(_, ref substs_f, _, _) => (/*bad*/copy *substs_f),\n+          ty::ty_trait(_, ref substs_f, _, _, _) => (/*bad*/copy *substs_f),\n           _ => fail!(\"t_f should be a trait\")\n         }\n     }\n@@ -530,7 +531,9 @@ pub fn early_resolve_expr(ex: @ast::expr,\n           debug!(\"vtable resolution on expr %s\", ex.repr(fcx.tcx()));\n           let target_ty = fcx.expr_ty(ex);\n           match ty::get(target_ty).sty {\n-              ty::ty_trait(target_def_id, ref target_substs, store, target_mutbl) => {\n+              // Bounds of type's contents are not checked here, but in kind.rs.\n+              ty::ty_trait(target_def_id, ref target_substs, store,\n+                           target_mutbl, _bounds) => {\n                   fn mutability_allowed(a_mutbl: ast::mutability,\n                                         b_mutbl: ast::mutability) -> bool {\n                       a_mutbl == b_mutbl ||"}, {"sha": "7ad27077cd8673f2e8ecd632360561a772a14358", "filename": "src/librustc/middle/typeck/coherence.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcoherence.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -114,7 +114,7 @@ pub fn type_is_defined_in_local_crate(original_type: t) -> bool {\n     do ty::walk_ty(original_type) |t| {\n         match get(t).sty {\n             ty_enum(def_id, _) |\n-            ty_trait(def_id, _, _, _) |\n+            ty_trait(def_id, _, _, _, _) |\n             ty_struct(def_id, _) => {\n                 if def_id.crate == ast::local_crate {\n                     found_nominal = true;\n@@ -140,7 +140,7 @@ pub fn get_base_type_def_id(inference_context: @mut InferCtxt,\n             match get(base_type).sty {\n                 ty_enum(def_id, _) |\n                 ty_struct(def_id, _) |\n-                ty_trait(def_id, _, _, _) => {\n+                ty_trait(def_id, _, _, _, _) => {\n                     return Some(def_id);\n                 }\n                 _ => {\n@@ -753,7 +753,7 @@ impl CoherenceChecker {\n     pub fn ast_type_is_defined_in_local_crate(&self, original_type: @ast::Ty)\n                                               -> bool {\n         match original_type.node {\n-            ty_path(_, path_id) => {\n+            ty_path(_, _, path_id) => {\n                 match self.crate_context.tcx.def_map.get_copy(&path_id) {\n                     def_ty(def_id) | def_struct(def_id) => {\n                         if def_id.crate != local_crate {"}, {"sha": "884f72b57f081cc4b08491719df634bf939d87b9", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -508,13 +508,15 @@ pub fn super_tys<C:Combine>(\n           }\n       }\n \n-      (&ty::ty_trait(a_id, ref a_substs, a_store, a_mutbl),\n-       &ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl))\n+      (&ty::ty_trait(a_id, ref a_substs, a_store, a_mutbl, a_bounds),\n+       &ty::ty_trait(b_id, ref b_substs, b_store, b_mutbl, b_bounds))\n       if a_id == b_id && a_mutbl == b_mutbl => {\n           let trait_def = ty::lookup_trait_def(tcx, a_id);\n           do this.substs(&trait_def.generics, a_substs, b_substs).chain |substs| {\n               do this.trait_stores(ty::terr_trait, a_store, b_store).chain |s| {\n-                  Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s, a_mutbl))\n+                  do this.bounds(a_bounds, b_bounds).chain |bounds| {\n+                    Ok(ty::mk_trait(tcx, a_id, /*bad*/copy substs, s, a_mutbl, bounds))\n+                  }\n               }\n           }\n       }"}, {"sha": "1bfe452f25e09a54448abb6a6ed8ed228a2d66a1", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -717,10 +717,11 @@ impl InferCtxt {\n                                   trait_ref.def_id,\n                                   copy trait_ref.substs,\n                                   ty::UniqTraitStore,\n-                                  ast::m_imm);\n+                                  ast::m_imm,\n+                                  ty::EmptyBuiltinBounds());\n         let dummy1 = self.resolve_type_vars_if_possible(dummy0);\n         match ty::get(dummy1).sty {\n-            ty::ty_trait(ref def_id, ref substs, _, _) => {\n+            ty::ty_trait(ref def_id, ref substs, _, _, _) => {\n                 ty::TraitRef {def_id: *def_id,\n                               substs: copy *substs}\n             }"}, {"sha": "2a0b97d4cb1b34c479e238cb6327301aeb074f15", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -365,6 +365,8 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n \n         s.push_str(\"fn\");\n \n+        s.push_str(cty.bounds.repr(cx));\n+\n         push_sig_to_str(cx, &mut s, &cty.sig);\n \n         return s;\n@@ -451,11 +453,13 @@ pub fn ty_to_str(cx: ctxt, typ: t) -> ~str {\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n         parameterized(cx, base, substs.self_r, substs.tps)\n       }\n-      ty_trait(did, ref substs, s, mutbl) => {\n+      ty_trait(did, ref substs, s, mutbl, ref bounds) => {\n         let path = ty::item_path(cx, did);\n         let base = ast_map::path_to_str(path, cx.sess.intr());\n         let ty = parameterized(cx, base, substs.self_r, substs.tps);\n-        fmt!(\"%s%s%s\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty)\n+        let bound_str = bounds.repr(cx);\n+        fmt!(\"%s%s%s%s\", trait_store_to_str(cx, s), mutability_to_str(mutbl), ty,\n+                         bound_str)\n       }\n       ty_evec(ref mt, vs) => {\n         vstore_ty_to_str(cx, mt, vs)"}, {"sha": "2e3d557daa90f21a00e8be83040281e072840723", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -797,7 +797,7 @@ pub enum ty_ {\n     ty_closure(@TyClosure),\n     ty_bare_fn(@TyBareFn),\n     ty_tup(~[@Ty]),\n-    ty_path(@Path, node_id),\n+    ty_path(@Path, @OptVec<TyParamBound>, node_id),\n     ty_mac(mac),\n     // ty_infer means the type should be inferred instead of it having been\n     // specified. This should only appear at the \"top level\" of a type and not"}, {"sha": "24cf5662a36b1c372bbce9c58a4b2df4d6c36349", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -473,7 +473,7 @@ pub fn id_visitor<T: Copy>(vfn: @fn(node_id, T)) -> visit::vt<T> {\n \n         visit_ty: |ty, (t, vt)| {\n             match ty.node {\n-              ty_path(_, id) => vfn(id, copy t),\n+              ty_path(_, _, id) => vfn(id, copy t),\n               _ => { /* fall through */ }\n             }\n             visit::visit_ty(ty, (t, vt));"}, {"sha": "b63997944774526ca97c11fcfeb2637f248394cd", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -48,7 +48,7 @@ pub trait AstBuilder {\n     fn ty_mt(&self, ty: @ast::Ty, mutbl: ast::mutability) -> ast::mt;\n \n     fn ty(&self, span: span, ty: ast::ty_) -> @ast::Ty;\n-    fn ty_path(&self, @ast::Path) -> @ast::Ty;\n+    fn ty_path(&self, @ast::Path, @OptVec<ast::TyParamBound>) -> @ast::Ty;\n     fn ty_ident(&self, span: span, idents: ast::ident) -> @ast::Ty;\n \n     fn ty_rptr(&self, span: span,\n@@ -267,14 +267,17 @@ impl AstBuilder for @ExtCtxt {\n         }\n     }\n \n-    fn ty_path(&self, path: @ast::Path) -> @ast::Ty {\n+    fn ty_path(&self, path: @ast::Path, bounds: @OptVec<ast::TyParamBound>)\n+              -> @ast::Ty {\n         self.ty(path.span,\n-                ast::ty_path(path, self.next_id()))\n+                ast::ty_path(path, bounds, self.next_id()))\n     }\n \n+    // Might need to take bounds as an argument in the future, if you ever want\n+    // to generate a bounded existential trait type.\n     fn ty_ident(&self, span: span, ident: ast::ident)\n         -> @ast::Ty {\n-        self.ty_path(self.path_ident(span, ident))\n+        self.ty_path(self.path_ident(span, ident), @opt_vec::Empty)\n     }\n \n     fn ty_rptr(&self,\n@@ -304,7 +307,8 @@ impl AstBuilder for @ExtCtxt {\n                               self.ident_of(\"Option\")\n                           ],\n                           None,\n-                          ~[ ty ]))\n+                          ~[ ty ]),\n+            @opt_vec::Empty)\n     }\n \n     fn ty_field_imm(&self, span: span, name: ident, ty: @ast::Ty) -> ast::ty_field {\n@@ -342,7 +346,7 @@ impl AstBuilder for @ExtCtxt {\n     fn ty_vars_global(&self, ty_params: &OptVec<ast::TyParam>) -> ~[@ast::Ty] {\n         opt_vec::take_vec(\n             ty_params.map(|p| self.ty_path(\n-                self.path_global(dummy_sp(), ~[p.ident]))))\n+                self.path_global(dummy_sp(), ~[p.ident]), @opt_vec::Empty)))\n     }\n \n     fn strip_bounds(&self, generics: &Generics) -> Generics {"}, {"sha": "981b28afd022755ad61794203674635563cad274", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -358,7 +358,8 @@ impl<'self> TraitDef<'self> {\n \n         // Create the type of `self`.\n         let self_type = cx.ty_path(cx.path_all(span, false, ~[ type_ident ], self_lifetime,\n-                                               opt_vec::take_vec(self_ty_params)));\n+                                               opt_vec::take_vec(self_ty_params)),\n+                                   @opt_vec::Empty);\n \n         let doc_attr = cx.attribute(\n             span,"}, {"sha": "d28613f52faf795f6280e419df3b8a63e53c0e3b", "filename": "src/libsyntax/ext/deriving/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fty.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -65,7 +65,7 @@ impl<'self> Path<'self> {\n                  self_generics: &Generics)\n                  -> @ast::Ty {\n         cx.ty_path(self.to_path(cx, span,\n-                                self_ty, self_generics))\n+                                self_ty, self_generics), @opt_vec::Empty)\n     }\n     pub fn to_path(&self,\n                    cx: @ExtCtxt,\n@@ -144,7 +144,8 @@ impl<'self> Ty<'self> {\n             }\n             Literal(ref p) => { p.to_ty(cx, span, self_ty, self_generics) }\n             Self  => {\n-                cx.ty_path(self.to_path(cx, span, self_ty, self_generics))\n+                cx.ty_path(self.to_path(cx, span, self_ty, self_generics),\n+                           @opt_vec::Empty)\n             }\n             Tuple(ref fields) => {\n                 let ty = if fields.is_empty() {"}, {"sha": "a20528082ab55dd59769cc1d8fc456534784838c", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -61,7 +61,7 @@ impl gen_send for message {\n \n             let pipe_ty = cx.ty_path(\n                 path(~[this.data_name()], span)\n-                .add_tys(cx.ty_vars(&this.generics.ty_params)));\n+                .add_tys(cx.ty_vars(&this.generics.ty_params)), @opt_vec::Empty);\n             let args_ast = vec::append(\n                 ~[cx.arg(span, cx.ident_of(\"pipe\"), pipe_ty)],\n                 args_ast);\n@@ -117,7 +117,7 @@ impl gen_send for message {\n \n             let mut rty = cx.ty_path(path(~[next.data_name()],\n                                           span)\n-                                     .add_tys(copy next_state.tys));\n+                                     .add_tys(copy next_state.tys), @opt_vec::Empty);\n             if try {\n                 rty = cx.ty_option(rty);\n             }\n@@ -146,7 +146,7 @@ impl gen_send for message {\n                              cx.ty_path(\n                                  path(~[this.data_name()], span)\n                                  .add_tys(cx.ty_vars(\n-                                     &this.generics.ty_params))))],\n+                                     &this.generics.ty_params)), @opt_vec::Empty))],\n                     args_ast);\n \n                 let message_args = if arg_names.len() == 0 {\n@@ -192,7 +192,7 @@ impl gen_send for message {\n \n     fn to_ty(&mut self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path(path(~[cx.ident_of(self.name())], self.span())\n-          .add_tys(cx.ty_vars(&self.get_generics().ty_params)))\n+          .add_tys(cx.ty_vars(&self.get_generics().ty_params)), @opt_vec::Empty)\n     }\n }\n \n@@ -226,7 +226,7 @@ impl to_type_decls for state {\n                                 cx.ty_path(\n                                     path(~[cx.ident_of(dir),\n                                            cx.ident_of(next_name)], span)\n-                                    .add_tys(copy next_state.tys)))\n+                                    .add_tys(copy next_state.tys), @opt_vec::Empty))\n               }\n               None => tys\n             };\n@@ -279,7 +279,8 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                  dummy_sp())\n                             .add_tys(cx.ty_vars(\n-                                &self.generics.ty_params))))),\n+                                &self.generics.ty_params)), @opt_vec::Empty)),\n+                        @opt_vec::Empty),\n                     cx.strip_bounds(&self.generics)));\n         }\n         else {\n@@ -298,8 +299,8 @@ impl to_type_decls for state {\n                                    self.data_name()],\n                                         dummy_sp())\n                             .add_tys(cx.ty_vars_global(\n-                                &self.generics.ty_params))),\n-                                   self.proto.buffer_ty_path(cx)])),\n+                                &self.generics.ty_params)), @opt_vec::Empty),\n+                                   self.proto.buffer_ty_path(cx)]), @opt_vec::Empty),\n                     cx.strip_bounds(&self.generics)));\n         };\n         items\n@@ -384,7 +385,7 @@ impl gen_init for protocol {\n         cx.ty_path(path(~[cx.ident_of(\"super\"),\n                           cx.ident_of(\"__Buffer\")],\n                         copy self.span)\n-                   .add_tys(cx.ty_vars_global(&params)))\n+                   .add_tys(cx.ty_vars_global(&params)), @opt_vec::Empty)\n     }\n \n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {"}, {"sha": "87aaf7781fae554de9ee5d6f066d0b25eff3b83f", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -15,6 +15,7 @@ use codemap::span;\n use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use ext::pipes::ast_builder::{append_types, path};\n+use opt_vec;\n \n #[deriving(Eq)]\n pub enum direction { send, recv }\n@@ -101,7 +102,7 @@ impl state_ {\n     pub fn to_ty(&self, cx: @ExtCtxt) -> @ast::Ty {\n         cx.ty_path\n             (path(~[cx.ident_of(self.name)],self.span).add_tys(\n-                cx.ty_vars(&self.generics.ty_params)))\n+                cx.ty_vars(&self.generics.ty_params)), @opt_vec::Empty)\n     }\n \n     /// Iterate over the states that can be reached in one message"}, {"sha": "4bd2c0a3de1ffcd02ff815adb115f96e5ed33d79", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -680,7 +680,9 @@ pub fn noop_fold_ty(t: &ty_, fld: @ast_fold) -> ty_ {\n             })\n         }\n         ty_tup(ref tys) => ty_tup(tys.map(|ty| fld.fold_ty(*ty))),\n-        ty_path(path, id) => ty_path(fld.fold_path(path), fld.new_id(id)),\n+        ty_path(path, bounds, id) =>\n+            ty_path(fld.fold_path(path),\n+                    @bounds.map(|x| fold_ty_param_bound(x, fld)), fld.new_id(id)),\n         ty_fixed_length_vec(ref mt, e) => {\n             ty_fixed_length_vec(\n                 fold_mt(mt, fld),"}, {"sha": "0c5731c8b29b981ad7ca8b408e41bf18b307ce3a", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -494,7 +494,7 @@ mod test {\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       2),\n+                                                       @opt_vec::Empty, 2),\n                                     span:sp(4,7)},\n                        pat: @ast::pat{id:1,\n                                       node: ast::pat_ident(ast::bind_infer,\n@@ -530,7 +530,7 @@ mod test {\n                                         idents:~[str_to_ident(\"int\")],\n                                         rp: None,\n                                         types: ~[]},\n-                                                       2),\n+                                                       @opt_vec::Empty, 2),\n                                                 span:sp(10,13)},\n                                     pat: @ast::pat{id:1, // fixme\n                                                    node: ast::pat_ident("}, {"sha": "19b4d254580811b6d7a733ec22d534ffd18aa66a", "filename": "src/libsyntax/parse/obsolete.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fparse%2Fobsolete.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fobsolete.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -46,7 +46,6 @@ pub enum ObsoleteSyntax {\n     ObsoleteUnsafeBlock,\n     ObsoleteUnenforcedBound,\n     ObsoleteImplSyntax,\n-    ObsoleteTraitBoundSeparator,\n     ObsoleteMutOwnedPointer,\n     ObsoleteMutVector,\n     ObsoleteImplVisibility,\n@@ -143,10 +142,6 @@ impl Parser {\n                 \"colon-separated impl syntax\",\n                 \"write `impl Trait for Type`\"\n             ),\n-            ObsoleteTraitBoundSeparator => (\n-                \"space-separated trait bounds\",\n-                \"write `+` between trait bounds\"\n-            ),\n             ObsoleteMutOwnedPointer => (\n                 \"const or mutable owned pointer\",\n                 \"mutability inherits through `~` pointers; place the `~` box"}, {"sha": "f2443f9e533592dde6cb07f71036d61e4a289a73", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -75,7 +75,7 @@ use parse::obsolete::{ObsoleteLet, ObsoleteFieldTerminator};\n use parse::obsolete::{ObsoleteMoveInit, ObsoleteBinaryMove, ObsoleteSwap};\n use parse::obsolete::{ObsoleteSyntax, ObsoleteLowerCaseKindBounds};\n use parse::obsolete::{ObsoleteUnsafeBlock, ObsoleteImplSyntax};\n-use parse::obsolete::{ObsoleteTraitBoundSeparator, ObsoleteMutOwnedPointer};\n+use parse::obsolete::{ObsoleteMutOwnedPointer};\n use parse::obsolete::{ObsoleteMutVector, ObsoleteImplVisibility};\n use parse::obsolete::{ObsoleteRecordType, ObsoleteRecordPattern};\n use parse::obsolete::{ObsoletePostFnTySigil};\n@@ -710,8 +710,8 @@ impl Parser {\n         } else if *self.token == token::MOD_SEP\n             || is_ident_or_path(self.token) {\n             // NAMED TYPE\n-            let path = self.parse_path_with_tps(false);\n-            ty_path(path, self.get_id())\n+            let (path, bounds) = self.parse_type_path();\n+            ty_path(path, @bounds, self.get_id())\n         } else {\n             self.fatal(fmt!(\"expected type, found token %?\",\n                             *self.token));\n@@ -974,10 +974,8 @@ impl Parser {\n                      types: ~[] }\n     }\n \n-    // parse a path optionally with type parameters. If 'colons'\n-    // is true, then type parameters must be preceded by colons,\n-    // as in a::t::<t1,t2>\n-    pub fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n+    pub fn parse_bounded_path_with_tps(&self, colons: bool,\n+                                        before_tps: Option<&fn()>) -> @ast::Path {\n         debug!(\"parse_path_with_tps(colons=%b)\", colons);\n \n         maybe_whole!(self, nt_path);\n@@ -987,6 +985,10 @@ impl Parser {\n             return path;\n         }\n \n+        // If the path might have bounds on it, they should be parsed before\n+        // the parameters, e.g. module::TraitName:B1+B2<T>\n+        before_tps.map_consume(|callback| callback());\n+\n         // Parse the (obsolete) trailing region parameter, if any, which will\n         // be written \"foo/&x\"\n         let rp_slash = {\n@@ -1038,6 +1040,25 @@ impl Parser {\n                      .. copy *path }\n     }\n \n+    // parse a path optionally with type parameters. If 'colons'\n+    // is true, then type parameters must be preceded by colons,\n+    // as in a::t::<t1,t2>\n+    pub fn parse_path_with_tps(&self, colons: bool) -> @ast::Path {\n+        self.parse_bounded_path_with_tps(colons, None)\n+    }\n+\n+    // Like the above, but can also parse kind bounds in the case of a\n+    // path to be used as a type that might be a trait.\n+    pub fn parse_type_path(&self) -> (@ast::Path, OptVec<TyParamBound>) {\n+        let mut bounds = opt_vec::Empty;\n+        let path = self.parse_bounded_path_with_tps(false, Some(|| {\n+            // Note: this closure might not even get called in the case of a\n+            // macro-generated path. But that's the macro parser's job.\n+            bounds = self.parse_optional_ty_param_bounds();\n+        }));\n+        (path, bounds)\n+    }\n+\n     /// parses 0 or 1 lifetime\n     pub fn parse_opt_lifetime(&self) -> Option<@ast::Lifetime> {\n         match *self.token {\n@@ -2847,16 +2868,6 @@ impl Parser {\n         spanned(lo, hi, bloc)\n     }\n \n-    fn mk_ty_path(&self, i: ident) -> @Ty {\n-        @Ty {\n-            id: self.get_id(),\n-            node: ty_path(\n-                ident_to_path(*self.last_span, i),\n-                self.get_id()),\n-            span: *self.last_span,\n-        }\n-    }\n-\n     fn parse_optional_purity(&self) -> ast::purity {\n         if self.eat_keyword(keywords::Pure) {\n             self.obsolete(*self.last_span, ObsoletePurity);\n@@ -2921,13 +2932,8 @@ impl Parser {\n                 _ => break,\n             }\n \n-            if self.eat(&token::BINOP(token::PLUS)) {\n-                loop;\n-            }\n-\n-            if is_ident_or_path(self.token) {\n-                self.obsolete(*self.span,\n-                              ObsoleteTraitBoundSeparator);\n+            if !self.eat(&token::BINOP(token::PLUS)) {\n+                break;\n             }\n         }\n \n@@ -3284,14 +3290,19 @@ impl Parser {\n         let opt_trait = if could_be_trait && self.eat_keyword(keywords::For) {\n             // New-style trait. Reinterpret the type as a trait.\n             let opt_trait_ref = match ty.node {\n-                ty_path(path, node_id) => {\n+                ty_path(path, @opt_vec::Empty, node_id) => {\n                     Some(@trait_ref {\n                         path: path,\n                         ref_id: node_id\n                     })\n                 }\n+                ty_path(*) => {\n+                    self.span_err(ty.span,\n+                                  \"bounded traits are only valid in type position\");\n+                    None\n+                }\n                 _ => {\n-                    self.span_err(*self.span, \"not a trait\");\n+                    self.span_err(ty.span, \"not a trait\");\n                     None\n                 }\n             };"}, {"sha": "fa22b7ceb71006026c526734669f550583c2271d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -422,7 +422,7 @@ pub fn print_type(s: @ps, ty: @ast::Ty) {\n                       f.purity, f.onceness, &f.decl, None,\n                       Some(&generics), None);\n       }\n-      ast::ty_path(path, _) => print_path(s, path, false),\n+      ast::ty_path(path, bounds, _) => print_bounded_path(s, path, bounds),\n       ast::ty_fixed_length_vec(ref mt, v) => {\n         word(s.s, \"[\");\n         match mt.mutbl {\n@@ -1483,14 +1483,18 @@ pub fn print_for_decl(s: @ps, loc: @ast::local, coll: @ast::expr) {\n     print_expr(s, coll);\n }\n \n-pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n+fn print_path_(s: @ps, path: @ast::Path, colons_before_params: bool,\n+               opt_bounds: Option<@OptVec<ast::TyParamBound>>) {\n     maybe_print_comment(s, path.span.lo);\n     if path.global { word(s.s, \"::\"); }\n     let mut first = true;\n     for path.idents.iter().advance |id| {\n         if first { first = false; } else { word(s.s, \"::\"); }\n         print_ident(s, *id);\n     }\n+    do opt_bounds.map_consume |bounds| {\n+        print_bounds(s, bounds);\n+    };\n     if path.rp.is_some() || !path.types.is_empty() {\n         if colons_before_params { word(s.s, \"::\"); }\n \n@@ -1511,6 +1515,15 @@ pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n     }\n }\n \n+pub fn print_path(s: @ps, path: @ast::Path, colons_before_params: bool) {\n+    print_path_(s, path, colons_before_params, None)\n+}\n+\n+pub fn print_bounded_path(s: @ps, path: @ast::Path,\n+                          bounds: @OptVec<ast::TyParamBound>) {\n+    print_path_(s, path, false, Some(bounds))\n+}\n+\n pub fn print_irrefutable_pat(s: @ps, pat: @ast::pat) {\n     print_pat(s, pat, false)\n }"}, {"sha": "5aa38c0348c003e0782ad92c0998629d08150d85", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce857e3d60da1b5eff5d830dbd03f32a8890ad16/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ce857e3d60da1b5eff5d830dbd03f32a8890ad16", "patch": "@@ -247,13 +247,17 @@ pub fn visit_ty<E: Copy>(t: @Ty, (e, v): (E, vt<E>)) {\n         },\n         ty_closure(ref f) => {\n             for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n-            (v.visit_ty)(f.decl.output, (e, v));\n+            (v.visit_ty)(f.decl.output, (copy e, v));\n+            visit_ty_param_bounds(&f.bounds, (e, v));\n         },\n         ty_bare_fn(ref f) => {\n             for f.decl.inputs.iter().advance |a| { (v.visit_ty)(a.ty, (copy e, v)); }\n             (v.visit_ty)(f.decl.output, (e, v));\n         },\n-        ty_path(p, _) => visit_path(p, (e, v)),\n+        ty_path(p, bounds, _) => {\n+            visit_path(p, (copy e, v));\n+            visit_ty_param_bounds(bounds, (e, v));\n+        },\n         ty_fixed_length_vec(ref mt, ex) => {\n             (v.visit_ty)(mt.ty, (copy e, v));\n             (v.visit_expr)(ex, (copy e, v));\n@@ -328,7 +332,7 @@ pub fn visit_foreign_item<E: Copy>(ni: @foreign_item, (e, v): (E, vt<E>)) {\n     }\n }\n \n-pub fn visit_ty_param_bounds<E: Copy>(bounds: @OptVec<TyParamBound>,\n+pub fn visit_ty_param_bounds<E: Copy>(bounds: &OptVec<TyParamBound>,\n                                       (e, v): (E, vt<E>)) {\n     for bounds.each |bound| {\n         match *bound {"}]}