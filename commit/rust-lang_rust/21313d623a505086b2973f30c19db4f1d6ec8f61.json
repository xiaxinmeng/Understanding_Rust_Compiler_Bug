{"sha": "21313d623a505086b2973f30c19db4f1d6ec8f61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxMzEzZDYyM2E1MDUwODZiMjk3M2YzMGMxOWRiNGYxZDZlYzhmNjE=", "commit": {"author": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-29T02:16:18Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2011-05-31T18:00:47Z"}, "message": "new pretty printer", "tree": {"sha": "0e28736bd38ee3b9d2a3cf9f338525560490733d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0e28736bd38ee3b9d2a3cf9f338525560490733d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21313d623a505086b2973f30c19db4f1d6ec8f61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21313d623a505086b2973f30c19db4f1d6ec8f61", "html_url": "https://github.com/rust-lang/rust/commit/21313d623a505086b2973f30c19db4f1d6ec8f61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21313d623a505086b2973f30c19db4f1d6ec8f61/comments", "author": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "697be84d61508872a2cfcb8699e1ee8d00932ff0", "url": "https://api.github.com/repos/rust-lang/rust/commits/697be84d61508872a2cfcb8699e1ee8d00932ff0", "html_url": "https://github.com/rust-lang/rust/commit/697be84d61508872a2cfcb8699e1ee8d00932ff0"}], "stats": {"total": 1141, "additions": 736, "deletions": 405}, "files": [{"sha": "88d50e340835b616e306f677f31abd37ba0139e5", "filename": "src/comp/pretty/pp.rs", "status": "modified", "additions": 502, "deletions": 228, "changes": 730, "blob_url": "https://github.com/rust-lang/rust/blob/21313d623a505086b2973f30c19db4f1d6ec8f61/src%2Fcomp%2Fpretty%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21313d623a505086b2973f30c19db4f1d6ec8f61/src%2Fcomp%2Fpretty%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpp.rs?ref=21313d623a505086b2973f30c19db4f1d6ec8f61", "patch": "@@ -2,267 +2,541 @@ import std::io;\n import std::vec;\n import std::str;\n \n-tag boxtype {box_h; box_v; box_hv; box_align;}\n-tag contexttype {cx_h; cx_v;}\n-tag scantype {scan_hv; scan_h; scan_none;}\n+/*\n+ * This pretty-printer is a direct reimplementation of Philip Karlton's\n+ * Mesa pretty-printer, as described in appendix A of\n+ *\n+ *     STAN-CS-79-770: \"Pretty Printing\", by Derek C. Oppen.\n+ *     Stanford Department of Computer Science, 1979.\n+ *\n+ * The algorithm's aim is to break a stream into as few lines as possible\n+ * while respecting the indentation-consistency requirements of the enclosing\n+ * block, and avoiding breaking at silly places on block boundaries, for\n+ * example, between \"x\" and \")\" in \"x)\".\n+ *\n+ * I am implementing this algorithm because it comes with 20 pages of\n+ * documentation explaining its theory, and because it addresses the set of\n+ * concerns I've seen other pretty-printers fall down on. Weirdly. Even though\n+ * it's 32 years old and not written in Haskell. What can I say?\n+ *\n+ * Despite some redundancies and quirks in the way it's implemented in that\n+ * paper, I've opted to keep the implementation here as similar as I can,\n+ * changing only what was blatantly wrong, a typo, or sufficiently\n+ * non-idiomatic rust that it really stuck out.\n+ *\n+ * In particular you'll see a certain amount of churn related to INTEGER vs.\n+ * CARDINAL in the Mesa implementation. Mesa apparently interconverts the two\n+ * somewhat readily? In any case, I've used uint for indices-in-buffers and\n+ * ints for character-sizes-and-indentation-offsets. This respects the need\n+ * for ints to \"go negative\" while carrying a pending-calculation balance, and\n+ * helps differentiate all the numbers flying around internally (slightly).\n+ *\n+ * I also inverted the indentation arithmetic used in the print stack, since\n+ * the Mesa implementation (somewhat randomly) stores the offset on the print\n+ * stack in terms of margin-col rather than col itself. I store col.\n+ */\n+\n+tag breaks { consistent; inconsistent; }\n+type break_t = rec(int offset, int blank_space);\n+type begin_t = rec(int offset, breaks breaks);\n \n tag token {\n-  brk(uint);\n-  hardbrk;\n-  word(str);\n-  cword(str); // closing token\n-  open(boxtype, uint);\n-  close;\n+    STRING(str);\n+    BREAK(break_t);\n+    BEGIN(begin_t);\n+    END;\n+    EOF;\n }\n \n-type context = rec(contexttype tp, uint indent);\n-\n-type ps = @rec(mutable vec[context] context,\n-               uint width,\n-               io::writer out,\n-               mutable uint col,\n-               mutable uint spaces,\n-               mutable vec[token] buffered,\n-               mutable scantype scanning,\n-               mutable vec[boxtype] scandepth,\n-               mutable uint scancol,\n-               mutable bool start_of_line,\n-               mutable bool start_of_box,\n-               mutable bool potential_brk);\n-\n-fn mkstate(io::writer out, uint width) -> ps {\n-  let vec[context] stack = [rec(tp=cx_v, indent=0u)];\n-  let vec[token] buff = [];\n-  let vec[boxtype] sd = [];\n-  ret @rec(mutable context=stack,\n-           width=width,\n-           out=out,\n-           mutable col=0u,\n-           mutable spaces=0u,\n-           mutable buffered=buff,\n-           mutable scanning=scan_none,\n-           mutable scandepth=sd,\n-           mutable scancol=0u,\n-           mutable start_of_line=true,\n-           mutable start_of_box=true,\n-           mutable potential_brk=false);\n-}\n \n-fn write_spaces(ps p, uint i) {\n-  while (i > 0u) {\n-    i -= 1u;\n-    p.out.write_str(\" \");\n-  }\n+fn tok_str(token t) -> str {\n+    alt (t) {\n+        case (STRING(?s)) { ret \"STR(\" + s + \")\"; }\n+        case (BREAK(_)) { ret \"BREAK\"; }\n+        case (BEGIN(_)) { ret \"BEGIN\"; }\n+        case (END) { ret \"END\"; }\n+        case (EOF) { ret \"EOF\"; }\n+    }\n }\n \n-fn push_context(ps p, contexttype tp, uint indent) {\n-  before_print(p, false);\n-  vec::push[context](p.context, rec(tp=tp, indent=indent));\n-  p.start_of_box = true;\n+fn buf_str(vec[token] toks, vec[int] szs,\n+           uint left, uint right, uint lim) -> str {\n+    auto n = vec::len(toks);\n+    assert n == vec::len(szs);\n+    auto i = left;\n+    auto L = lim;\n+    auto s = \"[\";\n+    while (i != right && L != 0u) {\n+        L -= 1u;\n+        if (i != left) {\n+            s += \", \";\n+        }\n+        s += #fmt(\"%d=%s\", szs.(i), tok_str(toks.(i)));\n+        i += 1u;\n+        i %= n;\n+    }\n+    s += \"]\";\n+    ret s;\n }\n \n-fn pop_context(ps p) {\n-  vec::pop[context](p.context);\n-}\n \n-fn add_token(ps p, token tok) {\n-  if (p.width == 0u) {direct_token(p, tok);}\n-  else if (p.scanning == scan_none) {do_token(p, tok);}\n-  else {buffer_token(p, tok);}\n-}\n+tag print_stack_break { fits; broken(breaks); }\n+type print_stack_elt = rec(int offset, print_stack_break pbreak);\n \n-fn direct_token(ps p, token tok) {\n-  alt (tok) {\n-    case (brk(?sz)) {write_spaces(p, sz);}\n-    case (word(?w)) {p.out.write_str(w);}\n-    case (cword(?w)) {p.out.write_str(w);}\n-    case (_) {}\n-  }\n-}\n+const int size_infinity = 0xffff;\n \n-fn buffer_token(ps p, token tok) {\n-  p.buffered += [tok];\n-  auto col = p.scancol;\n-  p.scancol = col + token_size(tok);\n-  if (p.scancol > p.width) {\n-    finish_scan(p, false);\n-  } else {\n-    alt (tok) {\n-      case (open(?tp,_)) {\n-        vec::push[boxtype](p.scandepth, tp);\n-        if (p.scanning == scan_h) {\n-          if (tp == box_h) {\n-            check_potential_brk(p);\n-          }\n-        }\n-      }\n-      case (close) {\n-        vec::pop[boxtype](p.scandepth);\n-        if (vec::len[boxtype](p.scandepth) == 0u) {\n-          finish_scan(p, true);\n-        }\n-      }\n-      case (brk(_)) {\n-        if (p.scanning == scan_h) {\n-          if (p.scandepth.(vec::len[boxtype](p.scandepth)-1u) == box_v) {\n-            finish_scan(p, true);\n-          }\n-        }\n-      }\n-      case (_) {}\n-    }\n-  }\n-}\n+fn mk_printer(io::writer out, uint linewidth) -> printer {\n \n-fn check_potential_brk(ps p) {\n-  for (boxtype tp in p.scandepth) {\n-    if (tp != box_h) {ret;}\n-  }\n-  p.potential_brk = true;\n+    // Yes 3, it makes the ring buffers big enough to never\n+    // fall behind.\n+    let uint n = 3u * linewidth;\n+\n+    log #fmt(\"mk_printer %u\", linewidth);\n+\n+    let vec[token] token = vec::init_elt[token](EOF, n);\n+    let vec[int] size = vec::init_elt[int](0, n);\n+    let vec[uint] scan_stack = vec::init_elt[uint](0u, n);\n+    let vec[print_stack_elt] print_stack = [];\n+\n+    ret printer(out,\n+                n,\n+                linewidth as int, // margin\n+                linewidth as int, // space\n+                0u,               // left\n+                0u,               // right\n+                token,\n+                size,\n+                0,                // left_total\n+                0,                // right_total\n+                scan_stack,\n+                true,             // scan_stack_empty\n+                0u,               // top\n+                0u,               // bottom\n+                print_stack);\n }\n \n-fn finish_scan(ps p, bool fits) {\n-  auto buf = p.buffered;\n-  auto front = vec::shift[token](buf);\n-  auto chosen_tp = cx_h;\n-  if (!fits) {chosen_tp = cx_v;}\n-  alt (front) {\n-    case (open(box_hv, ?ind)) {\n-      push_context(p, chosen_tp, base_indent(p) + ind);\n+/*\n+ * In case you do not have the paper, here is an explanation of what's going\n+ * on.\n+ *\n+ * There is a stream of input tokens flowing through this printer.\n+ *\n+ * The printer buffers up to 3N tokens inside itself, where N is linewidth.\n+ * Yes, linewidth is chars and tokens are multi-char, but in the worst\n+ * case every token worth buffering is 1 char long, so it's ok.\n+ *\n+ * Tokens are STRING, BREAK, and BEGIN/END to delimit blocks.\n+ *\n+ * BEGIN tokens can carry an offset, saying \"how far to indent when you break\n+ * inside here\", as well as a flag indicating \"consistent\" or \"inconsistent\"\n+ * breaking. Consistent breaking means that after the first break, no attempt\n+ * will be made to flow subsequent breaks together onto lines. Inconsistent\n+ * is the opposite. Inconsistent breaking example would be, say:\n+ *\n+ *  foo(hello, there, good, friends)\n+ *\n+ * breaking inconsistently to become\n+ *\n+ *  foo(hello, there\n+ *      good, friends);\n+ *\n+ * whereas a consistent breaking would yield:\n+ *\n+ *  foo(hello,\n+ *      there\n+ *      good,\n+ *      friends);\n+ *\n+ * That is, in the consistent-break blocks we value vertical alignment\n+ * more than the ability to cram stuff onto a line. But in all cases if it\n+ * can make a block a one-liner, it'll do so.\n+ *\n+ * Carrying on with high-level logic:\n+ *\n+ * The buffered tokens go through a ring-buffer, 'tokens'. The 'left' and\n+ * 'right' indices denote the active portion of the ring buffer as well as\n+ * describing hypothetical points-in-the-infinite-stream at most 3N tokens\n+ * apart (i.e. \"not wrapped to ring-buffer boundaries\"). The paper will switch\n+ * between using 'left' and 'right' terms to denote the wrapepd-to-ring-buffer\n+ * and point-in-infinite-stream senses freely.\n+ *\n+ * There is a parallel ring buffer, 'size', that holds the calculated size of\n+ * each token. Why calculated? Because for BEGIN/END pairs, the \"size\"\n+ * includes everything betwen the pair. That is, the \"size\" of BEGIN is\n+ * actually the sum of the sizes of everything between BEGIN and the paired\n+ * END that follows. Since that is arbitrarily far in the future, 'size' is\n+ * being rewritten regularly while the printer runs; in fact most of the\n+ * machinery is here to work out 'size' entries on the fly (and give up when\n+ * they're so obviously over-long that \"infinity\" is a good enough\n+ * approximation for purposes of line breaking).\n+ *\n+ * The \"input side\" of the printer is managed as an abstract process called\n+ * SCAN, which uses 'scan_stack', 'scan_stack_empty', 'top' and 'bottom', to\n+ * manage calculating 'size'. SCAN is, in other words, the process of\n+ * calculating 'size' entries.\n+ *\n+ * The \"output side\" of the printer is managed by an abstract process called\n+ * PRINT, which uses 'print_stack', 'margin' and 'space' to figure out what to\n+ * do with each token/size pair it consumes as it goes. It's trying to consume\n+ * the entire buffered window, but can't output anything until the size is >=\n+ * 0 (sizes are set to negative while they're pending calculation).\n+ *\n+ * So SCAN takeks input and buffers tokens and pending calculations, while\n+ * PRINT gobbles up completed calculations and tokens from the buffer. The\n+ * theory is that the two can never get more than 3N tokens apart, because\n+ * once there's \"obviously\" too much data to fit on a line, in a size\n+ * calculation, SCAN will write \"infinity\" to the size and let PRINT consume\n+ * it.\n+ *\n+ * In this implementation (following the paper, again) the SCAN process is\n+ * the method called 'pretty_print', and the 'PRINT' process is the method\n+ * called 'print'.\n+ */\n+\n+obj printer(io::writer out,\n+            uint buf_len,\n+            mutable int margin,        // width of lines we're constrained to\n+            mutable int space,         // number of spaces left on line\n+\n+            mutable uint left,         // index of left side of input stream\n+            mutable uint right,        // index of right side of input stream\n+            mutable vec[token] token,  // ring-buffer stream goes through\n+            mutable vec[int] size,     // ring-buffer of calculated sizes\n+            mutable int left_total,    // running size of stream \"...left\"\n+            mutable int right_total,   // running size of stream \"...right\"\n+\n+            // pseudo-stack, really a ring too. Holds the primary-ring-buffers\n+            // index of the BEGIN that started the current block, possibly\n+            // with the most recent BREAK after that BEGIN (if there is any)\n+            // on top of it. Stuff is flushed off the bottom as it becomes\n+            // irrelevant due to the primary ring-buffer advancing.\n+\n+            mutable vec[uint] scan_stack,\n+            mutable bool scan_stack_empty, // top==bottom disambiguator\n+            mutable uint top,              // index of top of scan_stack\n+            mutable uint bottom,           // index of bottom of scan_stack\n+\n+            // stack of blocks-in-progress being flushed by print\n+            mutable vec[print_stack_elt] print_stack\n+            ) {\n+\n+\n+    fn pretty_print(token t) {\n+\n+        log #fmt(\"pp [%u,%u]\", left, right);\n+        alt (t) {\n+\n+            case (EOF) {\n+                if (!scan_stack_empty) {\n+                    self.check_stack(0);\n+                    self.advance_left(token.(left), size.(left));\n+                }\n+                self.indent(0);\n+            }\n+\n+            case (BEGIN(?b)) {\n+                if (scan_stack_empty) {\n+                    left_total = 1;\n+                    right_total = 1;\n+                    left = 0u;\n+                    right = 0u;\n+                } else {\n+                    self.advance_right();\n+                }\n+                log #fmt(\"pp BEGIN/buffer [%u,%u]\", left, right);\n+                token.(right) = t;\n+                size.(right) = -right_total;\n+                self.scan_push(right);\n+            }\n+\n+            case (END) {\n+                if (scan_stack_empty) {\n+                    log #fmt(\"pp END/print [%u,%u]\", left, right);\n+                    self.print(t, 0);\n+                } else {\n+                    log #fmt(\"pp END/buffer [%u,%u]\", left, right);\n+                    self.advance_right();\n+                    token.(right) = t;\n+                    size.(right) = -1;\n+                    self.scan_push(right);\n+                }\n+            }\n+\n+            case (BREAK(?b)) {\n+                if (scan_stack_empty) {\n+                    left_total = 1;\n+                    right_total = 1;\n+                    left = 0u;\n+                    right = 0u;\n+                } else {\n+                    self.advance_right();\n+                }\n+                log #fmt(\"pp BREAK/buffer [%u,%u]\", left, right);\n+                self.check_stack(0);\n+                self.scan_push(right);\n+                token.(right) = t;\n+                size.(right) = -right_total;\n+                right_total += b.blank_space;\n+            }\n+\n+            case (STRING(?s)) {\n+                auto len = str::char_len(s) as int;\n+                if (scan_stack_empty) {\n+                    log #fmt(\"pp STRING/print [%u,%u]\", left, right);\n+                    self.print(t, len);\n+                } else {\n+                    log #fmt(\"pp STRING/buffer [%u,%u]\", left, right);\n+                    self.advance_right();\n+                    token.(right) = t;\n+                    size.(right) = len;\n+                    right_total += len;\n+                    self.check_stream();\n+                }\n+            }\n+        }\n     }\n-    case (open(box_align, _)) {\n-      push_context(p, chosen_tp, p.col);\n+\n+    fn check_stream() {\n+        log #fmt(\"check_stream [%u, %u] with left_total=%d, right_total=%d\",\n+                     left, right, left_total, right_total);;\n+        if (right_total - left_total > space) {\n+            log #fmt(\"scan window is %d, longer than space on line (%d)\",\n+                         right_total - left_total, space);\n+            if (!scan_stack_empty) {\n+                if (left == scan_stack.(bottom)) {\n+                    log #fmt(\"setting %u to infinity and popping\", left);\n+                    size.(self.scan_pop_bottom()) = size_infinity;\n+                }\n+            }\n+            self.advance_left(token.(left), size.(left));\n+            if (left != right) {\n+                self.check_stream();\n+            }\n+        }\n     }\n-    case (open(box_h, ?ind)) {\n-      if (!fits && !p.start_of_box && !p.start_of_line && !p.potential_brk) {\n-        line_break(p);\n-      }\n-      push_context(p, cx_h, base_indent(p) + ind);\n+\n+    fn scan_push(uint x) {\n+        log #fmt(\"scan_push %u\", x);\n+        if (scan_stack_empty) {\n+            scan_stack_empty = false;\n+        } else {\n+            top += 1u;\n+            top %= buf_len;\n+            assert top != bottom;\n+        }\n+        scan_stack.(top) = x;\n     }\n-  }\n-  p.scandepth = [];\n-  p.scanning = scan_none;\n-  for (token t in buf) { add_token(p, t); }\n-}\n \n-fn start_scan(ps p, token tok, scantype tp) {\n-  p.buffered = [];\n-  p.scancol = p.col;\n-  p.scanning = tp;\n-  buffer_token(p, tok);\n-  p.potential_brk = false;\n-}\n+    fn scan_pop() -> uint {\n+        assert !scan_stack_empty;\n+        auto x = scan_stack.(top);\n+        if (top == bottom) {\n+            scan_stack_empty = true;\n+        } else {\n+            top += (buf_len - 1u);\n+            top %= buf_len;\n+        }\n+        ret x;\n+    }\n \n-fn cur_context(ps p) -> context {\n-  ret p.context.(vec::len[context](p.context)-1u);\n-}\n-fn base_indent(ps p) -> uint {\n-  auto i = vec::len[context](p.context);\n-  while (i > 0u) {\n-    i -= 1u;\n-    auto cx = p.context.(i);\n-    if (cx.tp == cx_v) {ret cx.indent;}\n-  }\n-  ret 0u;\n-}\n+    fn scan_top() -> uint {\n+        assert !scan_stack_empty;\n+        ret scan_stack.(top);\n+    }\n \n-fn cx_is(contexttype a, contexttype b) -> bool {\n-  if (a == b) {ret true;}\n-  else {ret false;}\n-}\n-fn box_is(boxtype a, boxtype b) -> bool {\n-  if (a == b) {ret true;}\n-  else {ret false;}\n-}\n+    fn scan_pop_bottom() -> uint {\n+        assert !scan_stack_empty;\n+        auto x = scan_stack.(bottom);\n+        if (top == bottom) {\n+            scan_stack_empty = true;\n+        } else {\n+            bottom += 1u;\n+            bottom %= buf_len;\n+        }\n+        ret x;\n+    }\n \n-fn do_token(ps p, token tok) {\n-  auto start_of_box = p.start_of_box;\n-  p.start_of_box = false;\n-  alt (tok) {\n-    case (brk(?sz)) {\n-      if (cx_is(cur_context(p).tp, cx_v) || sz + p.col > p.width) {\n-        line_break(p);\n-      }\n-      else {\n-        p.spaces += sz;\n-      }\n+    fn advance_right() {\n+        right += 1u;\n+        right %= buf_len;\n+        assert right != left;\n     }\n-    case (hardbrk) {\n-      line_break(p);\n+\n+    fn advance_left(token x, int L) {\n+        log #fmt(\"advnce_left [%u,%u], sizeof(%u)=%d\", left, right, left, L);\n+        if (L >= 0) {\n+            self.print(x, L);\n+            alt (x) {\n+                case (BREAK(?b)) {\n+                    left_total += b.blank_space;\n+                }\n+                case (STRING(?s)) {\n+                    // I think? paper says '1' here but 1 and L look same in\n+                    // it.\n+                    left_total += L;\n+                }\n+                case (_) {}\n+            }\n+            if (left != right) {\n+                left += 1u;\n+                left %= buf_len;\n+                self.advance_left(token.(left), size.(left));\n+            }\n+        }\n     }\n-    case (word(?w)) {\n-      auto len = str::char_len(w);\n-      if (len + p.col + p.spaces > p.width && !start_of_box &&\n-          !p.start_of_line) {\n-        line_break(p);\n-      }\n-      before_print(p, false);\n-      p.out.write_str(w);\n-      p.col += len;\n+\n+    fn check_stack(int k) {\n+        if (!scan_stack_empty) {\n+            auto x = self.scan_top();\n+            alt (token.(x)) {\n+                case (BEGIN(?b)) {\n+                    if (k > 0) {\n+                        size.(self.scan_pop()) = size.(x) + right_total;\n+                        self.check_stack(k - 1);\n+                    }\n+                }\n+                case (END) {\n+                    // paper says + not =, but that makes no sense.\n+                    size.(self.scan_pop()) = 1;\n+                    self.check_stack(k + 1);\n+                }\n+                case (_) {\n+                    size.(self.scan_pop()) = size.(x) + right_total;\n+                    if (k > 0) {\n+                        self.check_stack(k);\n+                    }\n+                }\n+            }\n+        }\n     }\n-    case (cword(?w)) {\n-      before_print(p, true);\n-      p.out.write_str(w);\n-      p.col += str::char_len(w);\n+\n+    fn print_newline(int amount) {\n+        log #fmt(\"NEWLINE %d\", amount);\n+        out.write_str(\"\\n\");\n+        self.indent(amount);\n     }\n-    case (open(?tp, ?indent)) {\n-      if (tp == box_v) {\n-        push_context(p, cx_v, base_indent(p) + indent);\n-      } else if (box_is(tp, box_h) && cx_is(cur_context(p).tp, cx_v)) {\n-        push_context(p, cx_h, base_indent(p) + indent);\n-      } else if (tp == box_h) {\n-        p.start_of_box = start_of_box;\n-        start_scan(p, tok, scan_h);\n-      } else {\n-        p.start_of_box = start_of_box;\n-        start_scan(p, tok, scan_hv);\n-      }\n+\n+    fn indent(int amount) {\n+        log #fmt(\"INDENT %d\", amount);\n+        auto u = 0;\n+        while (u < amount) {\n+            out.write_str(\" \");\n+            u += 1;\n+        }\n     }\n-    case (close) {\n-      pop_context(p);\n+\n+    fn print(token x, int L) {\n+        log #fmt(\"print %s %d (remaining line space=%d)\", tok_str(x), L, space);\n+        log buf_str(token, size, left, right, 6u);\n+        alt (x) {\n+            case (BEGIN(?b)) {\n+                if (L > space) {\n+                    auto col = (margin - space) + b.offset;\n+                    log #fmt(\"print BEGIN -> push broken block at col %d\", col);\n+                    vec::push(print_stack,\n+                              rec(offset = col,\n+                                  pbreak = broken(b.breaks)));\n+                } else {\n+                    log \"print BEGIN -> push fitting block\";\n+                    vec::push(print_stack,\n+                              rec(offset = 0,\n+                                  pbreak = fits));\n+                }\n+            }\n+\n+            case (END) {\n+                log \"print END -> pop END\";\n+                assert vec::len(print_stack) != 0u;\n+                vec::pop(print_stack);\n+            }\n+\n+            case (BREAK(?b)) {\n+\n+                auto n = vec::len(print_stack);\n+                let print_stack_elt top =\n+                    rec(offset=0, pbreak=broken(inconsistent));;\n+                if (n != 0u) {\n+                    top = print_stack.(n - 1u);\n+                }\n+\n+                alt (top.pbreak) {\n+                    case (fits) {\n+                        log \"print BREAK in fitting block\";\n+                        space -= b.blank_space;\n+                        self.indent(b.blank_space);\n+                    }\n+\n+                    case (broken(consistent)) {\n+                        log \"print BREAK in consistent block\";\n+                        self.print_newline(top.offset + b.offset);\n+                        space = margin - (top.offset + b.offset);\n+                    }\n+\n+                    case (broken(inconsistent)) {\n+                        if (L > space) {\n+                            log \"print BREAK w/ newline in inconsistent block\";\n+                            self.print_newline(top.offset + b.offset);\n+                            space = margin - (top.offset + b.offset);\n+                        } else {\n+                            log \"print BREAK w/o newline in inconsistent block\";\n+                            self.indent(b.blank_space);\n+                            space -= b.blank_space;\n+                        }\n+                    }\n+                }\n+            }\n+\n+            case (STRING(?s)) {\n+                log \"print STRING\";\n+                assert L as uint == str::char_len(s);\n+                // assert L <= space;\n+                space -= L;\n+                out.write_str(s);\n+            }\n+\n+            case (EOF) {\n+                // EOF should never get here.\n+                fail;\n+            }\n+        }\n     }\n-  }\n }\n \n-fn line_break(ps p) {\n-  p.out.write_str(\"\\n\");\n-  p.col = 0u;\n-  p.spaces = cur_context(p).indent;\n-  p.start_of_line = true;\n+\n+// Convenience functions to talk to the printer.\n+\n+fn ibox(printer p, uint indent) {\n+    p.pretty_print(BEGIN(rec(offset = indent as int,\n+                             breaks = inconsistent)));\n }\n \n-fn before_print(ps p, bool closing) {\n-  if (p.start_of_line) {\n-    p.start_of_line = false;\n-    if (closing) {p.spaces = base_indent(p);}\n-    else {p.spaces = cur_context(p).indent;}\n-  }\n-  if (p.spaces > 0u) {\n-    write_spaces(p, p.spaces);\n-    p.col += p.spaces;\n-    p.spaces = 0u;\n-  }\n+fn cbox(printer p, uint indent) {\n+    p.pretty_print(BEGIN(rec(offset = indent as int,\n+                             breaks = consistent)));\n }\n \n-fn token_size(token tok) -> uint {\n-  alt (tok) {\n-    case (brk(?sz)) {ret sz;}\n-    case (hardbrk) {ret 0xFFFFFFu;}\n-    case (word(?w)) {ret str::char_len(w);}\n-    case (cword(?w)) {ret str::char_len(w);}\n-    case (open(_, _)) {ret 0u;}\n-    case (close) {ret 0u;}\n-  }\n+\n+fn break_offset(printer p, uint n, int off) {\n+    p.pretty_print(BREAK(rec(offset = off,\n+                             blank_space = n as int)));\n }\n \n-fn box(ps p, uint indent) {add_token(p, open(box_hv, indent));}\n-fn abox(ps p) {add_token(p, open(box_align, 0u));}\n-fn vbox(ps p, uint indent) {add_token(p, open(box_v, indent));}\n-fn hbox(ps p, uint indent) {add_token(p, open(box_h, indent));}\n-fn end(ps p) {add_token(p, close);}\n-fn wrd(ps p, str wrd) {add_token(p, word(wrd));}\n-fn cwrd(ps p, str wrd) {add_token(p, cword(wrd));}\n-fn space(ps p) {add_token(p, brk(1u));}\n-fn spaces(ps p, uint n) {add_token(p, brk(n));}\n-fn line(ps p) {add_token(p, brk(0u));}\n-fn hardbreak(ps p) {add_token(p, hardbrk);}\n+fn end(printer p) { p.pretty_print(END); }\n+fn eof(printer p) { p.pretty_print(EOF); }\n+fn wrd(printer p, str wrd) { p.pretty_print(STRING(wrd)); }\n+fn spaces(printer p, uint n) { break_offset(p, n, 0); }\n+fn space(printer p) { spaces(p, 1u); }\n+fn hardbreak(printer p) { spaces(p, 0xffffu); }\n+\n+\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "1684cb6f66e69ef772be5499affb84f5627a9c56", "filename": "src/comp/pretty/pprust.rs", "status": "modified", "additions": 227, "deletions": 170, "changes": 397, "blob_url": "https://github.com/rust-lang/rust/blob/21313d623a505086b2973f30c19db4f1d6ec8f61/src%2Fcomp%2Fpretty%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21313d623a505086b2973f30c19db4f1d6ec8f61/src%2Fcomp%2Fpretty%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fpretty%2Fpprust.rs?ref=21313d623a505086b2973f30c19db4f1d6ec8f61", "patch": "@@ -7,7 +7,17 @@ import front::ast;\n import front::lexer;\n import middle::ty;\n import util::common;\n-import pp::end; import pp::wrd; import pp::space; import pp::line;\n+import pp;\n+\n+import pp::printer;\n+import pp::break_offset;\n+import pp::cbox;\n+import pp::ibox;\n+import pp::wrd;\n+import pp::space;\n+import pp::hardbreak;\n+import pp::end;\n+import pp::eof;\n \n const uint indent_unit = 4u;\n const uint default_columns = 78u;\n@@ -17,93 +27,110 @@ tag mode {\n     mo_typed(ty::ctxt);\n }\n \n-type ps = @rec(pp::ps s,\n+type ps = @rec(pp::printer s,\n                option::t[vec[lexer::cmnt]] comments,\n                mutable uint cur_cmnt,\n                mode mode);\n \n fn print_file(session sess, ast::_mod _mod, str filename, io::writer out,\n               mode mode) {\n     auto cmnts = lexer::gather_comments(sess, filename);\n-    auto s = @rec(s=pp::mkstate(out, default_columns),\n+    auto s = @rec(s=pp::mk_printer(out, default_columns),\n                   comments=option::some[vec[lexer::cmnt]](cmnts),\n                   mutable cur_cmnt=0u,\n                   mode=mode);\n     print_mod(s, _mod);\n+    eof(s.s);\n }\n \n fn ty_to_str(&@ast::ty ty) -> str {\n     auto writer = io::string_writer();\n-    auto s = @rec(s=pp::mkstate(writer.get_writer(), 0u),\n+    auto s = @rec(s=pp::mk_printer(writer.get_writer(), default_columns),\n                   comments=option::none[vec[lexer::cmnt]],\n                   mutable cur_cmnt=0u,\n                   mode=mo_untyped);\n     print_type(s, ty);\n+    eof(s.s);\n     ret writer.get_str();\n }\n \n fn block_to_str(&ast::block blk) -> str {\n     auto writer = io::string_writer();\n-    auto s = @rec(s=pp::mkstate(writer.get_writer(), 78u),\n+    auto s = @rec(s=pp::mk_printer(writer.get_writer(), default_columns),\n                   comments=option::none[vec[lexer::cmnt]],\n                   mutable cur_cmnt=0u,\n                   mode=mo_untyped);\n+    cbox(s.s, indent_unit); // containing cbox, will be closed by print-block at }\n+    ibox(s.s, 0u); // head-ibox, will be closed by print-block after {\n     print_block(s, blk);\n+    eof(s.s);\n     ret writer.get_str();\n }\n \n fn pat_to_str(&@ast::pat p) -> str {\n     auto writer = io::string_writer();\n-    auto s = @rec(s=pp::mkstate(writer.get_writer(), 78u),\n+    auto s = @rec(s=pp::mk_printer(writer.get_writer(), default_columns),\n                   comments=option::none[vec[lexer::cmnt]],\n                   mutable cur_cmnt=0u,\n                   mode=mo_untyped);\n     print_pat(s, p);\n+    eof(s.s);\n     ret writer.get_str();\n }\n \n-fn hbox(ps s) {\n-    pp::hbox(s.s, indent_unit);\n+fn word_nbsp(ps s, str word) {\n+    wrd(s.s, word);\n+    wrd(s.s, \" \");\n }\n-fn wrd1(ps s, str word) {\n+\n+fn word_space(ps s, str word) {\n     wrd(s.s, word);\n     space(s.s);\n }\n+\n fn popen(ps s) {\n     wrd(s.s, \"(\");\n-    pp::abox(s.s);\n-}\n-fn popen_h(ps s) {\n-    wrd(s.s, \"(\");\n-    pp::hbox(s.s, 0u);\n }\n+\n fn pclose(ps s) {\n-    end(s.s);\n     wrd(s.s, \")\");\n }\n+\n+fn head(ps s, str word) {\n+    // outer-box is consistent\n+    cbox(s.s, indent_unit);\n+    // head-box is inconsistent\n+    ibox(s.s, str::char_len(word) + 1u);\n+    // keyword that starts the head\n+    word_nbsp(s, word);\n+}\n+\n fn bopen(ps s) {\n     wrd(s.s, \"{\");\n-    pp::vbox(s.s, indent_unit);\n-    line(s.s);\n-}\n-fn bclose(ps s) {\n-    end(s.s);\n-    pp::cwrd(s.s, \"}\");\n+    end(s.s); // close the head-box\n }\n-fn bclose_c(ps s, common::span span) {\n+\n+fn bclose(ps s, common::span span) {\n     maybe_print_comment(s, span.hi);\n-    bclose(s);\n+    break_offset(s.s, 1u, -(indent_unit as int));\n+    wrd(s.s, \"}\");\n+    end(s.s); // close the outer-box\n }\n+\n fn commasep[IN](ps s, vec[IN] elts, fn(ps, &IN) op) {\n+    ibox(s.s, 0u);\n     auto first = true;\n     for (IN elt in elts) {\n         if (first) {first = false;}\n-        else {wrd1(s, \",\");}\n+        else {word_space(s, \",\");}\n         op(s, elt);\n     }\n+    end(s.s);\n }\n+\n fn commasep_cmnt[IN](ps s, vec[IN] elts, fn(ps, &IN) op,\n-                            fn(&IN) -> common::span get_span) {\n+                     fn(&IN) -> common::span get_span) {\n+    ibox(s.s, 0u);\n     auto len = vec::len[IN](elts);\n     auto i = 0u;\n     for (IN elt in elts) {\n@@ -114,7 +141,9 @@ fn commasep_cmnt[IN](ps s, vec[IN] elts, fn(ps, &IN) op,\n             if (!maybe_print_line_comment(s, get_span(elt))) {space(s.s);}\n         }\n     }\n+    end(s.s);\n }\n+\n fn commasep_exprs(ps s, vec[@ast::expr] exprs) {\n     fn expr_span(&@ast::expr expr) -> common::span {ret expr.span;}\n     auto f = print_expr;\n@@ -126,14 +155,18 @@ fn print_mod(ps s, ast::_mod _mod) {\n     for (@ast::view_item vitem in _mod.view_items) {\n         print_view_item(s, vitem);\n     }\n-    line(s.s);\n-    for (@ast::item item in _mod.items) {print_item(s, item);}\n+    for (@ast::item item in _mod.items) {\n+        // Mod-level item printing we're a little more space-y about.\n+        hardbreak(s.s);\n+        print_item(s, item);\n+    }\n     print_remaining_comments(s);\n }\n \n fn print_type(ps s, &@ast::ty ty) {\n+\n     maybe_print_comment(s, ty.span.lo);\n-    hbox(s);\n+    ibox(s.s, 0u);\n     alt (ty.node) {\n         case (ast::ty_nil) {wrd(s.s, \"()\");}\n         case (ast::ty_bool) {wrd(s.s, \"bool\");}\n@@ -166,7 +199,7 @@ fn print_type(ps s, &@ast::ty ty) {\n             wrd(s.s, \"rec\");\n             popen(s);\n             fn print_field(ps s, &ast::ty_field f) {\n-                hbox(s);\n+                cbox(s.s, indent_unit);\n                 print_mt(s, f.mt);\n                 space(s.s);\n                 wrd(s.s, f.ident);\n@@ -184,17 +217,16 @@ fn print_type(ps s, &@ast::ty ty) {\n             pclose(s);\n         }\n         case (ast::ty_obj(?methods)) {\n-            wrd1(s, \"obj\");\n+            head(s, \"obj\");\n             bopen(s);\n             for (ast::ty_method m in methods) {\n-                hbox(s);\n+                cbox(s.s, indent_unit);\n                 print_ty_fn(s, m.proto, option::some[str](m.ident),\n                             m.inputs, m.output, m.cf);\n                 wrd(s.s, \";\");\n                 end(s.s);\n-                line(s.s);\n             }\n-            bclose_c(s, ty.span);\n+            bclose(s, ty.span);\n         }\n         case (ast::ty_fn(?proto,?inputs,?output,?cf)) {\n             print_ty_fn(s, proto, option::none[str], inputs, output, cf);\n@@ -207,53 +239,56 @@ fn print_type(ps s, &@ast::ty ty) {\n }\n \n fn print_item(ps s, @ast::item item) {\n+\n+    hardbreak(s.s);\n     maybe_print_comment(s, item.span.lo);\n-    hbox(s);\n     alt (item.node) {\n         case (ast::item_const(?id, ?ty, ?expr, _, _)) {\n-            wrd1(s, \"const\");\n+            head(s, \"const\");\n             print_type(s, ty);\n             space(s.s);\n-            wrd1(s, id);\n-            wrd1(s, \"=\");\n+            word_space(s, id);\n+            end(s.s); // end the head-ibox\n+            word_space(s, \"=\");\n             print_expr(s, expr);\n             wrd(s.s, \";\");\n+            end(s.s); // end the outer cbox\n         }\n         case (ast::item_fn(?name,?_fn,?typarams,_,_)) {\n             print_fn(s, _fn.decl, name, typarams);\n-            space(s.s);\n+            wrd(s.s, \" \");\n             print_block(s, _fn.body);\n         }\n         case (ast::item_mod(?id,?_mod,_)) {\n-            wrd1(s, \"mod\");\n-            wrd1(s, id);\n+            head(s, \"mod\");\n             bopen(s);\n             for (@ast::item itm in _mod.items) {print_item(s, itm);}\n-            bclose_c(s, item.span);\n+            bclose(s, item.span);\n         }\n         case (ast::item_native_mod(?id,?nmod,_)) {\n-            wrd1(s, \"native\");\n+            head(s, \"native\");\n             alt (nmod.abi) {\n-                case (ast::native_abi_rust) {wrd1(s, \"\\\"rust\\\"\");}\n-                case (ast::native_abi_cdecl) {wrd1(s, \"\\\"cdecl\\\"\");}\n+                case (ast::native_abi_rust) {word_nbsp(s, \"\\\"rust\\\"\");}\n+                case (ast::native_abi_cdecl) {word_nbsp(s, \"\\\"cdecl\\\"\");}\n                 case (ast::native_abi_rust_intrinsic) {\n-                    wrd1(s, \"\\\"rust-intrinsic\\\"\");\n+                    word_nbsp(s, \"\\\"rust-intrinsic\\\"\");\n                 }\n             }\n-            wrd1(s, \"mod\");\n-            wrd1(s, id);\n+            word_nbsp(s, \"mod\");\n+            word_nbsp(s, id);\n             bopen(s);\n             for (@ast::native_item item in nmod.items) {\n-                hbox(s);\n+                ibox(s.s, indent_unit);\n                 maybe_print_comment(s, item.span.lo);\n                 alt (item.node) {\n                     case (ast::native_item_ty(?id,_)) {\n-                        wrd1(s, \"type\");\n+                        word_nbsp(s, \"type\");\n                         wrd(s.s, id);\n                     }\n                     case (ast::native_item_fn(?id,?lname,?decl,\n                                              ?typarams,_,_)) {\n                         print_fn(s, decl, id, typarams);\n+                        end(s.s); // end head-ibox\n                         alt (lname) {\n                             case (option::none[str]) {}\n                             case (option::some[str](?ss)) {\n@@ -265,24 +300,30 @@ fn print_item(ps s, @ast::item item) {\n                 wrd(s.s, \";\");\n                 end(s.s);\n             }\n-            bclose_c(s, item.span);\n+            bclose(s, item.span);\n         }\n         case (ast::item_ty(?id,?ty,?params,_,_)) {\n-            wrd1(s, \"type\");\n+            ibox(s.s, indent_unit);\n+            ibox(s.s, 0u);\n+            word_nbsp(s, \"type\");\n             wrd(s.s, id);\n             print_type_params(s, params);\n+            end(s.s); // end the inner ibox\n             space(s.s);\n-            wrd1(s, \"=\");\n+            word_space(s, \"=\");\n             print_type(s, ty);\n             wrd(s.s, \";\");\n+            end(s.s); // end the outer ibox\n+            break_offset(s.s, 0u, 0);\n         }\n         case (ast::item_tag(?id,?variants,?params,_,_)) {\n-            wrd1(s, \"tag\");\n+            head(s, \"tag\");\n             wrd(s.s, id);\n             print_type_params(s, params);\n             space(s.s);\n             bopen(s);\n             for (ast::variant v in variants) {\n+                space(s.s);\n                 maybe_print_comment(s, v.span.lo);\n                 wrd(s.s, v.node.name);\n                 if (vec::len[ast::variant_arg](v.node.args) > 0u) {\n@@ -295,17 +336,17 @@ fn print_item(ps s, @ast::item item) {\n                     pclose(s);\n                 }\n                 wrd(s.s, \";\");\n-                if (!maybe_print_line_comment(s, v.span)) {line(s.s);}\n+                maybe_print_line_comment(s, v.span);\n             }\n-            bclose_c(s, item.span);\n+            bclose(s, item.span);\n         }\n         case (ast::item_obj(?id,?_obj,?params,_,_)) {\n-            wrd1(s, \"obj\");\n+            head(s, \"obj\");\n             wrd(s.s, id);\n             print_type_params(s, params);\n             popen(s);\n             fn print_field(ps s, &ast::obj_field field) {\n-                hbox(s);\n+                ibox(s.s, indent_unit);\n                 print_type(s, field.ty);\n                 space(s.s);\n                 wrd(s.s, field.ident);\n@@ -319,53 +360,52 @@ fn print_item(ps s, @ast::item item) {\n             space(s.s);\n             bopen(s);\n             for (@ast::method meth in _obj.methods) {\n-                hbox(s);\n                 let vec[ast::ty_param] typarams = [];\n+                hardbreak(s.s);\n                 maybe_print_comment(s, meth.span.lo);\n                 print_fn(s, meth.node.meth.decl, meth.node.ident, typarams);\n-                space(s.s);\n+                wrd(s.s, \" \");\n                 print_block(s, meth.node.meth.body);\n-                end(s.s);\n-                line(s.s);\n             }\n             alt (_obj.dtor) {\n                 case (option::some[@ast::method](?dtor)) {\n-                    hbox(s);\n-                    wrd1(s, \"close\");\n+                    head(s, \"drop\");\n                     print_block(s, dtor.node.meth.body);\n-                    end(s.s);\n-                    line(s.s);\n                 }\n                 case (_) {}\n             }\n-            bclose_c(s, item.span);\n+            bclose(s, item.span);\n         }\n     }\n-    end(s.s);\n-    line(s.s);\n-    line(s.s);\n }\n \n fn print_block(ps s, ast::block blk) {\n     maybe_print_comment(s, blk.span.lo);\n     bopen(s);\n+    auto first = true;\n     for (@ast::stmt st in blk.node.stmts) {\n         maybe_print_comment(s, st.span.lo);\n         alt (st.node) {\n-          case (ast::stmt_decl(?decl,_)) {print_decl(s, decl);}\n-          case (ast::stmt_expr(?expr,_)) {print_expr(s, expr);}\n+          case (ast::stmt_decl(?decl,_)) {\n+              print_decl(s, decl);\n+          }\n+          case (ast::stmt_expr(?expr,_)) {\n+              space(s.s);\n+              print_expr(s, expr);\n+          }\n         }\n         if (front::parser::stmt_ends_with_semi(st)) {wrd(s.s, \";\");}\n-        if (!maybe_print_line_comment(s, st.span)) {line(s.s);}\n+        maybe_print_line_comment(s, st.span);\n     }\n     alt (blk.node.expr) {\n         case (option::some[@ast::expr](?expr)) {\n+            space(s.s);\n             print_expr(s, expr);\n-            if (!maybe_print_line_comment(s, expr.span)) {line(s.s);}\n+            maybe_print_line_comment(s, expr.span);\n         }\n         case (_) {}\n     }\n-    bclose_c(s, blk.span);\n+    bclose(s, blk.span);\n }\n \n fn print_literal(ps s, @ast::lit lit) {\n@@ -403,7 +443,7 @@ fn print_literal(ps s, @ast::lit lit) {\n \n fn print_expr(ps s, &@ast::expr expr) {\n     maybe_print_comment(s, expr.span.lo);\n-    hbox(s);\n+    ibox(s.s, indent_unit);\n \n     alt (s.mode) {\n         case (mo_untyped) { /* no-op */ }\n@@ -413,18 +453,18 @@ fn print_expr(ps s, &@ast::expr expr) {\n     alt (expr.node) {\n         case (ast::expr_vec(?exprs,?mut,_)) {\n             if (mut == ast::mut) {\n-                wrd1(s, \"mutable\");\n+                word_nbsp(s, \"mutable\");\n             }\n+            ibox(s.s, indent_unit);\n             wrd(s.s, \"[\");\n-            pp::abox(s.s);\n             commasep_exprs(s, exprs);\n-            end(s.s);\n             wrd(s.s, \"]\");\n+            end(s.s);\n         }\n         case (ast::expr_tup(?exprs,_)) {\n             fn printElt(ps s, &ast::elt elt) {\n-                hbox(s);\n-                if (elt.mut == ast::mut) {wrd1(s, \"mutable\");}\n+                ibox(s.s, indent_unit);\n+                if (elt.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n                 print_expr(s, elt.expr);\n                 end(s.s);\n             }\n@@ -438,8 +478,8 @@ fn print_expr(ps s, &@ast::expr expr) {\n         }\n         case (ast::expr_rec(?fields,?wth,_)) {\n             fn print_field(ps s, &ast::field field) {\n-                hbox(s);\n-                if (field.mut == ast::mut) {wrd1(s, \"mutable\");}\n+                ibox(s.s, indent_unit);\n+                if (field.mut == ast::mut) {word_nbsp(s, \"mutable\");}\n                 wrd(s.s, field.ident);\n                 wrd(s.s, \"=\");\n                 print_expr(s, field.expr);\n@@ -456,8 +496,8 @@ fn print_expr(ps s, &@ast::expr expr) {\n             alt (wth) {\n                 case (option::some[@ast::expr](?expr)) {\n                     if (vec::len[ast::field](fields) > 0u) {space(s.s);}\n-                    hbox(s);\n-                    wrd1(s, \"with\");\n+                    ibox(s.s, indent_unit);\n+                    word_space(s, \"with\");\n                     print_expr(s, expr);\n                     end(s.s);\n                 }\n@@ -484,15 +524,15 @@ fn print_expr(ps s, &@ast::expr expr) {\n                     case (_) {wrd(s.s, \"_\");}\n                 }\n             }\n-            wrd1(s, \"bind\");\n+            word_nbsp(s, \"bind\");\n             print_expr(s, func);\n             popen(s);\n             auto f = print_opt;\n             commasep[option::t[@ast::expr]](s, args, f);\n             pclose(s);\n         }\n     case (ast::expr_spawn(_,_,?e,?es,_)) {\n-          wrd1(s, \"spawn\");\n+          word_nbsp(s, \"spawn\");\n           print_expr(s, e);\n           popen(s);\n           commasep_exprs(s, es);\n@@ -502,7 +542,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             auto prec = operator_prec(op);\n             print_maybe_parens(s, lhs, prec);\n             space(s.s);\n-            wrd1(s, ast::binop_to_str(op));\n+            word_space(s, ast::binop_to_str(op));\n             print_maybe_parens(s, rhs, prec + 1);\n         }\n         case (ast::expr_unary(?op,?expr,_)) {\n@@ -515,111 +555,119 @@ fn print_expr(ps s, &@ast::expr expr) {\n         case (ast::expr_cast(?expr,?ty,_)) {\n             print_maybe_parens(s, expr, front::parser::as_prec);\n             space(s.s);\n-            wrd1(s, \"as\");\n+            word_space(s, \"as\");\n             print_type(s, ty);\n         }\n         case (ast::expr_if(?test,?block,?elseopt,_)) {\n-            wrd1(s, \"if\");\n-            popen_h(s);\n+            head(s, \"if\");\n+            popen(s);\n             print_expr(s, test);\n             pclose(s);\n             space(s.s);\n             print_block(s, block);\n             alt (elseopt) {\n                 case (option::some[@ast::expr](?_else)) {\n-                    space(s.s);\n-                    wrd1(s, \"else\");\n-                    print_expr(s, _else);\n+                    // NB: we can't use 'head' here since\n+                    // it builds a block that starts in the\n+                    // wrong column.\n+                    cbox(s.s, indent_unit-1u);\n+                    ibox(s.s, 0u);\n+                    wrd(s.s, \" else \");\n+                    alt (_else.node) {\n+                        case (ast::expr_block(?b, _)) {\n+                            print_block(s, block);\n+                        }\n+                    }\n                 }\n                 case (_) { /* fall through */ }\n             }\n         }\n         case (ast::expr_while(?test,?block,_)) {\n-            wrd1(s, \"while\");\n-            popen_h(s);\n+            head(s, \"while\");\n+            popen(s);\n             print_expr(s, test);\n             pclose(s);\n             space(s.s);\n             print_block(s, block);\n         }\n         case (ast::expr_for(?decl,?expr,?block,_)) {\n-            wrd1(s, \"for\");\n-            popen_h(s);\n+            head(s, \"for\");\n+            popen(s);\n             print_for_decl(s, decl);\n             space(s.s);\n-            wrd1(s, \"in\");\n+            word_space(s, \"in\");\n             print_expr(s, expr);\n             pclose(s);\n             space(s.s);\n             print_block(s, block);\n         }\n         case (ast::expr_for_each(?decl,?expr,?block,_)) {\n-            wrd1(s, \"for each\");\n-            popen_h(s);\n+            head(s, \"for each\");\n+            popen(s);\n             print_for_decl(s, decl);\n             space(s.s);\n-            wrd1(s, \"in\");\n+            word_space(s, \"in\");\n             print_expr(s, expr);\n             pclose(s);\n             space(s.s);\n             print_block(s, block);\n         }\n         case (ast::expr_do_while(?block,?expr,_)) {\n-            wrd1(s, \"do\");\n+            head(s, \"do\");\n             space(s.s);\n             print_block(s, block);\n             space(s.s);\n-            wrd1(s, \"while\");\n-            popen_h(s);\n+            word_space(s, \"while\");\n+            popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n         case (ast::expr_alt(?expr,?arms,_)) {\n-            wrd1(s, \"alt\");\n-            popen_h(s);\n+            head(s, \"alt\");\n+            popen(s);\n             print_expr(s, expr);\n             pclose(s);\n             space(s.s);\n             bopen(s);\n             for (ast::arm arm in arms) {\n-                hbox(s);\n-                wrd1(s, \"case\");\n-                popen_h(s);\n+                space(s.s);\n+                head(s, \"case\");\n+                popen(s);\n                 print_pat(s, arm.pat);\n                 pclose(s);\n                 space(s.s);\n                 print_block(s, arm.block);\n-                end(s.s);\n-                line(s.s);\n             }\n-            bclose_c(s, expr.span);\n+            bclose(s, expr.span);\n         }\n         case (ast::expr_block(?block,_)) {\n+            cbox(s.s, indent_unit); // containing cbox, will be closed by print-block at }\n+            ibox(s.s, 0u); // head-box, will be closed by print-block after {\n             print_block(s, block);\n         }\n         case (ast::expr_assign(?lhs,?rhs,_)) {\n             print_expr(s, lhs);\n             space(s.s);\n-            wrd1(s, \"=\");\n+            word_space(s, \"=\");\n             print_expr(s, rhs);\n         }\n         case (ast::expr_assign_op(?op,?lhs,?rhs,_)) {\n             print_expr(s, lhs);\n             space(s.s);\n             wrd(s.s, ast::binop_to_str(op));\n-            wrd1(s, \"=\");\n+            word_space(s, \"=\");\n             print_expr(s, rhs);\n         }\n         case (ast::expr_send(?lhs, ?rhs, _)) {\n             print_expr(s, lhs);\n             space(s.s);\n-            wrd1(s, \"<|\");\n+            word_space(s, \"<|\");\n             print_expr(s, rhs);\n         }\n         case (ast::expr_recv(?lhs, ?rhs, _)) {\n             print_expr(s, rhs);\n             space(s.s);\n-            wrd1(s, \"|>\");\n+            word_space(s, \"|>\");\n             print_expr(s, lhs);\n         }\n         case (ast::expr_field(?expr,?id,_)) {\n@@ -630,7 +678,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n         case (ast::expr_index(?expr,?index,_)) {\n             print_expr(s, expr);\n             wrd(s.s, \".\");\n-            popen_h(s);\n+            popen(s);\n             print_expr(s, index);\n             pclose(s);\n         }\n@@ -650,7 +698,7 @@ fn print_expr(ps s, &@ast::expr expr) {\n             wrd(s.s, \"ret\");\n             alt (result) {\n                 case (option::some[@ast::expr](?expr)) {\n-                    space(s.s);\n+                    wrd(s.s, \" \");\n                     print_expr(s, expr);\n                 }\n                 case (_) {}\n@@ -660,32 +708,32 @@ fn print_expr(ps s, &@ast::expr expr) {\n             wrd(s.s, \"put\");\n             alt (result) {\n                 case (option::some[@ast::expr](?expr)) {\n-                    space(s.s);\n+                    wrd(s.s, \" \");\n                     print_expr(s, expr);\n                 }\n                 case (_) {}\n             }\n         }\n         case (ast::expr_be(?result,_)) {\n-            wrd1(s, \"be\");\n+            word_nbsp(s, \"be\");\n             print_expr(s, result);\n         }\n         case (ast::expr_log(?lvl,?expr,_)) {\n             alt (lvl) {\n-                case (1) {wrd1(s, \"log\");}\n-                case (0) {wrd1(s, \"log_err\");}\n+                case (1) {word_nbsp(s, \"log\");}\n+                case (0) {word_nbsp(s, \"log_err\");}\n             }\n             print_expr(s, expr);\n         }\n         case (ast::expr_check(?expr,_)) {\n-            wrd1(s, \"check\");\n-            popen_h(s);\n+            word_nbsp(s, \"check\");\n+            popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n         case (ast::expr_assert(?expr,_)) {\n-            wrd1(s, \"assert\");\n-            popen_h(s);\n+            word_nbsp(s, \"assert\");\n+            popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n@@ -701,12 +749,12 @@ fn print_expr(ps s, &@ast::expr expr) {\n         }\n         case (ast::expr_port(_)) {\n             wrd(s.s, \"port\");\n-            popen_h(s);\n+            popen(s);\n             pclose(s);\n         }\n         case (ast::expr_chan(?expr, _)) {\n             wrd(s.s, \"chan\");\n-            popen_h(s);\n+            popen(s);\n             print_expr(s, expr);\n             pclose(s);\n         }\n@@ -722,7 +770,8 @@ fn print_expr(ps s, &@ast::expr expr) {\n         case (mo_untyped) { /* no-op */ }\n         case (mo_typed(?tcx)) {\n             space(s.s);\n-            wrd1(s, \"as\");\n+            wrd(s.s, \"as\");\n+            space(s.s);\n             wrd(s.s, ty::ty_to_str(tcx, ty::expr_ty(tcx, expr)));\n             pclose(s);\n         }\n@@ -733,25 +782,26 @@ fn print_expr(ps s, &@ast::expr expr) {\n \n fn print_decl(ps s, @ast::decl decl) {\n     maybe_print_comment(s, decl.span.lo);\n-    hbox(s);\n     alt (decl.node) {\n         case (ast::decl_local(?loc)) {\n+            space(s.s);\n+            ibox(s.s, indent_unit);\n             alt (loc.ty) {\n                 case (option::some[@ast::ty](?ty)) {\n-                    wrd1(s, \"let\");\n+                    word_nbsp(s, \"let\");\n                     print_type(s, ty);\n                     space(s.s);\n                 }\n                 case (_) {\n-                    wrd1(s, \"auto\");\n+                    word_nbsp(s, \"auto\");\n \n                     // Print the type if necessary.\n                     alt (s.mode) {\n                         case (mo_untyped) { /* no-op */ }\n                         case (mo_typed(?tcx)) {\n                             auto lty =\n                                 ty::ann_to_type(tcx.node_types, loc.ann);\n-                            wrd1(s, ty::ty_to_str(tcx, lty));\n+                            word_space(s, ty::ty_to_str(tcx, lty));\n                         }\n                     }\n                 }\n@@ -762,22 +812,22 @@ fn print_decl(ps s, @ast::decl decl) {\n                     space(s.s);\n                     alt (init.op) {\n                         case (ast::init_assign) {\n-                            wrd1(s, \"=\");\n+                            word_space(s, \"=\");\n                         }\n                         case (ast::init_recv) {\n-                            wrd1(s, \"<-\");\n+                            word_space(s, \"<-\");\n                         }\n                     }\n                     print_expr(s, init.expr);\n                 }\n                 case (_) {}\n             }\n+            end(s.s);\n         }\n         case (ast::decl_item(?item)) {\n             print_item(s, item);\n         }\n     }\n-    end(s.s);\n }\n \n fn print_ident(ps s, ast::ident ident) {\n@@ -819,7 +869,7 @@ fn print_pat(ps s, &@ast::pat pat) {\n         case (ast::pat_tag(?path,?args,_)) {\n             print_path(s, path);\n             if (vec::len[@ast::pat](args) > 0u) {\n-                popen_h(s);\n+                popen(s);\n                 auto f = print_pat;\n                 commasep[@ast::pat](s, args, f);\n                 pclose(s);\n@@ -832,17 +882,17 @@ fn print_fn(ps s, ast::fn_decl decl, str name,\n                    vec[ast::ty_param] typarams) {\n     alt (decl.purity) {\n         case (ast::impure_fn) {\n-            wrd1(s, \"fn\");\n+            head(s, \"fn\");\n         }\n         case (_) {\n-            wrd1(s, \"pred\");\n+            head(s, \"pred\");\n         }\n     }\n     wrd(s.s, name);\n     print_type_params(s, typarams);\n     popen(s);\n     fn print_arg(ps s, &ast::arg x) {\n-        hbox(s);\n+        ibox(s.s, indent_unit);\n         if (x.mode == ast::alias) {wrd(s.s, \"&\");}\n         print_type(s, x.ty);\n         space(s.s);\n@@ -855,10 +905,8 @@ fn print_fn(ps s, ast::fn_decl decl, str name,\n     maybe_print_comment(s, decl.output.span.lo);\n     if (decl.output.node != ast::ty_nil) {\n         space(s.s);\n-        hbox(s);\n-        wrd1(s, \"->\");\n+        word_space(s, \"->\");\n         print_type(s, decl.output);\n-        end(s.s);\n     }\n }\n \n@@ -875,18 +923,18 @@ fn print_type_params(ps s, vec[ast::ty_param] params) {\n }\n \n fn print_view_item(ps s, @ast::view_item item) {\n+    hardbreak(s.s);\n     maybe_print_comment(s, item.span.lo);\n-    hbox(s);\n     alt (item.node) {\n         case (ast::view_item_use(?id,?mta,_,_)) {\n-            wrd1(s, \"use\");\n+            head(s, \"use\");\n             wrd(s.s, id);\n             if (vec::len[@ast::meta_item](mta) > 0u) {\n                 popen(s);\n                 fn print_meta(ps s, &@ast::meta_item item) {\n-                    hbox(s);\n-                    wrd1(s, item.node.name);\n-                    wrd1(s, \"=\");\n+                    ibox(s.s, indent_unit);\n+                    word_space(s, item.node.name);\n+                    word_space(s, \"=\");\n                     print_string(s, item.node.value);\n                     end(s.s);\n                 }\n@@ -896,10 +944,10 @@ fn print_view_item(ps s, @ast::view_item item) {\n             }\n         }\n         case (ast::view_item_import(?id,?ids,_)) {\n-            wrd1(s, \"import\");\n+            head(s, \"import\");\n             if (!str::eq(id, ids.(vec::len[str](ids)-1u))) {\n-                wrd1(s, id);\n-                wrd1(s, \"=\");\n+                word_space(s, id);\n+                word_space(s, \"=\");\n             }\n             auto first = true;\n             for (str elt in ids) {\n@@ -909,13 +957,13 @@ fn print_view_item(ps s, @ast::view_item item) {\n             }\n         }\n         case (ast::view_item_export(?id)) {\n-            wrd1(s, \"export\");\n+            head(s, \"export\");\n             wrd(s.s, id);\n         }\n     }\n-    end(s.s);\n     wrd(s.s, \";\");\n-    line(s.s);\n+    end(s.s); // end inner head-block\n+    end(s.s); // end outer head-block\n }\n \n // FIXME: The fact that this builds up the table anew for every call is\n@@ -968,8 +1016,8 @@ fn escape_str(str st, char to_escape) -> str {\n \n fn print_mt(ps s, &ast::mt mt) {\n     alt (mt.mut) {\n-        case (ast::mut)       { wrd1(s, \"mutable\");  }\n-        case (ast::maybe_mut) { wrd1(s, \"mutable?\"); }\n+        case (ast::mut)       { word_nbsp(s, \"mutable\");  }\n+        case (ast::maybe_mut) { word_nbsp(s, \"mutable?\"); }\n         case (ast::imm)       { /* nothing */        }\n     }\n     print_type(s, mt.ty);\n@@ -988,7 +1036,7 @@ fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n         case (option::some[str](?id)) {space(s.s); wrd(s.s, id);}\n         case (_) {}\n     }\n-    popen_h(s);\n+    popen(s);\n     fn print_arg(ps s, &ast::ty_arg input) {\n         if (input.mode == ast::alias) {wrd(s.s, \"&\");}\n         print_type(s, input.ty);\n@@ -999,14 +1047,14 @@ fn print_ty_fn(ps s, ast::proto proto, option::t[str] id,\n     maybe_print_comment(s, output.span.lo);\n     if (output.node != ast::ty_nil) {\n         space(s.s);\n-        hbox(s);\n-        wrd1(s, \"->\");\n+        ibox(s.s, indent_unit);\n+        word_space(s, \"->\");\n         alt (cf) {\n             case (ast::return) {\n                 print_type(s, output);\n             }\n             case (ast::noreturn) {\n-                wrd1(s, \"!\");\n+                word_nbsp(s, \"!\");\n             }\n         }\n         end(s.s);\n@@ -1025,12 +1073,16 @@ fn next_comment(ps s) -> option::t[lexer::cmnt] {\n }\n \n fn maybe_print_comment(ps s, uint pos) {\n+    auto first = true;\n     while (true) {\n         alt (next_comment(s)) {\n             case (option::some[lexer::cmnt](?cmnt)) {\n                 if (cmnt.pos < pos) {\n+                    if (first) {\n+                        first = false;\n+                        break_offset(s.s, 0u, 0);\n+                    }\n                     print_comment(s, cmnt.val);\n-                    if (cmnt.space_after) {line(s.s);}\n                     s.cur_cmnt += 1u;\n                 } else { break; }\n             }\n@@ -1055,11 +1107,15 @@ fn maybe_print_line_comment(ps s, common::span span) -> bool {\n }\n \n fn print_remaining_comments(ps s) {\n+    auto first = true;\n     while (true) {\n         alt (next_comment(s)) {\n             case (option::some[lexer::cmnt](?cmnt)) {\n+                if (first) {\n+                    first = false;\n+                    break_offset(s.s, 0u, 0);\n+                }\n                 print_comment(s, cmnt.val);\n-                if (cmnt.space_after) {line(s.s);}\n                 s.cur_cmnt += 1u;\n             }\n             case (_) {break;}\n@@ -1071,22 +1127,23 @@ fn print_comment(ps s, lexer::cmnt_ cmnt) {\n     alt (cmnt) {\n         case (lexer::cmnt_line(?val)) {\n             wrd(s.s, \"// \" + val);\n-            pp::hardbreak(s.s);\n+            hardbreak(s.s);\n         }\n         case (lexer::cmnt_block(?lines)) {\n-            pp::abox(s.s);\n-            wrd(s.s, \"/* \");\n-            pp::abox(s.s);\n+            cbox(s.s, 1u);\n+            wrd(s.s, \"/*\");\n             auto first = true;\n             for (str ln in lines) {\n-                if (first) {first = false;}\n-                else {pp::hardbreak(s.s);}\n+                if (first) {\n+                    first = false;\n+                } else {\n+                    hardbreak(s.s);\n+                }\n                 wrd(s.s, ln);\n             }\n-            end(s.s);\n             wrd(s.s, \"*/\");\n             end(s.s);\n-            line(s.s);\n+            hardbreak(s.s);\n         }\n     }\n }"}, {"sha": "119fcce806c221f9c474ff33191e88ac907d753d", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21313d623a505086b2973f30c19db4f1d6ec8f61/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21313d623a505086b2973f30c19db4f1d6ec8f61/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=21313d623a505086b2973f30c19db4f1d6ec8f61", "patch": "@@ -20,7 +20,7 @@ import pretty::pprust::print_decl;\n import pretty::pprust::print_fn;\n import pretty::pprust::print_type;\n import pretty::pprust::mo_untyped;\n-import pretty::pp::mkstate;\n+import pretty::pp::mk_printer;\n \n type filename = str;\n type span = rec(uint lo, uint hi);\n@@ -127,7 +127,7 @@ fn field_exprs(vec[ast::field] fields) -> vec [@ast::expr] {\n \n fn expr_to_str(&@ast::expr e) -> str {\n   let str_writer s = string_writer();\n-  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out_ = mk_printer(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u,\n@@ -138,7 +138,7 @@ fn expr_to_str(&@ast::expr e) -> str {\n \n fn ty_to_str(&ty t) -> str {\n   let str_writer s = string_writer();\n-  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out_ = mk_printer(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u,\n@@ -165,7 +165,7 @@ fn log_pat_err(&@pat p) -> () {\n \n fn block_to_str(&ast::block b) -> str {\n   let str_writer s = string_writer();\n-  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out_ = mk_printer(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u,\n@@ -177,7 +177,7 @@ fn block_to_str(&ast::block b) -> str {\n \n fn item_to_str(&@ast::item i) -> str {\n   let str_writer s = string_writer();\n-  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out_ = mk_printer(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u,\n@@ -200,7 +200,7 @@ fn log_item_err(&@ast::item i) -> () {\n \n fn fun_to_str(&ast::_fn f, str name, vec[ast::ty_param] params) -> str {\n  let str_writer s = string_writer();\n-  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out_ = mk_printer(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u,\n@@ -220,7 +220,7 @@ fn log_fn_err(&ast::_fn f, str name, vec[ast::ty_param] params) -> () {\n \n fn stmt_to_str(&ast::stmt st) -> str {\n   let str_writer s = string_writer();\n-  auto out_ = mkstate(s.get_writer(), 80u);\n+  auto out_ = mk_printer(s.get_writer(), 80u);\n   auto out = @rec(s=out_,\n                   comments=none[vec[front::lexer::cmnt]],\n                   mutable cur_cmnt=0u,"}]}