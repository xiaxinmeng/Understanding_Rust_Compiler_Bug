{"sha": "a2c4affe860ec53647b902f257e7e575f0350854", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEyYzRhZmZlODYwZWM1MzY0N2I5MDJmMjU3ZTdlNTc1ZjAzNTA4NTQ=", "commit": {"author": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-01T17:12:55Z"}, "committer": {"name": "bjorn3", "email": "bjorn3@users.noreply.github.com", "date": "2021-06-01T17:29:11Z"}, "message": "Remove unused functions and arguments from rustc_serialize", "tree": {"sha": "ae84fef72226be77f6884839120f5018aec9c7b7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ae84fef72226be77f6884839120f5018aec9c7b7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a2c4affe860ec53647b902f257e7e575f0350854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a2c4affe860ec53647b902f257e7e575f0350854", "html_url": "https://github.com/rust-lang/rust/commit/a2c4affe860ec53647b902f257e7e575f0350854", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a2c4affe860ec53647b902f257e7e575f0350854/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7f9ab0300cd66f6f616e03ea90b2d71af474bf28", "url": "https://api.github.com/repos/rust-lang/rust/commits/7f9ab0300cd66f6f616e03ea90b2d71af474bf28", "html_url": "https://github.com/rust-lang/rust/commit/7f9ab0300cd66f6f616e03ea90b2d71af474bf28"}], "stats": {"total": 466, "additions": 130, "deletions": 336}, "files": [{"sha": "72395bd31eca556aed999d8f7057489b6a546dca", "filename": "compiler/rustc_errors/src/json.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_errors%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fjson.rs?ref=a2c4affe860ec53647b902f257e7e575f0350854", "patch": "@@ -216,7 +216,7 @@ macro_rules! encode_fields {\n             $(\n                 $enc.emit_struct_field(\n                     stringify!($name),\n-                    idx,\n+                    idx == 0,\n                     |enc| $name.encode(enc),\n                 )?;\n                 idx += 1;\n@@ -229,7 +229,7 @@ macro_rules! encode_fields {\n // Special-case encoder to skip tool_metadata if not set\n impl<E: Encoder> Encodable<E> for Diagnostic {\n     fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(\"diagnostic\", 7, |s| {\n+        s.emit_struct(false, |s| {\n             let mut idx = 0;\n \n             idx = encode_fields!("}, {"sha": "7bc669f2b005c53fc86c89970270b62f617dd799", "filename": "compiler/rustc_macros/src/serialize.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fserialize.rs?ref=a2c4affe860ec53647b902f257e7e575f0350854", "patch": "@@ -43,12 +43,9 @@ fn decodable_body(\n     let decode_body = match s.variants() {\n         [vi] => {\n             let construct = vi.construct(|field, index| decode_field(field, index, true));\n-            let n_fields = vi.ast().fields.len();\n             quote! {\n                 ::rustc_serialize::Decoder::read_struct(\n                     __decoder,\n-                    #ty_name,\n-                    #n_fields,\n                     |__decoder| { ::std::result::Result::Ok(#construct) },\n                 )\n             }\n@@ -77,7 +74,6 @@ fn decodable_body(\n             quote! {\n                 ::rustc_serialize::Decoder::read_enum(\n                     __decoder,\n-                    #ty_name,\n                     |__decoder| {\n                         ::rustc_serialize::Decoder::read_enum_variant(\n                             __decoder,\n@@ -128,7 +124,7 @@ fn decode_field(field: &syn::Field, index: usize, is_struct: bool) -> proc_macro\n \n     quote! {\n         match ::rustc_serialize::Decoder::#decode_method(\n-            __decoder, #opt_field_name #index, #decode_inner_method) {\n+            __decoder, #opt_field_name #decode_inner_method) {\n             ::std::result::Result::Ok(__res) => __res,\n             ::std::result::Result::Err(__err) => return ::std::result::Result::Err(__err),\n         }\n@@ -183,7 +179,6 @@ fn encodable_body(\n         }\n     });\n \n-    let ty_name = s.ast().ident.to_string();\n     let encode_body = match s.variants() {\n         [_] => {\n             let mut field_idx = 0usize;\n@@ -197,11 +192,12 @@ fn encodable_body(\n                             .ident\n                             .as_ref()\n                             .map_or_else(|| field_idx.to_string(), |i| i.to_string());\n+                        let first = field_idx == 0;\n                         let result = quote! {\n                             match ::rustc_serialize::Encoder::emit_struct_field(\n                                 __encoder,\n                                 #field_name,\n-                                #field_idx,\n+                                #first,\n                                 |__encoder|\n                                 ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n@@ -215,8 +211,9 @@ fn encodable_body(\n                     })\n                     .collect::<TokenStream>()\n             });\n+            let no_fields = field_idx == 0;\n             quote! {\n-                ::rustc_serialize::Encoder::emit_struct(__encoder, #ty_name, #field_idx, |__encoder| {\n+                ::rustc_serialize::Encoder::emit_struct(__encoder, #no_fields, |__encoder| {\n                     ::std::result::Result::Ok(match *self { #encode_inner })\n                 })\n             }\n@@ -232,10 +229,11 @@ fn encodable_body(\n                     .iter()\n                     .map(|binding| {\n                         let bind_ident = &binding.binding;\n+                        let first = field_idx == 0;\n                         let result = quote! {\n                             match ::rustc_serialize::Encoder::emit_enum_variant_arg(\n                                 __encoder,\n-                                #field_idx,\n+                                #first,\n                                 |__encoder|\n                                 ::rustc_serialize::Encodable::<#encoder_ty>::encode(#bind_ident, __encoder),\n                             ) {\n@@ -260,7 +258,7 @@ fn encodable_body(\n                 result\n             });\n             quote! {\n-                ::rustc_serialize::Encoder::emit_enum(__encoder, #ty_name, |__encoder| {\n+                ::rustc_serialize::Encoder::emit_enum(__encoder, |__encoder| {\n                     match *self {\n                         #encode_inner\n                     }"}, {"sha": "73c00fc49ba39c7794becf632ae0a8d1a9daa973", "filename": "compiler/rustc_query_system/src/dep_graph/serialized.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fserialized.rs?ref=a2c4affe860ec53647b902f257e7e575f0350854", "patch": "@@ -122,21 +122,21 @@ impl<'a, K: DepKind + Decodable<opaque::Decoder<'a>>> Decodable<opaque::Decoder<\n         let mut edge_list_data = Vec::with_capacity(edge_count);\n \n         for _index in 0..node_count {\n-            d.read_struct(\"NodeInfo\", 3, |d| {\n-                let dep_node: DepNode<K> = d.read_struct_field(\"node\", 0, Decodable::decode)?;\n+            d.read_struct(|d| {\n+                let dep_node: DepNode<K> = d.read_struct_field(\"node\", Decodable::decode)?;\n                 let _i: SerializedDepNodeIndex = nodes.push(dep_node);\n                 debug_assert_eq!(_i.index(), _index);\n \n                 let fingerprint: Fingerprint =\n-                    d.read_struct_field(\"fingerprint\", 1, Decodable::decode)?;\n+                    d.read_struct_field(\"fingerprint\", Decodable::decode)?;\n                 let _i: SerializedDepNodeIndex = fingerprints.push(fingerprint);\n                 debug_assert_eq!(_i.index(), _index);\n \n-                d.read_struct_field(\"edges\", 2, |d| {\n+                d.read_struct_field(\"edges\", |d| {\n                     d.read_seq(|d, len| {\n                         let start = edge_list_data.len().try_into().unwrap();\n-                        for e in 0..len {\n-                            let edge = d.read_seq_elt(e, Decodable::decode)?;\n+                        for _ in 0..len {\n+                            let edge = d.read_seq_elt(Decodable::decode)?;\n                             edge_list_data.push(edge);\n                         }\n                         let end = edge_list_data.len().try_into().unwrap();"}, {"sha": "80a7f650188803f0e9a3a99ffdee40c5648b3604", "filename": "compiler/rustc_serialize/src/collection_impls.rs", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fcollection_impls.rs?ref=a2c4affe860ec53647b902f257e7e575f0350854", "patch": "@@ -21,8 +21,8 @@ impl<D: Decoder, A: Array<Item: Decodable<D>>> Decodable<D> for SmallVec<A> {\n         d.read_seq(|d, len| {\n             let mut vec = SmallVec::with_capacity(len);\n             // FIXME(#48994) - could just be collected into a Result<SmallVec, D::Error>\n-            for i in 0..len {\n-                vec.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                vec.push(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(vec)\n         })\n@@ -44,8 +44,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for LinkedList<T> {\n     fn decode(d: &mut D) -> Result<LinkedList<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut list = LinkedList::new();\n-            for i in 0..len {\n-                list.push_back(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                list.push_back(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(list)\n         })\n@@ -67,8 +67,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for VecDeque<T> {\n     fn decode(d: &mut D) -> Result<VecDeque<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut deque: VecDeque<T> = VecDeque::with_capacity(len);\n-            for i in 0..len {\n-                deque.push_back(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                deque.push_back(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(deque)\n         })\n@@ -84,7 +84,7 @@ where\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(i, |e| val.encode(e))?;\n+                e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n         })\n@@ -99,9 +99,9 @@ where\n     fn decode(d: &mut D) -> Result<BTreeMap<K, V>, D::Error> {\n         d.read_map(|d, len| {\n             let mut map = BTreeMap::new();\n-            for i in 0..len {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n+            for _ in 0..len {\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n                 map.insert(key, val);\n             }\n             Ok(map)\n@@ -130,8 +130,8 @@ where\n     fn decode(d: &mut D) -> Result<BTreeSet<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut set = BTreeSet::new();\n-            for i in 0..len {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(set)\n         })\n@@ -148,7 +148,7 @@ where\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(i, |e| val.encode(e))?;\n+                e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n         })\n@@ -165,9 +165,9 @@ where\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = HashMap::with_capacity_and_hasher(len, state);\n-            for i in 0..len {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n+            for _ in 0..len {\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n                 map.insert(key, val);\n             }\n             Ok(map)\n@@ -209,8 +209,8 @@ where\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = HashSet::with_capacity_and_hasher(len, state);\n-            for i in 0..len {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(set)\n         })\n@@ -227,7 +227,7 @@ where\n         e.emit_map(self.len(), |e| {\n             for (i, (key, val)) in self.iter().enumerate() {\n                 e.emit_map_elt_key(i, |e| key.encode(e))?;\n-                e.emit_map_elt_val(i, |e| val.encode(e))?;\n+                e.emit_map_elt_val(|e| val.encode(e))?;\n             }\n             Ok(())\n         })\n@@ -244,9 +244,9 @@ where\n         d.read_map(|d, len| {\n             let state = Default::default();\n             let mut map = indexmap::IndexMap::with_capacity_and_hasher(len, state);\n-            for i in 0..len {\n-                let key = d.read_map_elt_key(i, |d| Decodable::decode(d))?;\n-                let val = d.read_map_elt_val(i, |d| Decodable::decode(d))?;\n+            for _ in 0..len {\n+                let key = d.read_map_elt_key(|d| Decodable::decode(d))?;\n+                let val = d.read_map_elt_val(|d| Decodable::decode(d))?;\n                 map.insert(key, val);\n             }\n             Ok(map)\n@@ -278,8 +278,8 @@ where\n         d.read_seq(|d, len| {\n             let state = Default::default();\n             let mut set = indexmap::IndexSet::with_capacity_and_hasher(len, state);\n-            for i in 0..len {\n-                set.insert(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                set.insert(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(set)\n         })"}, {"sha": "b79adb6f7bcd92a5d2bb4287c018c3bfa84e2638", "filename": "compiler/rustc_serialize/src/json.rs", "status": "modified", "additions": 24, "deletions": 147, "changes": 171, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fjson.rs?ref=a2c4affe860ec53647b902f257e7e575f0350854", "patch": "@@ -560,7 +560,7 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n+    fn emit_enum<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -589,46 +589,20 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+    fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        if idx != 0 {\n+        if !first {\n             write!(self.writer, \",\")?;\n         }\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant<F>(\n-        &mut self,\n-        name: &str,\n-        id: usize,\n-        cnt: usize,\n-        f: F,\n-    ) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_enum_variant(name, id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: &str, _: usize, f: F) -> EncodeResult\n+    fn emit_struct<F>(&mut self, _: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -641,14 +615,14 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult\n+    fn emit_struct_field<F>(&mut self, name: &str, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        if idx != 0 {\n+        if !first {\n             write!(self.writer, \",\")?;\n         }\n         escape_str(self.writer, name)?;\n@@ -675,25 +649,6 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n     fn emit_option<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n@@ -774,7 +729,7 @@ impl<'a> crate::Encoder for Encoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+    fn emit_map_elt_val<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut Encoder<'a>) -> EncodeResult,\n     {\n@@ -892,7 +847,7 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> EncodeResult\n+    fn emit_enum<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n@@ -930,54 +885,28 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         }\n     }\n \n-    fn emit_enum_variant_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n+    fn emit_enum_variant_arg<F>(&mut self, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        if idx != 0 {\n+        if !first {\n             writeln!(self.writer, \",\")?;\n         }\n         spaces(self.writer, self.curr_indent)?;\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant<F>(\n-        &mut self,\n-        name: &str,\n-        id: usize,\n-        cnt: usize,\n-        f: F,\n-    ) -> EncodeResult\n+    fn emit_struct<F>(&mut self, no_fields: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        self.emit_enum_variant(name, id, cnt, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(&mut self, _: &str, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_enum_variant_arg(idx, f)\n-    }\n-\n-    fn emit_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        if len == 0 {\n+        if no_fields {\n             write!(self.writer, \"{{}}\")?;\n         } else {\n             write!(self.writer, \"{{\")?;\n@@ -991,14 +920,14 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_struct_field<F>(&mut self, name: &str, idx: usize, f: F) -> EncodeResult\n+    fn emit_struct_field<F>(&mut self, name: &str, first: bool, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n         if self.is_emitting_map_key {\n             return Err(EncoderError::BadHashmapKey);\n         }\n-        if idx == 0 {\n+        if first {\n             writeln!(self.writer)?;\n         } else {\n             writeln!(self.writer, \",\")?;\n@@ -1028,25 +957,6 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         self.emit_seq_elt(idx, f)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _: &str, len: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq(len, f)\n-    }\n-    fn emit_tuple_struct_arg<F>(&mut self, idx: usize, f: F) -> EncodeResult\n-    where\n-        F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n-    {\n-        if self.is_emitting_map_key {\n-            return Err(EncoderError::BadHashmapKey);\n-        }\n-        self.emit_seq_elt(idx, f)\n-    }\n-\n     fn emit_option<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n@@ -1149,7 +1059,7 @@ impl<'a> crate::Encoder for PrettyEncoder<'a> {\n         Ok(())\n     }\n \n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> EncodeResult\n+    fn emit_map_elt_val<F>(&mut self, f: F) -> EncodeResult\n     where\n         F: FnOnce(&mut PrettyEncoder<'a>) -> EncodeResult,\n     {\n@@ -2373,7 +2283,7 @@ impl crate::Decoder for Decoder {\n         Ok(())\n     }\n \n-    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> DecodeResult<T>\n+    fn read_enum<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n@@ -2410,33 +2320,14 @@ impl crate::Decoder for Decoder {\n         f(self, idx)\n     }\n \n-    fn read_enum_variant_arg<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n-    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> DecodeResult<T>\n-    where\n-        F: FnMut(&mut Decoder, usize) -> DecodeResult<T>,\n-    {\n-        self.read_enum_variant(names, f)\n-    }\n-\n-    fn read_enum_struct_variant_field<T, F>(\n-        &mut self,\n-        _name: &str,\n-        idx: usize,\n-        f: F,\n-    ) -> DecodeResult<T>\n-    where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n-    {\n-        self.read_enum_variant_arg(idx, f)\n-    }\n-\n-    fn read_struct<T, F>(&mut self, _name: &str, _len: usize, f: F) -> DecodeResult<T>\n+    fn read_struct<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n@@ -2445,7 +2336,7 @@ impl crate::Decoder for Decoder {\n         Ok(value)\n     }\n \n-    fn read_struct_field<T, F>(&mut self, name: &str, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_struct_field<T, F>(&mut self, name: &str, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n@@ -2483,25 +2374,11 @@ impl crate::Decoder for Decoder {\n         })\n     }\n \n-    fn read_tuple_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n-    where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n-    {\n-        self.read_seq_elt(idx, f)\n-    }\n-\n-    fn read_tuple_struct<T, F>(&mut self, _name: &str, len: usize, f: F) -> DecodeResult<T>\n-    where\n-        F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n-    {\n-        self.read_tuple(len, f)\n-    }\n-\n-    fn read_tuple_struct_arg<T, F>(&mut self, idx: usize, f: F) -> DecodeResult<T>\n+    fn read_tuple_arg<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n-        self.read_tuple_arg(idx, f)\n+        self.read_seq_elt(f)\n     }\n \n     fn read_option<T, F>(&mut self, mut f: F) -> DecodeResult<T>\n@@ -2527,7 +2404,7 @@ impl crate::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_seq_elt<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n@@ -2547,14 +2424,14 @@ impl crate::Decoder for Decoder {\n         f(self, len)\n     }\n \n-    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_map_elt_key<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {\n         f(self)\n     }\n \n-    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> DecodeResult<T>\n+    fn read_map_elt_val<T, F>(&mut self, f: F) -> DecodeResult<T>\n     where\n         F: FnOnce(&mut Decoder) -> DecodeResult<T>,\n     {"}, {"sha": "bb3c537ef1949c024637efa50612078c794854d0", "filename": "compiler/rustc_serialize/src/serialize.rs", "status": "modified", "additions": 25, "deletions": 108, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_serialize%2Fsrc%2Fserialize.rs?ref=a2c4affe860ec53647b902f257e7e575f0350854", "patch": "@@ -37,7 +37,7 @@ pub trait Encoder {\n \n     // Compound types:\n     #[inline]\n-    fn emit_enum<F>(&mut self, _name: &str, f: F) -> Result<(), Self::Error>\n+    fn emit_enum<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -59,53 +59,23 @@ pub trait Encoder {\n     }\n \n     #[inline]\n-    fn emit_enum_variant_arg<F>(&mut self, _a_idx: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_enum_variant_arg<F>(&mut self, _first: bool, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n         f(self)\n     }\n \n-    fn emit_enum_struct_variant<F>(\n-        &mut self,\n-        v_name: &str,\n-        v_id: usize,\n-        len: usize,\n-        f: F,\n-    ) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_enum_variant(v_name, v_id, len, f)\n-    }\n-\n-    fn emit_enum_struct_variant_field<F>(\n-        &mut self,\n-        _f_name: &str,\n-        f_idx: usize,\n-        f: F,\n-    ) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_enum_variant_arg(f_idx, f)\n-    }\n-\n     #[inline]\n-    fn emit_struct<F>(&mut self, _name: &str, _len: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_struct<F>(&mut self, _no_fields: bool, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn emit_struct_field<F>(\n-        &mut self,\n-        _f_name: &str,\n-        _f_idx: usize,\n-        f: F,\n-    ) -> Result<(), Self::Error>\n+    fn emit_struct_field<F>(&mut self, _f_name: &str, _first: bool, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -128,26 +98,12 @@ pub trait Encoder {\n         f(self)\n     }\n \n-    fn emit_tuple_struct<F>(&mut self, _name: &str, len: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_tuple(len, f)\n-    }\n-\n-    fn emit_tuple_struct_arg<F>(&mut self, f_idx: usize, f: F) -> Result<(), Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n-    {\n-        self.emit_tuple_arg(f_idx, f)\n-    }\n-\n     // Specialized types:\n     fn emit_option<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n-        self.emit_enum(\"Option\", f)\n+        self.emit_enum(f)\n     }\n \n     #[inline]\n@@ -195,7 +151,7 @@ pub trait Encoder {\n     }\n \n     #[inline]\n-    fn emit_map_elt_val<F>(&mut self, _idx: usize, f: F) -> Result<(), Self::Error>\n+    fn emit_map_elt_val<F>(&mut self, f: F) -> Result<(), Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<(), Self::Error>,\n     {\n@@ -229,7 +185,7 @@ pub trait Decoder {\n \n     // Compound types:\n     #[inline]\n-    fn read_enum<T, F>(&mut self, _name: &str, f: F) -> Result<T, Self::Error>\n+    fn read_enum<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n@@ -246,47 +202,23 @@ pub trait Decoder {\n     }\n \n     #[inline]\n-    fn read_enum_variant_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_enum_variant_arg<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n         f(self)\n     }\n \n-    fn read_enum_struct_variant<T, F>(&mut self, names: &[&str], f: F) -> Result<T, Self::Error>\n-    where\n-        F: FnMut(&mut Self, usize) -> Result<T, Self::Error>,\n-    {\n-        self.read_enum_variant(names, f)\n-    }\n-\n-    fn read_enum_struct_variant_field<T, F>(\n-        &mut self,\n-        _f_name: &str,\n-        f_idx: usize,\n-        f: F,\n-    ) -> Result<T, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n-    {\n-        self.read_enum_variant_arg(f_idx, f)\n-    }\n-\n     #[inline]\n-    fn read_struct<T, F>(&mut self, _s_name: &str, _len: usize, f: F) -> Result<T, Self::Error>\n+    fn read_struct<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_struct_field<T, F>(\n-        &mut self,\n-        _f_name: &str,\n-        _f_idx: usize,\n-        f: F,\n-    ) -> Result<T, Self::Error>\n+    fn read_struct_field<T, F>(&mut self, _f_name: &str, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n@@ -302,33 +234,19 @@ pub trait Decoder {\n     }\n \n     #[inline]\n-    fn read_tuple_arg<T, F>(&mut self, _a_idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_tuple_arg<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n         f(self)\n     }\n \n-    fn read_tuple_struct<T, F>(&mut self, _s_name: &str, len: usize, f: F) -> Result<T, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n-    {\n-        self.read_tuple(len, f)\n-    }\n-\n-    fn read_tuple_struct_arg<T, F>(&mut self, a_idx: usize, f: F) -> Result<T, Self::Error>\n-    where\n-        F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n-    {\n-        self.read_tuple_arg(a_idx, f)\n-    }\n-\n     // Specialized types:\n     fn read_option<T, F>(&mut self, mut f: F) -> Result<T, Self::Error>\n     where\n         F: FnMut(&mut Self, bool) -> Result<T, Self::Error>,\n     {\n-        self.read_enum(\"Option\", move |this| {\n+        self.read_enum(move |this| {\n             this.read_enum_variant(&[\"None\", \"Some\"], move |this, idx| match idx {\n                 0 => f(this, false),\n                 1 => f(this, true),\n@@ -346,7 +264,7 @@ pub trait Decoder {\n     }\n \n     #[inline]\n-    fn read_seq_elt<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_seq_elt<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n@@ -362,15 +280,15 @@ pub trait Decoder {\n     }\n \n     #[inline]\n-    fn read_map_elt_key<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_map_elt_key<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n         f(self)\n     }\n \n     #[inline]\n-    fn read_map_elt_val<T, F>(&mut self, _idx: usize, f: F) -> Result<T, Self::Error>\n+    fn read_map_elt_val<T, F>(&mut self, f: F) -> Result<T, Self::Error>\n     where\n         F: FnOnce(&mut Self) -> Result<T, Self::Error>,\n     {\n@@ -550,8 +468,8 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Vec<T> {\n     default fn decode(d: &mut D) -> Result<Vec<T>, D::Error> {\n         d.read_seq(|d, len| {\n             let mut v = Vec::with_capacity(len);\n-            for i in 0..len {\n-                v.push(d.read_seq_elt(i, |d| Decodable::decode(d))?);\n+            for _ in 0..len {\n+                v.push(d.read_seq_elt(|d| Decodable::decode(d))?);\n             }\n             Ok(v)\n         })\n@@ -571,7 +489,7 @@ impl<D: Decoder, const N: usize> Decodable<D> for [u8; N] {\n             assert!(len == N);\n             let mut v = [0u8; N];\n             for i in 0..len {\n-                v[i] = d.read_seq_elt(i, |d| Decodable::decode(d))?;\n+                v[i] = d.read_seq_elt(|d| Decodable::decode(d))?;\n             }\n             Ok(v)\n         })\n@@ -615,23 +533,23 @@ impl<D: Decoder, T: Decodable<D>> Decodable<D> for Option<T> {\n \n impl<S: Encoder, T1: Encodable<S>, T2: Encodable<S>> Encodable<S> for Result<T1, T2> {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_enum(\"Result\", |s| match *self {\n+        s.emit_enum(|s| match *self {\n             Ok(ref v) => {\n-                s.emit_enum_variant(\"Ok\", 0, 1, |s| s.emit_enum_variant_arg(0, |s| v.encode(s)))\n+                s.emit_enum_variant(\"Ok\", 0, 1, |s| s.emit_enum_variant_arg(true, |s| v.encode(s)))\n             }\n             Err(ref v) => {\n-                s.emit_enum_variant(\"Err\", 1, 1, |s| s.emit_enum_variant_arg(0, |s| v.encode(s)))\n+                s.emit_enum_variant(\"Err\", 1, 1, |s| s.emit_enum_variant_arg(true, |s| v.encode(s)))\n             }\n         })\n     }\n }\n \n impl<D: Decoder, T1: Decodable<D>, T2: Decodable<D>> Decodable<D> for Result<T1, T2> {\n     fn decode(d: &mut D) -> Result<Result<T1, T2>, D::Error> {\n-        d.read_enum(\"Result\", |d| {\n+        d.read_enum(|d| {\n             d.read_enum_variant(&[\"Ok\", \"Err\"], |d, disr| match disr {\n-                0 => Ok(Ok(d.read_enum_variant_arg(0, |d| T1::decode(d))?)),\n-                1 => Ok(Err(d.read_enum_variant_arg(0, |d| T2::decode(d))?)),\n+                0 => Ok(Ok(d.read_enum_variant_arg(|d| T1::decode(d))?)),\n+                1 => Ok(Err(d.read_enum_variant_arg(|d| T2::decode(d))?)),\n                 _ => {\n                     panic!(\n                         \"Encountered invalid discriminant while \\\n@@ -668,8 +586,7 @@ macro_rules! tuple {\n             fn decode(d: &mut D) -> Result<($($name,)+), D::Error> {\n                 let len: usize = count!($($name)+);\n                 d.read_tuple(len, |d| {\n-                    let mut i = 0;\n-                    let ret = ($(d.read_tuple_arg({ i+=1; i-1 }, |d| -> Result<$name, D::Error> {\n+                    let ret = ($(d.read_tuple_arg(|d| -> Result<$name, D::Error> {\n                         Decodable::decode(d)\n                     })?,)+);\n                     Ok(ret)"}, {"sha": "02b20d03a574aa19f7a56b6ca6f9f2147e53ee2f", "filename": "compiler/rustc_span/src/def_id.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fdef_id.rs?ref=a2c4affe860ec53647b902f257e7e575f0350854", "patch": "@@ -295,20 +295,20 @@ impl DefId {\n \n impl<E: Encoder> Encodable<E> for DefId {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n-        s.emit_struct(\"DefId\", 2, |s| {\n-            s.emit_struct_field(\"krate\", 0, |s| self.krate.encode(s))?;\n+        s.emit_struct(false, |s| {\n+            s.emit_struct_field(\"krate\", true, |s| self.krate.encode(s))?;\n \n-            s.emit_struct_field(\"index\", 1, |s| self.index.encode(s))\n+            s.emit_struct_field(\"index\", false, |s| self.index.encode(s))\n         })\n     }\n }\n \n impl<D: Decoder> Decodable<D> for DefId {\n     default fn decode(d: &mut D) -> Result<DefId, D::Error> {\n-        d.read_struct(\"DefId\", 2, |d| {\n+        d.read_struct(|d| {\n             Ok(DefId {\n-                krate: d.read_struct_field(\"krate\", 0, Decodable::decode)?,\n-                index: d.read_struct_field(\"index\", 1, Decodable::decode)?,\n+                krate: d.read_struct_field(\"krate\", Decodable::decode)?,\n+                index: d.read_struct_field(\"index\", Decodable::decode)?,\n             })\n         })\n     }"}, {"sha": "74a5eded650f3278df74eff20892fb1e2103ffc8", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 35, "deletions": 33, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a2c4affe860ec53647b902f257e7e575f0350854/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=a2c4affe860ec53647b902f257e7e575f0350854", "patch": "@@ -146,11 +146,12 @@ impl Hash for RealFileName {\n // an added assert statement\n impl<S: Encoder> Encodable<S> for RealFileName {\n     fn encode(&self, encoder: &mut S) -> Result<(), S::Error> {\n-        encoder.emit_enum(\"RealFileName\", |encoder| match *self {\n+        encoder.emit_enum(|encoder| match *self {\n             RealFileName::LocalPath(ref local_path) => {\n                 encoder.emit_enum_variant(\"LocalPath\", 0, 1, |encoder| {\n                     Ok({\n-                        encoder.emit_enum_variant_arg(0, |encoder| local_path.encode(encoder))?;\n+                        encoder\n+                            .emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n                     })\n                 })\n             }\n@@ -161,8 +162,10 @@ impl<S: Encoder> Encodable<S> for RealFileName {\n                     // if they have been remapped by --remap-path-prefix\n                     assert!(local_path.is_none());\n                     Ok({\n-                        encoder.emit_enum_variant_arg(0, |encoder| local_path.encode(encoder))?;\n-                        encoder.emit_enum_variant_arg(1, |encoder| virtual_name.encode(encoder))?;\n+                        encoder\n+                            .emit_enum_variant_arg(true, |encoder| local_path.encode(encoder))?;\n+                        encoder\n+                            .emit_enum_variant_arg(false, |encoder| virtual_name.encode(encoder))?;\n                     })\n                 }),\n         })\n@@ -827,17 +830,17 @@ impl Default for Span {\n impl<E: Encoder> Encodable<E> for Span {\n     default fn encode(&self, s: &mut E) -> Result<(), E::Error> {\n         let span = self.data();\n-        s.emit_struct(\"Span\", 2, |s| {\n-            s.emit_struct_field(\"lo\", 0, |s| span.lo.encode(s))?;\n-            s.emit_struct_field(\"hi\", 1, |s| span.hi.encode(s))\n+        s.emit_struct(false, |s| {\n+            s.emit_struct_field(\"lo\", true, |s| span.lo.encode(s))?;\n+            s.emit_struct_field(\"hi\", false, |s| span.hi.encode(s))\n         })\n     }\n }\n impl<D: Decoder> Decodable<D> for Span {\n     default fn decode(s: &mut D) -> Result<Span, D::Error> {\n-        s.read_struct(\"Span\", 2, |d| {\n-            let lo = d.read_struct_field(\"lo\", 0, Decodable::decode)?;\n-            let hi = d.read_struct_field(\"hi\", 1, Decodable::decode)?;\n+        s.read_struct(|d| {\n+            let lo = d.read_struct_field(\"lo\", Decodable::decode)?;\n+            let hi = d.read_struct_field(\"hi\", Decodable::decode)?;\n \n             Ok(Span::new(lo, hi, SyntaxContext::root()))\n         })\n@@ -1234,12 +1237,12 @@ pub struct SourceFile {\n \n impl<S: Encoder> Encodable<S> for SourceFile {\n     fn encode(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_struct(\"SourceFile\", 8, |s| {\n-            s.emit_struct_field(\"name\", 0, |s| self.name.encode(s))?;\n-            s.emit_struct_field(\"src_hash\", 2, |s| self.src_hash.encode(s))?;\n-            s.emit_struct_field(\"start_pos\", 3, |s| self.start_pos.encode(s))?;\n-            s.emit_struct_field(\"end_pos\", 4, |s| self.end_pos.encode(s))?;\n-            s.emit_struct_field(\"lines\", 5, |s| {\n+        s.emit_struct(false, |s| {\n+            s.emit_struct_field(\"name\", true, |s| self.name.encode(s))?;\n+            s.emit_struct_field(\"src_hash\", false, |s| self.src_hash.encode(s))?;\n+            s.emit_struct_field(\"start_pos\", false, |s| self.start_pos.encode(s))?;\n+            s.emit_struct_field(\"end_pos\", false, |s| self.end_pos.encode(s))?;\n+            s.emit_struct_field(\"lines\", false, |s| {\n                 let lines = &self.lines[..];\n                 // Store the length.\n                 s.emit_u32(lines.len() as u32)?;\n@@ -1297,25 +1300,24 @@ impl<S: Encoder> Encodable<S> for SourceFile {\n \n                 Ok(())\n             })?;\n-            s.emit_struct_field(\"multibyte_chars\", 6, |s| self.multibyte_chars.encode(s))?;\n-            s.emit_struct_field(\"non_narrow_chars\", 7, |s| self.non_narrow_chars.encode(s))?;\n-            s.emit_struct_field(\"name_hash\", 8, |s| self.name_hash.encode(s))?;\n-            s.emit_struct_field(\"normalized_pos\", 9, |s| self.normalized_pos.encode(s))?;\n-            s.emit_struct_field(\"cnum\", 10, |s| self.cnum.encode(s))\n+            s.emit_struct_field(\"multibyte_chars\", false, |s| self.multibyte_chars.encode(s))?;\n+            s.emit_struct_field(\"non_narrow_chars\", false, |s| self.non_narrow_chars.encode(s))?;\n+            s.emit_struct_field(\"name_hash\", false, |s| self.name_hash.encode(s))?;\n+            s.emit_struct_field(\"normalized_pos\", false, |s| self.normalized_pos.encode(s))?;\n+            s.emit_struct_field(\"cnum\", false, |s| self.cnum.encode(s))\n         })\n     }\n }\n \n impl<D: Decoder> Decodable<D> for SourceFile {\n     fn decode(d: &mut D) -> Result<SourceFile, D::Error> {\n-        d.read_struct(\"SourceFile\", 8, |d| {\n-            let name: FileName = d.read_struct_field(\"name\", 0, |d| Decodable::decode(d))?;\n+        d.read_struct(|d| {\n+            let name: FileName = d.read_struct_field(\"name\", |d| Decodable::decode(d))?;\n             let src_hash: SourceFileHash =\n-                d.read_struct_field(\"src_hash\", 2, |d| Decodable::decode(d))?;\n-            let start_pos: BytePos =\n-                d.read_struct_field(\"start_pos\", 3, |d| Decodable::decode(d))?;\n-            let end_pos: BytePos = d.read_struct_field(\"end_pos\", 4, |d| Decodable::decode(d))?;\n-            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", 5, |d| {\n+                d.read_struct_field(\"src_hash\", |d| Decodable::decode(d))?;\n+            let start_pos: BytePos = d.read_struct_field(\"start_pos\", |d| Decodable::decode(d))?;\n+            let end_pos: BytePos = d.read_struct_field(\"end_pos\", |d| Decodable::decode(d))?;\n+            let lines: Vec<BytePos> = d.read_struct_field(\"lines\", |d| {\n                 let num_lines: u32 = Decodable::decode(d)?;\n                 let mut lines = Vec::with_capacity(num_lines as usize);\n \n@@ -1344,13 +1346,13 @@ impl<D: Decoder> Decodable<D> for SourceFile {\n                 Ok(lines)\n             })?;\n             let multibyte_chars: Vec<MultiByteChar> =\n-                d.read_struct_field(\"multibyte_chars\", 6, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"multibyte_chars\", |d| Decodable::decode(d))?;\n             let non_narrow_chars: Vec<NonNarrowChar> =\n-                d.read_struct_field(\"non_narrow_chars\", 7, |d| Decodable::decode(d))?;\n-            let name_hash: u128 = d.read_struct_field(\"name_hash\", 8, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"non_narrow_chars\", |d| Decodable::decode(d))?;\n+            let name_hash: u128 = d.read_struct_field(\"name_hash\", |d| Decodable::decode(d))?;\n             let normalized_pos: Vec<NormalizedPos> =\n-                d.read_struct_field(\"normalized_pos\", 9, |d| Decodable::decode(d))?;\n-            let cnum: CrateNum = d.read_struct_field(\"cnum\", 10, |d| Decodable::decode(d))?;\n+                d.read_struct_field(\"normalized_pos\", |d| Decodable::decode(d))?;\n+            let cnum: CrateNum = d.read_struct_field(\"cnum\", |d| Decodable::decode(d))?;\n             Ok(SourceFile {\n                 name,\n                 start_pos,"}]}