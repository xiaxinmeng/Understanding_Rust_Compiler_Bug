{"sha": "517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxN2MyOGU0MjFiMGQ2MDFjNmY4ZWIwN2VhNmFhZmI4ZTE2OTc1YWQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-26T22:26:23Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-26T22:26:23Z"}, "message": "Auto merge of #87280 - lcnr:lazy-anon-const-default-substs, r=nikomatsakis\n\nlazily \"compute\" anon const default substs\n\nContinuing the work of #83086, this implements the discussed solution for the [unused substs problem](https://github.com/rust-lang/project-const-generics/blob/master/design-docs/anon-const-substs.md#unused-substs). As of now, anonymous constants inherit all of their parents generics, even if they do not use them, e.g. in `fn foo<T, const N: usize>() -> [T; N + 1]`, the array length has `T` as a generic parameter even though it doesn't use it. These *unused substs* cause some backwards incompatible, and imo incorrect behavior, e.g. #78369.\n\n---\nWe do not actually filter any generic parameters here and the `default_anon_const_substs` query still a dummy which only checks that\n- we now prevent the previously existing query cycles and are able to call `predicates_of(parent)` when computing the substs of anonymous constants\n- the default anon consts substs only include the typeflags we assume it does.\n\nImplementing that filtering will be left as future work.\n\n---\n\nThe idea of this PR is to delay the creation of the anon const substs until after we've computed `predicates_of` for the parent of the anon const. As the predicates of the parent can however contain the anon const we still have to create a `ty::Const` for it.\n\nWe do this by changing the substs field of `ty::Unevaluated` to an option and modifying accesses to instead call the method `unevaluated.substs(tcx)` which returns the substs as before. If the substs - now `substs_` -  of `ty::Unevaluated` are `None`, it means that the anon const currently has its default substs, i.e. the substs it has when first constructed, which are the generic parameters it has available. To be able to call `unevaluated.substs(tcx)` in a `TypeVisitor`, we add the non-defaulted method `fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>>`. In case `tcx_for_anon_const_substs` returns `None`, unknown anon const default substs are skipped entirely.\n\nEven when `substs_` is `None` we still have to treat the constant as if it has its default substs. To do this, `TypeFlags` are modified so that it is clear whether they can still change when *exposing* any anon const default substs. A new flag, `HAS_UNKNOWN_DEFAULT_CONST_SUBSTS`, is added in case some default flags are missing.\n\nThe rest of this PR are some smaller changes to either not cause cycles by trying to access the default anon const substs too early or to be able to access the `tcx` in previously unused locations.\n\ncc `@rust-lang/project-const-generics`\nr? `@nikomatsakis`", "tree": {"sha": "274199dcdca33882f75448d58ebec4109d2151ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/274199dcdca33882f75448d58ebec4109d2151ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "html_url": "https://github.com/rust-lang/rust/commit/517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ad02dc46badee510bd3a2c093edf80fcaade91b1", "url": "https://api.github.com/repos/rust-lang/rust/commits/ad02dc46badee510bd3a2c093edf80fcaade91b1", "html_url": "https://github.com/rust-lang/rust/commit/ad02dc46badee510bd3a2c093edf80fcaade91b1"}, {"sha": "7cbfa2ee330b6e389027c6276df0f0f9b62fc76b", "url": "https://api.github.com/repos/rust-lang/rust/commits/7cbfa2ee330b6e389027c6276df0f0f9b62fc76b", "html_url": "https://github.com/rust-lang/rust/commit/7cbfa2ee330b6e389027c6276df0f0f9b62fc76b"}], "stats": {"total": 1544, "additions": 1023, "deletions": 521}, "files": [{"sha": "424a0d742d12b56c29b4b40339faedb7d6b204dd", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -129,13 +129,13 @@ pub(crate) fn codegen_constant<'tcx>(\n     };\n     let const_val = match const_.val {\n         ConstKind::Value(const_val) => const_val,\n-        ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n-            if fx.tcx.is_static(def.did) =>\n+        ConstKind::Unevaluated(uv)\n+            if fx.tcx.is_static(uv.def.did) =>\n         {\n-            assert!(substs.is_empty());\n-            assert!(promoted.is_none());\n+            assert!(uv.substs(fx.tcx).is_empty());\n+            assert!(uv.promoted.is_none());\n \n-            return codegen_static_ref(fx, def.did, fx.layout_of(const_.ty)).to_cvalue(fx);\n+            return codegen_static_ref(fx, uv.def.did, fx.layout_of(const_.ty)).to_cvalue(fx);\n         }\n         ConstKind::Unevaluated(unevaluated) => {\n             match fx.tcx.const_eval_resolve(ParamEnv::reveal_all(), unevaluated, None) {"}, {"sha": "914376d58ddeeb4e7dfcc089d78df300c1d9cff7", "filename": "compiler/rustc_codegen_llvm/src/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fdebuginfo%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -499,7 +499,7 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n                         ty::Adt(def, ..) if !def.is_box() => {\n                             // Again, only create type information if full debuginfo is enabled\n                             if cx.sess().opts.debuginfo == DebugInfo::Full\n-                                && !impl_self_ty.needs_subst()\n+                                && !impl_self_ty.definitely_needs_subst(cx.tcx)\n                             {\n                                 Some(type_metadata(cx, impl_self_ty, rustc_span::DUMMY_SP))\n                             } else {"}, {"sha": "673d348a2a89c377b3af1602e44cc1156579f775", "filename": "compiler/rustc_codegen_ssa/src/mir/block.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fblock.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1398,7 +1398,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),\n                 LocalRef::Operand(None) => {\n                     let dst_layout = bx.layout_of(self.monomorphized_place_ty(dst.as_ref()));\n-                    assert!(!dst_layout.ty.has_erasable_regions());\n+                    assert!(!dst_layout.ty.has_erasable_regions(self.cx.tcx()));\n                     let place = PlaceRef::alloca(bx, dst_layout);\n                     place.storage_live(bx);\n                     self.codegen_transmute_into(bx, src, place);"}, {"sha": "e2edd448267175974d734b913086e88f43ebac16", "filename": "compiler/rustc_codegen_ssa/src/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -216,7 +216,7 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         let mut allocate_local = |local| {\n             let decl = &mir.local_decls[local];\n             let layout = bx.layout_of(fx.monomorphize(decl.ty));\n-            assert!(!layout.ty.has_erasable_regions());\n+            assert!(!layout.ty.has_erasable_regions(cx.tcx()));\n \n             if local == mir::RETURN_PLACE && fx.fn_abi.ret.is_indirect() {\n                 debug!(\"alloc: {:?} (return place) -> place\", local);"}, {"sha": "934ada9932e71ad91d9b737b0ed38ff145696d17", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -470,7 +470,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n     {\n         let needs_canonical_flags = if canonicalize_region_mode.any() {\n             TypeFlags::NEEDS_INFER |\n-            TypeFlags::HAS_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_FREE_REGIONS`\n+            TypeFlags::HAS_POTENTIAL_FREE_REGIONS | // `HAS_RE_PLACEHOLDER` implies `HAS_POTENTIAL_FREE_REGIONS`\n             TypeFlags::HAS_TY_PLACEHOLDER |\n             TypeFlags::HAS_CT_PLACEHOLDER\n         } else {"}, {"sha": "32308910aa7d9b4da96c8ae7a2edf80e6f874f79", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -129,6 +129,8 @@ impl<'infcx, 'tcx> InferCtxt<'infcx, 'tcx> {\n     where\n         R: ConstEquateRelation<'tcx>,\n     {\n+        let a = self.tcx.expose_default_const_substs(a);\n+        let b = self.tcx.expose_default_const_substs(b);\n         debug!(\"{}.consts({:?}, {:?})\", relation.tag(), a, b);\n         if a == b {\n             return Ok(a);\n@@ -742,10 +744,9 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                     }\n                 }\n             }\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n-                if self.tcx().lazy_normalization() =>\n-            {\n-                assert_eq!(promoted, None);\n+            ty::ConstKind::Unevaluated(uv) if self.tcx().lazy_normalization() => {\n+                assert_eq!(uv.promoted, None);\n+                let substs = uv.substs(self.tcx());\n                 let substs = self.relate_with_variance(\n                     ty::Variance::Invariant,\n                     ty::VarianceDiagInfo::default(),\n@@ -754,7 +755,7 @@ impl TypeRelation<'tcx> for Generalizer<'_, 'tcx> {\n                 )?;\n                 Ok(self.tcx().mk_const(ty::Const {\n                     ty: c.ty,\n-                    val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated::new(uv.def, substs)),\n                 }))\n             }\n             _ => relate::super_relate_consts(self, c, c),\n@@ -976,10 +977,9 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                     }\n                 }\n             }\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted })\n-                if self.tcx().lazy_normalization() =>\n-            {\n-                assert_eq!(promoted, None);\n+            ty::ConstKind::Unevaluated(uv) if self.tcx().lazy_normalization() => {\n+                assert_eq!(uv.promoted, None);\n+                let substs = uv.substs(self.tcx());\n                 let substs = self.relate_with_variance(\n                     ty::Variance::Invariant,\n                     ty::VarianceDiagInfo::default(),\n@@ -988,7 +988,7 @@ impl TypeRelation<'tcx> for ConstInferUnifier<'_, 'tcx> {\n                 )?;\n                 Ok(self.tcx().mk_const(ty::Const {\n                     ty: c.ty,\n-                    val: ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }),\n+                    val: ty::ConstKind::Unevaluated(ty::Unevaluated::new(uv.def, substs)),\n                 }))\n             }\n             _ => relate::super_relate_consts(self, c, c),"}, {"sha": "299dcf5f17a872150da795d97e390630a2206df3", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1537,6 +1537,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for OpaqueTypesVisitor<'tcx> {\n+            fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+                Some(self.tcx)\n+            }\n+\n             fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 if let Some((kind, def_id)) = TyCategory::from_ty(self.tcx, t) {\n                     let span = self.tcx.def_span(def_id);"}, {"sha": "e00003face9ced40b6f7d3e13367b05b4e7d68cc", "filename": "compiler/rustc_infer/src/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -51,7 +51,7 @@ impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n \n     fn node_ty_contains_target(&self, hir_id: HirId) -> Option<Ty<'tcx>> {\n         self.node_type_opt(hir_id).map(|ty| self.infcx.resolve_vars_if_possible(ty)).filter(|ty| {\n-            ty.walk().any(|inner| {\n+            ty.walk(self.infcx.tcx).any(|inner| {\n                 inner == self.target\n                     || match (inner.unpack(), self.target.unpack()) {\n                         (GenericArgKind::Type(inner_ty), GenericArgKind::Type(target_ty)) => {"}, {"sha": "81059fbcb10511265061f17010f237c9bdbf9229", "filename": "compiler/rustc_infer/src/infer/error_reporting/nice_region_error/static_impl_trait.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fnice_region_error%2Fstatic_impl_trait.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -9,7 +9,9 @@ use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder, ErrorRepor\n use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{walk_ty, ErasedMap, NestedVisitorMap, Visitor};\n use rustc_hir::{self as hir, GenericBound, Item, ItemKind, Lifetime, LifetimeName, Node, TyKind};\n-use rustc_middle::ty::{self, AssocItemContainer, RegionKind, Ty, TypeFoldable, TypeVisitor};\n+use rustc_middle::ty::{\n+    self, AssocItemContainer, RegionKind, Ty, TyCtxt, TypeFoldable, TypeVisitor,\n+};\n use rustc_span::symbol::Ident;\n use rustc_span::{MultiSpan, Span};\n \n@@ -476,8 +478,14 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n /// Collect all the trait objects in a type that could have received an implicit `'static` lifetime.\n pub(super) struct TraitObjectVisitor(pub(super) FxHashSet<DefId>);\n \n-impl TypeVisitor<'_> for TraitObjectVisitor {\n-    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n+impl<'tcx> TypeVisitor<'tcx> for TraitObjectVisitor {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        // The default anon const substs cannot include\n+        // trait objects, so we don't have to bother looking.\n+        None\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n             ty::Dynamic(preds, RegionKind::ReStatic) => {\n                 if let Some(def_id) = preds.principal_def_id() {"}, {"sha": "c40e409891bc25cb76a7612fbab231493c67de98", "filename": "compiler/rustc_infer/src/infer/freshen.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ffreshen.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -146,7 +146,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for TypeFreshener<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_infer() && !t.has_erasable_regions() {\n+        if !t.needs_infer() && !t.has_erasable_regions(self.tcx()) {\n             return t;\n         }\n "}, {"sha": "bc98a3aa3f95e563d1982137b0ac0e7b4e65d71a", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -675,13 +675,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     /// canonicalizing the consts.\n     pub fn try_unify_abstract_consts(\n         &self,\n-        a: ty::Unevaluated<'tcx>,\n-        b: ty::Unevaluated<'tcx>,\n+        a: ty::Unevaluated<'tcx, ()>,\n+        b: ty::Unevaluated<'tcx, ()>,\n     ) -> bool {\n-        let canonical = self.canonicalize_query(\n-            ((a.def, a.substs), (b.def, b.substs)),\n-            &mut OriginalQueryValues::default(),\n-        );\n+        let canonical = self.canonicalize_query((a, b), &mut OriginalQueryValues::default());\n         debug!(\"canonical consts: {:?}\", &canonical.value);\n \n         self.tcx.try_unify_abstract_consts(canonical.value)\n@@ -1592,16 +1589,16 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     pub fn const_eval_resolve(\n         &self,\n         param_env: ty::ParamEnv<'tcx>,\n-        ty::Unevaluated { def, substs, promoted }: ty::Unevaluated<'tcx>,\n+        unevaluated: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToConstValueResult<'tcx> {\n         let mut original_values = OriginalQueryValues::default();\n-        let canonical = self.canonicalize_query((param_env, substs), &mut original_values);\n+        let canonical = self.canonicalize_query((param_env, unevaluated), &mut original_values);\n \n-        let (param_env, substs) = canonical.value;\n+        let (param_env, unevaluated) = canonical.value;\n         // The return value is the evaluated value which doesn't contain any reference to inference\n         // variables, thus we don't need to substitute back the original values.\n-        self.tcx.const_eval_resolve(param_env, ty::Unevaluated { def, substs, promoted }, span)\n+        self.tcx.const_eval_resolve(param_env, unevaluated, span)\n     }\n \n     /// If `typ` is a type variable of some kind, resolve it one level"}, {"sha": "c211d8e94a68b1b05b2ba0f8bedb276c57d0f2ae", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -202,6 +202,7 @@ where\n         };\n \n         value.skip_binder().visit_with(&mut ScopeInstantiator {\n+            tcx: self.infcx.tcx,\n             next_region: &mut next_region,\n             target_index: ty::INNERMOST,\n             bound_region_scope: &mut scope,\n@@ -757,13 +758,18 @@ where\n /// `for<..`>.  For each of those, it creates an entry in\n /// `bound_region_scope`.\n struct ScopeInstantiator<'me, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     next_region: &'me mut dyn FnMut(ty::BoundRegion) -> ty::Region<'tcx>,\n     // The debruijn index of the scope we are instantiating.\n     target_index: ty::DebruijnIndex,\n     bound_region_scope: &'me mut BoundRegionScope<'tcx>,\n }\n \n impl<'me, 'tcx> TypeVisitor<'tcx> for ScopeInstantiator<'me, 'tcx> {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: &ty::Binder<'tcx, T>,"}, {"sha": "dba73251b4f0d44e9e8d68e3333c6f44181e38f5", "filename": "compiler/rustc_infer/src/infer/outlives/verify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fverify.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -189,7 +189,7 @@ impl<'cx, 'tcx> VerifyBoundCx<'cx, 'tcx> {\n         visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> VerifyBound<'tcx> {\n         let mut bounds = parent\n-            .walk_shallow(visited)\n+            .walk_shallow(self.tcx, visited)\n             .filter_map(|child| match child.unpack() {\n                 GenericArgKind::Type(ty) => Some(self.type_bound(ty, visited)),\n                 GenericArgKind::Lifetime(lt) => {"}, {"sha": "4b08c2eb9c19eee7d3bf9cc9327553a17d82518c", "filename": "compiler/rustc_infer/src/infer/resolve.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fresolve.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -126,6 +126,11 @@ impl<'a, 'tcx> UnresolvedTypeFinder<'a, 'tcx> {\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for UnresolvedTypeFinder<'a, 'tcx> {\n     type BreakTy = (Ty<'tcx>, Option<Span>);\n+\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.infcx.tcx)\n+    }\n+\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         let t = self.infcx.shallow_resolve(t);\n         if t.has_infer_types() {"}, {"sha": "8f848f54aad631a0beea2babf5537f27641319ab", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -152,8 +152,8 @@ declare_lint! {\n declare_lint_pass!(BoxPointers => [BOX_POINTERS]);\n \n impl BoxPointers {\n-    fn check_heap_type(&self, cx: &LateContext<'_>, span: Span, ty: Ty<'_>) {\n-        for leaf in ty.walk() {\n+    fn check_heap_type<'tcx>(&self, cx: &LateContext<'tcx>, span: Span, ty: Ty<'tcx>) {\n+        for leaf in ty.walk(cx.tcx) {\n             if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n                 if leaf_ty.is_box() {\n                     cx.struct_span_lint(BOX_POINTERS, span, |lint| {\n@@ -1656,7 +1656,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     ConstEquate(..) |\n                     TypeWellFormedFromEnv(..) => continue,\n                 };\n-                if predicate.is_global() {\n+                if predicate.is_global(cx.tcx) {\n                     cx.struct_span_lint(TRIVIAL_BOUNDS, span, |lint| {\n                         lint.build(&format!(\n                             \"{} bound {} does not depend on any type \\"}, {"sha": "c14f16b6d11ba8ab194d039d284d0d760017f25a", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n             _ => return,\n         };\n         let substs = cx.typeck_results().node_substs(expr.hir_id);\n-        if substs.needs_subst() {\n+        if substs.definitely_needs_subst(cx.tcx) {\n             // We can't resolve on types that require monomorphization, so we don't handle them if\n             // we need to perfom substitution.\n             return;"}, {"sha": "5d25578163976b75f6e2abcd0043a6ef2cb72f31", "filename": "compiler/rustc_lint/src/types.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftypes.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1160,6 +1160,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n         impl<'a, 'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueTypes<'a, 'tcx> {\n             type BreakTy = Ty<'tcx>;\n+            fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+                Some(self.cx.tcx)\n+            }\n \n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 match ty.kind() {"}, {"sha": "c63613ae3af29b097ea4a562f0c9bd5505869746", "filename": "compiler/rustc_middle/src/mir/interpret/queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fqueries.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -38,7 +38,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         ct: ty::Unevaluated<'tcx>,\n         span: Option<Span>,\n     ) -> EvalToConstValueResult<'tcx> {\n-        match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs) {\n+        match ty::Instance::resolve_opt_const_arg(self, param_env, ct.def, ct.substs(self)) {\n             Ok(Some(instance)) => {\n                 let cid = GlobalId { instance, promoted: ct.promoted };\n                 self.const_eval_global_id(param_env, cid, span)"}, {"sha": "8e2917ee5b47c2d0e8128ba6b49f9e794b201367", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -242,6 +242,7 @@ pub struct Body<'tcx> {\n \n impl<'tcx> Body<'tcx> {\n     pub fn new(\n+        tcx: TyCtxt<'tcx>,\n         source: MirSource<'tcx>,\n         basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n         source_scopes: IndexVec<SourceScope, SourceScopeData<'tcx>>,\n@@ -284,7 +285,7 @@ impl<'tcx> Body<'tcx> {\n             predecessor_cache: PredecessorCache::new(),\n             is_cyclic: GraphIsCyclicCache::new(),\n         };\n-        body.is_polymorphic = body.has_param_types_or_consts();\n+        body.is_polymorphic = body.definitely_has_param_types_or_consts(tcx);\n         body\n     }\n \n@@ -294,7 +295,7 @@ impl<'tcx> Body<'tcx> {\n     /// is only useful for testing but cannot be `#[cfg(test)]` because it is used in a different\n     /// crate.\n     pub fn new_cfg_only(basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>) -> Self {\n-        let mut body = Body {\n+        Body {\n             phase: MirPhase::Build,\n             source: MirSource::item(DefId::local(CRATE_DEF_INDEX)),\n             basic_blocks,\n@@ -310,9 +311,7 @@ impl<'tcx> Body<'tcx> {\n             is_polymorphic: false,\n             predecessor_cache: PredecessorCache::new(),\n             is_cyclic: GraphIsCyclicCache::new(),\n-        };\n-        body.is_polymorphic = body.has_param_types_or_consts();\n-        body\n+        }\n     }\n \n     #[inline]"}, {"sha": "07407540975bb1e96883f24b0cf1384f65acf87d", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -114,6 +114,10 @@ rustc_queries! {\n         desc { |tcx| \"compute const default for a given parameter `{}`\", tcx.def_path_str(param)  }\n     }\n \n+    query default_anon_const_substs(key: DefId) -> SubstsRef<'tcx> {\n+        desc { |tcx| \"computing the default generic arguments for `{}`\", tcx.def_path_str(key) }\n+    }\n+\n     /// Records the type of every item.\n     query type_of(key: DefId) -> Ty<'tcx> {\n         desc { |tcx| \"computing type of `{}`\", tcx.def_path_str(key) }\n@@ -299,12 +303,11 @@ rustc_queries! {\n     }\n \n     query try_unify_abstract_consts(key: (\n-        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n-        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>)\n+        ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>\n     )) -> bool {\n         desc {\n             |tcx| \"trying to unify the generic constants {} and {}\",\n-            tcx.def_path_str(key.0.0.did), tcx.def_path_str(key.1.0.did)\n+            tcx.def_path_str(key.0.def.did), tcx.def_path_str(key.1.def.did)\n         }\n     }\n "}, {"sha": "869b2ab9dbcbc5a02495d8b515f6963ad1f10e6c", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1,6 +1,5 @@\n use crate::mir::interpret::ConstValue;\n use crate::mir::interpret::{LitToConstInput, Scalar};\n-use crate::ty::subst::InternalSubsts;\n use crate::ty::{self, Ty, TyCtxt};\n use crate::ty::{ParamEnv, ParamEnvAnd};\n use rustc_errors::ErrorReported;\n@@ -100,7 +99,7 @@ impl<'tcx> Const<'tcx> {\n             }\n             _ => ty::ConstKind::Unevaluated(ty::Unevaluated {\n                 def: def.to_global(),\n-                substs: InternalSubsts::identity_for_item(tcx, def.did.to_def_id()),\n+                substs_: None,\n                 promoted: None,\n             }),\n         };"}, {"sha": "7188eed5445516bd28a58d089b47a175df2f84ab", "filename": "compiler/rustc_middle/src/ty/consts/kind.rs", "status": "modified", "additions": 59, "deletions": 14, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts%2Fkind.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1,4 +1,5 @@\n use std::convert::TryInto;\n+use std::fmt;\n \n use crate::mir::interpret::{AllocId, ConstValue, Scalar};\n use crate::mir::Promoted;\n@@ -12,12 +13,53 @@ use rustc_target::abi::Size;\n \n use super::ScalarInt;\n /// An unevaluated, potentially generic, constant.\n-#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable)]\n+///\n+/// If `substs_` is `None` it means that this anon const\n+/// still has its default substs.\n+///\n+/// We check for all possible substs in `fn default_anon_const_substs`,\n+/// so refer to that check for more info.\n+#[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord, TyEncodable, TyDecodable, Lift)]\n #[derive(Hash, HashStable)]\n-pub struct Unevaluated<'tcx> {\n+pub struct Unevaluated<'tcx, P = Option<Promoted>> {\n     pub def: ty::WithOptConstParam<DefId>,\n-    pub substs: SubstsRef<'tcx>,\n-    pub promoted: Option<Promoted>,\n+    pub substs_: Option<SubstsRef<'tcx>>,\n+    pub promoted: P,\n+}\n+\n+impl<'tcx> Unevaluated<'tcx> {\n+    #[inline]\n+    pub fn shrink(self) -> Unevaluated<'tcx, ()> {\n+        debug_assert_eq!(self.promoted, None);\n+        Unevaluated { def: self.def, substs_: self.substs_, promoted: () }\n+    }\n+}\n+\n+impl<'tcx> Unevaluated<'tcx, ()> {\n+    #[inline]\n+    pub fn expand(self) -> Unevaluated<'tcx> {\n+        Unevaluated { def: self.def, substs_: self.substs_, promoted: None }\n+    }\n+}\n+\n+impl<'tcx, P: Default> Unevaluated<'tcx, P> {\n+    #[inline]\n+    pub fn new(def: ty::WithOptConstParam<DefId>, substs: SubstsRef<'tcx>) -> Unevaluated<'tcx, P> {\n+        Unevaluated { def, substs_: Some(substs), promoted: Default::default() }\n+    }\n+}\n+\n+impl<'tcx, P: Default + PartialEq + fmt::Debug> Unevaluated<'tcx, P> {\n+    #[inline]\n+    pub fn substs(self, tcx: TyCtxt<'tcx>) -> SubstsRef<'tcx> {\n+        self.substs_.unwrap_or_else(|| {\n+            // We must not use the parents default substs for promoted constants\n+            // as that can result in incorrect substs and calls the `default_anon_const_substs`\n+            // for something that might not actually be a constant.\n+            debug_assert_eq!(self.promoted, Default::default());\n+            tcx.default_anon_const_substs(self.def.did)\n+        })\n+    }\n }\n \n /// Represents a constant in Rust.\n@@ -109,7 +151,7 @@ impl<'tcx> ConstKind<'tcx> {\n         tcx: TyCtxt<'tcx>,\n         param_env: ParamEnv<'tcx>,\n     ) -> Option<Result<ConstValue<'tcx>, ErrorReported>> {\n-        if let ConstKind::Unevaluated(Unevaluated { def, substs, promoted }) = self {\n+        if let ConstKind::Unevaluated(unevaluated) = self {\n             use crate::mir::interpret::ErrorHandled;\n \n             // HACK(eddyb) this erases lifetimes even though `const_eval_resolve`\n@@ -118,29 +160,32 @@ impl<'tcx> ConstKind<'tcx> {\n             // Note that we erase regions *before* calling `with_reveal_all_normalized`,\n             // so that we don't try to invoke this query with\n             // any region variables.\n-            let param_env_and_substs = tcx\n+            let param_env_and = tcx\n                 .erase_regions(param_env)\n                 .with_reveal_all_normalized(tcx)\n-                .and(tcx.erase_regions(substs));\n+                .and(tcx.erase_regions(unevaluated));\n \n             // HACK(eddyb) when the query key would contain inference variables,\n             // attempt using identity substs and `ParamEnv` instead, that will succeed\n             // when the expression doesn't depend on any parameters.\n             // FIXME(eddyb, skinny121) pass `InferCtxt` into here when it's available, so that\n             // we can call `infcx.const_eval_resolve` which handles inference variables.\n-            let param_env_and_substs = if param_env_and_substs.needs_infer() {\n-                tcx.param_env(def.did).and(InternalSubsts::identity_for_item(tcx, def.did))\n+            let param_env_and = if param_env_and.needs_infer() {\n+                tcx.param_env(unevaluated.def.did).and(ty::Unevaluated {\n+                    def: unevaluated.def,\n+                    substs_: Some(InternalSubsts::identity_for_item(tcx, unevaluated.def.did)),\n+                    promoted: unevaluated.promoted,\n+                })\n             } else {\n-                param_env_and_substs\n+                param_env_and\n             };\n \n             // FIXME(eddyb) maybe the `const_eval_*` methods should take\n-            // `ty::ParamEnvAnd<SubstsRef>` instead of having them separate.\n-            let (param_env, substs) = param_env_and_substs.into_parts();\n+            // `ty::ParamEnvAnd` instead of having them separate.\n+            let (param_env, unevaluated) = param_env_and.into_parts();\n             // try to resolve e.g. associated constants to their definition on an impl, and then\n             // evaluate the const.\n-            match tcx.const_eval_resolve(param_env, ty::Unevaluated { def, substs, promoted }, None)\n-            {\n+            match tcx.const_eval_resolve(param_env, unevaluated, None) {\n                 // NOTE(eddyb) `val` contains no lifetimes/types/consts,\n                 // and we use the original type, so nothing from `substs`\n                 // (which may be identity substs, see above),"}, {"sha": "63eb55ed1a6208121d0e479810ae80209b0bce03", "filename": "compiler/rustc_middle/src/ty/erase_regions.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferase_regions.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -21,7 +21,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         // If there's nothing to erase avoid performing the query at all\n-        if !value.has_type_flags(TypeFlags::HAS_RE_LATE_BOUND | TypeFlags::HAS_FREE_REGIONS) {\n+        if !value\n+            .has_type_flags(TypeFlags::HAS_RE_LATE_BOUND | TypeFlags::HAS_POTENTIAL_FREE_REGIONS)\n+        {\n             return value;\n         }\n         debug!(\"erase_regions({:?})\", value);"}, {"sha": "a078b6fb742a7b179a0686190b46a23aef3f1e91", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 28, "deletions": 6, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -34,6 +34,12 @@ impl FlagComputation {\n         result.flags\n     }\n \n+    pub fn for_unevaluated_const(uv: ty::Unevaluated<'_>) -> TypeFlags {\n+        let mut result = FlagComputation::new();\n+        result.add_unevaluated_const(uv);\n+        result.flags\n+    }\n+\n     fn add_flags(&mut self, flags: TypeFlags) {\n         self.flags = self.flags | flags;\n     }\n@@ -91,7 +97,7 @@ impl FlagComputation {\n             &ty::Error(_) => self.add_flags(TypeFlags::HAS_ERROR),\n \n             &ty::Param(_) => {\n-                self.add_flags(TypeFlags::HAS_TY_PARAM);\n+                self.add_flags(TypeFlags::HAS_KNOWN_TY_PARAM);\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n \n@@ -246,8 +252,8 @@ impl FlagComputation {\n             ty::PredicateKind::ClosureKind(_def_id, substs, _kind) => {\n                 self.add_substs(substs);\n             }\n-            ty::PredicateKind::ConstEvaluatable(_def_id, substs) => {\n-                self.add_substs(substs);\n+            ty::PredicateKind::ConstEvaluatable(uv) => {\n+                self.add_unevaluated_const(uv);\n             }\n             ty::PredicateKind::ConstEquate(expected, found) => {\n                 self.add_const(expected);\n@@ -292,7 +298,7 @@ impl FlagComputation {\n                 self.add_bound_var(debruijn);\n             }\n             ty::ConstKind::Param(_) => {\n-                self.add_flags(TypeFlags::HAS_CT_PARAM);\n+                self.add_flags(TypeFlags::HAS_KNOWN_CT_PARAM);\n                 self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n             }\n             ty::ConstKind::Placeholder(_) => {\n@@ -304,8 +310,24 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_unevaluated_const(&mut self, ct: ty::Unevaluated<'tcx>) {\n-        self.add_substs(ct.substs);\n+    fn add_unevaluated_const<P>(&mut self, ct: ty::Unevaluated<'tcx, P>) {\n+        // The generic arguments of unevaluated consts are a bit special,\n+        // see the `rustc-dev-guide` for more information.\n+        //\n+        // FIXME(@lcnr): Actually add a link here.\n+        if let Some(substs) = ct.substs_ {\n+            // If they are available, we treat them as ordinary generic arguments.\n+            self.add_substs(substs);\n+        } else {\n+            // Otherwise, we add `HAS_UNKNOWN_DEFAULT_CONST_SUBSTS` to signify\n+            // that our const may potentially refer to generic parameters.\n+            //\n+            // Note that depending on which generic parameters are actually\n+            // used in this constant, we may not actually refer to any generic\n+            // parameters at all.\n+            self.add_flags(TypeFlags::STILL_FURTHER_SPECIALIZABLE);\n+            self.add_flags(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS);\n+        }\n         self.add_flags(TypeFlags::HAS_CT_PROJECTION);\n     }\n "}, {"sha": "a04b0a7ef61363b39226653c0a3a8df3981d36f6", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 227, "deletions": 35, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -74,8 +74,14 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n         self.has_vars_bound_at_or_above(ty::INNERMOST)\n     }\n \n+    fn definitely_has_type_flags(&self, tcx: TyCtxt<'tcx>, flags: TypeFlags) -> bool {\n+        self.visit_with(&mut HasTypeFlagsVisitor { tcx: Some(tcx), flags }).break_value()\n+            == Some(FoundFlags)\n+    }\n+\n     fn has_type_flags(&self, flags: TypeFlags) -> bool {\n-        self.visit_with(&mut HasTypeFlagsVisitor { flags }).break_value() == Some(FoundFlags)\n+        self.visit_with(&mut HasTypeFlagsVisitor { tcx: None, flags }).break_value()\n+            == Some(FoundFlags)\n     }\n     fn has_projections(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_PROJECTION)\n@@ -86,8 +92,18 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n     fn references_error(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_ERROR)\n     }\n-    fn has_param_types_or_consts(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_TY_PARAM | TypeFlags::HAS_CT_PARAM)\n+    fn potentially_has_param_types_or_consts(&self) -> bool {\n+        self.has_type_flags(\n+            TypeFlags::HAS_KNOWN_TY_PARAM\n+                | TypeFlags::HAS_KNOWN_CT_PARAM\n+                | TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS,\n+        )\n+    }\n+    fn definitely_has_param_types_or_consts(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.definitely_has_type_flags(\n+            tcx,\n+            TypeFlags::HAS_KNOWN_TY_PARAM | TypeFlags::HAS_KNOWN_CT_PARAM,\n+        )\n     }\n     fn has_infer_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_INFER)\n@@ -108,29 +124,44 @@ pub trait TypeFoldable<'tcx>: fmt::Debug + Clone {\n                 | TypeFlags::HAS_CT_PLACEHOLDER,\n         )\n     }\n-    fn needs_subst(&self) -> bool {\n-        self.has_type_flags(TypeFlags::NEEDS_SUBST)\n+    fn potentially_needs_subst(&self) -> bool {\n+        self.has_type_flags(\n+            TypeFlags::KNOWN_NEEDS_SUBST | TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS,\n+        )\n+    }\n+    fn definitely_needs_subst(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.definitely_has_type_flags(tcx, TypeFlags::KNOWN_NEEDS_SUBST)\n     }\n     /// \"Free\" regions in this context means that it has any region\n     /// that is not (a) erased or (b) late-bound.\n-    fn has_free_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    fn has_free_regions(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.definitely_has_type_flags(tcx, TypeFlags::HAS_KNOWN_FREE_REGIONS)\n     }\n \n     fn has_erased_regions(&self) -> bool {\n         self.has_type_flags(TypeFlags::HAS_RE_ERASED)\n     }\n \n     /// True if there are any un-erased free regions.\n-    fn has_erasable_regions(&self) -> bool {\n-        self.has_type_flags(TypeFlags::HAS_FREE_REGIONS)\n+    fn has_erasable_regions(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        self.definitely_has_type_flags(tcx, TypeFlags::HAS_KNOWN_FREE_REGIONS)\n+    }\n+\n+    /// Indicates whether this value definitely references only 'global'\n+    /// generic parameters that are the same regardless of what fn we are\n+    /// in. This is used for caching.\n+    ///\n+    /// Note that this function is pessimistic and may incorrectly return\n+    /// `false`.\n+    fn is_known_global(&self) -> bool {\n+        !self.has_type_flags(TypeFlags::HAS_POTENTIAL_FREE_LOCAL_NAMES)\n     }\n \n     /// Indicates whether this value references only 'global'\n     /// generic parameters that are the same regardless of what fn we are\n     /// in. This is used for caching.\n-    fn is_global(&self) -> bool {\n-        !self.has_type_flags(TypeFlags::HAS_FREE_LOCAL_NAMES)\n+    fn is_global(&self, tcx: TyCtxt<'tcx>) -> bool {\n+        !self.definitely_has_type_flags(tcx, TypeFlags::HAS_KNOWN_FREE_LOCAL_NAMES)\n     }\n \n     /// True if there are any late-bound regions\n@@ -182,13 +213,28 @@ pub trait TypeFolder<'tcx>: Sized {\n         c.super_fold_with(self)\n     }\n \n+    fn fold_predicate(&mut self, p: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+        p.super_fold_with(self)\n+    }\n+\n     fn fold_mir_const(&mut self, c: mir::ConstantKind<'tcx>) -> mir::ConstantKind<'tcx> {\n         bug!(\"most type folders should not be folding MIR datastructures: {:?}\", c)\n     }\n }\n \n pub trait TypeVisitor<'tcx>: Sized {\n     type BreakTy = !;\n+    /// Supplies the `tcx` for an unevaluated anonymous constant in case its default substs\n+    /// are not yet supplied.\n+    ///\n+    /// Returning `None` for this method is only recommended if the `TypeVisitor`\n+    /// does not care about default anon const substs, as it ignores generic parameters,\n+    /// and fetching the default substs would cause a query cycle.\n+    ///\n+    /// For visitors which return `None` we completely skip the default substs in `ty::Unevaluated::super_visit_with`.\n+    /// This means that incorrectly returning `None` can very quickly lead to ICE or other critical bugs, so be careful and\n+    /// try to return an actual `tcx` if possible.\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>>;\n \n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n@@ -209,6 +255,10 @@ pub trait TypeVisitor<'tcx>: Sized {\n         c.super_visit_with(self)\n     }\n \n+    fn visit_unevaluated_const(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        uv.super_visit_with(self)\n+    }\n+\n     fn visit_predicate(&mut self, p: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n         p.super_visit_with(self)\n     }\n@@ -301,7 +351,8 @@ impl<'tcx> TyCtxt<'tcx> {\n         value: &impl TypeFoldable<'tcx>,\n         callback: impl FnMut(ty::Region<'tcx>) -> bool,\n     ) -> bool {\n-        struct RegionVisitor<F> {\n+        struct RegionVisitor<'tcx, F> {\n+            tcx: TyCtxt<'tcx>,\n             /// The index of a binder *just outside* the things we have\n             /// traversed. If we encounter a bound region bound by this\n             /// binder or one outer to it, it appears free. Example:\n@@ -323,12 +374,16 @@ impl<'tcx> TyCtxt<'tcx> {\n             callback: F,\n         }\n \n-        impl<'tcx, F> TypeVisitor<'tcx> for RegionVisitor<F>\n+        impl<'tcx, F> TypeVisitor<'tcx> for RegionVisitor<'tcx, F>\n         where\n             F: FnMut(ty::Region<'tcx>) -> bool,\n         {\n             type BreakTy = ();\n \n+            fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+                Some(self.tcx)\n+            }\n+\n             fn visit_binder<T: TypeFoldable<'tcx>>(\n                 &mut self,\n                 t: &Binder<'tcx, T>,\n@@ -356,15 +411,17 @@ impl<'tcx> TyCtxt<'tcx> {\n \n             fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 // We're only interested in types involving regions\n-                if ty.flags().intersects(TypeFlags::HAS_FREE_REGIONS) {\n+                if ty.flags().intersects(TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n                     ty.super_visit_with(self)\n                 } else {\n                     ControlFlow::CONTINUE\n                 }\n             }\n         }\n \n-        value.visit_with(&mut RegionVisitor { outer_index: ty::INNERMOST, callback }).is_break()\n+        value\n+            .visit_with(&mut RegionVisitor { tcx: self, outer_index: ty::INNERMOST, callback })\n+            .is_break()\n     }\n }\n \n@@ -708,7 +765,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        let mut collector = LateBoundRegionsCollector::new(just_constraint);\n+        let mut collector = LateBoundRegionsCollector::new(self, just_constraint);\n         let result = value.as_ref().skip_binder().visit_with(&mut collector);\n         assert!(result.is_continue()); // should never have stopped early\n         collector.regions\n@@ -775,6 +832,11 @@ impl<'tcx> ValidateBoundVars<'tcx> {\n impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n     type BreakTy = ();\n \n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        // Anonymous constants do not contain bound vars in their substs by default.\n+        None\n+    }\n+\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: &Binder<'tcx, T>,\n@@ -989,6 +1051,11 @@ struct HasEscapingVarsVisitor {\n impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n     type BreakTy = FoundEscapingVars;\n \n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        // Anonymous constants do not contain bound vars in their substs by default.\n+        None\n+    }\n+\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: &Binder<'tcx, T>,\n@@ -1053,25 +1120,28 @@ impl<'tcx> TypeVisitor<'tcx> for HasEscapingVarsVisitor {\n struct FoundFlags;\n \n // FIXME: Optimize for checking for infer flags\n-struct HasTypeFlagsVisitor {\n+struct HasTypeFlagsVisitor<'tcx> {\n+    tcx: Option<TyCtxt<'tcx>>,\n     flags: ty::TypeFlags,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n+impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor<'tcx> {\n     type BreakTy = FoundFlags;\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        bug!(\"we shouldn't call this method as we manually look at ct substs\");\n+    }\n \n     #[inline]\n-    fn visit_ty(&mut self, t: Ty<'_>) -> ControlFlow<Self::BreakTy> {\n-        debug!(\n-            \"HasTypeFlagsVisitor: t={:?} t.flags={:?} self.flags={:?}\",\n-            t,\n-            t.flags(),\n-            self.flags\n-        );\n-        if t.flags().intersects(self.flags) {\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = t.flags();\n+        debug!(\"HasTypeFlagsVisitor: t={:?} flags={:?} self.flags={:?}\", t, flags, self.flags);\n+        if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n-            ControlFlow::CONTINUE\n+            match flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+                true if self.tcx.is_some() => UnknownConstSubstsVisitor::search(&self, t),\n+                _ => ControlFlow::CONTINUE,\n+            }\n         }\n     }\n \n@@ -1093,27 +1163,144 @@ impl<'tcx> TypeVisitor<'tcx> for HasTypeFlagsVisitor {\n         if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n         } else {\n-            ControlFlow::CONTINUE\n+            match flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+                true if self.tcx.is_some() => UnknownConstSubstsVisitor::search(&self, c),\n+                _ => ControlFlow::CONTINUE,\n+            }\n+        }\n+    }\n+\n+    #[inline]\n+    fn visit_unevaluated_const(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = FlagComputation::for_unevaluated_const(uv);\n+        debug!(\"HasTypeFlagsVisitor: uv={:?} uv.flags={:?} self.flags={:?}\", uv, flags, self.flags);\n+        if flags.intersects(self.flags) {\n+            ControlFlow::Break(FoundFlags)\n+        } else {\n+            match flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+                true if self.tcx.is_some() => UnknownConstSubstsVisitor::search(&self, uv),\n+                _ => ControlFlow::CONTINUE,\n+            }\n         }\n     }\n \n     #[inline]\n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        let flags = predicate.inner.flags;\n         debug!(\n-            \"HasTypeFlagsVisitor: predicate={:?} predicate.flags={:?} self.flags={:?}\",\n-            predicate, predicate.inner.flags, self.flags\n+            \"HasTypeFlagsVisitor: predicate={:?} flags={:?} self.flags={:?}\",\n+            predicate, flags, self.flags\n         );\n-        if predicate.inner.flags.intersects(self.flags) {\n+        if flags.intersects(self.flags) {\n             ControlFlow::Break(FoundFlags)\n+        } else {\n+            match flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+                true if self.tcx.is_some() => UnknownConstSubstsVisitor::search(&self, predicate),\n+                _ => ControlFlow::CONTINUE,\n+            }\n+        }\n+    }\n+}\n+\n+struct UnknownConstSubstsVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    flags: ty::TypeFlags,\n+}\n+\n+impl<'tcx> UnknownConstSubstsVisitor<'tcx> {\n+    /// This is fairly cold and we don't want to\n+    /// bloat the size of the `HasTypeFlagsVisitor`.\n+    #[inline(never)]\n+    pub fn search<T: TypeFoldable<'tcx>>(\n+        visitor: &HasTypeFlagsVisitor<'tcx>,\n+        v: T,\n+    ) -> ControlFlow<FoundFlags> {\n+        if visitor.flags.intersects(TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS) {\n+            v.super_visit_with(&mut UnknownConstSubstsVisitor {\n+                tcx: visitor.tcx.unwrap(),\n+                flags: visitor.flags,\n+            })\n         } else {\n             ControlFlow::CONTINUE\n         }\n     }\n }\n \n+impl<'tcx> TypeVisitor<'tcx> for UnknownConstSubstsVisitor<'tcx> {\n+    type BreakTy = FoundFlags;\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        bug!(\"we shouldn't call this method as we manually look at ct substs\");\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.flags().intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+            t.super_visit_with(self)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    fn visit_unevaluated_const(&mut self, uv: ty::Unevaluated<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if uv.substs_.is_none() {\n+            self.tcx\n+                .default_anon_const_substs(uv.def.did)\n+                .visit_with(&mut HasTypeFlagsVisitor { tcx: Some(self.tcx), flags: self.flags })\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+\n+    #[inline]\n+    fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if predicate.inner.flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+            predicate.super_visit_with(self)\n+        } else {\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+}\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// This is a HACK(const_generics) and should probably not be needed.\n+    /// Might however be perf relevant, so who knows.\n+    ///\n+    /// FIXME(@lcnr): explain this function a bit more\n+    pub fn expose_default_const_substs<T: TypeFoldable<'tcx>>(self, v: T) -> T {\n+        v.fold_with(&mut ExposeDefaultConstSubstsFolder { tcx: self })\n+    }\n+}\n+\n+struct ExposeDefaultConstSubstsFolder<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ExposeDefaultConstSubstsFolder<'tcx> {\n+    fn tcx(&self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, ty: Ty<'tcx>) -> Ty<'tcx> {\n+        if ty.flags().intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+            ty.super_fold_with(self)\n+        } else {\n+            ty\n+        }\n+    }\n+\n+    fn fold_predicate(&mut self, pred: ty::Predicate<'tcx>) -> ty::Predicate<'tcx> {\n+        if pred.inner.flags.intersects(TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS) {\n+            pred.super_fold_with(self)\n+        } else {\n+            pred\n+        }\n+    }\n+}\n+\n /// Collects all the late-bound regions at the innermost binding level\n /// into a hash set.\n-struct LateBoundRegionsCollector {\n+struct LateBoundRegionsCollector<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     current_index: ty::DebruijnIndex,\n     regions: FxHashSet<ty::BoundRegionKind>,\n \n@@ -1127,17 +1314,22 @@ struct LateBoundRegionsCollector {\n     just_constrained: bool,\n }\n \n-impl LateBoundRegionsCollector {\n-    fn new(just_constrained: bool) -> Self {\n+impl LateBoundRegionsCollector<'tcx> {\n+    fn new(tcx: TyCtxt<'tcx>, just_constrained: bool) -> Self {\n         LateBoundRegionsCollector {\n+            tcx,\n             current_index: ty::INNERMOST,\n             regions: Default::default(),\n             just_constrained,\n         }\n     }\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector {\n+impl<'tcx> TypeVisitor<'tcx> for LateBoundRegionsCollector<'tcx> {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: &Binder<'tcx, T>,"}, {"sha": "ab25aa83fd9e172e0acb700f9167da621c6950d5", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1739,7 +1739,9 @@ impl<'tcx> LayoutCx<'tcx, TyCtxt<'tcx>> {\n         // Ignore layouts that are done with non-empty environments or\n         // non-monomorphic layouts, as the user only wants to see the stuff\n         // resulting from the final codegen session.\n-        if layout.ty.has_param_types_or_consts() || !self.param_env.caller_bounds().is_empty() {\n+        if layout.ty.definitely_has_param_types_or_consts(self.tcx)\n+            || !self.param_env.caller_bounds().is_empty()\n+        {\n             return;\n         }\n \n@@ -1906,7 +1908,7 @@ impl<'tcx> SizeSkeleton<'tcx> {\n                 let tail = tcx.struct_tail_erasing_lifetimes(pointee, param_env);\n                 match tail.kind() {\n                     ty::Param(_) | ty::Projection(_) => {\n-                        debug_assert!(tail.has_param_types_or_consts());\n+                        debug_assert!(tail.definitely_has_param_types_or_consts(tcx));\n                         Ok(SizeSkeleton::Pointer { non_zero, tail: tcx.erase_regions(tail) })\n                     }\n                     _ => bug!("}, {"sha": "8f814a84b4959ff0102c87968099eddede56b344", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -502,7 +502,7 @@ pub enum PredicateKind<'tcx> {\n     Coerce(CoercePredicate<'tcx>),\n \n     /// Constant initializer must evaluate successfully.\n-    ConstEvaluatable(ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n+    ConstEvaluatable(ty::Unevaluated<'tcx, ()>),\n \n     /// Constants must be equal. The first component is the const that is expected.\n     ConstEquate(&'tcx Const<'tcx>, &'tcx Const<'tcx>),\n@@ -1292,7 +1292,7 @@ impl<'tcx> ParamEnv<'tcx> {\n             Reveal::UserFacing => ParamEnvAnd { param_env: self, value },\n \n             Reveal::All => {\n-                if value.is_global() {\n+                if value.is_known_global() {\n                     ParamEnvAnd { param_env: self.without_caller_bounds(), value }\n                 } else {\n                     ParamEnvAnd { param_env: self, value }"}, {"sha": "ef4ad998f10c81ab2f2ec3745e31d5e5c7a2f9c8", "filename": "compiler/rustc_middle/src/ty/outlives.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Foutlives.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -194,7 +194,7 @@ fn compute_components_recursive(\n     out: &mut SmallVec<[Component<'tcx>; 4]>,\n     visited: &mut SsoHashSet<GenericArg<'tcx>>,\n ) {\n-    for child in parent.walk_shallow(visited) {\n+    for child in parent.walk_shallow(tcx, visited) {\n         match child.unpack() {\n             GenericArgKind::Type(ty) => {\n                 compute_components(tcx, ty, out, visited);"}, {"sha": "db4a1d94d1a7c28bf8f180763fe0182ab39fda34", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 31, "deletions": 24, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -927,29 +927,28 @@ pub trait PrettyPrinter<'tcx>:\n         }\n \n         match ct.val {\n-            ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                def,\n-                substs,\n-                promoted: Some(promoted),\n-            }) => {\n-                p!(print_value_path(def.did, substs));\n-                p!(write(\"::{:?}\", promoted));\n-            }\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted: None }) => {\n-                match self.tcx().def_kind(def.did) {\n-                    DefKind::Static | DefKind::Const | DefKind::AssocConst => {\n-                        p!(print_value_path(def.did, substs))\n-                    }\n-                    _ => {\n-                        if def.is_local() {\n-                            let span = self.tcx().def_span(def.did);\n-                            if let Ok(snip) = self.tcx().sess.source_map().span_to_snippet(span) {\n-                                p!(write(\"{}\", snip))\n+            ty::ConstKind::Unevaluated(uv) => {\n+                if let Some(promoted) = uv.promoted {\n+                    let substs = uv.substs_.unwrap();\n+                    p!(print_value_path(uv.def.did, substs));\n+                    p!(write(\"::{:?}\", promoted));\n+                } else {\n+                    let tcx = self.tcx();\n+                    match tcx.def_kind(uv.def.did) {\n+                        DefKind::Static | DefKind::Const | DefKind::AssocConst => {\n+                            p!(print_value_path(uv.def.did, uv.substs(tcx)))\n+                        }\n+                        _ => {\n+                            if uv.def.is_local() {\n+                                let span = tcx.def_span(uv.def.did);\n+                                if let Ok(snip) = tcx.sess.source_map().span_to_snippet(span) {\n+                                    p!(write(\"{}\", snip))\n+                                } else {\n+                                    print_underscore!()\n+                                }\n                             } else {\n                                 print_underscore!()\n                             }\n-                        } else {\n-                            print_underscore!()\n                         }\n                     }\n                 }\n@@ -1194,15 +1193,17 @@ pub trait PrettyPrinter<'tcx>:\n \n             // Aggregates, printed as array/tuple/struct/variant construction syntax.\n             //\n-            // NB: the `has_param_types_or_consts` check ensures that we can use\n+            // NB: the `potentially_has_param_types_or_consts` check ensures that we can use\n             // the `destructure_const` query with an empty `ty::ParamEnv` without\n             // introducing ICEs (e.g. via `layout_of`) from missing bounds.\n             // E.g. `transmute([0usize; 2]): (u8, *mut T)` needs to know `T: Sized`\n             // to be able to destructure the tuple into `(0u8, *mut T)\n             //\n             // FIXME(eddyb) for `--emit=mir`/`-Z dump-mir`, we should provide the\n             // correct `ty::ParamEnv` to allow printing *all* constant values.\n-            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..)) if !ty.has_param_types_or_consts() => {\n+            (_, ty::Array(..) | ty::Tuple(..) | ty::Adt(..))\n+                if !ty.potentially_has_param_types_or_consts() =>\n+            {\n                 let contents = self.tcx().destructure_const(\n                     ty::ParamEnv::reveal_all()\n                         .and(self.tcx().mk_const(ty::Const { val: ty::ConstKind::Value(ct), ty })),\n@@ -2024,13 +2025,18 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         debug!(\"prepare_late_bound_region_info(value: {:?})\", value);\n \n         struct LateBoundRegionNameCollector<'a, 'tcx> {\n+            tcx: TyCtxt<'tcx>,\n             used_region_names: &'a mut FxHashSet<Symbol>,\n             type_collector: SsoHashSet<Ty<'tcx>>,\n         }\n \n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_, 'tcx> {\n             type BreakTy = ();\n \n+            fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+                Some(self.tcx)\n+            }\n+\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n                 debug!(\"LateBoundRegionNameCollector::visit_region(r: {:?}, address: {:p})\", r, &r);\n                 if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n@@ -2060,6 +2066,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n \n         self.used_region_names.clear();\n         let mut collector = LateBoundRegionNameCollector {\n+            tcx: self.tcx,\n             used_region_names: &mut self.used_region_names,\n             type_collector: SsoHashSet::new(),\n         };\n@@ -2294,8 +2301,8 @@ define_print_and_forward_display! {\n                 print_value_path(closure_def_id, &[]),\n                 write(\"` implements the trait `{}`\", kind))\n             }\n-            ty::PredicateKind::ConstEvaluatable(def, substs) => {\n-                p!(\"the constant `\", print_value_path(def.did, substs), \"` can be evaluated\")\n+            ty::PredicateKind::ConstEvaluatable(uv) => {\n+                p!(\"the constant `\", print_value_path(uv.def.did, uv.substs_.map_or(&[], |x| x)), \"` can be evaluated\")\n             }\n             ty::PredicateKind::ConstEquate(c1, c2) => {\n                 p!(\"the constant `\", print(c1), \"` equals `\", print(c2), \"`\")"}, {"sha": "4a2c8349fdc684270918203c738c5fb130b1e335", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -579,7 +579,7 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n         (ty::ConstKind::Unevaluated(au), ty::ConstKind::Unevaluated(bu))\n             if tcx.features().const_evaluatable_checked =>\n         {\n-            tcx.try_unify_abstract_consts(((au.def, au.substs), (bu.def, bu.substs)))\n+            tcx.try_unify_abstract_consts((au.shrink(), bu.shrink()))\n         }\n \n         // While this is slightly incorrect, it shouldn't matter for `min_const_generics`\n@@ -591,13 +591,13 @@ pub fn super_relate_consts<R: TypeRelation<'tcx>>(\n             let substs = relation.relate_with_variance(\n                 ty::Variance::Invariant,\n                 ty::VarianceDiagInfo::default(),\n-                au.substs,\n-                bu.substs,\n+                au.substs(tcx),\n+                bu.substs(tcx),\n             )?;\n             return Ok(tcx.mk_const(ty::Const {\n                 val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                     def: au.def,\n-                    substs,\n+                    substs_: Some(substs),\n                     promoted: au.promoted,\n                 }),\n                 ty: a.ty,"}, {"sha": "2ab25c839704ddbb56e1b2ddd5322251536a0ff0", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 60, "deletions": 12, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -190,8 +190,8 @@ impl fmt::Debug for ty::PredicateKind<'tcx> {\n             ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+            ty::PredicateKind::ConstEvaluatable(uv) => {\n+                write!(f, \"ConstEvaluatable({:?}, {:?})\", uv.def, uv.substs_)\n             }\n             ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n             ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n@@ -447,8 +447,8 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n             ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n             }\n-            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(substs).map(|substs| ty::PredicateKind::ConstEvaluatable(def_id, substs))\n+            ty::PredicateKind::ConstEvaluatable(uv) => {\n+                tcx.lift(uv).map(|uv| ty::PredicateKind::ConstEvaluatable(uv))\n             }\n             ty::PredicateKind::ConstEquate(c1, c2) => {\n                 tcx.lift((c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n@@ -974,6 +974,10 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n }\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n+    fn fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        folder.fold_predicate(self)\n+    }\n+\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n         let new = self.inner.kind.fold_with(folder);\n         folder.tcx().reuse_or_mk_predicate(self, new)\n@@ -1046,13 +1050,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n         match self {\n             ty::ConstKind::Infer(ic) => ty::ConstKind::Infer(ic.fold_with(folder)),\n             ty::ConstKind::Param(p) => ty::ConstKind::Param(p.fold_with(folder)),\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }) => {\n-                ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                    def,\n-                    substs: substs.fold_with(folder),\n-                    promoted,\n-                })\n-            }\n+            ty::ConstKind::Unevaluated(uv) => ty::ConstKind::Unevaluated(uv.fold_with(folder)),\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(..)\n@@ -1064,7 +1062,7 @@ impl<'tcx> TypeFoldable<'tcx> for ty::ConstKind<'tcx> {\n         match *self {\n             ty::ConstKind::Infer(ic) => ic.visit_with(visitor),\n             ty::ConstKind::Param(p) => p.visit_with(visitor),\n-            ty::ConstKind::Unevaluated(ct) => ct.substs.visit_with(visitor),\n+            ty::ConstKind::Unevaluated(uv) => uv.visit_with(visitor),\n             ty::ConstKind::Value(_)\n             | ty::ConstKind::Bound(..)\n             | ty::ConstKind::Placeholder(_)\n@@ -1082,3 +1080,53 @@ impl<'tcx> TypeFoldable<'tcx> for InferConst<'tcx> {\n         ControlFlow::CONTINUE\n     }\n }\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        ty::Unevaluated {\n+            def: self.def,\n+            substs_: Some(self.substs(folder.tcx()).fold_with(folder)),\n+            promoted: self.promoted,\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        visitor.visit_unevaluated_const(*self)\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        if let Some(tcx) = visitor.tcx_for_anon_const_substs() {\n+            self.substs(tcx).visit_with(visitor)\n+        } else if let Some(substs) = self.substs_ {\n+            substs.visit_with(visitor)\n+        } else {\n+            debug!(\"ignoring default substs of `{:?}`\", self.def);\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeFoldable<'tcx> for ty::Unevaluated<'tcx, ()> {\n+    fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n+        ty::Unevaluated {\n+            def: self.def,\n+            substs_: Some(self.substs(folder.tcx()).fold_with(folder)),\n+            promoted: self.promoted,\n+        }\n+    }\n+\n+    fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        visitor.visit_unevaluated_const(self.expand())\n+    }\n+\n+    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n+        if let Some(tcx) = visitor.tcx_for_anon_const_substs() {\n+            self.substs(tcx).visit_with(visitor)\n+        } else if let Some(substs) = self.substs_ {\n+            substs.visit_with(visitor)\n+        } else {\n+            debug!(\"ignoring default substs of `{:?}`\", self.def);\n+            ControlFlow::CONTINUE\n+        }\n+    }\n+}"}, {"sha": "8b893b779c0a2d47a44974c399c1af59435c1734", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1565,26 +1565,26 @@ impl RegionKind {\n \n         match *self {\n             ty::ReVar(..) => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_INFER;\n             }\n             ty::RePlaceholder(..) => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS;\n                 flags = flags | TypeFlags::HAS_RE_PLACEHOLDER;\n             }\n             ty::ReEarlyBound(..) => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n-                flags = flags | TypeFlags::HAS_RE_PARAM;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_RE_PARAM;\n             }\n             ty::ReFree { .. } => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n-                flags = flags | TypeFlags::HAS_FREE_LOCAL_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS;\n             }\n             ty::ReEmpty(_) | ty::ReStatic => {\n-                flags = flags | TypeFlags::HAS_FREE_REGIONS;\n+                flags = flags | TypeFlags::HAS_KNOWN_FREE_REGIONS;\n             }\n             ty::ReLateBound(..) => {\n                 flags = flags | TypeFlags::HAS_RE_LATE_BOUND;"}, {"sha": "2438d1a16021b50aa4f318d5946842e6bc6d4281", "filename": "compiler/rustc_middle/src/ty/subst.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsubst.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -486,7 +486,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     }\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n-        if !t.needs_subst() {\n+        if !t.potentially_needs_subst() {\n             return t;\n         }\n \n@@ -497,10 +497,6 @@ impl<'a, 'tcx> TypeFolder<'tcx> for SubstFolder<'a, 'tcx> {\n     }\n \n     fn fold_const(&mut self, c: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n-        if !c.needs_subst() {\n-            return c;\n-        }\n-\n         if let ty::ConstKind::Param(p) = c.val {\n             self.const_for_param(p, c)\n         } else {"}, {"sha": "73985cf31e0f9e736c79d67faa3d440cfee8850d", "filename": "compiler/rustc_middle/src/ty/walk.rs", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fwalk.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1,8 +1,8 @@\n //! An iterator over the type substructure.\n //! WARNING: this does not keep track of the region depth.\n \n-use crate::ty;\n use crate::ty::subst::{GenericArg, GenericArgKind};\n+use crate::ty::{self, TyCtxt};\n use rustc_data_structures::sso::SsoHashSet;\n use smallvec::{self, SmallVec};\n \n@@ -11,6 +11,7 @@ use smallvec::{self, SmallVec};\n type TypeWalkerStack<'tcx> = SmallVec<[GenericArg<'tcx>; 8]>;\n \n pub struct TypeWalker<'tcx> {\n+    expose_default_const_substs: Option<TyCtxt<'tcx>>,\n     stack: TypeWalkerStack<'tcx>,\n     last_subtree: usize,\n     pub visited: SsoHashSet<GenericArg<'tcx>>,\n@@ -25,8 +26,13 @@ pub struct TypeWalker<'tcx> {\n /// It maintains a set of visited types and\n /// skips any types that are already there.\n impl<'tcx> TypeWalker<'tcx> {\n-    pub fn new(root: GenericArg<'tcx>) -> Self {\n-        Self { stack: smallvec![root], last_subtree: 1, visited: SsoHashSet::new() }\n+    fn new(expose_default_const_substs: Option<TyCtxt<'tcx>>, root: GenericArg<'tcx>) -> Self {\n+        Self {\n+            expose_default_const_substs,\n+            stack: smallvec![root],\n+            last_subtree: 1,\n+            visited: SsoHashSet::new(),\n+        }\n     }\n \n     /// Skips the subtree corresponding to the last type\n@@ -55,7 +61,7 @@ impl<'tcx> Iterator for TypeWalker<'tcx> {\n             let next = self.stack.pop()?;\n             self.last_subtree = self.stack.len();\n             if self.visited.insert(next) {\n-                push_inner(&mut self.stack, next);\n+                push_inner(self.expose_default_const_substs, &mut self.stack, next);\n                 debug!(\"next: stack={:?}\", self.stack);\n                 return Some(next);\n             }\n@@ -74,8 +80,8 @@ impl GenericArg<'tcx> {\n     /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n     /// [isize] => { [isize], isize }\n     /// ```\n-    pub fn walk(self) -> TypeWalker<'tcx> {\n-        TypeWalker::new(self)\n+    pub fn walk(self, tcx: TyCtxt<'tcx>) -> TypeWalker<'tcx> {\n+        TypeWalker::new(Some(tcx), self)\n     }\n \n     /// Iterator that walks the immediate children of `self`. Hence\n@@ -87,16 +93,21 @@ impl GenericArg<'tcx> {\n     /// and skips any types that are already there.\n     pub fn walk_shallow(\n         self,\n+        tcx: TyCtxt<'tcx>,\n         visited: &mut SsoHashSet<GenericArg<'tcx>>,\n     ) -> impl Iterator<Item = GenericArg<'tcx>> {\n         let mut stack = SmallVec::new();\n-        push_inner(&mut stack, self);\n+        push_inner(Some(tcx), &mut stack, self);\n         stack.retain(|a| visited.insert(*a));\n         stack.into_iter()\n     }\n }\n \n impl<'tcx> super::TyS<'tcx> {\n+    pub fn walk_ignoring_default_const_substs(&'tcx self) -> TypeWalker<'tcx> {\n+        TypeWalker::new(None, self.into())\n+    }\n+\n     /// Iterator that walks `self` and any types reachable from\n     /// `self`, in depth-first order. Note that just walks the types\n     /// that appear in `self`, it does not descend into the fields of\n@@ -107,18 +118,22 @@ impl<'tcx> super::TyS<'tcx> {\n     /// Foo<Bar<isize>> => { Foo<Bar<isize>>, Bar<isize>, isize }\n     /// [isize] => { [isize], isize }\n     /// ```\n-    pub fn walk(&'tcx self) -> TypeWalker<'tcx> {\n-        TypeWalker::new(self.into())\n+    pub fn walk(&'tcx self, tcx: TyCtxt<'tcx>) -> TypeWalker<'tcx> {\n+        TypeWalker::new(Some(tcx), self.into())\n     }\n }\n \n-// We push `GenericArg`s on the stack in reverse order so as to\n-// maintain a pre-order traversal. As of the time of this\n-// writing, the fact that the traversal is pre-order is not\n-// known to be significant to any code, but it seems like the\n-// natural order one would expect (basically, the order of the\n-// types as they are written).\n-fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>) {\n+/// We push `GenericArg`s on the stack in reverse order so as to\n+/// maintain a pre-order traversal. As of the time of this\n+/// writing, the fact that the traversal is pre-order is not\n+/// known to be significant to any code, but it seems like the\n+/// natural order one would expect (basically, the order of the\n+/// types as they are written).\n+fn push_inner<'tcx>(\n+    expose_default_const_substs: Option<TyCtxt<'tcx>>,\n+    stack: &mut TypeWalkerStack<'tcx>,\n+    parent: GenericArg<'tcx>,\n+) {\n     match parent.unpack() {\n         GenericArgKind::Type(parent_ty) => match *parent_ty.kind() {\n             ty::Bool\n@@ -196,7 +211,11 @@ fn push_inner<'tcx>(stack: &mut TypeWalkerStack<'tcx>, parent: GenericArg<'tcx>)\n                 | ty::ConstKind::Error(_) => {}\n \n                 ty::ConstKind::Unevaluated(ct) => {\n-                    stack.extend(ct.substs.iter().rev());\n+                    if let Some(tcx) = expose_default_const_substs {\n+                        stack.extend(ct.substs(tcx).iter().rev());\n+                    } else if let Some(substs) = ct.substs_ {\n+                        stack.extend(substs.iter().rev());\n+                    }\n                 }\n             }\n         }"}, {"sha": "566c11811e6e1108267411a5d79c688ed0809946", "filename": "compiler/rustc_mir/src/borrow_check/type_check/liveness/trace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fliveness%2Ftrace.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -171,7 +171,7 @@ impl LivenessResults<'me, 'typeck, 'flow, 'tcx> {\n         for (local, location) in drop_used {\n             if !live_locals.contains(&local) {\n                 let local_ty = self.cx.body.local_decls[local].ty;\n-                if local_ty.has_free_regions() {\n+                if local_ty.has_free_regions(self.cx.typeck.tcx()) {\n                     self.cx.add_drop_live_facts_for(local, local_ty, &[location], &locations);\n                 }\n             }"}, {"sha": "639bcb8fa94efb7f3768665349a0508e5b703efe", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -377,8 +377,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                 },\n                 _ => None,\n             };\n-            if let Some(ty::Unevaluated { def, substs, promoted }) = maybe_uneval {\n-                if let Some(promoted) = promoted {\n+            if let Some(uv) = maybe_uneval {\n+                if let Some(promoted) = uv.promoted {\n                     let check_err = |verifier: &mut TypeVerifier<'a, 'b, 'tcx>,\n                                      promoted: &Body<'tcx>,\n                                      ty,\n@@ -413,8 +413,8 @@ impl<'a, 'b, 'tcx> Visitor<'tcx> for TypeVerifier<'a, 'b, 'tcx> {\n                         ConstraintCategory::Boring,\n                         self.cx.param_env.and(type_op::ascribe_user_type::AscribeUserType::new(\n                             constant.literal.ty(),\n-                            def.did,\n-                            UserSubsts { substs, user_self_ty: None },\n+                            uv.def.did,\n+                            UserSubsts { substs: uv.substs(self.tcx()), user_self_ty: None },\n                         )),\n                     ) {\n                         span_mirbug!("}, {"sha": "403dc1b4793d0b539d51e447ec3e47f10d9d4568", "filename": "compiler/rustc_mir/src/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Foperand.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -555,9 +555,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match val.val {\n             ty::ConstKind::Param(_) | ty::ConstKind::Bound(..) => throw_inval!(TooGeneric),\n             ty::ConstKind::Error(_) => throw_inval!(AlreadyReported(ErrorReported)),\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }) => {\n-                let instance = self.resolve(def, substs)?;\n-                Ok(self.eval_to_allocation(GlobalId { instance, promoted })?.into())\n+            ty::ConstKind::Unevaluated(uv) => {\n+                let instance = self.resolve(uv.def, uv.substs(*self.tcx))?;\n+                Ok(self.eval_to_allocation(GlobalId { instance, promoted: uv.promoted })?.into())\n             }\n             ty::ConstKind::Infer(..) | ty::ConstKind::Placeholder(..) => {\n                 span_bug!(self.cur_span(), \"const_to_op: Unexpected ConstKind {:?}\", val)"}, {"sha": "eb0fdebb665faa2bea8e83168f0700b8ce916d2d", "filename": "compiler/rustc_mir/src/interpret/util.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -9,7 +9,7 @@ where\n     T: TypeFoldable<'tcx>,\n {\n     debug!(\"ensure_monomorphic_enough: ty={:?}\", ty);\n-    if !ty.needs_subst() {\n+    if !ty.potentially_needs_subst() {\n         return Ok(());\n     }\n \n@@ -21,19 +21,12 @@ where\n     impl<'tcx> TypeVisitor<'tcx> for UsedParamsNeedSubstVisitor<'tcx> {\n         type BreakTy = FoundParam;\n \n-        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if !c.needs_subst() {\n-                return ControlFlow::CONTINUE;\n-            }\n-\n-            match c.val {\n-                ty::ConstKind::Param(..) => ControlFlow::Break(FoundParam),\n-                _ => c.super_visit_with(self),\n-            }\n+        fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+            Some(self.tcx)\n         }\n \n         fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if !ty.needs_subst() {\n+            if !ty.potentially_needs_subst() {\n                 return ControlFlow::CONTINUE;\n             }\n \n@@ -50,7 +43,7 @@ where\n                         let is_used = unused_params.contains(index).map_or(true, |unused| !unused);\n                         // Only recurse when generic parameters in fns, closures and generators\n                         // are used and require substitution.\n-                        match (is_used, subst.needs_subst()) {\n+                        match (is_used, subst.definitely_needs_subst(self.tcx)) {\n                             // Just in case there are closures or generators within this subst,\n                             // recurse.\n                             (true, true) => return subst.super_visit_with(self),\n@@ -73,6 +66,13 @@ where\n                 _ => ty.super_visit_with(self),\n             }\n         }\n+\n+        fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            match c.val {\n+                ty::ConstKind::Param(..) => ControlFlow::Break(FoundParam),\n+                _ => c.super_visit_with(self),\n+            }\n+        }\n     }\n \n     let mut vis = UsedParamsNeedSubstVisitor { tcx };"}, {"sha": "f03036267acfabb036b5cbf5a991e9f157830db0", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -573,7 +573,7 @@ fn check_type_length_limit<'tcx>(tcx: TyCtxt<'tcx>, instance: Instance<'tcx>) {\n     let type_length = instance\n         .substs\n         .iter()\n-        .flat_map(|arg| arg.walk())\n+        .flat_map(|arg| arg.walk(tcx))\n         .filter(|arg| match arg.unpack() {\n             GenericArgKind::Type(_) | GenericArgKind::Const(_) => true,\n             GenericArgKind::Lifetime(_) => false,"}, {"sha": "3c55a4b0a8fb1e52040d7a3e6055c2aeb47921d9", "filename": "compiler/rustc_mir/src/monomorphize/polymorphize.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fpolymorphize.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -178,7 +178,7 @@ fn mark_used_by_predicates<'tcx>(\n             // Consider all generic params in a predicate as used if any other parameter in the\n             // predicate is used.\n             let any_param_used = {\n-                let mut vis = HasUsedGenericParams { unused_parameters };\n+                let mut vis = HasUsedGenericParams { tcx, unused_parameters };\n                 predicate.visit_with(&mut vis).is_break()\n             };\n \n@@ -283,9 +283,12 @@ impl<'a, 'tcx> Visitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n }\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n     #[instrument(skip(self))]\n     fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !c.has_param_types_or_consts() {\n+        if !c.potentially_has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -295,7 +298,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n                 self.unused_parameters.clear(param.index);\n                 ControlFlow::CONTINUE\n             }\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted: Some(p)})\n+            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs_: _, promoted: Some(p)})\n                 // Avoid considering `T` unused when constants are of the form:\n                 //   `<Self as Foo<T>>::foo::promoted[p]`\n                 if self.def_id == def.did && !self.tcx.generics_of(def.did).has_self =>\n@@ -306,10 +309,10 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n                 self.visit_body(&promoted[p]);\n                 ControlFlow::CONTINUE\n             }\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted: None })\n-                if self.tcx.def_kind(def.did) == DefKind::AnonConst =>\n+            ty::ConstKind::Unevaluated(uv)\n+                if self.tcx.def_kind(uv.def.did) == DefKind::AnonConst =>\n             {\n-                self.visit_child_body(def.did, substs);\n+                self.visit_child_body(uv.def.did, uv.substs(self.tcx));\n                 ControlFlow::CONTINUE\n             }\n             _ => c.super_visit_with(self),\n@@ -318,7 +321,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n \n     #[instrument(skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !ty.has_param_types_or_consts() {\n+        if !ty.potentially_has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -346,16 +349,21 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for MarkUsedGenericParams<'a, 'tcx> {\n }\n \n /// Visitor used to check if a generic parameter is used.\n-struct HasUsedGenericParams<'a> {\n+struct HasUsedGenericParams<'a, 'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     unused_parameters: &'a FiniteBitSet<u32>,\n }\n \n-impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n+impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a, 'tcx> {\n     type BreakTy = ();\n \n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n     #[instrument(skip(self))]\n     fn visit_const(&mut self, c: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !c.has_param_types_or_consts() {\n+        if !c.potentially_has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n \n@@ -373,7 +381,7 @@ impl<'a, 'tcx> TypeVisitor<'tcx> for HasUsedGenericParams<'a> {\n \n     #[instrument(skip(self))]\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        if !ty.has_param_types_or_consts() {\n+        if !ty.potentially_has_param_types_or_consts() {\n             return ControlFlow::CONTINUE;\n         }\n "}, {"sha": "8083ec954478a136cb6dd25599b6a4b208a21ebb", "filename": "compiler/rustc_mir/src/shim.rs", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fshim.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -163,7 +163,7 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n \n     let source = MirSource::from_instance(ty::InstanceDef::DropGlue(def_id, ty));\n     let mut body =\n-        new_body(source, blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n+        new_body(tcx, source, blocks, local_decls_for_sig(&sig, span), sig.inputs().len(), span);\n \n     if ty.is_some() {\n         // The first argument (index 0), but add 1 for the return value.\n@@ -202,13 +202,15 @@ fn build_drop_shim<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId, ty: Option<Ty<'tcx>>)\n }\n \n fn new_body<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     source: MirSource<'tcx>,\n     basic_blocks: IndexVec<BasicBlock, BasicBlockData<'tcx>>,\n     local_decls: IndexVec<Local, LocalDecl<'tcx>>,\n     arg_count: usize,\n     span: Span,\n ) -> Body<'tcx> {\n     Body::new(\n+        tcx,\n         source,\n         basic_blocks,\n         IndexVec::from_elem_n(\n@@ -353,7 +355,14 @@ impl CloneShimBuilder<'tcx> {\n             self.def_id,\n             self.sig.inputs_and_output[0],\n         ));\n-        new_body(source, self.blocks, self.local_decls, self.sig.inputs().len(), self.span)\n+        new_body(\n+            self.tcx,\n+            source,\n+            self.blocks,\n+            self.local_decls,\n+            self.sig.inputs().len(),\n+            self.span,\n+        )\n     }\n \n     fn source_info(&self) -> SourceInfo {\n@@ -851,8 +860,14 @@ fn build_call_shim<'tcx>(\n         block(&mut blocks, vec![], TerminatorKind::Resume, true);\n     }\n \n-    let mut body =\n-        new_body(MirSource::from_instance(instance), blocks, local_decls, sig.inputs().len(), span);\n+    let mut body = new_body(\n+        tcx,\n+        MirSource::from_instance(instance),\n+        blocks,\n+        local_decls,\n+        sig.inputs().len(),\n+        span,\n+    );\n \n     if let Abi::RustCall = sig.abi {\n         body.spread_arg = Some(Local::new(sig.inputs().len()));\n@@ -917,6 +932,7 @@ pub fn build_adt_ctor(tcx: TyCtxt<'_>, ctor_id: DefId) -> Body<'_> {\n \n     let source = MirSource::item(ctor_id);\n     let body = new_body(\n+        tcx,\n         source,\n         IndexVec::from_elem_n(start_block, 1),\n         local_decls,"}, {"sha": "0361ddc915d4cd67abb4ccf3327630b2a60ab686", "filename": "compiler/rustc_mir/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -365,7 +365,7 @@ impl Checker<'mir, 'tcx> {\n     fn check_local_or_return_ty(&mut self, ty: Ty<'tcx>, local: Local) {\n         let kind = self.body.local_kind(local);\n \n-        for ty in ty.walk() {\n+        for ty in ty.walk(self.tcx) {\n             let ty = match ty.unpack() {\n                 GenericArgKind::Type(ty) => ty,\n "}, {"sha": "413a9638eb37b172717d4473f48079215170cf72", "filename": "compiler/rustc_mir/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -247,7 +247,7 @@ where\n \n     // Check the qualifs of the value of `const` items.\n     if let Some(ct) = constant.literal.const_for_ty() {\n-        if let ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted }) = ct.val {\n+        if let ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs_: _, promoted }) = ct.val {\n             assert!(promoted.is_none());\n             // Don't peek inside trait associated constants.\n             if cx.tcx.trait_of_item(def.did).is_none() {"}, {"sha": "1932cd5de29b5e25a72210f66552700d8e53a9a3", "filename": "compiler/rustc_mir/src/transform/const_prop.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fconst_prop.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -120,7 +120,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n             .predicates_of(def_id.to_def_id())\n             .predicates\n             .iter()\n-            .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+            .filter_map(|(p, _)| if p.is_global(tcx) { Some(*p) } else { None });\n         if traits::impossible_predicates(\n             tcx,\n             traits::elaborate_predicates(tcx, predicates).map(|o| o.predicate).collect(),\n@@ -132,6 +132,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         trace!(\"ConstProp starting for {:?}\", def_id);\n \n         let dummy_body = &Body::new(\n+            tcx,\n             body.source,\n             body.basic_blocks().clone(),\n             body.source_scopes.clone(),\n@@ -468,7 +469,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n     /// Returns the value, if any, of evaluating `c`.\n     fn eval_constant(&mut self, c: &Constant<'tcx>, source_info: SourceInfo) -> Option<OpTy<'tcx>> {\n         // FIXME we need to revisit this for #67176\n-        if c.needs_subst() {\n+        if c.definitely_needs_subst(self.tcx) {\n             return None;\n         }\n \n@@ -483,14 +484,14 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n                             // Promoteds must lint and not error as the user didn't ask for them\n                             ConstKind::Unevaluated(ty::Unevaluated {\n                                 def: _,\n-                                substs: _,\n+                                substs_: _,\n                                 promoted: Some(_),\n                             }) => true,\n                             // Out of backwards compatibility we cannot report hard errors in unused\n                             // generic functions using associated constants of the generic parameters.\n-                            _ => c.literal.needs_subst(),\n+                            _ => c.literal.definitely_needs_subst(*tcx),\n                         },\n-                        ConstantKind::Val(_, ty) => ty.needs_subst(),\n+                        ConstantKind::Val(_, ty) => ty.definitely_needs_subst(*tcx),\n                     };\n                     if lint_only {\n                         // Out of backwards compatibility we cannot report hard errors in unused\n@@ -720,7 +721,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         }\n \n         // FIXME we need to revisit this for #67176\n-        if rvalue.needs_subst() {\n+        if rvalue.definitely_needs_subst(self.tcx) {\n             return None;\n         }\n "}, {"sha": "ba2c91a9347ec5dd45ffc0a33250f8248d86b997", "filename": "compiler/rustc_mir/src/transform/function_item_references.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> Visitor<'tcx> for FunctionItemRefChecker<'a, 'tcx> {\n                     // Handle calls to `transmute`\n                     if self.tcx.is_diagnostic_item(sym::transmute, def_id) {\n                         let arg_ty = args[0].ty(self.body, self.tcx);\n-                        for generic_inner_ty in arg_ty.walk() {\n+                        for generic_inner_ty in arg_ty.walk(self.tcx) {\n                             if let GenericArgKind::Type(inner_ty) = generic_inner_ty.unpack() {\n                                 if let Some((fn_id, fn_substs)) =\n                                     FunctionItemRefChecker::is_fn_ref(inner_ty)\n@@ -110,7 +110,7 @@ impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n                 let arg_defs = self.tcx.fn_sig(def_id).skip_binder().inputs();\n                 for (arg_num, arg_def) in arg_defs.iter().enumerate() {\n                     // For all types reachable from the argument type in the fn sig\n-                    for generic_inner_ty in arg_def.walk() {\n+                    for generic_inner_ty in arg_def.walk(self.tcx) {\n                         if let GenericArgKind::Type(inner_ty) = generic_inner_ty.unpack() {\n                             // If the inner type matches the type bound by `Pointer`\n                             if TyS::same_type(inner_ty, bound_ty) {"}, {"sha": "385394ba67d4d2e8fa0fdc2f8747c59129817d11", "filename": "compiler/rustc_mir/src/transform/inline/cycle.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Finline%2Fcycle.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -89,7 +89,7 @@ crate fn mir_callgraph_reachable(\n                     // FIXME: A not fully substituted drop shim can cause ICEs if one attempts to\n                     // have its MIR built. Likely oli-obk just screwed up the `ParamEnv`s, so this\n                     // needs some more analysis.\n-                    if callee.needs_subst() {\n+                    if callee.definitely_needs_subst(tcx) {\n                         continue;\n                     }\n                 }"}, {"sha": "d4c2456e9a4367f9591b7db075163c7f845da290", "filename": "compiler/rustc_mir/src/transform/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -400,7 +400,7 @@ fn inner_mir_for_ctfe(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -\n         }\n     }\n \n-    debug_assert!(!body.has_free_regions(), \"Free regions in MIR for CTFE\");\n+    debug_assert!(!body.has_free_regions(tcx), \"Free regions in MIR for CTFE\");\n \n     body\n }\n@@ -594,7 +594,7 @@ fn inner_optimized_mir(tcx: TyCtxt<'_>, did: LocalDefId) -> Body<'_> {\n         tcx.mir_drops_elaborated_and_const_checked(ty::WithOptConstParam::unknown(did)).steal();\n     run_optimization_passes(tcx, &mut body);\n \n-    debug_assert!(!body.has_free_regions(), \"Free regions in optimized MIR\");\n+    debug_assert!(!body.has_free_regions(tcx), \"Free regions in optimized MIR\");\n \n     body\n }\n@@ -621,7 +621,7 @@ fn promoted_mir<'tcx>(\n         run_post_borrowck_cleanup_passes(tcx, body);\n     }\n \n-    debug_assert!(!promoted.has_free_regions(), \"Free regions in promoted MIR\");\n+    debug_assert!(!promoted.has_free_regions(tcx), \"Free regions in promoted MIR\");\n \n     tcx.arena.alloc(promoted)\n }"}, {"sha": "1b43670ba3ac103eaa3021f0b2e2a0c7c69545c7", "filename": "compiler/rustc_mir/src/transform/promote_consts.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fpromote_consts.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -859,13 +859,17 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             ty,\n                             val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n                                 def,\n-                                substs: InternalSubsts::for_item(tcx, def.did, |param, _| {\n-                                    if let ty::GenericParamDefKind::Lifetime = param.kind {\n-                                        tcx.lifetimes.re_erased.into()\n-                                    } else {\n-                                        tcx.mk_param_from_def(param)\n-                                    }\n-                                }),\n+                                substs_: Some(InternalSubsts::for_item(\n+                                    tcx,\n+                                    def.did,\n+                                    |param, _| {\n+                                        if let ty::GenericParamDefKind::Lifetime = param.kind {\n+                                            tcx.lifetimes.re_erased.into()\n+                                        } else {\n+                                            tcx.mk_param_from_def(param)\n+                                        }\n+                                    },\n+                                )),\n                                 promoted: Some(promoted_id),\n                             }),\n                         })\n@@ -988,6 +992,7 @@ pub fn promote_candidates<'tcx>(\n         scope.parent_scope = None;\n \n         let promoted = Body::new(\n+            tcx,\n             body.source, // `promoted` gets filled in below\n             IndexVec::new(),\n             IndexVec::from_elem_n(scope, 1),"}, {"sha": "92591db668ce9b7a6f0e9b74ec0b8b48133f648c", "filename": "compiler/rustc_mir/src/util/pretty.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Futil%2Fpretty.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -475,7 +475,7 @@ impl Visitor<'tcx> for ExtraComments<'tcx> {\n                 ty::ConstKind::Unevaluated(uv) => format!(\n                     \"Unevaluated({}, {:?}, {:?})\",\n                     self.tcx.def_path_str(uv.def.did),\n-                    uv.substs,\n+                    uv.substs(self.tcx),\n                     uv.promoted\n                 ),\n                 ty::ConstKind::Value(val) => format!(\"Value({:?})\", val),\n@@ -682,6 +682,12 @@ pub fn write_allocations<'tcx>(\n     }\n     struct CollectAllocIds(BTreeSet<AllocId>);\n     impl<'tcx> TypeVisitor<'tcx> for CollectAllocIds {\n+        fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+            // `AllocId`s are only inside of `ConstKind::Value` which\n+            // can't be part of the anon const default substs.\n+            None\n+        }\n+\n         fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n             if let ty::ConstKind::Value(val) = c.val {\n                 self.0.extend(alloc_ids_from_const(val));"}, {"sha": "0a760a740dcaea5801a8b4bcb854d19ba6758d50", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -239,10 +239,10 @@ fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_\n         // The exception is `body.user_type_annotations`, which is used unmodified\n         // by borrow checking.\n         debug_assert!(\n-            !(body.local_decls.has_free_regions()\n-                || body.basic_blocks().has_free_regions()\n-                || body.var_debug_info.has_free_regions()\n-                || body.yield_ty().has_free_regions()),\n+            !(body.local_decls.has_free_regions(tcx)\n+                || body.basic_blocks().has_free_regions(tcx)\n+                || body.var_debug_info.has_free_regions(tcx)\n+                || body.yield_ty().has_free_regions(tcx)),\n             \"Unexpected free regions in MIR: {:?}\",\n             body,\n         );\n@@ -755,6 +755,7 @@ fn construct_error<'a, 'tcx>(\n     cfg.terminate(START_BLOCK, source_info, TerminatorKind::Unreachable);\n \n     let mut body = Body::new(\n+        tcx,\n         MirSource::item(def.did.to_def_id()),\n         cfg.basic_blocks,\n         source_scopes,\n@@ -843,6 +844,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         }\n \n         Body::new(\n+            self.tcx,\n             MirSource::item(self.def_id),\n             self.cfg.basic_blocks,\n             self.source_scopes,"}, {"sha": "9106f1d2342a4cf088258bab8d1ad35a56a949ad", "filename": "compiler/rustc_mir_build/src/thir/cx/expr.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fcx%2Fexpr.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -693,11 +693,10 @@ impl<'tcx> Cx<'tcx> {\n                                 // and not the beginning of discriminants (which is always `0`)\n                                 let substs = InternalSubsts::identity_for_item(self.tcx(), did);\n                                 let lhs = ty::Const {\n-                                    val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                                        def: ty::WithOptConstParam::unknown(did),\n+                                    val: ty::ConstKind::Unevaluated(ty::Unevaluated::new(\n+                                        ty::WithOptConstParam::unknown(did),\n                                         substs,\n-                                        promoted: None,\n-                                    }),\n+                                    )),\n                                     ty: var_ty,\n                                 };\n                                 let lhs = self.thir.exprs.push(mk_const(self.tcx().mk_const(lhs)));\n@@ -889,11 +888,10 @@ impl<'tcx> Cx<'tcx> {\n                 debug!(\"convert_path_expr: (const) user_ty={:?}\", user_ty);\n                 ExprKind::Literal {\n                     literal: self.tcx.mk_const(ty::Const {\n-                        val: ty::ConstKind::Unevaluated(ty::Unevaluated {\n-                            def: ty::WithOptConstParam::unknown(def_id),\n+                        val: ty::ConstKind::Unevaluated(ty::Unevaluated::new(\n+                            ty::WithOptConstParam::unknown(def_id),\n                             substs,\n-                            promoted: None,\n-                        }),\n+                        )),\n                         ty: self.typeck_results().node_type(expr.hir_id),\n                     }),\n                     user_ty,"}, {"sha": "bbb5de34d1860a84011421cfebb78e1130a76488", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -237,7 +237,7 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n         // code at the moment, because types like `for <'a> fn(&'a ())` do\n         // not *yet* implement `PartialEq`. So for now we leave this here.\n         has_impl\n-            || ty.walk().any(|t| match t.unpack() {\n+            || ty.walk(self.tcx()).any(|t| match t.unpack() {\n                 ty::subst::GenericArgKind::Lifetime(_) => false,\n                 ty::subst::GenericArgKind::Type(t) => t.is_fn_ptr(),\n                 ty::subst::GenericArgKind::Const(_) => false,"}, {"sha": "6fe68a0c17a5d2842ebf2cf196ea4c88b119323d", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -134,11 +134,11 @@ where\n                 ty.visit_with(self)\n             }\n             ty::PredicateKind::RegionOutlives(..) => ControlFlow::CONTINUE,\n-            ty::PredicateKind::ConstEvaluatable(defs, substs)\n+            ty::PredicateKind::ConstEvaluatable(uv)\n                 if self.def_id_visitor.tcx().features().const_evaluatable_checked =>\n             {\n                 let tcx = self.def_id_visitor.tcx();\n-                if let Ok(Some(ct)) = AbstractConst::new(tcx, defs, substs) {\n+                if let Ok(Some(ct)) = AbstractConst::new(tcx, uv) {\n                     self.visit_abstract_const_expr(tcx, ct)?;\n                 }\n                 ControlFlow::CONTINUE\n@@ -179,6 +179,10 @@ where\n {\n     type BreakTy = V::BreakTy;\n \n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.def_id_visitor.tcx())\n+    }\n+\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<V::BreakTy> {\n         let tcx = self.def_id_visitor.tcx();\n         // InternalSubsts are not visited here because they are visited below in `super_visit_with`."}, {"sha": "d85f1c04524dda91e9e06a266e04034fe1d3bf36", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -217,18 +217,13 @@ impl<'tcx> Key for (DefId, SubstsRef<'tcx>) {\n     }\n }\n \n-impl<'tcx> Key\n-    for (\n-        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n-        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n-    )\n-{\n+impl<'tcx> Key for (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>) {\n     #[inline(always)]\n     fn query_crate_is_local(&self) -> bool {\n-        (self.0).0.did.krate == LOCAL_CRATE\n+        (self.0).def.did.krate == LOCAL_CRATE\n     }\n     fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n-        (self.0).0.did.default_span(tcx)\n+        (self.0).def.did.default_span(tcx)\n     }\n }\n "}, {"sha": "e236ef996bcc6034fc0a3dfacade4ce5fb42097f", "filename": "compiler/rustc_symbol_mangling/src/legacy.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flegacy.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -107,9 +107,9 @@ fn get_symbol_hash<'tcx>(\n         tcx.def_path_hash(def_id).hash_stable(&mut hcx, &mut hasher);\n \n         // Include the main item-type. Note that, in this case, the\n-        // assertions about `needs_subst` may not hold, but this item-type\n+        // assertions about `definitely_needs_subst` may not hold, but this item-type\n         // ought to be the same for every reference anyway.\n-        assert!(!item_type.has_erasable_regions());\n+        assert!(!item_type.has_erasable_regions(tcx));\n         hcx.while_hashing_spans(false, |hcx| {\n             hcx.with_node_id_hashing_mode(NodeIdHashingMode::HashDefPath, |hcx| {\n                 item_type.hash_stable(hcx, &mut hasher);"}, {"sha": "521730dfeb01cc22266da68404b104321abf2c39", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -280,7 +280,9 @@ impl Printer<'tcx> for &mut SymbolMangler<'tcx> {\n \n         // Encode impl generic params if the substitutions contain parameters (implying\n         // polymorphization is enabled) and this isn't an inherent impl.\n-        if impl_trait_ref.is_some() && substs.iter().any(|a| a.has_param_types_or_consts()) {\n+        if impl_trait_ref.is_some()\n+            && substs.iter().any(|a| a.definitely_has_param_types_or_consts(self.tcx))\n+        {\n             self = self.path_generic_args(\n                 |this| {\n                     this.path_append_ns("}, {"sha": "b743c809ca2434926b49c0f80ee205744d366cd5", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -352,6 +352,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         if !required_region_bounds.is_empty() {\n             for required_region in required_region_bounds {\n                 concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+                    tcx,\n                     op: |r| self.sub_regions(infer::CallReturn(span), required_region, r),\n                 });\n             }\n@@ -427,6 +428,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             }\n         }\n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx,\n             op: |r| self.sub_regions(infer::CallReturn(span), least_region, r),\n         });\n     }\n@@ -461,6 +463,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         );\n \n         concrete_ty.visit_with(&mut ConstrainOpaqueTypeRegionVisitor {\n+            tcx: self.tcx,\n             op: |r| {\n                 self.member_constraint(\n                     opaque_type_key.def_id,\n@@ -546,14 +549,19 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n //\n // We ignore any type parameters because impl trait values are assumed to\n // capture all the in-scope type parameters.\n-struct ConstrainOpaqueTypeRegionVisitor<OP> {\n+struct ConstrainOpaqueTypeRegionVisitor<'tcx, OP> {\n+    tcx: TyCtxt<'tcx>,\n     op: OP,\n }\n \n-impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<OP>\n+impl<'tcx, OP> TypeVisitor<'tcx> for ConstrainOpaqueTypeRegionVisitor<'tcx, OP>\n where\n     OP: FnMut(ty::Region<'tcx>),\n {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: &ty::Binder<'tcx, T>,\n@@ -575,7 +583,7 @@ where\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         // We're only interested in types involving regions\n-        if !ty.flags().intersects(ty::TypeFlags::HAS_FREE_REGIONS) {\n+        if !ty.flags().intersects(ty::TypeFlags::HAS_POTENTIAL_FREE_REGIONS) {\n             return ControlFlow::CONTINUE;\n         }\n "}, {"sha": "668a74bd6971506b02351ac309a8b892db2661e8", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -391,7 +391,7 @@ fn orphan_check_trait_ref<'tcx>(\n ) -> Result<(), OrphanCheckErr<'tcx>> {\n     debug!(\"orphan_check_trait_ref(trait_ref={:?}, in_crate={:?})\", trait_ref, in_crate);\n \n-    if trait_ref.needs_infer() && trait_ref.needs_subst() {\n+    if trait_ref.needs_infer() && trait_ref.definitely_needs_subst(tcx) {\n         bug!(\n             \"can't orphan check a trait ref with both params and inference variables {:?}\",\n             trait_ref"}, {"sha": "5c0bd1d8962f0b9c8ad29ff17a0fdfaa71d81740", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 24, "deletions": 40, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -19,7 +19,7 @@ use rustc_middle::mir::{self, Rvalue, StatementKind, TerminatorKind};\n use rustc_middle::ty::subst::{Subst, SubstsRef};\n use rustc_middle::ty::{self, TyCtxt, TypeFoldable};\n use rustc_session::lint;\n-use rustc_span::def_id::{DefId, LocalDefId};\n+use rustc_span::def_id::LocalDefId;\n use rustc_span::Span;\n \n use std::cmp;\n@@ -29,26 +29,20 @@ use std::ops::ControlFlow;\n /// Check if a given constant can be evaluated.\n pub fn is_const_evaluatable<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def: ty::WithOptConstParam<DefId>,\n-    substs: SubstsRef<'tcx>,\n+    uv: ty::Unevaluated<'tcx, ()>,\n     param_env: ty::ParamEnv<'tcx>,\n     span: Span,\n ) -> Result<(), NotConstEvaluatable> {\n-    debug!(\"is_const_evaluatable({:?}, {:?})\", def, substs);\n+    debug!(\"is_const_evaluatable({:?})\", uv);\n     if infcx.tcx.features().const_evaluatable_checked {\n         let tcx = infcx.tcx;\n-        match AbstractConst::new(tcx, def, substs)? {\n+        match AbstractConst::new(tcx, uv)? {\n             // We are looking at a generic abstract constant.\n             Some(ct) => {\n                 for pred in param_env.caller_bounds() {\n                     match pred.kind().skip_binder() {\n-                        ty::PredicateKind::ConstEvaluatable(b_def, b_substs) => {\n-                            if b_def == def && b_substs == substs {\n-                                debug!(\"is_const_evaluatable: caller_bound ~~> ok\");\n-                                return Ok(());\n-                            }\n-\n-                            if let Some(b_ct) = AbstractConst::new(tcx, b_def, b_substs)? {\n+                        ty::PredicateKind::ConstEvaluatable(uv) => {\n+                            if let Some(b_ct) = AbstractConst::new(tcx, uv)? {\n                                 // Try to unify with each subtree in the AbstractConst to allow for\n                                 // `N + 1` being const evaluatable even if theres only a `ConstEvaluatable`\n                                 // predicate for `(N + 1) * 2`\n@@ -91,7 +85,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                         let leaf = leaf.subst(tcx, ct.substs);\n                         if leaf.has_infer_types_or_consts() {\n                             failure_kind = FailureKind::MentionsInfer;\n-                        } else if leaf.has_param_types_or_consts() {\n+                        } else if leaf.definitely_has_param_types_or_consts(tcx) {\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n \n@@ -101,7 +95,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n                         let ty = ty.subst(tcx, ct.substs);\n                         if ty.has_infer_types_or_consts() {\n                             failure_kind = FailureKind::MentionsInfer;\n-                        } else if ty.has_param_types_or_consts() {\n+                        } else if ty.definitely_has_param_types_or_consts(tcx) {\n                             failure_kind = cmp::min(failure_kind, FailureKind::MentionsParam);\n                         }\n \n@@ -134,7 +128,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     }\n \n     let future_compat_lint = || {\n-        if let Some(local_def_id) = def.did.as_local() {\n+        if let Some(local_def_id) = uv.def.did.as_local() {\n             infcx.tcx.struct_span_lint_hir(\n                 lint::builtin::CONST_EVALUATABLE_UNCHECKED,\n                 infcx.tcx.hir().local_def_id_to_hir_id(local_def_id),\n@@ -155,16 +149,12 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n     // and hopefully soon change this to an error.\n     //\n     // See #74595 for more details about this.\n-    let concrete = infcx.const_eval_resolve(\n-        param_env,\n-        ty::Unevaluated { def, substs, promoted: None },\n-        Some(span),\n-    );\n-\n-    if concrete.is_ok() && substs.has_param_types_or_consts() {\n-        match infcx.tcx.def_kind(def.did) {\n+    let concrete = infcx.const_eval_resolve(param_env, uv.expand(), Some(span));\n+\n+    if concrete.is_ok() && uv.substs(infcx.tcx).definitely_has_param_types_or_consts(infcx.tcx) {\n+        match infcx.tcx.def_kind(uv.def.did) {\n             DefKind::AnonConst => {\n-                let mir_body = infcx.tcx.mir_for_ctfe_opt_const_arg(def);\n+                let mir_body = infcx.tcx.mir_for_ctfe_opt_const_arg(uv.def);\n \n                 if mir_body.is_polymorphic {\n                     future_compat_lint();\n@@ -176,7 +166,7 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n \n     debug!(?concrete, \"is_const_evaluatable\");\n     match concrete {\n-        Err(ErrorHandled::TooGeneric) => Err(match substs.has_infer_types_or_consts() {\n+        Err(ErrorHandled::TooGeneric) => Err(match uv.has_infer_types_or_consts() {\n             true => NotConstEvaluatable::MentionsInfer,\n             false => NotConstEvaluatable::MentionsParam,\n         }),\n@@ -201,25 +191,22 @@ pub struct AbstractConst<'tcx> {\n     pub substs: SubstsRef<'tcx>,\n }\n \n-impl AbstractConst<'tcx> {\n+impl<'tcx> AbstractConst<'tcx> {\n     pub fn new(\n         tcx: TyCtxt<'tcx>,\n-        def: ty::WithOptConstParam<DefId>,\n-        substs: SubstsRef<'tcx>,\n+        uv: ty::Unevaluated<'tcx, ()>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n-        let inner = tcx.mir_abstract_const_opt_const_arg(def)?;\n-        debug!(\"AbstractConst::new({:?}) = {:?}\", def, inner);\n-        Ok(inner.map(|inner| AbstractConst { inner, substs }))\n+        let inner = tcx.mir_abstract_const_opt_const_arg(uv.def)?;\n+        debug!(\"AbstractConst::new({:?}) = {:?}\", uv, inner);\n+        Ok(inner.map(|inner| AbstractConst { inner, substs: uv.substs(tcx) }))\n     }\n \n     pub fn from_const(\n         tcx: TyCtxt<'tcx>,\n         ct: &ty::Const<'tcx>,\n     ) -> Result<Option<AbstractConst<'tcx>>, ErrorReported> {\n         match ct.val {\n-            ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted: _ }) => {\n-                AbstractConst::new(tcx, def, substs)\n-            }\n+            ty::ConstKind::Unevaluated(uv) => AbstractConst::new(tcx, uv.shrink()),\n             ty::ConstKind::Error(_) => Err(ErrorReported),\n             _ => Ok(None),\n         }\n@@ -569,14 +556,11 @@ pub(super) fn mir_abstract_const<'tcx>(\n \n pub(super) fn try_unify_abstract_consts<'tcx>(\n     tcx: TyCtxt<'tcx>,\n-    ((a, a_substs), (b, b_substs)): (\n-        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n-        (ty::WithOptConstParam<DefId>, SubstsRef<'tcx>),\n-    ),\n+    (a, b): (ty::Unevaluated<'tcx, ()>, ty::Unevaluated<'tcx, ()>),\n ) -> bool {\n     (|| {\n-        if let Some(a) = AbstractConst::new(tcx, a, a_substs)? {\n-            if let Some(b) = AbstractConst::new(tcx, b, b_substs)? {\n+        if let Some(a) = AbstractConst::new(tcx, a)? {\n+            if let Some(b) = AbstractConst::new(tcx, b)? {\n                 return Ok(try_unify(tcx, a, b));\n             }\n         }"}, {"sha": "6a7aafc334ba281e366871e41fdf6d029758a142", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -811,10 +811,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 }\n \n                 match obligation.predicate.kind().skip_binder() {\n-                    ty::PredicateKind::ConstEvaluatable(def, _) => {\n+                    ty::PredicateKind::ConstEvaluatable(uv) => {\n                         let mut err =\n                             self.tcx.sess.struct_span_err(span, \"unconstrained generic constant\");\n-                        let const_span = self.tcx.def_span(def.did);\n+                        let const_span = self.tcx.def_span(uv.def.did);\n                         match self.tcx.sess.source_map().span_to_snippet(const_span) {\n                             Ok(snippet) => err.help(&format!(\n                                 \"try adding a `where` bound using this expression: `where [(); {}]:`\","}, {"sha": "f214930c57fe4bdd04219f70460f40859aff9807", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -543,19 +543,20 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+                ty::PredicateKind::ConstEvaluatable(uv) => {\n                     match const_evaluatable::is_const_evaluatable(\n                         self.selcx.infcx(),\n-                        def_id,\n-                        substs,\n+                        uv,\n                         obligation.param_env,\n                         obligation.cause.span,\n                     ) {\n                         Ok(()) => ProcessResult::Changed(vec![]),\n                         Err(NotConstEvaluatable::MentionsInfer) => {\n                             pending_obligation.stalled_on.clear();\n                             pending_obligation.stalled_on.extend(\n-                                substs.iter().filter_map(TyOrConstInferVar::maybe_from_generic_arg),\n+                                uv.substs(infcx.tcx)\n+                                    .iter()\n+                                    .filter_map(TyOrConstInferVar::maybe_from_generic_arg),\n                             );\n                             ProcessResult::Unchanged\n                         }\n@@ -570,15 +571,16 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n                 ty::PredicateKind::ConstEquate(c1, c2) => {\n                     debug!(?c1, ?c2, \"equating consts\");\n-                    if self.selcx.tcx().features().const_evaluatable_checked {\n+                    let tcx = self.selcx.tcx();\n+                    if tcx.features().const_evaluatable_checked {\n                         // FIXME: we probably should only try to unify abstract constants\n                         // if the constants depend on generic parameters.\n                         //\n                         // Let's just see where this breaks :shrug:\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                             (c1.val, c2.val)\n                         {\n-                            if infcx.try_unify_abstract_consts(a, b) {\n+                            if infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n                                 return ProcessResult::Changed(vec![]);\n                             }\n                         }\n@@ -597,7 +599,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                                 Err(ErrorHandled::TooGeneric) => {\n                                     stalled_on.extend(\n                                         unevaluated\n-                                            .substs\n+                                            .substs(tcx)\n                                             .iter()\n                                             .filter_map(TyOrConstInferVar::maybe_from_generic_arg),\n                                     );\n@@ -668,7 +670,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n         stalled_on: &mut Vec<TyOrConstInferVar<'tcx>>,\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n         let infcx = self.selcx.infcx();\n-        if obligation.predicate.is_global() {\n+        if obligation.predicate.is_known_global() {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n             //\n@@ -727,7 +729,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n     ) -> ProcessResult<PendingPredicateObligation<'tcx>, FulfillmentErrorCode<'tcx>> {\n         let tcx = self.selcx.tcx();\n \n-        if obligation.predicate.is_global() {\n+        if obligation.predicate.is_global(tcx) {\n             // no type variables present, can use evaluation for better caching.\n             // FIXME: consider caching errors too.\n             //\n@@ -766,14 +768,15 @@ fn substs_infer_vars<'a, 'tcx>(\n     selcx: &mut SelectionContext<'a, 'tcx>,\n     substs: ty::Binder<'tcx, SubstsRef<'tcx>>,\n ) -> impl Iterator<Item = TyOrConstInferVar<'tcx>> {\n+    let tcx = selcx.tcx();\n     selcx\n         .infcx()\n         .resolve_vars_if_possible(substs)\n         .skip_binder() // ok because this check doesn't care about regions\n         .iter()\n         .filter(|arg| arg.has_infer_types_or_consts())\n-        .flat_map(|arg| {\n-            let mut walker = arg.walk();\n+        .flat_map(move |arg| {\n+            let mut walker = arg.walk(tcx);\n             while let Some(c) = walker.next() {\n                 if !c.has_infer_types_or_consts() {\n                     walker.visited.remove(&c);"}, {"sha": "554b2950263ec38f3e24eb812ad300672d0d9fe3", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -450,7 +450,7 @@ fn subst_and_check_impossible_predicates<'tcx>(\n     debug!(\"subst_and_check_impossible_predicates(key={:?})\", key);\n \n     let mut predicates = tcx.predicates_of(key.0).instantiate(tcx, key.1).predicates;\n-    predicates.retain(|predicate| !predicate.needs_subst());\n+    predicates.retain(|predicate| !predicate.definitely_needs_subst(tcx));\n     let result = impossible_predicates(tcx, predicates);\n \n     debug!(\"subst_and_check_impossible_predicates(key={:?}) = {:?}\", key, result);"}, {"sha": "dd974e6fd4f1c8046d300727c8e1b937fa850ae5", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -278,7 +278,7 @@ fn predicate_references_self(\n     (predicate, sp): (ty::Predicate<'tcx>, Span),\n ) -> Option<Span> {\n     let self_ty = tcx.types.self_param;\n-    let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n+    let has_self_ty = |arg: &GenericArg<'tcx>| arg.walk(tcx).any(|arg| arg == self_ty.into());\n     match predicate.kind().skip_binder() {\n         ty::PredicateKind::Trait(ref data) => {\n             // In the case of a trait predicate, we can skip the \"self\" type.\n@@ -771,6 +771,9 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n \n     impl<'tcx> TypeVisitor<'tcx> for IllegalSelfTypeVisitor<'tcx> {\n         type BreakTy = ();\n+        fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+            Some(self.tcx)\n+        }\n \n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n             match t.kind() {\n@@ -851,12 +854,12 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n         }\n \n         fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::PredicateKind::ConstEvaluatable(def, substs) = pred.kind().skip_binder() {\n+            if let ty::PredicateKind::ConstEvaluatable(ct) = pred.kind().skip_binder() {\n                 // FIXME(const_evaluatable_checked): We should probably deduplicate the logic for\n                 // `AbstractConst`s here, it might make sense to change `ConstEvaluatable` to\n                 // take a `ty::Const` instead.\n                 use rustc_middle::mir::abstract_const::Node;\n-                if let Ok(Some(ct)) = AbstractConst::new(self.tcx, def, substs) {\n+                if let Ok(Some(ct)) = AbstractConst::new(self.tcx, ct) {\n                     const_evaluatable::walk_abstract_const(self.tcx, ct, |node| match node.root() {\n                         Node::Leaf(leaf) => {\n                             let leaf = leaf.subst(self.tcx, ct.substs);"}, {"sha": "ed5fe466c69f7579afe644b6d5c0e95228493a15", "filename": "compiler/rustc_trait_selection/src/traits/query/normalize.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fnormalize.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -78,8 +78,11 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n         // The rest of the code is already set up to be lazy about replacing bound vars,\n         // and only when we actually have to normalize.\n         if value.has_escaping_bound_vars() {\n-            let mut max_visitor =\n-                MaxEscapingBoundVarVisitor { outer_index: ty::INNERMOST, escaping: 0 };\n+            let mut max_visitor = MaxEscapingBoundVarVisitor {\n+                tcx: self.infcx.tcx,\n+                outer_index: ty::INNERMOST,\n+                escaping: 0,\n+            };\n             value.visit_with(&mut max_visitor);\n             if max_visitor.escaping > 0 {\n                 normalizer.universes.extend((0..max_visitor.escaping).map(|_| None));\n@@ -106,13 +109,18 @@ impl<'cx, 'tcx> AtExt<'tcx> for At<'cx, 'tcx> {\n }\n \n /// Visitor to find the maximum escaping bound var\n-struct MaxEscapingBoundVarVisitor {\n+struct MaxEscapingBoundVarVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     // The index which would count as escaping\n     outer_index: ty::DebruijnIndex,\n     escaping: usize,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for MaxEscapingBoundVarVisitor {\n+impl<'tcx> TypeVisitor<'tcx> for MaxEscapingBoundVarVisitor<'tcx> {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: &ty::Binder<'tcx, T>,"}, {"sha": "c571a1d628427f6af88f025a94195d1c39b1c8f2", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -947,7 +947,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n                 let mut unsizing_params = GrowableBitSet::new_empty();\n                 if tcx.features().relaxed_struct_unsize {\n-                    for arg in tail_field_ty.walk() {\n+                    for arg in tail_field_ty.walk(tcx) {\n                         if let Some(i) = maybe_unsizing_param_idx(arg) {\n                             unsizing_params.insert(i);\n                         }\n@@ -956,7 +956,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // Ensure none of the other fields mention the parameters used\n                     // in unsizing.\n                     for field in prefix_fields {\n-                        for arg in tcx.type_of(field.did).walk() {\n+                        for arg in tcx.type_of(field.did).walk(tcx) {\n                             if let Some(i) = maybe_unsizing_param_idx(arg) {\n                                 unsizing_params.remove(i);\n                             }\n@@ -968,7 +968,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 } else {\n                     let mut found = false;\n-                    for arg in tail_field_ty.walk() {\n+                    for arg in tail_field_ty.walk(tcx) {\n                         if let Some(i) = maybe_unsizing_param_idx(arg) {\n                             unsizing_params.insert(i);\n                             found = true;\n@@ -984,7 +984,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     // by putting it in a query; it would only need the `DefId` as it\n                     // looks at declared field types, not anything substituted.\n                     for field in prefix_fields {\n-                        for arg in tcx.type_of(field.did).walk() {\n+                        for arg in tcx.type_of(field.did).walk(tcx) {\n                             if let Some(i) = maybe_unsizing_param_idx(arg) {\n                                 if unsizing_params.contains(i) {\n                                     return Err(Unimplemented);"}, {"sha": "1580562a92f38ac6fa5b78f763beb16140a75103", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -544,7 +544,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 },\n \n                 ty::PredicateKind::TypeOutlives(pred) => {\n-                    if pred.0.is_global() {\n+                    if pred.0.is_known_global() {\n                         Ok(EvaluatedToOk)\n                     } else {\n                         Ok(EvaluatedToOkModuloRegions)\n@@ -598,11 +598,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+                ty::PredicateKind::ConstEvaluatable(uv) => {\n                     match const_evaluatable::is_const_evaluatable(\n                         self.infcx,\n-                        def_id,\n-                        substs,\n+                        uv,\n                         obligation.param_env,\n                         obligation.cause.span,\n                     ) {\n@@ -624,7 +623,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         if let (ty::ConstKind::Unevaluated(a), ty::ConstKind::Unevaluated(b)) =\n                             (c1.val, c2.val)\n                         {\n-                            if self.infcx.try_unify_abstract_consts(a, b) {\n+                            if self.infcx.try_unify_abstract_consts(a.shrink(), b.shrink()) {\n                                 return Ok(EvaluatedToOk);\n                             }\n                         }\n@@ -692,8 +691,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         debug!(?obligation, \"evaluate_trait_predicate_recursively\");\n \n         if !self.intercrate\n-            && obligation.is_global()\n-            && obligation.param_env.caller_bounds().iter().all(|bound| bound.needs_subst())\n+            && obligation.is_global(self.tcx())\n+            && obligation\n+                .param_env\n+                .caller_bounds()\n+                .iter()\n+                .all(|bound| bound.definitely_needs_subst(self.tcx()))\n         {\n             // If a param env has no global bounds, global obligations do not\n             // depend on its particular value in order to work, so we can clear\n@@ -1452,7 +1455,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         // the param_env so that it can be given the lowest priority. See\n         // #50825 for the motivation for this.\n         let is_global =\n-            |cand: &ty::PolyTraitRef<'_>| cand.is_global() && !cand.has_late_bound_regions();\n+            |cand: &ty::PolyTraitRef<'_>| cand.is_known_global() && !cand.has_late_bound_regions();\n \n         // (*) Prefer `BuiltinCandidate { has_nested: false }`, `PointeeCandidate`,\n         // and `DiscriminantKindCandidate` to anything else."}, {"sha": "ac8bab0cf36a77913ab3c5a5cd57de7e6ac9b478", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -130,6 +130,9 @@ impl Search<'a, 'tcx> {\n \n impl<'a, 'tcx> TypeVisitor<'tcx> for Search<'a, 'tcx> {\n     type BreakTy = NonStructuralMatchTy<'tcx>;\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx())\n+    }\n \n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         debug!(\"Search visiting ty: {:?}\", ty);"}, {"sha": "75307f135636be8f9be8f425e12f9a4b6c30207e", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -132,8 +132,9 @@ pub fn predicate_obligations<'a, 'tcx>(\n             wf.compute(a.into());\n             wf.compute(b.into());\n         }\n-        ty::PredicateKind::ConstEvaluatable(def, substs) => {\n-            let obligations = wf.nominal_obligations(def.did, substs);\n+        ty::PredicateKind::ConstEvaluatable(uv) => {\n+            let substs = uv.substs(wf.tcx());\n+            let obligations = wf.nominal_obligations(uv.def.did, substs);\n             wf.out.extend(obligations);\n \n             for arg in substs.iter() {\n@@ -422,7 +423,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n     /// Pushes all the predicates needed to validate that `ty` is WF into `out`.\n     fn compute(&mut self, arg: GenericArg<'tcx>) {\n-        let mut walker = arg.walk();\n+        let mut walker = arg.walk(self.tcx());\n         let param_env = self.param_env;\n         let depth = self.recursion_depth;\n         while let Some(arg) = walker.next() {\n@@ -435,14 +436,17 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n                 GenericArgKind::Const(constant) => {\n                     match constant.val {\n-                        ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs, promoted }) => {\n-                            assert!(promoted.is_none());\n+                        ty::ConstKind::Unevaluated(uv) => {\n+                            assert!(uv.promoted.is_none());\n+                            let substs = uv.substs(self.tcx());\n \n-                            let obligations = self.nominal_obligations(def.did, substs);\n+                            let obligations = self.nominal_obligations(uv.def.did, substs);\n                             self.out.extend(obligations);\n \n-                            let predicate = ty::PredicateKind::ConstEvaluatable(def, substs)\n-                                .to_predicate(self.tcx());\n+                            let predicate = ty::PredicateKind::ConstEvaluatable(\n+                                ty::Unevaluated::new(uv.def, substs),\n+                            )\n+                            .to_predicate(self.tcx());\n                             let cause = self.cause(traits::MiscObligation);\n                             self.out.push(traits::Obligation::with_depth(\n                                 cause,"}, {"sha": "1d4196e574782622ef60bedabf932a003acf0ae1", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -806,7 +806,7 @@ crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n     tcx: TyCtxt<'tcx>,\n     ty: Binder<'tcx, T>,\n ) -> (T, chalk_ir::VariableKinds<RustInterner<'tcx>>, BTreeMap<DefId, u32>) {\n-    let mut bound_vars_collector = BoundVarsCollector::new();\n+    let mut bound_vars_collector = BoundVarsCollector::new(tcx);\n     ty.as_ref().skip_binder().visit_with(&mut bound_vars_collector);\n     let mut parameters = bound_vars_collector.parameters;\n     let named_parameters: BTreeMap<DefId, u32> = bound_vars_collector\n@@ -836,14 +836,16 @@ crate fn collect_bound_vars<'tcx, T: TypeFoldable<'tcx>>(\n }\n \n crate struct BoundVarsCollector<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     binder_index: ty::DebruijnIndex,\n     crate parameters: BTreeMap<u32, chalk_ir::VariableKind<RustInterner<'tcx>>>,\n     crate named_parameters: Vec<DefId>,\n }\n \n impl<'tcx> BoundVarsCollector<'tcx> {\n-    crate fn new() -> Self {\n+    crate fn new(tcx: TyCtxt<'tcx>) -> Self {\n         BoundVarsCollector {\n+            tcx,\n             binder_index: ty::INNERMOST,\n             parameters: BTreeMap::new(),\n             named_parameters: vec![],\n@@ -852,6 +854,10 @@ impl<'tcx> BoundVarsCollector<'tcx> {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: &Binder<'tcx, T>,\n@@ -1070,6 +1076,11 @@ impl PlaceholdersCollector {\n }\n \n impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        // Anon const substs do not contain placeholders by default.\n+        None\n+    }\n+\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match t.kind() {\n             ty::Placeholder(p) if p.universe == self.universe_index => {"}, {"sha": "b00d2ab35617f5d8986357ffe9c13d4a9ba545d9", "filename": "compiler/rustc_ty_utils/src/instance.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Finstance.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -54,6 +54,10 @@ impl<'tcx> BoundVarsCollector<'tcx> {\n impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n     type BreakTy = ();\n \n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        // Anon const substs do not contain bound vars by default.\n+        None\n+    }\n     fn visit_binder<T: TypeFoldable<'tcx>>(\n         &mut self,\n         t: &Binder<'tcx, T>,"}, {"sha": "1b0fff93a99fbbf0e20469fad0070433e0b830f5", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -361,7 +361,7 @@ fn well_formed_types_in_env<'tcx>(\n         // constituents are well-formed.\n         NodeKind::InherentImpl => {\n             let self_ty = tcx.type_of(def_id);\n-            inputs.extend(self_ty.walk());\n+            inputs.extend(self_ty.walk(tcx));\n         }\n \n         // In an fn, we assume that the arguments and all their constituents are\n@@ -370,7 +370,7 @@ fn well_formed_types_in_env<'tcx>(\n             let fn_sig = tcx.fn_sig(def_id);\n             let fn_sig = tcx.liberate_late_bound_regions(def_id, fn_sig);\n \n-            inputs.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk()));\n+            inputs.extend(fn_sig.inputs().iter().flat_map(|ty| ty.walk(tcx)));\n         }\n \n         NodeKind::Other => (),"}, {"sha": "c405bbe2d1f53abb2193df1b8a478db40843ced5", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 67, "deletions": 45, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -19,94 +19,116 @@ bitflags! {\n         // Does this have parameters? Used to determine whether substitution is\n         // required.\n         /// Does this have `Param`?\n-        const HAS_TY_PARAM                = 1 << 0;\n+        const HAS_KNOWN_TY_PARAM                = 1 << 0;\n         /// Does this have `ReEarlyBound`?\n-        const HAS_RE_PARAM                = 1 << 1;\n+        const HAS_KNOWN_RE_PARAM                = 1 << 1;\n         /// Does this have `ConstKind::Param`?\n-        const HAS_CT_PARAM                = 1 << 2;\n+        const HAS_KNOWN_CT_PARAM                = 1 << 2;\n \n-        const NEEDS_SUBST                 = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_RE_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits;\n+        const KNOWN_NEEDS_SUBST                 = TypeFlags::HAS_KNOWN_TY_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_RE_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_CT_PARAM.bits;\n \n         /// Does this have `Infer`?\n-        const HAS_TY_INFER                = 1 << 3;\n+        const HAS_TY_INFER                      = 1 << 3;\n         /// Does this have `ReVar`?\n-        const HAS_RE_INFER                = 1 << 4;\n+        const HAS_RE_INFER                      = 1 << 4;\n         /// Does this have `ConstKind::Infer`?\n-        const HAS_CT_INFER                = 1 << 5;\n+        const HAS_CT_INFER                      = 1 << 5;\n \n         /// Does this have inference variables? Used to determine whether\n         /// inference is required.\n-        const NEEDS_INFER                 = TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_RE_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits;\n+        const NEEDS_INFER                       = TypeFlags::HAS_TY_INFER.bits\n+                                                | TypeFlags::HAS_RE_INFER.bits\n+                                                | TypeFlags::HAS_CT_INFER.bits;\n \n         /// Does this have `Placeholder`?\n-        const HAS_TY_PLACEHOLDER          = 1 << 6;\n+        const HAS_TY_PLACEHOLDER                = 1 << 6;\n         /// Does this have `RePlaceholder`?\n-        const HAS_RE_PLACEHOLDER          = 1 << 7;\n+        const HAS_RE_PLACEHOLDER                = 1 << 7;\n         /// Does this have `ConstKind::Placeholder`?\n-        const HAS_CT_PLACEHOLDER          = 1 << 8;\n+        const HAS_CT_PLACEHOLDER                = 1 << 8;\n \n         /// `true` if there are \"names\" of regions and so forth\n         /// that are local to a particular fn/inferctxt\n-        const HAS_FREE_LOCAL_REGIONS      = 1 << 9;\n+        const HAS_KNOWN_FREE_LOCAL_REGIONS      = 1 << 9;\n \n         /// `true` if there are \"names\" of types and regions and so forth\n         /// that are local to a particular fn\n-        const HAS_FREE_LOCAL_NAMES        = TypeFlags::HAS_TY_PARAM.bits\n-                                          | TypeFlags::HAS_CT_PARAM.bits\n-                                          | TypeFlags::HAS_TY_INFER.bits\n-                                          | TypeFlags::HAS_CT_INFER.bits\n-                                          | TypeFlags::HAS_TY_PLACEHOLDER.bits\n-                                          | TypeFlags::HAS_CT_PLACEHOLDER.bits\n-                                          // We consider 'freshened' types and constants\n-                                          // to depend on a particular fn.\n-                                          // The freshening process throws away information,\n-                                          // which can make things unsuitable for use in a global\n-                                          // cache. Note that there is no 'fresh lifetime' flag -\n-                                          // freshening replaces all lifetimes with `ReErased`,\n-                                          // which is different from how types/const are freshened.\n-                                          | TypeFlags::HAS_TY_FRESH.bits\n-                                          | TypeFlags::HAS_CT_FRESH.bits\n-                                          | TypeFlags::HAS_FREE_LOCAL_REGIONS.bits;\n+        const HAS_KNOWN_FREE_LOCAL_NAMES        = TypeFlags::HAS_KNOWN_TY_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_CT_PARAM.bits\n+                                                | TypeFlags::HAS_TY_INFER.bits\n+                                                | TypeFlags::HAS_CT_INFER.bits\n+                                                | TypeFlags::HAS_TY_PLACEHOLDER.bits\n+                                                | TypeFlags::HAS_CT_PLACEHOLDER.bits\n+                                                // We consider 'freshened' types and constants\n+                                                // to depend on a particular fn.\n+                                                // The freshening process throws away information,\n+                                                // which can make things unsuitable for use in a global\n+                                                // cache. Note that there is no 'fresh lifetime' flag -\n+                                                // freshening replaces all lifetimes with `ReErased`,\n+                                                // which is different from how types/const are freshened.\n+                                                | TypeFlags::HAS_TY_FRESH.bits\n+                                                | TypeFlags::HAS_CT_FRESH.bits\n+                                                | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS.bits;\n+\n+        const HAS_POTENTIAL_FREE_LOCAL_NAMES    = TypeFlags::HAS_KNOWN_FREE_LOCAL_NAMES.bits\n+                                                | TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS.bits;\n \n         /// Does this have `Projection`?\n-        const HAS_TY_PROJECTION           = 1 << 10;\n+        const HAS_TY_PROJECTION                 = 1 << 10;\n         /// Does this have `Opaque`?\n-        const HAS_TY_OPAQUE               = 1 << 11;\n+        const HAS_TY_OPAQUE                     = 1 << 11;\n         /// Does this have `ConstKind::Unevaluated`?\n-        const HAS_CT_PROJECTION           = 1 << 12;\n+        const HAS_CT_PROJECTION                 = 1 << 12;\n \n         /// Could this type be normalized further?\n-        const HAS_PROJECTION              = TypeFlags::HAS_TY_PROJECTION.bits\n-                                          | TypeFlags::HAS_TY_OPAQUE.bits\n-                                          | TypeFlags::HAS_CT_PROJECTION.bits;\n+        const HAS_PROJECTION                    = TypeFlags::HAS_TY_PROJECTION.bits\n+                                                | TypeFlags::HAS_TY_OPAQUE.bits\n+                                                | TypeFlags::HAS_CT_PROJECTION.bits;\n \n         /// Is an error type/const reachable?\n-        const HAS_ERROR                   = 1 << 13;\n+        const HAS_ERROR                         = 1 << 13;\n \n         /// Does this have any region that \"appears free\" in the type?\n         /// Basically anything but `ReLateBound` and `ReErased`.\n-        const HAS_FREE_REGIONS            = 1 << 14;\n+        const HAS_KNOWN_FREE_REGIONS            = 1 << 14;\n+\n+        const HAS_POTENTIAL_FREE_REGIONS        = TypeFlags::HAS_KNOWN_FREE_REGIONS.bits\n+                                                | TypeFlags::HAS_UNKNOWN_DEFAULT_CONST_SUBSTS.bits;\n \n         /// Does this have any `ReLateBound` regions? Used to check\n         /// if a global bound is safe to evaluate.\n-        const HAS_RE_LATE_BOUND           = 1 << 15;\n+        const HAS_RE_LATE_BOUND                 = 1 << 15;\n \n         /// Does this have any `ReErased` regions?\n-        const HAS_RE_ERASED               = 1 << 16;\n+        const HAS_RE_ERASED                     = 1 << 16;\n \n         /// Does this value have parameters/placeholders/inference variables which could be\n         /// replaced later, in a way that would change the results of `impl` specialization?\n-        const STILL_FURTHER_SPECIALIZABLE = 1 << 17;\n+        ///\n+        /// Note that this flag being set is not a guarantee, as it is also\n+        /// set if there are any anon consts with unknown default substs.\n+        const STILL_FURTHER_SPECIALIZABLE       = 1 << 17;\n \n         /// Does this value have `InferTy::FreshTy/FreshIntTy/FreshFloatTy`?\n-        const HAS_TY_FRESH                = 1 << 18;\n+        const HAS_TY_FRESH                      = 1 << 18;\n \n         /// Does this value have `InferConst::Fresh`?\n-        const HAS_CT_FRESH                = 1 << 19;\n+        const HAS_CT_FRESH                      = 1 << 19;\n+\n+        /// Does this value have unknown default anon const substs.\n+        ///\n+        /// For more details refer to...\n+        /// FIXME(@lcnr): ask me for now, still have to write all of this.\n+        const HAS_UNKNOWN_DEFAULT_CONST_SUBSTS  = 1 << 20;\n+        /// Flags which can be influenced by default anon const substs.\n+        const MAY_NEED_DEFAULT_CONST_SUBSTS     = TypeFlags::HAS_KNOWN_RE_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_TY_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_CT_PARAM.bits\n+                                                | TypeFlags::HAS_KNOWN_FREE_LOCAL_REGIONS.bits\n+                                                | TypeFlags::HAS_KNOWN_FREE_REGIONS.bits;\n+\n     }\n }\n "}, {"sha": "d916ff7db3d51af667b793f99bd1b52b08f9b2bf", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -394,7 +394,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     if self.is_object && has_default {\n                         let default_ty = tcx.at(self.span).type_of(param.def_id);\n                         let self_param = tcx.types.self_param;\n-                        if default_ty.walk().any(|arg| arg == self_param.into()) {\n+                        if default_ty.walk(tcx).any(|arg| arg == self_param.into()) {\n                             // There is no suitable inference default for a type parameter\n                             // that references self, in an object type.\n                             return true;\n@@ -1354,7 +1354,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that.\n                         let references_self =\n-                            pred.skip_binder().ty.walk().any(|arg| arg == dummy_self.into());\n+                            pred.skip_binder().ty.walk(tcx).any(|arg| arg == dummy_self.into());\n \n                         // If the projection output contains `Self`, force the user to\n                         // elaborate it explicitly to avoid a lot of complexity.\n@@ -2204,7 +2204,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 self.prohibit_generics(path.segments);\n                 // Try to evaluate any array length constants.\n                 let normalized_ty = self.normalize_ty(span, tcx.at(span).type_of(def_id));\n-                if forbid_generic && normalized_ty.needs_subst() {\n+                if forbid_generic && normalized_ty.definitely_needs_subst(tcx) {\n                     let mut err = tcx.sess.struct_span_err(\n                         path.span,\n                         \"generic `Self` types are currently not permitted in anonymous constants\","}, {"sha": "3c9d5b4def4e7a83a67655167919346a98b78eb7", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -470,14 +470,17 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n     debug!(?item, ?span);\n \n     struct FoundParentLifetime;\n-    struct FindParentLifetimeVisitor<'tcx>(&'tcx ty::Generics);\n+    struct FindParentLifetimeVisitor<'tcx>(TyCtxt<'tcx>, &'tcx ty::Generics);\n     impl<'tcx> ty::fold::TypeVisitor<'tcx> for FindParentLifetimeVisitor<'tcx> {\n         type BreakTy = FoundParentLifetime;\n+        fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+            Some(self.0)\n+        }\n \n         fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n             debug!(\"FindParentLifetimeVisitor: r={:?}\", r);\n             if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n-                if *index < self.0.parent_count as u32 {\n+                if *index < self.1.parent_count as u32 {\n                     return ControlFlow::Break(FoundParentLifetime);\n                 } else {\n                     return ControlFlow::CONTINUE;\n@@ -499,21 +502,24 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n     }\n \n     struct ProhibitOpaqueVisitor<'tcx> {\n+        tcx: TyCtxt<'tcx>,\n         opaque_identity_ty: Ty<'tcx>,\n         generics: &'tcx ty::Generics,\n-        tcx: TyCtxt<'tcx>,\n         selftys: Vec<(Span, Option<String>)>,\n     }\n \n     impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n         type BreakTy = Ty<'tcx>;\n+        fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+            Some(self.tcx)\n+        }\n \n         fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n             debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n             if t == self.opaque_identity_ty {\n                 ControlFlow::CONTINUE\n             } else {\n-                t.super_visit_with(&mut FindParentLifetimeVisitor(self.generics))\n+                t.super_visit_with(&mut FindParentLifetimeVisitor(self.tcx, self.generics))\n                     .map_break(|FoundParentLifetime| t)\n             }\n         }\n@@ -1476,7 +1482,7 @@ pub(super) fn check_type_params_are_used<'tcx>(\n         return;\n     }\n \n-    for leaf in ty.walk() {\n+    for leaf in ty.walk(tcx) {\n         if let GenericArgKind::Type(leaf_ty) = leaf.unpack() {\n             if let ty::Param(param) = leaf_ty.kind() {\n                 debug!(\"found use of ty param {:?}\", param);\n@@ -1578,8 +1584,12 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n                 .filter_map(|e| typeck_results.node_type_opt(e.hir_id).map(|t| (e.span, t)))\n                 .filter(|(_, ty)| !matches!(ty.kind(), ty::Never))\n             {\n-                struct VisitTypes(Vec<DefId>);\n-                impl<'tcx> ty::fold::TypeVisitor<'tcx> for VisitTypes {\n+                struct OpaqueTypeCollector(Vec<DefId>);\n+                impl<'tcx> ty::fold::TypeVisitor<'tcx> for OpaqueTypeCollector {\n+                    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+                        // Default anon const substs cannot contain opaque types.\n+                        None\n+                    }\n                     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                         match *t.kind() {\n                             ty::Opaque(def, _) => {\n@@ -1590,7 +1600,7 @@ fn opaque_type_cycle_error(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n                         }\n                     }\n                 }\n-                let mut visitor = VisitTypes(vec![]);\n+                let mut visitor = OpaqueTypeCollector(vec![]);\n                 ty.visit_with(&mut visitor);\n                 for def_id in visitor.0 {\n                     let ty_span = tcx.def_span(def_id);"}, {"sha": "fd150978f0074d8a5c4aea01e80090906b03221a", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -236,9 +236,9 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n                     relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 (\n-                    ty::PredicateKind::ConstEvaluatable(def_a, substs_a),\n-                    ty::PredicateKind::ConstEvaluatable(def_b, substs_b),\n-                ) => tcx.try_unify_abstract_consts(((def_a, substs_a), (def_b, substs_b))),\n+                    ty::PredicateKind::ConstEvaluatable(a),\n+                    ty::PredicateKind::ConstEvaluatable(b),\n+                ) => tcx.try_unify_abstract_consts((a, b)),\n                 (ty::PredicateKind::TypeOutlives(a), ty::PredicateKind::TypeOutlives(b)) => {\n                     relator.relate(predicate.rebind(a.0), p.rebind(b.0)).is_ok()\n                 }"}, {"sha": "25d1c8706e874db89651462d90596388b7049189", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -239,7 +239,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             self.tag(),\n         );\n \n-        if Self::can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n+        if self.can_contain_user_lifetime_bounds((substs, user_self_ty)) {\n             let canonicalized = self.infcx.canonicalize_user_type_annotation(UserType::TypeOf(\n                 def_id,\n                 UserSubsts { substs, user_self_ty },\n@@ -481,7 +481,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let ty = self.to_ty(ast_ty);\n         debug!(\"to_ty_saving_user_provided_ty: ty={:?}\", ty);\n \n-        if Self::can_contain_user_lifetime_bounds(ty) {\n+        if self.can_contain_user_lifetime_bounds(ty) {\n             let c_ty = self.infcx.canonicalize_response(UserType::Ty(ty));\n             debug!(\"to_ty_saving_user_provided_ty: c_ty={:?}\", c_ty);\n             self.typeck_results.borrow_mut().user_provided_types_mut().insert(ast_ty.hir_id, c_ty);\n@@ -526,11 +526,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     // reader, although I have my doubts). Also pass in types with inference\n     // types, because they may be repeated. Other sorts of things are already\n     // sufficiently enforced with erased regions. =)\n-    fn can_contain_user_lifetime_bounds<T>(t: T) -> bool\n+    fn can_contain_user_lifetime_bounds<T>(&self, t: T) -> bool\n     where\n         T: TypeFoldable<'tcx>,\n     {\n-        t.has_free_regions() || t.has_projections() || t.has_infer_types()\n+        t.has_free_regions(self.tcx) || t.has_projections() || t.has_infer_types()\n     }\n \n     pub fn node_ty(&self, id: hir::HirId) -> Ty<'tcx> {"}, {"sha": "9efb52a08b7e10eb98daaab1dd43f2bebf7b5987", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -937,7 +937,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         let ty = self.resolve_vars_if_possible(ty);\n                         // We walk the argument type because the argument's type could have\n                         // been `Option<T>`, but the `FulfillmentError` references `T`.\n-                        if ty.walk().any(|arg| arg == predicate.self_ty().into()) {\n+                        if ty.walk(self.tcx).any(|arg| arg == predicate.self_ty().into()) {\n                             Some(i)\n                         } else {\n                             None"}, {"sha": "9b495fba1975d01824abb7bb3095de2458d9c289", "filename": "compiler/rustc_typeck/src/check/op.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fop.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -428,7 +428,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     }\n                 }\n                 if let Some(missing_trait) = missing_trait {\n-                    let mut visitor = TypeParamVisitor(vec![]);\n+                    let mut visitor = TypeParamVisitor(self.tcx, vec![]);\n                     visitor.visit_ty(lhs_ty);\n \n                     if op.node == hir::BinOpKind::Add\n@@ -439,7 +439,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         // This has nothing here because it means we did string\n                         // concatenation (e.g., \"Hello \" + \"World!\"). This means\n                         // we don't want the note in the else clause to be emitted\n-                    } else if let [ty] = &visitor.0[..] {\n+                    } else if let [ty] = &visitor.1[..] {\n                         if let ty::Param(p) = *ty.kind() {\n                             // Check if the method would be found if the type param wasn't\n                             // involved. If so, it means that adding a trait bound to the param is\n@@ -1003,12 +1003,15 @@ fn suggest_constraining_param(\n     }\n }\n \n-struct TypeParamVisitor<'tcx>(Vec<Ty<'tcx>>);\n+struct TypeParamVisitor<'tcx>(TyCtxt<'tcx>, Vec<Ty<'tcx>>);\n \n impl<'tcx> TypeVisitor<'tcx> for TypeParamVisitor<'tcx> {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.0)\n+    }\n     fn visit_ty(&mut self, ty: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         if let ty::Param(_) = ty.kind() {\n-            self.0.push(ty);\n+            self.1.push(ty);\n         }\n         ty.super_visit_with(self)\n     }"}, {"sha": "2e01e99d36ec68dd848a2a605a7dea1fd89857c2", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -541,10 +541,10 @@ fn check_type_defn<'tcx, F>(\n                 fcx.register_predicate(traits::Obligation::new(\n                     cause,\n                     fcx.param_env,\n-                    ty::PredicateKind::ConstEvaluatable(\n+                    ty::PredicateKind::ConstEvaluatable(ty::Unevaluated::new(\n                         ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n                         discr_substs,\n-                    )\n+                    ))\n                     .to_predicate(tcx),\n                 ));\n             }\n@@ -746,7 +746,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     // Ignore dependent defaults -- that is, where the default of one type\n                     // parameter includes another (e.g., `<T, U = T>`). In those cases, we can't\n                     // be sure if it will error or not as user might always specify the other.\n-                    if !ty.needs_subst() {\n+                    if !ty.definitely_needs_subst(tcx) {\n                         fcx.register_wf_obligation(\n                             ty.into(),\n                             tcx.def_span(param.def_id),\n@@ -762,7 +762,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     // for `struct Foo<const N: usize, const M: usize = { 1 - 2 }>`\n                     // we should eagerly error.\n                     let default_ct = tcx.const_param_default(param.def_id);\n-                    if !default_ct.needs_subst() {\n+                    if !default_ct.definitely_needs_subst(tcx) {\n                         fcx.register_wf_obligation(\n                             default_ct.into(),\n                             tcx.def_span(param.def_id),\n@@ -796,7 +796,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 if is_our_default(param) {\n                     let default_ty = tcx.type_of(param.def_id);\n                     // ... and it's not a dependent default, ...\n-                    if !default_ty.needs_subst() {\n+                    if !default_ty.definitely_needs_subst(tcx) {\n                         // ... then substitute it with the default.\n                         return default_ty.into();\n                     }\n@@ -809,7 +809,7 @@ fn check_where_clauses<'tcx, 'fcx>(\n                 if is_our_default(param) {\n                     let default_ct = tcx.const_param_default(param.def_id);\n                     // ... and it's not a dependent default, ...\n-                    if !default_ct.needs_subst() {\n+                    if !default_ct.definitely_needs_subst(tcx) {\n                         // ... then substitute it with the default.\n                         return default_ct.into();\n                     }\n@@ -825,12 +825,15 @@ fn check_where_clauses<'tcx, 'fcx>(\n         .predicates\n         .iter()\n         .flat_map(|&(pred, sp)| {\n-            #[derive(Default)]\n-            struct CountParams {\n+            struct CountParams<'tcx> {\n+                tcx: TyCtxt<'tcx>,\n                 params: FxHashSet<u32>,\n             }\n-            impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams {\n+            impl<'tcx> ty::fold::TypeVisitor<'tcx> for CountParams<'tcx> {\n                 type BreakTy = ();\n+                fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+                    Some(self.tcx)\n+                }\n \n                 fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n                     if let ty::Param(param) = t.kind() {\n@@ -850,12 +853,12 @@ fn check_where_clauses<'tcx, 'fcx>(\n                     c.super_visit_with(self)\n                 }\n             }\n-            let mut param_count = CountParams::default();\n+            let mut param_count = CountParams { tcx: fcx.tcx, params: FxHashSet::default() };\n             let has_region = pred.visit_with(&mut param_count).is_break();\n             let substituted_pred = pred.subst(tcx, substs);\n             // Don't check non-defaulted params, dependent defaults (including lifetimes)\n             // or preds with multiple params.\n-            if substituted_pred.has_param_types_or_consts()\n+            if substituted_pred.definitely_has_param_types_or_consts(tcx)\n                 || param_count.params.len() > 1\n                 || has_region\n             {\n@@ -1377,7 +1380,7 @@ fn check_false_global_bounds(fcx: &FnCtxt<'_, '_>, span: Span, id: hir::HirId) {\n     for obligation in implied_obligations {\n         let pred = obligation.predicate;\n         // Match the existing behavior.\n-        if pred.is_global() && !pred.has_late_bound_regions() {\n+        if pred.is_global(fcx.tcx) && !pred.has_late_bound_regions() {\n             let pred = fcx.normalize_associated_types_in(span, pred);\n             let obligation = traits::Obligation::new(\n                 traits::ObligationCause::new(span, id, traits::TrivialBound),"}, {"sha": "c57ec9ef78f6856804cbe95c990e5b3b6a56241e", "filename": "compiler/rustc_typeck/src/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwriteback.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -130,7 +130,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn write_ty_to_typeck_results(&mut self, hir_id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty_to_typeck_results({:?}, {:?})\", hir_id, ty);\n-        assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n+        assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions(self.tcx()));\n         self.typeck_results.node_types_mut().insert(hir_id, ty);\n     }\n "}, {"sha": "75f9405e082ca3c5a6a3b7de96a786743025d9b4", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -68,6 +68,7 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n pub fn provide(providers: &mut Providers) {\n     *providers = Providers {\n         opt_const_param_of: type_of::opt_const_param_of,\n+        default_anon_const_substs: type_of::default_anon_const_substs,\n         type_of: type_of::type_of,\n         item_bounds: item_bounds::item_bounds,\n         explicit_item_bounds: item_bounds::explicit_item_bounds,\n@@ -2320,7 +2321,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n             tcx,\n             &mut predicates,\n             trait_ref,\n-            &mut cgp::parameters_for_impl(self_ty, trait_ref),\n+            &mut cgp::parameters_for_impl(tcx, self_ty, trait_ref),\n         );\n     }\n \n@@ -2355,7 +2356,7 @@ fn const_evaluatable_predicates_of<'tcx>(\n                 assert_eq!(uv.promoted, None);\n                 let span = self.tcx.hir().span(c.hir_id);\n                 self.preds.insert((\n-                    ty::PredicateKind::ConstEvaluatable(uv.def, uv.substs).to_predicate(self.tcx),\n+                    ty::PredicateKind::ConstEvaluatable(uv.shrink()).to_predicate(self.tcx),\n                     span,\n                 ));\n             }"}, {"sha": "9bce5ee0da263b782e2630e9c7d1194683efbad0", "filename": "compiler/rustc_typeck/src/collect/type_of.rs", "status": "modified", "additions": 26, "deletions": 1, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Ftype_of.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -7,7 +7,7 @@ use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirId, Node};\n use rustc_middle::hir::map::Map;\n-use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_middle::ty::{self, DefIdTree, Ty, TyCtxt, TypeFoldable, TypeFolder};\n use rustc_span::symbol::Ident;\n@@ -274,6 +274,31 @@ fn get_path_containing_arg_in_pat<'hir>(\n     arg_path\n }\n \n+pub(super) fn default_anon_const_substs(tcx: TyCtxt<'_>, def_id: DefId) -> SubstsRef<'_> {\n+    let generics = tcx.generics_of(def_id);\n+    if let Some(parent) = generics.parent {\n+        // This is the reason we bother with having optional anon const substs.\n+        //\n+        // In the future the substs of an anon const will depend on its parents predicates\n+        // at which point eagerly looking at them will cause a query cycle.\n+        //\n+        // So for now this is only an assurance that this approach won't cause cycle errors in\n+        // the future.\n+        let _cycle_check = tcx.predicates_of(parent);\n+    }\n+\n+    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n+    // We only expect substs with the following type flags as default substs.\n+    //\n+    // Getting this wrong can lead to ICE and unsoundness, so we assert it here.\n+    for arg in substs.iter() {\n+        let allowed_flags = ty::TypeFlags::MAY_NEED_DEFAULT_CONST_SUBSTS\n+            | ty::TypeFlags::STILL_FURTHER_SPECIALIZABLE;\n+        assert!(!arg.has_type_flags(!allowed_flags));\n+    }\n+    substs\n+}\n+\n pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     let def_id = def_id.expect_local();\n     use rustc_hir::*;"}, {"sha": "9b6f0be47caf5898e480540d4ffa14d2954a57f6", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -27,12 +27,13 @@ impl From<ty::ParamConst> for Parameter {\n \n /// Returns the set of parameters constrained by the impl header.\n pub fn parameters_for_impl<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     impl_self_ty: Ty<'tcx>,\n     impl_trait_ref: Option<ty::TraitRef<'tcx>>,\n ) -> FxHashSet<Parameter> {\n     let vec = match impl_trait_ref {\n-        Some(tr) => parameters_for(&tr, false),\n-        None => parameters_for(&impl_self_ty, false),\n+        Some(tr) => parameters_for(tcx, &tr, false),\n+        None => parameters_for(tcx, &impl_self_ty, false),\n     };\n     vec.into_iter().collect()\n }\n@@ -43,20 +44,26 @@ pub fn parameters_for_impl<'tcx>(\n /// of parameters whose values are needed in order to constrain `ty` - these\n /// differ, with the latter being a superset, in the presence of projections.\n pub fn parameters_for<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n     t: &impl TypeFoldable<'tcx>,\n     include_nonconstraining: bool,\n ) -> Vec<Parameter> {\n-    let mut collector = ParameterCollector { parameters: vec![], include_nonconstraining };\n+    let mut collector = ParameterCollector { tcx, parameters: vec![], include_nonconstraining };\n     t.visit_with(&mut collector);\n     collector.parameters\n }\n \n-struct ParameterCollector {\n+struct ParameterCollector<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     parameters: Vec<Parameter>,\n     include_nonconstraining: bool,\n }\n \n-impl<'tcx> TypeVisitor<'tcx> for ParameterCollector {\n+impl<'tcx> TypeVisitor<'tcx> for ParameterCollector<'tcx> {\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.tcx)\n+    }\n+\n     fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n         match *t.kind() {\n             ty::Projection(..) | ty::Opaque(..) if !self.include_nonconstraining => {\n@@ -198,12 +205,12 @@ pub fn setup_constraining_predicates<'tcx>(\n                 //     `<<T as Bar>::Baz as Iterator>::Output = <U as Iterator>::Output`\n                 // Then the projection only applies if `T` is known, but it still\n                 // does not determine `U`.\n-                let inputs = parameters_for(&projection.projection_ty, true);\n+                let inputs = parameters_for(tcx, &projection.projection_ty, true);\n                 let relies_only_on_inputs = inputs.iter().all(|p| input_parameters.contains(&p));\n                 if !relies_only_on_inputs {\n                     continue;\n                 }\n-                input_parameters.extend(parameters_for(&projection.ty, false));\n+                input_parameters.extend(parameters_for(tcx, &projection.ty, false));\n             } else {\n                 continue;\n             }"}, {"sha": "194c4efdbb05888fb8b677e1361f06e22f0b0d7b", "filename": "compiler/rustc_typeck/src/impl_wf_check.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -119,7 +119,7 @@ fn enforce_impl_params_are_constrained(\n     let impl_predicates = tcx.predicates_of(impl_def_id);\n     let impl_trait_ref = tcx.impl_trait_ref(impl_def_id);\n \n-    let mut input_parameters = cgp::parameters_for_impl(impl_self_ty, impl_trait_ref);\n+    let mut input_parameters = cgp::parameters_for_impl(tcx, impl_self_ty, impl_trait_ref);\n     cgp::identify_constrained_generic_params(\n         tcx,\n         impl_predicates,\n@@ -136,7 +136,7 @@ fn enforce_impl_params_are_constrained(\n             match item.kind {\n                 ty::AssocKind::Type => {\n                     if item.defaultness.has_value() {\n-                        cgp::parameters_for(&tcx.type_of(def_id), true)\n+                        cgp::parameters_for(tcx, &tcx.type_of(def_id), true)\n                     } else {\n                         Vec::new()\n                     }"}, {"sha": "d3e4be128a8df54a7b1c93b20da1cb82530b833c", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -207,15 +207,15 @@ fn unconstrained_parent_impl_substs<'tcx>(\n                 continue;\n             }\n \n-            unconstrained_parameters.extend(cgp::parameters_for(&projection_ty, true));\n+            unconstrained_parameters.extend(cgp::parameters_for(tcx, &projection_ty, true));\n \n-            for param in cgp::parameters_for(&projected_ty, false) {\n+            for param in cgp::parameters_for(tcx, &projected_ty, false) {\n                 if !unconstrained_parameters.contains(&param) {\n                     constrained_params.insert(param.0);\n                 }\n             }\n \n-            unconstrained_parameters.extend(cgp::parameters_for(&projected_ty, true));\n+            unconstrained_parameters.extend(cgp::parameters_for(tcx, &projected_ty, true));\n         }\n     }\n \n@@ -249,7 +249,7 @@ fn check_duplicate_params<'tcx>(\n     parent_substs: &Vec<GenericArg<'tcx>>,\n     span: Span,\n ) {\n-    let mut base_params = cgp::parameters_for(parent_substs, true);\n+    let mut base_params = cgp::parameters_for(tcx, parent_substs, true);\n     base_params.sort_by_key(|param| param.0);\n     if let (_, [duplicate, ..]) = base_params.partition_dedup() {\n         let param = impl1_substs[duplicate.0 as usize];\n@@ -363,7 +363,7 @@ fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tc\n     match predicate.kind().skip_binder() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n-        _ if predicate.is_global() => (),\n+        _ if predicate.is_global(tcx) => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n         ty::PredicateKind::Trait(ty::TraitPredicate {"}, {"sha": "9fe26711f2102508080b0b27f55a1ef12930ed1d", "filename": "compiler/rustc_typeck/src/outlives/implicit_infer.rs", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fimplicit_infer.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -114,7 +114,18 @@ fn insert_required_predicates_to_be_wf<'tcx>(\n     required_predicates: &mut RequiredPredicates<'tcx>,\n     explicit_map: &mut ExplicitPredicatesMap<'tcx>,\n ) {\n-    for arg in field_ty.walk() {\n+    // We must not look into the default substs of consts\n+    // as computing those depends on the results of `predicates_of`.\n+    //\n+    // Luckily the only types contained in default substs are type\n+    // parameters which don't matter here.\n+    //\n+    // FIXME(const_generics): Once more complex const parameter types\n+    // are allowed, this might be incorrect. I think that we will still be\n+    // fine, as all outlives relations of the const param types should also\n+    // be part of the adt containing it, but we should still both update the\n+    // documentation and add some tests for this.\n+    for arg in field_ty.walk_ignoring_default_const_substs() {\n         let ty = match arg.unpack() {\n             GenericArgKind::Type(ty) => ty,\n \n@@ -306,7 +317,7 @@ pub fn check_explicit_predicates<'tcx>(\n         // 'b`.\n         if let Some(self_ty) = ignored_self_ty {\n             if let GenericArgKind::Type(ty) = outlives_predicate.0.unpack() {\n-                if ty.walk().any(|arg| arg == self_ty.into()) {\n+                if ty.walk(tcx).any(|arg| arg == self_ty.into()) {\n                     debug!(\"skipping self ty = {:?}\", &ty);\n                     continue;\n                 }"}, {"sha": "bdfe3ffc13f1362be2168f2d58851e9d234ad57b", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -287,7 +287,7 @@ crate fn name_from_pat(p: &hir::Pat<'_>) -> Symbol {\n \n crate fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     match n.val {\n-        ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs: _, promoted }) => {\n+        ty::ConstKind::Unevaluated(ty::Unevaluated { def, substs_: _, promoted }) => {\n             let mut s = if let Some(def) = def.as_local() {\n                 let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def.did);\n                 print_const_expr(cx.tcx, cx.tcx.hir().body_owned_by(hir_id))"}, {"sha": "49d0a7ff455030181b4c27bd926b51ad958f675d", "filename": "src/test/mir-opt/const_promotion_extern_static.BAR.PromoteTemps.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.BAR.PromoteTemps.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -30,7 +30,7 @@\n -         _3 = [move _4];                  // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n -         _2 = &_3;                        // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n +                                          // + span: $DIR/const-promotion-extern-static.rs:9:31: 9:35\n-+                                          // + literal: Const { ty: &[&i32; 1], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:6 ~ const_promotion_extern_static[55e6]::BAR), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n++                                          // + literal: Const { ty: &[&i32; 1], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:6 ~ const_promotion_extern_static[55e6]::BAR), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n +         _2 = &(*_6);                     // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n           _1 = move _2 as &[&i32] (Pointer(Unsize)); // scope 0 at $DIR/const-promotion-extern-static.rs:9:31: 9:35\n -         StorageDead(_4);                 // scope 0 at $DIR/const-promotion-extern-static.rs:9:34: 9:35"}, {"sha": "f2504ae880eab2944f991db4ba81cfe0542cc458", "filename": "src/test/mir-opt/const_promotion_extern_static.FOO.PromoteTemps.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_promotion_extern_static.FOO.PromoteTemps.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -32,7 +32,7 @@\n -         _3 = [move _4];                  // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n -         _2 = &_3;                        // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n +                                          // + span: $DIR/const-promotion-extern-static.rs:13:31: 13:46\n-+                                          // + literal: Const { ty: &[&i32; 1], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:7 ~ const_promotion_extern_static[55e6]::FOO), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n++                                          // + literal: Const { ty: &[&i32; 1], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:7 ~ const_promotion_extern_static[55e6]::FOO), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n +         _2 = &(*_6);                     // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n           _1 = move _2 as &[&i32] (Pointer(Unsize)); // scope 0 at $DIR/const-promotion-extern-static.rs:13:31: 13:46\n -         StorageDead(_4);                 // scope 0 at $DIR/const-promotion-extern-static.rs:13:45: 13:46"}, {"sha": "f8fd2cc9b0d084b9dda42c28314702d7442ae208", "filename": "src/test/mir-opt/const_prop/bad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.32bit.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -31,7 +31,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n-                                           // + literal: Const { ty: &[i32; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ bad_op_unsafe_oob_for_slices[8240]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &[i32; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ bad_op_unsafe_oob_for_slices[8240]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _3 = _9;                         // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n           _2 = &raw const (*_3);           // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n           _1 = move _2 as *const [i32] (Pointer(Unsize)); // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35"}, {"sha": "f8fd2cc9b0d084b9dda42c28314702d7442ae208", "filename": "src/test/mir-opt/const_prop/bad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fbad_op_unsafe_oob_for_slices.main.ConstProp.64bit.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -31,7 +31,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n-                                           // + literal: Const { ty: &[i32; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ bad_op_unsafe_oob_for_slices[8240]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &[i32; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ bad_op_unsafe_oob_for_slices[8240]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _3 = _9;                         // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n           _2 = &raw const (*_3);           // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35\n           _1 = move _2 as *const [i32] (Pointer(Unsize)); // scope 0 at $DIR/bad_op_unsafe_oob_for_slices.rs:5:25: 5:35"}, {"sha": "49237934223e765d351295161846409d2c9c9af0", "filename": "src/test/mir-opt/const_prop/const_prop_fails_gracefully.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fconst_prop_fails_gracefully.main.ConstProp.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -22,7 +22,7 @@\n                                            // + val: Unevaluated(FOO, [], None)\n                                            // mir::Constant\n                                            // + span: $DIR/const_prop_fails_gracefully.rs:7:13: 7:16\n-                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:5 ~ const_prop_fails_gracefully[2706]::main::FOO), const_param_did: None }, substs: [], promoted: None }) }\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:5 ~ const_prop_fails_gracefully[2706]::main::FOO), const_param_did: None }, substs_: Some([]), promoted: None }) }\n           _2 = &raw const (*_3);           // scope 0 at $DIR/const_prop_fails_gracefully.rs:7:13: 7:16\n           _1 = move _2 as usize (Misc);    // scope 0 at $DIR/const_prop_fails_gracefully.rs:7:13: 7:39\n           StorageDead(_2);                 // scope 0 at $DIR/const_prop_fails_gracefully.rs:7:38: 7:39"}, {"sha": "54acae43abc58ae1630b3205882ef8808ab77236", "filename": "src/test/mir-opt/const_prop/ref_deref.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.ConstProp.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -17,7 +17,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $DIR/ref_deref.rs:5:6: 5:10\n-                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ ref_deref[cb9b]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ ref_deref[cb9b]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _2 = _4;                         // scope 0 at $DIR/ref_deref.rs:5:6: 5:10\n -         _1 = (*_2);                      // scope 0 at $DIR/ref_deref.rs:5:5: 5:10\n +         _1 = const 4_i32;                // scope 0 at $DIR/ref_deref.rs:5:5: 5:10"}, {"sha": "3b5c86942a7511b037525010df8ca2c3a360d03d", "filename": "src/test/mir-opt/const_prop/ref_deref.main.PromoteTemps.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref.main.PromoteTemps.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -20,7 +20,7 @@\n +                                          // + val: Unevaluated(main, [], Some(promoted[0]))\n +                                          // mir::Constant\n +                                          // + span: $DIR/ref_deref.rs:5:6: 5:10\n-+                                          // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ ref_deref[cb9b]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n++                                          // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ ref_deref[cb9b]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n +         _2 = &(*_4);                     // scope 0 at $DIR/ref_deref.rs:5:6: 5:10\n           _1 = (*_2);                      // scope 0 at $DIR/ref_deref.rs:5:5: 5:10\n -         StorageDead(_3);                 // scope 0 at $DIR/ref_deref.rs:5:10: 5:11"}, {"sha": "8590a98491b7be8aea83fe6b8e239b02cf91ba9a", "filename": "src/test/mir-opt/const_prop/ref_deref_project.main.ConstProp.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.ConstProp.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -17,7 +17,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $DIR/ref_deref_project.rs:5:6: 5:17\n-                                           // + literal: Const { ty: &(i32, i32), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ ref_deref_project[e8c3]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &(i32, i32), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ ref_deref_project[e8c3]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _2 = &((*_4).1: i32);            // scope 0 at $DIR/ref_deref_project.rs:5:6: 5:17\n           _1 = (*_2);                      // scope 0 at $DIR/ref_deref_project.rs:5:5: 5:17\n           StorageDead(_2);                 // scope 0 at $DIR/ref_deref_project.rs:5:17: 5:18"}, {"sha": "4e10ae17934881b5e242b4f72e6ddd38079e8e94", "filename": "src/test/mir-opt/const_prop/ref_deref_project.main.PromoteTemps.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.PromoteTemps.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.PromoteTemps.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fref_deref_project.main.PromoteTemps.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -20,7 +20,7 @@\n +                                          // + val: Unevaluated(main, [], Some(promoted[0]))\n +                                          // mir::Constant\n +                                          // + span: $DIR/ref_deref_project.rs:5:6: 5:17\n-+                                          // + literal: Const { ty: &(i32, i32), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ ref_deref_project[e8c3]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n++                                          // + literal: Const { ty: &(i32, i32), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ ref_deref_project[e8c3]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n +         _2 = &((*_4).1: i32);            // scope 0 at $DIR/ref_deref_project.rs:5:6: 5:17\n           _1 = (*_2);                      // scope 0 at $DIR/ref_deref_project.rs:5:5: 5:17\n -         StorageDead(_3);                 // scope 0 at $DIR/ref_deref_project.rs:5:17: 5:18"}, {"sha": "f305d602bbde106c4acdcba8a5379236cbe57b17", "filename": "src/test/mir-opt/const_prop/slice_len.main.ConstProp.32bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.main.ConstProp.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.main.ConstProp.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.main.ConstProp.32bit.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -24,7 +24,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $DIR/slice_len.rs:5:6: 5:19\n-                                           // + literal: Const { ty: &[u32; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ slice_len[6547]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &[u32; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ slice_len[6547]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _4 = _9;                         // scope 0 at $DIR/slice_len.rs:5:6: 5:19\n           _3 = _4;                         // scope 0 at $DIR/slice_len.rs:5:6: 5:19\n           _2 = move _3 as &[u32] (Pointer(Unsize)); // scope 0 at $DIR/slice_len.rs:5:6: 5:19"}, {"sha": "f305d602bbde106c4acdcba8a5379236cbe57b17", "filename": "src/test/mir-opt/const_prop/slice_len.main.ConstProp.64bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.main.ConstProp.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.main.ConstProp.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fconst_prop%2Fslice_len.main.ConstProp.64bit.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -24,7 +24,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $DIR/slice_len.rs:5:6: 5:19\n-                                           // + literal: Const { ty: &[u32; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ slice_len[6547]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &[u32; 3], val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ slice_len[6547]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _4 = _9;                         // scope 0 at $DIR/slice_len.rs:5:6: 5:19\n           _3 = _4;                         // scope 0 at $DIR/slice_len.rs:5:6: 5:19\n           _2 = move _3 as &[u32] (Pointer(Unsize)); // scope 0 at $DIR/slice_len.rs:5:6: 5:19"}, {"sha": "0ff0e8ea7b1faea4f7b3d4791132e9287a35791a", "filename": "src/test/mir-opt/inline/inline_retag.bar.Inline.after.mir", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Finline%2Finline_retag.bar.Inline.after.mir?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -38,7 +38,7 @@ fn bar() -> bool {\n                                          // + val: Unevaluated(bar, [], Some(promoted[1]))\n                                          // mir::Constant\n                                          // + span: $DIR/inline-retag.rs:12:7: 12:9\n-                                         // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:4 ~ inline_retag[a78c]::bar), const_param_did: None }, substs: [], promoted: Some(promoted[1]) }) }\n+                                         // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:4 ~ inline_retag[a78c]::bar), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[1]) }) }\n         Retag(_10);                      // scope 1 at $DIR/inline-retag.rs:12:7: 12:9\n         _4 = &(*_10);                    // scope 1 at $DIR/inline-retag.rs:12:7: 12:9\n         Retag(_4);                       // scope 1 at $DIR/inline-retag.rs:12:7: 12:9\n@@ -52,7 +52,7 @@ fn bar() -> bool {\n                                          // + val: Unevaluated(bar, [], Some(promoted[0]))\n                                          // mir::Constant\n                                          // + span: $DIR/inline-retag.rs:12:11: 12:14\n-                                         // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:4 ~ inline_retag[a78c]::bar), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                         // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:4 ~ inline_retag[a78c]::bar), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n         Retag(_9);                       // scope 1 at $DIR/inline-retag.rs:12:11: 12:14\n         _7 = &(*_9);                     // scope 1 at $DIR/inline-retag.rs:12:11: 12:14\n         Retag(_7);                       // scope 1 at $DIR/inline-retag.rs:12:11: 12:14"}, {"sha": "95632293d9991518f234eb31878b0ca98c49b66f", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.32bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.32bit.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -66,7 +66,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ issue_73223[2d0f]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ issue_73223[2d0f]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _8 = _20;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_6.0: &i32) = move _7;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_6.1: &i32) = move _8;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "95632293d9991518f234eb31878b0ca98c49b66f", "filename": "src/test/mir-opt/issue_73223.main.PreCodegen.64bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.PreCodegen.64bit.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -66,7 +66,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ issue_73223[2d0f]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ issue_73223[2d0f]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _8 = _20;                        // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_6.0: &i32) = move _7;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_6.1: &i32) = move _8;          // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "1581e945e70e6312cdf4632c69ddda7ad42b2c51", "filename": "src/test/mir-opt/issue_73223.main.SimplifyArmIdentity.32bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.32bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.32bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.32bit.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -87,7 +87,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ issue_73223[2d0f]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ issue_73223[2d0f]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _11 = _28;                       // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_9.0: &i32) = move _10;         // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_9.1: &i32) = move _11;         // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "1581e945e70e6312cdf4632c69ddda7ad42b2c51", "filename": "src/test/mir-opt/issue_73223.main.SimplifyArmIdentity.64bit.diff", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.64bit.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.64bit.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fissue_73223.main.SimplifyArmIdentity.64bit.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -87,7 +87,7 @@\n                                            // + val: Unevaluated(main, [], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ issue_73223[2d0f]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:3 ~ issue_73223[2d0f]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n           _11 = _28;                       // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_9.0: &i32) = move _10;         // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n           (_9.1: &i32) = move _11;         // scope 3 at $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "f427375e5a624ddbf9d5afd66e973362d980a02e", "filename": "src/test/mir-opt/lower_intrinsics.discriminant.LowerIntrinsics.diff", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Flower_intrinsics.discriminant.LowerIntrinsics.diff", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Flower_intrinsics.discriminant.LowerIntrinsics.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Flower_intrinsics.discriminant.LowerIntrinsics.diff?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -50,7 +50,7 @@\n                                            // + val: Unevaluated(discriminant, [T], Some(promoted[2]))\n                                            // mir::Constant\n                                            // + span: $DIR/lower_intrinsics.rs:70:42: 70:44\n-                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:27 ~ lower_intrinsics[2872]::discriminant), const_param_did: None }, substs: [T], promoted: Some(promoted[2]) }) }\n+                                           // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:27 ~ lower_intrinsics[2872]::discriminant), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[2]) }) }\n           _7 = &(*_19);                    // scope 0 at $DIR/lower_intrinsics.rs:70:42: 70:44\n           _6 = &(*_7);                     // scope 0 at $DIR/lower_intrinsics.rs:70:42: 70:44\n -         _5 = discriminant_value::<i32>(move _6) -> bb2; // scope 0 at $DIR/lower_intrinsics.rs:70:5: 70:45\n@@ -74,7 +74,7 @@\n                                            // + val: Unevaluated(discriminant, [T], Some(promoted[1]))\n                                            // mir::Constant\n                                            // + span: $DIR/lower_intrinsics.rs:71:42: 71:45\n-                                           // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:27 ~ lower_intrinsics[2872]::discriminant), const_param_did: None }, substs: [T], promoted: Some(promoted[1]) }) }\n+                                           // + literal: Const { ty: &(), val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:27 ~ lower_intrinsics[2872]::discriminant), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[1]) }) }\n           _11 = &(*_18);                   // scope 0 at $DIR/lower_intrinsics.rs:71:42: 71:45\n           _10 = &(*_11);                   // scope 0 at $DIR/lower_intrinsics.rs:71:42: 71:45\n -         _9 = discriminant_value::<()>(move _10) -> bb3; // scope 0 at $DIR/lower_intrinsics.rs:71:5: 71:46\n@@ -98,7 +98,7 @@\n                                            // + val: Unevaluated(discriminant, [T], Some(promoted[0]))\n                                            // mir::Constant\n                                            // + span: $DIR/lower_intrinsics.rs:72:42: 72:47\n-                                           // + literal: Const { ty: &E, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:27 ~ lower_intrinsics[2872]::discriminant), const_param_did: None }, substs: [T], promoted: Some(promoted[0]) }) }\n+                                           // + literal: Const { ty: &E, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:27 ~ lower_intrinsics[2872]::discriminant), const_param_did: None }, substs_: Some([T]), promoted: Some(promoted[0]) }) }\n           _15 = &(*_17);                   // scope 0 at $DIR/lower_intrinsics.rs:72:42: 72:47\n           _14 = &(*_15);                   // scope 0 at $DIR/lower_intrinsics.rs:72:42: 72:47\n -         _13 = discriminant_value::<E>(move _14) -> bb4; // scope 0 at $DIR/lower_intrinsics.rs:72:5: 72:48"}, {"sha": "7f80d81b7edc21a4be1af2b7644d4a41a4f870c0", "filename": "src/test/mir-opt/match_false_edges.full_tested_match.PromoteTemps.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.full_tested_match.PromoteTemps.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.full_tested_match.PromoteTemps.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fmatch_false_edges.full_tested_match.PromoteTemps.after.mir?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -57,7 +57,7 @@ fn full_tested_match() -> () {\n                                          // + val: Unevaluated(full_tested_match, [], Some(promoted[0]))\n                                          // mir::Constant\n                                          // + span: $DIR/match_false_edges.rs:16:14: 16:15\n-                                         // + literal: Const { ty: &std::option::Option<i32>, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:5 ~ match_false_edges[4011]::full_tested_match), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                         // + literal: Const { ty: &std::option::Option<i32>, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:5 ~ match_false_edges[4011]::full_tested_match), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n         _6 = &(((*_11) as Some).0: i32); // scope 0 at $DIR/match_false_edges.rs:16:14: 16:15\n         _4 = &shallow _2;                // scope 0 at $DIR/match_false_edges.rs:15:19: 15:27\n         StorageLive(_7);                 // scope 0 at $DIR/match_false_edges.rs:16:20: 16:27"}, {"sha": "ee99d033af320bca56f544145470c42330804b3c", "filename": "src/test/mir-opt/retag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.array_casts.SimplifyCfg-elaborate-drops.after.mir?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -127,7 +127,7 @@ fn array_casts() -> () {\n                                          // + val: Unevaluated(array_casts, [], Some(promoted[0]))\n                                          // mir::Constant\n                                          // + span: $SRC_DIR/core/src/macros/mod.rs:LL:COL\n-                                         // + literal: Const { ty: &usize, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:15 ~ retag[13e7]::array_casts), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                         // + literal: Const { ty: &usize, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:15 ~ retag[13e7]::array_casts), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n         Retag(_35);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         _18 = &(*_35);                   // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL\n         Retag(_18);                      // scope 5 at $SRC_DIR/core/src/macros/mod.rs:LL:COL"}, {"sha": "cdf7282c8c3c465ce43fd8c10c2dab0742cbbb63", "filename": "src/test/mir-opt/retag.main.SimplifyCfg-elaborate-drops.after.mir", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fmir-opt%2Fretag.main.SimplifyCfg-elaborate-drops.after.mir?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -153,7 +153,7 @@ fn main() -> () {\n                                          // + val: Unevaluated(main, [], Some(promoted[0]))\n                                          // mir::Constant\n                                          // + span: $DIR/retag.rs:47:21: 47:23\n-                                         // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:13 ~ retag[13e7]::main), const_param_did: None }, substs: [], promoted: Some(promoted[0]) }) }\n+                                         // + literal: Const { ty: &i32, val: Unevaluated(Unevaluated { def: WithOptConstParam { did: DefId(0:13 ~ retag[13e7]::main), const_param_did: None }, substs_: Some([]), promoted: Some(promoted[0]) }) }\n         Retag(_28);                      // scope 7 at $DIR/retag.rs:47:21: 47:23\n         _23 = &(*_28);                   // scope 7 at $DIR/retag.rs:47:21: 47:23\n         Retag(_23);                      // scope 7 at $DIR/retag.rs:47:21: 47:23"}, {"sha": "685dbf26250ce2b82aeafd95de9933831e6fc603", "filename": "src/tools/clippy/clippy_lints/src/escape.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fescape.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -53,7 +53,7 @@ fn is_non_trait_box(ty: Ty<'_>) -> bool {\n struct EscapeDelegate<'a, 'tcx> {\n     cx: &'a LateContext<'tcx>,\n     set: HirIdSet,\n-    trait_self_ty: Option<Ty<'a>>,\n+    trait_self_ty: Option<Ty<'tcx>>,\n     too_large_for_stack: u64,\n }\n \n@@ -171,7 +171,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                 // skip if there is a `self` parameter binding to a type\n                 // that contains `Self` (i.e.: `self: Box<Self>`), see #4804\n                 if let Some(trait_self_ty) = self.trait_self_ty {\n-                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(cmt.place.ty(), trait_self_ty) {\n+                    if map.name(cmt.hir_id) == kw::SelfLower && contains_ty(self.cx.tcx, cmt.place.ty(), trait_self_ty) {\n                         return;\n                     }\n                 }"}, {"sha": "89146b4dd2c9bd5f58b61a89a2cab4b61f7b6d76", "filename": "src/tools/clippy/clippy_lints/src/let_underscore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Flet_underscore.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LateLintPass<'tcx> for LetUnderscore {\n             if let Some(init) = local.init;\n             then {\n                 let init_ty = cx.typeck_results().expr_ty(init);\n-                let contains_sync_guard = init_ty.walk().any(|inner| match inner.unpack() {\n+                let contains_sync_guard = init_ty.walk(cx.tcx).any(|inner| match inner.unpack() {\n                     GenericArgKind::Type(inner_ty) => {\n                         SYNC_GUARD_PATHS.iter().any(|path| match_type(cx, inner_ty, path))\n                     },"}, {"sha": "545498a10478db9c623f979edee7a70bf3f54d37", "filename": "src/tools/clippy/clippy_lints/src/loops/same_item_push.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Floops%2Fsame_item_push.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -49,7 +49,7 @@ pub(super) fn check<'tcx>(\n         if same_item_push_visitor.should_lint();\n         if let Some((vec, pushed_item)) = same_item_push_visitor.vec_push;\n         let vec_ty = cx.typeck_results().expr_ty(vec);\n-        let ty = vec_ty.walk().nth(1).unwrap().expect_ty();\n+        let ty = vec_ty.walk(cx.tcx).nth(1).unwrap().expect_ty();\n         if cx\n             .tcx\n             .lang_items()"}, {"sha": "9626cf79dc129c4ba253907830fa8674c0c8e722", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1987,10 +1987,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n \n             // walk the return type and check for Self (this does not check associated types)\n             if let Some(self_adt) = self_ty.ty_adt_def() {\n-                if contains_adt_constructor(ret_ty, self_adt) {\n+                if contains_adt_constructor(cx.tcx, ret_ty, self_adt) {\n                     return;\n                 }\n-            } else if contains_ty(ret_ty, self_ty) {\n+            } else if contains_ty(cx.tcx, ret_ty, self_ty) {\n                 return;\n             }\n \n@@ -2001,10 +2001,10 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n                     if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n                         // walk the associated type and check for Self\n                         if let Some(self_adt) = self_ty.ty_adt_def() {\n-                            if contains_adt_constructor(projection_predicate.ty, self_adt) {\n+                            if contains_adt_constructor(cx.tcx, projection_predicate.ty, self_adt) {\n                                 return;\n                             }\n-                        } else if contains_ty(projection_predicate.ty, self_ty) {\n+                        } else if contains_ty(cx.tcx, projection_predicate.ty, self_ty) {\n                             return;\n                         }\n                     }\n@@ -2053,7 +2053,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let TraitItemKind::Fn(_, _) = item.kind;\n             let ret_ty = return_ty(cx, item.hir_id());\n             let self_ty = TraitRef::identity(cx.tcx, item.def_id.to_def_id()).self_ty();\n-            if !contains_ty(ret_ty, self_ty);\n+            if !contains_ty(cx.tcx, ret_ty, self_ty);\n \n             then {\n                 span_lint("}, {"sha": "90b2aa16896267b3fd66d06d739a34a202d88db4", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -117,7 +117,7 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n         let fn_def_id = cx.tcx.hir().local_def_id(hir_id);\n \n         let preds = traits::elaborate_predicates(cx.tcx, cx.param_env.caller_bounds().iter())\n-            .filter(|p| !p.is_global())\n+            .filter(|p| !p.is_global(cx.tcx))\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n                 match obligation.predicate.kind().no_bound_vars() {"}, {"sha": "2a85a67fa099cac9355d26e61ca5bdada9387994", "filename": "src/tools/clippy/clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -187,11 +187,7 @@ fn is_value_unfrozen_expr<'tcx>(cx: &LateContext<'tcx>, hir_id: HirId, def_id: D\n \n     let result = cx.tcx.const_eval_resolve(\n         cx.param_env,\n-        ty::Unevaluated {\n-            def: ty::WithOptConstParam::unknown(def_id),\n-            substs,\n-            promoted: None,\n-        },\n+        ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs),\n         None,\n     );\n     is_value_unfrozen_raw(cx, result, ty)"}, {"sha": "f5e43264a5c69809b4dfc04d00d93b4b2f0886ee", "filename": "src/tools/clippy/clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fredundant_clone.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -14,7 +14,7 @@ use rustc_middle::mir::{\n     visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor as _},\n     Mutability,\n };\n-use rustc_middle::ty::{self, fold::TypeVisitor, Ty};\n+use rustc_middle::ty::{self, fold::TypeVisitor, Ty, TyCtxt};\n use rustc_mir::dataflow::{Analysis, AnalysisDomain, GenKill, GenKillAnalysis, ResultsCursor};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::source_map::{BytePos, Span};\n@@ -576,7 +576,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                 self.possible_borrower.add(borrowed.local, lhs);\n             },\n             other => {\n-                if ContainsRegion\n+                if ContainsRegion(self.cx.tcx)\n                     .visit_ty(place.ty(&self.body.local_decls, self.cx.tcx).ty)\n                     .is_continue()\n                 {\n@@ -625,7 +625,7 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleBorrowerVisitor<'a, 'tcx> {\n                 .flat_map(HybridBitSet::iter)\n                 .collect();\n \n-            if ContainsRegion.visit_ty(self.body.local_decls[*dest].ty).is_break() {\n+            if ContainsRegion(self.cx.tcx).visit_ty(self.body.local_decls[*dest].ty).is_break() {\n                 mutable_variables.push(*dest);\n             }\n \n@@ -701,12 +701,15 @@ impl<'a, 'tcx> mir::visit::Visitor<'tcx> for PossibleOriginVisitor<'a, 'tcx> {\n     }\n }\n \n-struct ContainsRegion;\n+struct ContainsRegion<'tcx>(TyCtxt<'tcx>);\n \n-impl TypeVisitor<'_> for ContainsRegion {\n+impl<'tcx> TypeVisitor<'tcx> for ContainsRegion<'tcx> {\n     type BreakTy = ();\n+    fn tcx_for_anon_const_substs(&self) -> Option<TyCtxt<'tcx>> {\n+        Some(self.0)\n+    }\n \n-    fn visit_region(&mut self, _: ty::Region<'_>) -> ControlFlow<Self::BreakTy> {\n+    fn visit_region(&mut self, _: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n         ControlFlow::BREAK\n     }\n }"}, {"sha": "681baed8c3696f0323cda6a590bea11e8b325798", "filename": "src/tools/clippy/clippy_lints/src/returns.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Freturns.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -288,7 +288,7 @@ impl<'tcx> Visitor<'tcx> for BorrowVisitor<'_, 'tcx> {\n                 .fn_sig(def_id)\n                 .output()\n                 .skip_binder()\n-                .walk()\n+                .walk(self.cx.tcx)\n                 .any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)));\n         }\n "}, {"sha": "4ba5e1a0f5357829f95fad45aec80029882e8b88", "filename": "src/tools/clippy/clippy_lints/src/self_named_constructors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fself_named_constructors.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -62,10 +62,10 @@ impl<'tcx> LateLintPass<'tcx> for SelfNamedConstructors {\n \n         // Ensure method is constructor-like\n         if let Some(self_adt) = self_ty.ty_adt_def() {\n-            if !contains_adt_constructor(ret_ty, self_adt) {\n+            if !contains_adt_constructor(cx.tcx, ret_ty, self_adt) {\n                 return;\n             }\n-        } else if !contains_ty(ret_ty, self_ty) {\n+        } else if !contains_ty(cx.tcx, ret_ty, self_ty) {\n             return;\n         }\n "}, {"sha": "97b1b2dae3c1a3d03f3bd5e051fe74396a62410c", "filename": "src/tools/clippy/clippy_lints/src/unnecessary_sort_by.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funnecessary_sort_by.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -218,7 +218,7 @@ fn detect_lint(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<LintTrigger> {\n \n fn expr_borrows(cx: &LateContext<'_>, expr: &Expr<'_>) -> bool {\n     let ty = cx.typeck_results().expr_ty(expr);\n-    matches!(ty.kind(), ty::Ref(..)) || ty.walk().any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n+    matches!(ty.kind(), ty::Ref(..)) || ty.walk(cx.tcx).any(|arg| matches!(arg.unpack(), GenericArgKind::Lifetime(_)))\n }\n \n impl LateLintPass<'_> for UnnecessarySortBy {"}, {"sha": "9ae50e47ca4c59ce899e0472b635f7d0e493a925", "filename": "src/tools/clippy/clippy_lints/src/use_self.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fuse_self.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -170,7 +170,7 @@ impl<'tcx> LateLintPass<'tcx> for UseSelf {\n                 //\n                 // See also https://github.com/rust-lang/rust-clippy/issues/2894.\n                 for (impl_hir_ty, trait_sem_ty) in impl_inputs_outputs.zip(trait_method_sig.inputs_and_output) {\n-                    if trait_sem_ty.walk().any(|inner| inner == self_ty.into()) {\n+                    if trait_sem_ty.walk(cx.tcx).any(|inner| inner == self_ty.into()) {\n                         let mut visitor = SkipTyCollector::default();\n                         visitor.visit_ty(impl_hir_ty);\n                         types_to_skip.extend(visitor.types_to_skip);"}, {"sha": "8bf31807d55d1441d74e503a42e29334aee365f0", "filename": "src/tools/clippy/clippy_utils/src/consts.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fconsts.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -346,11 +346,7 @@ impl<'a, 'tcx> ConstEvalLateContext<'a, 'tcx> {\n                     .tcx\n                     .const_eval_resolve(\n                         self.param_env,\n-                        ty::Unevaluated {\n-                            def: ty::WithOptConstParam::unknown(def_id),\n-                            substs,\n-                            promoted: None,\n-                        },\n+                        ty::Unevaluated::new(ty::WithOptConstParam::unknown(def_id), substs),\n                         None,\n                     )\n                     .ok()"}, {"sha": "ddff1686ba2ce99f9ac3f22de1abe04cd50997f8", "filename": "src/tools/clippy/clippy_utils/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Flib.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -1581,7 +1581,7 @@ pub fn fn_has_unsatisfiable_preds(cx: &LateContext<'_>, did: DefId) -> bool {\n         .predicates_of(did)\n         .predicates\n         .iter()\n-        .filter_map(|(p, _)| if p.is_global() { Some(*p) } else { None });\n+        .filter_map(|(p, _)| if p.is_global(cx.tcx) { Some(*p) } else { None });\n     traits::impossible_predicates(\n         cx.tcx,\n         traits::elaborate_predicates(cx.tcx, predicates)\n@@ -1627,15 +1627,15 @@ pub fn is_slice_of_primitives(cx: &LateContext<'_>, expr: &Expr<'_>) -> Option<S\n     if is_primitive {\n         // if we have wrappers like Array, Slice or Tuple, print these\n         // and get the type enclosed in the slice ref\n-        match expr_type.peel_refs().walk().nth(1).unwrap().expect_ty().kind() {\n+        match expr_type.peel_refs().walk(cx.tcx).nth(1).unwrap().expect_ty().kind() {\n             rustc_ty::Slice(..) => return Some(\"slice\".into()),\n             rustc_ty::Array(..) => return Some(\"array\".into()),\n             rustc_ty::Tuple(..) => return Some(\"tuple\".into()),\n             _ => {\n                 // is_recursively_primitive_type() should have taken care\n                 // of the rest and we can rely on the type that is found\n                 let refs_peeled = expr_type.peel_refs();\n-                return Some(refs_peeled.walk().last().unwrap().to_string());\n+                return Some(refs_peeled.walk(cx.tcx).last().unwrap().to_string());\n             },\n         }\n     }"}, {"sha": "e5bbf75c3b0a1857ed5b7c4580cb8e1d973ce587", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -88,7 +88,7 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>, msrv: Option<&Ru\n }\n \n fn check_ty(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, span: Span) -> McfResult {\n-    for arg in ty.walk() {\n+    for arg in ty.walk(tcx) {\n         let ty = match arg.unpack() {\n             GenericArgKind::Type(ty) => ty,\n "}, {"sha": "3cd8ed5aa2c8c50ef32a129d0879f5428883969f", "filename": "src/tools/clippy/clippy_utils/src/ty.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/517c28e421b0d601c6f8eb07ea6aafb8e16975ad/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fty.rs?ref=517c28e421b0d601c6f8eb07ea6aafb8e16975ad", "patch": "@@ -10,7 +10,7 @@ use rustc_hir::{TyKind, Unsafety};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::LateContext;\n use rustc_middle::ty::subst::{GenericArg, GenericArgKind};\n-use rustc_middle::ty::{self, AdtDef, IntTy, Ty, TypeFoldable, UintTy};\n+use rustc_middle::ty::{self, TyCtxt, AdtDef, IntTy, Ty, TypeFoldable, UintTy};\n use rustc_span::sym;\n use rustc_span::symbol::{Ident, Symbol};\n use rustc_span::DUMMY_SP;\n@@ -36,17 +36,17 @@ pub fn can_partially_move_ty(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n }\n \n /// Walks into `ty` and returns `true` if any inner type is the same as `other_ty`\n-pub fn contains_ty(ty: Ty<'_>, other_ty: Ty<'_>) -> bool {\n-    ty.walk().any(|inner| match inner.unpack() {\n+pub fn contains_ty<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, other_ty: Ty<'tcx>) -> bool {\n+    ty.walk(tcx).any(|inner| match inner.unpack() {\n         GenericArgKind::Type(inner_ty) => ty::TyS::same_type(other_ty, inner_ty),\n         GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n     })\n }\n \n /// Walks into `ty` and returns `true` if any inner type is an instance of the given adt\n /// constructor.\n-pub fn contains_adt_constructor(ty: Ty<'_>, adt: &AdtDef) -> bool {\n-    ty.walk().any(|inner| match inner.unpack() {\n+pub fn contains_adt_constructor<'tcx>(tcx: TyCtxt<'tcx>, ty: Ty<'tcx>, adt: &'tcx AdtDef) -> bool {\n+    ty.walk(tcx).any(|inner| match inner.unpack() {\n         GenericArgKind::Type(inner_ty) => inner_ty.ty_adt_def() == Some(adt),\n         GenericArgKind::Lifetime(_) | GenericArgKind::Const(_) => false,\n     })\n@@ -209,7 +209,7 @@ fn is_normalizable_helper<'tcx>(\n                         .iter()\n                         .all(|field| is_normalizable_helper(cx, param_env, field.ty(cx.tcx, substs), cache))\n                 }),\n-                _ => ty.walk().all(|generic_arg| match generic_arg.unpack() {\n+                _ => ty.walk(cx.tcx).all(|generic_arg| match generic_arg.unpack() {\n                     GenericArgKind::Type(inner_ty) if inner_ty != ty => {\n                         is_normalizable_helper(cx, param_env, inner_ty, cache)\n                     },"}]}