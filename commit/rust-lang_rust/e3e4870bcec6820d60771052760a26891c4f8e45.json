{"sha": "e3e4870bcec6820d60771052760a26891c4f8e45", "node_id": "MDY6Q29tbWl0NzI0NzEyOmUzZTQ4NzBiY2VjNjgyMGQ2MDc3MTA1Mjc2MGEyNjg5MWM0ZjhlNDU=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-12-06T20:31:42Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-12-07T14:52:59Z"}, "message": "small `TypeVisitor` refactor", "tree": {"sha": "1654cd78660ac024b20f182d990879e4695ba848", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1654cd78660ac024b20f182d990879e4695ba848"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e3e4870bcec6820d60771052760a26891c4f8e45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e3e4870bcec6820d60771052760a26891c4f8e45", "html_url": "https://github.com/rust-lang/rust/commit/e3e4870bcec6820d60771052760a26891c4f8e45", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e3e4870bcec6820d60771052760a26891c4f8e45/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f6f2d681b39c5f95459cd09cb936b6ceb27cd82", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f6f2d681b39c5f95459cd09cb936b6ceb27cd82", "html_url": "https://github.com/rust-lang/rust/commit/0f6f2d681b39c5f95459cd09cb936b6ceb27cd82"}], "stats": {"total": 91, "additions": 55, "deletions": 36}, "files": [{"sha": "c2165db278fa0f946ac4cc488a4cc5d2ceb28d30", "filename": "compiler/rustc_mir/src/interpret/util.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/e3e4870bcec6820d60771052760a26891c4f8e45/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e4870bcec6820d60771052760a26891c4f8e45/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Futil.rs?ref=e3e4870bcec6820d60771052760a26891c4f8e45", "patch": "@@ -13,20 +13,21 @@ where\n         return Ok(());\n     }\n \n+    struct FoundParam;\n     struct UsedParamsNeedSubstVisitor<'tcx> {\n         tcx: TyCtxt<'tcx>,\n     }\n \n     impl<'tcx> TypeVisitor<'tcx> for UsedParamsNeedSubstVisitor<'tcx> {\n-        type BreakTy = ();\n+        type BreakTy = FoundParam;\n \n         fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n             if !c.needs_subst() {\n                 return ControlFlow::CONTINUE;\n             }\n \n             match c.val {\n-                ty::ConstKind::Param(..) => ControlFlow::BREAK,\n+                ty::ConstKind::Param(..) => ControlFlow::Break(FoundParam),\n                 _ => c.super_visit_with(self),\n             }\n         }\n@@ -37,7 +38,7 @@ where\n             }\n \n             match *ty.kind() {\n-                ty::Param(_) => ControlFlow::BREAK,\n+                ty::Param(_) => ControlFlow::Break(FoundParam),\n                 ty::Closure(def_id, substs)\n                 | ty::Generator(def_id, substs, ..)\n                 | ty::FnDef(def_id, substs) => {\n@@ -76,7 +77,7 @@ where\n     }\n \n     let mut vis = UsedParamsNeedSubstVisitor { tcx };\n-    if ty.visit_with(&mut vis).is_break() {\n+    if matches!(ty.visit_with(&mut vis), ControlFlow::Break(FoundParam)) {\n         throw_inval!(TooGeneric);\n     } else {\n         Ok(())"}, {"sha": "ec7369fd3e8ee6c96329ae849e36438a9244843d", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 36, "deletions": 32, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e3e4870bcec6820d60771052760a26891c4f8e45/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e4870bcec6820d60771052760a26891c4f8e45/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=e3e4870bcec6820d60771052760a26891c4f8e45", "patch": "@@ -462,39 +462,25 @@ pub(super) fn check_opaque<'tcx>(\n \n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n+#[instrument(skip(tcx, span))]\n pub(super) fn check_opaque_for_inheriting_lifetimes(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n     span: Span,\n ) {\n     let item = tcx.hir().expect_item(tcx.hir().local_def_id_to_hir_id(def_id));\n-    debug!(\n-        \"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n-        def_id, span, item\n-    );\n-\n-    #[derive(Debug)]\n-    struct ProhibitOpaqueVisitor<'tcx> {\n-        opaque_identity_ty: Ty<'tcx>,\n-        generics: &'tcx ty::Generics,\n-    }\n+    debug!(?item, ?span);\n \n-    impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n-        type BreakTy = Option<Ty<'tcx>>;\n-\n-        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n-            if t != self.opaque_identity_ty && t.super_visit_with(self).is_break() {\n-                return ControlFlow::Break(Some(t));\n-            }\n-            ControlFlow::CONTINUE\n-        }\n+    struct FoundParentLifetime;\n+    struct FindParentLifetimeVisitor<'tcx>(&'tcx ty::Generics);\n+    impl<'tcx> ty::fold::TypeVisitor<'tcx> for FindParentLifetimeVisitor<'tcx> {\n+        type BreakTy = FoundParentLifetime;\n \n         fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_region) r={:?}\", r);\n+            debug!(\"FindParentLifetimeVisitor: r={:?}\", r);\n             if let RegionKind::ReEarlyBound(ty::EarlyBoundRegion { index, .. }) = r {\n-                if *index < self.generics.parent_count as u32 {\n-                    return ControlFlow::Break(None);\n+                if *index < self.0.parent_count as u32 {\n+                    return ControlFlow::Break(FoundParentLifetime);\n                 } else {\n                     return ControlFlow::CONTINUE;\n                 }\n@@ -505,7 +491,7 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n \n         fn visit_const(&mut self, c: &'tcx ty::Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n             if let ty::ConstKind::Unevaluated(..) = c.val {\n-                // FIXME(#72219) We currenctly don't detect lifetimes within substs\n+                // FIXME(#72219) We currently don't detect lifetimes within substs\n                 // which would violate this check. Even though the particular substitution is not used\n                 // within the const, this should still be fixed.\n                 return ControlFlow::CONTINUE;\n@@ -514,6 +500,26 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n         }\n     }\n \n+    #[derive(Debug)]\n+    struct ProhibitOpaqueVisitor<'tcx> {\n+        opaque_identity_ty: Ty<'tcx>,\n+        generics: &'tcx ty::Generics,\n+    }\n+\n+    impl<'tcx> ty::fold::TypeVisitor<'tcx> for ProhibitOpaqueVisitor<'tcx> {\n+        type BreakTy = Ty<'tcx>;\n+\n+        fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+            debug!(\"check_opaque_for_inheriting_lifetimes: (visit_ty) t={:?}\", t);\n+            if t == self.opaque_identity_ty {\n+                ControlFlow::CONTINUE\n+            } else {\n+                t.super_visit_with(&mut FindParentLifetimeVisitor(self.generics))\n+                    .map_break(|FoundParentLifetime| t)\n+            }\n+        }\n+    }\n+\n     if let ItemKind::OpaqueTy(hir::OpaqueTy {\n         origin: hir::OpaqueTyOrigin::AsyncFn | hir::OpaqueTyOrigin::FnReturn,\n         ..\n@@ -555,14 +561,12 @@ pub(super) fn check_opaque_for_inheriting_lifetimes(\n \n             if let Ok(snippet) = tcx.sess.source_map().span_to_snippet(span) {\n                 if snippet == \"Self\" {\n-                    if let Some(ty) = ty {\n-                        err.span_suggestion(\n-                            span,\n-                            \"consider spelling out the type instead\",\n-                            format!(\"{:?}\", ty),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                    }\n+                    err.span_suggestion(\n+                        span,\n+                        \"consider spelling out the type instead\",\n+                        format!(\"{:?}\", ty),\n+                        Applicability::MaybeIncorrect,\n+                    );\n                 }\n             }\n             err.emit();"}, {"sha": "4834ca74b8270eaf0a09260fc62f10d4880ba387", "filename": "library/core/src/ops/control_flow.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/e3e4870bcec6820d60771052760a26891c4f8e45/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e3e4870bcec6820d60771052760a26891c4f8e45/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Fcontrol_flow.rs?ref=e3e4870bcec6820d60771052760a26891c4f8e45", "patch": "@@ -56,6 +56,20 @@ impl<B, C> ControlFlow<B, C> {\n             ControlFlow::Break(x) => Some(x),\n         }\n     }\n+\n+    /// Maps `ControlFlow<B, C>` to `ControlFlow<T, C>` by applying a function\n+    /// to the break value in case it exists.\n+    #[inline]\n+    #[unstable(feature = \"control_flow_enum\", reason = \"new API\", issue = \"75744\")]\n+    pub fn map_break<T, F>(self, f: F) -> ControlFlow<T, C>\n+    where\n+        F: FnOnce(B) -> T,\n+    {\n+        match self {\n+            ControlFlow::Continue(x) => ControlFlow::Continue(x),\n+            ControlFlow::Break(x) => ControlFlow::Break(f(x)),\n+        }\n+    }\n }\n \n impl<R: Try> ControlFlow<R, R::Ok> {"}]}