{"sha": "818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgxOGY4MzIwYTM0YzYwZWM3MmMyY2NlMGViMjRhNGEyNmMwZDJiN2E=", "commit": {"author": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-20T06:32:19Z"}, "committer": {"name": "Yoshitomo Nakanishi", "email": "yurayura.rounin.3@gmail.com", "date": "2021-03-26T11:22:07Z"}, "message": "Merge type_complexity pass into types pass", "tree": {"sha": "fde508df56cb2c0fa3a289bb62cd751bd7e962a2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fde508df56cb2c0fa3a289bb62cd751bd7e962a2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "html_url": "https://github.com/rust-lang/rust/commit/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a/comments", "author": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Y-Nak", "id": 6376004, "node_id": "MDQ6VXNlcjYzNzYwMDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/6376004?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Y-Nak", "html_url": "https://github.com/Y-Nak", "followers_url": "https://api.github.com/users/Y-Nak/followers", "following_url": "https://api.github.com/users/Y-Nak/following{/other_user}", "gists_url": "https://api.github.com/users/Y-Nak/gists{/gist_id}", "starred_url": "https://api.github.com/users/Y-Nak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Y-Nak/subscriptions", "organizations_url": "https://api.github.com/users/Y-Nak/orgs", "repos_url": "https://api.github.com/users/Y-Nak/repos", "events_url": "https://api.github.com/users/Y-Nak/events{/privacy}", "received_events_url": "https://api.github.com/users/Y-Nak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd1201a2635d757244dbdab09026d53ad52da6a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1201a2635d757244dbdab09026d53ad52da6a1", "html_url": "https://github.com/rust-lang/rust/commit/bd1201a2635d757244dbdab09026d53ad52da6a1"}], "stats": {"total": 392, "additions": 192, "deletions": 200}, "files": [{"sha": "402fecd478cc71beb628491d614496f0acfb7876", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "patch": "@@ -1031,7 +1031,8 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box await_holding_invalid::AwaitHolding);\n     store.register_late_pass(|| box serde_api::SerdeApi);\n     let vec_box_size_threshold = conf.vec_box_size_threshold;\n-    store.register_late_pass(move || box types::Types::new(vec_box_size_threshold));\n+    let type_complexity_threshold = conf.type_complexity_threshold;\n+    store.register_late_pass(move || box types::Types::new(vec_box_size_threshold, type_complexity_threshold));\n     store.register_late_pass(|| box booleans::NonminimalBool);\n     store.register_late_pass(|| box eq_op::EqOp);\n     store.register_late_pass(|| box enum_clike::UnportableVariant);\n@@ -1092,8 +1093,6 @@ pub fn register_plugins(store: &mut rustc_lint::LintStore, sess: &Session, conf:\n     store.register_late_pass(|| box main_recursion::MainRecursion::default());\n     store.register_late_pass(|| box lifetimes::Lifetimes);\n     store.register_late_pass(|| box entry::HashMapPass);\n-    let type_complexity_threshold = conf.type_complexity_threshold;\n-    store.register_late_pass(move || box types::TypeComplexity::new(type_complexity_threshold));\n     store.register_late_pass(|| box minmax::MinMaxPass);\n     store.register_late_pass(|| box open_options::OpenOptions);\n     store.register_late_pass(|| box zero_div_zero::ZeroDiv);"}, {"sha": "12e1eba2ca6620676d32d88581f911a7a5953042", "filename": "clippy_lints/src/types/mod.rs", "status": "modified", "additions": 111, "deletions": 197, "changes": 308, "blob_url": "https://github.com/rust-lang/rust/blob/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Fmod.rs?ref=818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "patch": "@@ -4,21 +4,19 @@ mod linked_list;\n mod option_option;\n mod rc_buffer;\n mod redundant_allocation;\n+mod type_complexity;\n mod utils;\n mod vec_box;\n \n-use clippy_utils::diagnostics::span_lint;\n use rustc_hir as hir;\n-use rustc_hir::intravisit::{walk_ty, FnKind, NestedVisitorMap, Visitor};\n+use rustc_hir::intravisit::FnKind;\n use rustc_hir::{\n-    Body, FnDecl, FnRetTy, FnSig, GenericArg, GenericParamKind, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local,\n-    MutTy, QPath, TraitFn, TraitItem, TraitItemKind, TyKind,\n+    Body, FnDecl, FnRetTy, GenericArg, HirId, ImplItem, ImplItemKind, Item, ItemKind, Local, MutTy, QPath, TraitItem,\n+    TraitItemKind, TyKind,\n };\n use rustc_lint::{LateContext, LateLintPass};\n-use rustc_middle::hir::map::Map;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n use rustc_span::source_map::Span;\n-use rustc_target::spec::abi::Abi;\n \n declare_clippy_lint! {\n     /// **What it does:** Checks for use of `Box<Vec<_>>` anywhere in the code.\n@@ -231,76 +229,144 @@ declare_clippy_lint! {\n     \"shared ownership of a buffer type\"\n }\n \n+declare_clippy_lint! {\n+    /// **What it does:** Checks for types used in structs, parameters and `let`\n+    /// declarations above a certain complexity threshold.\n+    ///\n+    /// **Why is this bad?** Too complex types make the code less readable. Consider\n+    /// using a `type` definition to simplify them.\n+    ///\n+    /// **Known problems:** None.\n+    ///\n+    /// **Example:**\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// struct Foo {\n+    ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n+    /// }\n+    /// ```\n+    pub TYPE_COMPLEXITY,\n+    complexity,\n+    \"usage of very complex types that might be better factored into `type` definitions\"\n+}\n+\n pub struct Types {\n     vec_box_size_threshold: u64,\n+    type_complexity_threshold: u64,\n }\n \n-impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER]);\n+impl_lint_pass!(Types => [BOX_VEC, VEC_BOX, OPTION_OPTION, LINKEDLIST, BORROWED_BOX, REDUNDANT_ALLOCATION, RC_BUFFER, TYPE_COMPLEXITY]);\n \n impl<'tcx> LateLintPass<'tcx> for Types {\n     fn check_fn(&mut self, cx: &LateContext<'_>, _: FnKind<'_>, decl: &FnDecl<'_>, _: &Body<'_>, _: Span, id: HirId) {\n-        // Skip trait implementations; see issue #605.\n-        if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id)) {\n-            if let ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }) = item.kind {\n-                return;\n-            }\n-        }\n+        let is_in_trait_impl = if let Some(hir::Node::Item(item)) = cx.tcx.hir().find(cx.tcx.hir().get_parent_item(id))\n+        {\n+            matches!(item.kind, ItemKind::Impl(hir::Impl { of_trait: Some(_), .. }))\n+        } else {\n+            false\n+        };\n \n-        self.check_fn_decl(cx, decl);\n+        self.check_fn_decl(\n+            cx,\n+            decl,\n+            CheckTyContext {\n+                is_in_trait_impl,\n+                ..CheckTyContext::default()\n+            },\n+        );\n     }\n \n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n         match item.kind {\n-            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => self.check_ty(cx, ty, false),\n+            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => {\n+                self.check_ty(cx, ty, CheckTyContext::default())\n+            },\n             // functions, enums, structs, impls and traits are covered\n             _ => (),\n         }\n     }\n \n+    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n+        match item.kind {\n+            ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_ty(\n+                cx,\n+                ty,\n+                CheckTyContext {\n+                    is_in_trait_impl: true,\n+                    ..CheckTyContext::default()\n+                },\n+            ),\n+            // methods are covered by check_fn\n+            ImplItemKind::Fn(..) => (),\n+        }\n+    }\n+\n     fn check_field_def(&mut self, cx: &LateContext<'_>, field: &hir::FieldDef<'_>) {\n-        self.check_ty(cx, &field.ty, false);\n+        self.check_ty(cx, &field.ty, CheckTyContext::default());\n     }\n \n     fn check_trait_item(&mut self, cx: &LateContext<'_>, item: &TraitItem<'_>) {\n         match item.kind {\n-            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_ty(cx, ty, false),\n-            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, &sig.decl),\n+            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => {\n+                self.check_ty(cx, ty, CheckTyContext::default())\n+            },\n+            TraitItemKind::Fn(ref sig, _) => self.check_fn_decl(cx, &sig.decl, CheckTyContext::default()),\n             TraitItemKind::Type(..) => (),\n         }\n     }\n \n     fn check_local(&mut self, cx: &LateContext<'_>, local: &Local<'_>) {\n         if let Some(ref ty) = local.ty {\n-            self.check_ty(cx, ty, true);\n+            self.check_ty(\n+                cx,\n+                ty,\n+                CheckTyContext {\n+                    is_local: true,\n+                    ..CheckTyContext::default()\n+                },\n+            );\n         }\n     }\n }\n \n impl Types {\n-    pub fn new(vec_box_size_threshold: u64) -> Self {\n-        Self { vec_box_size_threshold }\n+    pub fn new(vec_box_size_threshold: u64, type_complexity_threshold: u64) -> Self {\n+        Self {\n+            vec_box_size_threshold,\n+            type_complexity_threshold,\n+        }\n     }\n \n-    fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>) {\n+    fn check_fn_decl(&mut self, cx: &LateContext<'_>, decl: &FnDecl<'_>, context: CheckTyContext) {\n         for input in decl.inputs {\n-            self.check_ty(cx, input, false);\n+            self.check_ty(cx, input, context);\n         }\n \n         if let FnRetTy::Return(ref ty) = decl.output {\n-            self.check_ty(cx, ty, false);\n+            self.check_ty(cx, ty, context);\n         }\n     }\n \n     /// Recursively check for `TypePass` lints in the given type. Stop at the first\n     /// lint found.\n     ///\n     /// The parameter `is_local` distinguishes the context of the type.\n-    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, is_local: bool) {\n+    fn check_ty(&mut self, cx: &LateContext<'_>, hir_ty: &hir::Ty<'_>, mut context: CheckTyContext) {\n         if hir_ty.span.from_expansion() {\n             return;\n         }\n+\n+        if !context.is_nested_call && type_complexity::check(cx, hir_ty, self.type_complexity_threshold) {\n+            return;\n+        }\n+\n+        // Skip trait implementations; see issue #605.\n+        if context.is_in_trait_impl {\n+            return;\n+        }\n+\n         match hir_ty.kind {\n-            TyKind::Path(ref qpath) if !is_local => {\n+            TyKind::Path(ref qpath) if !context.is_local => {\n                 let hir_id = hir_ty.hir_id;\n                 let res = cx.qpath_res(qpath, hir_id);\n                 if let Some(def_id) = res.opt_def_id() {\n@@ -318,7 +384,8 @@ impl Types {\n                 }\n                 match *qpath {\n                     QPath::Resolved(Some(ref ty), ref p) => {\n-                        self.check_ty(cx, ty, is_local);\n+                        context.is_nested_call = true;\n+                        self.check_ty(cx, ty, context);\n                         for ty in p.segments.iter().flat_map(|seg| {\n                             seg.args\n                                 .as_ref()\n@@ -328,10 +395,11 @@ impl Types {\n                                     _ => None,\n                                 })\n                         }) {\n-                            self.check_ty(cx, ty, is_local);\n+                            self.check_ty(cx, ty, context);\n                         }\n                     },\n                     QPath::Resolved(None, ref p) => {\n+                        context.is_nested_call = true;\n                         for ty in p.segments.iter().flat_map(|seg| {\n                             seg.args\n                                 .as_ref()\n@@ -341,202 +409,48 @@ impl Types {\n                                     _ => None,\n                                 })\n                         }) {\n-                            self.check_ty(cx, ty, is_local);\n+                            self.check_ty(cx, ty, context);\n                         }\n                     },\n                     QPath::TypeRelative(ref ty, ref seg) => {\n-                        self.check_ty(cx, ty, is_local);\n+                        context.is_nested_call = true;\n+                        self.check_ty(cx, ty, context);\n                         if let Some(ref params) = seg.args {\n                             for ty in params.args.iter().filter_map(|arg| match arg {\n                                 GenericArg::Type(ty) => Some(ty),\n                                 _ => None,\n                             }) {\n-                                self.check_ty(cx, ty, is_local);\n+                                self.check_ty(cx, ty, context);\n                             }\n                         }\n                     },\n                     QPath::LangItem(..) => {},\n                 }\n             },\n             TyKind::Rptr(ref lt, ref mut_ty) => {\n+                context.is_nested_call = true;\n                 if !borrowed_box::check(cx, hir_ty, lt, mut_ty) {\n-                    self.check_ty(cx, &mut_ty.ty, is_local);\n+                    self.check_ty(cx, &mut_ty.ty, context);\n                 }\n             },\n             TyKind::Slice(ref ty) | TyKind::Array(ref ty, _) | TyKind::Ptr(MutTy { ref ty, .. }) => {\n-                self.check_ty(cx, ty, is_local)\n+                context.is_nested_call = true;\n+                self.check_ty(cx, ty, context)\n             },\n             TyKind::Tup(tys) => {\n+                context.is_nested_call = true;\n                 for ty in tys {\n-                    self.check_ty(cx, ty, is_local);\n+                    self.check_ty(cx, ty, context);\n                 }\n             },\n             _ => {},\n         }\n     }\n }\n \n-declare_clippy_lint! {\n-    /// **What it does:** Checks for types used in structs, parameters and `let`\n-    /// declarations above a certain complexity threshold.\n-    ///\n-    /// **Why is this bad?** Too complex types make the code less readable. Consider\n-    /// using a `type` definition to simplify them.\n-    ///\n-    /// **Known problems:** None.\n-    ///\n-    /// **Example:**\n-    /// ```rust\n-    /// # use std::rc::Rc;\n-    /// struct Foo {\n-    ///     inner: Rc<Vec<Vec<Box<(u32, u32, u32, u32)>>>>,\n-    /// }\n-    /// ```\n-    pub TYPE_COMPLEXITY,\n-    complexity,\n-    \"usage of very complex types that might be better factored into `type` definitions\"\n-}\n-\n-pub struct TypeComplexity {\n-    threshold: u64,\n-}\n-\n-impl TypeComplexity {\n-    #[must_use]\n-    pub fn new(threshold: u64) -> Self {\n-        Self { threshold }\n-    }\n-}\n-\n-impl_lint_pass!(TypeComplexity => [TYPE_COMPLEXITY]);\n-\n-impl<'tcx> LateLintPass<'tcx> for TypeComplexity {\n-    fn check_fn(\n-        &mut self,\n-        cx: &LateContext<'tcx>,\n-        _: FnKind<'tcx>,\n-        decl: &'tcx FnDecl<'_>,\n-        _: &'tcx Body<'_>,\n-        _: Span,\n-        _: HirId,\n-    ) {\n-        self.check_fndecl(cx, decl);\n-    }\n-\n-    fn check_field_def(&mut self, cx: &LateContext<'tcx>, field: &'tcx hir::FieldDef<'_>) {\n-        // enum variants are also struct fields now\n-        self.check_type(cx, &field.ty);\n-    }\n-\n-    fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx Item<'_>) {\n-        match item.kind {\n-            ItemKind::Static(ref ty, _, _) | ItemKind::Const(ref ty, _) => self.check_type(cx, ty),\n-            // functions, enums, structs, impls and traits are covered\n-            _ => (),\n-        }\n-    }\n-\n-    fn check_trait_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx TraitItem<'_>) {\n-        match item.kind {\n-            TraitItemKind::Const(ref ty, _) | TraitItemKind::Type(_, Some(ref ty)) => self.check_type(cx, ty),\n-            TraitItemKind::Fn(FnSig { ref decl, .. }, TraitFn::Required(_)) => self.check_fndecl(cx, decl),\n-            // methods with default impl are covered by check_fn\n-            TraitItemKind::Type(..) | TraitItemKind::Fn(_, TraitFn::Provided(_)) => (),\n-        }\n-    }\n-\n-    fn check_impl_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx ImplItem<'_>) {\n-        match item.kind {\n-            ImplItemKind::Const(ref ty, _) | ImplItemKind::TyAlias(ref ty) => self.check_type(cx, ty),\n-            // methods are covered by check_fn\n-            ImplItemKind::Fn(..) => (),\n-        }\n-    }\n-\n-    fn check_local(&mut self, cx: &LateContext<'tcx>, local: &'tcx Local<'_>) {\n-        if let Some(ref ty) = local.ty {\n-            self.check_type(cx, ty);\n-        }\n-    }\n-}\n-\n-impl<'tcx> TypeComplexity {\n-    fn check_fndecl(&self, cx: &LateContext<'tcx>, decl: &'tcx FnDecl<'_>) {\n-        for arg in decl.inputs {\n-            self.check_type(cx, arg);\n-        }\n-        if let FnRetTy::Return(ref ty) = decl.output {\n-            self.check_type(cx, ty);\n-        }\n-    }\n-\n-    fn check_type(&self, cx: &LateContext<'_>, ty: &hir::Ty<'_>) {\n-        if ty.span.from_expansion() {\n-            return;\n-        }\n-        let score = {\n-            let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n-            visitor.visit_ty(ty);\n-            visitor.score\n-        };\n-\n-        if score > self.threshold {\n-            span_lint(\n-                cx,\n-                TYPE_COMPLEXITY,\n-                ty.span,\n-                \"very complex type used. Consider factoring parts into `type` definitions\",\n-            );\n-        }\n-    }\n-}\n-\n-/// Walks a type and assigns a complexity score to it.\n-struct TypeComplexityVisitor {\n-    /// total complexity score of the type\n-    score: u64,\n-    /// current nesting level\n-    nest: u64,\n-}\n-\n-impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n-    type Map = Map<'tcx>;\n-\n-    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n-        let (add_score, sub_nest) = match ty.kind {\n-            // _, &x and *x have only small overhead; don't mess with nesting level\n-            TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n-\n-            // the \"normal\" components of a type: named types, arrays/tuples\n-            TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n-\n-            // function types bring a lot of overhead\n-            TyKind::BareFn(ref bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n-\n-            TyKind::TraitObject(ref param_bounds, _, _) => {\n-                let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n-                    bound\n-                        .bound_generic_params\n-                        .iter()\n-                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n-                });\n-                if has_lifetime_parameters {\n-                    // complex trait bounds like A<'a, 'b>\n-                    (50 * self.nest, 1)\n-                } else {\n-                    // simple trait bounds like A + B\n-                    (20 * self.nest, 0)\n-                }\n-            },\n-\n-            _ => (0, 0),\n-        };\n-        self.score += add_score;\n-        self.nest += sub_nest;\n-        walk_ty(self, ty);\n-        self.nest -= sub_nest;\n-    }\n-    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n-        NestedVisitorMap::None\n-    }\n+#[derive(Clone, Copy, Default)]\n+struct CheckTyContext {\n+    is_in_trait_impl: bool,\n+    is_local: bool,\n+    is_nested_call: bool,\n }"}, {"sha": "9a4e9da3e2be4cf87b7d5609146a15801c8bed1d", "filename": "clippy_lints/src/types/type_complexity.rs", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes%2Ftype_complexity.rs?ref=818f8320a34c60ec72c2cce0eb24a4a26c0d2b7a", "patch": "@@ -0,0 +1,79 @@\n+use clippy_utils::diagnostics::span_lint;\n+use rustc_hir as hir;\n+use rustc_hir::intravisit::{walk_ty, NestedVisitorMap, Visitor};\n+use rustc_hir::{GenericParamKind, TyKind};\n+use rustc_lint::LateContext;\n+use rustc_middle::hir::map::Map;\n+use rustc_target::spec::abi::Abi;\n+\n+use super::TYPE_COMPLEXITY;\n+\n+pub(super) fn check(cx: &LateContext<'_>, ty: &hir::Ty<'_>, type_complexity_threshold: u64) -> bool {\n+    let score = {\n+        let mut visitor = TypeComplexityVisitor { score: 0, nest: 1 };\n+        visitor.visit_ty(ty);\n+        visitor.score\n+    };\n+\n+    if score > type_complexity_threshold {\n+        span_lint(\n+            cx,\n+            TYPE_COMPLEXITY,\n+            ty.span,\n+            \"very complex type used. Consider factoring parts into `type` definitions\",\n+        );\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\n+/// Walks a type and assigns a complexity score to it.\n+struct TypeComplexityVisitor {\n+    /// total complexity score of the type\n+    score: u64,\n+    /// current nesting level\n+    nest: u64,\n+}\n+\n+impl<'tcx> Visitor<'tcx> for TypeComplexityVisitor {\n+    type Map = Map<'tcx>;\n+\n+    fn visit_ty(&mut self, ty: &'tcx hir::Ty<'_>) {\n+        let (add_score, sub_nest) = match ty.kind {\n+            // _, &x and *x have only small overhead; don't mess with nesting level\n+            TyKind::Infer | TyKind::Ptr(..) | TyKind::Rptr(..) => (1, 0),\n+\n+            // the \"normal\" components of a type: named types, arrays/tuples\n+            TyKind::Path(..) | TyKind::Slice(..) | TyKind::Tup(..) | TyKind::Array(..) => (10 * self.nest, 1),\n+\n+            // function types bring a lot of overhead\n+            TyKind::BareFn(ref bare) if bare.abi == Abi::Rust => (50 * self.nest, 1),\n+\n+            TyKind::TraitObject(ref param_bounds, _, _) => {\n+                let has_lifetime_parameters = param_bounds.iter().any(|bound| {\n+                    bound\n+                        .bound_generic_params\n+                        .iter()\n+                        .any(|gen| matches!(gen.kind, GenericParamKind::Lifetime { .. }))\n+                });\n+                if has_lifetime_parameters {\n+                    // complex trait bounds like A<'a, 'b>\n+                    (50 * self.nest, 1)\n+                } else {\n+                    // simple trait bounds like A + B\n+                    (20 * self.nest, 0)\n+                }\n+            },\n+\n+            _ => (0, 0),\n+        };\n+        self.score += add_score;\n+        self.nest += sub_nest;\n+        walk_ty(self, ty);\n+        self.nest -= sub_nest;\n+    }\n+    fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+        NestedVisitorMap::None\n+    }\n+}"}]}