{"sha": "a33b921c0db989368fbe9f9ff428a2e014439032", "node_id": "MDY6Q29tbWl0NzI0NzEyOmEzM2I5MjFjMGRiOTg5MzY4ZmJlOWY5ZmY0MjhhMmUwMTQ0MzkwMzI=", "commit": {"author": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-09-19T03:46:25Z"}, "committer": {"name": "Srinivas Reddy Thatiparthy", "email": "thatiparthysreenivas@gmail.com", "date": "2016-09-26T02:26:44Z"}, "message": " run rustfmt on typecheck/coherence folder", "tree": {"sha": "ce0789c8b78f5fb75df68a2c1bdd0e8a7fb11ec6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ce0789c8b78f5fb75df68a2c1bdd0e8a7fb11ec6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a33b921c0db989368fbe9f9ff428a2e014439032", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\nVersion: GnuPG v1\n\niQIcBAABAgAGBQJX6IdkAAoJEAkcWPS/w2VxlysP/0Gfs1mIb4/sX+7+focQ1Z7x\n8PQNPSrOAYHdHPhpzGp+WEFOTzvXCHp2p5mWocMVCwUQLxrJfsTzaUWHDmXPmlng\nW2spHvMsj/MYX8oPL6oz+DMhgt97dLmlHZGwJXY1qZWpC2mhgMIFlgmx9paoTRcY\n+r/N4oG2BfzX8G3QnId90dPF7dWMuu/8zAe+c5B0zq3F0XMrezh14BkoUUlvBPMR\nau1ZIG2L98nO6tWbpRhFqJKYk8RRTkpywbXGx8W046gU2ny5ZyGEtVL0MkYR6U5P\nlmEvGLdp0oy7o25iVY0iaVkqHkw4ejaUpbLg5fAgBdJEoh+QW5MiJNorswLpWUcW\nBDXPAhAejJDImoWTTR7UghXAMIBAMwu33LUv+WFpC+i2QWbplvlp0w1OZTWVrFiy\n/dYwVLWAf2pw28ZjedoJk4gulw+x9RCweLC9fFlWvakg/meRBNlGNuerc/BRbDv4\nVVEi+ALsqG2JuC9GV7xtZVVBc6YCQpcJS4KDfX/VSf4xuuJC26d4ZF9XdvPcY2F6\ndlrcbQnWea69fefxjOKmlk4pSAU7wRgChAeadGMaUKenL6XChCfsoW/6A/a+kt6L\nvEMaDVHFBamsU5Fb9uB8w8Ufu1iM906f09ZCMj5RO8Qg7Agw0hXoUUJiB/2Ynq/V\ndcqGzR5Ni3xTmRTiIn4g\n=pwt5\n-----END PGP SIGNATURE-----", "payload": "tree ce0789c8b78f5fb75df68a2c1bdd0e8a7fb11ec6\nparent 95abee1a680f008fb97472294dd376a66e06d311\nauthor Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1474256785 +0530\ncommitter Srinivas Reddy Thatiparthy <thatiparthysreenivas@gmail.com> 1474856804 +0530\n\n run rustfmt on typecheck/coherence folder\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a33b921c0db989368fbe9f9ff428a2e014439032", "html_url": "https://github.com/rust-lang/rust/commit/a33b921c0db989368fbe9f9ff428a2e014439032", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a33b921c0db989368fbe9f9ff428a2e014439032/comments", "author": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "srinivasreddy", "id": 198396, "node_id": "MDQ6VXNlcjE5ODM5Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/198396?v=4", "gravatar_id": "", "url": "https://api.github.com/users/srinivasreddy", "html_url": "https://github.com/srinivasreddy", "followers_url": "https://api.github.com/users/srinivasreddy/followers", "following_url": "https://api.github.com/users/srinivasreddy/following{/other_user}", "gists_url": "https://api.github.com/users/srinivasreddy/gists{/gist_id}", "starred_url": "https://api.github.com/users/srinivasreddy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/srinivasreddy/subscriptions", "organizations_url": "https://api.github.com/users/srinivasreddy/orgs", "repos_url": "https://api.github.com/users/srinivasreddy/repos", "events_url": "https://api.github.com/users/srinivasreddy/events{/privacy}", "received_events_url": "https://api.github.com/users/srinivasreddy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95abee1a680f008fb97472294dd376a66e06d311", "url": "https://api.github.com/repos/rust-lang/rust/commits/95abee1a680f008fb97472294dd376a66e06d311", "html_url": "https://github.com/rust-lang/rust/commit/95abee1a680f008fb97472294dd376a66e06d311"}], "stats": {"total": 448, "additions": 249, "deletions": 199}, "files": [{"sha": "ca22faa2ec36ab27f27c1c31cf01f2f3db772815", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 115, "deletions": 99, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/a33b921c0db989368fbe9f9ff428a2e014439032/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b921c0db989368fbe9f9ff428a2e014439032/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=a33b921c0db989368fbe9f9ff428a2e014439032", "patch": "@@ -20,7 +20,7 @@ use middle::lang_items::UnsizeTraitLangItem;\n use rustc::ty::subst::Subst;\n use rustc::ty::{self, TyCtxt, TypeFoldable};\n use rustc::traits::{self, Reveal};\n-use rustc::ty::{ParameterEnvironment};\n+use rustc::ty::ParameterEnvironment;\n use rustc::ty::{Ty, TyBool, TyChar, TyError};\n use rustc::ty::{TyParam, TyRawPtr};\n use rustc::ty::{TyRef, TyAdt, TyTrait, TyNever, TyTuple};\n@@ -44,13 +44,13 @@ mod orphan;\n mod overlap;\n mod unsafety;\n \n-struct CoherenceChecker<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n+struct CoherenceChecker<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n     crate_context: &'a CrateCtxt<'a, 'gcx>,\n     inference_context: InferCtxt<'a, 'gcx, 'tcx>,\n }\n \n-struct CoherenceCheckVisitor<'a, 'gcx: 'a+'tcx, 'tcx: 'a> {\n-    cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>\n+struct CoherenceCheckVisitor<'a, 'gcx: 'a + 'tcx, 'tcx: 'a> {\n+    cc: &'a CoherenceChecker<'a, 'gcx, 'tcx>,\n }\n \n impl<'a, 'gcx, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, 'gcx, 'tcx> {\n@@ -62,36 +62,25 @@ impl<'a, 'gcx, 'tcx, 'v> intravisit::Visitor<'v> for CoherenceCheckVisitor<'a, '\n }\n \n impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n-\n     // Returns the def ID of the base type, if there is one.\n     fn get_base_type_def_id(&self, span: Span, ty: Ty<'tcx>) -> Option<DefId> {\n         match ty.sty {\n-            TyAdt(def, _) => {\n-                Some(def.did)\n-            }\n+            TyAdt(def, _) => Some(def.did),\n \n-            TyTrait(ref t) => {\n-                Some(t.principal.def_id())\n-            }\n+            TyTrait(ref t) => Some(t.principal.def_id()),\n \n-            TyBox(_) => {\n-                self.inference_context.tcx.lang_items.owned_box()\n-            }\n+            TyBox(_) => self.inference_context.tcx.lang_items.owned_box(),\n \n-            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) |\n-            TyStr | TyArray(..) | TySlice(..) | TyFnDef(..) | TyFnPtr(_) |\n-            TyTuple(..) | TyParam(..) | TyError | TyNever |\n-            TyRawPtr(_) | TyRef(..) | TyProjection(..) => {\n-                None\n-            }\n+            TyBool | TyChar | TyInt(..) | TyUint(..) | TyFloat(..) | TyStr | TyArray(..) |\n+            TySlice(..) | TyFnDef(..) | TyFnPtr(_) | TyTuple(..) | TyParam(..) | TyError |\n+            TyNever | TyRawPtr(_) | TyRef(..) | TyProjection(..) => None,\n \n             TyInfer(..) | TyClosure(..) | TyAnon(..) => {\n                 // `ty` comes from a user declaration so we should only expect types\n                 // that the user can type\n-                span_bug!(\n-                    span,\n-                    \"coherence encountered unexpected type searching for base type: {}\",\n-                    ty);\n+                span_bug!(span,\n+                          \"coherence encountered unexpected type searching for base type: {}\",\n+                          ty);\n             }\n         }\n     }\n@@ -100,9 +89,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         // Check implementations and traits. This populates the tables\n         // containing the inherent methods and extension methods. It also\n         // builds up the trait inheritance table.\n-        self.crate_context.tcx.visit_all_items_in_krate(\n-            DepNode::CoherenceCheckImpl,\n-            &mut CoherenceCheckVisitor { cc: self });\n+        self.crate_context.tcx.visit_all_items_in_krate(DepNode::CoherenceCheckImpl,\n+                                                        &mut CoherenceCheckVisitor { cc: self });\n \n         // Populate the table of destructors. It might seem a bit strange to\n         // do this here, but it's actually the most convenient place, since\n@@ -167,7 +155,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n     fn add_trait_impl(&self, impl_trait_ref: ty::TraitRef<'gcx>, impl_def_id: DefId) {\n         debug!(\"add_trait_impl: impl_trait_ref={:?} impl_def_id={:?}\",\n-               impl_trait_ref, impl_def_id);\n+               impl_trait_ref,\n+               impl_def_id);\n         let trait_def = self.crate_context.tcx.lookup_trait_def(impl_trait_ref.def_id);\n         trait_def.record_local_impl(self.crate_context.tcx, impl_def_id, impl_trait_ref);\n     }\n@@ -176,24 +165,24 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n     fn create_impl_from_item(&self, item: &Item) -> Vec<DefId> {\n         match item.node {\n             ItemImpl(.., ref impl_items) => {\n-                impl_items.iter().map(|impl_item| {\n-                    self.crate_context.tcx.map.local_def_id(impl_item.id)\n-                }).collect()\n+                impl_items.iter()\n+                    .map(|impl_item| self.crate_context.tcx.map.local_def_id(impl_item.id))\n+                    .collect()\n             }\n             _ => {\n                 span_bug!(item.span, \"can't convert a non-impl to an impl\");\n             }\n         }\n     }\n \n-    //\n     // Destructors\n     //\n \n     fn populate_destructors(&self) {\n         let tcx = self.crate_context.tcx;\n         let drop_trait = match tcx.lang_items.drop_trait() {\n-            Some(id) => id, None => { return }\n+            Some(id) => id,\n+            None => return,\n         };\n         tcx.populate_implementations_for_trait_if_necessary(drop_trait);\n         let drop_trait = tcx.lookup_trait_def(drop_trait);\n@@ -219,13 +208,14 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         match tcx.map.find(impl_node_id) {\n                             Some(hir_map::NodeItem(item)) => {\n                                 let span = match item.node {\n-                                    ItemImpl(.., ref ty, _) => {\n-                                        ty.span\n-                                    },\n-                                    _ => item.span\n+                                    ItemImpl(.., ref ty, _) => ty.span,\n+                                    _ => item.span,\n                                 };\n-                                struct_span_err!(tcx.sess, span, E0120,\n-                                    \"the Drop trait may only be implemented on structures\")\n+                                struct_span_err!(tcx.sess,\n+                                                 span,\n+                                                 E0120,\n+                                                 \"the Drop trait may only be implemented on \\\n+                                                  structures\")\n                                     .span_label(span,\n                                                 &format!(\"implementing Drop requires a struct\"))\n                                     .emit();\n@@ -254,15 +244,14 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n         let copy_trait = tcx.lookup_trait_def(copy_trait);\n \n         copy_trait.for_each_impl(tcx, |impl_did| {\n-            debug!(\"check_implementations_of_copy: impl_did={:?}\",\n-                   impl_did);\n+            debug!(\"check_implementations_of_copy: impl_did={:?}\", impl_did);\n \n             let impl_node_id = if let Some(n) = tcx.map.as_local_node_id(impl_did) {\n                 n\n             } else {\n                 debug!(\"check_implementations_of_copy(): impl not in this \\\n                         crate\");\n-                return\n+                return;\n             };\n \n             let self_type = tcx.lookup_item_type(impl_did);\n@@ -280,14 +269,12 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             match param_env.can_type_implement_copy(tcx, self_type, span) {\n                 Ok(()) => {}\n                 Err(CopyImplementationError::InfrigingField(name)) => {\n-                       struct_span_err!(tcx.sess, span, E0204,\n-                                 \"the trait `Copy` may not be implemented for \\\n-                                 this type\")\n-                           .span_label(span, &format!(\n-                                 \"field `{}` does not implement `Copy`\", name)\n-                               )\n-                           .emit()\n-\n+                    struct_span_err!(tcx.sess,\n+                                     span,\n+                                     E0204,\n+                                     \"the trait `Copy` may not be implemented for this type\")\n+                        .span_label(span, &format!(\"field `{}` does not implement `Copy`\", name))\n+                        .emit()\n                 }\n                 Err(CopyImplementationError::InfrigingVariant(name)) => {\n                     let item = tcx.map.expect_item(impl_node_id);\n@@ -297,10 +284,12 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         span\n                     };\n \n-                    struct_span_err!(tcx.sess, span, E0205,\n+                    struct_span_err!(tcx.sess,\n+                                     span,\n+                                     E0205,\n                                      \"the trait `Copy` may not be implemented for this type\")\n-                        .span_label(span, &format!(\"variant `{}` does not implement `Copy`\",\n-                                                   name))\n+                        .span_label(span,\n+                                    &format!(\"variant `{}` does not implement `Copy`\", name))\n                         .emit()\n                 }\n                 Err(CopyImplementationError::NotAnAdt) => {\n@@ -311,15 +300,19 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                         span\n                     };\n \n-                    struct_span_err!(tcx.sess, span, E0206,\n+                    struct_span_err!(tcx.sess,\n+                                     span,\n+                                     E0206,\n                                      \"the trait `Copy` may not be implemented for this type\")\n                         .span_label(span, &format!(\"type is not a structure or enumeration\"))\n                         .emit();\n                 }\n                 Err(CopyImplementationError::HasDestructor) => {\n-                    struct_span_err!(tcx.sess, span, E0184,\n-                              \"the trait `Copy` may not be implemented for this type; \\\n-                               the type has a destructor\")\n+                    struct_span_err!(tcx.sess,\n+                                     span,\n+                                     E0184,\n+                                     \"the trait `Copy` may not be implemented for this type; the \\\n+                                      type has a destructor\")\n                         .span_label(span, &format!(\"Copy not allowed on types with destructors\"))\n                         .emit();\n                 }\n@@ -359,7 +352,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             let trait_ref = self.crate_context.tcx.impl_trait_ref(impl_did).unwrap();\n             let target = trait_ref.substs.type_at(1);\n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (bound)\",\n-                   source, target);\n+                   source,\n+                   target);\n \n             let span = tcx.map.span(impl_node_id);\n             let param_env = ParameterEnvironment::for_item(tcx, impl_node_id);\n@@ -368,15 +362,19 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n             assert!(!source.has_escaping_regions());\n \n             debug!(\"check_implementations_of_coerce_unsized: {:?} -> {:?} (free)\",\n-                   source, target);\n+                   source,\n+                   target);\n \n             tcx.infer_ctxt(None, Some(param_env), Reveal::ExactMatch).enter(|infcx| {\n                 let origin = TypeOrigin::Misc(span);\n-                let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>, mt_b: ty::TypeAndMut<'gcx>,\n+                let check_mutbl = |mt_a: ty::TypeAndMut<'gcx>,\n+                                   mt_b: ty::TypeAndMut<'gcx>,\n                                    mk_ptr: &Fn(Ty<'gcx>) -> Ty<'gcx>| {\n                     if (mt_a.mutbl, mt_b.mutbl) == (hir::MutImmutable, hir::MutMutable) {\n-                        infcx.report_mismatched_types(origin, mk_ptr(mt_b.ty),\n-                                                      target, ty::error::TypeError::Mutability);\n+                        infcx.report_mismatched_types(origin,\n+                                                      mk_ptr(mt_b.ty),\n+                                                      target,\n+                                                      ty::error::TypeError::Mutability);\n                     }\n                     (mt_a.ty, mt_b.ty, unsize_trait, None)\n                 };\n@@ -394,37 +392,45 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                     }\n \n                     (&ty::TyAdt(def_a, substs_a), &ty::TyAdt(def_b, substs_b))\n-                            if def_a.is_struct() && def_b.is_struct() => {\n+                        if def_a.is_struct() && def_b.is_struct() => {\n                         if def_a != def_b {\n                             let source_path = tcx.item_path_str(def_a.did);\n                             let target_path = tcx.item_path_str(def_b.did);\n-                            span_err!(tcx.sess, span, E0377,\n+                            span_err!(tcx.sess,\n+                                      span,\n+                                      E0377,\n                                       \"the trait `CoerceUnsized` may only be implemented \\\n                                        for a coercion between structures with the same \\\n                                        definition; expected {}, found {}\",\n-                                      source_path, target_path);\n+                                      source_path,\n+                                      target_path);\n                             return;\n                         }\n \n                         let fields = &def_a.struct_variant().fields;\n-                        let diff_fields = fields.iter().enumerate().filter_map(|(i, f)| {\n-                            let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n-\n-                            if f.unsubst_ty().is_phantom_data() {\n-                                // Ignore PhantomData fields\n-                                None\n-                            } else if infcx.sub_types(false, origin, b, a).is_ok() {\n-                                // Ignore fields that aren't significantly changed\n-                                None\n-                            } else {\n-                                // Collect up all fields that were significantly changed\n-                                // i.e. those that contain T in coerce_unsized T -> U\n-                                Some((i, a, b))\n-                            }\n-                        }).collect::<Vec<_>>();\n+                        let diff_fields = fields.iter()\n+                            .enumerate()\n+                            .filter_map(|(i, f)| {\n+                                let (a, b) = (f.ty(tcx, substs_a), f.ty(tcx, substs_b));\n+\n+                                if f.unsubst_ty().is_phantom_data() {\n+                                    // Ignore PhantomData fields\n+                                    None\n+                                } else if infcx.sub_types(false, origin, b, a).is_ok() {\n+                                    // Ignore fields that aren't significantly changed\n+                                    None\n+                                } else {\n+                                    // Collect up all fields that were significantly changed\n+                                    // i.e. those that contain T in coerce_unsized T -> U\n+                                    Some((i, a, b))\n+                                }\n+                            })\n+                            .collect::<Vec<_>>();\n \n                         if diff_fields.is_empty() {\n-                            span_err!(tcx.sess, span, E0374,\n+                            span_err!(tcx.sess,\n+                                      span,\n+                                      E0374,\n                                       \"the trait `CoerceUnsized` may only be implemented \\\n                                        for a coercion between structures with one field \\\n                                        being coerced, none found\");\n@@ -437,16 +443,22 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                                 tcx.map.span(impl_node_id)\n                             };\n \n-                            let mut err = struct_span_err!(tcx.sess, span, E0375,\n-                                      \"implementing the trait `CoerceUnsized` \\\n-                                       requires multiple coercions\");\n+                            let mut err = struct_span_err!(tcx.sess,\n+                                                           span,\n+                                                           E0375,\n+                                                           \"implementing the trait \\\n+                                                            `CoerceUnsized` requires multiple \\\n+                                                            coercions\");\n                             err.note(\"`CoerceUnsized` may only be implemented for \\\n                                       a coercion between structures with one field being coerced\");\n                             err.note(&format!(\"currently, {} fields need coercions: {}\",\n-                                             diff_fields.len(),\n-                                             diff_fields.iter().map(|&(i, a, b)| {\n-                                                format!(\"{} ({} to {})\", fields[i].name, a, b)\n-                                             }).collect::<Vec<_>>().join(\", \") ));\n+                                              diff_fields.len(),\n+                                              diff_fields.iter()\n+                                                  .map(|&(i, a, b)| {\n+                                                      format!(\"{} ({} to {})\", fields[i].name, a, b)\n+                                                  })\n+                                                  .collect::<Vec<_>>()\n+                                                  .join(\", \")));\n                             err.span_label(span, &format!(\"requires multiple coercions\"));\n                             err.emit();\n                             return;\n@@ -458,7 +470,9 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n                     }\n \n                     _ => {\n-                        span_err!(tcx.sess, span, E0376,\n+                        span_err!(tcx.sess,\n+                                  span,\n+                                  E0376,\n                                   \"the trait `CoerceUnsized` may only be implemented \\\n                                    for a coercion between structures\");\n                         return;\n@@ -469,8 +483,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n                 // Register an obligation for `A: Trait<B>`.\n                 let cause = traits::ObligationCause::misc(span, impl_node_id);\n-                let predicate = tcx.predicate_for_trait_def(cause, trait_def_id, 0,\n-                                                            source, &[target]);\n+                let predicate =\n+                    tcx.predicate_for_trait_def(cause, trait_def_id, 0, source, &[target]);\n                 fulfill_cx.register_predicate_obligation(&infcx, predicate);\n \n                 // Check that all transitive obligations are satisfied.\n@@ -480,8 +494,8 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n \n                 // Finally, resolve all regions.\n                 let mut free_regions = FreeRegionMap::new();\n-                free_regions.relate_free_regions_from_predicates(\n-                    &infcx.parameter_environment.caller_bounds);\n+                free_regions.relate_free_regions_from_predicates(&infcx.parameter_environment\n+                    .caller_bounds);\n                 infcx.resolve_regions_and_report_errors(&free_regions, impl_node_id);\n \n                 if let Some(kind) = kind {\n@@ -495,7 +509,7 @@ impl<'a, 'gcx, 'tcx> CoherenceChecker<'a, 'gcx, 'tcx> {\n fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: DefId) {\n     if tcx.sess.features.borrow().unboxed_closures {\n         // the feature gate allows all of them\n-        return\n+        return;\n     }\n     let did = Some(trait_def_id);\n     let li = &tcx.lang_items;\n@@ -507,24 +521,26 @@ fn enforce_trait_manually_implementable(tcx: TyCtxt, sp: Span, trait_def_id: Def\n     } else if did == li.fn_once_trait() {\n         \"FnOnce\"\n     } else {\n-        return // everything OK\n+        return; // everything OK\n     };\n     let mut err = struct_span_err!(tcx.sess,\n                                    sp,\n                                    E0183,\n                                    \"manual implementations of `{}` are experimental\",\n                                    trait_name);\n-    help!(&mut err, \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n+    help!(&mut err,\n+          \"add `#![feature(unboxed_closures)]` to the crate attributes to enable\");\n     err.emit();\n }\n \n pub fn check_coherence(ccx: &CrateCtxt) {\n     let _task = ccx.tcx.dep_graph.in_task(DepNode::Coherence);\n     ccx.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n         CoherenceChecker {\n-            crate_context: ccx,\n-            inference_context: infcx,\n-        }.check();\n+                crate_context: ccx,\n+                inference_context: infcx,\n+            }\n+            .check();\n     });\n     unsafety::check(ccx.tcx);\n     orphan::check(ccx.tcx);"}, {"sha": "bff794364c098dadc745f646022e5d77df181ebc", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 62, "deletions": 47, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/a33b921c0db989368fbe9f9ff428a2e014439032/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b921c0db989368fbe9f9ff428a2e014439032/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=a33b921c0db989368fbe9f9ff428a2e014439032", "patch": "@@ -25,17 +25,20 @@ pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.visit_all_items_in_krate(DepNode::CoherenceOrphanCheck, &mut orphan);\n }\n \n-struct OrphanChecker<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>\n+struct OrphanChecker<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n }\n \n impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     fn check_def_id(&self, item: &hir::Item, def_id: DefId) {\n         if def_id.krate != LOCAL_CRATE {\n-            struct_span_err!(self.tcx.sess, item.span, E0116,\n-                      \"cannot define inherent `impl` for a type outside of the \\\n-                       crate where the type is defined\")\n-                .span_label(item.span, &format!(\"impl for type defined outside of crate.\"))\n+            struct_span_err!(self.tcx.sess,\n+                             item.span,\n+                             E0116,\n+                             \"cannot define inherent `impl` for a type outside of the crate \\\n+                              where the type is defined\")\n+                .span_label(item.span,\n+                            &format!(\"impl for type defined outside of crate.\"))\n                 .note(\"define and implement a trait or new type instead\")\n                 .emit();\n         }\n@@ -48,11 +51,17 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                             ty: &str,\n                             span: Span) {\n         match lang_def_id {\n-            Some(lang_def_id) if lang_def_id == impl_def_id => { /* OK */ },\n+            Some(lang_def_id) if lang_def_id == impl_def_id => {\n+                // OK\n+            }\n             _ => {\n-                struct_span_err!(self.tcx.sess, span, E0390,\n-                          \"only a single inherent implementation marked with `#[lang = \\\"{}\\\"]` \\\n-                           is allowed for the `{}` primitive\", lang, ty)\n+                struct_span_err!(self.tcx.sess,\n+                                 span,\n+                                 E0390,\n+                                 \"only a single inherent implementation marked with `#[lang = \\\n+                                  \\\"{}\\\"]` is allowed for the `{}` primitive\",\n+                                 lang,\n+                                 ty)\n                     .span_help(span, \"consider using a trait to implement these methods\")\n                     .emit();\n             }\n@@ -209,12 +218,14 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                         return;\n                     }\n                     _ => {\n-                        struct_span_err!(self.tcx.sess, ty.span, E0118,\n+                        struct_span_err!(self.tcx.sess,\n+                                         ty.span,\n+                                         E0118,\n                                          \"no base type found for inherent implementation\")\n-                        .span_label(ty.span, &format!(\"impl requires a base type\"))\n-                        .note(&format!(\"either implement a trait on it or create a newtype \\\n-                                        to wrap it instead\"))\n-                        .emit();\n+                            .span_label(ty.span, &format!(\"impl requires a base type\"))\n+                            .note(&format!(\"either implement a trait on it or create a newtype \\\n+                                            to wrap it instead\"))\n+                            .emit();\n                         return;\n                     }\n                 }\n@@ -226,20 +237,23 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n                 match traits::orphan_check(self.tcx, def_id) {\n-                    Ok(()) => { }\n+                    Ok(()) => {}\n                     Err(traits::OrphanCheckErr::NoLocalInputType) => {\n-                        struct_span_err!(\n-                            self.tcx.sess, item.span, E0117,\n-                             \"only traits defined in the current crate can be \\\n-                             implemented for arbitrary types\")\n-                        .span_label(item.span, &format!(\"impl doesn't use types inside crate\"))\n-                        .note(&format!(\"the impl does not reference any \\\n-                                        types defined in this crate\"))\n-                        .emit();\n+                        struct_span_err!(self.tcx.sess,\n+                                         item.span,\n+                                         E0117,\n+                                         \"only traits defined in the current crate can be \\\n+                                          implemented for arbitrary types\")\n+                            .span_label(item.span, &format!(\"impl doesn't use types inside crate\"))\n+                            .note(&format!(\"the impl does not reference any types defined in \\\n+                                            this crate\"))\n+                            .emit();\n                         return;\n                     }\n                     Err(traits::OrphanCheckErr::UncoveredTy(param_ty)) => {\n-                        span_err!(self.tcx.sess, item.span, E0210,\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0210,\n                                   \"type parameter `{}` must be used as the type parameter for \\\n                                    some local type (e.g. `MyStruct<T>`); only traits defined in \\\n                                    the current crate can be implemented for a type parameter\",\n@@ -285,10 +299,8 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        trait_ref,\n                        trait_def_id,\n                        self.tcx.trait_has_default_impl(trait_def_id));\n-                if\n-                    self.tcx.trait_has_default_impl(trait_def_id) &&\n-                    trait_def_id.krate != LOCAL_CRATE\n-                {\n+                if self.tcx.trait_has_default_impl(trait_def_id) &&\n+                   trait_def_id.krate != LOCAL_CRATE {\n                     let self_ty = trait_ref.self_ty();\n                     let opt_self_def_id = match self_ty.sty {\n                         ty::TyAdt(self_def, _) => Some(self_def.did),\n@@ -305,20 +317,17 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                             if self_def_id.is_local() {\n                                 None\n                             } else {\n-                                Some(format!(\n-                                    \"cross-crate traits with a default impl, like `{}`, \\\n-                                     can only be implemented for a struct/enum type \\\n-                                     defined in the current crate\",\n-                                    self.tcx.item_path_str(trait_def_id)))\n+                                Some(format!(\"cross-crate traits with a default impl, like `{}`, \\\n+                                              can only be implemented for a struct/enum type \\\n+                                              defined in the current crate\",\n+                                             self.tcx.item_path_str(trait_def_id)))\n                             }\n                         }\n                         _ => {\n-                            Some(format!(\n-                                \"cross-crate traits with a default impl, like `{}`, \\\n-                                 can only be implemented for a struct/enum type, \\\n-                                 not `{}`\",\n-                                self.tcx.item_path_str(trait_def_id),\n-                                self_ty))\n+                            Some(format!(\"cross-crate traits with a default impl, like `{}`, can \\\n+                                          only be implemented for a struct/enum type, not `{}`\",\n+                                         self.tcx.item_path_str(trait_def_id),\n+                                         self_ty))\n                         }\n                     };\n \n@@ -330,14 +339,18 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n \n                 // Disallow *all* explicit impls of `Sized` and `Unsize` for now.\n                 if Some(trait_def_id) == self.tcx.lang_items.sized_trait() {\n-                    struct_span_err!(self.tcx.sess, item.span, E0322,\n-                              \"explicit impls for the `Sized` trait are not permitted\")\n+                    struct_span_err!(self.tcx.sess,\n+                                     item.span,\n+                                     E0322,\n+                                     \"explicit impls for the `Sized` trait are not permitted\")\n                         .span_label(item.span, &format!(\"impl of 'Sized' not allowed\"))\n                         .emit();\n                     return;\n                 }\n                 if Some(trait_def_id) == self.tcx.lang_items.unsize_trait() {\n-                    span_err!(self.tcx.sess, item.span, E0328,\n+                    span_err!(self.tcx.sess,\n+                              item.span,\n+                              E0328,\n                               \"explicit impls for the `Unsize` trait are not permitted\");\n                     return;\n                 }\n@@ -348,9 +361,11 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n                        self.tcx.map.node_to_string(item.id));\n                 let trait_ref = self.tcx.impl_trait_ref(def_id).unwrap();\n                 if trait_ref.def_id.krate != LOCAL_CRATE {\n-                    struct_span_err!(self.tcx.sess, item_trait_ref.path.span, E0318,\n-                              \"cannot create default implementations for traits outside the \\\n-                               crate they're defined in; define a new trait instead\")\n+                    struct_span_err!(self.tcx.sess,\n+                                     item_trait_ref.path.span,\n+                                     E0318,\n+                                     \"cannot create default implementations for traits outside \\\n+                                      the crate they're defined in; define a new trait instead\")\n                         .span_label(item_trait_ref.path.span,\n                                     &format!(\"`{}` trait not defined in this crate\",\n                                              item_trait_ref.path))\n@@ -365,7 +380,7 @@ impl<'cx, 'tcx> OrphanChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OrphanChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         self.check_item(item);\n     }"}, {"sha": "1bf140c21a5a5b0f99756d38dd4837e73b99d620", "filename": "src/librustc_typeck/coherence/overlap.rs", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/a33b921c0db989368fbe9f9ff428a2e014439032/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b921c0db989368fbe9f9ff428a2e014439032/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Foverlap.rs?ref=a33b921c0db989368fbe9f9ff428a2e014439032", "patch": "@@ -23,15 +23,17 @@ use util::nodemap::DefIdMap;\n use lint;\n \n pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n-    let mut overlap = OverlapChecker { tcx: tcx,\n-                                       default_impls: DefIdMap() };\n+    let mut overlap = OverlapChecker {\n+        tcx: tcx,\n+        default_impls: DefIdMap(),\n+    };\n \n     // this secondary walk specifically checks for some other cases,\n     // like defaulted traits, for which additional overlap rules exist\n     tcx.visit_all_items_in_krate(DepNode::CoherenceOverlapCheckSpecial, &mut overlap);\n }\n \n-struct OverlapChecker<'cx, 'tcx:'cx> {\n+struct OverlapChecker<'cx, 'tcx: 'cx> {\n     tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n \n     // maps from a trait def-id to an impl id\n@@ -41,18 +43,21 @@ struct OverlapChecker<'cx, 'tcx:'cx> {\n impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     fn check_for_common_items_in_impls(&self, impl1: DefId, impl2: DefId) {\n         #[derive(Copy, Clone, PartialEq)]\n-        enum Namespace { Type, Value }\n+        enum Namespace {\n+            Type,\n+            Value,\n+        }\n \n         fn name_and_namespace<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                                         def_id: DefId)\n-                                        -> (ast::Name, Namespace)\n-        {\n+                                        -> (ast::Name, Namespace) {\n             let item = tcx.impl_or_trait_item(def_id);\n-            (item.name(), match item {\n-                ty::TypeTraitItem(..) => Namespace::Type,\n-                ty::ConstTraitItem(..) => Namespace::Value,\n-                ty::MethodTraitItem(..) => Namespace::Value,\n-            })\n+            (item.name(),\n+             match item {\n+                 ty::TypeTraitItem(..) => Namespace::Type,\n+                 ty::ConstTraitItem(..) => Namespace::Value,\n+                 ty::MethodTraitItem(..) => Namespace::Value,\n+             })\n         }\n \n         let impl_items = self.tcx.impl_or_trait_item_def_ids.borrow();\n@@ -79,11 +84,11 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n         let inherent_impls = self.tcx.inherent_impls.borrow();\n         let impls = match inherent_impls.get(&ty_def_id) {\n             Some(impls) => impls,\n-            None => return\n+            None => return,\n         };\n \n         for (i, &impl1_def_id) in impls.iter().enumerate() {\n-            for &impl2_def_id in &impls[(i+1)..] {\n+            for &impl2_def_id in &impls[(i + 1)..] {\n                 self.tcx.infer_ctxt(None, None, Reveal::ExactMatch).enter(|infcx| {\n                     if traits::overlapping_impls(&infcx, impl1_def_id, impl2_def_id).is_some() {\n                         self.check_for_common_items_in_impls(impl1_def_id, impl2_def_id)\n@@ -94,10 +99,12 @@ impl<'cx, 'tcx> OverlapChecker<'cx, 'tcx> {\n     }\n }\n \n-impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n-            hir::ItemEnum(..) | hir::ItemStruct(..) | hir::ItemUnion(..) => {\n+            hir::ItemEnum(..) |\n+            hir::ItemStruct(..) |\n+            hir::ItemUnion(..) => {\n                 let type_def_id = self.tcx.map.local_def_id(item.id);\n                 self.check_for_overlapping_inherent_impls(type_def_id);\n             }\n@@ -111,12 +118,14 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n \n                 let prev_default_impl = self.default_impls.insert(trait_ref.def_id, item.id);\n                 if let Some(prev_id) = prev_default_impl {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess,\n-                        self.tcx.span_of_impl(impl_def_id).unwrap(), E0521,\n-                        \"redundant default implementations of trait `{}`:\",\n-                        trait_ref);\n-                    err.span_note(self.tcx.span_of_impl(self.tcx.map.local_def_id(prev_id))\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   self.tcx.span_of_impl(impl_def_id).unwrap(),\n+                                                   E0521,\n+                                                   \"redundant default implementations of trait \\\n+                                                    `{}`:\",\n+                                                   trait_ref);\n+                    err.span_note(self.tcx\n+                                      .span_of_impl(self.tcx.map.local_def_id(prev_id))\n                                       .unwrap(),\n                                   \"redundant implementation is here:\");\n                     err.emit();\n@@ -127,8 +136,8 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                 let trait_ref = self.tcx.impl_trait_ref(impl_def_id).unwrap();\n                 let trait_def_id = trait_ref.def_id;\n \n-                let _task = self.tcx.dep_graph.in_task(\n-                    DepNode::CoherenceOverlapCheck(trait_def_id));\n+                let _task =\n+                    self.tcx.dep_graph.in_task(DepNode::CoherenceOverlapCheck(trait_def_id));\n \n                 let def = self.tcx.lookup_trait_def(trait_def_id);\n \n@@ -137,26 +146,27 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n \n                 // insertion failed due to overlap\n                 if let Err(overlap) = insert_result {\n-                    let mut err = struct_span_err!(\n-                        self.tcx.sess, self.tcx.span_of_impl(impl_def_id).unwrap(), E0119,\n-                        \"conflicting implementations of trait `{}`{}:\",\n-                        overlap.trait_desc,\n-                        overlap.self_desc.clone().map_or(String::new(),\n-                                                         |ty| format!(\" for type `{}`\", ty)));\n+                    let mut err = struct_span_err!(self.tcx.sess,\n+                                                   self.tcx.span_of_impl(impl_def_id).unwrap(),\n+                                                   E0119,\n+                                                   \"conflicting implementations of trait `{}`{}:\",\n+                                                   overlap.trait_desc,\n+                                                   overlap.self_desc.clone().map_or(String::new(),\n+                                                                                    |ty| {\n+                        format!(\" for type `{}`\", ty)\n+                    }));\n \n                     match self.tcx.span_of_impl(overlap.with_impl) {\n                         Ok(span) => {\n-                            err.span_label(span,\n-                                           &format!(\"first implementation here\"));\n+                            err.span_label(span, &format!(\"first implementation here\"));\n                             err.span_label(self.tcx.span_of_impl(impl_def_id).unwrap(),\n                                            &format!(\"conflicting implementation{}\",\n                                                     overlap.self_desc\n                                                         .map_or(String::new(),\n                                                                 |ty| format!(\" for `{}`\", ty))));\n                         }\n                         Err(cname) => {\n-                            err.note(&format!(\"conflicting implementation in crate `{}`\",\n-                                              cname));\n+                            err.note(&format!(\"conflicting implementation in crate `{}`\", cname));\n                         }\n                     }\n \n@@ -177,7 +187,9 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for OverlapChecker<'cx, 'tcx> {\n                         let mut supertrait_def_ids =\n                             traits::supertrait_def_ids(self.tcx, data.principal.def_id());\n                         if supertrait_def_ids.any(|d| d == trait_def_id) {\n-                            span_err!(self.tcx.sess, item.span, E0371,\n+                            span_err!(self.tcx.sess,\n+                                      item.span,\n+                                      E0371,\n                                       \"the object type `{}` automatically \\\n                                        implements the trait `{}`\",\n                                       trait_ref.self_ty(),"}, {"sha": "ff55ce0e5eb55cea69b75aa270a9a04ea14e7e66", "filename": "src/librustc_typeck/coherence/unsafety.rs", "status": "modified", "additions": 26, "deletions": 19, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/a33b921c0db989368fbe9f9ff428a2e014439032/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a33b921c0db989368fbe9f9ff428a2e014439032/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Funsafety.rs?ref=a33b921c0db989368fbe9f9ff428a2e014439032", "patch": "@@ -20,21 +20,26 @@ pub fn check<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>) {\n     tcx.map.krate().visit_all_items(&mut orphan);\n }\n \n-struct UnsafetyChecker<'cx, 'tcx:'cx> {\n-    tcx: TyCtxt<'cx, 'tcx, 'tcx>\n+struct UnsafetyChecker<'cx, 'tcx: 'cx> {\n+    tcx: TyCtxt<'cx, 'tcx, 'tcx>,\n }\n \n impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n-    fn check_unsafety_coherence(&mut self, item: &'v hir::Item,\n+    fn check_unsafety_coherence(&mut self,\n+                                item: &'v hir::Item,\n                                 unsafety: hir::Unsafety,\n                                 polarity: hir::ImplPolarity) {\n         match self.tcx.impl_trait_ref(self.tcx.map.local_def_id(item.id)) {\n             None => {\n                 // Inherent impl.\n                 match unsafety {\n-                    hir::Unsafety::Normal => { /* OK */ }\n+                    hir::Unsafety::Normal => {\n+                        // OK\n+                    }\n                     hir::Unsafety::Unsafe => {\n-                        span_err!(self.tcx.sess, item.span, E0197,\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0197,\n                                   \"inherent impls cannot be declared as unsafe\");\n                     }\n                 }\n@@ -43,39 +48,41 @@ impl<'cx, 'tcx, 'v> UnsafetyChecker<'cx, 'tcx> {\n             Some(trait_ref) => {\n                 let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id);\n                 match (trait_def.unsafety, unsafety, polarity) {\n-                    (hir::Unsafety::Unsafe,\n-                     hir::Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n-                        span_err!(self.tcx.sess, item.span, E0198,\n+                    (hir::Unsafety::Unsafe, hir::Unsafety::Unsafe, hir::ImplPolarity::Negative) => {\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0198,\n                                   \"negative implementations are not unsafe\");\n                     }\n \n                     (hir::Unsafety::Normal, hir::Unsafety::Unsafe, _) => {\n-                        span_err!(self.tcx.sess, item.span, E0199,\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0199,\n                                   \"implementing the trait `{}` is not unsafe\",\n                                   trait_ref);\n                     }\n \n-                    (hir::Unsafety::Unsafe,\n-                     hir::Unsafety::Normal, hir::ImplPolarity::Positive) => {\n-                        span_err!(self.tcx.sess, item.span, E0200,\n+                    (hir::Unsafety::Unsafe, hir::Unsafety::Normal, hir::ImplPolarity::Positive) => {\n+                        span_err!(self.tcx.sess,\n+                                  item.span,\n+                                  E0200,\n                                   \"the trait `{}` requires an `unsafe impl` declaration\",\n                                   trait_ref);\n                     }\n \n-                    (hir::Unsafety::Unsafe,\n-                     hir::Unsafety::Normal, hir::ImplPolarity::Negative) |\n-                    (hir::Unsafety::Unsafe,\n-                     hir::Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n+                    (hir::Unsafety::Unsafe, hir::Unsafety::Normal, hir::ImplPolarity::Negative) |\n+                    (hir::Unsafety::Unsafe, hir::Unsafety::Unsafe, hir::ImplPolarity::Positive) |\n                     (hir::Unsafety::Normal, hir::Unsafety::Normal, _) => {\n-                        /* OK */\n+                        // OK\n                     }\n                 }\n             }\n         }\n     }\n }\n \n-impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n+impl<'cx, 'tcx, 'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n     fn visit_item(&mut self, item: &'v hir::Item) {\n         match item.node {\n             hir::ItemDefaultImpl(unsafety, _) => {\n@@ -84,7 +91,7 @@ impl<'cx, 'tcx,'v> intravisit::Visitor<'v> for UnsafetyChecker<'cx, 'tcx> {\n             hir::ItemImpl(unsafety, polarity, ..) => {\n                 self.check_unsafety_coherence(item, unsafety, polarity);\n             }\n-            _ => { }\n+            _ => {}\n         }\n     }\n }"}]}