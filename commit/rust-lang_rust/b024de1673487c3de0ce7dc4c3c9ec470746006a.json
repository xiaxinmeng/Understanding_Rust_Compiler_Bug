{"sha": "b024de1673487c3de0ce7dc4c3c9ec470746006a", "node_id": "C_kwDOAAsO6NoAKGIwMjRkZTE2NzM0ODdjM2RlMGNlN2RjNGMzYzllYzQ3MDc0NjAwNmE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-16T14:55:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-16T14:55:28Z"}, "message": "Auto merge of #2785 - Vanille-N:tree-borrows-merge, r=RalfJung\n\nTree borrows\n\nThis PR implements the experimental Tree Borrows (TB) rules for tracking reference aliasing, as an optional alternative to Stacked Borrows (SB).\n\nSB and TB are mutually exclusive. Using `-Zmiri-tree-borrows` replaces every invocation of SB with the equivalent TB procedure.\n\nA detailed explanation of the TB rules is currently under review, you can find the latest version [here [work in progress]](https://github.com/Vanille-N/tree-borrows/blob/master/model/treebor.pdf).\n\nThis PR does NOT yet include\n- enough `fail` tests for TB (although TB is less reliant than SB on `fail` tests to check that the implementation matches the design due to `pass` tests being more strict)\n- good diagnostics for TB violations", "tree": {"sha": "2335d716322806be92d52eeade9da6a51bfe7900", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2335d716322806be92d52eeade9da6a51bfe7900"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b024de1673487c3de0ce7dc4c3c9ec470746006a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b024de1673487c3de0ce7dc4c3c9ec470746006a", "html_url": "https://github.com/rust-lang/rust/commit/b024de1673487c3de0ce7dc4c3c9ec470746006a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b024de1673487c3de0ce7dc4c3c9ec470746006a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ad2fece144996fb3591dc3250b9fc6b49288a91", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ad2fece144996fb3591dc3250b9fc6b49288a91", "html_url": "https://github.com/rust-lang/rust/commit/3ad2fece144996fb3591dc3250b9fc6b49288a91"}, {"sha": "782b8692245b392613379f9957c321e47f670b8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/782b8692245b392613379f9957c321e47f670b8e", "html_url": "https://github.com/rust-lang/rust/commit/782b8692245b392613379f9957c321e47f670b8e"}], "stats": {"total": 3781, "additions": 3641, "deletions": 140}, "files": [{"sha": "b70f7e0e55634a2bb892a3b970956a50e2f2ff5e", "filename": "src/tools/miri/README.md", "status": "modified", "additions": 13, "deletions": 118, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2FREADME.md?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -15,6 +15,8 @@ for example:\n   or an invalid enum discriminant)\n * **Experimental**: Violations of the [Stacked Borrows] rules governing aliasing\n   for reference types\n+* **Experimental**: Violations of the Tree Borrows aliasing rules, as an optional\n+  alternative to [Stacked Borrows]\n * **Experimental**: Data races\n \n On top of that, Miri will also tell you about memory leaks: when there is memory\n@@ -357,9 +359,11 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-disable-data-race-detector` disables checking for data races.  Using\n   this flag is **unsound**. This implies `-Zmiri-disable-weak-memory-emulation`.\n * `-Zmiri-disable-stacked-borrows` disables checking the experimental\n-  [Stacked Borrows] aliasing rules.  This can make Miri run faster, but it also\n-  means no aliasing violations will be detected.  Using this flag is **unsound**\n-  (but the affected soundness rules are experimental).\n+  aliasing rules to track borrows ([Stacked Borrows] and Tree Borrows).\n+  This can make Miri run faster, but it also means no aliasing violations will\n+  be detected. Using this flag is **unsound** (but the affected soundness rules\n+  are experimental). Later flags take precedence: borrow tracking can be reactivated\n+  by `-Zmiri-tree-borrows`.\n * `-Zmiri-disable-validation` disables enforcing validity invariants, which are\n   enforced by default.  This is mostly useful to focus on other failures (such\n   as out-of-bounds accesses) first.  Setting this flag means Miri can miss bugs\n@@ -421,6 +425,9 @@ to Miri failing to detect cases of undefined behavior in a program.\n * `-Zmiri-track-weak-memory-loads` shows a backtrace when weak memory emulation returns an outdated\n   value from a load. This can help diagnose problems that disappear under\n   `-Zmiri-disable-weak-memory-emulation`.\n+* `-Zmiri-tree-borrows` replaces [Stacked Borrows] with the Tree Borrows rules.\n+  The soundness rules are already experimental without this flag, but even more\n+  so with this flag.\n * `-Zmiri-force-page-size=<num>` overrides the default page size for an architecture, in multiples of 1k.\n   `4` is default for most targets. This value should always be a power of 2 and nonzero.\n \n@@ -435,7 +442,7 @@ Some native rustc `-Z` flags are also very relevant for Miri:\n   functions.  This is needed so that Miri can execute such functions, so Miri\n   sets this flag per default.\n * `-Zmir-emit-retag` controls whether `Retag` statements are emitted. Miri\n-  enables this per default because it is needed for [Stacked Borrows].\n+  enables this per default because it is needed for [Stacked Borrows] and Tree Borrows.\n \n Moreover, Miri recognizes some environment variables:\n \n@@ -501,120 +508,8 @@ binaries, and as such worth documenting:\n ## Miri `extern` functions\n \n Miri provides some `extern` functions that programs can import to access\n-Miri-specific functionality:\n-\n-```rust\n-#[cfg(miri)]\n-extern \"Rust\" {\n-    /// Miri-provided extern function to mark the block `ptr` points to as a \"root\"\n-    /// for some static memory. This memory and everything reachable by it is not\n-    /// considered leaking even if it still exists when the program terminates.\n-    ///\n-    /// `ptr` has to point to the beginning of an allocated block.\n-    fn miri_static_root(ptr: *const u8);\n-\n-    // Miri-provided extern function to get the amount of frames in the current backtrace.\n-    // The `flags` argument must be `0`.\n-    fn miri_backtrace_size(flags: u64) -> usize;\n-\n-    /// Miri-provided extern function to obtain a backtrace of the current call stack.\n-    /// This writes a slice of pointers into `buf` - each pointer is an opaque value\n-    /// that is only useful when passed to `miri_resolve_frame`.\n-    /// `buf` must have `miri_backtrace_size(0) * pointer_size` bytes of space.\n-    /// The `flags` argument must be `1`.\n-    fn miri_get_backtrace(flags: u64, buf: *mut *mut ());\n-\n-    /// Miri-provided extern function to resolve a frame pointer obtained\n-    /// from `miri_get_backtrace`. The `flags` argument must be `1`,\n-    /// and `MiriFrame` should be declared as follows:\n-    ///\n-    /// ```rust\n-    /// #[repr(C)]\n-    /// struct MiriFrame {\n-    ///     // The size of the name of the function being executed, encoded in UTF-8\n-    ///     name_len: usize,\n-    ///     // The size of filename of the function being executed, encoded in UTF-8\n-    ///     filename_len: usize,\n-    ///     // The line number currently being executed in `filename`, starting from '1'.\n-    ///     lineno: u32,\n-    ///     // The column number currently being executed in `filename`, starting from '1'.\n-    ///     colno: u32,\n-    ///     // The function pointer to the function currently being executed.\n-    ///     // This can be compared against function pointers obtained by\n-    ///     // casting a function (e.g. `my_fn as *mut ()`)\n-    ///     fn_ptr: *mut ()\n-    /// }\n-    /// ```\n-    ///\n-    /// The fields must be declared in exactly the same order as they appear in `MiriFrame` above.\n-    /// This function can be called on any thread (not just the one which obtained `frame`).\n-    fn miri_resolve_frame(frame: *mut (), flags: u64) -> MiriFrame;\n-\n-    /// Miri-provided extern function to get the name and filename of the frame provided by `miri_resolve_frame`.\n-    /// `name_buf` and `filename_buf` should be allocated with the `name_len` and `filename_len` fields of `MiriFrame`.\n-    /// The flags argument must be `0`.\n-    fn miri_resolve_frame_names(ptr: *mut (), flags: u64, name_buf: *mut u8, filename_buf: *mut u8);\n-\n-    /// Miri-provided extern function to begin unwinding with the given payload.\n-    ///\n-    /// This is internal and unstable and should not be used; we give it here\n-    /// just to be complete.\n-    fn miri_start_panic(payload: *mut u8) -> !;\n-\n-    /// Miri-provided extern function to get the internal unique identifier for the allocation that a pointer\n-    /// points to. If this pointer is invalid (not pointing to an allocation), interpretation will abort.\n-    ///\n-    /// This is only useful as an input to `miri_print_borrow_stacks`, and it is a separate call because\n-    /// getting a pointer to an allocation at runtime can change the borrow stacks in the allocation.\n-    /// This function should be considered unstable. It exists only to support `miri_print_borrow_stacks` and so\n-    /// inherits all of its instability.\n-    fn miri_get_alloc_id(ptr: *const ()) -> u64;\n-\n-    /// Miri-provided extern function to print (from the interpreter, not the program) the contents of all\n-    /// borrow stacks in an allocation. The leftmost tag is the bottom of the stack.\n-    /// The format of what this emits is unstable and may change at any time. In particular, users should be\n-    /// aware that Miri will periodically attempt to garbage collect the contents of all stacks. Callers of\n-    /// this function may wish to pass `-Zmiri-tag-gc=0` to disable the GC.\n-    ///\n-    /// This function is extremely unstable. At any time the format of its output may change, its signature may\n-    /// change, or it may be removed entirely.\n-    fn miri_print_borrow_stacks(alloc_id: u64);\n-\n-    /// Miri-provided extern function to print (from the interpreter, not the\n-    /// program) the contents of a section of program memory, as bytes. Bytes\n-    /// written using this function will emerge from the interpreter's stdout.\n-    fn miri_write_to_stdout(bytes: &[u8]);\n-\n-    /// Miri-provided extern function to print (from the interpreter, not the\n-    /// program) the contents of a section of program memory, as bytes. Bytes\n-    /// written using this function will emerge from the interpreter's stderr.\n-    fn miri_write_to_stderr(bytes: &[u8]);\n-\n-    /// Miri-provided extern function to allocate memory from the interpreter.\n-    /// \n-    /// This is useful when no fundamental way of allocating memory is\n-    /// available, e.g. when using `no_std` + `alloc`.\n-    fn miri_alloc(size: usize, align: usize) -> *mut u8;\n-\n-    /// Miri-provided extern function to deallocate memory.\n-    fn miri_dealloc(ptr: *mut u8, size: usize, align: usize);\n-\n-    /// Convert a path from the host Miri runs on to the target Miri interprets.\n-    /// Performs conversion of path separators as needed.\n-    ///\n-    /// Usually Miri performs this kind of conversion automatically. However, manual conversion\n-    /// might be necessary when reading an environment variable that was set on the host\n-    /// (such as TMPDIR) and using it as a target path.\n-    ///\n-    /// Only works with isolation disabled.\n-    ///\n-    /// `in` must point to a null-terminated string, and will be read as the input host path.\n-    /// `out` must point to at least `out_size` many bytes, and the result will be stored there\n-    /// with a null terminator.\n-    /// Returns 0 if the `out` buffer was large enough, and the required size otherwise.\n-    fn miri_host_to_target_path(path: *const std::ffi::c_char, out: *mut std::ffi::c_char, out_size: usize) -> usize;\n-}\n-```\n+Miri-specific functionality. They are declared in\n+[/tests/utils/miri\\_extern.rs](/tests/utils/miri_extern.rs).\n \n ## Contributing and getting help\n "}, {"sha": "6fe3fa7fb1b6a094fbbda30fe44e02e25e9e8a9a", "filename": "src/tools/miri/src/bin/miri.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fbin%2Fmiri.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -32,7 +32,7 @@ use rustc_middle::{\n };\n use rustc_session::{config::CrateType, search_paths::PathKind, CtfeBacktrace};\n \n-use miri::{BacktraceStyle, ProvenanceMode, RetagFields};\n+use miri::{BacktraceStyle, BorrowTrackerMethod, ProvenanceMode, RetagFields};\n \n struct MiriCompilerCalls {\n     miri_config: miri::MiriConfig,\n@@ -317,6 +317,8 @@ fn main() {\n             miri_config.validate = false;\n         } else if arg == \"-Zmiri-disable-stacked-borrows\" {\n             miri_config.borrow_tracker = None;\n+        } else if arg == \"-Zmiri-tree-borrows\" {\n+            miri_config.borrow_tracker = Some(BorrowTrackerMethod::TreeBorrows);\n         } else if arg == \"-Zmiri-disable-data-race-detector\" {\n             miri_config.data_race_detector = false;\n             miri_config.weak_memory_emulation = false;"}, {"sha": "ed958329f9514f19dc3793759910ff91a6fada1c", "filename": "src/tools/miri/src/borrow_tracker/mod.rs", "status": "modified", "additions": 69, "deletions": 1, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Fmod.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -11,6 +11,7 @@ use rustc_target::abi::Size;\n \n use crate::*;\n pub mod stacked_borrows;\n+pub mod tree_borrows;\n \n pub type CallId = NonZeroU64;\n \n@@ -230,8 +231,10 @@ impl GlobalStateInner {\n /// Which borrow tracking method to use\n #[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum BorrowTrackerMethod {\n-    /// Stacked Borrows, as implemented in borrow_tracker/stacked\n+    /// Stacked Borrows, as implemented in borrow_tracker/stacked_borrows\n     StackedBorrows,\n+    /// Tree borrows, as implemented in borrow_tracker/tree_borrows\n+    TreeBorrows,\n }\n \n impl BorrowTrackerMethod {\n@@ -258,6 +261,10 @@ impl GlobalStateInner {\n                 AllocState::StackedBorrows(Box::new(RefCell::new(Stacks::new_allocation(\n                     id, alloc_size, self, kind, machine,\n                 )))),\n+            BorrowTrackerMethod::TreeBorrows =>\n+                AllocState::TreeBorrows(Box::new(RefCell::new(Tree::new_allocation(\n+                    id, alloc_size, self, kind, machine,\n+                )))),\n         }\n     }\n }\n@@ -273,6 +280,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_retag_ptr_value(kind, val),\n+            BorrowTrackerMethod::TreeBorrows => this.tb_retag_ptr_value(kind, val),\n         }\n     }\n \n@@ -285,6 +293,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_retag_place_contents(kind, place),\n+            BorrowTrackerMethod::TreeBorrows => this.tb_retag_place_contents(kind, place),\n         }\n     }\n \n@@ -293,6 +302,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_retag_return_place(),\n+            BorrowTrackerMethod::TreeBorrows => this.tb_retag_return_place(),\n         }\n     }\n \n@@ -301,6 +311,34 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n         match method {\n             BorrowTrackerMethod::StackedBorrows => this.sb_expose_tag(alloc_id, tag),\n+            BorrowTrackerMethod::TreeBorrows => this.tb_expose_tag(alloc_id, tag),\n+        }\n+    }\n+\n+    fn give_pointer_debug_name(\n+        &mut self,\n+        ptr: Pointer<Option<Provenance>>,\n+        nth_parent: u8,\n+        name: &str,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => {\n+                this.tcx.tcx.sess.warn(\"Stacked Borrows does not support named pointers; `miri_pointer_name` is a no-op\");\n+                Ok(())\n+            }\n+            BorrowTrackerMethod::TreeBorrows =>\n+                this.tb_give_pointer_debug_name(ptr, nth_parent, name),\n+        }\n+    }\n+\n+    fn print_borrow_state(&mut self, alloc_id: AllocId, show_unnamed: bool) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let method = this.machine.borrow_tracker.as_ref().unwrap().borrow().borrow_tracker_method;\n+        match method {\n+            BorrowTrackerMethod::StackedBorrows => this.print_stacks(alloc_id),\n+            BorrowTrackerMethod::TreeBorrows => this.print_tree(alloc_id, show_unnamed),\n         }\n     }\n }\n@@ -310,6 +348,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n pub enum AllocState {\n     /// Data corresponding to Stacked Borrows\n     StackedBorrows(Box<RefCell<stacked_borrows::AllocState>>),\n+    /// Data corresponding to Tree Borrows\n+    TreeBorrows(Box<RefCell<tree_borrows::AllocState>>),\n }\n \n impl machine::AllocExtra {\n@@ -328,6 +368,14 @@ impl machine::AllocExtra {\n             _ => panic!(\"expected Stacked Borrows borrow tracking, got something else\"),\n         }\n     }\n+\n+    #[track_caller]\n+    pub fn borrow_tracker_tb(&self) -> &RefCell<tree_borrows::AllocState> {\n+        match self.borrow_tracker {\n+            Some(AllocState::TreeBorrows(ref tb)) => tb,\n+            _ => panic!(\"expected Tree Borrows borrow tracking, got something else\"),\n+        }\n+    }\n }\n \n impl AllocState {\n@@ -341,6 +389,14 @@ impl AllocState {\n         match self {\n             AllocState::StackedBorrows(sb) =>\n                 sb.borrow_mut().before_memory_read(alloc_id, prov_extra, range, machine),\n+            AllocState::TreeBorrows(tb) =>\n+                tb.borrow_mut().before_memory_access(\n+                    AccessKind::Read,\n+                    alloc_id,\n+                    prov_extra,\n+                    range,\n+                    machine,\n+                ),\n         }\n     }\n \n@@ -354,6 +410,14 @@ impl AllocState {\n         match self {\n             AllocState::StackedBorrows(sb) =>\n                 sb.get_mut().before_memory_write(alloc_id, prov_extra, range, machine),\n+            AllocState::TreeBorrows(tb) =>\n+                tb.get_mut().before_memory_access(\n+                    AccessKind::Write,\n+                    alloc_id,\n+                    prov_extra,\n+                    range,\n+                    machine,\n+                ),\n         }\n     }\n \n@@ -367,12 +431,15 @@ impl AllocState {\n         match self {\n             AllocState::StackedBorrows(sb) =>\n                 sb.get_mut().before_memory_deallocation(alloc_id, prov_extra, range, machine),\n+            AllocState::TreeBorrows(tb) =>\n+                tb.get_mut().before_memory_deallocation(alloc_id, prov_extra, range, machine),\n         }\n     }\n \n     pub fn remove_unreachable_tags(&self, tags: &FxHashSet<BorTag>) {\n         match self {\n             AllocState::StackedBorrows(sb) => sb.borrow_mut().remove_unreachable_tags(tags),\n+            AllocState::TreeBorrows(tb) => tb.borrow_mut().remove_unreachable_tags(tags),\n         }\n     }\n }\n@@ -381,6 +448,7 @@ impl VisitTags for AllocState {\n     fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n         match self {\n             AllocState::StackedBorrows(sb) => sb.visit_tags(visit),\n+            AllocState::TreeBorrows(tb) => tb.visit_tags(visit),\n         }\n     }\n }"}, {"sha": "97bbdee1d4424b50762a51128b12bfa4a9fd5574", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/diagnostics.rs", "status": "added", "additions": 592, "deletions": 0, "changes": 592, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fdiagnostics.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,592 @@\n+use rustc_data_structures::fx::FxHashMap;\n+\n+use std::fmt;\n+use std::ops::Range;\n+\n+use crate::borrow_tracker::tree_borrows::{\n+    err_tb_ub, perms::Permission, tree::LocationState, unimap::UniIndex,\n+};\n+use crate::borrow_tracker::{AccessKind, ProtectorKind};\n+use crate::*;\n+\n+/// Some information that is irrelevant for the algorithm but very\n+/// convenient to know about a tag for debugging and testing.\n+#[derive(Clone, Debug)]\n+pub struct NodeDebugInfo {\n+    /// The tag in question.\n+    pub tag: BorTag,\n+    /// Name(s) that were associated with this tag (comma-separated).\n+    /// Typically the name of the variable holding the corresponding\n+    /// pointer in the source code.\n+    /// Helps match tag numbers to human-readable names.\n+    pub name: Option<String>,\n+}\n+impl NodeDebugInfo {\n+    /// New node info with a name.\n+    pub fn new(tag: BorTag) -> Self {\n+        Self { tag, name: None }\n+    }\n+\n+    /// Add a name to the tag. If a same tag is associated to several pointers,\n+    /// it can have several names which will be separated by commas.\n+    fn add_name(&mut self, name: &str) {\n+        if let Some(ref mut prev_name) = &mut self.name {\n+            prev_name.push(',');\n+            prev_name.push_str(name);\n+        } else {\n+            self.name = Some(String::from(name));\n+        }\n+    }\n+}\n+\n+impl fmt::Display for NodeDebugInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        if let Some(ref name) = self.name {\n+            write!(f, \"{tag:?} (also named '{name}')\", tag = self.tag)\n+        } else {\n+            write!(f, \"{tag:?}\", tag = self.tag)\n+        }\n+    }\n+}\n+\n+impl<'tcx> Tree {\n+    /// Climb the tree to get the tag of a distant ancestor.\n+    /// Allows operations on tags that are unreachable by the program\n+    /// but still exist in the tree. Not guaranteed to perform consistently\n+    /// if `tag-gc=1`.\n+    fn nth_parent(&self, tag: BorTag, nth_parent: u8) -> Option<BorTag> {\n+        let mut idx = self.tag_mapping.get(&tag).unwrap();\n+        for _ in 0..nth_parent {\n+            let node = self.nodes.get(idx).unwrap();\n+            idx = node.parent?;\n+        }\n+        Some(self.nodes.get(idx).unwrap().tag)\n+    }\n+\n+    /// Debug helper: assign name to tag.\n+    pub fn give_pointer_debug_name(\n+        &mut self,\n+        tag: BorTag,\n+        nth_parent: u8,\n+        name: &str,\n+    ) -> InterpResult<'tcx> {\n+        let tag = self.nth_parent(tag, nth_parent).unwrap();\n+        let idx = self.tag_mapping.get(&tag).unwrap();\n+        if let Some(node) = self.nodes.get_mut(idx) {\n+            node.debug_info.add_name(name);\n+        } else {\n+            eprintln!(\"Tag {tag:?} (to be named '{name}') not found!\");\n+        }\n+        Ok(())\n+    }\n+\n+    /// Debug helper: determines if the tree contains a tag.\n+    pub fn is_allocation_of(&self, tag: BorTag) -> bool {\n+        self.tag_mapping.contains_key(&tag)\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy)]\n+pub(super) enum TransitionError {\n+    /// This access is not allowed because some parent tag has insufficient permissions.\n+    /// For example, if a tag is `Frozen` and encounters a child write this will\n+    /// produce a `ChildAccessForbidden(Frozen)`.\n+    /// This kind of error can only occur on child accesses.\n+    ChildAccessForbidden(Permission),\n+    /// A protector was triggered due to an invalid transition that loses\n+    /// too much permissions.\n+    /// For example, if a protected tag goes from `Active` to `Frozen` due\n+    /// to a foreign write this will produce a `ProtectedTransition(Active, Frozen)`.\n+    /// This kind of error can only occur on foreign accesses.\n+    ProtectedTransition(Permission, Permission),\n+    /// Cannot deallocate because some tag in the allocation is strongly protected.\n+    /// This kind of error can only occur on deallocations.\n+    ProtectedDealloc,\n+}\n+\n+/// Failures that can occur during the execution of Tree Borrows procedures.\n+pub(super) struct TbError<'node> {\n+    /// What failure occurred.\n+    pub error_kind: TransitionError,\n+    /// The tag on which the error was triggered.\n+    /// On protector violations, this is the tag that was protected.\n+    /// On accesses rejected due to insufficient permissions, this is the\n+    /// tag that lacked those permissions.\n+    pub faulty_tag: &'node NodeDebugInfo,\n+    /// Whether this was a Read or Write access. This field is ignored\n+    /// when the error was triggered by a deallocation.\n+    pub access_kind: AccessKind,\n+    /// Which tag the access that caused this error was made through, i.e.\n+    /// which tag was used to read/write/deallocate.\n+    pub tag_of_access: &'node NodeDebugInfo,\n+}\n+\n+impl TbError<'_> {\n+    /// Produce a UB error.\n+    pub fn build<'tcx>(self) -> InterpErrorInfo<'tcx> {\n+        use TransitionError::*;\n+        err_tb_ub(match self.error_kind {\n+            ChildAccessForbidden(perm) => {\n+                format!(\n+                    \"{kind} through {initial} is forbidden because it is a child of {current} which is {perm}.\",\n+                    kind=self.access_kind,\n+                    initial=self.tag_of_access,\n+                    current=self.faulty_tag,\n+                    perm=perm,\n+                )\n+            }\n+            ProtectedTransition(start, end) => {\n+                format!(\n+                    \"{kind} through {initial} is forbidden because it is a foreign tag for {current}, which would hence change from {start} to {end}, but {current} is protected\",\n+                    current=self.faulty_tag,\n+                    start=start,\n+                    end=end,\n+                    kind=self.access_kind,\n+                    initial=self.tag_of_access,\n+                )\n+            }\n+            ProtectedDealloc => {\n+                format!(\n+                    \"the allocation of {initial} also contains {current} which is strongly protected, cannot deallocate\",\n+                    initial=self.tag_of_access,\n+                    current=self.faulty_tag,\n+                )\n+            }\n+        }).into()\n+    }\n+}\n+\n+type S = &'static str;\n+/// Pretty-printing details\n+///\n+/// Example:\n+/// ```\n+/// DisplayFmtWrapper {\n+///     top: '>',\n+///     bot: '<',\n+///     warning_text: \"Some tags have been hidden\",\n+/// }\n+/// ```\n+/// will wrap the entire text with\n+/// ```text\n+/// >>>>>>>>>>>>>>>>>>>>>>>>>>\n+/// Some tags have been hidden\n+///\n+/// [ main display here ]\n+///\n+/// <<<<<<<<<<<<<<<<<<<<<<<<<<\n+/// ```\n+struct DisplayFmtWrapper {\n+    /// Character repeated to make the upper border.\n+    top: char,\n+    /// Character repeated to make the lower border.\n+    bot: char,\n+    /// Warning about some tags (unnamed) being hidden.\n+    warning_text: S,\n+}\n+\n+/// Formating of the permissions on each range.\n+///\n+/// Example:\n+/// ```\n+/// DisplayFmtPermission {\n+///     open: \"[\",\n+///     sep: \"|\",\n+///     close: \"]\",\n+///     uninit: \"___\",\n+///     range_sep: \"..\",\n+/// }\n+/// ```\n+/// will show each permission line as\n+/// ```text\n+/// 0.. 1.. 2.. 3.. 4.. 5\n+/// [Act|Res|Frz|Dis|___]\n+/// ```\n+struct DisplayFmtPermission {\n+    /// Text that starts the permission block.\n+    open: S,\n+    /// Text that separates permissions on different ranges.\n+    sep: S,\n+    /// Text that ends the permission block.\n+    close: S,\n+    /// Text to show when a permission is not initialized.\n+    /// Should have the same width as a `Permission`'s `.short_name()`, i.e.\n+    /// 3 if using the `Res/Act/Frz/Dis` notation.\n+    uninit: S,\n+    /// Text to separate the `start` and `end` values of a range.\n+    range_sep: S,\n+}\n+\n+/// Formating of the tree structure.\n+///\n+/// Example:\n+/// ```\n+/// DisplayFmtPadding {\n+///     join_middle: \"|-\",\n+///     join_last: \"'-\",\n+///     join_haschild: \"-+-\",\n+///     join_default: \"---\",\n+///     indent_middle: \"| \",\n+///     indent_last: \"  \",\n+/// }\n+/// ```\n+/// will show the tree as\n+/// ```text\n+/// -+- root\n+///  |--+- a\n+///  |  '--+- b\n+///  |     '---- c\n+///  |--+- d\n+///  |  '---- e\n+///  '---- f\n+/// ```\n+struct DisplayFmtPadding {\n+    /// Connector for a child other than the last.\n+    join_middle: S,\n+    /// Connector for the last child. Should have the same width as `join_middle`.\n+    join_last: S,\n+    /// Connector for a node that itself has a child.\n+    join_haschild: S,\n+    /// Connector for a node that does not have a child. Should have the same width\n+    /// as `join_haschild`.\n+    join_default: S,\n+    /// Indentation when there is a next child.\n+    indent_middle: S,\n+    /// Indentation for the last child.\n+    indent_last: S,\n+}\n+/// How to show whether a location has been accessed\n+///\n+/// Example:\n+/// ```\n+/// DisplayFmtAccess {\n+///     yes: \" \",\n+///     no: \"?\",\n+///     meh: \"_\",\n+/// }\n+/// ```\n+/// will show states as\n+/// ```text\n+///  Act\n+/// ?Res\n+/// ____\n+/// ```\n+struct DisplayFmtAccess {\n+    /// Used when `State.initialized = true`.\n+    yes: S,\n+    /// Used when `State.initialized = false`.\n+    /// Should have the same width as `yes`.\n+    no: S,\n+    /// Used when there is no `State`.\n+    /// Should have the same width as `yes`.\n+    meh: S,\n+}\n+\n+/// All parameters to determine how the tree is formated.\n+struct DisplayFmt {\n+    wrapper: DisplayFmtWrapper,\n+    perm: DisplayFmtPermission,\n+    padding: DisplayFmtPadding,\n+    accessed: DisplayFmtAccess,\n+}\n+impl DisplayFmt {\n+    /// Print the permission with the format\n+    /// ` Res`/` Re*`/` Act`/` Frz`/` Dis` for accessed locations\n+    /// and `?Res`/`?Re*`/`?Act`/`?Frz`/`?Dis` for unaccessed locations.\n+    fn print_perm(&self, perm: Option<LocationState>) -> String {\n+        if let Some(perm) = perm {\n+            format!(\n+                \"{ac}{st}\",\n+                ac = if perm.is_initialized() { self.accessed.yes } else { self.accessed.no },\n+                st = perm.permission().short_name(),\n+            )\n+        } else {\n+            format!(\"{}{}\", self.accessed.meh, self.perm.uninit)\n+        }\n+    }\n+\n+    /// Print the tag with the format `<XYZ>` if the tag is unnamed,\n+    /// and `<XYZ=name>` if the tag is named.\n+    fn print_tag(&self, tag: BorTag, name: &Option<String>) -> String {\n+        let printable_tag = tag.get();\n+        if let Some(name) = name {\n+            format!(\"<{printable_tag}={name}>\")\n+        } else {\n+            format!(\"<{printable_tag}>\")\n+        }\n+    }\n+\n+    /// Print extra text if the tag has a protector.\n+    fn print_protector(&self, protector: Option<&ProtectorKind>) -> &'static str {\n+        protector\n+            .map(|p| {\n+                match *p {\n+                    ProtectorKind::WeakProtector => \" Weakly protected\",\n+                    ProtectorKind::StrongProtector => \" Strongly protected\",\n+                }\n+            })\n+            .unwrap_or(\"\")\n+    }\n+}\n+\n+/// Track the indentation of the tree.\n+struct DisplayIndent {\n+    curr: String,\n+}\n+impl DisplayIndent {\n+    fn new() -> Self {\n+        Self { curr: \"    \".to_string() }\n+    }\n+\n+    /// Increment the indentation by one. Note: need to know if this\n+    /// is the last child or not because the presence of other children\n+    /// changes the way the indentation is shown.\n+    fn increment(&mut self, formatter: &DisplayFmt, is_last: bool) {\n+        self.curr.push_str(if is_last {\n+            formatter.padding.indent_last\n+        } else {\n+            formatter.padding.indent_middle\n+        });\n+    }\n+\n+    /// Pop the last level of indentation.\n+    fn decrement(&mut self, formatter: &DisplayFmt) {\n+        for _ in 0..formatter.padding.indent_last.len() {\n+            let _ = self.curr.pop();\n+        }\n+    }\n+\n+    /// Print the current indentation.\n+    fn write(&self, s: &mut String) {\n+        s.push_str(&self.curr);\n+    }\n+}\n+\n+/// Repeat a character a number of times.\n+fn char_repeat(c: char, n: usize) -> String {\n+    std::iter::once(c).cycle().take(n).collect::<String>()\n+}\n+\n+/// Extracted information from the tree, in a form that is readily accessible\n+/// for printing. I.e. resolve parent-child pointers into an actual tree,\n+/// zip permissions with their tag, remove wrappers, stringify data.\n+struct DisplayRepr {\n+    tag: BorTag,\n+    name: Option<String>,\n+    rperm: Vec<Option<LocationState>>,\n+    children: Vec<DisplayRepr>,\n+}\n+\n+impl DisplayRepr {\n+    fn from(tree: &Tree, show_unnamed: bool) -> Option<Self> {\n+        let mut v = Vec::new();\n+        extraction_aux(tree, tree.root, show_unnamed, &mut v);\n+        let Some(root) = v.pop() else {\n+            if show_unnamed {\n+                unreachable!(\"This allocation contains no tags, not even a root. This should not happen.\");\n+            }\n+            eprintln!(\"This allocation does not contain named tags. Use `miri_print_borrow_state(_, true)` to also print unnamed tags.\");\n+            return None;\n+        };\n+        assert!(v.is_empty());\n+        return Some(root);\n+\n+        fn extraction_aux(\n+            tree: &Tree,\n+            idx: UniIndex,\n+            show_unnamed: bool,\n+            acc: &mut Vec<DisplayRepr>,\n+        ) {\n+            let node = tree.nodes.get(idx).unwrap();\n+            let name = node.debug_info.name.clone();\n+            let children_sorted = {\n+                let mut children = node.children.iter().cloned().collect::<Vec<_>>();\n+                children.sort_by_key(|idx| tree.nodes.get(*idx).unwrap().tag);\n+                children\n+            };\n+            if !show_unnamed && name.is_none() {\n+                // We skip this node\n+                for child_idx in children_sorted {\n+                    extraction_aux(tree, child_idx, show_unnamed, acc);\n+                }\n+            } else {\n+                // We take this node\n+                let rperm = tree\n+                    .rperms\n+                    .iter_all()\n+                    .map(move |(_offset, perms)| {\n+                        let perm = perms.get(idx);\n+                        perm.cloned()\n+                    })\n+                    .collect::<Vec<_>>();\n+                let mut children = Vec::new();\n+                for child_idx in children_sorted {\n+                    extraction_aux(tree, child_idx, show_unnamed, &mut children);\n+                }\n+                acc.push(DisplayRepr { tag: node.tag, name, rperm, children });\n+            }\n+        }\n+    }\n+    fn print(\n+        &self,\n+        fmt: &DisplayFmt,\n+        indenter: &mut DisplayIndent,\n+        protected_tags: &FxHashMap<BorTag, ProtectorKind>,\n+        ranges: Vec<Range<u64>>,\n+        print_warning: bool,\n+    ) {\n+        let mut block = Vec::new();\n+        // Push the header and compute the required paddings for the body.\n+        // Header looks like this: `0.. 1.. 2.. 3.. 4.. 5.. 6.. 7.. 8`,\n+        // and is properly aligned with the `|` of the body.\n+        let (range_header, range_padding) = {\n+            let mut header_top = String::new();\n+            header_top.push_str(\"0..\");\n+            let mut padding = Vec::new();\n+            for (i, range) in ranges.iter().enumerate() {\n+                if i > 0 {\n+                    header_top.push_str(fmt.perm.range_sep);\n+                }\n+                let s = range.end.to_string();\n+                let l = s.chars().count() + fmt.perm.range_sep.chars().count();\n+                {\n+                    let target_len =\n+                        fmt.perm.uninit.chars().count() + fmt.accessed.yes.chars().count() + 1;\n+                    let tot_len = target_len.max(l);\n+                    let header_top_pad_len = target_len.saturating_sub(l);\n+                    let body_pad_len = tot_len.saturating_sub(target_len);\n+                    header_top.push_str(&format!(\"{}{}\", char_repeat(' ', header_top_pad_len), s));\n+                    padding.push(body_pad_len);\n+                }\n+            }\n+            ([header_top], padding)\n+        };\n+        for s in range_header {\n+            block.push(s);\n+        }\n+        // This is the actual work\n+        print_aux(\n+            self,\n+            &range_padding,\n+            fmt,\n+            indenter,\n+            protected_tags,\n+            true, /* root _is_ the last child */\n+            &mut block,\n+        );\n+        // Then it's just prettifying it with a border of dashes.\n+        {\n+            let wr = &fmt.wrapper;\n+            let max_width = {\n+                let block_width = block.iter().map(|s| s.chars().count()).max().unwrap();\n+                if print_warning {\n+                    block_width.max(wr.warning_text.chars().count())\n+                } else {\n+                    block_width\n+                }\n+            };\n+            eprintln!(\"{}\", char_repeat(wr.top, max_width));\n+            if print_warning {\n+                eprintln!(\"{}\", wr.warning_text,);\n+            }\n+            for line in block {\n+                eprintln!(\"{line}\");\n+            }\n+            eprintln!(\"{}\", char_repeat(wr.bot, max_width));\n+        }\n+\n+        // Here is the function that does the heavy lifting\n+        fn print_aux(\n+            tree: &DisplayRepr,\n+            padding: &[usize],\n+            fmt: &DisplayFmt,\n+            indent: &mut DisplayIndent,\n+            protected_tags: &FxHashMap<BorTag, ProtectorKind>,\n+            is_last_child: bool,\n+            acc: &mut Vec<String>,\n+        ) {\n+            let mut line = String::new();\n+            // Format the permissions on each range.\n+            // Looks like `| Act| Res| Res| Act|`.\n+            line.push_str(fmt.perm.open);\n+            for (i, (perm, &pad)) in tree.rperm.iter().zip(padding.iter()).enumerate() {\n+                if i > 0 {\n+                    line.push_str(fmt.perm.sep);\n+                }\n+                let show_perm = fmt.print_perm(*perm);\n+                line.push_str(&format!(\"{}{}\", char_repeat(' ', pad), show_perm));\n+            }\n+            line.push_str(fmt.perm.close);\n+            // Format the tree structure.\n+            // Main difficulty is handling the indentation properly.\n+            indent.write(&mut line);\n+            {\n+                // padding\n+                line.push_str(if is_last_child {\n+                    fmt.padding.join_last\n+                } else {\n+                    fmt.padding.join_middle\n+                });\n+                line.push_str(fmt.padding.join_default);\n+                line.push_str(if tree.children.is_empty() {\n+                    fmt.padding.join_default\n+                } else {\n+                    fmt.padding.join_haschild\n+                });\n+                line.push_str(fmt.padding.join_default);\n+                line.push_str(fmt.padding.join_default);\n+            }\n+            line.push_str(&fmt.print_tag(tree.tag, &tree.name));\n+            let protector = protected_tags.get(&tree.tag);\n+            line.push_str(fmt.print_protector(protector));\n+            // Push the line to the accumulator then recurse.\n+            acc.push(line);\n+            let nb_children = tree.children.len();\n+            for (i, child) in tree.children.iter().enumerate() {\n+                indent.increment(fmt, is_last_child);\n+                print_aux(child, padding, fmt, indent, protected_tags, i + 1 == nb_children, acc);\n+                indent.decrement(fmt);\n+            }\n+        }\n+    }\n+}\n+\n+const DEFAULT_FORMATTER: DisplayFmt = DisplayFmt {\n+    wrapper: DisplayFmtWrapper {\n+        top: '\u2500',\n+        bot: '\u2500',\n+        warning_text: \"Warning: this tree is indicative only. Some tags may have been hidden.\",\n+    },\n+    perm: DisplayFmtPermission { open: \"|\", sep: \"|\", close: \"|\", uninit: \"---\", range_sep: \"..\" },\n+    padding: DisplayFmtPadding {\n+        join_middle: \"\u251c\",\n+        join_last: \"\u2514\",\n+        indent_middle: \"\u2502 \",\n+        indent_last: \"  \",\n+        join_haschild: \"\u252c\",\n+        join_default: \"\u2500\",\n+    },\n+    accessed: DisplayFmtAccess { yes: \" \", no: \"?\", meh: \"-\" },\n+};\n+\n+impl<'tcx> Tree {\n+    /// Display the contents of the tree.\n+    pub fn print_tree(\n+        &self,\n+        protected_tags: &FxHashMap<BorTag, ProtectorKind>,\n+        show_unnamed: bool,\n+    ) -> InterpResult<'tcx> {\n+        let mut indenter = DisplayIndent::new();\n+        let ranges = self.rperms.iter_all().map(|(range, _perms)| range).collect::<Vec<_>>();\n+        if let Some(repr) = DisplayRepr::from(self, show_unnamed) {\n+            repr.print(\n+                &DEFAULT_FORMATTER,\n+                &mut indenter,\n+                protected_tags,\n+                ranges,\n+                /* print warning message about tags not shown */ !show_unnamed,\n+            );\n+        }\n+        Ok(())\n+    }\n+}"}, {"sha": "2297ceb125912b98093c37f639967041df09aad9", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/mod.rs", "status": "added", "additions": 539, "deletions": 0, "changes": 539, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fmod.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,539 @@\n+use log::trace;\n+\n+use rustc_target::abi::{Abi, Size};\n+\n+use crate::borrow_tracker::{AccessKind, GlobalStateInner, ProtectorKind, RetagFields};\n+use rustc_middle::{\n+    mir::{Mutability, RetagKind},\n+    ty::{\n+        self,\n+        layout::{HasParamEnv, LayoutOf},\n+        Ty,\n+    },\n+};\n+\n+use crate::*;\n+\n+mod diagnostics;\n+mod perms;\n+mod tree;\n+mod unimap;\n+use perms::Permission;\n+pub use tree::Tree;\n+\n+pub type AllocState = Tree;\n+\n+pub fn err_tb_ub<'tcx>(msg: String) -> InterpError<'tcx> {\n+    err_machine_stop!(TerminationInfo::TreeBorrowsUb { msg })\n+}\n+\n+impl<'tcx> Tree {\n+    /// Create a new allocation, i.e. a new tree\n+    pub fn new_allocation(\n+        id: AllocId,\n+        size: Size,\n+        state: &mut GlobalStateInner,\n+        _kind: MemoryKind<machine::MiriMemoryKind>,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> Self {\n+        let tag = state.base_ptr_tag(id, machine); // Fresh tag for the root\n+        Tree::new(tag, size)\n+    }\n+\n+    /// Check that an access on the entire range is permitted, and update\n+    /// the tree.\n+    pub fn before_memory_access(\n+        &mut self,\n+        access_kind: AccessKind,\n+        alloc_id: AllocId,\n+        prov: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        trace!(\n+            \"{} with tag {:?}: {:?}, size {}\",\n+            access_kind,\n+            prov,\n+            Pointer::new(alloc_id, range.start),\n+            range.size.bytes(),\n+        );\n+        // TODO: for now we bail out on wildcard pointers. Eventually we should\n+        // handle them as much as we can.\n+        let tag = match prov {\n+            ProvenanceExtra::Concrete(tag) => tag,\n+            ProvenanceExtra::Wildcard => return Ok(()),\n+        };\n+        let global = machine.borrow_tracker.as_ref().unwrap();\n+        self.perform_access(access_kind, tag, range, global)\n+    }\n+\n+    /// Check that this pointer has permission to deallocate this range.\n+    pub fn before_memory_deallocation(\n+        &mut self,\n+        _alloc_id: AllocId,\n+        prov: ProvenanceExtra,\n+        range: AllocRange,\n+        machine: &MiriMachine<'_, 'tcx>,\n+    ) -> InterpResult<'tcx> {\n+        // TODO: for now we bail out on wildcard pointers. Eventually we should\n+        // handle them as much as we can.\n+        let tag = match prov {\n+            ProvenanceExtra::Concrete(tag) => tag,\n+            ProvenanceExtra::Wildcard => return Ok(()),\n+        };\n+        let global = machine.borrow_tracker.as_ref().unwrap();\n+        self.dealloc(tag, range, global)\n+    }\n+\n+    pub fn expose_tag(&mut self, _tag: BorTag) {\n+        // TODO\n+    }\n+}\n+\n+/// Policy for a new borrow.\n+#[derive(Debug, Clone, Copy)]\n+struct NewPermission {\n+    /// Whether this borrow requires a read access on its parent.\n+    /// `perform_read_access` is `true` for all pointers marked `dereferenceable`.\n+    perform_read_access: bool,\n+    /// Which permission should the pointer start with.\n+    initial_state: Permission,\n+    /// Whether this pointer is part of the arguments of a function call.\n+    /// `protector` is `Some(_)` for all pointers marked `noalias`.\n+    protector: Option<ProtectorKind>,\n+}\n+\n+impl<'tcx> NewPermission {\n+    /// Determine NewPermission of the reference from the type of the pointee.\n+    fn from_ref_ty(\n+        pointee: Ty<'tcx>,\n+        mutability: Mutability,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Option<Self> {\n+        let ty_is_freeze = pointee.is_freeze(*cx.tcx, cx.param_env());\n+        let ty_is_unpin = pointee.is_unpin(*cx.tcx, cx.param_env());\n+        let initial_state = match mutability {\n+            Mutability::Mut if ty_is_unpin => Permission::new_unique_2phase(ty_is_freeze),\n+            Mutability::Not if ty_is_freeze => Permission::new_frozen(),\n+            // Raw pointers never enter this function so they are not handled.\n+            // However raw pointers are not the only pointers that take the parent\n+            // tag, this also happens for `!Unpin` `&mut`s and interior mutable\n+            // `&`s, which are excluded above.\n+            _ => return None,\n+        };\n+        // This field happens to be redundant since right now we always do a read,\n+        // but it could be useful in the future.\n+        let perform_read_access = true;\n+\n+        let protector = (kind == RetagKind::FnEntry).then_some(ProtectorKind::StrongProtector);\n+        Some(Self { perform_read_access, initial_state, protector })\n+    }\n+\n+    // Boxes are not handled by `from_ref_ty`, they need special behavior\n+    // implemented here.\n+    fn from_box_ty(\n+        ty: Ty<'tcx>,\n+        kind: RetagKind,\n+        cx: &crate::MiriInterpCx<'_, 'tcx>,\n+    ) -> Option<Self> {\n+        let pointee = ty.builtin_deref(true).unwrap().ty;\n+        pointee.is_unpin(*cx.tcx, cx.param_env()).then_some(()).map(|()| {\n+            // Regular `Unpin` box, give it `noalias` but only a weak protector\n+            // because it is valid to deallocate it within the function.\n+            let ty_is_freeze = ty.is_freeze(*cx.tcx, cx.param_env());\n+            Self {\n+                perform_read_access: true,\n+                initial_state: Permission::new_unique_2phase(ty_is_freeze),\n+                protector: (kind == RetagKind::FnEntry).then_some(ProtectorKind::WeakProtector),\n+            }\n+        })\n+    }\n+}\n+\n+/// Retagging/reborrowing.\n+/// Policy on which permission to grant to each pointer should be left to\n+/// the implementation of NewPermission.\n+impl<'mir: 'ecx, 'tcx: 'mir, 'ecx> EvalContextPrivExt<'mir, 'tcx, 'ecx>\n+    for crate::MiriInterpCx<'mir, 'tcx>\n+{\n+}\n+trait EvalContextPrivExt<'mir: 'ecx, 'tcx: 'mir, 'ecx>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Returns the `AllocId` the reborrow was done in, if there is some actual\n+    /// memory associated with this pointer. Returns `None` if there is no actual\n+    /// memory allocated. Also checks that the reborrow of size `ptr_size` is\n+    /// within bounds of the allocation.\n+    ///\n+    /// Also returns the tag that the pointer should get, which is essentially\n+    /// `if new_perm.is_some() { new_tag } else { parent_tag }` along with\n+    /// some logging (always) and fake reads (if `new_perm` is\n+    /// `Some(NewPermission { perform_read_access: true }`).\n+    fn tb_reborrow(\n+        &mut self,\n+        place: &MPlaceTy<'tcx, Provenance>, // parent tag extracted from here\n+        ptr_size: Size,\n+        new_perm: Option<NewPermission>,\n+        new_tag: BorTag,\n+    ) -> InterpResult<'tcx, Option<(AllocId, BorTag)>> {\n+        let this = self.eval_context_mut();\n+\n+        // It is crucial that this gets called on all code paths, to ensure we track tag creation.\n+        let log_creation = |this: &MiriInterpCx<'mir, 'tcx>,\n+                            loc: Option<(AllocId, Size, ProvenanceExtra)>| // alloc_id, base_offset, orig_tag\n+         -> InterpResult<'tcx> {\n+            let global = this.machine.borrow_tracker.as_ref().unwrap().borrow();\n+            let ty = place.layout.ty;\n+            if global.tracked_pointer_tags.contains(&new_tag) {\n+                let kind_str = format!(\"{new_perm:?} (pointee type {ty})\");\n+                this.emit_diagnostic(NonHaltingDiagnostic::CreatedPointerTag(\n+                    new_tag.inner(),\n+                    Some(kind_str),\n+                    loc.map(|(alloc_id, base_offset, orig_tag)| (alloc_id, alloc_range(base_offset, ptr_size), orig_tag)),\n+                ));\n+            }\n+            drop(global); // don't hold that reference any longer than we have to\n+            Ok(())\n+        };\n+\n+        let (alloc_id, base_offset, parent_prov) = if ptr_size > Size::ZERO {\n+            this.ptr_get_alloc_id(place.ptr)?\n+        } else {\n+            match this.ptr_try_get_alloc_id(place.ptr) {\n+                Ok(data) => data,\n+                Err(_) => {\n+                    // This pointer doesn't come with an AllocId, so there's no\n+                    // memory to do retagging in.\n+                    trace!(\n+                        \"reborrow of size 0: reference {:?} derived from {:?} (pointee {})\",\n+                        new_tag,\n+                        place.ptr,\n+                        place.layout.ty,\n+                    );\n+                    log_creation(this, None)?;\n+                    return Ok(None);\n+                }\n+            }\n+        };\n+        let orig_tag = match parent_prov {\n+            ProvenanceExtra::Wildcard => return Ok(None), // TODO: handle wildcard pointers\n+            ProvenanceExtra::Concrete(tag) => tag,\n+        };\n+\n+        // Protection against trying to get a reference to a vtable:\n+        // vtables do not have an alloc_extra so the call to\n+        // `get_alloc_extra` that follows fails.\n+        let (alloc_size, _align, alloc_kind) = this.get_alloc_info(alloc_id);\n+        if ptr_size == Size::ZERO && !matches!(alloc_kind, AllocKind::LiveData) {\n+            return Ok(Some((alloc_id, orig_tag)));\n+        }\n+\n+        log_creation(this, Some((alloc_id, base_offset, parent_prov)))?;\n+\n+        // Ensure we bail out if the pointer goes out-of-bounds (see miri#1050).\n+        if base_offset + ptr_size > alloc_size {\n+            throw_ub!(PointerOutOfBounds {\n+                alloc_id,\n+                alloc_size,\n+                ptr_offset: this.target_usize_to_isize(base_offset.bytes()),\n+                ptr_size,\n+                msg: CheckInAllocMsg::InboundsTest\n+            });\n+        }\n+\n+        trace!(\n+            \"reborrow: reference {:?} derived from {:?} (pointee {}): {:?}, size {}\",\n+            new_tag,\n+            orig_tag,\n+            place.layout.ty,\n+            Pointer::new(alloc_id, base_offset),\n+            ptr_size.bytes()\n+        );\n+\n+        let Some(new_perm) = new_perm else { return Ok(Some((alloc_id, orig_tag))); };\n+\n+        if let Some(protect) = new_perm.protector {\n+            // We register the protection in two different places.\n+            // This makes creating a protector slower, but checking whether a tag\n+            // is protected faster.\n+            this.frame_mut().extra.borrow_tracker.as_mut().unwrap().protected_tags.push(new_tag);\n+            this.machine\n+                .borrow_tracker\n+                .as_mut()\n+                .expect(\"We should have borrow tracking data\")\n+                .get_mut()\n+                .protected_tags\n+                .insert(new_tag, protect);\n+        }\n+\n+        let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+        let range = alloc_range(base_offset, ptr_size);\n+        let mut tree_borrows = alloc_extra.borrow_tracker_tb().borrow_mut();\n+\n+        if new_perm.perform_read_access {\n+            // Count this reborrow as a read access\n+            let global = &this.machine.borrow_tracker.as_ref().unwrap();\n+            tree_borrows.perform_access(AccessKind::Read, orig_tag, range, global)?;\n+            if let Some(data_race) = alloc_extra.data_race.as_ref() {\n+                data_race.read(alloc_id, range, &this.machine)?;\n+            }\n+        }\n+\n+        // Record the parent-child pair in the tree.\n+        tree_borrows.new_child(orig_tag, new_tag, new_perm.initial_state, range)?;\n+        Ok(Some((alloc_id, new_tag)))\n+    }\n+\n+    /// Retags an indidual pointer, returning the retagged version.\n+    fn tb_retag_reference(\n+        &mut self,\n+        val: &ImmTy<'tcx, Provenance>,\n+        new_perm: Option<NewPermission>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        // We want a place for where the ptr *points to*, so we get one.\n+        let place = this.ref_to_mplace(val)?;\n+\n+        // Get a lower bound of the size of this place.\n+        // (When `extern type` are involved, use the size of the known prefix.)\n+        let size = this\n+            .size_and_align_of_mplace(&place)?\n+            .map(|(size, _)| size)\n+            .unwrap_or(place.layout.size);\n+\n+        // This new tag is not guaranteed to actually be used.\n+        //\n+        // If you run out of tags, consider the following optimization: adjust `tb_reborrow`\n+        // so that rather than taking as input a fresh tag and deciding whether it uses this\n+        // one or the parent it instead just returns whether a new tag should be created.\n+        // This will avoid creating tags than end up never being used.\n+        let new_tag = this.machine.borrow_tracker.as_mut().unwrap().get_mut().new_ptr();\n+\n+        // Compute the actual reborrow.\n+        let reborrowed = this.tb_reborrow(&place, size, new_perm, new_tag)?;\n+\n+        // Adjust pointer.\n+        let new_place = place.map_provenance(|p| {\n+            p.map(|prov| {\n+                match reborrowed {\n+                    Some((alloc_id, actual_tag)) => {\n+                        // If `reborrow` could figure out the AllocId of this ptr, hard-code it into the new one.\n+                        // Even if we started out with a wildcard, this newly retagged pointer is tied to that allocation.\n+                        Provenance::Concrete { alloc_id, tag: actual_tag }\n+                    }\n+                    None => {\n+                        // Looks like this has to stay a wildcard pointer.\n+                        assert!(matches!(prov, Provenance::Wildcard));\n+                        Provenance::Wildcard\n+                    }\n+                }\n+            })\n+        });\n+\n+        // Return new pointer.\n+        Ok(ImmTy::from_immediate(new_place.to_ref(this), val.layout))\n+    }\n+}\n+\n+impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriInterpCx<'mir, 'tcx> {}\n+pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n+    /// Retag a pointer. References are passed to `from_ref_ty` and\n+    /// raw pointers are never reborrowed.\n+    fn tb_retag_ptr_value(\n+        &mut self,\n+        kind: RetagKind,\n+        val: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n+        let this = self.eval_context_mut();\n+        let new_perm = if let &ty::Ref(_, pointee, mutability) = val.layout.ty.kind() {\n+            NewPermission::from_ref_ty(pointee, mutability, kind, this)\n+        } else {\n+            None\n+        };\n+        this.tb_retag_reference(val, new_perm)\n+    }\n+\n+    /// Retag all pointers that are stored in this place.\n+    fn tb_retag_place_contents(\n+        &mut self,\n+        kind: RetagKind,\n+        place: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let retag_fields = this.machine.borrow_tracker.as_mut().unwrap().get_mut().retag_fields;\n+        let mut visitor = RetagVisitor { ecx: this, kind, retag_fields };\n+        return visitor.visit_value(place);\n+\n+        // The actual visitor.\n+        struct RetagVisitor<'ecx, 'mir, 'tcx> {\n+            ecx: &'ecx mut MiriInterpCx<'mir, 'tcx>,\n+            kind: RetagKind,\n+            retag_fields: RetagFields,\n+        }\n+        impl<'ecx, 'mir, 'tcx> RetagVisitor<'ecx, 'mir, 'tcx> {\n+            #[inline(always)] // yes this helps in our benchmarks\n+            fn retag_ptr_inplace(\n+                &mut self,\n+                place: &PlaceTy<'tcx, Provenance>,\n+                new_perm: Option<NewPermission>,\n+            ) -> InterpResult<'tcx> {\n+                let val = self.ecx.read_immediate(&self.ecx.place_to_op(place)?)?;\n+                let val = self.ecx.tb_retag_reference(&val, new_perm)?;\n+                self.ecx.write_immediate(*val, place)?;\n+                Ok(())\n+            }\n+        }\n+        impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, MiriMachine<'mir, 'tcx>>\n+            for RetagVisitor<'ecx, 'mir, 'tcx>\n+        {\n+            type V = PlaceTy<'tcx, Provenance>;\n+\n+            #[inline(always)]\n+            fn ecx(&mut self) -> &mut MiriInterpCx<'mir, 'tcx> {\n+                self.ecx\n+            }\n+\n+            fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+                let new_perm = NewPermission::from_box_ty(place.layout.ty, self.kind, self.ecx);\n+                self.retag_ptr_inplace(place, new_perm)\n+            }\n+\n+            fn visit_value(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n+                // If this place is smaller than a pointer, we know that it can't contain any\n+                // pointers we need to retag, so we can stop recursion early.\n+                // This optimization is crucial for ZSTs, because they can contain way more fields\n+                // than we can ever visit.\n+                if place.layout.is_sized() && place.layout.size < self.ecx.pointer_size() {\n+                    return Ok(());\n+                }\n+\n+                // Check the type of this value to see what to do with it (retag, or recurse).\n+                match place.layout.ty.kind() {\n+                    &ty::Ref(_, pointee, mutability) => {\n+                        let new_perm =\n+                            NewPermission::from_ref_ty(pointee, mutability, self.kind, self.ecx);\n+                        self.retag_ptr_inplace(place, new_perm)?;\n+                    }\n+                    ty::RawPtr(_) => {\n+                        // We definitely do *not* want to recurse into raw pointers -- wide raw\n+                        // pointers have fields, and for dyn Trait pointees those can have reference\n+                        // type!\n+                        // We also do not want to reborrow them.\n+                    }\n+                    ty::Adt(adt, _) if adt.is_box() => {\n+                        // Recurse for boxes, they require some tricky handling and will end up in `visit_box` above.\n+                        // (Yes this means we technically also recursively retag the allocator itself\n+                        // even if field retagging is not enabled. *shrug*)\n+                        self.walk_value(place)?;\n+                    }\n+                    _ => {\n+                        // Not a reference/pointer/box. Only recurse if configured appropriately.\n+                        let recurse = match self.retag_fields {\n+                            RetagFields::No => false,\n+                            RetagFields::Yes => true,\n+                            RetagFields::OnlyScalar => {\n+                                // Matching `ArgAbi::new` at the time of writing, only fields of\n+                                // `Scalar` and `ScalarPair` ABI are considered.\n+                                matches!(place.layout.abi, Abi::Scalar(..) | Abi::ScalarPair(..))\n+                            }\n+                        };\n+                        if recurse {\n+                            self.walk_value(place)?;\n+                        }\n+                    }\n+                }\n+\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    /// After a stack frame got pushed, retag the return place so that we are sure\n+    /// it does not alias with anything.\n+    ///\n+    /// This is a HACK because there is nothing in MIR that would make the retag\n+    /// explicit. Also see <https://github.com/rust-lang/rust/issues/71117>.\n+    fn tb_retag_return_place(&mut self) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        //this.debug_hint_location();\n+        let return_place = &this.frame().return_place;\n+        if return_place.layout.is_zst() {\n+            // There may not be any memory here, nothing to do.\n+            return Ok(());\n+        }\n+        // We need this to be in-memory to use tagged pointers.\n+        let return_place = this.force_allocation(&return_place.clone())?;\n+\n+        // We have to turn the place into a pointer to use the existing code.\n+        // (The pointer type does not matter, so we use a raw pointer.)\n+        let ptr_layout = this.layout_of(this.tcx.mk_mut_ptr(return_place.layout.ty))?;\n+        let val = ImmTy::from_immediate(return_place.to_ref(this), ptr_layout);\n+        // Reborrow it. With protection! That is part of the point.\n+        // FIXME: do we truly want a 2phase borrow here?\n+        let new_perm = Some(NewPermission {\n+            initial_state: Permission::new_unique_2phase(/*freeze*/ false),\n+            perform_read_access: true,\n+            protector: Some(ProtectorKind::StrongProtector),\n+        });\n+        let val = this.tb_retag_reference(&val, new_perm)?;\n+        // And use reborrowed pointer for return place.\n+        let return_place = this.ref_to_mplace(&val)?;\n+        this.frame_mut().return_place = return_place.into();\n+\n+        Ok(())\n+    }\n+\n+    /// Mark the given tag as exposed. It was found on a pointer with the given AllocId.\n+    fn tb_expose_tag(&mut self, alloc_id: AllocId, tag: BorTag) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+\n+        // Function pointers and dead objects don't have an alloc_extra so we ignore them.\n+        // This is okay because accessing them is UB anyway, no need for any Tree Borrows checks.\n+        // NOT using `get_alloc_extra_mut` since this might be a read-only allocation!\n+        let (_size, _align, kind) = this.get_alloc_info(alloc_id);\n+        match kind {\n+            AllocKind::LiveData => {\n+                // This should have alloc_extra data, but `get_alloc_extra` can still fail\n+                // if converting this alloc_id from a global to a local one\n+                // uncovers a non-supported `extern static`.\n+                let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+                trace!(\"Stacked Borrows tag {tag:?} exposed in {alloc_id:?}\");\n+                alloc_extra.borrow_tracker_tb().borrow_mut().expose_tag(tag);\n+            }\n+            AllocKind::Function | AllocKind::VTable | AllocKind::Dead => {\n+                // No tree borrows on these allocations.\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Display the tree.\n+    fn print_tree(&mut self, alloc_id: AllocId, show_unnamed: bool) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+        let tree_borrows = alloc_extra.borrow_tracker_tb().borrow();\n+        let borrow_tracker = &this.machine.borrow_tracker.as_ref().unwrap().borrow();\n+        tree_borrows.print_tree(&borrow_tracker.protected_tags, show_unnamed)\n+    }\n+\n+    /// Give a name to the pointer, usually the name it has in the source code (for debugging).\n+    /// The name given is `name` and the pointer that receives it is the `nth_parent`\n+    /// of `ptr` (with 0 representing `ptr` itself)\n+    fn tb_give_pointer_debug_name(\n+        &mut self,\n+        ptr: Pointer<Option<Provenance>>,\n+        nth_parent: u8,\n+        name: &str,\n+    ) -> InterpResult<'tcx> {\n+        let this = self.eval_context_mut();\n+        let (tag, alloc_id) = match ptr.provenance {\n+            Some(Provenance::Concrete { tag, alloc_id }) => (tag, alloc_id),\n+            _ => {\n+                eprintln!(\"Can't give the name {name} to Wildcard pointer\");\n+                return Ok(());\n+            }\n+        };\n+        let alloc_extra = this.get_alloc_extra(alloc_id)?;\n+        let mut tree_borrows = alloc_extra.borrow_tracker_tb().borrow_mut();\n+        tree_borrows.give_pointer_debug_name(tag, nth_parent, name)\n+    }\n+}"}, {"sha": "04b8e1df576147092d501905136f34080a8c124c", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/perms.rs", "status": "added", "additions": 307, "deletions": 0, "changes": 307, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Fperms.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,307 @@\n+use std::cmp::{Ordering, PartialOrd};\n+use std::fmt;\n+\n+use crate::borrow_tracker::tree_borrows::tree::AccessRelatedness;\n+use crate::borrow_tracker::AccessKind;\n+\n+/// The activation states of a pointer\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum PermissionPriv {\n+    /// represents: a local reference that has not yet been written to;\n+    /// allows: child reads, foreign reads, foreign writes if type is freeze;\n+    /// rejects: child writes (Active), foreign writes (Disabled, except if type is not freeze).\n+    /// special case: behaves differently when protected to adhere more closely to noalias\n+    Reserved { ty_is_freeze: bool },\n+    /// represents: a unique pointer;\n+    /// allows: child reads, child writes;\n+    /// rejects: foreign reads (Frozen), foreign writes (Disabled).\n+    Active,\n+    /// represents: a shared pointer;\n+    /// allows: all read accesses;\n+    /// rejects child writes (UB), foreign writes (Disabled).\n+    Frozen,\n+    /// represents: a dead pointer;\n+    /// allows: all foreign accesses;\n+    /// rejects: all child accesses (UB).\n+    Disabled,\n+}\n+use PermissionPriv::*;\n+\n+impl PartialOrd for PermissionPriv {\n+    /// PermissionPriv is ordered as follows:\n+    /// - Reserved(_) < Active < Frozen < Disabled;\n+    /// - different kinds of `Reserved` (with or without interior mutability)\n+    /// are incomparable to each other.\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        use Ordering::*;\n+        Some(match (self, other) {\n+            (a, b) if a == b => Equal,\n+            (Disabled, _) => Greater,\n+            (_, Disabled) => Less,\n+            (Frozen, _) => Greater,\n+            (_, Frozen) => Less,\n+            (Active, _) => Greater,\n+            (_, Active) => Less,\n+            (Reserved { .. }, Reserved { .. }) => return None,\n+        })\n+    }\n+}\n+\n+/// This module controls how each permission individually reacts to an access.\n+/// Although these functions take `protected` as an argument, this is NOT because\n+/// we check protector violations here, but because some permissions behave differently\n+/// when protected.\n+mod transition {\n+    use super::*;\n+    /// A child node was read-accessed: UB on Disabled, noop on the rest.\n+    fn child_read(state: PermissionPriv, _protected: bool) -> Option<PermissionPriv> {\n+        Some(match state {\n+            Disabled => return None,\n+            // The inner data `ty_is_freeze` of `Reserved` is always irrelevant for Read\n+            // accesses, since the data is not being mutated. Hence the `{ .. }`\n+            readable @ (Reserved { .. } | Active | Frozen) => readable,\n+        })\n+    }\n+\n+    /// A non-child node was read-accessed: noop on non-protected Reserved, advance to Frozen otherwise.\n+    fn foreign_read(state: PermissionPriv, protected: bool) -> Option<PermissionPriv> {\n+        use Option::*;\n+        Some(match state {\n+            // The inner data `ty_is_freeze` of `Reserved` is always irrelevant for Read\n+            // accesses, since the data is not being mutated. Hence the `{ .. }`\n+            res @ Reserved { .. } if !protected => res,\n+            Reserved { .. } => Frozen, // protected reserved\n+            Active => Frozen,\n+            non_writeable @ (Frozen | Disabled) => non_writeable,\n+        })\n+    }\n+\n+    /// A child node was write-accessed: `Reserved` must become `Active` to obtain\n+    /// write permissions, `Frozen` and `Disabled` cannot obtain such permissions and produce UB.\n+    fn child_write(state: PermissionPriv, _protected: bool) -> Option<PermissionPriv> {\n+        Some(match state {\n+            // A write always activates the 2-phase borrow, even with interior\n+            // mutability\n+            Reserved { .. } | Active => Active,\n+            Frozen | Disabled => return None,\n+        })\n+    }\n+\n+    /// A non-child node was write-accessed: this makes everything `Disabled` except for\n+    /// non-protected interior mutable `Reserved` which stay the same.\n+    fn foreign_write(state: PermissionPriv, protected: bool) -> Option<PermissionPriv> {\n+        Some(match state {\n+            cell @ Reserved { ty_is_freeze: false } if !protected => cell,\n+            _ => Disabled,\n+        })\n+    }\n+\n+    /// Dispatch handler depending on the kind of access and its position.\n+    pub(super) fn perform_access(\n+        kind: AccessKind,\n+        rel_pos: AccessRelatedness,\n+        child: PermissionPriv,\n+        protected: bool,\n+    ) -> Option<PermissionPriv> {\n+        match (kind, rel_pos.is_foreign()) {\n+            (AccessKind::Write, true) => foreign_write(child, protected),\n+            (AccessKind::Read, true) => foreign_read(child, protected),\n+            (AccessKind::Write, false) => child_write(child, protected),\n+            (AccessKind::Read, false) => child_read(child, protected),\n+        }\n+    }\n+}\n+\n+impl PermissionPriv {\n+    /// Determines whether a transition that occured is compatible with the presence\n+    /// of a Protector. This is not included in the `transition` functions because\n+    /// it would distract from the few places where the transition is modified\n+    /// because of a protector, but not forbidden.\n+    fn protector_allows_transition(self, new: Self) -> bool {\n+        match (self, new) {\n+            _ if self == new => true,\n+            // It is always a protector violation to not be readable anymore\n+            (_, Disabled) => false,\n+            // In the case of a `Reserved` under a protector, both transitions\n+            // `Reserved => Active` and `Reserved => Frozen` can legitimately occur.\n+            // The first is standard (Child Write), the second is for Foreign Writes\n+            // on protected Reserved where we must ensure that the pointer is not\n+            // written to in the future.\n+            (Reserved { .. }, Active) | (Reserved { .. }, Frozen) => true,\n+            // This pointer should have stayed writeable for the whole function\n+            (Active, Frozen) => false,\n+            _ => unreachable!(\"Transition from {self:?} to {new:?} should never be possible\"),\n+        }\n+    }\n+}\n+\n+/// Public interface to the state machine that controls read-write permissions.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct Permission(PermissionPriv);\n+\n+impl fmt::Display for Permission {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(\n+            f,\n+            \"{}\",\n+            match self.0 {\n+                PermissionPriv::Reserved { .. } => \"Reserved\",\n+                PermissionPriv::Active => \"Active\",\n+                PermissionPriv::Frozen => \"Frozen\",\n+                PermissionPriv::Disabled => \"Disabled\",\n+            }\n+        )\n+    }\n+}\n+\n+impl Permission {\n+    /// Default initial permission of the root of a new tree.\n+    pub fn new_root() -> Self {\n+        Self(Active)\n+    }\n+\n+    /// Default initial permission of a reborrowed mutable reference.\n+    pub fn new_unique_2phase(ty_is_freeze: bool) -> Self {\n+        Self(Reserved { ty_is_freeze })\n+    }\n+\n+    /// Default initial permission of a reborrowed shared reference\n+    pub fn new_frozen() -> Self {\n+        Self(Frozen)\n+    }\n+\n+    /// Pretty-printing. Needs to be here and not in diagnostics.rs\n+    /// because `Self` is private.\n+    pub fn short_name(self) -> &'static str {\n+        // Make sure there are all of the same length as each other\n+        // and also as `diagnostics::DisplayFmtPermission.uninit` otherwise\n+        // alignment will be incorrect.\n+        match self.0 {\n+            Reserved { ty_is_freeze: true } => \"Res\",\n+            Reserved { ty_is_freeze: false } => \"Re*\",\n+            Active => \"Act\",\n+            Frozen => \"Frz\",\n+            Disabled => \"Dis\",\n+        }\n+    }\n+\n+    /// Check that there are no complaints from a possible protector.\n+    ///\n+    /// Note: this is not in charge of checking that there *is* a protector,\n+    /// it should be used as\n+    /// ```\n+    /// let no_protector_error = if is_protected(tag) {\n+    ///     old_perm.protector_allows_transition(new_perm)\n+    /// };\n+    /// ```\n+    pub fn protector_allows_transition(self, new: Self) -> bool {\n+        self.0.protector_allows_transition(new.0)\n+    }\n+\n+    /// Apply the transition to the inner PermissionPriv.\n+    pub fn perform_access(\n+        kind: AccessKind,\n+        rel_pos: AccessRelatedness,\n+        old_perm: Self,\n+        protected: bool,\n+    ) -> Option<Self> {\n+        let old_state = old_perm.0;\n+        transition::perform_access(kind, rel_pos, old_state, protected).map(Self)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod propagation_optimization_checks {\n+    pub use super::*;\n+\n+    mod util {\n+        pub use super::*;\n+        impl PermissionPriv {\n+            /// Enumerate all states\n+            pub fn all() -> impl Iterator<Item = PermissionPriv> {\n+                vec![\n+                    Active,\n+                    Reserved { ty_is_freeze: true },\n+                    Reserved { ty_is_freeze: false },\n+                    Frozen,\n+                    Disabled,\n+                ]\n+                .into_iter()\n+            }\n+        }\n+\n+        impl AccessKind {\n+            /// Enumerate all AccessKind.\n+            pub fn all() -> impl Iterator<Item = AccessKind> {\n+                use AccessKind::*;\n+                [Read, Write].into_iter()\n+            }\n+        }\n+\n+        impl AccessRelatedness {\n+            /// Enumerate all relative positions\n+            pub fn all() -> impl Iterator<Item = AccessRelatedness> {\n+                use AccessRelatedness::*;\n+                [This, StrictChildAccess, AncestorAccess, DistantAccess].into_iter()\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    // For any kind of access, if we do it twice the second should be a no-op.\n+    // Even if the protector has disappeared.\n+    fn all_transitions_idempotent() {\n+        use transition::*;\n+        for old in PermissionPriv::all() {\n+            for (old_protected, new_protected) in [(true, true), (true, false), (false, false)] {\n+                for access in AccessKind::all() {\n+                    for rel_pos in AccessRelatedness::all() {\n+                        if let Some(new) = perform_access(access, rel_pos, old, old_protected) {\n+                            assert_eq!(\n+                                new,\n+                                perform_access(access, rel_pos, new, new_protected).unwrap()\n+                            );\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn foreign_read_is_noop_after_write() {\n+        use transition::*;\n+        let old_access = AccessKind::Write;\n+        let new_access = AccessKind::Read;\n+        for old in PermissionPriv::all() {\n+            for (old_protected, new_protected) in [(true, true), (true, false), (false, false)] {\n+                for rel_pos in AccessRelatedness::all().filter(|rel| rel.is_foreign()) {\n+                    if let Some(new) = perform_access(old_access, rel_pos, old, old_protected) {\n+                        assert_eq!(\n+                            new,\n+                            perform_access(new_access, rel_pos, new, new_protected).unwrap()\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    // Check that all transitions are consistent with the order on PermissionPriv,\n+    // i.e. Reserved -> Active -> Frozen -> Disabled\n+    fn access_transitions_progress_increasing() {\n+        use transition::*;\n+        for old in PermissionPriv::all() {\n+            for protected in [true, false] {\n+                for access in AccessKind::all() {\n+                    for rel_pos in AccessRelatedness::all() {\n+                        if let Some(new) = perform_access(access, rel_pos, old, protected) {\n+                            assert!(old <= new);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}"}, {"sha": "86416a0eb1bca2ee4bd9859f9c7e7456980eb171", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/tree.rs", "status": "added", "additions": 554, "deletions": 0, "changes": 554, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Ftree.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,554 @@\n+//! In this file we handle the \"Tree\" part of Tree Borrows, i.e. all tree\n+//! traversal functions, optimizations to trim branches, and keeping track of\n+//! the relative position of the access to each node being updated. This of course\n+//! also includes the definition of the tree structure.\n+//!\n+//! Functions here manipulate permissions but are oblivious to them: as\n+//! the internals of `Permission` are private, the update process is a black\n+//! box. All we need to know here are\n+//! - the fact that updates depend only on the old state, the status of protectors,\n+//!   and the relative position of the access;\n+//! - idempotency properties asserted in `perms.rs` (for optimizations)\n+\n+use smallvec::SmallVec;\n+\n+use rustc_const_eval::interpret::InterpResult;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_target::abi::Size;\n+\n+use crate::borrow_tracker::tree_borrows::{\n+    diagnostics::{NodeDebugInfo, TbError, TransitionError},\n+    unimap::{UniEntry, UniIndex, UniKeyMap, UniValMap},\n+    Permission,\n+};\n+use crate::borrow_tracker::{AccessKind, GlobalState, ProtectorKind};\n+use crate::*;\n+\n+/// Data for a single *location*.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub(super) struct LocationState {\n+    /// This pointer's current permission\n+    permission: Permission,\n+    /// A location is initialized when it is child accessed for the first time,\n+    /// and it then stays initialized forever.\n+    /// Before initialization we still apply some preemptive transitions on\n+    /// `permission` to know what to do in case it ever gets initialized,\n+    /// but these can never cause any immediate UB. There can however be UB\n+    /// the moment we attempt to initalize (i.e. child-access) because some\n+    /// foreign access done between the creation and the initialization is\n+    /// incompatible with child accesses.\n+    initialized: bool,\n+    /// Strongest foreign access whose effects have already been applied to\n+    /// this node and all its children since the last child access.\n+    /// This is `None` if the most recent access is a child access,\n+    /// `Some(Write)` if at least one foreign write access has been applied\n+    /// since the previous child access, and `Some(Read)` if at least one\n+    /// foreign read and no foreign write have occurred since the last child access.\n+    latest_foreign_access: Option<AccessKind>,\n+}\n+\n+impl LocationState {\n+    /// Default initial state has never been accessed and has been subjected to no\n+    /// foreign access.\n+    fn new(permission: Permission) -> Self {\n+        Self { permission, initialized: false, latest_foreign_access: None }\n+    }\n+\n+    /// Record that this location was accessed through a child pointer by\n+    /// marking it as initialized\n+    fn with_access(mut self) -> Self {\n+        self.initialized = true;\n+        self\n+    }\n+\n+    pub fn is_initialized(&self) -> bool {\n+        self.initialized\n+    }\n+\n+    pub fn permission(&self) -> Permission {\n+        self.permission\n+    }\n+}\n+\n+/// Tree structure with both parents and children since we want to be\n+/// able to traverse the tree efficiently in both directions.\n+#[derive(Clone, Debug)]\n+pub struct Tree {\n+    /// Mapping from tags to keys. The key obtained can then be used in\n+    /// any of the `UniValMap` relative to this allocation, i.e. both the\n+    /// `nodes` and `rperms` of the same `Tree`.\n+    /// The parent-child relationship in `Node` is encoded in terms of these same\n+    /// keys, so traversing the entire tree needs exactly one access to\n+    /// `tag_mapping`.\n+    pub(super) tag_mapping: UniKeyMap<BorTag>,\n+    /// All nodes of this tree.\n+    pub(super) nodes: UniValMap<Node>,\n+    /// Maps a tag and a location to a perm, with possible lazy\n+    /// initialization.\n+    ///\n+    /// NOTE: not all tags registered in `nodes` are necessarily in all\n+    /// ranges of `rperms`, because `rperms` is in part lazily initialized.\n+    /// Just because `nodes.get(key)` is `Some(_)` does not mean you can safely\n+    /// `unwrap` any `perm.get(key)`.\n+    ///\n+    /// We do uphold the fact that `keys(perms)` is a subset of `keys(nodes)`\n+    pub(super) rperms: RangeMap<UniValMap<LocationState>>,\n+    /// The index of the root node.\n+    pub(super) root: UniIndex,\n+}\n+\n+/// A node in the borrow tree. Each node is uniquely identified by a tag via\n+/// the `nodes` map of `Tree`.\n+#[derive(Clone, Debug)]\n+pub(super) struct Node {\n+    /// The tag of this node.\n+    pub tag: BorTag,\n+    /// All tags except the root have a parent tag.\n+    pub parent: Option<UniIndex>,\n+    /// If the pointer was reborrowed, it has children.\n+    // FIXME: bench to compare this to FxHashSet and to other SmallVec sizes\n+    pub children: SmallVec<[UniIndex; 4]>,\n+    /// Either `Reserved` or `Frozen`, the permission this tag will be lazily initialized\n+    /// to on the first access.\n+    default_initial_perm: Permission,\n+    /// Some extra information useful only for debugging purposes\n+    pub debug_info: NodeDebugInfo,\n+}\n+\n+/// Data given to the transition function\n+struct NodeAppArgs<'node> {\n+    /// Node on which the transition is currently being applied\n+    node: &'node Node,\n+    /// Mutable access to its permissions\n+    perm: UniEntry<'node, LocationState>,\n+    /// Relative position of the access\n+    rel_pos: AccessRelatedness,\n+}\n+/// Data given to the error handler\n+struct ErrHandlerArgs<'node, InErr> {\n+    /// Kind of error that occurred\n+    error_kind: InErr,\n+    /// Tag that triggered the error (not the tag that was accessed,\n+    /// rather the parent tag that had insufficient permissions or the\n+    /// non-parent tag that had a protector).\n+    faulty_tag: &'node NodeDebugInfo,\n+}\n+/// Internal contents of `Tree` with the minimum of mutable access for\n+/// the purposes of the tree traversal functions: the permissions (`perms`) can be\n+/// updated but not the tree structure (`tag_mapping` and `nodes`)\n+struct TreeVisitor<'tree> {\n+    tag_mapping: &'tree UniKeyMap<BorTag>,\n+    nodes: &'tree UniValMap<Node>,\n+    perms: &'tree mut UniValMap<LocationState>,\n+}\n+\n+/// Whether to continue exploring the children recursively or not.\n+enum ContinueTraversal {\n+    Recurse,\n+    SkipChildren,\n+}\n+\n+impl<'tree> TreeVisitor<'tree> {\n+    // Applies `f_propagate` to every vertex of the tree top-down in the following order: first\n+    // all ancestors of `start`, then `start` itself, then children of `start`, then the rest.\n+    // This ensures that errors are triggered in the following order\n+    // - first invalid accesses with insufficient permissions, closest to the root first,\n+    // - then protector violations, closest to `start` first.\n+    //\n+    // `f_propagate` should follow the following format: for a given `Node` it updates its\n+    // `Permission` depending on the position relative to `start` (given by an\n+    // `AccessRelatedness`).\n+    // It outputs whether the tree traversal for this subree should continue or not.\n+    fn traverse_parents_this_children_others<InnErr, OutErr>(\n+        mut self,\n+        start: BorTag,\n+        f_propagate: impl Fn(NodeAppArgs<'_>) -> Result<ContinueTraversal, InnErr>,\n+        err_builder: impl Fn(ErrHandlerArgs<'_, InnErr>) -> OutErr,\n+    ) -> Result<(), OutErr>\n+where {\n+        struct TreeVisitAux<NodeApp, ErrHandler> {\n+            f_propagate: NodeApp,\n+            err_builder: ErrHandler,\n+            stack: Vec<(UniIndex, AccessRelatedness)>,\n+        }\n+        impl<NodeApp, InnErr, OutErr, ErrHandler> TreeVisitAux<NodeApp, ErrHandler>\n+        where\n+            NodeApp: Fn(NodeAppArgs<'_>) -> Result<ContinueTraversal, InnErr>,\n+            ErrHandler: Fn(ErrHandlerArgs<'_, InnErr>) -> OutErr,\n+        {\n+            fn pop(&mut self) -> Option<(UniIndex, AccessRelatedness)> {\n+                self.stack.pop()\n+            }\n+\n+            /// Apply the function to the current `tag`, and push its children\n+            /// to the stack of future tags to visit.\n+            fn exec_and_visit(\n+                &mut self,\n+                this: &mut TreeVisitor<'_>,\n+                tag: UniIndex,\n+                exclude: Option<UniIndex>,\n+                rel_pos: AccessRelatedness,\n+            ) -> Result<(), OutErr> {\n+                // 1. apply the propagation function\n+                let node = this.nodes.get(tag).unwrap();\n+                let recurse =\n+                    (self.f_propagate)(NodeAppArgs { node, perm: this.perms.entry(tag), rel_pos })\n+                        .map_err(|error_kind| {\n+                            (self.err_builder)(ErrHandlerArgs {\n+                                error_kind,\n+                                faulty_tag: &node.debug_info,\n+                            })\n+                        })?;\n+                // 2. add the children to the stack for future traversal\n+                if matches!(recurse, ContinueTraversal::Recurse) {\n+                    let child_rel = rel_pos.for_child();\n+                    for &child in node.children.iter() {\n+                        // some child might be excluded from here and handled separately\n+                        if Some(child) != exclude {\n+                            self.stack.push((child, child_rel));\n+                        }\n+                    }\n+                }\n+                Ok(())\n+            }\n+        }\n+\n+        let start_idx = self.tag_mapping.get(&start).unwrap();\n+        let mut stack = TreeVisitAux { f_propagate, err_builder, stack: Vec::new() };\n+        {\n+            let mut path_ascend = Vec::new();\n+            // First climb to the root while recording the path\n+            let mut curr = start_idx;\n+            while let Some(ancestor) = self.nodes.get(curr).unwrap().parent {\n+                path_ascend.push((ancestor, curr));\n+                curr = ancestor;\n+            }\n+            // Then descend:\n+            // - execute f_propagate on each node\n+            // - record children in visit\n+            while let Some((ancestor, next_in_path)) = path_ascend.pop() {\n+                // Explore ancestors in descending order.\n+                // `next_in_path` is excluded from the recursion because it\n+                // will be the `ancestor` of the next iteration.\n+                // It also needs a different `AccessRelatedness` than the other\n+                // children of `ancestor`.\n+                stack.exec_and_visit(\n+                    &mut self,\n+                    ancestor,\n+                    Some(next_in_path),\n+                    AccessRelatedness::StrictChildAccess,\n+                )?;\n+            }\n+        };\n+        // All (potentially zero) ancestors have been explored, call f_propagate on start\n+        stack.exec_and_visit(&mut self, start_idx, None, AccessRelatedness::This)?;\n+        // up to this point we have never popped from `stack`, hence if the\n+        // path to the root is `root = p(n) <- p(n-1)... <- p(1) <- p(0) = start`\n+        // then now `stack` contains\n+        // `[<children(p(n)) except p(n-1)> ... <children(p(1)) except p(0)> <children(p(0))>]`,\n+        // all of which are for now unexplored.\n+        // This is the starting point of a standard DFS which will thus\n+        // explore all non-ancestors of `start` in the following order:\n+        // - all descendants of `start`;\n+        // - then the unexplored descendants of `parent(start)`;\n+        // ...\n+        // - until finally the unexplored descendants of `root`.\n+        while let Some((tag, rel_pos)) = stack.pop() {\n+            stack.exec_and_visit(&mut self, tag, None, rel_pos)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl Tree {\n+    /// Create a new tree, with only a root pointer.\n+    pub fn new(root_tag: BorTag, size: Size) -> Self {\n+        let root_perm = Permission::new_root();\n+        let mut tag_mapping = UniKeyMap::default();\n+        let root_idx = tag_mapping.insert(root_tag);\n+        let nodes = {\n+            let mut nodes = UniValMap::<Node>::default();\n+            nodes.insert(\n+                root_idx,\n+                Node {\n+                    tag: root_tag,\n+                    parent: None,\n+                    children: SmallVec::default(),\n+                    default_initial_perm: root_perm,\n+                    debug_info: NodeDebugInfo::new(root_tag),\n+                },\n+            );\n+            nodes\n+        };\n+        let rperms = {\n+            let mut perms = UniValMap::default();\n+            perms.insert(root_idx, LocationState::new(root_perm).with_access());\n+            RangeMap::new(size, perms)\n+        };\n+        Self { root: root_idx, nodes, rperms, tag_mapping }\n+    }\n+}\n+\n+impl<'tcx> Tree {\n+    /// Insert a new tag in the tree\n+    pub fn new_child(\n+        &mut self,\n+        parent_tag: BorTag,\n+        new_tag: BorTag,\n+        default_initial_perm: Permission,\n+        range: AllocRange,\n+    ) -> InterpResult<'tcx> {\n+        assert!(!self.tag_mapping.contains_key(&new_tag));\n+        let idx = self.tag_mapping.insert(new_tag);\n+        let parent_idx = self.tag_mapping.get(&parent_tag).unwrap();\n+        // Create the node\n+        self.nodes.insert(\n+            idx,\n+            Node {\n+                tag: new_tag,\n+                parent: Some(parent_idx),\n+                children: SmallVec::default(),\n+                default_initial_perm,\n+                debug_info: NodeDebugInfo::new(new_tag),\n+            },\n+        );\n+        // Register new_tag as a child of parent_tag\n+        self.nodes.get_mut(parent_idx).unwrap().children.push(idx);\n+        // Initialize perms\n+        let perm = LocationState::new(default_initial_perm).with_access();\n+        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            perms.insert(idx, perm);\n+        }\n+        Ok(())\n+    }\n+\n+    /// Deallocation requires\n+    /// - a pointer that permits write accesses\n+    /// - the absence of Strong Protectors anywhere in the allocation\n+    pub fn dealloc(\n+        &mut self,\n+        tag: BorTag,\n+        range: AllocRange,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        self.perform_access(AccessKind::Write, tag, range, global)?;\n+        let access_info = &self.nodes.get(self.tag_mapping.get(&tag).unwrap()).unwrap().debug_info;\n+        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            TreeVisitor { nodes: &self.nodes, tag_mapping: &self.tag_mapping, perms }\n+                .traverse_parents_this_children_others(\n+                    tag,\n+                    |args: NodeAppArgs<'_>| -> Result<ContinueTraversal, TransitionError> {\n+                        let NodeAppArgs { node, .. } = args;\n+                        if global.borrow().protected_tags.get(&node.tag)\n+                            == Some(&ProtectorKind::StrongProtector)\n+                        {\n+                            Err(TransitionError::ProtectedDealloc)\n+                        } else {\n+                            Ok(ContinueTraversal::Recurse)\n+                        }\n+                    },\n+                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpErrorInfo<'tcx> {\n+                        let ErrHandlerArgs { error_kind, faulty_tag } = args;\n+                        TbError {\n+                            faulty_tag,\n+                            access_kind: AccessKind::Write,\n+                            error_kind,\n+                            tag_of_access: access_info,\n+                        }\n+                        .build()\n+                    },\n+                )?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Maps the following propagation procedure to each range:\n+    /// - initialize if needed;\n+    /// - compute new state after transition;\n+    /// - check that there is no protector that would forbid this;\n+    /// - record this specific location as accessed.\n+    pub fn perform_access(\n+        &mut self,\n+        access_kind: AccessKind,\n+        tag: BorTag,\n+        range: AllocRange,\n+        global: &GlobalState,\n+    ) -> InterpResult<'tcx> {\n+        let access_info = &self.nodes.get(self.tag_mapping.get(&tag).unwrap()).unwrap().debug_info;\n+        for (_range, perms) in self.rperms.iter_mut(range.start, range.size) {\n+            TreeVisitor { nodes: &self.nodes, tag_mapping: &self.tag_mapping, perms }\n+                .traverse_parents_this_children_others(\n+                    tag,\n+                    |args: NodeAppArgs<'_>| -> Result<ContinueTraversal, TransitionError> {\n+                        let NodeAppArgs { node, mut perm, rel_pos } = args;\n+\n+                        let old_state =\n+                            perm.or_insert_with(|| LocationState::new(node.default_initial_perm));\n+\n+                        // Optimize the tree traversal.\n+                        // The optimization here consists of observing thanks to the tests\n+                        // `foreign_read_is_noop_after_write` and `all_transitions_idempotent`\n+                        // that if we apply twice in a row the effects of a foreign access\n+                        // we can skip some branches.\n+                        // \"two foreign accesses in a row\" occurs when `perm.latest_foreign_access` is `Some(_)`\n+                        // AND the `rel_pos` of the current access corresponds to a foreign access.\n+                        if rel_pos.is_foreign() {\n+                            let new_access_noop =\n+                                match (old_state.latest_foreign_access, access_kind) {\n+                                    // Previously applied transition makes the new one a guaranteed\n+                                    // noop in the two following cases:\n+                                    // (1) justified by `foreign_read_is_noop_after_write`\n+                                    (Some(AccessKind::Write), AccessKind::Read) => true,\n+                                    // (2) justified by `all_transitions_idempotent`\n+                                    (Some(old), new) if old == new => true,\n+                                    // In all other cases there has been a recent enough\n+                                    // child access that the effects of the new foreign access\n+                                    // need to be applied to this subtree.\n+                                    _ => false,\n+                                };\n+                            if new_access_noop {\n+                                // Abort traversal if the new transition is indeed guaranteed\n+                                // to be noop.\n+                                return Ok(ContinueTraversal::SkipChildren);\n+                            } else {\n+                                // Otherwise propagate this time, and also record the\n+                                // access that just occurred so that we can skip the propagation\n+                                // next time.\n+                                old_state.latest_foreign_access = Some(access_kind);\n+                            }\n+                        } else {\n+                            // A child access occurred, this breaks the streak of \"two foreign\n+                            // accesses in a row\" and we reset this field.\n+                            old_state.latest_foreign_access = None;\n+                        }\n+\n+                        let old_perm = old_state.permission;\n+                        let protected = global.borrow().protected_tags.contains_key(&node.tag);\n+                        let new_perm =\n+                            Permission::perform_access(access_kind, rel_pos, old_perm, protected)\n+                                .ok_or(TransitionError::ChildAccessForbidden(old_perm))?;\n+                        if protected\n+                            // Can't trigger Protector on uninitialized locations\n+                            && old_state.initialized\n+                            && !old_perm.protector_allows_transition(new_perm)\n+                        {\n+                            return Err(TransitionError::ProtectedTransition(old_perm, new_perm));\n+                        }\n+                        old_state.permission = new_perm;\n+                        old_state.initialized |= !rel_pos.is_foreign();\n+                        Ok(ContinueTraversal::Recurse)\n+                    },\n+                    |args: ErrHandlerArgs<'_, TransitionError>| -> InterpErrorInfo<'tcx> {\n+                        let ErrHandlerArgs { error_kind, faulty_tag } = args;\n+                        TbError { faulty_tag, access_kind, error_kind, tag_of_access: access_info }\n+                            .build()\n+                    },\n+                )?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+/// Integration with the BorTag garbage collector\n+impl Tree {\n+    pub fn remove_unreachable_tags(&mut self, live_tags: &FxHashSet<BorTag>) {\n+        assert!(self.keep_only_needed(self.root, live_tags)); // root can't be removed\n+    }\n+\n+    /// Traverses the entire tree looking for useless tags.\n+    /// Returns true iff the tag it was called on is still live or has live children,\n+    /// and removes from the tree all tags that have no live children.\n+    ///\n+    /// NOTE: This leaves in the middle of the tree tags that are unreachable but have\n+    /// reachable children. There is a potential for compacting the tree by reassigning\n+    /// children of dead tags to the nearest live parent, but it must be done with care\n+    /// not to remove UB.\n+    ///\n+    /// Example: Consider the tree `root - parent - child`, with `parent: Frozen` and\n+    /// `child: Reserved`. This tree can exist. If we blindly delete `parent` and reassign\n+    /// `child` to be a direct child of `root` then Writes to `child` are now permitted\n+    /// whereas they were not when `parent` was still there.\n+    fn keep_only_needed(&mut self, idx: UniIndex, live: &FxHashSet<BorTag>) -> bool {\n+        let node = self.nodes.get(idx).unwrap();\n+        // FIXME: this function does a lot of cloning, a 2-pass approach is possibly\n+        // more efficient. It could consist of\n+        // 1. traverse the Tree, collect all useless tags in a Vec\n+        // 2. traverse the Vec, remove all tags previously selected\n+        // Bench it.\n+        let children: SmallVec<_> = node\n+            .children\n+            .clone()\n+            .into_iter()\n+            .filter(|child| self.keep_only_needed(*child, live))\n+            .collect();\n+        let no_children = children.is_empty();\n+        let node = self.nodes.get_mut(idx).unwrap();\n+        node.children = children;\n+        if !live.contains(&node.tag) && no_children {\n+            // All of the children and this node are unreachable, delete this tag\n+            // from the tree (the children have already been deleted by recursive\n+            // calls).\n+            // Due to the API of UniMap we must absolutely call\n+            // `UniValMap::remove` for the key of this tag on *all* maps that used it\n+            // (which are `self.nodes` and every range of `self.rperms`)\n+            // before we can safely apply `UniValMap::forget` to truly remove\n+            // the tag from the mapping.\n+            let tag = node.tag;\n+            self.nodes.remove(idx);\n+            for perms in self.rperms.iter_mut_all() {\n+                perms.remove(idx);\n+            }\n+            self.tag_mapping.remove(&tag);\n+            // The tag has been deleted, inform the caller\n+            false\n+        } else {\n+            // The tag is still live or has live children, it must be kept\n+            true\n+        }\n+    }\n+}\n+\n+impl VisitTags for Tree {\n+    fn visit_tags(&self, visit: &mut dyn FnMut(BorTag)) {\n+        // To ensure that the root never gets removed, we visit it\n+        // (the `root` node of `Tree` is not an `Option<_>`)\n+        visit(self.nodes.get(self.root).unwrap().tag)\n+    }\n+}\n+\n+/// Relative position of the access\n+#[derive(Clone, Copy, Debug, PartialEq, Eq)]\n+pub enum AccessRelatedness {\n+    /// The accessed pointer is the current one\n+    This,\n+    /// The accessed pointer is a (transitive) child of the current one.\n+    // Current pointer is excluded (unlike in some other places of this module\n+    // where \"child\" is inclusive).\n+    StrictChildAccess,\n+    /// The accessed pointer is a (transitive) parent of the current one.\n+    // Current pointer is excluded.\n+    AncestorAccess,\n+    /// The accessed pointer is neither of the above.\n+    // It's a cousin/uncle/etc., something in a side branch.\n+    // FIXME: find a better name ?\n+    DistantAccess,\n+}\n+\n+impl AccessRelatedness {\n+    /// Check that access is either Ancestor or Distant, i.e. not\n+    /// a transitive child (initial pointer included).\n+    pub fn is_foreign(self) -> bool {\n+        matches!(self, AccessRelatedness::AncestorAccess | AccessRelatedness::DistantAccess)\n+    }\n+\n+    /// Given the AccessRelatedness for the parent node, compute the AccessRelatedness\n+    /// for the child node. This function assumes that we propagate away from the initial\n+    /// access.\n+    pub fn for_child(self) -> Self {\n+        use AccessRelatedness::*;\n+        match self {\n+            AncestorAccess | This => AncestorAccess,\n+            StrictChildAccess | DistantAccess => DistantAccess,\n+        }\n+    }\n+}"}, {"sha": "c1d452ca89e9648ceffb19c58ab0078798862656", "filename": "src/tools/miri/src/borrow_tracker/tree_borrows/unimap.rs", "status": "added", "additions": 304, "deletions": 0, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fborrow_tracker%2Ftree_borrows%2Funimap.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,304 @@\n+//! This module implements the `UniMap`, which is a way to get efficient mappings\n+//! optimized for the setting of `tree_borrows/tree.rs`.\n+//!\n+//! A `UniKeyMap<K>` is a (slow) mapping from `K` to `UniIndex`,\n+//! and `UniValMap<V>` is a (fast) mapping from `UniIndex` to `V`.\n+//! Thus a pair `(UniKeyMap<K>, UniValMap<V>)` acts as a virtual `HashMap<K, V>`.\n+//!\n+//! Because of the asymmetry in access time, the use-case for `UniMap` is the following:\n+//! a tuple `(UniKeyMap<K>, Vec<UniValMap<V>>)` is much more efficient than\n+//! the equivalent `Vec<HashMap<K, V>>` it represents if all maps have similar\n+//! sets of keys.\n+\n+#![allow(dead_code)]\n+\n+use std::hash::Hash;\n+\n+use rustc_data_structures::fx::FxHashMap;\n+\n+/// Intermediate key between a UniKeyMap and a UniValMap.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+pub struct UniIndex {\n+    idx: u32,\n+}\n+\n+/// From K to UniIndex\n+#[derive(Debug, Clone, Default)]\n+pub struct UniKeyMap<K> {\n+    /// Underlying map that does all the hard work.\n+    /// Key invariant: the contents of `deassigned` are disjoint from the\n+    /// keys of `mapping`, and together they form the set of contiguous integers\n+    /// `0 .. (mapping.len() + deassigned.len())`.\n+    mapping: FxHashMap<K, u32>,\n+    /// Indexes that can be reused: memory gain when the map gets sparse\n+    /// due to many deletions.\n+    deassigned: Vec<u32>,\n+}\n+\n+/// From UniIndex to V\n+#[derive(Debug, Clone, PartialEq, Eq)]\n+pub struct UniValMap<V> {\n+    /// The mapping data. Thanks to Vec we get both fast accesses, and\n+    /// a memory-optimal representation if there are few deletions.\n+    data: Vec<Option<V>>,\n+}\n+\n+impl<V> Default for UniValMap<V> {\n+    fn default() -> Self {\n+        Self { data: Vec::default() }\n+    }\n+}\n+\n+impl<K> UniKeyMap<K>\n+where\n+    K: Hash + Eq,\n+{\n+    /// How many keys/index pairs are currently active.\n+    pub fn len(&self) -> usize {\n+        self.mapping.len()\n+    }\n+\n+    /// Whether this key has an associated index or not.\n+    pub fn contains_key(&self, key: &K) -> bool {\n+        self.mapping.contains_key(key)\n+    }\n+\n+    /// Assign this key to a new index. Panics if the key is already assigned,\n+    /// use `get_or_insert` for a version that instead returns the existing\n+    /// assignment.\n+    #[track_caller]\n+    pub fn insert(&mut self, key: K) -> UniIndex {\n+        // We want an unused index. First we attempt to find one from `deassigned`,\n+        // and if `deassigned` is empty we generate a fresh index.\n+        let idx = self.deassigned.pop().unwrap_or_else(|| {\n+            // `deassigned` is empty, so all keys in use are already in `mapping`.\n+            // The next available key is `mapping.len()`.\n+            self.mapping.len().try_into().expect(\"UniMap ran out of useable keys\")\n+        });\n+        if self.mapping.insert(key, idx).is_some() {\n+            panic!(\n+                \"This key is already assigned to a different index; either use `get_or_insert` instead if you care about this data, or first call `remove` to undo the preexisting assignment.\"\n+            );\n+        };\n+        UniIndex { idx }\n+    }\n+\n+    /// If it exists, the index this key maps to.\n+    pub fn get(&self, key: &K) -> Option<UniIndex> {\n+        self.mapping.get(key).map(|&idx| UniIndex { idx })\n+    }\n+\n+    /// Either get a previously existing entry, or create a new one if it\n+    /// is not yet present.\n+    pub fn get_or_insert(&mut self, key: K) -> UniIndex {\n+        self.get(&key).unwrap_or_else(|| self.insert(key))\n+    }\n+\n+    /// Return whatever index this key was using to the deassigned pool.\n+    ///\n+    /// Note: calling this function can be dangerous. If the index still exists\n+    /// somewhere in a `UniValMap` and is reassigned by the `UniKeyMap` then\n+    /// it will inherit the old value of a completely unrelated key.\n+    /// If you `UniKeyMap::remove` a key you should make sure to also `UniValMap::remove`\n+    /// the associated `UniIndex` from ALL `UniValMap`s.\n+    ///\n+    /// Example of such behavior:\n+    /// ```\n+    /// let mut keymap = UniKeyMap::<char>::default();\n+    /// let mut valmap = UniValMap::<char>::default();\n+    /// // Insert 'a' -> _ -> 'A'\n+    /// let idx_a = keymap.insert('a');\n+    /// valmap.insert(idx_a, 'A');\n+    /// // Remove 'a' -> _, but forget to remove _ -> 'A'\n+    /// keymap.remove(&'a');\n+    /// // valmap.remove(idx_a); // If we uncomment this line the issue is fixed\n+    /// // Insert 'b' -> _\n+    /// let idx_b = keymap.insert('b');\n+    /// let val_b = valmap.get(idx_b);\n+    /// assert_eq!(val_b, Some('A')); // Oh no\n+    /// // assert_eq!(val_b, None); // This is what we would have expected\n+    /// ```\n+    pub fn remove(&mut self, key: &K) {\n+        if let Some(idx) = self.mapping.remove(key) {\n+            self.deassigned.push(idx);\n+        }\n+    }\n+}\n+\n+impl<V> UniValMap<V> {\n+    /// Whether this index has an associated value.\n+    pub fn contains_idx(&self, idx: UniIndex) -> bool {\n+        self.data.get(idx.idx as usize).and_then(Option::as_ref).is_some()\n+    }\n+\n+    /// Reserve enough space to insert the value at the right index.\n+    fn extend_to_length(&mut self, len: usize) {\n+        if len > self.data.len() {\n+            let nb = len - self.data.len();\n+            self.data.reserve(nb);\n+            for _ in 0..nb {\n+                self.data.push(None);\n+            }\n+        }\n+    }\n+\n+    /// Assign a value to the index. Permanently overwrites any previous value.\n+    pub fn insert(&mut self, idx: UniIndex, val: V) {\n+        self.extend_to_length(idx.idx as usize + 1);\n+        self.data[idx.idx as usize] = Some(val)\n+    }\n+\n+    /// Get the value at this index, if it exists.\n+    pub fn get(&self, idx: UniIndex) -> Option<&V> {\n+        self.data.get(idx.idx as usize).and_then(Option::as_ref)\n+    }\n+\n+    /// Get the value at this index mutably, if it exists.\n+    pub fn get_mut(&mut self, idx: UniIndex) -> Option<&mut V> {\n+        self.data.get_mut(idx.idx as usize).and_then(Option::as_mut)\n+    }\n+\n+    /// Delete any value associated with this index. Ok even if the index\n+    /// has no associated value.\n+    pub fn remove(&mut self, idx: UniIndex) {\n+        if idx.idx as usize >= self.data.len() {\n+            return;\n+        }\n+        self.data[idx.idx as usize] = None;\n+    }\n+}\n+\n+/// An access to a single value of the map.\n+pub struct UniEntry<'a, V> {\n+    inner: &'a mut Option<V>,\n+}\n+\n+impl<'a, V> UniValMap<V> {\n+    /// Get a wrapper around a mutable access to the value corresponding to `idx`.\n+    pub fn entry(&'a mut self, idx: UniIndex) -> UniEntry<'a, V> {\n+        self.extend_to_length(idx.idx as usize + 1);\n+        UniEntry { inner: &mut self.data[idx.idx as usize] }\n+    }\n+}\n+\n+impl<'a, V> UniEntry<'a, V> {\n+    /// Insert in the map and get the value.\n+    pub fn or_insert_with<F>(&mut self, default: F) -> &mut V\n+    where\n+        F: FnOnce() -> V,\n+    {\n+        if self.inner.is_none() {\n+            *self.inner = Some(default());\n+        }\n+        self.inner.as_mut().unwrap()\n+    }\n+}\n+\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn extend_to_length() {\n+        let mut km = UniValMap::<char>::default();\n+        km.extend_to_length(10);\n+        assert!(km.data.len() == 10);\n+        km.extend_to_length(0);\n+        assert!(km.data.len() == 10);\n+        km.extend_to_length(10);\n+        assert!(km.data.len() == 10);\n+        km.extend_to_length(11);\n+        assert!(km.data.len() == 11);\n+    }\n+\n+    #[derive(Default)]\n+    struct MapWitness<K, V> {\n+        key: UniKeyMap<K>,\n+        val: UniValMap<V>,\n+        map: FxHashMap<K, V>,\n+    }\n+\n+    impl<K, V> MapWitness<K, V>\n+    where\n+        K: Copy + Hash + Eq,\n+        V: Copy + Eq + std::fmt::Debug,\n+    {\n+        fn insert(&mut self, k: K, v: V) {\n+            // UniMap\n+            let i = self.key.get_or_insert(k);\n+            self.val.insert(i, v);\n+            // HashMap\n+            self.map.insert(k, v);\n+            // Consistency: nothing to check\n+        }\n+\n+        fn get(&self, k: &K) {\n+            // UniMap\n+            let v1 = self.key.get(k).and_then(|i| self.val.get(i));\n+            // HashMap\n+            let v2 = self.map.get(k);\n+            // Consistency\n+            assert_eq!(v1, v2);\n+        }\n+\n+        fn get_mut(&mut self, k: &K) {\n+            // UniMap\n+            let v1 = self.key.get(k).and_then(|i| self.val.get_mut(i));\n+            // HashMap\n+            let v2 = self.map.get_mut(k);\n+            // Consistency\n+            assert_eq!(v1, v2);\n+        }\n+        fn remove(&mut self, k: &K) {\n+            // UniMap\n+            if let Some(i) = self.key.get(k) {\n+                self.val.remove(i);\n+            }\n+            self.key.remove(k);\n+            // HashMap\n+            self.map.remove(k);\n+            // Consistency: nothing to check\n+        }\n+    }\n+\n+    #[test]\n+    fn consistency_small() {\n+        let mut m = MapWitness::<u64, char>::default();\n+        m.insert(1, 'a');\n+        m.insert(2, 'b');\n+        m.get(&1);\n+        m.get_mut(&2);\n+        m.remove(&2);\n+        m.insert(1, 'c');\n+        m.get(&1);\n+        m.insert(3, 'd');\n+        m.insert(4, 'e');\n+        m.insert(4, 'f');\n+        m.get(&2);\n+        m.get(&3);\n+        m.get(&4);\n+        m.get(&5);\n+        m.remove(&100);\n+        m.get_mut(&100);\n+        m.get(&100);\n+    }\n+\n+    #[test]\n+    fn consistency_large() {\n+        use std::collections::hash_map::DefaultHasher;\n+        use std::hash::{Hash, Hasher};\n+        let mut hasher = DefaultHasher::new();\n+        let mut map = MapWitness::<u64, u64>::default();\n+        for i in 0..1000 {\n+            i.hash(&mut hasher);\n+            let rng = hasher.finish();\n+            let op = rng % 3 == 0;\n+            let key = (rng / 2) % 50;\n+            let val = (rng / 100) % 1000;\n+            if op {\n+                map.insert(key, val);\n+            } else {\n+                map.get(&key);\n+            }\n+        }\n+    }\n+}"}, {"sha": "3c13118122ca3f9f4eb8c16f492b7bd7c8ce652c", "filename": "src/tools/miri/src/diagnostics.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fdiagnostics.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -22,6 +22,10 @@ pub enum TerminationInfo {\n         help: Option<String>,\n         history: Option<TagHistory>,\n     },\n+    TreeBorrowsUb {\n+        msg: String,\n+        // FIXME: incomplete\n+    },\n     Int2PtrWithStrictProvenance,\n     Deadlock,\n     MultipleSymbolDefinitions {\n@@ -61,6 +65,7 @@ impl fmt::Display for TerminationInfo {\n                     \"integer-to-pointer casts and `ptr::from_exposed_addr` are not supported with `-Zmiri-strict-provenance`\"\n                 ),\n             StackedBorrowsUb { msg, .. } => write!(f, \"{msg}\"),\n+            TreeBorrowsUb { msg } => write!(f, \"{msg}\"),\n             Deadlock => write!(f, \"the evaluated program deadlocked\"),\n             MultipleSymbolDefinitions { link_name, .. } =>\n                 write!(f, \"multiple definitions of symbol `{link_name}`\"),\n@@ -184,7 +189,8 @@ pub fn report_error<'tcx, 'mir>(\n             Abort(_) => Some(\"abnormal termination\"),\n             UnsupportedInIsolation(_) | Int2PtrWithStrictProvenance =>\n                 Some(\"unsupported operation\"),\n-            StackedBorrowsUb { .. } | DataRace { .. } => Some(\"Undefined Behavior\"),\n+            StackedBorrowsUb { .. } | TreeBorrowsUb { .. } | DataRace { .. } =>\n+                Some(\"Undefined Behavior\"),\n             Deadlock => Some(\"deadlock\"),\n             MultipleSymbolDefinitions { .. } | SymbolShimClashing { .. } => None,\n         };\n@@ -212,6 +218,12 @@ pub fn report_error<'tcx, 'mir>(\n                     }\n                 }\n                 helps\n+            },\n+            TreeBorrowsUb { .. } => {\n+                let helps = vec![\n+                    (None, format!(\"this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\")),\n+                ];\n+                helps\n             }\n             MultipleSymbolDefinitions { first, first_crate, second, second_crate, .. } =>\n                 vec!["}, {"sha": "a32b18595b536355a455fed9b41b812737e0ad32", "filename": "src/tools/miri/src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Feval.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -87,7 +87,7 @@ pub struct MiriConfig {\n     pub env: Vec<(OsString, OsString)>,\n     /// Determine if validity checking is enabled.\n     pub validate: bool,\n-    /// Determines if Stacked Borrows is enabled.\n+    /// Determines if Stacked Borrows or Tree Borrows is enabled.\n     pub borrow_tracker: Option<BorrowTrackerMethod>,\n     /// Controls alignment checking.\n     pub check_alignment: AlignmentCheck,\n@@ -134,7 +134,7 @@ pub struct MiriConfig {\n     pub preemption_rate: f64,\n     /// Report the current instruction being executed every N basic blocks.\n     pub report_progress: Option<u32>,\n-    /// Whether Stacked Borrows retagging should recurse into fields of datatypes.\n+    /// Whether Stacked Borrows and Tree Borrows retagging should recurse into fields of datatypes.\n     pub retag_fields: RetagFields,\n     /// The location of a shared object file to load when calling external functions\n     /// FIXME! consider allowing users to specify paths to multiple SO files, or to a directory"}, {"sha": "01d0f01d319d0df310cd13384b8fc421a6a18ad7", "filename": "src/tools/miri/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Flib.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -95,6 +95,7 @@ pub use crate::shims::EvalContextExt as _;\n pub use crate::borrow_tracker::stacked_borrows::{\n     EvalContextExt as _, Item, Permission, Stack, Stacks,\n };\n+pub use crate::borrow_tracker::tree_borrows::{EvalContextExt as _, Tree};\n pub use crate::borrow_tracker::{\n     BorTag, BorrowTrackerMethod, CallId, EvalContextExt as _, RetagFields,\n };"}, {"sha": "eaa441d22ec9ea9e5986adc684e6e5a27877722f", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -38,7 +38,7 @@ pub const SIGRTMAX: i32 = 42;\n \n /// Extra data stored with each stack frame\n pub struct FrameExtra<'tcx> {\n-    /// Extra data for Stacked Borrows.\n+    /// Extra data for the Borrow Tracker.\n     pub borrow_tracker: Option<borrow_tracker::FrameState>,\n \n     /// If this is Some(), then this is a special \"catch unwind\" frame (the frame of `try_fn`\n@@ -146,7 +146,7 @@ impl fmt::Display for MiriMemoryKind {\n pub enum Provenance {\n     Concrete {\n         alloc_id: AllocId,\n-        /// Stacked Borrows tag.\n+        /// Borrow Tracker tag.\n         tag: BorTag,\n     },\n     Wildcard,\n@@ -195,7 +195,7 @@ impl fmt::Debug for Provenance {\n                 } else {\n                     write!(f, \"[{alloc_id:?}]\")?;\n                 }\n-                // Print Stacked Borrows tag.\n+                // Print Borrow Tracker tag.\n                 write!(f, \"{tag:?}\")?;\n             }\n             Provenance::Wildcard => {"}, {"sha": "73439133af219521c63d0b4a56f13458cb58a28b", "filename": "src/tools/miri/src/shims/foreign_items.rs", "status": "modified", "additions": 32, "deletions": 9, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fforeign_items.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -232,6 +232,19 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         }\n     }\n \n+    /// Read bytes from a `(ptr, len)` argument\n+    fn read_byte_slice<'i>(&'i self, bytes: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, &'i [u8]>\n+    where\n+        'mir: 'i,\n+    {\n+        let this = self.eval_context_ref();\n+        let (ptr, len) = this.read_immediate(bytes)?.to_scalar_pair();\n+        let ptr = ptr.to_pointer(this)?;\n+        let len = len.to_target_usize(this)?;\n+        let bytes = this.read_bytes_ptr_strip_provenance(ptr, Size::from_bytes(len))?;\n+        Ok(bytes)\n+    }\n+\n     /// Emulates calling a foreign item, failing if the item is not supported.\n     /// This function will handle `goto_block` if needed.\n     /// Returns Ok(None) if the foreign item was completely handled\n@@ -427,13 +440,27 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 })?;\n                 this.write_scalar(Scalar::from_u64(alloc_id.0.get()), dest)?;\n             }\n-            \"miri_print_borrow_stacks\" => {\n-                let [id] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+            \"miri_print_borrow_state\" => {\n+                let [id, show_unnamed] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let id = this.read_scalar(id)?.to_u64()?;\n+                let show_unnamed = this.read_scalar(show_unnamed)?.to_bool()?;\n                 if let Some(id) = std::num::NonZeroU64::new(id) {\n-                    this.print_stacks(AllocId(id))?;\n+                    this.print_borrow_state(AllocId(id), show_unnamed)?;\n                 }\n             }\n+            \"miri_pointer_name\" => {\n+                // This associates a name to a tag. Very useful for debugging, and also makes\n+                // tests more strict.\n+                let [ptr, nth_parent, name] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let ptr = this.read_pointer(ptr)?;\n+                let nth_parent = this.read_scalar(nth_parent)?.to_u8()?;\n+                let name = this.read_byte_slice(name)?;\n+                // We must make `name` owned because we need to\n+                // end the shared borrow from `read_byte_slice` before we can\n+                // start the mutable borrow for `give_pointer_debug_name`.\n+                let name = String::from_utf8_lossy(name).into_owned();\n+                this.give_pointer_debug_name(ptr, nth_parent, &name)?;\n+            }\n             \"miri_static_root\" => {\n                 let [ptr] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n                 let ptr = this.read_pointer(ptr)?;\n@@ -487,12 +514,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // Writes some bytes to the interpreter's stdout/stderr. See the\n             // README for details.\n             \"miri_write_to_stdout\" | \"miri_write_to_stderr\" => {\n-                let [bytes] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n-                let (ptr, len) = this.read_immediate(bytes)?.to_scalar_pair();\n-                let ptr = ptr.to_pointer(this)?;\n-                let len = len.to_target_usize(this)?;\n-                let msg = this.read_bytes_ptr_strip_provenance(ptr, Size::from_bytes(len))?;\n-\n+                let [msg] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n+                let msg = this.read_byte_slice(msg)?;\n                 // Note: we're ignoring errors writing to host stdout/stderr.\n                 let _ignore = match link_name.as_str() {\n                     \"miri_write_to_stdout\" => std::io::stdout().write_all(msg),"}, {"sha": "21eaeabe6ad8f6f8dfb75e7e94bad0f00e551302", "filename": "src/tools/miri/tests/compiletest.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fcompiletest.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -139,8 +139,9 @@ regexes! {\n     STDOUT:\n     // Windows file paths\n     r\"\\\\\"                           => \"/\",\n-    // erase Stacked Borrows tags\n+    // erase borrow tags\n     \"<[0-9]+>\"                      => \"<TAG>\",\n+    \"<[0-9]+=\"                      => \"<TAG=\",\n }\n \n regexes! {\n@@ -149,8 +150,9 @@ regexes! {\n     r\"\\.rs:[0-9]+:[0-9]+(: [0-9]+:[0-9]+)?\" => \".rs:LL:CC\",\n     // erase alloc ids\n     \"alloc[0-9]+\"                    => \"ALLOC\",\n-    // erase Stacked Borrows tags\n+    // erase borrow tags\n     \"<[0-9]+>\"                       => \"<TAG>\",\n+    \"<[0-9]+=\"                       => \"<TAG=\",\n     // erase whitespace that differs between platforms\n     r\" +at (.*\\.rs)\"                 => \" at $1\",\n     // erase generics in backtraces"}, {"sha": "0637e08af9bebe678df9163a94133cd466d6fc6c", "filename": "src/tools/miri/tests/fail/stacked_borrows/retag_data_race_read.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Fstacked_borrows%2Fretag_data_race_read.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,4 +1,4 @@\n-//! Make sure that a retag acts like a write for the data race model.\n+//! Make sure that a retag acts like a read for the data race model.\n //@compile-flags: -Zmiri-preemption-rate=0\n #[derive(Copy, Clone)]\n struct SendPtr(*mut u8);"}, {"sha": "122a8ff8752c5079a89d91601f4690a33cc49573", "filename": "src/tools/miri/tests/fail/tree-borrows/alternate-read-write.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,19 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+// Check that TB properly rejects alternating Reads and Writes, but tolerates\n+// alternating only Reads to Reserved mutable references.\n+pub fn main() {\n+    let x = &mut 0u8;\n+    let y = unsafe { &mut *(x as *mut u8) };\n+    // Foreign Read, but this is a no-op from the point of view of y (still Reserved)\n+    let _val = *x;\n+    // Now we activate y, for this to succeed y needs to not have been Frozen\n+    // by the previous operation\n+    *y += 1; // Success\n+    // This time y gets Frozen...\n+    let _val = *x;\n+    // ... and the next Write attempt fails.\n+    *y += 1; // Failure //~ ERROR: /write access through .* is forbidden/\n+    let _val = *x;\n+    *y += 1; // Unreachable\n+}"}, {"sha": "7c5bcd4e7b04b747f402605827405618f2c92a38", "filename": "src/tools/miri/tests/fail/tree-borrows/alternate-read-write.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Falternate-read-write.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,14 @@\n+error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+  --> $DIR/alternate-read-write.rs:LL:CC\n+   |\n+LL |     *y += 1; // Failure\n+   |     ^^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/alternate-read-write.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "215100de0a13ce0c715a193ea8f580827c5e30a1", "filename": "src/tools/miri/tests/fail/tree-borrows/fragile-data-race.rs", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,42 @@\n+//! Race-condition-like interaction between a read and a reborrow.\n+//! Even though no write or fake write occurs, reads have an effect on protected\n+//! Reserved. This is a protected-retag/read data race, but is not *detected* as\n+//! a data race violation because reborrows are not writes.\n+//!\n+//! This test is sensitive to the exact schedule so we disable preemption.\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-preemption-rate=0\n+use std::ptr::addr_of_mut;\n+use std::thread;\n+\n+#[derive(Copy, Clone)]\n+struct SendPtr(*mut u8);\n+\n+unsafe impl Send for SendPtr {}\n+\n+// First thread is just a reborrow, but for an instant `x` is\n+// protected and thus vulnerable to foreign reads.\n+fn thread_1(x: &mut u8) -> SendPtr {\n+    thread::yield_now(); // make the other thread go first\n+    SendPtr(x as *mut u8)\n+}\n+\n+// Second thread simply performs a read.\n+fn thread_2(x: &u8) {\n+    let _val = *x;\n+}\n+\n+fn main() {\n+    let mut x = 0u8;\n+    let x_1 = unsafe { &mut *addr_of_mut!(x) };\n+    let xg = unsafe { &*addr_of_mut!(x) };\n+\n+    // The two threads are executed in parallel on aliasing pointers.\n+    // UB occurs if the read of thread_2 occurs while the protector of thread_1\n+    // is in place.\n+    let hf = thread::spawn(move || thread_1(x_1));\n+    let hg = thread::spawn(move || thread_2(xg));\n+    let SendPtr(p) = hf.join().unwrap();\n+    let () = hg.join().unwrap();\n+\n+    unsafe { *p = 1 }; //~ ERROR: /write access through .* is forbidden/\n+}"}, {"sha": "a078d18d3b02bfafd7729f6d5413350608f84415", "filename": "src/tools/miri/tests/fail/tree-borrows/fragile-data-race.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Ffragile-data-race.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,14 @@\n+error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+  --> $DIR/fragile-data-race.rs:LL:CC\n+   |\n+LL |     unsafe { *p = 1 };\n+   |              ^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/fragile-data-race.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "8450e1c168d9a86dbe5f9003d4d1a81fd185a623", "filename": "src/tools/miri/tests/fail/tree-borrows/outside-range.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,22 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+// Check that in the case of locations outside the range of a pointer,\n+// protectors trigger if and only if the location has already been accessed\n+fn main() {\n+    unsafe {\n+        let data = &mut [0u8, 1, 2, 3];\n+        let raw = data.as_mut_ptr();\n+        stuff(&mut *raw, raw);\n+    }\n+}\n+\n+unsafe fn stuff(x: &mut u8, y: *mut u8) {\n+    let xraw = x as *mut u8;\n+    // No issue here: location 1 is not accessed\n+    *y.add(1) = 42;\n+    // Still no issue: location 2 is not invalidated\n+    let _val = *xraw.add(2);\n+    // However protector triggers if location is both accessed and invalidated\n+    let _val = *xraw.add(3);\n+    *y.add(3) = 42; //~ ERROR: /write access through .* is forbidden/\n+}"}, {"sha": "4396c63679e105c806022f17d299df370e1dc740", "filename": "src/tools/miri/tests/fail/tree-borrows/outside-range.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Foutside-range.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,19 @@\n+error: Undefined Behavior: write access through <TAG> is forbidden because it is a foreign tag for <TAG>, which would hence change from Reserved to Disabled, but <TAG> is protected\n+  --> $DIR/outside-range.rs:LL:CC\n+   |\n+LL |     *y.add(3) = 42;\n+   |     ^^^^^^^^^^^^^^ write access through <TAG> is forbidden because it is a foreign tag for <TAG>, which would hence change from Reserved to Disabled, but <TAG> is protected\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = note: BACKTRACE:\n+   = note: inside `stuff` at $DIR/outside-range.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/outside-range.rs:LL:CC\n+   |\n+LL |         stuff(&mut *raw, raw);\n+   |         ^^^^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "025b7ad22dc347f540ccf97345b0a1f3feddce58", "filename": "src/tools/miri/tests/fail/tree-borrows/read-to-local.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,14 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+// Read to local variable kills reborrows *and* raw pointers derived from them.\n+// This test would succeed under Stacked Borrows.\n+fn main() {\n+    unsafe {\n+        let mut root = 6u8;\n+        let mref = &mut root;\n+        let ptr = mref as *mut u8;\n+        *ptr = 0; // Write\n+        assert_eq!(root, 0); // Parent Read\n+        *ptr = 0; //~ ERROR: /write access through .* is forbidden/\n+    }\n+}"}, {"sha": "7d9367c87d051a331ae15a621c4bc6146b7aea51", "filename": "src/tools/miri/tests/fail/tree-borrows/read-to-local.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fread-to-local.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,14 @@\n+error: Undefined Behavior: write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+  --> $DIR/read-to-local.rs:LL:CC\n+   |\n+LL |         *ptr = 0;\n+   |         ^^^^^^^^ write access through <TAG> is forbidden because it is a child of <TAG> which is Frozen.\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = note: BACKTRACE:\n+   = note: inside `main` at $DIR/read-to-local.rs:LL:CC\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "872efe3ad5933cd02245f75f25aa0f3c57918062", "filename": "src/tools/miri/tests/fail/tree-borrows/reserved/cell-protected-write.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,34 @@\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-tag-gc=0\n+\n+// Check how a Reserved with interior mutability\n+// responds to a Foreign Write under a Protector\n+#[path = \"../../../utils/mod.rs\"]\n+mod utils;\n+use utils::macros::*;\n+\n+use std::cell::UnsafeCell;\n+\n+fn main() {\n+    unsafe {\n+        let n = &mut UnsafeCell::new(0u8);\n+        name!(n.get(), \"base\");\n+        let x = &mut *(n as *mut UnsafeCell<_>);\n+        name!(x.get(), \"x\");\n+        let y = (&mut *n).get();\n+        name!(y);\n+        write_second(x, y);\n+        unsafe fn write_second(x: &mut UnsafeCell<u8>, y: *mut u8) {\n+            let alloc_id = alloc_id!(x.get());\n+            name!(x.get(), \"callee:x\");\n+            name!(x.get()=>1, \"caller:x\");\n+            name!(y, \"callee:y\");\n+            name!(y, \"caller:y\");\n+            print_state!(alloc_id);\n+            // Right before the faulty Write, x is\n+            // - Reserved\n+            // - with interior mut\n+            // - Protected\n+            *y = 1; //~ ERROR: /write access through .* is forbidden/\n+        }\n+    }\n+}"}, {"sha": "8ae1c09470a57e0f01572f46db8313d926e91387", "filename": "src/tools/miri/tests/fail/tree-borrows/reserved/cell-protected-write.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fcell-protected-write.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,28 @@\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Re*|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Re*|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y,callee:y,caller:y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+error: Undefined Behavior: write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+  --> $DIR/cell-protected-write.rs:LL:CC\n+   |\n+LL |             *y = 1;\n+   |             ^^^^^^ write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = note: BACKTRACE:\n+   = note: inside `main::write_second` at $DIR/cell-protected-write.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/cell-protected-write.rs:LL:CC\n+   |\n+LL |         write_second(x, y);\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "3a1205a84f7264ca724b7f271b201893a3610763", "filename": "src/tools/miri/tests/fail/tree-borrows/reserved/int-protected-write.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,32 @@\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-tag-gc=0\n+\n+#[path = \"../../../utils/mod.rs\"]\n+mod utils;\n+use utils::macros::*;\n+\n+// Check how a Reserved without interior mutability responds to a Foreign\n+// Write when under a protector\n+fn main() {\n+    unsafe {\n+        let n = &mut 0u8;\n+        name!(n);\n+        let x = &mut *(n as *mut _);\n+        name!(x);\n+        let y = (&mut *n) as *mut _;\n+        name!(y);\n+        write_second(x, y);\n+        unsafe fn write_second(x: &mut u8, y: *mut u8) {\n+            let alloc_id = alloc_id!(x);\n+            name!(x, \"callee:x\");\n+            name!(x=>1, \"caller:x\");\n+            name!(y, \"callee:y\");\n+            name!(y, \"caller:y\");\n+            print_state!(alloc_id);\n+            // Right before the faulty Write, x is\n+            // - Reserved\n+            // - Protected\n+            // The Write turns it Disabled\n+            *y = 0; //~ ERROR: /write access through .* is forbidden/\n+        }\n+    }\n+}"}, {"sha": "a199fc0f0dacc62f74fc882d01f7a000959496e1", "filename": "src/tools/miri/tests/fail/tree-borrows/reserved/int-protected-write.stderr", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Freserved%2Fint-protected-write.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,28 @@\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=n>\n+| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y,callee:y,caller:y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+error: Undefined Behavior: write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+  --> $DIR/int-protected-write.rs:LL:CC\n+   |\n+LL |             *y = 0;\n+   |             ^^^^^^ write access through <TAG> (also named 'y,callee:y,caller:y') is forbidden because it is a foreign tag for <TAG> (also named 'callee:x'), which would hence change from Reserved to Disabled, but <TAG> (also named 'callee:x') is protected\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = note: BACKTRACE:\n+   = note: inside `main::write_second` at $DIR/int-protected-write.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/int-protected-write.rs:LL:CC\n+   |\n+LL |         write_second(x, y);\n+   |         ^^^^^^^^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "8ef3d23e804b7f474a66709ef5b98ddc9e30822a", "filename": "src/tools/miri/tests/fail/tree-borrows/retag-data-race.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fretag-data-race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fretag-data-race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fretag-data-race.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,28 @@\n+//! Make sure that a retag acts like a read for the data race model.\n+//! This is a retag/write race condition.\n+//!\n+//! This test is sensitive to the exact schedule so we disable preemption.\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-preemption-rate=0\n+#[derive(Copy, Clone)]\n+struct SendPtr(*mut u8);\n+\n+unsafe impl Send for SendPtr {}\n+\n+unsafe fn thread_1(SendPtr(p): SendPtr) {\n+    let _r = &*p;\n+}\n+\n+unsafe fn thread_2(SendPtr(p): SendPtr) {\n+    *p = 5; //~ ERROR: Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>`\n+}\n+\n+fn main() {\n+    let mut x = 0;\n+    let p = std::ptr::addr_of_mut!(x);\n+    let p = SendPtr(p);\n+\n+    let t1 = std::thread::spawn(move || unsafe { thread_1(p) });\n+    let t2 = std::thread::spawn(move || unsafe { thread_2(p) });\n+    let _ = t1.join();\n+    let _ = t2.join();\n+}"}, {"sha": "f2cdfe7c314d5bfbf23bd008036a52a376a3e503", "filename": "src/tools/miri/tests/fail/tree-borrows/retag-data-race.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fretag-data-race.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fretag-data-race.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fretag-data-race.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,25 @@\n+error: Undefined Behavior: Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n+  --> $DIR/retag-data-race.rs:LL:CC\n+   |\n+LL |     *p = 5;\n+   |     ^^^^^^ Data race detected between (1) Read on thread `<unnamed>` and (2) Write on thread `<unnamed>` at ALLOC. (2) just happened here\n+   |\n+help: and (1) occurred earlier here\n+  --> $DIR/retag-data-race.rs:LL:CC\n+   |\n+LL |     let _r = &*p;\n+   |              ^^^\n+   = help: this indicates a bug in the program: it performed an invalid operation, and caused Undefined Behavior\n+   = help: see https://doc.rust-lang.org/nightly/reference/behavior-considered-undefined.html for further information\n+   = note: BACKTRACE (of the first span):\n+   = note: inside `thread_2` at $DIR/retag-data-race.rs:LL:CC\n+note: inside closure\n+  --> $DIR/retag-data-race.rs:LL:CC\n+   |\n+LL |     let t2 = std::thread::spawn(move || unsafe { thread_2(p) });\n+   |                                                  ^^^^^^^^^^^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "6695d36306bc3893fe27e080f31842b72a3afb10", "filename": "src/tools/miri/tests/fail/tree-borrows/write-during-2phase.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,27 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+// We invalidate a reference during a 2-phase borrow by doing a Foreign\n+// Write in between the initial reborrow and function entry. UB occurs\n+// on function entry when reborrow from a Disabled fails.\n+// This test would pass under Stacked Borrows, but Tree Borrows\n+// is more strict on 2-phase borrows.\n+\n+struct Foo(u64);\n+impl Foo {\n+    #[rustfmt::skip] // rustfmt is wrong about which line contains an error\n+    fn add(&mut self, n: u64) -> u64 { //~ ERROR: /read access through .* is forbidden/\n+        self.0 + n\n+    }\n+}\n+\n+pub fn main() {\n+    let mut f = Foo(0);\n+    let inner = &mut f.0 as *mut u64;\n+    let _res = f.add(unsafe {\n+        let n = f.0;\n+        // This is the access at fault, but it's not immediately apparent because\n+        // the reference that got invalidated is not under a Protector.\n+        *inner = 42;\n+        n\n+    });\n+}"}, {"sha": "e511eb9cf8fbb816a2ccb4eb0dd043474bb1a8e4", "filename": "src/tools/miri/tests/fail/tree-borrows/write-during-2phase.stderr", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Ffail%2Ftree-borrows%2Fwrite-during-2phase.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,26 @@\n+error: Undefined Behavior: read access through <TAG> is forbidden because it is a child of <TAG> which is Disabled.\n+  --> $DIR/write-during-2phase.rs:LL:CC\n+   |\n+LL |     fn add(&mut self, n: u64) -> u64 {\n+   |            ^^^^^^^^^ read access through <TAG> is forbidden because it is a child of <TAG> which is Disabled.\n+   |\n+   = help: this indicates a potential bug in the program: it performed an invalid operation, but the Tree Borrows rules it violated are still experimental\n+   = note: BACKTRACE:\n+   = note: inside `Foo::add` at $DIR/write-during-2phase.rs:LL:CC\n+note: inside `main`\n+  --> $DIR/write-during-2phase.rs:LL:CC\n+   |\n+LL |       let _res = f.add(unsafe {\n+   |  ________________^\n+LL | |         let n = f.0;\n+LL | |         // This is the access at fault, but it's not immediately apparent because\n+LL | |         // the reference that got invalidated is not under a Protector.\n+LL | |         *inner = 42;\n+LL | |         n\n+LL | |     });\n+   | |______^\n+\n+note: some details are omitted, run with `MIRIFLAGS=-Zmiri-backtrace=full` for a verbose backtrace\n+\n+error: aborting due to previous error\n+"}, {"sha": "cbf41d68b57424ba5ad80fde675e73d7148f4687", "filename": "src/tools/miri/tests/pass/adjacent-allocs.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fadjacent-allocs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fadjacent-allocs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fadjacent-allocs.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-permissive-provenance\n \n fn ensure_allocs_can_be_adjacent() {"}, {"sha": "331fbfcefde15919f2eec770c0828649b6ee1269", "filename": "src/tools/miri/tests/pass/associated-const.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fassociated-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fassociated-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fassociated-const.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n trait Foo {\n     const ID: i32;\n }"}, {"sha": "662b90150886dcac26fde211802226bfc64fa9b5", "filename": "src/tools/miri/tests/pass/assume_bug.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fassume_bug.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fassume_bug.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fassume_bug.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n fn main() {\n     vec![()].into_iter();\n }"}, {"sha": "60b8ff87b59e31b1b420733cfcc457ce9afa9f88", "filename": "src/tools/miri/tests/pass/atomic.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fatomic.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n #![feature(strict_provenance, strict_provenance_atomic_ptr)]\n use std::sync::atomic::{"}, {"sha": "77fb78424ba2dadd6e13525a2554e5cc29bafdda", "filename": "src/tools/miri/tests/pass/available-parallelism.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Favailable-parallelism.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Favailable-parallelism.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Favailable-parallelism.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n fn main() {\n     assert_eq!(std::thread::available_parallelism().unwrap().get(), 1);\n }"}, {"sha": "155e3d74ab9c13e6258196f82facf934674c4e8f", "filename": "src/tools/miri/tests/pass/box-custom-alloc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox-custom-alloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox-custom-alloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox-custom-alloc.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n #![allow(incomplete_features)] // for trait upcasting\n #![feature(allocator_api, trait_upcasting)]\n "}, {"sha": "3bb481aab888ac6c37f6900cb2173e9918157525", "filename": "src/tools/miri/tests/pass/box.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows -Zmiri-permissive-provenance\n #![feature(ptr_internals)]\n \n fn main() {"}, {"sha": "4c2fb40e1102179641d96233433afc38aedb4b8b", "filename": "src/tools/miri/tests/pass/box.stack.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.stack.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "previous_filename": "src/tools/miri/tests/pass/box.stderr"}, {"sha": "230ef368da64494e27dc048cf97e96fa24b00da9", "filename": "src/tools/miri/tests/pass/box.stack.stdout", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.stack.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.stack.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.stack.stdout?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "previous_filename": "src/tools/miri/tests/pass/box.stdout"}, {"sha": "230ef368da64494e27dc048cf97e96fa24b00da9", "filename": "src/tools/miri/tests/pass/box.tree.stdout", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.tree.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.tree.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbox.tree.stdout?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,3 @@\n+pair_foo = PairFoo { fst: Foo(42), snd: Foo(1337) }\n+foo #0 = Foo(42)\n+foo #1 = Foo(1337)"}, {"sha": "b7c0406becc4dd590b13031418c5d0b445800142", "filename": "src/tools/miri/tests/pass/btreemap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbtreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbtreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fbtreemap.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n #![feature(btree_drain_filter)]\n use std::collections::{BTreeMap, BTreeSet};"}, {"sha": "ccf96b9967202c085c31a3ee7042ed17d03e5d20", "filename": "src/tools/miri/tests/pass/cast-rfc0401-vtable-kinds.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fcast-rfc0401-vtable-kinds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fcast-rfc0401-vtable-kinds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fcast-rfc0401-vtable-kinds.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n // Check that you can cast between different pointers to trait objects\n // whose vtable have the same kind (both lengths, or both trait pointers).\n "}, {"sha": "43086756b035f40fc44e288f777b6423dd9fc02a", "filename": "src/tools/miri/tests/pass/concurrency/channels.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fchannels.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n \n use std::sync::mpsc::{channel, sync_channel};"}, {"sha": "3bd1e542407056e48605fa55a4ebe6d99fa12802", "filename": "src/tools/miri/tests/pass/concurrency/sync.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-disable-isolation -Zmiri-strict-provenance\n \n use std::sync::{Arc, Barrier, Condvar, Mutex, Once, RwLock};"}, {"sha": "f2c036a1735eda7186df3a4b5249b8fc8abe5896", "filename": "src/tools/miri/tests/pass/concurrency/sync.stack.stdout", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.stack.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.stack.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.stack.stdout?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "previous_filename": "src/tools/miri/tests/pass/concurrency/sync.stdout"}, {"sha": "f2c036a1735eda7186df3a4b5249b8fc8abe5896", "filename": "src/tools/miri/tests/pass/concurrency/sync.tree.stdout", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.tree.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.tree.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fsync.tree.stdout?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,20 @@\n+before wait\n+before wait\n+before wait\n+before wait\n+before wait\n+before wait\n+before wait\n+before wait\n+before wait\n+before wait\n+after wait\n+after wait\n+after wait\n+after wait\n+after wait\n+after wait\n+after wait\n+after wait\n+after wait\n+after wait"}, {"sha": "13c11b55775ced421a3e1ff7058e3bd39f4a4364", "filename": "src/tools/miri/tests/pass/concurrency/thread_locals.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Fthread_locals.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n \n //! The main purpose of this test is to check that if we take a pointer to"}, {"sha": "bd06eec9cd5411ce0ba92cffb2d99c62b91e7f17", "filename": "src/tools/miri/tests/pass/concurrency/tls_lib_drop.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,6 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n+\n use std::cell::RefCell;\n use std::thread;\n "}, {"sha": "b7877820a0ca9760b42136ff92decd1fa7fd57db", "filename": "src/tools/miri/tests/pass/concurrency/tls_lib_drop.stack.stdout", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stack.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stack.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.stack.stdout?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "previous_filename": "src/tools/miri/tests/pass/concurrency/tls_lib_drop.stdout"}, {"sha": "b7877820a0ca9760b42136ff92decd1fa7fd57db", "filename": "src/tools/miri/tests/pass/concurrency/tls_lib_drop.tree.stdout", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.tree.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.tree.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fconcurrency%2Ftls_lib_drop.tree.stdout?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,5 @@\n+Dropping: 8 (should be before 'Continue main 1').\n+Dropping: 8 (should be before 'Continue main 1').\n+Continue main 1.\n+Joining: 7 (should be before 'Continue main 2').\n+Continue main 2."}, {"sha": "fdcacc6cea41cebc9fbe04ac5f344c4207110ee5", "filename": "src/tools/miri/tests/pass/disable-alignment-check.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdisable-alignment-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdisable-alignment-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdisable-alignment-check.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-disable-alignment-check\n \n fn main() {"}, {"sha": "94cf465e884d1e135bd98e448247f963af6e723f", "filename": "src/tools/miri/tests/pass/dyn-arbitrary-self.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fdyn-arbitrary-self.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n #![feature(arbitrary_self_types, unsize, coerce_unsized, dispatch_from_dyn)]\n #![feature(rustc_attrs)]\n "}, {"sha": "7ac93577f0cd5887cb593ff5ef808a39dbb6d97d", "filename": "src/tools/miri/tests/pass/extern_types.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fextern_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fextern_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fextern_types.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows -Zmiri-permissive-provenance\n #![feature(extern_types)]\n \n extern \"C\" {"}, {"sha": "2e18f69305896f27c73293a8e5b262851c3ab35f", "filename": "src/tools/miri/tests/pass/extern_types.stack.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fextern_types.stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fextern_types.stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fextern_types.stack.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "previous_filename": "src/tools/miri/tests/pass/extern_types.stderr"}, {"sha": "763eceeb6f0f7d382a4b83d871eed854d33551e7", "filename": "src/tools/miri/tests/pass/future-self-referential.rs", "status": "renamed", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ffuture-self-referential.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ffuture-self-referential.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ffuture-self-referential.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,6 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n+\n use std::future::*;\n use std::marker::PhantomPinned;\n use std::pin::*;", "previous_filename": "src/tools/miri/tests/pass/stacked-borrows/future-self-referential.rs"}, {"sha": "e059c7114e395bc69e5c1ab0f754f71cd83268fc", "filename": "src/tools/miri/tests/pass/generator.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fgenerator.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n #![feature(generators, generator_trait, never_type)]\n \n use std::fmt::Debug;"}, {"sha": "7224e357c6f856e04111a55be3a0a176d7b5580b", "filename": "src/tools/miri/tests/pass/hashmap.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fhashmap.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n use std::collections::HashMap;\n use std::hash::BuildHasher;\n "}, {"sha": "42b6f433420b6a9c4e32cea557618aabaa333b5e", "filename": "src/tools/miri/tests/pass/intptrcast.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fintptrcast.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-permissive-provenance\n \n use std::mem;"}, {"sha": "36df30070cb50952a07fe03a937ce79ef4e50ebc", "filename": "src/tools/miri/tests/pass/linked-list.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Flinked-list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Flinked-list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Flinked-list.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n #![feature(linked_list_cursors)]\n use std::collections::LinkedList;\n "}, {"sha": "aa960aa147abe76df31708108c7d8f0b75c8de96", "filename": "src/tools/miri/tests/pass/many_shr_bor.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmany_shr_bor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmany_shr_bor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmany_shr_bor.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n // Make sure validation can handle many overlapping shared borrows for different parts of a data structure\n use std::cell::RefCell;\n "}, {"sha": "bba3207ee4cf1ef57de7d2848568a4c45d383105", "filename": "src/tools/miri/tests/pass/memleak_ignored.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmemleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmemleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fmemleak_ignored.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-ignore-leaks\n \n fn main() {"}, {"sha": "0ba6607a5d442ff640f9608efd7125f4958fd17b", "filename": "src/tools/miri/tests/pass/option_box_transmute_ptr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Foption_box_transmute_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Foption_box_transmute_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Foption_box_transmute_ptr.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n // This tests that the size of Option<Box<i32>> is the same as *const i32.\n fn option_box_deref() -> i32 {\n     let val = Some(Box::new(42));"}, {"sha": "1525ded6151e83d9774d49c5f6efbbaefb10d13a", "filename": "src/tools/miri/tests/pass/pointers.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpointers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpointers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fpointers.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-permissive-provenance\n #![feature(ptr_metadata, const_raw_ptr_comparison)]\n "}, {"sha": "835daa36cfc04d90c3ba336f031284ace3ebcd89", "filename": "src/tools/miri/tests/pass/provenance.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fprovenance.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n #![feature(strict_provenance)]\n #![feature(pointer_byte_offsets)]\n use std::{mem, ptr};"}, {"sha": "a2fcd098107a675b5d8680ef47321f35a9878f76", "filename": "src/tools/miri/tests/pass/ptr_int_casts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_casts.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-permissive-provenance\n use std::mem;\n use std::ptr;"}, {"sha": "35a52d0220b819e1b1d80c2427b1794a3f27deb2", "filename": "src/tools/miri/tests/pass/ptr_int_from_exposed.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_from_exposed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_from_exposed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_from_exposed.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-permissive-provenance\n #![feature(strict_provenance)]\n "}, {"sha": "d99c25413e640d92f84ac3de08ea0331d51b87ec", "filename": "src/tools/miri/tests/pass/ptr_int_transmute.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_transmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_transmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fptr_int_transmute.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n // Test what happens when we read parts of a pointer.\n // Related to <https://github.com/rust-lang/rust/issues/69488>.\n fn ptr_partial_read() {"}, {"sha": "6375abcd2328694e9aa35cdadc6026b12135c9ab", "filename": "src/tools/miri/tests/pass/rc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Frc.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n #![feature(new_uninit)]\n #![feature(get_mut_unchecked)]"}, {"sha": "458312508d2ec1cdf13cffb833441c729f353d3f", "filename": "src/tools/miri/tests/pass/send-is-not-static-par-for.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fsend-is-not-static-par-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fsend-is-not-static-par-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fsend-is-not-static-par-for.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n use std::sync::Mutex;\n \n fn par_for<I, F>(iter: I, f: F)"}, {"sha": "a99e921150b310d3405a1e4fc6d8f54ac4401ddb", "filename": "src/tools/miri/tests/pass/slices.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fslices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fslices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fslices.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n #![feature(new_uninit)]\n #![feature(slice_as_chunks)]"}, {"sha": "74761a89cb94a4b4937014b1c36c981dd22bd202", "filename": "src/tools/miri/tests/pass/stacked-borrows/stack-printing.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fstacked-borrows%2Fstack-printing.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -7,15 +7,17 @@ use std::{\n \n extern \"Rust\" {\n     fn miri_get_alloc_id(ptr: *const u8) -> u64;\n-    fn miri_print_borrow_stacks(alloc_id: u64);\n+    fn miri_print_borrow_state(alloc_id: u64, show_unnamed: bool);\n }\n \n fn get_alloc_id(ptr: *const u8) -> u64 {\n     unsafe { miri_get_alloc_id(ptr) }\n }\n \n fn print_borrow_stacks(alloc_id: u64) {\n-    unsafe { miri_print_borrow_stacks(alloc_id) }\n+    unsafe {\n+        miri_print_borrow_state(alloc_id, /* ignored: show_unnamed */ false)\n+    }\n }\n \n fn main() {"}, {"sha": "d48998561948707ce0954e7bdb735539d14b3976", "filename": "src/tools/miri/tests/pass/threadleak_ignored.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-ignore-leaks\n \n //! Test that leaking threads works, and that their destructors are not executed."}, {"sha": "7557f49c7584b93e56e57c3fbf20be12f7b96748", "filename": "src/tools/miri/tests/pass/threadleak_ignored.stack.stderr", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.stack.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.stack.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.stack.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "previous_filename": "src/tools/miri/tests/pass/threadleak_ignored.stderr"}, {"sha": "7557f49c7584b93e56e57c3fbf20be12f7b96748", "filename": "src/tools/miri/tests/pass/threadleak_ignored.tree.stderr", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.tree.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.tree.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fthreadleak_ignored.tree.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1 @@\n+Dropping 0"}, {"sha": "ce6d86b7068a0a33d0f7dc599bb807766593b1c4", "filename": "src/tools/miri/tests/pass/transmute_ptr.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftransmute_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftransmute_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftransmute_ptr.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n #![feature(strict_provenance)]\n use std::{mem, ptr};\n "}, {"sha": "af52f53791a4fab165bcf72302ac5bcd6247b52d", "filename": "src/tools/miri/tests/pass/tree-borrows/2phase-interiormut.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2F2phase-interiormut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2F2phase-interiormut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2F2phase-interiormut.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,27 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+// Counterpart to tests/fail/tree-borrows/write-during-2phase.rs,\n+// this is the opposite situation: the Write is not problematic because\n+// the Protector has not yet been added and the Reserved has interior\n+// mutability.\n+use core::cell::Cell;\n+\n+trait Thing: Sized {\n+    fn do_the_thing(&mut self, _s: i32) {}\n+}\n+impl<T> Thing for Cell<T> {}\n+\n+fn main() {\n+    let mut x = Cell::new(1);\n+    let l = &x;\n+\n+    x.do_the_thing({\n+        // Several Foreign accesses (both Reads and Writes) to the location\n+        // being reborrowed. Reserved + unprotected + interior mut\n+        // makes the pointer immune to everything as long as all accesses\n+        // are child accesses to its parent pointer x.\n+        x.set(3);\n+        l.set(4);\n+        x.get() + l.get()\n+    });\n+}"}, {"sha": "1bd94c6df67c806a30bb2e162afc99692f8f9842", "filename": "src/tools/miri/tests/pass/tree-borrows/cell-alternate-writes.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,27 @@\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-tag-gc=0\n+#[path = \"../../utils/mod.rs\"]\n+mod utils;\n+use utils::macros::*;\n+\n+use std::cell::UnsafeCell;\n+\n+// UnsafeCells use the parent tag, so it is possible to use them with\n+// few restrictions when only among themselves.\n+fn main() {\n+    unsafe {\n+        let data = &mut UnsafeCell::new(0u8);\n+        name!(data.get(), \"data\");\n+        let x = &*data;\n+        name!(x.get(), \"x\");\n+        let y = &*data;\n+        name!(y.get(), \"y\");\n+        let alloc_id = alloc_id!(data.get());\n+        print_state!(alloc_id);\n+        // y and x tolerate alternating Writes\n+        *y.get() = 1;\n+        *x.get() = 2;\n+        *y.get() = 3;\n+        *x.get() = 4;\n+        print_state!(alloc_id);\n+    }\n+}"}, {"sha": "d4bc822b4bb064e368701d4e4e543722489c7ed0", "filename": "src/tools/miri/tests/pass/tree-borrows/cell-alternate-writes.stderr", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcell-alternate-writes.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,10 @@\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Re*|    \u2514\u2500\u2500\u2500\u2500<TAG=data,x,y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Act|    \u2514\u2500\u2500\u2500\u2500<TAG=data,x,y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "23250d6e6dfc5cb77c8de12273cbb61116d49e03", "filename": "src/tools/miri/tests/pass/tree-borrows/copy-nonoverlapping.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcopy-nonoverlapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcopy-nonoverlapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fcopy-nonoverlapping.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,29 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+// copy_nonoverlapping works regardless of the order in which we construct\n+// the arguments.\n+pub fn main() {\n+    test_to_from();\n+    test_from_to();\n+}\n+\n+fn test_to_from() {\n+    unsafe {\n+        let data = &mut [0u64, 1];\n+        let to = data.as_mut_ptr().add(1);\n+        let from = data.as_ptr();\n+        std::ptr::copy_nonoverlapping(from, to, 1);\n+    }\n+}\n+\n+// Stacked Borrows would not have liked this one because the `as_mut_ptr` reborrow\n+// invalidates the earlier pointer obtained from `as_ptr`, but Tree Borrows is fine\n+// with it.\n+fn test_from_to() {\n+    unsafe {\n+        let data = &mut [0u64, 1];\n+        let from = data.as_ptr();\n+        let to = data.as_mut_ptr().add(1);\n+        std::ptr::copy_nonoverlapping(from, to, 1);\n+    }\n+}"}, {"sha": "76bbc73e662d384ba1de58915dbe43c6f52835b0", "filename": "src/tools/miri/tests/pass/tree-borrows/end-of-protector.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,32 @@\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-tag-gc=0\n+\n+// Check that a protector goes back to normal behavior when the function\n+// returns.\n+#[path = \"../../utils/mod.rs\"]\n+mod utils;\n+use utils::macros::*;\n+\n+fn main() {\n+    unsafe {\n+        let data = &mut 0u8;\n+        name!(data);\n+        let alloc_id = alloc_id!(data);\n+        let x = &mut *data;\n+        name!(x);\n+        print_state!(alloc_id);\n+        do_nothing(x); // creates then removes a Protector for a child of x\n+        let y = &mut *data;\n+        name!(y);\n+        print_state!(alloc_id);\n+        // Invalidates the previous reborrow, but its Protector has been removed.\n+        *y = 1;\n+        print_state!(alloc_id);\n+    }\n+}\n+\n+unsafe fn do_nothing(x: &mut u8) {\n+    name!(x, \"callee:x\");\n+    name!(x=>1, \"caller:x\");\n+    let alloc_id = alloc_id!(x);\n+    print_state!(alloc_id);\n+}"}, {"sha": "d08d69483203bb1b367360609a8478a1c433d060", "filename": "src/tools/miri/tests/pass/tree-borrows/end-of-protector.stderr", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fend-of-protector.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,32 @@\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=x>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|      \u2514\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|        \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|          \u2514\u2500\u2500\u2500\u2500<TAG=callee:x> Strongly protected\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Res|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+| Dis|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Dis|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Dis|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "9021c4176383b1c53764d6d5e37f51330a1dfbf9", "filename": "src/tools/miri/tests/pass/tree-borrows/formatting.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,73 @@\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-tag-gc=0\n+\n+#[path = \"../../utils/mod.rs\"]\n+mod utils;\n+use utils::macros::*;\n+\n+// Check the formatting of the trees.\n+fn main() {\n+    unsafe {\n+        alignment_check();\n+        structure_check();\n+    }\n+}\n+\n+// Alignment check: we split the array at indexes with different amounts of\n+// decimal digits to verify proper padding.\n+unsafe fn alignment_check() {\n+    let data: &mut [u8] = &mut [0; 1024];\n+    name!(data.as_ptr()=>2, \"data\");\n+    let alloc_id = alloc_id!(data.as_ptr());\n+    let x = &mut data[1];\n+    name!(x as *mut _, \"data[1]\");\n+    *x = 1;\n+    let x = &mut data[10];\n+    name!(x as *mut _, \"data[10]\");\n+    *x = 1;\n+    let x = &mut data[100];\n+    name!(x as *mut _, \"data[100]\");\n+    *x = 1;\n+    let _val = data[100]; // So that the above is Frz\n+    let x = &mut data[1000];\n+    name!(x as *mut _, \"data[1000]\");\n+    *x = 1;\n+    print_state!(alloc_id);\n+}\n+\n+// Tree structure check: somewhat complex organization of reborrows.\n+unsafe fn structure_check() {\n+    let x = &0u8;\n+    name!(x);\n+    let xa = &*x;\n+    name!(xa);\n+    let xb = &*x;\n+    name!(xb);\n+    let xc = &*x;\n+    name!(xc);\n+    let xaa = &*xa;\n+    name!(xaa);\n+    let xab = &*xa;\n+    name!(xab);\n+    let xba = &*xb;\n+    name!(xba);\n+    let xbaa = &*xba;\n+    name!(xbaa);\n+    let xbaaa = &*xbaa;\n+    name!(xbaaa);\n+    let xbaaaa = &*xbaaa;\n+    name!(xbaaaa);\n+    let xca = &*xc;\n+    name!(xca);\n+    let xcb = &*xc;\n+    name!(xcb);\n+    let xcaa = &*xca;\n+    name!(xcaa);\n+    let xcab = &*xca;\n+    name!(xcab);\n+    let xcba = &*xcb;\n+    name!(xcba);\n+    let xcbb = &*xcb;\n+    name!(xcbb);\n+    let alloc_id = alloc_id!(x);\n+    print_state!(alloc_id);\n+}"}, {"sha": "a59775cf21f10002f62f3a81c42cba749de9bcbb", "filename": "src/tools/miri/tests/pass/tree-borrows/formatting.stderr", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fformatting.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,29 @@\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1..  2.. 10.. 11..100..101..1000..1001..1024\n+| Res| Act| Res| Act| Res| Act|  Res|  Act|  Res|    \u2514\u2500\u252c\u2500\u2500<TAG=data>\n+|----| Act|----|?Dis|----|?Dis| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[1]>\n+|----|----|----| Act|----|?Dis| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[10]>\n+|----|----|----|----|----| Frz| ----| ?Dis| ----|      \u251c\u2500\u2500\u2500\u2500<TAG=data[100]>\n+|----|----|----|----|----|----| ----|  Act| ----|      \u2514\u2500\u2500\u2500\u2500<TAG=data[1000]>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Frz|    \u2514\u2500\u252c\u2500\u2500<TAG=x>\n+| Frz|      \u251c\u2500\u252c\u2500\u2500<TAG=xa>\n+| Frz|      \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xaa>\n+| Frz|      \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xab>\n+| Frz|      \u251c\u2500\u252c\u2500\u2500<TAG=xb>\n+| Frz|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=xba>\n+| Frz|      \u2502   \u2514\u2500\u252c\u2500\u2500<TAG=xbaa>\n+| Frz|      \u2502     \u2514\u2500\u252c\u2500\u2500<TAG=xbaaa>\n+| Frz|      \u2502       \u2514\u2500\u2500\u2500\u2500<TAG=xbaaaa>\n+| Frz|      \u2514\u2500\u252c\u2500\u2500<TAG=xc>\n+| Frz|        \u251c\u2500\u252c\u2500\u2500<TAG=xca>\n+| Frz|        \u2502 \u251c\u2500\u2500\u2500\u2500<TAG=xcaa>\n+| Frz|        \u2502 \u2514\u2500\u2500\u2500\u2500<TAG=xcab>\n+| Frz|        \u2514\u2500\u252c\u2500\u2500<TAG=xcb>\n+| Frz|          \u251c\u2500\u2500\u2500\u2500<TAG=xcba>\n+| Frz|          \u2514\u2500\u2500\u2500\u2500<TAG=xcbb>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "4daf06c777e9a990b7c258e48b96889200221307", "filename": "src/tools/miri/tests/pass/tree-borrows/read-only-from-mut.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Fread-only-from-mut.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,14 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+// Tree Borrows has no issue with several mutable references existing\n+// at the same time, as long as they are used only immutably.\n+// I.e. multiple Reserved can coexist.\n+pub fn main() {\n+    unsafe {\n+        let base = &mut 42u64;\n+        let r1 = &mut *(base as *mut u64);\n+        let r2 = &mut *(base as *mut u64);\n+        let _l = *r1;\n+        let _l = *r2;\n+    }\n+}"}, {"sha": "e3f3f2d4032fd183eee7a1093deb5422f0bbaa90", "filename": "src/tools/miri/tests/pass/tree-borrows/reborrow-is-read.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,24 @@\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-tag-gc=0\n+\n+#[path = \"../../utils/mod.rs\"]\n+mod utils;\n+use utils::macros::*;\n+\n+// To check that a reborrow is counted as a Read access, we use a reborrow\n+// with no additional Read to Freeze an Active pointer.\n+\n+fn main() {\n+    unsafe {\n+        let parent = &mut 0u8;\n+        name!(parent);\n+        let alloc_id = alloc_id!(parent);\n+        let x = &mut *parent;\n+        name!(x);\n+        *x = 0; // x is now Active\n+        print_state!(alloc_id);\n+        let y = &mut *parent;\n+        name!(y);\n+        // Check in the debug output that x has been Frozen by the reborrow\n+        print_state!(alloc_id);\n+    }\n+}"}, {"sha": "b9c52c20640566a1d436bb1d86c4e63d5498e82b", "filename": "src/tools/miri/tests/pass/tree-borrows/reborrow-is-read.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freborrow-is-read.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,13 @@\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n+| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=x>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=parent>\n+| Frz|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "d8a8c27568d4d70137e65a3a825947e9a25b3e69", "filename": "src/tools/miri/tests/pass/tree-borrows/reserved.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,127 @@\n+//@compile-flags: -Zmiri-tree-borrows -Zmiri-tag-gc=0\n+\n+#[path = \"../../utils/mod.rs\"]\n+mod utils;\n+use utils::macros::*;\n+use utils::miri_extern::miri_write_to_stderr;\n+\n+use std::cell::UnsafeCell;\n+\n+// We exhaustively check that Reserved behaves as we want under all of the\n+// following conditions:\n+// - with or without interior mutability\n+// - with or without a protector\n+// - for a foreign read or write\n+// Of these cases, those in this file are the ones that must not cause\n+// immediate UB, and those that do are in tests/fail/tree-borrows/reserved/\n+// and are the combinations [_ + protected + write]\n+\n+fn main() {\n+    unsafe {\n+        cell_protected_read();\n+        cell_unprotected_read();\n+        cell_unprotected_write();\n+        int_protected_read();\n+        int_unprotected_read();\n+        int_unprotected_write();\n+    }\n+}\n+\n+unsafe fn print(msg: &str) {\n+    miri_write_to_stderr(msg.as_bytes());\n+    miri_write_to_stderr(\"\\n\".as_bytes());\n+}\n+\n+unsafe fn read_second<T>(x: &mut T, y: *mut u8) {\n+    name!(x as *mut T as *mut u8=>1, \"caller:x\");\n+    name!(x as *mut T as *mut u8, \"callee:x\");\n+    name!(y, \"caller:y\");\n+    name!(y, \"callee:y\");\n+    let _val = *y;\n+}\n+\n+// Foreign Read on a interior mutable Protected Reserved turns it Frozen.\n+unsafe fn cell_protected_read() {\n+    print(\"[interior mut + protected] Foreign Read: Re* -> Frz\");\n+    let base = &mut UnsafeCell::new(0u8);\n+    name!(base.get(), \"base\");\n+    let alloc_id = alloc_id!(base.get());\n+    let x = &mut *(base as *mut UnsafeCell<u8>);\n+    name!(x.get(), \"x\");\n+    let y = (&mut *base).get();\n+    name!(y);\n+    read_second(x, y); // Foreign Read for callee:x\n+    print_state!(alloc_id);\n+}\n+\n+// Foreign Read on an interior mutable pointer is a noop.\n+unsafe fn cell_unprotected_read() {\n+    print(\"[interior mut] Foreign Read: Re* -> Re*\");\n+    let base = &mut UnsafeCell::new(0u64);\n+    name!(base.get(), \"base\");\n+    let alloc_id = alloc_id!(base.get());\n+    let x = &mut *(base as *mut UnsafeCell<_>);\n+    name!(x.get(), \"x\");\n+    let y = (&mut *base).get();\n+    name!(y);\n+    let _val = *y; // Foreign Read for x\n+    print_state!(alloc_id);\n+}\n+\n+// Foreign Write on an interior mutable pointer is a noop.\n+// Also y must become Active.\n+unsafe fn cell_unprotected_write() {\n+    print(\"[interior mut] Foreign Write: Re* -> Re*\");\n+    let base = &mut UnsafeCell::new(0u64);\n+    name!(base.get(), \"base\");\n+    let alloc_id = alloc_id!(base.get());\n+    let x = &mut *(base as *mut UnsafeCell<u64>);\n+    name!(x.get(), \"x\");\n+    let y = (&mut *base).get();\n+    name!(y);\n+    *y = 1; // Foreign Write for x\n+    print_state!(alloc_id);\n+}\n+\n+// Foreign Read on a Protected Reserved turns it Frozen.\n+unsafe fn int_protected_read() {\n+    print(\"[protected] Foreign Read: Res -> Frz\");\n+    let base = &mut 0u8;\n+    let alloc_id = alloc_id!(base);\n+    name!(base);\n+    let x = &mut *(base as *mut u8);\n+    name!(x);\n+    let y = (&mut *base) as *mut u8;\n+    name!(y);\n+    read_second(x, y); // Foreign Read for callee:x\n+    print_state!(alloc_id);\n+}\n+\n+// Foreign Read on a Reserved is a noop.\n+// Also y must become Active.\n+unsafe fn int_unprotected_read() {\n+    print(\"[] Foreign Read: Res -> Res\");\n+    let base = &mut 0u8;\n+    name!(base);\n+    let alloc_id = alloc_id!(base);\n+    let x = &mut *(base as *mut u8);\n+    name!(x);\n+    let y = (&mut *base) as *mut u8;\n+    name!(y);\n+    let _val = *y; // Foreign Read for x\n+    print_state!(alloc_id);\n+}\n+\n+// Foreign Write on a Reserved turns it Disabled.\n+unsafe fn int_unprotected_write() {\n+    print(\"[] Foreign Write: Res -> Dis\");\n+    let base = &mut 0u8;\n+    name!(base);\n+    let alloc_id = alloc_id!(base);\n+    let x = &mut *(base as *mut u8);\n+    name!(x);\n+    let y = (&mut *base) as *mut u8;\n+    name!(y);\n+    *y = 1; // Foreign Write for x\n+    print_state!(alloc_id);\n+}"}, {"sha": "d76ee0f826607b50eee70ae60e394c8c56aa027f", "filename": "src/tools/miri/tests/pass/tree-borrows/reserved.stderr", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Freserved.stderr?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,52 @@\n+[interior mut + protected] Foreign Read: Re* -> Frz\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Re*|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Frz|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y,caller:y,callee:y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+[interior mut] Foreign Read: Re* -> Re*\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  8\n+| Re*|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Re*|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+[interior mut] Foreign Write: Re* -> Re*\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  8\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Re*|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+[protected] Foreign Read: Res -> Frz\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Res|      \u251c\u2500\u252c\u2500\u2500<TAG=x>\n+| Res|      \u2502 \u2514\u2500\u252c\u2500\u2500<TAG=caller:x>\n+| Frz|      \u2502   \u2514\u2500\u2500\u2500\u2500<TAG=callee:x>\n+| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y,caller:y,callee:y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+[] Foreign Read: Res -> Res\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Res|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Res|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Res|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+[] Foreign Write: Res -> Dis\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n+Warning: this tree is indicative only. Some tags may have been hidden.\n+0..  1\n+| Act|    \u2514\u2500\u252c\u2500\u2500<TAG=base>\n+| Dis|      \u251c\u2500\u2500\u2500\u2500<TAG=x>\n+| Act|      \u2514\u2500\u2500\u2500\u2500<TAG=y>\n+\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500"}, {"sha": "e1a9334ab5410b953da12f6c9b18d8ad9011301d", "filename": "src/tools/miri/tests/pass/tree-borrows/transmute-unsafecell.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftransmute-unsafecell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftransmute-unsafecell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Ftree-borrows%2Ftransmute-unsafecell.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,13 @@\n+//@compile-flags: -Zmiri-tree-borrows\n+\n+use core::cell::UnsafeCell;\n+use core::mem;\n+\n+fn main() {\n+    unsafe {\n+        let x = &0i32;\n+        // As long as we only read, transmuting this to UnsafeCell should be fine.\n+        let cell_x: &UnsafeCell<i32> = mem::transmute(&x);\n+        let _val = *cell_x.get();\n+    }\n+}"}, {"sha": "c9046dc3c761bf2e1590e37f053428f9c4908024", "filename": "src/tools/miri/tests/pass/unsized.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Funsized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Funsized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Funsized.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n #![feature(unsized_tuple_coercion)]\n #![feature(unsized_fn_params)]\n "}, {"sha": "06ec2f991722a74fd68781794fafd18622e3c164", "filename": "src/tools/miri/tests/pass/vec.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvec.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n #![feature(iter_advance_by, iter_next_chunk)]\n "}, {"sha": "dfbf9bb83c1d3e6b05e2e6f1296850b75c0421fa", "filename": "src/tools/miri/tests/pass/vecdeque.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -1,3 +1,5 @@\n+//@revisions: stack tree\n+//@[tree]compile-flags: -Zmiri-tree-borrows\n //@compile-flags: -Zmiri-strict-provenance\n use std::collections::VecDeque;\n "}, {"sha": "63de960ee2bdf1815fbcffdc5c49726f44021081", "filename": "src/tools/miri/tests/pass/vecdeque.stack.stdout", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.stack.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.stack.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.stack.stdout?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "previous_filename": "src/tools/miri/tests/pass/vecdeque.stdout"}, {"sha": "63de960ee2bdf1815fbcffdc5c49726f44021081", "filename": "src/tools/miri/tests/pass/vecdeque.tree.stdout", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.tree.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.tree.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Fpass%2Fvecdeque.tree.stdout?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,2 @@\n+[2, 2] Iter([2, 2], [])\n+Iter([], [])"}, {"sha": "de223410fba6bb62089ce648fc229608eb986c44", "filename": "src/tools/miri/tests/utils/macros.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmacros.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,61 @@\n+#![allow(unused_macros)]\n+#![allow(unused_macro_rules)]\n+#![allow(unused_imports)]\n+\n+/// `alloc_id!(ptr)`: obtain the allocation id from a pointer.\n+///\n+/// `ptr` should be any pointer or reference that can be converted with `_ as *const u8`.\n+///\n+/// The id obtained can be passed directly to `print_state!`.\n+macro_rules! alloc_id {\n+    ($ptr:expr) => {\n+        crate::utils::miri_extern::miri_get_alloc_id($ptr as *const u8 as *const ())\n+    };\n+}\n+\n+/// `print_state!(alloc_id, show_unnamed)`: print the internal state of the borrow\n+/// tracker (stack or tree).\n+///\n+/// `alloc_id` should be obtained from `alloc_id!`.\n+///\n+/// `show_unnamed` is an optional boolean that determines if Tree Borrows displays\n+/// tags that have not been given a name. Defaults to `false`.\n+macro_rules! print_state {\n+    ($alloc_id:expr) => {\n+        crate::utils::macros::print_state!($alloc_id, false);\n+    };\n+    ($alloc_id:expr, $show:expr) => {\n+        crate::utils::miri_extern::miri_print_borrow_state($alloc_id, $show);\n+    };\n+}\n+\n+/// `name!(ptr => nth_parent, name)`: associate `name` to the `nth_parent` of `ptr`.\n+///\n+/// `ptr` should be any pointer or reference that can be converted with `_ as *const u8`.\n+///\n+/// `nth_parent` is an optional `u8` that defaults to 0. The corresponding ancestor\n+/// of the tag of `ptr` will be searched: 0 for `ptr` itself, 1 for the direct parent\n+/// of `ptr`, 2 for the grandparent, etc. If `nth_parent` is not specified,\n+/// then `=>` should also not be included.\n+///\n+/// `name` is an optional string that will be used as the name. Defaults to\n+/// `stringify!($ptr)` the name of `ptr` in the source code.\n+macro_rules! name {\n+    ($ptr:expr, $name:expr) => {\n+        crate::utils::macros::name!($ptr => 0, $name);\n+    };\n+    ($ptr:expr) => {\n+        crate::utils::macros::name!($ptr => 0, stringify!($ptr));\n+    };\n+    ($ptr:expr => $nb:expr) => {\n+        crate::utils::macros::name!($ptr => $nb, stringify!($ptr));\n+    };\n+    ($ptr:expr => $nb:expr, $name:expr) => {\n+        let name = $name.as_bytes();\n+        crate::utils::miri_extern::miri_pointer_name($ptr as *const u8 as *const (), $nb, name);\n+    };\n+}\n+\n+pub(crate) use alloc_id;\n+pub(crate) use name;\n+pub(crate) use print_state;"}, {"sha": "6c4298c613b4526fe4b4be13bf09279b42cc9e4a", "filename": "src/tools/miri/tests/utils/miri_extern.rs", "status": "added", "additions": 142, "deletions": 0, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmiri_extern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmiri_extern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmiri_extern.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,142 @@\n+#![allow(dead_code)]\n+\n+#[repr(C)]\n+/// Layout of the return value of `miri_resolve_frame`,\n+/// with fields in the exact same order.\n+pub struct MiriFrame {\n+    // The size of the name of the function being executed, encoded in UTF-8\n+    pub name_len: usize,\n+    // The size of filename of the function being executed, encoded in UTF-8\n+    pub filename_len: usize,\n+    // The line number currently being executed in `filename`, starting from '1'.\n+    pub lineno: u32,\n+    // The column number currently being executed in `filename`, starting from '1'.\n+    pub colno: u32,\n+    // The function pointer to the function currently being executed.\n+    // This can be compared against function pointers obtained by\n+    // casting a function (e.g. `my_fn as *mut ()`)\n+    pub fn_ptr: *mut (),\n+}\n+\n+#[cfg(miri)]\n+extern \"Rust\" {\n+    /// Miri-provided extern function to mark the block `ptr` points to as a \"root\"\n+    /// for some static memory. This memory and everything reachable by it is not\n+    /// considered leaking even if it still exists when the program terminates.\n+    ///\n+    /// `ptr` has to point to the beginning of an allocated block.\n+    pub fn miri_static_root(ptr: *const u8);\n+\n+    // Miri-provided extern function to get the amount of frames in the current backtrace.\n+    // The `flags` argument must be `0`.\n+    pub fn miri_backtrace_size(flags: u64) -> usize;\n+\n+    /// Miri-provided extern function to obtain a backtrace of the current call stack.\n+    /// This writes a slice of pointers into `buf` - each pointer is an opaque value\n+    /// that is only useful when passed to `miri_resolve_frame`.\n+    /// `buf` must have `miri_backtrace_size(0) * pointer_size` bytes of space.\n+    /// The `flags` argument must be `1`.\n+    pub fn miri_get_backtrace(flags: u64, buf: *mut *mut ());\n+\n+    /// Miri-provided extern function to resolve a frame pointer obtained\n+    /// from `miri_get_backtrace`. The `flags` argument must be `1`.\n+    ///\n+    /// This function can be called on any thread (not just the one which obtained `frame`).\n+    pub fn miri_resolve_frame(frame: *mut (), flags: u64) -> MiriFrame;\n+\n+    /// Miri-provided extern function to get the name and filename of the frame provided by `miri_resolve_frame`.\n+    /// `name_buf` and `filename_buf` should be allocated with the `name_len` and `filename_len` fields of `MiriFrame`.\n+    /// The flags argument must be `0`.\n+    pub fn miri_resolve_frame_names(\n+        ptr: *mut (),\n+        flags: u64,\n+        name_buf: *mut u8,\n+        filename_buf: *mut u8,\n+    );\n+\n+    /// Miri-provided extern function to begin unwinding with the given payload.\n+    ///\n+    /// This is internal and unstable and should not be used; we give it here\n+    /// just to be complete.\n+    pub fn miri_start_panic(payload: *mut u8) -> !;\n+\n+    /// Miri-provided extern function to get the internal unique identifier for the allocation that a pointer\n+    /// points to. If this pointer is invalid (not pointing to an allocation), interpretation will abort.\n+    ///\n+    /// This is only useful as an input to `miri_print_borrow_stacks`, and it is a separate call because\n+    /// getting a pointer to an allocation at runtime can change the borrow stacks in the allocation.\n+    /// This function should be considered unstable. It exists only to support `miri_print_borrow_stacks` and so\n+    /// inherits all of its instability.\n+    pub fn miri_get_alloc_id(ptr: *const ()) -> u64;\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the program) the contents of all\n+    /// borrows in an allocation.\n+    ///\n+    /// If Stacked Borrows is running, this prints all the stacks. The leftmost tag is the bottom of the stack.\n+    ///\n+    /// If Tree borrows is running, this prints on the left the permissions of each tag on each range,\n+    /// an on the right the tree structure of the tags. If some tags were named via `miri_pointer_name`,\n+    /// their names appear here.\n+    ///\n+    /// If additionally `show_unnamed` is `false` then tags that did *not* receive a name will be hidden.\n+    /// Ensure that either the important tags have been named, or `show_unnamed = true`.\n+    /// Note: as Stacked Borrows does not have tag names at all, `show_unnamed` is ignored and all tags are shown.\n+    /// In general, unless you strongly want some tags to be hidden (as is the case in `tree-borrows` tests),\n+    /// `show_unnamed = true` should be the default.\n+    ///\n+    /// The format of what this emits is unstable and may change at any time. In particular, users should be\n+    /// aware that Miri will periodically attempt to garbage collect the contents of all stacks. Callers of\n+    /// this function may wish to pass `-Zmiri-tag-gc=0` to disable the GC.\n+    ///\n+    /// This function is extremely unstable. At any time the format of its output may change, its signature may\n+    /// change, or it may be removed entirely.\n+    pub fn miri_print_borrow_state(alloc_id: u64, show_unnamed: bool);\n+\n+    /// Miri-provided extern function to associate a name to the nth parent of a tag.\n+    /// Typically the name given would be the name of the program variable that holds the pointer.\n+    /// Unreachable tags can still be named by using nonzero `nth_parent` and a child tag.\n+    ///\n+    /// This function does nothing under Stacked Borrows, since Stacked Borrows's implementation\n+    /// of `miri_print_borrow_state` does not show the names.\n+    ///\n+    /// Under Tree Borrows, the names also appear in error messages.\n+    pub fn miri_pointer_name(ptr: *const (), nth_parent: u8, name: &[u8]);\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the\n+    /// program) the contents of a section of program memory, as bytes. Bytes\n+    /// written using this function will emerge from the interpreter's stdout.\n+    pub fn miri_write_to_stdout(bytes: &[u8]);\n+\n+    /// Miri-provided extern function to print (from the interpreter, not the\n+    /// program) the contents of a section of program memory, as bytes. Bytes\n+    /// written using this function will emerge from the interpreter's stderr.\n+    pub fn miri_write_to_stderr(bytes: &[u8]);\n+\n+    /// Miri-provided extern function to allocate memory from the interpreter.\n+    ///\n+    /// This is useful when no fundamental way of allocating memory is\n+    /// available, e.g. when using `no_std` + `alloc`.\n+    pub fn miri_alloc(size: usize, align: usize) -> *mut u8;\n+\n+    /// Miri-provided extern function to deallocate memory.\n+    pub fn miri_dealloc(ptr: *mut u8, size: usize, align: usize);\n+\n+    /// Convert a path from the host Miri runs on to the target Miri interprets.\n+    /// Performs conversion of path separators as needed.\n+    ///\n+    /// Usually Miri performs this kind of conversion automatically. However, manual conversion\n+    /// might be necessary when reading an environment variable that was set on the host\n+    /// (such as TMPDIR) and using it as a target path.\n+    ///\n+    /// Only works with isolation disabled.\n+    ///\n+    /// `in` must point to a null-terminated string, and will be read as the input host path.\n+    /// `out` must point to at least `out_size` many bytes, and the result will be stored there\n+    /// with a null terminator.\n+    /// Returns 0 if the `out` buffer was large enough, and the required size otherwise.\n+    pub fn miri_host_to_target_path(\n+        path: *const std::ffi::c_char,\n+        out: *mut std::ffi::c_char,\n+        out_size: usize,\n+    ) -> usize;\n+}"}, {"sha": "e1ea77e4df8c7018a72d7a93a0c0e574e3c224cf", "filename": "src/tools/miri/tests/utils/mod.rs", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b024de1673487c3de0ce7dc4c3c9ec470746006a/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Ftests%2Futils%2Fmod.rs?ref=b024de1673487c3de0ce7dc4c3c9ec470746006a", "patch": "@@ -0,0 +1,2 @@\n+pub mod macros;\n+pub mod miri_extern;"}]}