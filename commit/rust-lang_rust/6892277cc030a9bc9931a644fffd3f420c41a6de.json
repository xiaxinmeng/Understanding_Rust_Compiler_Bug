{"sha": "6892277cc030a9bc9931a644fffd3f420c41a6de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4OTIyNzdjYzAzMGE5YmM5OTMxYTY0NGZmZmQzZjQyMGM0MWE2ZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-17T03:40:33Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-04-17T03:40:33Z"}, "message": "Auto merge of #32952 - eddyb:mir-debuginfo-2, r=michaelwoerister\n\nGet all (but one) of debuginfo tests to pass with MIR codegen.\n\nI didn't get much feedback in #31005 so I went ahead and implemented something simple.\nCloses #31005, as MIR debuginfo should work now for most usecases.\n\nThe `no-debug-attribute` test no longer assumes variables are in scope of `return`.\nWe might also want to revisit that in #32949, but the test is more reliable now either way.\n\nIn order to get one last function in the `associated-type` test pass, this PR also fixes #32790.", "tree": {"sha": "9c69015ec7724680c30dbe0c3165b104afd5d254", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9c69015ec7724680c30dbe0c3165b104afd5d254"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6892277cc030a9bc9931a644fffd3f420c41a6de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6892277cc030a9bc9931a644fffd3f420c41a6de", "html_url": "https://github.com/rust-lang/rust/commit/6892277cc030a9bc9931a644fffd3f420c41a6de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6892277cc030a9bc9931a644fffd3f420c41a6de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "054a4b4019efe1f4a9800a5a322c4a0da5aef11c", "url": "https://api.github.com/repos/rust-lang/rust/commits/054a4b4019efe1f4a9800a5a322c4a0da5aef11c", "html_url": "https://github.com/rust-lang/rust/commit/054a4b4019efe1f4a9800a5a322c4a0da5aef11c"}, {"sha": "e2ac9895d68b7bed9a8fc3d9ce270ae0129d2b74", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2ac9895d68b7bed9a8fc3d9ce270ae0129d2b74", "html_url": "https://github.com/rust-lang/rust/commit/e2ac9895d68b7bed9a8fc3d9ce270ae0129d2b74"}], "stats": {"total": 286, "additions": 206, "deletions": 80}, "files": [{"sha": "3bc65124d34646540857ca68efbfb08de58ae72a", "filename": "src/librustc/mir/repr.rs", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc%2Fmir%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc%2Fmir%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Frepr.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -52,6 +52,10 @@ pub struct Mir<'tcx> {\n     /// through the resulting reference.\n     pub temp_decls: Vec<TempDecl<'tcx>>,\n \n+    /// Names and capture modes of all the closure upvars, assuming\n+    /// the first argument is either the closure or a reference to it.\n+    pub upvar_decls: Vec<UpvarDecl>,\n+\n     /// A span representing this MIR, for error reporting\n     pub span: Span,\n }\n@@ -197,7 +201,20 @@ pub struct ArgDecl<'tcx> {\n \n     /// If true, this argument is a tuple after monomorphization,\n     /// and has to be collected from multiple actual arguments.\n-    pub spread: bool\n+    pub spread: bool,\n+\n+    /// Either special_idents::invalid or the name of a single-binding\n+    /// pattern associated with this argument. Useful for debuginfo.\n+    pub debug_name: Name\n+}\n+\n+/// A closure capture, with its name and mode.\n+#[derive(Clone, Debug, RustcEncodable, RustcDecodable)]\n+pub struct UpvarDecl {\n+    pub debug_name: Name,\n+\n+    /// If true, the capture is behind a reference.\n+    pub by_ref: bool\n }\n \n ///////////////////////////////////////////////////////////////////////////"}, {"sha": "10afd3dd953d0ba4b13cc1bfa15be9f0651ef9d1", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -248,6 +248,7 @@ macro_rules! make_mir_visitor {\n                     ref $($mutability)* var_decls,\n                     ref $($mutability)* arg_decls,\n                     ref $($mutability)* temp_decls,\n+                    upvar_decls: _,\n                     ref $($mutability)* span,\n                 } = *mir;\n \n@@ -599,7 +600,8 @@ macro_rules! make_mir_visitor {\n                               arg_decl: & $($mutability)* ArgDecl<'tcx>) {\n                 let ArgDecl {\n                     ref $($mutability)* ty,\n-                    spread: _\n+                    spread: _,\n+                    debug_name: _\n                 } = *arg_decl;\n \n                 self.visit_ty(ty);"}, {"sha": "080183ae1da66ad491a172246c272f1356d8a67c", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -37,25 +37,28 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                       -> BlockAnd<()> {\n         let discriminant_lvalue = unpack!(block = self.as_lvalue(block, discriminant));\n \n-        // Before we do anything, create uninitialized variables with\n-        // suitable extent for all of the bindings in this match. It's\n-        // easiest to do this up front because some of these arms may\n-        // be unreachable or reachable multiple times.\n-        let var_scope_id = self.innermost_scope_id();\n-        for arm in &arms {\n-            self.declare_bindings(var_scope_id, &arm.patterns[0]);\n-        }\n-\n         let mut arm_blocks = ArmBlocks {\n             blocks: arms.iter()\n                         .map(|_| self.cfg.start_new_block())\n                         .collect(),\n         };\n \n-        let arm_bodies: Vec<ExprRef<'tcx>> =\n-            arms.iter()\n-                .map(|arm| arm.body.clone())\n-                .collect();\n+        // Get the body expressions and their scopes, while declaring bindings.\n+        let arm_bodies: Vec<_> = arms.iter().enumerate().map(|(i, arm)| {\n+            // Assume that all expressions are wrapped in Scope.\n+            let body = self.hir.mirror(arm.body.clone());\n+            match body.kind {\n+                ExprKind::Scope { extent, value } => {\n+                    let scope_id = self.push_scope(extent, arm_blocks.blocks[i]);\n+                    self.declare_bindings(scope_id, &arm.patterns[0]);\n+                    (extent, self.scopes.pop().unwrap(), value)\n+                }\n+                _ => {\n+                    span_bug!(body.span, \"arm body is not wrapped in Scope {:?}\",\n+                              body.kind);\n+                }\n+            }\n+        }).collect();\n \n         // assemble a list of candidates: there is one candidate per\n         // pattern, which means there may be more than one candidate\n@@ -95,11 +98,15 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n         // all the arm blocks will rejoin here\n         let end_block = self.cfg.start_new_block();\n \n-        for (arm_index, arm_body) in arm_bodies.into_iter().enumerate() {\n+        let scope_id = self.innermost_scope_id();\n+        for (arm_index, (extent, scope, body)) in arm_bodies.into_iter().enumerate() {\n             let mut arm_block = arm_blocks.blocks[arm_index];\n-            unpack!(arm_block = self.into(destination, arm_block, arm_body));\n+            // Re-enter the scope we created the bindings in.\n+            self.scopes.push(scope);\n+            unpack!(arm_block = self.into(destination, arm_block, body));\n+            unpack!(arm_block = self.pop_scope(extent, arm_block));\n             self.cfg.terminate(arm_block,\n-                               var_scope_id,\n+                               scope_id,\n                                span,\n                                TerminatorKind::Goto { target: end_block });\n         }"}, {"sha": "5284a2ef39535fc21c72a8ccf23e96788c8fb67a", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -10,13 +10,15 @@\n \n use hair::cx::Cx;\n use rustc::middle::region::{CodeExtent, CodeExtentData};\n-use rustc::ty::{FnOutput, Ty};\n+use rustc::ty::{self, FnOutput, Ty};\n use rustc::mir::repr::*;\n use rustc_data_structures::fnv::FnvHashMap;\n use rustc::hir;\n+use rustc::hir::pat_util::pat_is_binding;\n use std::ops::{Index, IndexMut};\n use syntax::ast;\n use syntax::codemap::Span;\n+use syntax::parse::token;\n \n pub struct Builder<'a, 'tcx: 'a> {\n     hir: Cx<'a, 'tcx>,\n@@ -224,13 +226,37 @@ pub fn construct<'a,'tcx>(hir: Cx<'a,'tcx>,\n                        true\n                    }));\n \n+    // Gather the upvars of a closure, if any.\n+    let upvar_decls: Vec<_> = tcx.with_freevars(fn_id, |freevars| {\n+        freevars.iter().map(|fv| {\n+            let by_ref = tcx.upvar_capture(ty::UpvarId {\n+                var_id: fv.def.var_id(),\n+                closure_expr_id: fn_id\n+            }).map_or(false, |capture| match capture {\n+                ty::UpvarCapture::ByValue => false,\n+                ty::UpvarCapture::ByRef(..) => true\n+            });\n+            let mut decl = UpvarDecl {\n+                debug_name: token::special_idents::invalid.name,\n+                by_ref: by_ref\n+            };\n+            if let Some(hir::map::NodeLocal(pat)) = tcx.map.find(fv.def.var_id()) {\n+                if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n+                    decl.debug_name = ident.node.name;\n+                }\n+            }\n+            decl\n+        }).collect()\n+    });\n+\n     (\n         Mir {\n             basic_blocks: builder.cfg.basic_blocks,\n             scopes: builder.scope_datas,\n             var_decls: builder.var_decls,\n             arg_decls: arg_decls.take().expect(\"args never built?\"),\n             temp_decls: builder.temp_decls,\n+            upvar_decls: upvar_decls,\n             return_ty: return_ty,\n             span: span\n         },\n@@ -269,7 +295,20 @@ impl<'a,'tcx> Builder<'a,'tcx> {\n                 self.schedule_drop(pattern.as_ref().map_or(ast_block.span, |pat| pat.span),\n                                    argument_extent, &lvalue, ty);\n \n-                ArgDecl { ty: ty, spread: false }\n+                let mut name = token::special_idents::invalid.name;\n+                if let Some(pat) = pattern {\n+                    if let hir::PatKind::Ident(_, ref ident, _) = pat.node {\n+                        if pat_is_binding(&self.hir.tcx().def_map.borrow(), pat) {\n+                            name = ident.node.name;\n+                        }\n+                    }\n+                }\n+\n+                ArgDecl {\n+                    ty: ty,\n+                    spread: false,\n+                    debug_name: name\n+                }\n             })\n             .collect();\n "}, {"sha": "4b1292e4086f78b66f3453718c3917e177b7ada5", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 19, "deletions": 12, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -120,21 +120,28 @@ fn make_mir_scope(ccx: &CrateContext,\n         return;\n     };\n \n-    scopes[idx] = if !has_variables.contains(idx) {\n+    if !has_variables.contains(idx) {\n         // Do not create a DIScope if there are no variables\n         // defined in this MIR Scope, to avoid debuginfo bloat.\n-        parent_scope\n-    } else {\n-        let loc = span_start(ccx, scope_data.span);\n-        let file_metadata = file_metadata(ccx, &loc.file.name);\n-        unsafe {\n-            llvm::LLVMDIBuilderCreateLexicalBlock(\n-                DIB(ccx),\n-                parent_scope,\n-                file_metadata,\n-                loc.line as c_uint,\n-                loc.col.to_usize() as c_uint)\n+\n+        // However, we don't skip creating a nested scope if\n+        // our parent is the root, because we might want to\n+        // put arguments in the root and not have shadowing.\n+        if parent_scope != fn_metadata {\n+            scopes[idx] = parent_scope;\n+            return;\n         }\n+    }\n+\n+    let loc = span_start(ccx, scope_data.span);\n+    let file_metadata = file_metadata(ccx, &loc.file.name);\n+    scopes[idx] = unsafe {\n+        llvm::LLVMDIBuilderCreateLexicalBlock(\n+            DIB(ccx),\n+            parent_scope,\n+            file_metadata,\n+            loc.line as c_uint,\n+            loc.col.to_usize() as c_uint)\n     };\n }\n "}, {"sha": "3edbea88c057502d8849e170ec34667fd275cfa9", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 75, "deletions": 7, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -126,6 +126,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n     let scopes = debuginfo::create_mir_scopes(fcx);\n \n     // Allocate variable and temp allocas\n+    let args = arg_value_refs(&bcx, &mir, &scopes);\n     let vars = mir.var_decls.iter()\n                             .map(|decl| (bcx.monomorphize(&decl.ty), decl))\n                             .map(|(mty, decl)| {\n@@ -156,7 +157,6 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n                                   TempRef::Operand(None)\n                               })\n                               .collect();\n-    let args = arg_value_refs(&bcx, &mir, &scopes);\n \n     // Allocate a `Block` for every basic block\n     let block_bcxs: Vec<Block<'blk,'tcx>> =\n@@ -278,15 +278,15 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                     let byte_offset_of_var_in_tuple =\n                         machine::llelement_offset(bcx.ccx(), lltuplety, i);\n \n-                    let address_operations = unsafe {\n+                    let ops = unsafe {\n                         [llvm::LLVMDIBuilderCreateOpDeref(),\n                          llvm::LLVMDIBuilderCreateOpPlus(),\n                          byte_offset_of_var_in_tuple as i64]\n                     };\n \n                     let variable_access = VariableAccess::IndirectVariable {\n                         alloca: lltemp,\n-                        address_operations: &address_operations\n+                        address_operations: &ops\n                     };\n                     declare_local(bcx, token::special_idents::invalid.name,\n                                   tupled_arg_ty, scope, variable_access,\n@@ -327,10 +327,78 @@ fn arg_value_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n             lltemp\n         };\n         bcx.with_block(|bcx| arg_scope.map(|scope| {\n-            declare_local(bcx, token::special_idents::invalid.name, arg_ty, scope,\n-                          VariableAccess::DirectVariable { alloca: llval },\n-                          VariableKind::ArgumentVariable(arg_index + 1),\n-                          bcx.fcx().span.unwrap_or(DUMMY_SP));\n+            // Is this a regular argument?\n+            if arg_index > 0 || mir.upvar_decls.is_empty() {\n+                declare_local(bcx, arg_decl.debug_name, arg_ty, scope,\n+                              VariableAccess::DirectVariable { alloca: llval },\n+                              VariableKind::ArgumentVariable(arg_index + 1),\n+                              bcx.fcx().span.unwrap_or(DUMMY_SP));\n+                return;\n+            }\n+\n+            // Or is it the closure environment?\n+            let (closure_ty, env_ref) = if let ty::TyRef(_, mt) = arg_ty.sty {\n+                (mt.ty, true)\n+            } else {\n+                (arg_ty, false)\n+            };\n+            let upvar_tys = if let ty::TyClosure(_, ref substs) = closure_ty.sty {\n+                &substs.upvar_tys[..]\n+            } else {\n+                bug!(\"upvar_decls with non-closure arg0 type `{}`\", closure_ty);\n+            };\n+\n+            // Store the pointer to closure data in an alloca for debuginfo\n+            // because that's what the llvm.dbg.declare intrinsic expects.\n+\n+            // FIXME(eddyb) this shouldn't be necessary but SROA seems to\n+            // mishandle DW_OP_plus not preceded by DW_OP_deref, i.e. it\n+            // doesn't actually strip the offset when splitting the closure\n+            // environment into its components so it ends up out of bounds.\n+            let env_ptr = if !env_ref {\n+                use base::*;\n+                use build::*;\n+                use common::*;\n+                let alloc = alloca(bcx, val_ty(llval), \"__debuginfo_env_ptr\");\n+                Store(bcx, llval, alloc);\n+                alloc\n+            } else {\n+                llval\n+            };\n+\n+            let llclosurety = type_of::type_of(bcx.ccx(), closure_ty);\n+            for (i, (decl, ty)) in mir.upvar_decls.iter().zip(upvar_tys).enumerate() {\n+                let byte_offset_of_var_in_env =\n+                    machine::llelement_offset(bcx.ccx(), llclosurety, i);\n+\n+                let ops = unsafe {\n+                    [llvm::LLVMDIBuilderCreateOpDeref(),\n+                     llvm::LLVMDIBuilderCreateOpPlus(),\n+                     byte_offset_of_var_in_env as i64,\n+                     llvm::LLVMDIBuilderCreateOpDeref()]\n+                };\n+\n+                // The environment and the capture can each be indirect.\n+\n+                // FIXME(eddyb) see above why we have to keep\n+                // a pointer in an alloca for debuginfo atm.\n+                let mut ops = if env_ref || true { &ops[..] } else { &ops[1..] };\n+\n+                let ty = if let (true, &ty::TyRef(_, mt)) = (decl.by_ref, &ty.sty) {\n+                    mt.ty\n+                } else {\n+                    ops = &ops[..ops.len() - 1];\n+                    ty\n+                };\n+\n+                let variable_access = VariableAccess::IndirectVariable {\n+                    alloca: env_ptr,\n+                    address_operations: &ops\n+                };\n+                declare_local(bcx, decl.debug_name, ty, scope, variable_access,\n+                              VariableKind::CapturedVariable,\n+                              bcx.fcx().span.unwrap_or(DUMMY_SP));\n+            }\n         }));\n         LvalueRef::new_sized(llval, LvalueTy::from_ty(arg_ty))\n     }).collect()"}, {"sha": "ebaad663bb4e74488f4c2f635a9bc0c0efd178b1", "filename": "src/test/debuginfo/associated-types.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fassociated-types.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -80,7 +80,7 @@\n \n #![allow(unused_variables)]\n #![allow(dead_code)]\n-#![feature(omit_gdb_pretty_printer_section, rustc_attrs)]\n+#![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n trait TraitWithAssocType {\n@@ -127,7 +127,6 @@ fn assoc_tuple<T: TraitWithAssocType>(arg: (T, T::Type)) {\n     zzz(); // #break\n }\n \n-#[rustc_no_mir] // FIXME(#32790) MIR reuses scopes for match arms.\n fn assoc_enum<T: TraitWithAssocType>(arg: Enum<T>) {\n \n     match arg {"}, {"sha": "f0ecda92993706ce145e3c1961298400e6b12076", "filename": "src/test/debuginfo/function-prologue-stepping-no-stack-check.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ffunction-prologue-stepping-no-stack-check.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -251,7 +251,7 @@\n #![omit_gdb_pretty_printer_section]\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn immediate_args(a: isize, b: bool, c: f64) {\n     println!(\"\");\n }\n@@ -268,51 +268,51 @@ struct BigStruct {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn non_immediate_args(a: BigStruct, b: BigStruct) {\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn binding(a: i64, b: u64, c: f64) {\n     let x = 0;\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn assignment(mut a: u64, b: u64, c: f64) {\n     a = b;\n     println!(\"\");\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn function_call(x: u64, y: u64, z: f64) {\n     println!(\"Hi!\")\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn identifier(x: u64, y: u64, z: f64) -> u64 {\n     x\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn return_expr(x: u64, y: u64, z: f64) -> u64 {\n     return x;\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn arithmetic_expr(x: u64, y: u64, z: f64) -> u64 {\n     x + y\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n     if x + y < 1000 {\n         x\n@@ -322,7 +322,7 @@ fn if_expr(x: u64, y: u64, z: f64) -> u64 {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     while x + y < 1000 {\n         x += z\n@@ -331,7 +331,7 @@ fn while_expr(mut x: u64, y: u64, z: u64) -> u64 {\n }\n \n #[no_stack_check]\n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing argument names.\n+#[rustc_no_mir] // FIXME(#32949) MIR debuginfo shadows arguments with uninit vars.\n fn loop_expr(mut x: u64, y: u64, z: u64) -> u64 {\n     loop {\n         x += z;"}, {"sha": "15f2eae76c6777355a84a1229115e660eb054447", "filename": "src/test/debuginfo/no-debug-attribute.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fno-debug-attribute.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -23,20 +23,22 @@\n // gdb-command:continue\n \n #![allow(unused_variables)]\n-#![feature(no_debug, rustc_attrs)]\n+#![feature(no_debug)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is inaccurate for returns.\n+#[inline(never)]\n+fn id<T>(x: T) -> T {x}\n+\n fn function_with_debuginfo() {\n     let abc = 10_usize;\n-    return (); // #break\n+    id(abc); // #break\n }\n \n #[no_debug]\n fn function_without_debuginfo() {\n     let abc = -57i32;\n-    return (); // #break\n+    id(abc); // #break\n }\n \n fn main() {"}, {"sha": "7090377e5db1bfd7fbdf23f51e3f492cd40116bd", "filename": "src/test/debuginfo/var-captured-in-nested-closure.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-nested-closure.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -78,7 +78,7 @@\n // lldb-command:continue\n \n #![allow(unused_variables)]\n-#![feature(box_syntax, rustc_attrs, stmt_expr_attributes)]\n+#![feature(box_syntax)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n@@ -88,7 +88,6 @@ struct Struct {\n     c: usize\n }\n \n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let mut variable = 1;\n     let constant = 2;\n@@ -102,14 +101,10 @@ fn main() {\n     let struct_ref = &a_struct;\n     let owned: Box<_> = box 6;\n \n-    let mut closure =\n-    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-    || {\n+    let mut closure = || {\n         let closure_local = 8;\n \n-        let mut nested_closure =\n-        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-        || {\n+        let mut nested_closure = || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned + closure_local;\n         };"}, {"sha": "aa269edadd8f410b9a96b40e1e965e38f5124c43", "filename": "src/test/debuginfo/var-captured-in-sendable-closure.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-sendable-closure.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -40,7 +40,7 @@\n // lldb-check:[...]$2 = 5\n \n #![allow(unused_variables)]\n-#![feature(unboxed_closures, box_syntax, rustc_attrs, stmt_expr_attributes)]\n+#![feature(unboxed_closures, box_syntax)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n \n@@ -50,7 +50,6 @@ struct Struct {\n     c: usize\n }\n \n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let constant = 1;\n \n@@ -62,9 +61,7 @@ fn main() {\n \n     let owned: Box<_> = box 5;\n \n-    let closure =\n-    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-    move || {\n+    let closure = move || {\n         zzz(); // #break\n         do_something(&constant, &a_struct.a, &*owned);\n     };\n@@ -76,9 +73,7 @@ fn main() {\n     // The `self` argument of the following closure should be passed by value\n     // to FnOnce::call_once(self, args), which gets translated a bit differently\n     // than the regular case. Let's make sure this is supported too.\n-    let immedate_env =\n-    #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-    move || {\n+    let immedate_env = move || {\n         zzz(); // #break\n         return constant2;\n     };"}, {"sha": "6def5cf285934f7790f334ccbf06960eb902fd39", "filename": "src/test/debuginfo/var-captured-in-stack-closure.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6892277cc030a9bc9931a644fffd3f420c41a6de/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fvar-captured-in-stack-closure.rs?ref=6892277cc030a9bc9931a644fffd3f420c41a6de", "patch": "@@ -69,7 +69,7 @@\n // lldb-command:print *owned\n // lldb-check:[...]$9 = 6\n \n-#![feature(unboxed_closures, box_syntax, rustc_attrs, stmt_expr_attributes)]\n+#![feature(unboxed_closures, box_syntax)]\n #![allow(unused_variables)]\n #![feature(omit_gdb_pretty_printer_section)]\n #![omit_gdb_pretty_printer_section]\n@@ -80,7 +80,6 @@ struct Struct {\n     c: usize\n }\n \n-#[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n fn main() {\n     let mut variable = 1;\n     let constant = 2;\n@@ -95,9 +94,7 @@ fn main() {\n     let owned: Box<_> = box 6;\n \n     {\n-        let mut first_closure =\n-        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-        || {\n+        let mut first_closure = || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned;\n         };\n@@ -106,9 +103,7 @@ fn main() {\n     }\n \n     {\n-        let mut second_closure =\n-        #[rustc_no_mir] // FIXME(#31005) MIR debuginfo is missing captures.\n-        || {\n+        let mut second_closure = || {\n             zzz(); // #break\n             variable = constant + a_struct.a + struct_ref.a + *owned;\n         };"}]}