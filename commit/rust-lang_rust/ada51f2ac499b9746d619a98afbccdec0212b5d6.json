{"sha": "ada51f2ac499b9746d619a98afbccdec0212b5d6", "node_id": "C_kwDOAAsO6NoAKGFkYTUxZjJhYzQ5OWI5NzQ2ZDYxOWE5OGFmYmNjZGVjMDIxMmI1ZDY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-05T21:30:50Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-05T21:30:50Z"}, "message": "Merge #11195 #11202\n\n11195: Correctly pass through reference modifiers when extracting a variable r=Veykril a=Vannevelj\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10034\r\n\r\nThis will parse the field expression and look at whether it is marked `&` or `&mut` and include a modifier if appropriate. The original issue only mentions `&mut params` but I've found that this issue also occurs for `&mut locals` as well as `&params` and `&locals` so I've also added tests for them.\r\n\r\nI'd definitely be interested in hearing where I can make my code more idiomatic for Rust.\n\n11202: fix: Fix `apply_demorgan` assist hanging for certain binary expressions r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10963\r\nbors r+\n\nCo-authored-by: Jeroen Vannevel <jer_vannevel@outlook.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "929976c6d4ec7e6c9e86f698e93c1ac8e219608a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/929976c6d4ec7e6c9e86f698e93c1ac8e219608a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ada51f2ac499b9746d619a98afbccdec0212b5d6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh1g4KCRBK7hj4Ov3rIwAAXFgIAIxKYfEJ7XvUV+E5V3+bEl6W\n4ll7/IKVdtJaHX9gB5wW2LliYAVCx3NhxhPVdAt6aiLHgqpsiEn+rQhxGRbj63AM\ntA8EBQ5F8DodX93seCnl9HyDyo2ejlZn/tzgR14OAzBGfGs8k28C7lYc/qOB7C+k\nJ9YdkL629cCHnte4Qvjl9AXyYF3BoHPdQxVF9CVnk9TziBUZ5tW5LlxDifmkRYkZ\nactc3RvExAECcoc49Fems/T48lwJZq000jgC2miq+95toVulGOec0lcWsrgEWdHk\nAexy5mMA4nRkwfZr6VeZ1edHD3nY/EeOYcp/P3R4KCHtFfwVob6zpergxkghNPw=\n=rsnY\n-----END PGP SIGNATURE-----\n", "payload": "tree 929976c6d4ec7e6c9e86f698e93c1ac8e219608a\nparent 735b542146eb729bbef90bdb50841ccc99ab46c5\nparent 035a373a6a025bd9b2f115adbe0884861ca2a9e4\nparent b92ed115c1b4760c33eaa0005fec1e85f9e18206\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1641418250 +0000\ncommitter GitHub <noreply@github.com> 1641418250 +0000\n\nMerge #11195 #11202\n\n11195: Correctly pass through reference modifiers when extracting a variable r=Veykril a=Vannevelj\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10034\r\n\r\nThis will parse the field expression and look at whether it is marked `&` or `&mut` and include a modifier if appropriate. The original issue only mentions `&mut params` but I've found that this issue also occurs for `&mut locals` as well as `&params` and `&locals` so I've also added tests for them.\r\n\r\nI'd definitely be interested in hearing where I can make my code more idiomatic for Rust.\n\n11202: fix: Fix `apply_demorgan` assist hanging for certain binary expressions r=Veykril a=Veykril\n\nFixes https://github.com/rust-analyzer/rust-analyzer/issues/10963\r\nbors r+\n\nCo-authored-by: Jeroen Vannevel <jer_vannevel@outlook.com>\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ada51f2ac499b9746d619a98afbccdec0212b5d6", "html_url": "https://github.com/rust-lang/rust/commit/ada51f2ac499b9746d619a98afbccdec0212b5d6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ada51f2ac499b9746d619a98afbccdec0212b5d6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "735b542146eb729bbef90bdb50841ccc99ab46c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/735b542146eb729bbef90bdb50841ccc99ab46c5", "html_url": "https://github.com/rust-lang/rust/commit/735b542146eb729bbef90bdb50841ccc99ab46c5"}, {"sha": "035a373a6a025bd9b2f115adbe0884861ca2a9e4", "url": "https://api.github.com/repos/rust-lang/rust/commits/035a373a6a025bd9b2f115adbe0884861ca2a9e4", "html_url": "https://github.com/rust-lang/rust/commit/035a373a6a025bd9b2f115adbe0884861ca2a9e4"}, {"sha": "b92ed115c1b4760c33eaa0005fec1e85f9e18206", "url": "https://api.github.com/repos/rust-lang/rust/commits/b92ed115c1b4760c33eaa0005fec1e85f9e18206", "html_url": "https://github.com/rust-lang/rust/commit/b92ed115c1b4760c33eaa0005fec1e85f9e18206"}], "stats": {"total": 371, "additions": 366, "deletions": 5}, "files": [{"sha": "21907ab41fb93628abc6cde8fe283d836c42f33c", "filename": "crates/ide_assists/src/handlers/apply_demorgan.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ada51f2ac499b9746d619a98afbccdec0212b5d6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada51f2ac499b9746d619a98afbccdec0212b5d6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fapply_demorgan.rs?ref=ada51f2ac499b9746d619a98afbccdec0212b5d6", "patch": "@@ -42,10 +42,11 @@ pub(crate) fn apply_demorgan(acc: &mut Assists, ctx: &AssistContext) -> Option<(\n \n     // Walk up the tree while we have the same binary operator\n     while let Some(parent_expr) = expr.syntax().parent().and_then(ast::BinExpr::cast) {\n-        if let Some(parent_op) = expr.op_kind() {\n-            if parent_op == op {\n-                expr = parent_expr\n+        match expr.op_kind() {\n+            Some(parent_op) if parent_op == op => {\n+                expr = parent_expr;\n             }\n+            _ => break,\n         }\n     }\n \n@@ -220,4 +221,14 @@ fn f() { !(S <= S || S < S) }\n         cov_mark::check!(demorgan_double_parens);\n         check_assist(apply_demorgan, \"fn f() { (x ||$0 x) }\", \"fn f() { !(!x && !x) }\")\n     }\n+\n+    // https://github.com/rust-analyzer/rust-analyzer/issues/10963\n+    #[test]\n+    fn demorgan_doesnt_hang() {\n+        check_assist(\n+            apply_demorgan,\n+            \"fn f() { 1 || 3 &&$0 4 || 5 }\",\n+            \"fn f() { !(!1 || !3 || !4) || 5 }\",\n+        )\n+    }\n }"}, {"sha": "aaed2b67fe8f56b087a5b5762e8d41129107411a", "filename": "crates/ide_assists/src/handlers/extract_variable.rs", "status": "modified", "additions": 352, "deletions": 2, "changes": 354, "blob_url": "https://github.com/rust-lang/rust/blob/ada51f2ac499b9746d619a98afbccdec0212b5d6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ada51f2ac499b9746d619a98afbccdec0212b5d6/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fextract_variable.rs?ref=ada51f2ac499b9746d619a98afbccdec0212b5d6", "patch": "@@ -52,6 +52,12 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n         }\n     }\n \n+    let reference_modifier = match get_receiver_type(&ctx, &to_extract) {\n+        Some(receiver_type) if receiver_type.is_mutable_reference() => \"&mut \",\n+        Some(receiver_type) if receiver_type.is_reference() => \"&\",\n+        _ => \"\",\n+    };\n+\n     let anchor = Anchor::from(&to_extract)?;\n     let indent = anchor.syntax().prev_sibling_or_token()?.as_token()?.clone();\n     let target = to_extract.syntax().text_range();\n@@ -79,9 +85,11 @@ pub(crate) fn extract_variable(acc: &mut Assists, ctx: &AssistContext) -> Option\n \n             match anchor {\n                 Anchor::Before(_) | Anchor::Replace(_) => {\n-                    format_to!(buf, \"let {} = \", var_name)\n+                    format_to!(buf, \"let {} = {}\", var_name, reference_modifier)\n+                }\n+                Anchor::WrapInBlock(_) => {\n+                    format_to!(buf, \"{{ let {} = {}\", var_name, reference_modifier)\n                 }\n-                Anchor::WrapInBlock(_) => format_to!(buf, \"{{ let {} = \", var_name),\n             };\n             format_to!(buf, \"{}\", to_extract.syntax());\n \n@@ -146,6 +154,22 @@ fn valid_target_expr(node: SyntaxNode) -> Option<ast::Expr> {\n     }\n }\n \n+fn get_receiver_type(ctx: &AssistContext, expression: &ast::Expr) -> Option<hir::Type> {\n+    let receiver = get_receiver(expression.clone())?;\n+    Some(ctx.sema.type_of_expr(&receiver)?.original())\n+}\n+\n+/// In the expression `a.b.c.x()`, find `a`\n+fn get_receiver(expression: ast::Expr) -> Option<ast::Expr> {\n+    match expression {\n+        ast::Expr::FieldExpr(field) if field.expr().is_some() => {\n+            let nested_expression = &field.expr()?;\n+            get_receiver(nested_expression.to_owned())\n+        }\n+        _ => Some(expression),\n+    }\n+}\n+\n #[derive(Debug)]\n enum Anchor {\n     Before(SyntaxNode),\n@@ -900,4 +924,330 @@ const X: usize = $0100$0;\n \",\n         );\n     }\n+\n+    #[test]\n+    fn test_extract_var_mutable_reference_parameter() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct S {\n+    vec: Vec<u8>\n+}\n+\n+fn foo(s: &mut S) {\n+    $0s.vec$0.push(0);\n+}\"#,\n+            r#\"\n+struct S {\n+    vec: Vec<u8>\n+}\n+\n+fn foo(s: &mut S) {\n+    let $0var_name = &mut s.vec;\n+    var_name.push(0);\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_var_mutable_reference_parameter_deep_nesting() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct Y {\n+    field: X\n+}\n+struct X {\n+    field: S\n+}\n+struct S {\n+    vec: Vec<u8>\n+}\n+\n+fn foo(f: &mut Y) {\n+    $0f.field.field.vec$0.push(0);\n+}\"#,\n+            r#\"\n+struct Y {\n+    field: X\n+}\n+struct X {\n+    field: S\n+}\n+struct S {\n+    vec: Vec<u8>\n+}\n+\n+fn foo(f: &mut Y) {\n+    let $0var_name = &mut f.field.field.vec;\n+    var_name.push(0);\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_var_reference_parameter() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct X;\n+\n+impl X {\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+struct S {\n+    sub: X\n+}\n+\n+fn foo(s: &S) {\n+    $0s.sub$0.do_thing();\n+}\"#,\n+            r#\"\n+struct X;\n+\n+impl X {\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+struct S {\n+    sub: X\n+}\n+\n+fn foo(s: &S) {\n+    let $0x = &s.sub;\n+    x.do_thing();\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_var_reference_parameter_deep_nesting() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct Z;\n+impl Z {\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+struct Y {\n+    field: Z\n+}\n+\n+struct X {\n+    field: Y\n+}\n+\n+struct S {\n+    sub: X\n+}\n+\n+fn foo(s: &S) {\n+    $0s.sub.field.field$0.do_thing();\n+}\"#,\n+            r#\"\n+struct Z;\n+impl Z {\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+struct Y {\n+    field: Z\n+}\n+\n+struct X {\n+    field: Y\n+}\n+\n+struct S {\n+    sub: X\n+}\n+\n+fn foo(s: &S) {\n+    let $0z = &s.sub.field.field;\n+    z.do_thing();\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_var_regular_parameter() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct X;\n+\n+impl X {\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+struct S {\n+    sub: X\n+}\n+\n+fn foo(s: S) {\n+    $0s.sub$0.do_thing();\n+}\"#,\n+            r#\"\n+struct X;\n+\n+impl X {\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+struct S {\n+    sub: X\n+}\n+\n+fn foo(s: S) {\n+    let $0x = s.sub;\n+    x.do_thing();\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_var_mutable_reference_local() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct X;\n+\n+struct S {\n+    sub: X\n+}\n+\n+impl S {\n+    fn new() -> S {\n+        S {\n+            sub: X::new()\n+        }\n+    }\n+}\n+\n+impl X {\n+    fn new() -> X {\n+        X { }\n+    }\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+\n+fn foo() {\n+    let local = &mut S::new();\n+    $0local.sub$0.do_thing();\n+}\"#,\n+            r#\"\n+struct X;\n+\n+struct S {\n+    sub: X\n+}\n+\n+impl S {\n+    fn new() -> S {\n+        S {\n+            sub: X::new()\n+        }\n+    }\n+}\n+\n+impl X {\n+    fn new() -> X {\n+        X { }\n+    }\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+\n+fn foo() {\n+    let local = &mut S::new();\n+    let $0x = &mut local.sub;\n+    x.do_thing();\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_extract_var_reference_local() {\n+        check_assist(\n+            extract_variable,\n+            r#\"\n+struct X;\n+\n+struct S {\n+    sub: X\n+}\n+\n+impl S {\n+    fn new() -> S {\n+        S {\n+            sub: X::new()\n+        }\n+    }\n+}\n+\n+impl X {\n+    fn new() -> X {\n+        X { }\n+    }\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+\n+fn foo() {\n+    let local = &S::new();\n+    $0local.sub$0.do_thing();\n+}\"#,\n+            r#\"\n+struct X;\n+\n+struct S {\n+    sub: X\n+}\n+\n+impl S {\n+    fn new() -> S {\n+        S {\n+            sub: X::new()\n+        }\n+    }\n+}\n+\n+impl X {\n+    fn new() -> X {\n+        X { }\n+    }\n+    fn do_thing(&self) {\n+\n+    }\n+}\n+\n+\n+fn foo() {\n+    let local = &S::new();\n+    let $0x = &local.sub;\n+    x.do_thing();\n+}\"#,\n+        );\n+    }\n }"}]}