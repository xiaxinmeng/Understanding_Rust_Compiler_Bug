{"sha": "738868b2ff5ab22057757bcd07f70f018285159d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjczODg2OGIyZmY1YWIyMjA1Nzc1N2JjZDA3ZjcwZjAxODI4NTE1OWQ=", "commit": {"author": {"name": "Hans Kratz", "email": "hans@appfour.com", "date": "2021-07-18T10:17:15Z"}, "committer": {"name": "Hans Kratz", "email": "hans@appfour.com", "date": "2021-08-04T21:36:13Z"}, "message": "LLVM codegen: Don't emit zero-sized padding for fields\n\nLLVM codegen: Don't emit zero-sized padding for whiles because that has no use and makes it impossible to generate the return types that LLVM expects for certain ARM SIMD intrinsics.", "tree": {"sha": "09164ee96465c545f61acf7981e79367b5c0b308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/09164ee96465c545f61acf7981e79367b5c0b308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/738868b2ff5ab22057757bcd07f70f018285159d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/738868b2ff5ab22057757bcd07f70f018285159d", "html_url": "https://github.com/rust-lang/rust/commit/738868b2ff5ab22057757bcd07f70f018285159d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/738868b2ff5ab22057757bcd07f70f018285159d/comments", "author": {"login": "hkratz", "id": 3736990, "node_id": "MDQ6VXNlcjM3MzY5OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3736990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkratz", "html_url": "https://github.com/hkratz", "followers_url": "https://api.github.com/users/hkratz/followers", "following_url": "https://api.github.com/users/hkratz/following{/other_user}", "gists_url": "https://api.github.com/users/hkratz/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkratz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkratz/subscriptions", "organizations_url": "https://api.github.com/users/hkratz/orgs", "repos_url": "https://api.github.com/users/hkratz/repos", "events_url": "https://api.github.com/users/hkratz/events{/privacy}", "received_events_url": "https://api.github.com/users/hkratz/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hkratz", "id": 3736990, "node_id": "MDQ6VXNlcjM3MzY5OTA=", "avatar_url": "https://avatars.githubusercontent.com/u/3736990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hkratz", "html_url": "https://github.com/hkratz", "followers_url": "https://api.github.com/users/hkratz/followers", "following_url": "https://api.github.com/users/hkratz/following{/other_user}", "gists_url": "https://api.github.com/users/hkratz/gists{/gist_id}", "starred_url": "https://api.github.com/users/hkratz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hkratz/subscriptions", "organizations_url": "https://api.github.com/users/hkratz/orgs", "repos_url": "https://api.github.com/users/hkratz/repos", "events_url": "https://api.github.com/users/hkratz/events{/privacy}", "received_events_url": "https://api.github.com/users/hkratz/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d54fbb98555c107fb62fb5ae1a5b8f4fc6ed3edc", "url": "https://api.github.com/repos/rust-lang/rust/commits/d54fbb98555c107fb62fb5ae1a5b8f4fc6ed3edc", "html_url": "https://github.com/rust-lang/rust/commit/d54fbb98555c107fb62fb5ae1a5b8f4fc6ed3edc"}], "stats": {"total": 53, "additions": 36, "deletions": 17}, "files": [{"sha": "b01bef01566c06d46f3fc8e58a279e44a9e26b88", "filename": "compiler/rustc_codegen_llvm/src/type_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/738868b2ff5ab22057757bcd07f70f018285159d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/738868b2ff5ab22057757bcd07f70f018285159d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_.rs?ref=738868b2ff5ab22057757bcd07f70f018285159d", "patch": "@@ -262,7 +262,7 @@ impl LayoutTypeMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         layout.is_llvm_scalar_pair()\n     }\n     fn backend_field_index(&self, layout: TyAndLayout<'tcx>, index: usize) -> u64 {\n-        layout.llvm_field_index(index)\n+        layout.llvm_field_index(self, index)\n     }\n     fn scalar_pair_element_backend_type(\n         &self,"}, {"sha": "91d4cfdd77b32cacb5589033506e1649f3c0b869", "filename": "compiler/rustc_codegen_llvm/src/type_of.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/738868b2ff5ab22057757bcd07f70f018285159d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/738868b2ff5ab22057757bcd07f70f018285159d/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Ftype_of.rs?ref=738868b2ff5ab22057757bcd07f70f018285159d", "patch": "@@ -116,11 +116,12 @@ fn struct_llfields<'a, 'tcx>(\n         );\n         assert!(target_offset >= offset);\n         let padding = target_offset - offset;\n-        let padding_align = prev_effective_align.min(effective_field_align);\n-        assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n-        result.push(cx.type_padding_filler(padding, padding_align));\n-        debug!(\"    padding before: {:?}\", padding);\n-\n+        if padding != Size::ZERO {\n+            let padding_align = prev_effective_align.min(effective_field_align);\n+            assert_eq!(offset.align_to(padding_align) + padding, target_offset);\n+            result.push(cx.type_padding_filler(padding, padding_align));\n+            debug!(\"    padding before: {:?}\", padding);\n+        }\n         result.push(field.llvm_type(cx));\n         offset = target_offset + field.size;\n         prev_effective_align = effective_field_align;\n@@ -130,14 +131,15 @@ fn struct_llfields<'a, 'tcx>(\n             bug!(\"layout: {:#?} stride: {:?} offset: {:?}\", layout, layout.size, offset);\n         }\n         let padding = layout.size - offset;\n-        let padding_align = prev_effective_align;\n-        assert_eq!(offset.align_to(padding_align) + padding, layout.size);\n-        debug!(\n-            \"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n-            padding, offset, layout.size\n-        );\n-        result.push(cx.type_padding_filler(padding, padding_align));\n-        assert_eq!(result.len(), 1 + field_count * 2);\n+        if padding != Size::ZERO {\n+            let padding_align = prev_effective_align;\n+            assert_eq!(offset.align_to(padding_align) + padding, layout.size);\n+            debug!(\n+                \"struct_llfields: pad_bytes: {:?} offset: {:?} stride: {:?}\",\n+                padding, offset, layout.size\n+            );\n+            result.push(cx.type_padding_filler(padding, padding_align));\n+        }\n     } else {\n         debug!(\"struct_llfields: offset: {:?} stride: {:?}\", offset, layout.size);\n     }\n@@ -177,7 +179,7 @@ pub trait LayoutLlvmExt<'tcx> {\n         index: usize,\n         immediate: bool,\n     ) -> &'a Type;\n-    fn llvm_field_index(&self, index: usize) -> u64;\n+    fn llvm_field_index<'a>(&self, cx: &CodegenCx<'a, 'tcx>, index: usize) -> u64;\n     fn pointee_info_at<'a>(&self, cx: &CodegenCx<'a, 'tcx>, offset: Size) -> Option<PointeeInfo>;\n }\n \n@@ -340,7 +342,7 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n         self.scalar_llvm_type_at(cx, scalar, offset)\n     }\n \n-    fn llvm_field_index(&self, index: usize) -> u64 {\n+    fn llvm_field_index<'a>(&self, cx: &CodegenCx<'a, 'tcx>, index: usize) -> u64 {\n         match self.abi {\n             Abi::Scalar(_) | Abi::ScalarPair(..) => {\n                 bug!(\"TyAndLayout::llvm_field_index({:?}): not applicable\", self)\n@@ -354,7 +356,24 @@ impl<'tcx> LayoutLlvmExt<'tcx> for TyAndLayout<'tcx> {\n \n             FieldsShape::Array { .. } => index as u64,\n \n-            FieldsShape::Arbitrary { .. } => 1 + (self.fields.memory_index(index) as u64) * 2,\n+            FieldsShape::Arbitrary { .. } => {\n+                let mut llvm_index = 0;\n+                let mut offset = Size::ZERO;\n+                for i in self.fields.index_by_increasing_offset() {\n+                    let target_offset = self.fields.offset(i as usize);\n+                    let field = self.field(cx, i);\n+                    let padding = target_offset - offset;\n+                    if padding != Size::ZERO {\n+                        llvm_index += 1;\n+                    }\n+                    if i == index {\n+                        return llvm_index;\n+                    }\n+                    offset = target_offset + field.size;\n+                    llvm_index += 1;\n+                }\n+                bug!(\"TyAndLayout::llvm_field_index({:?}): index {} out of range\", self, index)\n+            }\n         }\n     }\n "}]}