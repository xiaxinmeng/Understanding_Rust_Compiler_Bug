{"sha": "da545cee6057eddc0cf64767870a1cdc087ade1f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhNTQ1Y2VlNjA1N2VkZGMwY2Y2NDc2Nzg3MGExY2RjMDg3YWRlMWY=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-01-26T05:14:54Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2018-01-27T00:56:49Z"}, "message": "Make region inference use a dirty list\n\nFixes #47602", "tree": {"sha": "669afc706bd24bf470d5b2ca412c2357e60452bd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/669afc706bd24bf470d5b2ca412c2357e60452bd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/da545cee6057eddc0cf64767870a1cdc087ade1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/da545cee6057eddc0cf64767870a1cdc087ade1f", "html_url": "https://github.com/rust-lang/rust/commit/da545cee6057eddc0cf64767870a1cdc087ade1f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/da545cee6057eddc0cf64767870a1cdc087ade1f/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82", "url": "https://api.github.com/repos/rust-lang/rust/commits/a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82", "html_url": "https://github.com/rust-lang/rust/commit/a97cd17f5d71fb4ec362f4fbd79373a6e7ed7b82"}], "stats": {"total": 83, "additions": 59, "deletions": 24}, "files": [{"sha": "80cdb0e441790fac9971f6668e3135b25af6b9f6", "filename": "src/librustc_data_structures/bitvec.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/da545cee6057eddc0cf64767870a1cdc087ade1f/src%2Flibrustc_data_structures%2Fbitvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da545cee6057eddc0cf64767870a1cdc087ade1f/src%2Flibrustc_data_structures%2Fbitvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbitvec.rs?ref=da545cee6057eddc0cf64767870a1cdc087ade1f", "patch": "@@ -51,6 +51,17 @@ impl BitVector {\n         new_value != value\n     }\n \n+    /// Returns true if the bit has changed.\n+    #[inline]\n+    pub fn remove(&mut self, bit: usize) -> bool {\n+        let (word, mask) = word_mask(bit);\n+        let data = &mut self.data[word];\n+        let value = *data;\n+        let new_value = value & !mask;\n+        *data = new_value;\n+        new_value != value\n+    }\n+\n     #[inline]\n     pub fn insert_all(&mut self, all: &BitVector) -> bool {\n         assert!(self.data.len() == all.data.len());"}, {"sha": "f316a8b480db49e050b92519979e9039e99b6310", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 48, "deletions": 24, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/da545cee6057eddc0cf64767870a1cdc087ade1f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/da545cee6057eddc0cf64767870a1cdc087ade1f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=da545cee6057eddc0cf64767870a1cdc087ade1f", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use std::collections::HashMap;\n+\n use super::universal_regions::UniversalRegions;\n use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n@@ -22,6 +24,7 @@ use rustc::mir::{ClosureOutlivesRequirement, ClosureOutlivesSubject, ClosureRegi\n use rustc::traits::ObligationCause;\n use rustc::ty::{self, RegionVid, Ty, TypeFoldable};\n use rustc::util::common::ErrorReported;\n+use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::IndexVec;\n use rustc_errors::DiagnosticBuilder;\n use std::fmt;\n@@ -452,8 +455,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// satisfied. Note that some values may grow **too** large to be\n     /// feasible, but we check this later.\n     fn propagate_constraints(&mut self, mir: &Mir<'tcx>) {\n-        let mut changed = true;\n-\n         debug!(\"propagate_constraints()\");\n         debug!(\"propagate_constraints: constraints={:#?}\", {\n             let mut constraints: Vec<_> = self.constraints.iter().collect();\n@@ -465,37 +466,60 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // constraints we have accumulated.\n         let mut inferred_values = self.liveness_constraints.clone();\n \n-        while changed {\n-            changed = false;\n-            debug!(\"propagate_constraints: --------------------\");\n-            for constraint in &self.constraints {\n-                debug!(\"propagate_constraints: constraint={:?}\", constraint);\n-\n-                // Grow the value as needed to accommodate the\n-                // outlives constraint.\n-                let Ok(made_changes) = self.dfs(\n-                    mir,\n-                    CopyFromSourceToTarget {\n-                        source_region: constraint.sub,\n-                        target_region: constraint.sup,\n-                        inferred_values: &mut inferred_values,\n-                        constraint_point: constraint.point,\n-                        constraint_span: constraint.span,\n-                    },\n-                );\n+        let dependency_map = self.build_dependency_map();\n+        let mut dirty_list: Vec<_> = (0..self.constraints.len()).collect();\n+        let mut dirty_bit_vec = BitVector::new(dirty_list.len());\n+\n+        debug!(\"propagate_constraints: --------------------\");\n+        while let Some(constraint_idx) = dirty_list.pop() {\n+            dirty_bit_vec.remove(constraint_idx);\n+\n+            let constraint = &self.constraints[constraint_idx];\n+            debug!(\"propagate_constraints: constraint={:?}\", constraint);\n+\n+            // Grow the value as needed to accommodate the\n+            // outlives constraint.\n+            let Ok(made_changes) = self.dfs(\n+                mir,\n+                CopyFromSourceToTarget {\n+                    source_region: constraint.sub,\n+                    target_region: constraint.sup,\n+                    inferred_values: &mut inferred_values,\n+                    constraint_point: constraint.point,\n+                    constraint_span: constraint.span,\n+                },\n+            );\n+\n+            if made_changes {\n+                debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n+                debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n \n-                if made_changes {\n-                    debug!(\"propagate_constraints:   sub={:?}\", constraint.sub);\n-                    debug!(\"propagate_constraints:   sup={:?}\", constraint.sup);\n-                    changed = true;\n+                for &dep_idx in dependency_map.get(&constraint.sup).unwrap_or(&vec![]) {\n+                    if dirty_bit_vec.insert(dep_idx) {\n+                        dirty_list.push(dep_idx);\n+                    }\n                 }\n             }\n+\n             debug!(\"\\n\");\n         }\n \n         self.inferred_values = Some(inferred_values);\n     }\n \n+    /// Builds up a map from each region variable X to a vector with the indices of constraints that\n+    /// need to be re-evaluated when X changes. These are constraints like Y: X @ P -- so if X\n+    /// changed, we may need to grow Y.\n+    fn build_dependency_map(&self) -> HashMap<RegionVid, Vec<usize>> {\n+        let mut map = HashMap::new();\n+\n+        for (idx, constraint) in self.constraints.iter().enumerate() {\n+            map.entry(constraint.sub).or_insert(Vec::new()).push(idx);\n+        }\n+\n+        map\n+    }\n+\n     /// Once regions have been propagated, this method is used to see\n     /// whether the \"type tests\" produced by typeck were satisfied;\n     /// type tests encode type-outlives relationships like `T:"}]}