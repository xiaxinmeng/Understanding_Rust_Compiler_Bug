{"sha": "d73161b491ec670413c847639d3c5aa58a6a89b4", "node_id": "C_kwDOAAsO6NoAKGQ3MzE2MWI0OTFlYzY3MDQxM2M4NDc2MzlkM2M1YWE1OGE2YTg5YjQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-07T07:34:45Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-07T07:34:45Z"}, "message": "Auto merge of #14524 - Veykril:hir-pretty, r=Veykril\n\ninternal: Render function parameters in hir-def pretty printing", "tree": {"sha": "35420ded5e67ff3df5af1c8fba46aa2114703b41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/35420ded5e67ff3df5af1c8fba46aa2114703b41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d73161b491ec670413c847639d3c5aa58a6a89b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d73161b491ec670413c847639d3c5aa58a6a89b4", "html_url": "https://github.com/rust-lang/rust/commit/d73161b491ec670413c847639d3c5aa58a6a89b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d73161b491ec670413c847639d3c5aa58a6a89b4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "937ef97bc566d5b7ceac2c7a7711ef7a734b1614", "url": "https://api.github.com/repos/rust-lang/rust/commits/937ef97bc566d5b7ceac2c7a7711ef7a734b1614", "html_url": "https://github.com/rust-lang/rust/commit/937ef97bc566d5b7ceac2c7a7711ef7a734b1614"}, {"sha": "513d4a9c9a1814dcc6179d6f38e38b13dee3f72d", "url": "https://api.github.com/repos/rust-lang/rust/commits/513d4a9c9a1814dcc6179d6f38e38b13dee3f72d", "html_url": "https://github.com/rust-lang/rust/commit/513d4a9c9a1814dcc6179d6f38e38b13dee3f72d"}], "stats": {"total": 408, "additions": 201, "deletions": 207}, "files": [{"sha": "9caa084f2a2a311b57db7583a7a884163720fc1c", "filename": "crates/hir-def/src/body.rs", "status": "modified", "additions": 41, "deletions": 4, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-def%2Fsrc%2Fbody.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-def%2Fsrc%2Fbody.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody.rs?ref=d73161b491ec670413c847639d3c5aa58a6a89b4", "patch": "@@ -13,11 +13,12 @@ use cfg::{CfgExpr, CfgOptions};\n use drop_bomb::DropBomb;\n use either::Either;\n use hir_expand::{\n-    attrs::RawAttrs, hygiene::Hygiene, name::Name, ExpandError, ExpandResult, HirFileId, InFile,\n-    MacroCallId,\n+    ast_id_map::AstIdMap, attrs::RawAttrs, hygiene::Hygiene, name::Name, AstId, ExpandError,\n+    ExpandResult, HirFileId, InFile, MacroCallId,\n };\n use la_arena::{Arena, ArenaMap};\n use limit::Limit;\n+use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use syntax::{ast, AstPtr, SyntaxNode, SyntaxNodePtr};\n@@ -37,7 +38,43 @@ use crate::{\n     UnresolvedMacro,\n };\n \n-pub use lower::LowerCtx;\n+pub struct LowerCtx<'a> {\n+    pub db: &'a dyn DefDatabase,\n+    hygiene: Hygiene,\n+    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n+}\n+\n+impl<'a> LowerCtx<'a> {\n+    pub fn new(db: &'a dyn DefDatabase, hygiene: &Hygiene, file_id: HirFileId) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: Some((file_id, OnceCell::new())) }\n+    }\n+\n+    pub fn with_file_id(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n+        LowerCtx {\n+            db,\n+            hygiene: Hygiene::new(db.upcast(), file_id),\n+            ast_id_map: Some((file_id, OnceCell::new())),\n+        }\n+    }\n+\n+    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n+        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n+    }\n+\n+    pub(crate) fn hygiene(&self) -> &Hygiene {\n+        &self.hygiene\n+    }\n+\n+    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n+        Path::from_src(ast, self)\n+    }\n+\n+    pub(crate) fn ast_id<N: syntax::AstNode>(&self, item: &N) -> Option<AstId<N>> {\n+        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n+        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n+        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n+    }\n+}\n \n /// A subset of Expander that only deals with cfg attributes. We only need it to\n /// avoid cyclic queries in crate def map during enum processing.\n@@ -241,7 +278,7 @@ impl Expander {\n             // The overflow error should have been reported when it occurred (see the next branch),\n             // so don't return overflow error here to avoid diagnostics duplication.\n             cov_mark::hit!(overflow_but_not_me);\n-            return ExpandResult::only_err(ExpandError::RecursionOverflowPosioned);\n+            return ExpandResult::only_err(ExpandError::RecursionOverflowPoisoned);\n         } else if self.recursion_limit(db).check(self.recursion_depth + 1).is_err() {\n             self.recursion_depth = usize::MAX;\n             cov_mark::hit!(your_stack_belongs_to_me);"}, {"sha": "e6bea706d838b46da986b8354c015abefeae4195", "filename": "crates/hir-def/src/body/lower.rs", "status": "modified", "additions": 100, "deletions": 188, "changes": 288, "blob_url": "https://github.com/rust-lang/rust/blob/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Flower.rs?ref=d73161b491ec670413c847639d3c5aa58a6a89b4", "patch": "@@ -7,36 +7,30 @@ use base_db::CrateId;\n use either::Either;\n use hir_expand::{\n     ast_id_map::AstIdMap,\n-    hygiene::Hygiene,\n     name::{name, AsName, Name},\n-    AstId, ExpandError, HirFileId, InFile,\n+    AstId, ExpandError, InFile,\n };\n use intern::Interned;\n use la_arena::Arena;\n-use once_cell::unsync::OnceCell;\n use profile::Count;\n use rustc_hash::FxHashMap;\n use smallvec::SmallVec;\n use syntax::{\n     ast::{\n-        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasLoopBody, HasName, LiteralKind,\n+        self, ArrayExprKind, AstChildren, BlockExpr, HasArgList, HasLoopBody, HasName,\n         SlicePatComponents,\n     },\n     AstNode, AstPtr, SyntaxNodePtr,\n };\n \n use crate::{\n-    body::{\n-        Body, BodyDiagnostic, BodySourceMap, Expander, ExprPtr, ExprSource, LabelPtr, LabelSource,\n-        PatPtr, PatSource,\n-    },\n-    builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n+    body::{Body, BodyDiagnostic, BodySourceMap, Expander, ExprPtr, LabelPtr, LowerCtx, PatPtr},\n     data::adt::StructKind,\n     db::DefDatabase,\n     hir::{\n         dummy_expr_id, Array, Binding, BindingAnnotation, BindingId, ClosureKind, Expr, ExprId,\n-        FloatTypeWrapper, Label, LabelId, Literal, MatchArm, Movability, Pat, PatId,\n-        RecordFieldPat, RecordLitField, Statement,\n+        Label, LabelId, Literal, MatchArm, Movability, Pat, PatId, RecordFieldPat, RecordLitField,\n+        Statement,\n     },\n     item_scope::BuiltinShadowMode,\n     lang_item::LangItem,\n@@ -45,44 +39,6 @@ use crate::{\n     AdtId, BlockId, BlockLoc, ModuleDefId, UnresolvedMacro,\n };\n \n-pub struct LowerCtx<'a> {\n-    pub db: &'a dyn DefDatabase,\n-    hygiene: Hygiene,\n-    ast_id_map: Option<(HirFileId, OnceCell<Arc<AstIdMap>>)>,\n-}\n-\n-impl<'a> LowerCtx<'a> {\n-    pub fn new(db: &'a dyn DefDatabase, hygiene: &Hygiene, file_id: HirFileId) -> Self {\n-        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: Some((file_id, OnceCell::new())) }\n-    }\n-\n-    pub fn with_file_id(db: &'a dyn DefDatabase, file_id: HirFileId) -> Self {\n-        LowerCtx {\n-            db,\n-            hygiene: Hygiene::new(db.upcast(), file_id),\n-            ast_id_map: Some((file_id, OnceCell::new())),\n-        }\n-    }\n-\n-    pub fn with_hygiene(db: &'a dyn DefDatabase, hygiene: &Hygiene) -> Self {\n-        LowerCtx { db, hygiene: hygiene.clone(), ast_id_map: None }\n-    }\n-\n-    pub(crate) fn hygiene(&self) -> &Hygiene {\n-        &self.hygiene\n-    }\n-\n-    pub(crate) fn lower_path(&self, ast: ast::Path) -> Option<Path> {\n-        Path::from_src(ast, self)\n-    }\n-\n-    pub(crate) fn ast_id<N: AstNode>(&self, item: &N) -> Option<AstId<N>> {\n-        let &(file_id, ref ast_id_map) = self.ast_id_map.as_ref()?;\n-        let ast_id_map = ast_id_map.get_or_init(|| self.db.ast_id_map(file_id));\n-        Some(InFile::new(file_id, ast_id_map.ast_id(item)))\n-    }\n-}\n-\n pub(super) fn lower(\n     db: &dyn DefDatabase,\n     expander: Expander,\n@@ -119,12 +75,22 @@ struct ExprCollector<'a> {\n     db: &'a dyn DefDatabase,\n     expander: Expander,\n     ast_id_map: Arc<AstIdMap>,\n-    body: Body,\n     krate: CrateId,\n+    body: Body,\n     source_map: BodySourceMap,\n-    current_try_block_label: Option<LabelId>,\n+\n     is_lowering_assignee_expr: bool,\n     is_lowering_generator: bool,\n+\n+    current_try_block_label: Option<LabelId>,\n+    // points to the expression that a try expression will target (replaces current_try_block_label)\n+    // catch_scope: Option<ExprId>,\n+    // points to the expression that an unlabeled control flow will target\n+    // loop_scope: Option<ExprId>,\n+    // needed to diagnose non label control flow in while conditions\n+    // is_in_loop_condition: bool,\n+\n+    // resolution\n     label_ribs: Vec<LabelRib>,\n }\n \n@@ -202,12 +168,9 @@ impl ExprCollector<'_> {\n                 self.body.params.push(param_pat);\n             }\n \n-            for pat in param_list\n-                .params()\n-                .zip(attr_enabled)\n-                .filter_map(|(param, enabled)| param.pat().filter(|_| enabled))\n+            for (param, _) in param_list.params().zip(attr_enabled).filter(|(_, enabled)| *enabled)\n             {\n-                let param_pat = self.collect_pat(pat);\n+                let param_pat = self.collect_pat_top(param.pat());\n                 self.body.params.push(param_pat);\n             }\n         };\n@@ -236,63 +199,6 @@ impl ExprCollector<'_> {\n         self.expander.ctx(self.db)\n     }\n \n-    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_expr(expr, src.clone());\n-        self.source_map.expr_map.insert(src, id);\n-        id\n-    }\n-    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed somehow.\n-    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n-        self.body.exprs.alloc(expr)\n-    }\n-    fn missing_expr(&mut self) -> ExprId {\n-        self.alloc_expr_desugared(Expr::Missing)\n-    }\n-    fn make_expr(&mut self, expr: Expr, src: ExprSource) -> ExprId {\n-        let id = self.body.exprs.alloc(expr);\n-        self.source_map.expr_map_back.insert(id, src);\n-        id\n-    }\n-\n-    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n-        self.body.bindings.alloc(Binding { name, mode, definitions: SmallVec::new() })\n-    }\n-    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_pat(pat, src.clone());\n-        self.source_map.pat_map.insert(src, id);\n-        id\n-    }\n-    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.\n-    fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {\n-        self.body.pats.alloc(pat)\n-    }\n-    fn missing_pat(&mut self) -> PatId {\n-        self.body.pats.alloc(Pat::Missing)\n-    }\n-    fn make_pat(&mut self, pat: Pat, src: PatSource) -> PatId {\n-        let id = self.body.pats.alloc(pat);\n-        self.source_map.pat_map_back.insert(id, src);\n-        id\n-    }\n-\n-    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {\n-        let src = self.expander.to_source(ptr);\n-        let id = self.make_label(label, src.clone());\n-        self.source_map.label_map.insert(src, id);\n-        id\n-    }\n-    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.\n-    fn alloc_label_desugared(&mut self, label: Label) -> LabelId {\n-        self.body.labels.alloc(label)\n-    }\n-    fn make_label(&mut self, label: Label, src: LabelSource) -> LabelId {\n-        let id = self.body.labels.alloc(label);\n-        self.source_map.label_map_back.insert(id, src);\n-        id\n-    }\n-\n     fn collect_expr(&mut self, expr: ast::Expr) -> ExprId {\n         self.maybe_collect_expr(expr).unwrap_or_else(|| self.missing_expr())\n     }\n@@ -320,7 +226,7 @@ impl ExprCollector<'_> {\n                 self.alloc_expr(Expr::If { condition, then_branch, else_branch }, syntax_ptr)\n             }\n             ast::Expr::LetExpr(e) => {\n-                let pat = self.collect_pat_opt(e.pat());\n+                let pat = self.collect_pat_top(e.pat());\n                 let expr = self.collect_expr_opt(e.expr());\n                 self.alloc_expr(Expr::Let { pat, expr }, syntax_ptr)\n             }\n@@ -379,7 +285,7 @@ impl ExprCollector<'_> {\n             ast::Expr::ForExpr(e) => {\n                 let label = e.label().map(|label| self.collect_label(label));\n                 let iterable = self.collect_expr_opt(e.iterable());\n-                let pat = self.collect_pat_opt(e.pat());\n+                let pat = self.collect_pat_top(e.pat());\n                 let body = self.collect_labelled_block_opt(label, e.loop_body());\n                 self.alloc_expr(Expr::For { iterable, pat, body, label }, syntax_ptr)\n             }\n@@ -419,7 +325,7 @@ impl ExprCollector<'_> {\n                         .arms()\n                         .filter_map(|arm| {\n                             self.check_cfg(&arm).map(|()| MatchArm {\n-                                pat: self.collect_pat_opt(arm.pat()),\n+                                pat: self.collect_pat_top(arm.pat()),\n                                 expr: self.collect_expr_opt(arm.expr()),\n                                 guard: arm\n                                     .guard()\n@@ -559,7 +465,7 @@ impl ExprCollector<'_> {\n                 let mut arg_types = Vec::new();\n                 if let Some(pl) = e.param_list() {\n                     for param in pl.params() {\n-                        let pat = this.collect_pat_opt(param.pat());\n+                        let pat = this.collect_pat_top(param.pat());\n                         let type_ref =\n                             param.ty().map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n                         args.push(pat);\n@@ -571,8 +477,7 @@ impl ExprCollector<'_> {\n                     .and_then(|r| r.ty())\n                     .map(|it| Interned::new(TypeRef::from_ast(&this.ctx(), it)));\n \n-                let prev_is_lowering_generator = this.is_lowering_generator;\n-                this.is_lowering_generator = false;\n+                let prev_is_lowering_generator = mem::take(&mut this.is_lowering_generator);\n \n                 let body = this.collect_expr_opt(e.body());\n \n@@ -850,7 +755,7 @@ impl ExprCollector<'_> {\n                         krate: *krate,\n                     });\n                 }\n-                Some(ExpandError::RecursionOverflowPosioned) => {\n+                Some(ExpandError::RecursionOverflowPoisoned) => {\n                     // Recursion limit has been reached in the macro expansion tree, but not in\n                     // this very macro call. Don't add diagnostics to avoid duplication.\n                 }\n@@ -931,7 +836,7 @@ impl ExprCollector<'_> {\n                 if self.check_cfg(&stmt).is_none() {\n                     return;\n                 }\n-                let pat = self.collect_pat_opt(stmt.pat());\n+                let pat = self.collect_pat_top(stmt.pat());\n                 let type_ref =\n                     stmt.ty().map(|it| Interned::new(TypeRef::from_ast(&self.ctx(), it)));\n                 let initializer = stmt.initializer().map(|e| self.collect_expr(e));\n@@ -1052,32 +957,23 @@ impl ExprCollector<'_> {\n         }\n     }\n \n-    fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {\n-        let label = Label {\n-            name: ast_label.lifetime().as_ref().map_or_else(Name::missing, Name::new_lifetime),\n-        };\n-        self.alloc_label(label, AstPtr::new(&ast_label))\n-    }\n-\n-    fn collect_pat(&mut self, pat: ast::Pat) -> PatId {\n-        self.collect_pat_(pat, &mut BindingList::default())\n-    }\n+    // region: patterns\n \n-    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>) -> PatId {\n+    fn collect_pat_top(&mut self, pat: Option<ast::Pat>) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat(pat),\n+            Some(pat) => self.collect_pat(pat, &mut BindingList::default()),\n             None => self.missing_pat(),\n         }\n     }\n \n-    fn collect_pat_(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n+    fn collect_pat(&mut self, pat: ast::Pat, binding_list: &mut BindingList) -> PatId {\n         let pattern = match &pat {\n             ast::Pat::IdentPat(bp) => {\n                 let name = bp.name().map(|nr| nr.as_name()).unwrap_or_else(Name::missing);\n \n                 let annotation =\n                     BindingAnnotation::new(bp.mut_token().is_some(), bp.ref_token().is_some());\n-                let subpat = bp.pat().map(|subpat| self.collect_pat_(subpat, binding_list));\n+                let subpat = bp.pat().map(|subpat| self.collect_pat(subpat, binding_list));\n \n                 let is_simple_ident_pat =\n                     annotation == BindingAnnotation::Unannotated && subpat.is_none();\n@@ -1131,7 +1027,7 @@ impl ExprCollector<'_> {\n                 Pat::TupleStruct { path, args, ellipsis }\n             }\n             ast::Pat::RefPat(p) => {\n-                let pat = self.collect_pat_opt_(p.pat(), binding_list);\n+                let pat = self.collect_pat_opt(p.pat(), binding_list);\n                 let mutability = Mutability::from_mutable(p.mut_token().is_some());\n                 Pat::Ref { pat, mutability }\n             }\n@@ -1141,10 +1037,10 @@ impl ExprCollector<'_> {\n                 path.map(Pat::Path).unwrap_or(Pat::Missing)\n             }\n             ast::Pat::OrPat(p) => {\n-                let pats = p.pats().map(|p| self.collect_pat_(p, binding_list)).collect();\n+                let pats = p.pats().map(|p| self.collect_pat(p, binding_list)).collect();\n                 Pat::Or(pats)\n             }\n-            ast::Pat::ParenPat(p) => return self.collect_pat_opt_(p.pat(), binding_list),\n+            ast::Pat::ParenPat(p) => return self.collect_pat_opt(p.pat(), binding_list),\n             ast::Pat::TuplePat(p) => {\n                 let (args, ellipsis) = self.collect_tuple_pat(p.fields(), binding_list);\n                 Pat::Tuple { args, ellipsis }\n@@ -1159,7 +1055,7 @@ impl ExprCollector<'_> {\n                     .fields()\n                     .filter_map(|f| {\n                         let ast_pat = f.pat()?;\n-                        let pat = self.collect_pat_(ast_pat, binding_list);\n+                        let pat = self.collect_pat(ast_pat, binding_list);\n                         let name = f.field_name()?.as_name();\n                         Some(RecordFieldPat { name, pat })\n                     })\n@@ -1178,15 +1074,9 @@ impl ExprCollector<'_> {\n \n                 // FIXME properly handle `RestPat`\n                 Pat::Slice {\n-                    prefix: prefix\n-                        .into_iter()\n-                        .map(|p| self.collect_pat_(p, binding_list))\n-                        .collect(),\n-                    slice: slice.map(|p| self.collect_pat_(p, binding_list)),\n-                    suffix: suffix\n-                        .into_iter()\n-                        .map(|p| self.collect_pat_(p, binding_list))\n-                        .collect(),\n+                    prefix: prefix.into_iter().map(|p| self.collect_pat(p, binding_list)).collect(),\n+                    slice: slice.map(|p| self.collect_pat(p, binding_list)),\n+                    suffix: suffix.into_iter().map(|p| self.collect_pat(p, binding_list)).collect(),\n                 }\n             }\n             #[rustfmt::skip] // https://github.com/rust-lang/rustfmt/issues/5676\n@@ -1217,7 +1107,7 @@ impl ExprCollector<'_> {\n                 Pat::Missing\n             }\n             ast::Pat::BoxPat(boxpat) => {\n-                let inner = self.collect_pat_opt_(boxpat.pat(), binding_list);\n+                let inner = self.collect_pat_opt(boxpat.pat(), binding_list);\n                 Pat::Box { inner }\n             }\n             ast::Pat::ConstBlockPat(const_block_pat) => {\n@@ -1235,7 +1125,7 @@ impl ExprCollector<'_> {\n                     let src = self.expander.to_source(Either::Left(AstPtr::new(&pat)));\n                     let pat =\n                         self.collect_macro_call(call, macro_ptr, true, |this, expanded_pat| {\n-                            this.collect_pat_opt_(expanded_pat, binding_list)\n+                            this.collect_pat_opt(expanded_pat, binding_list)\n                         });\n                     self.source_map.pat_map.insert(src, pat);\n                     return pat;\n@@ -1249,9 +1139,9 @@ impl ExprCollector<'_> {\n         self.alloc_pat(pattern, Either::Left(ptr))\n     }\n \n-    fn collect_pat_opt_(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n+    fn collect_pat_opt(&mut self, pat: Option<ast::Pat>, binding_list: &mut BindingList) -> PatId {\n         match pat {\n-            Some(pat) => self.collect_pat_(pat, binding_list),\n+            Some(pat) => self.collect_pat(pat, binding_list),\n             None => self.missing_pat(),\n         }\n     }\n@@ -1267,12 +1157,14 @@ impl ExprCollector<'_> {\n         // We want to skip the `..` pattern here, since we account for it above.\n         let args = args\n             .filter(|p| !matches!(p, ast::Pat::RestPat(_)))\n-            .map(|p| self.collect_pat_(p, binding_list))\n+            .map(|p| self.collect_pat(p, binding_list))\n             .collect();\n \n         (args, ellipsis)\n     }\n \n+    // endregion: patterns\n+\n     /// Returns `None` (and emits diagnostics) when `owner` if `#[cfg]`d out, and `Some(())` when\n     /// not.\n     fn check_cfg(&mut self, owner: &dyn ast::HasAttrs) -> Option<()> {\n@@ -1301,6 +1193,15 @@ impl ExprCollector<'_> {\n         self.body.bindings[binding_id].definitions.push(pat_id);\n     }\n \n+    // region: labels\n+\n+    fn collect_label(&mut self, ast_label: ast::Label) -> LabelId {\n+        let label = Label {\n+            name: ast_label.lifetime().as_ref().map_or_else(Name::missing, Name::new_lifetime),\n+        };\n+        self.alloc_label(label, AstPtr::new(&ast_label))\n+    }\n+\n     fn resolve_label(\n         &self,\n         lifetime: Option<ast::Lifetime>,\n@@ -1351,42 +1252,53 @@ impl ExprCollector<'_> {\n         self.label_ribs.pop();\n         res\n     }\n+    // endregion: labels\n }\n \n-impl From<ast::LiteralKind> for Literal {\n-    fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n-        match ast_lit_kind {\n-            // FIXME: these should have actual values filled in, but unsure on perf impact\n-            LiteralKind::IntNumber(lit) => {\n-                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n-                    Literal::Float(\n-                        FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n-                        builtin,\n-                    )\n-                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinUint::from_suffix) {\n-                    Literal::Uint(lit.value().unwrap_or(0), builtin)\n-                } else {\n-                    let builtin = lit.suffix().and_then(BuiltinInt::from_suffix);\n-                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n-                }\n-            }\n-            LiteralKind::FloatNumber(lit) => {\n-                let ty = lit.suffix().and_then(BuiltinFloat::from_suffix);\n-                Literal::Float(FloatTypeWrapper::new(lit.value().unwrap_or(Default::default())), ty)\n-            }\n-            LiteralKind::ByteString(bs) => {\n-                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n-                Literal::ByteString(text)\n-            }\n-            LiteralKind::String(s) => {\n-                let text = s.value().map(Box::from).unwrap_or_else(Default::default);\n-                Literal::String(text)\n-            }\n-            LiteralKind::Byte(b) => {\n-                Literal::Uint(b.value().unwrap_or_default() as u128, Some(BuiltinUint::U8))\n-            }\n-            LiteralKind::Char(c) => Literal::Char(c.value().unwrap_or_default()),\n-            LiteralKind::Bool(val) => Literal::Bool(val),\n-        }\n+impl ExprCollector<'_> {\n+    fn alloc_expr(&mut self, expr: Expr, ptr: ExprPtr) -> ExprId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.exprs.alloc(expr);\n+        self.source_map.expr_map_back.insert(id, src.clone());\n+        self.source_map.expr_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared exprs don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_expr_desugared(&mut self, expr: Expr) -> ExprId {\n+        self.body.exprs.alloc(expr)\n+    }\n+    fn missing_expr(&mut self) -> ExprId {\n+        self.alloc_expr_desugared(Expr::Missing)\n+    }\n+\n+    fn alloc_binding(&mut self, name: Name, mode: BindingAnnotation) -> BindingId {\n+        self.body.bindings.alloc(Binding { name, mode, definitions: SmallVec::new() })\n+    }\n+\n+    fn alloc_pat(&mut self, pat: Pat, ptr: PatPtr) -> PatId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.pats.alloc(pat);\n+        self.source_map.pat_map_back.insert(id, src.clone());\n+        self.source_map.pat_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared pats don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_pat_desugared(&mut self, pat: Pat) -> PatId {\n+        self.body.pats.alloc(pat)\n+    }\n+    fn missing_pat(&mut self) -> PatId {\n+        self.body.pats.alloc(Pat::Missing)\n+    }\n+\n+    fn alloc_label(&mut self, label: Label, ptr: LabelPtr) -> LabelId {\n+        let src = self.expander.to_source(ptr);\n+        let id = self.body.labels.alloc(label);\n+        self.source_map.label_map_back.insert(id, src.clone());\n+        self.source_map.label_map.insert(src, id);\n+        id\n+    }\n+    // FIXME: desugared labels don't have ptr, that's wrong and should be fixed somehow.\n+    fn alloc_label_desugared(&mut self, label: Label) -> LabelId {\n+        self.body.labels.alloc(label)\n     }\n }"}, {"sha": "c539224073914ed5bb9c3b358b388d2ffecedce3", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=d73161b491ec670413c847639d3c5aa58a6a89b4", "patch": "@@ -13,20 +13,16 @@ use crate::{\n use super::*;\n \n pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBodyId) -> String {\n-    let needs_semi;\n     let header = match owner {\n         DefWithBodyId::FunctionId(it) => {\n-            needs_semi = false;\n             let item_tree_id = it.lookup(db).id;\n-            format!(\"fn {}(\u2026) \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+            format!(\"fn {}\", item_tree_id.item_tree(db)[item_tree_id.value].name)\n         }\n         DefWithBodyId::StaticId(it) => {\n-            needs_semi = true;\n             let item_tree_id = it.lookup(db).id;\n             format!(\"static {} = \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n         }\n         DefWithBodyId::ConstId(it) => {\n-            needs_semi = true;\n             let item_tree_id = it.lookup(db).id;\n             let name = match &item_tree_id.item_tree(db)[item_tree_id.value].name {\n                 Some(name) => name.to_string(),\n@@ -35,7 +31,6 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n             format!(\"const {name} = \")\n         }\n         DefWithBodyId::VariantId(it) => {\n-            needs_semi = false;\n             let src = it.parent.child_source(db);\n             let variant = &src.value[it.local_id];\n             let name = match &variant.name() {\n@@ -47,8 +42,18 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n     };\n \n     let mut p = Printer { body, buf: header, indent_level: 0, needs_indent: false };\n+    if let DefWithBodyId::FunctionId(it) = owner {\n+        p.buf.push('(');\n+        body.params.iter().zip(&db.function_data(it).params).for_each(|(&param, ty)| {\n+            p.print_pat(param);\n+            p.buf.push(':');\n+            p.print_type_ref(ty);\n+        });\n+        p.buf.push(')');\n+        p.buf.push(' ');\n+    }\n     p.print_expr(body.body_expr);\n-    if needs_semi {\n+    if matches!(owner, DefWithBodyId::StaticId(_) | DefWithBodyId::ConstId(_)) {\n         p.buf.push(';');\n     }\n     p.buf"}, {"sha": "8321ba1da6f063e16931f99f37eebd0ff25eef85", "filename": "crates/hir-def/src/hir.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-def%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-def%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fhir.rs?ref=d73161b491ec670413c847639d3c5aa58a6a89b4", "patch": "@@ -20,6 +20,7 @@ use hir_expand::name::Name;\n use intern::Interned;\n use la_arena::{Idx, RawIdx};\n use smallvec::SmallVec;\n+use syntax::ast;\n \n use crate::{\n     builtin_type::{BuiltinFloat, BuiltinInt, BuiltinUint},\n@@ -104,6 +105,45 @@ impl Literal {\n     }\n }\n \n+impl From<ast::LiteralKind> for Literal {\n+    fn from(ast_lit_kind: ast::LiteralKind) -> Self {\n+        use ast::LiteralKind;\n+        match ast_lit_kind {\n+            // FIXME: these should have actual values filled in, but unsure on perf impact\n+            LiteralKind::IntNumber(lit) => {\n+                if let builtin @ Some(_) = lit.suffix().and_then(BuiltinFloat::from_suffix) {\n+                    Literal::Float(\n+                        FloatTypeWrapper::new(lit.float_value().unwrap_or(Default::default())),\n+                        builtin,\n+                    )\n+                } else if let builtin @ Some(_) = lit.suffix().and_then(BuiltinUint::from_suffix) {\n+                    Literal::Uint(lit.value().unwrap_or(0), builtin)\n+                } else {\n+                    let builtin = lit.suffix().and_then(BuiltinInt::from_suffix);\n+                    Literal::Int(lit.value().unwrap_or(0) as i128, builtin)\n+                }\n+            }\n+            LiteralKind::FloatNumber(lit) => {\n+                let ty = lit.suffix().and_then(BuiltinFloat::from_suffix);\n+                Literal::Float(FloatTypeWrapper::new(lit.value().unwrap_or(Default::default())), ty)\n+            }\n+            LiteralKind::ByteString(bs) => {\n+                let text = bs.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::ByteString(text)\n+            }\n+            LiteralKind::String(s) => {\n+                let text = s.value().map(Box::from).unwrap_or_else(Default::default);\n+                Literal::String(text)\n+            }\n+            LiteralKind::Byte(b) => {\n+                Literal::Uint(b.value().unwrap_or_default() as u128, Some(BuiltinUint::U8))\n+            }\n+            LiteralKind::Char(c) => Literal::Char(c.value().unwrap_or_default()),\n+            LiteralKind::Bool(val) => Literal::Bool(val),\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, Eq, PartialEq)]\n pub enum Expr {\n     /// This is produced if the syntax tree does not have a required expression piece."}, {"sha": "929dabcaf62eb866a7aae59b4e7ed14c379235d9", "filename": "crates/hir-expand/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Flib.rs?ref=d73161b491ec670413c847639d3c5aa58a6a89b4", "patch": "@@ -55,7 +55,7 @@ pub type ExpandResult<T> = ValueResult<T, ExpandError>;\n pub enum ExpandError {\n     UnresolvedProcMacro(CrateId),\n     Mbe(mbe::ExpandError),\n-    RecursionOverflowPosioned,\n+    RecursionOverflowPoisoned,\n     Other(Box<str>),\n }\n \n@@ -70,7 +70,7 @@ impl fmt::Display for ExpandError {\n         match self {\n             ExpandError::UnresolvedProcMacro(_) => f.write_str(\"unresolved proc-macro\"),\n             ExpandError::Mbe(it) => it.fmt(f),\n-            ExpandError::RecursionOverflowPosioned => {\n+            ExpandError::RecursionOverflowPoisoned => {\n                 f.write_str(\"overflow expanding the original macro\")\n             }\n             ExpandError::Other(it) => f.write_str(it),"}, {"sha": "b37fe1d63d5b2c776da4465c8045261359898db1", "filename": "crates/hir-ty/src/lower.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-ty%2Fsrc%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d73161b491ec670413c847639d3c5aa58a6a89b4/crates%2Fhir-ty%2Fsrc%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flower.rs?ref=d73161b491ec670413c847639d3c5aa58a6a89b4", "patch": "@@ -988,7 +988,7 @@ impl<'a> TyLoweringContext<'a> {\n                         // ignore `T: Drop` or `T: Destruct` bounds.\n                         // - `T: ~const Drop` has a special meaning in Rust 1.61 that we don't implement.\n                         //   (So ideally, we'd only ignore `~const Drop` here)\n-                        // - `Destruct` impls are built-in in 1.62 (current nightlies as of 08-04-2022), so until\n+                        // - `Destruct` impls are built-in in 1.62 (current nightly as of 08-04-2022), so until\n                         //   the builtin impls are supported by Chalk, we ignore them here.\n                         if let Some(lang) = lang_attr(self.db.upcast(), tr.hir_trait_id()) {\n                             if matches!(lang, LangItem::Drop | LangItem::Destruct) {\n@@ -1082,23 +1082,23 @@ impl<'a> TyLoweringContext<'a> {\n                     associated_ty_id: to_assoc_type_id(associated_ty),\n                     substitution,\n                 };\n-                let mut preds: SmallVec<[_; 1]> = SmallVec::with_capacity(\n+                let mut predicates: SmallVec<[_; 1]> = SmallVec::with_capacity(\n                     binding.type_ref.as_ref().map_or(0, |_| 1) + binding.bounds.len(),\n                 );\n                 if let Some(type_ref) = &binding.type_ref {\n                     let ty = self.lower_ty(type_ref);\n                     let alias_eq =\n                         AliasEq { alias: AliasTy::Projection(projection_ty.clone()), ty };\n-                    preds.push(crate::wrap_empty_binders(WhereClause::AliasEq(alias_eq)));\n+                    predicates.push(crate::wrap_empty_binders(WhereClause::AliasEq(alias_eq)));\n                 }\n                 for bound in binding.bounds.iter() {\n-                    preds.extend(self.lower_type_bound(\n+                    predicates.extend(self.lower_type_bound(\n                         bound,\n                         TyKind::Alias(AliasTy::Projection(projection_ty.clone())).intern(Interner),\n                         false,\n                     ));\n                 }\n-                preds\n+                predicates\n             })\n     }\n \n@@ -1165,7 +1165,7 @@ impl<'a> TyLoweringContext<'a> {\n                 return None;\n             }\n \n-            // As multiple occurrences of the same auto traits *are* permitted, we dedulicate the\n+            // As multiple occurrences of the same auto traits *are* permitted, we deduplicate the\n             // bounds. We shouldn't have repeated elements besides auto traits at this point.\n             bounds.dedup();\n "}]}