{"sha": "7b552967b8ed122aa949cddac8c2270b6490e64e", "node_id": "C_kwDOAAsO6NoAKDdiNTUyOTY3YjhlZDEyMmFhOTQ5Y2RkYWM4YzIyNzBiNjQ5MGU2NGU", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-20T00:37:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-20T00:37:20Z"}, "message": "Auto merge of #105961 - fmease:iat-type-directed-probing, r=jackh726\n\nType-directed probing for inherent associated types\n\nWhen probing for inherent associated types (IATs), equate the Self-type found in the projection with the Self-type of the relevant inherent impl blocks and check if all predicates are satisfied.\nPreviously, we didn't look at the Self-type or at the bounds and just picked the first inherent impl block containing an associated type with the name we were searching for which is obviously incorrect.\n\nRegarding the implementation, I basically copied what we do during method probing (`assemble_inherent_impl_probe`, `consider_probe`). Unfortunately, I had to duplicate a lot of the diagnostic code found in `rustc_hir_typeck::method::suggest` which we don't have access to in `rustc_hir_analysis`. Not sure if there is a simple way to unify the error handling. Note that in the future, `rustc_hir_analysis::astconv` might not actually be the place where we resolve inherent associated types (see https://github.com/rust-lang/rust/pull/103621#issuecomment-1304309565) but `rustc_hir_typeck` (?) in which case the duplication may naturally just disappear. While inherent associated *constants* are currently resolved during \"method\" probing, I did not find a straightforward way to incorporate IAT lookup into it as types and values (functions & constants) are two separate entities for which distinct code paths are taken.\n\nFixes #104251 (incl. https://github.com/rust-lang/rust/issues/104251#issuecomment-1338501171).\nFixes #105305.\nFixes #107468.\n\n`@rustbot` label T-types F-inherent_associated_types\nr? types", "tree": {"sha": "cb26096ffe2091b5051496051ec18df2d7345d12", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cb26096ffe2091b5051496051ec18df2d7345d12"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b552967b8ed122aa949cddac8c2270b6490e64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b552967b8ed122aa949cddac8c2270b6490e64e", "html_url": "https://github.com/rust-lang/rust/commit/7b552967b8ed122aa949cddac8c2270b6490e64e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b552967b8ed122aa949cddac8c2270b6490e64e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "21e5b941e0fb23e3db53926dae0d47fd639fbe61", "url": "https://api.github.com/repos/rust-lang/rust/commits/21e5b941e0fb23e3db53926dae0d47fd639fbe61", "html_url": "https://github.com/rust-lang/rust/commit/21e5b941e0fb23e3db53926dae0d47fd639fbe61"}, {"sha": "f2253dad24ad541618c939f363688d4e90fca72a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f2253dad24ad541618c939f363688d4e90fca72a", "html_url": "https://github.com/rust-lang/rust/commit/f2253dad24ad541618c939f363688d4e90fca72a"}], "stats": {"total": 1030, "additions": 946, "deletions": 84}, "files": [{"sha": "a9c2886b41448a4ae764d066863120096d1fb665", "filename": "compiler/rustc_hir_analysis/src/astconv/errors.rs", "status": "modified", "additions": 228, "deletions": 2, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Ferrors.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -1,10 +1,11 @@\n use crate::astconv::AstConv;\n use crate::errors::{ManualImplementation, MissingTypeParams};\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_errors::{pluralize, struct_span_err, Applicability, ErrorGuaranteed};\n+use rustc_errors::{pluralize, struct_span_err, Applicability, Diagnostic, ErrorGuaranteed};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n-use rustc_middle::ty;\n+use rustc_infer::traits::FulfillmentError;\n+use rustc_middle::ty::{self, Ty};\n use rustc_session::parse::feature_err;\n use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{sym, Ident};\n@@ -221,6 +222,231 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         err.emit()\n     }\n \n+    pub(crate) fn complain_about_ambiguous_inherent_assoc_type(\n+        &self,\n+        name: Ident,\n+        candidates: Vec<DefId>,\n+        span: Span,\n+    ) -> ErrorGuaranteed {\n+        let mut err = struct_span_err!(\n+            self.tcx().sess,\n+            name.span,\n+            E0034,\n+            \"multiple applicable items in scope\"\n+        );\n+        err.span_label(name.span, format!(\"multiple `{name}` found\"));\n+        self.note_ambiguous_inherent_assoc_type(&mut err, candidates, span);\n+        err.emit()\n+    }\n+\n+    // FIXME(fmease): Heavily adapted from `rustc_hir_typeck::method::suggest`. Deduplicate.\n+    fn note_ambiguous_inherent_assoc_type(\n+        &self,\n+        err: &mut Diagnostic,\n+        candidates: Vec<DefId>,\n+        span: Span,\n+    ) {\n+        let tcx = self.tcx();\n+\n+        // Dynamic limit to avoid hiding just one candidate, which is silly.\n+        let limit = if candidates.len() == 5 { 5 } else { 4 };\n+\n+        for (index, &item) in candidates.iter().take(limit).enumerate() {\n+            let impl_ = tcx.impl_of_method(item).unwrap();\n+\n+            let note_span = if item.is_local() {\n+                Some(tcx.def_span(item))\n+            } else if impl_.is_local() {\n+                Some(tcx.def_span(impl_))\n+            } else {\n+                None\n+            };\n+\n+            let title = if candidates.len() > 1 {\n+                format!(\"candidate #{}\", index + 1)\n+            } else {\n+                \"the candidate\".into()\n+            };\n+\n+            let impl_ty = tcx.at(span).type_of(impl_).subst_identity();\n+            let note = format!(\"{title} is defined in an impl for the type `{impl_ty}`\");\n+\n+            if let Some(span) = note_span {\n+                err.span_note(span, &note);\n+            } else {\n+                err.note(&note);\n+            }\n+        }\n+        if candidates.len() > limit {\n+            err.note(&format!(\"and {} others\", candidates.len() - limit));\n+        }\n+    }\n+\n+    // FIXME(inherent_associated_types): Find similarly named associated types and suggest them.\n+    pub(crate) fn complain_about_inherent_assoc_type_not_found(\n+        &self,\n+        name: Ident,\n+        self_ty: Ty<'tcx>,\n+        candidates: Vec<(DefId, (DefId, DefId))>,\n+        fulfillment_errors: Vec<FulfillmentError<'tcx>>,\n+        span: Span,\n+    ) -> ErrorGuaranteed {\n+        // FIXME(fmease): This was copied in parts from an old version of `rustc_hir_typeck::method::suggest`.\n+        // Either\n+        // * update this code by applying changes similar to #106702 or by taking a\n+        //   Vec<(DefId, (DefId, DefId), Option<Vec<FulfillmentError<'tcx>>>)> or\n+        // * deduplicate this code across the two crates.\n+\n+        let tcx = self.tcx();\n+\n+        let adt_did = self_ty.ty_adt_def().map(|def| def.did());\n+        let add_def_label = |err: &mut Diagnostic| {\n+            if let Some(did) = adt_did {\n+                err.span_label(\n+                    tcx.def_span(did),\n+                    format!(\n+                        \"associated item `{name}` not found for this {}\",\n+                        tcx.def_kind(did).descr(did)\n+                    ),\n+                );\n+            }\n+        };\n+\n+        if fulfillment_errors.is_empty() {\n+            // FIXME(fmease): Copied from `rustc_hir_typeck::method::probe`. Deduplicate.\n+\n+            let limit = if candidates.len() == 5 { 5 } else { 4 };\n+            let type_candidates = candidates\n+                .iter()\n+                .take(limit)\n+                .map(|&(impl_, _)| format!(\"- `{}`\", tcx.at(span).type_of(impl_).subst_identity()))\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\");\n+            let additional_types = if candidates.len() > limit {\n+                format!(\"\\nand {} more types\", candidates.len() - limit)\n+            } else {\n+                String::new()\n+            };\n+\n+            let mut err = struct_span_err!(\n+                tcx.sess,\n+                name.span,\n+                E0220,\n+                \"associated type `{name}` not found for `{self_ty}` in the current scope\"\n+            );\n+            err.span_label(name.span, format!(\"associated item not found in `{self_ty}`\"));\n+            err.note(&format!(\n+                \"the associated type was found for\\n{type_candidates}{additional_types}\",\n+            ));\n+            add_def_label(&mut err);\n+            return err.emit();\n+        }\n+\n+        let mut bound_spans = Vec::new();\n+\n+        let mut bound_span_label = |self_ty: Ty<'_>, obligation: &str, quiet: &str| {\n+            let msg = format!(\n+                \"doesn't satisfy `{}`\",\n+                if obligation.len() > 50 { quiet } else { obligation }\n+            );\n+            match &self_ty.kind() {\n+                // Point at the type that couldn't satisfy the bound.\n+                ty::Adt(def, _) => bound_spans.push((tcx.def_span(def.did()), msg)),\n+                // Point at the trait object that couldn't satisfy the bound.\n+                ty::Dynamic(preds, _, _) => {\n+                    for pred in preds.iter() {\n+                        match pred.skip_binder() {\n+                            ty::ExistentialPredicate::Trait(tr) => {\n+                                bound_spans.push((tcx.def_span(tr.def_id), msg.clone()))\n+                            }\n+                            ty::ExistentialPredicate::Projection(_)\n+                            | ty::ExistentialPredicate::AutoTrait(_) => {}\n+                        }\n+                    }\n+                }\n+                // Point at the closure that couldn't satisfy the bound.\n+                ty::Closure(def_id, _) => {\n+                    bound_spans.push((tcx.def_span(*def_id), format!(\"doesn't satisfy `{quiet}`\")))\n+                }\n+                _ => {}\n+            }\n+        };\n+\n+        let format_pred = |pred: ty::Predicate<'tcx>| {\n+            let bound_predicate = pred.kind();\n+            match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => {\n+                    let pred = bound_predicate.rebind(pred);\n+                    // `<Foo as Iterator>::Item = String`.\n+                    let projection_ty = pred.skip_binder().projection_ty;\n+\n+                    let substs_with_infer_self = tcx.mk_substs(\n+                        std::iter::once(tcx.mk_ty_var(ty::TyVid::from_u32(0)).into())\n+                            .chain(projection_ty.substs.iter().skip(1)),\n+                    );\n+\n+                    let quiet_projection_ty =\n+                        tcx.mk_alias_ty(projection_ty.def_id, substs_with_infer_self);\n+\n+                    let term = pred.skip_binder().term;\n+\n+                    let obligation = format!(\"{projection_ty} = {term}\");\n+                    let quiet = format!(\"{quiet_projection_ty} = {term}\");\n+\n+                    bound_span_label(projection_ty.self_ty(), &obligation, &quiet);\n+                    Some((obligation, projection_ty.self_ty()))\n+                }\n+                ty::PredicateKind::Clause(ty::Clause::Trait(poly_trait_ref)) => {\n+                    let p = poly_trait_ref.trait_ref;\n+                    let self_ty = p.self_ty();\n+                    let path = p.print_only_trait_path();\n+                    let obligation = format!(\"{self_ty}: {path}\");\n+                    let quiet = format!(\"_: {path}\");\n+                    bound_span_label(self_ty, &obligation, &quiet);\n+                    Some((obligation, self_ty))\n+                }\n+                _ => None,\n+            }\n+        };\n+\n+        // FIXME(fmease): `rustc_hir_typeck::method::suggest` uses a `skip_list` to filter out some bounds.\n+        // I would do the same here if it didn't mean more code duplication.\n+        let mut bounds: Vec<_> = fulfillment_errors\n+            .into_iter()\n+            .map(|error| error.root_obligation.predicate)\n+            .filter_map(format_pred)\n+            .map(|(p, _)| format!(\"`{}`\", p))\n+            .collect();\n+        bounds.sort();\n+        bounds.dedup();\n+\n+        let mut err = tcx.sess.struct_span_err(\n+            name.span,\n+            &format!(\"the associated type `{name}` exists for `{self_ty}`, but its trait bounds were not satisfied\")\n+        );\n+        if !bounds.is_empty() {\n+            err.note(&format!(\n+                \"the following trait bounds were not satisfied:\\n{}\",\n+                bounds.join(\"\\n\")\n+            ));\n+        }\n+        err.span_label(\n+            name.span,\n+            format!(\"associated type cannot be referenced on `{self_ty}` due to unsatisfied trait bounds\")\n+        );\n+\n+        bound_spans.sort();\n+        bound_spans.dedup();\n+        for (span, msg) in bound_spans {\n+            if !tcx.sess.source_map().is_span_accessible(span) {\n+                continue;\n+            }\n+            err.span_label(span, &msg);\n+        }\n+        add_def_label(&mut err);\n+        err.emit()\n+    }\n+\n     /// When there are any missing associated types, emit an E0191 error and attempt to supply a\n     /// reasonable suggestion on how to write it. For the case of multiple associated types in the\n     /// same trait bound have the same name (as they come from different supertraits), we instead"}, {"sha": "716b4fc6ae36f75473c50fbcfec8253cf1ec2091", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 213, "deletions": 53, "changes": 266, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -27,7 +27,10 @@ use rustc_hir::def::{CtorOf, DefKind, Namespace, Res};\n use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_hir::intravisit::{walk_generics, Visitor as _};\n use rustc_hir::{GenericArg, GenericArgs, OpaqueTyOrigin};\n+use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n+use rustc_infer::traits::ObligationCause;\n+use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability::AllowUnstable;\n use rustc_middle::ty::subst::{self, GenericArgKind, InternalSubsts, SubstsRef};\n use rustc_middle::ty::DynKind;\n@@ -39,12 +42,11 @@ use rustc_span::lev_distance::find_best_match_for_name;\n use rustc_span::symbol::{kw, Ident, Symbol};\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_target::spec::abi;\n-use rustc_trait_selection::traits;\n-use rustc_trait_selection::traits::astconv_object_safety_violations;\n use rustc_trait_selection::traits::error_reporting::{\n     report_object_safety_error, suggestions::NextTypeParamName,\n };\n use rustc_trait_selection::traits::wf::object_region_bounds;\n+use rustc_trait_selection::traits::{self, astconv_object_safety_violations, ObligationCtxt};\n \n use smallvec::{smallvec, SmallVec};\n use std::collections::BTreeSet;\n@@ -1944,7 +1946,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             Res::Err\n         };\n \n-        // Check if we have an enum variant.\n+        // Check if we have an enum variant or an inherent associated type.\n         let mut variant_resolution = None;\n         if let Some(adt_def) = self.probe_adt(span, qself_ty) {\n             if adt_def.is_enum() {\n@@ -2043,23 +2045,15 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 }\n             }\n \n-            // see if we can satisfy using an inherent associated type\n-            for &impl_ in tcx.inherent_impls(adt_def.did()) {\n-                let Some(assoc_ty_did) = self.lookup_assoc_ty(assoc_ident, hir_ref_id, span, impl_) else {\n-                    continue;\n-                };\n-                let ty::Adt(_, adt_substs) = qself_ty.kind() else {\n-                    // FIXME(inherent_associated_types)\n-                    bug!(\"unimplemented: non-adt self of inherent assoc ty\");\n-                };\n-                let item_substs = self.create_substs_for_associated_item(\n-                    span,\n-                    assoc_ty_did,\n-                    assoc_segment,\n-                    adt_substs,\n-                );\n-                let ty = tcx.type_of(assoc_ty_did).subst(tcx, item_substs);\n-                return Ok((ty, DefKind::AssocTy, assoc_ty_did));\n+            if let Some((ty, did)) = self.lookup_inherent_assoc_ty(\n+                assoc_ident,\n+                assoc_segment,\n+                adt_def.did(),\n+                qself_ty,\n+                hir_ref_id,\n+                span,\n+            )? {\n+                return Ok((ty, DefKind::AssocTy, did));\n             }\n         }\n \n@@ -2202,6 +2196,172 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         Ok((ty, DefKind::AssocTy, assoc_ty_did))\n     }\n \n+    fn lookup_inherent_assoc_ty(\n+        &self,\n+        name: Ident,\n+        segment: &hir::PathSegment<'_>,\n+        adt_did: DefId,\n+        self_ty: Ty<'tcx>,\n+        block: hir::HirId,\n+        span: Span,\n+    ) -> Result<Option<(Ty<'tcx>, DefId)>, ErrorGuaranteed> {\n+        let tcx = self.tcx();\n+\n+        let candidates: Vec<_> = tcx\n+            .inherent_impls(adt_did)\n+            .iter()\n+            .filter_map(|&impl_| Some((impl_, self.lookup_assoc_ty_unchecked(name, block, impl_)?)))\n+            .collect();\n+\n+        if candidates.is_empty() {\n+            return Ok(None);\n+        }\n+\n+        // In contexts that have no inference context, just make a new one.\n+        // We do need a local variable to store it, though.\n+        let infcx_;\n+        let infcx = match self.infcx() {\n+            Some(infcx) => infcx,\n+            None => {\n+                assert!(!self_ty.needs_infer());\n+                infcx_ = tcx.infer_ctxt().ignoring_regions().build();\n+                &infcx_\n+            }\n+        };\n+\n+        let param_env = tcx.param_env(block.owner.to_def_id());\n+        let cause = ObligationCause::misc(span, block.owner.def_id);\n+        let mut fulfillment_errors = Vec::new();\n+        let mut applicable_candidates: Vec<_> = candidates\n+            .iter()\n+            .filter_map(|&(impl_, (assoc_item, def_scope))| {\n+                infcx.probe(|_| {\n+                    let ocx = ObligationCtxt::new_in_snapshot(&infcx);\n+\n+                    let impl_ty = tcx.type_of(impl_);\n+                    let impl_substs = infcx.fresh_item_substs(impl_);\n+                    let impl_ty = impl_ty.subst(tcx, impl_substs);\n+                    let impl_ty = ocx.normalize(&cause, param_env, impl_ty);\n+\n+                    // Check that the Self-types can be related.\n+                    // FIXME(fmease): Should we use `eq` here?\n+                    ocx.sup(&ObligationCause::dummy(), param_env, impl_ty, self_ty).ok()?;\n+\n+                    // Check whether the impl imposes obligations we have to worry about.\n+                    let impl_bounds = tcx.predicates_of(impl_);\n+                    let impl_bounds = impl_bounds.instantiate(tcx, impl_substs);\n+\n+                    let impl_bounds = ocx.normalize(&cause, param_env, impl_bounds);\n+\n+                    let impl_obligations = traits::predicates_for_generics(\n+                        |_, _| cause.clone(),\n+                        param_env,\n+                        impl_bounds,\n+                    );\n+\n+                    ocx.register_obligations(impl_obligations);\n+\n+                    let mut errors = ocx.select_where_possible();\n+                    if !errors.is_empty() {\n+                        fulfillment_errors.append(&mut errors);\n+                        return None;\n+                    }\n+\n+                    // FIXME(fmease): Unsolved vars can escape this InferCtxt snapshot.\n+                    Some((assoc_item, def_scope, infcx.resolve_vars_if_possible(impl_substs)))\n+                })\n+            })\n+            .collect();\n+\n+        if applicable_candidates.len() > 1 {\n+            return Err(self.complain_about_ambiguous_inherent_assoc_type(\n+                name,\n+                applicable_candidates.into_iter().map(|(candidate, ..)| candidate).collect(),\n+                span,\n+            ));\n+        }\n+\n+        if let Some((assoc_item, def_scope, impl_substs)) = applicable_candidates.pop() {\n+            self.check_assoc_ty(assoc_item, name, def_scope, block, span);\n+\n+            // FIXME(inherent_associated_types): To fully *confirm* the *probed* candidate, we still\n+            // need to relate the Self-type with fresh item substs & register region obligations for\n+            // regionck to prove/disprove.\n+\n+            let item_substs =\n+                self.create_substs_for_associated_item(span, assoc_item, segment, impl_substs);\n+\n+            // FIXME(fmease, #106722): Check if the bounds on the parameters of the\n+            // associated type hold, if any.\n+            let ty = tcx.type_of(assoc_item).subst(tcx, item_substs);\n+\n+            return Ok(Some((ty, assoc_item)));\n+        }\n+\n+        Err(self.complain_about_inherent_assoc_type_not_found(\n+            name,\n+            self_ty,\n+            candidates,\n+            fulfillment_errors,\n+            span,\n+        ))\n+    }\n+\n+    fn lookup_assoc_ty(\n+        &self,\n+        name: Ident,\n+        block: hir::HirId,\n+        span: Span,\n+        scope: DefId,\n+    ) -> Option<DefId> {\n+        let (item, def_scope) = self.lookup_assoc_ty_unchecked(name, block, scope)?;\n+        self.check_assoc_ty(item, name, def_scope, block, span);\n+        Some(item)\n+    }\n+\n+    fn lookup_assoc_ty_unchecked(\n+        &self,\n+        name: Ident,\n+        block: hir::HirId,\n+        scope: DefId,\n+    ) -> Option<(DefId, DefId)> {\n+        let tcx = self.tcx();\n+        let (ident, def_scope) = tcx.adjust_ident_and_get_scope(name, scope, block);\n+\n+        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n+        // of calling `find_by_name_and_kind`.\n+        let item = tcx.associated_items(scope).in_definition_order().find(|i| {\n+            i.kind.namespace() == Namespace::TypeNS\n+                && i.ident(tcx).normalize_to_macros_2_0() == ident\n+        })?;\n+\n+        Some((item.def_id, def_scope))\n+    }\n+\n+    fn check_assoc_ty(\n+        &self,\n+        item: DefId,\n+        name: Ident,\n+        def_scope: DefId,\n+        block: hir::HirId,\n+        span: Span,\n+    ) {\n+        let tcx = self.tcx();\n+        let kind = DefKind::AssocTy;\n+\n+        if !tcx.visibility(item).is_accessible_from(def_scope, tcx) {\n+            let kind = kind.descr(item);\n+            let msg = format!(\"{kind} `{name}` is private\");\n+            let def_span = tcx.def_span(item);\n+            tcx.sess\n+                .struct_span_err_with_code(span, &msg, rustc_errors::error_code!(E0624))\n+                .span_label(span, &format!(\"private {kind}\"))\n+                .span_label(def_span, &format!(\"{kind} defined here\"))\n+                .emit();\n+        }\n+        tcx.check_stability(item, Some(block), span, None);\n+    }\n+\n     fn probe_traits_that_match_assoc_ty(\n         &self,\n         qself_ty: Ty<'tcx>,\n@@ -2255,39 +2415,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             .collect()\n     }\n \n-    fn lookup_assoc_ty(\n-        &self,\n-        ident: Ident,\n-        block: hir::HirId,\n-        span: Span,\n-        scope: DefId,\n-    ) -> Option<DefId> {\n-        let tcx = self.tcx();\n-        let (ident, def_scope) = tcx.adjust_ident_and_get_scope(ident, scope, block);\n-\n-        // We have already adjusted the item name above, so compare with `ident.normalize_to_macros_2_0()` instead\n-        // of calling `find_by_name_and_kind`.\n-        let item = tcx.associated_items(scope).in_definition_order().find(|i| {\n-            i.kind.namespace() == Namespace::TypeNS\n-                && i.ident(tcx).normalize_to_macros_2_0() == ident\n-        })?;\n-\n-        let kind = DefKind::AssocTy;\n-        if !item.visibility(tcx).is_accessible_from(def_scope, tcx) {\n-            let kind = kind.descr(item.def_id);\n-            let msg = format!(\"{kind} `{ident}` is private\");\n-            let def_span = self.tcx().def_span(item.def_id);\n-            tcx.sess\n-                .struct_span_err_with_code(span, &msg, rustc_errors::error_code!(E0624))\n-                .span_label(span, &format!(\"private {kind}\"))\n-                .span_label(def_span, &format!(\"{kind} defined here\"))\n-                .emit();\n-        }\n-        tcx.check_stability(item.def_id, Some(block), span, None);\n-\n-        Some(item.def_id)\n-    }\n-\n     fn qpath_to_ty(\n         &self,\n         span: Span,\n@@ -3375,3 +3502,36 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n }\n+\n+pub trait InferCtxtExt<'tcx> {\n+    fn fresh_item_substs(&self, def_id: DefId) -> SubstsRef<'tcx>;\n+}\n+\n+impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n+    fn fresh_item_substs(&self, def_id: DefId) -> SubstsRef<'tcx> {\n+        InternalSubsts::for_item(self.tcx, def_id, |param, _| match param.kind {\n+            GenericParamDefKind::Lifetime => self.tcx.lifetimes.re_erased.into(),\n+            GenericParamDefKind::Type { .. } => self\n+                .next_ty_var(TypeVariableOrigin {\n+                    kind: TypeVariableOriginKind::SubstitutionPlaceholder,\n+                    span: self.tcx.def_span(def_id),\n+                })\n+                .into(),\n+            GenericParamDefKind::Const { .. } => {\n+                let span = self.tcx.def_span(def_id);\n+                let origin = ConstVariableOrigin {\n+                    kind: ConstVariableOriginKind::SubstitutionPlaceholder,\n+                    span,\n+                };\n+                self.next_const_var(\n+                    self.tcx\n+                        .type_of(param.def_id)\n+                        .no_bound_vars()\n+                        .expect(\"const parameter types cannot be generic\"),\n+                    origin,\n+                )\n+                .into()\n+            }\n+        })\n+    }\n+}"}, {"sha": "eb6c0b7686b6d94c12b646d210496bc94a319088", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 29, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -9,12 +9,11 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::Applicability;\n use rustc_hir as hir;\n use rustc_hir::def::DefKind;\n+use rustc_hir_analysis::astconv::InferCtxtExt as _;\n use rustc_hir_analysis::autoderef::{self, Autoderef};\n use rustc_infer::infer::canonical::OriginalQueryValues;\n use rustc_infer::infer::canonical::{Canonical, QueryResponse};\n-use rustc_infer::infer::type_variable::{TypeVariableOrigin, TypeVariableOriginKind};\n use rustc_infer::infer::{self, InferOk, TyCtxtInferExt};\n-use rustc_middle::infer::unify_key::{ConstVariableOrigin, ConstVariableOriginKind};\n use rustc_middle::middle::stability;\n use rustc_middle::ty::fast_reject::{simplify_type, TreatParams};\n use rustc_middle::ty::AssocItem;\n@@ -1941,33 +1940,6 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         (self.tcx.type_of(impl_def_id), self.fresh_item_substs(impl_def_id))\n     }\n \n-    fn fresh_item_substs(&self, def_id: DefId) -> SubstsRef<'tcx> {\n-        InternalSubsts::for_item(self.tcx, def_id, |param, _| match param.kind {\n-            GenericParamDefKind::Lifetime => self.tcx.lifetimes.re_erased.into(),\n-            GenericParamDefKind::Type { .. } => self\n-                .next_ty_var(TypeVariableOrigin {\n-                    kind: TypeVariableOriginKind::SubstitutionPlaceholder,\n-                    span: self.tcx.def_span(def_id),\n-                })\n-                .into(),\n-            GenericParamDefKind::Const { .. } => {\n-                let span = self.tcx.def_span(def_id);\n-                let origin = ConstVariableOrigin {\n-                    kind: ConstVariableOriginKind::SubstitutionPlaceholder,\n-                    span,\n-                };\n-                self.next_const_var(\n-                    self.tcx\n-                        .type_of(param.def_id)\n-                        .no_bound_vars()\n-                        .expect(\"const parameter types cannot be generic\"),\n-                    origin,\n-                )\n-                .into()\n-            }\n-        })\n-    }\n-\n     /// Replaces late-bound-regions bound by `value` with `'static` using\n     /// `ty::erase_late_bound_regions`.\n     ///"}, {"sha": "73920555b3e0415982d5526cee4c1c81ff9bfe99", "filename": "tests/ui/associated-inherent-types/ambiguity.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,16 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Wrapper<T>(T);\n+\n+impl Wrapper<i32> {\n+    type Foo = i32;\n+}\n+\n+impl Wrapper<()> {\n+    type Foo = ();\n+}\n+\n+fn main() {\n+    let _: Wrapper<_>::Foo = (); //~ ERROR multiple applicable items in scope\n+}"}, {"sha": "155c296cbb3c424b2a40b32a6e26d5b14e930e48", "filename": "tests/ui/associated-inherent-types/ambiguity.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fambiguity.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,20 @@\n+error[E0034]: multiple applicable items in scope\n+  --> $DIR/ambiguity.rs:15:24\n+   |\n+LL |     let _: Wrapper<_>::Foo = ();\n+   |                        ^^^ multiple `Foo` found\n+   |\n+note: candidate #1 is defined in an impl for the type `Wrapper<i32>`\n+  --> $DIR/ambiguity.rs:7:5\n+   |\n+LL |     type Foo = i32;\n+   |     ^^^^^^^^\n+note: candidate #2 is defined in an impl for the type `Wrapper<()>`\n+  --> $DIR/ambiguity.rs:11:5\n+   |\n+LL |     type Foo = ();\n+   |     ^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0034`."}, {"sha": "53ac79e0561baee45614c02ff575e52b27855a20", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,23 @@\n+// known-bug: unknown\n+// failure-status: 101\n+// normalize-stderr-test \"note: .*\\n\\n\" -> \"\"\n+// normalize-stderr-test \"thread 'rustc' panicked.*\\n\" -> \"\"\n+// rustc-env:RUST_BACKTRACE=0\n+\n+// FIXME: I presume a type variable that couldn't be solved by `resolve_vars_if_possible`\n+//        escapes the InferCtxt snapshot.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Cont<T>(T);\n+\n+impl<T: Copy> Cont<T> {\n+    type Out = Vec<T>;\n+}\n+\n+pub fn weird<T: Copy>(x: T) {\n+    let _: Cont<_>::Out = vec![true];\n+}\n+\n+fn main() {}"}, {"sha": "7b0d1c50516241ab6984a8872d1feb3d72fb56d1", "filename": "tests/ui/associated-inherent-types/bugs/ice-substitution.stderr", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Fice-substitution.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,6 @@\n+error: the compiler unexpectedly panicked. this is a bug.\n+\n+query stack during panic:\n+#0 [typeck] type-checking `weird`\n+#1 [typeck_item_bodies] type-checking all item bodies\n+end of query stack"}, {"sha": "a920b412b1a492a9840b0c588299bed9d0838926", "filename": "tests/ui/associated-inherent-types/bugs/inference-fail.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,15 @@\n+// known-bug: unknown\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl S<()> {\n+    type P = i128;\n+}\n+\n+fn main() {\n+    // We fail to infer `_ == ()` here.\n+    let _: S<_>::P;\n+}"}, {"sha": "425691bd6c4f694a860e05181f81a7fdd5e7f84e", "filename": "tests/ui/associated-inherent-types/bugs/inference-fail.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Finference-fail.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/inference-fail.rs:14:14\n+   |\n+LL |     let _: S<_>::P;\n+   |              ^ cannot infer type\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "632dbf3854b2b7b0eb5f09225f4be7c938abb462", "filename": "tests/ui/associated-inherent-types/bugs/lack-of-regionck.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fbugs%2Flack-of-regionck.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,19 @@\n+// known-bug: unknown\n+// check-pass\n+\n+// We currently don't region-check inherent associated type projections at all.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features, dead_code)]\n+\n+struct S<T>(T);\n+\n+impl S<&'static ()> {\n+    type T = ();\n+}\n+\n+fn usr<'a>() {\n+    let _: S::<&'a ()>::T; // this should *fail* but it doesn't!\n+}\n+\n+fn main() {}"}, {"sha": "f846bfa4168acdb9959ba7d7d8a6684b9a801070", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-0.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-0.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,41 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Check that inherent associated types are dispatched on the concrete Self type.\n+\n+struct Select<T>(T);\n+\n+impl Select<u8> {\n+    type Projection = ();\n+}\n+\n+impl Select<String> {\n+    type Projection = bool;\n+}\n+\n+struct Choose<T>(T);\n+struct NonCopy;\n+\n+impl<T: Copy> Choose<T> {\n+    type Result = Vec<T>;\n+}\n+\n+impl Choose<NonCopy> {\n+    type Result = ();\n+}\n+\n+fn main() {\n+    let _: Select<String>::Projection = false;\n+    let _: Select<u8>::Projection = ();\n+\n+    let _: Choose<NonCopy>::Result = ();\n+    let _: Choose<bool>::Result = vec![true];\n+}\n+\n+// Test if we use the correct `ParamEnv` when proving obligations.\n+\n+pub fn parameterized<T: Copy>(x: T) {\n+    let _: Choose<T>::Result = vec![x];\n+}"}, {"sha": "9b0fa8dc6f32cf9c606eaf98a27afdb4b8d628de", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-1.rs", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-1.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,39 @@\n+// check-pass\n+\n+#![feature(inherent_associated_types, auto_traits, negative_impls)]\n+#![allow(incomplete_features)]\n+\n+use std::cmp::Ordering;\n+\n+// Check that inherent associated types are dispatched on the concrete Self type.\n+\n+struct Select<T, U>(T, U);\n+\n+impl<T: Ordinary, U: Ordinary> Select<T, U> {\n+    type Type = ();\n+}\n+\n+impl<T: Ordinary> Select<T, Special> {\n+    type Type = bool;\n+}\n+\n+impl<T: Ordinary> Select<Special, T> {\n+    type Type = Ordering;\n+}\n+\n+impl Select<Special, Special> {\n+    type Type = (bool, bool);\n+}\n+\n+fn main() {\n+    let _: Select<String, Special>::Type = false;\n+    let _: Select<Special, Special>::Type = (true, false);\n+    let _: Select<Special, u8>::Type = Ordering::Equal;\n+    let _: Select<i128, ()>::Type = ();\n+}\n+\n+enum Special {}\n+\n+impl !Ordinary for Special {}\n+\n+auto trait Ordinary {}"}, {"sha": "7b205952f52bcee72b0e11fb029ede4d555331a6", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-2.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,17 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Parameterized<T, U>(T, U);\n+\n+impl Parameterized<(), ()> {\n+    type Output = bool;\n+}\n+\n+impl<T> Parameterized<bool, T> {\n+    type Result = T;\n+}\n+\n+fn main() {\n+    let _: Parameterized<(), ()>::Output = String::new(); //~ ERROR mismatched types\n+    let _: Parameterized<bool, u32>::Result = (); //~ ERROR mismatched types\n+}"}, {"sha": "c9a48872af40e1c4bc1410dc1f208bc40598101e", "filename": "tests/ui/associated-inherent-types/dispatch-on-self-type-2.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fdispatch-on-self-type-2.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,19 @@\n+error[E0308]: mismatched types\n+  --> $DIR/dispatch-on-self-type-2.rs:15:44\n+   |\n+LL |     let _: Parameterized<(), ()>::Output = String::new();\n+   |            -----------------------------   ^^^^^^^^^^^^^ expected `bool`, found `String`\n+   |            |\n+   |            expected due to this\n+\n+error[E0308]: mismatched types\n+  --> $DIR/dispatch-on-self-type-2.rs:16:47\n+   |\n+LL |     let _: Parameterized<bool, u32>::Result = ();\n+   |            --------------------------------   ^^ expected `u32`, found `()`\n+   |            |\n+   |            expected due to this\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "d2efb24c666204850974f2395d46850d79ad4601", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs-shadowing-trait-item.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,31 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Check that it's okay to report \u201c[inherent] associated type [\u2026] not found\u201d for inherent associated\n+// type candidates that are not applicable (due to unsuitable Self type) even if there exists a\n+// \u201cshadowed\u201d associated type from a trait with the same name since its use would be ambiguous\n+// anyway if the IAT didn't exist.\n+// FIXME(inherent_associated_types): Figure out which error would be more helpful here.\n+\n+// revisions: shadowed uncovered\n+\n+struct S<T>(T);\n+\n+trait Tr {\n+    type Pr;\n+}\n+\n+impl<T> Tr for S<T> {\n+    type Pr = ();\n+}\n+\n+#[cfg(shadowed)]\n+impl S<()> {\n+    type Pr = i32;\n+}\n+\n+fn main() {\n+    let _: S::<bool>::Pr = ();\n+    //[shadowed]~^ ERROR associated type `Pr` not found\n+    //[uncovered]~^^ ERROR ambiguous associated type\n+}"}, {"sha": "3561db354c03f81f7a047cf6d8731381e65c89d0", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs-shadowing-trait-item.shadowed.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.shadowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.shadowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.shadowed.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,15 @@\n+error[E0220]: associated type `Pr` not found for `S<bool>` in the current scope\n+  --> $DIR/not-found-self-type-differs-shadowing-trait-item.rs:28:23\n+   |\n+LL | struct S<T>(T);\n+   | ----------- associated item `Pr` not found for this struct\n+...\n+LL |     let _: S::<bool>::Pr = ();\n+   |                       ^^ associated item not found in `S<bool>`\n+   |\n+   = note: the associated type was found for\n+           - `S<()>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "88c72042ce2d0166a06d75e6382dcba692f2de65", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs-shadowing-trait-item.uncovered.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.uncovered.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.uncovered.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs-shadowing-trait-item.uncovered.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,9 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/not-found-self-type-differs-shadowing-trait-item.rs:28:12\n+   |\n+LL |     let _: S::<bool>::Pr = ();\n+   |            ^^^^^^^^^^^^^ help: use the fully-qualified path: `<S<bool> as Tr>::Pr`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0223`."}, {"sha": "4396435a6ddc5d2a583478c197b90269ed4a8420", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.alias.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.alias.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,16 @@\n+error[E0220]: associated type `Proj` not found for `Family<Option<()>>` in the current scope\n+  --> $DIR/not-found-self-type-differs.rs:17:34\n+   |\n+LL | struct Family<T>(T);\n+   | ---------------- associated item `Proj` not found for this struct\n+...\n+LL | type Alias = Family<Option<()>>::Proj;\n+   |                                  ^^^^ associated item not found in `Family<Option<()>>`\n+   |\n+   = note: the associated type was found for\n+           - `Family<()>`\n+           - `Family<Result<T, ()>>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "d527db022172fd3935f495f62cd4dd2d8eeb3ea1", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.local.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.local.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,16 @@\n+error[E0220]: associated type `Proj` not found for `Family<PathBuf>` in the current scope\n+  --> $DIR/not-found-self-type-differs.rs:21:40\n+   |\n+LL | struct Family<T>(T);\n+   | ---------------- associated item `Proj` not found for this struct\n+...\n+LL |     let _: Family<std::path::PathBuf>::Proj = ();\n+   |                                        ^^^^ associated item not found in `Family<PathBuf>`\n+   |\n+   = note: the associated type was found for\n+           - `Family<()>`\n+           - `Family<Result<T, ()>>`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0220`."}, {"sha": "93f58dcb6e61a7585f22eb1464a049f88e5350fb", "filename": "tests/ui/associated-inherent-types/not-found-self-type-differs.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-self-type-differs.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,22 @@\n+// revisions: local alias\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Family<T>(T);\n+\n+impl Family<()> {\n+    type Proj = ();\n+}\n+\n+impl<T> Family<Result<T, ()>> {\n+    type Proj = Self;\n+}\n+\n+#[cfg(alias)]\n+type Alias = Family<Option<()>>::Proj; //[alias]~ ERROR associated type `Proj` not found for `Family<Option<()>>`\n+\n+fn main() {\n+    #[cfg(local)]\n+    let _: Family<std::path::PathBuf>::Proj = (); //[local]~ ERROR associated type `Proj` not found for `Family<PathBuf>`\n+}"}, {"sha": "b00830fa1c15c6d2edd9aa2881f90e97195737f0", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-0.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,21 @@\n+// Regression test for issue #104251.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct Container<T: ?Sized>(T);\n+\n+impl<T> Container<T> {\n+    type Yield = i32;\n+}\n+\n+struct Duple<T, U>(T, U);\n+\n+impl<T: Copy, U: Send> Duple<T, U> {\n+    type Combination = (T, U);\n+}\n+\n+fn main() {\n+    let _: Container<[u8]>::Yield = 1; //~ ERROR the associated type `Yield` exists for `Container<[u8]>`, but its trait bounds were not satisfied\n+    let _: Duple<String, std::rc::Rc<str>>::Combination; //~ ERROR the associated type `Combination` exists for `Duple<String, Rc<str>>`, but its trait bounds were not satisfied\n+}"}, {"sha": "736579067615a7338268fb4ae341d96688e8759f", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-0.stderr", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-0.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,27 @@\n+error: the associated type `Yield` exists for `Container<[u8]>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds-0.rs:19:29\n+   |\n+LL | struct Container<T: ?Sized>(T);\n+   | --------------------------- associated item `Yield` not found for this struct\n+...\n+LL |     let _: Container<[u8]>::Yield = 1;\n+   |                             ^^^^^ associated type cannot be referenced on `Container<[u8]>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `[u8]: Sized`\n+\n+error: the associated type `Combination` exists for `Duple<String, Rc<str>>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds-0.rs:20:45\n+   |\n+LL | struct Duple<T, U>(T, U);\n+   | ------------------ associated item `Combination` not found for this struct\n+...\n+LL |     let _: Duple<String, std::rc::Rc<str>>::Combination;\n+   |                                             ^^^^^^^^^^^ associated type cannot be referenced on `Duple<String, Rc<str>>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `Rc<str>: Send`\n+           `String: Copy`\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "c80b1364ae3b8a24c7cf1c4c7c70eda674697ff4", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,18 @@\n+// fail-check\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+// Test if we use the correct `ParamEnv` when proving obligations.\n+\n+fn parameterized<T>() {\n+    let _: Container<T>::Proj = String::new(); //~ ERROR the associated type `Proj` exists for `Container<T>`, but its trait bounds were not satisfied\n+}\n+\n+struct Container<T>(T);\n+\n+impl<T: Clone> Container<T> {\n+    type Proj = String;\n+}\n+\n+fn main() {}"}, {"sha": "230bfa538b4f32148c02556715f17d9bd0f72732", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-1.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-1.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,14 @@\n+error: the associated type `Proj` exists for `Container<T>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds-1.rs:9:26\n+   |\n+LL |     let _: Container<T>::Proj = String::new();\n+   |                          ^^^^ associated type cannot be referenced on `Container<T>` due to unsatisfied trait bounds\n+...\n+LL | struct Container<T>(T);\n+   | ------------------- associated item `Proj` not found for this struct\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `T: Clone`\n+\n+error: aborting due to previous error\n+"}, {"sha": "5b0e8de9c580baf4478c7241899bf4cabff5ba42", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-in-multiple-impls.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,20 @@\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<A, B>(A, B);\n+struct Featureless;\n+\n+trait One {}\n+trait Two {}\n+\n+impl<T: One> S<Featureless, T> {\n+    type X = ();\n+}\n+\n+impl<T: Two> S<T, Featureless> {\n+    type X = String;\n+}\n+\n+fn main() {\n+    let _: S::<Featureless, Featureless>::X; //~ ERROR the associated type `X` exists for `S<Featureless, Featureless>`, but its trait bounds were not satisfied\n+}"}, {"sha": "3ddab25deb54c00b7e48dae515154ce0feff0ede", "filename": "tests/ui/associated-inherent-types/not-found-unsatisfied-bounds-in-multiple-impls.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fnot-found-unsatisfied-bounds-in-multiple-impls.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,20 @@\n+error: the associated type `X` exists for `S<Featureless, Featureless>`, but its trait bounds were not satisfied\n+  --> $DIR/not-found-unsatisfied-bounds-in-multiple-impls.rs:19:43\n+   |\n+LL | struct S<A, B>(A, B);\n+   | -------------- associated item `X` not found for this struct\n+LL | struct Featureless;\n+   | ------------------\n+   | |\n+   | doesn't satisfy `Featureless: One`\n+   | doesn't satisfy `Featureless: Two`\n+...\n+LL |     let _: S::<Featureless, Featureless>::X;\n+   |                                           ^ associated type cannot be referenced on `S<Featureless, Featureless>` due to unsatisfied trait bounds\n+   |\n+   = note: the following trait bounds were not satisfied:\n+           `Featureless: One`\n+           `Featureless: Two`\n+\n+error: aborting due to previous error\n+"}, {"sha": "00eb1a14da47ae77604011b87f35b5951b38e3e2", "filename": "tests/ui/associated-inherent-types/substitute-params-bad.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,23 @@\n+// Regression test for issue #105305 and for\n+// https://github.com/rust-lang/rust/issues/107468#issuecomment-1409096700\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+struct S<T>(T);\n+\n+impl<T, 'a> S<T> { //~ ERROR lifetime parameters must be declared prior to type and const parameters\n+    type P = T;\n+}\n+\n+struct Subj<T>(T);\n+\n+impl<T, S> Subj<(T, S)> {\n+    type Un = (T, S);\n+}\n+\n+fn main() {\n+    type A = S<()>::P;\n+\n+    let _: Subj<(i32, i32)>::Un = 0i32; //~ ERROR mismatched types\n+}"}, {"sha": "7a7808ba67b14d3ee6ecb5c5ddcffef17b70ca26", "filename": "tests/ui/associated-inherent-types/substitute-params-bad.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params-bad.stderr?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -0,0 +1,20 @@\n+error: lifetime parameters must be declared prior to type and const parameters\n+  --> $DIR/substitute-params-bad.rs:9:9\n+   |\n+LL | impl<T, 'a> S<T> {\n+   |     ----^^- help: reorder the parameters: lifetimes, then consts and types: `<'a, T>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/substitute-params-bad.rs:22:35\n+   |\n+LL |     let _: Subj<(i32, i32)>::Un = 0i32;\n+   |            --------------------   ^^^^ expected `(i32, i32)`, found `i32`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected tuple `(i32, i32)`\n+               found type `i32`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}, {"sha": "e94d683315903c9c84babf8089a367717896e79b", "filename": "tests/ui/associated-inherent-types/substitute-params.rs", "status": "renamed", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b552967b8ed122aa949cddac8c2270b6490e64e/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fassociated-inherent-types%2Fsubstitute-params.rs?ref=7b552967b8ed122aa949cddac8c2270b6490e64e", "patch": "@@ -9,7 +9,15 @@ impl<T> S<T> {\n     type P = T;\n }\n \n+impl<T> S<(T,)> {\n+    type Un = T;\n+}\n+\n fn main() {\n+    // Regression test for issue #104240.\n     type A = S<()>::P;\n     let _: A = ();\n+\n+    // Regression test for issue #107468.\n+    let _: S<(i32,)>::Un = 0i32;\n }", "previous_filename": "tests/ui/associated-inherent-types/struct-generics.rs"}]}