{"sha": "229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86", "node_id": "C_kwDOAAsO6NoAKDIyOWIwYTBmZGNhMWZhMmJiZjI3YTEzYzdkYmIyMDVjNmE3OGFmODY", "commit": {"author": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2023-04-12T12:57:12Z"}, "committer": {"name": "Gary Guo", "email": "gary@garyguo.net", "date": "2023-04-12T13:05:05Z"}, "message": "Make rust-intrinsic ABI unwindable\n\nStick `#[rustc_nounwind]` to all except `const_eval_select` to undo the\nchange for all other intrinsics.", "tree": {"sha": "995d0060941c21c0cab2ebae90d80ff64e2f344d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/995d0060941c21c0cab2ebae90d80ff64e2f344d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86", "html_url": "https://github.com/rust-lang/rust/commit/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/comments", "author": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nbdd0121", "id": 4065244, "node_id": "MDQ6VXNlcjQwNjUyNDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4065244?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nbdd0121", "html_url": "https://github.com/nbdd0121", "followers_url": "https://api.github.com/users/nbdd0121/followers", "following_url": "https://api.github.com/users/nbdd0121/following{/other_user}", "gists_url": "https://api.github.com/users/nbdd0121/gists{/gist_id}", "starred_url": "https://api.github.com/users/nbdd0121/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nbdd0121/subscriptions", "organizations_url": "https://api.github.com/users/nbdd0121/orgs", "repos_url": "https://api.github.com/users/nbdd0121/repos", "events_url": "https://api.github.com/users/nbdd0121/events{/privacy}", "received_events_url": "https://api.github.com/users/nbdd0121/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be9b5e09ad834e2ba9f2571ca17059e18f89b71", "html_url": "https://github.com/rust-lang/rust/commit/9be9b5e09ad834e2ba9f2571ca17059e18f89b71"}], "stats": {"total": 239, "additions": 236, "deletions": 3}, "files": [{"sha": "195d951f9f366af83a45f198e182d692ab289829", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86", "patch": "@@ -1226,10 +1226,11 @@ pub fn fn_can_unwind(tcx: TyCtxt<'_>, fn_def_id: Option<DefId>, abi: SpecAbi) ->\n         | AvrNonBlockingInterrupt\n         | CCmseNonSecureCall\n         | Wasm\n-        | RustIntrinsic\n         | PlatformIntrinsic\n         | Unadjusted => false,\n-        Rust | RustCall | RustCold => tcx.sess.panic_strategy() == PanicStrategy::Unwind,\n+        Rust | RustCall | RustCold | RustIntrinsic => {\n+            tcx.sess.panic_strategy() == PanicStrategy::Unwind\n+        }\n     }\n }\n "}, {"sha": "c4f554c8c6bf99c57d2dfeeee6636975e37911a8", "filename": "library/core/src/ffi/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fffi%2Fmod.rs?ref=229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86", "patch": "@@ -615,12 +615,15 @@ impl<'f> Drop for VaListImpl<'f> {\n extern \"rust-intrinsic\" {\n     /// Destroy the arglist `ap` after initialization with `va_start` or\n     /// `va_copy`.\n+    #[rustc_nounwind]\n     fn va_end(ap: &mut VaListImpl<'_>);\n \n     /// Copies the current location of arglist `src` to the arglist `dst`.\n+    #[rustc_nounwind]\n     fn va_copy<'f>(dest: *mut VaListImpl<'f>, src: &VaListImpl<'f>);\n \n     /// Loads an argument of type `T` from the `va_list` `ap` and increment the\n     /// argument `ap` points to.\n+    #[rustc_nounwind]\n     fn va_arg<T: sealed_trait::VaArgSafe>(ap: &mut VaListImpl<'_>) -> T;\n }"}, {"sha": "10c5425b7cf0a15d158487ba17312cf35e4837c7", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 229, "deletions": 1, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86", "patch": "@@ -84,104 +84,119 @@ extern \"rust-intrinsic\" {\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange` method by passing\n     /// [`Ordering::SeqCst`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchg_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Stores a value if the current value is the same as the `old` value.\n@@ -190,411 +205,477 @@ extern \"rust-intrinsic\" {\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Relaxed`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_relaxed_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Acquire`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acquire_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::Release`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_release_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::AcqRel`] and [`Ordering::SeqCst`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_acqrel_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Relaxed`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_relaxed<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] and [`Ordering::Acquire`] as the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_acquire<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n     /// Stores a value if the current value is the same as the `old` value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `compare_exchange_weak` method by passing\n     /// [`Ordering::SeqCst`] as both the success and failure parameters.\n     /// For example, [`AtomicBool::compare_exchange_weak`].\n+    #[rustc_nounwind]\n     pub fn atomic_cxchgweak_seqcst_seqcst<T: Copy>(dst: *mut T, old: T, src: T) -> (T, bool);\n \n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_seqcst<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_acquire<T: Copy>(src: *const T) -> T;\n     /// Loads the current value of the pointer.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `load` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::load`].\n+    #[rustc_nounwind]\n     pub fn atomic_load_relaxed<T: Copy>(src: *const T) -> T;\n+    #[rustc_nounwind]\n     pub fn atomic_load_unordered<T: Copy>(src: *const T) -> T;\n \n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_seqcst<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_release<T: Copy>(dst: *mut T, val: T);\n     /// Stores the value at the specified memory location.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `store` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::store`].\n+    #[rustc_nounwind]\n     pub fn atomic_store_relaxed<T: Copy>(dst: *mut T, val: T);\n+    #[rustc_nounwind]\n     pub fn atomic_store_unordered<T: Copy>(dst: *mut T, val: T);\n \n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Stores the value at the specified memory location, returning the old value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `swap` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::swap`].\n+    #[rustc_nounwind]\n     pub fn atomic_xchg_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Adds to the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_add` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_add`].\n+    #[rustc_nounwind]\n     pub fn atomic_xadd_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Subtract from the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_sub` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicIsize::fetch_sub`].\n+    #[rustc_nounwind]\n     pub fn atomic_xsub_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise and with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_and` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_and`].\n+    #[rustc_nounwind]\n     pub fn atomic_and_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise nand with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`AtomicBool`] type via the `fetch_nand` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_nand`].\n+    #[rustc_nounwind]\n     pub fn atomic_nand_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise or with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_or` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_or`].\n+    #[rustc_nounwind]\n     pub fn atomic_or_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Bitwise xor with the current value, returning the previous value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] types via the `fetch_xor` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicBool::fetch_xor`].\n+    #[rustc_nounwind]\n     pub fn atomic_xor_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_max_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using a signed comparison.\n     ///\n@@ -607,93 +688,108 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] signed integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicI32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_min_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Minimum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_min` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_min`].\n+    #[rustc_nounwind]\n     pub fn atomic_umin_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::SeqCst`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_seqcst<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Acquire`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_acquire<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Release`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_release<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::AcqRel`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_acqrel<T: Copy>(dst: *mut T, src: T) -> T;\n     /// Maximum with the current value using an unsigned comparison.\n     ///\n     /// The stabilized version of this intrinsic is available on the\n     /// [`atomic`] unsigned integer types via the `fetch_max` method by passing\n     /// [`Ordering::Relaxed`] as the `order`. For example, [`AtomicU32::fetch_max`].\n+    #[rustc_nounwind]\n     pub fn atomic_umax_relaxed<T: Copy>(dst: *mut T, src: T) -> T;\n \n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_seqcst();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_acquire();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_release();\n     /// An atomic fence.\n     ///\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_fence_acqrel();\n \n     /// A compiler-only memory barrier.\n@@ -706,6 +802,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::SeqCst`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_seqcst();\n     /// A compiler-only memory barrier.\n     ///\n@@ -717,6 +814,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Acquire`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_acquire();\n     /// A compiler-only memory barrier.\n     ///\n@@ -728,6 +826,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::Release`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_release();\n     /// A compiler-only memory barrier.\n     ///\n@@ -739,6 +838,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is available in\n     /// [`atomic::compiler_fence`] by passing [`Ordering::AcqRel`]\n     /// as the `order`.\n+    #[rustc_nounwind]\n     pub fn atomic_singlethreadfence_acqrel();\n \n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n@@ -750,6 +850,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_read_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -760,6 +861,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_write_data<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -770,6 +872,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_read_instruction<T>(data: *const T, locality: i32);\n     /// The `prefetch` intrinsic is a hint to the code generator to insert a prefetch instruction\n     /// if supported; otherwise, it is a no-op.\n@@ -780,6 +883,7 @@ extern \"rust-intrinsic\" {\n     /// ranging from (0) - no locality, to (3) - extremely local keep in cache.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn prefetch_write_instruction<T>(data: *const T, locality: i32);\n \n     /// Magic intrinsic that derives its meaning from attributes\n@@ -792,6 +896,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic should not be used outside of the compiler.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rustc_peek<T>(_: T) -> T;\n \n     /// Aborts the execution of the process.\n@@ -810,6 +915,7 @@ extern \"rust-intrinsic\" {\n     /// process will probably terminate with a signal like `SIGABRT`, `SIGILL`, `SIGTRAP`, `SIGSEGV` or\n     /// `SIGBUS`.  The precise behaviour is not guaranteed and not stable.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn abort() -> !;\n \n     /// Informs the optimizer that this point in the code is not reachable,\n@@ -821,6 +927,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// The stabilized version of this intrinsic is [`core::hint::unreachable_unchecked`].\n     #[rustc_const_stable(feature = \"const_unreachable_unchecked\", since = \"1.57.0\")]\n+    #[rustc_nounwind]\n     pub fn unreachable() -> !;\n \n     /// Informs the optimizer that a condition is always true.\n@@ -834,6 +941,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assume\", issue = \"76972\")]\n+    #[rustc_nounwind]\n     pub fn assume(b: bool);\n \n     /// Hints to the compiler that branch condition is likely to be true.\n@@ -849,6 +957,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn likely(b: bool) -> bool;\n \n     /// Hints to the compiler that branch condition is likely to be false.\n@@ -864,11 +973,13 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_likely\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn unlikely(b: bool) -> bool;\n \n     /// Executes a breakpoint trap, for inspection by a debugger.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn breakpoint();\n \n     /// The size of a type in bytes.\n@@ -884,6 +995,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::size_of`].\n     #[rustc_const_stable(feature = \"const_size_of\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn size_of<T>() -> usize;\n \n     /// The minimum alignment of a type.\n@@ -896,23 +1008,27 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::align_of`].\n     #[rustc_const_stable(feature = \"const_min_align_of\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn min_align_of<T>() -> usize;\n     /// The preferred alignment of a type.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     /// It's \"tracking issue\" is [#91971](https://github.com/rust-lang/rust/issues/91971).\n     #[rustc_const_unstable(feature = \"const_pref_align_of\", issue = \"91971\")]\n+    #[rustc_nounwind]\n     pub fn pref_align_of<T>() -> usize;\n \n     /// The size of the referenced value in bytes.\n     ///\n     /// The stabilized version of this intrinsic is [`mem::size_of_val`].\n     #[rustc_const_unstable(feature = \"const_size_of_val\", issue = \"46571\")]\n+    #[rustc_nounwind]\n     pub fn size_of_val<T: ?Sized>(_: *const T) -> usize;\n     /// The required alignment of the referenced value.\n     ///\n     /// The stabilized version of this intrinsic is [`core::mem::align_of_val`].\n     #[rustc_const_unstable(feature = \"const_align_of_val\", issue = \"46571\")]\n+    #[rustc_nounwind]\n     pub fn min_align_of_val<T: ?Sized>(_: *const T) -> usize;\n \n     /// Gets a static string slice containing the name of a type.\n@@ -925,6 +1041,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::any::type_name`].\n     #[rustc_const_unstable(feature = \"const_type_name\", issue = \"63084\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn type_name<T: ?Sized>() -> &'static str;\n \n     /// Gets an identifier which is globally unique to the specified type. This\n@@ -939,6 +1056,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::any::TypeId::of`].\n     #[rustc_const_unstable(feature = \"const_type_id\", issue = \"77125\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn type_id<T: ?Sized + 'static>() -> u64;\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` is uninhabited:\n@@ -947,6 +1065,7 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_stable(feature = \"const_assert_type\", since = \"1.59.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_inhabited<T>();\n \n     /// A guard for unsafe functions that cannot ever be executed if `T` does not permit\n@@ -955,13 +1074,15 @@ extern \"rust-intrinsic\" {\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_zero_valid<T>();\n \n     /// A guard for `std::mem::uninitialized`. This will statically either panic, or do nothing.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_assert_type2\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn assert_mem_uninitialized_valid<T>();\n \n     /// Gets a reference to a static `Location` indicating where it was called.\n@@ -974,6 +1095,7 @@ extern \"rust-intrinsic\" {\n     /// Consider using [`core::panic::Location::caller`] instead.\n     #[rustc_const_unstable(feature = \"const_caller_location\", issue = \"76156\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn caller_location() -> &'static crate::panic::Location<'static>;\n \n     /// Moves a value out of scope without running drop glue.\n@@ -987,6 +1109,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_intrinsic_forget\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn forget<T: ?Sized>(_: T);\n \n     /// Reinterprets the bits of a value of one type as another type.\n@@ -1250,6 +1373,7 @@ extern \"rust-intrinsic\" {\n     #[rustc_allowed_through_unstable_modules]\n     #[rustc_const_stable(feature = \"const_transmute\", since = \"1.56.0\")]\n     #[rustc_diagnostic_item = \"transmute\"]\n+    #[rustc_nounwind]\n     pub fn transmute<Src, Dst>(src: Src) -> Dst;\n \n     /// Returns `true` if the actual type given as `T` requires drop\n@@ -1267,6 +1391,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`mem::needs_drop`](crate::mem::needs_drop).\n     #[rustc_const_stable(feature = \"const_needs_drop\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn needs_drop<T: ?Sized>() -> bool;\n \n     /// Calculates the offset from a pointer.\n@@ -1284,6 +1409,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`pointer::offset`].\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n+    #[rustc_nounwind]\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Calculates the offset from a pointer, potentially wrapping.\n@@ -1301,6 +1427,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`pointer::wrapping_offset`].\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n     #[rustc_const_stable(feature = \"const_ptr_offset\", since = \"1.61.0\")]\n+    #[rustc_nounwind]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Masks out bits of the pointer according to a mask.\n@@ -1312,6 +1439,7 @@ extern \"rust-intrinsic\" {\n     ///\n     /// Consider using [`pointer::mask`] instead.\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ptr_mask<T>(ptr: *const T, mask: usize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with\n@@ -1322,6 +1450,7 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memmove.p0i8.0i8.*` intrinsic, with\n     /// a size of `count * size_of::<T>()` and an alignment of\n@@ -1331,6 +1460,7 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n     /// Equivalent to the appropriate `llvm.memset.p0i8.*` intrinsic, with a\n     /// size of `count * size_of::<T>()` and an alignment of\n@@ -1340,158 +1470,187 @@ extern \"rust-intrinsic\" {\n     /// unless size is equal to zero.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn volatile_set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Performs a volatile load from the `src` pointer.\n     ///\n     /// The stabilized version of this intrinsic is [`core::ptr::read_volatile`].\n+    #[rustc_nounwind]\n     pub fn volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     ///\n     /// The stabilized version of this intrinsic is [`core::ptr::write_volatile`].\n+    #[rustc_nounwind]\n     pub fn volatile_store<T>(dst: *mut T, val: T);\n \n     /// Performs a volatile load from the `src` pointer\n     /// The pointer is not required to be aligned.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn unaligned_volatile_load<T>(src: *const T) -> T;\n     /// Performs a volatile store to the `dst` pointer.\n     /// The pointer is not required to be aligned.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn unaligned_volatile_store<T>(dst: *mut T, val: T);\n \n     /// Returns the square root of an `f32`\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::sqrt`](../../std/primitive.f32.html#method.sqrt)\n+    #[rustc_nounwind]\n     pub fn sqrtf32(x: f32) -> f32;\n     /// Returns the square root of an `f64`\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::sqrt`](../../std/primitive.f64.html#method.sqrt)\n+    #[rustc_nounwind]\n     pub fn sqrtf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an integer power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::powi`](../../std/primitive.f32.html#method.powi)\n+    #[rustc_nounwind]\n     pub fn powif32(a: f32, x: i32) -> f32;\n     /// Raises an `f64` to an integer power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::powi`](../../std/primitive.f64.html#method.powi)\n+    #[rustc_nounwind]\n     pub fn powif64(a: f64, x: i32) -> f64;\n \n     /// Returns the sine of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::sin`](../../std/primitive.f32.html#method.sin)\n+    #[rustc_nounwind]\n     pub fn sinf32(x: f32) -> f32;\n     /// Returns the sine of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::sin`](../../std/primitive.f64.html#method.sin)\n+    #[rustc_nounwind]\n     pub fn sinf64(x: f64) -> f64;\n \n     /// Returns the cosine of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::cos`](../../std/primitive.f32.html#method.cos)\n+    #[rustc_nounwind]\n     pub fn cosf32(x: f32) -> f32;\n     /// Returns the cosine of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::cos`](../../std/primitive.f64.html#method.cos)\n+    #[rustc_nounwind]\n     pub fn cosf64(x: f64) -> f64;\n \n     /// Raises an `f32` to an `f32` power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::powf`](../../std/primitive.f32.html#method.powf)\n+    #[rustc_nounwind]\n     pub fn powf32(a: f32, x: f32) -> f32;\n     /// Raises an `f64` to an `f64` power.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::powf`](../../std/primitive.f64.html#method.powf)\n+    #[rustc_nounwind]\n     pub fn powf64(a: f64, x: f64) -> f64;\n \n     /// Returns the exponential of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::exp`](../../std/primitive.f32.html#method.exp)\n+    #[rustc_nounwind]\n     pub fn expf32(x: f32) -> f32;\n     /// Returns the exponential of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::exp`](../../std/primitive.f64.html#method.exp)\n+    #[rustc_nounwind]\n     pub fn expf64(x: f64) -> f64;\n \n     /// Returns 2 raised to the power of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::exp2`](../../std/primitive.f32.html#method.exp2)\n+    #[rustc_nounwind]\n     pub fn exp2f32(x: f32) -> f32;\n     /// Returns 2 raised to the power of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::exp2`](../../std/primitive.f64.html#method.exp2)\n+    #[rustc_nounwind]\n     pub fn exp2f64(x: f64) -> f64;\n \n     /// Returns the natural logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::ln`](../../std/primitive.f32.html#method.ln)\n+    #[rustc_nounwind]\n     pub fn logf32(x: f32) -> f32;\n     /// Returns the natural logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::ln`](../../std/primitive.f64.html#method.ln)\n+    #[rustc_nounwind]\n     pub fn logf64(x: f64) -> f64;\n \n     /// Returns the base 10 logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::log10`](../../std/primitive.f32.html#method.log10)\n+    #[rustc_nounwind]\n     pub fn log10f32(x: f32) -> f32;\n     /// Returns the base 10 logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::log10`](../../std/primitive.f64.html#method.log10)\n+    #[rustc_nounwind]\n     pub fn log10f64(x: f64) -> f64;\n \n     /// Returns the base 2 logarithm of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::log2`](../../std/primitive.f32.html#method.log2)\n+    #[rustc_nounwind]\n     pub fn log2f32(x: f32) -> f32;\n     /// Returns the base 2 logarithm of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::log2`](../../std/primitive.f64.html#method.log2)\n+    #[rustc_nounwind]\n     pub fn log2f64(x: f64) -> f64;\n \n     /// Returns `a * b + c` for `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::mul_add`](../../std/primitive.f32.html#method.mul_add)\n+    #[rustc_nounwind]\n     pub fn fmaf32(a: f32, b: f32, c: f32) -> f32;\n     /// Returns `a * b + c` for `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::mul_add`](../../std/primitive.f64.html#method.mul_add)\n+    #[rustc_nounwind]\n     pub fn fmaf64(a: f64, b: f64, c: f64) -> f64;\n \n     /// Returns the absolute value of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::abs`](../../std/primitive.f32.html#method.abs)\n+    #[rustc_nounwind]\n     pub fn fabsf32(x: f32) -> f32;\n     /// Returns the absolute value of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::abs`](../../std/primitive.f64.html#method.abs)\n+    #[rustc_nounwind]\n     pub fn fabsf64(x: f64) -> f64;\n \n     /// Returns the minimum of two `f32` values.\n@@ -1504,6 +1663,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f32::min`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn minnumf32(x: f32, y: f32) -> f32;\n     /// Returns the minimum of two `f64` values.\n     ///\n@@ -1515,6 +1675,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f64::min`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn minnumf64(x: f64, y: f64) -> f64;\n     /// Returns the maximum of two `f32` values.\n     ///\n@@ -1526,6 +1687,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f32::max`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn maxnumf32(x: f32, y: f32) -> f32;\n     /// Returns the maximum of two `f64` values.\n     ///\n@@ -1537,132 +1699,155 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`f64::max`]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn maxnumf64(x: f64, y: f64) -> f64;\n \n     /// Copies the sign from `y` to `x` for `f32` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::copysign`](../../std/primitive.f32.html#method.copysign)\n+    #[rustc_nounwind]\n     pub fn copysignf32(x: f32, y: f32) -> f32;\n     /// Copies the sign from `y` to `x` for `f64` values.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::copysign`](../../std/primitive.f64.html#method.copysign)\n+    #[rustc_nounwind]\n     pub fn copysignf64(x: f64, y: f64) -> f64;\n \n     /// Returns the largest integer less than or equal to an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::floor`](../../std/primitive.f32.html#method.floor)\n+    #[rustc_nounwind]\n     pub fn floorf32(x: f32) -> f32;\n     /// Returns the largest integer less than or equal to an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::floor`](../../std/primitive.f64.html#method.floor)\n+    #[rustc_nounwind]\n     pub fn floorf64(x: f64) -> f64;\n \n     /// Returns the smallest integer greater than or equal to an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::ceil`](../../std/primitive.f32.html#method.ceil)\n+    #[rustc_nounwind]\n     pub fn ceilf32(x: f32) -> f32;\n     /// Returns the smallest integer greater than or equal to an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::ceil`](../../std/primitive.f64.html#method.ceil)\n+    #[rustc_nounwind]\n     pub fn ceilf64(x: f64) -> f64;\n \n     /// Returns the integer part of an `f32`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::trunc`](../../std/primitive.f32.html#method.trunc)\n+    #[rustc_nounwind]\n     pub fn truncf32(x: f32) -> f32;\n     /// Returns the integer part of an `f64`.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::trunc`](../../std/primitive.f64.html#method.trunc)\n+    #[rustc_nounwind]\n     pub fn truncf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::round_ties_even`](../../std/primitive.f32.html#method.round_ties_even)\n+    #[rustc_nounwind]\n     pub fn rintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. May raise an inexact floating-point exception\n     /// if the argument is not an integer.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::round_ties_even`](../../std/primitive.f64.html#method.round_ties_even)\n+    #[rustc_nounwind]\n     pub fn rintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn nearbyintf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn nearbyintf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases away from zero.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f32::round`](../../std/primitive.f32.html#method.round)\n+    #[rustc_nounwind]\n     pub fn roundf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases away from zero.\n     ///\n     /// The stabilized version of this intrinsic is\n     /// [`f64::round`](../../std/primitive.f64.html#method.round)\n+    #[rustc_nounwind]\n     pub fn roundf64(x: f64) -> f64;\n \n     /// Returns the nearest integer to an `f32`. Rounds half-way cases to the number\n     /// with an even least significant digit.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn roundevenf32(x: f32) -> f32;\n     /// Returns the nearest integer to an `f64`. Rounds half-way cases to the number\n     /// with an even least significant digit.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn roundevenf64(x: f64) -> f64;\n \n     /// Float addition that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fadd_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float subtraction that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fsub_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float multiplication that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fmul_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float division that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn fdiv_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Float remainder that allows optimizations based on algebraic rules.\n     /// May assume inputs are finite.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n+    #[rustc_nounwind]\n     pub fn frem_fast<T: Copy>(a: T, b: T) -> T;\n \n     /// Convert with LLVM\u2019s fptoui/fptosi, which may return undef for values out of range\n     /// (<https://github.com/rust-lang/rust/issues/10184>)\n     ///\n     /// Stabilized as [`f32::to_int_unchecked`] and [`f64::to_int_unchecked`].\n+    #[rustc_nounwind]\n     pub fn float_to_int_unchecked<Float: Copy, Int: Copy>(value: Float) -> Int;\n \n     /// Returns the number of bits set in an integer type `T`\n@@ -1677,6 +1862,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::count_ones`]\n     #[rustc_const_stable(feature = \"const_ctpop\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ctpop<T: Copy>(x: T) -> T;\n \n     /// Returns the number of leading unset bits (zeroes) in an integer type `T`.\n@@ -1715,6 +1901,7 @@ extern \"rust-intrinsic\" {\n     /// ```\n     #[rustc_const_stable(feature = \"const_ctlz\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ctlz<T: Copy>(x: T) -> T;\n \n     /// Like `ctlz`, but extra-unsafe as it returns `undef` when\n@@ -1734,6 +1921,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_leading, 3);\n     /// ```\n     #[rustc_const_stable(feature = \"constctlz\", since = \"1.50.0\")]\n+    #[rustc_nounwind]\n     pub fn ctlz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Returns the number of trailing unset bits (zeroes) in an integer type `T`.\n@@ -1772,6 +1960,7 @@ extern \"rust-intrinsic\" {\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn cttz<T: Copy>(x: T) -> T;\n \n     /// Like `cttz`, but extra-unsafe as it returns `undef` when\n@@ -1791,6 +1980,7 @@ extern \"rust-intrinsic\" {\n     /// assert_eq!(num_trailing, 3);\n     /// ```\n     #[rustc_const_stable(feature = \"const_cttz_nonzero\", since = \"1.53.0\")]\n+    #[rustc_nounwind]\n     pub fn cttz_nonzero<T: Copy>(x: T) -> T;\n \n     /// Reverses the bytes in an integer type `T`.\n@@ -1805,6 +1995,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::swap_bytes`]\n     #[rustc_const_stable(feature = \"const_bswap\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn bswap<T: Copy>(x: T) -> T;\n \n     /// Reverses the bits in an integer type `T`.\n@@ -1819,6 +2010,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::reverse_bits`]\n     #[rustc_const_stable(feature = \"const_bitreverse\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn bitreverse<T: Copy>(x: T) -> T;\n \n     /// Performs checked integer addition.\n@@ -1833,6 +2025,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_add`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn add_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer subtraction\n@@ -1847,6 +2040,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_sub`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn sub_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs checked integer multiplication\n@@ -1861,13 +2055,15 @@ extern \"rust-intrinsic\" {\n     /// [`u32::overflowing_mul`]\n     #[rustc_const_stable(feature = \"const_int_overflow\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn mul_with_overflow<T: Copy>(x: T, y: T) -> (T, bool);\n \n     /// Performs an exact division, resulting in undefined behavior where\n     /// `x % y != 0` or `y == 0` or `x == T::MIN && y == -1`\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_exact_div\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn exact_div<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked division, resulting in undefined behavior\n@@ -1877,6 +2073,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_div` method. For example,\n     /// [`u32::checked_div`]\n     #[rustc_const_stable(feature = \"const_int_unchecked_div\", since = \"1.52.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_div<T: Copy>(x: T, y: T) -> T;\n     /// Returns the remainder of an unchecked division, resulting in\n     /// undefined behavior when `y == 0` or `x == T::MIN && y == -1`\n@@ -1885,6 +2082,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_rem` method. For example,\n     /// [`u32::checked_rem`]\n     #[rustc_const_stable(feature = \"const_int_unchecked_rem\", since = \"1.52.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_rem<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs an unchecked left shift, resulting in undefined behavior when\n@@ -1894,6 +2092,7 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shl` method. For example,\n     /// [`u32::checked_shl`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_shl<T: Copy>(x: T, y: T) -> T;\n     /// Performs an unchecked right shift, resulting in undefined behavior when\n     /// `y < 0` or `y >= N`, where N is the width of T in bits.\n@@ -1902,27 +2101,31 @@ extern \"rust-intrinsic\" {\n     /// primitives via the `checked_shr` method. For example,\n     /// [`u32::checked_shr`]\n     #[rustc_const_stable(feature = \"const_int_unchecked\", since = \"1.40.0\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_shr<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked addition, resulting in\n     /// undefined behavior when `x + y > T::MAX` or `x + y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_add<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked subtraction, resulting in\n     /// undefined behavior when `x - y > T::MAX` or `x - y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_sub<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns the result of an unchecked multiplication, resulting in\n     /// undefined behavior when `x * y > T::MAX` or `x * y < T::MIN`.\n     ///\n     /// This intrinsic does not have a stable counterpart.\n     #[rustc_const_unstable(feature = \"const_int_unchecked_arith\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn unchecked_mul<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate left.\n@@ -1937,6 +2140,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::rotate_left`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rotate_left<T: Copy>(x: T, y: T) -> T;\n \n     /// Performs rotate right.\n@@ -1951,6 +2155,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::rotate_right`]\n     #[rustc_const_stable(feature = \"const_int_rotate\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn rotate_right<T: Copy>(x: T, y: T) -> T;\n \n     /// Returns (a + b) mod 2<sup>N</sup>, where N is the width of T in bits.\n@@ -1965,6 +2170,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_add`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_add<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a - b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1978,6 +2184,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_sub`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_sub<T: Copy>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2<sup>N</sup>, where N is the width of T in bits.\n     ///\n@@ -1991,6 +2198,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::wrapping_mul`]\n     #[rustc_const_stable(feature = \"const_int_wrapping\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn wrapping_mul<T: Copy>(a: T, b: T) -> T;\n \n     /// Computes `a + b`, saturating at numeric bounds.\n@@ -2005,6 +2213,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::saturating_add`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn saturating_add<T: Copy>(a: T, b: T) -> T;\n     /// Computes `a - b`, saturating at numeric bounds.\n     ///\n@@ -2018,6 +2227,7 @@ extern \"rust-intrinsic\" {\n     /// [`u32::saturating_sub`]\n     #[rustc_const_stable(feature = \"const_int_saturating\", since = \"1.40.0\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn saturating_sub<T: Copy>(a: T, b: T) -> T;\n \n     /// This is an implementation detail of [`crate::ptr::read`] and should\n@@ -2028,6 +2238,7 @@ extern \"rust-intrinsic\" {\n     /// trivially obeys runtime-MIR rules about derefs in operands.\n     #[cfg(not(bootstrap))]\n     #[rustc_const_unstable(feature = \"const_ptr_read\", issue = \"80377\")]\n+    #[rustc_nounwind]\n     pub fn read_via_copy<T>(p: *const T) -> T;\n \n     /// Returns the value of the discriminant for the variant in 'v';\n@@ -2041,6 +2252,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is [`core::mem::discriminant`].\n     #[rustc_const_unstable(feature = \"const_discriminant\", issue = \"69821\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn discriminant_value<T>(v: &T) -> <T as DiscriminantKind>::Discriminant;\n \n     /// Returns the number of variants of the type `T` cast to a `usize`;\n@@ -2054,6 +2266,7 @@ extern \"rust-intrinsic\" {\n     /// The to-be-stabilized version of this intrinsic is [`mem::variant_count`].\n     #[rustc_const_unstable(feature = \"variant_count\", issue = \"73662\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn variant_count<T>() -> usize;\n \n     /// Rust's \"try catch\" construct which invokes the function pointer `try_fn`\n@@ -2063,18 +2276,22 @@ extern \"rust-intrinsic\" {\n     /// takes the data pointer and a pointer to the target-specific exception\n     /// object that was caught. For more information see the compiler's\n     /// source as well as std's catch implementation.\n+    #[rustc_nounwind]\n     pub fn r#try(try_fn: fn(*mut u8), data: *mut u8, catch_fn: fn(*mut u8, *mut u8)) -> i32;\n \n     /// Emits a `!nontemporal` store according to LLVM (see their docs).\n     /// Probably will never become stable.\n+    #[rustc_nounwind]\n     pub fn nontemporal_store<T>(ptr: *mut T, val: T);\n \n     /// See documentation of `<*const T>::offset_from` for details.\n     #[rustc_const_stable(feature = \"const_ptr_offset_from\", since = \"1.65.0\")]\n+    #[rustc_nounwind]\n     pub fn ptr_offset_from<T>(ptr: *const T, base: *const T) -> isize;\n \n     /// See documentation of `<*const T>::sub_ptr` for details.\n     #[rustc_const_unstable(feature = \"const_ptr_sub_ptr\", issue = \"95892\")]\n+    #[rustc_nounwind]\n     pub fn ptr_offset_from_unsigned<T>(ptr: *const T, base: *const T) -> usize;\n \n     /// See documentation of `<*const T>::guaranteed_eq` for details.\n@@ -2088,6 +2305,7 @@ extern \"rust-intrinsic\" {\n     /// any safety invariants.\n     #[rustc_const_unstable(feature = \"const_raw_ptr_comparison\", issue = \"53020\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn ptr_guaranteed_cmp<T>(ptr: *const T, other: *const T) -> u8;\n \n     /// Allocates a block of memory at compile time.\n@@ -2099,6 +2317,7 @@ extern \"rust-intrinsic\" {\n     ///    - At compile time, a compile error occurs if this constraint is violated.\n     ///    - At runtime, it is not checked.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n+    #[rustc_nounwind]\n     pub fn const_allocate(size: usize, align: usize) -> *mut u8;\n \n     /// Deallocates a memory which allocated by `intrinsics::const_allocate` at compile time.\n@@ -2112,6 +2331,7 @@ extern \"rust-intrinsic\" {\n     /// - If the `ptr` is created in an another const, this intrinsic doesn't deallocate it.\n     /// - If the `ptr` is pointing to a local variable, this intrinsic doesn't deallocate it.\n     #[rustc_const_unstable(feature = \"const_heap\", issue = \"79597\")]\n+    #[rustc_nounwind]\n     pub fn const_deallocate(ptr: *mut u8, size: usize, align: usize);\n \n     /// Determines whether the raw bytes of the two values are equal.\n@@ -2136,21 +2356,25 @@ extern \"rust-intrinsic\" {\n     /// (The implementation is allowed to branch on the results of comparisons,\n     /// which is UB if any of their inputs are `undef`.)\n     #[rustc_const_unstable(feature = \"const_intrinsic_raw_eq\", issue = \"none\")]\n+    #[rustc_nounwind]\n     pub fn raw_eq<T>(a: &T, b: &T) -> bool;\n \n     /// See documentation of [`std::hint::black_box`] for details.\n     ///\n     /// [`std::hint::black_box`]: crate::hint::black_box\n     #[rustc_const_unstable(feature = \"const_black_box\", issue = \"none\")]\n     #[rustc_safe_intrinsic]\n+    #[rustc_nounwind]\n     pub fn black_box<T>(dummy: T) -> T;\n \n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the size stored in that vtable.\n+    #[rustc_nounwind]\n     pub fn vtable_size(ptr: *const ()) -> usize;\n \n     /// `ptr` must point to a vtable.\n     /// The intrinsic will return the alignment stored in that vtable.\n+    #[rustc_nounwind]\n     pub fn vtable_align(ptr: *const ()) -> usize;\n \n     /// Selects which function to call depending on the context.\n@@ -2215,10 +2439,11 @@ extern \"rust-intrinsic\" {\n         G: FnOnce<ARG, Output = RET>,\n         F: FnOnce<ARG, Output = RET>;\n \n-    #[cfg(not(bootstrap))]\n     /// This method creates a pointer to any `Some` value. If the argument is\n     /// `None`, an invalid within-bounds pointer (that is still acceptable for\n     /// constructing an empty slice) is returned.\n+    #[cfg(not(bootstrap))]\n+    #[rustc_nounwind]\n     pub fn option_payload_ptr<T>(arg: *const Option<T>) -> *const T;\n }\n \n@@ -2392,6 +2617,7 @@ pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -\n pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         pub fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -2482,6 +2708,7 @@ pub const unsafe fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: us\n pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         fn copy<T>(src: *const T, dst: *mut T, count: usize);\n     }\n \n@@ -2554,6 +2781,7 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n pub const unsafe fn write_bytes<T>(dst: *mut T, val: u8, count: usize) {\n     extern \"rust-intrinsic\" {\n         #[rustc_const_unstable(feature = \"const_ptr_write\", issue = \"86302\")]\n+        #[rustc_nounwind]\n         fn write_bytes<T>(dst: *mut T, val: u8, count: usize);\n     }\n "}, {"sha": "818f1a919d0d5f2c3602dd7ccd7217680370a708", "filename": "library/core/src/ptr/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmod.rs?ref=229b0a0fdca1fa2bbf27a13c7dbb205c6a78af86", "patch": "@@ -1371,6 +1371,7 @@ pub const unsafe fn write<T>(dst: *mut T, src: T) {\n     // as `intrinsics::copy_nonoverlapping` is a wrapper function.\n     extern \"rust-intrinsic\" {\n         #[rustc_const_stable(feature = \"const_intrinsic_copy\", since = \"1.63.0\")]\n+        #[rustc_nounwind]\n         fn copy_nonoverlapping<T>(src: *const T, dst: *mut T, count: usize);\n     }\n "}]}