{"sha": "fb28214dcc1ee7dddaa6d318352937fa3e5ce0b2", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiMjgyMTRkY2MxZWU3ZGRkYWE2ZDMxODM1MjkzN2ZhM2U1Y2UwYjI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-01T22:24:00Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-03-01T22:24:00Z"}, "message": "Rollup merge of #22893 - Ms2ger:lints, r=huonw", "tree": {"sha": "493ac469c845fd6423923e9e8f6bd800fe766395", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/493ac469c845fd6423923e9e8f6bd800fe766395"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb28214dcc1ee7dddaa6d318352937fa3e5ce0b2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb28214dcc1ee7dddaa6d318352937fa3e5ce0b2", "html_url": "https://github.com/rust-lang/rust/commit/fb28214dcc1ee7dddaa6d318352937fa3e5ce0b2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb28214dcc1ee7dddaa6d318352937fa3e5ce0b2/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ef8b20a564bab2050403f2f5c1dab90e0941adf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/ef8b20a564bab2050403f2f5c1dab90e0941adf7", "html_url": "https://github.com/rust-lang/rust/commit/ef8b20a564bab2050403f2f5c1dab90e0941adf7"}, {"sha": "fe2e0976decadb94cecc4ab85abdd02345cc7a64", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe2e0976decadb94cecc4ab85abdd02345cc7a64", "html_url": "https://github.com/rust-lang/rust/commit/fe2e0976decadb94cecc4ab85abdd02345cc7a64"}], "stats": {"total": 326, "additions": 173, "deletions": 153}, "files": [{"sha": "fe047d2334eecec5650e1fb346339ae2d5a309a0", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 173, "deletions": 153, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/fb28214dcc1ee7dddaa6d318352937fa3e5ce0b2/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb28214dcc1ee7dddaa6d318352937fa3e5ce0b2/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=fb28214dcc1ee7dddaa6d318352937fa3e5ce0b2", "patch": "@@ -28,8 +28,6 @@\n //! Use the former for unit-like structs and the latter for structs with\n //! a `pub fn new()`.\n \n-use self::MethodContext::*;\n-\n use metadata::{csearch, decoder};\n use middle::def::*;\n use middle::subst::Substs;\n@@ -228,7 +226,9 @@ impl LintPass for TypeLimits {\n                             ast::LitInt(v, ast::UnsuffixedIntLit(ast::Plus)) => {\n                                 let int_type = if let ast::TyIs(_) = t {\n                                     cx.sess().target.int_type\n-                                } else { t };\n+                                } else {\n+                                    t\n+                                };\n                                 let (min, max) = int_ty_range(int_type);\n                                 let negative = self.negated_expr_id == e.id;\n \n@@ -245,14 +245,16 @@ impl LintPass for TypeLimits {\n                     ty::ty_uint(t) => {\n                         let uint_type = if let ast::TyUs(_) = t {\n                             cx.sess().target.uint_type\n-                        } else { t };\n+                        } else {\n+                            t\n+                        };\n                         let (min, max) = uint_ty_range(uint_type);\n                         let lit_val: u64 = match lit.node {\n                             ast::LitByte(_v) => return,  // _v is u8, within range by definition\n                             ast::LitInt(v, _) => v,\n                             _ => panic!()\n                         };\n-                        if  lit_val < min || lit_val > max {\n+                        if lit_val < min || lit_val > max {\n                             cx.span_lint(OVERFLOWING_LITERALS, e.span,\n                                          &*format!(\"literal out of range for {:?}\", t));\n                         }\n@@ -262,9 +264,9 @@ impl LintPass for TypeLimits {\n                         let lit_val: f64 = match lit.node {\n                             ast::LitFloat(ref v, _) |\n                             ast::LitFloatUnsuffixed(ref v) => {\n-                                match v.parse().ok() {\n-                                    Some(f) => f,\n-                                    None => return\n+                                match v.parse() {\n+                                    Ok(f) => f,\n+                                    Err(_) => return\n                                 }\n                             }\n                             _ => panic!()\n@@ -302,52 +304,52 @@ impl LintPass for TypeLimits {\n             })\n         }\n \n-        // for int & uint, be conservative with the warnings, so that the\n+        // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n         fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n             match int_ty {\n-                ast::TyIs(_) =>    (i64::MIN,        i64::MAX),\n-                ast::TyI8 =>   (i8::MIN  as i64, i8::MAX  as i64),\n-                ast::TyI16 =>  (i16::MIN as i64, i16::MAX as i64),\n-                ast::TyI32 =>  (i32::MIN as i64, i32::MAX as i64),\n-                ast::TyI64 =>  (i64::MIN,        i64::MAX)\n+                ast::TyIs(_) => (i64::MIN,        i64::MAX),\n+                ast::TyI8 =>    (i8::MIN  as i64, i8::MAX  as i64),\n+                ast::TyI16 =>   (i16::MIN as i64, i16::MAX as i64),\n+                ast::TyI32 =>   (i32::MIN as i64, i32::MAX as i64),\n+                ast::TyI64 =>   (i64::MIN,        i64::MAX)\n             }\n         }\n \n         fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n             match uint_ty {\n-                ast::TyUs(_) =>   (u64::MIN,         u64::MAX),\n-                ast::TyU8 =>  (u8::MIN   as u64, u8::MAX   as u64),\n-                ast::TyU16 => (u16::MIN  as u64, u16::MAX  as u64),\n-                ast::TyU32 => (u32::MIN  as u64, u32::MAX  as u64),\n-                ast::TyU64 => (u64::MIN,         u64::MAX)\n+                ast::TyUs(_) => (u64::MIN,         u64::MAX),\n+                ast::TyU8 =>    (u8::MIN   as u64, u8::MAX   as u64),\n+                ast::TyU16 =>   (u16::MIN  as u64, u16::MAX  as u64),\n+                ast::TyU32 =>   (u32::MIN  as u64, u32::MAX  as u64),\n+                ast::TyU64 =>   (u64::MIN,         u64::MAX)\n             }\n         }\n \n         fn float_ty_range(float_ty: ast::FloatTy) -> (f64, f64) {\n             match float_ty {\n-                ast::TyF32  => (f32::MIN as f64, f32::MAX as f64),\n-                ast::TyF64  => (f64::MIN,        f64::MAX)\n+                ast::TyF32 => (f32::MIN as f64, f32::MAX as f64),\n+                ast::TyF64 => (f64::MIN,        f64::MAX)\n             }\n         }\n \n         fn int_ty_bits(int_ty: ast::IntTy, target_int_ty: ast::IntTy) -> u64 {\n             match int_ty {\n-                ast::TyIs(_) =>    int_ty_bits(target_int_ty, target_int_ty),\n-                ast::TyI8 =>   i8::BITS  as u64,\n-                ast::TyI16 =>  i16::BITS as u64,\n-                ast::TyI32 =>  i32::BITS as u64,\n-                ast::TyI64 =>  i64::BITS as u64\n+                ast::TyIs(_) => int_ty_bits(target_int_ty, target_int_ty),\n+                ast::TyI8 =>    i8::BITS  as u64,\n+                ast::TyI16 =>   i16::BITS as u64,\n+                ast::TyI32 =>   i32::BITS as u64,\n+                ast::TyI64 =>   i64::BITS as u64\n             }\n         }\n \n         fn uint_ty_bits(uint_ty: ast::UintTy, target_uint_ty: ast::UintTy) -> u64 {\n             match uint_ty {\n-                ast::TyUs(_) =>    uint_ty_bits(target_uint_ty, target_uint_ty),\n-                ast::TyU8 =>   u8::BITS  as u64,\n-                ast::TyU16 =>  u16::BITS as u64,\n-                ast::TyU32 =>  u32::BITS as u64,\n-                ast::TyU64 =>  u64::BITS as u64\n+                ast::TyUs(_) => uint_ty_bits(target_uint_ty, target_uint_ty),\n+                ast::TyU8 =>    u8::BITS  as u64,\n+                ast::TyU16 =>   u16::BITS as u64,\n+                ast::TyU32 =>   u32::BITS as u64,\n+                ast::TyU64 =>   u64::BITS as u64\n             }\n         }\n \n@@ -360,7 +362,11 @@ impl LintPass for TypeLimits {\n             };\n             // Normalize the binop so that the literal is always on the RHS in\n             // the comparison\n-            let norm_binop = if swap { rev_binop(binop) } else { binop };\n+            let norm_binop = if swap {\n+                rev_binop(binop)\n+            } else {\n+                binop\n+            };\n             match ty::expr_ty(tcx, expr).sty {\n                 ty::ty_int(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n@@ -432,9 +438,9 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n \n                 if !ty::is_ffi_safe(self.cx.tcx, tty) {\n                     self.cx.span_lint(IMPROPER_CTYPES, sp,\n-                                      \"found type without foreign-function-safe\n-                                      representation annotation in foreign module, consider \\\n-                                      adding a #[repr(...)] attribute to the type\");\n+                                      \"found type without foreign-function-safe \\\n+                                       representation annotation in foreign module, consider \\\n+                                       adding a #[repr(...)] attribute to the type\");\n                 }\n             }\n             _ => ()\n@@ -595,15 +601,15 @@ impl LintPass for RawPointerDerive {\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n         if !attr::contains_name(&item.attrs, \"automatically_derived\") {\n-            return\n+            return;\n         }\n         let did = match item.node {\n             ast::ItemImpl(_, _, _, ref t_ref_opt, _, _) => {\n                 // Deriving the Copy trait does not cause a warning\n                 if let &Some(ref trait_ref) = t_ref_opt {\n                     let def_id = ty::trait_ref_to_def_id(cx.tcx, trait_ref);\n                     if Some(def_id) == cx.tcx.lang_items.copy_trait() {\n-                        return\n+                        return;\n                     }\n                 }\n \n@@ -615,12 +621,16 @@ impl LintPass for RawPointerDerive {\n             }\n             _ => return,\n         };\n-        if !ast_util::is_local(did) { return }\n+        if !ast_util::is_local(did) {\n+            return;\n+        }\n         let item = match cx.tcx.map.find(did.node) {\n             Some(ast_map::NodeItem(item)) => item,\n             _ => return,\n         };\n-        if !self.checked_raw_pointers.insert(item.id) { return }\n+        if !self.checked_raw_pointers.insert(item.id) {\n+            return;\n+        }\n         match item.node {\n             ast::ItemStruct(..) | ast::ItemEnum(..) => {\n                 let mut visitor = RawPtrDeriveVisitor { cx: cx };\n@@ -646,6 +656,7 @@ impl LintPass for UnusedAttributes {\n     }\n \n     fn check_attribute(&mut self, cx: &Context, attr: &ast::Attribute) {\n+        // Note that check_name() marks the attribute as used if it matches.\n         for &(ref name, ty) in KNOWN_ATTRIBUTES {\n             match ty {\n                 AttributeType::Whitelisted\n@@ -730,23 +741,24 @@ impl LintPass for UnusedResults {\n         }\n \n         let t = ty::expr_ty(cx.tcx, expr);\n-        let mut warned = false;\n-        match t.sty {\n+        let warned = match t.sty {\n             ty::ty_tup(ref tys) if tys.is_empty() => return,\n             ty::ty_bool => return,\n             ty::ty_struct(did, _) |\n             ty::ty_enum(did, _) => {\n                 if ast_util::is_local(did) {\n                     if let ast_map::NodeItem(it) = cx.tcx.map.get(did.node) {\n-                        warned |= check_must_use(cx, &it.attrs, s.span);\n+                        check_must_use(cx, &it.attrs, s.span)\n+                    } else {\n+                        false\n                     }\n                 } else {\n                     let attrs = csearch::get_item_attrs(&cx.sess().cstore, did);\n-                    warned |= check_must_use(cx, &attrs[..], s.span);\n+                    check_must_use(cx, &attrs[..], s.span)\n                 }\n             }\n-            _ => {}\n-        }\n+            _ => false,\n+        };\n         if !warned {\n             cx.span_lint(UNUSED_RESULTS, s.span, \"unused result\");\n         }\n@@ -785,7 +797,9 @@ impl NonCamelCaseTypes {\n     fn check_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_camel_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n-            if ident.is_empty() { return true; }\n+            if ident.is_empty() {\n+                return true;\n+            }\n             let ident = ident.trim_matches('_');\n \n             // start with a non-lowercase letter rather than non-uppercase\n@@ -795,8 +809,11 @@ impl NonCamelCaseTypes {\n \n         fn to_camel_case(s: &str) -> String {\n             s.split('_').flat_map(|word| word.chars().enumerate().map(|(i, c)|\n-                if i == 0 { c.to_uppercase() }\n-                else { c }\n+                if i == 0 {\n+                    c.to_uppercase()\n+                } else {\n+                    c\n+                }\n             )).collect()\n         }\n \n@@ -820,11 +837,13 @@ impl LintPass for NonCamelCaseTypes {\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        let has_extern_repr = it.attrs.iter().map(|attr| {\n+        let has_extern_repr = it.attrs.iter().any(|attr| {\n             attr::find_repr_attrs(cx.tcx.sess.diagnostic(), attr).iter()\n                 .any(|r| r == &attr::ReprExtern)\n-        }).any(|x| x);\n-        if has_extern_repr { return }\n+        });\n+        if has_extern_repr {\n+            return;\n+        }\n \n         match it.node {\n             ast::ItemTy(..) | ast::ItemStruct(..) => {\n@@ -834,7 +853,9 @@ impl LintPass for NonCamelCaseTypes {\n                 self.check_case(cx, \"trait\", it.ident, it.span)\n             }\n             ast::ItemEnum(ref enum_definition, _) => {\n-                if has_extern_repr { return }\n+                if has_extern_repr {\n+                    return;\n+                }\n                 self.check_case(cx, \"type\", it.ident, it.span);\n                 for variant in &enum_definition.variants {\n                     self.check_case(cx, \"variant\", variant.node.name, variant.span);\n@@ -866,32 +887,28 @@ fn method_context(cx: &Context, m: &ast::Method) -> MethodContext {\n \n     match cx.tcx.impl_or_trait_items.borrow().get(&did).cloned() {\n         None => cx.sess().span_bug(m.span, \"missing method descriptor?!\"),\n-        Some(md) => {\n-            match md {\n-                ty::MethodTraitItem(md) => {\n-                    match md.container {\n-                        ty::TraitContainer(..) => TraitDefaultImpl,\n-                        ty::ImplContainer(cid) => {\n-                            match ty::impl_trait_ref(cx.tcx, cid) {\n-                                Some(..) => TraitImpl,\n-                                None => PlainImpl\n-                            }\n-                        }\n+        Some(ty::MethodTraitItem(md)) => {\n+            match md.container {\n+                ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n+                ty::ImplContainer(cid) => {\n+                    match ty::impl_trait_ref(cx.tcx, cid) {\n+                        Some(..) => MethodContext::TraitImpl,\n+                        None => MethodContext::PlainImpl\n                     }\n                 }\n-                ty::TypeTraitItem(typedef) => {\n-                    match typedef.container {\n-                        ty::TraitContainer(..) => TraitDefaultImpl,\n-                        ty::ImplContainer(cid) => {\n-                            match ty::impl_trait_ref(cx.tcx, cid) {\n-                                Some(..) => TraitImpl,\n-                                None => PlainImpl\n-                            }\n-                        }\n+            }\n+        },\n+        Some(ty::TypeTraitItem(typedef)) => {\n+            match typedef.container {\n+                ty::TraitContainer(..) => MethodContext::TraitDefaultImpl,\n+                ty::ImplContainer(cid) => {\n+                    match ty::impl_trait_ref(cx.tcx, cid) {\n+                        Some(..) => MethodContext::TraitImpl,\n+                        None => MethodContext::PlainImpl\n                     }\n                 }\n             }\n-        }\n+        },\n     }\n }\n \n@@ -912,12 +929,16 @@ impl NonSnakeCase {\n             if c == '_' {\n                 words.push(String::new());\n                 true\n-            } else { false }\n+            } else {\n+                false\n+            }\n         });\n         for s in str.split('_') {\n             let mut last_upper = false;\n             let mut buf = String::new();\n-            if s.is_empty() { continue; }\n+            if s.is_empty() {\n+                continue;\n+            }\n             for ch in s.chars() {\n                 if !buf.is_empty() && buf != \"'\"\n                                    && ch.is_uppercase()\n@@ -936,7 +957,9 @@ impl NonSnakeCase {\n     fn check_snake_case(&self, cx: &Context, sort: &str, ident: ast::Ident, span: Span) {\n         fn is_snake_case(ident: ast::Ident) -> bool {\n             let ident = token::get_ident(ident);\n-            if ident.is_empty() { return true; }\n+            if ident.is_empty() {\n+                return true;\n+            }\n             let ident = ident.trim_left_matches('\\'');\n             let ident = ident.trim_matches('_');\n \n@@ -979,14 +1002,17 @@ impl LintPass for NonSnakeCase {\n                 _: &ast::Block, span: Span, _: ast::NodeId) {\n         match fk {\n             visit::FkMethod(ident, _, m) => match method_context(cx, m) {\n-                PlainImpl\n-                    => self.check_snake_case(cx, \"method\", ident, span),\n-                TraitDefaultImpl\n-                    => self.check_snake_case(cx, \"trait method\", ident, span),\n+                MethodContext::PlainImpl => {\n+                    self.check_snake_case(cx, \"method\", ident, span)\n+                },\n+                MethodContext::TraitDefaultImpl => {\n+                    self.check_snake_case(cx, \"trait method\", ident, span)\n+                },\n                 _ => (),\n             },\n-            visit::FkItemFn(ident, _, _, _)\n-                => self.check_snake_case(cx, \"function\", ident, span),\n+            visit::FkItemFn(ident, _, _, _) => {\n+                self.check_snake_case(cx, \"function\", ident, span)\n+            },\n             _ => (),\n         }\n     }\n@@ -1015,7 +1041,7 @@ impl LintPass for NonSnakeCase {\n     }\n \n     fn check_struct_def(&mut self, cx: &Context, s: &ast::StructDef,\n-            _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n+                        _: ast::Ident, _: &ast::Generics, _: ast::NodeId) {\n         for sf in &s.fields {\n             if let ast::StructField_ { kind: ast::NamedField(ident, _), .. } = sf.node {\n                 self.check_snake_case(cx, \"structure field\", ident, sf.span);\n@@ -1094,13 +1120,12 @@ pub struct UnusedParens;\n \n impl UnusedParens {\n     fn check_unused_parens_core(&self, cx: &Context, value: &ast::Expr, msg: &str,\n-                                     struct_lit_needs_parens: bool) {\n+                                struct_lit_needs_parens: bool) {\n         if let ast::ExprParen(ref inner) = value.node {\n             let necessary = struct_lit_needs_parens && contains_exterior_struct_lit(&**inner);\n             if !necessary {\n                 cx.span_lint(UNUSED_PARENS, value.span,\n-                             &format!(\"unnecessary parentheses around {}\",\n-                                     msg))\n+                             &format!(\"unnecessary parentheses around {}\", msg))\n             }\n         }\n \n@@ -1193,26 +1218,17 @@ impl LintPass for UnusedImportBraces {\n     }\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n-        match item.node {\n-            ast::ItemUse(ref view_path) => {\n-                match view_path.node {\n-                    ast::ViewPathList(_, ref items) => {\n-                        if items.len() == 1 {\n-                            match items[0].node {\n-                                ast::PathListIdent {ref name, ..} => {\n-                                    let m = format!(\"braces around {} is unnecessary\",\n-                                                    &token::get_ident(*name));\n-                                    cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n-                                                 &m[..]);\n-                                },\n-                                _ => ()\n-                            }\n-                        }\n+        if let ast::ItemUse(ref view_path) = item.node {\n+            if let ast::ViewPathList(_, ref items) = view_path.node {\n+                if items.len() == 1 {\n+                    if let ast::PathListIdent {ref name, ..} = items[0].node {\n+                        let m = format!(\"braces around {} is unnecessary\",\n+                                        &token::get_ident(*name));\n+                        cx.span_lint(UNUSED_IMPORT_BRACES, item.span,\n+                                     &m[..]);\n                     }\n-                    _ => ()\n                 }\n-            },\n-            _ => ()\n+            }\n         }\n     }\n }\n@@ -1234,9 +1250,10 @@ impl LintPass for NonShorthandFieldPatterns {\n     fn check_pat(&mut self, cx: &Context, pat: &ast::Pat) {\n         let def_map = cx.tcx.def_map.borrow();\n         if let ast::PatStruct(_, ref v, _) = pat.node {\n-            let field_pats = v.iter()\n-                              .filter(|fieldpat| !fieldpat.node.is_shorthand)\n-                              .filter(|fieldpat| {\n+            let field_pats = v.iter().filter(|fieldpat| {\n+                if fieldpat.node.is_shorthand {\n+                    return false;\n+                }\n                 let def = def_map.get(&fieldpat.node.pat.id).map(|d| d.full_def());\n                 def == Some(def::DefLocal(fieldpat.node.pat.id))\n             });\n@@ -1482,10 +1499,14 @@ impl MissingDoc {\n                                desc: &'static str) {\n         // If we're building a test harness, then warning about\n         // documentation is probably not really relevant right now.\n-        if cx.sess().opts.test { return }\n+        if cx.sess().opts.test {\n+            return;\n+        }\n \n         // `#[doc(hidden)]` disables missing_docs check.\n-        if self.doc_hidden() { return }\n+        if self.doc_hidden() {\n+            return;\n+        }\n \n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n@@ -1504,7 +1525,7 @@ impl MissingDoc {\n         });\n         if !has_doc {\n             cx.span_lint(MISSING_DOCS, sp,\n-                &format!(\"missing documentation for {}\", desc));\n+                         &format!(\"missing documentation for {}\", desc));\n         }\n     }\n }\n@@ -1528,20 +1549,19 @@ impl LintPass for MissingDoc {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_struct_def(&mut self, _: &Context,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+    fn check_struct_def(&mut self, _: &Context, _: &ast::StructDef,\n+                        _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n         self.struct_def_stack.push(id);\n     }\n \n-    fn check_struct_def_post(&mut self, _: &Context,\n-        _: &ast::StructDef, _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n+    fn check_struct_def_post(&mut self, _: &Context, _: &ast::StructDef,\n+                             _: ast::Ident, _: &ast::Generics, id: ast::NodeId) {\n         let popped = self.struct_def_stack.pop().expect(\"empty struct_def_stack\");\n         assert!(popped == id);\n     }\n \n     fn check_crate(&mut self, cx: &Context, krate: &ast::Crate) {\n-        self.check_missing_docs_attrs(cx, None, &krate.attrs,\n-                                     krate.span, \"crate\");\n+        self.check_missing_docs_attrs(cx, None, &krate.attrs, krate.span, \"crate\");\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n@@ -1554,27 +1574,25 @@ impl LintPass for MissingDoc {\n             ast::ItemTy(..) => \"a type alias\",\n             _ => return\n         };\n-        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs,\n-                                     it.span, desc);\n+        self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_fn(&mut self, cx: &Context,\n-            fk: visit::FnKind, _: &ast::FnDecl,\n-            _: &ast::Block, _: Span, _: ast::NodeId) {\n+    fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n+                _: &ast::Block, _: Span, _: ast::NodeId) {\n         if let visit::FkMethod(_, _, m) = fk {\n             // If the method is an impl for a trait, don't doc.\n-            if method_context(cx, m) == TraitImpl { return; }\n+            if method_context(cx, m) == MethodContext::TraitImpl {\n+                return;\n+            }\n \n             // Otherwise, doc according to privacy. This will also check\n             // doc for default methods defined on traits.\n-            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs,\n-                                          m.span, \"a method\");\n+            self.check_missing_docs_attrs(cx, Some(m.id), &m.attrs, m.span, \"a method\");\n         }\n     }\n \n     fn check_ty_method(&mut self, cx: &Context, tm: &ast::TypeMethod) {\n-        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs,\n-                                     tm.span, \"a type method\");\n+        self.check_missing_docs_attrs(cx, Some(tm.id), &tm.attrs, tm.span, \"a type method\");\n     }\n \n     fn check_trait_item(&mut self, cx: &Context, it: &ast::TraitItem) {\n@@ -1598,8 +1616,7 @@ impl LintPass for MissingDoc {\n     }\n \n     fn check_variant(&mut self, cx: &Context, v: &ast::Variant, _: &ast::Generics) {\n-        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs,\n-                                     v.span, \"a variant\");\n+        self.check_missing_docs_attrs(cx, Some(v.node.id), &v.node.attrs, v.span, \"a variant\");\n         assert!(!self.in_variant);\n         self.in_variant = true;\n     }\n@@ -1626,26 +1643,26 @@ impl LintPass for MissingCopyImplementations {\n \n     fn check_item(&mut self, cx: &Context, item: &ast::Item) {\n         if !cx.exported_items.contains(&item.id) {\n-            return\n+            return;\n         }\n         if cx.tcx\n              .destructor_for_type\n              .borrow()\n              .contains_key(&ast_util::local_def(item.id)) {\n-            return\n+            return;\n         }\n         let ty = match item.node {\n             ast::ItemStruct(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n-                    return\n+                    return;\n                 }\n                 ty::mk_struct(cx.tcx,\n                               ast_util::local_def(item.id),\n                               cx.tcx.mk_substs(Substs::empty()))\n             }\n             ast::ItemEnum(_, ref ast_generics) => {\n                 if ast_generics.is_parameterized() {\n-                    return\n+                    return;\n                 }\n                 ty::mk_enum(cx.tcx,\n                             ast_util::local_def(item.id),\n@@ -1655,7 +1672,7 @@ impl LintPass for MissingCopyImplementations {\n         };\n         let parameter_environment = ty::empty_parameter_environment(cx.tcx);\n         if !ty::type_moves_by_default(&parameter_environment, item.span, ty) {\n-            return\n+            return;\n         }\n         if ty::can_type_implement_copy(&parameter_environment, item.span, ty).is_ok() {\n             cx.span_lint(MISSING_COPY_IMPLEMENTATIONS,\n@@ -1709,10 +1726,10 @@ impl LintPass for MissingDebugImplementations {\n             let impls = match impls.get(&debug) {\n                 Some(impls) => {\n                     impls.borrow().iter()\n-                        .filter(|d| d.krate == ast::LOCAL_CRATE)\n-                        .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n-                        .map(|d| d.node)\n-                        .collect()\n+                         .filter(|d| d.krate == ast::LOCAL_CRATE)\n+                         .filter_map(|d| ty::ty_to_def_id(ty::node_id_to_type(cx.tcx, d.node)))\n+                         .map(|d| d.node)\n+                         .collect()\n                 }\n                 None => NodeSet(),\n             };\n@@ -1741,8 +1758,7 @@ pub struct Stability;\n \n impl Stability {\n     fn lint(&self, cx: &Context, _id: ast::DefId, span: Span, stability: &Option<attr::Stability>) {\n-\n-        // deprecated attributes apply in-crate and cross-crate\n+        // Deprecated attributes apply in-crate and cross-crate.\n         let (lint, label) = match *stability {\n             Some(attr::Stability { deprecated_since: Some(_), .. }) =>\n                 (DEPRECATED, \"deprecated\"),\n@@ -1857,25 +1873,27 @@ impl LintPass for UnconditionalRecursion {\n         let mut visited = BitSet::new();\n \n         while let Some(idx) = work_queue.pop() {\n-            let cfg_id = idx.node_id();\n             if idx == cfg.exit {\n                 // found a path!\n                 reached_exit_without_self_call = true;\n-                break\n-            } else if visited.contains(&cfg_id) {\n+                break;\n+            }\n+\n+            let cfg_id = idx.node_id();\n+            if visited.contains(&cfg_id) {\n                 // already done\n-                continue\n+                continue;\n             }\n             visited.insert(cfg_id);\n+\n             let node_id = cfg.graph.node_data(idx).id();\n \n             // is this a recursive call?\n             if node_id != ast::DUMMY_NODE_ID && checker(cx.tcx, impl_node_id, id, name, node_id) {\n-\n                 self_call_spans.push(cx.tcx.map.span(node_id));\n                 // this is a self call, so we shouldn't explore past\n                 // this node in the CFG.\n-                continue\n+                continue;\n             }\n             // add the successors of this node to explore the graph further.\n             cfg.graph.each_outgoing_edge(idx, |_, edge| {\n@@ -1888,7 +1906,7 @@ impl LintPass for UnconditionalRecursion {\n             });\n         }\n \n-        // check the number of sell calls because a function that\n+        // Check the number of self calls because a function that\n         // doesn't return (e.g. calls a `-> !` function or `loop { /*\n         // no break */ }`) shouldn't be linted unless it actually\n         // recurs.\n@@ -1920,7 +1938,7 @@ impl LintPass for UnconditionalRecursion {\n                                       _: ast::Ident,\n                                       id: ast::NodeId) -> bool {\n             tcx.def_map.borrow().get(&id)\n-                .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n+               .map_or(false, |def| def.def_id() == ast_util::local_def(fn_id))\n         }\n \n         // check if the method call `id` refers to method `method_id`\n@@ -1962,7 +1980,7 @@ impl LintPass for UnconditionalRecursion {\n                                 tcx.map.span(id),\n                                 \"non-method call expr behaving like a method call?\")\n                         };\n-                        // it matches if it comes from the same impl,\n+                        // It matches if it comes from the same impl,\n                         // and has the same method name.\n                         return ast_util::is_local(impl_def_id)\n                             && impl_def_id.node == impl_id\n@@ -2013,7 +2031,7 @@ impl LintPass for PluginAsLibrary {\n \n         if decoder::get_plugin_registrar_fn(md.data()).is_some() {\n             cx.span_lint(PLUGIN_AS_LIBRARY, it.span,\n-                \"compiler plugin used as an ordinary library\");\n+                         \"compiler plugin used as an ordinary library\");\n         }\n     }\n }\n@@ -2069,7 +2087,7 @@ impl LintPass for InvalidNoMangleItems {\n                     // Const items do not refer to a particular location in memory, and therefore\n                     // don't have anything to attach a symbol to\n                     let msg = \"const items should never be #[no_mangle], consider instead using \\\n-                        `pub static`\";\n+                               `pub static`\";\n                     cx.span_lint(NO_MANGLE_CONST_ITEMS, it.span, msg);\n                 }\n             }\n@@ -2082,15 +2100,17 @@ impl LintPass for InvalidNoMangleItems {\n #[derive(Copy)]\n pub struct UnstableFeatures;\n \n-declare_lint!(UNSTABLE_FEATURES, Allow,\n-              \"enabling unstable features\");\n+declare_lint! {\n+    UNSTABLE_FEATURES,\n+    Allow,\n+    \"enabling unstable features\"\n+}\n \n impl LintPass for UnstableFeatures {\n     fn get_lints(&self) -> LintArray {\n         lint_array!(UNSTABLE_FEATURES)\n     }\n     fn check_attribute(&mut self, ctx: &Context, attr: &ast::Attribute) {\n-        use syntax::attr;\n         if attr::contains_name(&[attr.node.value.clone()], \"feature\") {\n             ctx.span_lint(UNSTABLE_FEATURES, attr.span, \"unstable feature\");\n         }"}]}