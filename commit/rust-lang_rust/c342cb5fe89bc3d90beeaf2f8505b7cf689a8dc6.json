{"sha": "c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMzNDJjYjVmZTg5YmMzZDkwYmVlYWYyZjg1MDViN2NmNjg5YThkYzY=", "commit": {"author": {"name": "Scott Olson", "email": "scott@solson.me", "date": "2017-02-10T08:03:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-02-10T08:03:14Z"}, "message": "Merge pull request #136 from oli-obk/master\n\nrefactor drop glue and fix Box<Box<Struct>> as Box<Trait>", "tree": {"sha": "ec264302647aa4bcdfc8f2a694b94367fa8205ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ec264302647aa4bcdfc8f2a694b94367fa8205ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "html_url": "https://github.com/rust-lang/rust/commit/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/comments", "author": {"login": "solson", "id": 26806, "node_id": "MDQ6VXNlcjI2ODA2", "avatar_url": "https://avatars.githubusercontent.com/u/26806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/solson", "html_url": "https://github.com/solson", "followers_url": "https://api.github.com/users/solson/followers", "following_url": "https://api.github.com/users/solson/following{/other_user}", "gists_url": "https://api.github.com/users/solson/gists{/gist_id}", "starred_url": "https://api.github.com/users/solson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/solson/subscriptions", "organizations_url": "https://api.github.com/users/solson/orgs", "repos_url": "https://api.github.com/users/solson/repos", "events_url": "https://api.github.com/users/solson/events{/privacy}", "received_events_url": "https://api.github.com/users/solson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6e9e7af8e78de03604eaf22de195542c52f17d88", "url": "https://api.github.com/repos/rust-lang/rust/commits/6e9e7af8e78de03604eaf22de195542c52f17d88", "html_url": "https://github.com/rust-lang/rust/commit/6e9e7af8e78de03604eaf22de195542c52f17d88"}, {"sha": "333264c956cc4d2d821b8707abc5657a0f1e1369", "url": "https://api.github.com/repos/rust-lang/rust/commits/333264c956cc4d2d821b8707abc5657a0f1e1369", "html_url": "https://github.com/rust-lang/rust/commit/333264c956cc4d2d821b8707abc5657a0f1e1369"}], "stats": {"total": 574, "additions": 334, "deletions": 240}, "files": [{"sha": "835c7bca7f60f155350070382478b1fb1b25f378", "filename": "src/memory.rs", "status": "modified", "additions": 11, "deletions": 16, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/src%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/src%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmemory.rs?ref=c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "patch": "@@ -120,9 +120,11 @@ pub enum Function<'tcx> {\n     Concrete(FunctionDefinition<'tcx>),\n     /// Glue required to call a regular function through a Fn(Mut|Once) trait object\n     FnDefAsTraitObject(FunctionDefinition<'tcx>),\n-    /// Glue required to call the actual drop impl's `drop` method.\n-    /// Drop glue takes the `self` by value, while `Drop::drop` take `&mut self`\n-    DropGlue(FunctionDefinition<'tcx>),\n+    /// A drop glue function only needs to know the real type, and then miri can extract\n+    /// that type from a vtable's drop pointer.\n+    /// Instead of storing some drop function, we act as if there are no trait objects, by\n+    /// mapping trait objects to their real types before acting on them.\n+    DropGlue(ty::Ty<'tcx>),\n     /// Glue required to treat the ptr part of a fat pointer\n     /// as a function pointer\n     FnPtrAsTraitObject(&'tcx ty::FnSig<'tcx>),\n@@ -137,9 +139,9 @@ impl<'tcx> Function<'tcx> {\n             other => Err(EvalError::ExpectedConcreteFunction(other)),\n         }\n     }\n-    pub fn expect_drop_glue(self) -> EvalResult<'tcx, FunctionDefinition<'tcx>> {\n+    pub fn expect_drop_glue_real_ty(self) -> EvalResult<'tcx, ty::Ty<'tcx>> {\n         match self {\n-            Function::DropGlue(fn_def) => Ok(fn_def),\n+            Function::DropGlue(real_ty) => Ok(real_ty),\n             other => Err(EvalError::ExpectedDropGlue(other)),\n         }\n     }\n@@ -234,15 +236,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n         self.create_fn_alloc(Function::FnPtrAsTraitObject(fn_ty.sig.skip_binder()))\n     }\n \n-    pub fn create_drop_glue(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n-        self.create_fn_alloc(Function::DropGlue(FunctionDefinition {\n-            def_id,\n-            substs,\n-            abi: fn_ty.abi,\n-            // FIXME: why doesn't this compile?\n-            //sig: tcx.erase_late_bound_regions(&fn_ty.sig),\n-            sig: fn_ty.sig.skip_binder(),\n-        }))\n+    pub fn create_drop_glue(&mut self, ty: ty::Ty<'tcx>) -> Pointer {\n+        self.create_fn_alloc(Function::DropGlue(ty))\n     }\n \n     pub fn create_fn_ptr(&mut self, _tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId, substs: &'tcx Substs<'tcx>, fn_ty: &'tcx BareFnTy<'tcx>) -> Pointer {\n@@ -495,8 +490,8 @@ impl<'a, 'tcx> Memory<'a, 'tcx> {\n                     trace!(\"{} {}\", msg, dump_fn_def(fn_def));\n                     continue;\n                 },\n-                (None, Some(&Function::DropGlue(fn_def))) => {\n-                    trace!(\"{} drop glue for {}\", msg, dump_fn_def(fn_def));\n+                (None, Some(&Function::DropGlue(real_ty))) => {\n+                    trace!(\"{} drop glue for {}\", msg, real_ty);\n                     continue;\n                 },\n                 (None, Some(&Function::FnDefAsTraitObject(fn_def))) => {"}, {"sha": "cb971eca29c7ddeb3fbff187a426183ddb1bd550", "filename": "src/terminator/drop.rs", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/rust-lang/rust/blob/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/src%2Fterminator%2Fdrop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/src%2Fterminator%2Fdrop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fdrop.rs?ref=c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "patch": "@@ -0,0 +1,236 @@\n+use rustc::hir::def_id::DefId;\n+use rustc::ty::layout::Layout;\n+use rustc::ty::subst::{Substs, Kind};\n+use rustc::ty::{self, Ty};\n+use rustc::mir;\n+use syntax::codemap::Span;\n+\n+use error::{EvalError, EvalResult};\n+use eval_context::{EvalContext, monomorphize_field_ty, StackPopCleanup};\n+use lvalue::{Lvalue, LvalueExtra};\n+use memory::Pointer;\n+use value::PrimVal;\n+use value::Value;\n+\n+impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n+\n+    /// Creates stack frames for all drop impls. See `drop` for the actual content.\n+    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx> {\n+        // add them to the stack in reverse order, because the impl that needs to run the last\n+        // is the one that needs to be at the bottom of the stack\n+        for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n+            let mir = self.load_mir(drop_def_id)?;\n+            trace!(\"substs for drop glue: {:?}\", substs);\n+            self.push_stack_frame(\n+                drop_def_id,\n+                span,\n+                mir,\n+                substs,\n+                Lvalue::from_ptr(Pointer::zst_ptr()),\n+                StackPopCleanup::None,\n+                Vec::new(),\n+            )?;\n+            let mut arg_locals = self.frame().mir.args_iter();\n+            let first = arg_locals.next().expect(\"drop impl has self arg\");\n+            assert!(arg_locals.next().is_none(), \"drop impl should have only one arg\");\n+            let dest = self.eval_lvalue(&mir::Lvalue::Local(first))?;\n+            let ty = self.frame().mir.local_decls[first].ty;\n+            self.write_value(self_arg, dest, ty)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// push DefIds of drop impls and their argument on the given vector\n+    pub fn drop(\n+        &mut self,\n+        lval: Lvalue<'tcx>,\n+        ty: Ty<'tcx>,\n+        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n+    ) -> EvalResult<'tcx> {\n+        if !self.type_needs_drop(ty) {\n+            debug!(\"no need to drop {:?}\", ty);\n+            return Ok(());\n+        }\n+        trace!(\"-need to drop {:?} at {:?}\", ty, lval);\n+\n+        match ty.sty {\n+            // special case `Box` to deallocate the inner allocation\n+            ty::TyAdt(ref def, _) if def.is_box() => {\n+                let contents_ty = ty.boxed_ty();\n+                let val = self.read_lvalue(lval);\n+                // we are going through the read_value path, because that already does all the\n+                // checks for the trait object types. We'd only be repeating ourselves here.\n+                let val = self.follow_by_ref_value(val, ty)?;\n+                trace!(\"box dealloc on {:?}\", val);\n+                match val {\n+                    Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n+                    Value::ByVal(ptr) => {\n+                        assert!(self.type_is_sized(contents_ty));\n+                        let contents_ptr = ptr.to_ptr()?;\n+                        self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n+                    },\n+                    Value::ByValPair(prim_ptr, extra) => {\n+                        let ptr = prim_ptr.to_ptr()?;\n+                        let extra = match self.tcx.struct_tail(contents_ty).sty {\n+                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n+                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n+                            _ => bug!(\"invalid fat pointer type: {}\", ty),\n+                        };\n+                        self.drop(Lvalue::Ptr { ptr, extra }, contents_ty, drop)?;\n+                    },\n+                }\n+                // We cannot use Box's destructor, because it is a no-op and only exists to reduce\n+                // the number of hacks required in the compiler around the Box type.\n+                let box_free_fn = self.tcx.lang_items.box_free_fn().expect(\"no box_free lang item\");\n+                let substs = self.tcx.intern_substs(&[Kind::from(contents_ty)]);\n+                // this is somewhat hacky, but hey, there's no representation difference between\n+                // pointers, `Box`es and references, so\n+                // #[lang = \"box_free\"] unsafe fn box_free<T>(ptr: *mut T)\n+                // is the same as\n+                // fn drop(&mut self) if Self is Box<T>\n+                drop.push((box_free_fn, val, substs));\n+            },\n+\n+            ty::TyAdt(adt_def, substs) => {\n+                // FIXME: some structs are represented as ByValPair\n+                let lval = self.force_allocation(lval)?;\n+                let adt_ptr = match lval {\n+                    Lvalue::Ptr { ptr, .. } => ptr,\n+                    _ => bug!(\"force allocation can only yield Lvalue::Ptr\"),\n+                };\n+                // run drop impl before the fields' drop impls\n+                if let Some(drop_def_id) = adt_def.destructor() {\n+                    drop.push((drop_def_id, Value::ByVal(PrimVal::Ptr(adt_ptr)), substs));\n+                }\n+                let layout = self.type_layout(ty)?;\n+                let fields = match *layout {\n+                    Layout::Univariant { ref variant, .. } => {\n+                        adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n+                    },\n+                    Layout::General { ref variants, .. } => {\n+                        let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n+                        match adt_def.variants.iter().position(|v| discr_val == v.disr_val.to_u128_unchecked()) {\n+                            // start at offset 1, to skip over the discriminant\n+                            Some(i) => adt_def.variants[i].fields.iter().zip(&variants[i].offsets[1..]),\n+                            None => return Err(EvalError::InvalidDiscriminant),\n+                        }\n+                    },\n+                    Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n+                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n+                        if discr == nndiscr as u128 {\n+                            assert_eq!(discr as usize as u128, discr);\n+                            adt_def.variants[discr as usize].fields.iter().zip(&nonnull.offsets)\n+                        } else {\n+                            // FIXME: the zst variant might contain zst types that impl Drop\n+                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n+                        }\n+                    },\n+                    Layout::RawNullablePointer { nndiscr, .. } => {\n+                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n+                        if discr == nndiscr as u128 {\n+                            assert_eq!(discr as usize as u128, discr);\n+                            assert_eq!(adt_def.variants[discr as usize].fields.len(), 1);\n+                            let field_ty = &adt_def.variants[discr as usize].fields[0];\n+                            let field_ty = monomorphize_field_ty(self.tcx, field_ty, substs);\n+                            // FIXME: once read_discriminant_value works with lvalue, don't force\n+                            // alloc in the RawNullablePointer case\n+                            self.drop(lval, field_ty, drop)?;\n+                            return Ok(());\n+                        } else {\n+                            // FIXME: the zst variant might contain zst types that impl Drop\n+                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n+                        }\n+                    },\n+                    Layout::CEnum { .. } => return Ok(()),\n+                    _ => bug!(\"{:?} is not an adt layout\", layout),\n+                };\n+                let tcx = self.tcx;\n+                self.drop_fields(\n+                    fields.map(|(ty, &offset)| (monomorphize_field_ty(tcx, ty, substs), offset)),\n+                    lval,\n+                    drop,\n+                )?;\n+            },\n+            ty::TyTuple(fields, _) => {\n+                let offsets = match *self.type_layout(ty)? {\n+                    Layout::Univariant { ref variant, .. } => &variant.offsets,\n+                    _ => bug!(\"tuples must be univariant\"),\n+                };\n+                self.drop_fields(fields.iter().cloned().zip(offsets.iter().cloned()), lval, drop)?;\n+            },\n+            ty::TyDynamic(..) => {\n+                let (ptr, vtable) = match lval {\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n+                    _ => bug!(\"expected an lvalue with a vtable\"),\n+                };\n+                let drop_fn = self.memory.read_ptr(vtable)?;\n+                // some values don't need to call a drop impl, so the value is null\n+                if drop_fn != Pointer::from_int(0) {\n+                    let real_ty = self.memory.get_fn(drop_fn.alloc_id)?.expect_drop_glue_real_ty()?;\n+                    self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n+                } else {\n+                    // just a sanity check\n+                    assert_eq!(drop_fn.offset, 0);\n+                }\n+            },\n+            ty::TySlice(elem_ty) => {\n+                let (ptr, len) = match lval {\n+                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len),\n+                    _ => bug!(\"expected an lvalue with a length\"),\n+                };\n+                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n+                // FIXME: this creates a lot of stack frames if the element type has\n+                // a drop impl\n+                for i in 0..len {\n+                    self.drop(Lvalue::from_ptr(ptr.offset(i * size)), elem_ty, drop)?;\n+                }\n+            },\n+            ty::TyArray(elem_ty, len) => {\n+                let lval = self.force_allocation(lval)?;\n+                let (ptr, extra) = match lval {\n+                    Lvalue::Ptr { ptr, extra } => (ptr, extra),\n+                    _ => bug!(\"expected an lvalue with optional extra data\"),\n+                };\n+                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\");\n+                // FIXME: this creates a lot of stack frames if the element type has\n+                // a drop impl\n+                for i in 0..(len as u64) {\n+                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i * size), extra }, elem_ty, drop)?;\n+                }\n+            },\n+            // FIXME: what about TyClosure and TyAnon?\n+            // other types do not need to process drop\n+            _ => {},\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn drop_fields<I>(\n+        &mut self,\n+        mut fields: I,\n+        lval: Lvalue<'tcx>,\n+        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n+    ) -> EvalResult<'tcx>\n+        where I: Iterator<Item = (Ty<'tcx>, ty::layout::Size)>,\n+    {\n+        // FIXME: some aggregates may be represented by Value::ByValPair\n+        let (adt_ptr, extra) = self.force_allocation(lval)?.to_ptr_and_extra();\n+        // manual iteration, because we need to be careful about the last field if it is unsized\n+        while let Some((field_ty, offset)) = fields.next() {\n+            let ptr = adt_ptr.offset(offset.bytes());\n+            if self.type_is_sized(field_ty) {\n+                self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n+            } else {\n+                self.drop(Lvalue::Ptr { ptr, extra }, field_ty, drop)?;\n+                break; // if it is not sized, then this is the last field anyway\n+            }\n+        }\n+        assert!(fields.next().is_none());\n+        Ok(())\n+    }\n+\n+    fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n+        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n+    }\n+}"}, {"sha": "e6ed715280e0a35bb03e5d7644a1456beacc5ec0", "filename": "src/terminator/mod.rs", "status": "modified", "additions": 4, "deletions": 222, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/src%2Fterminator%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/src%2Fterminator%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fterminator%2Fmod.rs?ref=c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "patch": "@@ -3,19 +3,20 @@ use rustc::mir;\n use rustc::traits::{self, Reveal};\n use rustc::ty::fold::TypeFoldable;\n use rustc::ty::layout::{Layout, Size};\n-use rustc::ty::subst::{Substs, Kind};\n+use rustc::ty::subst::Substs;\n use rustc::ty::{self, Ty, TyCtxt, BareFnTy};\n use syntax::codemap::{DUMMY_SP, Span};\n use syntax::{ast, attr, abi};\n \n use error::{EvalError, EvalResult};\n-use eval_context::{EvalContext, IntegerExt, StackPopCleanup, monomorphize_field_ty, is_inhabited};\n-use lvalue::{Lvalue, LvalueExtra};\n+use eval_context::{EvalContext, IntegerExt, StackPopCleanup, is_inhabited};\n+use lvalue::Lvalue;\n use memory::{Pointer, FunctionDefinition, Function};\n use value::PrimVal;\n use value::Value;\n \n mod intrinsic;\n+mod drop;\n \n impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n \n@@ -161,31 +162,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         Ok(())\n     }\n \n-    pub fn eval_drop_impls(&mut self, drops: Vec<(DefId, Value, &'tcx Substs<'tcx>)>, span: Span) -> EvalResult<'tcx> {\n-        // add them to the stack in reverse order, because the impl that needs to run the last\n-        // is the one that needs to be at the bottom of the stack\n-        for (drop_def_id, self_arg, substs) in drops.into_iter().rev() {\n-            let mir = self.load_mir(drop_def_id)?;\n-            trace!(\"substs for drop glue: {:?}\", substs);\n-            self.push_stack_frame(\n-                drop_def_id,\n-                span,\n-                mir,\n-                substs,\n-                Lvalue::from_ptr(Pointer::zst_ptr()),\n-                StackPopCleanup::None,\n-                Vec::new(),\n-            )?;\n-            let mut arg_locals = self.frame().mir.args_iter();\n-            let first = arg_locals.next().expect(\"drop impl has self arg\");\n-            assert!(arg_locals.next().is_none(), \"drop impl should have only one arg\");\n-            let dest = self.eval_lvalue(&mir::Lvalue::Local(first))?;\n-            let ty = self.frame().mir.local_decls[first].ty;\n-            self.write_value(self_arg, dest, ty)?;\n-        }\n-        Ok(())\n-    }\n-\n     fn eval_fn_call(\n         &mut self,\n         def_id: DefId,\n@@ -699,200 +675,6 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n             vtable => bug!(\"resolved vtable bad vtable {:?} in trans\", vtable),\n         }\n     }\n-\n-    pub(super) fn type_needs_drop(&self, ty: Ty<'tcx>) -> bool {\n-        self.tcx.type_needs_drop_given_env(ty, &self.tcx.empty_parameter_environment())\n-    }\n-\n-    /// push DefIds of drop impls and their argument on the given vector\n-    pub fn drop(\n-        &mut self,\n-        lval: Lvalue<'tcx>,\n-        ty: Ty<'tcx>,\n-        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx> {\n-        if !self.type_needs_drop(ty) {\n-            debug!(\"no need to drop {:?}\", ty);\n-            return Ok(());\n-        }\n-        trace!(\"-need to drop {:?} at {:?}\", ty, lval);\n-\n-        match ty.sty {\n-            // special case `Box` to deallocate the inner allocation\n-            ty::TyAdt(ref def, _) if def.is_box() => {\n-                let contents_ty = ty.boxed_ty();\n-                let val = self.read_lvalue(lval);\n-                // we are going through the read_value path, because that already does all the\n-                // checks for the trait object types. We'd only be repeating ourselves here.\n-                let val = self.follow_by_ref_value(val, ty)?;\n-                trace!(\"box dealloc on {:?}\", val);\n-                match val {\n-                    Value::ByRef(_) => bug!(\"follow_by_ref_value can't result in ByRef\"),\n-                    Value::ByVal(ptr) => {\n-                        assert!(self.type_is_sized(contents_ty));\n-                        let contents_ptr = ptr.to_ptr()?;\n-                        self.drop(Lvalue::from_ptr(contents_ptr), contents_ty, drop)?;\n-                    },\n-                    Value::ByValPair(prim_ptr, extra) => {\n-                        let ptr = prim_ptr.to_ptr()?;\n-                        let extra = match self.tcx.struct_tail(contents_ty).sty {\n-                            ty::TyDynamic(..) => LvalueExtra::Vtable(extra.to_ptr()?),\n-                            ty::TyStr | ty::TySlice(_) => LvalueExtra::Length(extra.to_u64()?),\n-                            _ => bug!(\"invalid fat pointer type: {}\", ty),\n-                        };\n-                        self.drop(Lvalue::Ptr { ptr, extra }, contents_ty, drop)?;\n-                    },\n-                }\n-                let box_free_fn = self.tcx.lang_items.box_free_fn().expect(\"no box_free lang item\");\n-                let substs = self.tcx.intern_substs(&[Kind::from(contents_ty)]);\n-                // this is somewhat hacky, but hey, there's no representation difference between\n-                // pointers and references, so\n-                // #[lang = \"box_free\"] unsafe fn box_free<T>(ptr: *mut T)\n-                // is the same as\n-                // fn drop(&mut self) if Self is Box<T>\n-                drop.push((box_free_fn, val, substs));\n-            },\n-\n-            ty::TyAdt(adt_def, substs) => {\n-                // FIXME: some structs are represented as ByValPair\n-                let lval = self.force_allocation(lval)?;\n-                let adt_ptr = match lval {\n-                    Lvalue::Ptr { ptr, .. } => ptr,\n-                    _ => bug!(\"force allocation can only yield Lvalue::Ptr\"),\n-                };\n-                // run drop impl before the fields' drop impls\n-                if let Some(drop_def_id) = adt_def.destructor() {\n-                    drop.push((drop_def_id, Value::ByVal(PrimVal::Ptr(adt_ptr)), substs));\n-                }\n-                let layout = self.type_layout(ty)?;\n-                let fields = match *layout {\n-                    Layout::Univariant { ref variant, .. } => {\n-                        adt_def.struct_variant().fields.iter().zip(&variant.offsets)\n-                    },\n-                    Layout::General { ref variants, .. } => {\n-                        let discr_val = self.read_discriminant_value(adt_ptr, ty)? as u128;\n-                        match adt_def.variants.iter().position(|v| discr_val == v.disr_val.to_u128_unchecked()) {\n-                            // start at offset 1, to skip over the discriminant\n-                            Some(i) => adt_def.variants[i].fields.iter().zip(&variants[i].offsets[1..]),\n-                            None => return Err(EvalError::InvalidDiscriminant),\n-                        }\n-                    },\n-                    Layout::StructWrappedNullablePointer { nndiscr, ref nonnull, .. } => {\n-                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n-                        if discr == nndiscr as u128 {\n-                            assert_eq!(discr as usize as u128, discr);\n-                            adt_def.variants[discr as usize].fields.iter().zip(&nonnull.offsets)\n-                        } else {\n-                            // FIXME: the zst variant might contain zst types that impl Drop\n-                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n-                        }\n-                    },\n-                    Layout::RawNullablePointer { nndiscr, .. } => {\n-                        let discr = self.read_discriminant_value(adt_ptr, ty)?;\n-                        if discr == nndiscr as u128 {\n-                            assert_eq!(discr as usize as u128, discr);\n-                            assert_eq!(adt_def.variants[discr as usize].fields.len(), 1);\n-                            let field_ty = &adt_def.variants[discr as usize].fields[0];\n-                            let field_ty = monomorphize_field_ty(self.tcx, field_ty, substs);\n-                            // FIXME: once read_discriminant_value works with lvalue, don't force\n-                            // alloc in the RawNullablePointer case\n-                            self.drop(lval, field_ty, drop)?;\n-                            return Ok(());\n-                        } else {\n-                            // FIXME: the zst variant might contain zst types that impl Drop\n-                            return Ok(()); // nothing to do, this is zero sized (e.g. `None`)\n-                        }\n-                    },\n-                    Layout::CEnum { .. } => return Ok(()),\n-                    _ => bug!(\"{:?} is not an adt layout\", layout),\n-                };\n-                let tcx = self.tcx;\n-                self.drop_fields(\n-                    fields.map(|(ty, &offset)| (monomorphize_field_ty(tcx, ty, substs), offset)),\n-                    lval,\n-                    drop,\n-                )?;\n-            },\n-            ty::TyTuple(fields, _) => {\n-                let offsets = match *self.type_layout(ty)? {\n-                    Layout::Univariant { ref variant, .. } => &variant.offsets,\n-                    _ => bug!(\"tuples must be univariant\"),\n-                };\n-                self.drop_fields(fields.iter().cloned().zip(offsets.iter().cloned()), lval, drop)?;\n-            },\n-            ty::TyDynamic(..) => {\n-                let (ptr, vtable) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Vtable(vtable) } => (ptr, vtable),\n-                    _ => bug!(\"expected an lvalue with a vtable\"),\n-                };\n-                let drop_fn = self.memory.read_ptr(vtable)?;\n-                // some values don't need to call a drop impl, so the value is null\n-                if drop_fn != Pointer::from_int(0) {\n-                    let FunctionDefinition {def_id, substs, sig, ..} = self.memory.get_fn(drop_fn.alloc_id)?.expect_drop_glue()?;\n-                    let real_ty = sig.inputs()[0];\n-                    self.drop(Lvalue::from_ptr(ptr), real_ty, drop)?;\n-                    drop.push((def_id, Value::ByVal(PrimVal::Ptr(ptr)), substs));\n-                } else {\n-                    // just a sanity check\n-                    assert_eq!(drop_fn.offset, 0);\n-                }\n-            },\n-            ty::TySlice(elem_ty) => {\n-                let (ptr, len) = match lval {\n-                    Lvalue::Ptr { ptr, extra: LvalueExtra::Length(len) } => (ptr, len),\n-                    _ => bug!(\"expected an lvalue with a length\"),\n-                };\n-                let size = self.type_size(elem_ty)?.expect(\"slice element must be sized\");\n-                // FIXME: this creates a lot of stack frames if the element type has\n-                // a drop impl\n-                for i in 0..len {\n-                    self.drop(Lvalue::from_ptr(ptr.offset(i * size)), elem_ty, drop)?;\n-                }\n-            },\n-            ty::TyArray(elem_ty, len) => {\n-                let lval = self.force_allocation(lval)?;\n-                let (ptr, extra) = match lval {\n-                    Lvalue::Ptr { ptr, extra } => (ptr, extra),\n-                    _ => bug!(\"expected an lvalue with optional extra data\"),\n-                };\n-                let size = self.type_size(elem_ty)?.expect(\"array element cannot be unsized\");\n-                // FIXME: this creates a lot of stack frames if the element type has\n-                // a drop impl\n-                for i in 0..(len as u64) {\n-                    self.drop(Lvalue::Ptr { ptr: ptr.offset(i * size), extra }, elem_ty, drop)?;\n-                }\n-            },\n-            // FIXME: what about TyClosure and TyAnon?\n-            // other types do not need to process drop\n-            _ => {},\n-        }\n-\n-        Ok(())\n-    }\n-\n-    fn drop_fields<I>(\n-        &mut self,\n-        mut fields: I,\n-        lval: Lvalue<'tcx>,\n-        drop: &mut Vec<(DefId, Value, &'tcx Substs<'tcx>)>,\n-    ) -> EvalResult<'tcx>\n-        where I: Iterator<Item = (Ty<'tcx>, ty::layout::Size)>,\n-    {\n-        // FIXME: some aggregates may be represented by Value::ByValPair\n-        let (adt_ptr, extra) = self.force_allocation(lval)?.to_ptr_and_extra();\n-        // manual iteration, because we need to be careful about the last field if it is unsized\n-        while let Some((field_ty, offset)) = fields.next() {\n-            let ptr = adt_ptr.offset(offset.bytes());\n-            if self.type_is_sized(field_ty) {\n-                self.drop(Lvalue::from_ptr(ptr), field_ty, drop)?;\n-            } else {\n-                self.drop(Lvalue::Ptr { ptr, extra }, field_ty, drop)?;\n-                break; // if it is not sized, then this is the last field anyway\n-            }\n-        }\n-        assert!(fields.next().is_none());\n-        Ok(())\n-    }\n }\n \n #[derive(Debug)]"}, {"sha": "78acfd9dded4cdf778ac0b838c3624dffd852604", "filename": "src/vtable.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/src%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/src%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvtable.rs?ref=c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "patch": "@@ -94,11 +94,16 @@ impl<'a, 'tcx> EvalContext<'a, 'tcx> {\n         self.memory.write_usize(vtable, 0)?;\n         if let ty::TyAdt(adt_def, substs) = trait_ref.self_ty().sty {\n             if let Some(drop_def_id) = adt_def.destructor() {\n-                let fn_ty = match  self.tcx.item_type(drop_def_id).sty {\n+                let fn_ty = match self.tcx.item_type(drop_def_id).sty {\n                     ty::TyFnDef(_, _, fn_ty) => self.tcx.erase_regions(&fn_ty),\n                     _ => bug!(\"drop method is not a TyFnDef\"),\n                 };\n-                let fn_ptr = self.memory.create_drop_glue(self.tcx, drop_def_id, substs, fn_ty);\n+                // The real type is taken from the self argument in `fn drop(&mut self)`\n+                let real_ty = match fn_ty.sig.skip_binder().inputs()[0].sty {\n+                    ty::TyRef(_, mt) => self.monomorphize(mt.ty, substs),\n+                    _ => bug!(\"first argument of Drop::drop must be &mut T\"),\n+                };\n+                let fn_ptr = self.memory.create_drop_glue(real_ty);\n                 self.memory.write_ptr(vtable, fn_ptr)?;\n             }\n         }"}, {"sha": "57eef52d573b9e4c6b3acb3d1a8d910c5af3b6eb", "filename": "tests/run-pass/box_box_trait.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/tests%2Frun-pass%2Fbox_box_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/tests%2Frun-pass%2Fbox_box_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fbox_box_trait.rs?ref=c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "patch": "@@ -0,0 +1,29 @@\n+#![feature(box_syntax)]\n+\n+struct DroppableStruct;\n+\n+static mut DROPPED: bool = false;\n+\n+impl Drop for DroppableStruct {\n+    fn drop(&mut self) {\n+        unsafe { DROPPED = true; }\n+    }\n+}\n+\n+trait MyTrait { fn dummy(&self) { } }\n+impl MyTrait for Box<DroppableStruct> {}\n+\n+struct Whatever { w: Box<MyTrait+'static> }\n+impl  Whatever {\n+    fn new(w: Box<MyTrait+'static>) -> Whatever {\n+        Whatever { w: w }\n+    }\n+}\n+\n+fn main() {\n+    {\n+        let f: Box<_> = box DroppableStruct;\n+        let _a = Whatever::new(box f as Box<MyTrait>);\n+    }\n+    assert!(unsafe { DROPPED });\n+}"}, {"sha": "5631b65ed9d8a6dd60a0465fd9651e8965e7390d", "filename": "tests/run-pass/dst-field-align.rs", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/tests%2Frun-pass%2Fdst-field-align.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6/tests%2Frun-pass%2Fdst-field-align.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fdst-field-align.rs?ref=c342cb5fe89bc3d90beeaf2f8505b7cf689a8dc6", "patch": "@@ -23,8 +23,55 @@ impl Bar for usize {\n     fn get(&self) -> usize { *self }\n }\n \n+struct Baz<T: ?Sized> {\n+    a: T\n+}\n+\n+struct HasDrop<T: ?Sized> {\n+    ptr: Box<usize>,\n+    data: T\n+}\n+\n fn main() {\n+    // Test that zero-offset works properly\n+    let b : Baz<usize> = Baz { a: 7 };\n+    assert_eq!(b.a.get(), 7);\n+    let b : &Baz<Bar> = &b;\n+    assert_eq!(b.a.get(), 7);\n+\n+    // Test that the field is aligned properly\n     let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    assert_eq!(f.b.get(), 11);\n+    let ptr1 : *const u8 = &f.b as *const _ as *const u8;\n+\n     let f : &Foo<Bar> = &f;\n+    let ptr2 : *const u8 = &f.b as *const _ as *const u8;\n     assert_eq!(f.b.get(), 11);\n+\n+    // The pointers should be the same\n+    assert_eq!(ptr1, ptr2);\n+\n+    // Test that nested DSTs work properly\n+    let f : Foo<Foo<usize>> = Foo { a: 0, b: Foo { a: 1, b: 17 }};\n+    assert_eq!(f.b.b.get(), 17);\n+    let f : &Foo<Foo<Bar>> = &f;\n+    assert_eq!(f.b.b.get(), 17);\n+\n+    // Test that get the pointer via destructuring works\n+\n+    let f : Foo<usize> = Foo { a: 0, b: 11 };\n+    let f : &Foo<Bar> = &f;\n+    let &Foo { a: _, b: ref bar } = f;\n+    assert_eq!(bar.get(), 11);\n+\n+    // Make sure that drop flags don't screw things up\n+\n+    let d : HasDrop<Baz<[i32; 4]>> = HasDrop {\n+        ptr: Box::new(0),\n+        data: Baz { a: [1,2,3,4] }\n+    };\n+    assert_eq!([1,2,3,4], d.data.a);\n+\n+    let d : &HasDrop<Baz<[i32]>> = &d;\n+    assert_eq!(&[1,2,3,4], &d.data.a);\n }"}]}