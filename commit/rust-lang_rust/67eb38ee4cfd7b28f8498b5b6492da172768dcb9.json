{"sha": "67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY3ZWIzOGVlNGNmZDdiMjhmODQ5OGI1YjY0OTJkYTE3Mjc2OGRjYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-22T22:45:46Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-22T22:45:46Z"}, "message": "Auto merge of #22466 - Kimundi:str_pattern_ai_safe, r=aturon\n\nThis is not a complete implementation of the RFC:\r\n\r\n- only existing methods got updated, no new ones added\r\n- doc comments are not extensive enough yet\r\n- optimizations got lost and need to be reimplemented\r\n\r\nSee https://github.com/rust-lang/rfcs/pull/528\r\n\r\nTechnically a\r\n\r\n[breaking-change]", "tree": {"sha": "358263816246c0e05a4ba458cadb266307a96172", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/358263816246c0e05a4ba458cadb266307a96172"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "html_url": "https://github.com/rust-lang/rust/commit/67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "html_url": "https://github.com/rust-lang/rust/commit/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd"}, {"sha": "c8dd2d066d7b25246d2b940b7c161b8b67608b74", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8dd2d066d7b25246d2b940b7c161b8b67608b74", "html_url": "https://github.com/rust-lang/rust/commit/c8dd2d066d7b25246d2b940b7c161b8b67608b74"}], "stats": {"total": 1426, "additions": 1076, "deletions": 350}, "files": [{"sha": "7411a9b48d417e70936dcacfad51c6b10822a5ee", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -58,7 +58,7 @@ pub fn load_errors(testfile: &Path) -> Vec<ExpectedError> {\n fn parse_expected(last_nonfollow_error: Option<uint>,\n                   line_num: uint,\n                   line: &str) -> Option<(WhichLine, ExpectedError)> {\n-    let start = match line.find_str(\"//~\") { Some(i) => i, None => return None };\n+    let start = match line.find(\"//~\") { Some(i) => i, None => return None };\n     let (follow, adjusts) = if line.char_at(start + 3) == '|' {\n         (true, 0)\n     } else {"}, {"sha": "9c217651c3edcc1b429b040d6e0b4219ede5983d", "filename": "src/compiletest/header.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Fcompiletest%2Fheader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Fcompiletest%2Fheader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fheader.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -330,7 +330,7 @@ fn parse_name_directive(line: &str, directive: &str) -> bool {\n pub fn parse_name_value_directive(line: &str, directive: &str)\n                                   -> Option<String> {\n     let keycolon = format!(\"{}:\", directive);\n-    match line.find_str(&keycolon) {\n+    match line.find(&keycolon) {\n         Some(colon) => {\n             let value = line[(colon + keycolon.len()) .. line.len()].to_string();\n             debug!(\"{}: {}\", directive, value);"}, {"sha": "39ecc323125b734b19b3ad43882cddc9dba1b1c3", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -847,7 +847,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n             check_lines.iter().map(|s| {\n                 s\n                  .trim()\n-                 .split_str(\"[...]\")\n+                 .split(\"[...]\")\n                  .map(|x| x.to_string())\n                  .collect()\n             }).collect();\n@@ -866,7 +866,7 @@ fn check_debugger_output(debugger_run_result: &ProcRes, check_lines: &[String])\n                         None\n                     }\n                 } else {\n-                    rest.find_str(frag)\n+                    rest.find(frag)\n                 };\n                 match found {\n                     None => {"}, {"sha": "92dc01dc3e4e432c11c682f076433f59735904bd", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 35, "deletions": 56, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -82,6 +82,8 @@ pub use core::str::{SplitN, RSplitN};\n pub use core::str::{from_utf8, CharEq, Chars, CharIndices, Bytes};\n pub use core::str::{from_utf8_unchecked, from_c_str, ParseBoolError};\n pub use unicode::str::{Words, Graphemes, GraphemeIndices};\n+pub use core::str::Pattern;\n+pub use core::str::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n \n /*\n Section: Creating a string\n@@ -530,7 +532,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert!(\"bananas\".contains(\"nana\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn contains(&self, pat: &str) -> bool {\n+    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::contains(&self[..], pat)\n     }\n \n@@ -545,9 +547,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```rust\n     /// assert!(\"hello\".contains_char('e'));\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might get removed in favour of a more generic contains()\")]\n-    fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `contains()` with a char\")]\n+    fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::contains_char(&self[..], pat)\n     }\n \n@@ -603,7 +605,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n+    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n         core_str::StrExt::split(&self[..], pat)\n     }\n \n@@ -630,7 +632,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(v, vec![\"\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n+    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n         core_str::StrExt::splitn(&self[..], count, pat)\n     }\n \n@@ -658,8 +660,8 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').rev().collect();\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"\", \"lion\"]);\n     /// ```\n-    #[unstable(feature = \"collections\", reason = \"might get removed\")]\n-    fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n         core_str::StrExt::split_terminator(&self[..], pat)\n     }\n \n@@ -680,7 +682,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n         core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n \n@@ -706,7 +708,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n-    fn match_indices<'a>(&'a self, pat: &'a str) -> MatchIndices<'a> {\n+    // NB: Right now MatchIndices yields `(usize, usize)`,\n+    // but it would be more consistent and useful to return `(usize, &str)`\n+    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n         core_str::StrExt::match_indices(&self[..], pat)\n     }\n \n@@ -721,9 +725,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n     /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might get removed in the future in favor of a more generic split()\")]\n-    fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a> {\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `split()` with a `&str`\")]\n+    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n         core_str::StrExt::split_str(&self[..], pat)\n     }\n \n@@ -825,7 +829,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert!(\"banana\".starts_with(\"ba\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn starts_with(&self, pat: &str) -> bool {\n+    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n         core_str::StrExt::starts_with(&self[..], pat)\n     }\n \n@@ -837,7 +841,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert!(\"banana\".ends_with(\"nana\"));\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn ends_with(&self, pat: &str) -> bool {\n+    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::ends_with(&self[..], pat)\n     }\n \n@@ -857,7 +863,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(\"123foo1bar123\".trim_matches(|c: char| c.is_numeric()), \"foo1bar\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_matches<P: CharEq>(&self, pat: P) -> &str {\n+    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n         core_str::StrExt::trim_matches(&self[..], pat)\n     }\n \n@@ -877,7 +885,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(\"123foo1bar123\".trim_left_matches(|c: char| c.is_numeric()), \"foo1bar123\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_left_matches<P: CharEq>(&self, pat: P) -> &str {\n+    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n         core_str::StrExt::trim_left_matches(&self[..], pat)\n     }\n \n@@ -897,7 +905,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(\"123foo1bar123\".trim_right_matches(|c: char| c.is_numeric()), \"123foo1bar\");\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn trim_right_matches<P: CharEq>(&self, pat: P) -> &str {\n+    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::trim_right_matches(&self[..], pat)\n     }\n \n@@ -1074,7 +1084,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.find(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn find<P: CharEq>(&self, pat: P) -> Option<usize> {\n+    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n         core_str::StrExt::find(&self[..], pat)\n     }\n \n@@ -1102,7 +1112,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.rfind(x), None);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn rfind<P: CharEq>(&self, pat: P) -> Option<usize> {\n+    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::rfind(&self[..], pat)\n     }\n \n@@ -1125,9 +1137,9 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// assert_eq!(s.find_str(\"\u8001\u864e L\"), Some(6));\n     /// assert_eq!(s.find_str(\"muffin man\"), None);\n     /// ```\n-    #[unstable(feature = \"collections\",\n-               reason = \"might get removed in favor of a more generic find in the future\")]\n-    fn find_str(&self, needle: &str) -> Option<usize> {\n+    #[unstable(feature = \"collections\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"use `find()` with a `&str`\")]\n+    fn find_str<'a, P: Pattern<'a>>(&'a self, needle: P) -> Option<usize> {\n         core_str::StrExt::find_str(&self[..], needle)\n     }\n \n@@ -2887,22 +2899,6 @@ mod bench {\n         b.iter(|| assert_eq!(s.split('V').count(), 3));\n     }\n \n-    #[bench]\n-    fn split_unicode_not_ascii(b: &mut Bencher) {\n-        struct NotAscii(char);\n-        impl CharEq for NotAscii {\n-            fn matches(&mut self, c: char) -> bool {\n-                let NotAscii(cc) = *self;\n-                cc == c\n-            }\n-            fn only_ascii(&self) -> bool { false }\n-        }\n-        let s = \"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\";\n-\n-        b.iter(|| assert_eq!(s.split(NotAscii('V')).count(), 3));\n-    }\n-\n-\n     #[bench]\n     fn split_ascii(b: &mut Bencher) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n@@ -2911,23 +2907,6 @@ mod bench {\n         b.iter(|| assert_eq!(s.split(' ').count(), len));\n     }\n \n-    #[bench]\n-    fn split_not_ascii(b: &mut Bencher) {\n-        struct NotAscii(char);\n-        impl CharEq for NotAscii {\n-            #[inline]\n-            fn matches(&mut self, c: char) -> bool {\n-                let NotAscii(cc) = *self;\n-                cc == c\n-            }\n-            fn only_ascii(&self) -> bool { false }\n-        }\n-        let s = \"Mary had a little lamb, Little lamb, little-lamb.\";\n-        let len = s.split(' ').count();\n-\n-        b.iter(|| assert_eq!(s.split(NotAscii(' ')).count(), len));\n-    }\n-\n     #[bench]\n     fn split_extern_fn(b: &mut Bencher) {\n         let s = \"Mary had a little lamb, Little lamb, little-lamb.\";"}, {"sha": "8e27ae1cea97039342dceb76b1e04b541d6faa41", "filename": "src/libcore/char.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -22,13 +22,13 @@ use option::Option;\n use slice::SliceExt;\n \n // UTF-8 ranges and tags for encoding characters\n-static TAG_CONT: u8    = 0b1000_0000u8;\n-static TAG_TWO_B: u8   = 0b1100_0000u8;\n-static TAG_THREE_B: u8 = 0b1110_0000u8;\n-static TAG_FOUR_B: u8  = 0b1111_0000u8;\n-static MAX_ONE_B: u32   =     0x80u32;\n-static MAX_TWO_B: u32   =    0x800u32;\n-static MAX_THREE_B: u32 =  0x10000u32;\n+const TAG_CONT: u8    = 0b1000_0000u8;\n+const TAG_TWO_B: u8   = 0b1100_0000u8;\n+const TAG_THREE_B: u8 = 0b1110_0000u8;\n+const TAG_FOUR_B: u8  = 0b1111_0000u8;\n+const MAX_ONE_B: u32   =     0x80u32;\n+const MAX_TWO_B: u32   =    0x800u32;\n+const MAX_THREE_B: u32 =  0x10000u32;\n \n /*\n     Lu  Uppercase_Letter        an uppercase letter\n@@ -398,11 +398,14 @@ impl CharExt for char {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn len_utf8(self) -> usize {\n         let code = self as u32;\n-        match () {\n-            _ if code < MAX_ONE_B   => 1,\n-            _ if code < MAX_TWO_B   => 2,\n-            _ if code < MAX_THREE_B => 3,\n-            _  => 4,\n+        if code < MAX_ONE_B {\n+            1\n+        } else if code < MAX_TWO_B {\n+            2\n+        } else if code < MAX_THREE_B {\n+            3\n+        } else {\n+            4\n         }\n     }\n "}, {"sha": "2debcaa5813421c0951b434f85c8b01f44001c1d", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -657,6 +657,8 @@ macro_rules! iterator {\n             fn next(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n+                    ::intrinsics::assume(!self.ptr.is_null());\n+                    ::intrinsics::assume(!self.end.is_null());\n                     if self.ptr == self.end {\n                         None\n                     } else {\n@@ -693,6 +695,8 @@ macro_rules! iterator {\n             fn next_back(&mut self) -> Option<$elem> {\n                 // could be implemented with slices, but this avoids bounds checks\n                 unsafe {\n+                    ::intrinsics::assume(!self.ptr.is_null());\n+                    ::intrinsics::assume(!self.end.is_null());\n                     if self.end == self.ptr {\n                         None\n                     } else {"}, {"sha": "7e51f8e8503b411e4c62ba740aff3d23a0e112a7", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 242, "deletions": 263, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -16,7 +16,7 @@\n \n #![doc(primitive = \"str\")]\n \n-use self::Searcher::{Naive, TwoWay, TwoWayLong};\n+use self::OldSearcher::{TwoWay, TwoWayLong};\n \n use clone::Clone;\n use cmp::{self, Eq};\n@@ -36,6 +36,11 @@ use result::Result::{self, Ok, Err};\n use slice::{self, SliceExt};\n use usize;\n \n+pub use self::pattern::Pattern;\n+pub use self::pattern::{Searcher, ReverseSearcher, DoubleEndedSearcher, SearchStep};\n+\n+mod pattern;\n+\n macro_rules! delegate_iter {\n     (exact $te:ty : $ti:ty) => {\n         delegate_iter!{$te : $ti}\n@@ -70,7 +75,7 @@ macro_rules! delegate_iter {\n     };\n     (pattern $te:ty : $ti:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: CharEq> Iterator for $ti {\n+        impl<'a, P: Pattern<'a>> Iterator for $ti {\n             type Item = $te;\n \n             #[inline]\n@@ -83,7 +88,8 @@ macro_rules! delegate_iter {\n             }\n         }\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: CharEq> DoubleEndedIterator for $ti {\n+        impl<'a, P: Pattern<'a>> DoubleEndedIterator for $ti\n+        where P::Searcher: DoubleEndedSearcher<'a> {\n             #[inline]\n             fn next_back(&mut self) -> Option<$te> {\n                 self.0.next_back()\n@@ -92,7 +98,8 @@ macro_rules! delegate_iter {\n     };\n     (pattern forward $te:ty : $ti:ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-        impl<'a, P: CharEq> Iterator for $ti {\n+        impl<'a, P: Pattern<'a>> Iterator for $ti\n+        where P::Searcher: DoubleEndedSearcher<'a> {\n             type Item = $te;\n \n             #[inline]\n@@ -235,8 +242,10 @@ pub unsafe fn from_c_str(s: *const i8) -> &'static str {\n }\n \n /// Something that can be used to compare against a character\n-#[unstable(feature = \"core\",\n-           reason = \"definition may change as pattern-related methods are stabilized\")]\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\",\n+             reason = \"use `Pattern` instead\")]\n+// NB: Rather than removing it, make it private and move it into self::pattern\n pub trait CharEq {\n     /// Determine if the splitter should split at the given character\n     fn matches(&mut self, char) -> bool;\n@@ -245,6 +254,7 @@ pub trait CharEq {\n     fn only_ascii(&self) -> bool;\n }\n \n+#[allow(deprecated) /* for CharEq */ ]\n impl CharEq for char {\n     #[inline]\n     fn matches(&mut self, c: char) -> bool { *self == c }\n@@ -253,6 +263,7 @@ impl CharEq for char {\n     fn only_ascii(&self) -> bool { (*self as u32) < 128 }\n }\n \n+#[allow(deprecated) /* for CharEq */ ]\n impl<F> CharEq for F where F: FnMut(char) -> bool {\n     #[inline]\n     fn matches(&mut self, c: char) -> bool { (*self)(c) }\n@@ -261,13 +272,16 @@ impl<F> CharEq for F where F: FnMut(char) -> bool {\n     fn only_ascii(&self) -> bool { false }\n }\n \n+#[allow(deprecated) /* for CharEq */ ]\n impl<'a> CharEq for &'a [char] {\n     #[inline]\n+    #[allow(deprecated) /* for CharEq */ ]\n     fn matches(&mut self, c: char) -> bool {\n         self.iter().any(|&m| { let mut m = m; m.matches(c) })\n     }\n \n     #[inline]\n+    #[allow(deprecated) /* for CharEq */ ]\n     fn only_ascii(&self) -> bool {\n         self.iter().all(|m| m.only_ascii())\n     }\n@@ -337,6 +351,7 @@ fn unwrap_or_0(opt: Option<&u8>) -> u8 {\n /// Reads the next code point out of a byte iterator (assuming a\n /// UTF-8-like encoding).\n #[unstable(feature = \"core\")]\n+#[inline]\n pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     // Decode UTF-8\n     let x = match bytes.next() {\n@@ -368,6 +383,38 @@ pub fn next_code_point(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n     Some(ch)\n }\n \n+/// Reads the last code point out of a byte iterator (assuming a\n+/// UTF-8-like encoding).\n+#[unstable(feature = \"core\")]\n+#[inline]\n+pub fn next_code_point_reverse(bytes: &mut slice::Iter<u8>) -> Option<u32> {\n+    // Decode UTF-8\n+    let w = match bytes.next_back() {\n+        None => return None,\n+        Some(&next_byte) if next_byte < 128 => return Some(next_byte as u32),\n+        Some(&back_byte) => back_byte,\n+    };\n+\n+    // Multibyte case follows\n+    // Decode from a byte combination out of: [x [y [z w]]]\n+    let mut ch;\n+    let z = unwrap_or_0(bytes.next_back());\n+    ch = utf8_first_byte!(z, 2);\n+    if utf8_is_cont_byte!(z) {\n+        let y = unwrap_or_0(bytes.next_back());\n+        ch = utf8_first_byte!(y, 3);\n+        if utf8_is_cont_byte!(y) {\n+            let x = unwrap_or_0(bytes.next_back());\n+            ch = utf8_first_byte!(x, 4);\n+            ch = utf8_acc_cont_byte!(ch, y);\n+        }\n+        ch = utf8_acc_cont_byte!(ch, z);\n+    }\n+    ch = utf8_acc_cont_byte!(ch, w);\n+\n+    Some(ch)\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a> Iterator for Chars<'a> {\n     type Item = char;\n@@ -393,33 +440,12 @@ impl<'a> Iterator for Chars<'a> {\n impl<'a> DoubleEndedIterator for Chars<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<char> {\n-        let w = match self.iter.next_back() {\n-            None => return None,\n-            Some(&back_byte) if back_byte < 128 => return Some(back_byte as char),\n-            Some(&back_byte) => back_byte,\n-        };\n-\n-        // Multibyte case follows\n-        // Decode from a byte combination out of: [x [y [z w]]]\n-        let mut ch;\n-        let z = unwrap_or_0(self.iter.next_back());\n-        ch = utf8_first_byte!(z, 2);\n-        if utf8_is_cont_byte!(z) {\n-            let y = unwrap_or_0(self.iter.next_back());\n-            ch = utf8_first_byte!(y, 3);\n-            if utf8_is_cont_byte!(y) {\n-                let x = unwrap_or_0(self.iter.next_back());\n-                ch = utf8_first_byte!(x, 4);\n-                ch = utf8_acc_cont_byte!(ch, y);\n+        next_code_point_reverse(&mut self.iter).map(|ch| {\n+            // str invariant says `ch` is a valid Unicode Scalar Value\n+            unsafe {\n+                mem::transmute(ch)\n             }\n-            ch = utf8_acc_cont_byte!(ch, z);\n-        }\n-        ch = utf8_acc_cont_byte!(ch, w);\n-\n-        // str invariant says `ch` is a valid Unicode Scalar Value\n-        unsafe {\n-            Some(mem::transmute(ch))\n-        }\n+        })\n     }\n }\n \n@@ -495,22 +521,20 @@ impl<'a> Fn<(&'a u8,)> for BytesDeref {\n }\n \n /// An iterator over the substrings of a string, separated by `sep`.\n-#[derive(Clone)]\n-struct CharSplits<'a, Sep> {\n+struct CharSplits<'a, P: Pattern<'a>> {\n     /// The slice remaining to be iterated\n-    string: &'a str,\n-    sep: Sep,\n+    start: usize,\n+    end: usize,\n+    matcher: P::Searcher,\n     /// Whether an empty string at the end is allowed\n     allow_trailing_empty: bool,\n-    only_ascii: bool,\n     finished: bool,\n }\n \n /// An iterator over the substrings of a string, separated by `sep`,\n /// splitting at most `count` times.\n-#[derive(Clone)]\n-struct CharSplitsN<'a, Sep> {\n-    iter: CharSplits<'a, Sep>,\n+struct CharSplitsN<'a, P: Pattern<'a>> {\n+    iter: CharSplits<'a, P>,\n     /// The number of splits remaining\n     count: usize,\n     invert: bool,\n@@ -528,46 +552,34 @@ pub struct LinesAny<'a> {\n     inner: Map<Lines<'a>, fn(&str) -> &str>,\n }\n \n-impl<'a, Sep> CharSplits<'a, Sep> {\n+impl<'a, P: Pattern<'a>> CharSplits<'a, P> {\n     #[inline]\n     fn get_end(&mut self) -> Option<&'a str> {\n-        if !self.finished && (self.allow_trailing_empty || self.string.len() > 0) {\n+        if !self.finished && (self.allow_trailing_empty || self.end - self.start > 0) {\n             self.finished = true;\n-            Some(self.string)\n+            unsafe {\n+                let string = self.matcher.haystack().slice_unchecked(self.start, self.end);\n+                Some(string)\n+            }\n         } else {\n             None\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n+impl<'a, P: Pattern<'a>> Iterator for CharSplits<'a, P> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n \n-        let mut next_split = None;\n-        if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate() {\n-                if self.sep.matches(byte as char) && byte < 128u8 {\n-                    next_split = Some((idx, idx + 1));\n-                    break;\n-                }\n-            }\n-        } else {\n-            for (idx, ch) in self.string.char_indices() {\n-                if self.sep.matches(ch) {\n-                    next_split = Some((idx, self.string.char_range_at(idx).next));\n-                    break;\n-                }\n-            }\n-        }\n-        match next_split {\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match() {\n             Some((a, b)) => unsafe {\n-                let elt = self.string.slice_unchecked(0, a);\n-                self.string = self.string.slice_unchecked(b, self.string.len());\n+                let elt = haystack.slice_unchecked(self.start, a);\n+                self.start = b;\n                 Some(elt)\n             },\n             None => self.get_end(),\n@@ -576,7 +588,8 @@ impl<'a, Sep: CharEq> Iterator for CharSplits<'a, Sep> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n+impl<'a, P: Pattern<'a>> DoubleEndedIterator for CharSplits<'a, P>\n+where P::Searcher: DoubleEndedSearcher<'a> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a str> {\n         if self.finished { return None }\n@@ -588,37 +601,25 @@ impl<'a, Sep: CharEq> DoubleEndedIterator for CharSplits<'a, Sep> {\n                 _ => if self.finished { return None }\n             }\n         }\n-        let len = self.string.len();\n-        let mut next_split = None;\n-\n-        if self.only_ascii {\n-            for (idx, byte) in self.string.bytes().enumerate().rev() {\n-                if self.sep.matches(byte as char) && byte < 128u8 {\n-                    next_split = Some((idx, idx + 1));\n-                    break;\n-                }\n-            }\n-        } else {\n-            for (idx, ch) in self.string.char_indices().rev() {\n-                if self.sep.matches(ch) {\n-                    next_split = Some((idx, self.string.char_range_at(idx).next));\n-                    break;\n-                }\n-            }\n-        }\n-        match next_split {\n+\n+        let haystack = self.matcher.haystack();\n+        match self.matcher.next_match_back() {\n             Some((a, b)) => unsafe {\n-                let elt = self.string.slice_unchecked(b, len);\n-                self.string = self.string.slice_unchecked(0, a);\n+                let elt = haystack.slice_unchecked(b, self.end);\n+                self.end = a;\n                 Some(elt)\n             },\n-            None => { self.finished = true; Some(self.string) }\n+            None => unsafe {\n+                self.finished = true;\n+                Some(haystack.slice_unchecked(self.start, self.end))\n+            },\n         }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n+impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P>\n+where P::Searcher: DoubleEndedSearcher<'a> {\n     type Item = &'a str;\n \n     #[inline]\n@@ -632,32 +633,6 @@ impl<'a, Sep: CharEq> Iterator for CharSplitsN<'a, Sep> {\n     }\n }\n \n-/// The internal state of an iterator that searches for matches of a substring\n-/// within a larger string using naive search\n-#[derive(Clone)]\n-struct NaiveSearcher {\n-    position: usize\n-}\n-\n-impl NaiveSearcher {\n-    fn new() -> NaiveSearcher {\n-        NaiveSearcher { position: 0 }\n-    }\n-\n-    fn next(&mut self, haystack: &[u8], needle: &[u8]) -> Option<(usize, usize)> {\n-        while self.position + needle.len() <= haystack.len() {\n-            if &haystack[self.position .. self.position + needle.len()] == needle {\n-                let match_pos = self.position;\n-                self.position += needle.len(); // add 1 for all matches\n-                return Some((match_pos, match_pos + needle.len()));\n-            } else {\n-                self.position += 1;\n-            }\n-        }\n-        None\n-    }\n-}\n-\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using two-way search\n #[derive(Clone)]\n@@ -743,6 +718,7 @@ struct TwoWaySearcher {\n \n */\n impl TwoWaySearcher {\n+    #[allow(dead_code)]\n     fn new(needle: &[u8]) -> TwoWaySearcher {\n         let (crit_pos_false, period_false) = TwoWaySearcher::maximal_suffix(needle, false);\n         let (crit_pos_true, period_true) = TwoWaySearcher::maximal_suffix(needle, true);\n@@ -852,6 +828,7 @@ impl TwoWaySearcher {\n     // Specifically, returns (i, p), where i is the starting index of v in some\n     // critical factorization (u, v) and p = period(v)\n     #[inline]\n+    #[allow(dead_code)]\n     fn maximal_suffix(arr: &[u8], reversed: bool) -> (usize, usize) {\n         let mut left = -1; // Corresponds to i in the paper\n         let mut right = 0; // Corresponds to j in the paper\n@@ -896,20 +873,26 @@ impl TwoWaySearcher {\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using a dynamically chosen search algorithm\n #[derive(Clone)]\n-enum Searcher {\n-    Naive(NaiveSearcher),\n+// NB: This is kept around for convenience because\n+// it is planned to be used again in the future\n+enum OldSearcher {\n     TwoWay(TwoWaySearcher),\n-    TwoWayLong(TwoWaySearcher)\n+    TwoWayLong(TwoWaySearcher),\n }\n \n-impl Searcher {\n-    fn new(haystack: &[u8], needle: &[u8]) -> Searcher {\n+impl OldSearcher {\n+    #[allow(dead_code)]\n+    fn new(haystack: &[u8], needle: &[u8]) -> OldSearcher {\n+        if needle.len() == 0 {\n+            // Handle specially\n+            unimplemented!()\n         // FIXME: Tune this.\n         // FIXME(#16715): This unsigned integer addition will probably not\n         // overflow because that would mean that the memory almost solely\n         // consists of the needle. Needs #16715 to be formally fixed.\n-        if needle.len() + 20 > haystack.len() {\n-            Naive(NaiveSearcher::new())\n+        } else if needle.len() + 20 > haystack.len() {\n+            // Use naive searcher\n+            unimplemented!()\n         } else {\n             let searcher = TwoWaySearcher::new(needle);\n             if searcher.memory == usize::MAX { // If the period is long\n@@ -921,67 +904,59 @@ impl Searcher {\n     }\n }\n \n-/// An iterator over the start and end indices of the matches of a\n-/// substring within a larger string\n #[derive(Clone)]\n-#[unstable(feature = \"core\", reason = \"type may be removed\")]\n-pub struct MatchIndices<'a> {\n+// NB: This is kept around for convenience because\n+// it is planned to be used again in the future\n+struct OldMatchIndices<'a, 'b> {\n     // constants\n     haystack: &'a str,\n-    needle: &'a str,\n-    searcher: Searcher\n+    needle: &'b str,\n+    searcher: OldSearcher\n }\n \n-/// An iterator over the substrings of a string separated by a given\n-/// search string\n-#[derive(Clone)]\n+// FIXME: #21637 Prevents a Clone impl\n+/// An iterator over the start and end indices of the matches of a\n+/// substring within a larger string\n #[unstable(feature = \"core\", reason = \"type may be removed\")]\n-pub struct SplitStr<'a> {\n-    it: MatchIndices<'a>,\n-    last_end: usize,\n-    finished: bool\n-}\n+pub struct MatchIndices<'a, P: Pattern<'a>>(P::Searcher);\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for MatchIndices<'a> {\n+impl<'a, P: Pattern<'a>> Iterator for MatchIndices<'a, P> {\n     type Item = (usize, usize);\n \n     #[inline]\n     fn next(&mut self) -> Option<(usize, usize)> {\n-        match self.searcher {\n-            Naive(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes()),\n-            TwoWay(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), false),\n-            TwoWayLong(ref mut searcher)\n-                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true)\n-        }\n+        self.0.next_match()\n     }\n }\n \n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a> Iterator for SplitStr<'a> {\n+/// An iterator over the substrings of a string separated by a given\n+/// search string\n+#[unstable(feature = \"core\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `Split` with a `&str`\")]\n+pub struct SplitStr<'a, P: Pattern<'a>>(Split<'a, P>);\n+impl<'a, P: Pattern<'a>> Iterator for SplitStr<'a, P> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n-        if self.finished { return None; }\n+        Iterator::next(&mut self.0)\n+    }\n+}\n \n-        match self.it.next() {\n-            Some((from, to)) => {\n-                let ret = Some(&self.it.haystack[self.last_end .. from]);\n-                self.last_end = to;\n-                ret\n-            }\n-            None => {\n-                self.finished = true;\n-                Some(&self.it.haystack[self.last_end .. self.it.haystack.len()])\n-            }\n+impl<'a, 'b>  OldMatchIndices<'a, 'b> {\n+    #[inline]\n+    #[allow(dead_code)]\n+    fn next(&mut self) -> Option<(usize, usize)> {\n+        match self.searcher {\n+            TwoWay(ref mut searcher)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), false),\n+            TwoWayLong(ref mut searcher)\n+                => searcher.next(self.haystack.as_bytes(), self.needle.as_bytes(), true),\n         }\n     }\n }\n \n-\n /*\n Section: Comparing strings\n */\n@@ -1298,28 +1273,39 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n }\n \n /// Return type of `StrExt::split`\n-#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Split<'a, P>(CharSplits<'a, P>);\n-delegate_iter!{pattern &'a str : Split<'a, P>}\n+pub struct Split<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> Iterator for Split<'a, P> {\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        self.0.next()\n+    }\n+}\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> DoubleEndedIterator for Split<'a, P>\n+where P::Searcher: DoubleEndedSearcher<'a> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<&'a str> {\n+        self.0.next_back()\n+    }\n+}\n \n /// Return type of `StrExt::split_terminator`\n-#[derive(Clone)]\n-#[unstable(feature = \"core\",\n-           reason = \"might get removed in favour of a constructor method on Split\")]\n-pub struct SplitTerminator<'a, P>(CharSplits<'a, P>);\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub struct SplitTerminator<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n delegate_iter!{pattern &'a str : SplitTerminator<'a, P>}\n \n /// Return type of `StrExt::splitn`\n-#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct SplitN<'a, P>(CharSplitsN<'a, P>);\n+pub struct SplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : SplitN<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n-#[derive(Clone)]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplitN<'a, P>(CharSplitsN<'a, P>);\n+pub struct RSplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n \n /// Methods for string slices\n@@ -1328,36 +1314,40 @@ pub trait StrExt {\n     // NB there are no docs here are they're all located on the StrExt trait in\n     // libcollections, not here.\n \n-    fn contains(&self, pat: &str) -> bool;\n-    fn contains_char<P: CharEq>(&self, pat: P) -> bool;\n+    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n+    fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n     fn chars<'a>(&'a self) -> Chars<'a>;\n     fn bytes<'a>(&'a self) -> Bytes<'a>;\n     fn char_indices<'a>(&'a self) -> CharIndices<'a>;\n-    fn split<'a, P: CharEq>(&'a self, pat: P) -> Split<'a, P>;\n-    fn splitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n-    fn split_terminator<'a, P: CharEq>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n-    fn rsplitn<'a, P: CharEq>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n-    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a>;\n-    fn split_str<'a>(&'a self, pat: &'a str) -> SplitStr<'a>;\n+    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P>;\n+    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P>;\n+    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n+    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n+    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P>;\n     fn lines<'a>(&'a self) -> Lines<'a>;\n     fn lines_any<'a>(&'a self) -> LinesAny<'a>;\n     fn char_len(&self) -> usize;\n     fn slice_chars<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n     unsafe fn slice_unchecked<'a>(&'a self, begin: usize, end: usize) -> &'a str;\n-    fn starts_with(&self, pat: &str) -> bool;\n-    fn ends_with(&self, pat: &str) -> bool;\n-    fn trim_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n-    fn trim_left_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n-    fn trim_right_matches<'a, P: CharEq>(&'a self, pat: P) -> &'a str;\n+    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool;\n+    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>;\n+    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>;\n+    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str;\n+    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn is_char_boundary(&self, index: usize) -> bool;\n     fn char_range_at(&self, start: usize) -> CharRange;\n     fn char_range_at_reverse(&self, start: usize) -> CharRange;\n     fn char_at(&self, i: usize) -> char;\n     fn char_at_reverse(&self, i: usize) -> char;\n     fn as_bytes<'a>(&'a self) -> &'a [u8];\n-    fn find<P: CharEq>(&self, pat: P) -> Option<usize>;\n-    fn rfind<P: CharEq>(&self, pat: P) -> Option<usize>;\n-    fn find_str(&self, pat: &str) -> Option<usize>;\n+    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n+    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>;\n+    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>;\n     fn slice_shift_char<'a>(&'a self) -> Option<(char, &'a str)>;\n     fn subslice_offset(&self, inner: &str) -> usize;\n     fn as_ptr(&self) -> *const u8;\n@@ -1375,13 +1365,13 @@ fn slice_error_fail(s: &str, begin: usize, end: usize) -> ! {\n \n impl StrExt for str {\n     #[inline]\n-    fn contains(&self, needle: &str) -> bool {\n-        self.find_str(needle).is_some()\n+    fn contains<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        pat.is_contained_in(self)\n     }\n \n     #[inline]\n-    fn contains_char<P: CharEq>(&self, pat: P) -> bool {\n-        self.find(pat).is_some()\n+    fn contains_char<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        pat.is_contained_in(self)\n     }\n \n     #[inline]\n@@ -1400,18 +1390,18 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn split<P: CharEq>(&self, pat: P) -> Split<P> {\n+    fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n         Split(CharSplits {\n-            string: self,\n-            only_ascii: pat.only_ascii(),\n-            sep: pat,\n+            start: 0,\n+            end: self.len(),\n+            matcher: pat.into_searcher(self),\n             allow_trailing_empty: true,\n             finished: false,\n         })\n     }\n \n     #[inline]\n-    fn splitn<P: CharEq>(&self, count: usize, pat: P) -> SplitN<P> {\n+    fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1420,15 +1410,15 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn split_terminator<P: CharEq>(&self, pat: P) -> SplitTerminator<P> {\n+    fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n         SplitTerminator(CharSplits {\n             allow_trailing_empty: false,\n             ..self.split(pat).0\n         })\n     }\n \n     #[inline]\n-    fn rsplitn<P: CharEq>(&self, count: usize, pat: P) -> RSplitN<P> {\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n         RSplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n@@ -1437,22 +1427,14 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn match_indices<'a>(&'a self, sep: &'a str) -> MatchIndices<'a> {\n-        assert!(!sep.is_empty());\n-        MatchIndices {\n-            haystack: self,\n-            needle: sep,\n-            searcher: Searcher::new(self.as_bytes(), sep.as_bytes())\n-        }\n+    fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P> {\n+        MatchIndices(pat.into_searcher(self))\n     }\n \n     #[inline]\n-    fn split_str<'a>(&'a self, sep: &'a str) -> SplitStr<'a> {\n-        SplitStr {\n-            it: self.match_indices(sep),\n-            last_end: 0,\n-            finished: false\n-        }\n+    #[allow(deprecated) /* for SplitStr */ ]\n+    fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P> {\n+        SplitStr(self.split(pat))\n     }\n \n     #[inline]\n@@ -1500,54 +1482,69 @@ impl StrExt for str {\n     #[inline]\n     unsafe fn slice_unchecked(&self, begin: usize, end: usize) -> &str {\n         mem::transmute(Slice {\n-            data: self.as_ptr().offset(begin as isize),\n+            data: self.as_ptr().offset(begin as int),\n             len: end - begin,\n         })\n     }\n \n     #[inline]\n-    fn starts_with(&self, needle: &str) -> bool {\n-        let n = needle.len();\n-        self.len() >= n && needle.as_bytes() == &self.as_bytes()[..n]\n+    fn starts_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool {\n+        pat.is_prefix_of(self)\n     }\n \n     #[inline]\n-    fn ends_with(&self, needle: &str) -> bool {\n-        let (m, n) = (self.len(), needle.len());\n-        m >= n && needle.as_bytes() == &self.as_bytes()[m-n..]\n+    fn ends_with<'a, P: Pattern<'a>>(&'a self, pat: P) -> bool\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        pat.is_suffix_of(self)\n     }\n \n     #[inline]\n-    fn trim_matches<P: CharEq>(&self, mut pat: P) -> &str {\n-        let cur = match self.find(|c: char| !pat.matches(c)) {\n-            None => \"\",\n-            Some(i) => unsafe { self.slice_unchecked(i, self.len()) }\n-        };\n-        match cur.rfind(|c: char| !pat.matches(c)) {\n-            None => \"\",\n-            Some(i) => {\n-                let right = cur.char_range_at(i).next;\n-                unsafe { cur.slice_unchecked(0, right) }\n-            }\n+    fn trim_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: DoubleEndedSearcher<'a>\n+    {\n+        let mut i = 0;\n+        let mut j = 0;\n+        let mut matcher = pat.into_searcher(self);\n+        if let Some((a, b)) = matcher.next_reject() {\n+            i = a;\n+            j = b; // Rember earliest known match, correct it below if\n+                   // last match is different\n+        }\n+        if let Some((_, b)) = matcher.next_reject_back() {\n+            j = b;\n+        }\n+        unsafe {\n+            // Searcher is known to return valid indices\n+            self.slice_unchecked(i, j)\n         }\n     }\n \n     #[inline]\n-    fn trim_left_matches<P: CharEq>(&self, mut pat: P) -> &str {\n-        match self.find(|c: char| !pat.matches(c)) {\n-            None => \"\",\n-            Some(first) => unsafe { self.slice_unchecked(first, self.len()) }\n+    fn trim_left_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str {\n+        let mut i = self.len();\n+        let mut matcher = pat.into_searcher(self);\n+        if let Some((a, _)) = matcher.next_reject() {\n+            i = a;\n+        }\n+        unsafe {\n+            // Searcher is known to return valid indices\n+            self.slice_unchecked(i, self.len())\n         }\n     }\n \n     #[inline]\n-    fn trim_right_matches<P: CharEq>(&self, mut pat: P) -> &str {\n-        match self.rfind(|c: char| !pat.matches(c)) {\n-            None => \"\",\n-            Some(last) => {\n-                let next = self.char_range_at(last).next;\n-                unsafe { self.slice_unchecked(0, next) }\n-            }\n+    fn trim_right_matches<'a, P: Pattern<'a>>(&'a self, pat: P) -> &'a str\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        let mut j = 0;\n+        let mut matcher = pat.into_searcher(self);\n+        if let Some((_, b)) = matcher.next_reject_back() {\n+            j = b;\n+        }\n+        unsafe {\n+            // Searcher is known to return valid indices\n+            self.slice_unchecked(0, j)\n         }\n     }\n \n@@ -1612,36 +1609,18 @@ impl StrExt for str {\n         unsafe { mem::transmute(self) }\n     }\n \n-    fn find<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n-        if pat.only_ascii() {\n-            self.bytes().position(|b| pat.matches(b as char))\n-        } else {\n-            for (index, c) in self.char_indices() {\n-                if pat.matches(c) { return Some(index); }\n-            }\n-            None\n-        }\n+    fn find<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        pat.into_searcher(self).next_match().map(|(i, _)| i)\n     }\n \n-    fn rfind<P: CharEq>(&self, mut pat: P) -> Option<usize> {\n-        if pat.only_ascii() {\n-            self.bytes().rposition(|b| pat.matches(b as char))\n-        } else {\n-            for (index, c) in self.char_indices().rev() {\n-                if pat.matches(c) { return Some(index); }\n-            }\n-            None\n-        }\n+    fn rfind<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        pat.into_searcher(self).next_match_back().map(|(i, _)| i)\n     }\n \n-    fn find_str(&self, needle: &str) -> Option<usize> {\n-        if needle.is_empty() {\n-            Some(0)\n-        } else {\n-            self.match_indices(needle)\n-                .next()\n-                .map(|(start, _end)| start)\n-        }\n+    fn find_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> Option<usize> {\n+        self.find(pat)\n     }\n \n     #[inline]"}, {"sha": "1f669c66eb117aedc2717d8931d987f9de5af518", "filename": "src/libcore/str/pattern.rs", "status": "added", "additions": 495, "deletions": 0, "changes": 495, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -0,0 +1,495 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(deprecated) /* for CharEq */ ]\n+\n+use prelude::*;\n+use super::CharEq;\n+\n+// Pattern\n+\n+/// A string pattern.\n+///\n+/// A `Pattern<'a>` expresses that the implementing type\n+/// can be used as a string pattern for searching in a `&'a str`.\n+///\n+/// For example, both `'a'` and `\"aa\"` are patterns that\n+/// would match at index `1` in the string `\"baaaab\"`.\n+///\n+/// The trait itself acts as a builder for an associated\n+/// `Searcher` type, which does the actual work of finding\n+/// occurences of the pattern in a string.\n+pub trait Pattern<'a>: Sized {\n+    /// Associated searcher for this pattern\n+    type Searcher: Searcher<'a>;\n+\n+    /// Construct the associated searcher from\n+    /// `self` and the `haystack` to search in.\n+    fn into_searcher(self, haystack: &'a str) -> Self::Searcher;\n+\n+    /// Check whether the pattern matches anywhere in the haystack\n+    #[inline]\n+    fn is_contained_in(self, haystack: &'a str) -> bool {\n+        self.into_searcher(haystack).next_match().is_some()\n+    }\n+\n+    /// Check whether the pattern matches at the front of the haystack\n+    #[inline]\n+    fn is_prefix_of(self, haystack: &'a str) -> bool {\n+        match self.into_searcher(haystack).next() {\n+            SearchStep::Match(0, _) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    /// Check whether the pattern matches at the back of the haystack\n+    #[inline]\n+    fn is_suffix_of(self, haystack: &'a str) -> bool\n+        where Self::Searcher: ReverseSearcher<'a>\n+    {\n+        match self.into_searcher(haystack).next_back() {\n+            SearchStep::Match(_, j) if haystack.len() == j => true,\n+            _ => false,\n+        }\n+    }\n+}\n+\n+// Searcher\n+\n+/// Result of calling `Searcher::next()` or `ReverseSearcher::next_back()`.\n+#[derive(Copy, Clone, Eq, PartialEq, Debug)]\n+pub enum SearchStep {\n+    /// Expresses that a match of the pattern has been found at\n+    /// `haystack[a..b]`.\n+    Match(usize, usize),\n+    /// Expresses that `haystack[a..b]` has been rejected as a possible match\n+    /// of the pattern.\n+    ///\n+    /// Note that there might be more than one `Reject` betwen two `Match`es,\n+    /// there is no requirement for them to be combined into one.\n+    Reject(usize, usize),\n+    /// Expresses that every byte of the haystack has been visted, ending\n+    /// the iteration.\n+    Done\n+}\n+\n+/// A searcher for a string pattern.\n+///\n+/// This trait provides methods for searching for non-overlapping\n+/// matches of a pattern starting from the front (left) of a string.\n+///\n+/// It will be implemented by associated `Searcher`\n+/// types of the `Pattern` trait.\n+///\n+/// The trait is marked unsafe because the indices returned by the\n+/// `next()` methods are required to lie on valid utf8 boundaries in\n+/// the haystack. This enables consumers of this trait to\n+/// slice the haystack without additional runtime checks.\n+pub unsafe trait Searcher<'a> {\n+    /// Getter for the underlaying string to be searched in\n+    ///\n+    /// Will always return the same `&str`\n+    fn haystack(&self) -> &'a str;\n+\n+    /// Performs the next search step starting from the front.\n+    ///\n+    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n+    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n+    ///   pattern, even partially.\n+    /// - Returns `Done` if every byte of the haystack has been visited\n+    ///\n+    /// The stream of `Match` and `Reject` values up to a `Done`\n+    /// will contain index ranges that are adjacent, non-overlapping,\n+    /// covering the whole haystack, and laying on utf8 boundaries.\n+    ///\n+    /// A `Match` result needs to contain the whole matched pattern,\n+    /// however `Reject` results may be split up into arbitrary\n+    /// many adjacent fragments. Both ranges may have zero length.\n+    ///\n+    /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n+    /// might produce the stream\n+    /// `[Reject(0, 1), Reject(1, 2), Match(2, 5), Reject(5, 8)]`\n+    fn next(&mut self) -> SearchStep;\n+\n+    /// Find the next `Match` result. See `next()`\n+    #[inline]\n+    fn next_match(&mut self) -> Option<(usize, usize)> {\n+        loop {\n+            match self.next() {\n+                SearchStep::Match(a, b) => return Some((a, b)),\n+                SearchStep::Done => return None,\n+                _ => continue,\n+            }\n+        }\n+    }\n+\n+    /// Find the next `Reject` result. See `next()`\n+    #[inline]\n+    fn next_reject(&mut self) -> Option<(usize, usize)> {\n+        loop {\n+            match self.next() {\n+                SearchStep::Reject(a, b) => return Some((a, b)),\n+                SearchStep::Done => return None,\n+                _ => continue,\n+            }\n+        }\n+    }\n+}\n+\n+/// A reverse searcher for a string pattern.\n+///\n+/// This trait provides methods for searching for non-overlapping\n+/// matches of a pattern starting from the back (right) of a string.\n+///\n+/// It will be implemented by associated `Searcher`\n+/// types of the `Pattern` trait if the pattern supports searching\n+/// for it from the back.\n+///\n+/// The index ranges returned by this trait are not required\n+/// to exactly match those of the forward search in reverse.\n+///\n+/// For the reason why this trait is marked unsafe, see them\n+/// parent trait `Searcher`.\n+pub unsafe trait ReverseSearcher<'a>: Searcher<'a> {\n+    /// Performs the next search step starting from the back.\n+    ///\n+    /// - Returns `Match(a, b)` if `haystack[a..b]` matches the pattern.\n+    /// - Returns `Reject(a, b)` if `haystack[a..b]` can not match the\n+    ///   pattern, even partially.\n+    /// - Returns `Done` if every byte of the haystack has been visited\n+    ///\n+    /// The stream of `Match` and `Reject` values up to a `Done`\n+    /// will contain index ranges that are adjacent, non-overlapping,\n+    /// covering the whole haystack, and laying on utf8 boundaries.\n+    ///\n+    /// A `Match` result needs to contain the whole matched pattern,\n+    /// however `Reject` results may be split up into arbitrary\n+    /// many adjacent fragments. Both ranges may have zero length.\n+    ///\n+    /// As an example, the pattern `\"aaa\"` and the haystack `\"cbaaaaab\"`\n+    /// might produce the stream\n+    /// `[Reject(7, 8), Match(4, 7), Reject(1, 4), Reject(0, 1)]`\n+    fn next_back(&mut self) -> SearchStep;\n+\n+    /// Find the next `Match` result. See `next_back()`\n+    #[inline]\n+    fn next_match_back(&mut self) -> Option<(usize, usize)>{\n+        loop {\n+            match self.next_back() {\n+                SearchStep::Match(a, b) => return Some((a, b)),\n+                SearchStep::Done => return None,\n+                _ => continue,\n+            }\n+        }\n+    }\n+\n+    /// Find the next `Reject` result. See `next_back()`\n+    #[inline]\n+    fn next_reject_back(&mut self) -> Option<(usize, usize)>{\n+        loop {\n+            match self.next_back() {\n+                SearchStep::Reject(a, b) => return Some((a, b)),\n+                SearchStep::Done => return None,\n+                _ => continue,\n+            }\n+        }\n+    }\n+}\n+\n+/// A marker trait to express that a `ReverseSearcher`\n+/// can be used for a `DoubleEndedIterator` implementation.\n+///\n+/// For this, the impl of `Searcher` and `ReverseSearcher` need\n+/// to follow these conditions:\n+///\n+/// - All results of `next()` need to be identical\n+///   to the results of `next_back()` in reverse order.\n+/// - `next()` and `next_back()` need to behave as\n+///   the two ends of a range of values, that is they\n+///   can not \"walk past each other\".\n+///\n+/// # Example\n+///\n+/// `char::Searcher` is a `DoubleEndedSearcher` because searching for a\n+/// `char` only requires looking at one at a time, which behaves the same\n+/// from both ends.\n+///\n+/// `(&str)::Searcher` is not a `DoubleEndedSearcher` because\n+/// the pattern `\"aa\"` in the haystack `\"aaa\"` matches as either\n+/// `\"[aa]a\"` or `\"a[aa]\"`, depending from which side it is searched.\n+pub trait DoubleEndedSearcher<'a>: ReverseSearcher<'a> {}\n+\n+// Impl for a CharEq wrapper\n+\n+struct CharEqPattern<C: CharEq>(C);\n+\n+struct CharEqSearcher<'a, C: CharEq> {\n+    char_eq: C,\n+    haystack: &'a str,\n+    char_indices: super::CharIndices<'a>,\n+    #[allow(dead_code)]\n+    ascii_only: bool,\n+}\n+\n+impl<'a, C: CharEq> Pattern<'a> for CharEqPattern<C> {\n+    type Searcher = CharEqSearcher<'a, C>;\n+\n+    #[inline]\n+    fn into_searcher(self, haystack: &'a str) -> CharEqSearcher<'a, C> {\n+        CharEqSearcher {\n+            ascii_only: self.0.only_ascii(),\n+            haystack: haystack,\n+            char_eq: self.0,\n+            char_indices: haystack.char_indices(),\n+        }\n+    }\n+}\n+\n+unsafe impl<'a, C: CharEq> Searcher<'a> for CharEqSearcher<'a, C> {\n+    #[inline]\n+    fn haystack(&self) -> &'a str {\n+        self.haystack\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> SearchStep {\n+        let s = &mut self.char_indices;\n+        // Compare lengths of the internal byte slice iterator\n+        // to find length of current char\n+        let (pre_len, _) = s.iter.iter.size_hint();\n+        if let Some((i, c)) = s.next() {\n+            let (len, _) = s.iter.iter.size_hint();\n+            let char_len = pre_len - len;\n+            if self.char_eq.matches(c) {\n+                return SearchStep::Match(i, i + char_len);\n+            } else {\n+                return SearchStep::Reject(i, i + char_len);\n+            }\n+        }\n+        SearchStep::Done\n+    }\n+}\n+\n+unsafe impl<'a, C: CharEq> ReverseSearcher<'a> for CharEqSearcher<'a, C> {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep {\n+        let s = &mut self.char_indices;\n+        // Compare lengths of the internal byte slice iterator\n+        // to find length of current char\n+        let (pre_len, _) = s.iter.iter.size_hint();\n+        if let Some((i, c)) = s.next_back() {\n+            let (len, _) = s.iter.iter.size_hint();\n+            let char_len = pre_len - len;\n+            if self.char_eq.matches(c) {\n+                return SearchStep::Match(i, i + char_len);\n+            } else {\n+                return SearchStep::Reject(i, i + char_len);\n+            }\n+        }\n+        SearchStep::Done\n+    }\n+}\n+\n+impl<'a, C: CharEq> DoubleEndedSearcher<'a> for CharEqSearcher<'a, C> {}\n+\n+// Impl for &str\n+\n+// Todo: Optimize the naive implementation here\n+\n+#[derive(Clone)]\n+struct StrSearcher<'a, 'b> {\n+    haystack: &'a str,\n+    needle: &'b str,\n+    start: usize,\n+    end: usize,\n+    done: bool,\n+}\n+\n+/// Non-allocating substring search.\n+///\n+/// Will handle the pattern `\"\"` as returning empty matches at each utf8\n+/// boundary.\n+impl<'a, 'b> Pattern<'a> for &'b str {\n+    type Searcher = StrSearcher<'a, 'b>;\n+\n+    #[inline]\n+    fn into_searcher(self, haystack: &'a str) -> StrSearcher<'a, 'b> {\n+        StrSearcher {\n+            haystack: haystack,\n+            needle: self,\n+            start: 0,\n+            end: haystack.len(),\n+            done: false,\n+        }\n+    }\n+}\n+\n+unsafe impl<'a, 'b> Searcher<'a> for StrSearcher<'a, 'b>  {\n+    #[inline]\n+    fn haystack(&self) -> &'a str {\n+        self.haystack\n+    }\n+\n+    #[inline]\n+    fn next(&mut self) -> SearchStep {\n+        str_search_step(self,\n+        |m: &mut StrSearcher| {\n+            // Forward step for empty needle\n+            let current_start = m.start;\n+            if !m.done {\n+                m.start = m.haystack.char_range_at(current_start).next;\n+            }\n+            SearchStep::Match(current_start, current_start)\n+        },\n+        |m: &mut StrSearcher| {\n+            // Forward step for nonempty needle\n+            let current_start = m.start;\n+            // Compare byte window because this might break utf8 boundaries\n+            let possible_match = &m.haystack.as_bytes()[m.start .. m.start + m.needle.len()];\n+            if possible_match == m.needle.as_bytes() {\n+                m.start += m.needle.len();\n+                SearchStep::Match(current_start, m.start)\n+            } else {\n+                // Skip a char\n+                let haystack_suffix = &m.haystack[m.start..];\n+                m.start += haystack_suffix.chars().next().unwrap().len_utf8();\n+                SearchStep::Reject(current_start, m.start)\n+            }\n+        })\n+    }\n+}\n+\n+unsafe impl<'a, 'b> ReverseSearcher<'a> for StrSearcher<'a, 'b>  {\n+    #[inline]\n+    fn next_back(&mut self) -> SearchStep {\n+        str_search_step(self,\n+        |m: &mut StrSearcher| {\n+            // Backward step for empty needle\n+            let current_end = m.end;\n+            if !m.done {\n+                m.end = m.haystack.char_range_at_reverse(current_end).next;\n+            }\n+            SearchStep::Match(current_end, current_end)\n+        },\n+        |m: &mut StrSearcher| {\n+            // Backward step for nonempty needle\n+            let current_end = m.end;\n+            // Compare byte window because this might break utf8 boundaries\n+            let possible_match = &m.haystack.as_bytes()[m.end - m.needle.len() .. m.end];\n+            if possible_match == m.needle.as_bytes() {\n+                m.end -= m.needle.len();\n+                SearchStep::Match(m.end, current_end)\n+            } else {\n+                // Skip a char\n+                let haystack_prefix = &m.haystack[..m.end];\n+                m.end -= haystack_prefix.chars().rev().next().unwrap().len_utf8();\n+                SearchStep::Reject(m.end, current_end)\n+            }\n+        })\n+    }\n+}\n+\n+// Helper function for encapsulating the common control flow\n+// of doing a search step from the front or doing a search step from the back\n+fn str_search_step<F, G>(mut m: &mut StrSearcher,\n+                         empty_needle_step: F,\n+                         nonempty_needle_step: G) -> SearchStep\n+    where F: FnOnce(&mut StrSearcher) -> SearchStep,\n+          G: FnOnce(&mut StrSearcher) -> SearchStep\n+{\n+    if m.done {\n+        SearchStep::Done\n+    } else if m.needle.len() == 0 && m.start <= m.end {\n+        // Case for needle == \"\"\n+        if m.start == m.end {\n+            m.done = true;\n+        }\n+        empty_needle_step(&mut m)\n+    } else if m.start + m.needle.len() <= m.end {\n+        // Case for needle != \"\"\n+        nonempty_needle_step(&mut m)\n+    } else if m.start < m.end {\n+        // Remaining slice shorter than needle, reject it\n+        m.done = true;\n+        SearchStep::Reject(m.start, m.end)\n+    } else {\n+        m.done = true;\n+        SearchStep::Done\n+    }\n+}\n+\n+macro_rules! associated_items {\n+    ($t:ty, $s:ident, $e:expr) => {\n+        // FIXME: #22463\n+        //type Searcher = $t;\n+\n+        fn into_searcher(self, haystack: &'a str) -> $t {\n+            let $s = self;\n+            $e.into_searcher(haystack)\n+        }\n+\n+        #[inline]\n+        fn is_contained_in(self, haystack: &'a str) -> bool {\n+            let $s = self;\n+            $e.is_contained_in(haystack)\n+        }\n+\n+        #[inline]\n+        fn is_prefix_of(self, haystack: &'a str) -> bool {\n+            let $s = self;\n+            $e.is_prefix_of(haystack)\n+        }\n+\n+        // FIXME: #21750\n+        /*#[inline]\n+        fn is_suffix_of(self, haystack: &'a str) -> bool\n+            where $t: ReverseSearcher<'a>\n+        {\n+            let $s = self;\n+            $e.is_suffix_of(haystack)\n+        }*/\n+    }\n+}\n+\n+// CharEq delegation impls\n+\n+/// Searches for chars that are equal to a given char\n+impl<'a> Pattern<'a> for char {\n+    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n+    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n+                      s, CharEqPattern(s));\n+}\n+\n+/// Searches for chars that are equal to any of the chars in the array\n+impl<'a, 'b> Pattern<'a> for &'b [char] {\n+    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n+    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n+                      s, CharEqPattern(s));\n+}\n+\n+/// Searches for chars that match the given predicate\n+impl<'a, F> Pattern<'a> for F where F: FnMut(char) -> bool {\n+    type Searcher =   <CharEqPattern<Self> as Pattern<'a>>::Searcher;\n+    associated_items!(<CharEqPattern<Self> as Pattern<'a>>::Searcher,\n+                      s, CharEqPattern(s));\n+}\n+\n+// Deref-forward impl\n+\n+use ops::Deref;\n+\n+/// Delegates to the next deref coercion of `Self` that implements `Pattern`\n+impl<'a, 'b, P: 'b + ?Sized, T: Deref<Target = P> + ?Sized> Pattern<'a> for &'b T\n+    where &'b P: Pattern<'a>\n+{\n+    type Searcher =   <&'b P as Pattern<'a>>::Searcher;\n+    associated_items!(<&'b P as Pattern<'a>>::Searcher,\n+                      s, (&**s));\n+}"}, {"sha": "beb746d25b61cf81a9b0f2d80bdd0b5383de7cd4", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 267, "deletions": 1, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,23 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[test]\n+fn test_pattern_deref_forward() {\n+    let data = \"aabcdaa\";\n+    assert!(data.contains(\"bcd\"));\n+    assert!(data.contains(&\"bcd\"));\n+    assert!(data.contains(&&\"bcd\"));\n+    assert!(data.contains(&\"bcd\".to_string()));\n+    assert!(data.contains(&&\"bcd\".to_string()));\n+}\n+\n+#[test]\n+fn test_empty_match_indices() {\n+    let data = \"a\u00e4\u4e2d!\";\n+    let vec: Vec<_> = data.match_indices(\"\").collect();\n+    assert_eq!(vec, vec![(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n+}\n+\n #[test]\n fn test_bool_from_str() {\n     assert_eq!(\"true\".parse().ok(), Some(true));\n@@ -121,3 +138,252 @@ fn test_utf16_code_units() {\n     assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n                vec![0xE9, 0xD83D, 0xDCA9])\n }\n+\n+#[test]\n+fn starts_with_in_unicode() {\n+    assert!(!\"\u251c\u2500\u2500 Cargo.toml\".starts_with(\"# \"));\n+}\n+\n+#[test]\n+fn starts_short_long() {\n+    assert!(!\"\".starts_with(\"##\"));\n+    assert!(!\"##\".starts_with(\"####\"));\n+    assert!(\"####\".starts_with(\"##\"));\n+    assert!(!\"##\u00e4\".starts_with(\"####\"));\n+    assert!(\"####\u00e4\".starts_with(\"##\"));\n+    assert!(!\"##\".starts_with(\"####\u00e4\"));\n+    assert!(\"##\u00e4##\".starts_with(\"##\u00e4\"));\n+\n+    assert!(\"\".starts_with(\"\"));\n+    assert!(\"\u00e4\".starts_with(\"\"));\n+    assert!(\"#\u00e4\".starts_with(\"\"));\n+    assert!(\"##\u00e4\".starts_with(\"\"));\n+    assert!(\"\u00e4###\".starts_with(\"\"));\n+    assert!(\"#\u00e4##\".starts_with(\"\"));\n+    assert!(\"##\u00e4#\".starts_with(\"\"));\n+}\n+\n+#[test]\n+fn contains_weird_cases() {\n+    assert!(\"* \\t\".contains_char(' '));\n+    assert!(!\"* \\t\".contains_char('?'));\n+    assert!(!\"* \\t\".contains_char('\\u{1F4A9}'));\n+}\n+\n+#[test]\n+fn trim_ws() {\n+    assert_eq!(\" \\t  a \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+                    \"a \\t  \");\n+    assert_eq!(\" \\t  a \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+               \" \\t  a\");\n+    assert_eq!(\" \\t  a \\t  \".trim_matches(|c: char| c.is_whitespace()),\n+                    \"a\");\n+    assert_eq!(\" \\t   \\t  \".trim_left_matches(|c: char| c.is_whitespace()),\n+                         \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_right_matches(|c: char| c.is_whitespace()),\n+               \"\");\n+    assert_eq!(\" \\t   \\t  \".trim_matches(|c: char| c.is_whitespace()),\n+               \"\");\n+}\n+\n+mod pattern {\n+    use std::str::Pattern;\n+    use std::str::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n+    use std::str::SearchStep::{self, Match, Reject, Done};\n+\n+    macro_rules! make_test {\n+        ($name:ident, $p:expr, $h:expr, [$($e:expr,)*]) => {\n+            mod $name {\n+                use std::str::Pattern;\n+                use std::str::{Searcher, ReverseSearcher, DoubleEndedSearcher};\n+                use std::str::SearchStep::{self, Match, Reject, Done};\n+                use super::{cmp_search_to_vec};\n+                #[test]\n+                fn fwd() {\n+                    cmp_search_to_vec(false, $p, $h, vec![$($e),*]);\n+                }\n+                #[test]\n+                fn bwd() {\n+                    cmp_search_to_vec(true, $p, $h, vec![$($e),*]);\n+                }\n+            }\n+        }\n+    }\n+\n+    fn cmp_search_to_vec<'a, P: Pattern<'a>>(rev: bool, pat: P, haystack: &'a str,\n+                                             right: Vec<SearchStep>)\n+    where P::Searcher: ReverseSearcher<'a>\n+    {\n+        let mut searcher = pat.into_searcher(haystack);\n+        let mut v = vec![];\n+        loop {\n+            match if !rev {searcher.next()} else {searcher.next_back()} {\n+                Match(a, b) => v.push(Match(a, b)),\n+                Reject(a, b) => v.push(Reject(a, b)),\n+                Done => break,\n+            }\n+        }\n+        if rev {\n+            v.reverse();\n+        }\n+        assert_eq!(v, right);\n+    }\n+\n+    make_test!(str_searcher_ascii_haystack, \"bb\", \"abbcbbd\", [\n+        Reject(0, 1),\n+        Match (1, 3),\n+        Reject(3, 4),\n+        Match (4, 6),\n+        Reject(6, 7),\n+    ]);\n+    make_test!(str_searcher_empty_needle_ascii_haystack, \"\", \"abbcbbd\", [\n+        Match(0, 0),\n+        Match(1, 1),\n+        Match(2, 2),\n+        Match(3, 3),\n+        Match(4, 4),\n+        Match(5, 5),\n+        Match(6, 6),\n+        Match(7, 7),\n+    ]);\n+    make_test!(str_searcher_mulibyte_haystack, \" \", \"\u251c\u2500\u2500\", [\n+        Reject(0, 3),\n+        Reject(3, 6),\n+        Reject(6, 9),\n+    ]);\n+    make_test!(str_searcher_empty_needle_mulibyte_haystack, \"\", \"\u251c\u2500\u2500\", [\n+        Match(0, 0),\n+        Match(3, 3),\n+        Match(6, 6),\n+        Match(9, 9),\n+    ]);\n+    make_test!(str_searcher_empty_needle_empty_haystack, \"\", \"\", [\n+        Match(0, 0),\n+    ]);\n+    make_test!(str_searcher_nonempty_needle_empty_haystack, \"\u251c\", \"\", [\n+    ]);\n+    make_test!(char_searcher_ascii_haystack, 'b', \"abbcbbd\", [\n+        Reject(0, 1),\n+        Match (1, 2),\n+        Match (2, 3),\n+        Reject(3, 4),\n+        Match (4, 5),\n+        Match (5, 6),\n+        Reject(6, 7),\n+    ]);\n+    make_test!(char_searcher_mulibyte_haystack, ' ', \"\u251c\u2500\u2500\", [\n+        Reject(0, 3),\n+        Reject(3, 6),\n+        Reject(6, 9),\n+    ]);\n+    make_test!(char_searcher_short_haystack, '\\u{1F4A9}', \"* \\t\", [\n+        Reject(0, 1),\n+        Reject(1, 2),\n+        Reject(2, 3),\n+    ]);\n+\n+}\n+\n+mod bench {\n+    macro_rules! make_test_inner {\n+        ($s:ident, $code:expr, $name:ident, $str:expr) => {\n+            #[bench]\n+            fn $name(bencher: &mut Bencher) {\n+                let mut $s = $str;\n+                black_box(&mut $s);\n+                bencher.iter(|| $code);\n+            }\n+        }\n+    }\n+\n+    macro_rules! make_test {\n+        ($name:ident, $s:ident, $code:expr) => {\n+            mod $name {\n+                use test::Bencher;\n+                use test::black_box;\n+\n+                // Short strings: 65 bytes each\n+                make_test_inner!($s, $code, short_ascii,\n+                    \"Mary had a little lamb, Little lamb Mary had a littl lamb, lamb!\");\n+                make_test_inner!($s, $code, short_mixed,\n+                    \"\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam; Mary had a little lamb, Little lam!\");\n+                make_test_inner!($s, $code, short_pile_of_poo,\n+                    \"\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9\ud83d\udca9!\");\n+                make_test_inner!($s, $code, long_lorem_ipsum,\"\\\n+Lorem ipsum dolor sit amet, consectetur adipiscing elit. Suspendisse quis lorem sit amet dolor \\\n+ultricies condimentum. Praesent iaculis purus elit, ac malesuada quam malesuada in. Duis sed orci \\\n+eros. Suspendisse sit amet magna mollis, mollis nunc luctus, imperdiet mi. Integer fringilla non \\\n+sem ut lacinia. Fusce varius tortor a risus porttitor hendrerit. Morbi mauris dui, ultricies nec \\\n+tempus vel, gravida nec quam.\n+\n+In est dui, tincidunt sed tempus interdum, adipiscing laoreet ante. Etiam tempor, tellus quis \\\n+sagittis interdum, nulla purus mattis sem, quis auctor erat odio ac tellus. In nec nunc sit amet \\\n+diam volutpat molestie at sed ipsum. Vestibulum laoreet consequat vulputate. Integer accumsan \\\n+lorem ac dignissim placerat. Suspendisse convallis faucibus lorem. Aliquam erat volutpat. In vel \\\n+eleifend felis. Sed suscipit nulla lorem, sed mollis est sollicitudin et. Nam fermentum egestas \\\n+interdum. Curabitur ut nisi justo.\n+\n+Sed sollicitudin ipsum tellus, ut condimentum leo eleifend nec. Cras ut velit ante. Phasellus nec \\\n+mollis odio. Mauris molestie erat in arcu mattis, at aliquet dolor vehicula. Quisque malesuada \\\n+lectus sit amet nisi pretium, a condimentum ipsum porta. Morbi at dapibus diam. Praesent egestas \\\n+est sed risus elementum, eu rutrum metus ultrices. Etiam fermentum consectetur magna, id rutrum \\\n+felis accumsan a. Aliquam ut pellentesque libero. Sed mi nulla, lobortis eu tortor id, suscipit \\\n+ultricies neque. Morbi iaculis sit amet risus at iaculis. Praesent eget ligula quis turpis \\\n+feugiat suscipit vel non arcu. Interdum et malesuada fames ac ante ipsum primis in faucibus. \\\n+Aliquam sit amet placerat lorem.\n+\n+Cras a lacus vel ante posuere elementum. Nunc est leo, bibendum ut facilisis vel, bibendum at \\\n+mauris. Nullam adipiscing diam vel odio ornare, luctus adipiscing mi luctus. Nulla facilisi. \\\n+Mauris adipiscing bibendum neque, quis adipiscing lectus tempus et. Sed feugiat erat et nisl \\\n+lobortis pharetra. Donec vitae erat enim. Nullam sit amet felis et quam lacinia tincidunt. Aliquam \\\n+suscipit dapibus urna. Sed volutpat urna in magna pulvinar volutpat. Phasellus nec tellus ac diam \\\n+cursus accumsan.\n+\n+Nam lectus enim, dapibus non nisi tempor, consectetur convallis massa. Maecenas eleifend dictum \\\n+feugiat. Etiam quis mauris vel risus luctus mattis a a nunc. Nullam orci quam, imperdiet id \\\n+vehicula in, porttitor ut nibh. Duis sagittis adipiscing nisl vitae congue. Donec mollis risus eu \\\n+leo suscipit, varius porttitor nulla porta. Pellentesque ut sem nec nisi euismod vehicula. Nulla \\\n+malesuada sollicitudin quam eu fermentum!\");\n+            }\n+        }\n+    }\n+\n+    make_test!(chars_count, s, s.chars().count());\n+\n+    make_test!(contains_bang_str, s, s.contains(\"!\"));\n+    make_test!(contains_bang_char, s, s.contains_char('!'));\n+\n+    make_test!(match_indices_a_str, s, s.match_indices(\"a\").count());\n+\n+    make_test!(split_str_a_str, s, s.split_str(\"a\").count());\n+\n+    make_test!(trim_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_matches(|c: char| c.is_ascii())\n+    });\n+    make_test!(trim_left_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_left_matches(|c: char| c.is_ascii())\n+    });\n+    make_test!(trim_right_ascii_char, s, {\n+        use std::ascii::AsciiExt;\n+        s.trim_right_matches(|c: char| c.is_ascii())\n+    });\n+\n+    make_test!(find_underscore_char, s, s.find('_'));\n+    make_test!(rfind_underscore_char, s, s.rfind('_'));\n+    make_test!(find_underscore_str, s, s.find_str(\"_\"));\n+\n+    make_test!(find_zzz_char, s, s.find('\\u{1F4A4}'));\n+    make_test!(rfind_zzz_char, s, s.rfind('\\u{1F4A4}'));\n+    make_test!(find_zzz_str, s, s.find_str(\"\\u{1F4A4}\"));\n+\n+    make_test!(split_space_char, s, s.split(' ').count());\n+    make_test!(split_terminator_space_char, s, s.split_terminator(' ').count());\n+\n+    make_test!(splitn_space_char, s, s.splitn(10, ' ').count());\n+    make_test!(rsplitn_space_char, s, s.rsplitn(10, ' ').count());\n+\n+    make_test!(split_str_space_str, s, s.split_str(\" \").count());\n+    make_test!(split_str_ad_str, s, s.split_str(\"ad\").count());\n+}"}, {"sha": "09fbf4935e4c1e7a86ade0c5bdb543854bb313a8", "filename": "src/libgraphviz/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibgraphviz%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibgraphviz%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgraphviz%2Flib.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -463,7 +463,7 @@ impl<'a> LabelText<'a> {\n     fn pre_escaped_content(self) -> Cow<'a, str> {\n         match self {\n             EscStr(s) => s,\n-            LabelStr(s) => if s.contains_char('\\\\') {\n+            LabelStr(s) => if s.contains('\\\\') {\n                 (&*s).escape_default().into_cow()\n             } else {\n                 s"}, {"sha": "3c06bae177cef775de6d2c8fc64062985a98b4e1", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -784,7 +784,7 @@ impl NonCamelCaseTypes {\n \n             // start with a non-lowercase letter rather than non-uppercase\n             // ones (some scripts don't have a concept of upper/lowercase)\n-            ident.len() > 0 && !ident.char_at(0).is_lowercase() && !ident.contains_char('_')\n+            ident.len() > 0 && !ident.char_at(0).is_lowercase() && !ident.contains('_')\n         }\n \n         fn to_camel_case(s: &str) -> String {"}, {"sha": "d63b3dd60d01d31222ecc4ccc0e15956813ef692", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -219,7 +219,7 @@ pub fn rust_path() -> Vec<Path> {\n     let mut env_rust_path: Vec<Path> = match get_rust_path() {\n         Some(env_path) => {\n             let env_path_components =\n-                env_path.split_str(PATH_ENTRY_SEPARATOR);\n+                env_path.split(PATH_ENTRY_SEPARATOR);\n             env_path_components.map(|s| Path::new(s)).collect()\n         }\n         None => Vec::new()"}, {"sha": "43cd1fc8edbac83b87300390c0678087cb335dee", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -90,7 +90,7 @@ pub fn maybe_print_constraints_for<'a, 'tcx>(region_vars: &RegionVarBindings<'a,\n             tcx.sess.bug(\"empty string provided as RUST_REGION_GRAPH\");\n         }\n \n-        if output_template.contains_char('%') {\n+        if output_template.contains('%') {\n             let mut new_str = String::new();\n             for c in output_template.chars() {\n                 if c == '%' {"}, {"sha": "b690cc7f7d06b2685e20e21d59e732f4742c989d", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -280,9 +280,9 @@ fn split_msg_into_multilines(msg: &str) -> Option<String> {\n     }\n \n     let mut tail = &msg[head..];\n-    let third = tail.find_str(\"(values differ\")\n-                   .or(tail.find_str(\"(lifetime\"))\n-                   .or(tail.find_str(\"(cyclic type of infinite size\"));\n+    let third = tail.find(\"(values differ\")\n+                   .or(tail.find(\"(lifetime\"))\n+                   .or(tail.find(\"(cyclic type of infinite size\"));\n     // Insert `\\n` before any remaining messages which match.\n     if let Some(pos) = third {\n         // The end of the message may just be wrapped in `()` without"}, {"sha": "22473099baf60311fbe59b6e505a56a84e4ad35d", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -348,7 +348,7 @@ impl FromStr for UserIdentifiedItem {\n     type Err = ();\n     fn from_str(s: &str) -> Result<UserIdentifiedItem, ()> {\n         Ok(s.parse().map(ItemViaNode).unwrap_or_else(|_| {\n-            ItemViaPath(s.split_str(\"::\").map(|s| s.to_string()).collect())\n+            ItemViaPath(s.split(\"::\").map(|s| s.to_string()).collect())\n         }))\n     }\n }"}, {"sha": "735487611dc50d522a13a2ae0ebf4b67e0fc50e6", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -1469,7 +1469,7 @@ fn full_path(cx: &Context, item: &clean::Item) -> String {\n \n fn shorter<'a>(s: Option<&'a str>) -> &'a str {\n     match s {\n-        Some(s) => match s.find_str(\"\\n\\n\") {\n+        Some(s) => match s.find(\"\\n\\n\") {\n             Some(pos) => &s[..pos],\n             None => s,\n         },"}, {"sha": "31a8cbe572a0318d60d8c0afb8f2c710d205cd11", "filename": "src/libstd/old_path/windows.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibstd%2Fold_path%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibstd%2Fold_path%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_path%2Fwindows.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -507,7 +507,7 @@ impl GenericPath for Path {\n \n     fn path_relative_from(&self, base: &Path) -> Option<Path> {\n         fn comp_requires_verbatim(s: &str) -> bool {\n-            s == \".\" || s == \"..\" || s.contains_char(SEP2)\n+            s == \".\" || s == \"..\" || s.contains(SEP2)\n         }\n \n         if !self.equiv_prefix(base) {"}, {"sha": "7a5d75581a511447cf5cd4c16950f2c80dadaf38", "filename": "src/libsyntax/parse/lexer/comments.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -92,7 +92,7 @@ pub fn strip_doc_comment_decoration(comment: &str) -> String {\n         let mut first = true;\n         for line in &lines {\n             for (j, c) in line.chars().enumerate() {\n-                if j > i || !\"* \\t\".contains_char(c) {\n+                if j > i || !\"* \\t\".contains(c) {\n                     can_trim = false;\n                     break;\n                 }\n@@ -264,7 +264,7 @@ fn read_block_comment(rdr: &mut StringReader,\n         if is_block_doc_comment(&curr_line[..]) {\n             return\n         }\n-        assert!(!curr_line.contains_char('\\n'));\n+        assert!(!curr_line.contains('\\n'));\n         lines.push(curr_line);\n     } else {\n         let mut level: isize = 1;"}, {"sha": "f43b09ddb9de8cbaaa12585b26b8a764cf05d3b0", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -2496,7 +2496,7 @@ impl<'a> Parser<'a> {\n                     let fstr = n.as_str();\n                     self.span_err(last_span,\n                                   &format!(\"unexpected token: `{}`\", n.as_str()));\n-                    if fstr.chars().all(|x| \"0123456789.\".contains_char(x)) {\n+                    if fstr.chars().all(|x| \"0123456789.\".contains(x)) {\n                         let float = match fstr.parse::<f64>().ok() {\n                             Some(f) => f,\n                             None => continue,"}, {"sha": "38cbe5c7dea16218d1942fc7eef3f9e70406dc18", "filename": "src/libunicode/u_str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibunicode%2Fu_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67eb38ee4cfd7b28f8498b5b6492da172768dcb9/src%2Flibunicode%2Fu_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fu_str.rs?ref=67eb38ee4cfd7b28f8498b5b6492da172768dcb9", "patch": "@@ -84,7 +84,7 @@ impl UnicodeStr for str {\n \n     #[inline]\n     fn trim(&self) -> &str {\n-        self.trim_left().trim_right()\n+        self.trim_matches(|c: char| c.is_whitespace())\n     }\n \n     #[inline]"}]}