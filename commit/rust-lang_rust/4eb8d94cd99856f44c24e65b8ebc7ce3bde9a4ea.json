{"sha": "4eb8d94cd99856f44c24e65b8ebc7ce3bde9a4ea", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRlYjhkOTRjZDk5ODU2ZjQ0YzI0ZTY1YjhlYmM3Y2UzYmRlOWE0ZWE=", "commit": {"author": {"name": "Bruno Dutra", "email": "brunocodutra@gmail.com", "date": "2018-08-26T16:47:42Z"}, "committer": {"name": "Bruno Dutra", "email": "brunocodutra@gmail.com", "date": "2018-09-03T18:02:35Z"}, "message": "Add a convenience macro to reduce code duplication", "tree": {"sha": "963465e739fdbd713d369f9ebc93e40eba4bcace", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/963465e739fdbd713d369f9ebc93e40eba4bcace"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4eb8d94cd99856f44c24e65b8ebc7ce3bde9a4ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4eb8d94cd99856f44c24e65b8ebc7ce3bde9a4ea", "html_url": "https://github.com/rust-lang/rust/commit/4eb8d94cd99856f44c24e65b8ebc7ce3bde9a4ea", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4eb8d94cd99856f44c24e65b8ebc7ce3bde9a4ea/comments", "author": {"login": "brunocodutra", "id": 4043663, "node_id": "MDQ6VXNlcjQwNDM2NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4043663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunocodutra", "html_url": "https://github.com/brunocodutra", "followers_url": "https://api.github.com/users/brunocodutra/followers", "following_url": "https://api.github.com/users/brunocodutra/following{/other_user}", "gists_url": "https://api.github.com/users/brunocodutra/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunocodutra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunocodutra/subscriptions", "organizations_url": "https://api.github.com/users/brunocodutra/orgs", "repos_url": "https://api.github.com/users/brunocodutra/repos", "events_url": "https://api.github.com/users/brunocodutra/events{/privacy}", "received_events_url": "https://api.github.com/users/brunocodutra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brunocodutra", "id": 4043663, "node_id": "MDQ6VXNlcjQwNDM2NjM=", "avatar_url": "https://avatars.githubusercontent.com/u/4043663?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brunocodutra", "html_url": "https://github.com/brunocodutra", "followers_url": "https://api.github.com/users/brunocodutra/followers", "following_url": "https://api.github.com/users/brunocodutra/following{/other_user}", "gists_url": "https://api.github.com/users/brunocodutra/gists{/gist_id}", "starred_url": "https://api.github.com/users/brunocodutra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brunocodutra/subscriptions", "organizations_url": "https://api.github.com/users/brunocodutra/orgs", "repos_url": "https://api.github.com/users/brunocodutra/repos", "events_url": "https://api.github.com/users/brunocodutra/events{/privacy}", "received_events_url": "https://api.github.com/users/brunocodutra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0a84ff07bd13a1c2261b4f2db2e1042487431dfe", "url": "https://api.github.com/repos/rust-lang/rust/commits/0a84ff07bd13a1c2261b4f2db2e1042487431dfe", "html_url": "https://github.com/rust-lang/rust/commit/0a84ff07bd13a1c2261b4f2db2e1042487431dfe"}], "stats": {"total": 200, "additions": 86, "deletions": 114}, "files": [{"sha": "02b3c696e1f898fd09d55a0aefb67c9589000650", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 86, "deletions": 114, "changes": 200, "blob_url": "https://github.com/rust-lang/rust/blob/4eb8d94cd99856f44c24e65b8ebc7ce3bde9a4ea/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4eb8d94cd99856f44c24e65b8ebc7ce3bde9a4ea/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=4eb8d94cd99856f44c24e65b8ebc7ce3bde9a4ea", "patch": "@@ -14,16 +14,60 @@ use super::eval_context::{LocalValue, StackPopCleanup};\n use super::{Frame, Memory, Machine, Operand, MemPlace, Place, Value};\n \n trait SnapshotContext<'a> {\n-    type To;\n-    type From;\n-    fn resolve(&'a self, id: &Self::From) -> Option<&'a Self::To>;\n+    fn resolve(&'a self, id: &AllocId) -> Option<&'a Allocation>;\n }\n \n trait Snapshot<'a, Ctx: SnapshotContext<'a>> {\n     type Item;\n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item;\n }\n \n+macro_rules! __impl_snapshot_field {\n+    ($field:ident, $ctx:expr) => ($field.snapshot($ctx));\n+    ($field:ident, $ctx:expr, $delegate:expr) => ($delegate);\n+}\n+\n+macro_rules! impl_snapshot_for {\n+    // FIXME(mark-i-m): Some of these should be `?` rather than `*`.\n+    (enum $enum_name:ident { $( $variant:ident $( ( $($field:ident $(-> $delegate:expr)*),* ) )* ),* $(,)* }) => {\n+        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $enum_name\n+            where Ctx: self::SnapshotContext<'a>,\n+        {\n+            type Item = $enum_name<AllocIdSnapshot<'a>>;\n+\n+            #[inline]\n+            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n+                match *self {\n+                    $(\n+                        $enum_name::$variant $( ( $(ref $field),* ) )* =>\n+                            $enum_name::$variant $( ( $( __impl_snapshot_field!($field, __ctx $(, $delegate)*) ),* ), )*\n+                    )*\n+                }\n+            }\n+        }\n+    };\n+\n+    // FIXME(mark-i-m): same here.\n+    (struct $struct_name:ident { $($field:ident $(-> $delegate:expr)*),*  $(,)* }) => {\n+        impl<'a, Ctx> self::Snapshot<'a, Ctx> for $struct_name\n+            where Ctx: self::SnapshotContext<'a>,\n+        {\n+            type Item = $struct_name<AllocIdSnapshot<'a>>;\n+\n+            #[inline]\n+            fn snapshot(&self, __ctx: &'a Ctx) -> Self::Item {\n+                let $struct_name {\n+                    $(ref $field),*\n+                } = *self;\n+\n+                $struct_name {\n+                    $( $field: __impl_snapshot_field!($field, __ctx $(, $delegate)*) ),*\n+                }\n+            }\n+        }\n+    };\n+}\n+\n impl<'a, Ctx, T> Snapshot<'a, Ctx> for Option<T>\n     where Ctx: SnapshotContext<'a>,\n           T: Snapshot<'a, Ctx>\n@@ -42,7 +86,7 @@ impl<'a, Ctx, T> Snapshot<'a, Ctx> for Option<T>\n struct AllocIdSnapshot<'a>(Option<AllocationSnapshot<'a>>);\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+    where Ctx: SnapshotContext<'a>,\n {\n     type Item = AllocIdSnapshot<'a>;\n \n@@ -51,80 +95,42 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for AllocId\n     }\n }\n \n-type PointerSnapshot<'a> = Pointer<AllocIdSnapshot<'a>>;\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Pointer\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n-{\n-    type Item = PointerSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let Pointer{ alloc_id, offset } = self;\n-\n-        Pointer {\n-            alloc_id: alloc_id.snapshot(ctx),\n-            offset: *offset,\n-        }\n-    }\n-}\n-\n-type ScalarSnapshot<'a> = Scalar<AllocIdSnapshot<'a>>;\n+impl_snapshot_for!(struct Pointer {\n+    alloc_id,\n+    offset -> *offset,\n+});\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for Scalar\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+    where Ctx: SnapshotContext<'a>,\n {\n-    type Item = ScalarSnapshot<'a>;\n+    type Item = Scalar<AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         match self {\n             Scalar::Ptr(p) => Scalar::Ptr(p.snapshot(ctx)),\n-            Scalar::Bits{ size, bits } => Scalar::Bits{\n+            Scalar::Bits{ size, bits } => Scalar::Bits {\n                 size: *size,\n                 bits: *bits,\n             },\n         }\n     }\n }\n \n-type ScalarMaybeUndefSnapshot<'a> = ScalarMaybeUndef<AllocIdSnapshot<'a>>;\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for ScalarMaybeUndef\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n-{\n-    type Item = ScalarMaybeUndefSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            ScalarMaybeUndef::Scalar(s) => ScalarMaybeUndef::Scalar(s.snapshot(ctx)),\n-            ScalarMaybeUndef::Undef => ScalarMaybeUndef::Undef,\n-        }\n-    }\n-}\n-\n-type MemPlaceSnapshot<'a> = MemPlace<AllocIdSnapshot<'a>>;\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for MemPlace\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n-{\n-    type Item = MemPlaceSnapshot<'a>;\n+impl_snapshot_for!(enum ScalarMaybeUndef {\n+    Scalar(s),\n+    Undef,\n+});\n \n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        let MemPlace{ ptr, extra, align } = self;\n-\n-        MemPlaceSnapshot{\n-            ptr: ptr.snapshot(ctx),\n-            extra: extra.snapshot(ctx),\n-            align: *align,\n-        }\n-    }\n-}\n-\n-type PlaceSnapshot<'a> = Place<AllocIdSnapshot<'a>>;\n+impl_snapshot_for!(struct MemPlace {\n+    ptr,\n+    extra,\n+    align -> *align,\n+});\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+    where Ctx: SnapshotContext<'a>,\n {\n-    type Item = PlaceSnapshot<'a>;\n+    type Item = Place<AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         match self {\n@@ -138,57 +144,25 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Place\n     }\n }\n \n-type ValueSnapshot<'a> = Value<AllocIdSnapshot<'a>>;\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for Value\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n-{\n-    type Item = ValueSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Value::Scalar(s) => Value::Scalar(s.snapshot(ctx)),\n-            Value::ScalarPair(a, b) => Value::ScalarPair(a.snapshot(ctx), b.snapshot(ctx)),\n-        }\n-    }\n-}\n+impl_snapshot_for!(enum Value {\n+    Scalar(s),\n+    ScalarPair(s, t),\n+});\n \n-type OperandSnapshot<'a> = Operand<AllocIdSnapshot<'a>>;\n+impl_snapshot_for!(enum Operand {\n+    Immediate(v),\n+    Indirect(m),\n+});\n \n-impl<'a, Ctx> Snapshot<'a, Ctx> for Operand\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n-{\n-    type Item = OperandSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            Operand::Immediate(v) => Operand::Immediate(v.snapshot(ctx)),\n-            Operand::Indirect(m) => Operand::Indirect(m.snapshot(ctx)),\n-        }\n-    }\n-}\n-\n-type LocalValueSnapshot<'a> = LocalValue<AllocIdSnapshot<'a>>;\n-\n-impl<'a, Ctx> Snapshot<'a, Ctx> for LocalValue\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n-{\n-    type Item = LocalValueSnapshot<'a>;\n-\n-    fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n-        match self {\n-            LocalValue::Live(v) => LocalValue::Live(v.snapshot(ctx)),\n-            LocalValue::Dead => LocalValue::Dead,\n-        }\n-    }\n-}\n-\n-type RelocationsSnapshot<'a> = Relocations<AllocIdSnapshot<'a>>;\n+impl_snapshot_for!(enum LocalValue {\n+    Live(v),\n+    Dead,\n+});\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+    where Ctx: SnapshotContext<'a>,\n {\n-    type Item = RelocationsSnapshot<'a>;\n+    type Item = Relocations<AllocIdSnapshot<'a>>;\n \n     fn snapshot(&self, ctx: &'a Ctx) -> Self::Item {\n         Relocations::from_presorted(self.iter().map(|(size, id)| (*size, id.snapshot(ctx))).collect())\n@@ -198,14 +172,14 @@ impl<'a, Ctx> Snapshot<'a, Ctx> for Relocations\n #[derive(Eq, PartialEq)]\n struct AllocationSnapshot<'a> {\n     bytes: &'a [u8],\n-    relocations: RelocationsSnapshot<'a>,\n+    relocations: Relocations<AllocIdSnapshot<'a>>,\n     undef_mask: &'a UndefMask,\n     align: &'a Align,\n     mutability: &'a Mutability,\n }\n \n impl<'a, Ctx> Snapshot<'a, Ctx> for &'a Allocation\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+    where Ctx: SnapshotContext<'a>,\n {\n     type Item = AllocationSnapshot<'a>;\n \n@@ -227,14 +201,14 @@ struct FrameSnapshot<'a, 'tcx: 'a> {\n     instance: &'a ty::Instance<'tcx>,\n     span: &'a Span,\n     return_to_block: &'a StackPopCleanup,\n-    return_place: PlaceSnapshot<'a>,\n-    locals: IndexVec<mir::Local, LocalValueSnapshot<'a>>,\n+    return_place: Place<AllocIdSnapshot<'a>>,\n+    locals: IndexVec<mir::Local, LocalValue<AllocIdSnapshot<'a>>>,\n     block: &'a mir::BasicBlock,\n     stmt: usize,\n }\n \n impl<'a, 'mir, 'tcx, Ctx> Snapshot<'a, Ctx> for &'a Frame<'mir, 'tcx>\n-    where Ctx: SnapshotContext<'a, To=Allocation, From=AllocId>,\n+    where Ctx: SnapshotContext<'a>,\n {\n     type Item = FrameSnapshot<'a, 'tcx>;\n \n@@ -279,9 +253,7 @@ impl<'a, 'mir, 'tcx, M> Memory<'a, 'mir, 'tcx, M>\n impl<'a, 'b, 'mir, 'tcx, M> SnapshotContext<'b> for Memory<'a, 'mir, 'tcx, M>\n     where M: Machine<'mir, 'tcx>,\n {\n-    type To = Allocation;\n-    type From = AllocId;\n-    fn resolve(&'b self, id: &Self::From) -> Option<&'b Self::To> {\n+    fn resolve(&'b self, id: &AllocId) -> Option<&'b Allocation> {\n         self.get(*id).ok()\n     }\n }"}]}