{"sha": "1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmNmFmYTg4N2I5ZmJhYWRkYTM2Y2U1N2EzYzI5NmY0M2VkOGEwODQ=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-10T23:50:42Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-08-13T06:18:51Z"}, "message": "Correct the padding on integer types for formatting", "tree": {"sha": "4288b946747ca74367b21301bb609f23b5ffdf40", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4288b946747ca74367b21301bb609f23b5ffdf40"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "html_url": "https://github.com/rust-lang/rust/commit/1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "url": "https://api.github.com/repos/rust-lang/rust/commits/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002", "html_url": "https://github.com/rust-lang/rust/commit/6feb58ed84d8dce2aea35a8be9fd8d7b6883f002"}], "stats": {"total": 246, "additions": 133, "deletions": 113}, "files": [{"sha": "eca0b84d208912ebb49c802f5ed55f3d0637b621", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 41, "deletions": 25, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "patch": "@@ -32,7 +32,7 @@ pub struct Formatter<'self> {\n     /// Character used as 'fill' whenever there is alignment\n     fill: char,\n     /// Boolean indication of whether the output should be left-aligned\n-    alignleft: bool,\n+    align: parse::Alignment,\n     /// Optionally specified integer width that the output should be\n     width: Option<uint>,\n     /// Optionally specified precision for numeric types\n@@ -108,7 +108,7 @@ pub unsafe fn sprintf(fmt: &[rt::Piece], args: &[Argument]) -> ~str {\n             precision: None,\n             // FIXME(#8248): shouldn't need a transmute\n             buf: cast::transmute(&output as &io::Writer),\n-            alignleft: false,\n+            align: parse::AlignUnknown,\n             fill: ' ',\n             args: args,\n             curarg: args.iter(),\n@@ -148,7 +148,7 @@ impl<'self> Formatter<'self> {\n             rt::Argument(ref arg) => {\n                 // Fill in the format parameters into the formatter\n                 self.fill = arg.format.fill;\n-                self.alignleft = arg.format.alignleft;\n+                self.align = arg.format.align;\n                 self.flags = arg.format.flags;\n                 setcount(&mut self.width, &arg.format.width);\n                 setcount(&mut self.precision, &arg.format.precision);\n@@ -251,36 +251,47 @@ impl<'self> Formatter<'self> {\n     /// TODO: dox\n     pub fn pad_integral(&mut self, s: &[u8], alternate_prefix: &str,\n                         positive: bool) {\n-        use fmt::parse::{FlagAlternate, FlagSignPlus};\n+        use fmt::parse::{FlagAlternate, FlagSignPlus, FlagSignAwareZeroPad};\n \n         let mut actual_len = s.len();\n         if self.flags & 1 << (FlagAlternate as uint) != 0 {\n             actual_len += alternate_prefix.len();\n         }\n         if self.flags & 1 << (FlagSignPlus as uint) != 0 {\n             actual_len += 1;\n-        }\n-        if !positive {\n+        } else if !positive {\n             actual_len += 1;\n         }\n \n-        let emit = |this: &mut Formatter| {\n-            if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n-                this.buf.write(['+' as u8]);\n-            } else if !positive {\n-                this.buf.write(['-' as u8]);\n-            }\n-            if this.flags & 1 << (FlagAlternate as uint) != 0 {\n-                this.buf.write(alternate_prefix.as_bytes());\n+        let mut signprinted = false;\n+        let sign = |this: &mut Formatter| {\n+            if !signprinted {\n+                if this.flags & 1 << (FlagSignPlus as uint) != 0 && positive {\n+                    this.buf.write(['+' as u8]);\n+                } else if !positive {\n+                    this.buf.write(['-' as u8]);\n+                }\n+                if this.flags & 1 << (FlagAlternate as uint) != 0 {\n+                    this.buf.write(alternate_prefix.as_bytes());\n+                }\n+                signprinted = true;\n             }\n+        };\n+\n+        let emit = |this: &mut Formatter| {\n+            sign(this);\n             this.buf.write(s);\n         };\n \n         match self.width {\n             None => { emit(self) }\n             Some(min) if actual_len >= min => { emit(self) }\n             Some(min) => {\n-                do self.with_padding(min - actual_len) |me| {\n+                if self.flags & 1 << (FlagSignAwareZeroPad as uint) != 0 {\n+                    self.fill = '0';\n+                    sign(self);\n+                }\n+                do self.with_padding(min - actual_len, parse::AlignRight) |me| {\n                     emit(me);\n                 }\n             }\n@@ -292,8 +303,8 @@ impl<'self> Formatter<'self> {\n     /// recognized for generic strings are:\n     ///\n     /// * width - the minimum width of what to emit\n-    /// * fill/alignleft - what to emit and where to emit it if the string\n-    ///                    provided needs to be padded\n+    /// * fill/align - what to emit and where to emit it if the string\n+    ///                provided needs to be padded\n     /// * precision - the maximum length to emit, the string is truncated if it\n     ///               is longer than this length\n     ///\n@@ -336,23 +347,28 @@ impl<'self> Formatter<'self> {\n             // If we're under both the maximum and the minimum width, then fill\n             // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n-                do self.with_padding(width - s.len()) |me| {\n+                do self.with_padding(width - s.len(), parse::AlignLeft) |me| {\n                     me.buf.write(s.as_bytes());\n                 }\n             }\n         }\n     }\n \n-    fn with_padding(&mut self, padding: uint, f: &fn(&mut Formatter)) {\n-        if self.alignleft {\n+    fn with_padding(&mut self, padding: uint,\n+                    default: parse::Alignment, f: &fn(&mut Formatter)) {\n+        let align = match self.align {\n+            parse::AlignUnknown => default,\n+            parse::AlignLeft | parse::AlignRight => self.align\n+        };\n+        if align == parse::AlignLeft {\n             f(self);\n         }\n         let mut fill = [0u8, ..4];\n         let len = self.fill.encode_utf8(fill);\n         for _ in range(0, padding) {\n             self.buf.write(fill.slice_to(len));\n         }\n-        if !self.alignleft {\n+        if align == parse::AlignRight {\n             f(self);\n         }\n     }\n@@ -427,7 +443,6 @@ macro_rules! upper_hex(($ty:ident, $into:ident) => {\n         }\n     }\n })\n-\n // Not sure why, but this causes an \"unresolved enum variant, struct or const\"\n // when inlined into the above macro...\n #[doc(hidden)]\n@@ -500,9 +515,10 @@ impl<T> Poly for T {\n //      time.\n impl<T> Pointer for *const T {\n     fn fmt(t: &*const T, f: &mut Formatter) {\n-        // XXX: formatting args\n-        f.buf.write(\"0x\".as_bytes());\n-        LowerHex::fmt(&(*t as uint), f);\n+        f.flags |= 1 << (parse::FlagAlternate as uint);\n+        do ::uint::to_str_bytes(*t as uint, 16) |buf| {\n+            f.pad_integral(buf, \"0x\", true);\n+        }\n     }\n }\n "}, {"sha": "0d39ae84a6057432a2887fee8a6ae4961ea52973", "filename": "src/libstd/fmt/parse.rs", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Flibstd%2Ffmt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Flibstd%2Ffmt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fparse.rs?ref=1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "patch": "@@ -47,7 +47,7 @@ pub struct FormatSpec<'self> {\n     /// Optionally specified character to fill alignment with\n     fill: Option<char>,\n     /// Optionally specified alignment\n-    align: Option<Alignment>,\n+    align: Alignment,\n     /// Packed version of various flags provided\n     flags: uint,\n     /// The integer precision to use\n@@ -68,7 +68,7 @@ pub enum Position<'self> {\n \n /// Enum of alignments which are supoprted.\n #[deriving(Eq)]\n-pub enum Alignment { AlignLeft, AlignRight }\n+pub enum Alignment { AlignLeft, AlignRight, AlignUnknown }\n \n /// Various flags which can be applied to format strings, the meaning of these\n /// flags is defined by the formatters themselves.\n@@ -77,6 +77,7 @@ pub enum Flag {\n     FlagSignPlus,\n     FlagSignMinus,\n     FlagAlternate,\n+    FlagSignAwareZeroPad,\n }\n \n /// A count is used for the precision and width parameters of an integer, and\n@@ -288,7 +289,7 @@ impl<'self> Parser<'self> {\n     fn format(&mut self) -> FormatSpec<'self> {\n         let mut spec = FormatSpec {\n             fill: None,\n-            align: None,\n+            align: AlignUnknown,\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n@@ -311,9 +312,9 @@ impl<'self> Parser<'self> {\n         }\n         // Alignment\n         if self.consume('<') {\n-            spec.align = Some(AlignLeft);\n+            spec.align = AlignLeft;\n         } else if self.consume('>') {\n-            spec.align = Some(AlignRight);\n+            spec.align = AlignRight;\n         }\n         // Sign flags\n         if self.consume('+') {\n@@ -326,6 +327,9 @@ impl<'self> Parser<'self> {\n             spec.flags |= 1 << (FlagAlternate as uint);\n         }\n         // Width and precision\n+        if self.consume('0') {\n+            spec.flags |= 1 << (FlagSignAwareZeroPad as uint);\n+        }\n         spec.width = self.count();\n         if self.consume('.') {\n             if self.consume('*') {\n@@ -597,7 +601,7 @@ mod tests {\n     fn fmtdflt() -> FormatSpec<'static> {\n         return FormatSpec {\n             fill: None,\n-            align: None,\n+            align: AlignUnknown,\n             flags: 0,\n             precision: CountImplied,\n             width: CountImplied,\n@@ -656,7 +660,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -671,7 +675,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n-                align: Some(AlignRight),\n+                align: AlignRight,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -683,7 +687,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('0'),\n-                align: Some(AlignLeft),\n+                align: AlignLeft,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -695,7 +699,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: Some('*'),\n-                align: Some(AlignLeft),\n+                align: AlignLeft,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -710,7 +714,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountIs(10),\n@@ -722,7 +726,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIs(10),\n                 width: CountIsParam(10),\n@@ -734,7 +738,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIsNextParam,\n                 width: CountImplied,\n@@ -746,7 +750,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountIsParam(10),\n                 width: CountImplied,\n@@ -761,7 +765,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: (1 << FlagSignMinus as uint),\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -773,7 +777,7 @@ mod tests {\n             position: ArgumentNext,\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: (1 << FlagSignPlus as uint) | (1 << FlagAlternate as uint),\n                 precision: CountImplied,\n                 width: CountImplied,\n@@ -788,7 +792,7 @@ mod tests {\n             position: ArgumentIs(3),\n             format: FormatSpec {\n                 fill: None,\n-                align: None,\n+                align: AlignUnknown,\n                 flags: 0,\n                 precision: CountImplied,\n                 width: CountImplied,"}, {"sha": "90763836fc6b6ef03f807949ac08c8f4c9ac365f", "filename": "src/libstd/fmt/rt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Flibstd%2Ffmt%2Frt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Flibstd%2Ffmt%2Frt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Frt.rs?ref=1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "patch": "@@ -36,7 +36,7 @@ pub struct Argument<'self> {\n \n pub struct FormatSpec {\n     fill: char,\n-    alignleft: bool,\n+    align: parse::Alignment,\n     flags: uint,\n     precision: parse::Count,\n     width: parse::Count,"}, {"sha": "2d839f652d50af160b5b985d7af49065dc4e8795", "filename": "src/libsyntax/ext/ifmt.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Flibsyntax%2Fext%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Flibsyntax%2Fext%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fifmt.rs?ref=1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "patch": "@@ -317,6 +317,10 @@ impl Context {\n     /// Translate a `parse::Piece` to a static `rt::Piece`\n     fn trans_piece(&mut self, piece: &parse::Piece) -> @ast::expr {\n         let sp = self.fmtsp;\n+        let parsepath = |s: &str| {\n+            ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n+              self.ecx.ident_of(\"parse\"), self.ecx.ident_of(s)]\n+        };\n         let rtpath = |s: &str| {\n             ~[self.ecx.ident_of(\"std\"), self.ecx.ident_of(\"fmt\"),\n               self.ecx.ident_of(\"rt\"), self.ecx.ident_of(s)]\n@@ -482,20 +486,24 @@ impl Context {\n                 let fill = self.ecx.expr_lit(sp, ast::lit_int(fill as i64,\n                                                               ast::ty_char));\n                 let align = match arg.format.align {\n-                    None | Some(parse::AlignLeft) => {\n-                        self.ecx.expr_bool(sp, true)\n+                    parse::AlignLeft => {\n+                        self.ecx.path_global(sp, parsepath(\"AlignLeft\"))\n+                    }\n+                    parse::AlignRight => {\n+                        self.ecx.path_global(sp, parsepath(\"AlignRight\"))\n                     }\n-                    Some(parse::AlignRight) => {\n-                        self.ecx.expr_bool(sp, false)\n+                    parse::AlignUnknown => {\n+                        self.ecx.path_global(sp, parsepath(\"AlignUnknown\"))\n                     }\n                 };\n+                let align = self.ecx.expr_path(align);\n                 let flags = self.ecx.expr_uint(sp, arg.format.flags);\n                 let prec = trans_count(arg.format.precision);\n                 let width = trans_count(arg.format.width);\n                 let path = self.ecx.path_global(sp, rtpath(\"FormatSpec\"));\n                 let fmt = self.ecx.expr_struct(sp, path, ~[\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"fill\"), fill),\n-                    self.ecx.field_imm(sp, self.ecx.ident_of(\"alignleft\"), align),\n+                    self.ecx.field_imm(sp, self.ecx.ident_of(\"align\"), align),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"flags\"), flags),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"precision\"), prec),\n                     self.ecx.field_imm(sp, self.ecx.ident_of(\"width\"), width),"}, {"sha": "55dc6bd2407f58717a5624454f4211b25a3d0edf", "filename": "src/test/run-pass/ifmt.rs", "status": "modified", "additions": 57, "deletions": 65, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Ftest%2Frun-pass%2Fifmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f6afa887b9fbaadda36ce57a3c296f43ed8a084/src%2Ftest%2Frun-pass%2Fifmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fifmt.rs?ref=1f6afa887b9fbaadda36ce57a3c296f43ed8a084", "patch": "@@ -95,36 +95,36 @@ pub fn main() {\n     // type of the argument. Also, hex/octal/binary should be defined for\n     // integers, but they shouldn't emit the negative sign.\n     t!(ifmt!(\"{:d}\", -1i), \"-1\");\n-    t!(ifmt!(\"{:d}\", -1i8), \"1\");\n-    t!(ifmt!(\"{:d}\", -1i16), \"1\");\n-    t!(ifmt!(\"{:d}\", -1i32), \"1\");\n-    t!(ifmt!(\"{:d}\", -1i64), \"1\");\n-    t!(ifmt!(\"{:t}\", -1i), \"1\");\n-    t!(ifmt!(\"{:t}\", -1i8), \"1\");\n-    t!(ifmt!(\"{:t}\", -1i16), \"1\");\n-    t!(ifmt!(\"{:t}\", -1i32), \"1\");\n-    t!(ifmt!(\"{:t}\", -1i64), \"1\");\n-    t!(ifmt!(\"{:x}\", -1i), \"1\");\n-    t!(ifmt!(\"{:x}\", -1i8), \"1\");\n-    t!(ifmt!(\"{:x}\", -1i16), \"1\");\n-    t!(ifmt!(\"{:x}\", -1i32), \"1\");\n-    t!(ifmt!(\"{:x}\", -1i64), \"1\");\n-    t!(ifmt!(\"{:X}\", -1i), \"1\");\n-    t!(ifmt!(\"{:X}\", -1i8), \"1\");\n-    t!(ifmt!(\"{:X}\", -1i16), \"1\");\n-    t!(ifmt!(\"{:X}\", -1i32), \"1\");\n-    t!(ifmt!(\"{:X}\", -1i64), \"1\");\n-    t!(ifmt!(\"{:o}\", -1i), \"1\");\n-    t!(ifmt!(\"{:o}\", -1i8), \"1\");\n-    t!(ifmt!(\"{:o}\", -1i16), \"1\");\n-    t!(ifmt!(\"{:o}\", -1i32), \"1\");\n-    t!(ifmt!(\"{:o}\", -1i64), \"1\");\n+    t!(ifmt!(\"{:d}\", -1i8), \"-1\");\n+    t!(ifmt!(\"{:d}\", -1i16), \"-1\");\n+    t!(ifmt!(\"{:d}\", -1i32), \"-1\");\n+    t!(ifmt!(\"{:d}\", -1i64), \"-1\");\n+    t!(ifmt!(\"{:t}\", 1i), \"1\");\n+    t!(ifmt!(\"{:t}\", 1i8), \"1\");\n+    t!(ifmt!(\"{:t}\", 1i16), \"1\");\n+    t!(ifmt!(\"{:t}\", 1i32), \"1\");\n+    t!(ifmt!(\"{:t}\", 1i64), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i8), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i16), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i32), \"1\");\n+    t!(ifmt!(\"{:x}\", 1i64), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i8), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i16), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i32), \"1\");\n+    t!(ifmt!(\"{:X}\", 1i64), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i8), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i16), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i32), \"1\");\n+    t!(ifmt!(\"{:o}\", 1i64), \"1\");\n \n-    t!(ifmt!(\"{:d}\", 1u), \"1\");\n-    t!(ifmt!(\"{:d}\", 1u8), \"1\");\n-    t!(ifmt!(\"{:d}\", 1u16), \"1\");\n-    t!(ifmt!(\"{:d}\", 1u32), \"1\");\n-    t!(ifmt!(\"{:d}\", 1u64), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u8), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u16), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u32), \"1\");\n+    t!(ifmt!(\"{:u}\", 1u64), \"1\");\n     t!(ifmt!(\"{:t}\", 1u), \"1\");\n     t!(ifmt!(\"{:t}\", 1u8), \"1\");\n     t!(ifmt!(\"{:t}\", 1u16), \"1\");\n@@ -147,44 +147,36 @@ pub fn main() {\n     t!(ifmt!(\"{:o}\", 1u64), \"1\");\n \n     // Test the flags for formatting integers\n-    t!(ifmt!(\"{:3d}\", 1), \"1  \");\n-    t!(ifmt!(\"{:>3d}\", 1), \"  1\");\n+    t!(ifmt!(\"{:3d}\", 1),  \"  1\");\n+    t!(ifmt!(\"{:>3d}\", 1),  \"  1\");\n+    t!(ifmt!(\"{:>+3d}\", 1), \" +1\");\n+    t!(ifmt!(\"{:<3d}\", 1), \"1  \");\n     t!(ifmt!(\"{:#d}\", 1), \"1\");\n-    t!(ifmt!(\"{:#x}\", 10u), \"0xa\");\n-    t!(ifmt!(\"{:#X}\", 10u), \"0xA\");\n-    t!(ifmt!(\"{:#5x}\", 10u), \"0xa  \");\n-    t!(ifmt!(\"{:#o}\", 10u), \"0o12\");\n-\n-    // Precision overrides 0-padding\n-    // FIXME #2481: Recent gcc's report some of these as warnings\n-    /*t!(ifmt!(\"{:0>6.5d}\", 0), ~\" 00000\");*/\n-    /*t!(ifmt!(\"{:0>6.5u}\", 0u), ~\" 00000\");*/\n-    /*t!(ifmt!(\"{:0>6.5x}\", 0u), ~\" 00000\");*/\n-    /*t!(ifmt!(\"{:0>6.5d}\", 10), ~\" 00010\");*/\n-    /*t!(ifmt!(\"{:0>6.5d}\", -10), ~\"-00010\");*/\n-    /*t!(ifmt!(\"{:0>6.5u}\", 10u), ~\" 00010\");*/\n-    /*t!(ifmt!(\"{:0>6.5s}\", ~\"t!\"), ~\"  t!\");*/\n-    /*t!(ifmt!(\"{:0>6.5c}\", 'A'), ~\"     A\");*/\n-    /*t!(ifmt!(\"{:0>6.5x}\", 127u), ~\" 0007f\");*/\n-    /*t!(ifmt!(\"{:0>6.5X}\", 127u), ~\" 0007F\");*/\n-    /*t!(ifmt!(\"{:0>6.5o}\", 10u), ~\" 00012\");*/\n+    t!(ifmt!(\"{:#x}\", 10), \"0xa\");\n+    t!(ifmt!(\"{:#X}\", 10), \"0xA\");\n+    t!(ifmt!(\"{:#5x}\", 10), \"  0xa\");\n+    t!(ifmt!(\"{:#o}\", 10), \"0o12\");\n+    t!(ifmt!(\"{:08x}\", 10),  \"0000000a\");\n+    t!(ifmt!(\"{:8x}\", 10),   \"       a\");\n+    t!(ifmt!(\"{:<8x}\", 10),  \"a       \");\n+    t!(ifmt!(\"{:>8x}\", 10),  \"       a\");\n+    t!(ifmt!(\"{:#08x}\", 10), \"0x00000a\");\n+    t!(ifmt!(\"{:08d}\", -10), \"-0000010\");\n+    t!(ifmt!(\"{:x}\", -1u8), \"ff\");\n+    t!(ifmt!(\"{:X}\", -1u8), \"FF\");\n+    t!(ifmt!(\"{:t}\", -1u8), \"11111111\");\n+    t!(ifmt!(\"{:o}\", -1u8), \"377\");\n+    t!(ifmt!(\"{:#x}\", -1u8), \"0xff\");\n+    t!(ifmt!(\"{:#X}\", -1u8), \"0xFF\");\n+    t!(ifmt!(\"{:#t}\", -1u8), \"0b11111111\");\n+    t!(ifmt!(\"{:#o}\", -1u8), \"0o377\");\n \n     // Signed combinations\n-    /*t!(ifmt!(\"{:5d}\", 1), ~\"    1\");*/\n-    /*t!(ifmt!(\"{: >5d}\", -1), ~\"   -1\");*/\n-    /*t!(ifmt!(\"{:+5d}\", 1), ~\"   +1\");*/\n-    /*t!(ifmt!(\"{:+5d}\", -1), ~\"   -1\");*/\n-    /*t!(ifmt!(\"{:0>5d}\", 1), ~\" 0001\");*/\n-    /*t!(ifmt!(\"{:0>5d}\", -1), ~\"-0001\");*/\n-    /*t!(ifmt!(\"{:0>+5d}\", 1), ~\"+0001\");*/\n-    /*t!(ifmt!(\"{:0>+5d}\", -1), ~\"-0001\");*/\n-    /*t!(ifmt!(\"%- 5d\", 1), ~\" 1   \");*/\n-    /*t!(ifmt!(\"%- 5d\", -1), ~\"-1   \");*/\n-    /*t!(ifmt!(\"%-+5d\", 1), ~\"+1   \");*/\n-    /*t!(ifmt!(\"%-+5d\", -1), ~\"-1   \");*/\n-    /*t!(ifmt!(\"%- 05d\", 1), ~\" 1   \");*/\n-    /*t!(ifmt!(\"%- 05d\", -1), ~\"-1   \");*/\n-    /*t!(ifmt!(\"%-+05d\", 1), ~\"+1   \");*/\n-    /*t!(ifmt!(\"%-+05d\", -1), ~\"-1   \");*/\n+    t!(ifmt!(\"{:+5d}\", 1),  ~\"   +1\");\n+    t!(ifmt!(\"{:+5d}\", -1), ~\"   -1\");\n+    t!(ifmt!(\"{:05d}\", 1),    ~\"00001\");\n+    t!(ifmt!(\"{:05d}\", -1),   ~\"-0001\");\n+    t!(ifmt!(\"{:+05d}\", 1),   ~\"+0001\");\n+    t!(ifmt!(\"{:+05d}\", -1),  ~\"-0001\");\n }\n "}]}