{"sha": "20de961226de41a18ca1d9b166c6bc607f3a597a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIwZGU5NjEyMjZkZTQxYTE4Y2ExZDliMTY2YzZiYzYwN2YzYTU5N2E=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-08T15:49:03Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-05-08T15:49:03Z"}, "message": "Auto merge of #41824 - Mark-Simulacrum:undo-yacc-removal, r=nagisa\n\nReadd LALR grammar\n\nReverts a portion of #41705. Please let me know if I missed anything.\n\nr? @nagisa", "tree": {"sha": "70225fde1e24cabbe0a90d446640776391aa4295", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/70225fde1e24cabbe0a90d446640776391aa4295"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20de961226de41a18ca1d9b166c6bc607f3a597a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20de961226de41a18ca1d9b166c6bc607f3a597a", "html_url": "https://github.com/rust-lang/rust/commit/20de961226de41a18ca1d9b166c6bc607f3a597a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20de961226de41a18ca1d9b166c6bc607f3a597a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "198917bb4f13daca7225af61d17c6fd4f70487bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/198917bb4f13daca7225af61d17c6fd4f70487bd", "html_url": "https://github.com/rust-lang/rust/commit/198917bb4f13daca7225af61d17c6fd4f70487bd"}, {"sha": "6ebbe0ef50667af7a6ddb5ba674a6ab5e0827be1", "url": "https://api.github.com/repos/rust-lang/rust/commits/6ebbe0ef50667af7a6ddb5ba674a6ab5e0827be1", "html_url": "https://github.com/rust-lang/rust/commit/6ebbe0ef50667af7a6ddb5ba674a6ab5e0827be1"}], "stats": {"total": 2725, "additions": 2725, "deletions": 0}, "files": [{"sha": "3e4498759434f92723f6a9665fb1fa7bc6d9997c", "filename": "src/grammar/.gitignore", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2F.gitignore?ref=20de961226de41a18ca1d9b166c6bc607f3a597a", "patch": "@@ -0,0 +1,3 @@\n+*.class\n+*.java\n+*.tokens"}, {"sha": "77737c99496f34757127d29e0040da0ff7f4fa56", "filename": "src/grammar/lexer.l", "status": "added", "additions": 343, "deletions": 0, "changes": 343, "blob_url": "https://github.com/rust-lang/rust/blob/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/rust-lang/rust/raw/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Flexer.l?ref=20de961226de41a18ca1d9b166c6bc607f3a597a", "patch": "@@ -0,0 +1,343 @@\n+%{\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <stdio.h>\n+#include <ctype.h>\n+\n+static int num_hashes;\n+static int end_hashes;\n+static int saw_non_hash;\n+\n+%}\n+\n+%option stack\n+%option yylineno\n+\n+%x str\n+%x rawstr\n+%x rawstr_esc_begin\n+%x rawstr_esc_body\n+%x rawstr_esc_end\n+%x byte\n+%x bytestr\n+%x rawbytestr\n+%x rawbytestr_nohash\n+%x pound\n+%x shebang_or_attr\n+%x ltorchar\n+%x linecomment\n+%x doc_line\n+%x blockcomment\n+%x doc_block\n+%x suffix\n+\n+ident [a-zA-Z\\x80-\\xff_][a-zA-Z0-9\\x80-\\xff_]*\n+\n+%%\n+\n+<suffix>{ident}            { BEGIN(INITIAL); }\n+<suffix>(.|\\n)  { yyless(0); BEGIN(INITIAL); }\n+\n+[ \\n\\t\\r]             { }\n+\n+\\xef\\xbb\\xbf {\n+  // UTF-8 byte order mark (BOM), ignore if in line 1, error otherwise\n+  if (yyget_lineno() != 1) {\n+    return -1;\n+  }\n+}\n+\n+\\/\\/(\\/|\\!)           { BEGIN(doc_line); yymore(); }\n+<doc_line>\\n          { BEGIN(INITIAL);\n+                        yyleng--;\n+                        yytext[yyleng] = 0;\n+                        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n+                      }\n+<doc_line>[^\\n]*      { yymore(); }\n+\n+\\/\\/|\\/\\/\\/\\/         { BEGIN(linecomment); }\n+<linecomment>\\n       { BEGIN(INITIAL); }\n+<linecomment>[^\\n]*   { }\n+\n+\\/\\*(\\*|\\!)[^*]       { yy_push_state(INITIAL); yy_push_state(doc_block); yymore(); }\n+<doc_block>\\/\\*       { yy_push_state(doc_block); yymore(); }\n+<doc_block>\\*\\/       {\n+    yy_pop_state();\n+    if (yy_top_state() == doc_block) {\n+        yymore();\n+    } else {\n+        return ((yytext[2] == '!') ? INNER_DOC_COMMENT : OUTER_DOC_COMMENT);\n+    }\n+}\n+<doc_block>(.|\\n)     { yymore(); }\n+\n+\\/\\*                  { yy_push_state(blockcomment); }\n+<blockcomment>\\/\\*    { yy_push_state(blockcomment); }\n+<blockcomment>\\*\\/    { yy_pop_state(); }\n+<blockcomment>(.|\\n)   { }\n+\n+_        { return UNDERSCORE; }\n+as       { return AS; }\n+box      { return BOX; }\n+break    { return BREAK; }\n+const    { return CONST; }\n+continue { return CONTINUE; }\n+crate    { return CRATE; }\n+else     { return ELSE; }\n+enum     { return ENUM; }\n+extern   { return EXTERN; }\n+false    { return FALSE; }\n+fn       { return FN; }\n+for      { return FOR; }\n+if       { return IF; }\n+impl     { return IMPL; }\n+in       { return IN; }\n+let      { return LET; }\n+loop     { return LOOP; }\n+match    { return MATCH; }\n+mod      { return MOD; }\n+move     { return MOVE; }\n+mut      { return MUT; }\n+priv     { return PRIV; }\n+proc     { return PROC; }\n+pub      { return PUB; }\n+ref      { return REF; }\n+return   { return RETURN; }\n+self     { return SELF; }\n+static   { return STATIC; }\n+struct   { return STRUCT; }\n+trait    { return TRAIT; }\n+true     { return TRUE; }\n+type     { return TYPE; }\n+typeof   { return TYPEOF; }\n+unsafe   { return UNSAFE; }\n+use      { return USE; }\n+where    { return WHERE; }\n+while    { return WHILE; }\n+\n+{ident}  { return IDENT; }\n+\n+0x[0-9a-fA-F_]+                                    { BEGIN(suffix); return LIT_INTEGER; }\n+0o[0-8_]+                                          { BEGIN(suffix); return LIT_INTEGER; }\n+0b[01_]+                                           { BEGIN(suffix); return LIT_INTEGER; }\n+[0-9][0-9_]*                                       { BEGIN(suffix); return LIT_INTEGER; }\n+[0-9][0-9_]*\\.(\\.|[a-zA-Z])    { yyless(yyleng - 2); BEGIN(suffix); return LIT_INTEGER; }\n+\n+[0-9][0-9_]*\\.[0-9_]*([eE][-\\+]?[0-9_]+)?          { BEGIN(suffix); return LIT_FLOAT; }\n+[0-9][0-9_]*(\\.[0-9_]*)?[eE][-\\+]?[0-9_]+          { BEGIN(suffix); return LIT_FLOAT; }\n+\n+;      { return ';'; }\n+,      { return ','; }\n+\\.\\.\\. { return DOTDOTDOT; }\n+\\.\\.   { return DOTDOT; }\n+\\.     { return '.'; }\n+\\(     { return '('; }\n+\\)     { return ')'; }\n+\\{     { return '{'; }\n+\\}     { return '}'; }\n+\\[     { return '['; }\n+\\]     { return ']'; }\n+@      { return '@'; }\n+#      { BEGIN(pound); yymore(); }\n+<pound>\\! { BEGIN(shebang_or_attr); yymore(); }\n+<shebang_or_attr>\\[ {\n+  BEGIN(INITIAL);\n+  yyless(2);\n+  return SHEBANG;\n+}\n+<shebang_or_attr>[^\\[\\n]*\\n {\n+  // Since the \\n was eaten as part of the token, yylineno will have\n+  // been incremented to the value 2 if the shebang was on the first\n+  // line. This yyless undoes that, setting yylineno back to 1.\n+  yyless(yyleng - 1);\n+  if (yyget_lineno() == 1) {\n+    BEGIN(INITIAL);\n+    return SHEBANG_LINE;\n+  } else {\n+    BEGIN(INITIAL);\n+    yyless(2);\n+    return SHEBANG;\n+  }\n+}\n+<pound>. { BEGIN(INITIAL); yyless(1); return '#'; }\n+\n+\\~     { return '~'; }\n+::     { return MOD_SEP; }\n+:      { return ':'; }\n+\\$     { return '$'; }\n+\\?     { return '?'; }\n+\n+==    { return EQEQ; }\n+=>    { return FAT_ARROW; }\n+=     { return '='; }\n+\\!=   { return NE; }\n+\\!    { return '!'; }\n+\\<=   { return LE; }\n+\\<\\<  { return SHL; }\n+\\<\\<= { return SHLEQ; }\n+\\<    { return '<'; }\n+\\>=   { return GE; }\n+\\>\\>  { return SHR; }\n+\\>\\>= { return SHREQ; }\n+\\>    { return '>'; }\n+\n+\\x27                                  { BEGIN(ltorchar); yymore(); }\n+<ltorchar>static                      { BEGIN(INITIAL); return STATIC_LIFETIME; }\n+<ltorchar>{ident}                     { BEGIN(INITIAL); return LIFETIME; }\n+<ltorchar>\\\\[nrt\\\\\\x27\\x220]\\x27      { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\x[0-9a-fA-F]{2}\\x27       { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>\\\\u\\{[0-9a-fA-F]?{6}\\}\\x27  { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>.\\x27                       { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar>[\\x80-\\xff]{2,4}\\x27        { BEGIN(suffix); return LIT_CHAR; }\n+<ltorchar><<EOF>>                     { BEGIN(INITIAL); return -1; }\n+\n+b\\x22              { BEGIN(bytestr); yymore(); }\n+<bytestr>\\x22      { BEGIN(suffix); return LIT_BYTE_STR; }\n+\n+<bytestr><<EOF>>                { return -1; }\n+<bytestr>\\\\[n\\nrt\\\\\\x27\\x220]   { yymore(); }\n+<bytestr>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n+<bytestr>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n+<bytestr>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n+<bytestr>(.|\\n)                 { yymore(); }\n+\n+br\\x22                      { BEGIN(rawbytestr_nohash); yymore(); }\n+<rawbytestr_nohash>\\x22     { BEGIN(suffix); return LIT_BYTE_STR_RAW; }\n+<rawbytestr_nohash>(.|\\n)   { yymore(); }\n+<rawbytestr_nohash><<EOF>>  { return -1; }\n+\n+br/# {\n+    BEGIN(rawbytestr);\n+    yymore();\n+    num_hashes = 0;\n+    saw_non_hash = 0;\n+    end_hashes = 0;\n+}\n+<rawbytestr># {\n+    if (!saw_non_hash) {\n+        num_hashes++;\n+    } else if (end_hashes != 0) {\n+        end_hashes++;\n+        if (end_hashes == num_hashes) {\n+            BEGIN(INITIAL);\n+            return LIT_BYTE_STR_RAW;\n+        }\n+    }\n+    yymore();\n+}\n+<rawbytestr>\\x22# {\n+    end_hashes = 1;\n+    if (end_hashes == num_hashes) {\n+        BEGIN(INITIAL);\n+        return LIT_BYTE_STR_RAW;\n+    }\n+    yymore();\n+}\n+<rawbytestr>(.|\\n) {\n+    if (!saw_non_hash) {\n+        saw_non_hash = 1;\n+    }\n+    if (end_hashes != 0) {\n+        end_hashes = 0;\n+    }\n+    yymore();\n+}\n+<rawbytestr><<EOF>> { return -1; }\n+\n+b\\x27                        { BEGIN(byte); yymore(); }\n+<byte>\\\\[nrt\\\\\\x27\\x220]\\x27 { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\x[0-9a-fA-F]{2}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\u[0-9a-fA-F]{4}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>\\\\U[0-9a-fA-F]{8}\\x27  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte>.\\x27                  { BEGIN(INITIAL); return LIT_BYTE; }\n+<byte><<EOF>>                { BEGIN(INITIAL); return -1; }\n+\n+r\\x22           { BEGIN(rawstr); yymore(); }\n+<rawstr>\\x22    { BEGIN(suffix); return LIT_STR_RAW; }\n+<rawstr>(.|\\n)  { yymore(); }\n+<rawstr><<EOF>> { return -1; }\n+\n+r/#             {\n+    BEGIN(rawstr_esc_begin);\n+    yymore();\n+    num_hashes = 0;\n+    saw_non_hash = 0;\n+    end_hashes = 0;\n+}\n+\n+<rawstr_esc_begin># {\n+    num_hashes++;\n+    yymore();\n+}\n+<rawstr_esc_begin>\\x22 {\n+    BEGIN(rawstr_esc_body);\n+    yymore();\n+}\n+<rawstr_esc_begin>(.|\\n) { return -1; }\n+\n+<rawstr_esc_body>\\x22/# {\n+  BEGIN(rawstr_esc_end);\n+  yymore();\n+ }\n+<rawstr_esc_body>(.|\\n) {\n+  yymore();\n+ }\n+\n+<rawstr_esc_end># {\n+  end_hashes++;\n+  if (end_hashes == num_hashes) {\n+    BEGIN(INITIAL);\n+    return LIT_STR_RAW;\n+  }\n+  yymore();\n+ }\n+<rawstr_esc_end>[^#] {\n+  end_hashes = 0;\n+  BEGIN(rawstr_esc_body);\n+  yymore();\n+ }\n+\n+<rawstr_esc_begin,rawstr_esc_body,rawstr_esc_end><<EOF>> { return -1; }\n+\n+\\x22                     { BEGIN(str); yymore(); }\n+<str>\\x22                { BEGIN(suffix); return LIT_STR; }\n+\n+<str><<EOF>>                { return -1; }\n+<str>\\\\[n\\nr\\rt\\\\\\x27\\x220] { yymore(); }\n+<str>\\\\x[0-9a-fA-F]{2}      { yymore(); }\n+<str>\\\\u\\{[0-9a-fA-F]?{6}\\} { yymore(); }\n+<str>\\\\[^n\\nrt\\\\\\x27\\x220]  { return -1; }\n+<str>(.|\\n)                 { yymore(); }\n+\n+\\<-  { return LARROW; }\n+-\\>  { return RARROW; }\n+-    { return '-'; }\n+-=   { return MINUSEQ; }\n+&&   { return ANDAND; }\n+&    { return '&'; }\n+&=   { return ANDEQ; }\n+\\|\\| { return OROR; }\n+\\|   { return '|'; }\n+\\|=  { return OREQ; }\n+\\+   { return '+'; }\n+\\+=  { return PLUSEQ; }\n+\\*   { return '*'; }\n+\\*=  { return STAREQ; }\n+\\/   { return '/'; }\n+\\/=  { return SLASHEQ; }\n+\\^   { return '^'; }\n+\\^=  { return CARETEQ; }\n+%    { return '%'; }\n+%=   { return PERCENTEQ; }\n+\n+<<EOF>> { return 0; }\n+\n+%%"}, {"sha": "db88a1f2999aa56a8fdac9d26472e20c3b9c824f", "filename": "src/grammar/parser-lalr-main.c", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/rust-lang/rust/raw/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr-main.c?ref=20de961226de41a18ca1d9b166c6bc607f3a597a", "patch": "@@ -0,0 +1,203 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#include <stdio.h>\n+#include <stdarg.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n+extern int yylex();\n+extern int rsparse();\n+\n+#define PUSHBACK_LEN 4\n+\n+static char pushback[PUSHBACK_LEN];\n+static int verbose;\n+\n+void print(const char* format, ...) {\n+  va_list args;\n+  va_start(args, format);\n+  if (verbose) {\n+    vprintf(format, args);\n+  }\n+  va_end(args);\n+}\n+\n+// If there is a non-null char at the head of the pushback queue,\n+// dequeue it and shift the rest of the queue forwards. Otherwise,\n+// return the token from calling yylex.\n+int rslex() {\n+  if (pushback[0] == '\\0') {\n+    return yylex();\n+  } else {\n+    char c = pushback[0];\n+    memmove(pushback, pushback + 1, PUSHBACK_LEN - 1);\n+    pushback[PUSHBACK_LEN - 1] = '\\0';\n+    return c;\n+  }\n+}\n+\n+// Note: this does nothing if the pushback queue is full. As long as\n+// there aren't more than PUSHBACK_LEN consecutive calls to push_back\n+// in an action, this shouldn't be a problem.\n+void push_back(char c) {\n+  for (int i = 0; i < PUSHBACK_LEN; ++i) {\n+    if (pushback[i] == '\\0') {\n+      pushback[i] = c;\n+      break;\n+    }\n+  }\n+}\n+\n+extern int rsdebug;\n+\n+struct node {\n+  struct node *next;\n+  struct node *prev;\n+  int own_string;\n+  char const *name;\n+  int n_elems;\n+  struct node *elems[];\n+};\n+\n+struct node *nodes = NULL;\n+int n_nodes;\n+\n+struct node *mk_node(char const *name, int n, ...) {\n+  va_list ap;\n+  int i = 0;\n+  unsigned sz = sizeof(struct node) + (n * sizeof(struct node *));\n+  struct node *nn, *nd = (struct node *)malloc(sz);\n+\n+  print(\"# New %d-ary node: %s = %p\\n\", n, name, nd);\n+\n+  nd->own_string = 0;\n+  nd->prev = NULL;\n+  nd->next = nodes;\n+  if (nodes) {\n+    nodes->prev = nd;\n+  }\n+  nodes = nd;\n+\n+  nd->name = name;\n+  nd->n_elems = n;\n+\n+  va_start(ap, n);\n+  while (i < n) {\n+    nn = va_arg(ap, struct node *);\n+    print(\"#   arg[%d]: %p\\n\", i, nn);\n+    print(\"#            (%s ...)\\n\", nn->name);\n+    nd->elems[i++] = nn;\n+  }\n+  va_end(ap);\n+  n_nodes++;\n+  return nd;\n+}\n+\n+struct node *mk_atom(char *name) {\n+  struct node *nd = mk_node((char const *)strdup(name), 0);\n+  nd->own_string = 1;\n+  return nd;\n+}\n+\n+struct node *mk_none() {\n+  return mk_atom(\"<none>\");\n+}\n+\n+struct node *ext_node(struct node *nd, int n, ...) {\n+  va_list ap;\n+  int i = 0, c = nd->n_elems + n;\n+  unsigned sz = sizeof(struct node) + (c * sizeof(struct node *));\n+  struct node *nn;\n+\n+  print(\"# Extending %d-ary node by %d nodes: %s = %p\",\n+        nd->n_elems, c, nd->name, nd);\n+\n+  if (nd->next) {\n+    nd->next->prev = nd->prev;\n+  }\n+  if (nd->prev) {\n+    nd->prev->next = nd->next;\n+  }\n+  nd = realloc(nd, sz);\n+  nd->prev = NULL;\n+  nd->next = nodes;\n+  nodes->prev = nd;\n+  nodes = nd;\n+\n+  print(\" ==> %p\\n\", nd);\n+\n+  va_start(ap, n);\n+  while (i < n) {\n+    nn = va_arg(ap, struct node *);\n+    print(\"#   arg[%d]: %p\\n\", i, nn);\n+    print(\"#            (%s ...)\\n\", nn->name);\n+    nd->elems[nd->n_elems++] = nn;\n+    ++i;\n+  }\n+  va_end(ap);\n+  return nd;\n+}\n+\n+int const indent_step = 4;\n+\n+void print_indent(int depth) {\n+  while (depth) {\n+    if (depth-- % indent_step == 0) {\n+      print(\"|\");\n+    } else {\n+      print(\" \");\n+    }\n+  }\n+}\n+\n+void print_node(struct node *n, int depth) {\n+  int i = 0;\n+  print_indent(depth);\n+  if (n->n_elems == 0) {\n+    print(\"%s\\n\", n->name);\n+  } else {\n+    print(\"(%s\\n\", n->name);\n+    for (i = 0; i < n->n_elems; ++i) {\n+      print_node(n->elems[i], depth + indent_step);\n+    }\n+    print_indent(depth);\n+    print(\")\\n\");\n+  }\n+}\n+\n+int main(int argc, char **argv) {\n+  if (argc == 2 && strcmp(argv[1], \"-v\") == 0) {\n+    verbose = 1;\n+  } else {\n+    verbose = 0;\n+  }\n+  int ret = 0;\n+  struct node *tmp;\n+  memset(pushback, '\\0', PUSHBACK_LEN);\n+  ret = rsparse();\n+  print(\"--- PARSE COMPLETE: ret:%d, n_nodes:%d ---\\n\", ret, n_nodes);\n+  if (nodes) {\n+    print_node(nodes, 0);\n+  }\n+  while (nodes) {\n+    tmp = nodes;\n+    nodes = tmp->next;\n+    if (tmp->own_string) {\n+      free((void*)tmp->name);\n+    }\n+    free(tmp);\n+  }\n+  return ret;\n+}\n+\n+void rserror(char const *s) {\n+  fprintf(stderr, \"%s\\n\", s);\n+}"}, {"sha": "c9fcdf7647b9cfa79e42164ca858d728a7685dd7", "filename": "src/grammar/parser-lalr.y", "status": "added", "additions": 1945, "deletions": 0, "changes": 1945, "blob_url": "https://github.com/rust-lang/rust/blob/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/rust-lang/rust/raw/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fparser-lalr.y?ref=20de961226de41a18ca1d9b166c6bc607f3a597a", "patch": "@@ -0,0 +1,1945 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+%{\n+#define YYERROR_VERBOSE\n+#define YYSTYPE struct node *\n+struct node;\n+extern int yylex();\n+extern void yyerror(char const *s);\n+extern struct node *mk_node(char const *name, int n, ...);\n+extern struct node *mk_atom(char *text);\n+extern struct node *mk_none();\n+extern struct node *ext_node(struct node *nd, int n, ...);\n+extern void push_back(char c);\n+extern char *yytext;\n+%}\n+%debug\n+\n+%token SHL\n+%token SHR\n+%token LE\n+%token EQEQ\n+%token NE\n+%token GE\n+%token ANDAND\n+%token OROR\n+%token SHLEQ\n+%token SHREQ\n+%token MINUSEQ\n+%token ANDEQ\n+%token OREQ\n+%token PLUSEQ\n+%token STAREQ\n+%token SLASHEQ\n+%token CARETEQ\n+%token PERCENTEQ\n+%token DOTDOT\n+%token DOTDOTDOT\n+%token MOD_SEP\n+%token RARROW\n+%token LARROW\n+%token FAT_ARROW\n+%token LIT_BYTE\n+%token LIT_CHAR\n+%token LIT_INTEGER\n+%token LIT_FLOAT\n+%token LIT_STR\n+%token LIT_STR_RAW\n+%token LIT_BYTE_STR\n+%token LIT_BYTE_STR_RAW\n+%token IDENT\n+%token UNDERSCORE\n+%token LIFETIME\n+\n+// keywords\n+%token SELF\n+%token STATIC\n+%token AS\n+%token BREAK\n+%token CRATE\n+%token ELSE\n+%token ENUM\n+%token EXTERN\n+%token FALSE\n+%token FN\n+%token FOR\n+%token IF\n+%token IMPL\n+%token IN\n+%token LET\n+%token LOOP\n+%token MATCH\n+%token MOD\n+%token MOVE\n+%token MUT\n+%token PRIV\n+%token PUB\n+%token REF\n+%token RETURN\n+%token STRUCT\n+%token TRUE\n+%token TRAIT\n+%token TYPE\n+%token UNSAFE\n+%token DEFAULT\n+%token USE\n+%token WHILE\n+%token CONTINUE\n+%token PROC\n+%token BOX\n+%token CONST\n+%token WHERE\n+%token TYPEOF\n+%token INNER_DOC_COMMENT\n+%token OUTER_DOC_COMMENT\n+\n+%token SHEBANG\n+%token SHEBANG_LINE\n+%token STATIC_LIFETIME\n+\n+ /*\n+   Quoting from the Bison manual:\n+\n+   \"Finally, the resolution of conflicts works by comparing the precedence\n+   of the rule being considered with that of the lookahead token. If the\n+   token's precedence is higher, the choice is to shift. If the rule's\n+   precedence is higher, the choice is to reduce. If they have equal\n+   precedence, the choice is made based on the associativity of that\n+   precedence level. The verbose output file made by \u2018-v\u2019 (see Invoking\n+   Bison) says how each conflict was resolved\"\n+ */\n+\n+// We expect no shift/reduce or reduce/reduce conflicts in this grammar;\n+// all potential ambiguities are scrutinized and eliminated manually.\n+%expect 0\n+\n+// fake-precedence symbol to cause '|' bars in lambda context to parse\n+// at low precedence, permit things like |x| foo = bar, where '=' is\n+// otherwise lower-precedence than '|'. Also used for proc() to cause\n+// things like proc() a + b to parse as proc() { a + b }.\n+%precedence LAMBDA\n+\n+%precedence SELF\n+\n+// MUT should be lower precedence than IDENT so that in the pat rule,\n+// \"& MUT pat\" has higher precedence than \"binding_mode ident [@ pat]\"\n+%precedence MUT\n+\n+// IDENT needs to be lower than '{' so that 'foo {' is shifted when\n+// trying to decide if we've got a struct-construction expr (esp. in\n+// contexts like 'if foo { .')\n+//\n+// IDENT also needs to be lower precedence than '<' so that '<' in\n+// 'foo:bar . <' is shifted (in a trait reference occurring in a\n+// bounds list), parsing as foo:(bar<baz>) rather than (foo:bar)<baz>.\n+%precedence IDENT\n+\n+// A couple fake-precedence symbols to use in rules associated with +\n+// and < in trailing type contexts. These come up when you have a type\n+// in the RHS of operator-AS, such as \"foo as bar<baz>\". The \"<\" there\n+// has to be shifted so the parser keeps trying to parse a type, even\n+// though it might well consider reducing the type \"bar\" and then\n+// going on to \"<\" as a subsequent binop. The \"+\" case is with\n+// trailing type-bounds (\"foo as bar:A+B\"), for the same reason.\n+%precedence SHIFTPLUS\n+\n+%precedence MOD_SEP\n+%precedence RARROW ':'\n+\n+// In where clauses, \"for\" should have greater precedence when used as\n+// a higher ranked constraint than when used as the beginning of a\n+// for_in_type (which is a ty)\n+%precedence FORTYPE\n+%precedence FOR\n+\n+// Binops & unops, and their precedences\n+%precedence BOX\n+%precedence BOXPLACE\n+%nonassoc DOTDOT\n+\n+// RETURN needs to be lower-precedence than tokens that start\n+// prefix_exprs\n+%precedence RETURN\n+\n+%right '=' SHLEQ SHREQ MINUSEQ ANDEQ OREQ PLUSEQ STAREQ SLASHEQ CARETEQ PERCENTEQ\n+%right LARROW\n+%left OROR\n+%left ANDAND\n+%left EQEQ NE\n+%left '<' '>' LE GE\n+%left '|'\n+%left '^'\n+%left '&'\n+%left SHL SHR\n+%left '+' '-'\n+%precedence AS\n+%left '*' '/' '%'\n+%precedence '!'\n+\n+%precedence '{' '[' '(' '.'\n+\n+%precedence RANGE\n+\n+%start crate\n+\n+%%\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 1: Items and attributes\n+////////////////////////////////////////////////////////////////////////\n+\n+crate\n+: maybe_shebang inner_attrs maybe_mod_items  { mk_node(\"crate\", 2, $2, $3); }\n+| maybe_shebang maybe_mod_items  { mk_node(\"crate\", 1, $2); }\n+;\n+\n+maybe_shebang\n+: SHEBANG_LINE\n+| %empty\n+;\n+\n+maybe_inner_attrs\n+: inner_attrs\n+| %empty                   { $$ = mk_none(); }\n+;\n+\n+inner_attrs\n+: inner_attr               { $$ = mk_node(\"InnerAttrs\", 1, $1); }\n+| inner_attrs inner_attr   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+inner_attr\n+: SHEBANG '[' meta_item ']'   { $$ = mk_node(\"InnerAttr\", 1, $3); }\n+| INNER_DOC_COMMENT           { $$ = mk_node(\"InnerAttr\", 1, mk_node(\"doc-comment\", 1, mk_atom(yytext))); }\n+;\n+\n+maybe_outer_attrs\n+: outer_attrs\n+| %empty                   { $$ = mk_none(); }\n+;\n+\n+outer_attrs\n+: outer_attr               { $$ = mk_node(\"OuterAttrs\", 1, $1); }\n+| outer_attrs outer_attr   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+outer_attr\n+: '#' '[' meta_item ']'    { $$ = $3; }\n+| OUTER_DOC_COMMENT        { $$ = mk_node(\"doc-comment\", 1, mk_atom(yytext)); }\n+;\n+\n+meta_item\n+: ident                      { $$ = mk_node(\"MetaWord\", 1, $1); }\n+| ident '=' lit              { $$ = mk_node(\"MetaNameValue\", 2, $1, $3); }\n+| ident '(' meta_seq ')'     { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n+| ident '(' meta_seq ',' ')' { $$ = mk_node(\"MetaList\", 2, $1, $3); }\n+;\n+\n+meta_seq\n+: %empty                   { $$ = mk_none(); }\n+| meta_item                { $$ = mk_node(\"MetaItems\", 1, $1); }\n+| meta_seq ',' meta_item   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+maybe_mod_items\n+: mod_items\n+| %empty             { $$ = mk_none(); }\n+;\n+\n+mod_items\n+: mod_item                               { $$ = mk_node(\"Items\", 1, $1); }\n+| mod_items mod_item                     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+attrs_and_vis\n+: maybe_outer_attrs visibility           { $$ = mk_node(\"AttrsAndVis\", 2, $1, $2); }\n+;\n+\n+mod_item\n+: attrs_and_vis item    { $$ = mk_node(\"Item\", 2, $1, $2); }\n+;\n+\n+// items that can appear outside of a fn block\n+item\n+: stmt_item\n+| item_macro\n+;\n+\n+// items that can appear in \"stmts\"\n+stmt_item\n+: item_static\n+| item_const\n+| item_type\n+| block_item\n+| view_item\n+;\n+\n+item_static\n+: STATIC ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $2, $4, $6); }\n+| STATIC MUT ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemStatic\", 3, $3, $5, $7); }\n+;\n+\n+item_const\n+: CONST ident ':' ty '=' expr ';'  { $$ = mk_node(\"ItemConst\", 3, $2, $4, $6); }\n+;\n+\n+item_macro\n+: path_expr '!' maybe_ident parens_delimited_token_trees ';'  { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n+| path_expr '!' maybe_ident braces_delimited_token_trees      { $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n+| path_expr '!' maybe_ident brackets_delimited_token_trees ';'{ $$ = mk_node(\"ItemMacro\", 3, $1, $3, $4); }\n+;\n+\n+view_item\n+: use_item\n+| extern_fn_item\n+| EXTERN CRATE ident ';'                      { $$ = mk_node(\"ViewItemExternCrate\", 1, $3); }\n+| EXTERN CRATE ident AS ident ';'             { $$ = mk_node(\"ViewItemExternCrate\", 2, $3, $5); }\n+;\n+\n+extern_fn_item\n+: EXTERN maybe_abi item_fn                    { $$ = mk_node(\"ViewItemExternFn\", 2, $2, $3); }\n+;\n+\n+use_item\n+: USE view_path ';'                           { $$ = mk_node(\"ViewItemUse\", 1, $2); }\n+;\n+\n+view_path\n+: path_no_types_allowed                                    { $$ = mk_node(\"ViewPathSimple\", 1, $1); }\n+| path_no_types_allowed MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, mk_atom(\"ViewPathListEmpty\")); }\n+|                       MOD_SEP '{'                '}'     { $$ = mk_node(\"ViewPathList\", 1, mk_atom(\"ViewPathListEmpty\")); }\n+| path_no_types_allowed MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n+|                       MOD_SEP '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $3); }\n+| path_no_types_allowed MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 2, $1, $4); }\n+|                       MOD_SEP '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $3); }\n+| path_no_types_allowed MOD_SEP '*'                        { $$ = mk_node(\"ViewPathGlob\", 1, $1); }\n+|                               '{'                '}'     { $$ = mk_atom(\"ViewPathListEmpty\"); }\n+|                               '{' idents_or_self '}'     { $$ = mk_node(\"ViewPathList\", 1, $2); }\n+|                               '{' idents_or_self ',' '}' { $$ = mk_node(\"ViewPathList\", 1, $2); }\n+| path_no_types_allowed AS ident                           { $$ = mk_node(\"ViewPathSimple\", 2, $1, $3); }\n+;\n+\n+block_item\n+: item_fn\n+| item_unsafe_fn\n+| item_mod\n+| item_foreign_mod          { $$ = mk_node(\"ItemForeignMod\", 1, $1); }\n+| item_struct\n+| item_enum\n+| item_trait\n+| item_impl\n+;\n+\n+maybe_ty_ascription\n+: ':' ty_sum { $$ = $2; }\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_init_expr\n+: '=' expr { $$ = $2; }\n+| %empty   { $$ = mk_none(); }\n+;\n+\n+// structs\n+item_struct\n+: STRUCT ident generic_params maybe_where_clause struct_decl_args\n+{\n+  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n+}\n+| STRUCT ident generic_params struct_tuple_args maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"ItemStruct\", 4, $2, $3, $4, $5);\n+}\n+| STRUCT ident generic_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"ItemStruct\", 3, $2, $3, $4);\n+}\n+;\n+\n+struct_decl_args\n+: '{' struct_decl_fields '}'                  { $$ = $2; }\n+| '{' struct_decl_fields ',' '}'              { $$ = $2; }\n+;\n+\n+struct_tuple_args\n+: '(' struct_tuple_fields ')'                 { $$ = $2; }\n+| '(' struct_tuple_fields ',' ')'             { $$ = $2; }\n+;\n+\n+struct_decl_fields\n+: struct_decl_field                           { $$ = mk_node(\"StructFields\", 1, $1); }\n+| struct_decl_fields ',' struct_decl_field    { $$ = ext_node($1, 1, $3); }\n+| %empty                                      { $$ = mk_none(); }\n+;\n+\n+struct_decl_field\n+: attrs_and_vis ident ':' ty_sum              { $$ = mk_node(\"StructField\", 3, $1, $2, $4); }\n+;\n+\n+struct_tuple_fields\n+: struct_tuple_field                          { $$ = mk_node(\"StructFields\", 1, $1); }\n+| struct_tuple_fields ',' struct_tuple_field  { $$ = ext_node($1, 1, $3); }\n+;\n+\n+struct_tuple_field\n+: attrs_and_vis ty_sum                    { $$ = mk_node(\"StructField\", 2, $1, $2); }\n+;\n+\n+// enums\n+item_enum\n+: ENUM ident generic_params maybe_where_clause '{' enum_defs '}'     { $$ = mk_node(\"ItemEnum\", 0); }\n+| ENUM ident generic_params maybe_where_clause '{' enum_defs ',' '}' { $$ = mk_node(\"ItemEnum\", 0); }\n+;\n+\n+enum_defs\n+: enum_def               { $$ = mk_node(\"EnumDefs\", 1, $1); }\n+| enum_defs ',' enum_def { $$ = ext_node($1, 1, $3); }\n+| %empty                 { $$ = mk_none(); }\n+;\n+\n+enum_def\n+: attrs_and_vis ident enum_args { $$ = mk_node(\"EnumDef\", 3, $1, $2, $3); }\n+;\n+\n+enum_args\n+: '{' struct_decl_fields '}'     { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '{' struct_decl_fields ',' '}' { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '(' maybe_ty_sums ')'          { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| '=' expr                       { $$ = mk_node(\"EnumArgs\", 1, $2); }\n+| %empty                         { $$ = mk_none(); }\n+;\n+\n+item_mod\n+: MOD ident ';'                                 { $$ = mk_node(\"ItemMod\", 1, $2); }\n+| MOD ident '{' maybe_mod_items '}'             { $$ = mk_node(\"ItemMod\", 2, $2, $4); }\n+| MOD ident '{' inner_attrs maybe_mod_items '}' { $$ = mk_node(\"ItemMod\", 3, $2, $4, $5); }\n+;\n+\n+item_foreign_mod\n+: EXTERN maybe_abi '{' maybe_foreign_items '}'             { $$ = mk_node(\"ItemForeignMod\", 1, $4); }\n+| EXTERN maybe_abi '{' inner_attrs maybe_foreign_items '}' { $$ = mk_node(\"ItemForeignMod\", 2, $4, $5); }\n+;\n+\n+maybe_abi\n+: str\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_foreign_items\n+: foreign_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+foreign_items\n+: foreign_item               { $$ = mk_node(\"ForeignItems\", 1, $1); }\n+| foreign_items foreign_item { $$ = ext_node($1, 1, $2); }\n+;\n+\n+foreign_item\n+: attrs_and_vis STATIC item_foreign_static { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n+| attrs_and_vis item_foreign_fn            { $$ = mk_node(\"ForeignItem\", 2, $1, $2); }\n+| attrs_and_vis UNSAFE item_foreign_fn     { $$ = mk_node(\"ForeignItem\", 2, $1, $3); }\n+;\n+\n+item_foreign_static\n+: maybe_mut ident ':' ty ';'               { $$ = mk_node(\"StaticItem\", 3, $1, $2, $4); }\n+;\n+\n+item_foreign_fn\n+: FN ident generic_params fn_decl_allow_variadic maybe_where_clause ';' { $$ = mk_node(\"ForeignFn\", 4, $2, $3, $4, $5); }\n+;\n+\n+fn_decl_allow_variadic\n+: fn_params_allow_variadic ret_ty { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_params_allow_variadic\n+: '(' ')'                      { $$ = mk_none(); }\n+| '(' params ')'               { $$ = $2; }\n+| '(' params ',' ')'           { $$ = $2; }\n+| '(' params ',' DOTDOTDOT ')' { $$ = $2; }\n+;\n+\n+visibility\n+: PUB      { $$ = mk_atom(\"Public\"); }\n+| %empty   { $$ = mk_atom(\"Inherited\"); }\n+;\n+\n+idents_or_self\n+: ident_or_self                    { $$ = mk_node(\"IdentsOrSelf\", 1, $1); }\n+| ident_or_self AS ident           { $$ = mk_node(\"IdentsOrSelf\", 2, $1, $3); }\n+| idents_or_self ',' ident_or_self { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ident_or_self\n+: ident\n+| SELF  { $$ = mk_atom(yytext); }\n+;\n+\n+item_type\n+: TYPE ident generic_params maybe_where_clause '=' ty_sum ';'  { $$ = mk_node(\"ItemTy\", 4, $2, $3, $4, $6); }\n+;\n+\n+for_sized\n+: FOR '?' ident { $$ = mk_node(\"ForSized\", 1, $3); }\n+| FOR ident '?' { $$ = mk_node(\"ForSized\", 1, $2); }\n+| %empty        { $$ = mk_none(); }\n+;\n+\n+item_trait\n+: maybe_unsafe TRAIT ident generic_params for_sized maybe_ty_param_bounds maybe_where_clause '{' maybe_trait_items '}'\n+{\n+  $$ = mk_node(\"ItemTrait\", 7, $1, $3, $4, $5, $6, $7, $9);\n+}\n+;\n+\n+maybe_trait_items\n+: trait_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+trait_items\n+: trait_item               { $$ = mk_node(\"TraitItems\", 1, $1); }\n+| trait_items trait_item   { $$ = ext_node($1, 1, $2); }\n+;\n+\n+trait_item\n+: trait_const\n+| trait_type\n+| trait_method\n+;\n+\n+trait_const\n+: maybe_outer_attrs CONST ident maybe_ty_ascription maybe_const_default ';' { $$ = mk_node(\"ConstTraitItem\", 4, $1, $3, $4, $5); }\n+;\n+\n+maybe_const_default\n+: '=' expr { $$ = mk_node(\"ConstDefault\", 1, $2); }\n+| %empty   { $$ = mk_none(); }\n+;\n+\n+trait_type\n+: maybe_outer_attrs TYPE ty_param ';' { $$ = mk_node(\"TypeTraitItem\", 2, $1, $3); }\n+;\n+\n+maybe_unsafe\n+: UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_default_maybe_unsafe\n+: DEFAULT UNSAFE { $$ = mk_atom(\"DefaultUnsafe\"); }\n+| DEFAULT        { $$ = mk_atom(\"Default\"); }\n+|         UNSAFE { $$ = mk_atom(\"Unsafe\"); }\n+| %empty { $$ = mk_none(); }\n+\n+trait_method\n+: type_method { $$ = mk_node(\"Required\", 1, $1); }\n+| method      { $$ = mk_node(\"Provided\", 1, $1); }\n+;\n+\n+type_method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 6, $1, $2, $4, $5, $6, $7);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause ';'\n+{\n+  $$ = mk_node(\"TypeMethod\", 7, $1, $2, $4, $6, $7, $8, $9);\n+}\n+;\n+\n+method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self_allow_anon_params maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n+}\n+;\n+\n+impl_method\n+: attrs_and_vis maybe_unsafe FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 7, $1, $2, $4, $5, $6, $7, $8);\n+}\n+| attrs_and_vis maybe_unsafe EXTERN maybe_abi FN ident generic_params fn_decl_with_self maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"Method\", 8, $1, $2, $4, $6, $7, $8, $9, $10);\n+}\n+;\n+\n+// There are two forms of impl:\n+//\n+// impl (<...>)? TY { ... }\n+// impl (<...>)? TRAIT for TY { ... }\n+//\n+// Unfortunately since TY can begin with '<' itself -- as part of a\n+// TyQualifiedPath type -- there's an s/r conflict when we see '<' after IMPL:\n+// should we reduce one of the early rules of TY (such as maybe_once)\n+// or shall we continue shifting into the generic_params list for the\n+// impl?\n+//\n+// The production parser disambiguates a different case here by\n+// permitting / requiring the user to provide parens around types when\n+// they are ambiguous with traits. We do the same here, regrettably,\n+// by splitting ty into ty and ty_prim.\n+item_impl\n+: maybe_default_maybe_unsafe IMPL generic_params ty_prim_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $1, $3, $4, $5, $7, $8);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params '(' ty ')' maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $1, $3, 5, $6, $9, $10);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImpl\", 6, $3, $4, $6, $7, $9, $10);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR ty_sum maybe_where_clause '{' maybe_inner_attrs maybe_impl_items '}'\n+{\n+  $$ = mk_node(\"ItemImplNeg\", 7, $1, $3, $5, $7, $8, $10, $11);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params trait_ref FOR DOTDOT '{' '}'\n+{\n+  $$ = mk_node(\"ItemImplDefault\", 3, $1, $3, $4);\n+}\n+| maybe_default_maybe_unsafe IMPL generic_params '!' trait_ref FOR DOTDOT '{' '}'\n+{\n+  $$ = mk_node(\"ItemImplDefaultNeg\", 3, $1, $3, $4);\n+}\n+;\n+\n+maybe_impl_items\n+: impl_items\n+| %empty { $$ = mk_none(); }\n+;\n+\n+impl_items\n+: impl_item               { $$ = mk_node(\"ImplItems\", 1, $1); }\n+| impl_item impl_items    { $$ = ext_node($1, 1, $2); }\n+;\n+\n+impl_item\n+: impl_method\n+| attrs_and_vis item_macro { $$ = mk_node(\"ImplMacroItem\", 2, $1, $2); }\n+| impl_const\n+| impl_type\n+;\n+\n+impl_const\n+: attrs_and_vis item_const { $$ = mk_node(\"ImplConst\", 1, $1, $2); }\n+;\n+\n+impl_type\n+: attrs_and_vis TYPE ident generic_params '=' ty_sum ';'  { $$ = mk_node(\"ImplType\", 4, $1, $3, $4, $6); }\n+;\n+\n+item_fn\n+: FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemFn\", 5, $2, $3, $4, $5, $6);\n+}\n+;\n+\n+item_unsafe_fn\n+: UNSAFE FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 5, $3, $4, $5, $6, $7);\n+}\n+| UNSAFE EXTERN maybe_abi FN ident generic_params fn_decl maybe_where_clause inner_attrs_and_block\n+{\n+  $$ = mk_node(\"ItemUnsafeFn\", 6, $3, $5, $6, $7, $8, $9);\n+}\n+;\n+\n+fn_decl\n+: fn_params ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_decl_with_self\n+: fn_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_decl_with_self_allow_anon_params\n+: fn_anon_params_with_self ret_ty   { $$ = mk_node(\"FnDecl\", 2, $1, $2); }\n+;\n+\n+fn_params\n+: '(' maybe_params ')'  { $$ = $2; }\n+;\n+\n+fn_anon_params\n+: '(' anon_param anon_params_allow_variadic_tail ')' { $$ = ext_node($2, 1, $3); }\n+| '(' ')'                                            { $$ = mk_none(); }\n+;\n+\n+fn_params_with_self\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n+| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n+| '(' maybe_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n+;\n+\n+fn_anon_params_with_self\n+: '(' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'              { $$ = mk_node(\"SelfValue\", 3, $2, $4, $5); }\n+| '(' '&' maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')'          { $$ = mk_node(\"SelfRegion\", 3, $3, $5, $6); }\n+| '(' '&' lifetime maybe_mut SELF maybe_ty_ascription maybe_comma_anon_params ')' { $$ = mk_node(\"SelfRegion\", 4, $3, $4, $6, $7); }\n+| '(' maybe_anon_params ')'                                                       { $$ = mk_node(\"SelfStatic\", 1, $2); }\n+;\n+\n+maybe_params\n+: params\n+| params ','\n+| %empty  { $$ = mk_none(); }\n+;\n+\n+params\n+: param                { $$ = mk_node(\"Args\", 1, $1); }\n+| params ',' param     { $$ = ext_node($1, 1, $3); }\n+;\n+\n+param\n+: pat ':' ty_sum   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n+;\n+\n+inferrable_params\n+: inferrable_param                       { $$ = mk_node(\"InferrableParams\", 1, $1); }\n+| inferrable_params ',' inferrable_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+inferrable_param\n+: pat maybe_ty_ascription { $$ = mk_node(\"InferrableParam\", 2, $1, $2); }\n+;\n+\n+maybe_unboxed_closure_kind\n+: %empty\n+| ':'\n+| '&' maybe_mut ':'\n+;\n+\n+maybe_comma_params\n+: ','            { $$ = mk_none(); }\n+| ',' params     { $$ = $2; }\n+| ',' params ',' { $$ = $2; }\n+| %empty         { $$ = mk_none(); }\n+;\n+\n+maybe_comma_anon_params\n+: ','                 { $$ = mk_none(); }\n+| ',' anon_params     { $$ = $2; }\n+| ',' anon_params ',' { $$ = $2; }\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+maybe_anon_params\n+: anon_params\n+| anon_params ','\n+| %empty      { $$ = mk_none(); }\n+;\n+\n+anon_params\n+: anon_param                 { $$ = mk_node(\"Args\", 1, $1); }\n+| anon_params ',' anon_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// anon means it's allowed to be anonymous (type-only), but it can\n+// still have a name\n+anon_param\n+: named_arg ':' ty   { $$ = mk_node(\"Arg\", 2, $1, $3); }\n+| ty\n+;\n+\n+anon_params_allow_variadic_tail\n+: ',' DOTDOTDOT                                  { $$ = mk_none(); }\n+| ',' anon_param anon_params_allow_variadic_tail { $$ = mk_node(\"Args\", 2, $2, $3); }\n+| %empty                                         { $$ = mk_none(); }\n+;\n+\n+named_arg\n+: ident\n+| UNDERSCORE        { $$ = mk_atom(\"PatWild\"); }\n+| '&' ident         { $$ = $2; }\n+| '&' UNDERSCORE    { $$ = mk_atom(\"PatWild\"); }\n+| ANDAND ident      { $$ = $2; }\n+| ANDAND UNDERSCORE { $$ = mk_atom(\"PatWild\"); }\n+| MUT ident         { $$ = $2; }\n+;\n+\n+ret_ty\n+: RARROW '!'         { $$ = mk_none(); }\n+| RARROW ty          { $$ = mk_node(\"ret-ty\", 1, $2); }\n+| %prec IDENT %empty { $$ = mk_none(); }\n+;\n+\n+generic_params\n+: '<' lifetimes '>'                   { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' '>'               { $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, mk_none()); }\n+| '<' lifetimes ',' ty_params '>'     { $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params ',' '>' { $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params SHR     { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' lifetimes ',' ty_params ',' SHR { push_back('>'); $$ = mk_node(\"Generics\", 2, $2, $4); }\n+| '<' ty_params '>'                   { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params ',' '>'               { $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params SHR                   { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| '<' ty_params ',' SHR               { push_back('>'); $$ = mk_node(\"Generics\", 2, mk_none(), $2); }\n+| %empty                              { $$ = mk_none(); }\n+;\n+\n+maybe_where_clause\n+: %empty                              { $$ = mk_none(); }\n+| where_clause\n+;\n+\n+where_clause\n+: WHERE where_predicates              { $$ = mk_node(\"WhereClause\", 1, $2); }\n+| WHERE where_predicates ','          { $$ = mk_node(\"WhereClause\", 1, $2); }\n+;\n+\n+where_predicates\n+: where_predicate                      { $$ = mk_node(\"WherePredicates\", 1, $1); }\n+| where_predicates ',' where_predicate { $$ = ext_node($1, 1, $3); }\n+;\n+\n+where_predicate\n+: maybe_for_lifetimes lifetime ':' bounds    { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n+| maybe_for_lifetimes ty ':' ty_param_bounds { $$ = mk_node(\"WherePredicate\", 3, $1, $2, $4); }\n+;\n+\n+maybe_for_lifetimes\n+: FOR '<' lifetimes '>' { $$ = mk_none(); }\n+| %prec FORTYPE %empty  { $$ = mk_none(); }\n+\n+ty_params\n+: ty_param               { $$ = mk_node(\"TyParams\", 1, $1); }\n+| ty_params ',' ty_param { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// A path with no type parameters; e.g. `foo::bar::Baz`\n+//\n+// These show up in 'use' view-items, because these are processed\n+// without respect to types.\n+path_no_types_allowed\n+: ident                               { $$ = mk_node(\"ViewPath\", 1, $1); }\n+| MOD_SEP ident                       { $$ = mk_node(\"ViewPath\", 1, $2); }\n+| SELF                                { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| MOD_SEP SELF                        { $$ = mk_node(\"ViewPath\", 1, mk_atom(\"Self\")); }\n+| path_no_types_allowed MOD_SEP ident { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// A path with a lifetime and type parameters, with no double colons\n+// before the type parameters; e.g. `foo::bar<'a>::Baz<T>`\n+//\n+// These show up in \"trait references\", the components of\n+// type-parameter bounds lists, as well as in the prefix of the\n+// path_generic_args_and_bounds rule, which is the full form of a\n+// named typed expression.\n+//\n+// They do not have (nor need) an extra '::' before '<' because\n+// unlike in expr context, there are no \"less-than\" type exprs to\n+// be ambiguous with.\n+path_generic_args_without_colons\n+: %prec IDENT\n+  ident                                                                       { $$ = mk_node(\"components\", 1, $1); }\n+| %prec IDENT\n+  ident generic_args                                                          { $$ = mk_node(\"components\", 2, $1, $2); }\n+| %prec IDENT\n+  ident '(' maybe_ty_sums ')' ret_ty                                          { $$ = mk_node(\"components\", 2, $1, $3); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident                              { $$ = ext_node($1, 1, $3); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident generic_args                 { $$ = ext_node($1, 2, $3, $4); }\n+| %prec IDENT\n+  path_generic_args_without_colons MOD_SEP ident '(' maybe_ty_sums ')' ret_ty { $$ = ext_node($1, 2, $3, $5); }\n+;\n+\n+generic_args\n+: '<' generic_values '>'   { $$ = $2; }\n+| '<' generic_values SHR   { push_back('>'); $$ = $2; }\n+| '<' generic_values GE    { push_back('='); $$ = $2; }\n+| '<' generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n+// If generic_args starts with \"<<\", the first arg must be a\n+// TyQualifiedPath because that's the only type that can start with a\n+// '<'. This rule parses that as the first ty_sum and then continues\n+// with the rest of generic_values.\n+| SHL ty_qualified_path_and_generic_values '>'   { $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values SHR   { push_back('>'); $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values GE    { push_back('='); $$ = $2; }\n+| SHL ty_qualified_path_and_generic_values SHREQ { push_back('>'); push_back('='); $$ = $2; }\n+;\n+\n+generic_values\n+: maybe_lifetimes maybe_ty_sums_and_or_bindings { $$ = mk_node(\"GenericValues\", 2, $1, $2); }\n+;\n+\n+maybe_ty_sums_and_or_bindings\n+: ty_sums\n+| ty_sums ','\n+| ty_sums ',' bindings { $$ = mk_node(\"TySumsAndBindings\", 2, $1, $3); }\n+| bindings\n+| bindings ','\n+| %empty               { $$ = mk_none(); }\n+;\n+\n+maybe_bindings\n+: ',' bindings { $$ = $2; }\n+| %empty       { $$ = mk_none(); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 2: Patterns\n+////////////////////////////////////////////////////////////////////////\n+\n+pat\n+: UNDERSCORE                                      { $$ = mk_atom(\"PatWild\"); }\n+| '&' pat                                         { $$ = mk_node(\"PatRegion\", 1, $2); }\n+| '&' MUT pat                                     { $$ = mk_node(\"PatRegion\", 1, $3); }\n+| ANDAND pat                                      { $$ = mk_node(\"PatRegion\", 1, mk_node(\"PatRegion\", 1, $2)); }\n+| '(' ')'                                         { $$ = mk_atom(\"PatUnit\"); }\n+| '(' pat_tup ')'                                 { $$ = mk_node(\"PatTup\", 1, $2); }\n+| '(' pat_tup ',' ')'                             { $$ = mk_node(\"PatTup\", 1, $2); }\n+| '[' pat_vec ']'                                 { $$ = mk_node(\"PatVec\", 1, $2); }\n+| lit_or_path\n+| lit_or_path DOTDOTDOT lit_or_path               { $$ = mk_node(\"PatRange\", 2, $1, $3); }\n+| path_expr '{' pat_struct '}'                    { $$ = mk_node(\"PatStruct\", 2, $1, $3); }\n+| path_expr '(' DOTDOT ')'                        { $$ = mk_node(\"PatEnum\", 1, $1); }\n+| path_expr '(' pat_tup ')'                       { $$ = mk_node(\"PatEnum\", 2, $1, $3); }\n+| path_expr '!' maybe_ident delimited_token_trees { $$ = mk_node(\"PatMac\", 3, $1, $3, $4); }\n+| binding_mode ident                              { $$ = mk_node(\"PatIdent\", 2, $1, $2); }\n+|              ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, mk_node(\"BindByValue\", 1, mk_atom(\"MutImmutable\")), $1, $3); }\n+| binding_mode ident '@' pat                      { $$ = mk_node(\"PatIdent\", 3, $1, $2, $4); }\n+| BOX pat                                         { $$ = mk_node(\"PatUniq\", 1, $2); }\n+| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"PatQualifiedPath\", 3, $2, $3, $6); }\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n+{\n+  $$ = mk_node(\"PatQualifiedPath\", 3, mk_node(\"PatQualifiedPath\", 3, $2, $3, $6), $7, $10);\n+}\n+;\n+\n+pats_or\n+: pat              { $$ = mk_node(\"Pats\", 1, $1); }\n+| pats_or '|' pat  { $$ = ext_node($1, 1, $3); }\n+;\n+\n+binding_mode\n+: REF         { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutImmutable\")); }\n+| REF MUT     { $$ = mk_node(\"BindByRef\", 1, mk_atom(\"MutMutable\")); }\n+| MUT         { $$ = mk_node(\"BindByValue\", 1, mk_atom(\"MutMutable\")); }\n+;\n+\n+lit_or_path\n+: path_expr    { $$ = mk_node(\"PatLit\", 1, $1); }\n+| lit          { $$ = mk_node(\"PatLit\", 1, $1); }\n+| '-' lit      { $$ = mk_node(\"PatLit\", 1, $2); }\n+;\n+\n+pat_field\n+:                  ident        { $$ = mk_node(\"PatField\", 1, $1); }\n+|     binding_mode ident        { $$ = mk_node(\"PatField\", 2, $1, $2); }\n+| BOX              ident        { $$ = mk_node(\"PatField\", 2, mk_atom(\"box\"), $2); }\n+| BOX binding_mode ident        { $$ = mk_node(\"PatField\", 3, mk_atom(\"box\"), $2, $3); }\n+|              ident ':' pat    { $$ = mk_node(\"PatField\", 2, $1, $3); }\n+| binding_mode ident ':' pat    { $$ = mk_node(\"PatField\", 3, $1, $2, $4); }\n+;\n+\n+pat_fields\n+: pat_field                  { $$ = mk_node(\"PatFields\", 1, $1); }\n+| pat_fields ',' pat_field   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+pat_struct\n+: pat_fields                 { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n+| pat_fields ','             { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"false\")); }\n+| pat_fields ',' DOTDOT      { $$ = mk_node(\"PatStruct\", 2, $1, mk_atom(\"true\")); }\n+| DOTDOT                     { $$ = mk_node(\"PatStruct\", 1, mk_atom(\"true\")); }\n+;\n+\n+pat_tup\n+: pat               { $$ = mk_node(\"pat_tup\", 1, $1); }\n+| pat_tup ',' pat   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+pat_vec\n+: pat_vec_elts                                  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts                             ','  { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts     DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts ',' DOTDOT                       { $$ = mk_node(\"PatVec\", 2, $1, mk_none()); }\n+| pat_vec_elts     DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n+| pat_vec_elts     DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $4); }\n+| pat_vec_elts ',' DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n+| pat_vec_elts ',' DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, $1, $5); }\n+|                  DOTDOT ',' pat_vec_elts      { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n+|                  DOTDOT ',' pat_vec_elts ','  { $$ = mk_node(\"PatVec\", 2, mk_none(), $3); }\n+|                  DOTDOT                       { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n+| %empty                                        { $$ = mk_node(\"PatVec\", 2, mk_none(), mk_none()); }\n+;\n+\n+pat_vec_elts\n+: pat                    { $$ = mk_node(\"PatVecElts\", 1, $1); }\n+| pat_vec_elts ',' pat   { $$ = ext_node($1, 1, $3); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 3: Types\n+////////////////////////////////////////////////////////////////////////\n+\n+ty\n+: ty_prim\n+| ty_closure\n+| '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident                                      { $$ = mk_node(\"TyQualifiedPath\", 3, $2, $3, $6); }\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident { $$ = mk_node(\"TyQualifiedPath\", 3, mk_node(\"TyQualifiedPath\", 3, $2, $3, $6), $7, $10); }\n+| '(' ty_sums ')'                                                                      { $$ = mk_node(\"TyTup\", 1, $2); }\n+| '(' ty_sums ',' ')'                                                                  { $$ = mk_node(\"TyTup\", 1, $2); }\n+| '(' ')'                                                                              { $$ = mk_atom(\"TyNil\"); }\n+;\n+\n+ty_prim\n+: %prec IDENT path_generic_args_without_colons              { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"false\")), $1); }\n+| %prec IDENT MOD_SEP path_generic_args_without_colons      { $$ = mk_node(\"TyPath\", 2, mk_node(\"global\", 1, mk_atom(\"true\")), $2); }\n+| %prec IDENT SELF MOD_SEP path_generic_args_without_colons { $$ = mk_node(\"TyPath\", 2, mk_node(\"self\", 1, mk_atom(\"true\")), $3); }\n+| BOX ty                                                    { $$ = mk_node(\"TyBox\", 1, $2); }\n+| '*' maybe_mut_or_const ty                                 { $$ = mk_node(\"TyPtr\", 2, $2, $3); }\n+| '&' ty                                                    { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2); }\n+| '&' MUT ty                                                { $$ = mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3); }\n+| ANDAND ty                                                 { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutImmutable\"), $2)); }\n+| ANDAND MUT ty                                             { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 2, mk_atom(\"MutMutable\"), $3)); }\n+| '&' lifetime maybe_mut ty                                 { $$ = mk_node(\"TyRptr\", 3, $2, $3, $4); }\n+| ANDAND lifetime maybe_mut ty                              { $$ = mk_node(\"TyRptr\", 1, mk_node(\"TyRptr\", 3, $2, $3, $4)); }\n+| '[' ty ']'                                                { $$ = mk_node(\"TyVec\", 1, $2); }\n+| '[' ty ',' DOTDOT expr ']'                                { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $5); }\n+| '[' ty ';' expr ']'                                       { $$ = mk_node(\"TyFixedLengthVec\", 2, $2, $4); }\n+| TYPEOF '(' expr ')'                                       { $$ = mk_node(\"TyTypeof\", 1, $3); }\n+| UNDERSCORE                                                { $$ = mk_atom(\"TyInfer\"); }\n+| ty_bare_fn\n+| ty_proc\n+| for_in_type\n+;\n+\n+ty_bare_fn\n+:                         FN ty_fn_decl { $$ = $2; }\n+| UNSAFE                  FN ty_fn_decl { $$ = $3; }\n+|        EXTERN maybe_abi FN ty_fn_decl { $$ = $4; }\n+| UNSAFE EXTERN maybe_abi FN ty_fn_decl { $$ = $5; }\n+;\n+\n+ty_fn_decl\n+: generic_params fn_anon_params ret_ty { $$ = mk_node(\"TyFnDecl\", 3, $1, $2, $3); }\n+;\n+\n+ty_closure\n+: UNSAFE '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $3, $5, $6); }\n+|        '|' anon_params '|' maybe_bounds ret_ty { $$ = mk_node(\"TyClosure\", 3, $2, $4, $5); }\n+| UNSAFE OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $3, $4); }\n+|        OROR maybe_bounds ret_ty                { $$ = mk_node(\"TyClosure\", 2, $2, $3); }\n+;\n+\n+ty_proc\n+: PROC generic_params fn_params maybe_bounds ret_ty { $$ = mk_node(\"TyProc\", 4, $2, $3, $4, $5); }\n+;\n+\n+for_in_type\n+: FOR '<' maybe_lifetimes '>' for_in_type_suffix { $$ = mk_node(\"ForInType\", 2, $3, $5); }\n+;\n+\n+for_in_type_suffix\n+: ty_proc\n+| ty_bare_fn\n+| trait_ref\n+| ty_closure\n+;\n+\n+maybe_mut\n+: MUT              { $$ = mk_atom(\"MutMutable\"); }\n+| %prec MUT %empty { $$ = mk_atom(\"MutImmutable\"); }\n+;\n+\n+maybe_mut_or_const\n+: MUT    { $$ = mk_atom(\"MutMutable\"); }\n+| CONST  { $$ = mk_atom(\"MutImmutable\"); }\n+| %empty { $$ = mk_atom(\"MutImmutable\"); }\n+;\n+\n+ty_qualified_path_and_generic_values\n+: ty_qualified_path maybe_bindings\n+{\n+  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 1, mk_node(\"TySum\", 1, $1)), $2);\n+}\n+| ty_qualified_path ',' ty_sums maybe_bindings\n+{\n+  $$ = mk_node(\"GenericValues\", 3, mk_none(), mk_node(\"TySums\", 2, $1, $3), $4);\n+}\n+;\n+\n+ty_qualified_path\n+: ty_sum AS trait_ref '>' MOD_SEP ident                     { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n+| ty_sum AS trait_ref '>' MOD_SEP ident '+' ty_param_bounds { $$ = mk_node(\"TyQualifiedPath\", 3, $1, $3, $6); }\n+;\n+\n+maybe_ty_sums\n+: ty_sums\n+| ty_sums ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+ty_sums\n+: ty_sum             { $$ = mk_node(\"TySums\", 1, $1); }\n+| ty_sums ',' ty_sum { $$ = ext_node($1, 1, $3); }\n+;\n+\n+ty_sum\n+: ty                     { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+;\n+\n+ty_prim_sum\n+: ty_prim                     { $$ = mk_node(\"TySum\", 1, $1); }\n+| ty_prim '+' ty_param_bounds { $$ = mk_node(\"TySum\", 2, $1, $3); }\n+;\n+\n+maybe_ty_param_bounds\n+: ':' ty_param_bounds { $$ = $2; }\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+ty_param_bounds\n+: boundseq\n+| %empty { $$ = mk_none(); }\n+;\n+\n+boundseq\n+: polybound\n+| boundseq '+' polybound { $$ = ext_node($1, 1, $3); }\n+;\n+\n+polybound\n+: FOR '<' maybe_lifetimes '>' bound { $$ = mk_node(\"PolyBound\", 2, $3, $5); }\n+| bound\n+| '?' bound { $$ = $2; }\n+;\n+\n+bindings\n+: binding              { $$ = mk_node(\"Bindings\", 1, $1); }\n+| bindings ',' binding { $$ = ext_node($1, 1, $3); }\n+;\n+\n+binding\n+: ident '=' ty { mk_node(\"Binding\", 2, $1, $3); }\n+;\n+\n+ty_param\n+: ident maybe_ty_param_bounds maybe_ty_default           { $$ = mk_node(\"TyParam\", 3, $1, $2, $3); }\n+| ident '?' ident maybe_ty_param_bounds maybe_ty_default { $$ = mk_node(\"TyParam\", 4, $1, $3, $4, $5); }\n+;\n+\n+maybe_bounds\n+: %prec SHIFTPLUS\n+  ':' bounds             { $$ = $2; }\n+| %prec SHIFTPLUS %empty { $$ = mk_none(); }\n+;\n+\n+bounds\n+: bound            { $$ = mk_node(\"bounds\", 1, $1); }\n+| bounds '+' bound { $$ = ext_node($1, 1, $3); }\n+;\n+\n+bound\n+: lifetime\n+| trait_ref\n+;\n+\n+maybe_ltbounds\n+: %prec SHIFTPLUS\n+  ':' ltbounds       { $$ = $2; }\n+| %empty             { $$ = mk_none(); }\n+;\n+\n+ltbounds\n+: lifetime              { $$ = mk_node(\"ltbounds\", 1, $1); }\n+| ltbounds '+' lifetime { $$ = ext_node($1, 1, $3); }\n+;\n+\n+maybe_ty_default\n+: '=' ty_sum { $$ = mk_node(\"TyDefault\", 1, $2); }\n+| %empty     { $$ = mk_none(); }\n+;\n+\n+maybe_lifetimes\n+: lifetimes\n+| lifetimes ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+lifetimes\n+: lifetime_and_bounds               { $$ = mk_node(\"Lifetimes\", 1, $1); }\n+| lifetimes ',' lifetime_and_bounds { $$ = ext_node($1, 1, $3); }\n+;\n+\n+lifetime_and_bounds\n+: LIFETIME maybe_ltbounds         { $$ = mk_node(\"lifetime\", 2, mk_atom(yytext), $2); }\n+| STATIC_LIFETIME                 { $$ = mk_atom(\"static_lifetime\"); }\n+;\n+\n+lifetime\n+: LIFETIME         { $$ = mk_node(\"lifetime\", 1, mk_atom(yytext)); }\n+| STATIC_LIFETIME  { $$ = mk_atom(\"static_lifetime\"); }\n+;\n+\n+trait_ref\n+: %prec IDENT path_generic_args_without_colons\n+| %prec IDENT MOD_SEP path_generic_args_without_colons { $$ = $2; }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 4: Blocks, statements, and expressions\n+////////////////////////////////////////////////////////////////////////\n+\n+inner_attrs_and_block\n+: '{' maybe_inner_attrs maybe_stmts '}'        { $$ = mk_node(\"ExprBlock\", 2, $2, $3); }\n+;\n+\n+block\n+: '{' maybe_stmts '}'                          { $$ = mk_node(\"ExprBlock\", 1, $2); }\n+;\n+\n+maybe_stmts\n+: stmts\n+| stmts nonblock_expr { $$ = ext_node($1, 1, $2); }\n+| nonblock_expr\n+| %empty              { $$ = mk_none(); }\n+;\n+\n+// There are two sub-grammars within a \"stmts: exprs\" derivation\n+// depending on whether each stmt-expr is a block-expr form; this is to\n+// handle the \"semicolon rule\" for stmt sequencing that permits\n+// writing\n+//\n+//     if foo { bar } 10\n+//\n+// as a sequence of two stmts (one if-expr stmt, one lit-10-expr\n+// stmt). Unfortunately by permitting juxtaposition of exprs in\n+// sequence like that, the non-block expr grammar has to have a\n+// second limited sub-grammar that excludes the prefix exprs that\n+// are ambiguous with binops. That is to say:\n+//\n+//     {10} - 1\n+//\n+// should parse as (progn (progn 10) (- 1)) not (- (progn 10) 1), that\n+// is to say, two statements rather than one, at least according to\n+// the mainline rust parser.\n+//\n+// So we wind up with a 3-way split in exprs that occur in stmt lists:\n+// block, nonblock-prefix, and nonblock-nonprefix.\n+//\n+// In non-stmts contexts, expr can relax this trichotomy.\n+//\n+// There is also one other expr subtype: nonparen_expr disallows exprs\n+// surrounded by parens (including tuple expressions), this is\n+// necessary for BOX (place) expressions, so a parens expr following\n+// the BOX is always parsed as the place.\n+\n+stmts\n+: stmt           { $$ = mk_node(\"stmts\", 1, $1); }\n+| stmts stmt     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+stmt\n+: let\n+|                 stmt_item\n+|             PUB stmt_item { $$ = $2; }\n+| outer_attrs     stmt_item { $$ = $2; }\n+| outer_attrs PUB stmt_item { $$ = $3; }\n+| full_block_expr\n+| block\n+| nonblock_expr ';'\n+| ';'                   { $$ = mk_none(); }\n+;\n+\n+maybe_exprs\n+: exprs\n+| exprs ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+maybe_expr\n+: expr\n+| %empty { $$ = mk_none(); }\n+;\n+\n+exprs\n+: expr                                                        { $$ = mk_node(\"exprs\", 1, $1); }\n+| exprs ',' expr                                              { $$ = ext_node($1, 1, $3); }\n+;\n+\n+path_expr\n+: path_generic_args_with_colons\n+| MOD_SEP path_generic_args_with_colons      { $$ = $2; }\n+| SELF MOD_SEP path_generic_args_with_colons { $$ = mk_node(\"SelfPath\", 1, $3); }\n+;\n+\n+// A path with a lifetime and type parameters with double colons before\n+// the type parameters; e.g. `foo::bar::<'a>::Baz::<T>`\n+//\n+// These show up in expr context, in order to disambiguate from \"less-than\"\n+// expressions.\n+path_generic_args_with_colons\n+: ident                                              { $$ = mk_node(\"components\", 1, $1); }\n+| path_generic_args_with_colons MOD_SEP ident        { $$ = ext_node($1, 1, $3); }\n+| path_generic_args_with_colons MOD_SEP generic_args { $$ = ext_node($1, 1, $3); }\n+;\n+\n+// the braces-delimited macro is a block_expr so it doesn't appear here\n+macro_expr\n+: path_expr '!' maybe_ident parens_delimited_token_trees   { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n+| path_expr '!' maybe_ident brackets_delimited_token_trees { $$ = mk_node(\"MacroExpr\", 3, $1, $3, $4); }\n+;\n+\n+nonblock_expr\n+: lit                                                           { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                                     { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                          { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                                    { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                          { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonblock_expr '.' path_generic_args_with_colons               { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| nonblock_expr '.' LIT_INTEGER                                 { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| nonblock_expr '[' maybe_expr ']'                              { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| nonblock_expr '(' maybe_exprs ')'                             { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                              { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| '(' maybe_exprs ')'                                           { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| CONTINUE                                                      { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE lifetime                                             { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                                        { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                                   { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                                         { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK lifetime                                                { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| nonblock_expr LARROW expr                                     { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n+| nonblock_expr '=' expr                                        { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| nonblock_expr SHLEQ expr                                      { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| nonblock_expr SHREQ expr                                      { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| nonblock_expr MINUSEQ expr                                    { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| nonblock_expr ANDEQ expr                                      { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| nonblock_expr OREQ expr                                       { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| nonblock_expr PLUSEQ expr                                     { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| nonblock_expr STAREQ expr                                     { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| nonblock_expr SLASHEQ expr                                    { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| nonblock_expr CARETEQ expr                                    { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| nonblock_expr PERCENTEQ expr                                  { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| nonblock_expr OROR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| nonblock_expr ANDAND expr                                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| nonblock_expr EQEQ expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| nonblock_expr NE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| nonblock_expr '<' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| nonblock_expr '>' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| nonblock_expr LE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| nonblock_expr GE expr                                         { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| nonblock_expr '|' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| nonblock_expr '^' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| nonblock_expr '&' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| nonblock_expr SHL expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| nonblock_expr SHR expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| nonblock_expr '+' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| nonblock_expr '-' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| nonblock_expr '*' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| nonblock_expr '/' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| nonblock_expr '%' expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| nonblock_expr DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| nonblock_expr DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT expr                                     { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+|               DOTDOT                                          { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n+| nonblock_expr AS ty                                           { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                             { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' nonblock_expr           { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| expr_qualified_path\n+| nonblock_prefix_expr\n+;\n+\n+expr\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| expr '.' path_generic_args_with_colons              { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| expr '.' LIT_INTEGER                                { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| expr '[' maybe_expr ']'                             { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| expr '(' maybe_exprs ')'                            { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr LARROW expr                                    { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n+| expr '=' expr                                       { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| expr SHLEQ expr                                     { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| expr SHREQ expr                                     { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| expr MINUSEQ expr                                   { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| expr ANDEQ expr                                     { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| expr OREQ expr                                      { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| expr PLUSEQ expr                                    { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| expr STAREQ expr                                    { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| expr SLASHEQ expr                                   { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| expr CARETEQ expr                                   { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| expr PERCENTEQ expr                                 { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| expr OROR expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| expr ANDAND expr                                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| expr EQEQ expr                                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| expr NE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| expr '<' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| expr '>' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| expr LE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| expr GE expr                                        { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| expr '|' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| expr '^' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| expr '&' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| expr SHL expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| expr SHR expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| expr '+' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| expr '-' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| expr '*' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| expr '/' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| expr '%' expr                                       { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| expr DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| expr DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|      DOTDOT expr                                    { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+|      DOTDOT                                         { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n+| expr AS ty                                          { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 2, $3, $5); }\n+| expr_qualified_path\n+| block_expr\n+| block\n+| nonblock_prefix_expr\n+;\n+\n+nonparen_expr\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| path_expr '{' struct_expr_fields '}'                { $$ = mk_node(\"ExprStruct\", 2, $1, $3); }\n+| nonparen_expr '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| nonparen_expr '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| nonparen_expr '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| nonparen_expr '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| nonparen_expr LARROW nonparen_expr                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n+| nonparen_expr '=' nonparen_expr                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| nonparen_expr SHLEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| nonparen_expr SHREQ nonparen_expr                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| nonparen_expr MINUSEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| nonparen_expr ANDEQ nonparen_expr                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| nonparen_expr OREQ nonparen_expr                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| nonparen_expr PLUSEQ nonparen_expr                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| nonparen_expr STAREQ nonparen_expr                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| nonparen_expr SLASHEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| nonparen_expr CARETEQ nonparen_expr                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| nonparen_expr PERCENTEQ nonparen_expr               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| nonparen_expr OROR nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| nonparen_expr ANDAND nonparen_expr                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| nonparen_expr EQEQ nonparen_expr                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| nonparen_expr NE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| nonparen_expr '<' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| nonparen_expr '>' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| nonparen_expr LE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| nonparen_expr GE nonparen_expr                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| nonparen_expr '|' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| nonparen_expr '^' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| nonparen_expr '&' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| nonparen_expr SHL nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| nonparen_expr SHR nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| nonparen_expr '+' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| nonparen_expr '-' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| nonparen_expr '*' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| nonparen_expr '/' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| nonparen_expr '%' nonparen_expr                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| nonparen_expr DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| nonparen_expr DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT nonparen_expr                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n+| nonparen_expr AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr          { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr_qualified_path\n+| block_expr\n+| block\n+| nonblock_prefix_expr\n+;\n+\n+expr_nostruct\n+: lit                                                 { $$ = mk_node(\"ExprLit\", 1, $1); }\n+| %prec IDENT\n+  path_expr                                           { $$ = mk_node(\"ExprPath\", 1, $1); }\n+| SELF                                                { $$ = mk_node(\"ExprPath\", 1, mk_node(\"ident\", 1, mk_atom(\"self\"))); }\n+| macro_expr                                          { $$ = mk_node(\"ExprMac\", 1, $1); }\n+| expr_nostruct '.' path_generic_args_with_colons     { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| expr_nostruct '.' LIT_INTEGER                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+| expr_nostruct '[' maybe_expr ']'                    { $$ = mk_node(\"ExprIndex\", 2, $1, $3); }\n+| expr_nostruct '(' maybe_exprs ')'                   { $$ = mk_node(\"ExprCall\", 2, $1, $3); }\n+| '[' vec_expr ']'                                    { $$ = mk_node(\"ExprVec\", 1, $2); }\n+| '(' maybe_exprs ')'                                 { $$ = mk_node(\"ExprParen\", 1, $2); }\n+| CONTINUE                                            { $$ = mk_node(\"ExprAgain\", 0); }\n+| CONTINUE ident                                      { $$ = mk_node(\"ExprAgain\", 1, $2); }\n+| RETURN                                              { $$ = mk_node(\"ExprRet\", 0); }\n+| RETURN expr                                         { $$ = mk_node(\"ExprRet\", 1, $2); }\n+| BREAK                                               { $$ = mk_node(\"ExprBreak\", 0); }\n+| BREAK ident                                         { $$ = mk_node(\"ExprBreak\", 1, $2); }\n+| expr_nostruct LARROW expr_nostruct                  { $$ = mk_node(\"ExprInPlace\", 2, $1, $3); }\n+| expr_nostruct '=' expr_nostruct                     { $$ = mk_node(\"ExprAssign\", 2, $1, $3); }\n+| expr_nostruct SHLEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShl\", 2, $1, $3); }\n+| expr_nostruct SHREQ expr_nostruct                   { $$ = mk_node(\"ExprAssignShr\", 2, $1, $3); }\n+| expr_nostruct MINUSEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignSub\", 2, $1, $3); }\n+| expr_nostruct ANDEQ expr_nostruct                   { $$ = mk_node(\"ExprAssignBitAnd\", 2, $1, $3); }\n+| expr_nostruct OREQ expr_nostruct                    { $$ = mk_node(\"ExprAssignBitOr\", 2, $1, $3); }\n+| expr_nostruct PLUSEQ expr_nostruct                  { $$ = mk_node(\"ExprAssignAdd\", 2, $1, $3); }\n+| expr_nostruct STAREQ expr_nostruct                  { $$ = mk_node(\"ExprAssignMul\", 2, $1, $3); }\n+| expr_nostruct SLASHEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignDiv\", 2, $1, $3); }\n+| expr_nostruct CARETEQ expr_nostruct                 { $$ = mk_node(\"ExprAssignBitXor\", 2, $1, $3); }\n+| expr_nostruct PERCENTEQ expr_nostruct               { $$ = mk_node(\"ExprAssignRem\", 2, $1, $3); }\n+| expr_nostruct OROR expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiOr\"), $1, $3); }\n+| expr_nostruct ANDAND expr_nostruct                  { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAnd\"), $1, $3); }\n+| expr_nostruct EQEQ expr_nostruct                    { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiEq\"), $1, $3); }\n+| expr_nostruct NE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiNe\"), $1, $3); }\n+| expr_nostruct '<' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLt\"), $1, $3); }\n+| expr_nostruct '>' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGt\"), $1, $3); }\n+| expr_nostruct LE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiLe\"), $1, $3); }\n+| expr_nostruct GE expr_nostruct                      { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiGe\"), $1, $3); }\n+| expr_nostruct '|' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitOr\"), $1, $3); }\n+| expr_nostruct '^' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitXor\"), $1, $3); }\n+| expr_nostruct '&' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiBitAnd\"), $1, $3); }\n+| expr_nostruct SHL expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShl\"), $1, $3); }\n+| expr_nostruct SHR expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiShr\"), $1, $3); }\n+| expr_nostruct '+' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiAdd\"), $1, $3); }\n+| expr_nostruct '-' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiSub\"), $1, $3); }\n+| expr_nostruct '*' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiMul\"), $1, $3); }\n+| expr_nostruct '/' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiDiv\"), $1, $3); }\n+| expr_nostruct '%' expr_nostruct                     { $$ = mk_node(\"ExprBinary\", 3, mk_atom(\"BiRem\"), $1, $3); }\n+| expr_nostruct DOTDOT               %prec RANGE      { $$ = mk_node(\"ExprRange\", 2, $1, mk_none()); }\n+| expr_nostruct DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, $1, $3); }\n+|               DOTDOT expr_nostruct                  { $$ = mk_node(\"ExprRange\", 2, mk_none(), $2); }\n+|               DOTDOT                                { $$ = mk_node(\"ExprRange\", 2, mk_none(), mk_none()); }\n+| expr_nostruct AS ty                                 { $$ = mk_node(\"ExprCast\", 2, $1, $3); }\n+| BOX nonparen_expr                                   { $$ = mk_node(\"ExprBox\", 1, $2); }\n+| %prec BOXPLACE BOX '(' maybe_expr ')' expr_nostruct { $$ = mk_node(\"ExprBox\", 1, $3, $5); }\n+| expr_qualified_path\n+| block_expr\n+| block\n+| nonblock_prefix_expr_nostruct\n+;\n+\n+nonblock_prefix_expr_nostruct\n+: '-' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n+| '!' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n+| '*' expr_nostruct                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n+| '&' maybe_mut expr_nostruct               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n+| ANDAND maybe_mut expr_nostruct            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n+| lambda_expr_nostruct\n+| MOVE lambda_expr_nostruct                 { $$ = $2; }\n+| proc_expr_nostruct\n+;\n+\n+nonblock_prefix_expr\n+: '-' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNeg\"), $2); }\n+| '!' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnNot\"), $2); }\n+| '*' expr                         { $$ = mk_node(\"ExprUnary\", 2, mk_atom(\"UnDeref\"), $2); }\n+| '&' maybe_mut expr               { $$ = mk_node(\"ExprAddrOf\", 2, $2, $3); }\n+| ANDAND maybe_mut expr            { $$ = mk_node(\"ExprAddrOf\", 1, mk_node(\"ExprAddrOf\", 2, $2, $3)); }\n+| lambda_expr\n+| MOVE lambda_expr                 { $$ = $2; }\n+| proc_expr\n+;\n+\n+expr_qualified_path\n+: '<' ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_qpath_params\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7);\n+}\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10);\n+}\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 3, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11);\n+}\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident maybe_as_trait_ref '>' MOD_SEP ident generic_args\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 3, $2, $3, $6), $7, $10, $11);\n+}\n+| SHL ty_sum maybe_as_trait_ref '>' MOD_SEP ident generic_args maybe_as_trait_ref '>' MOD_SEP ident generic_args\n+{\n+  $$ = mk_node(\"ExprQualifiedPath\", 4, mk_node(\"ExprQualifiedPath\", 4, $2, $3, $6, $7), $8, $11, $12);\n+}\n+\n+maybe_qpath_params\n+: MOD_SEP generic_args { $$ = $2; }\n+| %empty               { $$ = mk_none(); }\n+;\n+\n+maybe_as_trait_ref\n+: AS trait_ref { $$ = $2; }\n+| %empty       { $$ = mk_none(); }\n+;\n+\n+lambda_expr\n+: %prec LAMBDA\n+  OROR ret_ty expr                                        { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $2, $3); }\n+| %prec LAMBDA\n+  '|' maybe_unboxed_closure_kind '|' ret_ty expr          { $$ = mk_node(\"ExprFnBlock\", 3, mk_none(), $4, $5); }\n+| %prec LAMBDA\n+  '|' inferrable_params '|' ret_ty expr                   { $$ = mk_node(\"ExprFnBlock\", 3, $2, $4, $5); }\n+| %prec LAMBDA\n+  '|' '&' maybe_mut ':' inferrable_params '|' ret_ty expr { $$ = mk_node(\"ExprFnBlock\", 3, $5, $7, $8); }\n+| %prec LAMBDA\n+  '|' ':' inferrable_params '|' ret_ty expr               { $$ = mk_node(\"ExprFnBlock\", 3, $3, $5, $6); }\n+;\n+\n+lambda_expr_nostruct\n+: %prec LAMBDA\n+  OROR expr_nostruct                                        { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $2); }\n+| %prec LAMBDA\n+  '|' maybe_unboxed_closure_kind '|'  expr_nostruct         { $$ = mk_node(\"ExprFnBlock\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  '|' inferrable_params '|' expr_nostruct                   { $$ = mk_node(\"ExprFnBlock\", 2, $2, $4); }\n+| %prec LAMBDA\n+  '|' '&' maybe_mut ':' inferrable_params '|' expr_nostruct { $$ = mk_node(\"ExprFnBlock\", 2, $5, $7); }\n+| %prec LAMBDA\n+  '|' ':' inferrable_params '|' expr_nostruct               { $$ = mk_node(\"ExprFnBlock\", 2, $3, $5); }\n+\n+;\n+\n+proc_expr\n+: %prec LAMBDA\n+  PROC '(' ')' expr                         { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  PROC '(' inferrable_params ')' expr       { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+;\n+\n+proc_expr_nostruct\n+: %prec LAMBDA\n+  PROC '(' ')' expr_nostruct                     { $$ = mk_node(\"ExprProc\", 2, mk_none(), $4); }\n+| %prec LAMBDA\n+  PROC '(' inferrable_params ')' expr_nostruct   { $$ = mk_node(\"ExprProc\", 2, $3, $5); }\n+;\n+\n+vec_expr\n+: maybe_exprs\n+| exprs ';' expr { $$ = mk_node(\"VecRepeat\", 2, $1, $3); }\n+;\n+\n+struct_expr_fields\n+: field_inits\n+| field_inits ','\n+| maybe_field_inits default_field_init { $$ = ext_node($1, 1, $2); }\n+;\n+\n+maybe_field_inits\n+: field_inits\n+| field_inits ','\n+| %empty { $$ = mk_none(); }\n+;\n+\n+field_inits\n+: field_init                 { $$ = mk_node(\"FieldInits\", 1, $1); }\n+| field_inits ',' field_init { $$ = ext_node($1, 1, $3); }\n+;\n+\n+field_init\n+: ident ':' expr   { $$ = mk_node(\"FieldInit\", 2, $1, $3); }\n+;\n+\n+default_field_init\n+: DOTDOT expr   { $$ = mk_node(\"DefaultFieldInit\", 1, $2); }\n+;\n+\n+block_expr\n+: expr_match\n+| expr_if\n+| expr_if_let\n+| expr_while\n+| expr_while_let\n+| expr_loop\n+| expr_for\n+| UNSAFE block                                           { $$ = mk_node(\"UnsafeBlock\", 1, $2); }\n+| path_expr '!' maybe_ident braces_delimited_token_trees { $$ = mk_node(\"Macro\", 3, $1, $3, $4); }\n+;\n+\n+full_block_expr\n+: block_expr\n+| full_block_expr '.' path_generic_args_with_colons %prec IDENT         { $$ = mk_node(\"ExprField\", 2, $1, $3); }\n+| full_block_expr '.' path_generic_args_with_colons '[' maybe_expr ']'  { $$ = mk_node(\"ExprIndex\", 3, $1, $3, $5); }\n+| full_block_expr '.' path_generic_args_with_colons '(' maybe_exprs ')' { $$ = mk_node(\"ExprCall\", 3, $1, $3, $5); }\n+| full_block_expr '.' LIT_INTEGER                                       { $$ = mk_node(\"ExprTupleIndex\", 1, $1); }\n+;\n+\n+expr_match\n+: MATCH expr_nostruct '{' '}'                                     { $$ = mk_node(\"ExprMatch\", 1, $2); }\n+| MATCH expr_nostruct '{' match_clauses                       '}' { $$ = mk_node(\"ExprMatch\", 2, $2, $4); }\n+| MATCH expr_nostruct '{' match_clauses nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, ext_node($4, 1, $5)); }\n+| MATCH expr_nostruct '{'               nonblock_match_clause '}' { $$ = mk_node(\"ExprMatch\", 2, $2, mk_node(\"Arms\", 1, $4)); }\n+;\n+\n+match_clauses\n+: match_clause               { $$ = mk_node(\"Arms\", 1, $1); }\n+| match_clauses match_clause { $$ = ext_node($1, 1, $2); }\n+;\n+\n+match_clause\n+: nonblock_match_clause ','\n+| block_match_clause\n+| block_match_clause ','\n+;\n+\n+nonblock_match_clause\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW nonblock_expr   { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+| maybe_outer_attrs pats_or maybe_guard FAT_ARROW full_block_expr { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+;\n+\n+block_match_clause\n+: maybe_outer_attrs pats_or maybe_guard FAT_ARROW block { $$ = mk_node(\"Arm\", 4, $1, $2, $3, $5); }\n+;\n+\n+maybe_guard\n+: IF expr_nostruct           { $$ = $2; }\n+| %empty                     { $$ = mk_none(); }\n+;\n+\n+expr_if\n+: IF expr_nostruct block                              { $$ = mk_node(\"ExprIf\", 2, $2, $3); }\n+| IF expr_nostruct block ELSE block_or_if             { $$ = mk_node(\"ExprIf\", 3, $2, $3, $5); }\n+;\n+\n+expr_if_let\n+: IF LET pat '=' expr_nostruct block                  { $$ = mk_node(\"ExprIfLet\", 3, $3, $5, $6); }\n+| IF LET pat '=' expr_nostruct block ELSE block_or_if { $$ = mk_node(\"ExprIfLet\", 4, $3, $5, $6, $8); }\n+;\n+\n+block_or_if\n+: block\n+| expr_if\n+| expr_if_let\n+;\n+\n+expr_while\n+: maybe_label WHILE expr_nostruct block               { $$ = mk_node(\"ExprWhile\", 3, $1, $3, $4); }\n+;\n+\n+expr_while_let\n+: maybe_label WHILE LET pat '=' expr_nostruct block   { $$ = mk_node(\"ExprWhileLet\", 4, $1, $4, $6, $7); }\n+;\n+\n+expr_loop\n+: maybe_label LOOP block                              { $$ = mk_node(\"ExprLoop\", 2, $1, $3); }\n+;\n+\n+expr_for\n+: maybe_label FOR pat IN expr_nostruct block          { $$ = mk_node(\"ExprForLoop\", 4, $1, $3, $5, $6); }\n+;\n+\n+maybe_label\n+: lifetime ':'\n+| %empty { $$ = mk_none(); }\n+;\n+\n+let\n+: LET pat maybe_ty_ascription maybe_init_expr ';' { $$ = mk_node(\"DeclLocal\", 3, $2, $3, $4); }\n+;\n+\n+////////////////////////////////////////////////////////////////////////\n+// Part 5: Macros and misc. rules\n+////////////////////////////////////////////////////////////////////////\n+\n+lit\n+: LIT_BYTE                   { $$ = mk_node(\"LitByte\", 1, mk_atom(yytext)); }\n+| LIT_CHAR                   { $$ = mk_node(\"LitChar\", 1, mk_atom(yytext)); }\n+| LIT_INTEGER                { $$ = mk_node(\"LitInteger\", 1, mk_atom(yytext)); }\n+| LIT_FLOAT                  { $$ = mk_node(\"LitFloat\", 1, mk_atom(yytext)); }\n+| TRUE                       { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n+| FALSE                      { $$ = mk_node(\"LitBool\", 1, mk_atom(yytext)); }\n+| str\n+;\n+\n+str\n+: LIT_STR                    { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"CookedStr\")); }\n+| LIT_STR_RAW                { $$ = mk_node(\"LitStr\", 1, mk_atom(yytext), mk_atom(\"RawStr\")); }\n+| LIT_BYTE_STR                 { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"ByteStr\")); }\n+| LIT_BYTE_STR_RAW             { $$ = mk_node(\"LitByteStr\", 1, mk_atom(yytext), mk_atom(\"RawByteStr\")); }\n+;\n+\n+maybe_ident\n+: %empty { $$ = mk_none(); }\n+| ident\n+;\n+\n+ident\n+: IDENT                      { $$ = mk_node(\"ident\", 1, mk_atom(yytext)); }\n+;\n+\n+unpaired_token\n+: SHL                        { $$ = mk_atom(yytext); }\n+| SHR                        { $$ = mk_atom(yytext); }\n+| LE                         { $$ = mk_atom(yytext); }\n+| EQEQ                       { $$ = mk_atom(yytext); }\n+| NE                         { $$ = mk_atom(yytext); }\n+| GE                         { $$ = mk_atom(yytext); }\n+| ANDAND                     { $$ = mk_atom(yytext); }\n+| OROR                       { $$ = mk_atom(yytext); }\n+| LARROW                     { $$ = mk_atom(yytext); }\n+| SHLEQ                      { $$ = mk_atom(yytext); }\n+| SHREQ                      { $$ = mk_atom(yytext); }\n+| MINUSEQ                    { $$ = mk_atom(yytext); }\n+| ANDEQ                      { $$ = mk_atom(yytext); }\n+| OREQ                       { $$ = mk_atom(yytext); }\n+| PLUSEQ                     { $$ = mk_atom(yytext); }\n+| STAREQ                     { $$ = mk_atom(yytext); }\n+| SLASHEQ                    { $$ = mk_atom(yytext); }\n+| CARETEQ                    { $$ = mk_atom(yytext); }\n+| PERCENTEQ                  { $$ = mk_atom(yytext); }\n+| DOTDOT                     { $$ = mk_atom(yytext); }\n+| DOTDOTDOT                  { $$ = mk_atom(yytext); }\n+| MOD_SEP                    { $$ = mk_atom(yytext); }\n+| RARROW                     { $$ = mk_atom(yytext); }\n+| FAT_ARROW                  { $$ = mk_atom(yytext); }\n+| LIT_BYTE                   { $$ = mk_atom(yytext); }\n+| LIT_CHAR                   { $$ = mk_atom(yytext); }\n+| LIT_INTEGER                { $$ = mk_atom(yytext); }\n+| LIT_FLOAT                  { $$ = mk_atom(yytext); }\n+| LIT_STR                    { $$ = mk_atom(yytext); }\n+| LIT_STR_RAW                { $$ = mk_atom(yytext); }\n+| LIT_BYTE_STR               { $$ = mk_atom(yytext); }\n+| LIT_BYTE_STR_RAW           { $$ = mk_atom(yytext); }\n+| IDENT                      { $$ = mk_atom(yytext); }\n+| UNDERSCORE                 { $$ = mk_atom(yytext); }\n+| LIFETIME                   { $$ = mk_atom(yytext); }\n+| SELF                       { $$ = mk_atom(yytext); }\n+| STATIC                     { $$ = mk_atom(yytext); }\n+| AS                         { $$ = mk_atom(yytext); }\n+| BREAK                      { $$ = mk_atom(yytext); }\n+| CRATE                      { $$ = mk_atom(yytext); }\n+| ELSE                       { $$ = mk_atom(yytext); }\n+| ENUM                       { $$ = mk_atom(yytext); }\n+| EXTERN                     { $$ = mk_atom(yytext); }\n+| FALSE                      { $$ = mk_atom(yytext); }\n+| FN                         { $$ = mk_atom(yytext); }\n+| FOR                        { $$ = mk_atom(yytext); }\n+| IF                         { $$ = mk_atom(yytext); }\n+| IMPL                       { $$ = mk_atom(yytext); }\n+| IN                         { $$ = mk_atom(yytext); }\n+| LET                        { $$ = mk_atom(yytext); }\n+| LOOP                       { $$ = mk_atom(yytext); }\n+| MATCH                      { $$ = mk_atom(yytext); }\n+| MOD                        { $$ = mk_atom(yytext); }\n+| MOVE                       { $$ = mk_atom(yytext); }\n+| MUT                        { $$ = mk_atom(yytext); }\n+| PRIV                       { $$ = mk_atom(yytext); }\n+| PUB                        { $$ = mk_atom(yytext); }\n+| REF                        { $$ = mk_atom(yytext); }\n+| RETURN                     { $$ = mk_atom(yytext); }\n+| STRUCT                     { $$ = mk_atom(yytext); }\n+| TRUE                       { $$ = mk_atom(yytext); }\n+| TRAIT                      { $$ = mk_atom(yytext); }\n+| TYPE                       { $$ = mk_atom(yytext); }\n+| UNSAFE                     { $$ = mk_atom(yytext); }\n+| USE                        { $$ = mk_atom(yytext); }\n+| WHILE                      { $$ = mk_atom(yytext); }\n+| CONTINUE                   { $$ = mk_atom(yytext); }\n+| PROC                       { $$ = mk_atom(yytext); }\n+| BOX                        { $$ = mk_atom(yytext); }\n+| CONST                      { $$ = mk_atom(yytext); }\n+| WHERE                      { $$ = mk_atom(yytext); }\n+| TYPEOF                     { $$ = mk_atom(yytext); }\n+| INNER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n+| OUTER_DOC_COMMENT          { $$ = mk_atom(yytext); }\n+| SHEBANG                    { $$ = mk_atom(yytext); }\n+| STATIC_LIFETIME            { $$ = mk_atom(yytext); }\n+| ';'                        { $$ = mk_atom(yytext); }\n+| ','                        { $$ = mk_atom(yytext); }\n+| '.'                        { $$ = mk_atom(yytext); }\n+| '@'                        { $$ = mk_atom(yytext); }\n+| '#'                        { $$ = mk_atom(yytext); }\n+| '~'                        { $$ = mk_atom(yytext); }\n+| ':'                        { $$ = mk_atom(yytext); }\n+| '$'                        { $$ = mk_atom(yytext); }\n+| '='                        { $$ = mk_atom(yytext); }\n+| '?'                        { $$ = mk_atom(yytext); }\n+| '!'                        { $$ = mk_atom(yytext); }\n+| '<'                        { $$ = mk_atom(yytext); }\n+| '>'                        { $$ = mk_atom(yytext); }\n+| '-'                        { $$ = mk_atom(yytext); }\n+| '&'                        { $$ = mk_atom(yytext); }\n+| '|'                        { $$ = mk_atom(yytext); }\n+| '+'                        { $$ = mk_atom(yytext); }\n+| '*'                        { $$ = mk_atom(yytext); }\n+| '/'                        { $$ = mk_atom(yytext); }\n+| '^'                        { $$ = mk_atom(yytext); }\n+| '%'                        { $$ = mk_atom(yytext); }\n+;\n+\n+token_trees\n+: %empty                     { $$ = mk_node(\"TokenTrees\", 0); }\n+| token_trees token_tree     { $$ = ext_node($1, 1, $2); }\n+;\n+\n+token_tree\n+: delimited_token_trees\n+| unpaired_token         { $$ = mk_node(\"TTTok\", 1, $1); }\n+;\n+\n+delimited_token_trees\n+: parens_delimited_token_trees\n+| braces_delimited_token_trees\n+| brackets_delimited_token_trees\n+;\n+\n+parens_delimited_token_trees\n+: '(' token_trees ')'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"(\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\")\")));\n+}\n+;\n+\n+braces_delimited_token_trees\n+: '{' token_trees '}'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"{\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\"}\")));\n+}\n+;\n+\n+brackets_delimited_token_trees\n+: '[' token_trees ']'\n+{\n+  $$ = mk_node(\"TTDelim\", 3,\n+               mk_node(\"TTTok\", 1, mk_atom(\"[\")),\n+               $2,\n+               mk_node(\"TTTok\", 1, mk_atom(\"]\")));\n+}\n+;\n\\ No newline at end of file"}, {"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "src/grammar/raw-string-literal-ambiguity.md", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/rust-lang/rust/raw/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=20de961226de41a18ca1d9b166c6bc607f3a597a", "patch": "@@ -0,0 +1,64 @@\n+Rust's lexical grammar is not context-free. Raw string literals are the source\n+of the problem. Informally, a raw string literal is an `r`, followed by `N`\n+hashes (where N can be zero), a quote, any characters, then a quote followed\n+by `N` hashes. Critically, once inside the first pair of quotes,\n+another quote cannot be followed by `N` consecutive hashes. e.g.\n+`r###\"\"###\"###` is invalid.\n+\n+This grammar describes this as best possible:\n+\n+    R -> 'r' S\n+    S -> '\"' B '\"'\n+    S -> '#' S '#'\n+    B -> . B\n+    B -> \u03b5\n+\n+Where `.` represents any character, and `\u03b5` the empty string. Consider the\n+string `r#\"\"#\"#`. This string is not a valid raw string literal, but can be\n+accepted as one by the above grammar, using the derivation:\n+\n+    R : #\"\"#\"#\n+    S : \"\"#\"\n+    S : \"#\n+    B : #\n+    B : \u03b5\n+\n+(Where `T : U` means the rule `T` is applied, and `U` is the remainder of the\n+string.) The difficulty arises from the fact that it is fundamentally\n+context-sensitive. In particular, the context needed is the number of hashes.\n+\n+To prove that Rust's string literals are not context-free, we will use\n+the fact that context-free languages are closed under intersection with\n+regular languages, and the\n+[pumping lemma for context-free languages](https://en.wikipedia.org/wiki/Pumping_lemma_for_context-free_languages).\n+\n+Consider the regular language `R = r#+\"\"#*\"#+`. If Rust's raw string literals are\n+context-free, then their intersection with `R`, `R'`, should also be context-free.\n+Therefore, to prove that raw string literals are not context-free,\n+it is sufficient to prove that `R'` is not context-free.\n+\n+The language `R'` is `{r#^n\"\"#^m\"#^n | m < n}`.\n+\n+Assume `R'` *is* context-free. Then `R'` has some pumping length `p > 0` for which\n+the pumping lemma applies. Consider the following string `s` in `R'`:\n+\n+`r#^p\"\"#^{p-1}\"#^p`\n+\n+e.g. for `p = 2`: `s = r##\"\"#\"##`\n+\n+Then `s = uvwxy` for some choice of `uvwxy` such that `vx` is non-empty,\n+`|vwx| < p+1`, and `uv^iwx^iy` is in `R'` for all `i >= 0`.\n+\n+Neither `v` nor `x` can contain a `\"` or `r`, as the number of these characters\n+in any string in `R'` is fixed. So `v` and `x` contain only hashes.\n+Consequently, of the three sequences of hashes, `v` and `x` combined\n+can only pump two of them.\n+If we ever choose the central sequence of hashes, then one of the outer sequences\n+will not grow when we pump, leading to an imbalance between the outer sequences.\n+Therefore, we must pump both outer sequences of hashes. However,\n+there are `p+2` characters between these two sequences of hashes, and `|vwx|` must\n+be less than `p+1`. Therefore we have a contradiction, and `R'` must not be\n+context-free.\n+\n+Since `R'` is not context-free, it follows that the Rust's raw string literals\n+must not be context-free."}, {"sha": "37be41b935f84b4e1434ba9f76d8aa8b25ed4c98", "filename": "src/grammar/testparser.py", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/rust-lang/rust/raw/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftestparser.py?ref=20de961226de41a18ca1d9b166c6bc607f3a597a", "patch": "@@ -0,0 +1,76 @@\n+#!/usr/bin/env python\n+#\n+# Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+# ignore-tidy-linelength\n+\n+import sys\n+\n+import os\n+import subprocess\n+import argparse\n+\n+# usage: testparser.py [-h] [-p PARSER [PARSER ...]] -s SOURCE_DIR\n+\n+# Parsers should read from stdin and return exit status 0 for a\n+# successful parse, and nonzero for an unsuccessful parse\n+\n+parser = argparse.ArgumentParser()\n+parser.add_argument('-p', '--parser', nargs='+')\n+parser.add_argument('-s', '--source-dir', nargs=1, required=True)\n+args = parser.parse_args(sys.argv[1:])\n+\n+total = 0\n+ok = {}\n+bad = {}\n+for parser in args.parser:\n+    ok[parser] = 0\n+    bad[parser] = []\n+devnull = open(os.devnull, 'w')\n+print(\"\\n\")\n+\n+for base, dirs, files in os.walk(args.source_dir[0]):\n+    for f in filter(lambda p: p.endswith('.rs'), files):\n+        p = os.path.join(base, f)\n+        parse_fail = 'parse-fail' in p\n+        if sys.version_info.major == 3:\n+            lines = open(p, encoding='utf-8').readlines()\n+        else:\n+            lines = open(p).readlines()\n+        if any('ignore-test' in line or 'ignore-lexer-test' in line for line in lines):\n+            continue\n+        total += 1\n+        for parser in args.parser:\n+            if subprocess.call(parser, stdin=open(p), stderr=subprocess.STDOUT, stdout=devnull) == 0:\n+                if parse_fail:\n+                    bad[parser].append(p)\n+                else:\n+                    ok[parser] += 1\n+            else:\n+                if parse_fail:\n+                    ok[parser] += 1\n+                else:\n+                    bad[parser].append(p)\n+        parser_stats = ', '.join(['{}: {}'.format(parser, ok[parser]) for parser in args.parser])\n+        sys.stdout.write(\"\\033[K\\r total: {}, {}, scanned {}\"\n+                         .format(total, os.path.relpath(parser_stats), os.path.relpath(p)))\n+\n+devnull.close()\n+\n+print(\"\\n\")\n+\n+for parser in args.parser:\n+    filename = os.path.basename(parser) + '.bad'\n+    print(\"writing {} files that did not yield the correct result with {} to {}\".format(len(bad[parser]), parser, filename))\n+    with open(filename, \"w\") as f:\n+        for p in bad[parser]:\n+            f.write(p)\n+            f.write(\"\\n\")"}, {"sha": "081bd05025967e76940f075c1c490c6ccdf2bfa7", "filename": "src/grammar/tokens.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/rust-lang/rust/raw/20de961226de41a18ca1d9b166c6bc607f3a597a/src%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fgrammar%2Ftokens.h?ref=20de961226de41a18ca1d9b166c6bc607f3a597a", "patch": "@@ -0,0 +1,91 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+enum Token {\n+  SHL = 257, // Parser generators reserve 0-256 for char literals\n+  SHR,\n+  LE,\n+  EQEQ,\n+  NE,\n+  GE,\n+  ANDAND,\n+  OROR,\n+  SHLEQ,\n+  SHREQ,\n+  MINUSEQ,\n+  ANDEQ,\n+  OREQ,\n+  PLUSEQ,\n+  STAREQ,\n+  SLASHEQ,\n+  CARETEQ,\n+  PERCENTEQ,\n+  DOTDOT,\n+  DOTDOTDOT,\n+  MOD_SEP,\n+  RARROW,\n+  FAT_ARROW,\n+  LIT_BYTE,\n+  LIT_CHAR,\n+  LIT_INTEGER,\n+  LIT_FLOAT,\n+  LIT_STR,\n+  LIT_STR_RAW,\n+  LIT_BYTE_STR,\n+  LIT_BYTE_STR_RAW,\n+  IDENT,\n+  UNDERSCORE,\n+  LIFETIME,\n+\n+  // keywords\n+  SELF,\n+  STATIC,\n+  AS,\n+  BREAK,\n+  CRATE,\n+  ELSE,\n+  ENUM,\n+  EXTERN,\n+  FALSE,\n+  FN,\n+  FOR,\n+  IF,\n+  IMPL,\n+  IN,\n+  LET,\n+  LOOP,\n+  MATCH,\n+  MOD,\n+  MOVE,\n+  MUT,\n+  PRIV,\n+  PUB,\n+  REF,\n+  RETURN,\n+  STRUCT,\n+  TRUE,\n+  TRAIT,\n+  TYPE,\n+  UNSAFE,\n+  USE,\n+  WHILE,\n+  CONTINUE,\n+  PROC,\n+  BOX,\n+  CONST,\n+  WHERE,\n+  TYPEOF,\n+  INNER_DOC_COMMENT,\n+  OUTER_DOC_COMMENT,\n+\n+  SHEBANG,\n+  SHEBANG_LINE,\n+  STATIC_LIFETIME\n+};"}]}