{"sha": "c9e1c445dbcbfc9c938488a79ef12595e0f99c8d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5ZTFjNDQ1ZGJjYmZjOWM5Mzg0ODhhNzllZjEyNTk1ZTBmOTljOGQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-02T16:52:08Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-02-03T16:55:45Z"}, "message": "Allow closure arguments types to unify even if we can't fully resolve\na trait obligation. Partial fix for #16440 -- closure return types are\nnot handled yet.", "tree": {"sha": "f98110e619682ecfb0bc34b4adce7b29f318c41a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f98110e619682ecfb0bc34b4adce7b29f318c41a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c9e1c445dbcbfc9c938488a79ef12595e0f99c8d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c9e1c445dbcbfc9c938488a79ef12595e0f99c8d", "html_url": "https://github.com/rust-lang/rust/commit/c9e1c445dbcbfc9c938488a79ef12595e0f99c8d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c9e1c445dbcbfc9c938488a79ef12595e0f99c8d/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3d072a193bfcb76206aab576049e696d6d8db25d", "url": "https://api.github.com/repos/rust-lang/rust/commits/3d072a193bfcb76206aab576049e696d6d8db25d", "html_url": "https://github.com/rust-lang/rust/commit/3d072a193bfcb76206aab576049e696d6d8db25d"}], "stats": {"total": 85, "additions": 63, "deletions": 22}, "files": [{"sha": "7a59909e131665950823f4bffb7d8c5fbd5520ea", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 62, "deletions": 21, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/c9e1c445dbcbfc9c938488a79ef12595e0f99c8d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e1c445dbcbfc9c938488a79ef12595e0f99c8d/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=c9e1c445dbcbfc9c938488a79ef12595e0f99c8d", "patch": "@@ -233,21 +233,78 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     //    is `Vec<Foo>:Iterable<Bar>`, but the impl specifies\n     //    `impl<T> Iterable<T> for Vec<T>`, than an error would result.\n \n-    /// Evaluates whether the obligation can be satisfied. Returns an indication of whether the\n-    /// obligation can be satisfied and, if so, by what means. Never affects surrounding typing\n-    /// environment.\n+    /// Attempts to satisfy the obligation. If successful, this will affect the surrounding\n+    /// type environment by performing unification.\n     pub fn select(&mut self, obligation: &TraitObligation<'tcx>)\n                   -> SelectionResult<'tcx, Selection<'tcx>> {\n         debug!(\"select({})\", obligation.repr(self.tcx()));\n         assert!(!obligation.predicate.has_escaping_regions());\n \n         let stack = self.push_stack(None, obligation);\n         match try!(self.candidate_from_obligation(&stack)) {\n-            None => Ok(None),\n+            None => {\n+                self.consider_unification_despite_ambiguity(obligation);\n+                Ok(None)\n+            }\n             Some(candidate) => Ok(Some(try!(self.confirm_candidate(obligation, candidate)))),\n         }\n     }\n \n+    /// In the particular case of unboxed closure obligations, we can\n+    /// sometimes do some amount of unification for the\n+    /// argument/return types even though we can't yet fully match obligation.\n+    /// The particular case we are interesting in is an obligation of the form:\n+    ///\n+    ///    C : FnFoo<A>\n+    ///\n+    /// where `C` is an unboxed closure type and `FnFoo` is one of the\n+    /// `Fn` traits. Because we know that users cannot write impls for closure types\n+    /// themselves, the only way that `C : FnFoo` can fail to match is under two\n+    /// conditions:\n+    ///\n+    /// 1. The closure kind for `C` is not yet known, because inference isn't complete.\n+    /// 2. The closure kind for `C` *is* known, but doesn't match what is needed.\n+    ///    For example, `C` may be a `FnOnce` closure, but a `Fn` closure is needed.\n+    ///\n+    /// In either case, we always know what argument types are\n+    /// expected by `C`, no matter what kind of `Fn` trait it\n+    /// eventually matches. So we can go ahead and unify the argument\n+    /// types, even though the end result is ambiguous.\n+    ///\n+    /// Note that this is safe *even if* the trait would never be\n+    /// matched (case 2 above). After all, in that case, an error will\n+    /// result, so it kind of doesn't matter what we do --- unifying\n+    /// the argument types can only be helpful to the user, because\n+    /// once they patch up the kind of closure that is expected, the\n+    /// argment types won't really change.\n+    fn consider_unification_despite_ambiguity(&mut self, obligation: &TraitObligation<'tcx>)\n+    {\n+        // Is this a `C : FnFoo(...)` trait reference for some trait binding `FnFoo`?\n+        match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n+            Some(_) => { }\n+            None => { return; }\n+        }\n+\n+        // Is the self-type a closure type? We ignore bindings here\n+        // because if it is a closure type, it must be a closure type from\n+        // within this current fn, and hence none of the higher-ranked\n+        // lifetimes can appear inside the self-type.\n+        let self_ty = self.infcx.shallow_resolve(obligation.self_ty());\n+        let (closure_def_id, substs) = match self_ty.sty {\n+            ty::ty_closure(id, _, ref substs) => (id, substs.clone()),\n+            _ => { return; }\n+        };\n+        assert!(!substs.has_escaping_regions());\n+\n+        let closure_trait_ref = self.closure_trait_ref(obligation, closure_def_id, substs);\n+        match self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                           obligation.predicate.to_poly_trait_ref(),\n+                                           closure_trait_ref) {\n+            Ok(()) => { }\n+            Err(_) => { /* Silently ignore errors. */ }\n+        }\n+    }\n+\n     ///////////////////////////////////////////////////////////////////////////\n     // EVALUATION\n     //\n@@ -1003,7 +1060,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                    candidates: &mut SelectionCandidateSet<'tcx>)\n                                    -> Result<(),SelectionError<'tcx>>\n     {\n-        let kind = match self.fn_family_trait_kind(obligation.predicate.0.def_id()) {\n+        let kind = match self.tcx().lang_items.fn_trait_kind(obligation.predicate.0.def_id()) {\n             Some(k) => k,\n             None => { return Ok(()); }\n         };\n@@ -2303,22 +2360,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         impl_obligations\n     }\n \n-    fn fn_family_trait_kind(&self,\n-                            trait_def_id: ast::DefId)\n-                            -> Option<ty::ClosureKind>\n-    {\n-        let tcx = self.tcx();\n-        if Some(trait_def_id) == tcx.lang_items.fn_trait() {\n-            Some(ty::FnClosureKind)\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_mut_trait() {\n-            Some(ty::FnMutClosureKind)\n-        } else if Some(trait_def_id) == tcx.lang_items.fn_once_trait() {\n-            Some(ty::FnOnceClosureKind)\n-        } else {\n-            None\n-        }\n-    }\n-\n     #[allow(unused_comparisons)]\n     fn derived_cause(&self,\n                      obligation: &TraitObligation<'tcx>,"}, {"sha": "51996ddfbe8008578993088852111147de67db21", "filename": "src/test/run-pass/closure-inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c9e1c445dbcbfc9c938488a79ef12595e0f99c8d/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c9e1c445dbcbfc9c938488a79ef12595e0f99c8d/src%2Ftest%2Frun-pass%2Fclosure-inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclosure-inference.rs?ref=c9e1c445dbcbfc9c938488a79ef12595e0f99c8d", "patch": "@@ -14,6 +14,6 @@ fn foo(i: int) -> int { i + 1 }\n fn apply<A, F>(f: F, v: A) -> A where F: FnOnce(A) -> A { f(v) }\n \n pub fn main() {\n-    let f = {|: i| foo(i)};\n+    let f = {|i| foo(i)};\n     assert_eq!(apply(f, 2), 3);\n }"}]}