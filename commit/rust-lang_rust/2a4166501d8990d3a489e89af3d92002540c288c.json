{"sha": "2a4166501d8990d3a489e89af3d92002540c288c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJhNDE2NjUwMWQ4OTkwZDNhNDg5ZTg5YWYzZDkyMDAyNTQwYzI4OGM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-07-11T14:29:09Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2020-07-12T18:20:31Z"}, "message": "Remove built-in Unsize impls\n\nThey exist in Chalk now.", "tree": {"sha": "f514e2c613df8f3a6569410bda37548e3f3d7e02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f514e2c613df8f3a6569410bda37548e3f3d7e02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2a4166501d8990d3a489e89af3d92002540c288c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4166501d8990d3a489e89af3d92002540c288c", "html_url": "https://github.com/rust-lang/rust/commit/2a4166501d8990d3a489e89af3d92002540c288c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2a4166501d8990d3a489e89af3d92002540c288c/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "71d645101db8f3674ba5be4c55ac3732336ee4ba", "url": "https://api.github.com/repos/rust-lang/rust/commits/71d645101db8f3674ba5be4c55ac3732336ee4ba", "html_url": "https://github.com/rust-lang/rust/commit/71d645101db8f3674ba5be4c55ac3732336ee4ba"}], "stats": {"total": 241, "additions": 6, "deletions": 235}, "files": [{"sha": "f7edb4c8b6af740040c82fbaa3646fb7b593a658", "filename": "crates/ra_hir_ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/2a4166501d8990d3a489e89af3d92002540c288c/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4166501d8990d3a489e89af3d92002540c288c/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits.rs?ref=2a4166501d8990d3a489e89af3d92002540c288c", "patch": "@@ -295,13 +295,8 @@ pub enum Impl {\n     /// A normal impl from an impl block.\n     ImplDef(ImplId),\n     /// Closure types implement the Fn traits synthetically.\n+    // FIXME: implement closure support from Chalk, remove this\n     ClosureFnTraitImpl(ClosureFnTraitImplData),\n-    /// [T; n]: Unsize<[T]>\n-    UnsizeArray,\n-    /// T: Unsize<dyn Trait> where T: Trait\n-    UnsizeToTraitObject(TraitId),\n-    /// dyn Trait: Unsize<dyn SuperTrait> if Trait: SuperTrait\n-    UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData),\n }\n /// This exists just for Chalk, because our ImplIds are only unique per module.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]"}, {"sha": "86e22e459542a669ac49a86b7fb333b749412917", "filename": "crates/ra_hir_ty/src/traits/builtin.rs", "status": "modified", "additions": 4, "deletions": 197, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/2a4166501d8990d3a489e89af3d92002540c288c/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4166501d8990d3a489e89af3d92002540c288c/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fbuiltin.rs?ref=2a4166501d8990d3a489e89af3d92002540c288c", "patch": "@@ -1,15 +1,12 @@\n //! This module provides the built-in trait implementations, e.g. to make\n //! closures implement `Fn`.\n-use hir_def::{expr::Expr, lang_item::LangItemTarget, TraitId, TypeAliasId};\n+use hir_def::{expr::Expr, TraitId, TypeAliasId};\n use hir_expand::name::name;\n use ra_db::CrateId;\n \n-use super::{AssocTyValue, Impl, UnsizeToSuperTraitObjectData};\n+use super::{AssocTyValue, Impl};\n use crate::{\n-    db::HirDatabase,\n-    utils::{all_super_traits, generics},\n-    ApplicationTy, Binders, BoundVar, DebruijnIndex, GenericPredicate, Substs, TraitRef, Ty,\n-    TypeCtor, TypeWalk,\n+    db::HirDatabase, ApplicationTy, BoundVar, DebruijnIndex, Substs, TraitRef, Ty, TypeCtor,\n };\n \n pub(super) struct BuiltinImplData {\n@@ -31,7 +28,7 @@ pub(super) fn get_builtin_impls(\n     krate: CrateId,\n     ty: &Ty,\n     // The first argument for the trait, if present\n-    arg: &Option<Ty>,\n+    _arg: &Option<Ty>,\n     trait_: TraitId,\n     mut callback: impl FnMut(Impl),\n ) {\n@@ -50,60 +47,12 @@ pub(super) fn get_builtin_impls(\n             }\n         }\n     }\n-\n-    let unsize_trait = get_unsize_trait(db, krate);\n-    if let Some(actual_trait) = unsize_trait {\n-        if trait_ == actual_trait {\n-            get_builtin_unsize_impls(db, krate, ty, arg, callback);\n-        }\n-    }\n-}\n-\n-fn get_builtin_unsize_impls(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    ty: &Ty,\n-    // The first argument for the trait, if present\n-    arg: &Option<Ty>,\n-    mut callback: impl FnMut(Impl),\n-) {\n-    if !check_unsize_impl_prerequisites(db, krate) {\n-        return;\n-    }\n-\n-    if let Ty::Apply(ApplicationTy { ctor: TypeCtor::Array, .. }) = ty {\n-        callback(Impl::UnsizeArray);\n-        return; // array is unsized, the rest of the impls shouldn't apply\n-    }\n-\n-    if let Some(target_trait) = arg.as_ref().and_then(|t| t.dyn_trait_ref()) {\n-        // FIXME what about more complicated dyn tys with marker traits?\n-        if let Some(trait_ref) = ty.dyn_trait_ref() {\n-            if trait_ref.trait_ != target_trait.trait_ {\n-                let super_traits = all_super_traits(db.upcast(), trait_ref.trait_);\n-                if super_traits.contains(&target_trait.trait_) {\n-                    callback(Impl::UnsizeToSuperTraitObject(UnsizeToSuperTraitObjectData {\n-                        trait_: trait_ref.trait_,\n-                        super_trait: target_trait.trait_,\n-                    }));\n-                }\n-            }\n-        } else {\n-            // FIXME only for sized types\n-            callback(Impl::UnsizeToTraitObject(target_trait.trait_));\n-        }\n-    }\n }\n \n pub(super) fn impl_datum(db: &dyn HirDatabase, krate: CrateId, impl_: Impl) -> BuiltinImplData {\n     match impl_ {\n         Impl::ImplDef(_) => unreachable!(),\n         Impl::ClosureFnTraitImpl(data) => closure_fn_trait_impl_datum(db, krate, data),\n-        Impl::UnsizeArray => array_unsize_impl_datum(db, krate),\n-        Impl::UnsizeToTraitObject(trait_) => trait_object_unsize_impl_datum(db, krate, trait_),\n-        Impl::UnsizeToSuperTraitObject(data) => {\n-            super_trait_object_unsize_impl_datum(db, krate, data)\n-        }\n     }\n }\n \n@@ -227,145 +176,3 @@ fn closure_fn_trait_output_assoc_ty_value(\n         value: output_ty,\n     }\n }\n-\n-// Array unsizing\n-\n-fn check_unsize_impl_prerequisites(db: &dyn HirDatabase, krate: CrateId) -> bool {\n-    // the Unsize trait needs to exist and have two type parameters (Self and T)\n-    let unsize_trait = match get_unsize_trait(db, krate) {\n-        Some(t) => t,\n-        None => return false,\n-    };\n-    let generic_params = generics(db.upcast(), unsize_trait.into());\n-    generic_params.len() == 2\n-}\n-\n-fn array_unsize_impl_datum(db: &dyn HirDatabase, krate: CrateId) -> BuiltinImplData {\n-    // impl<T> Unsize<[T]> for [T; _]\n-    // (this can be a single impl because we don't distinguish array sizes currently)\n-\n-    let trait_ = get_unsize_trait(db, krate) // get unsize trait\n-        // the existence of the Unsize trait has been checked before\n-        .expect(\"Unsize trait missing\");\n-\n-    let var = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n-    let substs = Substs::builder(2)\n-        .push(Ty::apply_one(TypeCtor::Array, var.clone()))\n-        .push(Ty::apply_one(TypeCtor::Slice, var))\n-        .build();\n-\n-    let trait_ref = TraitRef { trait_, substs };\n-\n-    BuiltinImplData {\n-        num_vars: 1,\n-        trait_ref,\n-        where_clauses: Vec::new(),\n-        assoc_ty_values: Vec::new(),\n-    }\n-}\n-\n-// Trait object unsizing\n-\n-fn trait_object_unsize_impl_datum(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    trait_: TraitId,\n-) -> BuiltinImplData {\n-    // impl<T, T1, ...> Unsize<dyn Trait<T1, ...>> for T where T: Trait<T1, ...>\n-\n-    let unsize_trait = get_unsize_trait(db, krate) // get unsize trait\n-        // the existence of the Unsize trait has been checked before\n-        .expect(\"Unsize trait missing\");\n-\n-    let self_ty = Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0));\n-\n-    let target_substs = Substs::build_for_def(db, trait_)\n-        .push(Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)))\n-        .fill_with_bound_vars(DebruijnIndex::ONE, 1)\n-        .build();\n-    let num_vars = target_substs.len();\n-    let target_trait_ref = TraitRef { trait_, substs: target_substs };\n-    let target_bounds = vec![GenericPredicate::Implemented(target_trait_ref)];\n-\n-    let self_substs =\n-        Substs::build_for_def(db, trait_).fill_with_bound_vars(DebruijnIndex::INNERMOST, 0).build();\n-    let self_trait_ref = TraitRef { trait_, substs: self_substs };\n-    let where_clauses = vec![GenericPredicate::Implemented(self_trait_ref)];\n-\n-    let impl_substs = Substs::builder(2).push(self_ty).push(Ty::Dyn(target_bounds.into())).build();\n-\n-    let trait_ref = TraitRef { trait_: unsize_trait, substs: impl_substs };\n-\n-    BuiltinImplData { num_vars, trait_ref, where_clauses, assoc_ty_values: Vec::new() }\n-}\n-\n-fn super_trait_object_unsize_impl_datum(\n-    db: &dyn HirDatabase,\n-    krate: CrateId,\n-    data: UnsizeToSuperTraitObjectData,\n-) -> BuiltinImplData {\n-    // impl<T1, ...> Unsize<dyn SuperTrait> for dyn Trait<T1, ...>\n-\n-    let unsize_trait = get_unsize_trait(db, krate) // get unsize trait\n-        // the existence of the Unsize trait has been checked before\n-        .expect(\"Unsize trait missing\");\n-\n-    let self_substs = Substs::build_for_def(db, data.trait_)\n-        .fill_with_bound_vars(DebruijnIndex::INNERMOST, 0)\n-        .build();\n-    let self_trait_ref = TraitRef { trait_: data.trait_, substs: self_substs.clone() };\n-\n-    let num_vars = self_substs.len() - 1;\n-\n-    // we need to go from our trait to the super trait, substituting type parameters\n-    let path = crate::utils::find_super_trait_path(db.upcast(), data.trait_, data.super_trait);\n-\n-    let mut current_trait_ref = self_trait_ref.clone();\n-    for t in path.into_iter().skip(1) {\n-        let bounds = db.generic_predicates(current_trait_ref.trait_.into());\n-        let super_trait_ref = bounds\n-            .iter()\n-            .find_map(|b| match &b.value {\n-                GenericPredicate::Implemented(tr)\n-                    if tr.trait_ == t\n-                        && tr.substs[0]\n-                            == Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)) =>\n-                {\n-                    Some(Binders { value: tr, num_binders: b.num_binders })\n-                }\n-                _ => None,\n-            })\n-            .expect(\"trait bound for known super trait not found\");\n-        current_trait_ref = super_trait_ref.cloned().subst(&current_trait_ref.substs);\n-    }\n-\n-    // We need to renumber the variables a bit now: from ^0.0, ^0.1, ^0.2, ...\n-    // to ^0.0, ^1.0, ^1.1. The reason for this is that the first variable comes\n-    // from the dyn Trait binder, while the other variables come from the impl.\n-    let new_substs = Substs::builder(num_vars + 1)\n-        .push(Ty::Bound(BoundVar::new(DebruijnIndex::INNERMOST, 0)))\n-        .fill_with_bound_vars(DebruijnIndex::ONE, 0)\n-        .build();\n-\n-    let self_bounds =\n-        vec![GenericPredicate::Implemented(self_trait_ref.subst_bound_vars(&new_substs))];\n-    let super_bounds =\n-        vec![GenericPredicate::Implemented(current_trait_ref.subst_bound_vars(&new_substs))];\n-\n-    let substs = Substs::builder(2)\n-        .push(Ty::Dyn(self_bounds.into()))\n-        .push(Ty::Dyn(super_bounds.into()))\n-        .build();\n-\n-    let trait_ref = TraitRef { trait_: unsize_trait, substs };\n-\n-    BuiltinImplData { num_vars, trait_ref, where_clauses: Vec::new(), assoc_ty_values: Vec::new() }\n-}\n-\n-fn get_unsize_trait(db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n-    let target = db.lang_item(krate, \"unsize\".into())?;\n-    match target {\n-        LangItemTarget::TraitId(t) => Some(t),\n-        _ => None,\n-    }\n-}"}, {"sha": "7bdb6264e6acbff115f12fcfd5a03ec3913aede1", "filename": "crates/ra_hir_ty/src/traits/chalk/mapping.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2a4166501d8990d3a489e89af3d92002540c288c/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4166501d8990d3a489e89af3d92002540c288c/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Ftraits%2Fchalk%2Fmapping.rs?ref=2a4166501d8990d3a489e89af3d92002540c288c", "patch": "@@ -271,6 +271,7 @@ impl ToChalk for TypeCtor {\n             }\n             TypeCtor::Never => TypeName::Never,\n \n+            // FIXME convert these\n             TypeCtor::Adt(_)\n             | TypeCtor::Array\n             | TypeCtor::FnPtr { .. }"}, {"sha": "e3e2442680e8ec7946c19501c70e480fe40c482b", "filename": "crates/ra_hir_ty/src/utils.rs", "status": "modified", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/2a4166501d8990d3a489e89af3d92002540c288c/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2a4166501d8990d3a489e89af3d92002540c288c/crates%2Fra_hir_ty%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir_ty%2Fsrc%2Futils.rs?ref=2a4166501d8990d3a489e89af3d92002540c288c", "patch": "@@ -110,38 +110,6 @@ pub(super) fn all_super_trait_refs(db: &dyn HirDatabase, trait_ref: TraitRef) ->\n     result\n }\n \n-/// Finds a path from a trait to one of its super traits. Returns an empty\n-/// vector if there is no path.\n-pub(super) fn find_super_trait_path(\n-    db: &dyn DefDatabase,\n-    trait_: TraitId,\n-    super_trait: TraitId,\n-) -> Vec<TraitId> {\n-    let mut result = Vec::with_capacity(2);\n-    result.push(trait_);\n-    return if go(db, super_trait, &mut result) { result } else { Vec::new() };\n-\n-    fn go(db: &dyn DefDatabase, super_trait: TraitId, path: &mut Vec<TraitId>) -> bool {\n-        let trait_ = *path.last().unwrap();\n-        if trait_ == super_trait {\n-            return true;\n-        }\n-\n-        for tt in direct_super_traits(db, trait_) {\n-            if path.contains(&tt) {\n-                continue;\n-            }\n-            path.push(tt);\n-            if go(db, super_trait, path) {\n-                return true;\n-            } else {\n-                path.pop();\n-            }\n-        }\n-        false\n-    }\n-}\n-\n pub(super) fn associated_type_by_name_including_super_traits(\n     db: &dyn HirDatabase,\n     trait_ref: TraitRef,"}]}