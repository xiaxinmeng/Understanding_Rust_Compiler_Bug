{"sha": "db24ee9db02acf0912a89626e09801665bbb365a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRiMjRlZTlkYjAyYWNmMDkxMmE4OTYyNmUwOTgwMTY2NWJiYjM2NWE=", "commit": {"author": {"name": "Fedor Indutny", "email": "fedor.indutny@gmail.com", "date": "2013-06-26T15:42:11Z"}, "committer": {"name": "Fedor Indutny", "email": "fedor.indutny@gmail.com", "date": "2013-07-09T15:20:26Z"}, "message": "os: introduce cross-platform MemoryMap bindings\n\nBasically, one may just do:\n\n    MemoryMap::new(16, ~[\n      MapExecutable,\n      MapReadable,\n      MapWritable\n    ])\n\nAnd executable+readable+writable chunk of at least 16 bytes size will be\nallocated and freed with the result of `MemoryMap::new`.", "tree": {"sha": "d8f0a542f08db501d88ec74fa7da332e81494eeb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8f0a542f08db501d88ec74fa7da332e81494eeb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/db24ee9db02acf0912a89626e09801665bbb365a", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/db24ee9db02acf0912a89626e09801665bbb365a", "html_url": "https://github.com/rust-lang/rust/commit/db24ee9db02acf0912a89626e09801665bbb365a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/db24ee9db02acf0912a89626e09801665bbb365a/comments", "author": {"login": "indutny", "id": 238531, "node_id": "MDQ6VXNlcjIzODUzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/238531?v=4", "gravatar_id": "", "url": "https://api.github.com/users/indutny", "html_url": "https://github.com/indutny", "followers_url": "https://api.github.com/users/indutny/followers", "following_url": "https://api.github.com/users/indutny/following{/other_user}", "gists_url": "https://api.github.com/users/indutny/gists{/gist_id}", "starred_url": "https://api.github.com/users/indutny/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/indutny/subscriptions", "organizations_url": "https://api.github.com/users/indutny/orgs", "repos_url": "https://api.github.com/users/indutny/repos", "events_url": "https://api.github.com/users/indutny/events{/privacy}", "received_events_url": "https://api.github.com/users/indutny/received_events", "type": "User", "site_admin": false}, "committer": {"login": "indutny", "id": 238531, "node_id": "MDQ6VXNlcjIzODUzMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/238531?v=4", "gravatar_id": "", "url": "https://api.github.com/users/indutny", "html_url": "https://github.com/indutny", "followers_url": "https://api.github.com/users/indutny/followers", "following_url": "https://api.github.com/users/indutny/following{/other_user}", "gists_url": "https://api.github.com/users/indutny/gists{/gist_id}", "starred_url": "https://api.github.com/users/indutny/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/indutny/subscriptions", "organizations_url": "https://api.github.com/users/indutny/orgs", "repos_url": "https://api.github.com/users/indutny/repos", "events_url": "https://api.github.com/users/indutny/events{/privacy}", "received_events_url": "https://api.github.com/users/indutny/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4a868c7c1df6a0e68b03c1710474e83c057d69c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/4a868c7c1df6a0e68b03c1710474e83c057d69c0", "html_url": "https://github.com/rust-lang/rust/commit/4a868c7c1df6a0e68b03c1710474e83c057d69c0"}], "stats": {"total": 362, "additions": 358, "deletions": 4}, "files": [{"sha": "2518ba1a73d9a7c35d0ce1ceb41f67928275f5dc", "filename": "src/libstd/libc.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/db24ee9db02acf0912a89626e09801665bbb365a/src%2Flibstd%2Flibc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db24ee9db02acf0912a89626e09801665bbb365a/src%2Flibstd%2Flibc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flibc.rs?ref=db24ee9db02acf0912a89626e09801665bbb365a", "patch": "@@ -732,8 +732,8 @@ pub mod types {\n                             wProcessorArchitecture: 0,\n                             wReserved: 0,\n                             dwPageSize: 0,\n-                            lpMinimumApplicationAddress: ptr::null(),\n-                            lpMaximumApplicationAddress: ptr::null(),\n+                            lpMinimumApplicationAddress: ptr::mut_null(),\n+                            lpMaximumApplicationAddress: ptr::mut_null(),\n                             dwActiveProcessorMask: 0,\n                             dwNumberOfProcessors: 0,\n                             dwProcessorType: 0,\n@@ -1011,7 +1011,7 @@ pub mod consts {\n         }\n         pub mod extra {\n             use libc::types::os::arch::c95::c_int;\n-            use libc::types::os::arch::extra::{DWORD, BOOL};\n+            use libc::types::os::arch::extra::{WORD, DWORD, BOOL};\n \n             pub static TRUE : BOOL = 1;\n             pub static FALSE : BOOL = 0;\n@@ -3002,7 +3002,8 @@ pub mod funcs {\n                                                LPCVOID};\n             use libc::types::os::arch::extra::{LPSECURITY_ATTRIBUTES, LPSTARTUPINFO,\n                                                LPPROCESS_INFORMATION,\n-                                               LPMEMORY_BASIC_INFORMATION};\n+                                               LPMEMORY_BASIC_INFORMATION,\n+                                               LPSYSTEM_INFO};\n             use libc::types::os::arch::extra::{HANDLE, LPHANDLE};\n \n             #[abi = \"stdcall\"]"}, {"sha": "50acbee697f2b5ccd3eacd9f508a84aef28a1196", "filename": "src/libstd/os.rs", "status": "modified", "additions": 353, "deletions": 0, "changes": 353, "blob_url": "https://github.com/rust-lang/rust/blob/db24ee9db02acf0912a89626e09801665bbb365a/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/db24ee9db02acf0912a89626e09801665bbb365a/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=db24ee9db02acf0912a89626e09801665bbb365a", "patch": "@@ -41,6 +41,7 @@ use os;\n use prelude::*;\n use ptr;\n use str;\n+use to_str;\n use uint;\n use unstable::finally::Finally;\n use vec;\n@@ -1335,6 +1336,288 @@ extern {\n     pub fn _NSGetArgv() -> ***c_char;\n }\n \n+// Round up `from` to be divisible by `to`\n+fn round_up(from: uint, to: uint) -> uint {\n+    let r = if from % to == 0 {\n+        from\n+    } else {\n+        from + to - (from % to)\n+    };\n+    if r == 0 {\n+        to\n+    } else {\n+        r\n+    }\n+}\n+\n+#[cfg(unix)]\n+pub fn page_size() -> uint {\n+    unsafe {\n+        libc::sysconf(libc::_SC_PAGESIZE) as uint\n+    }\n+}\n+\n+#[cfg(windows)]\n+pub fn page_size() -> uint {\n+  unsafe {\n+    let mut info = libc::SYSTEM_INFO::new();\n+    libc::GetSystemInfo(&mut info);\n+\n+    return info.dwPageSize as uint;\n+  }\n+}\n+\n+pub struct MemoryMap {\n+    data: *mut u8,\n+    len: size_t,\n+    kind: MemoryMapKind\n+}\n+\n+pub enum MemoryMapKind {\n+    MapFile(*c_void),\n+    MapVirtual\n+}\n+\n+pub enum MapOption {\n+    MapReadable,\n+    MapWritable,\n+    MapExecutable,\n+    MapAddr(*c_void),\n+    MapFd(c_int),\n+    MapOffset(uint)\n+}\n+\n+pub enum MapError {\n+    // Linux-specific errors\n+    ErrFdNotAvail,\n+    ErrInvalidFd,\n+    ErrUnaligned,\n+    ErrNoMapSupport,\n+    ErrNoMem,\n+    ErrUnknown(libc::c_int),\n+\n+    // Windows-specific errors\n+    ErrUnsupProt,\n+    ErrUnsupOffset,\n+    ErrNeedRW,\n+    ErrAlreadyExists,\n+    ErrVirtualAlloc(uint),\n+    ErrCreateFileMappingW(uint),\n+    ErrMapViewOfFile(uint)\n+}\n+\n+impl to_str::ToStr for MapError {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ErrFdNotAvail => ~\"fd not available for reading or writing\",\n+            ErrInvalidFd => ~\"Invalid fd\",\n+            ErrUnaligned => ~\"Unaligned address, invalid flags, \\\n+                              negative length or unaligned offset\",\n+            ErrNoMapSupport=> ~\"File doesn't support mapping\",\n+            ErrNoMem => ~\"Invalid address, or not enough available memory\",\n+            ErrUnknown(code) => fmt!(\"Unknown error=%?\", code),\n+            ErrUnsupProt => ~\"Protection mode unsupported\",\n+            ErrUnsupOffset => ~\"Offset in virtual memory mode is unsupported\",\n+            ErrNeedRW => ~\"File mapping should be at least readable/writable\",\n+            ErrAlreadyExists => ~\"File mapping for specified file already exists\",\n+            ErrVirtualAlloc(code) => fmt!(\"VirtualAlloc failure=%?\", code),\n+            ErrCreateFileMappingW(code) => fmt!(\"CreateFileMappingW failure=%?\", code),\n+            ErrMapViewOfFile(code) => fmt!(\"MapViewOfFile failure=%?\", code)\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+impl MemoryMap {\n+    pub fn new(min_len: uint, options: ~[MapOption]) -> Result<~MemoryMap, MapError> {\n+        use libc::off_t;\n+\n+        let mut addr: *c_void = ptr::null();\n+        let mut prot: c_int = 0;\n+        let mut flags: c_int = libc::MAP_PRIVATE;\n+        let mut fd: c_int = -1;\n+        let mut offset: off_t = 0;\n+        let len = round_up(min_len, page_size()) as size_t;\n+\n+        for options.iter().advance |&o| {\n+            match o {\n+                MapReadable => { prot |= libc::PROT_READ; },\n+                MapWritable => { prot |= libc::PROT_WRITE; },\n+                MapExecutable => { prot |= libc::PROT_EXEC; },\n+                MapAddr(addr_) => {\n+                    flags |= libc::MAP_FIXED;\n+                    addr = addr_;\n+                },\n+                MapFd(fd_) => {\n+                    flags |= libc::MAP_FILE;\n+                    fd = fd_;\n+                },\n+                MapOffset(offset_) => { offset = offset_ as off_t; }\n+            }\n+        }\n+        if fd == -1 { flags |= libc::MAP_ANON; }\n+\n+        let r = unsafe {\n+            libc::mmap(addr, len, prot, flags, fd, offset)\n+        };\n+        if r == libc::MAP_FAILED {\n+            Err(match errno() as c_int {\n+                libc::EACCES => ErrFdNotAvail,\n+                libc::EBADF => ErrInvalidFd,\n+                libc::EINVAL => ErrUnaligned,\n+                libc::ENODEV => ErrNoMapSupport,\n+                libc::ENOMEM => ErrNoMem,\n+                code => ErrUnknown(code)\n+            })\n+        } else {\n+            Ok(~MemoryMap {\n+               data: r as *mut u8,\n+               len: len,\n+               kind: if fd == -1 {\n+                   MapVirtual\n+               } else {\n+                   MapFile(ptr::null())\n+               }\n+            })\n+        }\n+    }\n+}\n+\n+#[cfg(unix)]\n+impl Drop for MemoryMap {\n+    fn drop(&self) {\n+        unsafe {\n+            match libc::munmap(self.data as *c_void, self.len) {\n+                0 => (),\n+                -1 => error!(match errno() as c_int {\n+                    libc::EINVAL => ~\"invalid addr or len\",\n+                    e => fmt!(\"unknown errno=%?\", e)\n+                }),\n+                r => error!(fmt!(\"Unexpected result %?\", r))\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+impl MemoryMap {\n+    pub fn new(min_len: uint, options: ~[MapOption]) -> Result<~MemoryMap, MapError> {\n+        use libc::types::os::arch::extra::{LPVOID, DWORD, SIZE_T, HANDLE};\n+\n+        let mut lpAddress: LPVOID = ptr::mut_null();\n+        let mut readable = false;\n+        let mut writable = false;\n+        let mut executable = false;\n+        let mut fd: c_int = -1;\n+        let mut offset: uint = 0;\n+        let len = round_up(min_len, page_size()) as SIZE_T;\n+\n+        for options.iter().advance |&o| {\n+            match o {\n+                MapReadable => { readable = true; },\n+                MapWritable => { writable = true; },\n+                MapExecutable => { executable = true; }\n+                MapAddr(addr_) => { lpAddress = addr_ as LPVOID; },\n+                MapFd(fd_) => { fd = fd_; },\n+                MapOffset(offset_) => { offset = offset_; }\n+            }\n+        }\n+\n+        let flProtect = match (executable, readable, writable) {\n+            (false, false, false) if fd == -1 => libc::PAGE_NOACCESS,\n+            (false, true, false) => libc::PAGE_READONLY,\n+            (false, true, true) => libc::PAGE_READWRITE,\n+            (true, false, false) if fd == -1 => libc::PAGE_EXECUTE,\n+            (true, true, false) => libc::PAGE_EXECUTE_READ,\n+            (true, true, true) => libc::PAGE_EXECUTE_READWRITE,\n+            _ => return Err(ErrUnsupProt)\n+        };\n+\n+        if fd == -1 {\n+            if offset != 0 {\n+                return Err(ErrUnsupOffset);\n+            }\n+            let r = unsafe {\n+                libc::VirtualAlloc(lpAddress,\n+                                   len,\n+                                   libc::MEM_COMMIT | libc::MEM_RESERVE,\n+                                   flProtect)\n+            };\n+            match r as uint {\n+                0 => Err(ErrVirtualAlloc(errno())),\n+                _ => Ok(~MemoryMap {\n+                   data: r as *mut u8,\n+                   len: len,\n+                   kind: MapVirtual\n+                })\n+            }\n+        } else {\n+            let dwDesiredAccess = match (readable, writable) {\n+                (true, true) => libc::FILE_MAP_ALL_ACCESS,\n+                (true, false) => libc::FILE_MAP_READ,\n+                (false, true) => libc::FILE_MAP_WRITE,\n+                _ => {\n+                    return Err(ErrNeedRW);\n+                }\n+            };\n+            unsafe {\n+                let hFile = libc::get_osfhandle(fd) as HANDLE;\n+                let mapping = libc::CreateFileMappingW(hFile,\n+                                                       ptr::mut_null(),\n+                                                       flProtect,\n+                                                       (len >> 32) as DWORD,\n+                                                       (len & 0xffff_ffff) as DWORD,\n+                                                       ptr::null());\n+                if mapping == ptr::mut_null() {\n+                    return Err(ErrCreateFileMappingW(errno()));\n+                }\n+                if errno() as c_int == libc::ERROR_ALREADY_EXISTS {\n+                    return Err(ErrAlreadyExists);\n+                }\n+                let r = libc::MapViewOfFile(mapping,\n+                                            dwDesiredAccess,\n+                                            (offset >> 32) as DWORD,\n+                                            (offset & 0xffff_ffff) as DWORD,\n+                                            0);\n+                match r as uint {\n+                    0 => Err(ErrMapViewOfFile(errno())),\n+                    _ => Ok(~MemoryMap {\n+                       data: r as *mut u8,\n+                       len: len,\n+                       kind: MapFile(mapping as *c_void)\n+                    })\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(windows)]\n+impl Drop for MemoryMap {\n+    fn drop(&self) {\n+        use libc::types::os::arch::extra::{LPCVOID, HANDLE};\n+\n+        unsafe {\n+            match self.kind {\n+                MapVirtual => match libc::VirtualFree(self.data as *mut c_void,\n+                                                      self.len,\n+                                                      libc::MEM_RELEASE) {\n+                    0 => error!(fmt!(\"VirtualFree failed: %?\", errno())),\n+                    _ => ()\n+                },\n+                MapFile(mapping) => {\n+                    if libc::UnmapViewOfFile(self.data as LPCVOID) != 0 {\n+                        error!(fmt!(\"UnmapViewOfFile failed: %?\", errno()));\n+                    }\n+                    if libc::CloseHandle(mapping as HANDLE) != 0 {\n+                        error!(fmt!(\"CloseHandle failed: %?\", errno()));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n pub mod consts {\n \n     #[cfg(unix)]\n@@ -1715,5 +1998,75 @@ mod tests {\n         assert!(!os::mkdir_recursive(&path, (S_IRUSR | S_IWUSR | S_IXUSR) as i32));\n     }\n \n+    #[test]\n+    fn memory_map_rw() {\n+        use result::{Ok, Err};\n+\n+        let chunk = match os::MemoryMap::new(16, ~[\n+            os::MapReadable,\n+            os::MapWritable\n+        ]) {\n+            Ok(chunk) => chunk,\n+            Err(msg) => fail!(msg.to_str())\n+        };\n+        assert!(chunk.len >= 16);\n+\n+        unsafe {\n+            *chunk.data = 0xBE;\n+            assert!(*chunk.data == 0xBE);\n+        }\n+    }\n+\n+    #[test]\n+    fn memory_map_file() {\n+        use result::{Ok, Err};\n+        use os::*;\n+        use libc::*;\n+\n+        #[cfg(unix)]\n+        fn lseek_(fd: c_int, size: uint) {\n+            unsafe {\n+                assert!(lseek(fd, size as off_t, SEEK_SET) == size as off_t);\n+            }\n+        }\n+        #[cfg(windows)]\n+        fn lseek_(fd: c_int, size: uint) {\n+           unsafe {\n+               assert!(lseek(fd, size as c_long, SEEK_SET) == size as c_long);\n+           }\n+        }\n+\n+        let p = tmpdir().push(\"mmap_file.tmp\");\n+        let size = page_size() * 2;\n+        remove_file(&p);\n+\n+        let fd = unsafe {\n+            let fd = do as_c_charp(p.to_str()) |path| {\n+                open(path, O_CREAT | O_RDWR | O_TRUNC, S_IRUSR | S_IWUSR)\n+            };\n+            lseek_(fd, size);\n+            do as_c_charp(\"x\") |x| {\n+                assert!(write(fd, x as *c_void, 1) == 1);\n+            }\n+            fd\n+        };\n+        let chunk = match MemoryMap::new(size / 2, ~[\n+            MapReadable,\n+            MapWritable,\n+            MapFd(fd),\n+            MapOffset(size / 2)\n+        ]) {\n+            Ok(chunk) => chunk,\n+            Err(msg) => fail!(msg.to_str())\n+        };\n+        assert!(chunk.len > 0);\n+\n+        unsafe {\n+            *chunk.data = 0xbe;\n+            assert!(*chunk.data == 0xbe);\n+            close(fd);\n+        }\n+    }\n+\n     // More recursive_mkdir tests are in extra::tempfile\n }"}]}