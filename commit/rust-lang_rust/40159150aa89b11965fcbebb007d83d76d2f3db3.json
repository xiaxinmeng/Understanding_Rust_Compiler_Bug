{"sha": "40159150aa89b11965fcbebb007d83d76d2f3db3", "node_id": "C_kwDOAAsO6NoAKDQwMTU5MTUwYWE4OWIxMTk2NWZjYmViYjAwN2Q4M2Q3NmQyZjNkYjM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-12-11T22:58:49Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-11T22:58:49Z"}, "message": "Merge #10951\n\n10951: feat: assist to generate documentation templates r=Veykril a=numero-744\n\nCloses #10878, #1915 and #4767\r\n\r\nFull description is in #10878, better read [the tests](https://github.com/rust-analyzer/rust-analyzer/pull/10951/files#diff-7a64e2efb66b2625443340fcbc96d531baff12c17cc0aaf51885ea94f67de254R424) to understand what this feature does.\r\n\r\n- [x] There is one remaining thing about non-`pub` functions, what do you think about it?\r\n- [x] In this PR [empty examples are generated](https://github.com/rust-analyzer/rust-analyzer/pull/10951/files#diff-7a64e2efb66b2625443340fcbc96d531baff12c17cc0aaf51885ea94f67de254R99) for `trait` functions, but maybe no examples should be provided at all.\r\n- [x] If there is already a documentation, add another one with a separator ([currently done](https://github.com/rust-analyzer/rust-analyzer/pull/10951/files#diff-7a64e2efb66b2625443340fcbc96d531baff12c17cc0aaf51885ea94f67de254R74)) or simply disable this assist?\r\n- [x] I will check once more that the generated examples are correct (ie. they are easy to fill before that they are built and tested)\r\n\r\nComments appreciated :smile: \n\nCo-authored-by: C\u00f4me ALLART <come.allart@etu.emse.fr>", "tree": {"sha": "6e7f074e2f60b085b1a2205f33995357effc2402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6e7f074e2f60b085b1a2205f33995357effc2402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/40159150aa89b11965fcbebb007d83d76d2f3db3", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhtS0pCRBK7hj4Ov3rIwAAeYQIAC/O6dCT9hqBtWcTjBN5naqo\n1ACE9aF4cBStRHtB26Ld1OV92P4rDNMnllaqTnxjadLJivNvfF3pMS2CgmE49xr7\n4y8/TGJbM+C3oPXNhLkqVVyb+sIeg0QC32PF29PZtK/Z755r/1PMKJ2cl300hsrz\nHBS4QzMA0QrSyi1cA03HTDgZj0G8XGJp0e6mkM0Pk5VXEkuZpiw/BlqnszEHML1Z\n1IRX8KhSrVJTwGcD3A6PB8XlyWKNyYgvcKF94hIFrTqCN4a6jglz1tLoM89zEHfd\n7rfdPBwbb3auPt18D2GNBGSEbpezdE9dhm4IIW6rjm89rv336PU4RYVl/lqbRUA=\n=p8lE\n-----END PGP SIGNATURE-----\n", "payload": "tree 6e7f074e2f60b085b1a2205f33995357effc2402\nparent 36a7c0e00902172af7ea43704e58eedd32b308bc\nparent 0e89f2f346ff00f5411a238fb85e48ede50e35cc\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1639263529 +0000\ncommitter GitHub <noreply@github.com> 1639263529 +0000\n\nMerge #10951\n\n10951: feat: assist to generate documentation templates r=Veykril a=numero-744\n\nCloses #10878, #1915 and #4767\r\n\r\nFull description is in #10878, better read [the tests](https://github.com/rust-analyzer/rust-analyzer/pull/10951/files#diff-7a64e2efb66b2625443340fcbc96d531baff12c17cc0aaf51885ea94f67de254R424) to understand what this feature does.\r\n\r\n- [x] There is one remaining thing about non-`pub` functions, what do you think about it?\r\n- [x] In this PR [empty examples are generated](https://github.com/rust-analyzer/rust-analyzer/pull/10951/files#diff-7a64e2efb66b2625443340fcbc96d531baff12c17cc0aaf51885ea94f67de254R99) for `trait` functions, but maybe no examples should be provided at all.\r\n- [x] If there is already a documentation, add another one with a separator ([currently done](https://github.com/rust-analyzer/rust-analyzer/pull/10951/files#diff-7a64e2efb66b2625443340fcbc96d531baff12c17cc0aaf51885ea94f67de254R74)) or simply disable this assist?\r\n- [x] I will check once more that the generated examples are correct (ie. they are easy to fill before that they are built and tested)\r\n\r\nComments appreciated :smile: \n\nCo-authored-by: C\u00f4me ALLART <come.allart@etu.emse.fr>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/40159150aa89b11965fcbebb007d83d76d2f3db3", "html_url": "https://github.com/rust-lang/rust/commit/40159150aa89b11965fcbebb007d83d76d2f3db3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/40159150aa89b11965fcbebb007d83d76d2f3db3/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36a7c0e00902172af7ea43704e58eedd32b308bc", "url": "https://api.github.com/repos/rust-lang/rust/commits/36a7c0e00902172af7ea43704e58eedd32b308bc", "html_url": "https://github.com/rust-lang/rust/commit/36a7c0e00902172af7ea43704e58eedd32b308bc"}, {"sha": "0e89f2f346ff00f5411a238fb85e48ede50e35cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e89f2f346ff00f5411a238fb85e48ede50e35cc", "html_url": "https://github.com/rust-lang/rust/commit/0e89f2f346ff00f5411a238fb85e48ede50e35cc"}], "stats": {"total": 1123, "additions": 1123, "deletions": 0}, "files": [{"sha": "cfc7e9d0436f393290b013dc618ca1d03a9b8d77", "filename": "crates/ide_assists/src/handlers/generate_documentation_template.rs", "status": "added", "additions": 1091, "deletions": 0, "changes": 1091, "blob_url": "https://github.com/rust-lang/rust/blob/40159150aa89b11965fcbebb007d83d76d2f3db3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40159150aa89b11965fcbebb007d83d76d2f3db3/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fhandlers%2Fgenerate_documentation_template.rs?ref=40159150aa89b11965fcbebb007d83d76d2f3db3", "patch": "@@ -0,0 +1,1091 @@\n+use hir::{AsAssocItem, HasVisibility, ModuleDef, Visibility};\n+use ide_db::assists::{AssistId, AssistKind};\n+use itertools::Itertools;\n+use stdx::to_lower_snake_case;\n+use syntax::{\n+    ast::{self, edit::IndentLevel, HasDocComments, HasName},\n+    AstNode,\n+};\n+\n+use crate::assist_context::{AssistContext, Assists};\n+\n+// Assist: generate_documentation_template\n+//\n+// Adds a documentation template above a function definition / declaration.\n+//\n+// ```\n+// pub fn my_$0func(a: i32, b: i32) -> Result<(), std::io::Error> {\n+//     unimplemented!()\n+// }\n+// ```\n+// ->\n+// ```\n+// /// .\n+// ///\n+// /// # Examples\n+// ///\n+// /// ```\n+// /// use test::my_func;\n+// ///\n+// /// assert_eq!(my_func(a, b), );\n+// /// ```\n+// ///\n+// /// # Errors\n+// ///\n+// /// This function will return an error if .\n+// pub fn my_func(a: i32, b: i32) -> Result<(), std::io::Error> {\n+//     unimplemented!()\n+// }\n+// ```\n+pub(crate) fn generate_documentation_template(\n+    acc: &mut Assists,\n+    ctx: &AssistContext,\n+) -> Option<()> {\n+    let name = ctx.find_node_at_offset::<ast::Name>()?;\n+    let ast_func = name.syntax().parent().and_then(ast::Fn::cast)?;\n+    if is_in_trait_impl(&ast_func, ctx)\n+        || !is_public(&ast_func, ctx)?\n+        || ast_func.doc_comments().next().is_some()\n+    {\n+        return None;\n+    }\n+\n+    let parent_syntax = ast_func.syntax();\n+    let text_range = parent_syntax.text_range();\n+    let indent_level = IndentLevel::from_node(&parent_syntax);\n+\n+    acc.add(\n+        AssistId(\"generate_documentation_template\", AssistKind::Generate),\n+        \"Generate a documentation template\",\n+        text_range,\n+        |builder| {\n+            let mut doc_lines = Vec::new();\n+            // Introduction / short function description before the sections\n+            doc_lines.push(introduction_builder(&ast_func, ctx));\n+            // Then come the sections\n+            if let Some(mut lines) = examples_builder(&ast_func, ctx) {\n+                doc_lines.push(\"\".into());\n+                doc_lines.append(&mut lines);\n+            }\n+            for section_builder in [panics_builder, errors_builder, safety_builder] {\n+                if let Some(mut lines) = section_builder(&ast_func) {\n+                    doc_lines.push(\"\".into());\n+                    doc_lines.append(&mut lines);\n+                }\n+            }\n+            builder.insert(text_range.start(), documentation_from_lines(doc_lines, indent_level));\n+        },\n+    )\n+}\n+\n+/// Builds an introduction, trying to be smart if the function is `::new()`\n+fn introduction_builder(ast_func: &ast::Fn, ctx: &AssistContext) -> String {\n+    || -> Option<String> {\n+        let hir_func = ctx.sema.to_def(ast_func)?;\n+        let container = hir_func.as_assoc_item(ctx.db())?.container(ctx.db());\n+        if let hir::AssocItemContainer::Impl(implementation) = container {\n+            let ret_ty = hir_func.ret_type(ctx.db());\n+            let self_ty = implementation.self_ty(ctx.db());\n+\n+            let is_new = ast_func.name()?.to_string() == \"new\";\n+            match is_new && ret_ty == self_ty {\n+                true => Some(format!(\"Creates a new [`{}`].\", self_type(ast_func)?)),\n+                false => None,\n+            }\n+        } else {\n+            None\n+        }\n+    }()\n+    .unwrap_or_else(|| \".\".into())\n+}\n+\n+/// Builds an `# Examples` section. An option is returned to be able to manage an error in the AST.\n+fn examples_builder(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<Vec<String>> {\n+    let mut lines = string_vec_from(&[\"# Examples\", \"\", \"```\"]);\n+    if is_in_trait_def(ast_func, ctx) {\n+        lines.push(\"// Example template not implemented for trait functions\".into());\n+    } else {\n+        lines.append(&mut gen_ex_template(ast_func, ctx)?)\n+    };\n+\n+    lines.push(\"```\".into());\n+    Some(lines)\n+}\n+\n+/// Builds an optional `# Panics` section\n+fn panics_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {\n+    match can_panic(ast_func) {\n+        Some(true) => Some(string_vec_from(&[\"# Panics\", \"\", \"Panics if .\"])),\n+        _ => None,\n+    }\n+}\n+\n+/// Builds an optional `# Errors` section\n+fn errors_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {\n+    match return_type(ast_func)?.to_string().contains(\"Result\") {\n+        true => Some(string_vec_from(&[\"# Errors\", \"\", \"This function will return an error if .\"])),\n+        false => None,\n+    }\n+}\n+\n+/// Builds an optional `# Safety` section\n+fn safety_builder(ast_func: &ast::Fn) -> Option<Vec<String>> {\n+    let is_unsafe = ast_func.unsafe_token().is_some();\n+    match is_unsafe {\n+        true => Some(string_vec_from(&[\"# Safety\", \"\", \".\"])),\n+        false => None,\n+    }\n+}\n+\n+/// Generates an example template\n+fn gen_ex_template(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<Vec<String>> {\n+    let mut lines = Vec::new();\n+    let is_unsafe = ast_func.unsafe_token().is_some();\n+    let param_list = ast_func.param_list()?;\n+    let ref_mut_params = ref_mut_params(&param_list);\n+    let self_name: Option<String> = self_name(ast_func);\n+\n+    lines.push(format!(\"use {};\", build_path(ast_func, ctx)?));\n+    lines.push(\"\".into());\n+    if let Some(self_definition) = self_definition(ast_func, self_name.as_deref()) {\n+        lines.push(self_definition);\n+    }\n+    for param_name in &ref_mut_params {\n+        lines.push(format!(\"let mut {} = ;\", param_name))\n+    }\n+    // Call the function, check result\n+    let function_call = function_call(ast_func, &param_list, self_name.as_deref(), is_unsafe)?;\n+    if returns_a_value(ast_func, ctx) {\n+        if count_parameters(&param_list) < 3 {\n+            lines.push(format!(\"assert_eq!({}, );\", function_call));\n+        } else {\n+            lines.push(format!(\"let result = {};\", function_call));\n+            lines.push(\"assert_eq!(result, );\".into());\n+        }\n+    } else {\n+        lines.push(format!(\"{};\", function_call));\n+    }\n+    // Check the mutated values\n+    if is_ref_mut_self(ast_func) == Some(true) {\n+        lines.push(format!(\"assert_eq!({}, );\", self_name?));\n+    }\n+    for param_name in &ref_mut_params {\n+        lines.push(format!(\"assert_eq!({}, );\", param_name));\n+    }\n+    Some(lines)\n+}\n+\n+/// Checks if the function is public / exported\n+fn is_public(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<bool> {\n+    let hir_func = ctx.sema.to_def(ast_func)?;\n+    Some(\n+        hir_func.visibility(ctx.db()) == Visibility::Public\n+            && all_parent_mods_public(&hir_func, ctx),\n+    )\n+}\n+\n+/// Checks that all parent modules of the function are public / exported\n+fn all_parent_mods_public(hir_func: &hir::Function, ctx: &AssistContext) -> bool {\n+    let mut module = hir_func.module(ctx.db());\n+    loop {\n+        if let Some(parent) = module.parent(ctx.db()) {\n+            match ModuleDef::from(module).visibility(ctx.db()) {\n+                Visibility::Public => module = parent,\n+                _ => break false,\n+            }\n+        } else {\n+            break true;\n+        }\n+    }\n+}\n+\n+/// Returns the name of the current crate\n+fn crate_name(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+    let krate = ctx.sema.scope(&ast_func.syntax()).module()?.krate();\n+    Some(krate.display_name(ctx.db())?.to_string())\n+}\n+\n+/// `None` if function without a body; some bool to guess if function can panic\n+fn can_panic(ast_func: &ast::Fn) -> Option<bool> {\n+    let body = ast_func.body()?.to_string();\n+    let can_panic = body.contains(\"panic!(\")\n+        // FIXME it would be better to not match `debug_assert*!` macro invocations\n+        || body.contains(\"assert!(\")\n+        || body.contains(\".unwrap()\")\n+        || body.contains(\".expect(\");\n+    Some(can_panic)\n+}\n+\n+/// Helper function to get the name that should be given to `self` arguments\n+fn self_name(ast_func: &ast::Fn) -> Option<String> {\n+    self_partial_type(ast_func).map(|name| to_lower_snake_case(&name))\n+}\n+\n+/// Heper function to get the name of the type of `self`\n+fn self_type(ast_func: &ast::Fn) -> Option<String> {\n+    ast_func\n+        .syntax()\n+        .ancestors()\n+        .find_map(ast::Impl::cast)\n+        .and_then(|i| i.self_ty())\n+        .map(|t| (t.to_string()))\n+}\n+\n+/// Heper function to get the name of the type of `self` without generic arguments\n+fn self_partial_type(ast_func: &ast::Fn) -> Option<String> {\n+    let mut self_type = self_type(ast_func)?;\n+    if let Some(idx) = self_type.find(|c| ['<', ' '].contains(&c)) {\n+        self_type.truncate(idx);\n+    }\n+    Some(self_type)\n+}\n+\n+/// Helper function to determine if the function is in a trait implementation\n+fn is_in_trait_impl(ast_func: &ast::Fn, ctx: &AssistContext) -> bool {\n+    ctx.sema\n+        .to_def(ast_func)\n+        .and_then(|hir_func| hir_func.as_assoc_item(ctx.db()))\n+        .and_then(|assoc_item| assoc_item.containing_trait_impl(ctx.db()))\n+        .is_some()\n+}\n+\n+/// Helper function to determine if the function definition is in a trait definition\n+fn is_in_trait_def(ast_func: &ast::Fn, ctx: &AssistContext) -> bool {\n+    ctx.sema\n+        .to_def(ast_func)\n+        .and_then(|hir_func| hir_func.as_assoc_item(ctx.db()))\n+        .and_then(|assoc_item| assoc_item.containing_trait(ctx.db()))\n+        .is_some()\n+}\n+\n+/// Returns `None` if no `self` at all, `Some(true)` if there is `&mut self` else `Some(false)`\n+fn is_ref_mut_self(ast_func: &ast::Fn) -> Option<bool> {\n+    let self_param = ast_func.param_list()?.self_param()?;\n+    Some(self_param.mut_token().is_some() && self_param.amp_token().is_some())\n+}\n+\n+/// Helper function to define an variable to be the `self` argument\n+fn self_definition(ast_func: &ast::Fn, self_name: Option<&str>) -> Option<String> {\n+    let definition = match is_ref_mut_self(ast_func)? {\n+        true => format!(\"let mut {} = ;\", self_name?),\n+        false => format!(\"let {} = ;\", self_name?),\n+    };\n+    Some(definition)\n+}\n+\n+/// Helper function to determine if a parameter is `&mut`\n+fn is_a_ref_mut_param(param: &ast::Param) -> bool {\n+    match param.ty() {\n+        Some(ast::Type::RefType(param_ref)) => param_ref.mut_token().is_some(),\n+        _ => false,\n+    }\n+}\n+\n+/// Helper function to build the list of `&mut` parameters\n+fn ref_mut_params(param_list: &ast::ParamList) -> Vec<String> {\n+    param_list\n+        .params()\n+        .filter_map(|param| match is_a_ref_mut_param(&param) {\n+            // Maybe better filter the param name (to do this maybe extract a function from\n+            // `arguments_from_params`?) in case of a `mut a: &mut T`. Anyway managing most (not\n+            // all) cases might be enough, the goal is just to produce a template.\n+            true => Some(param.pat()?.to_string()),\n+            false => None,\n+        })\n+        .collect()\n+}\n+\n+/// Helper function to build the comma-separated list of arguments of the function\n+fn arguments_from_params(param_list: &ast::ParamList) -> String {\n+    let args_iter = param_list.params().map(|param| match param.pat() {\n+        // To avoid `mut` in the function call (which would be a nonsense), `Pat` should not be\n+        // written as is so its variants must be managed independently. Other variants (for\n+        // instance `TuplePat`) could be managed later.\n+        Some(ast::Pat::IdentPat(ident_pat)) => match ident_pat.name() {\n+            Some(name) => match is_a_ref_mut_param(&param) {\n+                true => format!(\"&mut {}\", name.to_string()),\n+                false => name.to_string(),\n+            },\n+            None => \"_\".to_string(),\n+        },\n+        _ => \"_\".to_string(),\n+    });\n+    Itertools::intersperse(args_iter, \", \".to_string()).collect()\n+}\n+\n+/// Helper function to build a function call. `None` if expected `self_name` was not provided\n+fn function_call(\n+    ast_func: &ast::Fn,\n+    param_list: &ast::ParamList,\n+    self_name: Option<&str>,\n+    is_unsafe: bool,\n+) -> Option<String> {\n+    let name = ast_func.name()?;\n+    let arguments = arguments_from_params(&param_list);\n+    let function_call = if param_list.self_param().is_some() {\n+        format!(\"{}.{}({})\", self_name?, name, arguments)\n+    } else if let Some(implementation) = self_partial_type(ast_func) {\n+        format!(\"{}::{}({})\", implementation, name, arguments)\n+    } else {\n+        format!(\"{}({})\", name, arguments)\n+    };\n+    match is_unsafe {\n+        true => Some(format!(\"unsafe {{ {} }}\", function_call)),\n+        false => Some(function_call),\n+    }\n+}\n+\n+/// Helper function to count the parameters including `self`\n+fn count_parameters(param_list: &ast::ParamList) -> usize {\n+    param_list.params().count() + if param_list.self_param().is_some() { 1 } else { 0 }\n+}\n+\n+/// Helper function to transform lines of documentation into a Rust code documentation\n+fn documentation_from_lines(doc_lines: Vec<String>, indent_level: IndentLevel) -> String {\n+    let mut result = String::new();\n+    for doc_line in doc_lines {\n+        result.push_str(\"///\");\n+        if !doc_line.is_empty() {\n+            result.push(' ');\n+            result.push_str(&doc_line);\n+        }\n+        result.push('\\n');\n+        result.push_str(&indent_level.to_string());\n+    }\n+    result\n+}\n+\n+/// Helper function to transform an array of borrowed strings to an owned `Vec<String>`\n+fn string_vec_from(string_array: &[&str]) -> Vec<String> {\n+    string_array.iter().map(|&s| s.to_owned()).collect()\n+}\n+\n+/// Helper function to build the path of the module in the which is the node\n+fn build_path(ast_func: &ast::Fn, ctx: &AssistContext) -> Option<String> {\n+    let crate_name = crate_name(ast_func, ctx)?;\n+    let leaf = self_partial_type(ast_func)\n+        .or_else(|| ast_func.name().map(|n| n.to_string()))\n+        .unwrap_or_else(|| \"*\".into());\n+    let module_def: ModuleDef = ctx.sema.to_def(ast_func)?.module(ctx.db()).into();\n+    match module_def.canonical_path(ctx.db()) {\n+        Some(path) => Some(format!(\"{}::{}::{}\", crate_name, path, leaf)),\n+        None => Some(format!(\"{}::{}\", crate_name, leaf)),\n+    }\n+}\n+\n+/// Helper function to get the return type of a function\n+fn return_type(ast_func: &ast::Fn) -> Option<ast::Type> {\n+    ast_func.ret_type()?.ty()\n+}\n+\n+/// Helper function to determine if the function returns some data\n+fn returns_a_value(ast_func: &ast::Fn, ctx: &AssistContext) -> bool {\n+    ctx.sema\n+        .to_def(ast_func)\n+        .map(|hir_func| hir_func.ret_type(ctx.db()))\n+        .map(|ret_ty| !ret_ty.is_unit() && !ret_ty.is_never())\n+        .unwrap_or(false)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::tests::{check_assist, check_assist_not_applicable};\n+\n+    use super::*;\n+\n+    #[test]\n+    fn not_applicable_on_function_calls() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"\n+fn hello_world() {}\n+fn calls_hello_world() {\n+    hello_world$0();\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_in_trait_impl() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"\n+trait MyTrait {}\n+struct MyStruct;\n+impl MyTrait for MyStruct {\n+    fn hello_world$0();\n+}\n+\"#,\n+        )\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_function_is_private() {\n+        check_assist_not_applicable(generate_documentation_template, r#\"fn priv$0ate() {}\"#);\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_function_is_pub_crate() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"pub(crate) fn pri$0vate() {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_function_is_in_private_mod() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"\n+mod PrivateModule {\n+    pub fn pri$0vate() {}\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_function_is_in_pub_crate_mod() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"\n+pub(crate) mod PrivateModule {\n+    pub fn pr$0ivate() {}\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_function_is_in_non_public_mod_is_recursive() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"\n+mod ParentPrivateModule {\n+    pub mod PrivateModule {\n+        pub fn pr$0ivate() {}\n+    }\n+}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn not_applicable_if_function_already_documented() {\n+        check_assist_not_applicable(\n+            generate_documentation_template,\n+            r#\"\n+/// Some documentation here\n+pub fn $0documented_function() {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_noop_function() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn no$0op() {}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::noop;\n+///\n+/// noop();\n+/// ```\n+pub fn noop() {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_a_parameter() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn no$0op_with_param(_a: i32) {}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::noop_with_param;\n+///\n+/// noop_with_param(_a);\n+/// ```\n+pub fn noop_with_param(_a: i32) {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn detects_unsafe_function() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub unsafe fn no$0op_unsafe() {}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::noop_unsafe;\n+///\n+/// unsafe { noop_unsafe() };\n+/// ```\n+///\n+/// # Safety\n+///\n+/// .\n+pub unsafe fn noop_unsafe() {}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_panic_macro_can_panic() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn panic$0s_if(a: bool) {\n+    if a {\n+        panic!();\n+    }\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::panics_if;\n+///\n+/// panics_if(a);\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if .\n+pub fn panics_if(a: bool) {\n+    if a {\n+        panic!();\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_assert_macro_can_panic() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn $0panics_if_not(a: bool) {\n+    assert!(a == true);\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::panics_if_not;\n+///\n+/// panics_if_not(a);\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if .\n+pub fn panics_if_not(a: bool) {\n+    assert!(a == true);\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_unwrap_can_panic() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn $0panics_if_none(a: Option<()>) {\n+    a.unwrap();\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::panics_if_none;\n+///\n+/// panics_if_none(a);\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if .\n+pub fn panics_if_none(a: Option<()>) {\n+    a.unwrap();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn guesses_expect_can_panic() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn $0panics_if_none2(a: Option<()>) {\n+    a.expect(\"Bouh!\");\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::panics_if_none2;\n+///\n+/// panics_if_none2(a);\n+/// ```\n+///\n+/// # Panics\n+///\n+/// Panics if .\n+pub fn panics_if_none2(a: Option<()>) {\n+    a.expect(\"Bouh!\");\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn checks_output_in_example() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn returns_a_value$0() -> i32 {\n+    0\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::returns_a_value;\n+///\n+/// assert_eq!(returns_a_value(), );\n+/// ```\n+pub fn returns_a_value() -> i32 {\n+    0\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn detects_result_output() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn returns_a_result$0() -> Result<i32, std::io::Error> {\n+    Ok(0)\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::returns_a_result;\n+///\n+/// assert_eq!(returns_a_result(), );\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if .\n+pub fn returns_a_result() -> Result<i32, std::io::Error> {\n+    Ok(0)\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn checks_ref_mut_in_example() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn modifies_a_value$0(a: &mut i32) {\n+    *a = 0;\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::modifies_a_value;\n+///\n+/// let mut a = ;\n+/// modifies_a_value(&mut a);\n+/// assert_eq!(a, );\n+/// ```\n+pub fn modifies_a_value(a: &mut i32) {\n+    *a = 0;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn stores_result_if_at_least_3_params() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub fn sum3$0(a: i32, b: i32, c: i32) -> i32 {\n+    a + b + c\n+}\n+\"#,\n+            r#\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::sum3;\n+///\n+/// let result = sum3(a, b, c);\n+/// assert_eq!(result, );\n+/// ```\n+pub fn sum3(a: i32, b: i32, c: i32) -> i32 {\n+    a + b + c\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_fn_in_mods() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub mod a {\n+    pub mod b {\n+        pub fn no$0op() {}\n+    }\n+}\n+\"#,\n+            r#\"\n+pub mod a {\n+    pub mod b {\n+        /// .\n+        ///\n+        /// # Examples\n+        ///\n+        /// ```\n+        /// use test::a::b::noop;\n+        ///\n+        /// noop();\n+        /// ```\n+        pub fn noop() {}\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_fn_in_impl() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub struct MyStruct;\n+impl MyStruct {\n+    pub fn no$0op() {}\n+}\n+\"#,\n+            r#\"\n+pub struct MyStruct;\n+impl MyStruct {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyStruct;\n+    ///\n+    /// MyStruct::noop();\n+    /// ```\n+    pub fn noop() {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_fn_in_trait() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub trait MyTrait {\n+    fn fun$0ction_trait();\n+}\n+\"#,\n+            r#\"\n+pub trait MyTrait {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // Example template not implemented for trait functions\n+    /// ```\n+    fn function_trait();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_unsafe_fn_in_trait() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub trait MyTrait {\n+    unsafe fn unsafe_funct$0ion_trait();\n+}\n+\"#,\n+            r#\"\n+pub trait MyTrait {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // Example template not implemented for trait functions\n+    /// ```\n+    ///\n+    /// # Safety\n+    ///\n+    /// .\n+    unsafe fn unsafe_function_trait();\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_fn_in_trait_with_default_panicking() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub trait MyTrait {\n+    fn function_trait_with_$0default_panicking() {\n+        panic!()\n+    }\n+}\n+\"#,\n+            r#\"\n+pub trait MyTrait {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // Example template not implemented for trait functions\n+    /// ```\n+    ///\n+    /// # Panics\n+    ///\n+    /// Panics if .\n+    fn function_trait_with_default_panicking() {\n+        panic!()\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_fn_in_trait_returning_result() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+pub trait MyTrait {\n+    fn function_tr$0ait_returning_result() -> Result<(), std::io::Error>;\n+}\n+\"#,\n+            r#\"\n+pub trait MyTrait {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// // Example template not implemented for trait functions\n+    /// ```\n+    ///\n+    /// # Errors\n+    ///\n+    /// This function will return an error if .\n+    fn function_trait_returning_result() -> Result<(), std::io::Error>;\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn detects_new() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<T> {\n+    pub x: T,\n+}\n+impl<T> MyGenericStruct<T> {\n+    pub fn new$0(x: T) -> MyGenericStruct<T> {\n+        MyGenericStruct { x }\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct<T> {\n+    pub x: T,\n+}\n+impl<T> MyGenericStruct<T> {\n+    /// Creates a new [`MyGenericStruct<T>`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// assert_eq!(MyGenericStruct::new(x), );\n+    /// ```\n+    pub fn new(x: T) -> MyGenericStruct<T> {\n+        MyGenericStruct { x }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn detects_new_with_self() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct2<T> {\n+    pub x: T,\n+}\n+impl<T> MyGenericStruct2<T> {\n+    pub fn new$0(x: T) -> Self {\n+        MyGenericStruct2 { x }\n+    }\n+}\n+\"#,\n+            r#\"\n+#[derive(Debug, PartialEq)]\n+pub struct MyGenericStruct2<T> {\n+    pub x: T,\n+}\n+impl<T> MyGenericStruct2<T> {\n+    /// Creates a new [`MyGenericStruct2<T>`].\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct2;\n+    ///\n+    /// assert_eq!(MyGenericStruct2::new(x), );\n+    /// ```\n+    pub fn new(x: T) -> Self {\n+        MyGenericStruct2 { x }\n+    }\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn supports_method_call() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+impl<T> MyGenericStruct<T> {\n+    pub fn co$0nsume(self) {}\n+}\n+\"#,\n+            r#\"\n+impl<T> MyGenericStruct<T> {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// let my_generic_struct = ;\n+    /// my_generic_struct.consume();\n+    /// ```\n+    pub fn consume(self) {}\n+}\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn checks_modified_self_param() {\n+        check_assist(\n+            generate_documentation_template,\n+            r#\"\n+impl<T> MyGenericStruct<T> {\n+    pub fn modi$0fy(&mut self, new_value: T) {\n+        self.x = new_value;\n+    }\n+}\n+\"#,\n+            r#\"\n+impl<T> MyGenericStruct<T> {\n+    /// .\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use test::MyGenericStruct;\n+    ///\n+    /// let mut my_generic_struct = ;\n+    /// my_generic_struct.modify(new_value);\n+    /// assert_eq!(my_generic_struct, );\n+    /// ```\n+    pub fn modify(&mut self, new_value: T) {\n+        self.x = new_value;\n+    }\n+}\n+\"#,\n+        );\n+    }\n+}"}, {"sha": "61ac45637be2e4a76f60a3773bc561c21397057c", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/40159150aa89b11965fcbebb007d83d76d2f3db3/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40159150aa89b11965fcbebb007d83d76d2f3db3/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=40159150aa89b11965fcbebb007d83d76d2f3db3", "patch": "@@ -136,6 +136,7 @@ mod handlers {\n     mod generate_default_from_new;\n     mod generate_deref;\n     mod generate_derive;\n+    mod generate_documentation_template;\n     mod generate_enum_is_method;\n     mod generate_enum_projection_method;\n     mod generate_from_impl_for_enum;\n@@ -219,6 +220,7 @@ mod handlers {\n             generate_delegate_methods::generate_delegate_methods,\n             generate_deref::generate_deref,\n             generate_derive::generate_derive,\n+            generate_documentation_template::generate_documentation_template,\n             generate_enum_is_method::generate_enum_is_method,\n             generate_enum_projection_method::generate_enum_as_method,\n             generate_enum_projection_method::generate_enum_try_into_method,"}, {"sha": "c67e15b2ce44d3c6fda74de8f4f691cee963c6cb", "filename": "crates/ide_assists/src/tests/generated.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/40159150aa89b11965fcbebb007d83d76d2f3db3/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/40159150aa89b11965fcbebb007d83d76d2f3db3/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=40159150aa89b11965fcbebb007d83d76d2f3db3", "patch": "@@ -839,6 +839,36 @@ struct Point {\n     )\n }\n \n+#[test]\n+fn doctest_generate_documentation_template() {\n+    check_doc_test(\n+        \"generate_documentation_template\",\n+        r#####\"\n+pub fn my_$0func(a: i32, b: i32) -> Result<(), std::io::Error> {\n+    unimplemented!()\n+}\n+\"#####,\n+        r#####\"\n+/// .\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use test::my_func;\n+///\n+/// assert_eq!(my_func(a, b), );\n+/// ```\n+///\n+/// # Errors\n+///\n+/// This function will return an error if .\n+pub fn my_func(a: i32, b: i32) -> Result<(), std::io::Error> {\n+    unimplemented!()\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_generate_enum_as_method() {\n     check_doc_test("}]}