{"sha": "c697a56d01c650f65b4ca4a264db1ea3573d0565", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2OTdhNTZkMDFjNjUwZjY1YjRjYTRhMjY0ZGIxZWEzNTczZDA1NjU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-01T23:00:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2018-07-01T23:00:27Z"}, "message": "Auto merge of #51110 - alexreg:new-static-eval-rules, r=eddyb\n\nLoosened rules involving statics mentioning other statics\n\nBefore this PR, trying to mention a static in any way other than taking a reference to it caused a compile-time error. So, while\n\n```rust\nstatic A: u32 = 42;\nstatic B: &u32 = &A;\n```\n\ncompiles successfully,\n\n```rust\nstatic A: u32 = 42;\nstatic B: u32 = A; // error\n```\n\nand\n\n```rust\nstatic A: u32 = 42;\nstatic B: u32 = *&A; // error\n```\n\nare not possible to express in Rust. On the other hand, introducing an intermediate `const fn` can presently allow one to do just that:\n\n```rust\nstatic A: u32 = 42;\nstatic B: u32 = foo(&A); // success!\n\nconst fn foo(a: &u32) -> u32 {\n    *a\n}\n```\n\nPreventing `const fn` from allowing to work around the ban on reading from statics would cripple `const fn` almost into uselessness.\nAdditionally, the limitation for reading from statics comes from the old const evaluator(s) and is not shared by `miri`.\n\nThis PR loosens the rules around use of statics to allow statics to evaluate other statics by value, allowing all of the above examples to compile and run successfully.\nReads from extern (foreign) statics are however still disallowed by miri, because there is no compile-time value to be read.\n\n```rust\nextern static A: u32;\n\nstatic B: u32 = A; // error\n```\n\nThis opens up a new avenue of potential issues, as a static can now not just refer to other statics or read from other statics, but even contain references that point into itself.\nWhile it might seem like this could cause subtle bugs like allowing a static to be initialized by its own value, this is inherently impossible in miri.\nReading from a static causes the `const_eval` query for that static to be invoked. Calling the `const_eval` query for a static while already inside the `const_eval` query of said static will cause cycle errors.\nIt is not possible to accidentally create a bug in miri that would enable initializing a static with itself, because the memory of the static *does not exist* while being initialized.\nThe memory is not uninitialized, it is not there. Thus any change that would accidentally allow reading from a not yet initialized static would cause ICEs.\n\nTests have been modified according to the new rules, and new tests have been added for writing to `static mut`s within definitions of statics (which needs to fail), and incremental compilation with complex/interlinking static definitions.\nNote that incremental compilation did not need to be adjusted, because all of this was already possible before with workarounds (like intermediate `const fn`s) and the encoding/decoding already supports all the possible cases.\n\nr? @eddyb", "tree": {"sha": "e5e43f3bc9c0e880853ec6c6ab1639b35eba2896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e5e43f3bc9c0e880853ec6c6ab1639b35eba2896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c697a56d01c650f65b4ca4a264db1ea3573d0565", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c697a56d01c650f65b4ca4a264db1ea3573d0565", "html_url": "https://github.com/rust-lang/rust/commit/c697a56d01c650f65b4ca4a264db1ea3573d0565", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c697a56d01c650f65b4ca4a264db1ea3573d0565/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a7a60dc7f8e9a53feb70ee7aa05485345a045afb", "url": "https://api.github.com/repos/rust-lang/rust/commits/a7a60dc7f8e9a53feb70ee7aa05485345a045afb", "html_url": "https://github.com/rust-lang/rust/commit/a7a60dc7f8e9a53feb70ee7aa05485345a045afb"}, {"sha": "1c342270424058847b3e348dea4038ff42ab75eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/1c342270424058847b3e348dea4038ff42ab75eb", "html_url": "https://github.com/rust-lang/rust/commit/1c342270424058847b3e348dea4038ff42ab75eb"}], "stats": {"total": 363, "additions": 127, "deletions": 236}, "files": [{"sha": "5753557a102aa95e664ae9dd3cff1b36a2d53ec2", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -521,6 +521,7 @@ for ::mir::interpret::EvalErrorKind<'gcx, O> {\n             InvalidNullPointerUsage |\n             ReadPointerAsBytes |\n             ReadBytesAsPointer |\n+            ReadForeignStatic |\n             InvalidPointerMath |\n             ReadUndefBytes |\n             DeadLocal |"}, {"sha": "7e2c144e0a71df68731067f21cd4e2ac1fd9aa63", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -188,6 +188,7 @@ pub enum EvalErrorKind<'tcx, O> {\n     InvalidNullPointerUsage,\n     ReadPointerAsBytes,\n     ReadBytesAsPointer,\n+    ReadForeignStatic,\n     InvalidPointerMath,\n     ReadUndefBytes,\n     DeadLocal,\n@@ -304,6 +305,8 @@ impl<'tcx, O> EvalErrorKind<'tcx, O> {\n                 \"a raw memory access tried to access part of a pointer value as raw bytes\",\n             ReadBytesAsPointer =>\n                 \"a memory access tried to interpret some bytes as a pointer\",\n+            ReadForeignStatic =>\n+                \"tried to read from foreign (extern) static\",\n             InvalidPointerMath =>\n                 \"attempted to do invalid arithmetic on pointers that would leak base addresses, e.g. comparing pointers into different allocations\",\n             ReadUndefBytes =>"}, {"sha": "c84999a7e5990c6df750c963d2a833758d5a288d", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -506,6 +506,7 @@ impl<'a, 'tcx, O: Lift<'tcx>> Lift<'tcx> for interpret::EvalErrorKind<'a, O> {\n             InvalidNullPointerUsage => InvalidNullPointerUsage,\n             ReadPointerAsBytes => ReadPointerAsBytes,\n             ReadBytesAsPointer => ReadBytesAsPointer,\n+            ReadForeignStatic => ReadForeignStatic,\n             InvalidPointerMath => InvalidPointerMath,\n             ReadUndefBytes => ReadUndefBytes,\n             DeadLocal => DeadLocal,"}, {"sha": "3c751d52b066498f93102a1aaf04c57bf2f9669c", "filename": "src/librustc_mir/diagnostics.rs", "status": "modified", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc_mir%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc_mir%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdiagnostics.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -1145,33 +1145,6 @@ fn main() {\n ```\n \"##,\n \n-E0394: r##\"\n-A static was referred to by value by another static.\n-\n-Erroneous code examples:\n-\n-```compile_fail,E0394\n-static A: u32 = 0;\n-static B: u32 = A; // error: cannot refer to other statics by value, use the\n-                   //        address-of operator or a constant instead\n-```\n-\n-A static cannot be referred by value. To fix this issue, either use a\n-constant:\n-\n-```\n-const A: u32 = 0; // `A` is now a constant\n-static B: u32 = A; // ok!\n-```\n-\n-Or refer to `A` by reference:\n-\n-```\n-static A: u32 = 0;\n-static B: &'static u32 = &A; // ok!\n-```\n-\"##,\n-\n E0395: r##\"\n The value assigned to a constant scalar must be known at compile time,\n which is not the case when comparing raw pointers.\n@@ -1333,34 +1306,6 @@ Remember this solution is unsafe! You will have to ensure that accesses to the\n cell are synchronized.\n \"##,\n \n-E0494: r##\"\n-A reference of an interior static was assigned to another const/static.\n-Erroneous code example:\n-\n-```compile_fail,E0494\n-struct Foo {\n-    a: u32\n-}\n-\n-static S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a;\n-// error: cannot refer to the interior of another static, use a\n-//        constant instead\n-```\n-\n-The \"base\" variable has to be a const if you want another static/const variable\n-to refer to one of its fields. Example:\n-\n-```\n-struct Foo {\n-    a: u32\n-}\n-\n-const S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a; // ok!\n-```\n-\"##,\n-\n E0499: r##\"\n A variable was borrowed as mutable more than once. Erroneous code example:\n "}, {"sha": "749c0d04ae91f71a19f138287626e4b6a654e784", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -374,7 +374,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n             Ok(None)\n         } else {\n             Err(\n-                ConstEvalError::NeedsRfc(\"Pointer arithmetic or comparison\".to_string()).into(),\n+                ConstEvalError::NeedsRfc(\"pointer arithmetic or comparison\".to_string()).into(),\n             )\n         }\n     }\n@@ -404,7 +404,7 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         _dest: Place,\n     ) -> EvalResult<'tcx> {\n         Err(\n-            ConstEvalError::NeedsRfc(\"Heap allocations via `box` keyword\".to_string()).into(),\n+            ConstEvalError::NeedsRfc(\"heap allocations via `box` keyword\".to_string()).into(),\n         )\n     }\n "}, {"sha": "f5da65ae44db7b4bc6bb8a12b23d2004c4f91d74", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -279,6 +279,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n /// Allocation accessors\n impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n     fn const_eval_static(&self, def_id: DefId) -> EvalResult<'tcx, &'tcx Allocation> {\n+        if self.tcx.is_foreign_item(def_id) {\n+            return err!(ReadForeignStatic);\n+        }\n         let instance = Instance::mono(self.tcx.tcx, def_id);\n         let gid = GlobalId {\n             instance,\n@@ -302,7 +305,8 @@ impl<'a, 'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'a, 'mir, 'tcx, M> {\n                 Some(alloc) => Ok(alloc),\n                 None => {\n                     // static alloc?\n-                    match self.tcx.alloc_map.lock().get(id) {\n+                    let alloc = self.tcx.alloc_map.lock().get(id);\n+                    match alloc {\n                         Some(AllocType::Memory(mem)) => Ok(mem),\n                         Some(AllocType::Function(..)) => {\n                             Err(EvalErrorKind::DerefFunctionPointer.into())"}, {"sha": "986957d5a82676b1fdf64f41d0aeb35c306603e5", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 36, "deletions": 110, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -56,19 +56,13 @@ bitflags! {\n         // Function argument.\n         const FN_ARGUMENT       = 1 << 2;\n \n-        // Static place or move from a static.\n-        const STATIC            = 1 << 3;\n-\n-        // Reference to a static.\n-        const STATIC_REF        = 1 << 4;\n-\n         // Not constant at all - non-`const fn` calls, asm!,\n         // pointer comparisons, ptr-to-int casts, etc.\n-        const NOT_CONST         = 1 << 5;\n+        const NOT_CONST         = 1 << 3;\n \n         // Refers to temporaries which cannot be promoted as\n         // promote_consts decided they weren't simple enough.\n-        const NOT_PROMOTABLE    = 1 << 6;\n+        const NOT_PROMOTABLE    = 1 << 4;\n \n         // Const items can only have MUTABLE_INTERIOR\n         // and NOT_PROMOTABLE without producing an error.\n@@ -226,42 +220,6 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n         self.add(original);\n     }\n \n-    /// Check if a Local with the current qualifications is promotable.\n-    fn can_promote(&self, qualif: Qualif) -> bool {\n-        // References to statics are allowed, but only in other statics.\n-        if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-            (qualif - Qualif::STATIC_REF).is_empty()\n-        } else {\n-            qualif.is_empty()\n-        }\n-    }\n-\n-    /// Check if a Place with the current qualifications could\n-    /// be consumed, by either an operand or a Deref projection.\n-    fn try_consume(&mut self) -> bool {\n-        if self.qualif.intersects(Qualif::STATIC) && self.mode != Mode::Fn {\n-            let msg = if self.mode == Mode::Static ||\n-                         self.mode == Mode::StaticMut {\n-                \"cannot refer to other statics by value, use the \\\n-                 address-of operator or a constant instead\"\n-            } else {\n-                \"cannot refer to statics by value, use a constant instead\"\n-            };\n-            struct_span_err!(self.tcx.sess, self.span, E0394, \"{}\", msg)\n-                .span_label(self.span, \"referring to another static by value\")\n-                .note(\"use the address-of operator or a constant instead\")\n-                .emit();\n-\n-            // Replace STATIC with NOT_CONST to avoid further errors.\n-            self.qualif = self.qualif - Qualif::STATIC;\n-            self.add(Qualif::NOT_CONST);\n-\n-            false\n-        } else {\n-            true\n-        }\n-    }\n-\n     /// Assign the current qualification to the given destination.\n     fn assign(&mut self, dest: &Place<'tcx>, location: Location) {\n         trace!(\"assign: {:?}\", dest);\n@@ -305,7 +263,7 @@ impl<'a, 'tcx> Qualifier<'a, 'tcx, 'tcx> {\n             }) if self.mir.local_kind(index) == LocalKind::Temp\n                && self.mir.local_decls[index].ty.is_box()\n                && self.local_qualif[index].map_or(false, |qualif| {\n-                    qualif.intersects(Qualif::NOT_CONST)\n+                    qualif.contains(Qualif::NOT_CONST)\n                }) => {\n                 // Part of `box expr`, we should've errored\n                 // already for the Box allocation Rvalue.\n@@ -492,21 +450,26 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n         match *place {\n             Place::Local(ref local) => self.visit_local(local, context, location),\n             Place::Static(ref global) => {\n-                self.add(Qualif::STATIC);\n-\n-                if self.mode != Mode::Fn {\n-                    for attr in &self.tcx.get_attrs(global.def_id)[..] {\n-                        if attr.check_name(\"thread_local\") {\n-                            span_err!(self.tcx.sess, self.span, E0625,\n-                                      \"thread-local statics cannot be \\\n-                                       accessed at compile-time\");\n-                            self.add(Qualif::NOT_CONST);\n-                            return;\n-                        }\n+                if self.tcx\n+                       .get_attrs(global.def_id)\n+                       .iter()\n+                       .any(|attr| attr.check_name(\"thread_local\")) {\n+                    if self.mode != Mode::Fn {\n+                        span_err!(self.tcx.sess, self.span, E0625,\n+                                  \"thread-local statics cannot be \\\n+                                   accessed at compile-time\");\n                     }\n+                    self.add(Qualif::NOT_CONST);\n+                    return;\n+                }\n+\n+                // Only allow statics (not consts) to refer to other statics.\n+                if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n+                    return;\n                 }\n+                self.add(Qualif::NOT_CONST);\n \n-                if self.mode == Mode::Const || self.mode == Mode::ConstFn {\n+                if self.mode != Mode::Fn {\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n                                                    \"{}s cannot refer to statics, use \\\n                                                     a constant instead\", self.mode);\n@@ -527,15 +490,6 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     this.super_place(place, context, location);\n                     match proj.elem {\n                         ProjectionElem::Deref => {\n-                            if !this.try_consume() {\n-                                return;\n-                            }\n-\n-                            if this.qualif.intersects(Qualif::STATIC_REF) {\n-                                this.qualif = this.qualif - Qualif::STATIC_REF;\n-                                this.add(Qualif::STATIC);\n-                            }\n-\n                             this.add(Qualif::NOT_CONST);\n \n                             let base_ty = proj.base.ty(this.mir, this.tcx).to_ty(this.tcx);\n@@ -573,11 +527,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                         this.not_const();\n                                     }\n                                 }\n-                            } else if this.qualif.intersects(Qualif::STATIC) {\n-                                span_err!(this.tcx.sess, this.span, E0494,\n-                                          \"cannot refer to the interior of another \\\n-                                           static, use a constant instead\");\n                             }\n+\n                             let ty = place.ty(this.mir, this.tcx).to_ty(this.tcx);\n                             this.qualif.restrict(ty, this.tcx, this.param_env);\n                         }\n@@ -594,14 +545,11 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n     }\n \n     fn visit_operand(&mut self, operand: &Operand<'tcx>, location: Location) {\n+        self.super_operand(operand, location);\n+\n         match *operand {\n             Operand::Copy(_) |\n             Operand::Move(_) => {\n-                self.nest(|this| {\n-                    this.super_operand(operand, location);\n-                    this.try_consume();\n-                });\n-\n                 // Mark the consumed locals to indicate later drops are noops.\n                 if let Operand::Move(Place::Local(local)) = *operand {\n                     self.local_qualif[local] = self.local_qualif[local].map(|q|\n@@ -646,20 +594,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             }\n \n             if is_reborrow {\n-                self.nest(|this| {\n-                    this.super_place(place, PlaceContext::Borrow {\n-                        region,\n-                        kind\n-                    }, location);\n-                    if !this.try_consume() {\n-                        return;\n-                    }\n-\n-                    if this.qualif.intersects(Qualif::STATIC_REF) {\n-                        this.qualif = this.qualif - Qualif::STATIC_REF;\n-                        this.add(Qualif::STATIC);\n-                    }\n-                });\n+                self.super_place(place, PlaceContext::Borrow {\n+                    region,\n+                    kind\n+                }, location);\n             } else {\n                 self.super_rvalue(rvalue, location);\n             }\n@@ -678,22 +616,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n             Rvalue::Cast(CastKind::UnsafeFnPointer, ..) |\n             Rvalue::Cast(CastKind::ClosureFnPointer, ..) |\n             Rvalue::Cast(CastKind::Unsize, ..) |\n-            Rvalue::Discriminant(..) => {}\n-\n-            Rvalue::Len(_) => {\n-                // Static places in consts would have errored already,\n-                // don't treat length checks as reads from statics.\n-                self.qualif = self.qualif - Qualif::STATIC;\n-            }\n+            Rvalue::Discriminant(..) |\n+            Rvalue::Len(_) => {}\n \n             Rvalue::Ref(_, kind, ref place) => {\n-                // Static places in consts would have errored already,\n-                // only keep track of references to them here.\n-                if self.qualif.intersects(Qualif::STATIC) {\n-                    self.qualif = self.qualif - Qualif::STATIC;\n-                    self.add(Qualif::STATIC_REF);\n-                }\n-\n                 let ty = place.ty(self.mir, self.tcx).to_ty(self.tcx);\n \n                 // Default to forbidding the borrow and/or its promotion,\n@@ -744,7 +670,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                     // Constants cannot be borrowed if they contain interior mutability as\n                     // it means that our \"silent insertion of statics\" could change\n                     // initializer values (very bad).\n-                    if self.qualif.intersects(Qualif::MUTABLE_INTERIOR) {\n+                    if self.qualif.contains(Qualif::MUTABLE_INTERIOR) {\n                         // A reference of a MUTABLE_INTERIOR place is instead\n                         // NOT_CONST (see `if forbidden_mut` below), to avoid\n                         // duplicate errors (from reborrowing, for example).\n@@ -781,7 +707,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Qualifier<'a, 'tcx, 'tcx> {\n                                 // This allows borrowing fields which don't have\n                                 // `MUTABLE_INTERIOR`, from a type that does, e.g.:\n                                 // `let _: &'static _ = &(Cell::new(1), 2).1;`\n-                                if self.can_promote(qualif - Qualif::MUTABLE_INTERIOR) {\n+                                if (qualif - Qualif::MUTABLE_INTERIOR).is_empty() {\n                                     self.promotion_candidates.push(candidate);\n                                 }\n                             }\n@@ -889,7 +815,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                     if Some(def.did) == self.tcx.lang_items().unsafe_cell_type() {\n                         let ty = rvalue.ty(self.mir, self.tcx);\n                         self.add_type(ty);\n-                        assert!(self.qualif.intersects(Qualif::MUTABLE_INTERIOR));\n+                        assert!(self.qualif.contains(Qualif::MUTABLE_INTERIOR));\n                     }\n                 }\n             }\n@@ -949,7 +875,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                     }\n                     let candidate = Candidate::Argument { bb, index: i };\n                     if is_shuffle && i == 2 {\n-                        if this.can_promote(this.qualif) {\n+                        if this.qualif.is_empty() {\n                             this.promotion_candidates.push(candidate);\n                         } else {\n                             span_err!(this.tcx.sess, this.span, E0526,\n@@ -965,7 +891,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                     if !constant_arguments.contains(&i) {\n                         return\n                     }\n-                    if this.can_promote(this.qualif) {\n+                    if this.qualif.is_empty() {\n                         this.promotion_candidates.push(candidate);\n                     } else {\n                         this.tcx.sess.span_err(this.span,\n@@ -1059,7 +985,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                 // HACK(eddyb) Emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n                 let needs_drop = if let Place::Local(local) = *place {\n-                    if self.local_qualif[local].map_or(true, |q| q.intersects(Qualif::NEEDS_DROP)) {\n+                    if self.local_qualif[local].map_or(true, |q| q.contains(Qualif::NEEDS_DROP)) {\n                         Some(self.mir.local_decls[local].source_info.span)\n                     } else {\n                         None\n@@ -1111,7 +1037,7 @@ This does not pose a problem by itself because they can't be accessed directly.\"\n                 }\n \n                 // Avoid a generic error for other uses of arguments.\n-                if self.qualif.intersects(Qualif::FN_ARGUMENT) {\n+                if self.qualif.contains(Qualif::FN_ARGUMENT) {\n                     let decl = &self.mir.local_decls[index];\n                     let mut err = feature_err(\n                         &self.tcx.sess.parse_sess,"}, {"sha": "341cc7bb49116d8bfb3ef1f28968f8cd44616ce1", "filename": "src/test/compile-fail/const-fn-not-safe-for-const.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -29,7 +29,6 @@ static Y: u32 = 0;\n const fn get_Y() -> u32 {\n     Y\n         //~^ ERROR E0013\n-        //~| ERROR cannot refer to statics by value\n }\n \n const fn get_Y_addr() -> &'static u32 {\n@@ -49,5 +48,4 @@ const fn get() -> u32 {\n     //~| ERROR let bindings in constant functions are unstable\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "95f017061a2576efb65e4baf94083394bbc48e18", "filename": "src/test/compile-fail/issue-14227.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-14227.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -13,6 +13,10 @@\n extern {\n     pub static symbol: ();\n }\n-static CRASH: () = symbol; //~ cannot refer to other statics by value\n+static CRASH: () = symbol;\n+//~^ ERROR could not evaluate static initializer\n+//~| tried to read from foreign (extern) static\n+//~^^^ ERROR could not evaluate static initializer\n+//~| tried to read from foreign (extern) static\n \n fn main() {}"}, {"sha": "cc652119377165527c78412f12d18924f2840d9a", "filename": "src/test/compile-fail/issue-16538.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -22,7 +22,6 @@ mod Y {\n \n static foo: *const Y::X = Y::foo(Y::x as *const Y::X);\n //~^ ERROR `*const usize` cannot be shared between threads safely [E0277]\n-//~| ERROR cannot refer to other statics by value, use the address-of operator or a constant instead\n //~| ERROR E0015\n \n fn main() {}"}, {"sha": "586cfebcd161c06af2f3fba81f2dcab51c2dd9b2", "filename": "src/test/compile-fail/issue-17718-references.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-17718-references.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -22,14 +22,13 @@ static T4: &'static usize = &S;\n \n const T5: usize = C;\n const T6: usize = S; //~ ERROR: constants cannot refer to statics\n-//~^ cannot refer to statics\n static T7: usize = C;\n-static T8: usize = S; //~ ERROR: cannot refer to other statics by value\n+static T8: usize = S;\n \n const T9: Struct = Struct { a: C };\n-const T10: Struct = Struct { a: S }; //~ ERROR: cannot refer to statics by value\n+const T10: Struct = Struct { a: S };\n //~^ ERROR: constants cannot refer to statics\n static T11: Struct = Struct { a: C };\n-static T12: Struct = Struct { a: S }; //~ ERROR: cannot refer to other statics by value\n+static T12: Struct = Struct { a: S };\n \n fn main() {}"}, {"sha": "8512238dd31ca668d1dfa0dd1fd1bf248a2113ad", "filename": "src/test/compile-fail/issue-28324.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-28324.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -15,6 +15,9 @@ extern {\n }\n \n pub static BAZ: u32 = *&error_message_count;\n-//~^ ERROR cannot refer to other statics by value\n+//~^ ERROR could not evaluate static initializer\n+//~| tried to read from foreign (extern) static\n+//~^^^ ERROR could not evaluate static initializer\n+//~| tried to read from foreign (extern) static\n \n fn main() {}"}, {"sha": "62c1859e09d3a5b45d45e15a880c2b9c1b2e2a20", "filename": "src/test/compile-fail/recursive-static-definition.rs", "status": "renamed", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Frecursive-static-definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Frecursive-static-definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Frecursive-static-definition.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,12 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-struct Foo {\n-    a: u32\n-}\n+pub static FOO: u32 = FOO;\n+//~^ ERROR cycle detected when const-evaluating `FOO`\n \n-static S : Foo = Foo { a : 0 };\n-static A : &'static u32 = &S.a; //~ ERROR E0494\n-\n-fn main() {\n-}\n+fn main() {}", "previous_filename": "src/test/ui/error-codes/E0494.rs"}, {"sha": "62e26f28b066782b29447ee6e4d023cf2c38eb70", "filename": "src/test/compile-fail/thread-local-in-ctfe.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fthread-local-in-ctfe.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -15,22 +15,19 @@ static A: u32 = 1;\n \n static B: u32 = A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n-//~| ERROR cannot refer to other statics by value\n \n static C: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n \n const D: u32 = A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n-//~| ERROR cannot refer to statics by value\n \n const E: &u32 = &A;\n //~^ ERROR thread-local statics cannot be accessed at compile-time\n \n const fn f() -> u32 {\n     A\n     //~^ ERROR thread-local statics cannot be accessed at compile-time\n-    //~| ERROR cannot refer to statics by value\n }\n \n fn main() {}"}, {"sha": "1ea74f73723b762224327b69e57a6184e55b2c8e", "filename": "src/test/compile-fail/write-to-static-mut-in-static.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fwrite-to-static-mut-in-static.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fcompile-fail%2Fwrite-to-static-mut-in-static.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fwrite-to-static-mut-in-static.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(const_let)]\n+\n+pub static mut A: u32 = 0;\n+pub static mut B: () = unsafe { A = 1; };\n+//~^ ERROR statements in statics are unstable\n+\n+pub static mut C: u32 = unsafe { C = 1; 0 };\n+//~^ ERROR statements in statics are unstable\n+\n+pub static D: u32 = D;\n+\n+fn main() {}"}, {"sha": "f19ae9e0e8d11b29300eefdb646047598eab13bc", "filename": "src/test/incremental/static_refering_to_other_static3/issue.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fincremental%2Fstatic_refering_to_other_static3%2Fissue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Fincremental%2Fstatic_refering_to_other_static3%2Fissue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fstatic_refering_to_other_static3%2Fissue.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -0,0 +1,25 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// revisions:rpass1 rpass2\n+\n+#[cfg(rpass1)]\n+pub static A: u8 = 42;\n+#[cfg(rpass2)]\n+pub static A: u8 = 43;\n+\n+static B: &u8 = &C.1;\n+static C: (&&u8, u8) = (&B, A);\n+\n+fn main() {\n+    assert_eq!(*B, A);\n+    assert_eq!(**C.0, A);\n+    assert_eq!(C.1, A);\n+}"}, {"sha": "7248d0e543bdba2d138ebf308f15da3ef9c15c4e", "filename": "src/test/run-pass/auxiliary/pub_static_array.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fauxiliary%2Fpub_static_array.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fauxiliary%2Fpub_static_array.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauxiliary%2Fpub_static_array.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "previous_filename": "src/test/compile-fail/auxiliary/pub_static_array.rs"}, {"sha": "242d8c20cd75950bb527be637b511da4ae14b398", "filename": "src/test/run-pass/issue-17450.rs", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fissue-17450.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fissue-17450.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17450.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -11,9 +11,6 @@\n #![allow(dead_code, warnings)]\n \n static mut x: isize = 3;\n-static mut y: isize = unsafe {\n-    x\n-//~^ ERROR cannot refer to other statics by value, use the address-of operator or a constant instea\n-};\n+static mut y: isize = unsafe { x };\n \n fn main() {}", "previous_filename": "src/test/compile-fail/issue-17450.rs"}, {"sha": "cafc037525782e57f1f9239b2ab7a42cc4939df2", "filename": "src/test/run-pass/issue-17718-borrow-interior.rs", "status": "renamed", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fissue-17718-borrow-interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fissue-17718-borrow-interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-17718-borrow-interior.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -9,17 +9,19 @@\n // except according to those terms.\n \n struct S { a: usize }\n-static A: S  = S { a: 3 };\n+\n+static A: S = S { a: 3 };\n static B: &'static usize = &A.a;\n-//~^ ERROR: cannot refer to the interior of another static\n static C: &'static usize = &(A.a);\n-//~^ ERROR: cannot refer to the interior of another static\n \n static D: [usize; 1] = [1];\n static E: usize = D[0];\n-//~^ ERROR: cannot refer to the interior of another static\n-//~^^ ERROR: cannot refer to other statics by value\n static F: &'static usize = &D[0];\n-//~^ ERROR: cannot refer to the interior of another static\n \n-fn main() {}\n+fn main() {\n+    assert_eq!(*B, A.a);\n+    assert_eq!(*B, A.a);\n+\n+    assert_eq!(E, D[0]);\n+    assert_eq!(*F, D[0]);\n+}", "previous_filename": "src/test/compile-fail/issue-17718-borrow-interior.rs"}, {"sha": "e1aef8996196d1b30921d9a94842937a4bb4fe50", "filename": "src/test/run-pass/issue-34194.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fissue-34194.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fissue-34194.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-34194.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -16,6 +16,5 @@ struct A {\n \n static B: &'static A = &A { a: &() };\n static C: &'static A = &B;\n-//~^ ERROR cannot refer to other statics by value\n \n fn main() {}", "previous_filename": "src/test/compile-fail/issue-34194.rs"}, {"sha": "32a9a055d49b897bf2b12d9d63eb18bf8db0e4ba", "filename": "src/test/run-pass/issue-6991.rs", "status": "renamed", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fissue-6991.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fissue-6991.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-6991.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -10,6 +10,5 @@\n \n static x: &'static usize = &1;\n static y: usize = *x;\n-//~^ ERROR cannot refer to other statics by value,\n-//         use the address-of operator or a constant instead\n+\n fn main() {}", "previous_filename": "src/test/compile-fail/issue-6991.rs"}, {"sha": "94c98ff95aba22d04b920a373c96af30e2e9a603", "filename": "src/test/run-pass/refer-to-other-statics-by-value.rs", "status": "renamed", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Frefer-to-other-statics-by-value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Frefer-to-other-statics-by-value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frefer-to-other-statics-by-value.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,11 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-#![allow(warnings)]\n-\n-static A: u32 = 0;\n-static B: u32 = A;\n-//~^ ERROR E0394\n+static A: usize = 42;\n+static B: usize = A;\n \n fn main() {\n+    assert_eq!(B, 42);\n }", "previous_filename": "src/test/ui/error-codes/E0394.rs"}, {"sha": "732d94cee8ed3f553a73551c9364855aa35990d1", "filename": "src/test/run-pass/static-array-across-crate.rs", "status": "renamed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fstatic-array-across-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c697a56d01c650f65b4ca4a264db1ea3573d0565/src%2Ftest%2Frun-pass%2Fstatic-array-across-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstatic-array-across-crate.rs?ref=c697a56d01c650f65b4ca4a264db1ea3573d0565", "patch": "@@ -15,13 +15,7 @@ extern crate pub_static_array as array;\n use array::ARRAY;\n \n static X: &'static u8 = &ARRAY[0];\n-//~^ ERROR: cannot refer to the interior of another static, use a constant\n-\n static Y: &'static u8 = &(&ARRAY)[0];\n-//~^ ERROR: cannot refer to the interior of another static, use a constant\n-\n static Z: u8 = (&ARRAY)[0];\n-//~^ ERROR: cannot refer to the interior of another static, use a constant\n-//~^^ ERROR: cannot refer to other statics by value\n \n pub fn main() {}", "previous_filename": "src/test/compile-fail/static-array-across-crate.rs"}, {"sha": "6c89957de07e3e90b5fedd8e0587158b47ca9366", "filename": "src/test/ui/error-codes/E0394.stderr", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a7a60dc7f8e9a53feb70ee7aa05485345a045afb/src%2Ftest%2Fui%2Ferror-codes%2FE0394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7a60dc7f8e9a53feb70ee7aa05485345a045afb/src%2Ftest%2Fui%2Ferror-codes%2FE0394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0394.stderr?ref=a7a60dc7f8e9a53feb70ee7aa05485345a045afb", "patch": "@@ -1,11 +0,0 @@\n-error[E0394]: cannot refer to other statics by value, use the address-of operator or a constant instead\n-  --> $DIR/E0394.rs:14:17\n-   |\n-LL | static B: u32 = A;\n-   |                 ^ referring to another static by value\n-   |\n-   = note: use the address-of operator or a constant instead\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0394`."}, {"sha": "65e6b1fe670f11bc794d78ed2629d8bbcc4ad101", "filename": "src/test/ui/error-codes/E0494.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a7a60dc7f8e9a53feb70ee7aa05485345a045afb/src%2Ftest%2Fui%2Ferror-codes%2FE0494.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a7a60dc7f8e9a53feb70ee7aa05485345a045afb/src%2Ftest%2Fui%2Ferror-codes%2FE0494.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0494.stderr?ref=a7a60dc7f8e9a53feb70ee7aa05485345a045afb", "patch": "@@ -1,9 +0,0 @@\n-error[E0494]: cannot refer to the interior of another static, use a constant instead\n-  --> $DIR/E0494.rs:16:27\n-   |\n-LL | static A : &'static u32 = &S.a; //~ ERROR E0494\n-   |                           ^^^^\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0494`."}]}