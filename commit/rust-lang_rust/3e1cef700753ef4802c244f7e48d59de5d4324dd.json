{"sha": "3e1cef700753ef4802c244f7e48d59de5d4324dd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlMWNlZjcwMDc1M2VmNDgwMmMyNDRmN2U0OGQ1OWRlNWQ0MzI0ZGQ=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-19T03:01:06Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T11:25:10Z"}, "message": "rustc: pass Option<&Substs> and Namespace around in ty::item_path.", "tree": {"sha": "da8667def53ff876841db86a204823bb732bc134", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/da8667def53ff876841db86a204823bb732bc134"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3e1cef700753ef4802c244f7e48d59de5d4324dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3e1cef700753ef4802c244f7e48d59de5d4324dd", "html_url": "https://github.com/rust-lang/rust/commit/3e1cef700753ef4802c244f7e48d59de5d4324dd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3e1cef700753ef4802c244f7e48d59de5d4324dd/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed2be6fa89428b6c0a43e41a8906d29bc78f62d0", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed2be6fa89428b6c0a43e41a8906d29bc78f62d0", "html_url": "https://github.com/rust-lang/rust/commit/ed2be6fa89428b6c0a43e41a8906d29bc78f62d0"}], "stats": {"total": 253, "additions": 159, "deletions": 94}, "files": [{"sha": "d9a8deb80e46ac1a798937926e5121c571b3c547", "filename": "src/librustc/ty/item_path.rs", "status": "modified", "additions": 103, "deletions": 34, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Flibrustc%2Fty%2Fitem_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Flibrustc%2Fty%2Fitem_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fitem_path.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -1,8 +1,10 @@\n+use crate::hir::def::Namespace;\n use crate::hir::map::DefPathData;\n use crate::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use crate::ty::{self, DefIdTree, Ty, TyCtxt};\n+use crate::ty::print::PrintCx;\n+use crate::ty::subst::{Subst, Substs};\n use crate::middle::cstore::{ExternCrate, ExternCrateSource};\n-use ty::print::PrintCx;\n use syntax::ast;\n use syntax::symbol::{keywords, Symbol};\n \n@@ -54,18 +56,48 @@ pub fn with_crate_prefix<F: FnOnce() -> R, R>(f: F) -> R {\n }\n \n impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n+    // HACK(eddyb) get rid of `item_path_str` and/or pass `Namespace` explicitly always\n+    // (but also some things just print a `DefId` generally so maybe we need this?)\n+    fn guess_def_namespace(self, def_id: DefId) -> Namespace {\n+        match self.def_key(def_id).disambiguated_data.data {\n+            DefPathData::ValueNs(..) |\n+            DefPathData::EnumVariant(..) |\n+            DefPathData::Field(..) |\n+            DefPathData::AnonConst |\n+            DefPathData::ClosureExpr |\n+            DefPathData::StructCtor => Namespace::ValueNS,\n+\n+            DefPathData::MacroDef(..) => Namespace::MacroNS,\n+\n+            _ => Namespace::TypeNS,\n+        }\n+    }\n+\n     /// Returns a string identifying this `DefId`. This string is\n     /// suitable for user output. It is relative to the current crate\n     /// root, unless with_forced_absolute_paths was used.\n-    pub fn item_path_str(self, def_id: DefId) -> String {\n-        debug!(\"item_path_str: def_id={:?}\", def_id);\n+    pub fn item_path_str_with_substs_and_ns(\n+        self,\n+        def_id: DefId,\n+        substs: Option<&Substs<'tcx>>,\n+        ns: Namespace,\n+    ) -> String {\n+        debug!(\"item_path_str: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n         if FORCE_ABSOLUTE.with(|force| force.get()) {\n-            PrintCx::new(self, AbsolutePathPrinter).print_item_path(def_id)\n+            PrintCx::new(self, AbsolutePathPrinter).print_item_path(def_id, substs, ns)\n         } else {\n-            PrintCx::new(self, LocalPathPrinter).print_item_path(def_id)\n+            PrintCx::new(self, LocalPathPrinter).print_item_path(def_id, substs, ns)\n         }\n     }\n \n+    /// Returns a string identifying this def-id. This string is\n+    /// suitable for user output. It is relative to the current crate\n+    /// root, unless with_forced_absolute_paths was used.\n+    pub fn item_path_str(self, def_id: DefId) -> String {\n+        let ns = self.guess_def_namespace(def_id);\n+        self.item_path_str_with_substs_and_ns(def_id, None, ns)\n+    }\n+\n     /// Returns a string identifying this local node-id.\n     pub fn node_path_str(self, id: ast::NodeId) -> String {\n         self.item_path_str(self.hir().local_def_id(id))\n@@ -75,13 +107,19 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n     /// suitable for user output. It always begins with a crate identifier.\n     pub fn absolute_item_path_str(self, def_id: DefId) -> String {\n         debug!(\"absolute_item_path_str: def_id={:?}\", def_id);\n-        PrintCx::new(self, AbsolutePathPrinter).print_item_path(def_id)\n+        let ns = self.guess_def_namespace(def_id);\n+        PrintCx::new(self, AbsolutePathPrinter).print_item_path(def_id, None, ns)\n     }\n }\n \n impl<P: ItemPathPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n-    pub fn default_print_item_path(&mut self, def_id: DefId) -> P::Path {\n-        debug!(\"default_print_item_path: def_id={:?}\", def_id);\n+    pub fn default_print_item_path(\n+        &mut self,\n+        def_id: DefId,\n+        substs: Option<&Substs<'tcx>>,\n+        ns: Namespace,\n+    ) -> P::Path {\n+        debug!(\"default_print_item_path: def_id={:?}, substs={:?}, ns={:?}\", def_id, substs, ns);\n         let key = self.tcx.def_key(def_id);\n         debug!(\"default_print_item_path: key={:?}\", key);\n         match key.disambiguated_data.data {\n@@ -91,7 +129,7 @@ impl<P: ItemPathPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             }\n \n             DefPathData::Impl => {\n-                self.print_impl_path(def_id)\n+                self.print_impl_path(def_id, substs, ns)\n             }\n \n             // Unclear if there is any value in distinguishing these.\n@@ -117,18 +155,23 @@ impl<P: ItemPathPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             data @ DefPathData::ImplTrait |\n             data @ DefPathData::GlobalMetaData(..) => {\n                 let parent_did = self.tcx.parent_def_id(def_id).unwrap();\n-                let path = self.print_item_path(parent_did);\n+                let path = self.print_item_path(parent_did, None, ns);\n                 self.path_append(path, &data.as_interned_str().as_symbol().as_str())\n             },\n \n             DefPathData::StructCtor => { // present `X` instead of `X::{{constructor}}`\n                 let parent_def_id = self.tcx.parent_def_id(def_id).unwrap();\n-                self.print_item_path(parent_def_id)\n+                self.print_item_path(parent_def_id, substs, ns)\n             }\n         }\n     }\n \n-    fn default_print_impl_path(&mut self, impl_def_id: DefId) -> P::Path {\n+    fn default_print_impl_path(\n+        &mut self,\n+        impl_def_id: DefId,\n+        substs: Option<&Substs<'tcx>>,\n+        ns: Namespace,\n+    ) -> P::Path {\n         debug!(\"default_print_impl_path: impl_def_id={:?}\", impl_def_id);\n         let parent_def_id = self.tcx.parent_def_id(impl_def_id).unwrap();\n \n@@ -137,13 +180,19 @@ impl<P: ItemPathPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         // users may find it useful. Currently, we omit the parent if\n         // the impl is either in the same module as the self-type or\n         // as the trait.\n-        let self_ty = self.tcx.type_of(impl_def_id);\n+        let mut self_ty = self.tcx.type_of(impl_def_id);\n+        if let Some(substs) = substs {\n+            self_ty = self_ty.subst(self.tcx, substs);\n+        }\n         let in_self_mod = match characteristic_def_id_of_type(self_ty) {\n             None => false,\n             Some(ty_def_id) => self.tcx.parent_def_id(ty_def_id) == Some(parent_def_id),\n         };\n \n-        let impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id);\n+        let mut impl_trait_ref = self.tcx.impl_trait_ref(impl_def_id);\n+        if let Some(substs) = substs {\n+            impl_trait_ref = impl_trait_ref.subst(self.tcx, substs);\n+        }\n         let in_trait_mod = match impl_trait_ref {\n             None => false,\n             Some(trait_ref) => self.tcx.parent_def_id(trait_ref.def_id) == Some(parent_def_id),\n@@ -153,7 +202,7 @@ impl<P: ItemPathPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n             // If the impl is not co-located with either self-type or\n             // trait-type, then fallback to a format that identifies\n             // the module more clearly.\n-            let path = self.print_item_path(parent_def_id);\n+            let path = self.print_item_path(parent_def_id, None, ns);\n             if let Some(trait_ref) = impl_trait_ref {\n                 return self.path_append(path, &format!(\"<impl {} for {}>\", trait_ref, self_ty));\n             } else {\n@@ -174,15 +223,14 @@ impl<P: ItemPathPrinter> PrintCx<'a, 'gcx, 'tcx, P> {\n         // anything other than a simple path.\n         match self_ty.sty {\n             ty::Adt(adt_def, substs) => {\n-                // FIXME(eddyb) always print without <> here.\n-                if substs.types().next().is_none() { // ignore regions\n-                    self.print_item_path(adt_def.did)\n-                } else {\n-                    self.path_impl(&format!(\"<{}>\", self_ty))\n-                }\n+                // FIXME(eddyb) this should recurse to build the path piecewise.\n+                // self.print_item_path(adt_def.did, Some(substs), ns)\n+                let mut s = String::new();\n+                crate::util::ppaux::parameterized(&mut s, adt_def.did, substs, ns).unwrap();\n+                self.path_impl(&s)\n             }\n \n-            ty::Foreign(did) => self.print_item_path(did),\n+            ty::Foreign(did) => self.print_item_path(did, None, ns),\n \n             ty::Bool |\n             ty::Char |\n@@ -263,11 +311,21 @@ pub fn characteristic_def_id_of_type(ty: Ty<'_>) -> Option<DefId> {\n pub trait ItemPathPrinter: Sized {\n     type Path;\n \n-    fn print_item_path(self: &mut PrintCx<'_, '_, '_, Self>, def_id: DefId) -> Self::Path {\n-        self.default_print_item_path(def_id)\n+    fn print_item_path(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<&Substs<'tcx>>,\n+        ns: Namespace,\n+    ) -> Self::Path {\n+        self.default_print_item_path(def_id, substs, ns)\n     }\n-    fn print_impl_path(self: &mut PrintCx<'_, '_, '_, Self>, impl_def_id: DefId) -> Self::Path {\n-        self.default_print_impl_path(impl_def_id)\n+    fn print_impl_path(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        impl_def_id: DefId,\n+        substs: Option<&Substs<'tcx>>,\n+        ns: Namespace,\n+    ) -> Self::Path {\n+        self.default_print_impl_path(impl_def_id, substs, ns)\n     }\n \n     fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path;\n@@ -312,6 +370,7 @@ impl LocalPathPrinter {\n     fn try_print_visible_item_path(\n         self: &mut PrintCx<'_, '_, '_, Self>,\n         def_id: DefId,\n+        ns: Namespace,\n     ) -> Option<<Self as ItemPathPrinter>::Path> {\n         debug!(\"try_print_visible_item_path: def_id={:?}\", def_id);\n \n@@ -343,7 +402,7 @@ impl LocalPathPrinter {\n                 }) => {\n                     debug!(\"try_print_visible_item_path: def_id={:?}\", def_id);\n                     let path = if !span.is_dummy() {\n-                        self.print_item_path(def_id)\n+                        self.print_item_path(def_id, None, ns)\n                     } else {\n                         self.path_crate(cnum)\n                     };\n@@ -376,7 +435,7 @@ impl LocalPathPrinter {\n         }\n \n         let visible_parent = visible_parent_map.get(&def_id).cloned()?;\n-        let path = self.try_print_visible_item_path(visible_parent)?;\n+        let path = self.try_print_visible_item_path(visible_parent, ns)?;\n         let actual_parent = self.tcx.parent(def_id);\n \n         let data = cur_def_key.disambiguated_data.data;\n@@ -444,11 +503,21 @@ impl LocalPathPrinter {\n impl ItemPathPrinter for LocalPathPrinter {\n     type Path = String;\n \n-    fn print_item_path(self: &mut PrintCx<'_, '_, '_, Self>, def_id: DefId) -> Self::Path {\n-        self.try_print_visible_item_path(def_id)\n-            .unwrap_or_else(|| self.default_print_item_path(def_id))\n+    fn print_item_path(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        def_id: DefId,\n+        substs: Option<&Substs<'tcx>>,\n+        ns: Namespace,\n+    ) -> Self::Path {\n+        self.try_print_visible_item_path(def_id, ns)\n+            .unwrap_or_else(|| self.default_print_item_path(def_id, substs, ns))\n     }\n-    fn print_impl_path(self: &mut PrintCx<'_, '_, '_, Self>, impl_def_id: DefId) -> Self::Path {\n+    fn print_impl_path(\n+        self: &mut PrintCx<'_, '_, 'tcx, Self>,\n+        impl_def_id: DefId,\n+        substs: Option<&Substs<'tcx>>,\n+        ns: Namespace,\n+    ) -> Self::Path {\n         // Always use types for non-local impls, where types are always\n         // available, and filename/line-number is mostly uninteresting.\n         let use_types = !impl_def_id.is_local() || {\n@@ -463,12 +532,12 @@ impl ItemPathPrinter for LocalPathPrinter {\n             // only occur very early in the compiler pipeline.\n             // FIXME(eddyb) this should just be using `tcx.def_span(impl_def_id)`\n             let parent_def_id = self.tcx.parent_def_id(impl_def_id).unwrap();\n-            let path = self.print_item_path(parent_def_id);\n+            let path = self.print_item_path(parent_def_id, None, ns);\n             let span = self.tcx.def_span(impl_def_id);\n             return self.path_append(path, &format!(\"<impl at {:?}>\", span));\n         }\n \n-        self.default_print_impl_path(impl_def_id)\n+        self.default_print_impl_path(impl_def_id, substs, ns)\n     }\n \n     fn path_crate(self: &mut PrintCx<'_, '_, '_, Self>, cnum: CrateNum) -> Self::Path {"}, {"sha": "092255129f4eeb39e1af90044324fcdef0ac8070", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -317,23 +317,15 @@ impl<F: fmt::Write> PrintCx<'a, 'gcx, 'tcx, FmtPrinter<F>> {\n                 }\n             }\n         } else {\n-            // Try to print `impl`s more like how you'd refer to their associated items.\n+            // FIXME(eddyb) recurse through printing a path via `self`, instead\n+            // instead of using the `tcx` method that produces a `String`.\n+            print!(self, write(\"{}\",\n+                self.tcx.item_path_str_with_substs_and_ns(def_id, Some(substs), ns)))?;\n+\n+            // For impls, the above call already prints relevant generics args.\n             if let DefPathData::Impl = key.disambiguated_data.data {\n-                if let Some(trait_ref) = self.tcx.impl_trait_ref(def_id) {\n-                    // HACK(eddyb) this is in lieu of more specific disambiguation.\n-                    print!(self, write(\"{}\", self.tcx.item_path_str(def_id)))?;\n-\n-                    let trait_ref = trait_ref.subst(self.tcx, substs);\n-                    print!(self, print_debug(trait_ref))?;\n-                } else {\n-                    let self_ty = self.tcx.type_of(def_id).subst(self.tcx, substs);\n-                    // FIXME(eddyb) omit the <> where possible.\n-                    print!(self, write(\"<\"), print(self_ty), write(\">\"))?;\n-                }\n                 return Ok(());\n             }\n-\n-            print!(self, write(\"{}\", self.tcx.item_path_str(def_id)))?;\n         }\n \n         let mut empty = true;"}, {"sha": "a7771f3da18eedda2311b523f197373b39f644b4", "filename": "src/librustc_codegen_utils/symbol_names.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_utils%2Fsymbol_names.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -87,6 +87,7 @@\n //! virtually impossible. Thus, symbol hash generation exclusively relies on\n //! DefPaths which are much more robust in the face of changes to the code base.\n \n+use rustc::hir::def::Namespace;\n use rustc::hir::def_id::{CrateNum, DefId, LOCAL_CRATE};\n use rustc::hir::Node;\n use rustc::hir::CodegenFnAttrFlags;\n@@ -225,7 +226,9 @@ fn get_symbol_hash<'a, 'tcx>(\n \n fn def_symbol_name<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, def_id: DefId) -> ty::SymbolName {\n     item_path::with_forced_absolute_paths(|| {\n-        PrintCx::new(tcx, SymbolPathPrinter).print_item_path(def_id).into_interned()\n+        PrintCx::new(tcx, SymbolPathPrinter)\n+            .print_item_path(def_id, None, Namespace::ValueNS)\n+            .into_interned()\n     })\n }\n "}, {"sha": "6714866369efa2e4a81e161b83abd4bbde900bbc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -18,7 +18,7 @@ use rustc::middle::lang_items;\n use rustc::middle::stability;\n use rustc::mir::interpret::GlobalId;\n use rustc::hir::{self, GenericArg, HirVec};\n-use rustc::hir::def::{self, Def, CtorKind};\n+use rustc::hir::def::{self, Def, CtorKind, Namespace};\n use rustc::hir::def_id::{CrateNum, DefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n use rustc::ty::subst::{InternalSubsts, SubstsRef};\n use rustc::ty::{self, TyCtxt, Region, RegionVid, Ty, AdtKind};\n@@ -4249,7 +4249,8 @@ where F: Fn(DefId) -> Def {\n         }\n     }\n \n-    let names = PrintCx::new(tcx, AbsolutePathPrinter).print_item_path(def_id);\n+    let names = PrintCx::new(tcx, AbsolutePathPrinter)\n+        .print_item_path(def_id, None, Namespace::TypeNS);\n \n     hir::Path {\n         span: DUMMY_SP,"}, {"sha": "ad663412e77768505d34156a85313ed0afd900e4", "filename": "src/test/pretty/issue-4264.pp", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fpretty%2Fissue-4264.pp", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fpretty%2Fissue-4264.pp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fpretty%2Fissue-4264.pp?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -32,27 +32,27 @@\n                   (($crate::fmt::format as\n                        for<'r> fn(std::fmt::Arguments<'r>) -> std::string::String {std::fmt::format})(((<$crate::fmt::Arguments>::new_v1\n                                                                                                            as\n-                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments<'_>::new_v1})((&([(\"test\"\n+                                                                                                           fn(&[&str], &[std::fmt::ArgumentV1<'_>]) -> std::fmt::Arguments<'_> {std::fmt::Arguments::<'_>::new_v1})((&([(\"test\"\n+                                                                                                                                                                                                                            as\n+                                                                                                                                                                                                                            &'static str)]\n                                                                                                                                                                                                                           as\n-                                                                                                                                                                                                                          &'static str)]\n+                                                                                                                                                                                                                          [&str; 1])\n                                                                                                                                                                                                                         as\n-                                                                                                                                                                                                                        [&str; 1])\n-                                                                                                                                                                                                                      as\n-                                                                                                                                                                                                                      &[&str; 1]),\n-                                                                                                                                                                                                                  (&(match (()\n+                                                                                                                                                                                                                        &[&str; 1]),\n+                                                                                                                                                                                                                    (&(match (()\n+                                                                                                                                                                                                                                 as\n+                                                                                                                                                                                                                                 ())\n+                                                                                                                                                                                                                           {\n+                                                                                                                                                                                                                           ()\n+                                                                                                                                                                                                                           =>\n+                                                                                                                                                                                                                           ([]\n                                                                                                                                                                                                                                as\n-                                                                                                                                                                                                                               ())\n-                                                                                                                                                                                                                         {\n-                                                                                                                                                                                                                         ()\n-                                                                                                                                                                                                                         =>\n-                                                                                                                                                                                                                         ([]\n-                                                                                                                                                                                                                             as\n-                                                                                                                                                                                                                             [std::fmt::ArgumentV1<'_>; 0]),\n-                                                                                                                                                                                                                     }\n+                                                                                                                                                                                                                               [std::fmt::ArgumentV1<'_>; 0]),\n+                                                                                                                                                                                                                       }\n+                                                                                                                                                                                                                          as\n+                                                                                                                                                                                                                          [std::fmt::ArgumentV1<'_>; 0])\n                                                                                                                                                                                                                         as\n-                                                                                                                                                                                                                        [std::fmt::ArgumentV1<'_>; 0])\n-                                                                                                                                                                                                                      as\n-                                                                                                                                                                                                                      &[std::fmt::ArgumentV1<'_>; 0]))\n+                                                                                                                                                                                                                        &[std::fmt::ArgumentV1<'_>; 0]))\n                                                                                                           as\n                                                                                                           std::fmt::Arguments<'_>))\n                       as std::string::String);"}, {"sha": "51b84745552938e6df88bd7138204c1a930f9100", "filename": "src/test/ui/bad/bad-sized.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbad%2Fbad-sized.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -22,7 +22,7 @@ LL |     let x: Vec<Trait + Sized> = Vec::new();\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `dyn Trait`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = note: required by `<std::vec::Vec<T>>::new`\n+   = note: required by `std::vec::Vec::<T>::new`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "7ede44c65b83a0479aaf7a7c786a24eb6b5056bb", "filename": "src/test/ui/consts/miri_unleashed/feature-gate-unleash_the_miri_inside_of_you.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Ffeature-gate-unleash_the_miri_inside_of_you.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -4,7 +4,7 @@ error[E0493]: destructors cannot be evaluated at compile-time\n LL |     const F: u32 = (U::X, 42).1;\n    |                    ^^^^^^^^^^ constants cannot evaluate destructors\n \n-error: `<std::vec::Vec<T>>::new` is not yet stable as a const fn\n+error: `std::vec::Vec::<T>::new` is not yet stable as a const fn\n   --> $DIR/feature-gate-unleash_the_miri_inside_of_you.rs:18:25\n    |\n LL |     const X: Vec<u32> = Vec::new();"}, {"sha": "37794c6e0773c0773af66d9c5b211b6ddf2d065b", "filename": "src/test/ui/hygiene/impl_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -9,7 +9,7 @@ mod foo {\n     }\n \n     pub macro m() {\n-        let _: () = S.f(); //~ ERROR type `for<'r> fn(&'r foo::S) {<foo::S>::f}` is private\n+        let _: () = S.f(); //~ ERROR type `for<'r> fn(&'r foo::S) {foo::S::f}` is private\n     }\n }\n "}, {"sha": "418c2c73ba157e36521d53aea367883cfe2301fe", "filename": "src/test/ui/hygiene/impl_items.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fimpl_items.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -1,4 +1,4 @@\n-error: type `for<'r> fn(&'r foo::S) {<foo::S>::f}` is private\n+error: type `for<'r> fn(&'r foo::S) {foo::S::f}` is private\n   --> $DIR/impl_items.rs:12:23\n    |\n LL |         let _: () = S.f();"}, {"sha": "ce9af1524b0879e18c663cb82d68ef8f9b0d21a2", "filename": "src/test/ui/issues/issue-17651.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17651.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -6,7 +6,7 @@ LL |     (|| Box::new(*(&[0][..])))();\n    |\n    = help: the trait `std::marker::Sized` is not implemented for `[{integer}]`\n    = note: to learn more, visit <https://doc.rust-lang.org/book/ch19-04-advanced-types.html#dynamically-sized-types-and-the-sized-trait>\n-   = note: required by `<std::boxed::Box<T>>::new`\n+   = note: required by `std::boxed::Box::<T>::new`\n \n error: aborting due to previous error\n "}, {"sha": "fab24404eba7d43b79965706921f66eab17a59c6", "filename": "src/test/ui/issues/issue-22638.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22638.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -50,7 +50,7 @@ struct D (Box<A>);\n \n impl D {\n     pub fn matches<F: Fn()>(&self, f: &F) {\n-        //~^ ERROR reached the type-length limit while instantiating `<D>::matches::<[closure\n+        //~^ ERROR reached the type-length limit while instantiating `D::matches::<[closure\n         let &D(ref a) = self;\n         a.matches(f)\n     }"}, {"sha": "aff968f3618c1edb8da02f3fdcbf0214d4d66e4c", "filename": "src/test/ui/issues/issue-22638.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-22638.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -1,4 +1,4 @@\n-error: reached the type-length limit while instantiating `<D>::matches::$CLOSURE`\n+error: reached the type-length limit while instantiating `D::matches::$CLOSURE`\n   --> $DIR/issue-22638.rs:52:5\n    |\n LL | /     pub fn matches<F: Fn()>(&self, f: &F) {"}, {"sha": "def373cf2c0a896b4d3c6a7daaea9d1f43991576", "filename": "src/test/ui/issues/issue-24322.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-24322.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-24322.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-24322.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -5,7 +5,7 @@ LL |     let x: &fn(&B) -> u32 = &B::func;\n    |                             ^^^^^^^^ expected fn pointer, found fn item\n    |\n    = note: expected type `&for<'r> fn(&'r B) -> u32`\n-              found type `&for<'r> fn(&'r B) -> u32 {<B>::func}`\n+              found type `&for<'r> fn(&'r B) -> u32 {B::func}`\n \n error: aborting due to previous error\n "}, {"sha": "1cd3f84f7a2270ec54df1c7817df02dbfa64707d", "filename": "src/test/ui/issues/issue-29124.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-29124.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-29124.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29124.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -13,7 +13,7 @@ fn func() -> Ret {\n \n fn main() {\n     Obj::func.x();\n-    //~^ ERROR no method named `x` found for type `fn() -> Ret {<Obj>::func}` in the current scope\n+    //~^ ERROR no method named `x` found for type `fn() -> Ret {Obj::func}` in the current scope\n     func.x();\n     //~^ ERROR no method named `x` found for type `fn() -> Ret {func}` in the current scope\n }"}, {"sha": "3beb728978884e36f08a84cc81d9fa327502edb5", "filename": "src/test/ui/issues/issue-29124.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-29124.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-29124.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-29124.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -1,4 +1,4 @@\n-error[E0599]: no method named `x` found for type `fn() -> Ret {<Obj>::func}` in the current scope\n+error[E0599]: no method named `x` found for type `fn() -> Ret {Obj::func}` in the current scope\n   --> $DIR/issue-29124.rs:15:15\n    |\n LL |     Obj::func.x();"}, {"sha": "c5432190412297a55c372d3a50040289e750908e", "filename": "src/test/ui/issues/issue-37311-type-length-limit/issue-37311.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37311-type-length-limit%2Fissue-37311.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -1,4 +1,4 @@\n-error: reached the type-length limit while instantiating `<T as Foo><(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(), &()), &(&()...`\n+error: reached the type-length limit while instantiating `<(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(&(), &()), &(&(), &())), &...`\n   --> $DIR/issue-37311.rs:13:5\n    |\n LL | /     fn recurse(&self) {"}, {"sha": "700dbe36474978e8798d1474a61b15a7f883f0f1", "filename": "src/test/ui/issues/issue-39559-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -8,7 +8,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-39559-2.rs:14:24\n    |\n LL |     let array: [usize; Dim3::dim()]\n-   |                        ^^^^^^^^^^^ calling non-const function `<Dim3 as Dim><Dim3 as Dim>::dim`\n+   |                        ^^^^^^^^^^^ calling non-const function `<Dim3 as Dim>::dim`\n \n error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n   --> $DIR/issue-39559-2.rs:17:15\n@@ -20,7 +20,7 @@ error[E0080]: evaluation of constant value failed\n   --> $DIR/issue-39559-2.rs:17:15\n    |\n LL |         = [0; Dim3::dim()];\n-   |               ^^^^^^^^^^^ calling non-const function `<Dim3 as Dim><Dim3 as Dim>::dim`\n+   |               ^^^^^^^^^^^ calling non-const function `<Dim3 as Dim>::dim`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c3ae920238f18af71e1c946f5b5f1c13eda1f67d", "filename": "src/test/ui/privacy/associated-item-privacy-inherent.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-inherent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-inherent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-inherent.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -11,11 +11,11 @@ mod priv_nominal {\n \n     pub macro mac() {\n         let value = Pub::method;\n-        //~^ ERROR type `for<'r> fn(&'r priv_nominal::Pub) {<priv_nominal::Pub>::method}` is private\n+        //~^ ERROR type `for<'r> fn(&'r priv_nominal::Pub) {priv_nominal::Pub::method}` is private\n         value;\n-        //~^ ERROR type `for<'r> fn(&'r priv_nominal::Pub) {<priv_nominal::Pub>::method}` is private\n+        //~^ ERROR type `for<'r> fn(&'r priv_nominal::Pub) {priv_nominal::Pub::method}` is private\n         Pub.method();\n-        //~^ ERROR type `for<'r> fn(&'r priv_nominal::Pub) {<priv_nominal::Pub>::method}` is private\n+        //~^ ERROR type `for<'r> fn(&'r priv_nominal::Pub) {priv_nominal::Pub::method}` is private\n         Pub::CONST;\n         //~^ ERROR associated constant `CONST` is private\n         // let _: Pub::AssocTy;"}, {"sha": "6471a7914e1039583d65591ce3921eb0fa49b803", "filename": "src/test/ui/privacy/associated-item-privacy-inherent.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-inherent.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-inherent.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fassociated-item-privacy-inherent.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -1,4 +1,4 @@\n-error: type `for<'r> fn(&'r priv_nominal::Pub) {<priv_nominal::Pub>::method}` is private\n+error: type `for<'r> fn(&'r priv_nominal::Pub) {priv_nominal::Pub::method}` is private\n   --> $DIR/associated-item-privacy-inherent.rs:13:21\n    |\n LL |         let value = Pub::method;\n@@ -7,7 +7,7 @@ LL |         let value = Pub::method;\n LL |     priv_nominal::mac!();\n    |     --------------------- in this macro invocation\n \n-error: type `for<'r> fn(&'r priv_nominal::Pub) {<priv_nominal::Pub>::method}` is private\n+error: type `for<'r> fn(&'r priv_nominal::Pub) {priv_nominal::Pub::method}` is private\n   --> $DIR/associated-item-privacy-inherent.rs:15:9\n    |\n LL |         value;\n@@ -16,7 +16,7 @@ LL |         value;\n LL |     priv_nominal::mac!();\n    |     --------------------- in this macro invocation\n \n-error: type `for<'r> fn(&'r priv_nominal::Pub) {<priv_nominal::Pub>::method}` is private\n+error: type `for<'r> fn(&'r priv_nominal::Pub) {priv_nominal::Pub::method}` is private\n   --> $DIR/associated-item-privacy-inherent.rs:17:13\n    |\n LL |         Pub.method();"}, {"sha": "39f2e5d4af2aaeb7fad5185640a0dd1b907875e5", "filename": "src/test/ui/privacy/private-inferred-type-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -6,7 +6,7 @@\n // error-pattern:type `fn() {<u8 as ext::PrivTrait>::method}` is private\n // error-pattern:type `fn(u8) -> ext::PrivTupleStruct {ext::PrivTupleStruct}` is private\n // error-pattern:type `fn(u8) -> ext::PubTupleStruct {ext::PubTupleStruct}` is private\n-// error-pattern:type `for<'r> fn(&'r ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n+// error-pattern:type `for<'r> fn(&'r ext::Pub<u8>) {ext::Pub::<u8>::priv_method}` is private\n \n #![feature(decl_macro)]\n "}, {"sha": "61cd84762978c6e4ee2ff691db53b405c8ce7df4", "filename": "src/test/ui/privacy/private-inferred-type-3.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type-3.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -46,7 +46,7 @@ LL |     ext::m!();\n    |\n    = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n \n-error: type `for<'r> fn(&'r ext::Pub<u8>) {<ext::Pub<u8>>::priv_method}` is private\n+error: type `for<'r> fn(&'r ext::Pub<u8>) {ext::Pub::<u8>::priv_method}` is private\n   --> $DIR/private-inferred-type-3.rs:16:5\n    |\n LL |     ext::m!();"}, {"sha": "d9bb421b53f8c5ccf9d10b2a2741d0bd37492f00", "filename": "src/test/ui/privacy/private-inferred-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -47,7 +47,7 @@ mod m {\n         PubTupleStruct;\n         //~^ ERROR type `fn(u8) -> m::PubTupleStruct {m::PubTupleStruct}` is private\n         Pub(0u8).priv_method();\n-        //~^ ERROR type `for<'r> fn(&'r m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n+        //~^ ERROR type `for<'r> fn(&'r m::Pub<u8>) {m::Pub::<u8>::priv_method}` is private\n     }\n \n     trait Trait {}"}, {"sha": "4d40b6b7cab32962d78808f5c85dee662eb525eb", "filename": "src/test/ui/privacy/private-inferred-type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fprivacy%2Fprivate-inferred-type.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -151,7 +151,7 @@ LL |         PubTupleStruct;\n LL |     m::m!();\n    |     -------- in this macro invocation\n \n-error: type `for<'r> fn(&'r m::Pub<u8>) {<m::Pub<u8>>::priv_method}` is private\n+error: type `for<'r> fn(&'r m::Pub<u8>) {m::Pub::<u8>::priv_method}` is private\n   --> $DIR/private-inferred-type.rs:49:18\n    |\n LL |         Pub(0u8).priv_method();"}, {"sha": "926b098040f1498d427e5ec36f8de41368d5dcd7", "filename": "src/test/ui/qualified/qualified-path-params.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fqualified%2Fqualified-path-params.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -11,7 +11,7 @@ LL |         0 ..= <S as Tr>::A::f::<u8> => {}\n    |               ^^^^^^^^^^^^^^^^^^^^^ ranges require char or numeric types\n    |\n    = note: start type: {integer}\n-   = note: end type: fn() {<S>::f::<u8>}\n+   = note: end type: fn() {S::f::<u8>}\n \n error: aborting due to 2 previous errors\n "}, {"sha": "69cd49e39512ee57b0cbcd6b32f101da9b0ce33f", "filename": "src/test/ui/symbol-names/impl1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.rs?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -5,7 +5,7 @@ mod foo {\n     pub struct Foo { x: u32 }\n \n     impl Foo {\n-        #[rustc_symbol_name] //~ ERROR _ZN5impl13foo3Foo3bar\n+        #[rustc_symbol_name] //~ ERROR _ZN15impl1..foo..Foo3bar\n         #[rustc_item_path] //~ ERROR item-path(foo::Foo::bar)\n         fn bar() { }\n     }"}, {"sha": "4041eb6b0ba4a4026018cd8eed70daa90adf825c", "filename": "src/test/ui/symbol-names/impl1.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/3e1cef700753ef4802c244f7e48d59de5d4324dd/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsymbol-names%2Fimpl1.stderr?ref=3e1cef700753ef4802c244f7e48d59de5d4324dd", "patch": "@@ -1,4 +1,4 @@\n-error: symbol-name(_ZN5impl13foo3Foo3bar17hc487d6ec13fe9124E)\n+error: symbol-name(_ZN15impl1..foo..Foo3bar17hc487d6ec13fe9124E)\n   --> $DIR/impl1.rs:8:9\n    |\n LL |         #[rustc_symbol_name]"}]}