{"sha": "0da1aca498114a1caa608592dd63bebee615755e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBkYTFhY2E0OTgxMTRhMWNhYTYwODU5MmRkNjNiZWJlZTYxNTc1NWU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-28T21:40:35Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-02-29T17:06:26Z"}, "message": "Recognize last uses for copied closed-over variables\n\nAnd clean up and fix some bad things in last_use.rs.\n\nCloses #1894", "tree": {"sha": "4a687d605098dd7896648c06b09845da3e5eefab", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a687d605098dd7896648c06b09845da3e5eefab"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0da1aca498114a1caa608592dd63bebee615755e", "comment_count": 2, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0da1aca498114a1caa608592dd63bebee615755e", "html_url": "https://github.com/rust-lang/rust/commit/0da1aca498114a1caa608592dd63bebee615755e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0da1aca498114a1caa608592dd63bebee615755e/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cccb0fbf72389758d6a2880ebd613a53bbf59bf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/cccb0fbf72389758d6a2880ebd613a53bbf59bf1", "html_url": "https://github.com/rust-lang/rust/commit/cccb0fbf72389758d6a2880ebd613a53bbf59bf1"}], "stats": {"total": 289, "additions": 171, "deletions": 118}, "files": [{"sha": "0f641d477f1ed02fdb85bbb81571a559a2154400", "filename": "src/comp/metadata/astencode.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fastencode.rs?ref=0da1aca498114a1caa608592dd63bebee615755e", "patch": "@@ -13,13 +13,10 @@ import std::serialization::deserializer;\n import std::serialization::serializer_helpers;\n import std::serialization::deserializer_helpers;\n import middle::trans::common::maps;\n-import middle::ty;\n-import middle::typeck;\n+import middle::{ty, typeck, last_use, ast_map};\n import middle::typeck::method_origin;\n import middle::typeck::dict_res;\n import middle::typeck::dict_origin;\n-import middle::ast_map;\n-import driver::session;\n import driver::session::session;\n import middle::freevars::freevar_entry;\n import c = common;\n@@ -248,7 +245,7 @@ fn decode_id_range(par_doc: ebml::doc) -> id_range {\n     }\n }\n \n-fn reserve_id_range(sess: session::session,\n+fn reserve_id_range(sess: session,\n                     from_id_range: id_range) -> id_range {\n     // Handle the case of an empty range:\n     if empty(from_id_range) { ret from_id_range; }\n@@ -781,7 +778,7 @@ fn decode_side_tables(xcx: extended_decode_ctxt,\n         } else if tag == (c::tag_table_copy as uint) {\n             dcx.maps.copy_map.insert(id, ());\n         } else if tag == (c::tag_table_last_use as uint) {\n-            dcx.maps.last_uses.insert(id, ());\n+            dcx.maps.last_uses.insert(id, last_use::is_last_use);\n         } else {\n             let val_doc = entry_doc[c::tag_table_val];\n             let val_dsr = serialization::mk_ebml_deserializer(val_doc);"}, {"sha": "c4dadc02f44ff4a2a972de2e0c1c1f44817f676d", "filename": "src/comp/middle/last_use.rs", "status": "modified", "additions": 127, "deletions": 75, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Flast_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Flast_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Flast_use.rs?ref=0da1aca498114a1caa608592dd63bebee615755e", "patch": "@@ -24,15 +24,26 @@ import std::list;\n // (by `break` or conditionals), and for handling loops.\n \n // Marks expr_paths that are last uses.\n-type last_uses = std::map::hashmap<node_id, ()>;\n+enum is_last_use {\n+    is_last_use,\n+    has_last_use,\n+    closes_over([node_id]),\n+}\n+type last_uses = std::map::hashmap<node_id, is_last_use>;\n \n enum seen { unset, seen(node_id), }\n enum block_type { func, loop, }\n \n-type set = [{def: node_id, exprs: list<node_id>}];\n+enum use { var_use(node_id), close_over(node_id), }\n+type set = [{def: node_id, uses: list<use>}];\n type bl = @{type: block_type, mutable second: bool, mutable exits: [set]};\n \n-type ctx = {last_uses: std::map::hashmap<node_id, bool>,\n+enum use_id { path(node_id), close(node_id, node_id) }\n+fn hash_use_id(id: use_id) -> uint {\n+    (alt id { path(i) { i } close(i, j) { (i << 10) + j } }) as uint\n+}\n+\n+type ctx = {last_uses: std::map::hashmap<use_id, bool>,\n             def_map: resolve::def_map,\n             ref_map: alias::ref_map,\n             tcx: ty::ctxt,\n@@ -43,9 +54,10 @@ type ctx = {last_uses: std::map::hashmap<node_id, bool>,\n fn find_last_uses(c: @crate, def_map: resolve::def_map,\n                   ref_map: alias::ref_map, tcx: ty::ctxt) -> last_uses {\n     let v = visit::mk_vt(@{visit_expr: visit_expr,\n+                           visit_stmt: visit_stmt,\n                            visit_fn: visit_fn\n                            with *visit::default_visitor()});\n-    let cx = {last_uses: std::map::new_int_hash(),\n+    let cx = {last_uses: std::map::mk_hashmap(hash_use_id, {|a, b| a == b}),\n               def_map: def_map,\n               ref_map: ref_map,\n               tcx: tcx,\n@@ -54,22 +66,26 @@ fn find_last_uses(c: @crate, def_map: resolve::def_map,\n     visit::visit_crate(*c, cx, v);\n     let mini_table = std::map::new_int_hash();\n     cx.last_uses.items {|key, val|\n-        if val {\n-            mini_table.insert(key, ());\n-            let def_node = ast_util::def_id_of_def(def_map.get(key)).node;\n-            mini_table.insert(def_node, ());\n+        if !val { ret; }\n+        alt key {\n+          path(id) {\n+            mini_table.insert(id, is_last_use);\n+            let def_node = ast_util::def_id_of_def(def_map.get(id)).node;\n+            mini_table.insert(def_node, has_last_use);\n+          }\n+          close(fn_id, local_id) {\n+            mini_table.insert(local_id, has_last_use);\n+            let known = alt check mini_table.find(fn_id) {\n+              some(closes_over(ids)) { ids }\n+              none { [] }\n+            };\n+            mini_table.insert(fn_id, closes_over(known + [local_id]));\n+          }\n         }\n     }\n     ret mini_table;\n }\n \n-fn ex_is_blockish(cx: ctx, id: node_id) -> bool {\n-    alt ty::get(ty::node_id_to_type(cx.tcx, id)).struct {\n-      ty::ty_fn({proto: p, _}) if is_blockish(p) { true }\n-      _ { false }\n-    }\n-}\n-\n fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     alt ex.node {\n       expr_ret(oexpr) {\n@@ -107,15 +123,17 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         cx.current = join_branches([cur, cx.current]);\n       }\n       expr_path(_) {\n-        let my_def = ast_util::def_id_of_def(cx.def_map.get(ex.id)).node;\n-        alt cx.ref_map.find(my_def) {\n-          option::some(root_id) { clear_in_current(cx, root_id, false); }\n+        let my_def = cx.def_map.get(ex.id);\n+        let my_def_id = ast_util::def_id_of_def(my_def).node;\n+        alt cx.ref_map.find(my_def_id) {\n+          option::some(root_id) {\n+            clear_in_current(cx, root_id, false);\n+          }\n           _ {\n-            alt clear_if_path(cx, ex, v, false) {\n-              option::some(my_def) {\n-                cx.current += [{def: my_def, exprs: cons(ex.id, @nil)}];\n-              }\n-              _ {}\n+            option::may(def_is_owned_local(cx, my_def)) {|nid|\n+                clear_in_current(cx, nid, false);\n+                cx.current += [{def: nid,\n+                                uses: cons(var_use(ex.id), @nil)}];\n             }\n           }\n         }\n@@ -138,7 +156,7 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         // then they are ignored, otherwise they will show up\n         // as freevars in the body.\n         vec::iter(cap_clause.moves) {|ci|\n-            clear_def_if_path(cx, cx.def_map.get(ci.id), true);\n+            clear_def_if_local(cx, cx.def_map.get(ci.id), false);\n         }\n         visit::visit_expr(ex, cx, v);\n       }\n@@ -148,10 +166,8 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n         let arg_ts = ty::ty_fn_args(ty::expr_ty(cx.tcx, f));\n         for arg in args {\n             alt arg.node {\n-              expr_fn(p, _, _, _) if is_blockish(p) {\n-                fns += [arg];\n-              }\n-              expr_fn_block(_, _) if ex_is_blockish(cx, arg.id) {\n+              expr_fn(_, _, _, _) | expr_fn_block(_, _)\n+              if is_blockish(ty::ty_fn_proto(arg_ts[i].ty)) {\n                 fns += [arg];\n               }\n               _ {\n@@ -169,6 +185,26 @@ fn visit_expr(ex: @expr, cx: ctx, v: visit::vt<ctx>) {\n     }\n }\n \n+fn visit_stmt(s: @stmt, cx: ctx, v: visit::vt<ctx>) {\n+    alt s.node {\n+      stmt_decl(@{node: decl_local(ls), _}, _) {\n+        shadow_in_current(cx, {|id|\n+            for local in ls {\n+                let found = false;\n+                pat_util::pat_bindings(cx.tcx.def_map, local.node.pat,\n+                                       {|pid, _a, _b|\n+                    if pid == id { found = true; }\n+                });\n+                if found { ret true; }\n+            }\n+            false\n+        });\n+      }\n+      _ {}\n+    }\n+    visit::visit_stmt(s, cx, v);\n+}\n+\n fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n             sp: span, id: node_id,\n             cx: ctx, v: visit::vt<ctx>) {\n@@ -177,42 +213,48 @@ fn visit_fn(fk: visit::fn_kind, decl: fn_decl, body: blk,\n     alt proto {\n       proto_any | proto_block {\n         visit_block(func, cx, {||\n+            shadow_in_current(cx, {|id|\n+                for arg in decl.inputs { if arg.id == id { ret true; } }\n+                false\n+            });\n             visit::visit_fn(fk, decl, body, sp, id, cx, v);\n         });\n       }\n       proto_box | proto_uniq | proto_bare {\n         alt cx.tcx.freevars.find(id) {\n           some(vars) {\n             for v in *vars {\n-                clear_in_current(cx, ast_util::def_id_of_def(v.def).node,\n-                                 false);\n+                option::may(def_is_owned_local(cx, v.def)) {|nid|\n+                    clear_in_current(cx, nid, false);\n+                    cx.current += [{def: nid,\n+                                    uses: cons(close_over(id), @nil)}];\n+                }\n             }\n           }\n           _ {}\n         }\n-        let old = nil;\n-        cx.blocks <-> old;\n+        let old_cur = [], old_blocks = nil;\n+        cx.blocks <-> old_blocks;\n+        cx.current <-> old_cur;\n         visit::visit_fn(fk, decl, body, sp, id, cx, v);\n-        cx.blocks <-> old;\n+        cx.blocks <-> old_blocks;\n         leave_fn(cx);\n+        cx.current <-> old_cur;\n       }\n     }\n }\n \n fn visit_block(tp: block_type, cx: ctx, visit: fn()) {\n     let local = @{type: tp, mutable second: false, mutable exits: []};\n     cx.blocks = cons(local, @cx.blocks);\n-    let start_current = cx.current;\n     visit();\n     local.second = true;\n     local.exits = [];\n-    cx.current = start_current;\n     visit();\n     let cx_blocks = cx.blocks;\n     cx.blocks = tail(cx_blocks);\n-    let branches = if tp == func { local.exits + [cx.current] }\n-                   else { local.exits };\n-    cx.current = join_branches(branches);\n+    local.exits += [cx.current];\n+    cx.current = join_branches(local.exits);\n }\n \n fn add_block_exit(cx: ctx, tp: block_type) -> bool {\n@@ -240,82 +282,92 @@ fn join_branches(branches: [set]) -> set {\n     let found: set = [], i = 0u, l = vec::len(branches);\n     for set in branches {\n         i += 1u;\n-        for {def, exprs} in set {\n+        for {def, uses} in set {\n             if !vec::any(found, {|v| v.def == def}) {\n-                let j = i, nne = exprs;\n+                let j = i, nne = uses;\n                 while j < l {\n-                    for {def: d2, exprs} in branches[j] {\n+                    for {def: d2, uses} in branches[j] {\n                         if d2 == def {\n-                            list::iter(exprs) {|e|\n+                            list::iter(uses) {|e|\n                                 if !list::has(nne, e) { nne = cons(e, @nne); }\n                             }\n                         }\n                     }\n                     j += 1u;\n                 }\n-                found += [{def: def, exprs: nne}];\n+                found += [{def: def, uses: nne}];\n             }\n         }\n     }\n     ret found;\n }\n \n fn leave_fn(cx: ctx) {\n-    for {def, exprs} in cx.current {\n-        list::iter(exprs) {|ex_id|\n-            if !cx.last_uses.contains_key(ex_id) {\n-                cx.last_uses.insert(ex_id, true);\n+    for {def, uses} in cx.current {\n+        list::iter(uses) {|use|\n+            let key = alt use {\n+              var_use(pth_id) { path(pth_id) }\n+              close_over(fn_id) { close(fn_id, def) }\n+            };\n+            if !cx.last_uses.contains_key(key) {\n+                cx.last_uses.insert(key, true);\n             }\n         }\n     }\n }\n \n+fn shadow_in_current(cx: ctx, p: fn(node_id) -> bool) {\n+    let out = [];\n+    cx.current <-> out;\n+    for e in out { if !p(e.def) { cx.current += [e]; } }\n+}\n+\n fn clear_in_current(cx: ctx, my_def: node_id, to: bool) {\n-    for {def, exprs} in cx.current {\n+    for {def, uses} in cx.current {\n         if def == my_def {\n-            list::iter(exprs) {|expr|\n-                if !to || !cx.last_uses.contains_key(expr) {\n-                     cx.last_uses.insert(expr, to);\n+            list::iter(uses) {|use|\n+                let key = alt use {\n+                  var_use(pth_id) { path(pth_id) }\n+                  close_over(fn_id) { close(fn_id, def) }\n+                };\n+                if !to || !cx.last_uses.contains_key(key) {\n+                    cx.last_uses.insert(key, to);\n                 }\n             }\n-            cx.current = vec::filter(copy cx.current,\n-                                     {|x| x.def != my_def});\n+            cx.current = vec::filter(copy cx.current, {|x| x.def != my_def});\n             break;\n         }\n     }\n }\n \n-fn clear_def_if_path(cx: ctx, d: def, to: bool)\n-    -> option<node_id> {\n+fn def_is_owned_local(cx: ctx, d: def) -> option<node_id> {\n     alt d {\n-      def_local(nid) {\n-        clear_in_current(cx, nid, to);\n-        some(nid)\n-      }\n-      def_arg(nid, m) {\n+      def_local(id) { some(id) }\n+      def_arg(id, m) {\n         alt ty::resolved_mode(cx.tcx, m) {\n-          by_copy | by_move {\n-            clear_in_current(cx, nid, to);\n-            some(nid)\n-          }\n-          by_ref | by_val | by_mutbl_ref {\n-            none\n-          }\n+          by_copy | by_move { some(id) }\n+          by_ref | by_val | by_mutbl_ref { none }\n         }\n       }\n-      _ {\n-        none\n+      def_upvar(_, d, fn_id) {\n+        if is_blockish(ty::ty_fn_proto(ty::node_id_to_type(cx.tcx, fn_id))) {\n+            def_is_owned_local(cx, *d)\n+        } else { none }\n       }\n+      _ { none }\n     }\n }\n \n-fn clear_if_path(cx: ctx, ex: @expr, v: visit::vt<ctx>, to: bool)\n-    -> option<node_id> {\n+fn clear_def_if_local(cx: ctx, d: def, to: bool) {\n+    alt def_is_owned_local(cx, d) {\n+      some(nid) { clear_in_current(cx, nid, to); }\n+      _ {}\n+    }\n+}\n+\n+fn clear_if_path(cx: ctx, ex: @expr, v: visit::vt<ctx>, to: bool) {\n     alt ex.node {\n-      expr_path(_) {\n-        ret clear_def_if_path(cx, cx.def_map.get(ex.id), to);\n-      }\n+      expr_path(_) { clear_def_if_local(cx, cx.def_map.get(ex.id), to); }\n       _ { v.visit_expr(ex, cx, v); }\n     }\n-    ret option::none;\n }"}, {"sha": "a1642202501364d44a24267e29a589250a0be290", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=0da1aca498114a1caa608592dd63bebee615755e", "patch": "@@ -1,4 +1,3 @@\n-\n import syntax::{ast, ast_util, codemap};\n import syntax::ast::*;\n import ast::{ident, fn_ident, def, def_id, node_id};\n@@ -512,7 +511,6 @@ fn resolve_names(e: @env, c: @ast::crate) {\n \n // Visit helper functions\n fn visit_item_with_scope(e: @env, i: @ast::item, sc: scopes, v: vt<scopes>) {\n-\n     // Some magic here. Items with the !resolve_unexported attribute\n     // cause us to consider every name to be exported when resolving their\n     // contents. This is used to allow the test runner to run unexported\n@@ -978,6 +976,7 @@ fn def_is_ty_arg(d: def) -> bool {\n \n fn lookup_in_scope(e: env, sc: scopes, sp: span, name: ident, ns: namespace)\n    -> option<def> {\n+\n     fn in_scope(e: env, sp: span, name: ident, s: scope, ns: namespace) ->\n        option<def> {\n         alt s {"}, {"sha": "9d05ec5e10b3914e1b8c941a76302ba4c4cf8de4", "filename": "src/comp/middle/trans/base.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fbase.rs?ref=0da1aca498114a1caa608592dd63bebee615755e", "patch": "@@ -20,7 +20,6 @@ import std::map::{new_int_hash, new_str_hash};\n import driver::session;\n import session::session;\n import front::attr;\n-import middle::freevars::*;\n import middle::inline::inline_map;\n import back::{link, abi, upcall};\n import syntax::{ast, ast_util, codemap};"}, {"sha": "4cd9eef01e36aa18406a7bc3b003f894ae28f45f", "filename": "src/comp/middle/trans/closure.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans%2Fclosure.rs?ref=0da1aca498114a1caa608592dd63bebee615755e", "patch": "@@ -8,7 +8,6 @@ import build::*;\n import base::*;\n import type_of::*;\n import type_of::type_of; // Issue #1873\n-import middle::freevars::{get_freevars, freevar_info};\n import back::abi;\n import syntax::codemap::span;\n import syntax::print::pprust::expr_to_str;\n@@ -353,12 +352,11 @@ fn store_environment(\n // collects the upvars and packages them up for store_environment.\n fn build_closure(bcx0: block,\n                  cap_vars: [capture::capture_var],\n-                 ck: ty::closure_kind)\n-    -> closure_result {\n+                 ck: ty::closure_kind,\n+                 id: ast::node_id) -> closure_result {\n     // If we need to, package up the iterator body to call\n     let env_vals = [];\n-    let bcx = bcx0;\n-    let tcx = bcx.tcx();\n+    let bcx = bcx0, ccx = bcx.ccx(), tcx = ccx.tcx;\n \n     // Package up the captured upvars\n     vec::iter(cap_vars) { |cap_var|\n@@ -373,7 +371,12 @@ fn build_closure(bcx0: block,\n             env_vals += [env_ref(lv.val, ty, lv.kind)];\n           }\n           capture::cap_copy {\n-            env_vals += [env_copy(lv.val, ty, lv.kind)];\n+            let mv = alt check ccx.maps.last_uses.find(id) {\n+              none { false }\n+              some(last_use::closes_over(vars)) { vec::contains(vars, nid) }\n+            };\n+            if mv { env_vals += [env_move(lv.val, ty, lv.kind)]; }\n+            else { env_vals += [env_copy(lv.val, ty, lv.kind)]; }\n           }\n           capture::cap_move {\n             env_vals += [env_move(lv.val, ty, lv.kind)];\n@@ -465,7 +468,7 @@ fn trans_expr_fn(bcx: block,\n     let trans_closure_env = fn@(ck: ty::closure_kind) -> ValueRef {\n         let cap_vars = capture::compute_capture_vars(\n             ccx.tcx, id, proto, cap_clause);\n-        let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck);\n+        let {llbox, cdata_ty, bcx} = build_closure(bcx, cap_vars, ck, id);\n         trans_closure(ccx, sub_path, decl, body, llfn, no_self, [],\n                       bcx.fcx.param_substs, id, {|fcx|\n             load_environment(bcx, fcx, cdata_ty, cap_vars, ck);"}, {"sha": "ee16bf3aadf3a68b58ea87aa02761e6b92596939", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da1aca498114a1caa608592dd63bebee615755e/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=0da1aca498114a1caa608592dd63bebee615755e", "patch": "@@ -1303,33 +1303,33 @@ fn gather_locals(ccx: @crate_ctxt,\n                  body: ast::blk,\n                  id: ast::node_id,\n                  old_fcx: option<@fn_ctxt>) -> gather_result {\n-    let {vb: vb, locals: locals, nvi: nvi} =\n-        alt old_fcx {\n-          none {\n-            {vb: ty::unify::mk_var_bindings(),\n-             locals: new_int_hash::<int>(),\n-             nvi: @mutable 0}\n-          }\n-          some(fcx) {\n-            {vb: fcx.var_bindings,\n-             locals: fcx.locals,\n-             nvi: fcx.next_var_id}\n-          }\n-        };\n+    let {vb: vb, locals: locals, nvi: nvi} = alt old_fcx {\n+      none {\n+        {vb: ty::unify::mk_var_bindings(),\n+         locals: new_int_hash::<int>(),\n+         nvi: @mutable 0}\n+      }\n+      some(fcx) {\n+        {vb: fcx.var_bindings,\n+         locals: fcx.locals,\n+         nvi: fcx.next_var_id}\n+      }\n+    };\n     let tcx = ccx.tcx;\n \n     let next_var_id = fn@() -> int { let rv = *nvi; *nvi += 1; ret rv; };\n+\n     let assign = fn@(nid: ast::node_id, ty_opt: option<ty::t>) {\n-            let var_id = next_var_id();\n-            locals.insert(nid, var_id);\n-            alt ty_opt {\n-              none {/* nothing to do */ }\n-              some(typ) {\n-                ty::unify::unify(ty::mk_var(tcx, var_id), typ,\n-                                 ty::unify::in_bindings(vb), tcx);\n-              }\n-            }\n-        };\n+        let var_id = next_var_id();\n+        locals.insert(nid, var_id);\n+        alt ty_opt {\n+          none {/* nothing to do */ }\n+          some(typ) {\n+            ty::unify::unify(ty::mk_var(tcx, var_id), typ,\n+                             ty::unify::in_bindings(vb), tcx);\n+          }\n+        }\n+    };\n \n     // Add formal parameters.\n     let args = ty::ty_fn_args(ty::node_id_to_type(ccx.tcx, id));\n@@ -1341,10 +1341,10 @@ fn gather_locals(ccx: @crate_ctxt,\n \n     // Add explicitly-declared locals.\n     let visit_local = fn@(local: @ast::local, &&e: (), v: visit::vt<()>) {\n-            let local_ty = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n-            assign(local.node.id, local_ty);\n-            visit::visit_local(local, e, v);\n-        };\n+        let local_ty = ast_ty_to_ty_crate_infer(ccx, local.node.ty);\n+        assign(local.node.id, local_ty);\n+        visit::visit_local(local, e, v);\n+    };\n \n     // Add pattern bindings.\n     let visit_pat = fn@(p: @ast::pat, &&e: (), v: visit::vt<()>) {"}, {"sha": "5052c7a60571293b88fef9f7d90d597193d1fd80", "filename": "src/test/run-pass/block-arg.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0da1aca498114a1caa608592dd63bebee615755e/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da1aca498114a1caa608592dd63bebee615755e/src%2Ftest%2Frun-pass%2Fblock-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fblock-arg.rs?ref=0da1aca498114a1caa608592dd63bebee615755e", "patch": "@@ -1,4 +1,5 @@\n // Check usage and precedence of block arguments in expressions:\n+// xfail-test\n fn main() {\n     let v = [-1f, 0f, 1f, 2f, 3f];\n "}, {"sha": "1758faaac50bedb4b2e7279f1a6ac854bd9f72b2", "filename": "src/test/run-pass/task-spawn-move-and-copy.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0da1aca498114a1caa608592dd63bebee615755e/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0da1aca498114a1caa608592dd63bebee615755e/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-spawn-move-and-copy.rs?ref=0da1aca498114a1caa608592dd63bebee615755e", "patch": "@@ -15,6 +15,8 @@ fn main() {\n         let y_in_child = ptr::addr_of(*y) as uint;\n         comm::send(ch, y_in_child);\n     });\n+    // Ensure last-use analysis doesn't move y to child.\n+    let _q = y;\n \n     let x_in_child = comm::recv(p);\n     assert x_in_parent == x_in_child;"}]}