{"sha": "53493361925a1eba9226ba3f33bb1871962be169", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNDkzMzYxOTI1YTFlYmE5MjI2YmEzZjMzYmIxODcxOTYyYmUxNjk=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-01-11T01:34:42Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-01-11T05:14:41Z"}, "message": "Refactor if/else formatting\n\nRemoves else_if_brace_style from config options. Use control_brace_style instead.", "tree": {"sha": "c2dfd5574eab8f16eb5b335a0542e6462f06b6da", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2dfd5574eab8f16eb5b335a0542e6462f06b6da"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53493361925a1eba9226ba3f33bb1871962be169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53493361925a1eba9226ba3f33bb1871962be169", "html_url": "https://github.com/rust-lang/rust/commit/53493361925a1eba9226ba3f33bb1871962be169", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53493361925a1eba9226ba3f33bb1871962be169/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9be29712748cf8d723d190f9e99442cebbe1fd94", "url": "https://api.github.com/repos/rust-lang/rust/commits/9be29712748cf8d723d190f9e99442cebbe1fd94", "html_url": "https://github.com/rust-lang/rust/commit/9be29712748cf8d723d190f9e99442cebbe1fd94"}], "stats": {"total": 550, "additions": 288, "deletions": 262}, "files": [{"sha": "0095e714f69c888c6869bc9258e995026561395b", "filename": "src/config.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -40,13 +40,6 @@ configuration_option_enum! { BraceStyle:\n }\n \n configuration_option_enum! { ControlBraceStyle:\n-    // K&R/Stroustrup style, Rust community default\n-    AlwaysSameLine,\n-    // Allman style\n-    AlwaysNextLine,\n-}\n-\n-configuration_option_enum! { ElseIfBraceStyle:\n     // K&R style, Rust community default\n     AlwaysSameLine,\n     // Stroustrup style\n@@ -350,10 +343,8 @@ create_config! {\n     newline_style: NewlineStyle, NewlineStyle::Unix, \"Unix or Windows line endings\";\n     fn_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for functions\";\n     item_brace_style: BraceStyle, BraceStyle::SameLineWhere, \"Brace style for structs and enums\";\n-    else_if_brace_style: ElseIfBraceStyle, ElseIfBraceStyle::AlwaysSameLine,\n-        \"Brace style for if, else if, and else constructs\";\n     control_brace_style: ControlBraceStyle, ControlBraceStyle::AlwaysSameLine,\n-        \"Brace style for match, loop, for, and while constructs\";\n+        \"Brace style for control flow constructs\";\n     impl_empty_single_line: bool, true, \"Put empty-body implementations on a single line\";\n     fn_empty_single_line: bool, true, \"Put empty-body functions on a single line\";\n     fn_single_line: bool, false, \"Put single-expression functions on a single line\";"}, {"sha": "b0b2315f1fee9ef4fae9f4ea96da6efb9fa571c2", "filename": "src/expr.rs", "status": "modified", "additions": 274, "deletions": 242, "changes": 516, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -24,7 +24,7 @@ use string::{StringFormat, rewrite_string};\n use utils::{extra_offset, last_line_width, wrap_str, binary_search, first_line_width,\n             semicolon_for_stmt, trimmed_last_line_width, left_most_sub_expr, stmt_expr};\n use visitor::FmtVisitor;\n-use config::{Config, StructLitStyle, MultilineStyle, ElseIfBraceStyle, ControlBraceStyle};\n+use config::{Config, StructLitStyle, MultilineStyle, ControlBraceStyle};\n use comment::{FindUncommented, rewrite_comment, contains_comment, recover_comment_removed};\n use types::rewrite_path;\n use items::{span_lo_for_arg, span_hi_for_arg};\n@@ -110,41 +110,39 @@ fn format_expr(expr: &ast::Expr,\n                           offset)\n         }\n         ast::ExprKind::While(ref cond, ref block, label) => {\n-            Loop::new_while(None, cond, block, label).rewrite(context, width, offset)\n+            ControlFlow::new_while(None, cond, block, label, expr.span)\n+                .rewrite(context, width, offset)\n         }\n         ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n-            Loop::new_while(Some(pat), cond, block, label).rewrite(context, width, offset)\n+            ControlFlow::new_while(Some(pat), cond, block, label, expr.span)\n+                .rewrite(context, width, offset)\n         }\n         ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n-            Loop::new_for(pat, cond, block, label).rewrite(context, width, offset)\n+            ControlFlow::new_for(pat, cond, block, label, expr.span).rewrite(context, width, offset)\n         }\n         ast::ExprKind::Loop(ref block, label) => {\n-            Loop::new_loop(block, label).rewrite(context, width, offset)\n+            ControlFlow::new_loop(block, label, expr.span).rewrite(context, width, offset)\n         }\n         ast::ExprKind::Block(ref block) => block.rewrite(context, width, offset),\n         ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n-            rewrite_if_else(context,\n-                            cond,\n-                            expr_type,\n-                            if_block,\n-                            else_block.as_ref().map(|e| &**e),\n-                            expr.span,\n-                            None,\n-                            width,\n-                            offset,\n-                            true)\n+            ControlFlow::new_if(cond,\n+                                None,\n+                                if_block,\n+                                else_block.as_ref().map(|e| &**e),\n+                                expr_type == ExprType::SubExpression,\n+                                false,\n+                                expr.span)\n+                .rewrite(context, width, offset)\n         }\n         ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref else_block) => {\n-            rewrite_if_else(context,\n-                            cond,\n-                            expr_type,\n-                            if_block,\n-                            else_block.as_ref().map(|e| &**e),\n-                            expr.span,\n-                            Some(pat),\n-                            width,\n-                            offset,\n-                            true)\n+            ControlFlow::new_if(cond,\n+                                Some(pat),\n+                                if_block,\n+                                else_block.as_ref().map(|e| &**e),\n+                                expr_type == ExprType::SubExpression,\n+                                false,\n+                                expr.span)\n+                .rewrite(context, width, offset)\n         }\n         ast::ExprKind::Match(ref cond, ref arms) => {\n             rewrite_match(context, cond, arms, width, offset, expr.span)\n@@ -679,72 +677,175 @@ impl Rewrite for ast::Stmt {\n     }\n }\n \n-// Abstraction over for, while and loop expressions\n-struct Loop<'a> {\n+// Abstraction over control flow expressions\n+struct ControlFlow<'a> {\n     cond: Option<&'a ast::Expr>,\n     block: &'a ast::Block,\n+    else_block: Option<&'a ast::Expr>,\n     label: Option<ast::SpannedIdent>,\n     pat: Option<&'a ast::Pat>,\n     keyword: &'a str,\n     matcher: &'a str,\n     connector: &'a str,\n+    allow_single_line: bool,\n+    // True if this is an `if` expression in an `else if` :-( hacky\n+    nested_if: bool,\n+    span: Span,\n }\n \n-impl<'a> Loop<'a> {\n-    fn new_loop(block: &'a ast::Block, label: Option<ast::SpannedIdent>) -> Loop<'a> {\n-        Loop {\n+impl<'a> ControlFlow<'a> {\n+    fn new_if(cond: &'a ast::Expr,\n+              pat: Option<&'a ast::Pat>,\n+              block: &'a ast::Block,\n+              else_block: Option<&'a ast::Expr>,\n+              allow_single_line: bool,\n+              nested_if: bool,\n+              span: Span)\n+              -> ControlFlow<'a> {\n+        ControlFlow {\n+            cond: Some(cond),\n+            block: block,\n+            else_block: else_block,\n+            label: None,\n+            pat: pat,\n+            keyword: \"if\",\n+            matcher: match pat {\n+                Some(..) => \"let\",\n+                None => \"\",\n+            },\n+            connector: \" =\",\n+            allow_single_line: allow_single_line,\n+            nested_if: nested_if,\n+            span: span,\n+        }\n+    }\n+\n+    fn new_loop(block: &'a ast::Block,\n+                label: Option<ast::SpannedIdent>,\n+                span: Span)\n+                -> ControlFlow<'a> {\n+        ControlFlow {\n             cond: None,\n             block: block,\n+            else_block: None,\n             label: label,\n             pat: None,\n             keyword: \"loop\",\n             matcher: \"\",\n             connector: \"\",\n+            allow_single_line: false,\n+            nested_if: false,\n+            span: span,\n         }\n     }\n \n     fn new_while(pat: Option<&'a ast::Pat>,\n                  cond: &'a ast::Expr,\n                  block: &'a ast::Block,\n-                 label: Option<ast::SpannedIdent>)\n-                 -> Loop<'a> {\n-        Loop {\n+                 label: Option<ast::SpannedIdent>,\n+                 span: Span)\n+                 -> ControlFlow<'a> {\n+        ControlFlow {\n             cond: Some(cond),\n             block: block,\n+            else_block: None,\n             label: label,\n             pat: pat,\n-            keyword: \"while \",\n+            keyword: \"while\",\n             matcher: match pat {\n-                Some(..) => \"let \",\n+                Some(..) => \"let\",\n                 None => \"\",\n             },\n             connector: \" =\",\n+            allow_single_line: false,\n+            nested_if: false,\n+            span: span,\n         }\n     }\n \n     fn new_for(pat: &'a ast::Pat,\n                cond: &'a ast::Expr,\n                block: &'a ast::Block,\n-               label: Option<ast::SpannedIdent>)\n-               -> Loop<'a> {\n-        Loop {\n+               label: Option<ast::SpannedIdent>,\n+               span: Span)\n+               -> ControlFlow<'a> {\n+        ControlFlow {\n             cond: Some(cond),\n             block: block,\n+            else_block: None,\n             label: label,\n             pat: Some(pat),\n-            keyword: \"for \",\n+            keyword: \"for\",\n             matcher: \"\",\n             connector: \" in\",\n+            allow_single_line: false,\n+            nested_if: false,\n+            span: span,\n+        }\n+    }\n+\n+    fn rewrite_single_line(&self,\n+                           pat_expr_str: &str,\n+                           context: &RewriteContext,\n+                           width: usize)\n+                           -> Option<String> {\n+        assert!(self.allow_single_line);\n+        let else_block = try_opt!(self.else_block);\n+        let fixed_cost = self.keyword.len() + \"  {  } else {  }\".len();\n+\n+        if let ast::ExprKind::Block(ref else_node) = else_block.node {\n+            if !is_simple_block(self.block, context.codemap) ||\n+               !is_simple_block(else_node, context.codemap) ||\n+               pat_expr_str.contains('\\n') {\n+                return None;\n+            }\n+\n+            let new_width = try_opt!(width.checked_sub(pat_expr_str.len() + fixed_cost));\n+            let expr = &self.block.stmts[0];\n+            let if_str = try_opt!(expr.rewrite(context, new_width, Indent::empty()));\n+\n+            let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n+            let else_expr = &else_node.stmts[0];\n+            let else_str = try_opt!(else_expr.rewrite(context, new_width, Indent::empty()));\n+\n+            if if_str.contains('\\n') || else_str.contains('\\n') {\n+                return None;\n+            }\n+\n+            let result = format!(\"{} {} {{ {} }} else {{ {} }}\",\n+                                 self.keyword,\n+                                 pat_expr_str,\n+                                 if_str,\n+                                 else_str);\n+\n+            if result.len() <= width {\n+                return Some(result);\n+            }\n         }\n+\n+        None\n     }\n }\n \n-impl<'a> Rewrite for Loop<'a> {\n+impl<'a> Rewrite for ControlFlow<'a> {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: Indent) -> Option<String> {\n+        let (budget, indent) = if self.nested_if {\n+            // We are part of an if-elseif-else chain. Our constraints are tightened.\n+            // 7 = \"} else \" .len()\n+            (try_opt!(width.checked_sub(7)), offset + 7)\n+        } else {\n+            (width, offset)\n+        };\n+\n         let label_string = rewrite_label(self.label);\n-        // 2 = \" {\".len()\n-        let inner_width = try_opt!(width.checked_sub(self.keyword.len() + 2 + label_string.len()));\n-        let inner_offset = offset + self.keyword.len() + label_string.len();\n+        // 1 = space after keyword.\n+        let inner_offset = indent + self.keyword.len() + label_string.len() + 1;\n+        let mut inner_width =\n+            try_opt!(budget.checked_sub(self.keyword.len() + label_string.len() + 1));\n+        if context.config.control_brace_style != ControlBraceStyle::AlwaysNextLine {\n+            // 2 = \" {\".len()\n+            inner_width = try_opt!(inner_width.checked_sub(2));\n+        }\n \n         let pat_expr_string = match self.cond {\n             Some(cond) => {\n@@ -759,28 +860,131 @@ impl<'a> Rewrite for Loop<'a> {\n             None => String::new(),\n         };\n \n-        let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n-        let block_sep = match context.config.control_brace_style {\n-            ControlBraceStyle::AlwaysNextLine => alt_block_sep.as_str(),\n-            ControlBraceStyle::AlwaysSameLine => \" \",\n-        };\n+        // Try to format if-else on single line.\n+        if self.allow_single_line && context.config.single_line_if_else_max_width > 0 {\n+            let trial = self.rewrite_single_line(&pat_expr_string, context, width);\n \n-        // This is used only for the empty block case: `{}`\n+            if trial.is_some() &&\n+               trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width {\n+                return trial;\n+            }\n+        }\n+\n+        // This is used only for the empty block case: `{}`.\n+        // 2 = spaces after keyword and condition.\n         let block_width = try_opt!(width.checked_sub(label_string.len() + self.keyword.len() +\n                                                      extra_offset(&pat_expr_string, inner_offset) +\n-                                                     1));\n-\n-        // FIXME: this drops any comment between \"loop\" and the block.\n-        self.block\n-            .rewrite(context, block_width, offset)\n-            .map(|result| {\n-                format!(\"{}{}{}{}{}\",\n-                        label_string,\n-                        self.keyword,\n-                        pat_expr_string,\n-                        block_sep,\n-                        result)\n-            })\n+                                                     2));\n+\n+        let block_str = try_opt!(self.block.rewrite(context, block_width, offset));\n+\n+        let cond_span = if let Some(cond) = self.cond {\n+            cond.span\n+        } else {\n+            mk_sp(self.block.span.lo, self.block.span.lo)\n+        };\n+\n+        // for event in event\n+        let between_kwd_cond =\n+            mk_sp(context.codemap.span_after(self.span, self.keyword.trim()),\n+                  self.pat.map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n+                      p.span.lo\n+                  } else {\n+                      context.codemap.span_before(self.span, self.matcher.trim())\n+                  }));\n+\n+        let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, offset, width);\n+\n+        let after_cond_comment = extract_comment(mk_sp(cond_span.hi, self.block.span.lo),\n+                                                 context,\n+                                                 offset,\n+                                                 width);\n+\n+        let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n+        let block_sep = if self.cond.is_none() && between_kwd_cond_comment.is_some() {\n+            \"\"\n+        } else if context.config.control_brace_style ==\n+                                  ControlBraceStyle::AlwaysNextLine {\n+            alt_block_sep.as_str()\n+        } else {\n+            \" \"\n+        };\n+\n+        let mut result = format!(\"{}{}{}{}{}{}\",\n+                                 label_string,\n+                                 self.keyword,\n+                                 between_kwd_cond_comment.as_ref()\n+                                     .map_or(if pat_expr_string.is_empty() { \"\" } else { \" \" },\n+                                             |s| &**s),\n+                                 pat_expr_string,\n+                                 after_cond_comment.as_ref().map_or(block_sep, |s| &**s),\n+                                 block_str);\n+\n+        if let Some(else_block) = self.else_block {\n+            let mut last_in_chain = false;\n+            let rewrite = match else_block.node {\n+                // If the else expression is another if-else expression, prevent it\n+                // from being formatted on a single line.\n+                // Note how we're passing the original width and offset, as the\n+                // cost of \"else\" should not cascade.\n+                ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n+                    ControlFlow::new_if(cond,\n+                                        Some(pat),\n+                                        if_block,\n+                                        next_else_block.as_ref().map(|e| &**e),\n+                                        false,\n+                                        true,\n+                                        mk_sp(else_block.span.lo, self.span.hi))\n+                        .rewrite(context, width, offset)\n+                }\n+                ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n+                    ControlFlow::new_if(cond,\n+                                        None,\n+                                        if_block,\n+                                        next_else_block.as_ref().map(|e| &**e),\n+                                        false,\n+                                        true,\n+                                        mk_sp(else_block.span.lo, self.span.hi))\n+                        .rewrite(context, width, offset)\n+                }\n+                _ => {\n+                    last_in_chain = true;\n+                    else_block.rewrite(context, width, offset)\n+                }\n+            };\n+\n+            let between_kwd_else_block =\n+                mk_sp(self.block.span.hi,\n+                      context.codemap\n+                          .span_before(mk_sp(self.block.span.hi, else_block.span.lo), \"else\"));\n+            let between_kwd_else_block_comment =\n+                extract_comment(between_kwd_else_block, context, offset, width);\n+\n+            let after_else = mk_sp(context.codemap\n+                                       .span_after(mk_sp(self.block.span.hi, else_block.span.lo),\n+                                                   \"else\"),\n+                                   else_block.span.lo);\n+            let after_else_comment = extract_comment(after_else, context, offset, width);\n+\n+            let between_sep = match context.config.control_brace_style {\n+                ControlBraceStyle::AlwaysNextLine |\n+                ControlBraceStyle::ClosingNextLine => &*alt_block_sep,\n+                ControlBraceStyle::AlwaysSameLine => \" \",\n+            };\n+            let after_sep = match context.config.control_brace_style {\n+                ControlBraceStyle::AlwaysNextLine if last_in_chain => &*alt_block_sep,\n+                _ => \" \",\n+            };\n+            try_opt!(write!(&mut result,\n+                            \"{}else{}\",\n+                            between_kwd_else_block_comment.as_ref()\n+                                .map_or(between_sep, |s| &**s),\n+                            after_else_comment.as_ref().map_or(after_sep, |s| &**s))\n+                .ok());\n+            result.push_str(&try_opt!(rewrite));\n+        }\n+\n+        Some(result)\n     }\n }\n \n@@ -808,183 +1012,6 @@ fn extract_comment(span: Span,\n     }\n }\n \n-// Rewrites if-else blocks. If let Some(_) = pat, the expression is\n-// treated as an if-let-else expression.\n-fn rewrite_if_else(context: &RewriteContext,\n-                   cond: &ast::Expr,\n-                   expr_type: ExprType,\n-                   if_block: &ast::Block,\n-                   else_block_opt: Option<&ast::Expr>,\n-                   span: Span,\n-                   pat: Option<&ast::Pat>,\n-                   width: usize,\n-                   offset: Indent,\n-                   allow_single_line: bool)\n-                   -> Option<String> {\n-    let (budget, indent) = if !allow_single_line {\n-        // We are part of an if-elseif-else chain. Our constraints are tightened.\n-        // 7 = \"} else\" .len()\n-        (try_opt!(width.checked_sub(7)), offset + 7)\n-    } else {\n-        (width, offset)\n-    };\n-\n-    // 3 = \"if \", 2 = \" {\"\n-    let pat_penalty = match context.config.else_if_brace_style {\n-        ElseIfBraceStyle::AlwaysNextLine => 3,\n-        _ => 3 + 2,\n-    };\n-    let pat_expr_string = try_opt!(rewrite_pat_expr(context,\n-                                                    pat,\n-                                                    cond,\n-                                                    \"let \",\n-                                                    \" =\",\n-                                                    try_opt!(budget.checked_sub(pat_penalty)),\n-                                                    indent + 3));\n-\n-    // Try to format if-else on single line.\n-    if expr_type == ExprType::SubExpression && allow_single_line &&\n-       context.config.single_line_if_else_max_width > 0 {\n-        let trial = single_line_if_else(context, &pat_expr_string, if_block, else_block_opt, width);\n-\n-        if trial.is_some() &&\n-           trial.as_ref().unwrap().len() <= context.config.single_line_if_else_max_width {\n-            return trial;\n-        }\n-    }\n-\n-    let if_block_string = try_opt!(if_block.rewrite(context, width, offset));\n-\n-    let between_if_cond = mk_sp(context.codemap.span_after(span, \"if\"),\n-                                pat.map_or(cond.span.lo,\n-                                           |_| context.codemap.span_before(span, \"let\")));\n-\n-    let between_if_cond_comment = extract_comment(between_if_cond, context, offset, width);\n-\n-    let after_cond_comment = extract_comment(mk_sp(cond.span.hi, if_block.span.lo),\n-                                             context,\n-                                             offset,\n-                                             width);\n-\n-    let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n-    let after_sep = match context.config.else_if_brace_style {\n-        ElseIfBraceStyle::AlwaysNextLine => alt_block_sep.as_str(),\n-        _ => \" \",\n-    };\n-    let mut result = format!(\"if{}{}{}{}\",\n-                             between_if_cond_comment.as_ref().map_or(\" \", |str| &**str),\n-                             pat_expr_string,\n-                             after_cond_comment.as_ref().map_or(after_sep, |str| &**str),\n-                             if_block_string);\n-\n-    if let Some(else_block) = else_block_opt {\n-        let mut last_in_chain = false;\n-        let rewrite = match else_block.node {\n-            // If the else expression is another if-else expression, prevent it\n-            // from being formatted on a single line.\n-            // Note how we're passing the original width and offset, as the\n-            // cost of \"else\" should not cascade.\n-            ast::ExprKind::IfLet(ref pat, ref cond, ref if_block, ref next_else_block) => {\n-                rewrite_if_else(context,\n-                                cond,\n-                                expr_type,\n-                                if_block,\n-                                next_else_block.as_ref().map(|e| &**e),\n-                                mk_sp(else_block.span.lo, span.hi),\n-                                Some(pat),\n-                                width,\n-                                offset,\n-                                false)\n-            }\n-            ast::ExprKind::If(ref cond, ref if_block, ref next_else_block) => {\n-                rewrite_if_else(context,\n-                                cond,\n-                                expr_type,\n-                                if_block,\n-                                next_else_block.as_ref().map(|e| &**e),\n-                                mk_sp(else_block.span.lo, span.hi),\n-                                None,\n-                                width,\n-                                offset,\n-                                false)\n-            }\n-            _ => {\n-                last_in_chain = true;\n-                else_block.rewrite(context, width, offset)\n-            }\n-        };\n-\n-        let between_if_else_block =\n-            mk_sp(if_block.span.hi,\n-                  context.codemap.span_before(mk_sp(if_block.span.hi, else_block.span.lo), \"else\"));\n-        let between_if_else_block_comment =\n-            extract_comment(between_if_else_block, context, offset, width);\n-\n-        let after_else = mk_sp(context.codemap\n-                                   .span_after(mk_sp(if_block.span.hi, else_block.span.lo),\n-                                               \"else\"),\n-                               else_block.span.lo);\n-        let after_else_comment = extract_comment(after_else, context, offset, width);\n-\n-        let between_sep = match context.config.else_if_brace_style {\n-            ElseIfBraceStyle::AlwaysNextLine |\n-            ElseIfBraceStyle::ClosingNextLine => alt_block_sep.as_str(),\n-            ElseIfBraceStyle::AlwaysSameLine => \" \",\n-        };\n-        let after_sep = match context.config.else_if_brace_style {\n-            ElseIfBraceStyle::AlwaysNextLine if last_in_chain => alt_block_sep.as_str(),\n-            _ => \" \",\n-        };\n-        try_opt!(write!(&mut result,\n-                        \"{}else{}\",\n-                        between_if_else_block_comment.as_ref()\n-                            .map_or(between_sep, |str| &**str),\n-                        after_else_comment.as_ref().map_or(after_sep, |str| &**str))\n-            .ok());\n-        result.push_str(&try_opt!(rewrite));\n-    }\n-\n-    Some(result)\n-}\n-\n-fn single_line_if_else(context: &RewriteContext,\n-                       pat_expr_str: &str,\n-                       if_node: &ast::Block,\n-                       else_block_opt: Option<&ast::Expr>,\n-                       width: usize)\n-                       -> Option<String> {\n-    let else_block = try_opt!(else_block_opt);\n-    let fixed_cost = \"if  {  } else {  }\".len();\n-\n-    if let ast::ExprKind::Block(ref else_node) = else_block.node {\n-        if !is_simple_block(if_node, context.codemap) ||\n-           !is_simple_block(else_node, context.codemap) || pat_expr_str.contains('\\n') {\n-            return None;\n-        }\n-\n-        let new_width = try_opt!(width.checked_sub(pat_expr_str.len() + fixed_cost));\n-        let if_expr = &if_node.stmts[0];\n-        let if_str = try_opt!(if_expr.rewrite(context, new_width, Indent::empty()));\n-\n-        let new_width = try_opt!(new_width.checked_sub(if_str.len()));\n-        let else_expr = &else_node.stmts[0];\n-        let else_str = try_opt!(else_expr.rewrite(context, new_width, Indent::empty()));\n-\n-        // FIXME: this check shouldn't be necessary. Rewrites should either fail\n-        // or wrap to a newline when the object does not fit the width.\n-        let fits_line = fixed_cost + pat_expr_str.len() + if_str.len() + else_str.len() <= width;\n-\n-        if fits_line && !if_str.contains('\\n') && !else_str.contains('\\n') {\n-            return Some(format!(\"if {} {{ {} }} else {{ {} }}\",\n-                                pat_expr_str,\n-                                if_str,\n-                                else_str));\n-        }\n-    }\n-\n-    None\n-}\n-\n fn block_contains_comment(block: &ast::Block, codemap: &CodeMap) -> bool {\n     let snippet = codemap.span_to_snippet(block.span).unwrap();\n     contains_comment(&snippet)\n@@ -1079,7 +1106,7 @@ fn rewrite_match(context: &RewriteContext,\n     let alt_block_sep = String::from(\"\\n\") + &context.block_indent.to_string(context.config);\n     let block_sep = match context.config.control_brace_style {\n         ControlBraceStyle::AlwaysSameLine => \" \",\n-        ControlBraceStyle::AlwaysNextLine => alt_block_sep.as_str(),\n+        _ => alt_block_sep.as_str(),\n     };\n     let mut result = format!(\"match {}{}{{\", cond_str, block_sep);\n \n@@ -1299,7 +1326,7 @@ impl Rewrite for ast::Arm {\n \n         let block_sep = match context.config.control_brace_style {\n             ControlBraceStyle::AlwaysNextLine => alt_block_sep + body_prefix + \"\\n\",\n-            ControlBraceStyle::AlwaysSameLine => String::from(\" \") + body_prefix + \"\\n\",\n+            _ => String::from(\" \") + body_prefix + \"\\n\",\n         };\n         Some(format!(\"{}{} =>{}{}{}\\n{}{}\",\n                      attr_str.trim_left(),\n@@ -1369,10 +1396,15 @@ fn rewrite_pat_expr(context: &RewriteContext,\n                     width: usize,\n                     offset: Indent)\n                     -> Option<String> {\n-    let pat_offset = offset + matcher.len();\n     let mut result = match pat {\n         Some(pat) => {\n+            let matcher = if matcher.is_empty() {\n+                matcher.to_owned()\n+            } else {\n+                format!(\"{} \", matcher)\n+            };\n             let pat_budget = try_opt!(width.checked_sub(connector.len() + matcher.len()));\n+            let pat_offset = offset + matcher.len();\n             let pat_string = try_opt!(pat.rewrite(context, pat_budget, pat_offset));\n             format!(\"{}{}{}\", matcher, pat_string, connector)\n         }"}, {"sha": "9079fb46c0cd7d6a1e5683fe8cfceb7add9b15f7", "filename": "tests/source/control-brace-style-always-next-line.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Fcontrol-brace-style-always-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Fcontrol-brace-style-always-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcontrol-brace-style-always-next-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -7,7 +7,7 @@ fn main() {\n         }\n \n \n-    'loop_label: loop // loop comment  \n+    'label: loop // loop comment  \n     {\n         ();\n     }"}, {"sha": "1c8f487e7cdaabf3653e3c585611314e9ccf3daa", "filename": "tests/source/control-brace-style-always-same-line.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Fcontrol-brace-style-always-same-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Fcontrol-brace-style-always-same-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fcontrol-brace-style-always-same-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -7,7 +7,7 @@ fn main() {\n         }\n \n \n-    'loop_label: loop // loop comment  \n+    'label: loop // loop comment  \n     {\n         ();\n     }"}, {"sha": "12208dd7c8bc4135c6f397f93f6ecbbc0600fe09", "filename": "tests/source/else-if-brace-style-always-next-line.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Felse-if-brace-style-always-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Felse-if-brace-style-always-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Felse-if-brace-style-always-next-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -1,5 +1,5 @@\n // rustfmt-single_line_if_else_max_width: 0\n-// rustfmt-else_if_brace_style: AlwaysNextLine\n+// rustfmt-control_brace_style: AlwaysNextLine\n \n fn main() {\n     if false"}, {"sha": "c844275ef5b41235bf6b6a65cd3962272b07f69b", "filename": "tests/source/else-if-brace-style-always-same-line.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Felse-if-brace-style-always-same-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Felse-if-brace-style-always-same-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Felse-if-brace-style-always-same-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -1,5 +1,5 @@\n // rustfmt-single_line_if_else_max_width: 0\n-// rustfmt-else_if_brace_style: AlwaysSameLine\n+// rustfmt-control_brace_style: AlwaysSameLine\n \n fn main() {\n     if false"}, {"sha": "ccc8d7b0f3f5931994fa8d332a4870f8472a0afd", "filename": "tests/source/else-if-brace-style-closing-next-line.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Felse-if-brace-style-closing-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Fsource%2Felse-if-brace-style-closing-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Felse-if-brace-style-closing-next-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -1,5 +1,5 @@\n // rustfmt-single_line_if_else_max_width: 0\n-// rustfmt-else_if_brace_style: ClosingNextLine\n+// rustfmt-control_brace_style: ClosingNextLine\n \n fn main() {\n     if false"}, {"sha": "07f46fa6163de674b6826dafae5c279cd51d8ae1", "filename": "tests/target/control-brace-style-always-next-line.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Fcontrol-brace-style-always-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Fcontrol-brace-style-always-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcontrol-brace-style-always-next-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -8,7 +8,8 @@ fn main() {\n     }\n \n \n-    'loop_label: loop\n+    'label: loop\n+    // loop comment\n     {\n         ();\n     }"}, {"sha": "d88ae5a2c2d4f0465fc8d90930872455800526ea", "filename": "tests/target/control-brace-style-always-same-line.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Fcontrol-brace-style-always-same-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Fcontrol-brace-style-always-same-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fcontrol-brace-style-always-same-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -7,7 +7,9 @@ fn main() {\n     }\n \n \n-    'loop_label: loop {\n+    'label: loop\n+    // loop comment\n+    {\n         ();\n     }\n "}, {"sha": "4a2ef877b85702a1c48131de86dc94e45293c966", "filename": "tests/target/else-if-brace-style-always-next-line.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Felse-if-brace-style-always-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Felse-if-brace-style-always-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Felse-if-brace-style-always-next-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -1,5 +1,5 @@\n // rustfmt-single_line_if_else_max_width: 0\n-// rustfmt-else_if_brace_style: AlwaysNextLine\n+// rustfmt-control_brace_style: AlwaysNextLine\n \n fn main() {\n     if false"}, {"sha": "9baaa3f9b36b7ce060dc356b7b7046fcb8690f21", "filename": "tests/target/else-if-brace-style-always-same-line.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Felse-if-brace-style-always-same-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Felse-if-brace-style-always-same-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Felse-if-brace-style-always-same-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -1,5 +1,5 @@\n // rustfmt-single_line_if_else_max_width: 0\n-// rustfmt-else_if_brace_style: AlwaysSameLine\n+// rustfmt-control_brace_style: AlwaysSameLine\n \n fn main() {\n     if false {"}, {"sha": "f1af1943431ab6d68c21b89556ba1ad43e7c5782", "filename": "tests/target/else-if-brace-style-closing-next-line.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Felse-if-brace-style-closing-next-line.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53493361925a1eba9226ba3f33bb1871962be169/tests%2Ftarget%2Felse-if-brace-style-closing-next-line.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Felse-if-brace-style-closing-next-line.rs?ref=53493361925a1eba9226ba3f33bb1871962be169", "patch": "@@ -1,5 +1,5 @@\n // rustfmt-single_line_if_else_max_width: 0\n-// rustfmt-else_if_brace_style: ClosingNextLine\n+// rustfmt-control_brace_style: ClosingNextLine\n \n fn main() {\n     if false {"}]}