{"sha": "0219b145ea255e215693d0fc324aa78311a41236", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyMTliMTQ1ZWEyNTVlMjE1NjkzZDBmYzMyNGFhNzgzMTFhNDEyMzY=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-20T16:36:59Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-06-20T17:12:06Z"}, "message": "Clean up coercion tests", "tree": {"sha": "42664273d77977f8f02448d8a56d6e74a8b8815d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42664273d77977f8f02448d8a56d6e74a8b8815d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0219b145ea255e215693d0fc324aa78311a41236", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0219b145ea255e215693d0fc324aa78311a41236", "html_url": "https://github.com/rust-lang/rust/commit/0219b145ea255e215693d0fc324aa78311a41236", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0219b145ea255e215693d0fc324aa78311a41236/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d340f28a815ba53a4d35801242eec7fca3718731", "url": "https://api.github.com/repos/rust-lang/rust/commits/d340f28a815ba53a4d35801242eec7fca3718731", "html_url": "https://github.com/rust-lang/rust/commit/d340f28a815ba53a4d35801242eec7fca3718731"}], "stats": {"total": 669, "additions": 117, "deletions": 552}, "files": [{"sha": "87089f09d13fe96c11e965b3af9c0e0556dc6b89", "filename": "crates/hir_ty/src/tests/coercion.rs", "status": "modified", "additions": 117, "deletions": 552, "changes": 669, "blob_url": "https://github.com/rust-lang/rust/blob/0219b145ea255e215693d0fc324aa78311a41236/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0219b145ea255e215693d0fc324aa78311a41236/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=0219b145ea255e215693d0fc324aa78311a41236", "patch": "@@ -1,27 +1,22 @@\n-use expect_test::expect;\n-\n-use super::{check_infer, check_infer_with_mismatches, check_no_mismatches, check_types};\n+use super::{check, check_no_mismatches, check_types};\n \n #[test]\n-fn infer_block_expr_type_mismatch() {\n-    check_infer(\n+fn block_expr_type_mismatch() {\n+    // FIXME fix double type mismatch\n+    check(\n         r\"\n-        fn test() {\n-            let a: i32 = { 1i64 };\n-        }\n+fn test() {\n+    let a: i32 = { 1i64 };\n+              // ^^^^^^^^ expected i32, got i64\n+                // ^^^^ expected i32, got i64\n+}\n         \",\n-        expect![[r\"\n-            10..40 '{     ...4 }; }': ()\n-            20..21 'a': i32\n-            29..37 '{ 1i64 }': i64\n-            31..35 '1i64': i64\n-        \"]],\n     );\n }\n \n #[test]\n fn coerce_places() {\n-    check_infer(\n+    check_no_mismatches(\n         r#\"\n //- minicore: coerce_unsized\n struct S<T> { a: T }\n@@ -46,81 +41,25 @@ fn test2() {\n     let g: (&[_], &[_]) = (arr, arr);\n }\n \"#,\n-        expect![[r#\"\n-            30..31 '_': &[T]\n-            44..55 '{ loop {} }': T\n-            46..53 'loop {}': !\n-            51..53 '{}': ()\n-            64..65 '_': S<&[T]>\n-            81..92 '{ loop {} }': T\n-            83..90 'loop {}': !\n-            88..90 '{}': ()\n-            121..132 '{ loop {} }': *mut [T; 2]\n-            123..130 'loop {}': !\n-            128..130 '{}': ()\n-            159..172 '{     gen() }': *mut [U]\n-            165..168 'gen': fn gen<U>() -> *mut [U; 2]\n-            165..170 'gen()': *mut [U; 2]\n-            185..419 '{     ...rr); }': ()\n-            195..198 'arr': &[u8; 1]\n-            211..215 '&[1]': &[u8; 1]\n-            212..215 '[1]': [u8; 1]\n-            213..214 '1': u8\n-            226..227 'a': &[u8]\n-            236..239 'arr': &[u8; 1]\n-            249..250 'b': u8\n-            253..254 'f': fn f<u8>(&[u8]) -> u8\n-            253..259 'f(arr)': u8\n-            255..258 'arr': &[u8; 1]\n-            269..270 'c': &[u8]\n-            279..286 '{ arr }': &[u8]\n-            281..284 'arr': &[u8; 1]\n-            296..297 'd': u8\n-            300..301 'g': fn g<u8>(S<&[u8]>) -> u8\n-            300..315 'g(S { a: arr })': u8\n-            302..314 'S { a: arr }': S<&[u8]>\n-            309..312 'arr': &[u8; 1]\n-            325..326 'e': [&[u8]; 1]\n-            340..345 '[arr]': [&[u8]; 1]\n-            341..344 'arr': &[u8; 1]\n-            355..356 'f': [&[u8]; 2]\n-            370..378 '[arr; 2]': [&[u8]; 2]\n-            371..374 'arr': &[u8; 1]\n-            376..377 '2': usize\n-            388..389 'g': (&[u8], &[u8])\n-            406..416 '(arr, arr)': (&[u8], &[u8])\n-            407..410 'arr': &[u8; 1]\n-            412..415 'arr': &[u8; 1]\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_let_stmt_coerce() {\n-    check_infer(\n+fn let_stmt_coerce() {\n+    check_no_mismatches(\n         r\"\n-        fn test() {\n-            let x: &[isize] = &[1];\n-            let x: *const [isize] = &[1];\n-        }\n-        \",\n-        expect![[r#\"\n-            10..75 '{     ...[1]; }': ()\n-            20..21 'x': &[isize]\n-            34..38 '&[1]': &[isize; 1]\n-            35..38 '[1]': [isize; 1]\n-            36..37 '1': isize\n-            48..49 'x': *const [isize]\n-            68..72 '&[1]': &[isize; 1]\n-            69..72 '[1]': [isize; 1]\n-            70..71 '1': isize\n-        \"#]],\n+//- minicore: coerce_unsized\n+fn test() {\n+    let x: &[isize] = &[1];\n+    let x: *const [isize] = &[1];\n+}\n+\",\n     );\n }\n \n #[test]\n-fn infer_custom_coerce_unsized() {\n-    check_infer(\n+fn custom_coerce_unsized() {\n+    check(\n         r#\"\n //- minicore: coerce_unsized\n use core::{marker::Unsize, ops::CoerceUnsized};\n@@ -138,46 +77,22 @@ fn foo3<T>(x: C<[T]>) -> C<[T]> { x }\n \n fn test(a: A<[u8; 2]>, b: B<[u8; 2]>, c: C<[u8; 2]>) {\n     let d = foo1(a);\n+              // ^ expected A<[{unknown}]>, got A<[u8; 2]>\n     let e = foo2(b);\n+     // ^ type: B<[u8]>\n     let f = foo3(c);\n+     // ^ type: C<[u8]>\n }\n \"#,\n-        expect![[r#\"\n-            306..307 'x': A<[T]>\n-            327..332 '{ x }': A<[T]>\n-            329..330 'x': A<[T]>\n-            344..345 'x': B<[T]>\n-            365..370 '{ x }': B<[T]>\n-            367..368 'x': B<[T]>\n-            382..383 'x': C<[T]>\n-            403..408 '{ x }': C<[T]>\n-            405..406 'x': C<[T]>\n-            418..419 'a': A<[u8; 2]>\n-            433..434 'b': B<[u8; 2]>\n-            448..449 'c': C<[u8; 2]>\n-            463..529 '{     ...(c); }': ()\n-            473..474 'd': A<[{unknown}]>\n-            477..481 'foo1': fn foo1<{unknown}>(A<[{unknown}]>) -> A<[{unknown}]>\n-            477..484 'foo1(a)': A<[{unknown}]>\n-            482..483 'a': A<[u8; 2]>\n-            494..495 'e': B<[u8]>\n-            498..502 'foo2': fn foo2<u8>(B<[u8]>) -> B<[u8]>\n-            498..505 'foo2(b)': B<[u8]>\n-            503..504 'b': B<[u8; 2]>\n-            515..516 'f': C<[u8]>\n-            519..523 'foo3': fn foo3<u8>(C<[u8]>) -> C<[u8]>\n-            519..526 'foo3(c)': C<[u8]>\n-            524..525 'c': C<[u8; 2]>\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_if_coerce() {\n-    check_infer(\n+fn if_coerce() {\n+    check_no_mismatches(\n         r#\"\n-//- minicore: unsize\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+//- minicore: coerce_unsized\n+fn foo<T>(x: &[T]) -> &[T] { x }\n fn test() {\n     let x = if true {\n         foo(&[1])\n@@ -186,35 +101,15 @@ fn test() {\n     };\n }\n \"#,\n-        expect![[r#\"\n-            10..11 'x': &[T]\n-            27..38 '{ loop {} }': &[T]\n-            29..36 'loop {}': !\n-            34..36 '{}': ()\n-            49..125 '{     ...  }; }': ()\n-            59..60 'x': &[i32]\n-            63..122 'if tru...     }': &[i32]\n-            66..70 'true': bool\n-            71..96 '{     ...     }': &[i32]\n-            81..84 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-            81..90 'foo(&[1])': &[i32]\n-            85..89 '&[1]': &[i32; 1]\n-            86..89 '[1]': [i32; 1]\n-            87..88 '1': i32\n-            102..122 '{     ...     }': &[i32; 1]\n-            112..116 '&[1]': &[i32; 1]\n-            113..116 '[1]': [i32; 1]\n-            114..115 '1': i32\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_if_else_coerce() {\n-    check_infer(\n+fn if_else_coerce() {\n+    check_no_mismatches(\n         r#\"\n //- minicore: coerce_unsized\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+fn foo<T>(x: &[T]) -> &[T] { x }\n fn test() {\n     let x = if true {\n         &[1]\n@@ -223,35 +118,15 @@ fn test() {\n     };\n }\n \"#,\n-        expect![[r#\"\n-            10..11 'x': &[T]\n-            27..38 '{ loop {} }': &[T]\n-            29..36 'loop {}': !\n-            34..36 '{}': ()\n-            49..125 '{     ...  }; }': ()\n-            59..60 'x': &[i32]\n-            63..122 'if tru...     }': &[i32]\n-            66..70 'true': bool\n-            71..91 '{     ...     }': &[i32; 1]\n-            81..85 '&[1]': &[i32; 1]\n-            82..85 '[1]': [i32; 1]\n-            83..84 '1': i32\n-            97..122 '{     ...     }': &[i32]\n-            107..110 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-            107..116 'foo(&[1])': &[i32]\n-            111..115 '&[1]': &[i32; 1]\n-            112..115 '[1]': [i32; 1]\n-            113..114 '1': i32\n-        \"#]],\n     )\n }\n \n #[test]\n-fn infer_match_first_coerce() {\n-    check_infer(\n+fn match_first_coerce() {\n+    check_no_mismatches(\n         r#\"\n-//- minicore: unsize\n-fn foo<T>(x: &[T]) -> &[T] { loop {} }\n+//- minicore: coerce_unsized\n+fn foo<T>(x: &[T]) -> &[T] { x }\n fn test(i: i32) {\n     let x = match i {\n         2 => foo(&[2]),\n@@ -260,39 +135,12 @@ fn test(i: i32) {\n     };\n }\n \"#,\n-        expect![[r#\"\n-            10..11 'x': &[T]\n-            27..38 '{ loop {} }': &[T]\n-            29..36 'loop {}': !\n-            34..36 '{}': ()\n-            47..48 'i': i32\n-            55..149 '{     ...  }; }': ()\n-            65..66 'x': &[i32]\n-            69..146 'match ...     }': &[i32]\n-            75..76 'i': i32\n-            87..88 '2': i32\n-            87..88 '2': i32\n-            92..95 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-            92..101 'foo(&[2])': &[i32]\n-            96..100 '&[2]': &[i32; 1]\n-            97..100 '[2]': [i32; 1]\n-            98..99 '2': i32\n-            111..112 '1': i32\n-            111..112 '1': i32\n-            116..120 '&[1]': &[i32; 1]\n-            117..120 '[1]': [i32; 1]\n-            118..119 '1': i32\n-            130..131 '_': i32\n-            135..139 '&[3]': &[i32; 1]\n-            136..139 '[3]': [i32; 1]\n-            137..138 '3': i32\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_match_second_coerce() {\n-    check_infer(\n+fn match_second_coerce() {\n+    check_no_mismatches(\n         r#\"\n //- minicore: coerce_unsized\n fn foo<T>(x: &[T]) -> &[T] { loop {} }\n@@ -304,128 +152,59 @@ fn test(i: i32) {\n     };\n }\n \"#,\n-        expect![[r#\"\n-            10..11 'x': &[T]\n-            27..38 '{ loop {} }': &[T]\n-            29..36 'loop {}': !\n-            34..36 '{}': ()\n-            47..48 'i': i32\n-            55..149 '{     ...  }; }': ()\n-            65..66 'x': &[i32]\n-            69..146 'match ...     }': &[i32]\n-            75..76 'i': i32\n-            87..88 '1': i32\n-            87..88 '1': i32\n-            92..96 '&[1]': &[i32; 1]\n-            93..96 '[1]': [i32; 1]\n-            94..95 '1': i32\n-            106..107 '2': i32\n-            106..107 '2': i32\n-            111..114 'foo': fn foo<i32>(&[i32]) -> &[i32]\n-            111..120 'foo(&[2])': &[i32]\n-            115..119 '&[2]': &[i32; 1]\n-            116..119 '[2]': [i32; 1]\n-            117..118 '2': i32\n-            130..131 '_': i32\n-            135..139 '&[3]': &[i32; 1]\n-            136..139 '[3]': [i32; 1]\n-            137..138 '3': i32\n-        \"#]],\n     );\n }\n \n #[test]\n fn coerce_merge_one_by_one1() {\n     cov_mark::check!(coerce_merge_fail_fallback);\n \n-    check_infer(\n+    check(\n         r\"\n-        fn test() {\n-            let t = &mut 1;\n-            let x = match 1 {\n-                1 => t as *mut i32,\n-                2 => t as &i32,\n-                _ => t as *const i32,\n-            };\n-        }\n+fn test() {\n+    let t = &mut 1;\n+    let x = match 1 {\n+        1 => t as *mut i32,\n+        2 => t as &i32,\n+           //^^^^^^^^^ expected *mut i32, got &i32\n+        _ => t as *const i32,\n+    };\n+    x;\n+  //^ type: *const i32\n+}\n         \",\n-        expect![[r\"\n-            10..144 '{     ...  }; }': ()\n-            20..21 't': &mut i32\n-            24..30 '&mut 1': &mut i32\n-            29..30 '1': i32\n-            40..41 'x': *const i32\n-            44..141 'match ...     }': *const i32\n-            50..51 '1': i32\n-            62..63 '1': i32\n-            62..63 '1': i32\n-            67..68 't': &mut i32\n-            67..80 't as *mut i32': *mut i32\n-            90..91 '2': i32\n-            90..91 '2': i32\n-            95..96 't': &mut i32\n-            95..104 't as &i32': &i32\n-            114..115 '_': i32\n-            119..120 't': &mut i32\n-            119..134 't as *const i32': *const i32\n-    \"]],\n     );\n }\n \n #[test]\n fn return_coerce_unknown() {\n-    check_infer_with_mismatches(\n+    check_types(\n         r\"\n-        fn foo() -> u32 {\n-            return unknown;\n-        }\n+fn foo() -> u32 {\n+    return unknown;\n+         //^^^^^^^ u32\n+}\n         \",\n-        expect![[r\"\n-            16..39 '{     ...own; }': u32\n-            22..36 'return unknown': !\n-            29..36 'unknown': u32\n-        \"]],\n     );\n }\n \n #[test]\n fn coerce_autoderef() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        struct Foo;\n-        fn takes_ref_foo(x: &Foo) {}\n-        fn test() {\n-            takes_ref_foo(&Foo);\n-            takes_ref_foo(&&Foo);\n-            takes_ref_foo(&&&Foo);\n-        }\n-        \",\n-        expect![[r\"\n-            29..30 'x': &Foo\n-            38..40 '{}': ()\n-            51..132 '{     ...oo); }': ()\n-            57..70 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-            57..76 'takes_...(&Foo)': ()\n-            71..75 '&Foo': &Foo\n-            72..75 'Foo': Foo\n-            82..95 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-            82..102 'takes_...&&Foo)': ()\n-            96..101 '&&Foo': &&Foo\n-            97..101 '&Foo': &Foo\n-            98..101 'Foo': Foo\n-            108..121 'takes_ref_foo': fn takes_ref_foo(&Foo)\n-            108..129 'takes_...&&Foo)': ()\n-            122..128 '&&&Foo': &&&Foo\n-            123..128 '&&Foo': &&Foo\n-            124..128 '&Foo': &Foo\n-            125..128 'Foo': Foo\n-        \"]],\n+struct Foo;\n+fn takes_ref_foo(x: &Foo) {}\n+fn test() {\n+    takes_ref_foo(&Foo);\n+    takes_ref_foo(&&Foo);\n+    takes_ref_foo(&&&Foo);\n+}\",\n     );\n }\n \n #[test]\n fn coerce_autoderef_generic() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r#\"\n struct Foo;\n fn takes_ref<T>(x: &T) -> T { *x }\n@@ -435,34 +214,12 @@ fn test() {\n     takes_ref(&&&Foo);\n }\n \"#,\n-        expect![[r\"\n-            28..29 'x': &T\n-            40..46 '{ *x }': T\n-            42..44 '*x': T\n-            43..44 'x': &T\n-            57..126 '{     ...oo); }': ()\n-            63..72 'takes_ref': fn takes_ref<Foo>(&Foo) -> Foo\n-            63..78 'takes_ref(&Foo)': Foo\n-            73..77 '&Foo': &Foo\n-            74..77 'Foo': Foo\n-            84..93 'takes_ref': fn takes_ref<&Foo>(&&Foo) -> &Foo\n-            84..100 'takes_...&&Foo)': &Foo\n-            94..99 '&&Foo': &&Foo\n-            95..99 '&Foo': &Foo\n-            96..99 'Foo': Foo\n-            106..115 'takes_ref': fn takes_ref<&&Foo>(&&&Foo) -> &&Foo\n-            106..123 'takes_...&&Foo)': &&Foo\n-            116..122 '&&&Foo': &&&Foo\n-            117..122 '&&Foo': &&Foo\n-            118..122 '&Foo': &Foo\n-            119..122 'Foo': Foo\n-        \"]],\n     );\n }\n \n #[test]\n fn coerce_autoderef_block() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r#\"\n //- minicore: deref\n struct String {}\n@@ -473,182 +230,95 @@ fn test() {\n     takes_ref_str(&{ returns_string() });\n }\n \"#,\n-        expect![[r#\"\n-            90..91 'x': &str\n-            99..101 '{}': ()\n-            132..143 '{ loop {} }': String\n-            134..141 'loop {}': !\n-            139..141 '{}': ()\n-            154..199 '{     ... }); }': ()\n-            160..173 'takes_ref_str': fn takes_ref_str(&str)\n-            160..196 'takes_...g() })': ()\n-            174..195 '&{ ret...ng() }': &String\n-            175..195 '{ retu...ng() }': String\n-            177..191 'returns_string': fn returns_string() -> String\n-            177..193 'return...ring()': String\n-        \"#]],\n     );\n }\n \n #[test]\n fn closure_return_coerce() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        fn foo() {\n-            let x = || {\n-                if true {\n-                    return &1u32;\n-                }\n-                &&1u32\n-            };\n+fn foo() {\n+    let x = || {\n+        if true {\n+            return &1u32;\n         }\n-        \",\n-        expect![[r\"\n-            9..105 '{     ...  }; }': ()\n-            19..20 'x': || -> &u32\n-            23..102 '|| {  ...     }': || -> &u32\n-            26..102 '{     ...     }': &u32\n-            36..81 'if tru...     }': ()\n-            39..43 'true': bool\n-            44..81 '{     ...     }': ()\n-            58..70 'return &1u32': !\n-            65..70 '&1u32': &u32\n-            66..70 '1u32': u32\n-            90..96 '&&1u32': &&u32\n-            91..96 '&1u32': &u32\n-            92..96 '1u32': u32\n-        \"]],\n+        &&1u32\n+    };\n+}\",\n     );\n }\n \n #[test]\n fn coerce_fn_item_to_fn_ptr() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        fn foo(x: u32) -> isize { 1 }\n-        fn test() {\n-            let f: fn(u32) -> isize = foo;\n-        }\n-        \",\n-        expect![[r\"\n-            7..8 'x': u32\n-            24..29 '{ 1 }': isize\n-            26..27 '1': isize\n-            40..78 '{     ...foo; }': ()\n-            50..51 'f': fn(u32) -> isize\n-            72..75 'foo': fn foo(u32) -> isize\n-        \"]],\n+fn foo(x: u32) -> isize { 1 }\n+fn test() {\n+    let f: fn(u32) -> isize = foo;\n+}\",\n     );\n }\n \n #[test]\n fn coerce_fn_items_in_match_arms() {\n     cov_mark::check!(coerce_fn_reification);\n \n-    check_infer_with_mismatches(\n+    check_types(\n         r\"\n-        fn foo1(x: u32) -> isize { 1 }\n-        fn foo2(x: u32) -> isize { 2 }\n-        fn foo3(x: u32) -> isize { 3 }\n-        fn test() {\n-            let x = match 1 {\n-                1 => foo1,\n-                2 => foo2,\n-                _ => foo3,\n-            };\n-        }\n-        \",\n-        expect![[r\"\n-            8..9 'x': u32\n-            25..30 '{ 1 }': isize\n-            27..28 '1': isize\n-            39..40 'x': u32\n-            56..61 '{ 2 }': isize\n-            58..59 '2': isize\n-            70..71 'x': u32\n-            87..92 '{ 3 }': isize\n-            89..90 '3': isize\n-            103..192 '{     ...  }; }': ()\n-            113..114 'x': fn(u32) -> isize\n-            117..189 'match ...     }': fn(u32) -> isize\n-            123..124 '1': i32\n-            135..136 '1': i32\n-            135..136 '1': i32\n-            140..144 'foo1': fn foo1(u32) -> isize\n-            154..155 '2': i32\n-            154..155 '2': i32\n-            159..163 'foo2': fn foo2(u32) -> isize\n-            173..174 '_': i32\n-            178..182 'foo3': fn foo3(u32) -> isize\n-        \"]],\n+fn foo1(x: u32) -> isize { 1 }\n+fn foo2(x: u32) -> isize { 2 }\n+fn foo3(x: u32) -> isize { 3 }\n+fn test() {\n+    let x = match 1 {\n+        1 => foo1,\n+        2 => foo2,\n+        _ => foo3,\n+    };\n+    x;\n+  //^ fn(u32) -> isize\n+}\",\n     );\n }\n \n #[test]\n fn coerce_closure_to_fn_ptr() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        fn test() {\n-            let f: fn(u32) -> isize = |x| { 1 };\n-        }\n-        \",\n-        expect![[r\"\n-            10..54 '{     ...1 }; }': ()\n-            20..21 'f': fn(u32) -> isize\n-            42..51 '|x| { 1 }': |u32| -> isize\n-            43..44 'x': u32\n-            46..51 '{ 1 }': isize\n-            48..49 '1': isize\n-        \"]],\n+fn test() {\n+    let f: fn(u32) -> isize = |x| { 1 };\n+}\",\n     );\n }\n \n #[test]\n fn coerce_placeholder_ref() {\n     // placeholders should unify, even behind references\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r\"\n-        struct S<T> { t: T }\n-        impl<TT> S<TT> {\n-            fn get(&self) -> &TT {\n-                &self.t\n-            }\n-        }\n-        \",\n-        expect![[r\"\n-            50..54 'self': &S<TT>\n-            63..86 '{     ...     }': &TT\n-            73..80 '&self.t': &TT\n-            74..78 'self': &S<TT>\n-            74..80 'self.t': TT\n-        \"]],\n+struct S<T> { t: T }\n+impl<TT> S<TT> {\n+    fn get(&self) -> &TT {\n+        &self.t\n+    }\n+}\",\n     );\n }\n \n #[test]\n fn coerce_unsize_array() {\n-    check_infer_with_mismatches(\n+    check_types(\n         r#\"\n //- minicore: coerce_unsized\n fn test() {\n     let f: &[usize] = &[1, 2, 3];\n-}\n-        \"#,\n-        expect![[r#\"\n-            10..47 '{     ... 3]; }': ()\n-            20..21 'f': &[usize]\n-            34..44 '&[1, 2, 3]': &[usize; 3]\n-            35..44 '[1, 2, 3]': [usize; 3]\n-            36..37 '1': usize\n-            39..40 '2': usize\n-            42..43 '3': usize\n-        \"#]],\n+                      //^ usize\n+}\"#,\n     );\n }\n \n #[test]\n fn coerce_unsize_trait_object_simple() {\n-    check_infer_with_mismatches(\n+    check_types(\n         r#\"\n //- minicore: coerce_unsized\n trait Foo<T, U> {}\n@@ -662,88 +332,18 @@ impl<T, X> Baz<T, X> for S<T, X> {}\n \n fn test() {\n     let obj: &dyn Baz<i8, i16> = &S;\n+                                //^ S<i8, i16>\n     let obj: &dyn Bar<_, i8, i16> = &S;\n+                                   //^ S<i8, i16>\n     let obj: &dyn Foo<i8, _> = &S;\n-}\n-\"#,\n-        expect![[r#\"\n-            236..351 '{     ... &S; }': ()\n-            246..249 'obj': &dyn Baz<i8, i16>\n-            271..273 '&S': &S<i8, i16>\n-            272..273 'S': S<i8, i16>\n-            283..286 'obj': &dyn Bar<usize, i8, i16>\n-            311..313 '&S': &S<i8, i16>\n-            312..313 'S': S<i8, i16>\n-            323..326 'obj': &dyn Foo<i8, usize>\n-            346..348 '&S': &S<i8, {unknown}>\n-            347..348 'S': S<i8, {unknown}>\n-        \"#]],\n-    );\n-}\n-\n-#[test]\n-fn coerce_unsize_trait_object_to_trait_object() {\n-    // FIXME: The rust reference says this should be possible, but rustc doesn't\n-    // implement it. We used to support it, but Chalk doesn't. Here's the\n-    // correct expect:\n-    //\n-    //     424..609 '{     ...bj2; }': ()\n-    //     434..437 'obj': &dyn Baz<i8, i16>\n-    //     459..461 '&S': &S<i8, i16>\n-    //     460..461 'S': S<i8, i16>\n-    //     471..474 'obj': &dyn Bar<usize, i8, i16>\n-    //     496..499 'obj': &dyn Baz<i8, i16>\n-    //     509..512 'obj': &dyn Foo<i8, usize>\n-    //     531..534 'obj': &dyn Bar<usize, i8, i16>\n-    //     544..548 'obj2': &dyn Baz<i8, i16>\n-    //     570..572 '&S': &S<i8, i16>\n-    //     571..572 'S': S<i8, i16>\n-    //     582..583 '_': &dyn Foo<i8, usize>\n-    //     602..606 'obj2': &dyn Baz<i8, i16>\n-    check_infer_with_mismatches(\n-        r#\"\n-//- minicore: coerce_unsized\n-trait Foo<T, U> {}\n-trait Bar<U, T, X>: Foo<T, U> {}\n-trait Baz<T, X>: Bar<usize, T, X> {}\n-\n-struct S<T, X>;\n-impl<T, X> Foo<T, usize> for S<T, X> {}\n-impl<T, X> Bar<usize, T, X> for S<T, X> {}\n-impl<T, X> Baz<T, X> for S<T, X> {}\n-\n-fn test() {\n-    let obj: &dyn Baz<i8, i16> = &S;\n-    let obj: &dyn Bar<_, _, _> = obj;\n-    let obj: &dyn Foo<_, _> = obj;\n-    let obj2: &dyn Baz<i8, i16> = &S;\n-    let _: &dyn Foo<_, _> = obj2;\n-}\n-\"#,\n-        expect![[r#\"\n-            236..421 '{     ...bj2; }': ()\n-            246..249 'obj': &dyn Baz<i8, i16>\n-            271..273 '&S': &S<i8, i16>\n-            272..273 'S': S<i8, i16>\n-            283..286 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            308..311 'obj': &dyn Baz<i8, i16>\n-            321..324 'obj': &dyn Foo<{unknown}, {unknown}>\n-            343..346 'obj': &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            356..360 'obj2': &dyn Baz<i8, i16>\n-            382..384 '&S': &S<i8, i16>\n-            383..384 'S': S<i8, i16>\n-            394..395 '_': &dyn Foo<{unknown}, {unknown}>\n-            414..418 'obj2': &dyn Baz<i8, i16>\n-            308..311: expected &dyn Bar<{unknown}, {unknown}, {unknown}>, got &dyn Baz<i8, i16>\n-            343..346: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Bar<{unknown}, {unknown}, {unknown}>\n-            414..418: expected &dyn Foo<{unknown}, {unknown}>, got &dyn Baz<i8, i16>\n-        \"#]],\n+                              //^ S<i8, {unknown}>\n+}\"#,\n     );\n }\n \n #[test]\n fn coerce_unsize_super_trait_cycle() {\n-    check_infer_with_mismatches(\n+    check_no_mismatches(\n         r#\"\n //- minicore: coerce_unsized\n trait A {}\n@@ -762,81 +362,46 @@ fn test() {\n     let obj: &dyn A = &S;\n }\n \"#,\n-        expect![[r#\"\n-            140..195 '{     ... &S; }': ()\n-            150..153 'obj': &dyn D\n-            164..166 '&S': &S\n-            165..166 'S': S\n-            176..179 'obj': &dyn A\n-            190..192 '&S': &S\n-            191..192 'S': S\n-        \"#]],\n     );\n }\n \n #[test]\n fn coerce_unsize_generic() {\n     // FIXME: fix the type mismatches here\n-    check_infer_with_mismatches(\n+    check(\n         r#\"\n //- minicore: coerce_unsized\n struct Foo<T> { t: T };\n struct Bar<T>(Foo<T>);\n \n fn test() {\n     let _: &Foo<[usize]> = &Foo { t: [1, 2, 3] };\n+                                   //^^^^^^^^^ expected [usize], got [usize; 3]\n     let _: &Bar<[usize]> = &Bar(Foo { t: [1, 2, 3] });\n+                         //^^^^^^^^^^^^^^^^^^^^^^^^^^ expected &Bar<[usize]>, got &Bar<[i32; 3]>\n }\n \"#,\n-        expect![[r#\"\n-            58..166 '{     ... }); }': ()\n-            68..69 '_': &Foo<[usize]>\n-            87..108 '&Foo {..., 3] }': &Foo<[usize]>\n-            88..108 'Foo { ..., 3] }': Foo<[usize]>\n-            97..106 '[1, 2, 3]': [usize; 3]\n-            98..99 '1': usize\n-            101..102 '2': usize\n-            104..105 '3': usize\n-            118..119 '_': &Bar<[usize]>\n-            137..163 '&Bar(F... 3] })': &Bar<[i32; 3]>\n-            138..141 'Bar': Bar<[i32; 3]>(Foo<[i32; 3]>) -> Bar<[i32; 3]>\n-            138..163 'Bar(Fo... 3] })': Bar<[i32; 3]>\n-            142..162 'Foo { ..., 3] }': Foo<[i32; 3]>\n-            151..160 '[1, 2, 3]': [i32; 3]\n-            152..153 '1': i32\n-            155..156 '2': i32\n-            158..159 '3': i32\n-            97..106: expected [usize], got [usize; 3]\n-            137..163: expected &Bar<[usize]>, got &Bar<[i32; 3]>\n-        \"#]],\n     );\n }\n \n #[test]\n fn coerce_unsize_apit() {\n     // FIXME: #8984\n-    check_infer_with_mismatches(\n+    check(\n         r#\"\n //- minicore: coerce_unsized\n trait Foo {}\n \n fn test(f: impl Foo) {\n     let _: &dyn Foo = &f;\n+                    //^^ expected &dyn Foo, got &impl Foo\n }\n         \"#,\n-        expect![[r#\"\n-            22..23 'f': impl Foo\n-            35..64 '{     ... &f; }': ()\n-            45..46 '_': &dyn Foo\n-            59..61 '&f': &impl Foo\n-            60..61 'f': impl Foo\n-            59..61: expected &dyn Foo, got &impl Foo\n-        \"#]],\n     );\n }\n \n #[test]\n-fn infer_two_closures_lub() {\n+fn two_closures_lub() {\n     check_types(\n         r#\"\n fn foo(c: i32) {\n@@ -851,7 +416,7 @@ fn foo(c: i32) {\n }\n \n #[test]\n-fn infer_match_diverging_branch_1() {\n+fn match_diverging_branch_1() {\n     check_types(\n         r#\"\n enum Result<T> { Ok(T), Err }\n@@ -870,7 +435,7 @@ fn test() -> i32 {\n }\n \n #[test]\n-fn infer_match_diverging_branch_2() {\n+fn match_diverging_branch_2() {\n     // same as 1 except for order of branches\n     check_types(\n         r#\""}]}