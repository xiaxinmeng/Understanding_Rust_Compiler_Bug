{"sha": "74d079d566255e83ccfdb7da9494079a1cf2c086", "node_id": "C_kwDOAAsO6NoAKDc0ZDA3OWQ1NjYyNTVlODNjY2ZkYjdkYTk0OTQwNzlhMWNmMmMwODY", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-03-23T21:32:00Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2022-03-24T23:03:54Z"}, "message": "resolve: Stop passing unused spans and node ids to path resolution functions", "tree": {"sha": "2a2a2b39fb76a057b7b0a206c84994de46721a0c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2a2a2b39fb76a057b7b0a206c84994de46721a0c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/74d079d566255e83ccfdb7da9494079a1cf2c086", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/74d079d566255e83ccfdb7da9494079a1cf2c086", "html_url": "https://github.com/rust-lang/rust/commit/74d079d566255e83ccfdb7da9494079a1cf2c086", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/74d079d566255e83ccfdb7da9494079a1cf2c086/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "15a8b981e08bb942a439b680da93bad1dd18843e", "url": "https://api.github.com/repos/rust-lang/rust/commits/15a8b981e08bb942a439b680da93bad1dd18843e", "html_url": "https://github.com/rust-lang/rust/commit/15a8b981e08bb942a439b680da93bad1dd18843e"}], "stats": {"total": 457, "additions": 189, "deletions": 268}, "files": [{"sha": "c1ddff3d031433f2544ca1bbe97db121db4a65d9", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=74d079d566255e83ccfdb7da9494079a1cf2c086", "patch": "@@ -296,8 +296,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     &segments,\n                     Some(TypeNS),\n                     parent_scope,\n-                    path.span,\n-                    if speculative { CrateLint::No } else { CrateLint::SimplePath(id) },\n+                    if speculative { CrateLint::No } else { CrateLint::SimplePath(id, path.span) },\n                 ) {\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         let res = module.res().expect(\"visibility resolved to unnamed block\");\n@@ -1130,8 +1129,7 @@ impl<'a, 'b> BuildReducedGraphVisitor<'a, 'b> {\n                     ident,\n                     MacroNS,\n                     &self.parent_scope,\n-                    false,\n-                    ident.span,\n+                    None,\n                 );\n                 if let Ok(binding) = result {\n                     let import = macro_use_import(self, ident.span);"}, {"sha": "d407a31c0eaf53e8332821c58592a7ef4f4e8e60", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=74d079d566255e83ccfdb7da9494079a1cf2c086", "patch": "@@ -1076,9 +1076,8 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ScopeSet::All(ns, false),\n                 &parent_scope,\n+                None,\n                 false,\n-                false,\n-                ident.span,\n             ) {\n                 let desc = match binding.res() {\n                     Res::Def(DefKind::Macro(MacroKind::Bang), _) => {\n@@ -1405,10 +1404,10 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             _ => return None,\n         }\n \n-        self.make_missing_self_suggestion(span, path.clone(), parent_scope)\n-            .or_else(|| self.make_missing_crate_suggestion(span, path.clone(), parent_scope))\n-            .or_else(|| self.make_missing_super_suggestion(span, path.clone(), parent_scope))\n-            .or_else(|| self.make_external_crate_suggestion(span, path, parent_scope))\n+        self.make_missing_self_suggestion(path.clone(), parent_scope)\n+            .or_else(|| self.make_missing_crate_suggestion(path.clone(), parent_scope))\n+            .or_else(|| self.make_missing_super_suggestion(path.clone(), parent_scope))\n+            .or_else(|| self.make_external_crate_suggestion(path, parent_scope))\n     }\n \n     /// Suggest a missing `self::` if that resolves to an correct module.\n@@ -1420,13 +1419,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     fn make_missing_self_suggestion(\n         &mut self,\n-        span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `self` and check if that is valid.\n         path[0].ident.name = kw::SelfLower;\n-        let result = self.r.resolve_path(&path, None, parent_scope, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, CrateLint::No);\n         debug!(\"make_missing_self_suggestion: path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1440,13 +1438,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     fn make_missing_crate_suggestion(\n         &mut self,\n-        span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Crate;\n-        let result = self.r.resolve_path(&path, None, parent_scope, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, CrateLint::No);\n         debug!(\"make_missing_crate_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result {\n             Some((\n@@ -1472,13 +1469,12 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// ```\n     fn make_missing_super_suggestion(\n         &mut self,\n-        span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n         // Replace first ident with `crate` and check if that is valid.\n         path[0].ident.name = kw::Super;\n-        let result = self.r.resolve_path(&path, None, parent_scope, span, CrateLint::No);\n+        let result = self.r.resolve_path(&path, None, parent_scope, CrateLint::No);\n         debug!(\"make_missing_super_suggestion:  path={:?} result={:?}\", path, result);\n         if let PathResult::Module(..) = result { Some((path, Vec::new())) } else { None }\n     }\n@@ -1495,7 +1491,6 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n     /// name as the first part of path.\n     fn make_external_crate_suggestion(\n         &mut self,\n-        span: Span,\n         mut path: Vec<Segment>,\n         parent_scope: &ParentScope<'b>,\n     ) -> Option<(Vec<Segment>, Vec<String>)> {\n@@ -1513,7 +1508,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n         for name in extern_crate_names.into_iter() {\n             // Replace first ident with a crate name and check if that is valid.\n             path[0].ident.name = name;\n-            let result = self.r.resolve_path(&path, None, parent_scope, span, CrateLint::No);\n+            let result = self.r.resolve_path(&path, None, parent_scope, CrateLint::No);\n             debug!(\n                 \"make_external_crate_suggestion: name={:?} path={:?} result={:?}\",\n                 name, path, result"}, {"sha": "34bd39e711e905b18bb5b5078d33ff879ec44803", "filename": "compiler/rustc_resolve/src/imports.rs", "status": "modified", "additions": 26, "deletions": 58, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fimports.rs?ref=74d079d566255e83ccfdb7da9494079a1cf2c086", "patch": "@@ -175,8 +175,7 @@ impl<'a> Resolver<'a> {\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n+        record_used: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         self.resolve_ident_in_module_unadjusted_ext(\n             module,\n@@ -185,7 +184,6 @@ impl<'a> Resolver<'a> {\n             parent_scope,\n             false,\n             record_used,\n-            path_span,\n         )\n         .map_err(|(determinacy, _)| determinacy)\n     }\n@@ -199,8 +197,7 @@ impl<'a> Resolver<'a> {\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n         restricted_shadowing: bool,\n-        record_used: bool,\n-        path_span: Span,\n+        record_used: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let module = match module {\n             ModuleOrUniformRoot::Module(module) => module,\n@@ -211,16 +208,16 @@ impl<'a> Resolver<'a> {\n                     ScopeSet::AbsolutePath(ns),\n                     parent_scope,\n                     record_used,\n-                    record_used,\n-                    path_span,\n+                    record_used.is_some(),\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n             ModuleOrUniformRoot::ExternPrelude => {\n                 assert!(!restricted_shadowing);\n                 return if ns != TypeNS {\n                     Err((Determined, Weak::No))\n-                } else if let Some(binding) = self.extern_prelude_get(ident, !record_used) {\n+                } else if let Some(binding) = self.extern_prelude_get(ident, record_used.is_none())\n+                {\n                     Ok(binding)\n                 } else if !self.graph_root.unexpanded_invocations.borrow().is_empty() {\n                     // Macro-expanded `extern crate` items can add names to extern prelude.\n@@ -251,8 +248,7 @@ impl<'a> Resolver<'a> {\n                     scopes,\n                     parent_scope,\n                     record_used,\n-                    record_used,\n-                    path_span,\n+                    record_used.is_some(),\n                 );\n                 return binding.map_err(|determinacy| (determinacy, Weak::No));\n             }\n@@ -262,7 +258,7 @@ impl<'a> Resolver<'a> {\n         let resolution =\n             self.resolution(module, key).try_borrow_mut().map_err(|_| (Determined, Weak::No))?; // This happens when there is a cycle of imports.\n \n-        if let Some(binding) = resolution.binding {\n+        if let Some(binding) = resolution.binding && let Some(path_span) = record_used {\n             if !restricted_shadowing && binding.expansion != LocalExpnId::ROOT {\n                 if let NameBindingKind::Res(_, true) = binding.kind {\n                     self.macro_expanded_macro_export_errors.insert((path_span, binding.span));\n@@ -280,7 +276,7 @@ impl<'a> Resolver<'a> {\n             if usable { Ok(binding) } else { Err((Determined, Weak::No)) }\n         };\n \n-        if record_used {\n+        if let Some(path_span) = record_used {\n             return resolution\n                 .binding\n                 .and_then(|binding| {\n@@ -353,14 +349,8 @@ impl<'a> Resolver<'a> {\n             let ImportKind::Single { source: ident, .. } = single_import.kind else {\n                 unreachable!();\n             };\n-            match self.resolve_ident_in_module(\n-                module,\n-                ident,\n-                ns,\n-                &single_import.parent_scope,\n-                false,\n-                path_span,\n-            ) {\n+            match self.resolve_ident_in_module(module, ident, ns, &single_import.parent_scope, None)\n+            {\n                 Err(Determined) => continue,\n                 Ok(binding)\n                     if !self.is_accessible_from(binding.vis, single_import.parent_scope.module) =>\n@@ -434,8 +424,7 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ns,\n                 adjusted_parent_scope,\n-                false,\n-                path_span,\n+                None,\n             );\n \n             match result {\n@@ -783,13 +772,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             // For better failure detection, pretend that the import will\n             // not define any names while resolving its module path.\n             let orig_vis = import.vis.replace(ty::Visibility::Invisible);\n-            let path_res = self.r.resolve_path(\n-                &import.module_path,\n-                None,\n-                &import.parent_scope,\n-                import.span,\n-                CrateLint::No,\n-            );\n+            let path_res =\n+                self.r.resolve_path(&import.module_path, None, &import.parent_scope, CrateLint::No);\n             import.vis.set(orig_vis);\n \n             match path_res {\n@@ -828,8 +812,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         source,\n                         ns,\n                         &import.parent_scope,\n-                        false,\n-                        import.span,\n+                        None,\n                     );\n                     import.vis.set(orig_vis);\n                     source_bindings[ns].set(binding);\n@@ -882,15 +865,13 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             _ => None,\n         };\n         let prev_ambiguity_errors_len = self.r.ambiguity_errors.len();\n-        let crate_lint =\n-            CrateLint::UsePath { root_id: import.root_id, root_span: import.root_span };\n-        let path_res = self.r.resolve_path(\n-            &import.module_path,\n-            None,\n-            &import.parent_scope,\n-            import.span,\n-            crate_lint,\n-        );\n+        let crate_lint = CrateLint::UsePath {\n+            root_id: import.root_id,\n+            root_span: import.root_span,\n+            path_span: import.span,\n+        };\n+        let path_res =\n+            self.r.resolve_path(&import.module_path, None, &import.parent_scope, crate_lint);\n         let no_ambiguity = self.r.ambiguity_errors.len() == prev_ambiguity_errors_len;\n         if let Some(orig_unusable_binding) = orig_unusable_binding {\n             self.r.unusable_binding = orig_unusable_binding;\n@@ -977,12 +958,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     // 2 segments, so the `resolve_path` above won't trigger it.\n                     let mut full_path = import.module_path.clone();\n                     full_path.push(Segment::from_ident(Ident::empty()));\n-                    self.r.lint_if_path_starts_with_module(\n-                        crate_lint,\n-                        &full_path,\n-                        import.span,\n-                        None,\n-                    );\n+                    self.r.lint_if_path_starts_with_module(crate_lint, &full_path, None);\n                 }\n \n                 if let ModuleOrUniformRoot::Module(module) = module {\n@@ -1020,8 +996,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     ident,\n                     ns,\n                     &import.parent_scope,\n-                    true,\n-                    import.span,\n+                    Some(import.span),\n                 );\n                 this.last_import_segment = orig_last_import_segment;\n                 this.unusable_binding = orig_unusable_binding;\n@@ -1082,8 +1057,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                         ident,\n                         ns,\n                         &import.parent_scope,\n-                        true,\n-                        import.span,\n+                        Some(import.span),\n                     );\n                     if binding.is_ok() {\n                         all_ns_failed = false;\n@@ -1249,12 +1223,7 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n             full_path.push(Segment::from_ident(ident));\n             self.r.per_ns(|this, ns| {\n                 if let Ok(binding) = source_bindings[ns].get() {\n-                    this.lint_if_path_starts_with_module(\n-                        crate_lint,\n-                        &full_path,\n-                        import.span,\n-                        Some(binding),\n-                    );\n+                    this.lint_if_path_starts_with_module(crate_lint, &full_path, Some(binding));\n                 }\n             });\n         }\n@@ -1310,9 +1279,8 @@ impl<'a, 'b> ImportResolver<'a, 'b> {\n                     target,\n                     ScopeSet::All(ns, false),\n                     &import.parent_scope,\n+                    None,\n                     false,\n-                    false,\n-                    import.span,\n                 ) {\n                     Ok(other_binding) => {\n                         is_redundant[ns] = Some("}, {"sha": "995a48be407b13250dd398ab634287363a49cf15", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 47, "deletions": 52, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=74d079d566255e83ccfdb7da9494079a1cf2c086", "patch": "@@ -483,7 +483,11 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             TyKind::ImplicitSelf => {\n                 let self_ty = Ident::with_dummy_span(kw::SelfUpper);\n                 let res = self\n-                    .resolve_ident_in_lexical_scope(self_ty, TypeNS, Some(ty.id), ty.span)\n+                    .resolve_ident_in_lexical_scope(\n+                        self_ty,\n+                        TypeNS,\n+                        CrateLint::SimplePath(ty.id, ty.span),\n+                    )\n                     .map_or(Res::Err, |d| d.res());\n                 self.r.record_partial_res(ty.id, PartialRes::new(res));\n             }\n@@ -675,8 +679,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                             self.resolve_ident_in_lexical_scope(\n                                 path.segments[0].ident,\n                                 ns,\n-                                None,\n-                                path.span,\n+                                CrateLint::No,\n                             )\n                             .is_some()\n                         };\n@@ -751,15 +754,13 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         ident: Ident,\n         ns: Namespace,\n-        record_used_id: Option<NodeId>,\n-        path_span: Span,\n+        crate_lint: CrateLint,\n     ) -> Option<LexicalScopeBinding<'a>> {\n         self.r.resolve_ident_in_lexical_scope(\n             ident,\n             ns,\n             &self.parent_scope,\n-            record_used_id,\n-            path_span,\n+            crate_lint,\n             &self.ribs[ns],\n         )\n     }\n@@ -768,14 +769,12 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n-        path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n         self.r.resolve_path_with_ribs(\n             path,\n             opt_ns,\n             &self.parent_scope,\n-            path_span,\n             crate_lint,\n             Some(&self.ribs),\n         )\n@@ -941,15 +940,15 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n             for &ns in nss {\n-                match self.resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span) {\n+                match self.resolve_ident_in_lexical_scope(ident, ns, CrateLint::No) {\n                     Some(LexicalScopeBinding::Res(..)) => {\n                         report_error(self, ns);\n                     }\n                     Some(LexicalScopeBinding::Item(binding)) => {\n                         let orig_unusable_binding =\n                             replace(&mut self.r.unusable_binding, Some(binding));\n-                        if let Some(LexicalScopeBinding::Res(..)) = self\n-                            .resolve_ident_in_lexical_scope(ident, ns, None, use_tree.prefix.span)\n+                        if let Some(LexicalScopeBinding::Res(..)) =\n+                            self.resolve_ident_in_lexical_scope(ident, ns, CrateLint::No)\n                         {\n                             report_error(self, ns);\n                         }\n@@ -1244,12 +1243,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         if let Some(trait_ref) = opt_trait_ref {\n             let path: Vec<_> = Segment::from_path(&trait_ref.path);\n             let res = self.smart_resolve_path_fragment(\n-                trait_ref.ref_id,\n                 None,\n                 &path,\n-                trait_ref.path.span,\n                 PathSource::Trait(AliasPossibility::No),\n-                CrateLint::SimplePath(trait_ref.ref_id),\n+                CrateLint::SimplePath(trait_ref.ref_id, trait_ref.path.span),\n             );\n             if let Some(def_id) = res.base_res().opt_def_id() {\n                 new_id = Some(def_id);\n@@ -1691,7 +1688,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     // then fall back to a fresh binding.\n                     let has_sub = sub.is_some();\n                     let res = self\n-                        .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n+                        .try_resolve_as_non_binding(pat_src, bmode, ident, has_sub)\n                         .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n                     self.r.record_pat_span(pat.id, pat.span);\n@@ -1802,7 +1799,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     fn try_resolve_as_non_binding(\n         &mut self,\n         pat_src: PatternSource,\n-        pat: &Pat,\n         bm: BindingMode,\n         ident: Ident,\n         has_sub: bool,\n@@ -1812,7 +1808,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         // also be interpreted as a path to e.g. a constant, variant, etc.\n         let is_syntactic_ambiguity = !has_sub && bm == BindingMode::ByValue(Mutability::Not);\n \n-        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, pat.span)?;\n+        let ls_binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, CrateLint::No)?;\n         let (res, binding) = match ls_binding {\n             LexicalScopeBinding::Item(binding)\n                 if is_syntactic_ambiguity && binding.is_ambiguity() =>\n@@ -1901,35 +1897,34 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         source: PathSource<'ast>,\n     ) {\n         self.smart_resolve_path_fragment(\n-            id,\n             qself,\n             &Segment::from_path(path),\n-            path.span,\n             source,\n-            CrateLint::SimplePath(id),\n+            CrateLint::SimplePath(id, path.span),\n         );\n     }\n \n     fn smart_resolve_path_fragment(\n         &mut self,\n-        id: NodeId,\n         qself: Option<&QSelf>,\n         path: &[Segment],\n-        span: Span,\n         source: PathSource<'ast>,\n         crate_lint: CrateLint,\n     ) -> PartialRes {\n         tracing::debug!(\n-            \"smart_resolve_path_fragment(id={:?}, qself={:?}, path={:?})\",\n-            id,\n+            \"smart_resolve_path_fragment(qself={:?}, path={:?}, crate_lint={:?})\",\n             qself,\n-            path\n+            path,\n+            crate_lint,\n         );\n         let ns = source.namespace();\n \n+        let (id, path_span) =\n+            crate_lint.node_id_and_path_span().expect(\"unexpected speculative resolution\");\n         let report_errors = |this: &mut Self, res: Option<Res>| {\n             if this.should_report_errs() {\n-                let (err, candidates) = this.smart_resolve_report_errors(path, span, source, res);\n+                let (err, candidates) =\n+                    this.smart_resolve_report_errors(path, path_span, source, res);\n \n                 let def_id = this.parent_scope.module.nearest_parent_mod();\n                 let instead = res.is_some();\n@@ -1967,7 +1962,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n \n             let (mut err, candidates) =\n-                this.smart_resolve_report_errors(path, span, PathSource::Type, None);\n+                this.smart_resolve_report_errors(path, path_span, PathSource::Type, None);\n \n             if candidates.is_empty() {\n                 err.cancel();\n@@ -2015,13 +2010,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             None\n         };\n \n-        assert_ne!(crate_lint, CrateLint::No);\n         let partial_res = match self.resolve_qpath_anywhere(\n-            id,\n             qself,\n             path,\n             ns,\n-            span,\n+            path_span,\n             source.defer_to_typeck(),\n             crate_lint,\n         ) {\n@@ -2050,14 +2043,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     std_path.push(Segment::from_ident(Ident::with_dummy_span(sym::std)));\n                     std_path.extend(path);\n                     if let PathResult::Module(_) | PathResult::NonModule(_) =\n-                        self.resolve_path(&std_path, Some(ns), span, CrateLint::No)\n+                        self.resolve_path(&std_path, Some(ns), CrateLint::No)\n                     {\n                         // Check if we wrote `str::from_utf8` instead of `std::str::from_utf8`\n                         let item_span =\n-                            path.iter().last().map_or(span, |segment| segment.ident.span);\n+                            path.iter().last().map_or(path_span, |segment| segment.ident.span);\n \n-                        self.r.confused_type_with_std_module.insert(item_span, span);\n-                        self.r.confused_type_with_std_module.insert(span, span);\n+                        self.r.confused_type_with_std_module.insert(item_span, path_span);\n+                        self.r.confused_type_with_std_module.insert(path_span, path_span);\n                     }\n                 }\n \n@@ -2083,19 +2076,18 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         partial_res\n     }\n \n-    fn self_type_is_available(&mut self, span: Span) -> bool {\n+    fn self_type_is_available(&mut self) -> bool {\n         let binding = self.resolve_ident_in_lexical_scope(\n             Ident::with_dummy_span(kw::SelfUpper),\n             TypeNS,\n-            None,\n-            span,\n+            CrateLint::No,\n         );\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n-    fn self_value_is_available(&mut self, self_span: Span, path_span: Span) -> bool {\n+    fn self_value_is_available(&mut self, self_span: Span) -> bool {\n         let ident = Ident::new(kw::SelfLower, self_span);\n-        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, None, path_span);\n+        let binding = self.resolve_ident_in_lexical_scope(ident, ValueNS, CrateLint::No);\n         if let Some(LexicalScopeBinding::Res(res)) = binding { res != Res::Err } else { false }\n     }\n \n@@ -2117,7 +2109,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     // Resolve in alternative namespaces if resolution in the primary namespace fails.\n     fn resolve_qpath_anywhere(\n         &mut self,\n-        id: NodeId,\n         qself: Option<&QSelf>,\n         path: &[Segment],\n         primary_ns: Namespace,\n@@ -2129,7 +2120,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n \n         for (i, &ns) in [primary_ns, TypeNS, ValueNS].iter().enumerate() {\n             if i == 0 || ns != primary_ns {\n-                match self.resolve_qpath(id, qself, path, ns, span, crate_lint)? {\n+                match self.resolve_qpath(qself, path, ns, crate_lint)? {\n                     Some(partial_res)\n                         if partial_res.unresolved_segments() == 0 || defer_to_typeck =>\n                     {\n@@ -2162,16 +2153,14 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     /// Handles paths that may refer to associated items.\n     fn resolve_qpath(\n         &mut self,\n-        id: NodeId,\n         qself: Option<&QSelf>,\n         path: &[Segment],\n         ns: Namespace,\n-        span: Span,\n         crate_lint: CrateLint,\n     ) -> Result<Option<PartialRes>, Spanned<ResolutionError<'a>>> {\n         debug!(\n-            \"resolve_qpath(id={:?}, qself={:?}, path={:?}, ns={:?}, span={:?})\",\n-            id, qself, path, ns, span,\n+            \"resolve_qpath(qself={:?}, path={:?}, ns={:?}, crate_lint={:?})\",\n+            qself, path, ns, crate_lint,\n         );\n \n         if let Some(qself) = qself {\n@@ -2201,12 +2190,17 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             // contains the full span (the `CrateLint::QPathTrait`).\n             let ns = if qself.position + 1 == path.len() { ns } else { TypeNS };\n             let partial_res = self.smart_resolve_path_fragment(\n-                id,\n                 None,\n                 &path[..=qself.position],\n-                span,\n                 PathSource::TraitItem(ns),\n-                CrateLint::QPathTrait { qpath_id: id, qpath_span: qself.path_span },\n+                crate_lint.node_id_and_path_span().map_or(\n+                    CrateLint::No,\n+                    |(qpath_id, path_span)| CrateLint::QPathTrait {\n+                        qpath_id,\n+                        qpath_span: qself.path_span,\n+                        path_span,\n+                    },\n+                ),\n             );\n \n             // The remaining segments (the `C` in our example) will\n@@ -2218,7 +2212,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             )));\n         }\n \n-        let result = match self.resolve_path(&path, Some(ns), span, crate_lint) {\n+        let result = match self.resolve_path(&path, Some(ns), crate_lint) {\n             PathResult::NonModule(path_res) => path_res,\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) if !module.is_normal() => {\n                 PartialRes::new(module.res().unwrap())\n@@ -2256,9 +2250,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             && result.base_res() != Res::Err\n             && path[0].ident.name != kw::PathRoot\n             && path[0].ident.name != kw::DollarCrate\n+            && let Some((id, path_span)) = crate_lint.node_id_and_path_span()\n         {\n             let unqualified_result = {\n-                match self.resolve_path(&[*path.last().unwrap()], Some(ns), span, CrateLint::No) {\n+                match self.resolve_path(&[*path.last().unwrap()], Some(ns), CrateLint::No) {\n                     PathResult::NonModule(path_res) => path_res.base_res(),\n                     PathResult::Module(ModuleOrUniformRoot::Module(module)) => {\n                         module.res().unwrap()\n@@ -2268,7 +2263,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             };\n             if result.base_res() == unqualified_result {\n                 let lint = lint::builtin::UNUSED_QUALIFICATIONS;\n-                self.r.lint_buffer.buffer_lint(lint, id, span, \"unnecessary qualification\")\n+                self.r.lint_buffer.buffer_lint(lint, id, path_span, \"unnecessary qualification\")\n             }\n         }\n "}, {"sha": "fc04ce6dfb0a536e1c8b1246a308a06ae8a31402", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=74d079d566255e83ccfdb7da9494079a1cf2c086", "patch": "@@ -187,12 +187,11 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 (String::new(), \"the crate root\".to_string())\n             } else {\n                 let mod_path = &path[..path.len() - 1];\n-                let mod_prefix =\n-                    match self.resolve_path(mod_path, Some(TypeNS), span, CrateLint::No) {\n-                        PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n-                        _ => None,\n-                    }\n-                    .map_or_else(String::new, |res| format!(\"{} \", res.descr()));\n+                let mod_prefix = match self.resolve_path(mod_path, Some(TypeNS), CrateLint::No) {\n+                    PathResult::Module(ModuleOrUniformRoot::Module(module)) => module.res(),\n+                    _ => None,\n+                }\n+                .map_or_else(String::new, |res| format!(\"{} \", res.descr()));\n                 (mod_prefix, format!(\"`{}`\", Segment::names_to_string(mod_path)))\n             };\n             (\n@@ -232,7 +231,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             _ => {}\n         }\n \n-        let is_assoc_fn = self.self_type_is_available(span);\n+        let is_assoc_fn = self.self_type_is_available();\n         // Emit help message for fake-self from other languages (e.g., `this` in Javascript).\n         if [\"this\", \"my\"].contains(&item_str.as_str()) && is_assoc_fn {\n             err.span_suggestion_short(\n@@ -241,7 +240,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 \"self\".to_string(),\n                 Applicability::MaybeIncorrect,\n             );\n-            if !self.self_value_is_available(path[0].ident.span, span) {\n+            if !self.self_value_is_available(path[0].ident.span) {\n                 if let Some((FnKind::Fn(_, _, sig, ..), fn_span)) =\n                     &self.diagnostic_metadata.current_function\n                 {\n@@ -402,9 +401,9 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 );\n             }\n         }\n-        if path.len() == 1 && self.self_type_is_available(span) {\n+        if path.len() == 1 && self.self_type_is_available() {\n             if let Some(candidate) = self.lookup_assoc_candidate(ident, ns, is_expected) {\n-                let self_is_available = self.self_value_is_available(path[0].ident.span, span);\n+                let self_is_available = self.self_value_is_available(path[0].ident.span);\n                 match candidate {\n                     AssocSuggestion::Field => {\n                         if self_is_available {\n@@ -461,7 +460,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         }\n \n         // Try Levenshtein algorithm.\n-        let typo_sugg = self.lookup_typo_candidate(path, ns, is_expected, span);\n+        let typo_sugg = self.lookup_typo_candidate(path, ns, is_expected);\n         // Try context-dependent help if relaxed lookup didn't work.\n         if let Some(res) = res {\n             if self.smart_resolve_context_dependent_help(\n@@ -562,7 +561,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 }\n \n                 // If the trait has a single item (which wasn't matched by Levenshtein), suggest it\n-                let suggestion = self.get_single_associated_item(&path, span, &source, is_expected);\n+                let suggestion = self.get_single_associated_item(&path, &source, is_expected);\n                 self.r.add_typo_suggestion(&mut err, suggestion, ident_span);\n             }\n             if fallback {\n@@ -641,14 +640,13 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n     fn get_single_associated_item(\n         &mut self,\n         path: &[Segment],\n-        span: Span,\n         source: &PathSource<'_>,\n         filter_fn: &impl Fn(Res) -> bool,\n     ) -> Option<TypoSuggestion> {\n         if let crate::PathSource::TraitItem(_) = source {\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                self.resolve_path(mod_path, None, span, CrateLint::No)\n+                self.resolve_path(mod_path, None, CrateLint::No)\n             {\n                 let resolutions = self.r.resolutions(module).borrow();\n                 let targets: Vec<_> =\n@@ -699,7 +697,6 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         {\n             // use this to verify that ident is a type param.\n             let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n-                bounded_ty.id,\n                 None,\n                 &Segment::from_path(path),\n                 Namespace::TypeNS,\n@@ -724,7 +721,6 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         if let ast::TyKind::Path(None, type_param_path) = &ty.peel_refs().kind {\n             // Confirm that the `SelfTy` is a type parameter.\n             let Ok(Some(partial_res)) = self.resolve_qpath_anywhere(\n-                bounded_ty.id,\n                 None,\n                 &Segment::from_path(type_param_path),\n                 Namespace::TypeNS,\n@@ -1292,8 +1288,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n                 ident,\n                 ns,\n                 &self.parent_scope,\n-                false,\n-                module.span,\n+                None,\n             ) {\n                 let res = binding.res();\n                 if filter_fn(res) {\n@@ -1323,7 +1318,6 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n         path: &[Segment],\n         ns: Namespace,\n         filter_fn: &impl Fn(Res) -> bool,\n-        span: Span,\n     ) -> Option<TypoSuggestion> {\n         let mut names = Vec::new();\n         if path.len() == 1 {\n@@ -1384,7 +1378,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n             // Search in module.\n             let mod_path = &path[..path.len() - 1];\n             if let PathResult::Module(ModuleOrUniformRoot::Module(module)) =\n-                self.resolve_path(mod_path, Some(TypeNS), span, CrateLint::No)\n+                self.resolve_path(mod_path, Some(TypeNS), CrateLint::No)\n             {\n                 self.r.add_module_candidates(module, &mut names, &filter_fn);\n             }"}, {"sha": "a4fe7676fc459dbcab52723f9d9ccc26daa20336", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 72, "deletions": 89, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=74d079d566255e83ccfdb7da9494079a1cf2c086", "patch": "@@ -13,6 +13,7 @@\n #![feature(drain_filter)]\n #![feature(bool_to_option)]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_chains)]\n #![feature(let_else)]\n #![feature(never_type)]\n #![feature(nll)]\n@@ -54,9 +55,9 @@ use rustc_index::vec::IndexVec;\n use rustc_metadata::creader::{CStore, CrateLoader};\n use rustc_middle::metadata::ModChild;\n use rustc_middle::middle::privacy::AccessLevels;\n-use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n+use rustc_middle::{bug, span_bug};\n use rustc_query_system::ich::StableHashingContext;\n use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n use rustc_session::lint;\n@@ -1949,8 +1950,7 @@ impl<'a> Resolver<'a> {\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used_id: Option<NodeId>,\n-        path_span: Span,\n+        crate_lint: CrateLint,\n         ribs: &[Rib<'a>],\n     ) -> Option<LexicalScopeBinding<'a>> {\n         assert!(ns == TypeNS || ns == ValueNS);\n@@ -1972,7 +1972,7 @@ impl<'a> Resolver<'a> {\n         let normalized_ident = Ident { span: normalized_span, ..ident };\n \n         // Walk backwards up the ribs in scope.\n-        let record_used = record_used_id.is_some();\n+        let record_used = crate_lint.path_span();\n         let mut module = self.graph_root;\n         for i in (0..ribs.len()).rev() {\n             debug!(\"walk rib\\n{:?}\", ribs[i].bindings);\n@@ -1987,7 +1987,6 @@ impl<'a> Resolver<'a> {\n                     rib_ident,\n                     *res,\n                     record_used,\n-                    path_span,\n                     *original_rib_ident_def,\n                     ribs,\n                 )));\n@@ -2015,7 +2014,6 @@ impl<'a> Resolver<'a> {\n                 ns,\n                 parent_scope,\n                 record_used,\n-                path_span,\n             );\n             if let Ok(binding) = item {\n                 // The ident resolves to an item.\n@@ -2024,11 +2022,10 @@ impl<'a> Resolver<'a> {\n         }\n         self.early_resolve_ident_in_lexical_scope(\n             orig_ident,\n-            ScopeSet::Late(ns, module, record_used_id),\n+            ScopeSet::Late(ns, module, crate_lint.node_id()),\n             parent_scope,\n             record_used,\n-            record_used,\n-            path_span,\n+            record_used.is_some(),\n         )\n         .ok()\n         .map(LexicalScopeBinding::Item)\n@@ -2088,10 +2085,9 @@ impl<'a> Resolver<'a> {\n         ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n+        record_used: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n-        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, record_used, path_span)\n+        self.resolve_ident_in_module_ext(module, ident, ns, parent_scope, record_used)\n             .map_err(|(determinacy, _)| determinacy)\n     }\n \n@@ -2101,8 +2097,7 @@ impl<'a> Resolver<'a> {\n         mut ident: Ident,\n         ns: Namespace,\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n-        path_span: Span,\n+        record_used: Option<Span>,\n     ) -> Result<&'a NameBinding<'a>, (Determinacy, Weak)> {\n         let tmp_parent_scope;\n         let mut adjusted_parent_scope = parent_scope;\n@@ -2128,7 +2123,6 @@ impl<'a> Resolver<'a> {\n             adjusted_parent_scope,\n             false,\n             record_used,\n-            path_span,\n         )\n     }\n \n@@ -2219,35 +2213,30 @@ impl<'a> Resolver<'a> {\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        path_span: Span,\n         crate_lint: CrateLint,\n     ) -> PathResult<'a> {\n-        self.resolve_path_with_ribs(path, opt_ns, parent_scope, path_span, crate_lint, None)\n+        self.resolve_path_with_ribs(path, opt_ns, parent_scope, crate_lint, None)\n     }\n \n     fn resolve_path_with_ribs(\n         &mut self,\n         path: &[Segment],\n         opt_ns: Option<Namespace>, // `None` indicates a module path in import\n         parent_scope: &ParentScope<'a>,\n-        path_span: Span,\n         crate_lint: CrateLint,\n         ribs: Option<&PerNS<Vec<Rib<'a>>>>,\n     ) -> PathResult<'a> {\n-        let record_used = crate_lint != CrateLint::No;\n+        debug!(\"resolve_path(path={:?}, opt_ns={:?}, crate_lint={:?})\", path, opt_ns, crate_lint);\n+\n+        let record_used = crate_lint.path_span();\n         let mut module = None;\n         let mut allow_super = true;\n         let mut second_binding = None;\n \n-        debug!(\n-            \"resolve_path(path={:?}, opt_ns={:?}, path_span={:?}, crate_lint={:?})\",\n-            path, opt_ns, path_span, crate_lint,\n-        );\n-\n         for (i, &Segment { ident, id, has_generic_args: _ }) in path.iter().enumerate() {\n             debug!(\"resolve_path ident {} {:?} {:?}\", i, ident, id);\n             let record_segment_res = |this: &mut Self, res| {\n-                if record_used {\n+                if record_used.is_some() {\n                     if let Some(id) = id {\n                         if !this.partial_res_map.contains_key(&id) {\n                             assert!(id != ast::DUMMY_NODE_ID, \"Trying to resolve dummy id\");\n@@ -2281,7 +2270,7 @@ impl<'a> Resolver<'a> {\n                             continue;\n                         }\n                     }\n-                    return PathResult::failed(ident.span, false, record_used, || {\n+                    return PathResult::failed(ident.span, false, record_used.is_some(), || {\n                         (\"there are too many leading `super` keywords\".to_string(), None)\n                     });\n                 }\n@@ -2312,7 +2301,7 @@ impl<'a> Resolver<'a> {\n \n             // Report special messages for path segment keywords in wrong positions.\n             if ident.is_path_segment_keyword() && i != 0 {\n-                return PathResult::failed(ident.span, false, record_used, || {\n+                return PathResult::failed(ident.span, false, record_used.is_some(), || {\n                     let name_str = if name == kw::PathRoot {\n                         \"crate root\".to_string()\n                     } else {\n@@ -2333,31 +2322,22 @@ impl<'a> Resolver<'a> {\n             }\n             let find_binding_in_ns = |this: &mut Self, ns| {\n                 let binding = if let Some(module) = module {\n-                    this.resolve_ident_in_module(\n-                        module,\n-                        ident,\n-                        ns,\n-                        parent_scope,\n-                        record_used,\n-                        path_span,\n-                    )\n+                    this.resolve_ident_in_module(module, ident, ns, parent_scope, record_used)\n                 } else if ribs.is_none() || opt_ns.is_none() || opt_ns == Some(MacroNS) {\n                     let scopes = ScopeSet::All(ns, opt_ns.is_none());\n                     this.early_resolve_ident_in_lexical_scope(\n                         ident,\n                         scopes,\n                         parent_scope,\n                         record_used,\n-                        record_used,\n-                        path_span,\n+                        record_used.is_some(),\n                     )\n                 } else {\n                     match this.resolve_ident_in_lexical_scope(\n                         ident,\n                         ns,\n                         parent_scope,\n-                        crate_lint.node_id(),\n-                        path_span,\n+                        crate_lint,\n                         &ribs.unwrap()[ns],\n                     ) {\n                         // we found a locally-imported or available item/module\n@@ -2371,7 +2351,7 @@ impl<'a> Resolver<'a> {\n                                 PartialRes::with_unresolved_segments(res, path.len() - 1),\n                             ));\n                         }\n-                        _ => Err(Determinacy::determined(record_used)),\n+                        _ => Err(Determinacy::determined(record_used.is_some())),\n                     }\n                 };\n                 FindBindingResult::Binding(binding)\n@@ -2405,25 +2385,25 @@ impl<'a> Resolver<'a> {\n                     } else if res == Res::Err {\n                         return PathResult::NonModule(PartialRes::new(Res::Err));\n                     } else if opt_ns.is_some() && (is_last || maybe_assoc) {\n-                        self.lint_if_path_starts_with_module(\n-                            crate_lint,\n-                            path,\n-                            path_span,\n-                            second_binding,\n-                        );\n+                        self.lint_if_path_starts_with_module(crate_lint, path, second_binding);\n                         return PathResult::NonModule(PartialRes::with_unresolved_segments(\n                             res,\n                             path.len() - i - 1,\n                         ));\n                     } else {\n-                        return PathResult::failed(ident.span, is_last, record_used, || {\n-                            let label = format!(\n-                                \"`{ident}` is {} {}, not a module\",\n-                                res.article(),\n-                                res.descr()\n-                            );\n-                            (label, None)\n-                        });\n+                        return PathResult::failed(\n+                            ident.span,\n+                            is_last,\n+                            record_used.is_some(),\n+                            || {\n+                                let label = format!(\n+                                    \"`{ident}` is {} {}, not a module\",\n+                                    res.article(),\n+                                    res.descr()\n+                                );\n+                                (label, None)\n+                            },\n+                        );\n                     }\n                 }\n                 Err(Undetermined) => return PathResult::Indeterminate,\n@@ -2437,7 +2417,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     }\n \n-                    return PathResult::failed(ident.span, is_last, record_used, || {\n+                    return PathResult::failed(ident.span, is_last, record_used.is_some(), || {\n                         let module_res = match module {\n                             Some(ModuleOrUniformRoot::Module(module)) => module.res(),\n                             _ => None,\n@@ -2477,8 +2457,7 @@ impl<'a> Resolver<'a> {\n                                         ident,\n                                         ValueNS,\n                                         parent_scope,\n-                                        None,\n-                                        path_span,\n+                                        CrateLint::No,\n                                         &ribs.unwrap()[ValueNS],\n                                     ) {\n                                         // Name matches a local variable. For example:\n@@ -2603,27 +2582,26 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        self.lint_if_path_starts_with_module(crate_lint, path, path_span, second_binding);\n+        self.lint_if_path_starts_with_module(crate_lint, path, second_binding);\n \n         PathResult::Module(match module {\n             Some(module) => module,\n             None if path.is_empty() => ModuleOrUniformRoot::CurrentScope,\n-            _ => span_bug!(path_span, \"resolve_path: non-empty path `{:?}` has no module\", path),\n+            _ => bug!(\"resolve_path: non-empty path `{:?}` has no module\", path),\n         })\n     }\n \n     fn lint_if_path_starts_with_module(\n         &mut self,\n         crate_lint: CrateLint,\n         path: &[Segment],\n-        path_span: Span,\n         second_binding: Option<&NameBinding<'_>>,\n     ) {\n         let (diag_id, diag_span) = match crate_lint {\n             CrateLint::No => return,\n-            CrateLint::SimplePath(id) => (id, path_span),\n-            CrateLint::UsePath { root_id, root_span } => (root_id, root_span),\n-            CrateLint::QPathTrait { qpath_id, qpath_span } => (qpath_id, qpath_span),\n+            CrateLint::SimplePath(id, path_span) => (id, path_span),\n+            CrateLint::UsePath { root_id, root_span, .. } => (root_id, root_span),\n+            CrateLint::QPathTrait { qpath_id, qpath_span, .. } => (qpath_id, qpath_span),\n         };\n \n         let first_name = match path.get(0) {\n@@ -2678,8 +2656,7 @@ impl<'a> Resolver<'a> {\n         rib_index: usize,\n         rib_ident: Ident,\n         mut res: Res,\n-        record_used: bool,\n-        span: Span,\n+        record_used: Option<Span>,\n         original_rib_ident_def: Ident,\n         all_ribs: &[Rib<'a>],\n     ) -> Res {\n@@ -2689,7 +2666,7 @@ impl<'a> Resolver<'a> {\n \n         // An invalid forward use of a generic parameter from a previous default.\n         if let ForwardGenericParamBanRibKind = all_ribs[rib_index].kind {\n-            if record_used {\n+            if let Some(span) = record_used {\n                 let res_error = if rib_ident.name == kw::SelfUpper {\n                     ResolutionError::SelfInGenericParamDefault\n                 } else {\n@@ -2719,17 +2696,17 @@ impl<'a> Resolver<'a> {\n                             // This was an attempt to access an upvar inside a\n                             // named function item. This is not allowed, so we\n                             // report an error.\n-                            if record_used {\n+                            if let Some(span) = record_used {\n                                 // We don't immediately trigger a resolve error, because\n                                 // we want certain other resolution errors (namely those\n                                 // emitted for `ConstantItemRibKind` below) to take\n                                 // precedence.\n-                                res_err = Some(CannotCaptureDynamicEnvironmentInFnItem);\n+                                res_err = Some((span, CannotCaptureDynamicEnvironmentInFnItem));\n                             }\n                         }\n                         ConstantItemRibKind(_, item) => {\n                             // Still doesn't deal with upvars\n-                            if record_used {\n+                            if let Some(span) = record_used {\n                                 let (span, resolution_error) =\n                                     if let Some((ident, constant_item_kind)) = item {\n                                         let kind_str = match constant_item_kind {\n@@ -2757,14 +2734,14 @@ impl<'a> Resolver<'a> {\n                             return Res::Err;\n                         }\n                         ConstParamTyRibKind => {\n-                            if record_used {\n+                            if let Some(span) = record_used {\n                                 self.report_error(span, ParamInTyOfConstParam(rib_ident.name));\n                             }\n                             return Res::Err;\n                         }\n                     }\n                 }\n-                if let Some(res_err) = res_err {\n+                if let Some((span, res_err)) = res_err {\n                     self.report_error(span, res_err);\n                     return Res::Err;\n                 }\n@@ -2792,17 +2769,17 @@ impl<'a> Resolver<'a> {\n                                 if let Res::SelfTy { trait_, alias_to: Some((def, _)) } = res {\n                                     res = Res::SelfTy { trait_, alias_to: Some((def, true)) }\n                                 } else {\n-                                    if record_used {\n+                                    if let Some(span) = record_used {\n                                         self.report_error(\n                                             span,\n                                             ResolutionError::ParamInNonTrivialAnonConst {\n                                                 name: rib_ident.name,\n                                                 is_type: true,\n                                             },\n                                         );\n+                                        self.session.delay_span_bug(span, CG_BUG_STR);\n                                     }\n \n-                                    self.session.delay_span_bug(span, CG_BUG_STR);\n                                     return Res::Err;\n                                 }\n                             }\n@@ -2814,7 +2791,7 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind(has_generic_params) => has_generic_params,\n                         FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n-                            if record_used {\n+                            if let Some(span) = record_used {\n                                 self.report_error(\n                                     span,\n                                     ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n@@ -2824,7 +2801,7 @@ impl<'a> Resolver<'a> {\n                         }\n                     };\n \n-                    if record_used {\n+                    if let Some(span) = record_used {\n                         self.report_error(\n                             span,\n                             ResolutionError::GenericParamsFromOuterFunction(\n@@ -2858,17 +2835,17 @@ impl<'a> Resolver<'a> {\n                             let features = self.session.features_untracked();\n                             // HACK(min_const_generics): We currently only allow `N` or `{ N }`.\n                             if !(trivial || features.generic_const_exprs) {\n-                                if record_used {\n+                                if let Some(span) = record_used {\n                                     self.report_error(\n                                         span,\n                                         ResolutionError::ParamInNonTrivialAnonConst {\n                                             name: rib_ident.name,\n                                             is_type: false,\n                                         },\n                                     );\n+                                    self.session.delay_span_bug(span, CG_BUG_STR);\n                                 }\n \n-                                self.session.delay_span_bug(span, CG_BUG_STR);\n                                 return Res::Err;\n                             }\n \n@@ -2878,7 +2855,7 @@ impl<'a> Resolver<'a> {\n                         ItemRibKind(has_generic_params) => has_generic_params,\n                         FnItemRibKind => HasGenericParams::Yes,\n                         ConstParamTyRibKind => {\n-                            if record_used {\n+                            if let Some(span) = record_used {\n                                 self.report_error(\n                                     span,\n                                     ResolutionError::ParamInTyOfConstParam(rib_ident.name),\n@@ -2889,7 +2866,7 @@ impl<'a> Resolver<'a> {\n                     };\n \n                     // This was an attempt to use a const parameter outside its scope.\n-                    if record_used {\n+                    if let Some(span) = record_used {\n                         self.report_error(\n                             span,\n                             ResolutionError::GenericParamsFromOuterFunction(\n@@ -3330,7 +3307,6 @@ impl<'a> Resolver<'a> {\n             &segments,\n             Some(ns),\n             &ParentScope::module(module, self),\n-            DUMMY_SP,\n             CrateLint::No,\n         ) {\n             PathResult::Module(ModuleOrUniformRoot::Module(module)) => Some(module.res().unwrap()),\n@@ -3425,8 +3401,7 @@ impl<'a> Resolver<'a> {\n             ident,\n             ValueNS,\n             parent_scope,\n-            false,\n-            DUMMY_SP,\n+            None\n         ) else {\n             return;\n         };\n@@ -3490,29 +3465,37 @@ enum CrateLint {\n \n     /// This lint applies to some arbitrary path; e.g., `impl ::foo::Bar`.\n     /// In this case, we can take the span of that path.\n-    SimplePath(NodeId),\n+    SimplePath(NodeId, Span),\n \n     /// This lint comes from a `use` statement. In this case, what we\n     /// care about really is the *root* `use` statement; e.g., if we\n     /// have nested things like `use a::{b, c}`, we care about the\n     /// `use a` part.\n-    UsePath { root_id: NodeId, root_span: Span },\n+    UsePath { root_id: NodeId, root_span: Span, path_span: Span },\n \n     /// This is the \"trait item\" from a fully qualified path. For example,\n     /// we might be resolving  `X::Y::Z` from a path like `<T as X::Y>::Z`.\n     /// The `path_span` is the span of the to the trait itself (`X::Y`).\n-    QPathTrait { qpath_id: NodeId, qpath_span: Span },\n+    QPathTrait { qpath_id: NodeId, qpath_span: Span, path_span: Span },\n }\n \n impl CrateLint {\n-    fn node_id(&self) -> Option<NodeId> {\n+    fn node_id_and_path_span(&self) -> Option<(NodeId, Span)> {\n         match *self {\n             CrateLint::No => None,\n-            CrateLint::SimplePath(id)\n-            | CrateLint::UsePath { root_id: id, .. }\n-            | CrateLint::QPathTrait { qpath_id: id, .. } => Some(id),\n+            CrateLint::SimplePath(id, path_span)\n+            | CrateLint::UsePath { root_id: id, path_span, .. }\n+            | CrateLint::QPathTrait { qpath_id: id, path_span, .. } => Some((id, path_span)),\n         }\n     }\n+\n+    fn node_id(&self) -> Option<NodeId> {\n+        self.node_id_and_path_span().map(|(id, _)| id)\n+    }\n+\n+    fn path_span(&self) -> Option<Span> {\n+        self.node_id_and_path_span().map(|(_, path_span)| path_span)\n+    }\n }\n \n pub fn provide(providers: &mut Providers) {"}, {"sha": "e8ba8780526c53d0cfee8ef90eb07c0655565008", "filename": "compiler/rustc_resolve/src/macros.rs", "status": "modified", "additions": 18, "deletions": 30, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d079d566255e83ccfdb7da9494079a1cf2c086/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fmacros.rs?ref=74d079d566255e83ccfdb7da9494079a1cf2c086", "patch": "@@ -415,7 +415,7 @@ impl<'a> ResolverExpand for Resolver<'a> {\n \n         let mut indeterminate = false;\n         for ns in [TypeNS, ValueNS, MacroNS].iter().copied() {\n-            match self.resolve_path(path, Some(ns), &parent_scope, span, CrateLint::No) {\n+            match self.resolve_path(path, Some(ns), &parent_scope, CrateLint::No) {\n                 PathResult::Module(ModuleOrUniformRoot::Module(_)) => return Ok(true),\n                 PathResult::NonModule(partial_res) if partial_res.unresolved_segments() == 0 => {\n                     return Ok(true);\n@@ -575,13 +575,7 @@ impl<'a> Resolver<'a> {\n         }\n \n         let res = if path.len() > 1 {\n-            let res = match self.resolve_path(\n-                &path,\n-                Some(MacroNS),\n-                parent_scope,\n-                path_span,\n-                CrateLint::No,\n-            ) {\n+            let res = match self.resolve_path(&path, Some(MacroNS), parent_scope, CrateLint::No) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     Ok(path_res.base_res())\n                 }\n@@ -611,9 +605,8 @@ impl<'a> Resolver<'a> {\n                 path[0].ident,\n                 scope_set,\n                 parent_scope,\n-                false,\n+                None,\n                 force,\n-                path_span,\n             );\n             if let Err(Determinacy::Undetermined) = binding {\n                 return Err(Determinacy::Undetermined);\n@@ -647,9 +640,8 @@ impl<'a> Resolver<'a> {\n         orig_ident: Ident,\n         scope_set: ScopeSet<'a>,\n         parent_scope: &ParentScope<'a>,\n-        record_used: bool,\n+        record_used: Option<Span>,\n         force: bool,\n-        path_span: Span,\n     ) -> Result<&'a NameBinding<'a>, Determinacy> {\n         bitflags::bitflags! {\n             struct Flags: u8 {\n@@ -661,7 +653,7 @@ impl<'a> Resolver<'a> {\n             }\n         }\n \n-        assert!(force || !record_used); // `record_used` implies `force`\n+        assert!(force || !record_used.is_some()); // `record_used` implies `force`\n \n         // Make sure `self`, `super` etc produce an error when passed to here.\n         if orig_ident.is_path_segment_keyword() {\n@@ -769,7 +761,6 @@ impl<'a> Resolver<'a> {\n                             ns,\n                             parent_scope,\n                             record_used,\n-                            path_span,\n                         );\n                         match binding {\n                             Ok(binding) => Ok((binding, Flags::MODULE | Flags::MISC_SUGGEST_CRATE)),\n@@ -791,7 +782,6 @@ impl<'a> Resolver<'a> {\n                             adjusted_parent_scope,\n                             !matches!(scope_set, ScopeSet::Late(..)),\n                             record_used,\n-                            path_span,\n                         );\n                         match binding {\n                             Ok(binding) => {\n@@ -855,12 +845,14 @@ impl<'a> Resolver<'a> {\n                             Err(Determinacy::Determined)\n                         }\n                     }\n-                    Scope::ExternPrelude => match this.extern_prelude_get(ident, !record_used) {\n-                        Some(binding) => Ok((binding, Flags::empty())),\n-                        None => Err(Determinacy::determined(\n-                            this.graph_root.unexpanded_invocations.borrow().is_empty(),\n-                        )),\n-                    },\n+                    Scope::ExternPrelude => {\n+                        match this.extern_prelude_get(ident, record_used.is_none()) {\n+                            Some(binding) => Ok((binding, Flags::empty())),\n+                            None => Err(Determinacy::determined(\n+                                this.graph_root.unexpanded_invocations.borrow().is_empty(),\n+                            )),\n+                        }\n+                    }\n                     Scope::ToolPrelude => match this.registered_tools.get(&ident).cloned() {\n                         Some(ident) => ok(Res::ToolMod, ident.span, this.arenas),\n                         None => Err(Determinacy::Determined),\n@@ -873,8 +865,7 @@ impl<'a> Resolver<'a> {\n                                 ident,\n                                 ns,\n                                 parent_scope,\n-                                false,\n-                                path_span,\n+                                None,\n                             ) {\n                                 if use_prelude || this.is_builtin_macro(binding.res()) {\n                                     result = Ok((binding, Flags::MISC_FROM_PRELUDE));\n@@ -893,7 +884,7 @@ impl<'a> Resolver<'a> {\n                     Ok((binding, flags))\n                         if sub_namespace_match(binding.macro_kind(), macro_kind) =>\n                     {\n-                        if !record_used || matches!(scope_set, ScopeSet::Late(..)) {\n+                        if record_used.is_none() || matches!(scope_set, ScopeSet::Late(..)) {\n                             return Some(Ok(binding));\n                         }\n \n@@ -1032,8 +1023,7 @@ impl<'a> Resolver<'a> {\n                 &path,\n                 Some(MacroNS),\n                 &parent_scope,\n-                path_span,\n-                CrateLint::SimplePath(ast::CRATE_NODE_ID),\n+                CrateLint::SimplePath(ast::CRATE_NODE_ID, path_span),\n             ) {\n                 PathResult::NonModule(path_res) if path_res.unresolved_segments() == 0 => {\n                     let res = path_res.base_res();\n@@ -1067,9 +1057,8 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ScopeSet::Macro(kind),\n                 &parent_scope,\n+                Some(ident.span),\n                 true,\n-                true,\n-                ident.span,\n             ) {\n                 Ok(binding) => {\n                     let initial_res = initial_binding.map(|initial_binding| {\n@@ -1109,9 +1098,8 @@ impl<'a> Resolver<'a> {\n                 ident,\n                 ScopeSet::Macro(MacroKind::Attr),\n                 &parent_scope,\n+                Some(ident.span),\n                 true,\n-                true,\n-                ident.span,\n             );\n         }\n     }"}, {"sha": "6d7ca9a94cfbde9432fcff3e52c30dc7e435a125", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/74d079d566255e83ccfdb7da9494079a1cf2c086/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/74d079d566255e83ccfdb7da9494079a1cf2c086/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=74d079d566255e83ccfdb7da9494079a1cf2c086", "patch": "@@ -568,7 +568,7 @@ fn configure_cmake(\n     // We also do this if the user explicitly requested static libstdc++.\n     if builder.config.llvm_static_stdcpp {\n         if !target.contains(\"msvc\") && !target.contains(\"netbsd\") {\n-            if target.contains(\"apple\") {\n+            if target.contains(\"apple\") || target.contains(\"windows\") {\n                 ldflags.push_all(\"-static-libstdc++\");\n             } else {\n                 ldflags.push_all(\"-Wl,-Bsymbolic -static-libstdc++\");"}]}