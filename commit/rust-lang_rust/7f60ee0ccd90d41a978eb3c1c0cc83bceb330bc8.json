{"sha": "7f60ee0ccd90d41a978eb3c1c0cc83bceb330bc8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdmNjBlZTBjY2Q5MGQ0MWE5NzhlYjNjMWMwY2M4M2JjZWIzMzBiYzg=", "commit": {"author": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-10-02T19:10:49Z"}, "committer": {"name": "Joshua Nelson", "email": "jyn514@gmail.com", "date": "2020-11-24T19:10:18Z"}, "message": "Refactor clean_qpath into a separate function", "tree": {"sha": "31396615fd7283c09fb871c25da41a3763e5fc17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/31396615fd7283c09fb871c25da41a3763e5fc17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7f60ee0ccd90d41a978eb3c1c0cc83bceb330bc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7f60ee0ccd90d41a978eb3c1c0cc83bceb330bc8", "html_url": "https://github.com/rust-lang/rust/commit/7f60ee0ccd90d41a978eb3c1c0cc83bceb330bc8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7f60ee0ccd90d41a978eb3c1c0cc83bceb330bc8/comments", "author": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jyn514", "id": 23638587, "node_id": "MDQ6VXNlcjIzNjM4NTg3", "avatar_url": "https://avatars.githubusercontent.com/u/23638587?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jyn514", "html_url": "https://github.com/jyn514", "followers_url": "https://api.github.com/users/jyn514/followers", "following_url": "https://api.github.com/users/jyn514/following{/other_user}", "gists_url": "https://api.github.com/users/jyn514/gists{/gist_id}", "starred_url": "https://api.github.com/users/jyn514/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jyn514/subscriptions", "organizations_url": "https://api.github.com/users/jyn514/orgs", "repos_url": "https://api.github.com/users/jyn514/repos", "events_url": "https://api.github.com/users/jyn514/events{/privacy}", "received_events_url": "https://api.github.com/users/jyn514/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "25a691003cf6676259ee7d4bed05b43cb6283cea", "url": "https://api.github.com/repos/rust-lang/rust/commits/25a691003cf6676259ee7d4bed05b43cb6283cea", "html_url": "https://github.com/rust-lang/rust/commit/25a691003cf6676259ee7d4bed05b43cb6283cea"}], "stats": {"total": 290, "additions": 151, "deletions": 139}, "files": [{"sha": "1667a92d75726cd762992273bd880d328027cdfa", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 151, "deletions": 139, "changes": 290, "blob_url": "https://github.com/rust-lang/rust/blob/7f60ee0ccd90d41a978eb3c1c0cc83bceb330bc8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7f60ee0ccd90d41a978eb3c1c0cc83bceb330bc8/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7f60ee0ccd90d41a978eb3c1c0cc83bceb330bc8", "patch": "@@ -1283,6 +1283,156 @@ impl Clean<Item> for ty::AssocItem {\n     }\n }\n \n+fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &DocContext<'_>) -> Type {\n+    use rustc_hir::GenericParamCount;\n+    let hir::Ty { hir_id, span, ref kind } = *hir_ty;\n+    let qpath = match kind {\n+        hir::TyKind::Path(qpath) => qpath,\n+        _ => unreachable!(),\n+    };\n+    match qpath {\n+        hir::QPath::Resolved(None, ref path) => {\n+            if let Res::Def(DefKind::TyParam, did) = path.res {\n+                if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n+                    return new_ty;\n+                }\n+                if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did.into()) {\n+                    return ImplTrait(bounds);\n+                }\n+            }\n+\n+            let mut alias = None;\n+            if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n+                // Substitute private type aliases\n+                if let Some(def_id) = def_id.as_local() {\n+                    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n+                    if !cx.renderinfo.borrow().access_levels.is_exported(def_id.to_def_id()) {\n+                        alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n+                    }\n+                }\n+            };\n+\n+            if let Some(&hir::ItemKind::TyAlias(ref ty, ref generics)) = alias {\n+                let provided_params = &path.segments.last().expect(\"segments were empty\");\n+                let mut ty_substs = FxHashMap::default();\n+                let mut lt_substs = FxHashMap::default();\n+                let mut ct_substs = FxHashMap::default();\n+                let generic_args = provided_params.generic_args();\n+                {\n+                    let mut indices: GenericParamCount = Default::default();\n+                    for param in generics.params.iter() {\n+                        match param.kind {\n+                            hir::GenericParamKind::Lifetime { .. } => {\n+                                let mut j = 0;\n+                                let lifetime = generic_args.args.iter().find_map(|arg| match arg {\n+                                    hir::GenericArg::Lifetime(lt) => {\n+                                        if indices.lifetimes == j {\n+                                            return Some(lt);\n+                                        }\n+                                        j += 1;\n+                                        None\n+                                    }\n+                                    _ => None,\n+                                });\n+                                if let Some(lt) = lifetime.cloned() {\n+                                    let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                                    let cleaned = if !lt.is_elided() {\n+                                        lt.clean(cx)\n+                                    } else {\n+                                        self::types::Lifetime::elided()\n+                                    };\n+                                    lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n+                                }\n+                                indices.lifetimes += 1;\n+                            }\n+                            hir::GenericParamKind::Type { ref default, .. } => {\n+                                let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                                let mut j = 0;\n+                                let type_ = generic_args.args.iter().find_map(|arg| match arg {\n+                                    hir::GenericArg::Type(ty) => {\n+                                        if indices.types == j {\n+                                            return Some(ty);\n+                                        }\n+                                        j += 1;\n+                                        None\n+                                    }\n+                                    _ => None,\n+                                });\n+                                if let Some(ty) = type_ {\n+                                    ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n+                                } else if let Some(default) = *default {\n+                                    ty_substs\n+                                        .insert(ty_param_def_id.to_def_id(), default.clean(cx));\n+                                }\n+                                indices.types += 1;\n+                            }\n+                            hir::GenericParamKind::Const { .. } => {\n+                                let const_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n+                                let mut j = 0;\n+                                let const_ = generic_args.args.iter().find_map(|arg| match arg {\n+                                    hir::GenericArg::Const(ct) => {\n+                                        if indices.consts == j {\n+                                            return Some(ct);\n+                                        }\n+                                        j += 1;\n+                                        None\n+                                    }\n+                                    _ => None,\n+                                });\n+                                if let Some(ct) = const_ {\n+                                    ct_substs.insert(const_param_def_id.to_def_id(), ct.clean(cx));\n+                                }\n+                                // FIXME(const_generics:defaults)\n+                                indices.consts += 1;\n+                            }\n+                        }\n+                    }\n+                }\n+                return cx.enter_alias(ty_substs, lt_substs, ct_substs, || ty.clean(cx));\n+            }\n+            resolve_type(cx, path.clean(cx), hir_id)\n+        }\n+        hir::QPath::Resolved(Some(ref qself), ref p) => {\n+            let segments = if p.is_global() { &p.segments[1..] } else { &p.segments };\n+            let trait_segments = &segments[..segments.len() - 1];\n+            let trait_path = self::Path {\n+                global: p.is_global(),\n+                res: Res::Def(\n+                    DefKind::Trait,\n+                    cx.tcx.associated_item(p.res.def_id()).container.id(),\n+                ),\n+                segments: trait_segments.clean(cx),\n+            };\n+            Type::QPath {\n+                name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n+                self_type: box qself.clean(cx),\n+                trait_: box resolve_type(cx, trait_path, hir_id),\n+            }\n+        }\n+        hir::QPath::TypeRelative(ref qself, ref segment) => {\n+            let mut res = Res::Err;\n+            /*\n+            let hir_ty = hir::Ty {\n+                kind: hir::TyKind::Path((*qpath).clone()),\n+                hir_id,\n+                span,\n+            };\n+            */\n+            let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n+            if let ty::Projection(proj) = ty.kind() {\n+                res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n+            }\n+            let trait_path = hir::Path { span, res, segments: &[] };\n+            Type::QPath {\n+                name: segment.ident.name.clean(cx),\n+                self_type: box qself.clean(cx),\n+                trait_: box resolve_type(cx, trait_path.clean(cx), hir_id),\n+            }\n+        }\n+        hir::QPath::LangItem(..) => bug!(\"clean: requiring documentation of lang item\"),\n+    }\n+}\n+\n impl Clean<Type> for hir::Ty<'_> {\n     fn clean(&self, cx: &DocContext<'_>) -> Type {\n         use rustc_hir::*;\n@@ -1318,145 +1468,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                     unreachable!()\n                 }\n             }\n-            TyKind::Path(hir::QPath::Resolved(None, ref path)) => {\n-                if let Res::Def(DefKind::TyParam, did) = path.res {\n-                    if let Some(new_ty) = cx.ty_substs.borrow().get(&did).cloned() {\n-                        return new_ty;\n-                    }\n-                    if let Some(bounds) = cx.impl_trait_bounds.borrow_mut().remove(&did.into()) {\n-                        return ImplTrait(bounds);\n-                    }\n-                }\n-\n-                let mut alias = None;\n-                if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n-                    // Substitute private type aliases\n-                    if let Some(def_id) = def_id.as_local() {\n-                        let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-                        if !cx.renderinfo.borrow().access_levels.is_exported(def_id.to_def_id()) {\n-                            alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n-                        }\n-                    }\n-                };\n-\n-                if let Some(&hir::ItemKind::TyAlias(ref ty, ref generics)) = alias {\n-                    let provided_params = &path.segments.last().expect(\"segments were empty\");\n-                    let mut ty_substs = FxHashMap::default();\n-                    let mut lt_substs = FxHashMap::default();\n-                    let mut ct_substs = FxHashMap::default();\n-                    let generic_args = provided_params.generic_args();\n-                    {\n-                        let mut indices: GenericParamCount = Default::default();\n-                        for param in generics.params.iter() {\n-                            match param.kind {\n-                                hir::GenericParamKind::Lifetime { .. } => {\n-                                    let mut j = 0;\n-                                    let lifetime =\n-                                        generic_args.args.iter().find_map(|arg| match arg {\n-                                            hir::GenericArg::Lifetime(lt) => {\n-                                                if indices.lifetimes == j {\n-                                                    return Some(lt);\n-                                                }\n-                                                j += 1;\n-                                                None\n-                                            }\n-                                            _ => None,\n-                                        });\n-                                    if let Some(lt) = lifetime.cloned() {\n-                                        let lt_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                        let cleaned = if !lt.is_elided() {\n-                                            lt.clean(cx)\n-                                        } else {\n-                                            self::types::Lifetime::elided()\n-                                        };\n-                                        lt_substs.insert(lt_def_id.to_def_id(), cleaned);\n-                                    }\n-                                    indices.lifetimes += 1;\n-                                }\n-                                hir::GenericParamKind::Type { ref default, .. } => {\n-                                    let ty_param_def_id = cx.tcx.hir().local_def_id(param.hir_id);\n-                                    let mut j = 0;\n-                                    let type_ =\n-                                        generic_args.args.iter().find_map(|arg| match arg {\n-                                            hir::GenericArg::Type(ty) => {\n-                                                if indices.types == j {\n-                                                    return Some(ty);\n-                                                }\n-                                                j += 1;\n-                                                None\n-                                            }\n-                                            _ => None,\n-                                        });\n-                                    if let Some(ty) = type_ {\n-                                        ty_substs.insert(ty_param_def_id.to_def_id(), ty.clean(cx));\n-                                    } else if let Some(default) = *default {\n-                                        ty_substs\n-                                            .insert(ty_param_def_id.to_def_id(), default.clean(cx));\n-                                    }\n-                                    indices.types += 1;\n-                                }\n-                                hir::GenericParamKind::Const { .. } => {\n-                                    let const_param_def_id =\n-                                        cx.tcx.hir().local_def_id(param.hir_id);\n-                                    let mut j = 0;\n-                                    let const_ =\n-                                        generic_args.args.iter().find_map(|arg| match arg {\n-                                            hir::GenericArg::Const(ct) => {\n-                                                if indices.consts == j {\n-                                                    return Some(ct);\n-                                                }\n-                                                j += 1;\n-                                                None\n-                                            }\n-                                            _ => None,\n-                                        });\n-                                    if let Some(ct) = const_ {\n-                                        ct_substs\n-                                            .insert(const_param_def_id.to_def_id(), ct.clean(cx));\n-                                    }\n-                                    // FIXME(const_generics:defaults)\n-                                    indices.consts += 1;\n-                                }\n-                            }\n-                        }\n-                    }\n-                    return cx.enter_alias(ty_substs, lt_substs, ct_substs, || ty.clean(cx));\n-                }\n-                resolve_type(cx, path.clean(cx), self.hir_id)\n-            }\n-            TyKind::Path(hir::QPath::Resolved(Some(ref qself), ref p)) => {\n-                let segments = if p.is_global() { &p.segments[1..] } else { &p.segments };\n-                let trait_segments = &segments[..segments.len() - 1];\n-                let trait_path = self::Path {\n-                    global: p.is_global(),\n-                    res: Res::Def(\n-                        DefKind::Trait,\n-                        cx.tcx.associated_item(p.res.def_id()).container.id(),\n-                    ),\n-                    segments: trait_segments.clean(cx),\n-                };\n-                Type::QPath {\n-                    name: p.segments.last().expect(\"segments were empty\").ident.name.clean(cx),\n-                    self_type: box qself.clean(cx),\n-                    trait_: box resolve_type(cx, trait_path, self.hir_id),\n-                }\n-            }\n-            TyKind::Path(hir::QPath::TypeRelative(ref qself, ref segment)) => {\n-                let mut res = Res::Err;\n-                let ty = hir_ty_to_ty(cx.tcx, self);\n-                if let ty::Projection(proj) = ty.kind() {\n-                    res = Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id);\n-                }\n-                let trait_path = hir::Path { span: self.span, res, segments: &[] };\n-                Type::QPath {\n-                    name: segment.ident.name.clean(cx),\n-                    self_type: box qself.clean(cx),\n-                    trait_: box resolve_type(cx, trait_path.clean(cx), self.hir_id),\n-                }\n-            }\n-            TyKind::Path(hir::QPath::LangItem(..)) => {\n-                bug!(\"clean: requiring documentation of lang item\")\n-            }\n+            TyKind::Path(_) => clean_qpath(&self, cx),\n             TyKind::TraitObject(ref bounds, ref lifetime) => {\n                 match bounds[0].clean(cx).trait_ {\n                     ResolvedPath { path, param_names: None, did, is_generic } => {"}]}