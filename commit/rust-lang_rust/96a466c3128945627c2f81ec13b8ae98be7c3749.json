{"sha": "96a466c3128945627c2f81ec13b8ae98be7c3749", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YTQ2NmMzMTI4OTQ1NjI3YzJmODFlYzEzYjhhZTk4YmU3YzM3NDk=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-05-01T23:22:48Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2020-05-20T18:08:29Z"}, "message": "linker: Support `-static-pie` and `-static -shared`", "tree": {"sha": "f2f3b75e3c3b9d6df76b73a3b1f642c948c0ee6a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f2f3b75e3c3b9d6df76b73a3b1f642c948c0ee6a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96a466c3128945627c2f81ec13b8ae98be7c3749", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96a466c3128945627c2f81ec13b8ae98be7c3749", "html_url": "https://github.com/rust-lang/rust/commit/96a466c3128945627c2f81ec13b8ae98be7c3749", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96a466c3128945627c2f81ec13b8ae98be7c3749/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eccaa0186f8fa2a432bf612b74f18a319406134c", "url": "https://api.github.com/repos/rust-lang/rust/commits/eccaa0186f8fa2a432bf612b74f18a319406134c", "html_url": "https://github.com/rust-lang/rust/commit/eccaa0186f8fa2a432bf612b74f18a319406134c"}], "stats": {"total": 249, "additions": 118, "deletions": 131}, "files": [{"sha": "7addfd15f1cdd0fa2affc30238f7889490924c9f", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/96a466c3128945627c2f81ec13b8ae98be7c3749/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a466c3128945627c2f81ec13b8ae98be7c3749/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=96a466c3128945627c2f81ec13b8ae98be7c3749", "patch": "@@ -1530,16 +1530,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Support `StaticPicExe` correctly.\n-    match link_output_kind {\n-        LinkOutputKind::DynamicPicExe | LinkOutputKind::StaticPicExe => {\n-            cmd.position_independent_executable()\n-        }\n-        LinkOutputKind::DynamicNoPicExe | LinkOutputKind::StaticNoPicExe => {\n-            cmd.no_position_independent_executable()\n-        }\n-        _ => {}\n-    }\n+    cmd.set_output_kind(link_output_kind, out_filename);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n     add_relro_args(cmd, sess);\n@@ -1568,17 +1559,6 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         tmpdir,\n     );\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Merge with the previous `link_output_kind` match,\n-    // and support `StaticPicExe` and `StaticDylib` correctly.\n-    match link_output_kind {\n-        LinkOutputKind::StaticNoPicExe | LinkOutputKind::StaticPicExe => {\n-            cmd.build_static_executable()\n-        }\n-        LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => cmd.build_dylib(out_filename),\n-        _ => {}\n-    }\n-\n     // OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.opts.cg.profile_generate.enabled() {\n         cmd.pgo_gen();"}, {"sha": "80d1f7006847d06e2ff9ee34fdf4bdbf06afe7eb", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 117, "deletions": 110, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/96a466c3128945627c2f81ec13b8ae98be7c3749/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a466c3128945627c2f81ec13b8ae98be7c3749/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=96a466c3128945627c2f81ec13b8ae98be7c3749", "patch": "@@ -17,7 +17,7 @@ use rustc_serialize::{json, Encoder};\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel, Strip};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n-use rustc_target::spec::{LinkerFlavor, LldFlavor};\n+use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n \n /// Disables non-English messages from localized linkers.\n /// Such messages may cause issues with text encoding on Windows (#35785)\n@@ -102,6 +102,7 @@ impl LinkerInfo {\n /// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n     fn cmd(&mut self) -> &mut Command;\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path);\n     fn link_dylib(&mut self, lib: Symbol);\n     fn link_rust_dylib(&mut self, lib: Symbol, path: &Path);\n     fn link_framework(&mut self, framework: Symbol);\n@@ -114,8 +115,6 @@ pub trait Linker {\n     fn output_filename(&mut self, path: &Path);\n     fn add_object(&mut self, path: &Path);\n     fn gc_sections(&mut self, keep_metadata: bool);\n-    fn position_independent_executable(&mut self);\n-    fn no_position_independent_executable(&mut self);\n     fn full_relro(&mut self);\n     fn partial_relro(&mut self);\n     fn no_relro(&mut self);\n@@ -125,8 +124,6 @@ pub trait Linker {\n     fn debuginfo(&mut self, strip: Strip);\n     fn no_crt_objects(&mut self);\n     fn no_default_libraries(&mut self);\n-    fn build_dylib(&mut self, out_filename: &Path);\n-    fn build_static_executable(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n@@ -233,12 +230,94 @@ impl<'a> GccLinker<'a> {\n         let target_cpu = self.target_cpu;\n         self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", target_cpu));\n     }\n+\n+    fn build_dylib(&mut self, out_filename: &Path) {\n+        // On mac we need to tell the linker to let this library be rpathed\n+        if self.sess.target.target.options.is_like_osx {\n+            self.cmd.arg(\"-dynamiclib\");\n+            self.linker_arg(\"-dylib\");\n+\n+            // Note that the `osx_rpath_install_name` option here is a hack\n+            // purely to support rustbuild right now, we should get a more\n+            // principled solution at some point to force the compiler to pass\n+            // the right `-Wl,-install_name` with an `@rpath` in it.\n+            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n+                self.linker_arg(\"-install_name\");\n+                let mut v = OsString::from(\"@rpath/\");\n+                v.push(out_filename.file_name().unwrap());\n+                self.linker_arg(&v);\n+            }\n+        } else {\n+            self.cmd.arg(\"-shared\");\n+            if self.sess.target.target.options.is_like_windows {\n+                // The output filename already contains `dll_suffix` so\n+                // the resulting import library will have a name in the\n+                // form of libfoo.dll.a\n+                let implib_name =\n+                    out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n+                        format!(\n+                            \"{}{}{}\",\n+                            self.sess.target.target.options.staticlib_prefix,\n+                            file,\n+                            self.sess.target.target.options.staticlib_suffix\n+                        )\n+                    });\n+                if let Some(implib_name) = implib_name {\n+                    let implib = out_filename.parent().map(|dir| dir.join(&implib_name));\n+                    if let Some(implib) = implib {\n+                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'a> Linker for GccLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe => {\n+                if !self.is_ld {\n+                    self.cmd.arg(\"-no-pie\");\n+                }\n+            }\n+            LinkOutputKind::DynamicPicExe => {\n+                // `-pie` works for both gcc wrapper and ld.\n+                self.cmd.arg(\"-pie\");\n+            }\n+            LinkOutputKind::StaticNoPicExe => {\n+                // `-static` works for both gcc wrapper and ld.\n+                self.cmd.arg(\"-static\");\n+                if !self.is_ld {\n+                    self.cmd.arg(\"-no-pie\");\n+                }\n+            }\n+            LinkOutputKind::StaticPicExe => {\n+                if !self.is_ld {\n+                    // Note that combination `-static -pie` doesn't work as expected\n+                    // for the gcc wrapper, `-static` in that case suppresses `-pie`.\n+                    self.cmd.arg(\"-static-pie\");\n+                } else {\n+                    // `--no-dynamic-linker` and `-z text` are not strictly necessary for producing\n+                    // a static pie, but currently passed because gcc and clang pass them.\n+                    // The former suppresses the `INTERP` ELF header specifying dynamic linker,\n+                    // which is otherwise implicitly injected by ld (but not lld).\n+                    // The latter doesn't change anything, only ensures that everything is pic.\n+                    self.cmd.args(&[\"-static\", \"-pie\", \"--no-dynamic-linker\", \"-z\", \"text\"]);\n+                }\n+            }\n+            LinkOutputKind::DynamicDylib => self.build_dylib(out_filename),\n+            LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"-static\");\n+                self.build_dylib(out_filename);\n+            }\n+        }\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.hint_dynamic();\n         self.cmd.arg(format!(\"-l{}\", lib));\n@@ -263,14 +342,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n-    fn position_independent_executable(&mut self) {\n-        self.cmd.arg(\"-pie\");\n-    }\n-    fn no_position_independent_executable(&mut self) {\n-        if !self.is_ld {\n-            self.cmd.arg(\"-no-pie\");\n-        }\n-    }\n     fn full_relro(&mut self) {\n         self.linker_arg(\"-zrelro\");\n         self.linker_arg(\"-znow\");\n@@ -281,9 +352,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn no_relro(&mut self) {\n         self.linker_arg(\"-znorelro\");\n     }\n-    fn build_static_executable(&mut self) {\n-        self.cmd.arg(\"-static\");\n-    }\n \n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.hint_dynamic();\n@@ -419,47 +487,6 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n     }\n \n-    fn build_dylib(&mut self, out_filename: &Path) {\n-        // On mac we need to tell the linker to let this library be rpathed\n-        if self.sess.target.target.options.is_like_osx {\n-            self.cmd.arg(\"-dynamiclib\");\n-            self.linker_arg(\"-dylib\");\n-\n-            // Note that the `osx_rpath_install_name` option here is a hack\n-            // purely to support rustbuild right now, we should get a more\n-            // principled solution at some point to force the compiler to pass\n-            // the right `-Wl,-install_name` with an `@rpath` in it.\n-            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n-                self.linker_arg(\"-install_name\");\n-                let mut v = OsString::from(\"@rpath/\");\n-                v.push(out_filename.file_name().unwrap());\n-                self.linker_arg(&v);\n-            }\n-        } else {\n-            self.cmd.arg(\"-shared\");\n-            if self.sess.target.target.options.is_like_windows {\n-                // The output filename already contains `dll_suffix` so\n-                // the resulting import library will have a name in the\n-                // form of libfoo.dll.a\n-                let implib_name =\n-                    out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n-                        format!(\n-                            \"{}{}{}\",\n-                            self.sess.target.target.options.staticlib_prefix,\n-                            file,\n-                            self.sess.target.target.options.staticlib_suffix\n-                        )\n-                    });\n-                if let Some(implib_name) = implib_name {\n-                    let implib = out_filename.parent().map(|dir| dir.join(&implib_name));\n-                    if let Some(implib) = implib {\n-                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // Symbol visibility in object files typically takes care of this.\n         if crate_type == CrateType::Executable\n@@ -583,24 +610,29 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe\n+            | LinkOutputKind::DynamicPicExe\n+            | LinkOutputKind::StaticNoPicExe\n+            | LinkOutputKind::StaticPicExe => {}\n+            LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"/DLL\");\n+                let mut arg: OsString = \"/IMPLIB:\".into();\n+                arg.push(out_filename.with_extension(\"dll.lib\"));\n+                self.cmd.arg(arg);\n+            }\n+        }\n+    }\n+\n     fn link_rlib(&mut self, lib: &Path) {\n         self.cmd.arg(lib);\n     }\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n \n-    fn build_dylib(&mut self, out_filename: &Path) {\n-        self.cmd.arg(\"/DLL\");\n-        let mut arg: OsString = \"/IMPLIB:\".into();\n-        arg.push(out_filename.with_extension(\"dll.lib\"));\n-        self.cmd.arg(arg);\n-    }\n-\n-    fn build_static_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn gc_sections(&mut self, _keep_metadata: bool) {\n         // MSVC's ICF (Identical COMDAT Folding) link optimization is\n         // slow for Rust and thus we disable it by default when not in\n@@ -633,14 +665,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n     }\n \n-    fn position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn full_relro(&mut self) {\n         // noop\n     }\n@@ -818,6 +842,9 @@ impl<'a> Linker for EmLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n     fn include_path(&mut self, path: &Path) {\n         self.cmd.arg(\"-L\").arg(path);\n     }\n@@ -857,14 +884,6 @@ impl<'a> Linker for EmLinker<'a> {\n         self.add_object(lib);\n     }\n \n-    fn position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn full_relro(&mut self) {\n         // noop\n     }\n@@ -926,14 +945,6 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.args(&[\"-s\", \"DEFAULT_LIBRARY_FUNCS_TO_INCLUDE=[]\"]);\n     }\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {\n-        bug!(\"building dynamic library is unsupported on Emscripten\")\n-    }\n-\n-    fn build_static_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         let symbols = &self.info.exports[&crate_type];\n \n@@ -1032,6 +1043,18 @@ impl<'a> Linker for WasmLd<'a> {\n         &mut self.cmd\n     }\n \n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, _out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe\n+            | LinkOutputKind::DynamicPicExe\n+            | LinkOutputKind::StaticNoPicExe\n+            | LinkOutputKind::StaticPicExe => {}\n+            LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"--no-entry\");\n+            }\n+        }\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1060,16 +1083,12 @@ impl<'a> Linker for WasmLd<'a> {\n         self.cmd.arg(path);\n     }\n \n-    fn position_independent_executable(&mut self) {}\n-\n     fn full_relro(&mut self) {}\n \n     fn partial_relro(&mut self) {}\n \n     fn no_relro(&mut self) {}\n \n-    fn build_static_executable(&mut self) {}\n-\n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1125,10 +1144,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn no_default_libraries(&mut self) {}\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {\n-        self.cmd.arg(\"--no-entry\");\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         for sym in self.info.exports[&crate_type].iter() {\n             self.cmd.arg(\"--export\").arg(&sym);\n@@ -1144,8 +1159,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn no_position_independent_executable(&mut self) {}\n-\n     fn finalize(&mut self) {}\n \n     // Not needed for now with LLD\n@@ -1208,6 +1221,8 @@ impl<'a> Linker for PtxLinker<'a> {\n         &mut self.cmd\n     }\n \n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n     fn link_rlib(&mut self, path: &Path) {\n         self.cmd.arg(\"--rlib\").arg(path);\n     }\n@@ -1274,16 +1289,12 @@ impl<'a> Linker for PtxLinker<'a> {\n         panic!(\"frameworks not supported\")\n     }\n \n-    fn position_independent_executable(&mut self) {}\n-\n     fn full_relro(&mut self) {}\n \n     fn partial_relro(&mut self) {}\n \n     fn no_relro(&mut self) {}\n \n-    fn build_static_executable(&mut self) {}\n-\n     fn gc_sections(&mut self, _keep_metadata: bool) {}\n \n     fn pgo_gen(&mut self) {}\n@@ -1296,14 +1307,10 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.sess.warn(\"Windows Control Flow Guard is not supported by this linker.\");\n     }\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {}\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType) {}\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn no_position_independent_executable(&mut self) {}\n-\n     fn group_start(&mut self) {}\n \n     fn group_end(&mut self) {}"}]}