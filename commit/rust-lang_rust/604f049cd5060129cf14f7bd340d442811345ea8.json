{"sha": "604f049cd5060129cf14f7bd340d442811345ea8", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwNGYwNDljZDUwNjAxMjljZjE0ZjdiZDM0MGQ0NDI4MTEzNDVlYTg=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-10-10T18:35:41Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2017-10-10T18:35:41Z"}, "message": "Restore `T: Sized` on `ptr::is_null`\n\nThe exact semantics of `is_null` on unsized pointers are still debatable,\nespecially for trait objects.  It may be legal to call `*mut self`\nmethods on a trait object someday, as with Go interfaces, so `is_null`\nmight need to validate the vtable pointer too.\n\nFor `as_ref` and `as_mut`, we're assuming that you cannot have a non-null\ndata pointer with a null vtable, so casting the unsized check is fine.", "tree": {"sha": "63f8e90d66dc57fbae77142dc618feb61236fbf2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63f8e90d66dc57fbae77142dc618feb61236fbf2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/604f049cd5060129cf14f7bd340d442811345ea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/604f049cd5060129cf14f7bd340d442811345ea8", "html_url": "https://github.com/rust-lang/rust/commit/604f049cd5060129cf14f7bd340d442811345ea8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/604f049cd5060129cf14f7bd340d442811345ea8/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "40a678d8dbaea49a2e9f5451f4db68359a09f67a", "url": "https://api.github.com/repos/rust-lang/rust/commits/40a678d8dbaea49a2e9f5451f4db68359a09f67a", "html_url": "https://github.com/rust-lang/rust/commit/40a678d8dbaea49a2e9f5451f4db68359a09f67a"}], "stats": {"total": 70, "additions": 15, "deletions": 55}, "files": [{"sha": "f075d825f5d53f81f5f03bf8bf277c5596004fac", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/604f049cd5060129cf14f7bd340d442811345ea8/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604f049cd5060129cf14f7bd340d442811345ea8/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=604f049cd5060129cf14f7bd340d442811345ea8", "patch": "@@ -28,7 +28,8 @@ macro_rules! impl_zeroable_for_pointer_types {\n             unsafe impl<T: ?Sized> Zeroable for $Ptr {\n                 #[inline]\n                 fn is_zero(&self) -> bool {\n-                    (*self).is_null()\n+                    // Cast because `is_null` is only available on thin pointers\n+                    (*self as *mut u8).is_null()\n                 }\n             }\n         )+"}, {"sha": "7d0cdc27571f591ecb69b783f57df6a5027c9399", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/604f049cd5060129cf14f7bd340d442811345ea8/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604f049cd5060129cf14f7bd340d442811345ea8/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=604f049cd5060129cf14f7bd340d442811345ea8", "patch": "@@ -476,11 +476,6 @@ pub unsafe fn write_volatile<T>(dst: *mut T, src: T) {\n impl<T: ?Sized> *const T {\n     /// Returns `true` if the pointer is null.\n     ///\n-    /// Note that unsized types have many possible null pointers, as only the\n-    /// raw data pointer is considered, not their length, vtable, etc.\n-    /// Therefore, two pointers that are null may still not compare equal to\n-    /// each other.\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -492,10 +487,8 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_null(self) -> bool {\n-        // Compare via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        (self as *const u8) == null()\n+    pub fn is_null(self) -> bool where T: Sized {\n+        self == null()\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -527,7 +520,9 @@ impl<T: ?Sized> *const T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() {\n+        // Check for null via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        if (self as *const u8).is_null() {\n             None\n         } else {\n             Some(&*self)\n@@ -1114,11 +1109,6 @@ impl<T: ?Sized> *const T {\n impl<T: ?Sized> *mut T {\n     /// Returns `true` if the pointer is null.\n     ///\n-    /// Note that unsized types have many possible null pointers, as only the\n-    /// raw data pointer is considered, not their length, vtable, etc.\n-    /// Therefore, two pointers that are null may still not compare equal to\n-    /// each other.\n-    ///\n     /// # Examples\n     ///\n     /// Basic usage:\n@@ -1130,10 +1120,8 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n-    pub fn is_null(self) -> bool {\n-        // Compare via a cast to a thin pointer, so fat pointers are only\n-        // considering their \"data\" part for null-ness.\n-        (self as *mut u8) == null_mut()\n+    pub fn is_null(self) -> bool where T: Sized {\n+        self == null_mut()\n     }\n \n     /// Returns `None` if the pointer is null, or else returns a reference to\n@@ -1165,7 +1153,9 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_ref<'a>(self) -> Option<&'a T> {\n-        if self.is_null() {\n+        // Check for null via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        if (self as *const u8).is_null() {\n             None\n         } else {\n             Some(&*self)\n@@ -1289,7 +1279,9 @@ impl<T: ?Sized> *mut T {\n     #[stable(feature = \"ptr_as_ref\", since = \"1.9.0\")]\n     #[inline]\n     pub unsafe fn as_mut<'a>(self) -> Option<&'a mut T> {\n-        if self.is_null() {\n+        // Check for null via a cast to a thin pointer, so fat pointers are only\n+        // considering their \"data\" part for null-ness.\n+        if (self as *mut u8).is_null() {\n             None\n         } else {\n             Some(&mut *self)"}, {"sha": "e93e9be0cd50b378846ffe60fe6a99f3d13050cd", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/604f049cd5060129cf14f7bd340d442811345ea8/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/604f049cd5060129cf14f7bd340d442811345ea8/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=604f049cd5060129cf14f7bd340d442811345ea8", "patch": "@@ -62,39 +62,6 @@ fn test_is_null() {\n \n     let mq = unsafe { mp.offset(1) };\n     assert!(!mq.is_null());\n-\n-    // Pointers to unsized types -- slices\n-    let s: &mut [u8] = &mut [1, 2, 3];\n-    let cs: *const [u8] = s;\n-    assert!(!cs.is_null());\n-\n-    let ms: *mut [u8] = s;\n-    assert!(!ms.is_null());\n-\n-    let cz: *const [u8] = &[];\n-    assert!(!cz.is_null());\n-\n-    let mz: *mut [u8] = &mut [];\n-    assert!(!mz.is_null());\n-\n-    let ncs: *const [u8] = null::<[u8; 3]>();\n-    assert!(ncs.is_null());\n-\n-    let nms: *mut [u8] = null_mut::<[u8; 3]>();\n-    assert!(nms.is_null());\n-\n-    // Pointers to unsized types -- trait objects\n-    let ci: *const ToString = &3;\n-    assert!(!ci.is_null());\n-\n-    let mi: *mut ToString = &mut 3;\n-    assert!(!mi.is_null());\n-\n-    let nci: *const ToString = null::<isize>();\n-    assert!(nci.is_null());\n-\n-    let nmi: *mut ToString = null_mut::<isize>();\n-    assert!(nmi.is_null());\n }\n \n #[test]"}]}