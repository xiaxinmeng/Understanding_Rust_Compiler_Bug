{"sha": "f65f506d600282fdc45bfebf3cc0be29be33a325", "node_id": "C_kwDOAAsO6NoAKGY2NWY1MDZkNjAwMjgyZmRjNDViZmViZjNjYzBiZTI5YmUzM2EzMjU", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-09-04T22:36:01Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2023-04-20T17:48:52Z"}, "message": "Remove opt_const_param_of.", "tree": {"sha": "f96d73d606bfa1fd4243eb84f1dd208b36d0b492", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f96d73d606bfa1fd4243eb84f1dd208b36d0b492"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f65f506d600282fdc45bfebf3cc0be29be33a325", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f65f506d600282fdc45bfebf3cc0be29be33a325", "html_url": "https://github.com/rust-lang/rust/commit/f65f506d600282fdc45bfebf3cc0be29be33a325", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f65f506d600282fdc45bfebf3cc0be29be33a325/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b275d2c30b6e88cc48747f349f7137076d450658", "url": "https://api.github.com/repos/rust-lang/rust/commits/b275d2c30b6e88cc48747f349f7137076d450658", "html_url": "https://github.com/rust-lang/rust/commit/b275d2c30b6e88cc48747f349f7137076d450658"}], "stats": {"total": 276, "additions": 94, "deletions": 182}, "files": [{"sha": "36e294e8aa29f2a06f6852866323761329faf21b", "filename": "compiler/rustc_hir_analysis/src/collect.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f65f506d600282fdc45bfebf3cc0be29be33a325/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65f506d600282fdc45bfebf3cc0be29be33a325/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect.rs?ref=f65f506d600282fdc45bfebf3cc0be29be33a325", "patch": "@@ -55,7 +55,6 @@ fn collect_mod_item_types(tcx: TyCtxt<'_>, module_def_id: LocalDefId) {\n pub fn provide(providers: &mut Providers) {\n     resolve_bound_vars::provide(providers);\n     *providers = Providers {\n-        opt_const_param_of: type_of::opt_const_param_of,\n         type_of: type_of::type_of,\n         item_bounds: item_bounds::item_bounds,\n         explicit_item_bounds: item_bounds::explicit_item_bounds,"}, {"sha": "d7d509e5394bcb5a1cba2c5d267ebdca4b38bceb", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 94, "deletions": 158, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/f65f506d600282fdc45bfebf3cc0be29be33a325/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65f506d600282fdc45bfebf3cc0be29be33a325/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=f65f506d600282fdc45bfebf3cc0be29be33a325", "patch": "@@ -1,6 +1,6 @@\n use rustc_errors::{Applicability, StashKey};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::def_id::LocalDefId;\n use rustc_hir::intravisit;\n use rustc_hir::intravisit::Visitor;\n use rustc_hir::{HirId, Node};\n@@ -16,22 +16,81 @@ use super::ItemCtxt;\n use super::{bad_placeholder, is_suggestable_infer_ty};\n use crate::errors::UnconstrainedOpaqueType;\n \n-/// Computes the relevant generic parameter for a potential generic const argument.\n-///\n-/// This should be called using the query `tcx.opt_const_param_of`.\n-pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<DefId> {\n+fn anon_const_type_of<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> Ty<'tcx> {\n     use hir::*;\n     let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    match tcx.hir().get(hir_id) {\n-        Node::AnonConst(_) => (),\n-        _ => return None,\n-    };\n+    let Node::AnonConst(_) = tcx.hir().get(hir_id) else { panic!() };\n \n     let parent_node_id = tcx.hir().parent_id(hir_id);\n     let parent_node = tcx.hir().get(parent_node_id);\n \n     let (generics, arg_idx) = match parent_node {\n+        // Easy case: arrays repeat expressions.\n+        Node::Ty(&Ty { kind: TyKind::Array(_, ref constant), .. })\n+        | Node::Expr(&Expr { kind: ExprKind::Repeat(_, ref constant), .. })\n+            if constant.hir_id() == hir_id =>\n+        {\n+            return tcx.types.usize\n+        }\n+        Node::Ty(&Ty { kind: TyKind::Typeof(ref e), .. }) if e.hir_id == hir_id => {\n+            return tcx.typeck(def_id).node_type(e.hir_id)\n+        }\n+        Node::Expr(&Expr { kind: ExprKind::ConstBlock(ref anon_const), .. })\n+            if anon_const.hir_id == hir_id =>\n+        {\n+            let substs = InternalSubsts::identity_for_item(tcx, def_id.to_def_id());\n+            return substs.as_inline_const().ty()\n+        }\n+        Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n+        | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n+            if asm.operands.iter().any(|(op, _op_sp)| match op {\n+                hir::InlineAsmOperand::Const { anon_const }\n+                | hir::InlineAsmOperand::SymFn { anon_const } => anon_const.hir_id == hir_id,\n+                _ => false,\n+            }) =>\n+        {\n+            return tcx.typeck(def_id).node_type(hir_id)\n+        }\n+        Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+            return tcx\n+                .adt_def(tcx.hir().get_parent_item(hir_id))\n+                .repr()\n+                .discr_type()\n+                .to_ty(tcx)\n+        }\n+        Node::GenericParam(&GenericParam {\n+            def_id: param_def_id,\n+            kind: GenericParamKind::Const { default: Some(ct), .. },\n+            ..\n+        }) if ct.hir_id == hir_id => {\n+            return tcx.type_of(param_def_id)\n+                .no_bound_vars()\n+                .expect(\"const parameter types cannot be generic\")\n+        }\n+\n+        Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, ..  })\n+            if let Node::TraitRef(trait_ref) = tcx.hir().get(\n+                tcx.hir().parent_id(binding_id)\n+            ) =>\n+        {\n+            let Some(trait_def_id) = trait_ref.trait_def_id() else {\n+                return tcx.ty_error_with_message(tcx.def_span(def_id), \"Could not find trait\");\n+            };\n+            let assoc_items = tcx.associated_items(trait_def_id);\n+            let assoc_item = assoc_items.find_by_name_and_kind(\n+                tcx, binding.ident, ty::AssocKind::Const, def_id.to_def_id(),\n+            );\n+            return if let Some(assoc_item) = assoc_item {\n+                tcx.type_of(assoc_item.def_id)\n+                    .no_bound_vars()\n+                    .expect(\"const parameter types cannot be generic\")\n+            } else {\n+                // FIXME(associated_const_equality): add a useful error message here.\n+                tcx.ty_error_with_message(tcx.def_span(def_id), \"Could not find associated const on trait\")\n+            }\n+        }\n+\n         // This match arm is for when the def_id appears in a GAT whose\n         // path can't be resolved without typechecking e.g.\n         //\n@@ -86,11 +145,10 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                 (generics, arg_index)\n             } else {\n                 // I dont think it's possible to reach this but I'm not 100% sure - BoxyUwU\n-                tcx.sess.delay_span_bug(\n+                return tcx.ty_error_with_message(\n                     tcx.def_span(def_id),\n                     \"unexpected non-GAT usage of an anon const\",\n                 );\n-                return None;\n             }\n         }\n         Node::Expr(&Expr {\n@@ -103,7 +161,12 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             // This may fail in case the method/path does not actually exist.\n             // As there is no relevant param for `def_id`, we simply return\n             // `None` here.\n-            let type_dependent_def = tables.type_dependent_def_id(parent_node_id)?;\n+            let Some(type_dependent_def) = tables.type_dependent_def_id(parent_node_id) else {\n+                return tcx.ty_error_with_message(\n+                    tcx.def_span(def_id),\n+                    &format!(\"unable to find type-dependent def for {:?}\", parent_node_id),\n+                );\n+            };\n             let idx = segment\n                 .args\n                 .and_then(|args| {\n@@ -140,19 +203,17 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                     if let Some(path) = get_path_containing_arg_in_pat(pat, hir_id) {\n                         path\n                     } else {\n-                        tcx.sess.delay_span_bug(\n+                        return tcx.ty_error_with_message(\n                             tcx.def_span(def_id),\n                             &format!(\"unable to find const parent for {} in pat {:?}\", hir_id, pat),\n                         );\n-                        return None;\n                     }\n                 }\n                 _ => {\n-                    tcx.sess.delay_span_bug(\n+                    return tcx.ty_error_with_message(\n                         tcx.def_span(def_id),\n                         &format!(\"unexpected const parent path {:?}\", parent_node),\n                     );\n-                    return None;\n                 }\n             };\n \n@@ -171,32 +232,34 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n                     .position(|ct| ct.hir_id == hir_id)\n                     .map(|idx| (idx, seg)))\n             }) else {\n-                tcx.sess.delay_span_bug(\n+                return tcx.ty_error_with_message(\n                     tcx.def_span(def_id),\n                     \"no arg matching AnonConst in path\",\n                 );\n-                return None;\n             };\n \n             let generics = match tcx.res_generics_def_id(segment.res) {\n                 Some(def_id) => tcx.generics_of(def_id),\n                 None => {\n-                    tcx.sess.delay_span_bug(\n+                    return tcx.ty_error_with_message(\n                         tcx.def_span(def_id),\n                         &format!(\"unexpected anon const res {:?} in path: {:?}\", segment.res, path),\n                     );\n-                    return None;\n                 }\n             };\n \n             (generics, arg_index)\n         }\n-        _ => return None,\n+\n+        _ => return tcx.ty_error_with_message(\n+            tcx.def_span(def_id),\n+            &format!(\"unexpected const parent in type_of(): {parent_node:?}\"),\n+        ),\n     };\n \n     debug!(?parent_node);\n     debug!(?generics, ?arg_idx);\n-    generics\n+    if let Some(param_def_id) = generics\n         .params\n         .iter()\n         .filter(|param| param.kind.is_ty_or_const())\n@@ -211,6 +274,14 @@ pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<\n             }\n             _ => None,\n         })\n+    {\n+        tcx.type_of(param_def_id).no_bound_vars().expect(\"const parameter types cannot be generic\")\n+    } else {\n+        return tcx.ty_error_with_message(\n+            tcx.def_span(def_id),\n+            &format!(\"const generic parameter not found in {generics:?} at position {arg_idx:?}\"),\n+        );\n+    }\n }\n \n fn get_path_containing_arg_in_pat<'hir>(\n@@ -415,142 +486,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> ty::EarlyBinder<Ty\n             tcx.typeck(def_id).node_type(hir_id)\n         }\n \n-        Node::AnonConst(_) if let Some(param) = tcx.opt_const_param_of(def_id) => {\n-            // We defer to `type_of` of the corresponding parameter\n-            // for generic arguments.\n-            tcx.type_of(param).subst_identity()\n-        }\n-        Node::AnonConst(_) => {\n-            let parent_node = tcx.hir().get_parent(hir_id);\n-            match parent_node {\n-                Node::Ty(Ty { kind: TyKind::Array(_, constant), .. })\n-                | Node::Expr(Expr { kind: ExprKind::Repeat(_, constant), .. })\n-                    if constant.hir_id() == hir_id =>\n-                {\n-                    tcx.types.usize\n-                }\n-                Node::Ty(Ty { kind: TyKind::Typeof(e), .. }) if e.hir_id == hir_id => {\n-                    tcx.typeck(def_id).node_type(e.hir_id)\n-                }\n-\n-                Node::Expr(Expr { kind: ExprKind::ConstBlock(anon_const), .. })\n-                    if anon_const.hir_id == hir_id =>\n-                {\n-                    let substs = InternalSubsts::identity_for_item(tcx, def_id);\n-                    substs.as_inline_const().ty()\n-                }\n-\n-                Node::Expr(&Expr { kind: ExprKind::InlineAsm(asm), .. })\n-                | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n-                    if asm.operands.iter().any(|(op, _op_sp)| match op {\n-                        hir::InlineAsmOperand::Const { anon_const }\n-                        | hir::InlineAsmOperand::SymFn { anon_const } => {\n-                            anon_const.hir_id == hir_id\n-                        }\n-                        _ => false,\n-                    }) =>\n-                {\n-                    tcx.typeck(def_id).node_type(hir_id)\n-                }\n-\n-                Node::Variant(Variant { disr_expr: Some(e), .. }) if e.hir_id == hir_id => {\n-                    tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n-                }\n-\n-                Node::TypeBinding(TypeBinding {\n-                    hir_id: binding_id,\n-                    kind: TypeBindingKind::Equality { term: Term::Const(e) },\n-                    ident,\n-                    ..\n-                }) if let Node::TraitRef(trait_ref) = tcx.hir().get_parent(*binding_id)\n-                    && e.hir_id == hir_id =>\n-                {\n-                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n-                        return ty::EarlyBinder(tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\"));\n-                    };\n-                    let assoc_items = tcx.associated_items(trait_def_id);\n-                    let assoc_item = assoc_items.find_by_name_and_kind(\n-                        tcx,\n-                        *ident,\n-                        ty::AssocKind::Const,\n-                        def_id.to_def_id(),\n-                    );\n-                    if let Some(assoc_item) = assoc_item {\n-                        tcx.type_of(assoc_item.def_id)\n-                            .no_bound_vars()\n-                            .expect(\"const parameter types cannot be generic\")\n-                    } else {\n-                        // FIXME(associated_const_equality): add a useful error message here.\n-                        tcx.ty_error_with_message(\n-                            DUMMY_SP,\n-                            \"Could not find associated const on trait\",\n-                        )\n-                    }\n-                }\n-\n-                Node::TypeBinding(TypeBinding {\n-                    hir_id: binding_id,\n-                    gen_args,\n-                    kind,\n-                    ident,\n-                    ..\n-                }) if let Node::TraitRef(trait_ref) = tcx.hir().get_parent(*binding_id)\n-                    && let Some((idx, _)) =\n-                        gen_args.args.iter().enumerate().find(|(_, arg)| {\n-                            if let GenericArg::Const(ct) = arg {\n-                                ct.value.hir_id == hir_id\n-                            } else {\n-                                false\n-                            }\n-                        }) =>\n-                {\n-                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n-                        return ty::EarlyBinder(tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\"));\n-                    };\n-                    let assoc_items = tcx.associated_items(trait_def_id);\n-                    let assoc_item = assoc_items.find_by_name_and_kind(\n-                        tcx,\n-                        *ident,\n-                        match kind {\n-                            // I think `<A: T>` type bindings requires that `A` is a type\n-                            TypeBindingKind::Constraint { .. }\n-                            | TypeBindingKind::Equality { term: Term::Ty(..) } => {\n-                                ty::AssocKind::Type\n-                            }\n-                            TypeBindingKind::Equality { term: Term::Const(..) } => {\n-                                ty::AssocKind::Const\n-                            }\n-                        },\n-                        def_id.to_def_id(),\n-                    );\n-                    if let Some(assoc_item) = assoc_item\n-                        && let param = &tcx.generics_of(assoc_item.def_id).params[idx]\n-                        && matches!(param.kind, ty::GenericParamDefKind::Const { .. })\n-                    {\n-                        tcx.type_of(param.def_id)\n-                            .no_bound_vars()\n-                            .expect(\"const parameter types cannot be generic\")\n-                    } else {\n-                        // FIXME(associated_const_equality): add a useful error message here.\n-                        tcx.ty_error_with_message(\n-                            DUMMY_SP,\n-                            \"Could not find const param on associated item\",\n-                        )\n-                    }\n-                }\n-\n-                Node::GenericParam(&GenericParam {\n-                    def_id: param_def_id,\n-                    kind: GenericParamKind::Const { default: Some(ct), .. },\n-                    ..\n-                }) if ct.hir_id == hir_id => tcx.type_of(param_def_id).subst_identity(),\n-\n-                x => tcx.ty_error_with_message(\n-                    DUMMY_SP,\n-                    &format!(\"unexpected const parent in type_of(): {x:?}\"),\n-                ),\n-            }\n-        }\n+        Node::AnonConst(_) => anon_const_type_of(tcx, def_id),\n \n         Node::GenericParam(param) => match &param.kind {\n             GenericParamKind::Type { default: Some(ty), .. }"}, {"sha": "204ac97125d5f0bb84bafdd1b667c94d9d208854", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f65f506d600282fdc45bfebf3cc0be29be33a325/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f65f506d600282fdc45bfebf3cc0be29be33a325/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f65f506d600282fdc45bfebf3cc0be29be33a325", "patch": "@@ -127,29 +127,6 @@ rustc_queries! {\n         desc { |tcx| \"getting HIR owner attributes in `{}`\", tcx.def_path_str(key.to_def_id()) }\n     }\n \n-    /// Computes the `DefId` of the corresponding const parameter in case the `key` is a\n-    /// const argument and returns `None` otherwise.\n-    ///\n-    /// ```ignore (incomplete)\n-    /// let a = foo::<7>();\n-    /// //            ^ Calling `opt_const_param_of` for this argument,\n-    ///\n-    /// fn foo<const N: usize>()\n-    /// //           ^ returns this `DefId`.\n-    ///\n-    /// fn bar() {\n-    /// // ^ While calling `opt_const_param_of` for other bodies returns `None`.\n-    /// }\n-    /// ```\n-    // It looks like caching this query on disk actually slightly\n-    // worsened performance in #74376.\n-    //\n-    // Once const generics are more prevalently used, we might want to\n-    // consider only caching calls returning `Some`.\n-    query opt_const_param_of(key: LocalDefId) -> Option<DefId> {\n-        desc { |tcx| \"computing the optional const parameter of `{}`\", tcx.def_path_str(key.to_def_id()) }\n-    }\n-\n     /// Given the def_id of a const-generic parameter, computes the associated default const\n     /// parameter. e.g. `fn example<const N: usize=3>` called on `N` would return `3`.\n     query const_param_default(param: DefId) -> ty::EarlyBinder<ty::Const<'tcx>> {"}]}