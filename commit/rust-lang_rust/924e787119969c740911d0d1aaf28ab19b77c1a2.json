{"sha": "924e787119969c740911d0d1aaf28ab19b77c1a2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyNGU3ODcxMTk5NjljNzQwOTExZDBkMWFhZjI4YWIxOWI3N2MxYTI=", "commit": {"author": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-14T21:17:27Z"}, "committer": {"name": "Eric Holk", "email": "eric.holk@gmail.com", "date": "2012-08-16T23:46:19Z"}, "message": "Add std::comm with DuplexStream", "tree": {"sha": "7bd98e579824efd887664bf2c557238815809896", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7bd98e579824efd887664bf2c557238815809896"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/924e787119969c740911d0d1aaf28ab19b77c1a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/924e787119969c740911d0d1aaf28ab19b77c1a2", "html_url": "https://github.com/rust-lang/rust/commit/924e787119969c740911d0d1aaf28ab19b77c1a2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/924e787119969c740911d0d1aaf28ab19b77c1a2/comments", "author": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eholk", "id": 105766, "node_id": "MDQ6VXNlcjEwNTc2Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/105766?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eholk", "html_url": "https://github.com/eholk", "followers_url": "https://api.github.com/users/eholk/followers", "following_url": "https://api.github.com/users/eholk/following{/other_user}", "gists_url": "https://api.github.com/users/eholk/gists{/gist_id}", "starred_url": "https://api.github.com/users/eholk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eholk/subscriptions", "organizations_url": "https://api.github.com/users/eholk/orgs", "repos_url": "https://api.github.com/users/eholk/repos", "events_url": "https://api.github.com/users/eholk/events{/privacy}", "received_events_url": "https://api.github.com/users/eholk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "91622d03104c4d77c1c8bbb15e0600362f247db3", "url": "https://api.github.com/repos/rust-lang/rust/commits/91622d03104c4d77c1c8bbb15e0600362f247db3", "html_url": "https://github.com/rust-lang/rust/commit/91622d03104c4d77c1c8bbb15e0600362f247db3"}], "stats": {"total": 420, "additions": 251, "deletions": 169}, "files": [{"sha": "d6e59d6149fab1873300411283bc10f35ec7c8d4", "filename": "src/libstd/arc.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Farc.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -420,12 +420,11 @@ mod tests {\n         let v = ~[1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n         let arc_v = arc::arc(v);\n \n-        let p = port();\n-        let c = chan(p);\n+        let (c, p) = pipes::stream();\n \n         do task::spawn() {\n-            let p = port();\n-            c.send(chan(p));\n+            let p = pipes::port_set();\n+            c.send(p.chan());\n \n             let arc_v = p.recv();\n "}, {"sha": "c2f3518976ed5006a2bdd0cf1587454969cb1c64", "filename": "src/libstd/comm.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -0,0 +1,76 @@\n+/*!\n+\n+Higher level communication abstractions.\n+\n+*/\n+\n+// NB: transitionary, de-mode-ing.\n+#[forbid(deprecated_mode)];\n+#[forbid(deprecated_pattern)];\n+\n+// Make sure we follow the new conventions\n+#[forbid(non_camel_case_types)];\n+\n+import pipes::{channel, recv, chan, port, selectable};\n+\n+export DuplexStream;\n+\n+/// An extension of `pipes::stream` that allows both sending and receiving.\n+struct DuplexStream<T: send, U: send> : channel<T>, recv<U>, selectable {\n+    priv chan: chan<T>;\n+    priv port: port<U>;\n+\n+    fn send(+x: T) {\n+        self.chan.send(x)\n+    }\n+\n+    fn try_send(+x: T) -> bool {\n+        self.chan.try_send(x)\n+    }\n+\n+    fn recv() -> U {\n+        self.port.recv()\n+    }\n+\n+    fn try_recv() -> option<U> {\n+        self.port.try_recv()\n+    }\n+\n+    pure fn peek() -> bool {\n+        self.port.peek()\n+    }\n+\n+    pure fn header() -> *pipes::packet_header {\n+        self.port.header()\n+    }\n+}\n+\n+/// Creates a bidirectional stream.\n+fn DuplexStream<T: send, U: send>()\n+    -> (DuplexStream<T, U>, DuplexStream<U, T>)\n+{\n+    let (c2, p1) = pipes::stream();\n+    let (c1, p2) = pipes::stream();\n+    (DuplexStream {\n+        chan: c1,\n+        port: p1\n+    },\n+     DuplexStream {\n+         chan: c2,\n+         port: p2\n+     })\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    #[test]\n+    fn DuplexStream1() {\n+        let (left, right) = DuplexStream();\n+\n+        left.send(~\"abc\");\n+        right.send(123);\n+\n+        assert left.recv() == 123;\n+        assert right.recv() == ~\"abc\";\n+    }\n+}"}, {"sha": "bd4520e44a4f0f6520c2e0461e40d73ec523d238", "filename": "src/libstd/net_ip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_ip.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -19,6 +19,7 @@ import create_uv_getaddrinfo_t = uv::ll::getaddrinfo_t;\n import set_data_for_req = uv::ll::set_data_for_req;\n import get_data_for_req = uv::ll::get_data_for_req;\n import ll = uv::ll;\n+import comm = core::comm;\n \n export ip_addr, parse_addr_err;\n export format_addr;\n@@ -85,7 +86,7 @@ enum ip_get_addr_err {\n  */\n fn get_addr(++node: ~str, iotask: iotask)\n         -> result::result<~[ip_addr], ip_get_addr_err> unsafe {\n-    do comm::listen |output_ch| {\n+    do core::comm::listen |output_ch| {\n         do str::as_buf(node) |node_ptr, len| {\n             log(debug, fmt!{\"slice len %?\", len});\n             let handle = create_uv_getaddrinfo_t();"}, {"sha": "e14b15b4eff2e5d56a69d7fc3943759f32b0d1c1", "filename": "src/libstd/net_tcp.rs", "status": "modified", "additions": 94, "deletions": 91, "changes": 185, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet_tcp.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -9,6 +9,7 @@ import future_spawn = future::spawn;\n import result::*;\n import libc::size_t;\n import io::{Reader, Writer};\n+import comm = core::comm;\n \n // tcp interfaces\n export tcp_socket;\n@@ -120,19 +121,19 @@ enum tcp_connect_err_data {\n fn connect(-input_ip: ip::ip_addr, port: uint,\n            iotask: iotask)\n     -> result::result<tcp_socket, tcp_connect_err_data> unsafe {\n-    let result_po = comm::port::<conn_attempt>();\n-    let closed_signal_po = comm::port::<()>();\n+    let result_po = core::comm::port::<conn_attempt>();\n+    let closed_signal_po = core::comm::port::<()>();\n     let conn_data = {\n-        result_ch: comm::chan(result_po),\n-        closed_signal_ch: comm::chan(closed_signal_po)\n+        result_ch: core::comm::chan(result_po),\n+        closed_signal_ch: core::comm::chan(closed_signal_po)\n     };\n     let conn_data_ptr = ptr::addr_of(conn_data);\n-    let reader_po = comm::port::<result::result<~[u8], tcp_err_data>>();\n+    let reader_po = core::comm::port::<result::result<~[u8], tcp_err_data>>();\n     let stream_handle_ptr = malloc_uv_tcp_t();\n     *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n     let socket_data = @{\n         reader_po: reader_po,\n-        reader_ch: comm::chan(reader_po),\n+        reader_ch: core::comm::chan(reader_po),\n         stream_handle_ptr: stream_handle_ptr,\n         connect_req: uv::ll::connect_t(),\n         write_req: uv::ll::write_t(),\n@@ -202,7 +203,7 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n                     // immediate connect failure.. probably a garbage\n                     // ip or somesuch\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    comm::send((*conn_data_ptr).result_ch,\n+                    core::comm::send((*conn_data_ptr).result_ch,\n                                conn_failure(err_data.to_tcp_err()));\n                     uv::ll::set_data_for_uv_handle(stream_handle_ptr,\n                                                    conn_data_ptr);\n@@ -215,18 +216,18 @@ fn connect(-input_ip: ip::ip_addr, port: uint,\n           _ => {\n             // failure to create a tcp handle\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send((*conn_data_ptr).result_ch,\n+            core::comm::send((*conn_data_ptr).result_ch,\n                        conn_failure(err_data.to_tcp_err()));\n           }\n         }\n     };\n-    match comm::recv(result_po) {\n+    match core::comm::recv(result_po) {\n       conn_success => {\n         log(debug, ~\"tcp::connect - received success on result_po\");\n         result::ok(tcp_socket(socket_data))\n       }\n       conn_failure(err_data) => {\n-        comm::recv(closed_signal_po);\n+        core::comm::recv(closed_signal_po);\n         log(debug, ~\"tcp::connect - received failure on result_po\");\n         // still have to free the malloc'd stream handle..\n         rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n@@ -311,8 +312,9 @@ fn write_future(sock: tcp_socket, raw_write_data: ~[u8])\n  * # Returns\n  *\n  * * A `result` instance that will either contain a\n- * `comm::port<tcp_read_result>` that the user can read (and optionally, loop\n- * on) from until `read_stop` is called, or a `tcp_err_data` record\n+ * `core::comm::port<tcp_read_result>` that the user can read (and\n+ * optionally, loop on) from until `read_stop` is called, or a\n+ * `tcp_err_data` record\n  */\n fn read_start(sock: tcp_socket)\n     -> result::result<comm::Port<\n@@ -428,23 +430,23 @@ fn read_future(sock: tcp_socket, timeout_msecs: uint)\n  *     }\n  *     // this callback is ran when a new connection arrives\n  *     {|new_conn, kill_ch|\n- *     let cont_po = comm::port::<option<tcp_err_data>>();\n- *     let cont_ch = comm::chan(cont_po);\n+ *     let cont_po = core::comm::port::<option<tcp_err_data>>();\n+ *     let cont_ch = core::comm::chan(cont_po);\n  *     task::spawn {||\n  *         let accept_result = net::tcp::accept(new_conn);\n  *         if accept_result.is_err() {\n- *             comm::send(cont_ch, result::get_err(accept_result));\n+ *             core::comm::send(cont_ch, result::get_err(accept_result));\n  *             // fail?\n  *         }\n  *         else {\n  *             let sock = result::get(accept_result);\n- *             comm::send(cont_ch, true);\n+ *             core::comm::send(cont_ch, true);\n  *             // do work here\n  *         }\n  *     };\n- *     match comm::recv(cont_po) {\n+ *     match core::comm::recv(cont_po) {\n  *       // shut down listen()\n- *       some(err_data) { comm::send(kill_chan, some(err_data)) }\n+ *       some(err_data) { core::comm::send(kill_chan, some(err_data)) }\n  *       // wait for next connection\n  *       none {}\n  *     }\n@@ -470,13 +472,13 @@ fn accept(new_conn: tcp_new_connection)\n       new_tcp_conn(server_handle_ptr) => {\n         let server_data_ptr = uv::ll::get_data_for_uv_handle(\n             server_handle_ptr) as *tcp_listen_fc_data;\n-        let reader_po = comm::port::<result::result<~[u8], tcp_err_data>>();\n+        let reader_po = core::comm::port();\n         let iotask = (*server_data_ptr).iotask;\n         let stream_handle_ptr = malloc_uv_tcp_t();\n         *(stream_handle_ptr as *mut uv::ll::uv_tcp_t) = uv::ll::tcp_t();\n         let client_socket_data = @{\n             reader_po: reader_po,\n-            reader_ch: comm::chan(reader_po),\n+            reader_ch: core::comm::chan(reader_po),\n             stream_handle_ptr : stream_handle_ptr,\n             connect_req : uv::ll::connect_t(),\n             write_req : uv::ll::write_t(),\n@@ -486,8 +488,8 @@ fn accept(new_conn: tcp_new_connection)\n         let client_stream_handle_ptr =\n             (*client_socket_data_ptr).stream_handle_ptr;\n \n-        let result_po = comm::port::<option<tcp_err_data>>();\n-        let result_ch = comm::chan(result_po);\n+        let result_po = core::comm::port::<option<tcp_err_data>>();\n+        let result_ch = core::comm::chan(result_po);\n \n         // UNSAFE LIBUV INTERACTION BEGIN\n         // .. normally this happens within the context of\n@@ -509,23 +511,23 @@ fn accept(new_conn: tcp_new_connection)\n                 uv::ll::set_data_for_uv_handle(client_stream_handle_ptr,\n                                                client_socket_data_ptr\n                                                    as *libc::c_void);\n-                comm::send(result_ch, none);\n+                core::comm::send(result_ch, none);\n               }\n               _ => {\n                 log(debug, ~\"failed to accept client conn\");\n-                comm::send(result_ch, some(\n+                core::comm::send(result_ch, some(\n                     uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n               }\n             }\n           }\n           _ => {\n             log(debug, ~\"failed to init client stream\");\n-            comm::send(result_ch, some(\n+            core::comm::send(result_ch, some(\n                 uv::ll::get_last_err_data(loop_ptr).to_tcp_err()));\n           }\n         }\n         // UNSAFE LIBUV INTERACTION END\n-        match comm::recv(result_po) {\n+        match core::comm::recv(result_po) {\n           some(err_data) => result::err(err_data),\n           none => result::ok(tcp_socket(client_socket_data))\n         }\n@@ -551,8 +553,8 @@ fn accept(new_conn: tcp_new_connection)\n  * callback's arguments are:\n  *     * `new_conn` - an opaque type that can be passed to\n  *     `net::tcp::accept` in order to be converted to a `tcp_socket`.\n- *     * `kill_ch` - channel of type `comm::chan<option<tcp_err_data>>`. this\n- *     channel can be used to send a message to cause `listen` to begin\n+ *     * `kill_ch` - channel of type `core::comm::chan<option<tcp_err_data>>`.\n+ *     this channel can be used to send a message to cause `listen` to begin\n  *     closing the underlying libuv data structures.\n  *\n  * # returns\n@@ -583,28 +585,28 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n           on_establish_cb: fn~(comm::Chan<option<tcp_err_data>>),\n           -on_connect_cb: fn~(*uv::ll::uv_tcp_t))\n     -> result::result<(), tcp_listen_err_data> unsafe {\n-    let stream_closed_po = comm::port::<()>();\n-    let kill_po = comm::port::<option<tcp_err_data>>();\n-    let kill_ch = comm::chan(kill_po);\n+    let stream_closed_po = core::comm::port::<()>();\n+    let kill_po = core::comm::port::<option<tcp_err_data>>();\n+    let kill_ch = core::comm::chan(kill_po);\n     let server_stream = uv::ll::tcp_t();\n     let server_stream_ptr = ptr::addr_of(server_stream);\n     let server_data = {\n         server_stream_ptr: server_stream_ptr,\n-        stream_closed_ch: comm::chan(stream_closed_po),\n+        stream_closed_ch: core::comm::chan(stream_closed_po),\n         kill_ch: kill_ch,\n         on_connect_cb: on_connect_cb,\n         iotask: iotask,\n         mut active: true\n     };\n     let server_data_ptr = ptr::addr_of(server_data);\n \n-    let setup_result = do comm::listen |setup_ch| {\n+    let setup_result = do core::comm::listen |setup_ch| {\n         // this is to address a compiler warning about\n         // an implicit copy.. it seems that double nested\n         // will defeat a move sigil, as is done to the host_ip\n         // arg above.. this same pattern works w/o complaint in\n         // tcp::connect (because the iotask::interact cb isn't\n-        // nested within a comm::listen block)\n+        // nested within a core::comm::listen block)\n         let loc_ip = copy(host_ip);\n         do iotask::interact(iotask) |loop_ptr| {\n             match uv::ll::tcp_init(loop_ptr, server_stream_ptr) {\n@@ -632,25 +634,25 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n                     match uv::ll::listen(server_stream_ptr,\n                                        backlog as libc::c_int,\n                                        tcp_lfc_on_connection_cb) {\n-                      0i32 => comm::send(setup_ch, none),\n+                      0i32 => core::comm::send(setup_ch, none),\n                       _ => {\n                         log(debug, ~\"failure to uv_listen()\");\n                         let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                        comm::send(setup_ch, some(err_data));\n+                        core::comm::send(setup_ch, some(err_data));\n                       }\n                     }\n                   }\n                   _ => {\n                     log(debug, ~\"failure to uv_tcp_bind\");\n                     let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                    comm::send(setup_ch, some(err_data));\n+                    core::comm::send(setup_ch, some(err_data));\n                   }\n                 }\n               }\n               _ => {\n                 log(debug, ~\"failure to uv_tcp_init\");\n                 let err_data = uv::ll::get_last_err_data(loop_ptr);\n-                comm::send(setup_ch, some(err_data));\n+                core::comm::send(setup_ch, some(err_data));\n               }\n             }\n         };\n@@ -684,7 +686,7 @@ fn listen_common(-host_ip: ip::ip_addr, port: uint, backlog: uint,\n       }\n       none => {\n         on_establish_cb(kill_ch);\n-        let kill_result = comm::recv(kill_po);\n+        let kill_result = core::comm::recv(kill_po);\n         do iotask::interact(iotask) |loop_ptr| {\n             log(debug, fmt!{\"tcp::listen post-kill recv hl interact %?\",\n                             loop_ptr});\n@@ -835,8 +837,8 @@ impl @tcp_socket_buf: io::Writer {\n // INTERNAL API\n \n fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n-    let closed_po = comm::port::<()>();\n-    let closed_ch = comm::chan(closed_po);\n+    let closed_po = core::comm::port::<()>();\n+    let closed_ch = core::comm::chan(closed_po);\n     let close_data = {\n         closed_ch: closed_ch\n     };\n@@ -849,7 +851,7 @@ fn tear_down_socket_data(socket_data: @tcp_socket_data) unsafe {\n                                        close_data_ptr);\n         uv::ll::close(stream_handle_ptr, tcp_socket_dtor_close_cb);\n     };\n-    comm::recv(closed_po);\n+    core::comm::recv(closed_po);\n     log(debug, fmt!{\"about to free socket_data at %?\", socket_data});\n     rustrt::rust_uv_current_kernel_free(stream_handle_ptr\n                                        as *libc::c_void);\n@@ -872,7 +874,7 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n             timer::recv_timeout(\n                iotask, timeout_msecs, result::get(rs_result))\n         } else {\n-            some(comm::recv(result::get(rs_result)))\n+            some(core::comm::recv(result::get(rs_result)))\n         };\n         log(debug, ~\"tcp::read after recv_timeout\");\n         match read_result {\n@@ -898,23 +900,23 @@ fn read_common_impl(socket_data: *tcp_socket_data, timeout_msecs: uint)\n fn read_stop_common_impl(socket_data: *tcp_socket_data) ->\n     result::result<(), tcp_err_data> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let stop_po = comm::port::<option<tcp_err_data>>();\n-    let stop_ch = comm::chan(stop_po);\n+    let stop_po = core::comm::port::<option<tcp_err_data>>();\n+    let stop_ch = core::comm::chan(stop_po);\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n         log(debug, ~\"in interact cb for tcp::read_stop\");\n         match uv::ll::read_stop(stream_handle_ptr as *uv::ll::uv_stream_t) {\n           0i32 => {\n             log(debug, ~\"successfully called uv_read_stop\");\n-            comm::send(stop_ch, none);\n+            core::comm::send(stop_ch, none);\n           }\n           _ => {\n             log(debug, ~\"failure in calling uv_read_stop\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send(stop_ch, some(err_data.to_tcp_err()));\n+            core::comm::send(stop_ch, some(err_data.to_tcp_err()));\n           }\n         }\n     };\n-    match comm::recv(stop_po) {\n+    match core::comm::recv(stop_po) {\n       some(err_data) => result::err(err_data.to_tcp_err()),\n       none => result::ok(())\n     }\n@@ -925,8 +927,8 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n     -> result::result<comm::Port<\n         result::result<~[u8], tcp_err_data>>, tcp_err_data> unsafe {\n     let stream_handle_ptr = (*socket_data).stream_handle_ptr;\n-    let start_po = comm::port::<option<uv::ll::uv_err_data>>();\n-    let start_ch = comm::chan(start_po);\n+    let start_po = core::comm::port::<option<uv::ll::uv_err_data>>();\n+    let start_ch = core::comm::chan(start_po);\n     log(debug, ~\"in tcp::read_start before interact loop\");\n     do iotask::interact((*socket_data).iotask) |loop_ptr| {\n         log(debug, fmt!{\"in tcp::read_start interact cb %?\", loop_ptr});\n@@ -935,16 +937,16 @@ fn read_start_common_impl(socket_data: *tcp_socket_data)\n                                on_tcp_read_cb) {\n           0i32 => {\n             log(debug, ~\"success doing uv_read_start\");\n-            comm::send(start_ch, none);\n+            core::comm::send(start_ch, none);\n           }\n           _ => {\n             log(debug, ~\"error attempting uv_read_start\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send(start_ch, some(err_data));\n+            core::comm::send(start_ch, some(err_data));\n           }\n         }\n     };\n-    match comm::recv(start_po) {\n+    match core::comm::recv(start_po) {\n       some(err_data) => result::err(err_data.to_tcp_err()),\n       none => result::ok((*socket_data).reader_po)\n     }\n@@ -963,9 +965,9 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n         vec::unsafe::to_ptr(raw_write_data),\n         vec::len(raw_write_data)) ];\n     let write_buf_vec_ptr = ptr::addr_of(write_buf_vec);\n-    let result_po = comm::port::<tcp_write_result>();\n+    let result_po = core::comm::port::<tcp_write_result>();\n     let write_data = {\n-        result_ch: comm::chan(result_po)\n+        result_ch: core::comm::chan(result_po)\n     };\n     let write_data_ptr = ptr::addr_of(write_data);\n     do iotask::interact((*socket_data_ptr).iotask) |loop_ptr| {\n@@ -981,7 +983,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n           _ => {\n             log(debug, ~\"error invoking uv_write()\");\n             let err_data = uv::ll::get_last_err_data(loop_ptr);\n-            comm::send((*write_data_ptr).result_ch,\n+            core::comm::send((*write_data_ptr).result_ch,\n                        tcp_write_error(err_data.to_tcp_err()));\n           }\n         }\n@@ -990,7 +992,7 @@ fn write_common_impl(socket_data_ptr: *tcp_socket_data,\n     // and waiting here for the write to complete, we should transfer\n     // ownership of everything to the I/O task and let it deal with the\n     // aftermath, so we don't have to sit here blocking.\n-    match comm::recv(result_po) {\n+    match core::comm::recv(result_po) {\n       tcp_write_success => result::ok(()),\n       tcp_write_error(err_data) => result::err(err_data.to_tcp_err())\n     }\n@@ -1012,7 +1014,7 @@ type tcp_listen_fc_data = {\n extern fn tcp_lfc_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let server_data_ptr = uv::ll::get_data_for_uv_handle(\n         handle) as *tcp_listen_fc_data;\n-    comm::send((*server_data_ptr).stream_closed_ch, ());\n+    core::comm::send((*server_data_ptr).stream_closed_ch, ());\n }\n \n extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n@@ -1025,7 +1027,7 @@ extern fn tcp_lfc_on_connection_cb(handle: *uv::ll::uv_tcp_t,\n           0i32 => (*server_data_ptr).on_connect_cb(handle),\n           _ => {\n             let loop_ptr = uv::ll::get_loop_for_uv_handle(handle);\n-            comm::send(kill_ch,\n+            core::comm::send(kill_ch,\n                        some(uv::ll::get_last_err_data(loop_ptr)\n                             .to_tcp_err()));\n             (*server_data_ptr).active = false;\n@@ -1085,7 +1087,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         log(debug, fmt!{\"on_tcp_read_cb: incoming err.. name %? msg %?\",\n                         err_data.err_name, err_data.err_msg});\n         let reader_ch = (*socket_data_ptr).reader_ch;\n-        comm::send(reader_ch, result::err(err_data));\n+        core::comm::send(reader_ch, result::err(err_data));\n       }\n       // do nothing .. unneeded buf\n       0 => (),\n@@ -1096,7 +1098,7 @@ extern fn on_tcp_read_cb(stream: *uv::ll::uv_stream_t,\n         let reader_ch = (*socket_data_ptr).reader_ch;\n         let buf_base = uv::ll::get_base_from_buf(buf);\n         let new_bytes = vec::unsafe::from_buf(buf_base, nread as uint);\n-        comm::send(reader_ch, result::ok(new_bytes));\n+        core::comm::send(reader_ch, result::ok(new_bytes));\n       }\n     }\n     uv::ll::free_base_of_buf(buf);\n@@ -1123,7 +1125,7 @@ extern fn tcp_socket_dtor_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let data = uv::ll::get_data_for_uv_handle(handle)\n         as *tcp_socket_close_data;\n     let closed_ch = (*data).closed_ch;\n-    comm::send(closed_ch, ());\n+    core::comm::send(closed_ch, ());\n     log(debug, ~\"tcp_socket_dtor_close_cb exiting..\");\n }\n \n@@ -1133,14 +1135,15 @@ extern fn tcp_write_complete_cb(write_req: *uv::ll::uv_write_t,\n         as *write_req_data;\n     if status == 0i32 {\n         log(debug, ~\"successful write complete\");\n-        comm::send((*write_data_ptr).result_ch, tcp_write_success);\n+        core::comm::send((*write_data_ptr).result_ch, tcp_write_success);\n     } else {\n         let stream_handle_ptr = uv::ll::get_stream_handle_from_write_req(\n             write_req);\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(stream_handle_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, ~\"failure to write\");\n-        comm::send((*write_data_ptr).result_ch, tcp_write_error(err_data));\n+        core::comm::send((*write_data_ptr).result_ch,\n+                         tcp_write_error(err_data));\n     }\n }\n \n@@ -1156,7 +1159,7 @@ type connect_req_data = {\n extern fn stream_error_close_cb(handle: *uv::ll::uv_tcp_t) unsafe {\n     let data = uv::ll::get_data_for_uv_handle(handle) as\n         *connect_req_data;\n-    comm::send((*data).closed_signal_ch, ());\n+    core::comm::send((*data).closed_signal_ch, ());\n     log(debug, fmt!{\"exiting steam_error_close_cb for %?\", handle});\n }\n \n@@ -1175,15 +1178,15 @@ extern fn tcp_connect_on_connect_cb(connect_req_ptr: *uv::ll::uv_connect_t,\n     match status {\n       0i32 => {\n         log(debug, ~\"successful tcp connection!\");\n-        comm::send(result_ch, conn_success);\n+        core::comm::send(result_ch, conn_success);\n       }\n       _ => {\n         log(debug, ~\"error in tcp_connect_on_connect_cb\");\n         let loop_ptr = uv::ll::get_loop_for_uv_handle(tcp_stream_ptr);\n         let err_data = uv::ll::get_last_err_data(loop_ptr);\n         log(debug, fmt!{\"err_data %? %?\", err_data.err_name,\n                         err_data.err_msg});\n-        comm::send(result_ch, conn_failure(err_data));\n+        core::comm::send(result_ch, conn_failure(err_data));\n         uv::ll::set_data_for_uv_handle(tcp_stream_ptr,\n                                        conn_data_ptr);\n         uv::ll::close(tcp_stream_ptr, stream_error_close_cb);\n@@ -1279,11 +1282,11 @@ mod test {\n         let expected_req = ~\"ping\";\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = comm::port::<~str>();\n-        let server_result_ch = comm::chan(server_result_po);\n+        let server_result_po = core::comm::port::<~str>();\n+        let server_result_ch = core::comm::chan(server_result_po);\n \n-        let cont_po = comm::port::<()>();\n-        let cont_ch = comm::chan(cont_po);\n+        let cont_po = core::comm::port::<()>();\n+        let cont_ch = core::comm::chan(cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do comm::listen |server_ch| {\n@@ -1297,10 +1300,10 @@ mod test {\n             };\n             server_result_ch.send(actual_req);\n         };\n-        comm::recv(cont_po);\n+        core::comm::recv(cont_po);\n         // client\n         log(debug, ~\"server started, firing up client..\");\n-        let actual_resp_result = do comm::listen |client_ch| {\n+        let actual_resp_result = do core::comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1310,7 +1313,7 @@ mod test {\n         };\n         assert actual_resp_result.is_ok();\n         let actual_resp = actual_resp_result.get();\n-        let actual_req = comm::recv(server_result_po);\n+        let actual_req = core::comm::recv(server_result_po);\n         log(debug, fmt!{\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req});\n         log(debug, fmt!{\"RESP: expected: '%s' actual: '%s'\",\n@@ -1325,7 +1328,7 @@ mod test {\n         let expected_req = ~\"ping\";\n         // client\n         log(debug, ~\"firing up client..\");\n-        let actual_resp_result = do comm::listen |client_ch| {\n+        let actual_resp_result = do core::comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1345,11 +1348,11 @@ mod test {\n         let expected_req = ~\"ping\";\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = comm::port::<~str>();\n-        let server_result_ch = comm::chan(server_result_po);\n+        let server_result_po = core::comm::port::<~str>();\n+        let server_result_ch = core::comm::chan(server_result_po);\n \n-        let cont_po = comm::port::<()>();\n-        let cont_ch = comm::chan(cont_po);\n+        let cont_po = core::comm::port::<()>();\n+        let cont_ch = core::comm::chan(cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do comm::listen |server_ch| {\n@@ -1363,15 +1366,15 @@ mod test {\n             };\n             server_result_ch.send(actual_req);\n         };\n-        comm::recv(cont_po);\n+        core::comm::recv(cont_po);\n         // this one should fail..\n         let listen_err = run_tcp_test_server_fail(\n                             server_ip,\n                             server_port,\n                             hl_loop);\n         // client.. just doing this so that the first server tears down\n         log(debug, ~\"server started, firing up client..\");\n-        do comm::listen |client_ch| {\n+        do core::comm::listen |client_ch| {\n             run_tcp_test_client(\n                 server_ip,\n                 server_port,\n@@ -1415,11 +1418,11 @@ mod test {\n         let expected_req = ~\"ping\";\n         let expected_resp = ~\"pong\";\n \n-        let server_result_po = comm::port::<~str>();\n-        let server_result_ch = comm::chan(server_result_po);\n+        let server_result_po = core::comm::port::<~str>();\n+        let server_result_ch = core::comm::chan(server_result_po);\n \n-        let cont_po = comm::port::<()>();\n-        let cont_ch = comm::chan(cont_po);\n+        let cont_po = core::comm::port::<()>();\n+        let cont_ch = core::comm::chan(cont_po);\n         // server\n         do task::spawn_sched(task::ManualThreads(1u)) {\n             let actual_req = do comm::listen |server_ch| {\n@@ -1433,7 +1436,7 @@ mod test {\n             };\n             server_result_ch.send(actual_req);\n         };\n-        comm::recv(cont_po);\n+        core::comm::recv(cont_po);\n         // client\n         let server_addr = ip::v4::parse_addr(server_ip);\n         let conn_result = connect(server_addr, server_port, iotask);\n@@ -1449,7 +1452,7 @@ mod test {\n                      vec::len(resp_buf))\n         };\n \n-        let actual_req = comm::recv(server_result_po);\n+        let actual_req = core::comm::recv(server_result_po);\n         log(debug, fmt!{\"REQ: expected: '%s' actual: '%s'\",\n                        expected_req, actual_req});\n         log(debug, fmt!{\"RESP: expected: '%s' actual: '%s'\",\n@@ -1484,7 +1487,7 @@ mod test {\n             |kill_ch| {\n                 log(debug, fmt!{\"establish_cb %?\",\n                     kill_ch});\n-                comm::send(cont_ch, ());\n+                core::comm::send(cont_ch, ());\n             },\n             // risky to run this on the loop, but some users\n             // will want the POWER\n@@ -1499,7 +1502,7 @@ mod test {\n                     if result::is_err(accept_result) {\n                         log(debug, ~\"SERVER: error accept connection\");\n                         let err_data = result::get_err(accept_result);\n-                        comm::send(kill_ch, some(err_data));\n+                        core::comm::send(kill_ch, some(err_data));\n                         log(debug,\n                             ~\"SERVER/WORKER: send on err cont ch\");\n                         cont_ch.send(());\n@@ -1522,12 +1525,12 @@ mod test {\n                             log(debug, ~\"SERVER: before write\");\n                             tcp_write_single(sock, str::bytes(resp));\n                             log(debug, ~\"SERVER: after write.. die\");\n-                            comm::send(kill_ch, none);\n+                            core::comm::send(kill_ch, none);\n                           }\n                           result::err(err_data) => {\n                             log(debug, fmt!{\"SERVER: error recvd: %s %s\",\n                                 err_data.err_name, err_data.err_msg});\n-                            comm::send(kill_ch, some(err_data));\n+                            core::comm::send(kill_ch, some(err_data));\n                             server_ch.send(~\"\");\n                           }\n                         }"}, {"sha": "7dbb07a6aad6d1a1e30e04d9850d4e662e9a631a", "filename": "src/libstd/par.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fpar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fpar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpar.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -1,7 +1,3 @@\n-import comm::port;\n-import comm::chan;\n-import comm::send;\n-import comm::recv;\n import future_spawn = future::spawn;\n \n export map, mapi, alli, any, mapi_factory;"}, {"sha": "91a4ff23c19931876c426c129419a28d6ace58c2", "filename": "src/libstd/std.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstd.rc?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -52,6 +52,7 @@ mod cell;\n \n mod sync;\n mod arc;\n+mod comm;\n \n // Collections\n "}, {"sha": "09bde8d6b3f72f5164147a2db3017a3a6d46df33", "filename": "src/libstd/test.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftest.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -10,6 +10,7 @@ import result::{ok, err};\n import io::WriterUtil;\n import libc::size_t;\n import task::TaskBuilder;\n+import comm = core::comm;\n \n export test_name;\n export test_fn;\n@@ -285,8 +286,8 @@ fn run_tests(opts: test_opts, tests: ~[test_desc],\n     let mut wait_idx = 0u;\n     let mut done_idx = 0u;\n \n-    let p = comm::port();\n-    let ch = comm::chan(p);\n+    let p = core::comm::port();\n+    let ch = core::comm::chan(p);\n \n     while done_idx < total {\n         while wait_idx < concurrency && run_idx < total {\n@@ -302,7 +303,7 @@ fn run_tests(opts: test_opts, tests: ~[test_desc],\n             run_idx += 1u;\n         }\n \n-        let (test, result) = comm::recv(p);\n+        let (test, result) = core::comm::recv(p);\n         if concurrency != 1u {\n             callback(te_wait(copy test));\n         }\n@@ -381,7 +382,7 @@ type test_future = {test: test_desc, wait: fn@() -> test_result};\n \n fn run_test(+test: test_desc, monitor_ch: comm::Chan<monitor_msg>) {\n     if test.ignore {\n-        comm::send(monitor_ch, (copy test, tr_ignored));\n+        core::comm::send(monitor_ch, (copy test, tr_ignored));\n         return;\n     }\n \n@@ -419,10 +420,10 @@ mod tests {\n             ignore: true,\n             should_fail: false\n         };\n-        let p = comm::port();\n-        let ch = comm::chan(p);\n+        let p = core::comm::port();\n+        let ch = core::comm::chan(p);\n         run_test(desc, ch);\n-        let (_, res) = comm::recv(p);\n+        let (_, res) = core::comm::recv(p);\n         assert res != tr_ok;\n     }\n \n@@ -435,10 +436,10 @@ mod tests {\n             ignore: true,\n             should_fail: false\n         };\n-        let p = comm::port();\n-        let ch = comm::chan(p);\n+        let p = core::comm::port();\n+        let ch = core::comm::chan(p);\n         run_test(desc, ch);\n-        let (_, res) = comm::recv(p);\n+        let (_, res) = core::comm::recv(p);\n         assert res == tr_ignored;\n     }\n \n@@ -452,10 +453,10 @@ mod tests {\n             ignore: false,\n             should_fail: true\n         };\n-        let p = comm::port();\n-        let ch = comm::chan(p);\n+        let p = core::comm::port();\n+        let ch = core::comm::chan(p);\n         run_test(desc, ch);\n-        let (_, res) = comm::recv(p);\n+        let (_, res) = core::comm::recv(p);\n         assert res == tr_ok;\n     }\n \n@@ -468,10 +469,10 @@ mod tests {\n             ignore: false,\n             should_fail: true\n         };\n-        let p = comm::port();\n-        let ch = comm::chan(p);\n+        let p = core::comm::port();\n+        let ch = core::comm::chan(p);\n         run_test(desc, ch);\n-        let (_, res) = comm::recv(p);\n+        let (_, res) = core::comm::recv(p);\n         assert res == tr_failed;\n     }\n "}, {"sha": "6be8ff05bbac5c46321a3ceec3fd7063460efd86", "filename": "src/libstd/timer.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftimer.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -3,6 +3,8 @@\n import uv = uv;\n import uv::iotask;\n import iotask::iotask;\n+import comm = core::comm;\n+\n export delayed_send, sleep, recv_timeout;\n \n /**\n@@ -24,8 +26,8 @@ export delayed_send, sleep, recv_timeout;\n fn delayed_send<T: copy send>(iotask: iotask,\n                               msecs: uint, ch: comm::Chan<T>, val: T) {\n         unsafe {\n-            let timer_done_po = comm::port::<()>();\n-            let timer_done_ch = comm::chan(timer_done_po);\n+            let timer_done_po = core::comm::port::<()>();\n+            let timer_done_ch = core::comm::chan(timer_done_po);\n             let timer_done_ch_ptr = ptr::addr_of(timer_done_ch);\n             let timer = uv::ll::timer_t();\n             let timer_ptr = ptr::addr_of(timer);\n@@ -51,11 +53,11 @@ fn delayed_send<T: copy send>(iotask: iotask,\n                 }\n             };\n             // delayed_send_cb has been processed by libuv\n-            comm::recv(timer_done_po);\n+            core::comm::recv(timer_done_po);\n             // notify the caller immediately\n-            comm::send(ch, copy(val));\n+            core::comm::send(ch, copy(val));\n             // uv_close for this timer has been processed\n-            comm::recv(timer_done_po);\n+            core::comm::recv(timer_done_po);\n     };\n }\n \n@@ -71,10 +73,10 @@ fn delayed_send<T: copy send>(iotask: iotask,\n  * * msecs - an amount of time, in milliseconds, for the current task to block\n  */\n fn sleep(iotask: iotask, msecs: uint) {\n-    let exit_po = comm::port::<()>();\n-    let exit_ch = comm::chan(exit_po);\n+    let exit_po = core::comm::port::<()>();\n+    let exit_ch = core::comm::chan(exit_po);\n     delayed_send(iotask, msecs, exit_ch, ());\n-    comm::recv(exit_po);\n+    core::comm::recv(exit_po);\n }\n \n /**\n@@ -89,7 +91,7 @@ fn sleep(iotask: iotask, msecs: uint) {\n  *\n  * * `iotask' - `uv::iotask` that the tcp request will run on\n  * * msecs - an mount of time, in milliseconds, to wait to receive\n- * * wait_port - a `comm::port<T>` to receive on\n+ * * wait_port - a `core::comm::port<T>` to receive on\n  *\n  * # Returns\n  *\n@@ -111,7 +113,7 @@ fn recv_timeout<T: copy send>(iotask: iotask,\n             none\n         }, |right_val| {\n             some(*right_val)\n-        }, &comm::select2(timeout_po, wait_po)\n+        }, &core::comm::select2(timeout_po, wait_po)\n     )\n }\n \n@@ -123,7 +125,7 @@ extern fn delayed_send_cb(handle: *uv::ll::uv_timer_t,\n         *(uv::ll::get_data_for_uv_handle(handle) as *comm::Chan<()>);\n     let stop_result = uv::ll::timer_stop(handle);\n     if (stop_result == 0i32) {\n-        comm::send(timer_done_ch, ());\n+        core::comm::send(timer_done_ch, ());\n         uv::ll::close(handle, delayed_send_close_cb);\n     }\n     else {\n@@ -158,8 +160,8 @@ mod test {\n \n     #[test]\n     fn test_gl_timer_sleep_stress2() {\n-        let po = comm::port();\n-        let ch = comm::chan(po);\n+        let po = core::comm::port();\n+        let ch = core::comm::chan(po);\n         let hl_loop = uv::global_loop::get();\n \n         let repeat = 20u;\n@@ -181,13 +183,13 @@ mod test {\n                     for iter::repeat(times) {\n                         sleep(hl_loop, rng.next() as uint % maxms);\n                     }\n-                    comm::send(ch, ());\n+                    core::comm::send(ch, ());\n                 }\n             }\n         }\n \n         for iter::repeat(repeat * spec.len()) {\n-            comm::recv(po)\n+            core::comm::recv(po)\n         }\n     }\n \n@@ -208,8 +210,8 @@ mod test {\n             task::yield();\n \n             let expected = rand::rng().gen_str(16u);\n-            let test_po = comm::port::<str>();\n-            let test_ch = comm::chan(test_po);\n+            let test_po = core::comm::port::<str>();\n+            let test_ch = core::comm::chan(test_po);\n \n             do task::spawn() {\n                 delayed_send(hl_loop, 1u, test_ch, expected);\n@@ -236,8 +238,8 @@ mod test {\n \n         for iter::repeat(times as uint) {\n             let expected = rand::rng().gen_str(16u);\n-            let test_po = comm::port::<~str>();\n-            let test_ch = comm::chan(test_po);\n+            let test_po = core::comm::port::<~str>();\n+            let test_ch = core::comm::chan(test_po);\n \n             do task::spawn() {\n                 delayed_send(hl_loop, 1000u, test_ch, expected);"}, {"sha": "669b4f16e1b9d27e90d2f7a035cf01b3b2ac1b96", "filename": "src/libstd/uv_global_loop.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fuv_global_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fuv_global_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_global_loop.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -7,6 +7,7 @@ import iotask = uv_iotask;\n import get_gl = get;\n import iotask::{iotask, spawn_iotask};\n import priv::{chan_from_global_ptr, weaken_task};\n+import comm = core::comm;\n import comm::{Port, Chan, port, chan, select2, listen};\n import task::TaskBuilder;\n import either::{Left, Right};\n@@ -110,7 +111,7 @@ mod test {\n         let exit_ch_ptr = ll::get_data_for_uv_handle(\n             timer_ptr as *libc::c_void) as *comm::Chan<bool>;\n         let exit_ch = *exit_ch_ptr;\n-        comm::send(exit_ch, true);\n+        core::comm::send(exit_ch, true);\n         log(debug, fmt!{\"EXIT_CH_PTR simple_timer_close_cb exit_ch_ptr: %?\",\n                        exit_ch_ptr});\n     }\n@@ -129,8 +130,8 @@ mod test {\n     }\n \n     fn impl_uv_hl_simple_timer(iotask: iotask) unsafe {\n-        let exit_po = comm::port::<bool>();\n-        let exit_ch = comm::chan(exit_po);\n+        let exit_po = core::comm::port::<bool>();\n+        let exit_ch = core::comm::chan(exit_po);\n         let exit_ch_ptr = ptr::addr_of(exit_ch);\n         log(debug, fmt!{\"EXIT_CH_PTR newly created exit_ch_ptr: %?\",\n                        exit_ch_ptr});\n@@ -155,7 +156,7 @@ mod test {\n                 fail ~\"failure on ll::timer_init()\";\n             }\n         };\n-        comm::recv(exit_po);\n+        core::comm::recv(exit_po);\n         log(debug, ~\"global_loop timer test: msg recv on exit_po, done..\");\n     }\n \n@@ -166,10 +167,10 @@ mod test {\n         let exit_ch = comm::chan(exit_po);\n         task::spawn_sched(task::ManualThreads(1u), || {\n             impl_uv_hl_simple_timer(hl_loop);\n-            comm::send(exit_ch, ());\n+            core::comm::send(exit_ch, ());\n         });\n         impl_uv_hl_simple_timer(hl_loop);\n-        comm::recv(exit_po);\n+        core::comm::recv(exit_po);\n     }\n \n     // keeping this test ignored until some kind of stress-test-harness\n@@ -178,17 +179,17 @@ mod test {\n     #[ignore]\n     fn test_stress_gl_uv_global_loop_high_level_global_timer() unsafe {\n         let hl_loop = get_gl();\n-        let exit_po = comm::port::<()>();\n-        let exit_ch = comm::chan(exit_po);\n+        let exit_po = core::comm::port::<()>();\n+        let exit_ch = core::comm::chan(exit_po);\n         let cycles = 5000u;\n         for iter::repeat(cycles) {\n             task::spawn_sched(task::ManualThreads(1u), || {\n                 impl_uv_hl_simple_timer(hl_loop);\n-                comm::send(exit_ch, ());\n+                core::comm::send(exit_ch, ());\n             });\n         };\n         for iter::repeat(cycles) {\n-            comm::recv(exit_po);\n+            core::comm::recv(exit_po);\n         };\n         log(debug, ~\"test_stress_gl_uv_global_loop_high_level_global_timer\"+\n             ~\" exiting sucessfully!\");"}, {"sha": "f6ccbeb5d0d7b660aad7630fa86f6999cf2e4ec5", "filename": "src/libstd/uv_iotask.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fuv_iotask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fuv_iotask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_iotask.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -12,6 +12,7 @@ export exit;\n \n import libc::c_void;\n import ptr::addr_of;\n+import comm = core::comm;\n import comm::{Port, port, Chan, chan, listen};\n import task::TaskBuilder;\n import ll = uv_ll;\n@@ -171,7 +172,7 @@ mod test {\n         log(debug, fmt!{\"async_close_cb handle %?\", handle});\n         let exit_ch = (*(ll::get_data_for_uv_handle(handle)\n                         as *ah_data)).exit_ch;\n-        comm::send(exit_ch, ());\n+        core::comm::send(exit_ch, ());\n     }\n     extern fn async_handle_cb(handle: *ll::uv_async_t, status: libc::c_int)\n         unsafe {\n@@ -185,8 +186,8 @@ mod test {\n     fn impl_uv_iotask_async(iotask: iotask) unsafe {\n         let async_handle = ll::async_t();\n         let ah_ptr = ptr::addr_of(async_handle);\n-        let exit_po = comm::port::<()>();\n-        let exit_ch = comm::chan(exit_po);\n+        let exit_po = core::comm::port::<()>();\n+        let exit_ch = core::comm::chan(exit_po);\n         let ah_data = {\n             iotask: iotask,\n             exit_ch: exit_ch\n@@ -197,7 +198,7 @@ mod test {\n             ll::set_data_for_uv_handle(ah_ptr, ah_data_ptr as *libc::c_void);\n             ll::async_send(ah_ptr);\n         };\n-        comm::recv(exit_po);\n+        core::comm::recv(exit_po);\n     }\n \n     // this fn documents the bear minimum neccesary to roll your own\n@@ -209,7 +210,7 @@ mod test {\n             run_loop(iotask_ch);\n             exit_ch.send(());\n         };\n-        return comm::recv(iotask_port);\n+        return core::comm::recv(iotask_port);\n     }\n \n     extern fn lifetime_handle_close(handle: *libc::c_void) unsafe {\n@@ -224,8 +225,8 @@ mod test {\n \n     #[test]\n     fn test_uv_iotask_async() unsafe {\n-        let exit_po = comm::port::<()>();\n-        let exit_ch = comm::chan(exit_po);\n+        let exit_po = core::comm::port::<()>();\n+        let exit_ch = core::comm::chan(exit_po);\n         let iotask = spawn_test_loop(exit_ch);\n \n         // using this handle to manage the lifetime of the high_level_loop,\n@@ -234,20 +235,20 @@ mod test {\n         // under race-condition type situations.. this ensures that the loop\n         // lives until, at least, all of the impl_uv_hl_async() runs have been\n         // called, at least.\n-        let work_exit_po = comm::port::<()>();\n-        let work_exit_ch = comm::chan(work_exit_po);\n+        let work_exit_po = core::comm::port::<()>();\n+        let work_exit_ch = core::comm::chan(work_exit_po);\n         for iter::repeat(7u) {\n             do task::spawn_sched(task::ManualThreads(1u)) {\n                 impl_uv_iotask_async(iotask);\n-                comm::send(work_exit_ch, ());\n+                core::comm::send(work_exit_ch, ());\n             };\n         };\n         for iter::repeat(7u) {\n-            comm::recv(work_exit_po);\n+            core::comm::recv(work_exit_po);\n         };\n         log(debug, ~\"sending teardown_loop msg..\");\n         exit(iotask);\n-        comm::recv(exit_po);\n+        core::comm::recv(exit_po);\n         log(debug, ~\"after recv on exit_po.. exiting..\");\n     }\n }"}, {"sha": "0737e61a7c1515b11000083f9854848b184bb6bd", "filename": "src/libstd/uv_ll.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fuv_ll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/924e787119969c740911d0d1aaf28ab19b77c1a2/src%2Flibstd%2Fuv_ll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuv_ll.rs?ref=924e787119969c740911d0d1aaf28ab19b77c1a2", "patch": "@@ -22,6 +22,7 @@\n \n import libc::size_t;\n import ptr::assimilate;\n+import comm = core::comm;\n \n // libuv struct mappings\n type uv_ip4_addr = {\n@@ -1046,7 +1047,7 @@ mod test {\n             let bytes = vec::unsafe::from_buf(buf_base, buf_len as uint);\n             let read_chan = *((*client_data).read_chan);\n             let msg_from_server = str::from_bytes(bytes);\n-            comm::send(read_chan, msg_from_server);\n+            core::comm::send(read_chan, msg_from_server);\n             close(stream as *libc::c_void, after_close_cb)\n         }\n         else if (nread == -1) {\n@@ -1231,7 +1232,7 @@ mod test {\n                 log(debug, ~\"SERVER: sending response to client\");\n                 read_stop(client_stream_ptr);\n                 let server_chan = *((*client_data).server_chan);\n-                comm::send(server_chan, request_str);\n+                core::comm::send(server_chan, request_str);\n                 let write_result = write(\n                     write_req,\n                     client_stream_ptr as *libc::c_void,\n@@ -1346,7 +1347,7 @@ mod test {\n             async_handle as *libc::c_void) as *async_handle_data;\n         let continue_chan = *((*data).continue_chan);\n         let should_continue = status == 0i32;\n-        comm::send(continue_chan, should_continue);\n+        core::comm::send(continue_chan, should_continue);\n         close(async_handle as *libc::c_void, async_close_cb);\n     }\n \n@@ -1460,13 +1461,13 @@ mod test {\n         let port = 8887;\n         let kill_server_msg = ~\"does a dog have buddha nature?\";\n         let server_resp_msg = ~\"mu!\";\n-        let client_port = comm::port::<~str>();\n-        let client_chan = comm::chan::<~str>(client_port);\n-        let server_port = comm::port::<~str>();\n-        let server_chan = comm::chan::<~str>(server_port);\n+        let client_port = core::comm::port::<~str>();\n+        let client_chan = core::comm::chan::<~str>(client_port);\n+        let server_port = core::comm::port::<~str>();\n+        let server_chan = core::comm::chan::<~str>(server_port);\n \n-        let continue_port = comm::port::<bool>();\n-        let continue_chan = comm::chan::<bool>(continue_port);\n+        let continue_port = core::comm::port::<bool>();\n+        let continue_chan = core::comm::chan::<bool>(continue_port);\n         let continue_chan_ptr = ptr::addr_of(continue_chan);\n \n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1479,7 +1480,7 @@ mod test {\n \n         // block until the server up is.. possibly a race?\n         log(debug, ~\"before receiving on server continue_port\");\n-        comm::recv(continue_port);\n+        core::comm::recv(continue_port);\n         log(debug, ~\"received on continue port, set up tcp client\");\n \n         do task::spawn_sched(task::ManualThreads(1u)) {\n@@ -1488,8 +1489,8 @@ mod test {\n                                ptr::addr_of(client_chan));\n         };\n \n-        let msg_from_client = comm::recv(server_port);\n-        let msg_from_server = comm::recv(client_port);\n+        let msg_from_client = core::comm::recv(server_port);\n+        let msg_from_server = core::comm::recv(client_port);\n \n         assert str::contains(msg_from_client, kill_server_msg);\n         assert str::contains(msg_from_server, server_resp_msg);"}]}