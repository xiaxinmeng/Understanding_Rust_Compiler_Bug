{"sha": "700c095306ce89b0b18e2487aae9c0721e60a5e3", "node_id": "C_kwDOAAsO6NoAKDcwMGMwOTUzMDZjZTg5YjBiMThlMjQ4N2FhZTljMDcyMWU2MGE1ZTM", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-06T13:22:36Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-12-06T14:45:58Z"}, "message": "`rustc_builtin_macros`: remove `ref` patterns\n\n... and other pattern matching improvements", "tree": {"sha": "50e8a78e271c55895f1875234640d0bce83591f3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/50e8a78e271c55895f1875234640d0bce83591f3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/700c095306ce89b0b18e2487aae9c0721e60a5e3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/700c095306ce89b0b18e2487aae9c0721e60a5e3", "html_url": "https://github.com/rust-lang/rust/commit/700c095306ce89b0b18e2487aae9c0721e60a5e3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/700c095306ce89b0b18e2487aae9c0721e60a5e3/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "244990a6e91843289e094b384d67294756891fe9", "url": "https://api.github.com/repos/rust-lang/rust/commits/244990a6e91843289e094b384d67294756891fe9", "html_url": "https://github.com/rust-lang/rust/commit/244990a6e91843289e094b384d67294756891fe9"}], "stats": {"total": 372, "additions": 176, "deletions": 196}, "files": [{"sha": "95e38e4b053f496604f25079b22722e2fbf3dc4b", "filename": "compiler/rustc_builtin_macros/src/alloc_error_handler.rs", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Falloc_error_handler.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -17,32 +17,23 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::alloc_error_handler);\n \n     let orig_item = item.clone();\n-    let not_function = || {\n-        ecx.sess\n-            .parse_sess\n-            .span_diagnostic\n-            .span_err(item.span(), \"alloc_error_handler must be a function\");\n-        vec![orig_item.clone()]\n-    };\n \n     // Allow using `#[alloc_error_handler]` on an item statement\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n-    let (item, is_stmt, sig_span) = match &item {\n-        Annotatable::Item(item) => match item.kind {\n-            ItemKind::Fn(ref fn_kind) => (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span)),\n-            _ => return not_function(),\n-        },\n-        Annotatable::Stmt(stmt) => match &stmt.kind {\n-            StmtKind::Item(item_) => match item_.kind {\n-                ItemKind::Fn(ref fn_kind) => {\n-                    (item_, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n-                }\n-                _ => return not_function(),\n-            },\n-            _ => return not_function(),\n-        },\n-        _ => return not_function(),\n-    };\n+    let (item, is_stmt, sig_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Fn(fn_kind) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(fn_kind.sig.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"alloc_error_handler must be a function\");\n+            return vec![orig_item.clone()];\n+        };\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);"}, {"sha": "93b07801e035d7de24d995980ccd1568063ffb29", "filename": "compiler/rustc_builtin_macros/src/assert/context.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert%2Fcontext.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -191,19 +191,19 @@ impl<'cx, 'a> Context<'cx, 'a> {\n     ///\n     /// See [Self::manage_initial_capture] and [Self::manage_try_capture]\n     fn manage_cond_expr(&mut self, expr: &mut P<Expr>) {\n-        match (*expr).kind {\n-            ExprKind::AddrOf(_, mutability, ref mut local_expr) => {\n+        match &mut expr.kind {\n+            ExprKind::AddrOf(_, mutability, local_expr) => {\n                 self.with_is_consumed_management(\n                     matches!(mutability, Mutability::Mut),\n                     |this| this.manage_cond_expr(local_expr)\n                 );\n             }\n-            ExprKind::Array(ref mut local_exprs) => {\n+            ExprKind::Array(local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Binary(ref op, ref mut lhs, ref mut rhs) => {\n+            ExprKind::Binary(op, lhs, rhs) => {\n                 self.with_is_consumed_management(\n                     matches!(\n                         op.node,\n@@ -226,56 +226,56 @@ impl<'cx, 'a> Context<'cx, 'a> {\n                     }\n                 );\n             }\n-            ExprKind::Call(_, ref mut local_exprs) => {\n+            ExprKind::Call(_, local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Cast(ref mut local_expr, _) => {\n+            ExprKind::Cast(local_expr, _) => {\n                 self.manage_cond_expr(local_expr);\n             }\n-            ExprKind::Index(ref mut prefix, ref mut suffix) => {\n+            ExprKind::Index(prefix, suffix) => {\n                 self.manage_cond_expr(prefix);\n                 self.manage_cond_expr(suffix);\n             }\n-            ExprKind::MethodCall(ref mut call) => {\n-                for arg in call.args.iter_mut() {\n+            ExprKind::MethodCall(call) => {\n+                for arg in &mut call.args {\n                     self.manage_cond_expr(arg);\n                 }\n             }\n-            ExprKind::Path(_, Path { ref segments, .. }) if let &[ref path_segment] = &segments[..] => {\n+            ExprKind::Path(_, Path { segments, .. }) if let [path_segment] = &segments[..] => {\n                 let path_ident = path_segment.ident;\n                 self.manage_initial_capture(expr, path_ident);\n             }\n-            ExprKind::Paren(ref mut local_expr) => {\n+            ExprKind::Paren(local_expr) => {\n                 self.manage_cond_expr(local_expr);\n             }\n-            ExprKind::Range(ref mut prefix, ref mut suffix, _) => {\n-                if let Some(ref mut elem) = prefix {\n+            ExprKind::Range(prefix, suffix, _) => {\n+                if let Some(elem) = prefix {\n                     self.manage_cond_expr(elem);\n                 }\n-                if let Some(ref mut elem) = suffix {\n+                if let Some(elem) = suffix {\n                     self.manage_cond_expr(elem);\n                 }\n             }\n-            ExprKind::Repeat(ref mut local_expr, ref mut elem) => {\n+            ExprKind::Repeat(local_expr, elem) => {\n                 self.manage_cond_expr(local_expr);\n                 self.manage_cond_expr(&mut elem.value);\n             }\n-            ExprKind::Struct(ref mut elem) => {\n+            ExprKind::Struct(elem) => {\n                 for field in &mut elem.fields {\n                     self.manage_cond_expr(&mut field.expr);\n                 }\n-                if let StructRest::Base(ref mut local_expr) = elem.rest {\n+                if let StructRest::Base(local_expr) = &mut elem.rest {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Tup(ref mut local_exprs) => {\n+            ExprKind::Tup(local_exprs) => {\n                 for local_expr in local_exprs {\n                     self.manage_cond_expr(local_expr);\n                 }\n             }\n-            ExprKind::Unary(un_op, ref mut local_expr) => {\n+            ExprKind::Unary(un_op, local_expr) => {\n                 self.with_is_consumed_management(\n                     matches!(un_op, UnOp::Neg | UnOp::Not),\n                     |this| this.manage_cond_expr(local_expr)"}, {"sha": "e2d71825d556f69ca9bbc4277848b4aaf89047ad", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -20,7 +20,7 @@ pub fn expand_concat(\n     for e in es {\n         match e.kind {\n             ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n-                Ok(ast::LitKind::Str(ref s, _) | ast::LitKind::Float(ref s, _)) => {\n+                Ok(ast::LitKind::Str(s, _) | ast::LitKind::Float(s, _)) => {\n                     accumulator.push_str(s.as_str());\n                 }\n                 Ok(ast::LitKind::Char(c)) => {"}, {"sha": "d1124145dcbbb663febddf26081de93812aa39d5", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -144,8 +144,8 @@ pub fn expand_concat_bytes(\n     let mut missing_literals = vec![];\n     let mut has_errors = false;\n     for e in es {\n-        match e.kind {\n-            ast::ExprKind::Array(ref exprs) => {\n+        match &e.kind {\n+            ast::ExprKind::Array(exprs) => {\n                 for expr in exprs {\n                     if let Some(elem) =\n                         handle_array_element(cx, &mut has_errors, &mut missing_literals, expr)\n@@ -154,7 +154,7 @@ pub fn expand_concat_bytes(\n                     }\n                 }\n             }\n-            ast::ExprKind::Repeat(ref expr, ref count) => {\n+            ast::ExprKind::Repeat(expr, count) => {\n                 if let ast::ExprKind::Lit(token_lit) = count.value.kind\n                 && let Ok(ast::LitKind::Int(count_val, _)) =\n                     ast::LitKind::from_token_lit(token_lit)\n@@ -170,7 +170,7 @@ pub fn expand_concat_bytes(\n                     cx.span_err(count.value.span, \"repeat count is not a positive number\");\n                 }\n             }\n-            ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n+            &ast::ExprKind::Lit(token_lit) => match ast::LitKind::from_token_lit(token_lit) {\n                 Ok(ast::LitKind::Byte(val)) => {\n                     accumulator.push(val);\n                 }\n@@ -184,7 +184,7 @@ pub fn expand_concat_bytes(\n                     has_errors = true;\n                 }\n             },\n-            ast::ExprKind::IncludedBytes(ref bytes) => {\n+            ast::ExprKind::IncludedBytes(bytes) => {\n                 accumulator.extend_from_slice(bytes);\n             }\n             ast::ExprKind::Err => {"}, {"sha": "d59b3b8c86d35ef6303bb8a3adbd5e9aecf2d1f1", "filename": "compiler/rustc_builtin_macros/src/deriving/clone.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fclone.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -32,10 +32,10 @@ pub fn expand_deriving_clone(\n     let bounds;\n     let substructure;\n     let is_simple;\n-    match *item {\n-        Annotatable::Item(ref annitem) => match annitem.kind {\n-            ItemKind::Struct(_, Generics { ref params, .. })\n-            | ItemKind::Enum(_, Generics { ref params, .. }) => {\n+    match item {\n+        Annotatable::Item(annitem) => match &annitem.kind {\n+            ItemKind::Struct(_, Generics { params, .. })\n+            | ItemKind::Enum(_, Generics { params, .. }) => {\n                 let container_id = cx.current_expansion.id.expn_data().parent.expect_local();\n                 let has_derive_copy = cx.resolver.has_derive_copy(container_id);\n                 if has_derive_copy\n@@ -166,13 +166,13 @@ fn cs_clone(\n     };\n \n     let vdata;\n-    match *substr.fields {\n-        Struct(vdata_, ref af) => {\n+    match substr.fields {\n+        Struct(vdata_, af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident]);\n             all_fields = af;\n-            vdata = vdata_;\n+            vdata = *vdata_;\n         }\n-        EnumMatching(.., variant, ref af) => {\n+        EnumMatching(.., variant, af) => {\n             ctor_path = cx.path(trait_span, vec![substr.type_ident, variant.ident]);\n             all_fields = af;\n             vdata = &variant.data;"}, {"sha": "62af02c2bb4b2d35304cf4eafd42036fba31d5ef", "filename": "compiler/rustc_builtin_macros/src/deriving/decodable.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdecodable.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -78,11 +78,11 @@ fn decodable_substructure(\n     let blkarg = Ident::new(sym::_d, trait_span);\n     let blkdecoder = cx.expr_ident(trait_span, blkarg);\n \n-    let expr = match *substr.fields {\n-        StaticStruct(_, ref summary) => {\n-            let nfields = match *summary {\n-                Unnamed(ref fields, _) => fields.len(),\n-                Named(ref fields) => fields.len(),\n+    let expr = match substr.fields {\n+        StaticStruct(_, summary) => {\n+            let nfields = match summary {\n+                Unnamed(fields, _) => fields.len(),\n+                Named(fields) => fields.len(),\n             };\n             let fn_read_struct_field_path: Vec<_> =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Decoder, sym::read_struct_field]);\n@@ -119,7 +119,7 @@ fn decodable_substructure(\n                 ],\n             )\n         }\n-        StaticEnum(_, ref fields) => {\n+        StaticEnum(_, fields) => {\n             let variant = Ident::new(sym::i, trait_span);\n \n             let mut arms = Vec::with_capacity(fields.len() + 1);\n@@ -194,10 +194,10 @@ fn decode_static_fields<F>(\n where\n     F: FnMut(&mut ExtCtxt<'_>, Span, Symbol, usize) -> P<Expr>,\n {\n-    match *fields {\n-        Unnamed(ref fields, is_tuple) => {\n+    match fields {\n+        Unnamed(fields, is_tuple) => {\n             let path_expr = cx.expr_path(outer_pat_path);\n-            if !is_tuple {\n+            if !*is_tuple {\n                 path_expr\n             } else {\n                 let fields = fields\n@@ -209,7 +209,7 @@ where\n                 cx.expr_call(trait_span, path_expr, fields)\n             }\n         }\n-        Named(ref fields) => {\n+        Named(fields) => {\n             // use the field's span to get nicer error messages.\n             let fields = fields\n                 .iter()"}, {"sha": "eb66c4a69a69bc25bab4126e1649d5f3097a940f", "filename": "compiler/rustc_builtin_macros/src/deriving/default.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fdefault.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -62,15 +62,12 @@ fn default_struct_substructure(\n     let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     let expr = match summary {\n-        Unnamed(ref fields, is_tuple) => {\n-            if !is_tuple {\n-                cx.expr_ident(trait_span, substr.type_ident)\n-            } else {\n-                let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n-                cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n-            }\n+        Unnamed(_, false) => cx.expr_ident(trait_span, substr.type_ident),\n+        Unnamed(fields, true) => {\n+            let exprs = fields.iter().map(|sp| default_call(*sp)).collect();\n+            cx.expr_call_ident(trait_span, substr.type_ident, exprs)\n         }\n-        Named(ref fields) => {\n+        Named(fields) => {\n             let default_fields = fields\n                 .iter()\n                 .map(|&(ident, span)| cx.field_imm(span, ident, default_call(span)))"}, {"sha": "68bc0ff2ec0b41c553339586a0874ef5fcb6a1f1", "filename": "compiler/rustc_builtin_macros/src/deriving/encodable.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fencodable.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -164,8 +164,8 @@ fn encodable_substructure(\n         ],\n     ));\n \n-    match *substr.fields {\n-        Struct(_, ref fields) => {\n+    match substr.fields {\n+        Struct(_, fields) => {\n             let fn_emit_struct_field_path =\n                 cx.def_site_path(&[sym::rustc_serialize, sym::Encoder, sym::emit_struct_field]);\n             let mut stmts = Vec::new();\n@@ -224,7 +224,7 @@ fn encodable_substructure(\n             BlockOrExpr::new_expr(expr)\n         }\n \n-        EnumMatching(idx, _, variant, ref fields) => {\n+        EnumMatching(idx, _, variant, fields) => {\n             // We're not generating an AST that the borrow checker is expecting,\n             // so we need to generate a unique local variable to take the\n             // mutable loan out on, otherwise we get conflicts which don't\n@@ -274,7 +274,7 @@ fn encodable_substructure(\n                 vec![\n                     blkencoder,\n                     name,\n-                    cx.expr_usize(trait_span, idx),\n+                    cx.expr_usize(trait_span, *idx),\n                     cx.expr_usize(trait_span, fields.len()),\n                     blk,\n                 ],"}, {"sha": "beac591bfc879065a2c6fd411be0673ba59a3383", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/mod.rs", "status": "modified", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fmod.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -369,15 +369,14 @@ fn find_type_parameters(\n \n     impl<'a, 'b> visit::Visitor<'a> for Visitor<'a, 'b> {\n         fn visit_ty(&mut self, ty: &'a ast::Ty) {\n-            if let ast::TyKind::Path(_, ref path) = ty.kind {\n-                if let Some(segment) = path.segments.first() {\n-                    if self.ty_param_names.contains(&segment.ident.name) {\n-                        self.type_params.push(TypeParameter {\n-                            bound_generic_params: self.bound_generic_params_stack.clone(),\n-                            ty: P(ty.clone()),\n-                        });\n-                    }\n-                }\n+            if let ast::TyKind::Path(_, path) = &ty.kind\n+                && let Some(segment) = path.segments.first()\n+                && self.ty_param_names.contains(&segment.ident.name)\n+            {\n+                self.type_params.push(TypeParameter {\n+                    bound_generic_params: self.bound_generic_params_stack.clone(),\n+                    ty: P(ty.clone()),\n+                });\n             }\n \n             visit::walk_ty(self, ty)\n@@ -428,8 +427,8 @@ impl<'a> TraitDef<'a> {\n         push: &mut dyn FnMut(Annotatable),\n         from_scratch: bool,\n     ) {\n-        match *item {\n-            Annotatable::Item(ref item) => {\n+        match item {\n+            Annotatable::Item(item) => {\n                 let is_packed = item.attrs.iter().any(|attr| {\n                     for r in attr::find_repr_attrs(&cx.sess, attr) {\n                         if let attr::ReprPacked(_) = r {\n@@ -438,10 +437,10 @@ impl<'a> TraitDef<'a> {\n                     }\n                     false\n                 });\n-                let has_no_type_params = match item.kind {\n-                    ast::ItemKind::Struct(_, ref generics)\n-                    | ast::ItemKind::Enum(_, ref generics)\n-                    | ast::ItemKind::Union(_, ref generics) => !generics\n+                let has_no_type_params = match &item.kind {\n+                    ast::ItemKind::Struct(_, generics)\n+                    | ast::ItemKind::Enum(_, generics)\n+                    | ast::ItemKind::Union(_, generics) => !generics\n                         .params\n                         .iter()\n                         .any(|param| matches!(param.kind, ast::GenericParamKind::Type { .. })),\n@@ -451,24 +450,24 @@ impl<'a> TraitDef<'a> {\n                 let copy_fields =\n                     is_packed && has_no_type_params && cx.resolver.has_derive_copy(container_id);\n \n-                let newitem = match item.kind {\n-                    ast::ItemKind::Struct(ref struct_def, ref generics) => self.expand_struct_def(\n+                let newitem = match &item.kind {\n+                    ast::ItemKind::Struct(struct_def, generics) => self.expand_struct_def(\n                         cx,\n                         &struct_def,\n                         item.ident,\n                         generics,\n                         from_scratch,\n                         copy_fields,\n                     ),\n-                    ast::ItemKind::Enum(ref enum_def, ref generics) => {\n+                    ast::ItemKind::Enum(enum_def, generics) => {\n                         // We ignore `is_packed` here, because `repr(packed)`\n                         // enums cause an error later on.\n                         //\n                         // This can only cause further compilation errors\n                         // downstream in blatantly illegal code, so it is fine.\n                         self.expand_enum_def(cx, enum_def, item.ident, generics, from_scratch)\n                     }\n-                    ast::ItemKind::Union(ref struct_def, ref generics) => {\n+                    ast::ItemKind::Union(struct_def, generics) => {\n                         if self.supports_unions {\n                             self.expand_struct_def(\n                                 cx,\n@@ -663,12 +662,11 @@ impl<'a> TraitDef<'a> {\n \n                     for field_ty_param in field_ty_params {\n                         // if we have already handled this type, skip it\n-                        if let ast::TyKind::Path(_, ref p) = field_ty_param.ty.kind {\n-                            if p.segments.len() == 1\n-                                && ty_param_names.contains(&p.segments[0].ident.name)\n-                            {\n-                                continue;\n-                            };\n+                        if let ast::TyKind::Path(_, p) = &field_ty_param.ty.kind\n+                            && let [sole_segment] = &*p.segments\n+                            && ty_param_names.contains(&sole_segment.ident.name)\n+                        {\n+                            continue;\n                         }\n                         let mut bounds: Vec<_> = self\n                             .additional_bounds"}, {"sha": "eaa4881906a8e3aed446cec6b99657d64972d02f", "filename": "compiler/rustc_builtin_macros/src/deriving/generic/ty.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fgeneric%2Fty.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -115,7 +115,7 @@ impl Ty {\n         self_ty: Ident,\n         generics: &Generics,\n     ) -> ast::Path {\n-        match *self {\n+        match self {\n             Self_ => {\n                 let params: Vec<_> = generics\n                     .params\n@@ -135,7 +135,7 @@ impl Ty {\n \n                 cx.path_all(span, false, vec![self_ty], params)\n             }\n-            Path(ref p) => p.to_path(cx, span, self_ty, generics),\n+            Path(p) => p.to_path(cx, span, self_ty, generics),\n             Ref(..) => cx.span_bug(span, \"ref in a path in generic `derive`\"),\n             Unit => cx.span_bug(span, \"unit in a path in generic `derive`\"),\n         }\n@@ -180,10 +180,7 @@ impl Bounds {\n         let params = self\n             .bounds\n             .iter()\n-            .map(|t| {\n-                let (name, ref bounds) = *t;\n-                mk_ty_param(cx, span, name, &bounds, self_ty, self_generics)\n-            })\n+            .map(|&(name, ref bounds)| mk_ty_param(cx, span, name, &bounds, self_ty, self_generics))\n             .collect();\n \n         Generics {"}, {"sha": "de657e4e6006dcd8aea6ce578dd2657242a488b2", "filename": "compiler/rustc_builtin_macros/src/deriving/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fderiving%2Fmod.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -125,12 +125,12 @@ fn inject_impl_of_structural_trait(\n     structural_path: generic::ty::Path,\n     push: &mut dyn FnMut(Annotatable),\n ) {\n-    let Annotatable::Item(ref item) = *item else {\n+    let Annotatable::Item(item) = item else {\n         unreachable!();\n     };\n \n-    let generics = match item.kind {\n-        ItemKind::Struct(_, ref generics) | ItemKind::Enum(_, ref generics) => generics,\n+    let generics = match &item.kind {\n+        ItemKind::Struct(_, generics) | ItemKind::Enum(_, generics) => generics,\n         // Do not inject `impl Structural for Union`. (`PartialEq` does not\n         // support unions, so we will see error downstream.)\n         ItemKind::Union(..) => return,"}, {"sha": "0b4e545f7a3d0360757c9588e97742e7f4e1f0c6", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -53,7 +53,7 @@ pub fn expand_env<'cx>(\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n     let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n-        Some(ref exprs) if exprs.is_empty() => {\n+        Some(exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);\n         }"}, {"sha": "6f7fc3a95ba640e21311aca2d37b403f0f25a2c4", "filename": "compiler/rustc_builtin_macros/src/format_foreign.rs", "status": "modified", "additions": 14, "deletions": 20, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fformat_foreign.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -13,23 +13,23 @@ pub(crate) mod printf {\n \n     impl<'a> Substitution<'a> {\n         pub fn as_str(&self) -> &str {\n-            match *self {\n-                Substitution::Format(ref fmt) => fmt.span,\n+            match self {\n+                Substitution::Format(fmt) => fmt.span,\n                 Substitution::Escape(_) => \"%%\",\n             }\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n-            match *self {\n-                Substitution::Format(ref fmt) => Some(fmt.position),\n-                Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n+            match self {\n+                Substitution::Format(fmt) => Some(fmt.position),\n+                &Substitution::Escape((start, end)) => Some(InnerSpan::new(start, end)),\n             }\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n             match self {\n-                Substitution::Format(ref mut fmt) => fmt.position = InnerSpan::new(start, end),\n-                Substitution::Escape(ref mut pos) => *pos = (start, end),\n+                Substitution::Format(fmt) => fmt.position = InnerSpan::new(start, end),\n+                Substitution::Escape(pos) => *pos = (start, end),\n             }\n         }\n \n@@ -38,8 +38,8 @@ pub(crate) mod printf {\n         /// This ignores cases where the substitution does not have an exact equivalent, or where\n         /// the substitution would be unnecessary.\n         pub fn translate(&self) -> Result<String, Option<String>> {\n-            match *self {\n-                Substitution::Format(ref fmt) => fmt.translate(),\n+            match self {\n+                Substitution::Format(fmt) => fmt.translate(),\n                 Substitution::Escape(_) => Err(None),\n             }\n         }\n@@ -635,23 +635,17 @@ pub mod shell {\n         }\n \n         pub fn position(&self) -> Option<InnerSpan> {\n-            match self {\n-                Substitution::Ordinal(_, pos)\n-                | Substitution::Name(_, pos)\n-                | Substitution::Escape(pos) => Some(InnerSpan::new(pos.0, pos.1)),\n-            }\n+            let (Self::Ordinal(_, pos) | Self::Name(_, pos) | Self::Escape(pos)) = self;\n+            Some(InnerSpan::new(pos.0, pos.1))\n         }\n \n         pub fn set_position(&mut self, start: usize, end: usize) {\n-            match self {\n-                Substitution::Ordinal(_, ref mut pos)\n-                | Substitution::Name(_, ref mut pos)\n-                | Substitution::Escape(ref mut pos) => *pos = (start, end),\n-            }\n+            let (Self::Ordinal(_, pos) | Self::Name(_, pos) | Self::Escape(pos)) = self;\n+            *pos = (start, end);\n         }\n \n         pub fn translate(&self) -> Result<String, Option<String>> {\n-            match *self {\n+            match self {\n                 Substitution::Ordinal(n, _) => Ok(format!(\"{{{}}}\", n)),\n                 Substitution::Name(n, _) => Ok(format!(\"{{{}}}\", n)),\n                 Substitution::Escape(_) => Err(None),"}, {"sha": "41531580c1987ca92c0a2e76c10dc993c1c7e16a", "filename": "compiler/rustc_builtin_macros/src/global_allocator.rs", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fglobal_allocator.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -20,27 +20,23 @@ pub fn expand(\n     check_builtin_macro_attribute(ecx, meta_item, sym::global_allocator);\n \n     let orig_item = item.clone();\n-    let not_static = || {\n-        ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n-        vec![orig_item.clone()]\n-    };\n \n     // Allow using `#[global_allocator]` on an item statement\n     // FIXME - if we get deref patterns, use them to reduce duplication here\n-    let (item, is_stmt, ty_span) = match &item {\n-        Annotatable::Item(item) => match item.kind {\n-            ItemKind::Static(ref ty, ..) => (item, false, ecx.with_def_site_ctxt(ty.span)),\n-            _ => return not_static(),\n-        },\n-        Annotatable::Stmt(stmt) => match &stmt.kind {\n-            StmtKind::Item(item_) => match item_.kind {\n-                ItemKind::Static(ref ty, ..) => (item_, true, ecx.with_def_site_ctxt(ty.span)),\n-                _ => return not_static(),\n-            },\n-            _ => return not_static(),\n-        },\n-        _ => return not_static(),\n-    };\n+    let (item, is_stmt, ty_span) =\n+        if let Annotatable::Item(item) = &item\n+            && let ItemKind::Static(ty, ..) = &item.kind\n+        {\n+            (item, false, ecx.with_def_site_ctxt(ty.span))\n+        } else if let Annotatable::Stmt(stmt) = &item\n+            && let StmtKind::Item(item) = &stmt.kind\n+            && let ItemKind::Static(ty, ..) = &item.kind\n+        {\n+            (item, true, ecx.with_def_site_ctxt(ty.span))\n+        } else {\n+            ecx.sess.parse_sess.span_diagnostic.span_err(item.span(), \"allocators must be statics\");\n+            return vec![orig_item.clone()]\n+        };\n \n     // Generate a bunch of new items using the AllocFnFactory\n     let span = ecx.with_def_site_ctxt(item.span);"}, {"sha": "f5f02fc772ab6b5b08b1082ab3fdb8ee6ec99f3c", "filename": "compiler/rustc_builtin_macros/src/test.rs", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -466,61 +466,67 @@ fn test_type(cx: &ExtCtxt<'_>) -> TestType {\n fn has_test_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n     let has_should_panic_attr = cx.sess.contains_name(&i.attrs, sym::should_panic);\n     let sd = &cx.sess.parse_sess.span_diagnostic;\n-    if let ast::ItemKind::Fn(box ast::Fn { ref sig, ref generics, .. }) = i.kind {\n-        if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n-            sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n-                .span_label(span, \"`unsafe` because of this\")\n-                .emit();\n-            return false;\n-        }\n-        if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n-            sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n-                .span_label(span, \"`async` because of this\")\n-                .emit();\n-            return false;\n-        }\n-\n-        // If the termination trait is active, the compiler will check that the output\n-        // type implements the `Termination` trait as `libtest` enforces that.\n-        let has_output = match sig.decl.output {\n-            ast::FnRetTy::Default(..) => false,\n-            ast::FnRetTy::Ty(ref t) if t.kind.is_unit() => false,\n-            _ => true,\n-        };\n-\n-        if !sig.decl.inputs.is_empty() {\n-            sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n-            return false;\n-        }\n+    match &i.kind {\n+        ast::ItemKind::Fn(box ast::Fn { sig, generics, .. }) => {\n+            if let ast::Unsafe::Yes(span) = sig.header.unsafety {\n+                sd.struct_span_err(i.span, \"unsafe functions cannot be used for tests\")\n+                    .span_label(span, \"`unsafe` because of this\")\n+                    .emit();\n+                return false;\n+            }\n+            if let ast::Async::Yes { span, .. } = sig.header.asyncness {\n+                sd.struct_span_err(i.span, \"async functions cannot be used for tests\")\n+                    .span_label(span, \"`async` because of this\")\n+                    .emit();\n+                return false;\n+            }\n \n-        match (has_output, has_should_panic_attr) {\n-            (true, true) => {\n-                sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n-                false\n+            // If the termination trait is active, the compiler will check that the output\n+            // type implements the `Termination` trait as `libtest` enforces that.\n+            let has_output = match &sig.decl.output {\n+                ast::FnRetTy::Default(..) => false,\n+                ast::FnRetTy::Ty(t) if t.kind.is_unit() => false,\n+                _ => true,\n+            };\n+\n+            if !sig.decl.inputs.is_empty() {\n+                sd.span_err(i.span, \"functions used as tests can not have any arguments\");\n+                return false;\n             }\n-            (true, false) => {\n-                if !generics.params.is_empty() {\n-                    sd.span_err(i.span, \"functions used as tests must have signature fn() -> ()\");\n+\n+            match (has_output, has_should_panic_attr) {\n+                (true, true) => {\n+                    sd.span_err(i.span, \"functions using `#[should_panic]` must return `()`\");\n                     false\n-                } else {\n-                    true\n                 }\n+                (true, false) => {\n+                    if !generics.params.is_empty() {\n+                        sd.span_err(\n+                            i.span,\n+                            \"functions used as tests must have signature fn() -> ()\",\n+                        );\n+                        false\n+                    } else {\n+                        true\n+                    }\n+                }\n+                (false, _) => true,\n             }\n-            (false, _) => true,\n         }\n-    } else {\n-        // should be unreachable because `is_test_fn_item` should catch all non-fn items\n-        false\n+        _ => {\n+            // should be unreachable because `is_test_fn_item` should catch all non-fn items\n+            debug_assert!(false);\n+            false\n+        }\n     }\n }\n \n fn has_bench_signature(cx: &ExtCtxt<'_>, i: &ast::Item) -> bool {\n-    let has_sig = if let ast::ItemKind::Fn(box ast::Fn { ref sig, .. }) = i.kind {\n+    let has_sig = match &i.kind {\n         // N.B., inadequate check, but we're running\n         // well before resolve, can't get too deep.\n-        sig.decl.inputs.len() == 1\n-    } else {\n-        false\n+        ast::ItemKind::Fn(box ast::Fn { sig, .. }) => sig.decl.inputs.len() == 1,\n+        _ => false,\n     };\n \n     if !has_sig {"}, {"sha": "ad8871080910640e11e123b8f27221101f2a543d", "filename": "compiler/rustc_builtin_macros/src/test_harness.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/700c095306ce89b0b18e2487aae9c0721e60a5e3/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Ftest_harness.rs?ref=700c095306ce89b0b18e2487aae9c0721e60a5e3", "patch": "@@ -131,8 +131,9 @@ impl<'a> MutVisitor for TestHarnessGenerator<'a> {\n \n         // We don't want to recurse into anything other than mods, since\n         // mods or tests inside of functions will break things\n-        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., ref spans)) = item.kind {\n-            let ast::ModSpans { inner_span: span, inject_use_span: _ } = *spans;\n+        if let ast::ItemKind::Mod(_, ModKind::Loaded(.., ast::ModSpans { inner_span: span, .. })) =\n+            item.kind\n+        {\n             let prev_tests = mem::take(&mut self.tests);\n             noop_visit_item_kind(&mut item.kind, self);\n             self.add_test_cases(item.id, span, prev_tests);"}]}