{"sha": "d9c06586f2aa12f89c94a27a20f0d0b260da216e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ5YzA2NTg2ZjJhYTEyZjg5Yzk0YTI3YTIwZjBkMGIyNjBkYTIxNmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-23T17:16:37Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-12-23T17:16:37Z"}, "message": "auto merge of #11120 : alexcrichton/rust/rustdoc-test, r=brson\n\nThis commit adds a `--test` flag to rustdoc to expose the ability to test code examples in doc strings. This work by using sundown's `lang` attribute to figure out how a code block should be tested. The format for this is:\r\n\r\n```\r\n1. ```rust\r\n2. ```rust,ignore\r\n3. ```rust,notest\r\n4. ```rust,should_fail\r\n```\r\n\r\nWhere `rust` means that rustdoc will attempt to test is, `ignore` means that it will not execute the test but it will compile it, `notest` means that rustdoc completely ignores it, and `should_fail` means that the test should fail. This commit also leverages `extra::test` for the testing harness in order to allow parallelization and whatnot.\r\n\r\nI have fixed all existing code examples in libstd and libextra, but I have not made a pass through the crates in order to change code blocks to testable code blocks.\r\n\r\nIt may also be a questionable decision to require opting-in to a testable code block.\r\n\r\nFinally, I kept our sugar in the doc suite to omit lines starting with `#` in documentation but still process them during tests.\r\n\r\nCloses #2925", "tree": {"sha": "e886da2ed2d5ca57025853fa1410149941ea179d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e886da2ed2d5ca57025853fa1410149941ea179d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9c06586f2aa12f89c94a27a20f0d0b260da216e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9c06586f2aa12f89c94a27a20f0d0b260da216e", "html_url": "https://github.com/rust-lang/rust/commit/d9c06586f2aa12f89c94a27a20f0d0b260da216e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9c06586f2aa12f89c94a27a20f0d0b260da216e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f71c0dc2cd876f50252cdb907a6f05493c56d3cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/f71c0dc2cd876f50252cdb907a6f05493c56d3cc", "html_url": "https://github.com/rust-lang/rust/commit/f71c0dc2cd876f50252cdb907a6f05493c56d3cc"}, {"sha": "f9b231cd0884fe90a730d637517c257a4f0c601a", "url": "https://api.github.com/repos/rust-lang/rust/commits/f9b231cd0884fe90a730d637517c257a4f0c601a", "html_url": "https://github.com/rust-lang/rust/commit/f9b231cd0884fe90a730d637517c257a4f0c601a"}], "stats": {"total": 831, "additions": 662, "deletions": 169}, "files": [{"sha": "39fc03bca0d1ef0e54b6be04522eae86d7674d3f", "filename": "doc/rustdoc.md", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/doc%2Frustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/doc%2Frustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frustdoc.md?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -85,3 +85,92 @@ javascript and a statically-generated search index. No special web server is\n required for the search.\n \n [sundown]: https://github.com/vmg/sundown/\n+\n+# Testing the Documentation\n+\n+`rustdoc` has support for testing code examples which appear in the\n+documentation. This is helpful for keeping code examples up to date with the\n+source code.\n+\n+To test documentation, the `--test` argument is passed to rustdoc:\n+\n+~~~\n+rustdoc --test crate.rs\n+~~~\n+\n+## Defining tests\n+\n+Rust documentation currently uses the markdown format, and code blocks can refer\n+to any piece of code-related documentation, which isn't always rust. Because of\n+this, only code blocks with the language of \"rust\" will be considered for\n+testing.\n+\n+~~~\n+```rust\n+// This is a testable code block\n+```\n+\n+```\n+// This is not a testable code block\n+```\n+\n+    // This is not a testable code block (4-space indent)\n+~~~\n+\n+In addition to only testing \"rust\"-language code blocks, there are additional\n+specifiers that can be used to dictate how a code block is tested:\n+\n+~~~\n+```rust,ignore\n+// This code block is ignored by rustdoc, but is passed through to the test\n+// harness\n+```\n+\n+```rust,should_fail\n+// This code block is expected to generate a failure\n+```\n+~~~\n+\n+Rustdoc also supplies some extra sugar for helping with some tedious\n+documentation examples. If a line is prefixed with a `#` character, then the\n+line will not show up in the HTML documentation, but it will be used when\n+testing the code block.\n+\n+~~~\n+```rust\n+# // showing 'fib' in this documentation would just be tedious and detracts from\n+# // what's actualy being documented.\n+# fn fib(n: int) { n + 2 }\n+\n+do spawn { fib(200); }\n+```\n+~~~\n+\n+The documentation online would look like `do spawn { fib(200); }`, but when\n+testing this code, the `fib` function will be included (so it can compile).\n+\n+## Running tests (advanced)\n+\n+Running tests often requires some special configuration to filter tests, find\n+libraries, or try running ignored examples. The testing framework that rustdoc\n+uses is build on `extra::test`, which is also used when you compile crates with\n+rustc's `--test` flag. Extra arguments can be passed to rustdoc's test harness\n+with the `--test-args` flag.\n+\n+~~~\n+// Only run tests containing 'foo' in their name\n+rustdoc --test lib.rs --test-args 'foo'\n+\n+// See what's possible when running tests\n+rustdoc --test lib.rs --test-args '--help'\n+\n+// Run all ignored tests\n+rustdoc --test lib.rs --test-args '--ignored'\n+~~~\n+\n+When testing a library, code examples will often show how functions are used,\n+and this code often requires `use`-ing paths from the crate. To accomodate this,\n+rustdoc will implicitly add `extern mod <crate>;` where `<crate>` is the name of\n+the crate being tested to the top of each code example. This means that rustdoc\n+must be able to find a compiled version of the library crate being tested. Extra\n+search paths may be added via the `-L` flag to `rustdoc`."}, {"sha": "1a56c008ccb702d35e27bd27a7830c6f32ea04a3", "filename": "mk/tests.mk", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/mk%2Ftests.mk", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/mk%2Ftests.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Ftests.mk?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -15,6 +15,7 @@\n \n # The names of crates that must be tested\n TEST_TARGET_CRATES = std extra rustuv\n+TEST_DOC_CRATES = std extra\n TEST_HOST_CRATES = rustpkg rustc rustdoc syntax\n TEST_CRATES = $(TEST_TARGET_CRATES) $(TEST_HOST_CRATES)\n \n@@ -281,6 +282,7 @@ check-stage$(1)-T-$(2)-H-$(3)-exec:     \t\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rpass-full-exec\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-rmake-exec\t\t\t\\\n         check-stage$(1)-T-$(2)-H-$(3)-crates-exec                       \\\n+        check-stage$(1)-T-$(2)-H-$(3)-doc-crates-exec                   \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-bench-exec\t\t\t\\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-debuginfo-exec \\\n \tcheck-stage$(1)-T-$(2)-H-$(3)-codegen-exec \\\n@@ -303,6 +305,10 @@ check-stage$(1)-T-$(2)-H-$(3)-crates-exec: \\\n \n endif\n \n+check-stage$(1)-T-$(2)-H-$(3)-doc-crates-exec: \\\n+        $$(foreach crate,$$(TEST_DOC_CRATES), \\\n+           check-stage$(1)-T-$(2)-H-$(3)-doc-$$(crate)-exec)\n+\n check-stage$(1)-T-$(2)-H-$(3)-doc-exec: \\\n         $$(foreach docname,$$(DOC_TEST_NAMES), \\\n            check-stage$(1)-T-$(2)-H-$(3)-doc-$$(docname)-exec)\n@@ -734,6 +740,26 @@ $(foreach host,$(CFG_HOST), \\\n    $(foreach docname,$(DOC_TEST_NAMES), \\\n     $(eval $(call DEF_RUN_DOC_TEST,$(stage),$(target),$(host),$(docname)))))))\n \n+CRATE_DOC_LIB-std = $(STDLIB_CRATE)\n+CRATE_DOC_LIB-extra = $(EXTRALIB_CRATE)\n+\n+define DEF_CRATE_DOC_TEST\n+\n+check-stage$(1)-T-$(2)-H-$(2)-doc-$(3)-exec: $$(call TEST_OK_FILE,$(1),$(2),$(2),doc-$(3))\n+\n+$$(call TEST_OK_FILE,$(1),$(2),$(2),doc-$(3)):\t\t\\\n+\t        $$(TEST_SREQ$(1)_T_$(2)_H_$(2))\t\t\\\n+\t\t$$(HBIN$(1)_H_$(2))/rustdoc$$(X_$(2))\n+\t@$$(call E, run doc-$(3) [$(2)])\n+\t$$(Q)$$(HBIN$(1)_H_$(2))/rustdoc$$(X_$(2)) --test \\\n+\t    $$(CRATE_DOC_LIB-$(3)) && touch $$@\n+\n+endef\n+\n+$(foreach host,$(CFG_HOST), \\\n+ $(foreach stage,$(STAGES), \\\n+  $(foreach crate,$(TEST_DOC_CRATES), \\\n+   $(eval $(call DEF_CRATE_DOC_TEST,$(stage),$(host),$(crate))))))\n \n ######################################################################\n # Extracting tests for docs\n@@ -762,6 +788,7 @@ $(foreach host,$(CFG_HOST), \\\n TEST_GROUPS = \\\n \tcrates \\\n \t$(foreach crate,$(TEST_CRATES),$(crate)) \\\n+\t$(foreach crate,$(TEST_DOC_CRATES),doc-$(crate)) \\\n \trpass \\\n \trpass-full \\\n \trfail \\"}, {"sha": "c1763c37bb5a16e029224cf4f7e839134707c6d4", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -18,18 +18,19 @@\n  * With simple pipes, without Arc, a copy would have to be made for each task.\n  *\n  * ```rust\n- * extern mod std;\n- * use extra::arc;\n- * let numbers=vec::from_fn(100, |ind| (ind as float)*rand::random());\n- * let shared_numbers=arc::Arc::new(numbers);\n+ * use extra::arc::Arc;\n+ * use std::{rand, vec};\n  *\n- *   do 10.times {\n- *       let (port, chan)  = stream();\n+ * let numbers = vec::from_fn(100, |i| (i as f32) * rand::random());\n+ * let shared_numbers = Arc::new(numbers);\n+ *\n+ *   for _ in range(0, 10) {\n+ *       let (port, chan) = Chan::new();\n  *       chan.send(shared_numbers.clone());\n  *\n  *       do spawn {\n- *           let shared_numbers=port.recv();\n- *           let local_numbers=shared_numbers.get();\n+ *           let shared_numbers = port.recv();\n+ *           let local_numbers = shared_numbers.get();\n  *\n  *           // Work with the local numbers\n  *       }\n@@ -448,15 +449,18 @@ impl<T:Freeze + Send> RWArc<T> {\n      * # Example\n      *\n      * ```rust\n-     * do arc.write_downgrade |mut write_token| {\n-     *     do write_token.write_cond |state, condvar| {\n-     *         ... exclusive access with mutable state ...\n-     *     }\n+     * use extra::arc::RWArc;\n+     *\n+     * let arc = RWArc::new(1);\n+     * arc.write_downgrade(|mut write_token| {\n+     *     write_token.write_cond(|state, condvar| {\n+     *         // ... exclusive access with mutable state ...\n+     *     });\n      *     let read_token = arc.downgrade(write_token);\n-     *     do read_token.read |state| {\n-     *         ... shared access with immutable state ...\n-     *     }\n-     * }\n+     *     read_token.read(|state| {\n+     *         // ... shared access with immutable state ...\n+     *     });\n+     * })\n      * ```\n      */\n     pub fn write_downgrade<U>(&self, blk: |v: RWWriteMode<T>| -> U) -> U {"}, {"sha": "cb82c1abe1ebc0bb1852aba1770b6e49d54a1090", "filename": "src/libextra/future.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffuture.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -15,9 +15,10 @@\n  * # Example\n  *\n  * ```rust\n+ * use extra::future::Future;\n  * # fn fib(n: uint) -> uint {42};\n  * # fn make_a_sandwich() {};\n- * let mut delayed_fib = extra::future::spawn (|| fib(5000) );\n+ * let mut delayed_fib = do Future::spawn { fib(5000) };\n  * make_a_sandwich();\n  * println!(\"fib(5000) = {}\", delayed_fib.get())\n  * ```"}, {"sha": "cb9e53dc69ef43577314a2b8c02479e96e253b11", "filename": "src/libextra/glob.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Fglob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Fglob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fglob.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -53,8 +53,10 @@ pub struct GlobIterator {\n /// `puppies.jpg` and `hamsters.gif`:\n ///\n /// ```rust\n+/// use extra::glob::glob;\n+///\n /// for path in glob(\"/media/pictures/*.jpg\") {\n-///     println(path.to_str());\n+///     println!(\"{}\", path.display());\n /// }\n /// ```\n ///\n@@ -188,21 +190,23 @@ enum MatchResult {\n impl Pattern {\n \n     /**\n-     * This function compiles Unix shell style patterns: `?` matches any single character,\n-     * `*` matches any (possibly empty) sequence of characters and `[...]` matches any character\n-     * inside the brackets, unless the first character is `!` in which case it matches any\n-     * character except those between the `!` and the `]`. Character sequences can also specify\n-     * ranges of characters, as ordered by Unicode, so e.g. `[0-9]` specifies any character\n-     * between 0 and 9 inclusive.\n+     * This function compiles Unix shell style patterns: `?` matches any single\n+     * character, `*` matches any (possibly empty) sequence of characters and\n+     * `[...]` matches any character inside the brackets, unless the first\n+     * character is `!` in which case it matches any character except those\n+     * between the `!` and the `]`. Character sequences can also specify ranges\n+     * of characters, as ordered by Unicode, so e.g. `[0-9]` specifies any\n+     * character between 0 and 9 inclusive.\n      *\n-     * The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets (e.g. `[?]`).\n-     * When a `]` occurs immediately following `[` or `[!` then it is interpreted as\n-     * being part of, rather then ending, the character set, so `]` and NOT `]` can be\n-     * matched by `[]]` and `[!]]` respectively. The `-` character can be specified inside a\n-     * character sequence pattern by placing it at the start or the end, e.g. `[abc-]`.\n+     * The metacharacters `?`, `*`, `[`, `]` can be matched by using brackets\n+     * (e.g. `[?]`).  When a `]` occurs immediately following `[` or `[!` then\n+     * it is interpreted as being part of, rather then ending, the character\n+     * set, so `]` and NOT `]` can be matched by `[]]` and `[!]]` respectively.\n+     * The `-` character can be specified inside a character sequence pattern by\n+     * placing it at the start or the end, e.g. `[abc-]`.\n      *\n-     * When a `[` does not have a closing `]` before the end of the string then the `[` will\n-     * be treated literally.\n+     * When a `[` does not have a closing `]` before the end of the string then\n+     * the `[` will be treated literally.\n      */\n     pub fn new(pattern: &str) -> Pattern {\n \n@@ -229,7 +233,8 @@ impl Pattern {\n                         match chars.slice_from(i + 3).position_elem(&']') {\n                             None => (),\n                             Some(j) => {\n-                                let cs = parse_char_specifiers(chars.slice(i + 2, i + 3 + j));\n+                                let chars = chars.slice(i + 2, i + 3 + j);\n+                                let cs = parse_char_specifiers(chars);\n                                 tokens.push(AnyExcept(cs));\n                                 i += j + 4;\n                                 continue;\n@@ -292,6 +297,8 @@ impl Pattern {\n      * # Example\n      *\n      * ```rust\n+     * use extra::glob::Pattern;\n+     *\n      * assert!(Pattern::new(\"c?t\").matches(\"cat\"));\n      * assert!(Pattern::new(\"k[!e]tteh\").matches(\"kitteh\"));\n      * assert!(Pattern::new(\"d*g\").matches(\"doog\"));\n@@ -509,7 +516,7 @@ impl MatchOptions {\n      *\n      * This function always returns this value:\n      *\n-     * ```rust\n+     * ```rust,ignore\n      * MatchOptions {\n      *     case_sensitive: true,\n      *     require_literal_separator: false."}, {"sha": "380476dc4bca07695ee745917cb5cab29cd3eb15", "filename": "src/libextra/hex.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Fhex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Fhex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fhex.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -28,7 +28,6 @@ impl<'a> ToHex for &'a [u8] {\n      * # Example\n      *\n      * ```rust\n-     * extern mod extra;\n      * use extra::hex::ToHex;\n      *\n      * fn main () {\n@@ -71,12 +70,11 @@ impl<'a> FromHex for &'a str {\n      * This converts a string literal to hexadecimal and back.\n      *\n      * ```rust\n-     * extern mod extra;\n      * use extra::hex::{FromHex, ToHex};\n      * use std::str;\n      *\n      * fn main () {\n-     *     let hello_str = \"Hello, World\".to_hex();\n+     *     let hello_str = \"Hello, World\".as_bytes().to_hex();\n      *     println!(\"{}\", hello_str);\n      *     let bytes = hello_str.from_hex().unwrap();\n      *     println!(\"{:?}\", bytes);"}, {"sha": "e1cb54ae45296e1524e47855bc8c7c0a5c50feaf", "filename": "src/libextra/lru_cache.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Flru_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Flru_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Flru_cache.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -17,6 +17,8 @@\n //! # Example\n //!\n //! ```rust\n+//! use extra::lru_cache::LruCache;\n+//!\n //! let mut cache: LruCache<int, int> = LruCache::new(2);\n //! cache.put(1, 10);\n //! cache.put(2, 20);"}, {"sha": "57a7f38696d6c09dacd98198d86de5e3fd0a55e5", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -568,13 +568,16 @@ impl RWLock {\n      * # Example\n      *\n      * ```rust\n+     * use extra::sync::RWLock;\n+     *\n+     * let lock = RWLock::new();\n      * lock.write_downgrade(|mut write_token| {\n      *     write_token.write_cond(|condvar| {\n-     *         ... exclusive access ...\n+     *         // ... exclusive access ...\n      *     });\n      *     let read_token = lock.downgrade(write_token);\n      *     read_token.read(|| {\n-     *         ... shared access ...\n+     *         // ... shared access ...\n      *     })\n      * })\n      * ```"}, {"sha": "79886273a15413a17ab670cacfb113b9218640fb", "filename": "src/libextra/url.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Furl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibextra%2Furl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Furl.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -26,6 +26,8 @@ use std::uint;\n /// # Example\n ///\n /// ```rust\n+/// use extra::url::{Url, UserInfo};\n+///\n /// let url = Url { scheme: ~\"https\",\n ///                 user: Some(UserInfo { user: ~\"username\", pass: None }),\n ///                 host: ~\"example.com\",\n@@ -388,8 +390,10 @@ fn query_from_str(rawquery: &str) -> Query {\n  * # Example\n  *\n  * ```rust\n+ * use extra::url;\n+ *\n  * let query = ~[(~\"title\", ~\"The Village\"), (~\"north\", ~\"52.91\"), (~\"west\", ~\"4.10\")];\n- * println(query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n+ * println(url::query_to_str(&query));  // title=The%20Village&north=52.91&west=4.10\n  * ```\n  */\n pub fn query_to_str(query: &Query) -> ~str {"}, {"sha": "1111be5f417ec8fec7a635afb223c7d7afcdf961", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -1147,13 +1147,17 @@ fn name_from_pat(p: &ast::Pat) -> ~str {\n fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n                 id: ast::NodeId) -> Type {\n     let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+    let tycx = match cx.tycx {\n+        Some(tycx) => tycx,\n+        // If we're extracting tests, this return value doesn't matter.\n+        None => return Bool\n+    };\n     debug!(\"searching for {:?} in defmap\", id);\n-    let d = match cx.tycx.def_map.find(&id) {\n+    let d = match tycx.def_map.find(&id) {\n         Some(k) => k,\n         None => {\n-            let ctxt = local_data::get(super::ctxtkey, |x| *x.unwrap());\n             debug!(\"could not find {:?} in defmap (`{}`)\", id,\n-                   syntax::ast_map::node_id_to_str(ctxt.tycx.items, id, ctxt.sess.intr()));\n+                   syntax::ast_map::node_id_to_str(tycx.items, id, cx.sess.intr()));\n             fail!(\"Unexpected failure: unresolved id not in defmap (this is a bug!)\")\n         }\n     };\n@@ -1182,7 +1186,7 @@ fn resolve_type(path: Path, tpbs: Option<~[TyParamBound]>,\n     if ast_util::is_local(def_id) {\n         ResolvedPath{ path: path, typarams: tpbs, id: def_id.node }\n     } else {\n-        let fqn = csearch::get_item_path(cx.tycx, def_id);\n+        let fqn = csearch::get_item_path(tycx, def_id);\n         let fqn = fqn.move_iter().map(|i| {\n             match i {\n                 ast_map::path_mod(id) |\n@@ -1203,6 +1207,11 @@ fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n }\n \n fn resolve_def(id: ast::NodeId) -> Option<ast::DefId> {\n-    let dm = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.def_map;\n-    dm.find(&id).map(|&d| ast_util::def_id_of_def(d))\n+    let cx = local_data::get(super::ctxtkey, |x| *x.unwrap());\n+    match cx.tycx {\n+        Some(tcx) => {\n+            tcx.def_map.find(&id).map(|&d| ast_util::def_id_of_def(d))\n+        }\n+        None => None\n+    }\n }"}, {"sha": "5c3d3484657349da3e03e2363f3e5e848a099596", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -27,7 +27,7 @@ use clean::Clean;\n \n pub struct DocContext {\n     crate: ast::Crate,\n-    tycx: middle::ty::ctxt,\n+    tycx: Option<middle::ty::ctxt>,\n     sess: driver::session::Session\n }\n \n@@ -78,17 +78,13 @@ fn get_ast_and_resolve(cpath: &Path,\n     } = phase_3_run_analysis_passes(sess, &crate);\n \n     debug!(\"crate: {:?}\", crate);\n-    return (DocContext { crate: crate, tycx: ty_cx, sess: sess },\n+    return (DocContext { crate: crate, tycx: Some(ty_cx), sess: sess },\n             CrateAnalysis { exported_items: exported_items });\n }\n \n pub fn run_core (libs: HashSet<Path>, cfgs: ~[~str], path: &Path) -> (clean::Crate, CrateAnalysis) {\n     let (ctxt, analysis) = get_ast_and_resolve(path, libs, cfgs);\n     let ctxt = @ctxt;\n-    debug!(\"defmap:\");\n-    for (k, v) in ctxt.tycx.def_map.iter() {\n-        debug!(\"{:?}: {:?}\", k, v);\n-    }\n     local_data::set(super::ctxtkey, ctxt);\n \n     let v = @mut RustdocVisitor::new();"}, {"sha": "6fd83af3b2e760c7bac51f97b571be70a38a84aa", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 84, "deletions": 6, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -22,9 +22,12 @@\n //! // ... something using html\n //! ```\n \n+use std::cast;\n use std::fmt;\n-use std::libc;\n use std::io;\n+use std::libc;\n+use std::str;\n+use std::unstable::intrinsics;\n use std::vec;\n \n /// A unit struct which has the `fmt::Default` trait implemented. When\n@@ -41,8 +44,10 @@ static MKDEXT_STRIKETHROUGH: libc::c_uint = 1 << 4;\n \n type sd_markdown = libc::c_void;  // this is opaque to us\n \n-// this is a large struct of callbacks we don't use\n-type sd_callbacks = [libc::size_t, ..26];\n+struct sd_callbacks {\n+    blockcode: extern \"C\" fn(*buf, *buf, *buf, *libc::c_void),\n+    other: [libc::size_t, ..25],\n+}\n \n struct html_toc_data {\n     header_count: libc::c_int,\n@@ -56,6 +61,11 @@ struct html_renderopt {\n     link_attributes: Option<extern \"C\" fn(*buf, *buf, *libc::c_void)>,\n }\n \n+struct my_opaque {\n+    opt: html_renderopt,\n+    dfltblk: extern \"C\" fn(*buf, *buf, *buf, *libc::c_void),\n+}\n+\n struct buf {\n     data: *u8,\n     size: libc::size_t,\n@@ -84,7 +94,28 @@ extern {\n \n }\n \n-fn render(w: &mut io::Writer, s: &str) {\n+pub fn render(w: &mut io::Writer, s: &str) {\n+    extern fn block(ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n+        unsafe {\n+            let my_opaque: &my_opaque = cast::transmute(opaque);\n+            vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+                let text = str::from_utf8(text);\n+                let mut lines = text.lines().filter(|l| {\n+                    !l.trim().starts_with(\"#\")\n+                });\n+                let text = lines.to_owned_vec().connect(\"\\n\");\n+\n+                let buf = buf {\n+                    data: text.as_bytes().as_ptr(),\n+                    size: text.len() as libc::size_t,\n+                    asize: text.len() as libc::size_t,\n+                    unit: 0,\n+                };\n+                (my_opaque.dfltblk)(ob, &buf, lang, opaque);\n+            })\n+        }\n+    }\n+\n     // This code is all lifted from examples/sundown.c in the sundown repo\n     unsafe {\n         let ob = bufnew(OUTPUT_UNIT);\n@@ -100,11 +131,16 @@ fn render(w: &mut io::Writer, s: &str) {\n             flags: 0,\n             link_attributes: None,\n         };\n-        let callbacks: sd_callbacks = [0, ..26];\n+        let mut callbacks: sd_callbacks = intrinsics::init();\n \n         sdhtml_renderer(&callbacks, &options, 0);\n+        let opaque = my_opaque {\n+            opt: options,\n+            dfltblk: callbacks.blockcode,\n+        };\n+        callbacks.blockcode = block;\n         let markdown = sd_markdown_new(extensions, 16, &callbacks,\n-                                       &options as *html_renderopt as *libc::c_void);\n+                                       &opaque as *my_opaque as *libc::c_void);\n \n \n         sd_markdown_render(ob, s.as_ptr(), s.len() as libc::size_t, markdown);\n@@ -118,6 +154,48 @@ fn render(w: &mut io::Writer, s: &str) {\n     }\n }\n \n+pub fn find_testable_code(doc: &str, tests: &mut ::test::Collector) {\n+    extern fn block(_ob: *buf, text: *buf, lang: *buf, opaque: *libc::c_void) {\n+        unsafe {\n+            if text.is_null() || lang.is_null() { return }\n+            let (test, shouldfail, ignore) =\n+                vec::raw::buf_as_slice((*lang).data,\n+                                       (*lang).size as uint, |lang| {\n+                    let s = str::from_utf8(lang);\n+                    (s.contains(\"rust\"), s.contains(\"should_fail\"),\n+                     s.contains(\"ignore\"))\n+                });\n+            if !test { return }\n+            vec::raw::buf_as_slice((*text).data, (*text).size as uint, |text| {\n+                let tests: &mut ::test::Collector = intrinsics::transmute(opaque);\n+                let text = str::from_utf8(text);\n+                let mut lines = text.lines().map(|l| l.trim_chars(&'#'));\n+                let text = lines.to_owned_vec().connect(\"\\n\");\n+                tests.add_test(text, ignore, shouldfail);\n+            })\n+        }\n+    }\n+\n+    unsafe {\n+        let ob = bufnew(OUTPUT_UNIT);\n+        let extensions = MKDEXT_NO_INTRA_EMPHASIS | MKDEXT_TABLES |\n+                         MKDEXT_FENCED_CODE | MKDEXT_AUTOLINK |\n+                         MKDEXT_STRIKETHROUGH;\n+        let callbacks = sd_callbacks {\n+            blockcode: block,\n+            other: intrinsics::init()\n+        };\n+\n+        let tests = tests as *mut ::test::Collector as *libc::c_void;\n+        let markdown = sd_markdown_new(extensions, 16, &callbacks, tests);\n+\n+        sd_markdown_render(ob, doc.as_ptr(), doc.len() as libc::size_t,\n+                           markdown);\n+        sd_markdown_free(markdown);\n+        bufrelease(ob);\n+    }\n+}\n+\n impl<'a> fmt::Default for Markdown<'a> {\n     fn fmt(md: &Markdown<'a>, fmt: &mut fmt::Formatter) {\n         // This is actually common enough to special-case"}, {"sha": "3d9a0a73e57545e37e0590f2152dcf6cc0fe6667", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -47,6 +47,7 @@ pub mod html {\n pub mod passes;\n pub mod plugins;\n pub mod visit_ast;\n+pub mod test;\n \n pub static SCHEMA_VERSION: &'static str = \"0.8.1\";\n \n@@ -100,6 +101,9 @@ pub fn opts() -> ~[groups::OptGroup] {\n         optmulti(\"\", \"plugins\", \"space separated list of plugins to also load\",\n                  \"PLUGINS\"),\n         optflag(\"\", \"no-defaults\", \"don't run the default passes\"),\n+        optflag(\"\", \"test\", \"run code examples as tests\"),\n+        optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\",\n+                 \"ARGS\"),\n     ]\n }\n \n@@ -114,6 +118,19 @@ pub fn main_args(args: &[~str]) -> int {\n         return 0;\n     }\n \n+    if matches.free.len() == 0 {\n+        println(\"expected an input file to act on\");\n+        return 1;\n+    } if matches.free.len() > 1 {\n+        println(\"only one input file may be specified\");\n+        return 1;\n+    }\n+    let input = matches.free[0].as_slice();\n+\n+    if matches.opt_present(\"test\") {\n+        return test::run(input, &matches);\n+    }\n+\n     if matches.opt_strs(\"passes\") == ~[~\"list\"] {\n         println(\"Available passes for running rustdoc:\");\n         for &(name, _, description) in PASSES.iter() {\n@@ -126,7 +143,7 @@ pub fn main_args(args: &[~str]) -> int {\n         return 0;\n     }\n \n-    let (crate, res) = match acquire_input(&matches) {\n+    let (crate, res) = match acquire_input(input, &matches) {\n         Ok(pair) => pair,\n         Err(s) => {\n             println!(\"input error: {}\", s);\n@@ -157,14 +174,8 @@ pub fn main_args(args: &[~str]) -> int {\n \n /// Looks inside the command line arguments to extract the relevant input format\n /// and files and then generates the necessary rustdoc output for formatting.\n-fn acquire_input(matches: &getopts::Matches) -> Result<Output, ~str> {\n-    if matches.free.len() == 0 {\n-        return Err(~\"expected an input file to act on\");\n-    } if matches.free.len() > 1 {\n-        return Err(~\"only one input file may be specified\");\n-    }\n-\n-    let input = matches.free[0].as_slice();\n+fn acquire_input(input: &str,\n+                 matches: &getopts::Matches) -> Result<Output, ~str> {\n     match matches.opt_str(\"r\") {\n         Some(~\"rust\") => Ok(rust_input(input, matches)),\n         Some(~\"json\") => json_input(input),"}, {"sha": "9462f8118ba655c43ba7d5ba9cc20011c6e29081", "filename": "src/librustdoc/test.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -0,0 +1,207 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::hashmap::HashSet;\n+use std::local_data;\n+use std::os;\n+use std::run;\n+use std::str;\n+\n+use extra::tempfile::TempDir;\n+use extra::getopts;\n+use extra::test;\n+use rustc::driver::driver;\n+use rustc::driver::session;\n+use syntax::diagnostic;\n+use syntax::parse;\n+\n+use core;\n+use clean;\n+use clean::Clean;\n+use fold::DocFolder;\n+use html::markdown;\n+use passes;\n+use visit_ast::RustdocVisitor;\n+\n+pub fn run(input: &str, matches: &getopts::Matches) -> int {\n+    let parsesess = parse::new_parse_sess(None);\n+    let input = driver::file_input(Path::new(input));\n+    let libs = matches.opt_strs(\"L\").map(|s| Path::new(s.as_slice()));\n+    let libs = @mut libs.move_iter().collect();\n+\n+    let sessopts = @session::options {\n+        binary: @\"rustdoc\",\n+        maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n+        addl_lib_search_paths: libs,\n+        outputs: ~[session::OutputDylib],\n+        .. (*session::basic_options()).clone()\n+    };\n+\n+\n+    let diagnostic_handler = diagnostic::mk_handler(None);\n+    let span_diagnostic_handler =\n+        diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+\n+    let sess = driver::build_session_(sessopts,\n+                                      parsesess.cm,\n+                                      @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter,\n+                                      span_diagnostic_handler);\n+\n+    let cfg = driver::build_configuration(sess);\n+    let mut crate = driver::phase_1_parse_input(sess, cfg.clone(), &input);\n+    crate = driver::phase_2_configure_and_expand(sess, cfg, crate);\n+\n+    let ctx = @core::DocContext {\n+        crate: crate,\n+        tycx: None,\n+        sess: sess,\n+    };\n+    local_data::set(super::ctxtkey, ctx);\n+\n+    let v = @mut RustdocVisitor::new();\n+    v.visit(&ctx.crate);\n+    let crate = v.clean();\n+    let (crate, _) = passes::unindent_comments(crate);\n+    let (crate, _) = passes::collapse_docs(crate);\n+\n+    let mut collector = Collector {\n+        tests: ~[],\n+        names: ~[],\n+        cnt: 0,\n+        libs: libs,\n+        cratename: crate.name.to_owned(),\n+    };\n+    collector.fold_crate(crate);\n+\n+    let args = matches.opt_strs(\"test-args\");\n+    let mut args = args.iter().flat_map(|s| s.words()).map(|s| s.to_owned());\n+    let mut args = args.to_owned_vec();\n+    args.unshift(~\"rustdoctest\");\n+\n+    test::test_main(args, collector.tests);\n+\n+    0\n+}\n+\n+fn runtest(test: &str, cratename: &str, libs: HashSet<Path>) {\n+    let test = maketest(test, cratename);\n+    let parsesess = parse::new_parse_sess(None);\n+    let input = driver::str_input(test);\n+\n+    let sessopts = @session::options {\n+        binary: @\"rustdoctest\",\n+        maybe_sysroot: Some(@os::self_exe_path().unwrap().dir_path()),\n+        addl_lib_search_paths: @mut libs,\n+        outputs: ~[session::OutputExecutable],\n+        debugging_opts: session::prefer_dynamic,\n+        .. (*session::basic_options()).clone()\n+    };\n+\n+    let diagnostic_handler = diagnostic::mk_handler(None);\n+    let span_diagnostic_handler =\n+        diagnostic::mk_span_handler(diagnostic_handler, parsesess.cm);\n+\n+    let sess = driver::build_session_(sessopts,\n+                                      parsesess.cm,\n+                                      @diagnostic::DefaultEmitter as\n+                                            @diagnostic::Emitter,\n+                                      span_diagnostic_handler);\n+\n+    let outdir = TempDir::new(\"rustdoctest\").expect(\"rustdoc needs a tempdir\");\n+    let out = Some(outdir.path().clone());\n+    let cfg = driver::build_configuration(sess);\n+    driver::compile_input(sess, cfg, &input, &out, &None);\n+\n+    let exe = outdir.path().join(\"rust_out\");\n+    let out = run::process_output(exe.as_str().unwrap(), []);\n+    match out {\n+        None => fail!(\"couldn't run the test\"),\n+        Some(out) => {\n+            if !out.status.success() {\n+                fail!(\"test executable failed:\\n{}\",\n+                      str::from_utf8(out.error));\n+            }\n+        }\n+    }\n+}\n+\n+fn maketest(s: &str, cratename: &str) -> @str {\n+    let mut prog = ~r\"\n+#[deny(warnings)];\n+#[allow(unused_variable, dead_assignment, unused_mut, attribute_usage, dead_code)];\n+#[feature(macro_rules, globs, struct_variant, managed_boxes)];\n+\";\n+    if s.contains(\"extra\") {\n+        prog.push_str(\"extern mod extra;\\n\");\n+    }\n+    if s.contains(cratename) {\n+        prog.push_str(format!(\"extern mod {};\\n\", cratename));\n+    }\n+    if s.contains(\"fn main\") {\n+        prog.push_str(s);\n+    } else {\n+        prog.push_str(\"fn main() {\\n\");\n+        prog.push_str(s);\n+        prog.push_str(\"\\n}\");\n+    }\n+\n+    return prog.to_managed();\n+}\n+\n+pub struct Collector {\n+    priv tests: ~[test::TestDescAndFn],\n+    priv names: ~[~str],\n+    priv libs: @mut HashSet<Path>,\n+    priv cnt: uint,\n+    priv cratename: ~str,\n+}\n+\n+impl Collector {\n+    pub fn add_test(&mut self, test: &str, ignore: bool, should_fail: bool) {\n+        let test = test.to_owned();\n+        let name = format!(\"{}_{}\", self.names.connect(\"::\"), self.cnt);\n+        self.cnt += 1;\n+        let libs = (*self.libs).clone();\n+        let cratename = self.cratename.to_owned();\n+        self.tests.push(test::TestDescAndFn {\n+            desc: test::TestDesc {\n+                name: test::DynTestName(name),\n+                ignore: ignore,\n+                should_fail: should_fail,\n+            },\n+            testfn: test::DynTestFn(proc() {\n+                runtest(test, cratename, libs);\n+            }),\n+        });\n+    }\n+}\n+\n+impl DocFolder for Collector {\n+    fn fold_item(&mut self, item: clean::Item) -> Option<clean::Item> {\n+        let pushed = match item.name {\n+            Some(ref name) if name.len() == 0 => false,\n+            Some(ref name) => { self.names.push(name.to_owned()); true }\n+            None => false\n+        };\n+        match item.doc_value() {\n+            Some(doc) => {\n+                self.cnt = 0;\n+                markdown::find_testable_code(doc, self);\n+            }\n+            None => {}\n+        }\n+        let ret = self.fold_item_recur(item);\n+        if pushed {\n+            self.names.pop();\n+        }\n+        return ret;\n+    }\n+}"}, {"sha": "03ab85918c759fe3a5df2fc45cc90d2793be2e53", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 13, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -12,11 +12,10 @@\n //! usable for clean\n \n use syntax::abi::AbiSet;\n-use syntax::{ast, ast_map};\n+use syntax::ast;\n use syntax::codemap::Span;\n \n use doctree::*;\n-use std::local_data;\n \n pub struct RustdocVisitor {\n     module: Module,\n@@ -91,15 +90,8 @@ impl RustdocVisitor {\n         }\n \n         fn visit_mod_contents(span: Span, attrs: ~[ast::Attribute], vis:\n-                              ast::visibility, id: ast::NodeId, m: &ast::_mod) -> Module {\n-            let am = local_data::get(super::ctxtkey, |x| *x.unwrap()).tycx.items;\n-            let name = match am.find(&id) {\n-                Some(m) => match m {\n-                    &ast_map::node_item(ref it, _) => Some(it.ident),\n-                    _ => fail!(\"mod id mapped to non-item in the ast map\")\n-                },\n-                None => None\n-            };\n+                              ast::visibility, id: ast::NodeId, m: &ast::_mod,\n+                              name: Option<ast::Ident>) -> Module {\n             let mut om = Module::new(name);\n             om.view_items = m.view_items.clone();\n             om.where = span;\n@@ -117,7 +109,8 @@ impl RustdocVisitor {\n             match item.node {\n                 ast::item_mod(ref m) => {\n                     om.mods.push(visit_mod_contents(item.span, item.attrs.clone(),\n-                                                    item.vis, item.id, m));\n+                                                    item.vis, item.id, m,\n+                                                    Some(item.ident)));\n                 },\n                 ast::item_enum(ref ed, ref gen) => om.enums.push(visit_enum_def(item, ed, gen)),\n                 ast::item_struct(sd, ref gen) => om.structs.push(visit_struct_def(item, sd, gen)),\n@@ -182,6 +175,7 @@ impl RustdocVisitor {\n         }\n \n         self.module = visit_mod_contents(crate.span, crate.attrs.clone(),\n-                                         ast::public, ast::CRATE_NODE_ID, &crate.module);\n+                                         ast::public, ast::CRATE_NODE_ID,\n+                                         &crate.module, None);\n     }\n }"}, {"sha": "a7e502be32e613ad5c704f72d9a512182acd3f67", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -51,13 +51,13 @@ let my_string = \"Hello, world!\";\n let my_c_string = my_string.to_c_str();\n my_c_string.with_ref(|c_buffer| {\n     unsafe { puts(c_buffer); }\n-})\n+});\n \n // Don't save off the allocation of the C string, the `c_buffer` will be\n // deallocated when this block returns!\n my_string.with_c_str(|c_buffer| {\n     unsafe { puts(c_buffer); }\n-})\n+});\n  ```\n \n */\n@@ -216,7 +216,11 @@ pub trait ToCStr {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let s = \"PATH\".with_c_str(|path| libc::getenv(path))\n+    /// use std::libc;\n+    ///\n+    /// let s = \"PATH\".with_c_str(|path| unsafe {\n+    ///     libc::getenv(path)\n+    /// });\n     /// ```\n     ///\n     /// # Failure"}, {"sha": "05aab2f9570a896d8c5e01f2bceac4a0235d7aaa", "filename": "src/libstd/cast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcast.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -49,7 +49,9 @@ pub unsafe fn bump_box_refcount<T>(t: @T) { forget(t); }\n  * # Example\n  *\n  * ```rust\n- * let v: &[u8] = transmute(\"L\");\n+ * use std::cast;\n+ *\n+ * let v: &[u8] = unsafe { cast::transmute(\"L\") };\n  * assert!(v == [76u8]);\n  * ```\n  */"}, {"sha": "33d5d48ebdcae925035f9c3681e6027eb11e7525", "filename": "src/libstd/comm/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fcomm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fcomm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fmod.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -57,7 +57,7 @@\n //!\n //! # Example\n //!\n-//! ```rust\n+//! ```rust,should_fail\n //! // Create a simple streaming channel\n //! let (port, chan) = Chan::new();\n //! do spawn {\n@@ -81,7 +81,7 @@\n //!\n //! // The call to recv() will fail!() because the channel has already hung\n //! // up (or been deallocated)\n-//! let (port, chan) = Chan::new();\n+//! let (port, chan) = Chan::<int>::new();\n //! drop(chan);\n //! port.recv();\n //! ```"}, {"sha": "bbd4cfea78d7a65d81f7a2f6d7af94b296e7ab0c", "filename": "src/libstd/comm/select.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fcomm%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fcomm%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcomm%2Fselect.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -25,7 +25,7 @@\n //!\n //! # Example\n //!\n-//! ```rust\n+//! ```rust,ignore\n //! let (mut p1, c1) = Chan::new();\n //! let (mut p2, c2) = Chan::new();\n //!\n@@ -40,6 +40,7 @@\n //!         assert_eq!(val, 2);\n //!     }\n //! )\n+//! ```\n \n #[allow(dead_code)];\n "}, {"sha": "2ecae8e85d0a38d24b315e3972e6904ea353709c", "filename": "src/libstd/condition.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fcondition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fcondition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcondition.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -23,13 +23,17 @@ A condition is declared through the `condition!` macro provided by the compiler:\n condition! {\n     pub my_error: int -> ~str;\n }\n- ```\n+# fn main() {}\n+```\n \n This macro declares an inner module called `my_error` with one static variable,\n `cond` that is a static `Condition` instance. To help understand what the other\n parameters are used for, an example usage of this condition would be:\n \n ```rust\n+# condition! { pub my_error: int -> ~str; }\n+# fn main() {\n+\n my_error::cond.trap(|raised_int| {\n \n     // the condition `my_error` was raised on, and the value it raised is stored\n@@ -51,6 +55,8 @@ my_error::cond.trap(|raised_int| {\n     println(my_error::cond.raise(4)); // prints \"oh well\"\n \n })\n+\n+# }\n  ```\n \n Condition handling is useful in cases where propagating errors is either to\n@@ -99,10 +105,12 @@ impl<T, U> Condition<T, U> {\n     /// ```rust\n     /// condition! { my_error: int -> int; }\n     ///\n+    /// # fn main() {\n     /// let trap = my_error::cond.trap(|error| error + 3);\n     ///\n     /// // use `trap`'s inside method to register the handler and then run a\n     /// // block of code with the handler registered\n+    /// # }\n     /// ```\n     pub fn trap<'a>(&'a self, h: 'a |T| -> U) -> Trap<'a, T, U> {\n         let h: Closure = unsafe { ::cast::transmute(h) };\n@@ -176,10 +184,12 @@ impl<'a, T, U> Trap<'a, T, U> {\n     /// ```rust\n     /// condition! { my_error: int -> int; }\n     ///\n+    /// # fn main() {\n     /// let result = my_error::cond.trap(|error| error + 3).inside(|| {\n     ///     my_error::cond.raise(4)\n     /// });\n     /// assert_eq!(result, 7);\n+    /// # }\n     /// ```\n     pub fn inside<V>(&self, inner: 'a || -> V) -> V {\n         let _g = Guard { cond: self.cond };"}, {"sha": "3bbf8031fff93b843eda0c8e4d1d256e0203b618", "filename": "src/libstd/fmt/mod.rs", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffmt%2Fmod.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -34,12 +34,12 @@ arguments directly while performing minimal allocations.\n Some examples of the `format!` extension are:\n \n ```rust\n-format!(\"Hello\")                  // => ~\"Hello\"\n-format!(\"Hello, {:s}!\", \"world\")  // => ~\"Hello, world!\"\n-format!(\"The number is {:d}\", 1)  // => ~\"The number is 1\"\n-format!(\"{:?}\", ~[3, 4])          // => ~\"~[3, 4]\"\n-format!(\"{value}\", value=4)       // => ~\"4\"\n-format!(\"{} {}\", 1, 2)            // => ~\"1 2\"\n+format!(\"Hello\");                 // => ~\"Hello\"\n+format!(\"Hello, {:s}!\", \"world\"); // => ~\"Hello, world!\"\n+format!(\"The number is {:d}\", 1); // => ~\"The number is 1\"\n+format!(\"{:?}\", ~[3, 4]);         // => ~\"~[3, 4]\"\n+format!(\"{value}\", value=4);      // => ~\"4\"\n+format!(\"{} {}\", 1, 2);           // => ~\"1 2\"\n ```\n \n From these, you can see that the first argument is a format string. It is\n@@ -62,7 +62,7 @@ iterator over the argument. Each time a \"next argument\" specifier is seen, the\n iterator advances. This leads to behavior like this:\n \n ```rust\n-format!(\"{1} {} {0} {}\", 1, 2) // => ~\"2 1 1 2\"\n+format!(\"{1} {} {0} {}\", 1, 2); // => ~\"2 1 1 2\"\n ```\n \n The internal iterator over the argument has not been advanced by the time the\n@@ -89,9 +89,9 @@ identifier '=' expression\n For example, the following `format!` expressions all use named argument:\n \n ```rust\n-format!(\"{argument}\", argument = \"test\")       // => ~\"test\"\n-format!(\"{name} {}\", 1, name = 2)              // => ~\"2 1\"\n-format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3) // => ~\"a 3 ()\"\n+format!(\"{argument}\", argument = \"test\");       // => ~\"test\"\n+format!(\"{name} {}\", 1, name = 2);              // => ~\"2 1\"\n+format!(\"{a:s} {c:d} {b:?}\", a=\"a\", b=(), c=3); // => ~\"a 3 ()\"\n ```\n \n It is illegal to put positional parameters (those without names) after arguments\n@@ -160,7 +160,11 @@ When implementing a format trait for your own time, you will have to implement a\n method of the signature:\n \n ```rust\n+# use std;\n+# struct T;\n+# trait SomeName<T> {\n fn fmt(value: &T, f: &mut std::fmt::Formatter);\n+# }\n ```\n \n Your type will be passed by-reference in `value`, and then the function should\n@@ -218,7 +222,7 @@ fn main() {\n There are a number of related macros in the `format!` family. The ones that are\n currently implemented are:\n \n-```rust\n+```rust,ignore\n format!      // described above\n write!       // first argument is a &mut io::Writer, the destination\n writeln!     // same as write but appends a newline\n@@ -261,9 +265,13 @@ references information on the stack. Under the hood, all of\n the related macros are implemented in terms of this. First\n off, some example usage is:\n \n-```rust\n+```rust,ignore\n use std::fmt;\n \n+# fn lol<T>() -> T { fail!() }\n+# let my_writer: &mut ::std::io::Writer = lol();\n+# let my_fn: fn(&fmt::Arguments) = lol();\n+\n format_args!(fmt::format, \"this returns {}\", \"~str\");\n format_args!(|args| { fmt::write(my_writer, args) }, \"some {}\", \"args\");\n format_args!(my_fn, \"format {}\", \"string\");\n@@ -305,7 +313,7 @@ to reference the string value of the argument which was selected upon. As an\n example:\n \n ```rust\n-format!(\"{0, select, other{#}}\", \"hello\") // => ~\"hello\"\n+format!(\"{0, select, other{#}}\", \"hello\"); // => ~\"hello\"\n ```\n \n This example is the equivalent of `{0:s}` essentially.\n@@ -585,7 +593,9 @@ pub trait Float { fn fmt(&Self, &mut Formatter); }\n ///\n /// ```rust\n /// use std::fmt;\n-/// let w: &mut io::Writer = ...;\n+/// use std::io;\n+///\n+/// let w = &mut io::stdout() as &mut io::Writer;\n /// format_args!(|args| { fmt::write(w, args) }, \"Hello, {}!\", \"world\");\n /// ```\n pub fn write(output: &mut io::Writer, args: &Arguments) {\n@@ -650,8 +660,9 @@ pub unsafe fn write_unsafe(output: &mut io::Writer,\n ///\n /// ```rust\n /// use std::fmt;\n+///\n /// let s = format_args!(fmt::format, \"Hello, {}!\", \"world\");\n-/// assert_eq!(s, \"Hello, world!\");\n+/// assert_eq!(s, ~\"Hello, world!\");\n /// ```\n pub fn format(args: &Arguments) -> ~str {\n     unsafe { format_unsafe(args.fmt, args.args) }"}, {"sha": "bd0b9e08b7c6d5dbfb74b47e3bdedca1a605c8a7", "filename": "src/libstd/io/mod.rs", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fmod.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -26,6 +26,10 @@ Some examples of obvious things you might want to do\n * Read lines from stdin\n \n     ```rust\n+    use std::io::buffered::BufferedReader;\n+    use std::io::stdin;\n+\n+    # let _g = ::std::io::ignore_io_error();\n     let mut stdin = BufferedReader::new(stdin());\n     for line in stdin.lines() {\n         print(line);\n@@ -35,19 +39,29 @@ Some examples of obvious things you might want to do\n * Read a complete file\n \n     ```rust\n+    use std::io::File;\n+\n+    # let _g = ::std::io::ignore_io_error();\n     let contents = File::open(&Path::new(\"message.txt\")).read_to_end();\n     ```\n \n * Write a line to a file\n \n     ```rust\n+    use std::io::File;\n+\n+    # let _g = ::std::io::ignore_io_error();\n     let mut file = File::create(&Path::new(\"message.txt\"));\n     file.write(bytes!(\"hello, file!\\n\"));\n     ```\n \n * Iterate over the lines of a file\n \n     ```rust\n+    use std::io::buffered::BufferedReader;\n+    use std::io::File;\n+\n+    # let _g = ::std::io::ignore_io_error();\n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n     for line in file.lines() {\n@@ -58,6 +72,10 @@ Some examples of obvious things you might want to do\n * Pull the lines of a file into a vector of strings\n \n     ```rust\n+    use std::io::buffered::BufferedReader;\n+    use std::io::File;\n+\n+    # let _g = ::std::io::ignore_io_error();\n     let path = Path::new(\"message.txt\");\n     let mut file = BufferedReader::new(File::open(&path));\n     let lines: ~[~str] = file.lines().collect();\n@@ -67,7 +85,11 @@ Some examples of obvious things you might want to do\n   XXX This needs more improvement: TcpStream constructor taking &str,\n   `write_str` and `write_line` methods.\n \n-    ```rust\n+    ```rust,should_fail\n+    use std::io::net::ip::SocketAddr;\n+    use std::io::net::tcp::TcpStream;\n+\n+    # let _g = ::std::io::ignore_io_error();\n     let addr = from_str::<SocketAddr>(\"127.0.0.1:8080\").unwrap();\n     let mut socket = TcpStream::connect(addr).unwrap();\n     socket.write(bytes!(\"GET / HTTP/1.0\\n\\n\"));"}, {"sha": "00d84e22c25b21942872d63929a368ebb550631d", "filename": "src/libstd/io/signal.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fio%2Fsignal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fio%2Fsignal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fsignal.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -60,11 +60,11 @@ pub enum Signum {\n ///\n /// # Example\n ///\n-/// ```rust\n+/// ```rust,ignore\n /// use std::io::signal::{Listener, Interrupt};\n ///\n /// let mut listener = Listener::new();\n-/// listener.register(signal::Interrupt);\n+/// listener.register(Interrupt);\n ///\n /// do spawn {\n ///     loop {"}, {"sha": "9d4a72509e7fa65cdcd46f7d20b331ecccb4578c", "filename": "src/libstd/io/timer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fio%2Ftimer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fio%2Ftimer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Ftimer.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -17,7 +17,7 @@ and create ports which will receive notifications after a period of time.\n \n # Example\n \n-```rust\n+```rust,ignore\n \n use std::io::Timer;\n "}, {"sha": "5ace24dbbee108ea6273bcee01462180627c9d1e", "filename": "src/libstd/iter.rs", "status": "modified", "additions": 27, "deletions": 19, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiter.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -218,8 +218,8 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let a = [100, 200, 300];\n-    /// let mut it = xs.iter().map(|&x|x).peekable();\n+    /// let xs = [100, 200, 300];\n+    /// let mut it = xs.iter().map(|x| *x).peekable();\n     /// assert_eq!(it.peek().unwrap(), &100);\n     /// assert_eq!(it.next().unwrap(), 100);\n     /// assert_eq!(it.next().unwrap(), 200);\n@@ -338,12 +338,14 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::iter::count;\n+    ///\n     /// let xs = [2u, 3];\n     /// let ys = [0u, 1, 0, 1, 2];\n     /// let mut it = xs.iter().flat_map(|&x| count(0u, 1).take(x));\n     /// // Check that `it` has the same elements as `ys`\n     /// let mut i = 0;\n-    /// for x: uint in it {\n+    /// for x in it {\n     ///     assert_eq!(x, ys[i]);\n     ///     i += 1;\n     /// }\n@@ -366,7 +368,7 @@ pub trait Iterator<A> {\n     ///     let mut sum = 0;\n     ///     for x in it {\n     ///         if x > 5 {\n-    ///             break;\n+    ///             continue;\n     ///         }\n     ///         sum += x;\n     ///     }\n@@ -391,14 +393,16 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    ///let xs = [1u, 4, 2, 3, 8, 9, 6];\n-    ///let sum = xs.iter()\n-    ///            .map(|&x| x)\n-    ///            .inspect(|&x| debug!(\"filtering %u\", x))\n-    ///            .filter(|&x| x % 2 == 0)\n-    ///            .inspect(|&x| debug!(\"%u made it through\", x))\n-    ///            .sum();\n-    ///println(sum.to_str());\n+    /// use std::iter::AdditiveIterator;\n+    ///\n+    /// let xs = [1u, 4, 2, 3, 8, 9, 6];\n+    /// let sum = xs.iter()\n+    ///             .map(|&x| x)\n+    ///             .inspect(|&x| debug!(\"filtering {}\", x))\n+    ///             .filter(|&x| x % 2 == 0)\n+    ///             .inspect(|&x| debug!(\"{} made it through\", x))\n+    ///             .sum();\n+    /// println(sum.to_str());\n     /// ```\n     #[inline]\n     fn inspect<'r>(self, f: 'r |&A|) -> Inspect<'r, A, Self> {\n@@ -554,8 +558,8 @@ pub trait Iterator<A> {\n     ///\n     /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n-    /// assert!(a.iter().all(|&x| *x > 0));\n-    /// assert!(!a.iter().all(|&x| *x > 2));\n+    /// assert!(a.iter().all(|x| *x > 0));\n+    /// assert!(!a.iter().all(|x| *x > 2));\n     /// ```\n     #[inline]\n     fn all(&mut self, f: |A| -> bool) -> bool {\n@@ -571,8 +575,8 @@ pub trait Iterator<A> {\n     /// ```rust\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert!(it.any(|&x| *x == 3));\n-    /// assert!(!it.any(|&x| *x == 3));\n+    /// assert!(it.any(|x| *x == 3));\n+    /// assert!(!it.any(|x| *x == 3));\n     /// ```\n     #[inline]\n     fn any(&mut self, f: |A| -> bool) -> bool {\n@@ -618,7 +622,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let xs = [-3, 0, 1, 5, -10];\n+    /// let xs = [-3i, 0, 1, 5, -10];\n     /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     /// ```\n     #[inline]\n@@ -642,7 +646,7 @@ pub trait Iterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let xs = [-3, 0, 1, 5, -10];\n+    /// let xs = [-3i, 0, 1, 5, -10];\n     /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[inline]\n@@ -811,6 +815,8 @@ pub trait AdditiveIterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::iter::AdditiveIterator;\n+    ///\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter().map(|&x| x);\n     /// assert!(it.sum() == 15);\n@@ -834,7 +840,7 @@ pub trait MultiplicativeIterator<A> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::iter::count;\n+    /// use std::iter::{count, MultiplicativeIterator};\n     ///\n     /// fn factorial(n: uint) -> uint {\n     ///     count(1u, 1).take_while(|&i| i <= n).product()\n@@ -907,6 +913,8 @@ pub trait ClonableIterator {\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::iter::{ClonableIterator, count};\n+    ///\n     /// let a = count(1,1).take(1);\n     /// let mut cy = a.cycle();\n     /// assert_eq!(cy.next(), Some(1));"}, {"sha": "652aa4d8198a26c4202d707d493189859be39244", "filename": "src/libstd/local_data.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flocal_data.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -29,10 +29,10 @@ local_data_key!(key_int: int)\n local_data_key!(key_vector: ~[int])\n \n local_data::set(key_int, 3);\n-local_data::get(key_int, |opt| assert_eq!(opt, Some(&3)));\n+local_data::get(key_int, |opt| assert_eq!(opt.map(|x| *x), Some(3)));\n \n local_data::set(key_vector, ~[4]);\n-local_data::get(key_vector, |opt| assert_eq!(opt, Some(&~[4])));\n+local_data::get(key_vector, |opt| assert_eq!(*opt.unwrap(), ~[4]));\n  ```\n \n */"}, {"sha": "dbe8b3247c0b4c09fed120ad16902cf81b020acd", "filename": "src/libstd/logging.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Flogging.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Flogging.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flogging.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -78,7 +78,7 @@ error,hello=warn     // turn on global error logging and also warn for hello\n \n Each of these macros will expand to code similar to:\n \n-```rust\n+```rust,ignore\n if log_level <= my_module_log_level() {\n     ::std::logging::log(log_level, format!(...));\n }"}, {"sha": "2cb7d527618e6acb65deb9fcde6408feb2ed6fec", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -339,7 +339,8 @@ impl Round for f32 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```rust\n-    /// assert!(x == trunc(x) + fract(x))\n+    /// let x = 1.65f32;\n+    /// assert!(x == x.trunc() + x.fract())\n     /// ```\n     ///\n     #[inline]"}, {"sha": "1f01c26ad76f347ef0e8bd9ff9e51a2892845f72", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -357,7 +357,8 @@ impl Round for f64 {\n     /// The fractional part of the number, satisfying:\n     ///\n     /// ```rust\n-    /// assert!(x == trunc(x) + fract(x))\n+    /// let x = 1.65f64;\n+    /// assert!(x == x.trunc() + x.fract())\n     /// ```\n     ///\n     #[inline]"}, {"sha": "0f81a5faac8115341734337fbe9434ae9352f2b1", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 14, "deletions": 11, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -101,8 +101,7 @@ pub trait Unsigned: Num {}\n /// Times trait\n ///\n /// ```rust\n-/// use num::Times;\n-/// let ten = 10 as uint;\n+/// let ten = 10u;\n /// let mut accum = 0;\n /// ten.times(|| { accum += 1; })\n /// ```\n@@ -176,10 +175,10 @@ pub trait Round {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_approx_eq!(1.3f32.round(), 1.0);\n-    /// assert_approx_eq!((-1.3f32).round(), -1.0);\n-    /// assert_approx_eq!(1.5f32.round(), 1.0);\n-    /// assert_approx_eq!((-1.5f32).round(), -1.0);\n+    /// assert_approx_eq!(1.3f32.trunc(), 1.0);\n+    /// assert_approx_eq!((-1.3f32).trunc(), -1.0);\n+    /// assert_approx_eq!(1.5f32.trunc(), 1.0);\n+    /// assert_approx_eq!((-1.5f32).trunc(), -1.0);\n     /// ```\n     fn trunc(&self) -> Self;\n \n@@ -188,10 +187,10 @@ pub trait Round {\n     /// # Example\n     ///\n     /// ```rust\n-    /// assert_approx_eq!(1.3f32.round(), 0.3);\n-    /// assert_approx_eq!((-1.3f32).round(), -0.3);\n-    /// assert_approx_eq!(1.5f32.round(), 0.5);\n-    /// assert_approx_eq!((-1.5f32).round(), -0.5);\n+    /// assert_approx_eq!(1.3f32.fract(), 0.3);\n+    /// assert_approx_eq!((-1.3f32).fract(), -0.3);\n+    /// assert_approx_eq!(1.5f32.fract(), 0.5);\n+    /// assert_approx_eq!((-1.5f32).fract(), -0.5);\n     /// ```\n     fn fract(&self) -> Self;\n }\n@@ -225,7 +224,9 @@ pub trait Algebraic {\n /// # Example\n ///\n /// ```rust\n-/// let sixteen: float = num::pow(2.0, 4.0);\n+/// use std::num;\n+///\n+/// let sixteen: f64 = num::pow(2.0, 4.0);\n /// assert_eq!(sixteen, 16.0);\n /// ```\n #[inline(always)] pub fn pow<T: Algebraic>(value: T, n: T) -> T { value.pow(&n) }\n@@ -266,6 +267,8 @@ pub trait Trigonometric {\n     /// # Example\n     ///\n     /// ```rust\n+    /// use std::f32;\n+    ///\n     /// let y = 3f32.sqrt();\n     /// let x = 1f32;\n     /// assert_approx_eq!(y.atan2(&x), f32::consts::PI / 3f32);"}, {"sha": "6488595ea4f92ddd4a0183687d2e77b42bc02138", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -54,12 +54,11 @@ actually operates on the path; it is only intended for display.\n \n ```rust\n let mut path = Path::new(\"/tmp/path\");\n-debug!(\"path: {}\", path.display());\n+println!(\"path: {}\", path.display());\n path.set_filename(\"foo\");\n path.push(\"bar\");\n-debug!(\"new path: {}\", path.display());\n-let b = std::os::path_exists(&path);\n-debug!(\"path exists: {}\", b);\n+println!(\"new path: {}\", path.display());\n+println!(\"path exists: {}\", path.exists());\n ```\n \n */"}, {"sha": "36acae9133c28bd9accf6ec99d31f5c24d614410", "filename": "src/libstd/rand/distributions/gamma.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fgamma.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -39,7 +39,7 @@ use num;\n ///\n /// fn main() {\n ///     let gamma = Gamma::new(2.0, 5.0);\n-///     let v = gamma.ind_sample(rand::task_rng());\n+///     let v = gamma.ind_sample(&mut rand::task_rng());\n ///     println!(\"{} is from a Gamma(2, 5) distribution\", v);\n /// }\n /// ```"}, {"sha": "f13f840df402e44c5df660611984c6f2c10ede16", "filename": "src/libstd/rand/distributions/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fmod.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -98,10 +98,10 @@ pub struct Weighted<T> {\n ///     let wc = WeightedChoice::new(~[Weighted { weight: 2, item: 'a' },\n ///                                    Weighted { weight: 4, item: 'b' },\n ///                                    Weighted { weight: 1, item: 'c' }]);\n-///     let rng = rand::task_rng();\n+///     let mut rng = rand::task_rng();\n ///     for _ in range(0, 16) {\n ///          // on average prints 'a' 4 times, 'b' 8 and 'c' twice.\n-///          println!(\"{}\", wc.ind_sample(rng));\n+///          println!(\"{}\", wc.ind_sample(&mut rng));\n ///     }\n /// }\n /// ```"}, {"sha": "8b769c113c9d3468a631fe3c05a35d6d6eea70b9", "filename": "src/libstd/rand/distributions/normal.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Fnormal.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -123,7 +123,7 @@ impl IndependentSample<f64> for Normal {\n /// fn main() {\n ///     // mean 2, standard deviation 3\n ///     let log_normal = LogNormal::new(2.0, 3.0);\n-///     let v = normal.ind_sample(&mut rand::task_rng());\n+///     let v = log_normal.ind_sample(&mut rand::task_rng());\n ///     println!(\"{} is from an ln N(2, 9) distribution\", v)\n /// }\n /// ```"}, {"sha": "fc6cdde162df4b3754d98bc446436522dcbcad95", "filename": "src/libstd/rand/distributions/range.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fdistributions%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fdistributions%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fdistributions%2Frange.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -39,10 +39,10 @@ use rand::distributions::{Sample, IndependentSample};\n ///\n /// fn main() {\n ///     let between = Range::new(10u, 10000u);\n-///     let rng = rand::task_rng();\n+///     let mut rng = rand::task_rng();\n ///     let mut sum = 0;\n ///     for _ in range(0, 1000) {\n-///         sum += between.ind_sample(rng);\n+///         sum += between.ind_sample(&mut rng);\n ///     }\n ///     println!(\"{}\", sum);\n /// }"}, {"sha": "76bb6723a2ee3cdd92ab6bbe00a1b533666dec59", "filename": "src/libstd/rand/mod.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Frand%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fmod.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -64,7 +64,7 @@ use std::rand;\n \n fn main () {\n     let tuple_ptr = rand::random::<~(f64, char)>();\n-    println!(tuple_ptr)\n+    println!(\"{:?}\", tuple_ptr)\n }\n  ```\n */\n@@ -227,7 +227,7 @@ pub trait Rng {\n     ///    let mut rng = rand::task_rng();\n     ///    let n: uint = rng.gen_range(0u, 10);\n     ///    println!(\"{}\", n);\n-    ///    let m: float = rng.gen_range(-40.0, 1.3e5);\n+    ///    let m: f64 = rng.gen_range(-40.0, 1.3e5);\n     ///    println!(\"{}\", m);\n     /// }\n     /// ```\n@@ -292,8 +292,10 @@ pub trait Rng {\n     /// use std::rand::Rng;\n     ///\n     /// fn main() {\n-    ///     println!(\"{:?}\", rand::task_rng().choose_option([1,2,4,8,16,32]));\n-    ///     println!(\"{:?}\", rand::task_rng().choose_option([]));\n+    ///     let choices = [1, 2, 4, 8, 16, 32];\n+    ///     let mut rng = rand::task_rng();\n+    ///     println!(\"{:?}\", rng.choose_option(choices));\n+    ///     println!(\"{:?}\", rng.choose_option(choices.slice_to(0)));\n     /// }\n     /// ```\n     fn choose_option<'a, T>(&mut self, values: &'a [T]) -> Option<&'a T> {\n@@ -388,11 +390,10 @@ pub trait SeedableRng<Seed>: Rng {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::rand;\n-    /// use std::rand::Rng;\n+    /// use std::rand::{Rng, SeedableRng, StdRng};\n     ///\n     /// fn main() {\n-    ///     let mut rng: rand::StdRng = rand::SeedableRng::from_seed(&[1, 2, 3, 4]);\n+    ///     let mut rng: StdRng = SeedableRng::from_seed(&[1, 2, 3, 4]);\n     ///     println!(\"{}\", rng.gen::<f64>());\n     ///     rng.reseed([5, 6, 7, 8]);\n     ///     println!(\"{}\", rng.gen::<f64>());"}, {"sha": "2f5ef932a18e6bd763c5caab0031499a4b2949c5", "filename": "src/libstd/str.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -1458,10 +1458,10 @@ pub trait StrSlice<'a> {\n     /// let v: ~[(uint, uint)] = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, ~[(0,3), (6,9), (12,15)]);\n     ///\n-    /// let v: ~[(uint, uint)] = \"1abcabc2\".split_str(\"abc\").collect();\n+    /// let v: ~[(uint, uint)] = \"1abcabc2\".match_indices(\"abc\").collect();\n     /// assert_eq!(v, ~[(1,4), (4,7)]);\n     ///\n-    /// let v: ~[(uint, uint)] = \"ababa\".split_str(\"aba\").collect();\n+    /// let v: ~[(uint, uint)] = \"ababa\".match_indices(\"aba\").collect();\n     /// assert_eq!(v, ~[(0, 3)]); // only the first `aba`\n     /// ```\n     fn match_indices(&self, sep: &'a str) -> MatchesIndexIterator<'a>;\n@@ -1536,7 +1536,7 @@ pub trait StrSlice<'a> {\n     /// assert!(\" \\t\\n\".is_whitespace());\n     /// assert!(\"\".is_whitespace());\n     ///\n-    /// assert!( !\"abc.is_whitespace());\n+    /// assert!( !\"abc\".is_whitespace());\n     /// ```\n     fn is_whitespace(&self) -> bool;\n \n@@ -1606,7 +1606,7 @@ pub trait StrSlice<'a> {\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n     /// assert_eq!(s.slice(0, 1), \"L\");\n     ///\n-    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\"));\n+    /// assert_eq!(s.slice(1, 9), \"\u00f6we \u8001\");\n     ///\n     /// // these will fail:\n     /// // byte 2 lies within `\u00f6`:\n@@ -1808,6 +1808,8 @@ pub trait StrSlice<'a> {\n     /// `.char_indices`.\n     ///\n     /// ```rust\n+    /// use std::str::CharRange;\n+    ///\n     /// let s = \"\u4e2d\u534eVi\u1ec7t Nam\";\n     /// let mut i = 0u;\n     /// while i < s.len() {\n@@ -1949,11 +1951,11 @@ pub trait StrSlice<'a> {\n     ///\n     /// ```rust\n     /// let s = \"L\u00f6we \u8001\u864e L\u00e9opard\";\n-    /// let (c, s1) = s.shift_slice_char();\n+    /// let (c, s1) = s.slice_shift_char();\n     /// assert_eq!(c, 'L');\n     /// assert_eq!(s1, \"\u00f6we \u8001\u864e L\u00e9opard\");\n     ///\n-    /// let (c, s2) = s1.shift_slice_char();\n+    /// let (c, s2) = s1.slice_shift_char();\n     /// assert_eq!(c, '\u00f6');\n     /// assert_eq!(s2, \"we \u8001\u864e L\u00e9opard\");\n     /// ```"}, {"sha": "97d4c2f6d1b154a4c9b38fd61be47adc8716a85c", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9c06586f2aa12f89c94a27a20f0d0b260da216e/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=d9c06586f2aa12f89c94a27a20f0d0b260da216e", "patch": "@@ -2174,12 +2174,12 @@ pub trait MutableVector<'a, T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// let mut v = [5, 4, 1, 3, 2];\n-    /// v.sort(|a, b| a.cmp(b));\n+    /// let mut v = [5i, 4, 1, 3, 2];\n+    /// v.sort_by(|a, b| a.cmp(b));\n     /// assert_eq!(v, [1, 2, 3, 4, 5]);\n     ///\n     /// // reverse sorting\n-    /// v.sort(|a, b| b.cmp(a));\n+    /// v.sort_by(|a, b| b.cmp(a));\n     /// assert_eq!(v, [5, 4, 3, 2, 1]);\n     /// ```\n     fn sort_by(self, compare: |&T, &T| -> Ordering);\n@@ -2395,8 +2395,6 @@ pub trait MutableTotalOrdVector<T> {\n     /// # Example\n     ///\n     /// ```rust\n-    /// use std::vec;\n-    ///\n     /// let mut v = [-5, 4, 1, -3, 2];\n     ///\n     /// v.sort();"}]}