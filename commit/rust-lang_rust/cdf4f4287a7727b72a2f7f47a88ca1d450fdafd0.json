{"sha": "cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "node_id": "C_kwDOAAsO6NoAKGNkZjRmNDI4N2E3NzI3YjcyYTJmN2Y0N2E4OGNhMWQ0NTBmZGFmZDA", "commit": {"author": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-02-16T19:14:58Z"}, "committer": {"name": "bjorn3", "email": "17426603+bjorn3@users.noreply.github.com", "date": "2023-02-17T18:20:14Z"}, "message": "Remove easy_call", "tree": {"sha": "a7c9f9084884daefe922a0bbd7efd0cef1fafd4f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a7c9f9084884daefe922a0bbd7efd0cef1fafd4f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "html_url": "https://github.com/rust-lang/rust/commit/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/comments", "author": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bjorn3", "id": 17426603, "node_id": "MDQ6VXNlcjE3NDI2NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/17426603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bjorn3", "html_url": "https://github.com/bjorn3", "followers_url": "https://api.github.com/users/bjorn3/followers", "following_url": "https://api.github.com/users/bjorn3/following{/other_user}", "gists_url": "https://api.github.com/users/bjorn3/gists{/gist_id}", "starred_url": "https://api.github.com/users/bjorn3/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bjorn3/subscriptions", "organizations_url": "https://api.github.com/users/bjorn3/orgs", "repos_url": "https://api.github.com/users/bjorn3/repos", "events_url": "https://api.github.com/users/bjorn3/events{/privacy}", "received_events_url": "https://api.github.com/users/bjorn3/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "718574a53e1262c7370106ec606c8fabe0fb6a23", "url": "https://api.github.com/repos/rust-lang/rust/commits/718574a53e1262c7370106ec606c8fabe0fb6a23", "html_url": "https://github.com/rust-lang/rust/commit/718574a53e1262c7370106ec606c8fabe0fb6a23"}], "stats": {"total": 215, "additions": 100, "deletions": 115}, "files": [{"sha": "64bc9ab6aab41288552bb0d03fa5fd06822993be", "filename": "src/abi/mod.rs", "status": "modified", "additions": 1, "deletions": 31, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fabi%2Fmod.rs?ref=cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "patch": "@@ -125,42 +125,12 @@ impl<'tcx> FunctionCx<'_, '_, 'tcx> {\n         }\n         let call_inst = self.bcx.ins().call(func_ref, args);\n         if self.clif_comments.enabled() {\n-            self.add_comment(call_inst, format!(\"easy_call {}\", name));\n+            self.add_comment(call_inst, format!(\"lib_call {}\", name));\n         }\n         let results = self.bcx.inst_results(call_inst);\n         assert!(results.len() <= 2, \"{}\", results.len());\n         results\n     }\n-\n-    pub(crate) fn easy_call(\n-        &mut self,\n-        name: &str,\n-        args: &[CValue<'tcx>],\n-        return_ty: Ty<'tcx>,\n-    ) -> CValue<'tcx> {\n-        let (input_tys, args): (Vec<_>, Vec<_>) = args\n-            .iter()\n-            .map(|arg| {\n-                (AbiParam::new(self.clif_type(arg.layout().ty).unwrap()), arg.load_scalar(self))\n-            })\n-            .unzip();\n-        let return_layout = self.layout_of(return_ty);\n-        let return_tys = if let ty::Tuple(tup) = return_ty.kind() {\n-            tup.iter().map(|ty| AbiParam::new(self.clif_type(ty).unwrap())).collect()\n-        } else {\n-            vec![AbiParam::new(self.clif_type(return_ty).unwrap())]\n-        };\n-        let ret_vals = self.lib_call(name, input_tys, return_tys, &args);\n-        match *ret_vals {\n-            [] => CValue::by_ref(\n-                Pointer::const_addr(self, i64::from(self.pointer_type.bytes())),\n-                return_layout,\n-            ),\n-            [val] => CValue::by_val(val, return_layout),\n-            [val, extra] => CValue::by_val_pair(val, extra, return_layout),\n-            _ => unreachable!(),\n-        }\n-    }\n }\n \n /// Make a [`CPlace`] capable of holding value of the specified type."}, {"sha": "8c23152cda786cf79b994f3d7c5c11f0a9c5c92e", "filename": "src/cast.rs", "status": "modified", "additions": 12, "deletions": 21, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcast.rs?ref=cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "patch": "@@ -64,17 +64,12 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = if from_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            let to_rust_ty = match to_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            return fx\n-                .easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx);\n+            return fx.lib_call(\n+                &name,\n+                vec![AbiParam::new(types::I128)],\n+                vec![AbiParam::new(to_ty)],\n+                &[from],\n+            )[0];\n         }\n \n         // int-like -> float\n@@ -101,16 +96,12 @@ pub(crate) fn clif_int_or_float_cast(\n                 },\n             );\n \n-            let from_rust_ty = match from_ty {\n-                types::F32 => fx.tcx.types.f32,\n-                types::F64 => fx.tcx.types.f64,\n-                _ => unreachable!(),\n-            };\n-\n-            let to_rust_ty = if to_signed { fx.tcx.types.i128 } else { fx.tcx.types.u128 };\n-\n-            fx.easy_call(&name, &[CValue::by_val(from, fx.layout_of(from_rust_ty))], to_rust_ty)\n-                .load_scalar(fx)\n+            fx.lib_call(\n+                &name,\n+                vec![AbiParam::new(from_ty)],\n+                vec![AbiParam::new(types::I128)],\n+                &[from],\n+            )[0]\n         } else if to_ty == types::I8 || to_ty == types::I16 {\n             // FIXME implement fcvt_to_*int_sat.i8/i16\n             let val = if to_signed {"}, {"sha": "af3356e8213d943ad17e7887d20b561ddf1af54b", "filename": "src/codegen_i128.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fcodegen_i128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fcodegen_i128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcodegen_i128.rs?ref=cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "patch": "@@ -53,7 +53,14 @@ pub(crate) fn maybe_codegen<'tcx>(\n                     );\n                     Some(ret_place.to_cvalue(fx))\n                 } else {\n-                    Some(fx.easy_call(\"__multi3\", &[lhs, rhs], val_ty))\n+                    let args: Vec<_> = vec![lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                    let ret_val = fx.lib_call(\n+                        \"__multi3\",\n+                        vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                        vec![AbiParam::new(types::I128)],\n+                        &args,\n+                    )[0];\n+                    Some(CValue::by_val(ret_val, fx.layout_of(val_ty)))\n                 }\n             } else {\n                 let out_ty = fx.tcx.mk_tup([lhs.layout().ty, fx.tcx.types.bool].iter());\n@@ -141,7 +148,14 @@ pub(crate) fn maybe_codegen<'tcx>(\n                 ret_place.to_ptr().store(fx, ret, MemFlags::trusted());\n                 Some(ret_place.to_cvalue(fx))\n             } else {\n-                Some(fx.easy_call(name, &[lhs, rhs], lhs.layout().ty))\n+                let args: Vec<_> = vec![lhs.load_scalar(fx), rhs.load_scalar(fx)];\n+                let ret_val = fx.lib_call(\n+                    name,\n+                    vec![AbiParam::new(types::I128), AbiParam::new(types::I128)],\n+                    vec![AbiParam::new(types::I128)],\n+                    &args,\n+                )[0];\n+                Some(CValue::by_val(ret_val, lhs.layout()))\n             }\n         }\n         BinOp::Lt | BinOp::Le | BinOp::Eq | BinOp::Ge | BinOp::Gt | BinOp::Ne => {"}, {"sha": "b369edee8da1b471b76bd19bbcd3f2b53b66bb93", "filename": "src/intrinsics/mod.rs", "status": "modified", "additions": 59, "deletions": 52, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintrinsics%2Fmod.rs?ref=cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "patch": "@@ -251,41 +251,41 @@ fn codegen_float_intrinsic_call<'tcx>(\n     args: &[mir::Operand<'tcx>],\n     ret: CPlace<'tcx>,\n ) -> bool {\n-    let (name, arg_count, ty) = match intrinsic {\n-        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32),\n-        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64),\n-        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32),\n-        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64),\n-        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32),\n-        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64),\n-        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32), // compiler-builtins\n-        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64), // compiler-builtins\n-        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32),\n-        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64),\n-        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32),\n-        sym::logf64 => (\"log\", 1, fx.tcx.types.f64),\n-        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32),\n-        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64),\n-        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32),\n-        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64),\n-        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32),\n-        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64),\n-        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32),\n-        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64),\n-        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32),\n-        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64),\n-        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32),\n-        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64),\n-        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32),\n-        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64),\n-        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32),\n-        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64),\n-        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32),\n-        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64),\n-        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32),\n-        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64),\n-        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32),\n-        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64),\n+    let (name, arg_count, ty, clif_ty) = match intrinsic {\n+        sym::expf32 => (\"expf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::expf64 => (\"exp\", 1, fx.tcx.types.f64, types::F64),\n+        sym::exp2f32 => (\"exp2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::exp2f64 => (\"exp2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sqrtf32 => (\"sqrtf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sqrtf64 => (\"sqrt\", 1, fx.tcx.types.f64, types::F64),\n+        sym::powif32 => (\"__powisf2\", 2, fx.tcx.types.f32, types::F32), // compiler-builtins\n+        sym::powif64 => (\"__powidf2\", 2, fx.tcx.types.f64, types::F64), // compiler-builtins\n+        sym::powf32 => (\"powf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::powf64 => (\"pow\", 2, fx.tcx.types.f64, types::F64),\n+        sym::logf32 => (\"logf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::logf64 => (\"log\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log2f32 => (\"log2f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log2f64 => (\"log2\", 1, fx.tcx.types.f64, types::F64),\n+        sym::log10f32 => (\"log10f\", 1, fx.tcx.types.f32, types::F32),\n+        sym::log10f64 => (\"log10\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fabsf32 => (\"fabsf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::fabsf64 => (\"fabs\", 1, fx.tcx.types.f64, types::F64),\n+        sym::fmaf32 => (\"fmaf\", 3, fx.tcx.types.f32, types::F32),\n+        sym::fmaf64 => (\"fma\", 3, fx.tcx.types.f64, types::F64),\n+        sym::copysignf32 => (\"copysignf\", 2, fx.tcx.types.f32, types::F32),\n+        sym::copysignf64 => (\"copysign\", 2, fx.tcx.types.f64, types::F64),\n+        sym::floorf32 => (\"floorf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::floorf64 => (\"floor\", 1, fx.tcx.types.f64, types::F64),\n+        sym::ceilf32 => (\"ceilf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::ceilf64 => (\"ceil\", 1, fx.tcx.types.f64, types::F64),\n+        sym::truncf32 => (\"truncf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::truncf64 => (\"trunc\", 1, fx.tcx.types.f64, types::F64),\n+        sym::roundf32 => (\"roundf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::roundf64 => (\"round\", 1, fx.tcx.types.f64, types::F64),\n+        sym::sinf32 => (\"sinf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::sinf64 => (\"sin\", 1, fx.tcx.types.f64, types::F64),\n+        sym::cosf32 => (\"cosf\", 1, fx.tcx.types.f32, types::F32),\n+        sym::cosf64 => (\"cos\", 1, fx.tcx.types.f64, types::F64),\n         _ => return false,\n     };\n \n@@ -296,15 +296,19 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let (a, b, c);\n     let args = match args {\n         [x] => {\n-            a = [codegen_operand(fx, x)];\n+            a = [codegen_operand(fx, x).load_scalar(fx)];\n             &a as &[_]\n         }\n         [x, y] => {\n-            b = [codegen_operand(fx, x), codegen_operand(fx, y)];\n+            b = [codegen_operand(fx, x).load_scalar(fx), codegen_operand(fx, y).load_scalar(fx)];\n             &b\n         }\n         [x, y, z] => {\n-            c = [codegen_operand(fx, x), codegen_operand(fx, y), codegen_operand(fx, z)];\n+            c = [\n+                codegen_operand(fx, x).load_scalar(fx),\n+                codegen_operand(fx, y).load_scalar(fx),\n+                codegen_operand(fx, z).load_scalar(fx),\n+            ];\n             &c\n         }\n         _ => unreachable!(),\n@@ -313,15 +317,10 @@ fn codegen_float_intrinsic_call<'tcx>(\n     let layout = fx.layout_of(ty);\n     let res = match intrinsic {\n         sym::fmaf32 | sym::fmaf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            let c = args[2].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fma(a, b, c), layout)\n+            CValue::by_val(fx.bcx.ins().fma(args[0], args[1], args[2]), layout)\n         }\n         sym::copysignf32 | sym::copysignf64 => {\n-            let a = args[0].load_scalar(fx);\n-            let b = args[1].load_scalar(fx);\n-            CValue::by_val(fx.bcx.ins().fcopysign(a, b), layout)\n+            CValue::by_val(fx.bcx.ins().fcopysign(args[0], args[1]), layout)\n         }\n         sym::fabsf32\n         | sym::fabsf64\n@@ -331,21 +330,29 @@ fn codegen_float_intrinsic_call<'tcx>(\n         | sym::ceilf64\n         | sym::truncf32\n         | sym::truncf64 => {\n-            let a = args[0].load_scalar(fx);\n-\n             let val = match intrinsic {\n-                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(a),\n-                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(a),\n-                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(a),\n-                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(a),\n+                sym::fabsf32 | sym::fabsf64 => fx.bcx.ins().fabs(args[0]),\n+                sym::floorf32 | sym::floorf64 => fx.bcx.ins().floor(args[0]),\n+                sym::ceilf32 | sym::ceilf64 => fx.bcx.ins().ceil(args[0]),\n+                sym::truncf32 | sym::truncf64 => fx.bcx.ins().trunc(args[0]),\n                 _ => unreachable!(),\n             };\n \n             CValue::by_val(val, layout)\n         }\n+\n         // These intrinsics aren't supported natively by Cranelift.\n         // Lower them to a libcall.\n-        _ => fx.easy_call(name, &args, ty),\n+        sym::powif32 | sym::powif64 => {\n+            let input_tys: Vec<_> = vec![AbiParam::new(clif_ty), AbiParam::new(types::I32)];\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n+        _ => {\n+            let input_tys: Vec<_> = args.iter().map(|_| AbiParam::new(clif_ty)).collect();\n+            let ret_val = fx.lib_call(name, input_tys, vec![AbiParam::new(clif_ty)], &args)[0];\n+            CValue::by_val(ret_val, fx.layout_of(ty))\n+        }\n     };\n \n     ret.write_cvalue(fx, res);"}, {"sha": "51e79f85e02571041c8f1200bb5bac1801ef88c1", "filename": "src/num.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fnum.rs?ref=cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "patch": "@@ -347,12 +347,20 @@ pub(crate) fn codegen_float_binop<'tcx>(\n         BinOp::Mul => b.fmul(lhs, rhs),\n         BinOp::Div => b.fdiv(lhs, rhs),\n         BinOp::Rem => {\n-            let name = match in_lhs.layout().ty.kind() {\n-                ty::Float(FloatTy::F32) => \"fmodf\",\n-                ty::Float(FloatTy::F64) => \"fmod\",\n+            let (name, ty) = match in_lhs.layout().ty.kind() {\n+                ty::Float(FloatTy::F32) => (\"fmodf\", types::F32),\n+                ty::Float(FloatTy::F64) => (\"fmod\", types::F64),\n                 _ => bug!(),\n             };\n-            return fx.easy_call(name, &[in_lhs, in_rhs], in_lhs.layout().ty);\n+\n+            let ret_val = fx.lib_call(\n+                name,\n+                vec![AbiParam::new(ty), AbiParam::new(ty)],\n+                vec![AbiParam::new(ty)],\n+                &[lhs, rhs],\n+            )[0];\n+\n+            return CValue::by_val(ret_val, in_lhs.layout());\n         }\n         BinOp::Eq | BinOp::Lt | BinOp::Le | BinOp::Ne | BinOp::Ge | BinOp::Gt => {\n             let fltcc = match bin_op {"}, {"sha": "b60e56720ed5ed7c1f9cbe989c98dc9e10a608ce", "filename": "src/pointer.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0/src%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fpointer.rs?ref=cdf4f4287a7727b72a2f7f47a88ca1d450fdafd0", "patch": "@@ -30,11 +30,6 @@ impl Pointer {\n         Pointer { base: PointerBase::Stack(stack_slot), offset: Offset32::new(0) }\n     }\n \n-    pub(crate) fn const_addr(fx: &mut FunctionCx<'_, '_, '_>, addr: i64) -> Self {\n-        let addr = fx.bcx.ins().iconst(fx.pointer_type, addr);\n-        Pointer { base: PointerBase::Addr(addr), offset: Offset32::new(0) }\n-    }\n-\n     pub(crate) fn dangling(align: Align) -> Self {\n         Pointer { base: PointerBase::Dangling(align), offset: Offset32::new(0) }\n     }"}]}