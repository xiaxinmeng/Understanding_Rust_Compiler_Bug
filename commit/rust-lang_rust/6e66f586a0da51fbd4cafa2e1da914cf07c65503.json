{"sha": "6e66f586a0da51fbd4cafa2e1da914cf07c65503", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlNjZmNTg2YTBkYTUxZmJkNGNhZmEyZTFkYTkxNGNmMDdjNjU1MDM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-16T21:45:28Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-02-29T08:27:25Z"}, "message": "fmt", "tree": {"sha": "4e65c97a4ca68a93666a564a9b6b0f8c520a34f5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e65c97a4ca68a93666a564a9b6b0f8c520a34f5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e66f586a0da51fbd4cafa2e1da914cf07c65503", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e66f586a0da51fbd4cafa2e1da914cf07c65503", "html_url": "https://github.com/rust-lang/rust/commit/6e66f586a0da51fbd4cafa2e1da914cf07c65503", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e66f586a0da51fbd4cafa2e1da914cf07c65503/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b133d6776fde22e944eb7f266ee165ffcf7cdb09", "url": "https://api.github.com/repos/rust-lang/rust/commits/b133d6776fde22e944eb7f266ee165ffcf7cdb09", "html_url": "https://github.com/rust-lang/rust/commit/b133d6776fde22e944eb7f266ee165ffcf7cdb09"}], "stats": {"total": 57, "additions": 28, "deletions": 29}, "files": [{"sha": "7c5a17d43b6daef3b4801a5a5b75bfac5c28c7a8", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6e66f586a0da51fbd4cafa2e1da914cf07c65503/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e66f586a0da51fbd4cafa2e1da914cf07c65503/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=6e66f586a0da51fbd4cafa2e1da914cf07c65503", "patch": "@@ -524,24 +524,28 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         // These are intrinsics that compile to panics so that we can get a message\n         // which mentions the offending type, even from a const context.\n         #[derive(Debug, PartialEq)]\n-        enum PanicIntrinsic { IfUninhabited, IfZeroInvalid, IfAnyInvalid };\n+        enum PanicIntrinsic {\n+            IfUninhabited,\n+            IfZeroInvalid,\n+            IfAnyInvalid,\n+        };\n         let panic_intrinsic = intrinsic.and_then(|i| match i {\n             // FIXME: Move to symbols instead of strings.\n             \"panic_if_uninhabited\" => Some(PanicIntrinsic::IfUninhabited),\n             \"panic_if_zero_invalid\" => Some(PanicIntrinsic::IfZeroInvalid),\n             \"panic_if_any_invalid\" => Some(PanicIntrinsic::IfAnyInvalid),\n-            _ => None\n+            _ => None,\n         });\n         if let Some(intrinsic) = panic_intrinsic {\n             use PanicIntrinsic::*;\n             let ty = instance.unwrap().substs.type_at(0);\n             let layout = bx.layout_of(ty);\n             let do_panic = match intrinsic {\n                 IfUninhabited => layout.abi.is_uninhabited(),\n-                IfZeroInvalid => // We unwrap as the error type is `!`.\n-                    !layout.might_permit_raw_init(&bx, /*zero:*/ true).unwrap(),\n-                IfAnyInvalid => // We unwrap as the error type is `!`.\n-                    !layout.might_permit_raw_init(&bx, /*zero:*/ false).unwrap(),\n+                // We unwrap as the error type is `!`.\n+                IfZeroInvalid => !layout.might_permit_raw_init(&bx, /*zero:*/ true).unwrap(),\n+                // We unwrap as the error type is `!`.\n+                IfAnyInvalid => !layout.might_permit_raw_init(&bx, /*zero:*/ false).unwrap(),\n             };\n             if do_panic {\n                 let msg_str = if layout.abi.is_uninhabited() {"}, {"sha": "c043d87f69f9d66c6de39af2f85c0b422eb791b2", "filename": "src/librustc_target/abi/mod.rs", "status": "modified", "additions": 15, "deletions": 19, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/6e66f586a0da51fbd4cafa2e1da914cf07c65503/src%2Flibrustc_target%2Fabi%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e66f586a0da51fbd4cafa2e1da914cf07c65503/src%2Flibrustc_target%2Fabi%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fabi%2Fmod.rs?ref=6e66f586a0da51fbd4cafa2e1da914cf07c65503", "patch": "@@ -1047,22 +1047,17 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n     /// FIXME: Once we removed all the conservatism, we could alternatively\n     /// create an all-0/all-undef constant and run the vonst value validator to see if\n     /// this is a valid value for the given type.\n-    pub fn might_permit_raw_init<C, E>(\n-        self,\n-        cx: &C,\n-        zero: bool,\n-    ) -> Result<bool, E>\n+    pub fn might_permit_raw_init<C, E>(self, cx: &C, zero: bool) -> Result<bool, E>\n     where\n         Self: Copy,\n         Ty: TyLayoutMethods<'a, C>,\n-        C: LayoutOf<Ty = Ty, TyLayout: MaybeResult<Self, Error = E>> + HasDataLayout\n+        C: LayoutOf<Ty = Ty, TyLayout: MaybeResult<Self, Error = E>> + HasDataLayout,\n     {\n         let scalar_allows_raw_init = move |s: &Scalar| -> bool {\n             if zero {\n                 let range = &s.valid_range;\n                 // The range must contain 0.\n-                range.contains(&0) ||\n-                (*range.start() > *range.end()) // wrap-around allows 0\n+                range.contains(&0) || (*range.start() > *range.end()) // wrap-around allows 0\n             } else {\n                 // The range must include all values. `valid_range_exclusive` handles\n                 // the wrap-around using target arithmetic; with wrap-around then the full\n@@ -1076,13 +1071,11 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n         let res = match &self.abi {\n             Abi::Uninhabited => false, // definitely UB\n             Abi::Scalar(s) => scalar_allows_raw_init(s),\n-            Abi::ScalarPair(s1, s2) =>\n-                scalar_allows_raw_init(s1) && scalar_allows_raw_init(s2),\n-            Abi::Vector { element: s, count } =>\n-                *count == 0 || scalar_allows_raw_init(s),\n+            Abi::ScalarPair(s1, s2) => scalar_allows_raw_init(s1) && scalar_allows_raw_init(s2),\n+            Abi::Vector { element: s, count } => *count == 0 || scalar_allows_raw_init(s),\n             Abi::Aggregate { .. } => {\n                 match self.variants {\n-                    Variants::Multiple { .. } =>\n+                    Variants::Multiple { .. } => {\n                         if zero {\n                             // FIXME(#66151):\n                             // could we identify the variant with discriminant 0, check that?\n@@ -1091,17 +1084,20 @@ impl<'a, Ty> TyLayout<'a, Ty> {\n                             // FIXME(#66151): This needs to have some sort of discriminant,\n                             // which cannot be undef. But for now we are conservative.\n                             true\n-                        },\n+                        }\n+                    }\n                     Variants::Single { .. } => {\n                         // For aggregates, recurse.\n                         match self.fields {\n                             FieldPlacement::Union(..) => true, // An all-0 unit is fine.\n                             FieldPlacement::Array { .. } =>\n-                                // FIXME(#66151): The widely use smallvec 0.6 creates uninit arrays\n-                                // with any element type, so let us not (yet) complain about that.\n-                                /* count == 0 ||\n-                                self.field(cx, 0).to_result()?.might_permit_raw_init(cx, zero)? */\n-                                true,\n+                            // FIXME(#66151): The widely use smallvec 0.6 creates uninit arrays\n+                            // with any element type, so let us not (yet) complain about that.\n+                            /* count == 0 ||\n+                            self.field(cx, 0).to_result()?.might_permit_raw_init(cx, zero)? */\n+                            {\n+                                true\n+                            }\n                             FieldPlacement::Arbitrary { .. } => {\n                                 // FIXME(#66151) cargo depends on sized-chunks 0.3.0 which\n                                 // has some illegal zero-initialization, so let us not (yet)"}, {"sha": "d2a358c3e09b868d1c6f1789424f930f8f249a61", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6e66f586a0da51fbd4cafa2e1da914cf07c65503/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e66f586a0da51fbd4cafa2e1da914cf07c65503/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=6e66f586a0da51fbd4cafa2e1da914cf07c65503", "patch": "@@ -147,10 +147,9 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n             ),\n             \"rustc_peek\" => (1, vec![param(0)], param(0)),\n             \"caller_location\" => (0, vec![], tcx.caller_location_ty()),\n-            \"panic_if_uninhabited\" |\n-            \"panic_if_zero_invalid\" |\n-            \"panic_if_any_invalid\" =>\n-                (1, Vec::new(), tcx.mk_unit()),\n+            \"panic_if_uninhabited\" | \"panic_if_zero_invalid\" | \"panic_if_any_invalid\" => {\n+                (1, Vec::new(), tcx.mk_unit())\n+            }\n             \"init\" => (1, Vec::new(), param(0)),\n             \"uninit\" => (1, Vec::new(), param(0)),\n             \"forget\" => (1, vec![param(0)], tcx.mk_unit()),"}]}