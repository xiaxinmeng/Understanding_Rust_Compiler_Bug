{"sha": "76cbf0053f8812e210603689b4173c210976fe6c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2Y2JmMDA1M2Y4ODEyZTIxMDYwMzY4OWI0MTczYzIxMDk3NmZlNmM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-15T00:39:22Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-04-15T00:39:22Z"}, "message": "Auto merge of #71151 - Dylan-DPC:rollup-6rt4h7b, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #70657 (Allow `try`-blocks in places where an open delim is expected)\n - #70947 (tighten CTFE safety net for accesses to globals)\n - #70949 (simplify `vec!` macro)\n - #71002 (fix target & runtool args order)\n - #71082 (ptr: introduce len() method on raw slices)\n - #71128 (Remove unused single_step flag)\n - #71133 (Tighten time complexity on the doc of sort_by_key)\n - #71135 (Update books)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "3b94ae78b3728cbbc259eefa63c69160c1f24ea6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b94ae78b3728cbbc259eefa63c69160c1f24ea6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76cbf0053f8812e210603689b4173c210976fe6c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76cbf0053f8812e210603689b4173c210976fe6c", "html_url": "https://github.com/rust-lang/rust/commit/76cbf0053f8812e210603689b4173c210976fe6c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76cbf0053f8812e210603689b4173c210976fe6c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d12f0304839e599d498b3faaa652336b273bdcc8", "url": "https://api.github.com/repos/rust-lang/rust/commits/d12f0304839e599d498b3faaa652336b273bdcc8", "html_url": "https://github.com/rust-lang/rust/commit/d12f0304839e599d498b3faaa652336b273bdcc8"}, {"sha": "db3addb30b3b7b8b12e04ad04d9e3f362db13438", "url": "https://api.github.com/repos/rust-lang/rust/commits/db3addb30b3b7b8b12e04ad04d9e3f362db13438", "html_url": "https://github.com/rust-lang/rust/commit/db3addb30b3b7b8b12e04ad04d9e3f362db13438"}], "stats": {"total": 272, "additions": 222, "deletions": 50}, "files": [{"sha": "f5db319e0b19c22964398d56bc63103d669e1bba", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1 +1 @@\n-Subproject commit c8841f2841a2d26124319ddadd1b6a245f9a1856\n+Subproject commit f5db319e0b19c22964398d56bc63103d669e1bba"}, {"sha": "8204c1d123472cd17f0c1c5c77300ae802eb0271", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1 +1 @@\n-Subproject commit 37f9e6848411188a1062ead1bd8ebe4b8aa16899\n+Subproject commit 8204c1d123472cd17f0c1c5c77300ae802eb0271"}, {"sha": "668fb07b6160b9c468f598e839c1e044db65de30", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1 +1 @@\n-Subproject commit d22a9c487c78095afc4584f1d9b4ec43529d713c\n+Subproject commit 668fb07b6160b9c468f598e839c1e044db65de30"}, {"sha": "3ce94caed4cf967106c51ae86be5e098f7875f11", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1 +1 @@\n-Subproject commit 89dd146154474559536d5d4049a03831c501deea\n+Subproject commit 3ce94caed4cf967106c51ae86be5e098f7875f11"}, {"sha": "c106d1683c3a2b0960f0f0fb01728cbb19807332", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1 +1 @@\n-Subproject commit a6638463efc7631bc0e8dc67ccd256d4e1b61f1a\n+Subproject commit c106d1683c3a2b0960f0f0fb01728cbb19807332"}, {"sha": "e163a166b498fceab4aa669f23d3069f76195629", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -42,10 +42,9 @@ macro_rules! vec {\n     ($elem:expr; $n:expr) => (\n         $crate::vec::from_elem($elem, $n)\n     );\n-    ($($x:expr),*) => (\n-        <[_]>::into_vec(box [$($x),*])\n+    ($($x:expr),+ $(,)?) => (\n+        <[_]>::into_vec(box [$($x),+])\n     );\n-    ($($x:expr,)*) => ($crate::vec![$($x),*])\n }\n \n // HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is"}, {"sha": "4171185c9701a72c56a38ec27ac009f88f25f1b3", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -254,7 +254,7 @@ impl<T> [T] {\n \n     /// Sorts the slice with a key extraction function.\n     ///\n-    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log(m n))`\n+    /// This sort is stable (i.e., does not reorder equal elements) and `O(m n log n)`\n     /// worst-case, where the key function is `O(m)`.\n     ///\n     /// For expensive key functions (e.g. functions that are not simple property accesses or"}, {"sha": "729e0b897c0980f7ed4b7e6efdfcbf1ffe359056", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -706,6 +706,34 @@ impl<T: ?Sized> *const T {\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[lang = \"const_slice_ptr\"]\n+impl<T> *const [T] {\n+    /// Returns the length of a raw slice.\n+    ///\n+    /// The returned value is the number of **elements**, not the number of bytes.\n+    ///\n+    /// This function is safe, even when the raw slice cannot be cast to a slice\n+    /// reference because the pointer is null or unaligned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_len)]\n+    ///\n+    /// use std::ptr;\n+    ///\n+    /// let slice: *const [i8] = ptr::slice_from_raw_parts(ptr::null(), 3);\n+    /// assert_eq!(slice.len(), 3);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n+    #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n+    pub const fn len(self) -> usize {\n+        unsafe { Repr { rust: self }.raw }.len\n+    }\n+}\n+\n // Equality for pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> PartialEq for *const T {"}, {"sha": "3b7e83bf37fa67bcbd8ae70a9300b00a082c7b17", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -894,6 +894,34 @@ impl<T: ?Sized> *mut T {\n     }\n }\n \n+#[cfg(not(bootstrap))]\n+#[lang = \"mut_slice_ptr\"]\n+impl<T> *mut [T] {\n+    /// Returns the length of a raw slice.\n+    ///\n+    /// The returned value is the number of **elements**, not the number of bytes.\n+    ///\n+    /// This function is safe, even when the raw slice cannot be cast to a slice\n+    /// reference because the pointer is null or unaligned.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```rust\n+    /// #![feature(slice_ptr_len)]\n+    ///\n+    /// use std::ptr;\n+    ///\n+    /// let slice: *mut [i8] = ptr::slice_from_raw_parts_mut(ptr::null_mut(), 3);\n+    /// assert_eq!(slice.len(), 3);\n+    /// ```\n+    #[inline]\n+    #[unstable(feature = \"slice_ptr_len\", issue = \"71146\")]\n+    #[rustc_const_unstable(feature = \"const_slice_ptr_len\", issue = \"71146\")]\n+    pub const fn len(self) -> usize {\n+        unsafe { Repr { rust_mut: self }.raw }.len\n+    }\n+}\n+\n // Equality for pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> PartialEq for *mut T {"}, {"sha": "4d333fbf8ed971d8561d1f8acff5def0cb4656c2", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1697,7 +1697,7 @@ impl<T> [T] {\n     /// elements.\n     ///\n     /// This sort is unstable (i.e., may reorder equal elements), in-place\n-    /// (i.e., does not allocate), and `O(m n log(m n))` worst-case, where the key function is\n+    /// (i.e., does not allocate), and `O(m n log n)` worst-case, where the key function is\n     /// `O(m)`.\n     ///\n     /// # Current implementation"}, {"sha": "7473c890c5ab98b7dd6c7c2b0359680714c76711", "filename": "src/librustc_expand/expand.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_expand%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_expand%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_expand%2Fexpand.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -507,9 +507,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                 expanded_fragments.push(Vec::new());\n             }\n             expanded_fragments[depth - 1].push((expn_id, expanded_fragment));\n-            if !self.cx.ecfg.single_step {\n-                invocations.extend(new_invocations.into_iter().rev());\n-            }\n+            invocations.extend(new_invocations.into_iter().rev());\n         }\n \n         self.cx.current_expansion = orig_expansion_data;\n@@ -1819,7 +1817,6 @@ pub struct ExpansionConfig<'feat> {\n     pub recursion_limit: usize,\n     pub trace_mac: bool,\n     pub should_test: bool, // If false, strip `#[test]` nodes\n-    pub single_step: bool,\n     pub keep_macs: bool,\n }\n \n@@ -1831,7 +1828,6 @@ impl<'feat> ExpansionConfig<'feat> {\n             recursion_limit: 1024,\n             trace_mac: false,\n             should_test: false,\n-            single_step: false,\n             keep_macs: false,\n         }\n     }"}, {"sha": "53f72804a848d551b5227d4bfe49f70bdb7bf653", "filename": "src/librustc_hir/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_hir%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_hir%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Flang_items.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -135,6 +135,8 @@ language_item_table! {\n     SliceU8AllocImplItem,        \"slice_u8_alloc\",     slice_u8_alloc_impl,     Target::Impl;\n     ConstPtrImplItem,            \"const_ptr\",          const_ptr_impl,          Target::Impl;\n     MutPtrImplItem,              \"mut_ptr\",            mut_ptr_impl,            Target::Impl;\n+    ConstSlicePtrImplItem,       \"const_slice_ptr\",    const_slice_ptr_impl,    Target::Impl;\n+    MutSlicePtrImplItem,         \"mut_slice_ptr\",      mut_slice_ptr_impl,      Target::Impl;\n     I8ImplItem,                  \"i8\",                 i8_impl,                 Target::Impl;\n     I16ImplItem,                 \"i16\",                i16_impl,                Target::Impl;\n     I32ImplItem,                 \"i32\",                i32_impl,                Target::Impl;"}, {"sha": "3e1e9cc70aa11216e1013868885363e24a112c6b", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -384,7 +384,7 @@ trait UnusedDelimLint {\n     fn is_expr_delims_necessary(inner: &ast::Expr, followed_by_block: bool) -> bool {\n         followed_by_block\n             && match inner.kind {\n-                ast::ExprKind::Ret(_) | ast::ExprKind::Break(..) => true,\n+                ExprKind::Ret(_) | ExprKind::Break(..) => true,\n                 _ => parser::contains_exterior_struct_lit(&inner),\n             }\n     }"}, {"sha": "a1ab9a1c342c17a8ebc645a3250cedaaa7c08af9", "filename": "src/librustc_mir/const_eval/machine.rs", "status": "modified", "additions": 23, "deletions": 8, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Fmachine.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -353,15 +353,30 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter {\n         static_def_id: Option<DefId>,\n         is_write: bool,\n     ) -> InterpResult<'tcx> {\n-        if is_write && allocation.mutability == Mutability::Not {\n-            Err(err_ub!(WriteToReadOnly(alloc_id)).into())\n-        } else if is_write {\n-            Err(ConstEvalErrKind::ModifiedGlobal.into())\n-        } else if memory_extra.can_access_statics || static_def_id.is_none() {\n-            // `static_def_id.is_none()` indicates this is not a static, but a const or so.\n-            Ok(())\n+        if is_write {\n+            // Write access. These are never allowed, but we give a targeted error message.\n+            if allocation.mutability == Mutability::Not {\n+                Err(err_ub!(WriteToReadOnly(alloc_id)).into())\n+            } else {\n+                Err(ConstEvalErrKind::ModifiedGlobal.into())\n+            }\n         } else {\n-            Err(ConstEvalErrKind::ConstAccessesStatic.into())\n+            // Read access. These are usually allowed, with some exceptions.\n+            if memory_extra.can_access_statics {\n+                // Machine configuration allows us read from anything (e.g., `static` initializer).\n+                Ok(())\n+            } else if static_def_id.is_some() {\n+                // Machine configuration does not allow us to read statics\n+                // (e.g., `const` initializer).\n+                Err(ConstEvalErrKind::ConstAccessesStatic.into())\n+            } else {\n+                // Immutable global, this read is fine.\n+                // But make sure we never accept a read from something mutable, that would be\n+                // unsound. The reason is that as the content of this allocation may be different\n+                // now and at run-time, so if we permit reading now we might return the wrong value.\n+                assert_eq!(allocation.mutability, Mutability::Not);\n+                Ok(())\n+            }\n         }\n     }\n }"}, {"sha": "4e3c5fa63de2cbb2f715585290c59576714e877c", "filename": "src/librustc_parse/parser/expr.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_parse%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fexpr.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1846,11 +1846,9 @@ impl<'a> Parser<'a> {\n     }\n \n     fn is_try_block(&self) -> bool {\n-        self.token.is_keyword(kw::Try) &&\n-        self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace)) &&\n-        self.token.uninterpolated_span().rust_2018() &&\n-        // Prevent `while try {} {}`, `if try {} {} else {}`, etc.\n-        !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n+        self.token.is_keyword(kw::Try)\n+            && self.look_ahead(1, |t| *t == token::OpenDelim(token::Brace))\n+            && self.token.uninterpolated_span().rust_2018()\n     }\n \n     /// Parses an `async move? {...}` expression."}, {"sha": "9b1c8b9a9c83e62cbd3b9dbceb7596660305dd47", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -649,11 +649,16 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 }\n             }\n             ty::RawPtr(ty::TypeAndMut { ty: _, mutbl }) => {\n-                let lang_def_id = match mutbl {\n-                    hir::Mutability::Not => lang_items.const_ptr_impl(),\n-                    hir::Mutability::Mut => lang_items.mut_ptr_impl(),\n+                let (lang_def_id1, lang_def_id2) = match mutbl {\n+                    hir::Mutability::Not => {\n+                        (lang_items.const_ptr_impl(), lang_items.const_slice_ptr_impl())\n+                    }\n+                    hir::Mutability::Mut => {\n+                        (lang_items.mut_ptr_impl(), lang_items.mut_slice_ptr_impl())\n+                    }\n                 };\n-                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+                self.assemble_inherent_impl_for_primitive(lang_def_id1);\n+                self.assemble_inherent_impl_for_primitive(lang_def_id2);\n             }\n             ty::Int(i) => {\n                 let lang_def_id = match i {"}, {"sha": "2e84173477074de71f8ad5718d53e622a782a961", "filename": "src/librustc_typeck/coherence/inherent_impls.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Finherent_impls.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -112,6 +112,30 @@ impl ItemLikeVisitor<'v> for InherentCollect<'tcx> {\n                     item.span,\n                 );\n             }\n+            ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Not })\n+                if matches!(inner.kind, ty::Slice(_)) =>\n+            {\n+                self.check_primitive_impl(\n+                    def_id,\n+                    lang_items.const_slice_ptr_impl(),\n+                    None,\n+                    \"const_slice_ptr\",\n+                    \"*const [T]\",\n+                    item.span,\n+                );\n+            }\n+            ty::RawPtr(ty::TypeAndMut { ty: inner, mutbl: hir::Mutability::Mut })\n+                if matches!(inner.kind, ty::Slice(_)) =>\n+            {\n+                self.check_primitive_impl(\n+                    def_id,\n+                    lang_items.mut_slice_ptr_impl(),\n+                    None,\n+                    \"mut_slice_ptr\",\n+                    \"*mut [T]\",\n+                    item.span,\n+                );\n+            }\n             ty::RawPtr(ty::TypeAndMut { ty: _, mutbl: hir::Mutability::Not }) => {\n                 self.check_primitive_impl(\n                     def_id,"}, {"sha": "c80967a4b33f2b46ef628a0431f605e036469927", "filename": "src/librustdoc/passes/collect_trait_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_trait_impls.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -62,6 +62,8 @@ pub fn collect_trait_impls(krate: Crate, cx: &DocContext<'_>) -> Crate {\n         lang_items.slice_u8_alloc_impl(),\n         lang_items.const_ptr_impl(),\n         lang_items.mut_ptr_impl(),\n+        lang_items.const_slice_ptr_impl(),\n+        lang_items.mut_slice_ptr_impl(),\n     ];\n \n     for def_id in primitive_impls.iter().filter_map(|&def_id| def_id) {"}, {"sha": "fbbe172afb81f2abded48c31bf56b96899641f6a", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -263,7 +263,12 @@ fn run_test(\n     if no_run && !compile_fail {\n         compiler.arg(\"--emit=metadata\");\n     }\n-    compiler.arg(\"--target\").arg(target.to_string());\n+    compiler.arg(\"--target\").arg(match target {\n+        TargetTriple::TargetTriple(s) => s,\n+        TargetTriple::TargetPath(path) => {\n+            path.to_str().expect(\"target path must be valid unicode\").to_string()\n+        }\n+    });\n \n     compiler.arg(\"-\");\n     compiler.stdin(Stdio::piped());\n@@ -312,8 +317,8 @@ fn run_test(\n \n     if let Some(tool) = runtool {\n         cmd = Command::new(tool);\n-        cmd.arg(output_file);\n         cmd.args(runtool_args);\n+        cmd.arg(output_file);\n     } else {\n         cmd = Command::new(output_file);\n     }"}, {"sha": "cd0b967e79d07bcca6c1a8aca9fed4506aba433d", "filename": "src/test/ui/try-block/try-block-in-match.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-match.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1,7 +1,11 @@\n+// run-pass\n // compile-flags: --edition 2018\n \n #![feature(try_blocks)]\n \n fn main() {\n-    match try { false } { _ => {} } //~ ERROR expected expression, found reserved keyword `try`\n+    match try { } {\n+        Err(()) => (),\n+        Ok(()) => (),\n+    }\n }"}, {"sha": "936e0fe19bafeec19f05569240f644cbd9bc4fd9", "filename": "src/test/ui/try-block/try-block-in-match.stderr", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d12f0304839e599d498b3faaa652336b273bdcc8/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-match.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d12f0304839e599d498b3faaa652336b273bdcc8/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-match.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-match.stderr?ref=d12f0304839e599d498b3faaa652336b273bdcc8", "patch": "@@ -1,10 +0,0 @@\n-error: expected expression, found reserved keyword `try`\n-  --> $DIR/try-block-in-match.rs:6:11\n-   |\n-LL |     match try { false } { _ => {} }\n-   |     ----- ^^^ expected expression\n-   |     |\n-   |     while parsing this match expression\n-\n-error: aborting due to previous error\n-"}, {"sha": "33d27236519290134c5fdf4fb8dd9d0e6cacda6e", "filename": "src/test/ui/try-block/try-block-in-while.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -3,5 +3,6 @@\n #![feature(try_blocks)]\n \n fn main() {\n-    while try { false } {} //~ ERROR expected expression, found reserved keyword `try`\n+    while try { false } {}\n+    //~^ ERROR the trait bound `bool: std::ops::Try` is not satisfied\n }"}, {"sha": "ac41ddfd8c042c13b3663b22525126839c133b82", "filename": "src/test/ui/try-block/try-block-in-while.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-in-while.stderr?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -1,8 +1,11 @@\n-error: expected expression, found reserved keyword `try`\n-  --> $DIR/try-block-in-while.rs:6:11\n+error[E0277]: the trait bound `bool: std::ops::Try` is not satisfied\n+  --> $DIR/try-block-in-while.rs:6:15\n    |\n LL |     while try { false } {}\n-   |           ^^^ expected expression\n+   |               ^^^^^^^^^ the trait `std::ops::Try` is not implemented for `bool`\n+   |\n+   = note: required by `std::ops::Try::from_ok`\n \n error: aborting due to previous error\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "0b767eb2dad77de9c4dfbe5469dd63c104352a06", "filename": "src/test/ui/try-block/try-block-unused-delims.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.rs?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -0,0 +1,28 @@\n+// check-pass\n+// compile-flags: --edition 2018\n+\n+#![feature(try_blocks)]\n+#![warn(unused_parens, unused_braces)]\n+\n+fn consume<T>(_: Result<T, T>) -> T { todo!() }\n+\n+fn main() {\n+    consume((try {}));\n+    //~^ WARN unnecessary parentheses\n+\n+    consume({ try {} });\n+    //~^ WARN unnecessary braces\n+\n+    match (try {}) {\n+        //~^ WARN unnecessary parentheses\n+        Ok(()) | Err(()) => (),\n+    }\n+\n+    if let Err(()) = (try {}) {}\n+    //~^ WARN unnecessary parentheses\n+\n+    match (try {}) {\n+        //~^ WARN unnecessary parentheses\n+        Ok(()) | Err(()) => (),\n+    }\n+}"}, {"sha": "5c7602ee0ab1246c4322f5b1ffc16dfd2ee1f8c0", "filename": "src/test/ui/try-block/try-block-unused-delims.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/76cbf0053f8812e210603689b4173c210976fe6c/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftry-block%2Ftry-block-unused-delims.stderr?ref=76cbf0053f8812e210603689b4173c210976fe6c", "patch": "@@ -0,0 +1,44 @@\n+warning: unnecessary parentheses around function argument\n+  --> $DIR/try-block-unused-delims.rs:10:13\n+   |\n+LL |     consume((try {}));\n+   |             ^^^^^^^^ help: remove these parentheses\n+   |\n+note: the lint level is defined here\n+  --> $DIR/try-block-unused-delims.rs:5:9\n+   |\n+LL | #![warn(unused_parens, unused_braces)]\n+   |         ^^^^^^^^^^^^^\n+\n+warning: unnecessary braces around function argument\n+  --> $DIR/try-block-unused-delims.rs:13:13\n+   |\n+LL |     consume({ try {} });\n+   |             ^^^^^^^^^^ help: remove these braces\n+   |\n+note: the lint level is defined here\n+  --> $DIR/try-block-unused-delims.rs:5:24\n+   |\n+LL | #![warn(unused_parens, unused_braces)]\n+   |                        ^^^^^^^^^^^^^\n+\n+warning: unnecessary parentheses around `match` scrutinee expression\n+  --> $DIR/try-block-unused-delims.rs:16:11\n+   |\n+LL |     match (try {}) {\n+   |           ^^^^^^^^ help: remove these parentheses\n+\n+warning: unnecessary parentheses around `let` scrutinee expression\n+  --> $DIR/try-block-unused-delims.rs:21:22\n+   |\n+LL |     if let Err(()) = (try {}) {}\n+   |                      ^^^^^^^^ help: remove these parentheses\n+\n+warning: unnecessary parentheses around `match` scrutinee expression\n+  --> $DIR/try-block-unused-delims.rs:24:11\n+   |\n+LL |     match (try {}) {\n+   |           ^^^^^^^^ help: remove these parentheses\n+\n+warning: 5 warnings emitted\n+"}]}