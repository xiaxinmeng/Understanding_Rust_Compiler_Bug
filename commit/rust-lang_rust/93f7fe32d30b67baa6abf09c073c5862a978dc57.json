{"sha": "93f7fe32d30b67baa6abf09c073c5862a978dc57", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkzZjdmZTMyZDMwYjY3YmFhNmFiZjA5YzA3M2M1ODYyYTk3OGRjNTc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-10T23:49:24Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-10T23:49:24Z"}, "message": "Auto merge of #24270 - pnkfelix:use-disr-val-for-derive-ord, r=brson\n\nUse `discriminant_value` intrinsic for `derive(PartialOrd)`\r\n\r\n[breaking-change]\r\n\r\nThis is a [breaking-change] because it can change the result of comparison operators when enum discriminants have been explicitly assigned.  Notably in a case like:\r\n```rust\r\n#[derive(PartialOrd)]\r\nenum E { A = 2, B = 1}\r\n```\r\n\r\nUnder the old deriving, `A < B` held, because `A` came before `B` in the order of declaration.  But now we use the ordering according to the provided values, and thus `A > B`.  (However, this change is very unlikely to break much, if any, code, since the orderings themselves should all remain well-defined, total, etc.)\r\n\r\nFix #15523", "tree": {"sha": "5b63cfec7a546fe3c190f8a6cfafc3118b903180", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b63cfec7a546fe3c190f8a6cfafc3118b903180"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/93f7fe32d30b67baa6abf09c073c5862a978dc57", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/93f7fe32d30b67baa6abf09c073c5862a978dc57", "html_url": "https://github.com/rust-lang/rust/commit/93f7fe32d30b67baa6abf09c073c5862a978dc57", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/93f7fe32d30b67baa6abf09c073c5862a978dc57/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c897ac04e2ebda378fd9e38f6ec0878ae3a2baf7", "url": "https://api.github.com/repos/rust-lang/rust/commits/c897ac04e2ebda378fd9e38f6ec0878ae3a2baf7", "html_url": "https://github.com/rust-lang/rust/commit/c897ac04e2ebda378fd9e38f6ec0878ae3a2baf7"}, {"sha": "05aaad114f343ab6d484aa193b99e221089f4a8b", "url": "https://api.github.com/repos/rust-lang/rust/commits/05aaad114f343ab6d484aa193b99e221089f4a8b", "html_url": "https://github.com/rust-lang/rust/commit/05aaad114f343ab6d484aa193b99e221089f4a8b"}], "stats": {"total": 297, "additions": 264, "deletions": 33}, "files": [{"sha": "80f506ebc0643053bad8190a616e3d9550218dc6", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -569,4 +569,10 @@ extern \"rust-intrinsic\" {\n     pub fn overflowing_sub<T>(a: T, b: T) -> T;\n     /// Returns (a * b) mod 2^N, where N is the width of N in bits.\n     pub fn overflowing_mul<T>(a: T, b: T) -> T;\n+\n+    /// Returns the value of the discriminant for the variant in 'v',\n+    /// cast to a `u64`; if `T` has no discriminant, returns 0.\n+    // SNAP 5520801\n+    #[cfg(not(stage0))]\n+    pub fn discriminant_value<T>(v: &T) -> u64;\n }"}, {"sha": "1b7311028f5ed6ae03a05d97ac9bdd5d70961404", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -157,6 +157,7 @@ mod tuple;\n \n #[doc(hidden)]\n mod core {\n+    pub use intrinsics;\n     pub use panicking;\n     pub use fmt;\n     pub use clone;"}, {"sha": "fc3c0841dd84e9a3c6f837dfe7c64cc84baaf862", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -14,6 +14,7 @@ use llvm;\n use llvm::{SequentiallyConsistent, Acquire, Release, AtomicXchg, ValueRef, TypeKind};\n use middle::subst;\n use middle::subst::FnSpace;\n+use trans::adt;\n use trans::base::*;\n use trans::build::*;\n use trans::callee;\n@@ -683,6 +684,17 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n             }\n         }\n \n+        (_, \"discriminant_value\") => {\n+            let val_ty = substs.types.get(FnSpace, 0);\n+            match val_ty.sty {\n+                ty::ty_enum(..) => {\n+                    let repr = adt::represent_type(ccx, *val_ty);\n+                    adt::trans_get_discr(bcx, &*repr, llargs[0], Some(llret_ty))\n+                }\n+                _ => C_null(llret_ty)\n+            }\n+        }\n+\n         // This requires that atomic intrinsics follow a specific naming pattern:\n         // \"atomic_<operation>[_<ordering>]\", and no ordering means SeqCst\n         (_, name) if name.starts_with(\"atomic_\") => {"}, {"sha": "31039e3abca6eb6729f9c5d2b16fa2b1cdca9bae", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -5073,6 +5073,12 @@ pub fn check_intrinsic_type(ccx: &CrateCtxt, it: &ast::ForeignItem) {\n \n             \"assume\" => (0, vec![tcx.types.bool], ty::mk_nil(tcx)),\n \n+            \"discriminant_value\" => (1, vec![\n+                    ty::mk_imm_rptr(tcx,\n+                                    tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1),\n+                                                                  ty::BrAnon(0))),\n+                                    param(ccx, 0))], tcx.types.u64),\n+\n             ref other => {\n                 span_err!(tcx.sess, it.span, E0093,\n                     \"unrecognized intrinsic function: `{}`\", *other);"}, {"sha": "ac96375095e143a8bfd10635f74ee8bd011133ee", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 63, "deletions": 29, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -201,6 +201,7 @@ use ext::base::ExtCtxt;\n use ext::build::AstBuilder;\n use codemap::{self, DUMMY_SP};\n use codemap::Span;\n+use diagnostic::SpanHandler;\n use fold::MoveMap;\n use owned_slice::OwnedSlice;\n use parse::token::InternedString;\n@@ -391,6 +392,7 @@ impl<'a> TraitDef<'a> {\n             ast::ItemEnum(ref enum_def, ref generics) => {\n                 self.expand_enum_def(cx,\n                                      enum_def,\n+                                     &item.attrs[..],\n                                      item.ident,\n                                      generics)\n             }\n@@ -653,6 +655,7 @@ impl<'a> TraitDef<'a> {\n     fn expand_enum_def(&self,\n                        cx: &mut ExtCtxt,\n                        enum_def: &EnumDef,\n+                       type_attrs: &[ast::Attribute],\n                        type_ident: Ident,\n                        generics: &Generics) -> P<ast::Item> {\n         let mut field_tys = Vec::new();\n@@ -687,6 +690,7 @@ impl<'a> TraitDef<'a> {\n                 method_def.expand_enum_method_body(cx,\n                                                    self,\n                                                    enum_def,\n+                                                   type_attrs,\n                                                    type_ident,\n                                                    self_args,\n                                                    &nonself_args[..])\n@@ -706,13 +710,30 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n-fn variant_to_pat(cx: &mut ExtCtxt, sp: Span, enum_ident: ast::Ident, variant: &ast::Variant)\n-                  -> P<ast::Pat> {\n-    let path = cx.path(sp, vec![enum_ident, variant.node.name]);\n-    cx.pat(sp, match variant.node.kind {\n-        ast::TupleVariantKind(..) => ast::PatEnum(path, None),\n-        ast::StructVariantKind(..) => ast::PatStruct(path, Vec::new(), true),\n-    })\n+fn find_repr_type_name(diagnostic: &SpanHandler,\n+                       type_attrs: &[ast::Attribute]) -> &'static str {\n+    let mut repr_type_name = \"i32\";\n+    for a in type_attrs {\n+        for r in &attr::find_repr_attrs(diagnostic, a) {\n+            repr_type_name = match *r {\n+                attr::ReprAny | attr::ReprPacked => continue,\n+                attr::ReprExtern => \"i32\",\n+\n+                attr::ReprInt(_, attr::SignedInt(ast::TyIs)) => \"isize\",\n+                attr::ReprInt(_, attr::SignedInt(ast::TyI8)) => \"i8\",\n+                attr::ReprInt(_, attr::SignedInt(ast::TyI16)) => \"i16\",\n+                attr::ReprInt(_, attr::SignedInt(ast::TyI32)) => \"i32\",\n+                attr::ReprInt(_, attr::SignedInt(ast::TyI64)) => \"i64\",\n+\n+                attr::ReprInt(_, attr::UnsignedInt(ast::TyUs)) => \"usize\",\n+                attr::ReprInt(_, attr::UnsignedInt(ast::TyU8)) => \"u8\",\n+                attr::ReprInt(_, attr::UnsignedInt(ast::TyU16)) => \"u16\",\n+                attr::ReprInt(_, attr::UnsignedInt(ast::TyU32)) => \"u32\",\n+                attr::ReprInt(_, attr::UnsignedInt(ast::TyU64)) => \"u64\",\n+            }\n+        }\n+    }\n+    repr_type_name\n }\n \n impl<'a> MethodDef<'a> {\n@@ -983,12 +1004,13 @@ impl<'a> MethodDef<'a> {\n                                cx: &mut ExtCtxt,\n                                trait_: &TraitDef,\n                                enum_def: &EnumDef,\n+                               type_attrs: &[ast::Attribute],\n                                type_ident: Ident,\n                                self_args: Vec<P<Expr>>,\n                                nonself_args: &[P<Expr>])\n                                -> P<Expr> {\n         self.build_enum_match_tuple(\n-            cx, trait_, enum_def, type_ident, self_args, nonself_args)\n+            cx, trait_, enum_def, type_attrs, type_ident, self_args, nonself_args)\n     }\n \n \n@@ -1022,6 +1044,7 @@ impl<'a> MethodDef<'a> {\n         cx: &mut ExtCtxt,\n         trait_: &TraitDef,\n         enum_def: &EnumDef,\n+        type_attrs: &[ast::Attribute],\n         type_ident: Ident,\n         self_args: Vec<P<Expr>>,\n         nonself_args: &[P<Expr>]) -> P<Expr> {\n@@ -1044,8 +1067,8 @@ impl<'a> MethodDef<'a> {\n             .collect::<Vec<ast::Ident>>();\n \n         // The `vi_idents` will be bound, solely in the catch-all, to\n-        // a series of let statements mapping each self_arg to a usize\n-        // corresponding to its variant index.\n+        // a series of let statements mapping each self_arg to an int\n+        // value corresponding to its discriminant.\n         let vi_idents: Vec<ast::Ident> = self_arg_names.iter()\n             .map(|name| { let vi_suffix = format!(\"{}_vi\", &name[..]);\n                           cx.ident_of(&vi_suffix[..]) })\n@@ -1160,33 +1183,44 @@ impl<'a> MethodDef<'a> {\n         //   unreachable-pattern error.\n         //\n         if variants.len() > 1 && self_args.len() > 1 {\n-            let arms: Vec<ast::Arm> = variants.iter().enumerate()\n-                .map(|(index, variant)| {\n-                    let pat = variant_to_pat(cx, sp, type_ident, &**variant);\n-                    let lit = ast::LitInt(index as u64, ast::UnsignedIntLit(ast::TyUs));\n-                    cx.arm(sp, vec![pat], cx.expr_lit(sp, lit))\n-                }).collect();\n-\n             // Build a series of let statements mapping each self_arg\n-            // to a usize corresponding to its variant index.\n+            // to its discriminant value. If this is a C-style enum\n+            // with a specific repr type, then casts the values to\n+            // that type.  Otherwise casts to `i32` (the default repr\n+            // type).\n+            //\n             // i.e. for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n             // with three Self args, builds three statements:\n             //\n             // ```\n-            // let __self0_vi = match   self {\n-            //     A => 0, B(..) => 1, C(..) => 2\n-            // };\n-            // let __self1_vi = match __arg1 {\n-            //     A => 0, B(..) => 1, C(..) => 2\n-            // };\n-            // let __self2_vi = match __arg2 {\n-            //     A => 0, B(..) => 1, C(..) => 2\n-            // };\n+            // let __self0_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&self) } as i32;\n+            // let __self1_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&__arg1) } as i32;\n+            // let __self2_vi = unsafe {\n+            //     std::intrinsics::discriminant_value(&__arg2) } as i32;\n             // ```\n             let mut index_let_stmts: Vec<P<ast::Stmt>> = Vec::new();\n+\n+            let target_type_name =\n+                find_repr_type_name(&cx.parse_sess.span_diagnostic, type_attrs);\n+\n             for (&ident, self_arg) in vi_idents.iter().zip(self_args.iter()) {\n-                let variant_idx = cx.expr_match(sp, self_arg.clone(), arms.clone());\n-                let let_stmt = cx.stmt_let(sp, false, ident, variant_idx);\n+                let path = vec![cx.ident_of_std(\"core\"),\n+                                cx.ident_of(\"intrinsics\"),\n+                                cx.ident_of(\"discriminant_value\")];\n+                let call = cx.expr_call_global(\n+                    sp, path, vec![cx.expr_addr_of(sp, self_arg.clone())]);\n+                let variant_value = cx.expr_block(P(ast::Block {\n+                    stmts: vec![],\n+                    expr: Some(call),\n+                    id: ast::DUMMY_NODE_ID,\n+                    rules: ast::UnsafeBlock(ast::CompilerGenerated),\n+                    span: sp }));\n+\n+                let target_ty = cx.ty_ident(sp, cx.ident_of(target_type_name));\n+                let variant_disr = cx.expr_cast(sp, variant_value, target_ty);\n+                let let_stmt = cx.stmt_let(sp, false, ident, variant_disr);\n                 index_let_stmts.push(let_stmt);\n             }\n "}, {"sha": "217e696f0953884879229a36d46857bd5c66053e", "filename": "src/test/run-pass/discriminant_value.rs", "status": "added", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fdiscriminant_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fdiscriminant_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fdiscriminant_value.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -0,0 +1,77 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(core)]\n+\n+extern crate core;\n+use core::intrinsics::discriminant_value;\n+\n+enum CLike1 {\n+    A,\n+    B,\n+    C,\n+    D\n+}\n+\n+enum CLike2 {\n+    A = 5,\n+    B = 2,\n+    C = 19,\n+    D\n+}\n+\n+#[repr(i8)]\n+enum CLike3 {\n+    A = 5,\n+    B,\n+    C = -1,\n+    D\n+}\n+\n+enum ADT {\n+    First(u32, u32),\n+    Second(u64)\n+}\n+\n+enum NullablePointer {\n+    Something(&'static u32),\n+    Nothing\n+}\n+\n+static CONST : u32 = 0xBEEF;\n+\n+pub fn main() {\n+    unsafe {\n+\n+        assert_eq!(discriminant_value(&CLike1::A), 0);\n+        assert_eq!(discriminant_value(&CLike1::B), 1);\n+        assert_eq!(discriminant_value(&CLike1::C), 2);\n+        assert_eq!(discriminant_value(&CLike1::D), 3);\n+\n+        assert_eq!(discriminant_value(&CLike2::A), 5);\n+        assert_eq!(discriminant_value(&CLike2::B), 2);\n+        assert_eq!(discriminant_value(&CLike2::C), 19);\n+        assert_eq!(discriminant_value(&CLike2::D), 20);\n+\n+        assert_eq!(discriminant_value(&CLike3::A), 5);\n+        assert_eq!(discriminant_value(&CLike3::B), 6);\n+        assert_eq!(discriminant_value(&CLike3::C), -1_i8 as u64);\n+        assert_eq!(discriminant_value(&CLike3::D), 0);\n+\n+        assert_eq!(discriminant_value(&ADT::First(0,0)), 0);\n+        assert_eq!(discriminant_value(&ADT::Second(5)), 1);\n+\n+        assert_eq!(discriminant_value(&NullablePointer::Nothing), 1);\n+        assert_eq!(discriminant_value(&NullablePointer::Something(&CONST)), 0);\n+\n+        assert_eq!(discriminant_value(&10), 0);\n+        assert_eq!(discriminant_value(&\"test\"), 0);\n+    }\n+}"}, {"sha": "33c81cab3817bb6ba26c1260d27dbf1b4a514dba", "filename": "src/test/run-pass/issue-15523-big.rs", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fissue-15523-big.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fissue-15523-big.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15523-big.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -0,0 +1,48 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 15523: derive(PartialOrd) should use the provided\n+// discriminant values for the derived ordering.\n+//\n+// This test is checking corner cases that arise when you have\n+// 64-bit values in the variants.\n+\n+#[derive(PartialEq, PartialOrd)]\n+#[repr(u64)]\n+enum Eu64 {\n+    Pos2 = 2,\n+    PosMax = !0,\n+    Pos1 = 1,\n+}\n+\n+#[derive(PartialEq, PartialOrd)]\n+#[repr(i64)]\n+enum Ei64 {\n+    Pos2 = 2,\n+    Neg1 = -1,\n+    NegMin = 1 << 63,\n+    PosMax = !(1 << 63),\n+    Pos1 = 1,\n+}\n+\n+fn main() {\n+    assert!(Eu64::Pos2 > Eu64::Pos1);\n+    assert!(Eu64::Pos2 < Eu64::PosMax);\n+    assert!(Eu64::Pos1 < Eu64::PosMax);\n+\n+\n+    assert!(Ei64::Pos2 > Ei64::Pos1);\n+    assert!(Ei64::Pos2 > Ei64::Neg1);\n+    assert!(Ei64::Pos1 > Ei64::Neg1);\n+    assert!(Ei64::Pos2 > Ei64::NegMin);\n+    assert!(Ei64::Pos1 > Ei64::NegMin);\n+    assert!(Ei64::Pos2 < Ei64::PosMax);\n+    assert!(Ei64::Pos1 < Ei64::PosMax);\n+}"}, {"sha": "bb8fa6791a5c41ac26e50e535ec55802d9723ad0", "filename": "src/test/run-pass/issue-15523.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fissue-15523.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fissue-15523.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15523.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -0,0 +1,51 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Issue 15523: derive(PartialOrd) should use the provided\n+// discriminant values for the derived ordering.\n+//\n+// This is checking the basic functionality.\n+\n+#[derive(PartialEq, PartialOrd)]\n+enum E1 {\n+    Pos2 = 2,\n+    Neg1 = -1,\n+    Pos1 = 1,\n+}\n+\n+#[derive(PartialEq, PartialOrd)]\n+#[repr(u8)]\n+enum E2 {\n+    Pos2 = 2,\n+    PosMax = !0 as u8,\n+    Pos1 = 1,\n+}\n+\n+#[derive(PartialEq, PartialOrd)]\n+#[repr(i8)]\n+enum E3 {\n+    Pos2 = 2,\n+    Neg1 = -1_i8,\n+    Pos1 = 1,\n+}\n+\n+fn main() {\n+    assert!(E1::Pos2 > E1::Pos1);\n+    assert!(E1::Pos1 > E1::Neg1);\n+    assert!(E1::Pos2 > E1::Neg1);\n+\n+    assert!(E2::Pos2 > E2::Pos1);\n+    assert!(E2::Pos1 < E2::PosMax);\n+    assert!(E2::Pos2 < E2::PosMax);\n+\n+    assert!(E3::Pos2 > E3::Pos1);\n+    assert!(E3::Pos1 > E3::Neg1);\n+    assert!(E3::Pos2 > E3::Neg1);\n+}"}, {"sha": "819ec532ed2ce00c8e1092405b91cdf27120947e", "filename": "src/test/run-pass/issue-18738.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fissue-18738.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fissue-18738.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-18738.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #[derive(Eq, PartialEq, PartialOrd, Ord)]\n enum Test<'a> {\n     Int(&'a isize),"}, {"sha": "7ff770327742baaf8c36e0d24126dda278073581", "filename": "src/test/run-pass/while-prelude-drop.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/93f7fe32d30b67baa6abf09c073c5862a978dc57/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fwhile-prelude-drop.rs?ref=93f7fe32d30b67baa6abf09c073c5862a978dc57", "patch": "@@ -8,8 +8,6 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// pretty-expanded FIXME #23616\n-\n #![feature(collections)]\n \n use std::string::String;"}]}