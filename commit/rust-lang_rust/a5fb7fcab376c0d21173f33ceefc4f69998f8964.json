{"sha": "a5fb7fcab376c0d21173f33ceefc4f69998f8964", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE1ZmI3ZmNhYjM3NmMwZDIxMTczZjMzY2VlZmM0ZjY5OTk4Zjg5NjQ=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-05-30T03:39:12Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-30T03:39:12Z"}, "message": "Rollup merge of #72419 - RalfJung:read-discriminant, r=oli-obk,eddyb\n\nMiri read_discriminant: return a scalar instead of raw underlying bytes\n\nr? @oli-obk @eddyb", "tree": {"sha": "4e3d99bb8678fcd5917d235bbd9701005073c5e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e3d99bb8678fcd5917d235bbd9701005073c5e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a5fb7fcab376c0d21173f33ceefc4f69998f8964", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0dVhCRBK7hj4Ov3rIwAAdHIIAHGNS5Lf3pGXsHaODX6XMylO\nxZhIcgZ6O6+qxBEzo82R+5N5LyWpE6dXhxD9ry7jJX0pIuI+l43iJAT/FAWE90W2\no6sPWoN9Cp9SnRLAndT15bm92m7wAnqD8qhaJ4+/7J5AuYpby7HKQW71BrGA0yP8\nNox8jCKo8Euui2Ivf1F3RvmS6KxKMW9LeMl3hliJWOIqz5BrxRccxovUGYAi//P6\nkT4W3fquL054cbeO1LBGcTvl8UEtGOv2X4vVL2W7uEDB7NFO+ut9BY2+D6EyfOWE\n05DNPZFRZJkR/s5JdNs3llsBXr4YOG34cm3kPmu4rLic8ZbYJKCWusKx6KHOcmw=\n=uoJK\n-----END PGP SIGNATURE-----\n", "payload": "tree 4e3d99bb8678fcd5917d235bbd9701005073c5e4\nparent 3459eae96c3ab9ae40012e97723c7550e96200f6\nparent c4b6224ea46f57bb59df8d321d8f40e7f2900423\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1590809952 +0900\ncommitter GitHub <noreply@github.com> 1590809952 +0900\n\nRollup merge of #72419 - RalfJung:read-discriminant, r=oli-obk,eddyb\n\nMiri read_discriminant: return a scalar instead of raw underlying bytes\n\nr? @oli-obk @eddyb\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a5fb7fcab376c0d21173f33ceefc4f69998f8964", "html_url": "https://github.com/rust-lang/rust/commit/a5fb7fcab376c0d21173f33ceefc4f69998f8964", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a5fb7fcab376c0d21173f33ceefc4f69998f8964/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3459eae96c3ab9ae40012e97723c7550e96200f6", "url": "https://api.github.com/repos/rust-lang/rust/commits/3459eae96c3ab9ae40012e97723c7550e96200f6", "html_url": "https://github.com/rust-lang/rust/commit/3459eae96c3ab9ae40012e97723c7550e96200f6"}, {"sha": "c4b6224ea46f57bb59df8d321d8f40e7f2900423", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4b6224ea46f57bb59df8d321d8f40e7f2900423", "html_url": "https://github.com/rust-lang/rust/commit/c4b6224ea46f57bb59df8d321d8f40e7f2900423"}], "stats": {"total": 223, "additions": 129, "deletions": 94}, "files": [{"sha": "fc588e049d7d8b9da719d8ff096f5ff40ed4d53d", "filename": "src/librustc_middle/mir/interpret/error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Ferror.rs?ref=a5fb7fcab376c0d21173f33ceefc4f69998f8964", "patch": "@@ -1,4 +1,4 @@\n-use super::{AllocId, Pointer, RawConst, ScalarMaybeUninit};\n+use super::{AllocId, Pointer, RawConst, Scalar};\n \n use crate::mir::interpret::ConstValue;\n use crate::ty::layout::LayoutError;\n@@ -391,7 +391,7 @@ pub enum UndefinedBehaviorInfo<'tcx> {\n     /// Using a non-character `u32` as character.\n     InvalidChar(u32),\n     /// An enum discriminant was set to a value which was outside the range of valid values.\n-    InvalidDiscriminant(ScalarMaybeUninit),\n+    InvalidDiscriminant(Scalar),\n     /// Using a pointer-not-to-a-function as function pointer.\n     InvalidFunctionPointer(Pointer),\n     /// Using a string that is not valid UTF-8,"}, {"sha": "4059bfedc6da47ab8bdf591ba048b72d2461fd35", "filename": "src/librustc_middle/mir/tcx.rs", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_middle%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Ftcx.rs?ref=a5fb7fcab376c0d21173f33ceefc4f69998f8964", "patch": "@@ -5,7 +5,6 @@\n \n use crate::mir::*;\n use crate::ty::subst::Subst;\n-use crate::ty::util::IntTypeExt;\n use crate::ty::{self, Ty, TyCtxt};\n use rustc_hir as hir;\n use rustc_target::abi::VariantIdx;\n@@ -174,17 +173,7 @@ impl<'tcx> Rvalue<'tcx> {\n                 tcx.intern_tup(&[ty, tcx.types.bool])\n             }\n             Rvalue::UnaryOp(UnOp::Not | UnOp::Neg, ref operand) => operand.ty(local_decls, tcx),\n-            Rvalue::Discriminant(ref place) => {\n-                let ty = place.ty(local_decls, tcx).ty;\n-                match ty.kind {\n-                    ty::Adt(adt_def, _) => adt_def.repr.discr_type().to_ty(tcx),\n-                    ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n-                    _ => {\n-                        // This can only be `0`, for now, so `u8` will suffice.\n-                        tcx.types.u8\n-                    }\n-                }\n-            }\n+            Rvalue::Discriminant(ref place) => place.ty(local_decls, tcx).ty.discriminant_ty(tcx),\n             Rvalue::NullaryOp(NullOp::Box, t) => tcx.mk_box(t),\n             Rvalue::NullaryOp(NullOp::SizeOf, _) => tcx.types.usize,\n             Rvalue::Aggregate(ref ak, ref ops) => match **ak {"}, {"sha": "4cd3be932def004bfe7ffac53343770fc596d78e", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=a5fb7fcab376c0d21173f33ceefc4f69998f8964", "patch": "@@ -2037,6 +2037,8 @@ impl ReprOptions {\n         self.flags.contains(ReprFlags::HIDE_NICHE)\n     }\n \n+    /// Returns the discriminant type, given these `repr` options.\n+    /// This must only be called on enums!\n     pub fn discr_type(&self) -> attr::IntType {\n         self.int.unwrap_or(attr::SignedInt(ast::IntTy::Isize))\n     }\n@@ -2269,6 +2271,7 @@ impl<'tcx> AdtDef {\n \n     #[inline]\n     pub fn eval_explicit_discr(&self, tcx: TyCtxt<'tcx>, expr_did: DefId) -> Option<Discr<'tcx>> {\n+        assert!(self.is_enum());\n         let param_env = tcx.param_env(expr_did);\n         let repr_type = self.repr.discr_type();\n         match tcx.const_eval_poly(expr_did) {\n@@ -2305,6 +2308,7 @@ impl<'tcx> AdtDef {\n         &'tcx self,\n         tcx: TyCtxt<'tcx>,\n     ) -> impl Iterator<Item = (VariantIdx, Discr<'tcx>)> + Captures<'tcx> {\n+        assert!(self.is_enum());\n         let repr_type = self.repr.discr_type();\n         let initial = repr_type.initial_discriminant(tcx);\n         let mut prev_discr = None::<Discr<'tcx>>;\n@@ -2337,6 +2341,7 @@ impl<'tcx> AdtDef {\n         tcx: TyCtxt<'tcx>,\n         variant_index: VariantIdx,\n     ) -> Discr<'tcx> {\n+        assert!(self.is_enum());\n         let (val, offset) = self.discriminant_def_for_variant(variant_index);\n         let explicit_value = val\n             .and_then(|expr_did| self.eval_explicit_discr(tcx, expr_did))"}, {"sha": "f4962ced6c03a83e613e80ca8be838520cdc30cf", "filename": "src/librustc_middle/ty/sty.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_middle%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_middle%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fsty.rs?ref=a5fb7fcab376c0d21173f33ceefc4f69998f8964", "patch": "@@ -29,6 +29,7 @@ use std::borrow::Cow;\n use std::cmp::Ordering;\n use std::marker::PhantomData;\n use std::ops::Range;\n+use ty::util::IntTypeExt;\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, RustcEncodable, RustcDecodable)]\n #[derive(HashStable, TypeFoldable, Lift)]\n@@ -2096,14 +2097,28 @@ impl<'tcx> TyS<'tcx> {\n         variant_index: VariantIdx,\n     ) -> Option<Discr<'tcx>> {\n         match self.kind {\n-            TyKind::Adt(adt, _) => Some(adt.discriminant_for_variant(tcx, variant_index)),\n+            TyKind::Adt(adt, _) if adt.is_enum() => {\n+                Some(adt.discriminant_for_variant(tcx, variant_index))\n+            }\n             TyKind::Generator(def_id, substs, _) => {\n                 Some(substs.as_generator().discriminant_for_variant(def_id, tcx, variant_index))\n             }\n             _ => None,\n         }\n     }\n \n+    /// Returns the type of the discriminant of this type.\n+    pub fn discriminant_ty(&self, tcx: TyCtxt<'tcx>) -> Ty<'tcx> {\n+        match self.kind {\n+            ty::Adt(adt, _) if adt.is_enum() => adt.repr.discr_type().to_ty(tcx),\n+            ty::Generator(_, substs, _) => substs.as_generator().discr_ty(tcx),\n+            _ => {\n+                // This can only be `0`, for now, so `u8` will suffice.\n+                tcx.types.u8\n+            }\n+        }\n+    }\n+\n     /// When we create a closure, we record its kind (i.e., what trait\n     /// it implements) into its `ClosureSubsts` using a type\n     /// parameter. This is kind of a phantom type, except that the"}, {"sha": "115a472cabe5ea89b6b0ad2926cc6142b0602628", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=a5fb7fcab376c0d21173f33ceefc4f69998f8964", "patch": "@@ -220,15 +220,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             sym::discriminant_value => {\n                 let place = self.deref_operand(args[0])?;\n                 let discr_val = self.read_discriminant(place.into())?.0;\n-                let scalar = match dest.layout.ty.kind {\n-                    ty::Int(_) => Scalar::from_int(\n-                        self.sign_extend(discr_val, dest.layout) as i128,\n-                        dest.layout.size,\n-                    ),\n-                    ty::Uint(_) => Scalar::from_uint(discr_val, dest.layout.size),\n-                    _ => bug!(\"invalid `discriminant_value` return layout: {:?}\", dest.layout),\n-                };\n-                self.write_scalar(scalar, dest)?;\n+                self.write_scalar(discr_val, dest)?;\n             }\n             sym::unchecked_shl\n             | sym::unchecked_shr"}, {"sha": "db4473154c471af4a9c42f53e1e129afa8a9bbf2", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 95, "deletions": 68, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=a5fb7fcab376c0d21173f33ceefc4f69998f8964", "patch": "@@ -7,15 +7,15 @@ use std::fmt::Write;\n use rustc_errors::ErrorReported;\n use rustc_hir::def::Namespace;\n use rustc_macros::HashStable;\n-use rustc_middle::ty::layout::{IntegerExt, PrimitiveExt, TyAndLayout};\n+use rustc_middle::ty::layout::{PrimitiveExt, TyAndLayout};\n use rustc_middle::ty::print::{FmtPrinter, PrettyPrinter, Printer};\n use rustc_middle::ty::Ty;\n use rustc_middle::{mir, ty};\n-use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, Integer, LayoutOf, Size};\n+use rustc_target::abi::{Abi, DiscriminantKind, HasDataLayout, LayoutOf, Size};\n use rustc_target::abi::{VariantIdx, Variants};\n \n use super::{\n-    from_known_layout, sign_extend, truncate, ConstValue, GlobalId, InterpCx, InterpResult,\n+    from_known_layout, mir_assign_valid_types, ConstValue, GlobalId, InterpCx, InterpResult,\n     MPlaceTy, Machine, MemPlace, Place, PlaceTy, Pointer, Scalar, ScalarMaybeUninit,\n };\n \n@@ -469,6 +469,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .try_fold(base_op, |op, elem| self.operand_projection(op, elem))?;\n \n         trace!(\"eval_place_to_op: got {:?}\", *op);\n+        // Sanity-check the type we ended up with.\n+        debug_assert!(mir_assign_valid_types(\n+            *self.tcx,\n+            self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n+                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n+            ))?,\n+            op.layout,\n+        ));\n         Ok(op)\n     }\n \n@@ -576,98 +584,113 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Read discriminant, return the runtime value as well as the variant index.\n     pub fn read_discriminant(\n         &self,\n-        rval: OpTy<'tcx, M::PointerTag>,\n-    ) -> InterpResult<'tcx, (u128, VariantIdx)> {\n-        trace!(\"read_discriminant_value {:#?}\", rval.layout);\n-\n-        let (discr_layout, discr_kind, discr_index) = match rval.layout.variants {\n+        op: OpTy<'tcx, M::PointerTag>,\n+    ) -> InterpResult<'tcx, (Scalar<M::PointerTag>, VariantIdx)> {\n+        trace!(\"read_discriminant_value {:#?}\", op.layout);\n+\n+        // Get type and layout of the discriminant.\n+        let discr_layout = self.layout_of(op.layout.ty.discriminant_ty(*self.tcx))?;\n+        trace!(\"discriminant type: {:?}\", discr_layout.ty);\n+\n+        // We use \"discriminant\" to refer to the value associated with a particular enum variant.\n+        // This is not to be confused with its \"variant index\", which is just determining its position in the\n+        // declared list of variants -- they can differ with explicitly assigned discriminants.\n+        // We use \"tag\" to refer to how the discriminant is encoded in memory, which can be either\n+        // straight-forward (`DiscriminantKind::Tag`) or with a niche (`DiscriminantKind::Niche`).\n+        // Unfortunately, the rest of the compiler calls the latter \"discriminant\", too, which makes things\n+        // rather confusing.\n+        let (tag_scalar_layout, tag_kind, tag_index) = match op.layout.variants {\n             Variants::Single { index } => {\n-                let discr_val = rval\n-                    .layout\n-                    .ty\n-                    .discriminant_for_variant(*self.tcx, index)\n-                    .map_or(u128::from(index.as_u32()), |discr| discr.val);\n-                return Ok((discr_val, index));\n+                let discr = match op.layout.ty.discriminant_for_variant(*self.tcx, index) {\n+                    Some(discr) => {\n+                        // This type actually has discriminants.\n+                        assert_eq!(discr.ty, discr_layout.ty);\n+                        Scalar::from_uint(discr.val, discr_layout.size)\n+                    }\n+                    None => {\n+                        // On a type without actual discriminants, variant is 0.\n+                        assert_eq!(index.as_u32(), 0);\n+                        Scalar::from_uint(index.as_u32(), discr_layout.size)\n+                    }\n+                };\n+                return Ok((discr, index));\n             }\n-            Variants::Multiple { discr: ref discr_layout, ref discr_kind, discr_index, .. } => {\n-                (discr_layout, discr_kind, discr_index)\n+            Variants::Multiple { ref discr, ref discr_kind, discr_index, .. } => {\n+                (discr, discr_kind, discr_index)\n             }\n         };\n \n-        // read raw discriminant value\n-        let discr_op = self.operand_field(rval, discr_index)?;\n-        let discr_val = self.read_immediate(discr_op)?;\n-        let raw_discr = discr_val.to_scalar_or_undef();\n-        trace!(\"discr value: {:?}\", raw_discr);\n-        // post-process\n-        Ok(match *discr_kind {\n+        // There are *three* layouts that come into play here:\n+        // - The discriminant has a type for typechecking. This is `discr_layout`, and is used for\n+        //   the `Scalar` we return.\n+        // - The tag (encoded discriminant) has layout `tag_layout`. This is always an integer type,\n+        //   and used to interpret the value we read from the tag field.\n+        //   For the return value, a cast to `discr_layout` is performed.\n+        // - The field storing the tag has a layout, which is very similar to `tag_layout` but\n+        //   may be a pointer. This is `tag_val.layout`; we just use it for sanity checks.\n+\n+        // Get layout for tag.\n+        let tag_layout = self.layout_of(tag_scalar_layout.value.to_int_ty(*self.tcx))?;\n+\n+        // Read tag and sanity-check `tag_layout`.\n+        let tag_val = self.read_immediate(self.operand_field(op, tag_index)?)?;\n+        assert_eq!(tag_layout.size, tag_val.layout.size);\n+        assert_eq!(tag_layout.abi.is_signed(), tag_val.layout.abi.is_signed());\n+        let tag_val = tag_val.to_scalar()?;\n+        trace!(\"tag value: {:?}\", tag_val);\n+\n+        // Figure out which discriminant and variant this corresponds to.\n+        Ok(match *tag_kind {\n             DiscriminantKind::Tag => {\n-                let bits_discr = raw_discr\n-                    .not_undef()\n-                    .and_then(|raw_discr| self.force_bits(raw_discr, discr_val.layout.size))\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n-                let real_discr = if discr_val.layout.abi.is_signed() {\n-                    // going from layout tag type to typeck discriminant type\n-                    // requires first sign extending with the discriminant layout\n-                    let sexted = sign_extend(bits_discr, discr_val.layout.size);\n-                    // and then zeroing with the typeck discriminant type\n-                    let discr_ty = rval\n-                        .layout\n-                        .ty\n-                        .ty_adt_def()\n-                        .expect(\"tagged layout corresponds to adt\")\n-                        .repr\n-                        .discr_type();\n-                    let size = Integer::from_attr(self, discr_ty).size();\n-                    truncate(sexted, size)\n-                } else {\n-                    bits_discr\n-                };\n-                // Make sure we catch invalid discriminants\n-                let index = match rval.layout.ty.kind {\n+                let tag_bits = self\n+                    .force_bits(tag_val, tag_layout.size)\n+                    .map_err(|_| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                // Cast bits from tag layout to discriminant layout.\n+                let discr_val_cast = self.cast_from_scalar(tag_bits, tag_layout, discr_layout.ty);\n+                let discr_bits = discr_val_cast.assert_bits(discr_layout.size);\n+                // Convert discriminant to variant index, and catch invalid discriminants.\n+                let index = match op.layout.ty.kind {\n                     ty::Adt(adt, _) => {\n-                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == real_discr)\n+                        adt.discriminants(self.tcx.tcx).find(|(_, var)| var.val == discr_bits)\n                     }\n                     ty::Generator(def_id, substs, _) => {\n                         let substs = substs.as_generator();\n                         substs\n                             .discriminants(def_id, self.tcx.tcx)\n-                            .find(|(_, var)| var.val == real_discr)\n+                            .find(|(_, var)| var.val == discr_bits)\n                     }\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n                 }\n-                .ok_or_else(|| err_ub!(InvalidDiscriminant(raw_discr.erase_tag())))?;\n-                (real_discr, index.0)\n+                .ok_or_else(|| err_ub!(InvalidDiscriminant(tag_val.erase_tag())))?;\n+                // Return the cast value, and the index.\n+                (discr_val_cast, index.0)\n             }\n             DiscriminantKind::Niche { dataful_variant, ref niche_variants, niche_start } => {\n+                // Compute the variant this niche value/\"tag\" corresponds to. With niche layout,\n+                // discriminant (encoded in niche/tag) and variant index are the same.\n                 let variants_start = niche_variants.start().as_u32();\n                 let variants_end = niche_variants.end().as_u32();\n-                let raw_discr = raw_discr\n-                    .not_undef()\n-                    .map_err(|_| err_ub!(InvalidDiscriminant(ScalarMaybeUninit::Uninit)))?;\n-                match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n+                let variant = match tag_val.to_bits_or_ptr(tag_layout.size, self) {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0\n                             && variants_start == variants_end\n                             && !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            throw_ub!(InvalidDiscriminant(raw_discr.erase_tag().into()))\n+                            throw_ub!(InvalidDiscriminant(tag_val.erase_tag()))\n                         }\n-                        (u128::from(dataful_variant.as_u32()), dataful_variant)\n+                        dataful_variant\n                     }\n-                    Ok(raw_discr) => {\n+                    Ok(tag_bits) => {\n                         // We need to use machine arithmetic to get the relative variant idx:\n-                        // variant_index_relative = discr_val - niche_start_val\n-                        let discr_layout =\n-                            self.layout_of(discr_layout.value.to_int_ty(*self.tcx))?;\n-                        let discr_val = ImmTy::from_uint(raw_discr, discr_layout);\n-                        let niche_start_val = ImmTy::from_uint(niche_start, discr_layout);\n+                        // variant_index_relative = tag_val - niche_start_val\n+                        let tag_val = ImmTy::from_uint(tag_bits, tag_layout);\n+                        let niche_start_val = ImmTy::from_uint(niche_start, tag_layout);\n                         let variant_index_relative_val =\n-                            self.binary_op(mir::BinOp::Sub, discr_val, niche_start_val)?;\n+                            self.binary_op(mir::BinOp::Sub, tag_val, niche_start_val)?;\n                         let variant_index_relative = variant_index_relative_val\n                             .to_scalar()?\n-                            .assert_bits(discr_val.layout.size);\n+                            .assert_bits(tag_val.layout.size);\n                         // Check if this is in the range that indicates an actual discriminant.\n                         if variant_index_relative <= u128::from(variants_end - variants_start) {\n                             let variant_index_relative = u32::try_from(variant_index_relative)\n@@ -676,20 +699,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             let variant_index = variants_start\n                                 .checked_add(variant_index_relative)\n                                 .expect(\"overflow computing absolute variant idx\");\n-                            let variants_len = rval\n+                            let variants_len = op\n                                 .layout\n                                 .ty\n                                 .ty_adt_def()\n                                 .expect(\"tagged layout for non adt\")\n                                 .variants\n                                 .len();\n                             assert!(usize::try_from(variant_index).unwrap() < variants_len);\n-                            (u128::from(variant_index), VariantIdx::from_u32(variant_index))\n+                            VariantIdx::from_u32(variant_index)\n                         } else {\n-                            (u128::from(dataful_variant.as_u32()), dataful_variant)\n+                            dataful_variant\n                         }\n                     }\n-                }\n+                };\n+                // Compute the size of the scalar we need to return.\n+                // No need to cast, because the variant index directly serves as discriminant and is\n+                // encoded in the tag.\n+                (Scalar::from_uint(variant.as_u32(), discr_layout.size), variant)\n             }\n         })\n     }"}, {"sha": "3f0800b12b5498a56e2e10fb1d129051d247a5ec", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=a5fb7fcab376c0d21173f33ceefc4f69998f8964", "patch": "@@ -638,6 +638,14 @@ where\n         }\n \n         self.dump_place(place_ty.place);\n+        // Sanity-check the type we ended up with.\n+        debug_assert!(mir_assign_valid_types(\n+            *self.tcx,\n+            self.layout_of(self.subst_from_current_frame_and_normalize_erasing_regions(\n+                place.ty(&self.frame().body.local_decls, *self.tcx).ty\n+            ))?,\n+            place_ty.layout,\n+        ));\n         Ok(place_ty)\n     }\n "}, {"sha": "bd4df788057e248939d2fa49d1425e7c149aa722", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5fb7fcab376c0d21173f33ceefc4f69998f8964/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=a5fb7fcab376c0d21173f33ceefc4f69998f8964", "patch": "@@ -262,8 +262,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Discriminant(place) => {\n                 let op = self.eval_place_to_op(place, None)?;\n                 let discr_val = self.read_discriminant(op)?.0;\n-                let size = dest.layout.size;\n-                self.write_scalar(Scalar::from_uint(discr_val, size), dest)?;\n+                self.write_scalar(discr_val, dest)?;\n             }\n         }\n "}]}