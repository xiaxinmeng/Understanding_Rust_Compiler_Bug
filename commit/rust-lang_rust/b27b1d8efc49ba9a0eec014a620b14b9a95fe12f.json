{"sha": "b27b1d8efc49ba9a0eec014a620b14b9a95fe12f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyN2IxZDhlZmM0OWJhOWEwZWVjMDE0YTYyMGIxNGI5YTk1ZmUxMmY=", "commit": {"author": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2020-01-03T21:49:41Z"}, "committer": {"name": "Nikita Popov", "email": "nikita.ppv@gmail.com", "date": "2020-01-07T20:28:22Z"}, "message": "Remove legacy debuginfo tests\n\nThese are no longer relevant, as our minimum supported version\nis LLVM 7.", "tree": {"sha": "2d6612df39d2b4ae6a90ce52652cf423c7334de7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d6612df39d2b4ae6a90ce52652cf423c7334de7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b27b1d8efc49ba9a0eec014a620b14b9a95fe12f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b27b1d8efc49ba9a0eec014a620b14b9a95fe12f", "html_url": "https://github.com/rust-lang/rust/commit/b27b1d8efc49ba9a0eec014a620b14b9a95fe12f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b27b1d8efc49ba9a0eec014a620b14b9a95fe12f/comments", "author": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikic", "id": 216080, "node_id": "MDQ6VXNlcjIxNjA4MA==", "avatar_url": "https://avatars.githubusercontent.com/u/216080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikic", "html_url": "https://github.com/nikic", "followers_url": "https://api.github.com/users/nikic/followers", "following_url": "https://api.github.com/users/nikic/following{/other_user}", "gists_url": "https://api.github.com/users/nikic/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikic/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikic/subscriptions", "organizations_url": "https://api.github.com/users/nikic/orgs", "repos_url": "https://api.github.com/users/nikic/repos", "events_url": "https://api.github.com/users/nikic/events{/privacy}", "received_events_url": "https://api.github.com/users/nikic/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "00daf2dabc00646ebf92b6b9007558d6f67fb85a", "url": "https://api.github.com/repos/rust-lang/rust/commits/00daf2dabc00646ebf92b6b9007558d6f67fb85a", "html_url": "https://github.com/rust-lang/rust/commit/00daf2dabc00646ebf92b6b9007558d6f67fb85a"}], "stats": {"total": 916, "additions": 0, "deletions": 916}, "files": [{"sha": "9a973ed74e8672548296b47857770d3768527985", "filename": "src/test/debuginfo/borrowed-enum-legacy.rs", "status": "removed", "additions": 0, "deletions": 84, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fborrowed-enum-legacy.rs?ref=00daf2dabc00646ebf92b6b9007558d6f67fb85a", "patch": "@@ -1,84 +0,0 @@\n-// ignore-tidy-linelength\n-// min-lldb-version: 310\n-\n-// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n-// enum debuginfo fallback mode.  Once those are desupported, this\n-// test can be removed, as there is another (non-\"legacy\") test that\n-// tests the new mode.\n-// ignore-llvm-version: 7.0 - 9.9.9\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n-// ignore-gdb-version: 8.2 - 9.9\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:run\n-\n-// gdb-command:print *the_a_ref\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n-// gdbr-check:$1 = borrowed_enum_legacy::ABC::TheA{x: 0, y: 8970181431921507452}\n-\n-// gdb-command:print *the_b_ref\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n-// gdbr-check:$2 = borrowed_enum_legacy::ABC::TheB(0, 286331153, 286331153)\n-\n-// gdb-command:print *univariant_ref\n-// gdbg-check:$3 = {{__0 = 4820353753753434}}\n-// gdbr-check:$3 = borrowed_enum_legacy::Univariant::TheOnlyCase(4820353753753434)\n-\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:run\n-\n-// lldb-command:print *the_a_ref\n-// lldbg-check:[...]$0 = TheA { x: 0, y: 8970181431921507452 }\n-// lldbr-check:(borrowed_enum_legacy::ABC::TheA) *the_a_ref = TheA { borrowed_enum_legacy::ABC::TheA: 0, borrowed_enum_legacy::ABC::TheB: 8970181431921507452 }\n-// lldb-command:print *the_b_ref\n-// lldbg-check:[...]$1 = TheB(0, 286331153, 286331153)\n-// lldbr-check:(borrowed_enum_legacy::ABC::TheB) *the_b_ref = { = 0 = 286331153 = 286331153 }\n-// lldb-command:print *univariant_ref\n-// lldbg-check:[...]$2 = TheOnlyCase(4820353753753434)\n-// lldbr-check:(borrowed_enum_legacy::Univariant) *univariant_ref = { borrowed_enum_legacy::TheOnlyCase = { = 4820353753753434 } }\n-\n-#![allow(unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n-// the size of the discriminant value is machine dependent, this has be taken into account when\n-// datatype layout should be predictable as in this case.\n-enum ABC {\n-    TheA { x: i64, y: i64 },\n-    TheB (i64, i32, i32),\n-}\n-\n-// This is a special case since it does not have the implicit discriminant field.\n-enum Univariant {\n-    TheOnlyCase(i64)\n-}\n-\n-fn main() {\n-\n-    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n-    // 0b01111100011111000111110001111100 = 2088533116\n-    // 0b0111110001111100 = 31868\n-    // 0b01111100 = 124\n-    let the_a = ABC::TheA { x: 0, y: 8970181431921507452 };\n-    let the_a_ref: &ABC = &the_a;\n-\n-    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n-    // 0b00010001000100010001000100010001 = 286331153\n-    // 0b0001000100010001 = 4369\n-    // 0b00010001 = 17\n-    let the_b = ABC::TheB (0, 286331153, 286331153);\n-    let the_b_ref: &ABC = &the_b;\n-\n-    let univariant = Univariant::TheOnlyCase(4820353753753434);\n-    let univariant_ref: &Univariant = &univariant;\n-\n-    zzz(); // #break\n-}\n-\n-fn zzz() {()}"}, {"sha": "4f17e48c6a437a2022a9902dc754ef4555485868", "filename": "src/test/debuginfo/generic-enum-with-different-disr-sizes-legacy.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-enum-with-different-disr-sizes-legacy.rs?ref=00daf2dabc00646ebf92b6b9007558d6f67fb85a", "patch": "@@ -1,105 +0,0 @@\n-// ignore-tidy-linelength\n-// ignore-lldb: FIXME(#27089)\n-// min-lldb-version: 310\n-\n-// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n-// enum debuginfo fallback mode.  Once those are desupported, this\n-// test can be removed, as there is another (non-\"legacy\") test that\n-// tests the new mode.\n-// ignore-llvm-version: 7.0 - 9.9.9\n-// ignore-gdb-version: 8.2 - 9.9\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-// gdb-command:run\n-\n-// gdb-command:print eight_bytes1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Variant1, __0 = 100}, {RUST$ENUM$DISR = Variant1, __0 = 100}}\n-// gdbr-check:$1 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(100)\n-\n-// gdb-command:print four_bytes1\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Variant1, __0 = 101}, {RUST$ENUM$DISR = Variant1, __0 = 101}}\n-// gdbr-check:$2 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(101)\n-\n-// gdb-command:print two_bytes1\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Variant1, __0 = 102}, {RUST$ENUM$DISR = Variant1, __0 = 102}}\n-// gdbr-check:$3 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(102)\n-\n-// gdb-command:print one_byte1\n-// gdbg-check:$4 = {{RUST$ENUM$DISR = Variant1, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant1, __0 = 65 'A'}}\n-// gdbr-check:$4 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant1(65)\n-\n-\n-// gdb-command:print eight_bytes2\n-// gdbg-check:$5 = {{RUST$ENUM$DISR = Variant2, __0 = 100}, {RUST$ENUM$DISR = Variant2, __0 = 100}}\n-// gdbr-check:$5 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(100)\n-\n-// gdb-command:print four_bytes2\n-// gdbg-check:$6 = {{RUST$ENUM$DISR = Variant2, __0 = 101}, {RUST$ENUM$DISR = Variant2, __0 = 101}}\n-// gdbr-check:$6 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(101)\n-\n-// gdb-command:print two_bytes2\n-// gdbg-check:$7 = {{RUST$ENUM$DISR = Variant2, __0 = 102}, {RUST$ENUM$DISR = Variant2, __0 = 102}}\n-// gdbr-check:$7 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(102)\n-\n-// gdb-command:print one_byte2\n-// gdbg-check:$8 = {{RUST$ENUM$DISR = Variant2, __0 = 65 'A'}, {RUST$ENUM$DISR = Variant2, __0 = 65 'A'}}\n-// gdbr-check:$8 = generic_enum_with_different_disr_sizes_legacy::Enum::Variant2(65)\n-\n-// gdb-command:continue\n-\n-// === LLDB TESTS ==================================================================================\n-// lldb-command:run\n-\n-// lldb-command:print eight_bytes1\n-// lldb-check:[...]$0 = Variant1(100)\n-// lldb-command:print four_bytes1\n-// lldb-check:[...]$1 = Variant1(101)\n-// lldb-command:print two_bytes1\n-// lldb-check:[...]$2 = Variant1(102)\n-// lldb-command:print one_byte1\n-// lldb-check:[...]$3 = Variant1('A')\n-\n-// lldb-command:print eight_bytes2\n-// lldb-check:[...]$4 = Variant2(100)\n-// lldb-command:print four_bytes2\n-// lldb-check:[...]$5 = Variant2(101)\n-// lldb-command:print two_bytes2\n-// lldb-check:[...]$6 = Variant2(102)\n-// lldb-command:print one_byte2\n-// lldb-check:[...]$7 = Variant2('A')\n-\n-// lldb-command:continue\n-\n-#![allow(unused_variables)]\n-#![allow(dead_code)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-// This test case makes sure that we get correct type descriptions for the enum\n-// discriminant of different instantiations of the same generic enum type where,\n-// dependending on the generic type parameter(s), the discriminant has a\n-// different size in memory.\n-\n-enum Enum<T> {\n-    Variant1(T),\n-    Variant2(T)\n-}\n-\n-fn main() {\n-    // These are ordered for descending size on purpose\n-    let eight_bytes1 = Enum::Variant1(100.0f64);\n-    let four_bytes1 = Enum::Variant1(101i32);\n-    let two_bytes1 = Enum::Variant1(102i16);\n-    let one_byte1 = Enum::Variant1(65u8);\n-\n-    let eight_bytes2 = Enum::Variant2(100.0f64);\n-    let four_bytes2 = Enum::Variant2(101i32);\n-    let two_bytes2 = Enum::Variant2(102i16);\n-    let one_byte2 = Enum::Variant2(65u8);\n-\n-    zzz(); // #break\n-}\n-\n-fn zzz() { () }"}, {"sha": "37a875a4188c16fbb92b8c5da8fa044c68fc4812", "filename": "src/test/debuginfo/generic-struct-style-enum-legacy.rs", "status": "removed", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-struct-style-enum-legacy.rs?ref=00daf2dabc00646ebf92b6b9007558d6f67fb85a", "patch": "@@ -1,86 +0,0 @@\n-// ignore-tidy-linelength\n-// min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n-\n-// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n-// enum debuginfo fallback mode.  Once those are desupported, this\n-// test can be removed, as there is another (non-\"legacy\") test that\n-// tests the new mode.\n-// ignore-llvm-version: 7.0 - 9.9.9\n-// ignore-gdb-version: 8.2 - 9.9\n-\n-// compile-flags:-g\n-\n-// gdb-command:set print union on\n-// gdb-command:run\n-\n-// gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n-// gdbr-check:$1 = generic_struct_style_enum_legacy::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n-\n-// gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n-// gdbr-check:$2 = generic_struct_style_enum_legacy::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n-\n-// gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n-// gdbr-check:$3 = generic_struct_style_enum_legacy::Regular::Case3{a: 0, b: 6438275382588823897}\n-\n-// gdb-command:print univariant\n-// gdbg-check:$4 = {{a = -1}}\n-// gdbr-check:$4 = generic_struct_style_enum_legacy::Univariant<i32>::TheOnlyCase{a: -1}\n-\n-\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-use self::Regular::{Case1, Case2, Case3};\n-use self::Univariant::TheOnlyCase;\n-\n-// NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be\n-// substituted with something of size `xx` bits and the same alignment as an integer type of the\n-// same size.\n-\n-// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n-// the size of the discriminant value is machine dependent, this has be taken into account when\n-// datatype layout should be predictable as in this case.\n-enum Regular<T16, T32, T64> {\n-    Case1 { a: T64, b: T16, c: T16, d: T16, e: T16},\n-    Case2 { a: T64, b: T32, c: T32},\n-    Case3 { a: T64, b: T64 }\n-}\n-\n-enum Univariant<T> {\n-    TheOnlyCase { a: T }\n-}\n-\n-fn main() {\n-\n-    // In order to avoid endianness trouble all of the following test values consist of a single\n-    // repeated byte. This way each interpretation of the union should look the same, no matter if\n-    // this is a big or little endian machine.\n-\n-    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n-    // 0b01111100011111000111110001111100 = 2088533116\n-    // 0b0111110001111100 = 31868\n-    // 0b01111100 = 124\n-    let case1: Regular<u16, u32, i64> = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 };\n-\n-    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n-    // 0b00010001000100010001000100010001 = 286331153\n-    // 0b0001000100010001 = 4369\n-    // 0b00010001 = 17\n-    let case2: Regular<i16, u32, i64>  = Case2 { a: 0, b: 286331153, c: 286331153 };\n-\n-    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n-    // 0b01011001010110010101100101011001 = 1499027801\n-    // 0b0101100101011001 = 22873\n-    // 0b01011001 = 89\n-    let case3: Regular<u16, i32, u64>  = Case3 { a: 0, b: 6438275382588823897 };\n-\n-    let univariant = TheOnlyCase { a: -1 };\n-\n-    zzz(); // #break\n-}\n-\n-fn zzz() {()}"}, {"sha": "452e90008ea6020eea7a0e2f1abfb3bbe1c564df", "filename": "src/test/debuginfo/generic-tuple-style-enum-legacy.rs", "status": "removed", "additions": 0, "deletions": 108, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fgeneric-tuple-style-enum-legacy.rs?ref=00daf2dabc00646ebf92b6b9007558d6f67fb85a", "patch": "@@ -1,108 +0,0 @@\n-// ignore-tidy-linelength\n-// min-lldb-version: 310\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n-\n-// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n-// enum debuginfo fallback mode.  Once those are desupported, this\n-// test can be removed, as there is another (non-\"legacy\") test that\n-// tests the new mode.\n-// ignore-llvm-version: 7.0 - 9.9.9\n-// ignore-gdb-version: 8.2 - 9.9\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:set print union on\n-// gdb-command:run\n-\n-// gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n-// gdbr-check:$1 = generic_tuple_style_enum_legacy::Regular::Case1(0, 31868, 31868, 31868, 31868)\n-\n-// gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n-// gdbr-check:$2 = generic_tuple_style_enum_legacy::Regular::Case2(0, 286331153, 286331153)\n-\n-// gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n-// gdbr-check:$3 = generic_tuple_style_enum_legacy::Regular::Case3(0, 6438275382588823897)\n-\n-// gdb-command:print univariant\n-// gdbg-check:$4 = {{__0 = -1}}\n-// gdbr-check:$4 = generic_tuple_style_enum_legacy::Univariant<i64>::TheOnlyCase(-1)\n-\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:run\n-\n-// lldb-command:print case1\n-// lldbg-check:[...]$0 = Case1(0, 31868, 31868, 31868, 31868)\n-// lldbr-check:(generic_tuple_style_enum_legacy::Regular<u16, u32, u64>::Case1) case1 = { = 0 = 31868 = 31868 = 31868 = 31868 }\n-\n-// lldb-command:print case2\n-// lldbg-check:[...]$1 = Case2(0, 286331153, 286331153)\n-// lldbr-check:(generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2) case2 = Regular<i16, i32, i64>::Case2 { generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case1: 0, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2: 286331153, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case3: 286331153 }\n-\n-// lldb-command:print case3\n-// lldbg-check:[...]$2 = Case3(0, 6438275382588823897)\n-// lldbr-check:(generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case3) case3 = Regular<i16, i32, i64>::Case3 { generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case1: 0, generic_tuple_style_enum_legacy::Regular<i16, i32, i64>::Case2: 6438275382588823897 }\n-\n-// lldb-command:print univariant\n-// lldbg-check:[...]$3 = TheOnlyCase(-1)\n-// lldbr-check:(generic_tuple_style_enum_legacy::Univariant<i64>) univariant = { generic_tuple_style_enum_legacy::TheOnlyCase = { = -1 } }\n-\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-use self::Regular::{Case1, Case2, Case3};\n-use self::Univariant::TheOnlyCase;\n-\n-// NOTE: This is a copy of the non-generic test case. The `Txx` type parameters have to be\n-// substituted with something of size `xx` bits and the same alignment as an integer type of the\n-// same size.\n-\n-// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n-// the size of the discriminant value is machine dependent, this has be taken into account when\n-// datatype layout should be predictable as in this case.\n-enum Regular<T16, T32, T64> {\n-    Case1(T64, T16, T16, T16, T16),\n-    Case2(T64, T32, T32),\n-    Case3(T64, T64)\n-}\n-\n-enum Univariant<T64> {\n-    TheOnlyCase(T64)\n-}\n-\n-fn main() {\n-\n-    // In order to avoid endianness trouble all of the following test values consist of a single\n-    // repeated byte. This way each interpretation of the union should look the same, no matter if\n-    // this is a big or little endian machine.\n-\n-    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n-    // 0b01111100011111000111110001111100 = 2088533116\n-    // 0b0111110001111100 = 31868\n-    // 0b01111100 = 124\n-    let case1: Regular<u16, u32, u64> = Case1(0_u64, 31868_u16, 31868_u16, 31868_u16, 31868_u16);\n-\n-    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n-    // 0b00010001000100010001000100010001 = 286331153\n-    // 0b0001000100010001 = 4369\n-    // 0b00010001 = 17\n-    let case2: Regular<i16, i32, i64> = Case2(0_i64, 286331153_i32, 286331153_i32);\n-\n-    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n-    // 0b01011001010110010101100101011001 = 1499027801\n-    // 0b0101100101011001 = 22873\n-    // 0b01011001 = 89\n-    let case3: Regular<i16, i32, i64> = Case3(0_i64, 6438275382588823897_i64);\n-\n-    let univariant = TheOnlyCase(-1_i64);\n-\n-    zzz(); // #break\n-}\n-\n-fn zzz() { () }"}, {"sha": "99286708ae24321bbdb67db3f35ada6d79e9172e", "filename": "src/test/debuginfo/recursive-struct-legacy.rs", "status": "removed", "additions": 0, "deletions": 235, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Frecursive-struct-legacy.rs?ref=00daf2dabc00646ebf92b6b9007558d6f67fb85a", "patch": "@@ -1,235 +0,0 @@\n-// ignore-tidy-linelength\n-// ignore-lldb\n-\n-// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n-// enum debuginfo fallback mode.  Once those are desupported, this\n-// test can be removed, as there is another (non-\"legacy\") test that\n-// tests the new mode.\n-// ignore-llvm-version: 7.0 - 9.9.9\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n-// ignore-gdb-version: 8.2 - 9.9\n-\n-// compile-flags:-g\n-\n-// gdb-command:run\n-\n-// gdb-command:print stack_unique.value\n-// gdb-check:$1 = 0\n-// gdbg-command:print stack_unique.next.RUST$ENCODED$ENUM$0$Empty.val->value\n-// gdbr-command:print stack_unique.next.val.value\n-// gdb-check:$2 = 1\n-\n-// gdbg-command:print unique_unique->value\n-// gdbr-command:print unique_unique.value\n-// gdb-check:$3 = 2\n-// gdbg-command:print unique_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n-// gdbr-command:print unique_unique.next.val.value\n-// gdb-check:$4 = 3\n-\n-// gdb-command:print vec_unique[0].value\n-// gdb-check:$5 = 6.5\n-// gdbg-command:print vec_unique[0].next.RUST$ENCODED$ENUM$0$Empty.val->value\n-// gdbr-command:print vec_unique[0].next.val.value\n-// gdb-check:$6 = 7.5\n-\n-// gdbg-command:print borrowed_unique->value\n-// gdbr-command:print borrowed_unique.value\n-// gdb-check:$7 = 8.5\n-// gdbg-command:print borrowed_unique->next.RUST$ENCODED$ENUM$0$Empty.val->value\n-// gdbr-command:print borrowed_unique.next.val.value\n-// gdb-check:$8 = 9.5\n-\n-// LONG CYCLE\n-// gdb-command:print long_cycle1.value\n-// gdb-check:$9 = 20\n-// gdbg-command:print long_cycle1.next->value\n-// gdbr-command:print long_cycle1.next.value\n-// gdb-check:$10 = 21\n-// gdbg-command:print long_cycle1.next->next->value\n-// gdbr-command:print long_cycle1.next.next.value\n-// gdb-check:$11 = 22\n-// gdbg-command:print long_cycle1.next->next->next->value\n-// gdbr-command:print long_cycle1.next.next.next.value\n-// gdb-check:$12 = 23\n-\n-// gdb-command:print long_cycle2.value\n-// gdb-check:$13 = 24\n-// gdbg-command:print long_cycle2.next->value\n-// gdbr-command:print long_cycle2.next.value\n-// gdb-check:$14 = 25\n-// gdbg-command:print long_cycle2.next->next->value\n-// gdbr-command:print long_cycle2.next.next.value\n-// gdb-check:$15 = 26\n-\n-// gdb-command:print long_cycle3.value\n-// gdb-check:$16 = 27\n-// gdbg-command:print long_cycle3.next->value\n-// gdbr-command:print long_cycle3.next.value\n-// gdb-check:$17 = 28\n-\n-// gdb-command:print long_cycle4.value\n-// gdb-check:$18 = 29.5\n-\n-// gdbg-command:print (*****long_cycle_w_anonymous_types).value\n-// gdbr-command:print long_cycle_w_anonymous_types.value\n-// gdb-check:$19 = 30\n-\n-// gdbg-command:print (*****((*****long_cycle_w_anonymous_types).next.RUST$ENCODED$ENUM$0$Empty.val)).value\n-// gdbr-command:print long_cycle_w_anonymous_types.next.val.value\n-// gdb-check:$20 = 31\n-\n-// gdb-command:continue\n-\n-#![allow(unused_variables)]\n-#![feature(box_syntax)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-use self::Opt::{Empty, Val};\n-\n-enum Opt<T> {\n-    Empty,\n-    Val { val: T }\n-}\n-\n-struct UniqueNode<T> {\n-    next: Opt<Box<UniqueNode<T>>>,\n-    value: T\n-}\n-\n-struct LongCycle1<T> {\n-    next: Box<LongCycle2<T>>,\n-    value: T,\n-}\n-\n-struct LongCycle2<T> {\n-    next: Box<LongCycle3<T>>,\n-    value: T,\n-}\n-\n-struct LongCycle3<T> {\n-    next: Box<LongCycle4<T>>,\n-    value: T,\n-}\n-\n-struct LongCycle4<T> {\n-    next: Option<Box<LongCycle1<T>>>,\n-    value: T,\n-}\n-\n-struct LongCycleWithAnonymousTypes {\n-    next: Opt<Box<Box<Box<Box<Box<LongCycleWithAnonymousTypes>>>>>>,\n-    value: usize,\n-}\n-\n-// This test case makes sure that recursive structs are properly described. The Node structs are\n-// generic so that we can have a new type (that newly needs to be described) for the different\n-// cases. The potential problem with recursive types is that the DI generation algorithm gets\n-// trapped in an endless loop. To make sure, we actually test this in the different cases, we have\n-// to operate on a new type each time, otherwise we would just hit the DI cache for all but the\n-// first case.\n-\n-// The different cases below (stack_*, unique_*, box_*, etc) are set up so that the type description\n-// algorithm will enter the type reference cycle that is created by a recursive definition from a\n-// different context each time.\n-\n-// The \"long cycle\" cases are constructed to span a longer, indirect recursion cycle between types.\n-// The different locals will cause the DI algorithm to enter the type reference cycle at different\n-// points.\n-\n-fn main() {\n-    let stack_unique: UniqueNode<u16> = UniqueNode {\n-        next: Val {\n-            val: box UniqueNode {\n-                next: Empty,\n-                value: 1,\n-            }\n-        },\n-        value: 0,\n-    };\n-\n-    let unique_unique: Box<UniqueNode<u32>> = box UniqueNode {\n-        next: Val {\n-            val: box UniqueNode {\n-                next: Empty,\n-                value: 3,\n-            }\n-        },\n-        value: 2,\n-    };\n-\n-    let vec_unique: [UniqueNode<f32>; 1] = [UniqueNode {\n-        next: Val {\n-            val: box UniqueNode {\n-                next: Empty,\n-                value: 7.5,\n-            }\n-        },\n-        value: 6.5,\n-    }];\n-\n-    let borrowed_unique: &UniqueNode<f64> = &UniqueNode {\n-        next: Val {\n-            val: box UniqueNode {\n-                next: Empty,\n-                value: 9.5,\n-            }\n-        },\n-        value: 8.5,\n-    };\n-\n-    // LONG CYCLE\n-    let long_cycle1: LongCycle1<u16> = LongCycle1 {\n-        next: box LongCycle2 {\n-            next: box LongCycle3 {\n-                next: box LongCycle4 {\n-                    next: None,\n-                    value: 23,\n-                },\n-                value: 22,\n-            },\n-            value: 21\n-        },\n-        value: 20\n-    };\n-\n-    let long_cycle2: LongCycle2<u32> = LongCycle2 {\n-        next: box LongCycle3 {\n-            next: box LongCycle4 {\n-                next: None,\n-                value: 26,\n-            },\n-            value: 25,\n-        },\n-        value: 24\n-    };\n-\n-    let long_cycle3: LongCycle3<u64> = LongCycle3 {\n-        next: box LongCycle4 {\n-            next: None,\n-            value: 28,\n-        },\n-        value: 27,\n-    };\n-\n-    let long_cycle4: LongCycle4<f32> = LongCycle4 {\n-        next: None,\n-        value: 29.5,\n-    };\n-\n-    // It's important that LongCycleWithAnonymousTypes is encountered only at the end of the\n-    // `box` chain.\n-    let long_cycle_w_anonymous_types = box box box box box LongCycleWithAnonymousTypes {\n-        next: Val {\n-            val: box box box box box LongCycleWithAnonymousTypes {\n-                next: Empty,\n-                value: 31,\n-            }\n-        },\n-        value: 30\n-    };\n-\n-    zzz(); // #break\n-}\n-\n-fn zzz() {()}"}, {"sha": "1433493fd5d0f87b18984779f4e4a3caf1ecf448", "filename": "src/test/debuginfo/struct-style-enum-legacy.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fstruct-style-enum-legacy.rs?ref=00daf2dabc00646ebf92b6b9007558d6f67fb85a", "patch": "@@ -1,105 +0,0 @@\n-// ignore-tidy-linelength\n-// min-lldb-version: 310\n-\n-// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n-// enum debuginfo fallback mode.  Once those are desupported, this\n-// test can be removed, as there is another (non-\"legacy\") test that\n-// tests the new mode.\n-// ignore-llvm-version: 7.0 - 9.9.9\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n-// ignore-gdb-version: 8.2 - 9.9\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:set print union on\n-// gdb-command:run\n-\n-// gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, a = 0, b = 31868, c = 31868, d = 31868, e = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n-// gdbr-check:$1 = struct_style_enum_legacy::Regular::Case1{a: 0, b: 31868, c: 31868, d: 31868, e: 31868}\n-\n-// gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, a = 0, b = 286331153, c = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n-// gdbr-check:$2 = struct_style_enum_legacy::Regular::Case2{a: 0, b: 286331153, c: 286331153}\n-\n-// gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, a = 0, b = 6438275382588823897}}\n-// gdbr-check:$3 = struct_style_enum_legacy::Regular::Case3{a: 0, b: 6438275382588823897}\n-\n-// gdb-command:print univariant\n-// gdbg-check:$4 = {{a = -1}}\n-// gdbr-check:$4 = struct_style_enum_legacy::Univariant::TheOnlyCase{a: -1}\n-\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:run\n-\n-// lldb-command:print case1\n-// lldbg-check:[...]$0 = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 }\n-// lldbr-check:(struct_style_enum_legacy::Regular::Case1) case1 = { a = 0 b = 31868 c = 31868 d = 31868 e = 31868 }\n-\n-// lldb-command:print case2\n-// lldbg-check:[...]$1 = Case2 { a: 0, b: 286331153, c: 286331153 }\n-// lldbr-check:(struct_style_enum_legacy::Regular::Case2) case2 = Case2 { struct_style_enum_legacy::Regular::Case1: 0, struct_style_enum_legacy::Regular::Case2: 286331153, struct_style_enum_legacy::Regular::Case3: 286331153 }\n-\n-// lldb-command:print case3\n-// lldbg-check:[...]$2 = Case3 { a: 0, b: 6438275382588823897 }\n-// lldbr-check:(struct_style_enum_legacy::Regular::Case3) case3 = Case3 { struct_style_enum_legacy::Regular::Case1: 0, struct_style_enum_legacy::Regular::Case2: 6438275382588823897 }\n-\n-// lldb-command:print univariant\n-// lldbg-check:[...]$3 = TheOnlyCase { a: -1 }\n-// lldbr-check:(struct_style_enum_legacy::Univariant) univariant = Univariant { struct_style_enum_legacy::TheOnlyCase: TheOnlyCase { a: -1 } }\n-\n-#![allow(unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-use self::Regular::{Case1, Case2, Case3};\n-use self::Univariant::TheOnlyCase;\n-\n-// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n-// the size of the discriminant value is machine dependent, this has be taken into account when\n-// datatype layout should be predictable as in this case.\n-enum Regular {\n-    Case1 { a: u64, b: u16, c: u16, d: u16, e: u16},\n-    Case2 { a: u64, b: u32, c: u32},\n-    Case3 { a: u64, b: u64 }\n-}\n-\n-enum Univariant {\n-    TheOnlyCase { a: i64 }\n-}\n-\n-fn main() {\n-\n-    // In order to avoid endianness trouble all of the following test values consist of a single\n-    // repeated byte. This way each interpretation of the union should look the same, no matter if\n-    // this is a big or little endian machine.\n-\n-    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n-    // 0b01111100011111000111110001111100 = 2088533116\n-    // 0b0111110001111100 = 31868\n-    // 0b01111100 = 124\n-    let case1 = Case1 { a: 0, b: 31868, c: 31868, d: 31868, e: 31868 };\n-\n-    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n-    // 0b00010001000100010001000100010001 = 286331153\n-    // 0b0001000100010001 = 4369\n-    // 0b00010001 = 17\n-    let case2 = Case2 { a: 0, b: 286331153, c: 286331153 };\n-\n-    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n-    // 0b01011001010110010101100101011001 = 1499027801\n-    // 0b0101100101011001 = 22873\n-    // 0b01011001 = 89\n-    let case3 = Case3 { a: 0, b: 6438275382588823897 };\n-\n-    let univariant = TheOnlyCase { a: -1 };\n-\n-    zzz(); // #break\n-}\n-\n-fn zzz() {()}"}, {"sha": "ebc8e03443881a581e58a76611c9bd7f06795a78", "filename": "src/test/debuginfo/tuple-style-enum-legacy.rs", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Ftuple-style-enum-legacy.rs?ref=00daf2dabc00646ebf92b6b9007558d6f67fb85a", "patch": "@@ -1,105 +0,0 @@\n-// ignore-tidy-linelength\n-// min-lldb-version: 310\n-\n-// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n-// enum debuginfo fallback mode.  Once those are desupported, this\n-// test can be removed, as there is another (non-\"legacy\") test that\n-// tests the new mode.\n-// ignore-llvm-version: 7.0 - 9.9.9\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n-// ignore-gdb-version: 8.2 - 9.9\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:set print union on\n-// gdb-command:run\n-\n-// gdb-command:print case1\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = Case1, __0 = 0, __1 = 31868, __2 = 31868, __3 = 31868, __4 = 31868}, {RUST$ENUM$DISR = Case1, [...]}, {RUST$ENUM$DISR = Case1, [...]}}\n-// gdbr-check:$1 = tuple_style_enum_legacy::Regular::Case1(0, 31868, 31868, 31868, 31868)\n-\n-// gdb-command:print case2\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = Case2, [...]}, {RUST$ENUM$DISR = Case2, __0 = 0, __1 = 286331153, __2 = 286331153}, {RUST$ENUM$DISR = Case2, [...]}}\n-// gdbr-check:$2 = tuple_style_enum_legacy::Regular::Case2(0, 286331153, 286331153)\n-\n-// gdb-command:print case3\n-// gdbg-check:$3 = {{RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, [...]}, {RUST$ENUM$DISR = Case3, __0 = 0, __1 = 6438275382588823897}}\n-// gdbr-check:$3 = tuple_style_enum_legacy::Regular::Case3(0, 6438275382588823897)\n-\n-// gdb-command:print univariant\n-// gdbg-check:$4 = {{__0 = -1}}\n-// gdbr-check:$4 = tuple_style_enum_legacy::Univariant::TheOnlyCase(-1)\n-\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:run\n-\n-// lldb-command:print case1\n-// lldbg-check:[...]$0 = Case1(0, 31868, 31868, 31868, 31868)\n-// lldbr-check:(tuple_style_enum_legacy::Regular::Case1) case1 = { = 0 = 31868 = 31868 = 31868 = 31868 }\n-\n-// lldb-command:print case2\n-// lldbg-check:[...]$1 = Case2(0, 286331153, 286331153)\n-// lldbr-check:(tuple_style_enum_legacy::Regular::Case2) case2 = Case2 { tuple_style_enum_legacy::Regular::Case1: 0, tuple_style_enum_legacy::Regular::Case2: 286331153, tuple_style_enum_legacy::Regular::Case3: 286331153 }\n-\n-// lldb-command:print case3\n-// lldbg-check:[...]$2 = Case3(0, 6438275382588823897)\n-// lldbr-check:(tuple_style_enum_legacy::Regular::Case3) case3 = Case3 { tuple_style_enum_legacy::Regular::Case1: 0, tuple_style_enum_legacy::Regular::Case2: 6438275382588823897 }\n-\n-// lldb-command:print univariant\n-// lldbg-check:[...]$3 = TheOnlyCase(-1)\n-// lldbr-check:(tuple_style_enum_legacy::Univariant) univariant = { tuple_style_enum_legacy::TheOnlyCase = { = -1 } }\n-\n-#![allow(unused_variables)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-use self::Regular::{Case1, Case2, Case3};\n-use self::Univariant::TheOnlyCase;\n-\n-// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n-// the size of the discriminant value is machine dependent, this has be taken into account when\n-// datatype layout should be predictable as in this case.\n-enum Regular {\n-    Case1(u64, u16, u16, u16, u16),\n-    Case2(u64, u32, u32),\n-    Case3(u64, u64)\n-}\n-\n-enum Univariant {\n-    TheOnlyCase(i64)\n-}\n-\n-fn main() {\n-\n-    // In order to avoid endianness trouble all of the following test values consist of a single\n-    // repeated byte. This way each interpretation of the union should look the same, no matter if\n-    // this is a big or little endian machine.\n-\n-    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n-    // 0b01111100011111000111110001111100 = 2088533116\n-    // 0b0111110001111100 = 31868\n-    // 0b01111100 = 124\n-    let case1 = Case1(0, 31868, 31868, 31868, 31868);\n-\n-    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n-    // 0b00010001000100010001000100010001 = 286331153\n-    // 0b0001000100010001 = 4369\n-    // 0b00010001 = 17\n-    let case2 = Case2(0, 286331153, 286331153);\n-\n-    // 0b0101100101011001010110010101100101011001010110010101100101011001 = 6438275382588823897\n-    // 0b01011001010110010101100101011001 = 1499027801\n-    // 0b0101100101011001 = 22873\n-    // 0b01011001 = 89\n-    let case3 = Case3(0, 6438275382588823897);\n-\n-    let univariant = TheOnlyCase(-1);\n-\n-    zzz(); // #break\n-}\n-\n-fn zzz() {()}"}, {"sha": "e7c9357752897d09ca2aec003711445af08065c2", "filename": "src/test/debuginfo/unique-enum-legacy.rs", "status": "removed", "additions": 0, "deletions": 88, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/00daf2dabc00646ebf92b6b9007558d6f67fb85a/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Funique-enum-legacy.rs?ref=00daf2dabc00646ebf92b6b9007558d6f67fb85a", "patch": "@@ -1,88 +0,0 @@\n-// ignore-tidy-linelength\n-// min-lldb-version: 310\n-\n-// As long as LLVM 5 and LLVM 6 are supported, we want to test the\n-// enum debuginfo fallback mode.  Once those are desupported, this\n-// test can be removed, as there is another (non-\"legacy\") test that\n-// tests the new mode.\n-// ignore-llvm-version: 7.0 - 9.9.9\n-// ignore-gdb-version: 7.11.90 - 7.12.9\n-// ignore-gdb-version: 8.2 - 9.9\n-\n-// compile-flags:-g\n-\n-// === GDB TESTS ===================================================================================\n-\n-// gdb-command:run\n-\n-// gdb-command:print *the_a\n-// gdbg-check:$1 = {{RUST$ENUM$DISR = TheA, x = 0, y = 8970181431921507452}, {RUST$ENUM$DISR = TheA, [...]}}\n-// gdbr-check:$1 = unique_enum_legacy::ABC::TheA{x: 0, y: 8970181431921507452}\n-\n-// gdb-command:print *the_b\n-// gdbg-check:$2 = {{RUST$ENUM$DISR = TheB, [...]}, {RUST$ENUM$DISR = TheB, __0 = 0, __1 = 286331153, __2 = 286331153}}\n-// gdbr-check:$2 = unique_enum_legacy::ABC::TheB(0, 286331153, 286331153)\n-\n-// gdb-command:print *univariant\n-// gdbg-check:$3 = {{__0 = 123234}}\n-// gdbr-check:$3 = unique_enum_legacy::Univariant::TheOnlyCase(123234)\n-\n-\n-// === LLDB TESTS ==================================================================================\n-\n-// lldb-command:run\n-\n-// lldb-command:print *the_a\n-// lldbg-check:[...]$0 = TheA { x: 0, y: 8970181431921507452 }\n-// lldbr-check:(unique_enum_legacy::ABC::TheA) *the_a = TheA { unique_enum_legacy::ABC::TheA: 0, unique_enum_legacy::ABC::TheB: 8970181431921507452 }\n-\n-// lldb-command:print *the_b\n-// lldbg-check:[...]$1 = TheB(0, 286331153, 286331153)\n-// lldbr-check:(unique_enum_legacy::ABC::TheB) *the_b = { = 0 = 286331153 = 286331153 }\n-\n-// lldb-command:print *univariant\n-// lldbg-check:[...]$2 = TheOnlyCase(123234)\n-// lldbr-check:(unique_enum_legacy::Univariant) *univariant = { unique_enum_legacy::TheOnlyCase = { = 123234 } }\n-\n-#![allow(unused_variables)]\n-#![feature(box_syntax)]\n-#![feature(omit_gdb_pretty_printer_section)]\n-#![omit_gdb_pretty_printer_section]\n-\n-// The first element is to ensure proper alignment, irrespective of the machines word size. Since\n-// the size of the discriminant value is machine dependent, this has be taken into account when\n-// datatype layout should be predictable as in this case.\n-enum ABC {\n-    TheA { x: i64, y: i64 },\n-    TheB (i64, i32, i32),\n-}\n-\n-// This is a special case since it does not have the implicit discriminant field.\n-enum Univariant {\n-    TheOnlyCase(i64)\n-}\n-\n-fn main() {\n-\n-    // In order to avoid endianness trouble all of the following test values consist of a single\n-    // repeated byte. This way each interpretation of the union should look the same, no matter if\n-    // this is a big or little endian machine.\n-\n-    // 0b0111110001111100011111000111110001111100011111000111110001111100 = 8970181431921507452\n-    // 0b01111100011111000111110001111100 = 2088533116\n-    // 0b0111110001111100 = 31868\n-    // 0b01111100 = 124\n-    let the_a: Box<_> = box ABC::TheA { x: 0, y: 8970181431921507452 };\n-\n-    // 0b0001000100010001000100010001000100010001000100010001000100010001 = 1229782938247303441\n-    // 0b00010001000100010001000100010001 = 286331153\n-    // 0b0001000100010001 = 4369\n-    // 0b00010001 = 17\n-    let the_b: Box<_> = box ABC::TheB (0, 286331153, 286331153);\n-\n-    let univariant: Box<_> = box Univariant::TheOnlyCase(123234);\n-\n-    zzz(); // #break\n-}\n-\n-fn zzz() {()}"}]}