{"sha": "4ac14f9e63ba71e7f15204f9cff208f022563996", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYzE0ZjllNjNiYTcxZTdmMTUyMDRmOWNmZjIwOGYwMjI1NjM5OTY=", "commit": {"author": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-02-17T15:34:35Z"}, "committer": {"name": "Cameron Steffen", "email": "cam.steffen94@gmail.com", "date": "2021-02-17T16:47:26Z"}, "message": "Teach SpanlessEq binding IDs", "tree": {"sha": "7aa875d1a39482d643b14c1ce54e86f9b2408e41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7aa875d1a39482d643b14c1ce54e86f9b2408e41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4ac14f9e63ba71e7f15204f9cff208f022563996", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4ac14f9e63ba71e7f15204f9cff208f022563996", "html_url": "https://github.com/rust-lang/rust/commit/4ac14f9e63ba71e7f15204f9cff208f022563996", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4ac14f9e63ba71e7f15204f9cff208f022563996/comments", "author": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "camsteffen", "id": 5565418, "node_id": "MDQ6VXNlcjU1NjU0MTg=", "avatar_url": "https://avatars.githubusercontent.com/u/5565418?v=4", "gravatar_id": "", "url": "https://api.github.com/users/camsteffen", "html_url": "https://github.com/camsteffen", "followers_url": "https://api.github.com/users/camsteffen/followers", "following_url": "https://api.github.com/users/camsteffen/following{/other_user}", "gists_url": "https://api.github.com/users/camsteffen/gists{/gist_id}", "starred_url": "https://api.github.com/users/camsteffen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/camsteffen/subscriptions", "organizations_url": "https://api.github.com/users/camsteffen/orgs", "repos_url": "https://api.github.com/users/camsteffen/repos", "events_url": "https://api.github.com/users/camsteffen/events{/privacy}", "received_events_url": "https://api.github.com/users/camsteffen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa", "html_url": "https://github.com/rust-lang/rust/commit/e2753f9a7bcfcedaad7dcf78eba6ccfe14f2a3aa"}], "stats": {"total": 152, "additions": 102, "deletions": 50}, "files": [{"sha": "0a9719901f06486beee9a94c74bb0119489cc6d9", "filename": "clippy_lints/src/utils/hir_utils.rs", "status": "modified", "additions": 89, "deletions": 45, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/4ac14f9e63ba71e7f15204f9cff208f022563996/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac14f9e63ba71e7f15204f9cff208f022563996/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhir_utils.rs?ref=4ac14f9e63ba71e7f15204f9cff208f022563996", "patch": "@@ -1,10 +1,12 @@\n use crate::consts::{constant_context, constant_simple};\n use crate::utils::differing_macro_contexts;\n use rustc_ast::ast::InlineAsmTemplatePiece;\n+use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_hir::def::Res;\n use rustc_hir::{\n     BinOpKind, Block, BlockCheckMode, BodyId, BorrowKind, CaptureBy, Expr, ExprKind, Field, FieldPat, FnRetTy,\n-    GenericArg, GenericArgs, Guard, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n+    GenericArg, GenericArgs, Guard, HirId, InlineAsmOperand, Lifetime, LifetimeName, ParamName, Pat, PatKind, Path,\n     PathSegment, QPath, Stmt, StmtKind, Ty, TyKind, TypeBinding,\n };\n use rustc_lint::LateContext;\n@@ -52,8 +54,47 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         }\n     }\n \n-    /// Checks whether two statements are the same.\n-    pub fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n+    /// Use this method to wrap comparisons that may involve inter-expression context.\n+    /// See `self.locals`.\n+    fn inter_expr(&mut self) -> HirEqInterExpr<'_, 'a, 'tcx> {\n+        HirEqInterExpr {\n+            inner: self,\n+            locals: FxHashMap::default(),\n+        }\n+    }\n+\n+    pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n+        self.inter_expr().eq_block(left, right)\n+    }\n+\n+    pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+        self.inter_expr().eq_expr(left, right)\n+    }\n+\n+    pub fn eq_path_segment(&mut self, left: &PathSegment<'_>, right: &PathSegment<'_>) -> bool {\n+        self.inter_expr().eq_path_segment(left, right)\n+    }\n+\n+    pub fn eq_path_segments(&mut self, left: &[PathSegment<'_>], right: &[PathSegment<'_>]) -> bool {\n+        self.inter_expr().eq_path_segments(left, right)\n+    }\n+\n+    pub fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n+        self.inter_expr().eq_ty_kind(left, right)\n+    }\n+}\n+\n+struct HirEqInterExpr<'a, 'b, 'tcx> {\n+    inner: &'a mut SpanlessEq<'b, 'tcx>,\n+\n+    // When binding are declared, the binding ID in the left expression is mapped to the one on the\n+    // right. For example, when comparing `{ let x = 1; x + 2 }` and `{ let y = 1; y + 2 }`,\n+    // these blocks are considered equal since `x` is mapped to `y`.\n+    locals: FxHashMap<HirId, HirId>,\n+}\n+\n+impl HirEqInterExpr<'_, '_, '_> {\n+    fn eq_stmt(&mut self, left: &Stmt<'_>, right: &Stmt<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&StmtKind::Local(ref l), &StmtKind::Local(ref r)) => {\n                 self.eq_pat(&l.pat, &r.pat)\n@@ -68,21 +109,21 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     /// Checks whether two blocks are the same.\n-    pub fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n+    fn eq_block(&mut self, left: &Block<'_>, right: &Block<'_>) -> bool {\n         over(&left.stmts, &right.stmts, |l, r| self.eq_stmt(l, r))\n             && both(&left.expr, &right.expr, |l, r| self.eq_expr(l, r))\n     }\n \n     #[allow(clippy::similar_names)]\n-    pub fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n-        if !self.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n+    fn eq_expr(&mut self, left: &Expr<'_>, right: &Expr<'_>) -> bool {\n+        if !self.inner.allow_side_effects && differing_macro_contexts(left.span, right.span) {\n             return false;\n         }\n \n-        if let Some(typeck_results) = self.maybe_typeck_results {\n+        if let Some(typeck_results) = self.inner.maybe_typeck_results {\n             if let (Some(l), Some(r)) = (\n-                constant_simple(self.cx, typeck_results, left),\n-                constant_simple(self.cx, typeck_results, right),\n+                constant_simple(self.inner.cx, typeck_results, left),\n+                constant_simple(self.inner.cx, typeck_results, right),\n             ) {\n                 if l == r {\n                     return true;\n@@ -98,10 +139,10 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 both(&li.label, &ri.label, |l, r| l.ident.name == r.ident.name)\n             },\n             (&ExprKind::Assign(ref ll, ref lr, _), &ExprKind::Assign(ref rl, ref rr, _)) => {\n-                self.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.inner.allow_side_effects && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::AssignOp(ref lo, ref ll, ref lr), &ExprKind::AssignOp(ref ro, ref rl, ref rr)) => {\n-                self.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n+                self.inner.allow_side_effects && lo.node == ro.node && self.eq_expr(ll, rl) && self.eq_expr(lr, rr)\n             },\n             (&ExprKind::Block(ref l, _), &ExprKind::Block(ref r, _)) => self.eq_block(l, r),\n             (&ExprKind::Binary(l_op, ref ll, ref lr), &ExprKind::Binary(r_op, ref rl, ref rr)) => {\n@@ -116,7 +157,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             },\n             (&ExprKind::Box(ref l), &ExprKind::Box(ref r)) => self.eq_expr(l, r),\n             (&ExprKind::Call(l_fun, l_args), &ExprKind::Call(r_fun, r_args)) => {\n-                self.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n+                self.inner.allow_side_effects && self.eq_expr(l_fun, r_fun) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Cast(ref lx, ref lt), &ExprKind::Cast(ref rx, ref rt))\n             | (&ExprKind::Type(ref lx, ref lt), &ExprKind::Type(ref rx, ref rt)) => {\n@@ -139,19 +180,19 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n                 ls == rs\n                     && self.eq_expr(le, re)\n                     && over(la, ra, |l, r| {\n-                        self.eq_expr(&l.body, &r.body)\n+                        self.eq_pat(&l.pat, &r.pat)\n                             && both(&l.guard, &r.guard, |l, r| self.eq_guard(l, r))\n-                            && self.eq_pat(&l.pat, &r.pat)\n+                            && self.eq_expr(&l.body, &r.body)\n                     })\n             },\n             (&ExprKind::MethodCall(l_path, _, l_args, _), &ExprKind::MethodCall(r_path, _, r_args, _)) => {\n-                self.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n+                self.inner.allow_side_effects && self.eq_path_segment(l_path, r_path) && self.eq_exprs(l_args, r_args)\n             },\n             (&ExprKind::Repeat(ref le, ref ll_id), &ExprKind::Repeat(ref re, ref rl_id)) => {\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n-                let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n-                let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n+                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(ll_id.body));\n+                let ll = celcx.expr(&self.inner.cx.tcx.hir().body(ll_id.body).value);\n+                let mut celcx = constant_context(self.inner.cx, self.inner.cx.tcx.typeck_body(rl_id.body));\n+                let rl = celcx.expr(&self.inner.cx.tcx.hir().body(rl_id.body).value);\n \n                 self.eq_expr(le, re) && ll == rl\n             },\n@@ -168,7 +209,7 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&ExprKind::DropTemps(ref le), &ExprKind::DropTemps(ref re)) => self.eq_expr(le, re),\n             _ => false,\n         };\n-        is_eq || self.expr_fallback.as_ref().map_or(false, |f| f(left, right))\n+        is_eq || self.inner.expr_fallback.as_ref().map_or(false, |f| f(left, right))\n     }\n \n     fn eq_exprs(&mut self, left: &[Expr<'_>], right: &[Expr<'_>]) -> bool {\n@@ -199,13 +240,13 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         left.name == right.name\n     }\n \n-    pub fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n+    fn eq_fieldpat(&mut self, left: &FieldPat<'_>, right: &FieldPat<'_>) -> bool {\n         let (FieldPat { ident: li, pat: lp, .. }, FieldPat { ident: ri, pat: rp, .. }) = (&left, &right);\n         li.name == ri.name && self.eq_pat(lp, rp)\n     }\n \n     /// Checks whether two patterns are the same.\n-    pub fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n+    fn eq_pat(&mut self, left: &Pat<'_>, right: &Pat<'_>) -> bool {\n         match (&left.kind, &right.kind) {\n             (&PatKind::Box(ref l), &PatKind::Box(ref r)) => self.eq_pat(l, r),\n             (&PatKind::Struct(ref lp, ref la, ..), &PatKind::Struct(ref rp, ref ra, ..)) => {\n@@ -214,8 +255,12 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n             (&PatKind::TupleStruct(ref lp, ref la, ls), &PatKind::TupleStruct(ref rp, ref ra, rs)) => {\n                 self.eq_qpath(lp, rp) && over(la, ra, |l, r| self.eq_pat(l, r)) && ls == rs\n             },\n-            (&PatKind::Binding(ref lb, .., ref li, ref lp), &PatKind::Binding(ref rb, .., ref ri, ref rp)) => {\n-                lb == rb && li.name == ri.name && both(lp, rp, |l, r| self.eq_pat(l, r))\n+            (&PatKind::Binding(lb, li, _, ref lp), &PatKind::Binding(rb, ri, _, ref rp)) => {\n+                let eq = lb == rb && both(lp, rp, |l, r| self.eq_pat(l, r));\n+                if eq {\n+                    self.locals.insert(li, ri);\n+                }\n+                eq\n             },\n             (&PatKind::Path(ref l), &PatKind::Path(ref r)) => self.eq_qpath(l, r),\n             (&PatKind::Lit(ref l), &PatKind::Lit(ref r)) => self.eq_expr(l, r),\n@@ -251,8 +296,11 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n     }\n \n     fn eq_path(&mut self, left: &Path<'_>, right: &Path<'_>) -> bool {\n-        left.is_global() == right.is_global()\n-            && over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r))\n+        match (left.res, right.res) {\n+            (Res::Local(l), Res::Local(r)) => l == r || self.locals.get(&l) == Some(&r),\n+            (Res::Local(_), _) | (_, Res::Local(_)) => false,\n+            _ => over(&left.segments, &right.segments, |l, r| self.eq_path_segment(l, r)),\n+        }\n     }\n \n     fn eq_path_parameters(&mut self, left: &GenericArgs<'_>, right: &GenericArgs<'_>) -> bool {\n@@ -279,28 +327,19 @@ impl<'a, 'tcx> SpanlessEq<'a, 'tcx> {\n         left.ident.name == right.ident.name && both(&left.args, &right.args, |l, r| self.eq_path_parameters(l, r))\n     }\n \n-    pub fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n+    fn eq_ty(&mut self, left: &Ty<'_>, right: &Ty<'_>) -> bool {\n         self.eq_ty_kind(&left.kind, &right.kind)\n     }\n \n     #[allow(clippy::similar_names)]\n-    pub fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n+    fn eq_ty_kind(&mut self, left: &TyKind<'_>, right: &TyKind<'_>) -> bool {\n         match (left, right) {\n             (&TyKind::Slice(ref l_vec), &TyKind::Slice(ref r_vec)) => self.eq_ty(l_vec, r_vec),\n             (&TyKind::Array(ref lt, ref ll_id), &TyKind::Array(ref rt, ref rl_id)) => {\n-                let old_maybe_typeck_results = self.maybe_typeck_results;\n-\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(ll_id.body));\n-                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(ll_id.body));\n-                let ll = celcx.expr(&self.cx.tcx.hir().body(ll_id.body).value);\n-\n-                let mut celcx = constant_context(self.cx, self.cx.tcx.typeck_body(rl_id.body));\n-                self.maybe_typeck_results = Some(self.cx.tcx.typeck_body(rl_id.body));\n-                let rl = celcx.expr(&self.cx.tcx.hir().body(rl_id.body).value);\n-\n-                let eq_ty = self.eq_ty(lt, rt);\n-                self.maybe_typeck_results = old_maybe_typeck_results;\n-                eq_ty && ll == rl\n+                let cx = self.inner.cx;\n+                let eval_const =\n+                    |body| constant_context(cx, cx.tcx.typeck_body(body)).expr(&cx.tcx.hir().body(body).value);\n+                self.eq_ty(lt, rt) && eval_const(ll_id.body) == eval_const(rl_id.body)\n             },\n             (&TyKind::Ptr(ref l_mut), &TyKind::Ptr(ref r_mut)) => {\n                 l_mut.mutbl == r_mut.mutbl && self.eq_ty(&*l_mut.ty, &*r_mut.ty)\n@@ -667,10 +706,15 @@ impl<'a, 'tcx> SpanlessHash<'a, 'tcx> {\n         // self.maybe_typeck_results.unwrap().qpath_res(p, id).hash(&mut self.s);\n     }\n \n-    pub fn hash_path(&mut self, p: &Path<'_>) {\n-        p.is_global().hash(&mut self.s);\n-        for p in p.segments {\n-            self.hash_name(p.ident.name);\n+    pub fn hash_path(&mut self, path: &Path<'_>) {\n+        match path.res {\n+            // constant hash since equality is dependant on inter-expression context\n+            Res::Local(_) => 1_usize.hash(&mut self.s),\n+            _ => {\n+                for seg in path.segments {\n+                    self.hash_name(seg.ident.name);\n+                }\n+            },\n         }\n     }\n "}, {"sha": "55467cf4229de4b9e5607d003a93f010bfd9eefd", "filename": "tests/ui/collapsible_match.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4ac14f9e63ba71e7f15204f9cff208f022563996/tests%2Fui%2Fcollapsible_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac14f9e63ba71e7f15204f9cff208f022563996/tests%2Fui%2Fcollapsible_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fcollapsible_match.rs?ref=4ac14f9e63ba71e7f15204f9cff208f022563996", "patch": "@@ -232,6 +232,14 @@ fn negative_cases(res_opt: Result<Option<u32>, String>, res_res: Result<Result<u\n             };\n         }\n     }\n+    let _: &dyn std::any::Any = match &Some(Some(1)) {\n+        Some(e) => match e {\n+            Some(e) => e,\n+            e => e,\n+        },\n+        // else branch looks the same but the binding is different\n+        e => e,\n+    };\n }\n \n fn make<T>() -> T {"}, {"sha": "a2ff1b741ca25e5699ff8d9f2453325ed7e4b9f0", "filename": "tests/ui/if_same_then_else2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4ac14f9e63ba71e7f15204f9cff208f022563996/tests%2Fui%2Fif_same_then_else2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4ac14f9e63ba71e7f15204f9cff208f022563996/tests%2Fui%2Fif_same_then_else2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.rs?ref=4ac14f9e63ba71e7f15204f9cff208f022563996", "patch": "@@ -12,7 +12,7 @@ fn if_same_then_else2() -> Result<&'static str, ()> {\n     if true {\n         for _ in &[42] {\n             let foo: &Option<_> = &Some::<u8>(42);\n-            if true {\n+            if foo.is_some() {\n                 break;\n             } else {\n                 continue;\n@@ -21,8 +21,8 @@ fn if_same_then_else2() -> Result<&'static str, ()> {\n     } else {\n         //~ ERROR same body as `if` block\n         for _ in &[42] {\n-            let foo: &Option<_> = &Some::<u8>(42);\n-            if true {\n+            let bar: &Option<_> = &Some::<u8>(42);\n+            if bar.is_some() {\n                 break;\n             } else {\n                 continue;"}, {"sha": "454322d8aacda727b2a8efead93c70cc554ed772", "filename": "tests/ui/if_same_then_else2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4ac14f9e63ba71e7f15204f9cff208f022563996/tests%2Fui%2Fif_same_then_else2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4ac14f9e63ba71e7f15204f9cff208f022563996/tests%2Fui%2Fif_same_then_else2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fif_same_then_else2.stderr?ref=4ac14f9e63ba71e7f15204f9cff208f022563996", "patch": "@@ -5,7 +5,7 @@ LL |       } else {\n    |  ____________^\n LL | |         //~ ERROR same body as `if` block\n LL | |         for _ in &[42] {\n-LL | |             let foo: &Option<_> = &Some::<u8>(42);\n+LL | |             let bar: &Option<_> = &Some::<u8>(42);\n ...  |\n LL | |         }\n LL | |     }\n@@ -19,7 +19,7 @@ LL |       if true {\n    |  _____________^\n LL | |         for _ in &[42] {\n LL | |             let foo: &Option<_> = &Some::<u8>(42);\n-LL | |             if true {\n+LL | |             if foo.is_some() {\n ...  |\n LL | |         }\n LL | |     } else {"}]}