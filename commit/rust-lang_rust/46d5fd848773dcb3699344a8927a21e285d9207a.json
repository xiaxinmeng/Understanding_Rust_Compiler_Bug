{"sha": "46d5fd848773dcb3699344a8927a21e285d9207a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ2ZDVmZDg0ODc3M2RjYjM2OTkzNDRhODkyN2EyMWUyODVkOTIwN2E=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-17T12:57:13Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-04-17T14:02:57Z"}, "message": "barriers are dead, long live protectors -- this enables overlapping two-phase borrows!", "tree": {"sha": "c00142639f8a239785357a02ed0a0ca957d7616b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c00142639f8a239785357a02ed0a0ca957d7616b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/46d5fd848773dcb3699344a8927a21e285d9207a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/46d5fd848773dcb3699344a8927a21e285d9207a", "html_url": "https://github.com/rust-lang/rust/commit/46d5fd848773dcb3699344a8927a21e285d9207a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/46d5fd848773dcb3699344a8927a21e285d9207a/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e7a500b7e112be64e90517316a527e3a4a239437", "url": "https://api.github.com/repos/rust-lang/rust/commits/e7a500b7e112be64e90517316a527e3a4a239437", "html_url": "https://github.com/rust-lang/rust/commit/e7a500b7e112be64e90517316a527e3a4a239437"}], "stats": {"total": 282, "additions": 120, "deletions": 162}, "files": [{"sha": "98b6ca6543f23ba6eeac419db6a7e564b9759ff8", "filename": "src/stacked_borrows.rs", "status": "modified", "additions": 107, "deletions": 148, "changes": 255, "blob_url": "https://github.com/rust-lang/rust/blob/46d5fd848773dcb3699344a8927a21e285d9207a/src%2Fstacked_borrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d5fd848773dcb3699344a8927a21e285d9207a/src%2Fstacked_borrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows.rs?ref=46d5fd848773dcb3699344a8927a21e285d9207a", "patch": "@@ -15,7 +15,7 @@ use crate::{\n };\n \n pub type PtrId = NonZeroU64;\n-pub type CallId = u64;\n+pub type CallId = NonZeroU64;\n \n /// Tracking pointer provenance\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -46,19 +46,23 @@ pub enum Permission {\n \n /// An item in the per-location borrow stack.\n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n-pub enum Item {\n-    /// Grants the given permission for pointers with this tag.\n-    Permission(Permission, Tag),\n-    /// A barrier, tracking the function it belongs to by its index on the call stack.\n-    FnBarrier(CallId),\n+pub struct Item {\n+    /// The permission this item grants.\n+    perm: Permission,\n+    /// The pointers the permission is granted to.\n+    tag: Tag,\n+    /// An optional protector, ensuring the item cannot get popped until `CallId` is over.\n+    protector: Option<CallId>,\n }\n \n impl fmt::Display for Item {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self {\n-            Item::Permission(perm, tag) => write!(f, \"[{:?} for {}]\", perm, tag),\n-            Item::FnBarrier(call) => write!(f, \"[barrier {}]\", call),\n+        write!(f, \"[{:?} for {}\", self.perm, self.tag)?;\n+        if let Some(call) = self.protector {\n+            write!(f, \" (call {})\", call)?;\n         }\n+        write!(f, \"]\")?;\n+        Ok(())\n     }\n }\n \n@@ -69,7 +73,7 @@ pub struct Stack {\n     /// We sometimes push into the middle but never remove from the middle.\n     /// The same tag may occur multiple times, e.g. from a two-phase borrow.\n     /// Invariants:\n-    /// * Above a `SharedReadOnly` there can only be barriers and more `SharedReadOnly`.\n+    /// * Above a `SharedReadOnly` there can only be more `SharedReadOnly`.\n     borrows: Vec<Item>,\n }\n \n@@ -137,7 +141,7 @@ impl Default for GlobalState {\n     fn default() -> Self {\n         GlobalState {\n             next_ptr_id: NonZeroU64::new(1).unwrap(),\n-            next_call_id: 0,\n+            next_call_id: NonZeroU64::new(1).unwrap(),\n             active_calls: HashSet::default(),\n         }\n     }\n@@ -154,7 +158,7 @@ impl GlobalState {\n         let id = self.next_call_id;\n         trace!(\"new_call: Assigning ID {}\", id);\n         self.active_calls.insert(id);\n-        self.next_call_id = id+1;\n+        self.next_call_id = NonZeroU64::new(id.get() + 1).unwrap();\n         id\n     }\n \n@@ -232,7 +236,7 @@ impl Permission {\n             // When we are unique and this is a write/dealloc, we tolerate nothing.\n             // This makes sure we re-assert uniqueness (\"being on top\") on write accesses.\n             // (This is particularily important such that when a new mutable ref gets created, it gets\n-            // pushed into the right item -- this behaves like a write and we assert uniqueness of the\n+            // pushed onto the right item -- this behaves like a write and we assert uniqueness of the\n             // pointer from which this comes, *if* it was a unique pointer.)\n             (Unique, AccessKind::Write, _) =>\n                 false,\n@@ -259,11 +263,13 @@ impl<'tcx> Stack {\n             .rev() // search top-to-bottom\n             // Return permission of first item that grants access.\n             // We require a permission with the right tag, ensuring U3 and F3.\n-            .filter_map(|(idx, item)| match item {\n-                &Item::Permission(perm, item_tag) if perm.grants(access) && tag == item_tag =>\n-                    Some((idx, perm)),\n-                _ => None,\n-            })\n+            .filter_map(|(idx, item)|\n+                if item.perm.grants(access) && tag == item.tag {\n+                    Some((idx, item.perm))\n+                } else {\n+                    None\n+                }\n+            )\n             .next()\n     }\n \n@@ -276,9 +282,6 @@ impl<'tcx> Stack {\n         global: &GlobalState,\n     ) -> EvalResult<'tcx, usize> {\n         // Two main steps: Find granting item, remove all incompatible items above.\n-        // The second step is where barriers get implemented: they \"protect\" the items\n-        // below them, meaning that if we remove an item and then further up encounter a barrier,\n-        // we raise an error.\n \n         // Step 1: Find granting item.\n         let (granting_idx, granting_perm) = self.find_granting(access, tag)\n@@ -287,47 +290,35 @@ impl<'tcx> Stack {\n                     access, tag,\n             )))?;\n \n-        // Step 2: Remove everything incompatible above them.\n-        // Items below an active barrier however may not be removed, so we check that as well.\n+        // Step 2: Remove everything incompatible above them.  Make sure we do not remove protected\n+        // items.\n         // We do *not* maintain a stack discipline here.  We could, in principle, decide to only\n         // keep the items immediately above `granting_idx` that are compatible, and then pop the rest.\n         // However, that kills off entire \"branches\" of pointer derivation too easily:\n         // in `let raw = &mut *x as *mut _; let _val = *x;`, the second statement would pop the `Unique`\n         // from the reborrow of the first statement, and subequently also pop the `SharedReadWrite` for `raw`.\n+        // This pattern occurs a lot in the standard library: create a raw pointer, then also create a shared\n+        // reference and use that.\n         {\n             // Implemented with indices because there does not seem to be a nice iterator and range-based\n             // API for this.\n             let mut cur = granting_idx + 1;\n-            let mut removed_item = None;\n             while let Some(item) = self.borrows.get(cur) {\n-                match *item {\n-                    Item::Permission(perm, _) => {\n-                        if granting_perm.compatible_with(access, perm) {\n-                            // Keep this, check next.\n-                            cur += 1;\n-                        } else {\n-                            // Aha! This is a bad one, remove it.\n-                            let item = self.borrows.remove(cur);\n-                            trace!(\"access: removing item {}\", item);\n-                            removed_item = Some(item);\n-                        }\n-                    }\n-                    Item::FnBarrier(call) if !global.is_active(call) => {\n-                        // An inactive barrier, just get rid of it. (Housekeeping.)\n-                        self.borrows.remove(cur);\n-                    }\n-                    Item::FnBarrier(call) => {\n-                        // We hit an active barrier!  If we have already removed an item,\n-                        // we got a problem!  The barrier was supposed to protect this item.\n-                        if let Some(removed_item) = removed_item {\n+                if granting_perm.compatible_with(access, item.perm) {\n+                    // Keep this, check next.\n+                    cur += 1;\n+                } else {\n+                    // Aha! This is a bad one, remove it, and make sure it is not protected.\n+                    let item = self.borrows.remove(cur);\n+                    if let Some(call) = item.protector {\n+                        if global.is_active(call) {\n                             return err!(MachineError(format!(\n-                                    \"not granting {} access to tag {} because barrier ({}) protects incompatible item {}\",\n-                                    access, tag, call, removed_item\n+                                    \"not granting {} access to tag {} because incompatible item {} is protected\",\n+                                    access, tag, item\n                                 )));\n                         }\n-                        // Keep this, check next.\n-                        cur += 1;\n                     }\n+                    trace!(\"access: removing item {}\", item);\n                 }\n             }\n         }\n@@ -337,7 +328,7 @@ impl<'tcx> Stack {\n     }\n \n     /// Deallocate a location: Like a write access, but also there must be no\n-    /// barriers at all.\n+    /// active protectors at all.\n     fn dealloc(\n         &mut self,\n         tag: Tag,\n@@ -350,80 +341,51 @@ impl<'tcx> Stack {\n                     tag,\n             )))?;\n \n-        // We must make sure there are no active barriers remaining on the stack.\n+        // We must make sure there are no protected items remaining on the stack.\n         // Also clear the stack, no more accesses are possible.\n-        while let Some(itm) = self.borrows.pop() {\n-            match itm {\n-                Item::FnBarrier(call) if global.is_active(call) => {\n+        while let Some(item) = self.borrows.pop() {\n+            if let Some(call) = item.protector {\n+                if global.is_active(call) {\n                     return err!(MachineError(format!(\n-                        \"deallocating with active barrier ({})\", call\n+                        \"deallocating with active protector ({})\", call\n                     )))\n                 }\n-                _ => {},\n             }\n         }\n \n         Ok(())\n     }\n \n-    /// `reborrow` helper function.\n-    /// Grant `permisson` to new pointer tagged `tag`, added at `position` in the stack.\n-    fn grant(&mut self, perm: Permission, tag: Tag, position: usize) {\n-        // Simply add it to the \"stack\" -- this might add in the middle.\n-        // As an optimization, do nothing if the new item is identical to one of its neighbors.\n-        let item = Item::Permission(perm, tag);\n-        if self.borrows[position-1] == item || self.borrows.get(position) == Some(&item) {\n-            // Optimization applies, done.\n-            trace!(\"reborrow: avoiding redundant item {}\", item);\n-            return;\n-        }\n-        trace!(\"reborrow: adding item {}\", item);\n-        self.borrows.insert(position, item);\n-    }\n-\n-    /// `reborrow` helper function.\n-    /// Adds a barrier.\n-    fn barrier(&mut self, call: CallId) {\n-        let itm = Item::FnBarrier(call);\n-        if *self.borrows.last().unwrap() == itm {\n-            // This is just an optimization, no functional change: Avoid stacking\n-            // multiple identical barriers on top of each other.\n-            // This can happen when a function receives several shared references\n-            // that overlap.\n-            trace!(\"reborrow: avoiding redundant extra barrier\");\n-        } else {\n-            trace!(\"reborrow: adding barrier for call {}\", call);\n-            self.borrows.push(itm);\n-        }\n-    }\n-\n     /// `reborrow` helper function: test that the stack invariants are still maintained.\n     fn test_invariants(&self) {\n         let mut saw_shared_read_only = false;\n         for item in self.borrows.iter() {\n-            match item {\n-                Item::Permission(Permission::SharedReadOnly, _) => {\n+            match item.perm {\n+                Permission::SharedReadOnly => {\n                     saw_shared_read_only = true;\n                 }\n-                Item::Permission(perm, _) if saw_shared_read_only => {\n-                    panic!(\"Found {:?} on top of a SharedReadOnly!\", perm);\n+                // Otherwise, if we saw one before, that's a bug.\n+                perm if saw_shared_read_only => {\n+                    bug!(\"Found {:?} on top of a SharedReadOnly!\", perm);\n                 }\n                 _ => {}\n             }\n         }\n     }\n \n     /// Derived a new pointer from one with the given tag.\n+    /// `weak` controls whether this is a weak reborrow: weak reborrows do not act as\n+    /// accesses, and they add the new item directly on top of the one it is derived\n+    /// from instead of all the way at the top of the stack.\n     fn reborrow(\n         &mut self,\n         derived_from: Tag,\n-        barrier: Option<CallId>,\n-        new_perm: Permission,\n-        new_tag: Tag,\n+        weak: bool,\n+        new: Item,\n         global: &GlobalState,\n     ) -> EvalResult<'tcx> {\n         // Figure out which access `perm` corresponds to.\n-        let access = if new_perm.grants(AccessKind::Write) {\n+        let access = if new.perm.grants(AccessKind::Write) {\n                 AccessKind::Write\n             } else {\n                 AccessKind::Read\n@@ -432,16 +394,13 @@ impl<'tcx> Stack {\n         // We use that to determine where to put the new item.\n         let (derived_from_idx, _) = self.find_granting(access, derived_from)\n             .ok_or_else(|| InterpError::MachineError(format!(\n-                    \"no item to reborrow for {:?} from tag {} found in borrow stack\", new_perm, derived_from,\n+                    \"no item to reborrow for {:?} from tag {} found in borrow stack\", new.perm, derived_from,\n             )))?;\n \n-        // We behave very differently for the \"unsafe\" case of a shared-read-write pointer\n-        // (\"unsafe\" because this also applies to shared references with interior mutability).\n-        // This is because such pointers may be reborrowed to unique pointers that actually\n-        // remain valid when their \"parents\" get further reborrows!\n-        // However, either way, we ensure that we insert the new item in a way that between\n+        // Compute where to put the new item.\n+        // Either way, we ensure that we insert the new item in a way that between\n         // `derived_from` and the new one, there are only items *compatible with* `derived_from`.\n-        if new_perm == Permission::SharedReadWrite {\n+        let new_idx = if weak {\n             // A very liberal reborrow because the new pointer does not expect any kind of aliasing guarantee.\n             // Just insert new permission as child of old permission, and maintain everything else.\n             // This inserts \"as far down as possible\", which is good because it makes this pointer as\n@@ -451,17 +410,7 @@ impl<'tcx> Stack {\n             // and we'd allow write access without invalidating frozen shared references!\n             // This ensures F2b for `SharedReadWrite` by adding the new item below any\n             // potentially existing `SharedReadOnly`.\n-            self.grant(new_perm, new_tag, derived_from_idx+1);\n-\n-            // No barrier. They can rightfully alias with `&mut`.\n-            // FIXME: This means that the `dereferencable` attribute on non-frozen shared references\n-            // is incorrect! They are dereferencable when the function is called, but might become\n-            // non-dereferencable during the course of execution.\n-            // Also see [1], [2].\n-            //\n-            // [1]: <https://internals.rust-lang.org/t/\n-            //       is-it-possible-to-be-memory-safe-with-deallocated-self/8457/8>,\n-            // [2]: <https://lists.llvm.org/pipermail/llvm-dev/2018-July/124555.html>\n+            derived_from_idx+1\n         } else {\n             // A \"safe\" reborrow for a pointer that actually expects some aliasing guarantees.\n             // Here, creating a reference actually counts as an access, and pops incompatible\n@@ -474,12 +423,16 @@ impl<'tcx> Stack {\n             // on top of `derived_from`, and we want the new item at the top so that we\n             // get the strongest possible guarantees.\n             // This ensures U1 and F1.\n-            self.grant(new_perm, new_tag, self.borrows.len());\n+            self.borrows.len()\n+        };\n \n-            // Now is a good time to add the barrier, protecting the item we just added.\n-            if let Some(call) = barrier {\n-                self.barrier(call);\n-            }\n+        // Put the new item there. As an optimization, deduplicate if it is equal to one of its new neighbors.\n+        if self.borrows[new_idx-1] == new || self.borrows.get(new_idx) == Some(&new) {\n+            // Optimization applies, done.\n+            trace!(\"reborrow: avoiding adding redundant item {}\", new);\n+        } else {\n+            trace!(\"reborrow: adding item {}\", new);\n+            self.borrows.insert(new_idx, new);\n         }\n \n         // Make sure that after all this, the stack's invariant is still maintained.\n@@ -500,7 +453,7 @@ impl<'tcx> Stacks {\n         tag: Tag,\n         extra: MemoryState,\n     ) -> Self {\n-        let item = Item::Permission(Permission::Unique, tag);\n+        let item = Item { perm: Permission::Unique, tag, protector: None };\n         let stack = Stack {\n             borrows: vec![item],\n         };\n@@ -515,12 +468,12 @@ impl<'tcx> Stacks {\n         &self,\n         ptr: Pointer<Tag>,\n         size: Size,\n-        f: impl Fn(&mut Stack, Tag, &GlobalState) -> EvalResult<'tcx>,\n+        f: impl Fn(&mut Stack, &GlobalState) -> EvalResult<'tcx>,\n     ) -> EvalResult<'tcx> {\n         let global = self.global.borrow();\n         let mut stacks = self.stacks.borrow_mut();\n         for stack in stacks.iter_mut(ptr.offset, size) {\n-            f(stack, ptr.tag, &*global)?;\n+            f(stack, &*global)?;\n         }\n         Ok(())\n     }\n@@ -562,8 +515,8 @@ impl AllocationExtra<Tag> for Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         trace!(\"read access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, tag, global| {\n-            stack.access(AccessKind::Read, tag, global)?;\n+        alloc.extra.for_each(ptr, size, |stack, global| {\n+            stack.access(AccessKind::Read, ptr.tag, global)?;\n             Ok(())\n         })\n     }\n@@ -575,8 +528,8 @@ impl AllocationExtra<Tag> for Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         trace!(\"write access with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, tag, global| {\n-            stack.access(AccessKind::Write, tag, global)?;\n+        alloc.extra.for_each(ptr, size, |stack, global| {\n+            stack.access(AccessKind::Write, ptr.tag, global)?;\n             Ok(())\n         })\n     }\n@@ -588,26 +541,28 @@ impl AllocationExtra<Tag> for Stacks {\n         size: Size,\n     ) -> EvalResult<'tcx> {\n         trace!(\"deallocation with tag {}: {:?}, size {}\", ptr.tag, ptr, size.bytes());\n-        alloc.extra.for_each(ptr, size, |stack, tag, global| {\n-            stack.dealloc(tag, global)\n+        alloc.extra.for_each(ptr, size, |stack, global| {\n+            stack.dealloc(ptr.tag, global)\n         })\n     }\n }\n \n+/// Retagging/reborrowing.  There is some policy in here, such as which permissions\n+/// to grant for which references, when to add protectors, and how to realize two-phase\n+/// borrows in terms of the primitives above.\n impl<'a, 'mir, 'tcx> EvalContextPrivExt<'a, 'mir, 'tcx> for crate::MiriEvalContext<'a, 'mir, 'tcx> {}\n trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a, 'mir, 'tcx> {\n-    /// High-level `reborrow` operation.  This decides which reference gets which kind\n-    /// of permission!\n     fn reborrow(\n         &mut self,\n         place: MPlaceTy<'tcx, Tag>,\n         size: Size,\n         kind: RefKind,\n         new_tag: Tag,\n-        fn_barrier: bool,\n+        force_weak: bool,\n+        protect: bool,\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n-        let barrier = if fn_barrier { Some(this.frame().extra) } else { None };\n+        let protector = if protect { Some(this.frame().extra) } else { None };\n         let ptr = place.ptr.to_ptr()?;\n         trace!(\"reborrow: {:?} reference {} derived from {} (pointee {}): {:?}, size {}\",\n             kind, new_tag, ptr.tag, place.layout.ty, ptr, size.bytes());\n@@ -616,6 +571,8 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         let alloc = this.memory().get(ptr.alloc_id)?;\n         alloc.check_bounds(this, ptr, size)?;\n         // Update the stacks.\n+        // Make sure that raw pointers and mutable shared references are reborrowed \"weak\":\n+        // There could be existing unique pointers reborrowed from them that should remain valid!\n         let perm = match kind {\n             RefKind::Unique => Permission::Unique,\n             RefKind::Raw { mutable: true } => Permission::SharedReadWrite,\n@@ -625,16 +582,20 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 // We need a frozen-sensitive reborrow.\n                 return this.visit_freeze_sensitive(place, size, |cur_ptr, size, frozen| {\n                     // We are only ever `SharedReadOnly` inside the frozen bits.\n+                    let weak = !frozen || kind != RefKind::Shared; // `RefKind::Raw` is always weak, as is `SharedReadWrite`.\n                     let perm = if frozen { Permission::SharedReadOnly } else { Permission::SharedReadWrite };\n-                    alloc.extra.for_each(cur_ptr, size, |stack, tag, global| {\n-                        stack.reborrow(tag, barrier, perm, new_tag, global)\n+                    let item = Item { perm, tag: new_tag, protector };\n+                    alloc.extra.for_each(cur_ptr, size, |stack, global| {\n+                        stack.reborrow(cur_ptr.tag, force_weak || weak, item, global)\n                     })\n                 });\n             }\n         };\n         debug_assert_ne!(perm, Permission::SharedReadOnly, \"SharedReadOnly must be used frozen-sensitive\");\n-        alloc.extra.for_each(ptr, size, |stack, tag, global| {\n-            stack.reborrow(tag, barrier, perm, new_tag, global)\n+        let weak = perm == Permission::SharedReadWrite;\n+        let item = Item { perm, tag: new_tag, protector };\n+        alloc.extra.for_each(ptr, size, |stack, global| {\n+            stack.reborrow(ptr.tag, force_weak || weak, item, global)\n         })\n     }\n \n@@ -644,7 +605,7 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         &mut self,\n         val: ImmTy<'tcx, Tag>,\n         kind: RefKind,\n-        fn_barrier: bool,\n+        protect: bool,\n         two_phase: bool,\n     ) -> EvalResult<'tcx, Immediate<Tag>> {\n         let this = self.eval_context_mut();\n@@ -665,18 +626,16 @@ trait EvalContextPrivExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         };\n \n         // Reborrow.\n-        this.reborrow(place, size, kind, new_tag, fn_barrier)?;\n+        this.reborrow(place, size, kind, new_tag, /*force_weak:*/ two_phase, protect)?;\n         let new_place = place.replace_tag(new_tag);\n         // Handle two-phase borrows.\n         if two_phase {\n             assert!(kind == RefKind::Unique, \"two-phase shared borrows make no sense\");\n-            // Grant read access *to the parent pointer* with the old tag.  This means the same pointer\n-            // has multiple items in the stack now!\n-            // FIXME: Think about this some more, in particular about the interaction with cast-to-raw.\n-            // Maybe find a better way to express 2-phase, now that we have a \"more expressive language\"\n-            // in the stack.\n+            // Grant read access *to the parent pointer* with the old tag *derived from the new tag* (`new_place`). \n+            // This means the old pointer has multiple items in the stack now, which otherwise cannot happen\n+            // for unique references -- but in this case it precisely expresses the semantics we want.\n             let old_tag = place.ptr.to_ptr().unwrap().tag;\n-            this.reborrow(new_place, size, RefKind::Shared, old_tag, /* fn_barrier: */ false)?;\n+            this.reborrow(new_place, size, RefKind::Shared, old_tag, /*force_weak:*/ false, /*protect:*/ false)?;\n         }\n \n         // Return new pointer.\n@@ -692,7 +651,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         place: PlaceTy<'tcx, Tag>\n     ) -> EvalResult<'tcx> {\n         let this = self.eval_context_mut();\n-        // Determine mutability and whether to add a barrier.\n+        // Determine mutability and whether to add a protector.\n         // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n         // making it useless.\n         fn qualify(ty: ty::Ty<'_>, kind: RetagKind) -> Option<(RefKind, bool)> {\n@@ -705,7 +664,7 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n                 // Raw pointers need to be enabled.\n                 ty::RawPtr(tym) if kind == RetagKind::Raw =>\n                     Some((RefKind::Raw { mutable: tym.mutbl == MutMutable }, false)),\n-                // Boxes do not get a barrier: barriers reflect that references outlive the call\n+                // Boxes do not get a protector: protectors reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n                 ty::Adt(..) if ty.is_box() => Some((RefKind::Unique, false)),\n                 _ => None,\n@@ -715,10 +674,10 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n         // We need a visitor to visit all references. However, that requires\n         // a `MemPlace`, so we have a fast path for reference types that\n         // avoids allocating.\n-        if let Some((mutbl, barrier)) = qualify(place.layout.ty, kind) {\n+        if let Some((mutbl, protector)) = qualify(place.layout.ty, kind) {\n             // Fast path.\n             let val = this.read_immediate(this.place_to_op(place)?)?;\n-            let val = this.retag_reference(val, mutbl, barrier, kind == RetagKind::TwoPhase)?;\n+            let val = this.retag_reference(val, mutbl, protector, kind == RetagKind::TwoPhase)?;\n             this.write_immediate(val, place)?;\n             return Ok(());\n         }\n@@ -749,12 +708,12 @@ pub trait EvalContextExt<'a, 'mir, 'tcx: 'a+'mir>: crate::MiriEvalContextExt<'a,\n             {\n                 // Cannot use `builtin_deref` because that reports *immutable* for `Box`,\n                 // making it useless.\n-                if let Some((mutbl, barrier)) = qualify(place.layout.ty, self.kind) {\n+                if let Some((mutbl, protector)) = qualify(place.layout.ty, self.kind) {\n                     let val = self.ecx.read_immediate(place.into())?;\n                     let val = self.ecx.retag_reference(\n                         val,\n                         mutbl,\n-                        barrier,\n+                        protector,\n                         self.kind == RetagKind::TwoPhase\n                     )?;\n                     self.ecx.write_immediate(val, place.into())?;"}, {"sha": "d047925163bd62ceef7bbb30e7da642e8a3b0208", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut1.rs?ref=46d5fd848773dcb3699344a8927a21e285d9207a", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-pub fn safe(_x: &mut i32, _y: &mut i32) {} //~ ERROR barrier\n+pub fn safe(_x: &mut i32, _y: &mut i32) {} //~ ERROR protect\n \n fn main() {\n     let mut x = 0;"}, {"sha": "c679e01677eb5ea5be27bd9ff70d3f85b00e2beb", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut2.rs?ref=46d5fd848773dcb3699344a8927a21e285d9207a", "patch": "@@ -1,6 +1,6 @@\n use std::mem;\n \n-pub fn safe(_x: &i32, _y: &mut i32) {} //~ ERROR barrier\n+pub fn safe(_x: &i32, _y: &mut i32) {} //~ ERROR protect\n \n fn main() {\n     let mut x = 0;"}, {"sha": "778935a6d0b0dcdf03595b1659f359e9c74b50e9", "filename": "tests/compile-fail/stacked_borrows/aliasing_mut4.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Faliasing_mut4.rs?ref=46d5fd848773dcb3699344a8927a21e285d9207a", "patch": "@@ -2,7 +2,7 @@ use std::mem;\n use std::cell::Cell;\n \n // Make sure &mut UnsafeCell also is exclusive\n-pub fn safe(_x: &i32, _y: &mut Cell<i32>) {} //~ ERROR barrier\n+pub fn safe(_x: &i32, _y: &mut Cell<i32>) {} //~ ERROR protect\n \n fn main() {\n     let mut x = 0;"}, {"sha": "49e376c0287e89810f576647125f9e70f6880333", "filename": "tests/compile-fail/stacked_borrows/deallocate_against_barrier.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Fdeallocate_against_barrier.rs?ref=46d5fd848773dcb3699344a8927a21e285d9207a", "patch": "@@ -1,4 +1,4 @@\n-// error-pattern: deallocating with active barrier\n+// error-pattern: deallocating with active protect\n \n fn inner(x: &mut i32, f: fn(&mut i32)) {\n     // `f` may mutate, but it may not deallocate!"}, {"sha": "3a214a75b50595d621d95ad3b016c9418c76071c", "filename": "tests/compile-fail/stacked_borrows/invalidate_against_barrier1.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier1.rs?ref=46d5fd848773dcb3699344a8927a21e285d9207a", "patch": "@@ -2,7 +2,7 @@ fn inner(x: *mut i32, _y: &mut i32) {\n     // If `x` and `y` alias, retagging is fine with this... but we really\n     // shouldn't be allowed to use `x` at all because `y` was assumed to be\n     // unique for the duration of this call.\n-    let _val = unsafe { *x }; //~ ERROR barrier\n+    let _val = unsafe { *x }; //~ ERROR protect\n }\n \n fn main() {"}, {"sha": "86e4a84287ec114c5a51a3b29e86bf3b969da15e", "filename": "tests/compile-fail/stacked_borrows/invalidate_against_barrier2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fstacked_borrows%2Finvalidate_against_barrier2.rs?ref=46d5fd848773dcb3699344a8927a21e285d9207a", "patch": "@@ -2,7 +2,7 @@ fn inner(x: *mut i32, _y: &i32) {\n     // If `x` and `y` alias, retagging is fine with this... but we really\n     // shouldn't be allowed to write to `x` at all because `y` was assumed to be\n     // immutable for the duration of this call.\n-    unsafe { *x = 0 }; //~ ERROR barrier\n+    unsafe { *x = 0 }; //~ ERROR protect\n }\n \n fn main() {"}, {"sha": "97f435472e30045f5d4598df24805038d1f3e83b", "filename": "tests/run-pass/stacked-borrows/2phase.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Frun-pass%2Fstacked-borrows%2F2phase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/46d5fd848773dcb3699344a8927a21e285d9207a/tests%2Frun-pass%2Fstacked-borrows%2F2phase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Frun-pass%2Fstacked-borrows%2F2phase.rs?ref=46d5fd848773dcb3699344a8927a21e285d9207a", "patch": "@@ -1,3 +1,5 @@\n+#![allow(mutable_borrow_reservation_conflict)]\n+\n trait S: Sized {\n     fn tpb(&mut self, _s: Self) {}\n }\n@@ -41,7 +43,6 @@ fn two_phase_raw() {\n     );\n }\n \n-/*\n fn two_phase_overlapping1() {\n     let mut x = vec![];\n     let p = &x;\n@@ -54,7 +55,6 @@ fn two_phase_overlapping2() {\n     let l = &x;\n     x.add_assign(x + *l);\n }\n-*/\n \n fn with_interior_mutability() {\n     use std::cell::Cell;\n@@ -66,13 +66,13 @@ fn with_interior_mutability() {\n     impl<T> Thing for Cell<T> {}\n \n     let mut x = Cell::new(1);\n-    //let l = &x;\n+    let l = &x;\n \n     x\n         .do_the_thing({\n             x.set(3);\n-            // l.set(4); // FIXME: Enable this as an example of overlapping 2PB!\n-            x.get() // FIXME same: + l.get()\n+            l.set(4);\n+            x.get() + l.get()\n         })\n     ;\n }\n@@ -84,7 +84,6 @@ fn main() {\n     two_phase3(true);\n     two_phase_raw();\n     with_interior_mutability();\n-    //FIXME: enable these, or remove them, depending on how https://github.com/rust-lang/rust/issues/56254 gets resolved\n-    //two_phase_overlapping1();\n-    //two_phase_overlapping2();\n+    two_phase_overlapping1();\n+    two_phase_overlapping2();\n }"}]}