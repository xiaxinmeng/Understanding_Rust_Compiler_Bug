{"sha": "ce97bd4c8b841165bb22cb0be566a9b66931165a", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNlOTdiZDRjOGI4NDExNjViYjIyY2IwYmU1NjZhOWI2NjkzMTE2NWE=", "commit": {"author": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-26T17:17:10Z"}, "committer": {"name": "Eric Reed", "email": "ereed@mozilla.com", "date": "2013-06-26T17:17:10Z"}, "message": "cleaned up uv/net", "tree": {"sha": "1bcca7dacc61e1434514f36b341566bf866ffbe3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bcca7dacc61e1434514f36b341566bf866ffbe3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ce97bd4c8b841165bb22cb0be566a9b66931165a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ce97bd4c8b841165bb22cb0be566a9b66931165a", "html_url": "https://github.com/rust-lang/rust/commit/ce97bd4c8b841165bb22cb0be566a9b66931165a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ce97bd4c8b841165bb22cb0be566a9b66931165a/comments", "author": null, "committer": null, "parents": [{"sha": "87ecfb74357b669308a6e337ebc766af8a03b554", "url": "https://api.github.com/repos/rust-lang/rust/commits/87ecfb74357b669308a6e337ebc766af8a03b554", "html_url": "https://github.com/rust-lang/rust/commit/87ecfb74357b669308a6e337ebc766af8a03b554"}], "stats": {"total": 100, "additions": 32, "deletions": 68}, "files": [{"sha": "8c5f9fdbd4a52abef2d4d7d5cfbad3e0fb2b5685", "filename": "src/libstd/rt/uv/net.rs", "status": "modified", "additions": 32, "deletions": 68, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/ce97bd4c8b841165bb22cb0be566a9b66931165a/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ce97bd4c8b841165bb22cb0be566a9b66931165a/src%2Flibstd%2Frt%2Fuv%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fuv%2Fnet.rs?ref=ce97bd4c8b841165bb22cb0be566a9b66931165a", "patch": "@@ -44,8 +44,8 @@ pub fn ip4_as_uv_ip4<T>(addr: IpAddr, f: &fn(*sockaddr_in) -> T) -> T {\n pub fn uv_ip4_to_ip4(addr: *sockaddr_in) -> IpAddr {\n     let ip4_size = 16;\n     let buf = vec::from_elem(ip4_size + 1 /*null terminated*/, 0u8);\n-    unsafe { ip4_name(addr, vec::raw::to_ptr(buf), ip4_size as u64) };\n-    let port = unsafe { ip4_port(addr) };\n+    unsafe { uvll::ip4_name(addr, vec::raw::to_ptr(buf), ip4_size as u64) };\n+    let port = unsafe { uvll::ip4_port(addr) };\n     let ip_str = str::from_bytes_slice(buf).trim_right_chars(&'\\x00');\n     let ip: ~[u8] = ip_str.split_iter('.')\n                           .transform(|s: &str| -> u8 {\n@@ -71,22 +71,19 @@ impl StreamWatcher {\n             data.read_cb = Some(cb);\n         }\n \n-        let handle = self.native_handle();\n-        unsafe { uvll::read_start(handle, alloc_cb, read_cb); }\n+        unsafe { uvll::read_start(self.native_handle(), alloc_cb, read_cb); }\n \n         extern fn alloc_cb(stream: *uvll::uv_stream_t, suggested_size: size_t) -> Buf {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = stream_watcher.get_watcher_data();\n-            let alloc_cb = data.alloc_cb.get_ref();\n+            let alloc_cb = stream_watcher.get_watcher_data().alloc_cb.get_ref();\n             return (*alloc_cb)(suggested_size as uint);\n         }\n \n         extern fn read_cb(stream: *uvll::uv_stream_t, nread: ssize_t, buf: Buf) {\n             rtdebug!(\"buf addr: %x\", buf.base as uint);\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(stream);\n-            let data = stream_watcher.get_watcher_data();\n-            let cb = data.read_cb.get_ref();\n+            let cb = stream_watcher.get_watcher_data().read_cb.get_ref();\n             let status = status_to_maybe_uv_error(stream, nread as c_int);\n             (*cb)(stream_watcher, nread as int, buf, status);\n         }\n@@ -108,22 +105,15 @@ impl StreamWatcher {\n         }\n \n         let req = WriteRequest::new();\n-        let bufs = [buf];\n         unsafe {\n-            assert!(0 == uvll::write(req.native_handle(),\n-                                     self.native_handle(),\n-                                     bufs, write_cb));\n+        assert_eq!(0, uvll::write(req.native_handle(), self.native_handle(), [buf], write_cb));\n         }\n \n         extern fn write_cb(req: *uvll::uv_write_t, status: c_int) {\n             let write_request: WriteRequest = NativeHandle::from_native_handle(req);\n             let mut stream_watcher = write_request.stream();\n             write_request.delete();\n-            let cb = {\n-                let data = stream_watcher.get_watcher_data();\n-                let cb = data.write_cb.swap_unwrap();\n-                cb\n-            };\n+            let cb = stream_watcher.get_watcher_data().write_cb.swap_unwrap();\n             let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n             cb(stream_watcher, status);\n         }\n@@ -132,9 +122,7 @@ impl StreamWatcher {\n     pub fn accept(&mut self, stream: StreamWatcher) {\n         let self_handle = self.native_handle() as *c_void;\n         let stream_handle = stream.native_handle() as *c_void;\n-        unsafe {\n-            assert_eq!(0, uvll::accept(self_handle, stream_handle));\n-        }\n+        assert_eq!(0, unsafe { uvll::accept(self_handle, stream_handle) } );\n     }\n \n     pub fn close(self, cb: NullCallback) {\n@@ -149,19 +137,15 @@ impl StreamWatcher {\n \n         extern fn close_cb(handle: *uvll::uv_stream_t) {\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            {\n-                let data = stream_watcher.get_watcher_data();\n-                data.close_cb.swap_unwrap()();\n-            }\n+            stream_watcher.get_watcher_data().close_cb.swap_unwrap()();\n             stream_watcher.drop_watcher_data();\n             unsafe { free_handle(handle as *c_void) }\n         }\n     }\n }\n \n impl NativeHandle<*uvll::uv_stream_t> for StreamWatcher {\n-    fn from_native_handle(\n-        handle: *uvll::uv_stream_t) -> StreamWatcher {\n+    fn from_native_handle(handle: *uvll::uv_stream_t) -> StreamWatcher {\n         StreamWatcher(handle)\n     }\n     fn native_handle(&self) -> *uvll::uv_stream_t {\n@@ -188,9 +172,7 @@ impl TcpWatcher {\n         match address {\n             Ipv4(*) => {\n                 do ip4_as_uv_ip4(address) |addr| {\n-                    let result = unsafe {\n-                        uvll::tcp_bind(self.native_handle(), addr)\n-                    };\n+                    let result = unsafe { uvll::tcp_bind(self.native_handle(), addr) };\n                     if result == 0 {\n                         Ok(())\n                     } else {\n@@ -212,9 +194,9 @@ impl TcpWatcher {\n                 Ipv4(*) => {\n                     do ip4_as_uv_ip4(address) |addr| {\n                         rtdebug!(\"connect_t: %x\", connect_handle as uint);\n-                        assert!(0 == uvll::tcp_connect(connect_handle,\n-                                                            self.native_handle(),\n-                                                            addr, connect_cb));\n+                        assert_eq!(0, \n+                                   uvll::tcp_connect(connect_handle, self.native_handle(),\n+                                                    addr, connect_cb));\n                     }\n                 }\n                 _ => fail!()\n@@ -225,10 +207,7 @@ impl TcpWatcher {\n                 let connect_request: ConnectRequest = NativeHandle::from_native_handle(req);\n                 let mut stream_watcher = connect_request.stream();\n                 connect_request.delete();\n-                let cb: ConnectionCallback = {\n-                    let data = stream_watcher.get_watcher_data();\n-                    data.connect_cb.swap_unwrap()\n-                };\n+                let cb = stream_watcher.get_watcher_data().connect_cb.swap_unwrap();\n                 let status = status_to_maybe_uv_error(stream_watcher.native_handle(), status);\n                 cb(stream_watcher, status);\n             }\n@@ -245,15 +224,13 @@ impl TcpWatcher {\n         unsafe {\n             static BACKLOG: c_int = 128; // XXX should be configurable\n             // XXX: This can probably fail\n-            assert!(0 == uvll::listen(self.native_handle(),\n-                                           BACKLOG, connection_cb));\n+            assert_eq!(0, uvll::listen(self.native_handle(), BACKLOG, connection_cb));\n         }\n \n         extern fn connection_cb(handle: *uvll::uv_stream_t, status: c_int) {\n             rtdebug!(\"connection_cb\");\n             let mut stream_watcher: StreamWatcher = NativeHandle::from_native_handle(handle);\n-            let data = stream_watcher.get_watcher_data();\n-            let cb = data.connect_cb.get_ref();\n+            let cb = stream_watcher.get_watcher_data().connect_cb.get_ref();\n             let status = status_to_maybe_uv_error(handle, status);\n             (*cb)(stream_watcher, status);\n         }\n@@ -314,8 +291,7 @@ impl UdpWatcher {\n             data.udp_recv_cb = Some(cb);\n         }\n \n-        let handle = self.native_handle();\n-        unsafe { uvll::udp_recv_start(handle, alloc_cb, recv_cb); }\n+        unsafe { uvll::udp_recv_start(self.native_handle(), alloc_cb, recv_cb); }\n \n         extern fn alloc_cb(handle: *uvll::uv_udp_t, suggested_size: size_t) -> Buf {\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n@@ -331,17 +307,14 @@ impl UdpWatcher {\n             rtdebug!(\"buf addr: %x\", buf.base as uint);\n             rtdebug!(\"buf len: %d\", buf.len as int);\n             let mut udp_watcher: UdpWatcher = NativeHandle::from_native_handle(handle);\n-            let data = udp_watcher.get_watcher_data();\n-            let cb = data.udp_recv_cb.get_ref();\n+            let cb = udp_watcher.get_watcher_data().udp_recv_cb.get_ref();\n             let status = status_to_maybe_uv_error(handle, nread as c_int);\n-            let address = uv_ip4_to_ip4(addr);\n-            (*cb)(udp_watcher, nread as int, buf, address, flags as uint, status);\n+            (*cb)(udp_watcher, nread as int, buf, uv_ip4_to_ip4(addr), flags as uint, status);\n         }\n     }\n \n     pub fn recv_stop(&self) {\n-        let handle = self.native_handle();\n-        unsafe { uvll::udp_recv_stop(handle); }\n+        unsafe { uvll::udp_recv_stop(self.native_handle()); }\n     }\n \n     pub fn send(&self, buf: Buf, address: IpAddr, cb: UdpSendCallback) {\n@@ -357,7 +330,7 @@ impl UdpWatcher {\n             Ipv4(*) => {\n                 do ip4_as_uv_ip4(address) |addr| {\n                     unsafe {\n-                        assert!(0 == uvll::udp_send(req.native_handle(),\n+                        assert_eq!(0, uvll::udp_send(req.native_handle(),\n                                                     self.native_handle(),\n                                                     [buf], addr, send_cb));\n                     }\n@@ -411,12 +384,9 @@ impl Request for ConnectRequest { }\n impl ConnectRequest {\n \n     fn new() -> ConnectRequest {\n-        let connect_handle = unsafe {\n-            malloc_req(UV_CONNECT)\n-        };\n+        let connect_handle = unsafe { malloc_req(UV_CONNECT) };\n         assert!(connect_handle.is_not_null());\n-        let connect_handle = connect_handle as *uvll::uv_connect_t;\n-        ConnectRequest(connect_handle)\n+        ConnectRequest(connect_handle as *uvll::uv_connect_t)\n     }\n \n     fn stream(&self) -> StreamWatcher {\n@@ -432,8 +402,7 @@ impl ConnectRequest {\n }\n \n impl NativeHandle<*uvll::uv_connect_t> for ConnectRequest {\n-    fn from_native_handle(\n-        handle: *uvll:: uv_connect_t) -> ConnectRequest {\n+    fn from_native_handle(handle: *uvll:: uv_connect_t) -> ConnectRequest {\n         ConnectRequest(handle)\n     }\n     fn native_handle(&self) -> *uvll::uv_connect_t {\n@@ -447,12 +416,9 @@ impl Request for WriteRequest { }\n \n impl WriteRequest {\n     pub fn new() -> WriteRequest {\n-        let write_handle = unsafe {\n-            malloc_req(UV_WRITE)\n-        };\n+        let write_handle = unsafe { malloc_req(UV_WRITE) };\n         assert!(write_handle.is_not_null());\n-        let write_handle = write_handle as *uvll::uv_write_t;\n-        WriteRequest(write_handle)\n+        WriteRequest(write_handle as *uvll::uv_write_t)\n     }\n \n     pub fn stream(&self) -> StreamWatcher {\n@@ -483,16 +449,14 @@ impl UdpSendRequest {\n     pub fn new() -> UdpSendRequest {\n         let send_handle = unsafe { malloc_req(UV_UDP_SEND) };\n         assert!(send_handle.is_not_null());\n-        let send_handle = send_handle as *uvll::uv_udp_send_t;\n-        UdpSendRequest(send_handle)\n+        UdpSendRequest(send_handle as *uvll::uv_udp_send_t)\n     }\n \n     pub fn handle(&self) -> UdpWatcher {\n-        unsafe {\n-            NativeHandle::from_native_handle(\n-                uvll::get_udp_handle_from_send_req(\n-                    self.native_handle()))\n-        }\n+        let send_request_handle = unsafe {\n+            uvll::get_udp_handle_from_send_req(self.native_handle())\n+        };\n+        NativeHandle::from_native_handle(send_request_handle)\n     }\n \n     pub fn delete(self) {"}]}