{"sha": "33c6d3fd7880df371151ec3e9a053b7169a181e5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzYzZkM2ZkNzg4MGRmMzcxMTUxZWMzZTlhMDUzYjcxNjlhMTgxZTU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-08T17:28:06Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2013-08-08T23:41:02Z"}, "message": "Allow attributes to appear as macro arguments\n\nFixes #8393", "tree": {"sha": "55df69841505538e605cc5389455cdc96120052b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/55df69841505538e605cc5389455cdc96120052b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33c6d3fd7880df371151ec3e9a053b7169a181e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33c6d3fd7880df371151ec3e9a053b7169a181e5", "html_url": "https://github.com/rust-lang/rust/commit/33c6d3fd7880df371151ec3e9a053b7169a181e5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33c6d3fd7880df371151ec3e9a053b7169a181e5/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f65dbfcfa11aa521aa59881f6ab064bbd07184e", "html_url": "https://github.com/rust-lang/rust/commit/8f65dbfcfa11aa521aa59881f6ab064bbd07184e"}], "stats": {"total": 196, "additions": 137, "deletions": 59}, "files": [{"sha": "918949113ad0c3237ba134fa404a2edc19bb2387", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=33c6d3fd7880df371151ec3e9a053b7169a181e5", "patch": "@@ -17,6 +17,7 @@ use codemap;\n use parse::lexer::*; //resolve bug?\n use parse::ParseSess;\n use parse::parser::Parser;\n+use parse::attr::parser_attr;\n use parse::token::{Token, EOF, to_str, nonterminal, get_ident_interner, ident_to_str};\n use parse::token;\n \n@@ -430,6 +431,7 @@ pub fn parse_nt(p: &Parser, name: &str) -> nonterminal {\n                      + token::to_str(get_ident_interner(), p.token))\n       },\n       \"path\" => token::nt_path(p.parse_path_with_tps(false)),\n+      \"attr\" => token::nt_attr(@p.parse_attribute(false)),\n       \"tt\" => {\n         *p.quote_depth += 1u; //but in theory, non-quoted tts might be useful\n         let res = token::nt_tt(@p.parse_token_tree());"}, {"sha": "f2489d80e1e69fe83681f1ea2be16c8af8a450a8", "filename": "src/libsyntax/parse/attr.rs", "status": "modified", "additions": 74, "deletions": 57, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fattr.rs?ref=33c6d3fd7880df371151ec3e9a053b7169a181e5", "patch": "@@ -9,21 +9,17 @@\n // except according to those terms.\n \n use ast;\n-use codemap::spanned;\n+use codemap::{spanned, mk_sp};\n use codemap::BytePos;\n use parse::common::*; //resolve bug?\n use parse::token;\n use parse::parser::Parser;\n+use parse::token::INTERPOLATED;\n \n // a parser that can parse attributes.\n pub trait parser_attr {\n     fn parse_outer_attributes(&self) -> ~[ast::Attribute];\n-    fn parse_attribute(&self, style: ast::AttrStyle) -> ast::Attribute;\n-    fn parse_attribute_naked(\n-        &self,\n-        style: ast::AttrStyle,\n-        lo: BytePos\n-    ) -> ast::Attribute;\n+    fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute;\n     fn parse_inner_attrs_and_next(&self) ->\n         (~[ast::Attribute], ~[ast::Attribute]);\n     fn parse_meta_item(&self) -> @ast::MetaItem;\n@@ -37,12 +33,17 @@ impl parser_attr for Parser {\n     fn parse_outer_attributes(&self) -> ~[ast::Attribute] {\n         let mut attrs: ~[ast::Attribute] = ~[];\n         loop {\n+            debug!(\"parse_outer_attributes: self.token=%?\",\n+                   self.token);\n             match *self.token {\n+              token::INTERPOLATED(token::nt_attr(*)) => {\n+                attrs.push(self.parse_attribute(false));\n+              }\n               token::POUND => {\n                 if self.look_ahead(1, |t| *t != token::LBRACKET) {\n                     break;\n                 }\n-                attrs.push(self.parse_attribute(ast::AttrOuter));\n+                attrs.push(self.parse_attribute(false));\n               }\n               token::DOC_COMMENT(s) => {\n                 let attr = ::attr::mk_sugared_doc_attr(\n@@ -62,23 +63,49 @@ impl parser_attr for Parser {\n         return attrs;\n     }\n \n-    // matches attribute = # attribute_naked\n-    fn parse_attribute(&self, style: ast::AttrStyle) -> ast::Attribute {\n-        let lo = self.span.lo;\n-        self.expect(&token::POUND);\n-        return self.parse_attribute_naked(style, lo);\n+    // matches attribute = # [ meta_item ]\n+    //\n+    // if permit_inner is true, then a trailing `;` indicates an inner\n+    // attribute\n+    fn parse_attribute(&self, permit_inner: bool) -> ast::Attribute {\n+        debug!(\"parse_attributes: permit_inner=%? self.token=%?\",\n+               permit_inner, self.token);\n+        let (span, value) = match *self.token {\n+            INTERPOLATED(token::nt_attr(attr)) => {\n+                assert!(attr.node.style == ast::AttrOuter);\n+                self.bump();\n+                (attr.span, attr.node.value)\n+            }\n+            token::POUND => {\n+                let lo = self.span.lo;\n+                self.bump();\n+                self.expect(&token::LBRACKET);\n+                let meta_item = self.parse_meta_item();\n+                self.expect(&token::RBRACKET);\n+                let hi = self.span.hi;\n+                (mk_sp(lo, hi), meta_item)\n+            }\n+            _ => {\n+                self.fatal(fmt!(\"expected `#` but found `%s`\",\n+                                self.this_token_to_str()));\n+            }\n+        };\n+        let style = if permit_inner && *self.token == token::SEMI {\n+            self.bump();\n+            ast::AttrInner\n+        } else {\n+            ast::AttrOuter\n+        };\n+        return spanned {\n+            span: span,\n+            node: ast::Attribute_ {\n+                style: style,\n+                value: value,\n+                is_sugared_doc: false\n+            }\n+        };\n     }\n \n-    // matches attribute_naked = [ meta_item ]\n-    fn parse_attribute_naked(&self, style: ast::AttrStyle, lo: BytePos) ->\n-        ast::Attribute {\n-        self.expect(&token::LBRACKET);\n-        let meta_item = self.parse_meta_item();\n-        self.expect(&token::RBRACKET);\n-        let hi = self.span.hi;\n-        return spanned(lo, hi, ast::Attribute_ { style: style,\n-                                                 value: meta_item, is_sugared_doc: false }); }\n-\n     // Parse attributes that appear after the opening of an item, each\n     // terminated by a semicolon. In addition to a vector of inner attributes,\n     // this function also returns a vector that may contain the first outer\n@@ -89,47 +116,37 @@ impl parser_attr for Parser {\n     // matches inner_attrs* outer_attr?\n     // you can make the 'next' field an Option, but the result is going to be\n     // more useful as a vector.\n-    fn parse_inner_attrs_and_next(&self) ->\n-        (~[ast::Attribute], ~[ast::Attribute]) {\n+    fn parse_inner_attrs_and_next(&self)\n+                                  -> (~[ast::Attribute], ~[ast::Attribute]) {\n         let mut inner_attrs: ~[ast::Attribute] = ~[];\n         let mut next_outer_attrs: ~[ast::Attribute] = ~[];\n         loop {\n-            match *self.token {\n-              token::POUND => {\n-                if self.look_ahead(1, |t| *t != token::LBRACKET) {\n-                    // This is an extension\n-                    break;\n+            let attr = match *self.token {\n+                token::INTERPOLATED(token::nt_attr(*)) => {\n+                    self.parse_attribute(true)\n+                }\n+                token::POUND => {\n+                    if self.look_ahead(1, |t| *t != token::LBRACKET) {\n+                        // This is an extension\n+                        break;\n+                    }\n+                    self.parse_attribute(true)\n                 }\n-                let attr = self.parse_attribute(ast::AttrInner);\n-                if *self.token == token::SEMI {\n+                token::DOC_COMMENT(s) => {\n                     self.bump();\n-                    inner_attrs.push(attr);\n-                } else {\n-                    // It's not really an inner attribute\n-                    let outer_attr =\n-                        spanned(attr.span.lo, attr.span.hi,\n-                            ast::Attribute_ { style: ast::AttrOuter,\n-                                              value: attr.node.value,\n-                                              is_sugared_doc: false });\n-                    next_outer_attrs.push(outer_attr);\n-                    break;\n+                    ::attr::mk_sugared_doc_attr(self.id_to_str(s),\n+                                                self.span.lo,\n+                                                self.span.hi)\n                 }\n-              }\n-              token::DOC_COMMENT(s) => {\n-                let attr = ::attr::mk_sugared_doc_attr(\n-                    self.id_to_str(s),\n-                    self.span.lo,\n-                    self.span.hi\n-                );\n-                self.bump();\n-                if attr.node.style == ast::AttrInner {\n-                  inner_attrs.push(attr);\n-                } else {\n-                  next_outer_attrs.push(attr);\n-                  break;\n+                _ => {\n+                    break;\n                 }\n-              }\n-              _ => break\n+            };\n+            if attr.node.style == ast::AttrInner {\n+                inner_attrs.push(attr);\n+            } else {\n+                next_outer_attrs.push(attr);\n+                break;\n             }\n         }\n         (inner_attrs, next_outer_attrs)"}, {"sha": "bde568b2610c2c5bd69288a0792f0d2bb4bb1f56", "filename": "src/libsyntax/parse/lexer.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fparse%2Flexer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fparse%2Flexer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Flexer.rs?ref=33c6d3fd7880df371151ec3e9a053b7169a181e5", "patch": "@@ -129,7 +129,11 @@ impl reader for StringReader {\n \n impl reader for TtReader {\n     fn is_eof(@mut self) -> bool { self.cur_tok == token::EOF }\n-    fn next_token(@mut self) -> TokenAndSpan { tt_next_token(self) }\n+    fn next_token(@mut self) -> TokenAndSpan {\n+        let r = tt_next_token(self);\n+        debug!(\"TtReader: r=%?\", r);\n+        return r;\n+    }\n     fn fatal(@mut self, m: ~str) -> ! {\n         self.sp_diag.span_fatal(self.cur_span, m);\n     }"}, {"sha": "dcab89930dc56cf1c938c46994197f28b0346dfd", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=33c6d3fd7880df371151ec3e9a053b7169a181e5", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#[macro_escape];\n+\n use abi;\n use abi::AbiSet;\n use ast::{Sigil, BorrowedSigil, ManagedSigil, OwnedSigil};\n@@ -4452,7 +4454,17 @@ impl Parser {\n                                attrs: ~[Attribute],\n                                macros_allowed: bool)\n                                -> item_or_view_item {\n-        maybe_whole!(iovi self, nt_item);\n+        match *self.token {\n+            INTERPOLATED(token::nt_item(item)) => {\n+                self.bump();\n+                let new_attrs = vec::append(attrs, item.attrs);\n+                return iovi_item(@ast::item {\n+                        attrs: new_attrs,\n+                        ..(*item).clone()});\n+            }\n+            _ => {}\n+        }\n+\n         let lo = self.span.lo;\n \n         let visibility = self.parse_non_priv_visibility();"}, {"sha": "c554f111bf9a0d2997257d4021ba019b0651c48f", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=33c6d3fd7880df371151ec3e9a053b7169a181e5", "patch": "@@ -105,6 +105,7 @@ pub enum nonterminal {\n     nt_expr(@ast::expr),\n     nt_ty(   ast::Ty),\n     nt_ident(ast::ident, bool),\n+    nt_attr(@ast::Attribute),   // #[foo]\n     nt_path( ast::Path),\n     nt_tt(  @ast::token_tree), //needs @ed to break a circularity\n     nt_matchers(~[ast::matcher])\n@@ -205,13 +206,15 @@ pub fn to_str(input: @ident_interner, t: &Token) -> ~str {\n       INTERPOLATED(ref nt) => {\n         match nt {\n             &nt_expr(e) => ::print::pprust::expr_to_str(e, input),\n+            &nt_attr(e) => ::print::pprust::attribute_to_str(e, input),\n             _ => {\n                 ~\"an interpolated \" +\n                     match (*nt) {\n                       nt_item(*) => ~\"item\",\n                       nt_block(*) => ~\"block\",\n                       nt_stmt(*) => ~\"statement\",\n                       nt_pat(*) => ~\"pattern\",\n+                      nt_attr(*) => fail!(\"should have been handled\"),\n                       nt_expr(*) => fail!(\"should have been handled above\"),\n                       nt_ty(*) => ~\"type\",\n                       nt_ident(*) => ~\"identifier\","}, {"sha": "95000f4aa229ddbe8e133929c21d5d3f721ec5f8", "filename": "src/test/compile-fail/macro-inner-attributes.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-inner-attributes.rs?ref=33c6d3fd7880df371151ec3e9a053b7169a181e5", "patch": "@@ -0,0 +1,21 @@\n+macro_rules! test ( ($nm:ident,\n+                     $a:attr,\n+                     $i:item) => (mod $nm { $a; $i }); )\n+\n+test!(a,\n+      #[cfg(qux)],\n+      pub fn bar() { })\n+\n+test!(b,\n+      #[cfg(not(qux))],\n+      pub fn bar() { })\n+\n+#[qux]\n+fn main() {\n+    a::bar();\n+    //~^ ERROR use of undeclared module `a`\n+    //~^^ ERROR unresolved name\n+    //~^^^ ERROR unresolved name `a::bar`\n+    b::bar();\n+}\n+"}, {"sha": "23c3e80cd3b2b7f5dac908484732cc4b58990001", "filename": "src/test/compile-fail/macro-outer-attributes.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33c6d3fd7880df371151ec3e9a053b7169a181e5/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-outer-attributes.rs?ref=33c6d3fd7880df371151ec3e9a053b7169a181e5", "patch": "@@ -0,0 +1,19 @@\n+macro_rules! test ( ($nm:ident,\n+                     $a:attr,\n+                     $i:item) => (mod $nm { $a $i }); )\n+\n+test!(a,\n+      #[cfg(qux)],\n+      pub fn bar() { })\n+\n+test!(b,\n+      #[cfg(not(qux))],\n+      pub fn bar() { })\n+\n+// test1!(#[bar])\n+#[qux]\n+fn main() {\n+    a::bar(); //~ ERROR unresolved name `a::bar`\n+    b::bar();\n+}\n+"}]}