{"sha": "c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "node_id": "C_kwDOAAsO6NoAKGMzZjU2OGIzMzEyYmVkOTlkMGU0Yjk1ZGFlY2QzYzllY2ExYWU4OTU", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-23T01:58:33Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-08-25T18:59:48Z"}, "message": "Do not report too many expr field candidates", "tree": {"sha": "423d3b3036f2fbe01653abe230d788de304dfadc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/423d3b3036f2fbe01653abe230d788de304dfadc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "html_url": "https://github.com/rust-lang/rust/commit/c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "015a824f2dffe32707fceb59c47effaf7b73486c", "url": "https://api.github.com/repos/rust-lang/rust/commits/015a824f2dffe32707fceb59c47effaf7b73486c", "html_url": "https://github.com/rust-lang/rust/commit/015a824f2dffe32707fceb59c47effaf7b73486c"}], "stats": {"total": 229, "additions": 160, "deletions": 69}, "files": [{"sha": "43183fd8ec815313849659c91c158ba65dc2294d", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "patch": "@@ -157,6 +157,7 @@ symbols! {\n         BTreeSet,\n         BinaryHeap,\n         Borrow,\n+        BorrowMut,\n         Break,\n         C,\n         CStr,"}, {"sha": "43aababeea8ae0bace6e9e2a8a9bde67c4ada0af", "filename": "compiler/rustc_typeck/src/check/expr.rs", "status": "modified", "additions": 29, "deletions": 22, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fexpr.rs?ref=c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "patch": "@@ -2588,32 +2588,39 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         if let Some((fields, substs)) =\n             self.get_field_candidates_considering_privacy(span, expr_t, mod_id)\n         {\n-            for candidate_field in fields {\n-                if let Some(mut field_path) = self.check_for_nested_field_satisfying(\n-                    span,\n-                    &|candidate_field, _| candidate_field.ident(self.tcx()) == field,\n-                    candidate_field,\n-                    substs,\n-                    vec![],\n-                    mod_id,\n-                ) {\n-                    // field_path includes `field` that we're looking for, so pop it.\n+            let candidate_fields: Vec<_> = fields\n+                .filter_map(|candidate_field| {\n+                    self.check_for_nested_field_satisfying(\n+                        span,\n+                        &|candidate_field, _| candidate_field.ident(self.tcx()) == field,\n+                        candidate_field,\n+                        substs,\n+                        vec![],\n+                        mod_id,\n+                    )\n+                })\n+                .map(|mut field_path| {\n                     field_path.pop();\n-\n-                    let field_path_str = field_path\n+                    field_path\n                         .iter()\n                         .map(|id| id.name.to_ident_string())\n                         .collect::<Vec<String>>()\n-                        .join(\".\");\n-                    debug!(\"field_path_str: {:?}\", field_path_str);\n-\n-                    err.span_suggestion_verbose(\n-                        field.span.shrink_to_lo(),\n-                        \"one of the expressions' fields has a field of the same name\",\n-                        format!(\"{field_path_str}.\"),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n+                        .join(\".\")\n+                })\n+                .collect::<Vec<_>>();\n+\n+            let len = candidate_fields.len();\n+            if len > 0 {\n+                err.span_suggestions(\n+                    field.span.shrink_to_lo(),\n+                    format!(\n+                        \"{} of the expressions' fields {} a field of the same name\",\n+                        if len > 1 { \"some\" } else { \"one\" },\n+                        if len > 1 { \"have\" } else { \"has\" },\n+                    ),\n+                    candidate_fields.iter().map(|path| format!(\"{path}.\")),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n         }\n         err"}, {"sha": "70e6d33dae16a77527c3b932239045bccd12befb", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 57, "deletions": 31, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "patch": "@@ -1338,42 +1338,68 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         item_name: Ident,\n     ) {\n         if let SelfSource::MethodCall(expr) = source\n-            && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n-            && let Some((fields, substs)) = self.get_field_candidates_considering_privacy(span, actual, mod_id)\n+        && let mod_id = self.tcx.parent_module(expr.hir_id).to_def_id()\n+        && let Some((fields, substs)) =\n+            self.get_field_candidates_considering_privacy(span, actual, mod_id)\n         {\n             let call_expr = self.tcx.hir().expect_expr(self.tcx.hir().get_parent_node(expr.hir_id));\n-            for candidate_field in fields {\n-                if let Some(field_path) = self.check_for_nested_field_satisfying(\n-                    span,\n-                    &|_, field_ty| {\n-                        self.lookup_probe(\n-                            span,\n-                            item_name,\n-                            field_ty,\n-                            call_expr,\n-                            ProbeScope::AllTraits,\n-                        )\n-                        .is_ok()\n-                    },\n-                    candidate_field,\n-                    substs,\n-                    vec![],\n-                    mod_id,\n-                ) {\n-                    let field_path_str = field_path\n+\n+            let lang_items = self.tcx.lang_items();\n+            let never_mention_traits = [\n+                lang_items.clone_trait(),\n+                lang_items.deref_trait(),\n+                lang_items.deref_mut_trait(),\n+                self.tcx.get_diagnostic_item(sym::AsRef),\n+                self.tcx.get_diagnostic_item(sym::AsMut),\n+                self.tcx.get_diagnostic_item(sym::Borrow),\n+                self.tcx.get_diagnostic_item(sym::BorrowMut),\n+            ];\n+            let candidate_fields: Vec<_> = fields\n+                .filter_map(|candidate_field| {\n+                    self.check_for_nested_field_satisfying(\n+                        span,\n+                        &|_, field_ty| {\n+                            self.lookup_probe(\n+                                span,\n+                                item_name,\n+                                field_ty,\n+                                call_expr,\n+                                ProbeScope::TraitsInScope,\n+                            )\n+                            .map_or(false, |pick| {\n+                                !never_mention_traits\n+                                    .iter()\n+                                    .flatten()\n+                                    .any(|def_id| self.tcx.parent(pick.item.def_id) == *def_id)\n+                            })\n+                        },\n+                        candidate_field,\n+                        substs,\n+                        vec![],\n+                        mod_id,\n+                    )\n+                })\n+                .map(|field_path| {\n+                    field_path\n                         .iter()\n                         .map(|id| id.name.to_ident_string())\n                         .collect::<Vec<String>>()\n-                        .join(\".\");\n-                    debug!(\"field_path_str: {:?}\", field_path_str);\n-\n-                    err.span_suggestion_verbose(\n-                        item_name.span.shrink_to_lo(),\n-                        \"one of the expressions' fields has a method of the same name\",\n-                        format!(\"{field_path_str}.\"),\n-                        Applicability::MaybeIncorrect,\n-                    );\n-                }\n+                        .join(\".\")\n+                })\n+                .collect();\n+\n+            let len = candidate_fields.len();\n+            if len > 0 {\n+                err.span_suggestions(\n+                    item_name.span.shrink_to_lo(),\n+                    format!(\n+                        \"{} of the expressions' fields {} a method of the same name\",\n+                        if len > 1 { \"some\" } else { \"one\" },\n+                        if len > 1 { \"have\" } else { \"has\" },\n+                    ),\n+                    candidate_fields.iter().map(|path| format!(\"{path}.\")),\n+                    Applicability::MaybeIncorrect,\n+                );\n             }\n         }\n     }"}, {"sha": "128087f1e375522297267296a093509774bb30e1", "filename": "src/test/ui/copy-a-resource.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fcopy-a-resource.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcopy-a-resource.stderr?ref=c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "patch": "@@ -10,10 +10,6 @@ LL |     let _y = x.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let _y = x.i.clone();\n-   |                ++\n \n error: aborting due to previous error\n "}, {"sha": "b5a2b2f55a6d4905af0425b580efa1406101b0a9", "filename": "src/test/ui/issues/issue-2823.stderr", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-2823.stderr?ref=c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "patch": "@@ -10,10 +10,6 @@ LL |     let _d = c.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let _d = c.x.clone();\n-   |                ++\n \n error: aborting due to previous error\n "}, {"sha": "0c696163a26c5cba2737b6bf51ae504c1e84af26", "filename": "src/test/ui/noncopyable-class.stderr", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fnoncopyable-class.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnoncopyable-class.stderr?ref=c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "patch": "@@ -10,14 +10,6 @@ LL |     let _y = x.clone();\n    = help: items from traits can only be used if the trait is implemented and in scope\n    = note: the following trait defines an item `clone`, perhaps you need to implement it:\n            candidate #1: `Clone`\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let _y = x.i.clone();\n-   |                ++\n-help: one of the expressions' fields has a method of the same name\n-   |\n-LL |     let _y = x.j.x.clone();\n-   |                ++++\n \n error: aborting due to previous error\n "}, {"sha": "905f9502cf5be5270b501c9eafb0714886c01a09", "filename": "src/test/ui/suggestions/too-many-field-suggestions.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.rs?ref=c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "patch": "@@ -0,0 +1,29 @@\n+struct Thing {\n+    a0: Foo,\n+    a1: Foo,\n+    a2: Foo,\n+    a3: Foo,\n+    a4: Foo,\n+    a5: Foo,\n+    a6: Foo,\n+    a7: Foo,\n+    a8: Foo,\n+    a9: Foo,\n+}\n+\n+struct Foo {\n+    field: Field,\n+}\n+\n+struct Field;\n+\n+impl Foo {\n+    fn bar(&self) {}\n+}\n+\n+fn bar(t: Thing) {\n+    t.bar(); //~ ERROR no method named `bar` found for struct `Thing`\n+    t.field; //~ ERROR no field `field` on type `Thing`\n+}\n+\n+fn main() {}"}, {"sha": "63ad6fdb1699441327f85ff05cd5b354f87f0a96", "filename": "src/test/ui/suggestions/too-many-field-suggestions.stderr", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c3f568b3312bed99d0e4b95daecd3c9eca1ae895/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fsuggestions%2Ftoo-many-field-suggestions.stderr?ref=c3f568b3312bed99d0e4b95daecd3c9eca1ae895", "patch": "@@ -0,0 +1,44 @@\n+error[E0599]: no method named `bar` found for struct `Thing` in the current scope\n+  --> $DIR/too-many-field-suggestions.rs:25:7\n+   |\n+LL | struct Thing {\n+   | ------------ method `bar` not found for this struct\n+...\n+LL |     t.bar();\n+   |       ^^^ method not found in `Thing`\n+   |\n+help: some of the expressions' fields have a method of the same name\n+   |\n+LL |     t.a0.bar();\n+   |       +++\n+LL |     t.a1.bar();\n+   |       +++\n+LL |     t.a2.bar();\n+   |       +++\n+LL |     t.a3.bar();\n+   |       +++\n+     and 6 other candidates\n+\n+error[E0609]: no field `field` on type `Thing`\n+  --> $DIR/too-many-field-suggestions.rs:26:7\n+   |\n+LL |     t.field;\n+   |       ^^^^^ unknown field\n+   |\n+   = note: available fields are: `a0`, `a1`, `a2`, `a3`, `a4` ... and 5 others\n+help: some of the expressions' fields have a field of the same name\n+   |\n+LL |     t.a0.field;\n+   |       +++\n+LL |     t.a1.field;\n+   |       +++\n+LL |     t.a2.field;\n+   |       +++\n+LL |     t.a3.field;\n+   |       +++\n+     and 6 other candidates\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0599, E0609.\n+For more information about an error, try `rustc --explain E0599`."}]}