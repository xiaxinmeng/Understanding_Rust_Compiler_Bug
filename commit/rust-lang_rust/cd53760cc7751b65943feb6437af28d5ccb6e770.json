{"sha": "cd53760cc7751b65943feb6437af28d5ccb6e770", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNkNTM3NjBjYzc3NTFiNjU5NDNmZWI2NDM3YWYyOGQ1Y2NiNmU3NzA=", "commit": {"author": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-08-12T10:22:56Z"}, "committer": {"name": "Bastian Kauschke", "email": "bastian_kauschke@hotmail.de", "date": "2020-08-13T14:55:16Z"}, "message": "merge `as_local_hir_id` with `local_def_id_to_hir_id`", "tree": {"sha": "d9b23c013d5e129d5b96ba55ca8af7b714ea56a6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9b23c013d5e129d5b96ba55ca8af7b714ea56a6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cd53760cc7751b65943feb6437af28d5ccb6e770", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cd53760cc7751b65943feb6437af28d5ccb6e770", "html_url": "https://github.com/rust-lang/rust/commit/cd53760cc7751b65943feb6437af28d5ccb6e770", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cd53760cc7751b65943feb6437af28d5ccb6e770/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4745cbe83e0b3299bfe7f7f305b975c3c09f92db", "url": "https://api.github.com/repos/rust-lang/rust/commits/4745cbe83e0b3299bfe7f7f305b975c3c09f92db", "html_url": "https://github.com/rust-lang/rust/commit/4745cbe83e0b3299bfe7f7f305b975c3c09f92db"}], "stats": {"total": 478, "additions": 241, "deletions": 237}, "files": [{"sha": "0c749657001a60b4ab31e27858b22eb74537343a", "filename": "src/librustc_codegen_llvm/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_codegen_llvm%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fconsts.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -215,7 +215,7 @@ impl CodegenCx<'ll, 'tcx> {\n         debug!(\"get_static: sym={} instance={:?}\", sym, instance);\n \n         let g = if let Some(def_id) = def_id.as_local() {\n-            let id = self.tcx.hir().as_local_hir_id(def_id);\n+            let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n             let llty = self.layout_of(ty).llvm_type(self);\n             // FIXME: refactor this to work without accessing the HIR\n             let (g, attrs) = match self.tcx.hir().get(id) {"}, {"sha": "a9ffd416485ca9b22069fce74bf88498ffcfabf1", "filename": "src/librustc_codegen_ssa/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Fsymbol_export.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -370,7 +370,7 @@ fn upstream_drop_glue_for_provider<'tcx>(\n \n fn is_unreachable_local_definition_provider(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     if let Some(def_id) = def_id.as_local() {\n-        !tcx.reachable_set(LOCAL_CRATE).contains(&tcx.hir().as_local_hir_id(def_id))\n+        !tcx.reachable_set(LOCAL_CRATE).contains(&tcx.hir().local_def_id_to_hir_id(def_id))\n     } else {\n         bug!(\"is_unreachable_local_definition called with non-local DefId: {:?}\", def_id)\n     }"}, {"sha": "caa86b54fdfd81748718eee3b058523bfaf35892", "filename": "src/librustc_hir/definitions.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_hir%2Fdefinitions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_hir%2Fdefinitions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_hir%2Fdefinitions.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -306,11 +306,6 @@ impl Definitions {\n         })\n     }\n \n-    #[inline]\n-    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> hir::HirId {\n-        self.local_def_id_to_hir_id(def_id)\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, id: LocalDefId) -> hir::HirId {\n         self.def_id_to_hir_id[id].unwrap()"}, {"sha": "2b2c42207e48b6b62117b10b0023ae53a3dfac0b", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -144,7 +144,7 @@ fn msg_span_from_early_bound_and_free_regions(\n     let sm = tcx.sess.source_map();\n \n     let scope = region.free_region_binding_scope(tcx);\n-    let node = tcx.hir().as_local_hir_id(scope.expect_local());\n+    let node = tcx.hir().local_def_id_to_hir_id(scope.expect_local());\n     let tag = match tcx.hir().find(node) {\n         Some(Node::Block(_) | Node::Expr(_)) => \"body\",\n         Some(Node::Item(it)) => item_scope_tag(&it),\n@@ -1707,7 +1707,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .in_progress_typeck_results\n             .map(|typeck_results| typeck_results.borrow().hir_owner)\n             .map(|owner| {\n-                let hir_id = hir.as_local_hir_id(owner);\n+                let hir_id = hir.local_def_id_to_hir_id(owner);\n                 let parent_id = hir.get_parent_item(hir_id);\n                 (\n                     // Parent item could be a `mod`, so we check the HIR before calling:\n@@ -1733,7 +1733,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         // Get the `hir::Param` to verify whether it already has any bounds.\n                         // We do this to avoid suggesting code that ends up as `T: 'a'b`,\n                         // instead we suggest `T: 'a + 'b` in that case.\n-                        let id = hir.as_local_hir_id(def_id);\n+                        let id = hir.local_def_id_to_hir_id(def_id);\n                         let mut has_bounds = false;\n                         if let Node::GenericParam(param) = hir.get(id) {\n                             has_bounds = !param.bounds.is_empty();\n@@ -1786,7 +1786,10 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .and_then(|(_, g)| g.params.first())\n             .and_then(|param| param.def_id.as_local())\n             .map(|def_id| {\n-                (hir.span(hir.as_local_hir_id(def_id)).shrink_to_lo(), format!(\"{}, \", new_lt))\n+                (\n+                    hir.span(hir.local_def_id_to_hir_id(def_id)).shrink_to_lo(),\n+                    format!(\"{}, \", new_lt),\n+                )\n             });\n \n         let labeled_user_string = match bound_kind {"}, {"sha": "eb1521f0565767a22c0ef2fb6899b1e75409547d", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/find_anon_type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ffind_anon_type.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -28,7 +28,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         br: &ty::BoundRegion,\n     ) -> Option<(&hir::Ty<'tcx>, &hir::FnDecl<'tcx>)> {\n         if let Some(anon_reg) = self.tcx().is_suitable_region(region) {\n-            let hir_id = self.tcx().hir().as_local_hir_id(anon_reg.def_id);\n+            let hir_id = self.tcx().hir().local_def_id_to_hir_id(anon_reg.def_id);\n             let fndecl = match self.tcx().hir().get(hir_id) {\n                 Node::Item(&hir::Item { kind: hir::ItemKind::Fn(ref m, ..), .. })\n                 | Node::TraitItem(&hir::TraitItem {"}, {"sha": "788eabf296d7663c824544857c2c6d17db26a30e", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -67,7 +67,8 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         match assoc_item.kind {\n             ty::AssocKind::Fn => {\n                 let hir = self.tcx().hir();\n-                if let Some(hir_id) = assoc_item.def_id.as_local().map(|id| hir.as_local_hir_id(id))\n+                if let Some(hir_id) =\n+                    assoc_item.def_id.as_local().map(|id| hir.local_def_id_to_hir_id(id))\n                 {\n                     if let Some(decl) = hir.fn_decl_by_hir_id(hir_id) {\n                         visitor.visit_fn_decl(decl);"}, {"sha": "6e2d49f1ad792d4363f6dc150a51bdd08c1a67b7", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Futil.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -49,7 +49,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         };\n \n         let hir = &self.tcx().hir();\n-        let hir_id = hir.as_local_hir_id(id.as_local()?);\n+        let hir_id = hir.local_def_id_to_hir_id(id.as_local()?);\n         let body_id = hir.maybe_body_owned_by(hir_id)?;\n         let body = hir.body(body_id);\n         let owner_id = hir.body_owner(body_id);"}, {"sha": "ac3a9937dbad8b6b9873cdbf18f75ddada6385cf", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -440,7 +440,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 if let Some(def_id) = real_trait.as_local() {\n-                    let hir_id = cx.tcx.hir().as_local_hir_id(def_id);\n+                    let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n                     if let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) {\n                         if let hir::VisibilityKind::Inherited = item.vis.node {\n                             for impl_item_ref in items {\n@@ -614,7 +614,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDebugImplementations {\n             cx.tcx.for_each_impl(debug, |d| {\n                 if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n                     if let Some(def_id) = ty_def.did.as_local() {\n-                        impls.insert(cx.tcx.hir().as_local_hir_id(def_id));\n+                        impls.insert(cx.tcx.hir().local_def_id_to_hir_id(def_id));\n                     }\n                 }\n             });"}, {"sha": "4a612b89cac2284e878fcfe13d286e846148ed4e", "filename": "src/librustc_lint/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_lint%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_lint%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flate.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -379,7 +379,7 @@ fn late_lint_mod_pass<'tcx, T: LateLintPass<'tcx>>(\n         param_env: ty::ParamEnv::empty(),\n         access_levels,\n         lint_store: unerased_lint_store(tcx),\n-        last_node_with_lint_attrs: tcx.hir().as_local_hir_id(module_def_id),\n+        last_node_with_lint_attrs: tcx.hir().local_def_id_to_hir_id(module_def_id),\n         generics: None,\n         only_module: true,\n     };"}, {"sha": "76e395f2f1e2c9a8789dea9a7666b2024569b502", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -733,7 +733,7 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local());\n+        let enum_id = tcx.hir().local_def_id_to_hir_id(def.did.expect_local());\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n \n         record!(self.tables.kind[def_id] <- EntryKind::Variant(self.lazy(data)));\n@@ -780,7 +780,7 @@ impl EncodeContext<'a, 'tcx> {\n \n         // Variant constructors have the same visibility as the parent enums, unless marked as\n         // non-exhaustive, in which case they are lowered to `pub(crate)`.\n-        let enum_id = tcx.hir().as_local_hir_id(def.did.expect_local());\n+        let enum_id = tcx.hir().local_def_id_to_hir_id(def.did.expect_local());\n         let enum_vis = &tcx.hir().expect_item(enum_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(enum_vis, enum_id, tcx);\n         if variant.is_field_list_non_exhaustive() && ctor_vis == ty::Visibility::Public {\n@@ -819,11 +819,11 @@ impl EncodeContext<'a, 'tcx> {\n         let data = ModData {\n             reexports: match tcx.module_exports(local_def_id) {\n                 Some(exports) => {\n-                    let hir_map = self.tcx.hir();\n+                    let hir = self.tcx.hir();\n                     self.lazy(\n                         exports\n                             .iter()\n-                            .map(|export| export.map_id(|id| hir_map.as_local_hir_id(id))),\n+                            .map(|export| export.map_id(|id| hir.local_def_id_to_hir_id(id))),\n                     )\n                 }\n                 _ => Lazy::empty(),\n@@ -855,7 +855,7 @@ impl EncodeContext<'a, 'tcx> {\n         let def_id = field.did;\n         debug!(\"EncodeContext::encode_field({:?})\", def_id);\n \n-        let variant_id = tcx.hir().as_local_hir_id(variant.def_id.expect_local());\n+        let variant_id = tcx.hir().local_def_id_to_hir_id(variant.def_id.expect_local());\n         let variant_data = tcx.hir().expect_variant_data(variant_id);\n \n         record!(self.tables.kind[def_id] <- EntryKind::Field);\n@@ -883,7 +883,7 @@ impl EncodeContext<'a, 'tcx> {\n             is_non_exhaustive: variant.is_field_list_non_exhaustive(),\n         };\n \n-        let struct_id = tcx.hir().as_local_hir_id(adt_def.did.expect_local());\n+        let struct_id = tcx.hir().local_def_id_to_hir_id(adt_def.did.expect_local());\n         let struct_vis = &tcx.hir().expect_item(struct_id).vis;\n         let mut ctor_vis = ty::Visibility::from_hir(struct_vis, struct_id, tcx);\n         for field in &variant.fields {\n@@ -945,7 +945,7 @@ impl EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_info_for_trait_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         let ast_item = tcx.hir().expect_trait_item(hir_id);\n         let trait_item = tcx.associated_item(def_id);\n \n@@ -1034,7 +1034,7 @@ impl EncodeContext<'a, 'tcx> {\n         debug!(\"EncodeContext::encode_info_for_impl_item({:?})\", def_id);\n         let tcx = self.tcx;\n \n-        let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         let ast_item = self.tcx.hir().expect_impl_item(hir_id);\n         let impl_item = self.tcx.associated_item(def_id);\n \n@@ -1438,7 +1438,7 @@ impl EncodeContext<'a, 'tcx> {\n \n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n         // including on the signature, which is inferred in `typeck.\n-        let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = self.tcx.typeck(def_id).node_type(hir_id);\n \n         record!(self.tables.kind[def_id.to_def_id()] <- match ty.kind {\n@@ -1465,7 +1465,7 @@ impl EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let id = self.tcx.hir().as_local_hir_id(def_id);\n+        let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let qualifs = self.tcx.mir_const_qualif(def_id);"}, {"sha": "6697524279874d1eabfc7ca1bed55248e50c0852", "filename": "src/librustc_middle/dep_graph/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fdep_graph%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -185,6 +185,6 @@ impl<'tcx> DepContext for TyCtxt<'tcx> {\n }\n \n fn def_id_corresponds_to_hir_dep_node(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     def_id == hir_id.owner\n }"}, {"sha": "0794caca1baa5c7dda813cfae68330409ac11405", "filename": "src/librustc_middle/hir/map/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmap%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -173,11 +173,6 @@ impl<'hir> Map<'hir> {\n         self.tcx.definitions.opt_hir_id_to_local_def_id(hir_id)\n     }\n \n-    #[inline]\n-    pub fn as_local_hir_id(&self, def_id: LocalDefId) -> HirId {\n-        self.tcx.definitions.as_local_hir_id(def_id)\n-    }\n-\n     #[inline]\n     pub fn local_def_id_to_hir_id(&self, def_id: LocalDefId) -> HirId {\n         self.tcx.definitions.local_def_id_to_hir_id(def_id)\n@@ -450,7 +445,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_module(&self, module: LocalDefId) -> (&'hir Mod<'hir>, Span, HirId) {\n-        let hir_id = self.as_local_hir_id(module);\n+        let hir_id = self.local_def_id_to_hir_id(module);\n         match self.get_entry(hir_id).node {\n             Node::Item(&Item { span, kind: ItemKind::Mod(ref m), .. }) => (m, span, hir_id),\n             Node::Crate(item) => (&item.module, item.span, hir_id),\n@@ -483,7 +478,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn get_if_local(&self, id: DefId) -> Option<Node<'hir>> {\n-        id.as_local().map(|id| self.get(self.as_local_hir_id(id)))\n+        id.as_local().map(|id| self.get(self.local_def_id_to_hir_id(id)))\n     }\n \n     pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n@@ -872,7 +867,7 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn span_if_local(&self, id: DefId) -> Option<Span> {\n-        id.as_local().map(|id| self.span(self.as_local_hir_id(id)))\n+        id.as_local().map(|id| self.span(self.local_def_id_to_hir_id(id)))\n     }\n \n     pub fn res_span(&self, res: Res) -> Option<Span> {"}, {"sha": "ae3b30217cc4aae7010e98397e77f82379f30fac", "filename": "src/librustc_middle/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fhir%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -66,20 +66,20 @@ impl<'tcx> TyCtxt<'tcx> {\n pub fn provide(providers: &mut Providers) {\n     providers.parent_module_from_def_id = |tcx, id| {\n         let hir = tcx.hir();\n-        hir.local_def_id(hir.get_module_parent_node(hir.as_local_hir_id(id)))\n+        hir.local_def_id(hir.get_module_parent_node(hir.local_def_id_to_hir_id(id)))\n     };\n     providers.hir_crate = |tcx, _| tcx.untracked_crate;\n     providers.index_hir = map::index_hir;\n     providers.hir_module_items = |tcx, id| {\n         let hir = tcx.hir();\n-        let module = hir.as_local_hir_id(id);\n+        let module = hir.local_def_id_to_hir_id(id);\n         &tcx.untracked_crate.modules[&module]\n     };\n     providers.hir_owner = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].signature;\n     providers.hir_owner_nodes = |tcx, id| tcx.index_hir(LOCAL_CRATE).map[id].with_bodies.as_deref();\n     providers.fn_arg_names = |tcx, id| {\n         let hir = tcx.hir();\n-        let hir_id = hir.as_local_hir_id(id.expect_local());\n+        let hir_id = hir.local_def_id_to_hir_id(id.expect_local());\n         if let Some(body_id) = hir.maybe_body_owned_by(hir_id) {\n             tcx.arena.alloc_from_iter(hir.body_param_names(body_id))\n         } else if let Node::TraitItem(&TraitItem {"}, {"sha": "0a253e777dd9b0372e50a1a02922dda6358e28ca", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -2127,7 +2127,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n                         if let Some(def_id) = def_id.as_local() {\n-                            let hir_id = tcx.hir().as_local_hir_id(def_id);\n+                            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 let substs = tcx.lift(&substs).unwrap();\n                                 format!(\n@@ -2155,7 +2155,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n                         if let Some(def_id) = def_id.as_local() {\n-                            let hir_id = tcx.hir().as_local_hir_id(def_id);\n+                            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                             let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n "}, {"sha": "d240ae65b6dff81a85b81957e58613e4b889b320", "filename": "src/librustc_middle/mir/mono.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmono.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -198,10 +198,10 @@ impl<'tcx> MonoItem<'tcx> {\n     pub fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n         match *self {\n             MonoItem::Fn(Instance { def, .. }) => {\n-                def.def_id().as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                def.def_id().as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n             }\n             MonoItem::Static(def_id) => {\n-                def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n             }\n             MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n         }\n@@ -346,9 +346,10 @@ impl<'tcx> CodegenUnit<'tcx> {\n                             // instances into account. The others don't matter for\n                             // the codegen tests and can even make item order\n                             // unstable.\n-                            InstanceDef::Item(def) => {\n-                                def.did.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n-                            }\n+                            InstanceDef::Item(def) => def\n+                                .did\n+                                .as_local()\n+                                .map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id)),\n                             InstanceDef::VtableShim(..)\n                             | InstanceDef::ReifyShim(..)\n                             | InstanceDef::Intrinsic(..)\n@@ -360,7 +361,7 @@ impl<'tcx> CodegenUnit<'tcx> {\n                         }\n                     }\n                     MonoItem::Static(def_id) => {\n-                        def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                        def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n                     }\n                     MonoItem::GlobalAsm(hir_id) => Some(hir_id),\n                 },"}, {"sha": "d364a46463821c1995f3ff9879222713f809fe5a", "filename": "src/librustc_middle/query/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fquery%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -352,7 +352,7 @@ rustc_queries! {\n         /// per-type-parameter predicates for resolving `T::AssocTy`.\n         query type_param_predicates(key: (DefId, LocalDefId)) -> ty::GenericPredicates<'tcx> {\n             desc { |tcx| \"computing the bounds for type parameter `{}`\", {\n-                let id = tcx.hir().as_local_hir_id(key.1);\n+                let id = tcx.hir().local_def_id_to_hir_id(key.1);\n                 tcx.hir().ty_param_name(id)\n             }}\n         }"}, {"sha": "2e10c79598450d022d1f29ea02d957ebe34f7843", "filename": "src/librustc_middle/ty/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fconsts.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -88,7 +88,7 @@ impl<'tcx> Const<'tcx> {\n             ExprKind::Path(QPath::Resolved(_, &Path { res: Res::Def(ConstParam, def_id), .. })) => {\n                 // Find the name and index of the const parameter by indexing the generics of\n                 // the parent item and construct a `ParamConst`.\n-                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id.to_def_id());"}, {"sha": "4f990ece4d7967db73a57580c404b3bfb25b7dc4", "filename": "src/librustc_middle/ty/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fcontext.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -1420,7 +1420,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir().as_local_hir_id(suitable_region_binding_scope);\n+        let hir_id = self.hir().local_def_id_to_hir_id(suitable_region_binding_scope);\n         let is_impl_item = match self.hir().find(hir_id) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n@@ -1441,7 +1441,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         &self,\n         scope_def_id: LocalDefId,\n     ) -> Vec<&'tcx hir::Ty<'tcx>> {\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id);\n+        let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n         let hir_output = match self.hir().get(hir_id) {\n             Node::Item(hir::Item {\n                 kind:\n@@ -1486,7 +1486,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn return_type_impl_trait(&self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n-        let hir_id = self.hir().as_local_hir_id(scope_def_id);\n+        let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n         match self.hir().get(hir_id) {\n             Node::Item(item) => {\n                 match item.kind {"}, {"sha": "438da832226d72c68c58074905c505ba12272a4d", "filename": "src/librustc_middle/ty/error.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Ferror.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -403,7 +403,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                             .type_param(p, self)\n                             .def_id\n                             .as_local()\n-                            .map(|id| hir.as_local_hir_id(id))\n+                            .map(|id| hir.local_def_id_to_hir_id(id))\n                             .and_then(|id| self.hir().find(self.hir().get_parent_node(id)))\n                             .as_ref()\n                             .and_then(|node| node.generics())\n@@ -791,10 +791,11 @@ fn foo(&self) -> Self::T { String::new() }\n         body_owner_def_id: DefId,\n         found: Ty<'tcx>,\n     ) -> bool {\n-        let hir_id = match body_owner_def_id.as_local().map(|id| self.hir().as_local_hir_id(id)) {\n-            Some(hir_id) => hir_id,\n-            None => return false,\n-        };\n+        let hir_id =\n+            match body_owner_def_id.as_local().map(|id| self.hir().local_def_id_to_hir_id(id)) {\n+                Some(hir_id) => hir_id,\n+                None => return false,\n+            };\n         // When `body_owner` is an `impl` or `trait` item, look in its associated types for\n         // `expected` and point at it.\n         let parent_id = self.hir().get_parent_item(hir_id);"}, {"sha": "85c4cd91ebdac6a00c6015197063429206b0ebff", "filename": "src/librustc_middle/ty/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -2845,12 +2845,12 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn opt_item_name(self, def_id: DefId) -> Option<Ident> {\n         def_id\n             .as_local()\n-            .and_then(|def_id| self.hir().get(self.hir().as_local_hir_id(def_id)).ident())\n+            .and_then(|def_id| self.hir().get(self.hir().local_def_id_to_hir_id(def_id)).ident())\n     }\n \n     pub fn opt_associated_item(self, def_id: DefId) -> Option<&'tcx AssocItem> {\n         let is_associated_item = if let Some(def_id) = def_id.as_local() {\n-            match self.hir().get(self.hir().as_local_hir_id(def_id)) {\n+            match self.hir().get(self.hir().local_def_id_to_hir_id(def_id)) {\n                 Node::TraitItem(_) | Node::ImplItem(_) => true,\n                 _ => false,\n             }\n@@ -3009,7 +3009,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Gets the attributes of a definition.\n     pub fn get_attrs(self, did: DefId) -> Attributes<'tcx> {\n         if let Some(did) = did.as_local() {\n-            self.hir().attrs(self.hir().as_local_hir_id(did))\n+            self.hir().attrs(self.hir().local_def_id_to_hir_id(did))\n         } else {\n             self.item_attrs(did)\n         }\n@@ -3048,7 +3048,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if let Some(impl_did) = impl_did.as_local() {\n-            let hir_id = self.hir().as_local_hir_id(impl_did);\n+            let hir_id = self.hir().local_def_id_to_hir_id(impl_did);\n             Ok(self.hir().span(hir_id))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n@@ -3109,7 +3109,7 @@ pub struct AdtSizedConstraint<'tcx>(pub &'tcx [Ty<'tcx>]);\n /// Yields the parent function's `DefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<DefId> {\n     if let Some(def_id) = def_id.as_local() {\n-        if let Node::Item(item) = tcx.hir().get(tcx.hir().as_local_hir_id(def_id)) {\n+        if let Node::Item(item) = tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n             if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n                 return opaque_ty.impl_trait_fn;\n             }"}, {"sha": "fc444d4cc5b52635dd52973832189c53973317c5", "filename": "src/librustc_middle/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Fprint%2Fpretty.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -610,7 +610,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(did) = did.as_local() {\n-                    let hir_id = self.tcx().hir().as_local_hir_id(did);\n+                    let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n                     let span = self.tcx().hir().span(hir_id);\n                     p!(write(\"@{}\", self.tcx().sess.source_map().span_to_string(span)));\n \n@@ -656,7 +656,7 @@ pub trait PrettyPrinter<'tcx>:\n \n                 // FIXME(eddyb) should use `def_span`.\n                 if let Some(did) = did.as_local() {\n-                    let hir_id = self.tcx().hir().as_local_hir_id(did);\n+                    let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n                     if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                         p!(write(\"@\"), print_def_path(did.to_def_id(), substs));\n                     } else {"}, {"sha": "3e5eaca5417f7e622bd8daaacfdcbbc2400daca0", "filename": "src/librustc_middle/ty/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_middle%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fty%2Futil.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -879,7 +879,7 @@ impl<'tcx> ty::TyS<'tcx> {\n                         let span = match field\n                             .did\n                             .as_local()\n-                            .map(|id| tcx.hir().as_local_hir_id(id))\n+                            .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n                             .and_then(|id| tcx.hir().find(id))\n                         {\n                             Some(hir::Node::Field(field)) => field.ty.span,"}, {"sha": "7a50bdfeef625e0a25a906aa3b917241004d0471", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -263,7 +263,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             let needs_note = match ty.kind {\n                 ty::Closure(id, _) => {\n                     let tables = self.infcx.tcx.typeck(id.expect_local());\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(id.expect_local());\n+                    let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(id.expect_local());\n \n                     tables.closure_kind_origins().get(hir_id).is_none()\n                 }\n@@ -954,7 +954,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n+            let fn_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n             err.span_label(\n                 drop_span,\n                 format!(\n@@ -1863,7 +1863,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         debug!(\"annotate_fn_sig: did={:?} sig={:?}\", did, sig);\n         let is_closure = self.infcx.tcx.is_closure(did);\n-        let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(did.as_local()?);\n+        let fn_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did.as_local()?);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(fn_hir_id)?;\n \n         // We need to work out which arguments to highlight. We do this by looking"}, {"sha": "daffdec2a83bed72239b89fcfc78aa523b553688", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -104,7 +104,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 debug!(\"add_moved_or_invoked_closure_note: closure={:?}\", closure);\n                 if let ty::Closure(did, _) = self.body.local_decls[closure].ty.kind {\n                     let did = did.expect_local();\n-                    let hir_id = self.infcx.tcx.hir().as_local_hir_id(did);\n+                    let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n \n                     if let Some((span, name)) =\n                         self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n@@ -127,7 +127,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         if let Some(target) = target {\n             if let ty::Closure(did, _) = self.body.local_decls[target].ty.kind {\n                 let did = did.expect_local();\n-                let hir_id = self.infcx.tcx.hir().as_local_hir_id(did);\n+                let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(did);\n \n                 if let Some((span, name)) =\n                     self.infcx.tcx.typeck(did).closure_kind_origins().get(hir_id)\n@@ -937,7 +937,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             \"closure_span: def_id={:?} target_place={:?} places={:?}\",\n             def_id, target_place, places\n         );\n-        let hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id.as_local()?);\n+        let hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(def_id.as_local()?);\n         let expr = &self.infcx.tcx.hir().expect_expr(hir_id).kind;\n         debug!(\"closure_span: hir_id={:?} expr={:?}\", hir_id, expr);\n         if let hir::ExprKind::Closure(.., body_id, args_span, _) = expr {"}, {"sha": "d26436ff1de54d2c44697351590129653fecc72b", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();\n-        let closure_id = hir.as_local_hir_id(self.mir_def_id);\n+        let closure_id = hir.local_def_id_to_hir_id(self.mir_def_id);\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let item_id = hir.enclosing_body_owner(fn_call_id);\n@@ -691,7 +691,7 @@ fn annotate_struct_field(\n         if let ty::Adt(def, _) = ty.kind {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n-            let hir_id = tcx.hir().as_local_hir_id(field.did.as_local()?);\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(field.did.as_local()?);\n             let node = tcx.hir().find(hir_id)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type."}, {"sha": "2603b1e048d81ebe793a394dddad81d4e9db7f37", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -266,7 +266,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n+                    let mir_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n@@ -361,7 +361,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         &self,\n         argument_index: usize,\n     ) -> Option<&hir::Ty<'tcx>> {\n-        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n+        let mir_hir_id = self.infcx.tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n@@ -648,7 +648,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id);\n+        let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -700,7 +700,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id);\n+        let mir_hir_id = tcx.hir().local_def_id_to_hir_id(self.mir_def_id);\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {"}, {"sha": "f7031b2a598484963d763b63722119aaddcf141d", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -129,7 +129,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n \n     let tcx = infcx.tcx;\n     let param_env = tcx.param_env(def.did);\n-    let id = tcx.hir().as_local_hir_id(def.did);\n+    let id = tcx.hir().local_def_id_to_hir_id(def.did);\n \n     let mut local_names = IndexVec::from_elem(None, &input_body.local_decls);\n     for var_debug_info in &input_body.var_debug_info {"}, {"sha": "cd6b75cf55602cb7a3150720486190c5e269dd47", "filename": "src/librustc_mir/borrow_check/universal_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Funiversal_regions.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -231,7 +231,7 @@ impl<'tcx> UniversalRegions<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Self {\n         let tcx = infcx.tcx;\n-        let mir_hir_id = tcx.hir().as_local_hir_id(mir_def.did);\n+        let mir_hir_id = tcx.hir().local_def_id_to_hir_id(mir_def.did);\n         UniversalRegionsBuilder { infcx, mir_def, mir_hir_id, param_env }.build()\n     }\n "}, {"sha": "21915767057d01c6fc9fb98c50db39911cefae83", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -347,7 +347,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                     // validation thus preventing such a hard error from being a backwards\n                     // compatibility hazard\n                     DefKind::Const | DefKind::AssocConst => {\n-                        let hir_id = tcx.hir().as_local_hir_id(def.did);\n+                        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n                         err.report_as_lint(\n                             tcx.at(tcx.def_span(def.did)),\n                             \"any use of this value will cause an error\",\n@@ -370,7 +370,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                                 err.report_as_lint(\n                                     tcx.at(span),\n                                     \"reaching this expression at runtime will panic or abort\",\n-                                    tcx.hir().as_local_hir_id(def.did),\n+                                    tcx.hir().local_def_id_to_hir_id(def.did),\n                                     Some(err.span),\n                                 )\n                             }"}, {"sha": "9ef63b3322dd54900aea201995ee63a6bbc1d51e", "filename": "src/librustc_mir/const_eval/fn_queries.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Ffn_queries.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -90,7 +90,7 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n /// said intrinsic has a `rustc_const_{un,}stable` attribute.\n fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n "}, {"sha": "526c896df093cad5ad57a074afa68f7911cc5032", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -215,7 +215,7 @@ impl Validator<'mir, 'tcx> {\n             && !tcx.is_thread_local_static(def_id.to_def_id());\n \n         if should_check_for_sync {\n-            let hir_id = tcx.hir().as_local_hir_id(def_id);\n+            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n             check_return_ty_is_sync(tcx, &body, hir_id);\n         }\n     }"}, {"sha": "d2a5616b8ed3481edb267de9136810aa614e078c", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -483,7 +483,7 @@ fn check_unused_unsafe(\n     used_unsafe: &FxHashSet<hir::HirId>,\n     unsafe_blocks: &mut Vec<(hir::HirId, bool)>,\n ) {\n-    let body_id = tcx.hir().maybe_body_owned_by(tcx.hir().as_local_hir_id(def_id));\n+    let body_id = tcx.hir().maybe_body_owned_by(tcx.hir().local_def_id_to_hir_id(def_id));\n \n     let body_id = match body_id {\n         Some(body) => body,\n@@ -511,7 +511,7 @@ fn unsafety_check_result<'tcx>(\n \n     let param_env = tcx.param_env(def.did);\n \n-    let id = tcx.hir().as_local_hir_id(def.did);\n+    let id = tcx.hir().local_def_id_to_hir_id(def.did);\n     let (const_context, min_const_fn) = match tcx.hir().body_owner_kind(id) {\n         hir::BodyOwnerKind::Closure => (false, false),\n         hir::BodyOwnerKind::Fn => {\n@@ -532,7 +532,7 @@ fn unsafety_check_result<'tcx>(\n }\n \n fn unsafe_derive_on_repr_packed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let lint_hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let lint_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     tcx.struct_span_lint_hir(SAFE_PACKED_BORROWS, lint_hir_id, tcx.def_span(def_id), |lint| {\n         // FIXME: when we make this a hard error, this should have its"}, {"sha": "8920cb44942d6837bdf9e57e5db1338621da678e", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -67,7 +67,7 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         }\n \n         use rustc_middle::hir::map::blocks::FnLikeNode;\n-        let hir_id = tcx.hir().as_local_hir_id(source.def_id().expect_local());\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(source.def_id().expect_local());\n \n         let is_fn_like = FnLikeNode::from_node(tcx.hir().get(hir_id)).is_some();\n         let is_assoc_const = tcx.def_kind(source.def_id()) == DefKind::AssocConst;"}, {"sha": "315d4fa9d477de5e6b97079410ebfcb0baaf2713", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -75,7 +75,7 @@ impl Inliner<'tcx> {\n         let param_env = self.tcx.param_env_reveal_all_normalized(self.source.def_id());\n \n         // Only do inlining into fn bodies.\n-        let id = self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local());\n+        let id = self.tcx.hir().local_def_id_to_hir_id(self.source.def_id().expect_local());\n         if self.tcx.hir().body_owner_kind(id).is_fn_or_closure() && self.source.promoted.is_none() {\n             for (bb, bb_data) in caller_body.basic_blocks().iter_enumerated() {\n                 if let Some(callsite) =\n@@ -101,9 +101,9 @@ impl Inliner<'tcx> {\n                 }\n \n                 let callee_body = if let Some(callee_def_id) = callsite.callee.as_local() {\n-                    let callee_hir_id = self.tcx.hir().as_local_hir_id(callee_def_id);\n+                    let callee_hir_id = self.tcx.hir().local_def_id_to_hir_id(callee_def_id);\n                     let self_hir_id =\n-                        self.tcx.hir().as_local_hir_id(self.source.def_id().expect_local());\n+                        self.tcx.hir().local_def_id_to_hir_id(self.source.def_id().expect_local());\n                     // Avoid a cycle here by only using `optimized_mir` only if we have\n                     // a lower `HirId` than the callee. This ensures that the callee will\n                     // not inline us. This trick only works without incremental compilation."}, {"sha": "7abb09885ffd335dd685c07d732f1c325ff1f002", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -14,7 +14,7 @@ type McfResult = Result<(), (Span, Cow<'static, str>)>;\n pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, def_id: DefId, body: &'a Body<'tcx>) -> McfResult {\n     // Prevent const trait methods from being annotated as `stable`.\n     if tcx.features().staged_api {\n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n             return Err((body.span, \"trait methods cannot be stable const fn\".into()));\n         }"}, {"sha": "4d879469d48b8071b4f2b44ebc6a58464a1e4344", "filename": "src/librustc_mir_build/build/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -35,7 +35,7 @@ crate fn mir_built<'tcx>(\n \n /// Construct the MIR for a given `DefId`.\n fn mir_build(tcx: TyCtxt<'_>, def: ty::WithOptConstParam<LocalDefId>) -> Body<'_> {\n-    let id = tcx.hir().as_local_hir_id(def.did);\n+    let id = tcx.hir().local_def_id_to_hir_id(def.did);\n \n     // Figure out what primary body this item has.\n     let (body_id, return_ty_span) = match tcx.hir().get(id) {"}, {"sha": "662b6c7735747c04f29ba53f0c753b50c27f286c", "filename": "src/librustc_mir_build/lints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir_build%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir_build%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Flints.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -11,7 +11,7 @@ use rustc_session::lint::builtin::UNCONDITIONAL_RECURSION;\n use rustc_span::Span;\n \n crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: LocalDefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     if let Some(fn_like_node) = FnLikeNode::from_node(tcx.hir().get(hir_id)) {\n         if let FnKind::Closure(_) = fn_like_node.kind() {\n@@ -37,7 +37,7 @@ crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, def_id: LocalDefId) {\n \n         vis.reachable_recursive_calls.sort();\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id);\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let sp = tcx.sess.source_map().guess_head_span(tcx.hir().span(hir_id));\n         tcx.struct_span_lint_hir(UNCONDITIONAL_RECURSION, hir_id, sp, |lint| {\n             let mut db = lint.build(\"function cannot return without recursing\");"}, {"sha": "c51c3bcf5628845808801358cf677a915c416336", "filename": "src/librustc_mir_build/thir/cx/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fcx%2Fexpr.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -781,7 +781,7 @@ fn convert_path_expr<'a, 'tcx>(\n         }\n \n         Res::Def(DefKind::ConstParam, def_id) => {\n-            let hir_id = cx.tcx.hir().as_local_hir_id(def_id.expect_local());\n+            let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n             let item_id = cx.tcx.hir().get_parent_node(hir_id);\n             let item_def_id = cx.tcx.hir().local_def_id(item_id);\n             let generics = cx.tcx.generics_of(item_def_id);"}, {"sha": "1687286093d9c5062dade3278b6105fae1681468", "filename": "src/librustc_mir_build/thir/pattern/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fthir%2Fpattern%2Fcheck_match.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -23,7 +23,7 @@ use std::slice;\n crate fn check_match(tcx: TyCtxt<'_>, def_id: DefId) {\n     let body_id = match def_id.as_local() {\n         None => return,\n-        Some(id) => tcx.hir().body_owned_by(tcx.hir().as_local_hir_id(id)),\n+        Some(id) => tcx.hir().body_owned_by(tcx.hir().local_def_id_to_hir_id(id)),\n     };\n \n     let mut visitor = MatchVisitor {"}, {"sha": "29939c7cfafb05cd5b3a1bfbedee754a70741c6c", "filename": "src/librustc_passes/dead.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_passes%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_passes%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fdead.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -62,7 +62,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n \n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n             if should_explore(self.tcx, hir_id) || self.struct_constructors.contains_key(&hir_id) {\n                 self.worklist.push(hir_id);\n             }\n@@ -72,7 +72,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n \n     fn insert_def_id(&mut self, def_id: DefId) {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n+            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n             debug_assert!(!should_explore(self.tcx, hir_id));\n             self.live_symbols.insert(hir_id);\n         }\n@@ -461,7 +461,7 @@ fn create_and_seed_worklist<'tcx>(\n         )\n         .chain(\n             // Seed entry point\n-            tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().as_local_hir_id(def_id)),\n+            tcx.entry_fn(LOCAL_CRATE).map(|(def_id, _)| tcx.hir().local_def_id_to_hir_id(def_id)),\n         )\n         .collect::<Vec<_>>();\n \n@@ -546,7 +546,7 @@ impl DeadVisitor<'tcx> {\n         for &impl_did in inherent_impls.iter() {\n             for &item_did in &self.tcx.associated_item_def_ids(impl_did)[..] {\n                 if let Some(did) = item_did.as_local() {\n-                    let item_hir_id = self.tcx.hir().as_local_hir_id(did);\n+                    let item_hir_id = self.tcx.hir().local_def_id_to_hir_id(did);\n                     if self.live_symbols.contains(&item_hir_id) {\n                         return true;\n                     }"}, {"sha": "18fa4ada4daddba5e4bc99977175402fd08a19f4", "filename": "src/librustc_passes/reachable.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_passes%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_passes%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Freachable.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -53,7 +53,7 @@ fn method_might_be_inlined(\n             return true;\n         }\n     }\n-    match tcx.hir().find(tcx.hir().as_local_hir_id(impl_src)) {\n+    match tcx.hir().find(tcx.hir().local_def_id_to_hir_id(impl_src)) {\n         Some(Node::Item(item)) => item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n         Some(..) | None => span_bug!(impl_item.span, \"impl did is not an item\"),\n     }\n@@ -106,7 +106,9 @@ impl<'tcx> Visitor<'tcx> for ReachableContext<'tcx> {\n             }\n             Some(res) => {\n                 if let Some((hir_id, def_id)) = res.opt_def_id().and_then(|def_id| {\n-                    def_id.as_local().map(|def_id| (self.tcx.hir().as_local_hir_id(def_id), def_id))\n+                    def_id\n+                        .as_local()\n+                        .map(|def_id| (self.tcx.hir().local_def_id_to_hir_id(def_id), def_id))\n                 }) {\n                     if self.def_id_represents_local_inlined_item(def_id.to_def_id()) {\n                         self.worklist.push(hir_id);\n@@ -149,7 +151,7 @@ impl<'tcx> ReachableContext<'tcx> {\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n         let hir_id = match def_id.as_local() {\n-            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id),\n+            Some(def_id) => self.tcx.hir().local_def_id_to_hir_id(def_id),\n             None => {\n                 return false;\n             }\n@@ -181,7 +183,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n                             // does too.\n-                            let impl_hir_id = self.tcx.hir().as_local_hir_id(impl_did);\n+                            let impl_hir_id = self.tcx.hir().local_def_id_to_hir_id(impl_did);\n                             match self.tcx.hir().expect_item(impl_hir_id).kind {\n                                 hir::ItemKind::Impl { .. } => {\n                                     let generics = self.tcx.generics_of(impl_did);\n@@ -366,10 +368,10 @@ impl<'a, 'tcx> ItemLikeVisitor<'tcx> for CollectPrivateImplItemsVisitor<'a, 'tcx\n \n                 // FIXME(#53488) remove `let`\n                 let tcx = self.tcx;\n-                self.worklist.extend(\n-                    tcx.provided_trait_methods(trait_def_id)\n-                        .map(|assoc| tcx.hir().as_local_hir_id(assoc.def_id.expect_local())),\n-                );\n+                self.worklist\n+                    .extend(tcx.provided_trait_methods(trait_def_id).map(|assoc| {\n+                        tcx.hir().local_def_id_to_hir_id(assoc.def_id.expect_local())\n+                    }));\n             }\n         }\n     }\n@@ -406,7 +408,7 @@ fn reachable_set<'tcx>(tcx: TyCtxt<'tcx>, crate_num: CrateNum) -> &'tcx HirIdSet\n     reachable_context.worklist.extend(access_levels.map.iter().map(|(id, _)| *id));\n     for item in tcx.lang_items().items().iter() {\n         if let Some(did) = *item {\n-            if let Some(hir_id) = did.as_local().map(|did| tcx.hir().as_local_hir_id(did)) {\n+            if let Some(hir_id) = did.as_local().map(|did| tcx.hir().local_def_id_to_hir_id(did)) {\n                 reachable_context.worklist.push(hir_id);\n             }\n         }"}, {"sha": "1af79abe4b9119451725e451bc9530a9934140f2", "filename": "src/librustc_passes/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_passes%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_passes%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fregion.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -807,7 +807,7 @@ fn region_scope_tree(tcx: TyCtxt<'_>, def_id: DefId) -> &ScopeTree {\n         return tcx.region_scope_tree(closure_base_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let scope_tree = if let Some(body_id) = tcx.hir().maybe_body_owned_by(id) {\n         let mut visitor = RegionResolutionVisitor {\n             tcx,"}, {"sha": "91b8ae07637df001da64d72639d6ef7f9e2d9c16", "filename": "src/librustc_passes/upvars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_passes%2Fupvars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_passes%2Fupvars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_passes%2Fupvars.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -15,7 +15,7 @@ pub fn provide(providers: &mut Providers) {\n             return None;\n         }\n \n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         let body = tcx.hir().body(tcx.hir().maybe_body_owned_by(hir_id)?);\n \n         let mut local_collector = LocalCollector::default();"}, {"sha": "a5536942581be51c5a82cbd823481d567683e675", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -226,7 +226,7 @@ fn def_id_visibility<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     def_id: DefId,\n ) -> (ty::Visibility, Span, &'static str) {\n-    match def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id)) {\n+    match def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id)) {\n         Some(hir_id) => {\n             let vis = match tcx.hir().get(hir_id) {\n                 Node::Item(item) => &item.vis,\n@@ -431,7 +431,7 @@ impl VisibilityLike for Option<AccessLevel> {\n     fn new_min(find: &FindMin<'_, '_, Self>, def_id: DefId) -> Self {\n         cmp::min(\n             if let Some(def_id) = def_id.as_local() {\n-                let hir_id = find.tcx.hir().as_local_hir_id(def_id);\n+                let hir_id = find.tcx.hir().local_def_id_to_hir_id(def_id);\n                 find.access_levels.map.get(&hir_id).cloned()\n             } else {\n                 Self::MAX\n@@ -533,7 +533,7 @@ impl EmbargoVisitor<'tcx> {\n                     if let Res::Def(def_kind, def_id) = export.res {\n                         let vis = def_id_visibility(self.tcx, def_id).0;\n                         if let Some(def_id) = def_id.as_local() {\n-                            let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n+                            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                             self.update_macro_reachable_def(hir_id, def_kind, vis, defining_mod);\n                         }\n                     }\n@@ -650,7 +650,7 @@ impl EmbargoVisitor<'tcx> {\n                 // there will be no corresponding item.\n                 .filter(|def_id| def_id.index != CRATE_DEF_INDEX || def_id.krate != LOCAL_CRATE)\n                 .and_then(|def_id| {\n-                    def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n+                    def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n                 })\n                 .map(|module_hir_id| self.tcx.hir().expect_item(module_hir_id))\n             {\n@@ -913,7 +913,7 @@ impl Visitor<'tcx> for EmbargoVisitor<'tcx> {\n                     if export.vis == ty::Visibility::Public {\n                         if let Some(def_id) = export.res.opt_def_id() {\n                             if let Some(def_id) = def_id.as_local() {\n-                                let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n+                                let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 self.update(hir_id, Some(AccessLevel::Exported));\n                             }\n                         }\n@@ -1004,7 +1004,7 @@ impl DefIdVisitor<'tcx> for ReachEverythingInTheInterfaceVisitor<'_, 'tcx> {\n     }\n     fn visit_def_id(&mut self, def_id: DefId, _kind: &str, _descr: &dyn fmt::Display) -> bool {\n         if let Some(def_id) = def_id.as_local() {\n-            let hir_id = self.ev.tcx.hir().as_local_hir_id(def_id);\n+            let hir_id = self.ev.tcx.hir().local_def_id_to_hir_id(def_id);\n             if let ((ty::Visibility::Public, ..), _)\n             | (_, Some(AccessLevel::ReachableFromImplTrait)) =\n                 (def_id_visibility(self.tcx(), def_id.to_def_id()), self.access_level)\n@@ -1437,7 +1437,7 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         if let Some(did) = did.as_local() {\n             // .. and it corresponds to a private type in the AST (this returns\n             // `None` for type parameters).\n-            match self.tcx.hir().find(self.tcx.hir().as_local_hir_id(did)) {\n+            match self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(did)) {\n                 Some(Node::Item(ref item)) => !item.vis.node.is_pub(),\n                 Some(_) | None => false,\n             }\n@@ -1556,7 +1556,7 @@ impl<'a, 'tcx> Visitor<'tcx> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n                         let did = tr.path.res.def_id();\n \n                         if let Some(did) = did.as_local() {\n-                            self.trait_is_public(self.tcx.hir().as_local_hir_id(did))\n+                            self.trait_is_public(self.tcx.hir().local_def_id_to_hir_id(did))\n                         } else {\n                             true // external traits must be public\n                         }\n@@ -1815,7 +1815,7 @@ impl SearchInterfaceForPrivateItemsVisitor<'tcx> {\n         }\n \n         let hir_id = match def_id.as_local() {\n-            Some(def_id) => self.tcx.hir().as_local_hir_id(def_id),\n+            Some(def_id) => self.tcx.hir().local_def_id_to_hir_id(def_id),\n             None => return false,\n         };\n "}, {"sha": "bde72f751af8bc0191a7c216f9995d27558da1c4", "filename": "src/librustc_resolve/late/lifetimes.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flate%2Flifetimes.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -607,7 +607,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         let def = self.map.defs.get(&lifetime.hir_id).cloned();\n                         if let Some(Region::LateBound(_, def_id, _)) = def {\n                             if let Some(def_id) = def_id.as_local() {\n-                                let hir_id = self.tcx.hir().as_local_hir_id(def_id);\n+                                let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // Ensure that the parent of the def is an item, not HRTB\n                                 let parent_id = self.tcx.hir().get_parent_node(hir_id);\n                                 let parent_impl_id = hir::ImplItemId { hir_id: parent_id };\n@@ -1146,7 +1146,8 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                     if let Some(def) =\n                         lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n                     {\n-                        let hir_id = tcx.hir().as_local_hir_id(def.id().unwrap().expect_local());\n+                        let hir_id =\n+                            tcx.hir().local_def_id_to_hir_id(def.id().unwrap().expect_local());\n \n                         signal_shadowing_problem(\n                             tcx,\n@@ -1517,7 +1518,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n+                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n                     debug!(\"hir id first={:?}\", hir_id);\n                     if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n@@ -1537,7 +1538,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n                             if let Some(def_id) = parent_def_id.as_local() {\n-                                let parent_hir_id = self.tcx.hir().as_local_hir_id(def_id);\n+                                let parent_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n                                 if self.tcx.hir().attrs(parent_hir_id).iter().any(|attr| {\n                                     self.tcx.sess.check_name(attr, sym::automatically_derived)\n@@ -1575,7 +1576,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"not one use lifetime\");\n                 }\n                 None => {\n-                    let hir_id = self.tcx.hir().as_local_hir_id(def_id.expect_local());\n+                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n                     if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n                         Node::Lifetime(hir_lifetime) => Some((\n                             hir_lifetime.hir_id,\n@@ -1931,7 +1932,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             let map = &self.map;\n             let unsubst = if let Some(def_id) = def_id.as_local() {\n-                let id = self.tcx.hir().as_local_hir_id(def_id);\n+                let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                 &map.object_lifetime_defaults[&id]\n             } else {\n                 let tcx = self.tcx;\n@@ -2614,7 +2615,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n                         let hir_id =\n-                            self.tcx.hir().as_local_hir_id(def.id().unwrap().expect_local());\n+                            self.tcx.hir().local_def_id_to_hir_id(def.id().unwrap().expect_local());\n \n                         signal_shadowing_problem(\n                             self.tcx,"}, {"sha": "32e5aef00f8b8bf81b928f62002790999b017703", "filename": "src/librustc_symbol_mangling/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_symbol_mangling%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_symbol_mangling%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_symbol_mangling%2Flib.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -173,7 +173,7 @@ fn compute_symbol_name(\n             let disambiguator = tcx.sess.local_crate_disambiguator();\n             return tcx.sess.generate_proc_macro_decls_symbol(disambiguator);\n         }\n-        let hir_id = tcx.hir().as_local_hir_id(def_id);\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         match tcx.hir().get(hir_id) {\n             Node::ForeignItem(_) => true,\n             _ => false,"}, {"sha": "379c976df69e3f63abe51435b538eb55e0e431eb", "filename": "src/librustc_trait_selection/opaque_types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Fopaque_types.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -1039,7 +1039,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n                     // }\n                     // ```\n                     if let Some(def_id) = def_id.as_local() {\n-                        let opaque_hir_id = tcx.hir().as_local_hir_id(def_id);\n+                        let opaque_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                         let parent_def_id = self.parent_def_id;\n                         let def_scope_default = || {\n                             let opaque_parent_hir_id = tcx.hir().get_parent_item(opaque_hir_id);\n@@ -1205,7 +1205,7 @@ pub fn may_define_opaque_type(\n     def_id: LocalDefId,\n     opaque_hir_id: hir::HirId,\n ) -> bool {\n-    let mut hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let mut hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     // Named opaque types can be defined by any siblings or children of siblings.\n     let scope = tcx.hir().get_defining_scope(opaque_hir_id);"}, {"sha": "0097097707f320e012cf0b8cea5ad09c659bc435", "filename": "src/librustc_trait_selection/traits/chalk_fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fchalk_fulfill.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -41,7 +41,7 @@ fn environment<'tcx>(\n \n     let clauses = predicates.into_iter().map(ChalkEnvironmentClause::Predicate);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n \n     enum NodeKind {"}, {"sha": "e597843e6ce91105077e73c122b8be13c14b768a", "filename": "src/librustc_trait_selection/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -568,7 +568,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             self.tcx.sess.source_map().guess_head_span(\n                                 self.tcx.hir().span_if_local(closure_def_id).unwrap(),\n                             );\n-                        let hir_id = self.tcx.hir().as_local_hir_id(closure_def_id.expect_local());\n+                        let hir_id =\n+                            self.tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             closure_span,"}, {"sha": "7513ff6b37ef82087eceef0c02c42075f0182cfa", "filename": "src/librustc_trait_selection/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -535,7 +535,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n             };\n \n         let hir = self.tcx.hir();\n-        let hir_id = hir.as_local_hir_id(def_id.as_local()?);\n+        let hir_id = hir.local_def_id_to_hir_id(def_id.as_local()?);\n         let parent_node = hir.get_parent_node(hir_id);\n         match hir.find(parent_node) {\n             Some(hir::Node::Stmt(hir::Stmt { kind: hir::StmtKind::Local(local), .. })) => {\n@@ -1383,7 +1383,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n \n         let generator_body = generator_did\n             .as_local()\n-            .map(|def_id| hir.as_local_hir_id(def_id))\n+            .map(|def_id| hir.local_def_id_to_hir_id(def_id))\n             .and_then(|hir_id| hir.maybe_body_owned_by(hir_id))\n             .map(|body_id| hir.body(body_id));\n         let mut visitor = AwaitsVisitor::default();\n@@ -1535,7 +1535,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             .tcx\n                             .parent(generator_did)\n                             .and_then(|parent_did| parent_did.as_local())\n-                            .map(|parent_did| hir.as_local_hir_id(parent_did))\n+                            .map(|parent_did| hir.local_def_id_to_hir_id(parent_did))\n                             .and_then(|parent_hir_id| hir.opt_name(parent_hir_id))\n                             .map(|name| {\n                                 format!(\"future returned by `{}` is not {}\", name, trait_name)"}, {"sha": "4d81a3baa0edcedba098eca69d66807028800f1e", "filename": "src/librustc_trait_selection/traits/specialize/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fspecialize%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -451,7 +451,7 @@ fn report_conflicting_impls(\n             };\n             tcx.struct_span_lint_hir(\n                 lint,\n-                tcx.hir().as_local_hir_id(impl_def_id),\n+                tcx.hir().local_def_id_to_hir_id(impl_def_id),\n                 impl_span,\n                 decorate,\n             )"}, {"sha": "0f1dee7e2e006f6e5068cddec25eafbb89ba92e2", "filename": "src/librustc_ty/ty.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_ty%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_ty%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_ty%2Fty.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -126,7 +126,7 @@ fn associated_item_from_impl_item_ref(\n }\n \n fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let parent_id = tcx.hir().get_parent_item(id);\n     let parent_def_id = tcx.hir().local_def_id(parent_id);\n     let parent_item = tcx.hir().expect_item(parent_id);\n@@ -164,7 +164,7 @@ fn associated_item(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AssocItem {\n }\n \n fn impl_defaultness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::Defaultness {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(hir_id);\n     if let hir::ItemKind::Impl { defaultness, .. } = item.kind {\n         defaultness\n@@ -198,7 +198,7 @@ fn adt_sized_constraint(tcx: TyCtxt<'_>, def_id: DefId) -> ty::AdtSizedConstrain\n }\n \n fn associated_item_def_ids(tcx: TyCtxt<'_>, def_id: DefId) -> &[DefId] {\n-    let id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(id);\n     match item.kind {\n         hir::ItemKind::Trait(.., ref trait_item_refs) => tcx.arena.alloc_from_iter(\n@@ -268,7 +268,7 @@ fn param_env(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ParamEnv<'_> {\n \n     let body_id = def_id\n         .as_local()\n-        .map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+        .map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n         .map_or(hir::CRATE_HIR_ID, |id| {\n             tcx.hir().maybe_body_owned_by(id).map_or(id, |body| body.hir_id)\n         });\n@@ -360,7 +360,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n /// Check if a function is async.\n fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n "}, {"sha": "b6730328a28a6ad1fede39838bdd13e58ec1cc18", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -170,7 +170,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def: Option<&ty::GenericParamDef>,\n     ) -> ty::Region<'tcx> {\n         let tcx = self.tcx();\n-        let lifetime_name = |def_id| tcx.hir().name(tcx.hir().as_local_hir_id(def_id));\n+        let lifetime_name = |def_id| tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id));\n \n         let r = match tcx.named_region(lifetime.hir_id) {\n             Some(rl::Region::Static) => tcx.lifetimes.re_static,\n@@ -2099,7 +2099,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"find_bound_for_assoc_item: predicates={:#?}\", predicates);\n \n-        let param_hir_id = tcx.hir().as_local_hir_id(ty_param_def_id);\n+        let param_hir_id = tcx.hir().local_def_id_to_hir_id(ty_param_def_id);\n         let param_name = tcx.hir().ty_param_name(param_hir_id);\n         self.one_bound_for_assoc_type(\n             || {\n@@ -2483,7 +2483,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n             let parent_def_id = def_id\n                 .and_then(|def_id| {\n-                    def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id))\n+                    def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n                 })\n                 .map(|hir_id| tcx.hir().get_parent_did(hir_id).to_def_id());\n \n@@ -2819,7 +2819,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 assert_eq!(opt_self_ty, None);\n                 self.prohibit_generics(path.segments);\n \n-                let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n                 let item_id = tcx.hir().get_parent_node(hir_id);\n                 let item_def_id = tcx.hir().local_def_id(item_id);\n                 let generics = tcx.generics_of(item_def_id);"}, {"sha": "f0802c45ae030b5ea47d14b33170fd39a53d5e57", "filename": "src/librustc_typeck/check/coercion.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcoercion.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -1502,7 +1502,7 @@ impl<'tcx, 'exprs, E: AsCoercionSite> CoerceMany<'tcx, 'exprs, E> {\n                 let ty = AstConv::ast_ty_to_ty(fcx, ty);\n                 // Get the `impl Trait`'s `DefId`.\n                 if let ty::Opaque(def_id, _) = ty.kind {\n-                    let hir_id = fcx.tcx.hir().as_local_hir_id(def_id.expect_local());\n+                    let hir_id = fcx.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n                     // Get the `impl Trait`'s `Item` so that we can get its trait bounds and\n                     // get the `Trait`'s `DefId`.\n                     if let hir::ItemKind::OpaqueTy(hir::OpaqueTy { bounds, .. }) ="}, {"sha": "7adcd7b472e0d061dc24259f3e187fd4d8da716e", "filename": "src/librustc_typeck/check/compare_method.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcompare_method.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -77,7 +77,7 @@ fn compare_predicate_entailment<'tcx>(\n     // This node-id should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n+    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n \n     // We sometimes modify the span further down.\n     let mut cause = ObligationCause::new(\n@@ -401,7 +401,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n     trait_sig: ty::FnSig<'tcx>,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n-    let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n+    let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n     let (impl_m_output, impl_m_iter) = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n         ImplItemKind::Fn(ref impl_m_sig, _) => {\n             (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n@@ -412,7 +412,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n     match *terr {\n         TypeError::Mutability => {\n             if let Some(def_id) = trait_m.def_id.as_local() {\n-                let trait_m_hir_id = tcx.hir().as_local_hir_id(def_id);\n+                let trait_m_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                 let trait_m_iter = match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n                     TraitItemKind::Fn(ref trait_m_sig, _) => trait_m_sig.decl.inputs.iter(),\n                     _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n@@ -440,7 +440,7 @@ fn extract_spans_for_error_reporting<'a, 'tcx>(\n         }\n         TypeError::Sorts(ExpectedFound { .. }) => {\n             if let Some(def_id) = trait_m.def_id.as_local() {\n-                let trait_m_hir_id = tcx.hir().as_local_hir_id(def_id);\n+                let trait_m_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                 let (trait_m_output, trait_m_iter) =\n                     match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n                         TraitItemKind::Fn(ref trait_m_sig, _) => {\n@@ -589,7 +589,7 @@ fn compare_number_of_generics<'tcx>(\n             err_occurred = true;\n \n             let (trait_spans, impl_trait_spans) = if let Some(def_id) = trait_.def_id.as_local() {\n-                let trait_hir_id = tcx.hir().as_local_hir_id(def_id);\n+                let trait_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                 let trait_item = tcx.hir().expect_trait_item(trait_hir_id);\n                 if trait_item.generics.params.is_empty() {\n                     (Some(vec![trait_item.generics.span]), vec![])\n@@ -614,7 +614,7 @@ fn compare_number_of_generics<'tcx>(\n                 (trait_span.map(|s| vec![s]), vec![])\n             };\n \n-            let impl_hir_id = tcx.hir().as_local_hir_id(impl_.def_id.expect_local());\n+            let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_.def_id.expect_local());\n             let impl_item = tcx.hir().expect_impl_item(impl_hir_id);\n             let impl_item_impl_trait_spans: Vec<Span> = impl_item\n                 .generics\n@@ -706,7 +706,7 @@ fn compare_number_of_method_arguments<'tcx>(\n     let impl_number_args = impl_m_fty.inputs().skip_binder().len();\n     if trait_number_args != impl_number_args {\n         let trait_span = if let Some(def_id) = trait_m.def_id.as_local() {\n-            let trait_id = tcx.hir().as_local_hir_id(def_id);\n+            let trait_id = tcx.hir().local_def_id_to_hir_id(def_id);\n             match tcx.hir().expect_trait_item(trait_id).kind {\n                 TraitItemKind::Fn(ref trait_m_sig, _) => {\n                     let pos = if trait_number_args > 0 { trait_number_args - 1 } else { 0 };\n@@ -729,7 +729,7 @@ fn compare_number_of_method_arguments<'tcx>(\n         } else {\n             trait_item_span\n         };\n-        let impl_m_hir_id = tcx.hir().as_local_hir_id(impl_m.def_id.expect_local());\n+        let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n         let impl_span = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n             ImplItemKind::Fn(ref impl_m_sig, _) => {\n                 let pos = if impl_number_args > 0 { impl_number_args - 1 } else { 0 };\n@@ -811,7 +811,7 @@ fn compare_synthetic_generics<'tcx>(\n         impl_m_type_params.zip(trait_m_type_params)\n     {\n         if impl_synthetic != trait_synthetic {\n-            let impl_hir_id = tcx.hir().as_local_hir_id(impl_def_id.expect_local());\n+            let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_def_id.expect_local());\n             let impl_span = tcx.hir().span(impl_hir_id);\n             let trait_span = tcx.def_span(trait_def_id);\n             let mut err = struct_span_err!(\n@@ -832,10 +832,10 @@ fn compare_synthetic_generics<'tcx>(\n                         // FIXME: this is obviously suboptimal since the name can already be used\n                         // as another generic argument\n                         let new_name = tcx.sess.source_map().span_to_snippet(trait_span).ok()?;\n-                        let trait_m = tcx.hir().as_local_hir_id(trait_m.def_id.as_local()?);\n+                        let trait_m = tcx.hir().local_def_id_to_hir_id(trait_m.def_id.as_local()?);\n                         let trait_m = tcx.hir().trait_item(hir::TraitItemId { hir_id: trait_m });\n \n-                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?);\n+                        let impl_m = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.as_local()?);\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n \n                         // in case there are no generics, take the spot between the function name\n@@ -869,7 +869,7 @@ fn compare_synthetic_generics<'tcx>(\n                 (None, Some(hir::SyntheticTyParamKind::ImplTrait)) => {\n                     err.span_label(impl_span, \"expected `impl Trait`, found generic parameter\");\n                     (|| {\n-                        let impl_m = tcx.hir().as_local_hir_id(impl_m.def_id.as_local()?);\n+                        let impl_m = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.as_local()?);\n                         let impl_m = tcx.hir().impl_item(hir::ImplItemId { hir_id: impl_m });\n                         let input_tys = match impl_m.kind {\n                             hir::ImplItemKind::Fn(ref sig, _) => sig.decl.inputs,\n@@ -962,7 +962,7 @@ crate fn compare_const_impl<'tcx>(\n \n         // Create a parameter environment that represents the implementation's\n         // method.\n-        let impl_c_hir_id = tcx.hir().as_local_hir_id(impl_c.def_id.expect_local());\n+        let impl_c_hir_id = tcx.hir().local_def_id_to_hir_id(impl_c.def_id.expect_local());\n \n         // Compute placeholder form of impl and trait const tys.\n         let impl_ty = tcx.type_of(impl_c.def_id);\n@@ -1011,7 +1011,7 @@ crate fn compare_const_impl<'tcx>(\n             );\n \n             let trait_c_hir_id =\n-                trait_c.def_id.as_local().map(|def_id| tcx.hir().as_local_hir_id(def_id));\n+                trait_c.def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id));\n             let trait_c_span = trait_c_hir_id.map(|trait_c_hir_id| {\n                 // Add a label to the Span containing just the type of the const\n                 match tcx.hir().expect_trait_item(trait_c_hir_id).kind {\n@@ -1101,7 +1101,7 @@ fn compare_type_predicate_entailment<'tcx>(\n     // This `HirId` should be used for the `body_id` field on each\n     // `ObligationCause` (and the `FnCtxt`). This is what\n     // `regionck_item` expects.\n-    let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id.expect_local());\n+    let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n     let cause = ObligationCause::new(\n         impl_ty_span,\n         impl_ty_hir_id,\n@@ -1240,7 +1240,7 @@ fn compare_projection_bounds<'tcx>(\n         let infcx = &inh.infcx;\n         let mut selcx = traits::SelectionContext::new(&infcx);\n \n-        let impl_ty_hir_id = tcx.hir().as_local_hir_id(impl_ty.def_id.expect_local());\n+        let impl_ty_hir_id = tcx.hir().local_def_id_to_hir_id(impl_ty.def_id.expect_local());\n         let normalize_cause = traits::ObligationCause::misc(impl_ty_span, impl_ty_hir_id);\n         let cause = ObligationCause::new(\n             impl_ty_span,"}, {"sha": "434886538fb4d99b4a36bcfccf7405e13187ae39", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -70,7 +70,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n     drop_impl_ty: Ty<'tcx>,\n     self_type_did: DefId,\n ) -> Result<(), ErrorReported> {\n-    let drop_impl_hir_id = tcx.hir().as_local_hir_id(drop_impl_did);\n+    let drop_impl_hir_id = tcx.hir().local_def_id_to_hir_id(drop_impl_did);\n \n     // check that the impl type can be made to match the trait type.\n \n@@ -183,7 +183,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    let self_type_hir_id = tcx.hir().as_local_hir_id(self_type_did);\n+    let self_type_hir_id = tcx.hir().local_def_id_to_hir_id(self_type_did);\n \n     // We can assume the predicates attached to struct/enum definition\n     // hold."}, {"sha": "e88f13a1f3ab68576acd1f10a5cd42dadfecbd93", "filename": "src/librustc_typeck/check/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fexpr.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -1606,7 +1606,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n         let param_def_id = generic_param.def_id;\n         let param_hir_id = match param_def_id.as_local() {\n-            Some(x) => self.tcx.hir().as_local_hir_id(x),\n+            Some(x) => self.tcx.hir().local_def_id_to_hir_id(x),\n             None => return,\n         };\n         let param_span = self.tcx.hir().span(param_hir_id);"}, {"sha": "e941c844a6d9058113a018e0d2fa6ab561275399", "filename": "src/librustc_typeck/check/method/suggest.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fsuggest.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -579,7 +579,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                             {\n                                 if let ty::Adt(def, _) = p.trait_ref.self_ty().kind {\n                                     let node = def.did.as_local().map(|def_id| {\n-                                        self.tcx.hir().get(self.tcx.hir().as_local_hir_id(def_id))\n+                                        self.tcx\n+                                            .hir()\n+                                            .get(self.tcx.hir().local_def_id_to_hir_id(def_id))\n                                     });\n                                     if let Some(hir::Node::Item(hir::Item { kind, .. })) = node {\n                                         if let Some(g) = kind.generics() {\n@@ -859,7 +861,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         candidates: Vec<DefId>,\n     ) {\n         let module_did = self.tcx.parent_module(self.body_id);\n-        let module_id = self.tcx.hir().as_local_hir_id(module_did);\n+        let module_id = self.tcx.hir().local_def_id_to_hir_id(module_did);\n         let krate = self.tcx.hir().krate();\n         let (span, found_use) = UsePlacementFinder::check(self.tcx, krate, module_id);\n         if let Some(span) = span {\n@@ -975,7 +977,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 let id = item\n                                     .def_id\n                                     .as_local()\n-                                    .map(|def_id| self.tcx.hir().as_local_hir_id(def_id));\n+                                    .map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id));\n                                 if let Some(hir::Node::TraitItem(hir::TraitItem {\n                                     kind: hir::TraitItemKind::Fn(fn_sig, method),\n                                     ..\n@@ -1062,7 +1064,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 let type_param = generics.type_param(param, self.tcx);\n                 let hir = &self.tcx.hir();\n                 if let Some(def_id) = type_param.def_id.as_local() {\n-                    let id = hir.as_local_hir_id(def_id);\n+                    let id = hir.local_def_id_to_hir_id(def_id);\n                     // Get the `hir::Param` to verify whether it already has any bounds.\n                     // We do this to avoid suggesting code that ends up as `T: FooBar`,\n                     // instead we suggest `T: Foo + Bar` in that case."}, {"sha": "66400743e9528138347d1549066fccb1aebad40c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -974,7 +974,7 @@ fn typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tc\n /// Currently only used for type inference of `static`s and `const`s to avoid type cycle errors.\n fn diagnostic_only_typeck<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &ty::TypeckResults<'tcx> {\n     let fallback = move || {\n-        let span = tcx.hir().span(tcx.hir().as_local_hir_id(def_id));\n+        let span = tcx.hir().span(tcx.hir().local_def_id_to_hir_id(def_id));\n         tcx.ty_error_with_message(span, \"diagnostic only typeck table used\")\n     };\n     typeck_with_fallback(tcx, def_id, fallback)\n@@ -992,7 +992,7 @@ fn typeck_with_fallback<'tcx>(\n         return tcx.typeck(outer_def_id);\n     }\n \n-    let id = tcx.hir().as_local_hir_id(def_id);\n+    let id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let span = tcx.hir().span(id);\n \n     // Figure out what primary body this item has.\n@@ -1333,7 +1333,7 @@ fn check_fn<'a, 'tcx>(\n     }\n \n     let outer_def_id = tcx.closure_base_def_id(hir.local_def_id(fn_id).to_def_id()).expect_local();\n-    let outer_hir_id = hir.as_local_hir_id(outer_def_id);\n+    let outer_hir_id = hir.local_def_id_to_hir_id(outer_def_id);\n     GatherLocalsVisitor { fcx: &fcx, parent_id: outer_hir_id }.visit_body(body);\n \n     // C-variadic fns also have a `VaList` input that's not listed in `fn_sig`\n@@ -1444,7 +1444,7 @@ fn check_fn<'a, 'tcx>(\n     // Check that the main return type implements the termination trait.\n     if let Some(term_id) = tcx.lang_items().termination() {\n         if let Some((def_id, EntryFnType::Main)) = tcx.entry_fn(LOCAL_CRATE) {\n-            let main_id = hir.as_local_hir_id(def_id);\n+            let main_id = hir.local_def_id_to_hir_id(def_id);\n             if main_id == fn_id {\n                 let substs = tcx.mk_substs_trait(declared_ret_ty, &[]);\n                 let trait_ref = ty::TraitRef::new(term_id, substs);\n@@ -1622,7 +1622,7 @@ fn check_opaque<'tcx>(\n /// Checks that an opaque type does not use `Self` or `T::Foo` projections that would result\n /// in \"inheriting lifetimes\".\n fn check_opaque_for_inheriting_lifetimes(tcx: TyCtxt<'tcx>, def_id: LocalDefId, span: Span) {\n-    let item = tcx.hir().expect_item(tcx.hir().as_local_hir_id(def_id));\n+    let item = tcx.hir().expect_item(tcx.hir().local_def_id_to_hir_id(def_id));\n     debug!(\n         \"check_opaque_for_inheriting_lifetimes: def_id={:?} span={:?} item={:?}\",\n         def_id, span, item\n@@ -1729,7 +1729,7 @@ fn get_owner_return_paths(\n     tcx: TyCtxt<'tcx>,\n     def_id: LocalDefId,\n ) -> Option<(hir::HirId, ReturnsVisitor<'tcx>)> {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let id = tcx.hir().get_parent_item(hir_id);\n     tcx.hir()\n         .find(id)\n@@ -1833,7 +1833,7 @@ fn binding_opaque_type_cycle_error(\n     let mut err = struct_span_err!(tcx.sess, span, E0720, \"cannot resolve opaque type\");\n     err.span_label(span, \"cannot resolve opaque type\");\n     // Find the the owner that declared this `impl Trait` type.\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let mut prev_hir_id = hir_id;\n     let mut hir_id = tcx.hir().get_parent_node(hir_id);\n     while let Some(node) = tcx.hir().find(hir_id) {\n@@ -1858,7 +1858,7 @@ fn binding_opaque_type_cycle_error(\n                 source: hir::LocalSource::Normal,\n                 ..\n             }) => {\n-                let hir_id = tcx.hir().as_local_hir_id(def_id);\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                 let typeck_results =\n                     tcx.typeck(tcx.hir().local_def_id(tcx.hir().get_parent_item(hir_id)));\n                 if let Some(ty) = typeck_results.node_type_opt(expr.hir_id) {\n@@ -2874,7 +2874,7 @@ pub fn check_enum<'tcx>(\n         // Check for duplicate discriminant values\n         if let Some(i) = disr_vals.iter().position(|&x| x.val == discr.val) {\n             let variant_did = def.variants[VariantIdx::new(i)].def_id;\n-            let variant_i_hir_id = tcx.hir().as_local_hir_id(variant_did.expect_local());\n+            let variant_i_hir_id = tcx.hir().local_def_id_to_hir_id(variant_did.expect_local());\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n@@ -2935,7 +2935,7 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n \n     fn get_type_parameter_bounds(&self, _: Span, def_id: DefId) -> ty::GenericPredicates<'tcx> {\n         let tcx = self.tcx;\n-        let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         let item_id = tcx.hir().ty_param_owner(hir_id);\n         let item_def_id = tcx.hir().local_def_id(item_id);\n         let generics = tcx.generics_of(item_def_id);"}, {"sha": "66fb01a54f5741256a76bc28222eb5b1375128ed", "filename": "src/librustc_typeck/check/op.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fop.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -933,7 +933,7 @@ fn suggest_constraining_param(\n     let param_def_id = generics.type_param(&p, tcx).def_id;\n     if let Some(generics) = param_def_id\n         .as_local()\n-        .map(|id| hir.as_local_hir_id(id))\n+        .map(|id| hir.local_def_id_to_hir_id(id))\n         .and_then(|id| hir.find(hir.get_parent_item(id)))\n         .as_ref()\n         .and_then(|node| node.generics())"}, {"sha": "2bde5d2c78cc195378fb8e645afb44672628cd43", "filename": "src/librustc_typeck/check/wfcheck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwfcheck.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -71,7 +71,7 @@ impl<'tcx> CheckWfFcxBuilder<'tcx> {\n /// not included it frequently leads to confusing errors in fn bodies. So it's better to check\n /// the types first.\n pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let item = tcx.hir().expect_item(hir_id);\n \n     debug!(\n@@ -190,7 +190,7 @@ pub fn check_item_well_formed(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n }\n \n pub fn check_trait_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let trait_item = tcx.hir().expect_trait_item(hir_id);\n \n     let method_sig = match trait_item.kind {\n@@ -264,7 +264,7 @@ fn check_object_unsafe_self_trait_by_name(tcx: TyCtxt<'_>, item: &hir::TraitItem\n }\n \n pub fn check_impl_item(tcx: TyCtxt<'_>, def_id: LocalDefId) {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let impl_item = tcx.hir().expect_impl_item(hir_id);\n \n     let method_sig = match impl_item.kind {\n@@ -902,7 +902,7 @@ fn check_opaque_types<'fcx, 'tcx>(\n                 let generics = tcx.generics_of(def_id);\n \n                 let opaque_hir_id = if let Some(local_id) = def_id.as_local() {\n-                    tcx.hir().as_local_hir_id(local_id)\n+                    tcx.hir().local_def_id_to_hir_id(local_id)\n                 } else {\n                     // Opaque types from other crates won't have defining uses in this crate.\n                     return ty;"}, {"sha": "50e2d6a94bb71082b07763d69b10fddeca049eba", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -433,7 +433,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n-            let hir_id = self.tcx().hir().as_local_hir_id(def_id.expect_local());\n+            let hir_id = self.tcx().hir().local_def_id_to_hir_id(def_id.expect_local());\n             let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());"}, {"sha": "4fda8932e213b0d294e1712dc94587b123eb2d23", "filename": "src/librustc_typeck/check_unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck_unused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcheck_unused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck_unused.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -88,7 +88,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n             // Note that if we carry through to the `extern_mod_stmt_cnum` query\n             // below it'll cause a panic because `def_id` is actually bogus at this\n             // point in time otherwise.\n-            if tcx.hir().find(tcx.hir().as_local_hir_id(def_id)).is_none() {\n+            if tcx.hir().find(tcx.hir().local_def_id_to_hir_id(def_id)).is_none() {\n                 return false;\n             }\n             true\n@@ -113,7 +113,7 @@ fn unused_crates_lint(tcx: TyCtxt<'_>) {\n \n     for extern_crate in &crates_to_lint {\n         let def_id = extern_crate.def_id.expect_local();\n-        let id = tcx.hir().as_local_hir_id(def_id);\n+        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let item = tcx.hir().expect_item(id);\n \n         // If the crate is fully unused, we suggest removing it altogether."}, {"sha": "56a737964c0479809caa9ba85642d015bec8aefb", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -54,7 +54,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n         return;\n     }\n \n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n+    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n     let sp = match tcx.hir().expect_item(impl_hir_id).kind {\n         ItemKind::Impl { self_ty, .. } => self_ty.span,\n         _ => bug!(\"expected Drop impl item\"),\n@@ -73,7 +73,7 @@ fn visit_implementation_of_drop(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n fn visit_implementation_of_copy(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_copy: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n+    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n \n     let self_type = tcx.type_of(impl_did);\n     debug!(\"visit_implementation_of_copy: self_type={:?} (bound)\", self_type);\n@@ -146,7 +146,7 @@ fn visit_implementation_of_coerce_unsized(tcx: TyCtxt<'tcx>, impl_did: LocalDefI\n fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: LocalDefId) {\n     debug!(\"visit_implementation_of_dispatch_from_dyn: impl_did={:?}\", impl_did);\n \n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did);\n+    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did);\n     let span = tcx.hir().span(impl_hir_id);\n \n     let dispatch_from_dyn_trait = tcx.require_lang_item(DispatchFromDynTraitLangItem, Some(span));\n@@ -315,7 +315,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n     debug!(\"compute_coerce_unsized_info(impl_did={:?})\", impl_did);\n \n     // this provider should only get invoked for local def-ids\n-    let impl_hir_id = tcx.hir().as_local_hir_id(impl_did.expect_local());\n+    let impl_hir_id = tcx.hir().local_def_id_to_hir_id(impl_did.expect_local());\n     let span = tcx.hir().span(impl_hir_id);\n \n     let coerce_unsized_trait = tcx.require_lang_item(CoerceUnsizedTraitLangItem, Some(span));"}, {"sha": "da1f3ea62f239716d15bf11a25ec6c6cf4fdb9dd", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -275,7 +275,7 @@ impl ItemCtxt<'tcx> {\n     }\n \n     pub fn hir_id(&self) -> hir::HirId {\n-        self.tcx.hir().as_local_hir_id(self.item_def_id.expect_local())\n+        self.tcx.hir().local_def_id_to_hir_id(self.item_def_id.expect_local())\n     }\n \n     pub fn node(&self) -> hir::Node<'tcx> {\n@@ -490,7 +490,7 @@ fn type_param_predicates(\n     // written inline like `<T: Foo>` or in a where-clause like\n     // `where T: Foo`.\n \n-    let param_id = tcx.hir().as_local_hir_id(def_id);\n+    let param_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let param_owner = tcx.hir().ty_param_owner(param_id);\n     let param_owner_def_id = tcx.hir().local_def_id(param_owner);\n     let generics = tcx.generics_of(param_owner_def_id);\n@@ -512,7 +512,7 @@ fn type_param_predicates(\n         .unwrap_or_default();\n     let mut extend = None;\n \n-    let item_hir_id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n+    let item_hir_id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n     let ast_generics = match tcx.hir().get(item_hir_id) {\n         Node::TraitItem(item) => &item.generics,\n \n@@ -824,7 +824,7 @@ fn convert_variant(\n     parent_did: LocalDefId,\n ) -> ty::VariantDef {\n     let mut seen_fields: FxHashMap<Ident, Span> = Default::default();\n-    let hir_id = tcx.hir().as_local_hir_id(variant_did.unwrap_or(parent_did));\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(variant_did.unwrap_or(parent_did));\n     let fields = def\n         .fields()\n         .iter()\n@@ -878,7 +878,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n     use rustc_hir::*;\n \n     let def_id = def_id.expect_local();\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let item = match tcx.hir().get(hir_id) {\n         Node::Item(item) => item,\n         _ => bug!(),\n@@ -965,7 +965,7 @@ fn adt_def(tcx: TyCtxt<'_>, def_id: DefId) -> &ty::AdtDef {\n /// the transitive super-predicates are converted.\n fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredicates<'_> {\n     debug!(\"super_predicates(trait_def_id={:?})\", trait_def_id);\n-    let trait_hir_id = tcx.hir().as_local_hir_id(trait_def_id.expect_local());\n+    let trait_hir_id = tcx.hir().local_def_id_to_hir_id(trait_def_id.expect_local());\n \n     let item = match tcx.hir().get(trait_hir_id) {\n         Node::Item(item) => item,\n@@ -1016,7 +1016,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n }\n \n fn trait_def(tcx: TyCtxt<'_>, def_id: DefId) -> ty::TraitDef {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let item = tcx.hir().expect_item(hir_id);\n \n     let (is_auto, unsafety) = match item.kind {\n@@ -1194,7 +1194,7 @@ impl<'v> Visitor<'v> for AnonConstInParamListDetector {\n fn generics_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::Generics {\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n \n     let node = tcx.hir().get(hir_id);\n     let parent_def_id = match node {\n@@ -1499,7 +1499,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n     use rustc_hir::*;\n \n     let def_id = def_id.expect_local();\n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n \n@@ -1597,7 +1597,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n     let icx = ItemCtxt::new(tcx, def_id);\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     match tcx.hir().expect_item(hir_id).kind {\n         hir::ItemKind::Impl { ref of_trait, .. } => of_trait.as_ref().map(|ast_trait_ref| {\n             let selfty = tcx.type_of(def_id);\n@@ -1608,7 +1608,7 @@ fn impl_trait_ref(tcx: TyCtxt<'_>, def_id: DefId) -> Option<ty::TraitRef<'_>> {\n }\n \n fn impl_polarity(tcx: TyCtxt<'_>, def_id: DefId) -> ty::ImplPolarity {\n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let is_rustc_reservation = tcx.has_attr(def_id, sym::rustc_reservation_impl);\n     let item = tcx.hir().expect_item(hir_id);\n     match &item.kind {\n@@ -1738,7 +1738,7 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id.expect_local());\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let node = tcx.hir().get(hir_id);\n \n     let mut is_trait = None;\n@@ -2590,7 +2590,7 @@ fn codegen_fn_attrs(tcx: TyCtxt<'_>, id: DefId) -> CodegenFnAttrs {\n     if !codegen_fn_attrs.no_sanitize.is_empty() {\n         if codegen_fn_attrs.inline == InlineAttr::Always {\n             if let (Some(no_sanitize_span), Some(inline_span)) = (no_sanitize_span, inline_span) {\n-                let hir_id = tcx.hir().as_local_hir_id(id.expect_local());\n+                let hir_id = tcx.hir().local_def_id_to_hir_id(id.expect_local());\n                 tcx.struct_span_lint_hir(\n                     lint::builtin::INLINE_NO_SANITIZE,\n                     hir_id,\n@@ -2718,7 +2718,7 @@ fn check_target_feature_safe_fn(tcx: TyCtxt<'_>, id: DefId, attr_span: Span) {\n /// Checks the function annotated with `#[target_feature]` is not a safe\n /// trait method implementation, reporting an error if it is.\n fn check_target_feature_trait_unsafe(tcx: TyCtxt<'_>, id: LocalDefId, attr_span: Span) {\n-    let hir_id = tcx.hir().as_local_hir_id(id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n     let node = tcx.hir().get(hir_id);\n     if let Node::ImplItem(hir::ImplItem { kind: hir::ImplItemKind::Fn(..), .. }) = node {\n         let parent_id = tcx.hir().get_parent_item(hir_id);"}, {"sha": "f1478c8c952f87c7cd103ce12d22b1bdb0994057", "filename": "src/librustc_typeck/collect/type_of.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect%2Ftype_of.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -23,7 +23,7 @@ use super::{bad_placeholder_type, is_suggestable_infer_ty};\n pub(super) fn opt_const_param_of(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Option<DefId> {\n     use hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     if let Node::AnonConst(_) = tcx.hir().get(hir_id) {\n         let parent_node_id = tcx.hir().get_parent_node(hir_id);\n@@ -138,7 +138,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n     let def_id = def_id.expect_local();\n     use rustc_hir::*;\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n     let icx = ItemCtxt::new(tcx, def_id.to_def_id());\n \n@@ -564,7 +564,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n         }\n     }\n \n-    let hir_id = tcx.hir().as_local_hir_id(def_id);\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let scope = tcx.hir().get_defining_scope(hir_id);\n     let mut locator = ConstraintLocator { def_id: def_id.to_def_id(), tcx, found: None };\n \n@@ -617,7 +617,7 @@ fn find_opaque_ty_constraints(tcx: TyCtxt<'_>, def_id: LocalDefId) -> Ty<'_> {\n ///    by the time we borrow check, and it's not clear how we should handle\n ///    those.\n fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty<'_> {\n-    let scope = tcx.hir().get_defining_scope(tcx.hir().as_local_hir_id(opaque_ty_id));\n+    let scope = tcx.hir().get_defining_scope(tcx.hir().local_def_id_to_hir_id(opaque_ty_id));\n     let scope_def_id = tcx.hir().local_def_id(scope);\n \n     let opaque_ty_def_id = opaque_ty_id.to_def_id();\n@@ -653,7 +653,7 @@ fn let_position_impl_trait_type(tcx: TyCtxt<'_>, opaque_ty_id: LocalDefId) -> Ty\n     if concrete_ty.has_erased_regions() {\n         // FIXME(impl_trait_in_bindings) Handle this case.\n         tcx.sess.span_fatal(\n-            tcx.hir().span(tcx.hir().as_local_hir_id(opaque_ty_id)),\n+            tcx.hir().span(tcx.hir().local_def_id_to_hir_id(opaque_ty_id)),\n             \"lifetimes in impl Trait types in bindings are not currently supported\",\n         );\n     }"}, {"sha": "3746e5778aacdb740694fc3adf08952e710cff8e", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -336,7 +336,7 @@ fn check_predicates<'tcx>(\n         if let Some(obligations) = wf::obligations(\n             infcx,\n             tcx.param_env(impl1_def_id),\n-            tcx.hir().as_local_hir_id(impl1_def_id),\n+            tcx.hir().local_def_id_to_hir_id(impl1_def_id),\n             arg,\n             span,\n         ) {"}, {"sha": "41639c53b79918f06c80b70eb3831151fa6de926", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -153,7 +153,7 @@ fn require_same_types<'tcx>(\n }\n \n fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n-    let main_id = tcx.hir().as_local_hir_id(main_def_id);\n+    let main_id = tcx.hir().local_def_id_to_hir_id(main_def_id);\n     let main_span = tcx.def_span(main_def_id);\n     let main_t = tcx.type_of(main_def_id);\n     match main_t.kind {\n@@ -249,7 +249,7 @@ fn check_main_fn_ty(tcx: TyCtxt<'_>, main_def_id: LocalDefId) {\n }\n \n fn check_start_fn_ty(tcx: TyCtxt<'_>, start_def_id: LocalDefId) {\n-    let start_id = tcx.hir().as_local_hir_id(start_def_id);\n+    let start_id = tcx.hir().local_def_id_to_hir_id(start_def_id);\n     let start_span = tcx.def_span(start_def_id);\n     let start_t = tcx.type_of(start_def_id);\n     match start_t.kind {"}, {"sha": "762d4216f7060bf5115ff9e60b869cbf247f84e7", "filename": "src/librustc_typeck/outlives/implicit_infer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fimplicit_infer.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -57,7 +57,7 @@ impl<'cx, 'tcx> ItemLikeVisitor<'tcx> for InferVisitor<'cx, 'tcx> {\n \n         debug!(\"InferVisitor::visit_item(item={:?})\", item_did);\n \n-        let hir_id = self.tcx.hir().as_local_hir_id(item_did);\n+        let hir_id = self.tcx.hir().local_def_id_to_hir_id(item_did);\n         let item = match self.tcx.hir().get(hir_id) {\n             Node::Item(item) => item,\n             _ => bug!(),"}, {"sha": "94926f480e23e3227ef8b2d2e3d47fc9133bf528", "filename": "src/librustc_typeck/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Foutlives%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -18,7 +18,7 @@ pub fn provide(providers: &mut Providers) {\n }\n \n fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate<'_>, Span)] {\n-    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n+    let id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n \n     match tcx.hir().get(id) {\n         Node::Item(item) => match item.kind {"}, {"sha": "535530a2ed494cb5e7bd44289ce3f679262954c4", "filename": "src/librustc_typeck/variance/constraints.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fconstraints.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -137,7 +137,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n             return;\n         }\n \n-        let id = tcx.hir().as_local_hir_id(def_id);\n+        let id = tcx.hir().local_def_id_to_hir_id(def_id);\n         let inferred_start = self.terms_cx.inferred_starts[&id];\n         let current_item = &CurrentItem { inferred_start };\n         match tcx.type_of(def_id).kind {\n@@ -375,7 +375,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         }\n \n         let (local, remote) = if let Some(def_id) = def_id.as_local() {\n-            let id = self.tcx().hir().as_local_hir_id(def_id);\n+            let id = self.tcx().hir().local_def_id_to_hir_id(def_id);\n             (Some(self.terms_cx.inferred_starts[&id]), None)\n         } else {\n             (None, Some(self.tcx().variances_of(def_id)))"}, {"sha": "a893f69c48adab6536ebb1614a9090b5570cacb9", "filename": "src/librustc_typeck/variance/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -39,7 +39,7 @@ fn crate_variances(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CrateVariancesMap<'_\n }\n \n fn variances_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[ty::Variance] {\n-    let id = tcx.hir().as_local_hir_id(item_def_id.expect_local());\n+    let id = tcx.hir().local_def_id_to_hir_id(item_def_id.expect_local());\n     let unsupported = || {\n         // Variance not relevant.\n         span_bug!(tcx.hir().span(id), \"asked to compute variance for wrong kind of item\")"}, {"sha": "f61a783de694be6e499067e6578e26bad09f19d0", "filename": "src/librustc_typeck/variance/terms.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance%2Fterms.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -94,7 +94,9 @@ fn lang_items(tcx: TyCtxt<'_>) -> Vec<(hir::HirId, Vec<ty::Variance>)> {\n     all.into_iter() // iterating over (Option<DefId>, Variance)\n         .filter(|&(ref d, _)| d.is_some())\n         .map(|(d, v)| (d.unwrap(), v)) // (DefId, Variance)\n-        .filter_map(|(d, v)| d.as_local().map(|d| tcx.hir().as_local_hir_id(d)).map(|n| (n, v))) // (HirId, Variance)\n+        .filter_map(|(d, v)| {\n+            d.as_local().map(|d| tcx.hir().local_def_id_to_hir_id(d)).map(|n| (n, v))\n+        }) // (HirId, Variance)\n         .collect()\n }\n "}, {"sha": "cb7c62e3a5ac64759916b85a6e53b399ce03769e", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -356,7 +356,7 @@ pub fn build_impl(\n     }\n \n     let for_ = if let Some(did) = did.as_local() {\n-        let hir_id = tcx.hir().as_local_hir_id(did);\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n         match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl { self_ty, .. } => self_ty.clean(cx),\n             _ => panic!(\"did given to build_impl was not an impl\"),\n@@ -377,7 +377,7 @@ pub fn build_impl(\n \n     let predicates = tcx.explicit_predicates_of(did);\n     let (trait_items, generics) = if let Some(did) = did.as_local() {\n-        let hir_id = tcx.hir().as_local_hir_id(did);\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(did);\n         match tcx.hir().expect_item(hir_id).kind {\n             hir::ItemKind::Impl { ref generics, ref items, .. } => (\n                 items.iter().map(|item| tcx.hir().impl_item(item.id).clean(cx)).collect::<Vec<_>>(),\n@@ -500,7 +500,7 @@ fn build_module(cx: &DocContext<'_>, did: DefId, visited: &mut FxHashSet<DefId>)\n \n pub fn print_inlined_const(cx: &DocContext<'_>, did: DefId) -> String {\n     if let Some(did) = did.as_local() {\n-        let hir_id = cx.tcx.hir().as_local_hir_id(did);\n+        let hir_id = cx.tcx.hir().local_def_id_to_hir_id(did);\n         rustc_hir_pretty::id_to_string(&cx.tcx.hir(), hir_id)\n     } else {\n         cx.tcx.rendered_const(did)\n@@ -513,7 +513,7 @@ fn build_const(cx: &DocContext<'_>, did: DefId) -> clean::Constant {\n         expr: print_inlined_const(cx, did),\n         value: clean::utils::print_evaluated_const(cx, did),\n         is_literal: did.as_local().map_or(false, |did| {\n-            clean::utils::is_literal_expr(cx, cx.tcx.hir().as_local_hir_id(did))\n+            clean::utils::is_literal_expr(cx, cx.tcx.hir().local_def_id_to_hir_id(did))\n         }),\n     }\n }"}, {"sha": "3ad357e583cf1d0fbfa4e1a19181bc23197841f9", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -1382,7 +1382,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                 if let Res::Def(DefKind::TyAlias, def_id) = path.res {\n                     // Substitute private type aliases\n                     if let Some(def_id) = def_id.as_local() {\n-                        let hir_id = cx.tcx.hir().as_local_hir_id(def_id);\n+                        let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n                         if !cx.renderinfo.borrow().access_levels.is_exported(def_id.to_def_id()) {\n                             alias = Some(&cx.tcx.hir().expect_item(hir_id).kind);\n                         }"}, {"sha": "e46c6c46cecae7e027123ab79964b80ab1c823d2", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -471,7 +471,7 @@ pub fn print_const(cx: &DocContext<'_>, n: &'tcx ty::Const<'_>) -> String {\n     match n.val {\n         ty::ConstKind::Unevaluated(def, _, promoted) => {\n             let mut s = if let Some(def) = def.as_local() {\n-                let hir_id = cx.tcx.hir().as_local_hir_id(def.did);\n+                let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def.did);\n                 print_const_expr(cx, cx.tcx.hir().body_owned_by(hir_id))\n             } else {\n                 inline::print_inlined_const(cx, def.did)"}, {"sha": "c21fd8da0ed9af4953e0cf1c274b5147eb41641d", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -143,13 +143,13 @@ impl<'tcx> DocContext<'tcx> {\n         def_id\n     }\n \n-    /// Like the function of the same name on the HIR map, but skips calling it on fake DefIds.\n+    /// Like `hir().local_def_id_to_hir_id()`, but skips calling it on fake DefIds.\n     /// (This avoids a slice-index-out-of-bounds panic.)\n     pub fn as_local_hir_id(&self, def_id: DefId) -> Option<HirId> {\n         if self.all_fake_def_ids.borrow().contains(&def_id) {\n             None\n         } else {\n-            def_id.as_local().map(|def_id| self.tcx.hir().as_local_hir_id(def_id))\n+            def_id.as_local().map(|def_id| self.tcx.hir().local_def_id_to_hir_id(def_id))\n         }\n     }\n \n@@ -400,7 +400,7 @@ pub fn run_core(options: RustdocOptions) -> (clean::Crate, RenderInfo, RenderOpt\n                 }\n \n                 let hir = tcx.hir();\n-                let body = hir.body(hir.body_owned_by(hir.as_local_hir_id(def_id)));\n+                let body = hir.body(hir.body_owned_by(hir.local_def_id_to_hir_id(def_id)));\n                 debug!(\"visiting body for {:?}\", def_id);\n                 EmitIgnoredResolutionErrors::new(tcx).visit_body(body);\n                 (rustc_interface::DEFAULT_QUERY_PROVIDERS.typeck)(tcx, def_id)"}, {"sha": "b2589e5b806e8673947695f64cc28eb62417a786", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -655,7 +655,7 @@ impl<'a, 'b> ExtraInfo<'a, 'b> {\n             (Some(h), _) => h,\n             (None, Some(item_did)) => {\n                 match item_did.as_local() {\n-                    Some(item_did) => self.tcx.hir().as_local_hir_id(item_did),\n+                    Some(item_did) => self.tcx.hir().local_def_id_to_hir_id(item_did),\n                     None => {\n                         // If non-local, no need to check anything.\n                         return;"}, {"sha": "f7fc3579d67a701f7f316169c5bf1e5a06bf76f4", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -813,8 +813,8 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n                 {\n                     use rustc_hir::def_id::LOCAL_CRATE;\n \n-                    let hir_src = self.cx.tcx.hir().as_local_hir_id(src_id);\n-                    let hir_dst = self.cx.tcx.hir().as_local_hir_id(dst_id);\n+                    let hir_src = self.cx.tcx.hir().local_def_id_to_hir_id(src_id);\n+                    let hir_dst = self.cx.tcx.hir().local_def_id_to_hir_id(dst_id);\n \n                     if self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_src)\n                         && !self.cx.tcx.privacy_access_levels(LOCAL_CRATE).is_exported(hir_dst)"}, {"sha": "be80193db8c3bd4c619320d7a2e72ed1efc1c496", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -323,7 +323,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         }\n \n         let res_hir_id = match res_did.as_local() {\n-            Some(n) => tcx.hir().as_local_hir_id(n),\n+            Some(n) => tcx.hir().local_def_id_to_hir_id(n),\n             None => return false,\n         };\n "}, {"sha": "58b0704294b566622dd6028c290066e5dd605f7b", "filename": "src/tools/clippy/clippy_lints/src/derive.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fderive.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -224,7 +224,7 @@ fn check_hash_peq<'tcx>(\n                         mess,\n                         |diag| {\n                             if let Some(local_def_id) = impl_id.as_local() {\n-                                let hir_id = cx.tcx.hir().as_local_hir_id(local_def_id);\n+                                let hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n                                 diag.span_note(\n                                     cx.tcx.hir().span(hir_id),\n                                     \"`PartialEq` implemented here\"\n@@ -278,7 +278,7 @@ fn check_ord_partial_ord<'tcx>(\n                         mess,\n                         |diag| {\n                             if let Some(local_def_id) = impl_id.as_local() {\n-                                let hir_id = cx.tcx.hir().as_local_hir_id(local_def_id);\n+                                let hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n                                 diag.span_note(\n                                     cx.tcx.hir().span(hir_id),\n                                     \"`PartialOrd` implemented here\"\n@@ -341,7 +341,7 @@ fn check_unsafe_derive_deserialize<'tcx>(\n     ty: Ty<'tcx>,\n ) {\n     fn item_from_def_id<'tcx>(cx: &LateContext<'tcx>, def_id: DefId) -> &'tcx Item<'tcx> {\n-        let hir_id = cx.tcx.hir().as_local_hir_id(def_id.expect_local());\n+        let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n         cx.tcx.hir().expect_item(hir_id)\n     }\n \n@@ -355,7 +355,7 @@ fn check_unsafe_derive_deserialize<'tcx>(\n         if match_path(&trait_ref.path, &paths::SERDE_DESERIALIZE);\n         if let ty::Adt(def, _) = ty.kind;\n         if let Some(local_def_id) = def.did.as_local();\n-        let adt_hir_id = cx.tcx.hir().as_local_hir_id(local_def_id);\n+        let adt_hir_id = cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n         if !is_allowed(cx, UNSAFE_DERIVE_DESERIALIZE, adt_hir_id);\n         if cx.tcx.inherent_impls(def.did)\n             .iter()"}, {"sha": "28d1322e94626c604cced668546593bb2193e02e", "filename": "src/tools/clippy/clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cd53760cc7751b65943feb6437af28d5ccb6e770/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fnew_without_default.rs?ref=cd53760cc7751b65943feb6437af28d5ccb6e770", "patch": "@@ -103,7 +103,7 @@ impl<'tcx> LateLintPass<'tcx> for NewWithoutDefault {\n                                         cx.tcx.for_each_impl(default_trait_id, |d| {\n                                             if let Some(ty_def) = cx.tcx.type_of(d).ty_adt_def() {\n                                                 if let Some(local_def_id) = ty_def.did.as_local() {\n-                                                    impls.insert(cx.tcx.hir().as_local_hir_id(local_def_id));\n+                                                    impls.insert(cx.tcx.hir().local_def_id_to_hir_id(local_def_id));\n                                                 }\n                                             }\n                                         });"}]}