{"sha": "4062b84f4a5926f1037535903b13b99b6806f490", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQwNjJiODRmNGE1OTI2ZjEwMzc1MzU5MDNiMTNiOTliNjgwNmY0OTA=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-09T14:19:23Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-08-10T14:02:17Z"}, "message": "std: merge Iterator and IteratorUtil", "tree": {"sha": "cad03e369e3269f0cfe28a95cb8a11040a904485", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cad03e369e3269f0cfe28a95cb8a11040a904485"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4062b84f4a5926f1037535903b13b99b6806f490", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4062b84f4a5926f1037535903b13b99b6806f490", "html_url": "https://github.com/rust-lang/rust/commit/4062b84f4a5926f1037535903b13b99b6806f490", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4062b84f4a5926f1037535903b13b99b6806f490/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a6614621afbbcc04c503a4828adbb0acc4e0fe20", "url": "https://api.github.com/repos/rust-lang/rust/commits/a6614621afbbcc04c503a4828adbb0acc4e0fe20", "html_url": "https://github.com/rust-lang/rust/commit/a6614621afbbcc04c503a4828adbb0acc4e0fe20"}], "stats": {"total": 488, "additions": 204, "deletions": 284}, "files": [{"sha": "ac07fd2bebfbb1c1443c25863c6d5c583c64756d", "filename": "src/libextra/smallintmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibextra%2Fsmallintmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibextra%2Fsmallintmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsmallintmap.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -15,7 +15,7 @@\n \n #[allow(missing_doc)];\n \n-use std::iterator::{Iterator, IteratorUtil, Enumerate, FilterMap, Invert};\n+use std::iterator::{Iterator, Enumerate, FilterMap, Invert};\n use std::util::replace;\n use std::vec::{VecIterator, VecMutIterator};\n use std::vec;"}, {"sha": "b2a5707676aff292b8571e0c2ef1728e8e58e0ba", "filename": "src/libextra/terminfo/parm.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibextra%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibextra%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparm.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -12,7 +12,6 @@\n \n use std::{char, vec, util};\n use std::num::strconv::{SignNone,SignNeg,SignAll,int_to_str_bytes_common};\n-use std::iterator::IteratorUtil;\n \n #[deriving(Eq)]\n enum States {"}, {"sha": "85ec69a85727a6b4a00691e079dc91916467c61b", "filename": "src/libextra/test.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibextra%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibextra%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftest.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -525,7 +525,6 @@ impl ConsoleTestState {\n }\n \n pub fn fmt_metrics(mm: &MetricMap) -> ~str {\n-    use std::iterator::IteratorUtil;\n     let v : ~[~str] = mm.iter()\n         .transform(|(k,v)| fmt!(\"%s: %f (+/- %f)\",\n                                 *k,"}, {"sha": "32b3032c53d490e04e43023e2bcb20fff8d28715", "filename": "src/libstd/hashmap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fhashmap.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -19,7 +19,7 @@ use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n use clone::Clone;\n use cmp::{Eq, Equiv};\n use hash::Hash;\n-use iterator::{Iterator, IteratorUtil, FromIterator, Extendable};\n+use iterator::{Iterator, FromIterator, Extendable};\n use iterator::{FilterMap, Chain, Repeat, Zip};\n use num;\n use option::{None, Option, Some};"}, {"sha": "48d058c6f1cb2b5db1b0e896fd570e8b67a17e9e", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 192, "deletions": 268, "changes": 460, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -49,76 +49,7 @@ pub trait Iterator<A> {\n     /// The common use case for the estimate is pre-allocating space to store the results.\n     #[inline]\n     fn size_hint(&self) -> (uint, Option<uint>) { (0, None) }\n-}\n-\n-/// A range iterator able to yield elements from both ends\n-pub trait DoubleEndedIterator<A>: Iterator<A> {\n-    /// Yield an element from the end of the range, returning `None` if the range is empty.\n-    fn next_back(&mut self) -> Option<A>;\n-\n-    /// Flip the direction of the iterator\n-    ///\n-    /// The inverted iterator flips the ends on an iterator that can already\n-    /// be iterated from the front and from the back.\n-    ///\n-    ///\n-    /// If the iterator also implements RandomAccessIterator, the inverted\n-    /// iterator is also random access, with the indices starting at the back\n-    /// of the original iterator.\n-    ///\n-    /// Note: Random access with inverted indices still only applies to the first\n-    /// `uint::max_value` elements of the original iterator.\n-    #[inline]\n-    fn invert(self) -> Invert<Self> {\n-        Invert{iter: self}\n-    }\n-}\n \n-/// An object implementing random access indexing by `uint`\n-///\n-/// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n-pub trait RandomAccessIterator<A>: Iterator<A> {\n-    /// Return the number of indexable elements. At most `std::uint::max_value`\n-    /// elements are indexable, even if the iterator represents a longer range.\n-    fn indexable(&self) -> uint;\n-\n-    /// Return an element at an index\n-    fn idx(&self, index: uint) -> Option<A>;\n-}\n-\n-/// An double-ended iterator with the direction inverted\n-#[deriving(Clone)]\n-pub struct Invert<T> {\n-    priv iter: T\n-}\n-\n-impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Invert<T> {\n-    #[inline]\n-    fn next(&mut self) -> Option<A> { self.iter.next_back() }\n-    #[inline]\n-    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n-}\n-\n-impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Invert<T> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<A> { self.iter.next() }\n-}\n-\n-impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n-    for Invert<T> {\n-    #[inline]\n-    fn indexable(&self) -> uint { self.iter.indexable() }\n-    #[inline]\n-    fn idx(&self, index: uint) -> Option<A> {\n-        self.iter.idx(self.indexable() - index - 1)\n-    }\n-}\n-\n-/// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n-/// implementations of the `Iterator` trait.\n-///\n-/// In the future these will be default methods instead of a utility trait.\n-pub trait IteratorUtil<A> {\n     /// Chain this iterator with another, returning a new iterator which will\n     /// finish iterating over the current iterator, and then it will iterate\n     /// over the other specified iterator.\n@@ -133,7 +64,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn chain_<U: Iterator<A>>(self, other: U) -> Chain<Self, U>;\n+    #[inline]\n+    fn chain_<U: Iterator<A>>(self, other: U) -> Chain<Self, U> {\n+        Chain{a: self, b: other, flag: false}\n+    }\n \n     /// Creates an iterator which iterates over both this and the specified\n     /// iterators simultaneously, yielding the two elements as pairs. When\n@@ -149,7 +83,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), (&0, &1));\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U>;\n+    #[inline]\n+    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<Self, U> {\n+        Zip{a: self, b: other}\n+    }\n \n     // FIXME: #5898: should be called map\n     /// Creates a new iterator which will apply the specified function to each\n@@ -164,7 +101,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), 4);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn transform<'r, B>(self, f: &'r fn(A) -> B) -> Map<'r, A, B, Self>;\n+    #[inline]\n+    fn transform<'r, B>(self, f: &'r fn(A) -> B) -> Map<'r, A, B, Self> {\n+        Map{iter: self, f: f}\n+    }\n \n     /// Creates an iterator which applies the predicate to each element returned\n     /// by this iterator. Only elements which have the predicate evaluate to\n@@ -178,7 +118,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &2);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> Filter<'r, A, Self>;\n+    #[inline]\n+    fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> Filter<'r, A, Self> {\n+        Filter{iter: self, predicate: predicate}\n+    }\n \n     /// Creates an iterator which both filters and maps elements.\n     /// If the specified function returns None, the element is skipped.\n@@ -192,7 +135,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), 4);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn filter_map<'r,  B>(self, f: &'r fn(A) -> Option<B>) -> FilterMap<'r, A, B, Self>;\n+    #[inline]\n+    fn filter_map<'r, B>(self, f: &'r fn(A) -> Option<B>) -> FilterMap<'r, A, B, Self> {\n+        FilterMap { iter: self, f: f }\n+    }\n \n     /// Creates an iterator which yields a pair of the value returned by this\n     /// iterator plus the current index of iteration.\n@@ -206,7 +152,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), (1, &200));\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn enumerate(self) -> Enumerate<Self>;\n+    #[inline]\n+    fn enumerate(self) -> Enumerate<Self> {\n+        Enumerate{iter: self, count: 0}\n+    }\n \n     /// Creates an iterator which invokes the predicate on elements until it\n     /// returns false. Once the predicate returns false, all further elements are\n@@ -222,7 +171,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &1);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhile<'r, A, Self>;\n+    #[inline]\n+    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhile<'r, A, Self> {\n+        SkipWhile{iter: self, flag: false, predicate: predicate}\n+    }\n \n     /// Creates an iterator which yields elements so long as the predicate\n     /// returns true. After the predicate returns false for the first time, no\n@@ -237,7 +189,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &2);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhile<'r, A, Self>;\n+    #[inline]\n+    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhile<'r, A, Self> {\n+        TakeWhile{iter: self, flag: false, predicate: predicate}\n+    }\n \n     /// Creates an iterator which skips the first `n` elements of this iterator,\n     /// and then it yields all further items.\n@@ -251,7 +206,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &5);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn skip(self, n: uint) -> Skip<Self>;\n+    #[inline]\n+    fn skip(self, n: uint) -> Skip<Self> {\n+        Skip{iter: self, n: n}\n+    }\n \n     // FIXME: #5898: should be called take\n     /// Creates an iterator which yields the first `n` elements of this\n@@ -267,7 +225,10 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), &3);\n     /// assert!(it.next().is_none());\n     /// ~~~\n-    fn take_(self, n: uint) -> Take<Self>;\n+    #[inline]\n+    fn take_(self, n: uint) -> Take<Self> {\n+        Take{iter: self, n: n}\n+    }\n \n     /// Creates a new iterator which behaves in a similar fashion to foldl.\n     /// There is a state which is passed between each iteration and can be\n@@ -289,8 +250,11 @@ pub trait IteratorUtil<A> {\n     /// assert_eq!(it.next().get(), 120);\n     /// assert!(it.next().is_none());\n     /// ~~~\n+    #[inline]\n     fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n-        -> Scan<'r, A, B, Self, St>;\n+        -> Scan<'r, A, B, Self, St> {\n+        Scan{iter: self, f: f, state: initial_state}\n+    }\n \n     /// Creates an iterator that maps each element to an iterator,\n     /// and yields the elements of the produced iterators\n@@ -309,8 +273,11 @@ pub trait IteratorUtil<A> {\n     /// }\n     /// ~~~\n     // FIXME: #5898: should be called `flat_map`\n+    #[inline]\n     fn flat_map_<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n-        -> FlatMap<'r, A, Self, U>;\n+        -> FlatMap<'r, A, Self, U> {\n+        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n+    }\n \n     /// Creates an iterator that calls a function with a reference to each\n     /// element before yielding it. This is often useful for debugging an\n@@ -329,7 +296,10 @@ pub trait IteratorUtil<A> {\n     ///println(sum.to_str());\n     /// ~~~\n     // FIXME: #5898: should be called `peek`\n-    fn peek_<'r>(self, f: &'r fn(&A)) -> Peek<'r, A, Self>;\n+    #[inline]\n+    fn peek_<'r>(self, f: &'r fn(&A)) -> Peek<'r, A, Self> {\n+        Peek{iter: self, f: f}\n+    }\n \n     /// An adaptation of an external iterator to the for-loop protocol of rust.\n     ///\n@@ -342,7 +312,17 @@ pub trait IteratorUtil<A> {\n     ///     printfln!(\"%d\", i);\n     /// }\n     /// ~~~\n-    fn advance(&mut self, f: &fn(A) -> bool) -> bool;\n+    #[inline]\n+    fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n+        loop {\n+            match self.next() {\n+                Some(x) => {\n+                    if !f(x) { return false; }\n+                }\n+                None => { return true; }\n+            }\n+        }\n+    }\n \n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a container implementing `FromIterator`.\n@@ -354,7 +334,10 @@ pub trait IteratorUtil<A> {\n     /// let b: ~[int] = a.iter().transform(|&x| x).collect();\n     /// assert!(a == b);\n     /// ~~~\n-    fn collect<B: FromIterator<A, Self>>(&mut self) -> B;\n+    #[inline]\n+    fn collect<B: FromIterator<A, Self>>(&mut self) -> B {\n+        FromIterator::from_iterator(self)\n+    }\n \n     /// Loops through the entire iterator, collecting all of the elements into\n     /// a unique vector. This is simply collect() specialized for vectors.\n@@ -366,7 +349,10 @@ pub trait IteratorUtil<A> {\n     /// let b: ~[int] = a.iter().transform(|&x| x).to_owned_vec();\n     /// assert!(a == b);\n     /// ~~~\n-    fn to_owned_vec(&mut self) -> ~[A];\n+    #[inline]\n+    fn to_owned_vec(&mut self) -> ~[A] {\n+        self.collect()\n+    }\n \n     /// Loops through `n` iterations, returning the `n`th element of the\n     /// iterator.\n@@ -379,7 +365,16 @@ pub trait IteratorUtil<A> {\n     /// assert!(it.nth(2).get() == &3);\n     /// assert!(it.nth(2) == None);\n     /// ~~~\n-    fn nth(&mut self, n: uint) -> Option<A>;\n+    #[inline]\n+    fn nth(&mut self, mut n: uint) -> Option<A> {\n+        loop {\n+            match self.next() {\n+                Some(x) => if n == 0 { return Some(x) },\n+                None => return None\n+            }\n+            n -= 1;\n+        }\n+    }\n \n     /// Loops through the entire iterator, returning the last element of the\n     /// iterator.\n@@ -391,7 +386,12 @@ pub trait IteratorUtil<A> {\n     /// assert!(a.iter().last().get() == &5);\n     /// ~~~\n     // FIXME: #5898: should be called `last`\n-    fn last_(&mut self) -> Option<A>;\n+    #[inline]\n+    fn last_(&mut self) -> Option<A> {\n+        let mut last = None;\n+        for x in *self { last = Some(x); }\n+        last\n+    }\n \n     /// Performs a fold operation over the entire iterator, returning the\n     /// eventual state at the end of the iteration.\n@@ -402,7 +402,17 @@ pub trait IteratorUtil<A> {\n     /// let a = [1, 2, 3, 4, 5];\n     /// assert!(a.iter().fold(0, |a, &b| a + b) == 15);\n     /// ~~~\n-    fn fold<B>(&mut self, start: B, f: &fn(B, A) -> B) -> B;\n+    #[inline]\n+    fn fold<B>(&mut self, init: B, f: &fn(B, A) -> B) -> B {\n+        let mut accum = init;\n+        loop {\n+            match self.next() {\n+                Some(x) => { accum = f(accum, x); }\n+                None    => { break; }\n+            }\n+        }\n+        accum\n+    }\n \n     // FIXME: #5898: should be called len\n     /// Counts the number of elements in this iterator.\n@@ -415,7 +425,10 @@ pub trait IteratorUtil<A> {\n     /// assert!(it.len_() == 5);\n     /// assert!(it.len_() == 0);\n     /// ~~~\n-    fn len_(&mut self) -> uint;\n+    #[inline]\n+    fn len_(&mut self) -> uint {\n+        self.fold(0, |cnt, _x| cnt + 1)\n+    }\n \n     /// Tests whether the predicate holds true for all elements in the iterator.\n     ///\n@@ -426,7 +439,11 @@ pub trait IteratorUtil<A> {\n     /// assert!(a.iter().all(|&x| *x > 0));\n     /// assert!(!a.iter().all(|&x| *x > 2));\n     /// ~~~\n-    fn all(&mut self, f: &fn(A) -> bool) -> bool;\n+    #[inline]\n+    fn all(&mut self, f: &fn(A) -> bool) -> bool {\n+        for x in *self { if !f(x) { return false; } }\n+        true\n+    }\n \n     /// Tests whether any element of an iterator satisfies the specified\n     /// predicate.\n@@ -439,179 +456,6 @@ pub trait IteratorUtil<A> {\n     /// assert!(it.any(|&x| *x == 3));\n     /// assert!(!it.any(|&x| *x == 3));\n     /// ~~~\n-    fn any(&mut self, f: &fn(A) -> bool) -> bool;\n-\n-    /// Return the first element satisfying the specified predicate\n-    fn find_(&mut self, predicate: &fn(&A) -> bool) -> Option<A>;\n-\n-    /// Return the index of the first element satisfying the specified predicate\n-    fn position(&mut self, predicate: &fn(A) -> bool) -> Option<uint>;\n-\n-    /// Count the number of elements satisfying the specified predicate\n-    fn count(&mut self, predicate: &fn(A) -> bool) -> uint;\n-\n-    /// Return the element that gives the maximum value from the specfied function\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = [-3, 0, 1, 5, -10];\n-    /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n-    /// ~~~\n-    fn max_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A>;\n-\n-    /// Return the element that gives the minimum value from the specfied function\n-    ///\n-    /// # Example\n-    ///\n-    /// ~~~ {.rust}\n-    /// let xs = [-3, 0, 1, 5, -10];\n-    /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n-    /// ~~~\n-    fn min_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A>;\n-}\n-\n-/// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n-/// implementations of the `Iterator` trait.\n-///\n-/// In the future these will be default methods instead of a utility trait.\n-impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n-    #[inline]\n-    fn chain_<U: Iterator<A>>(self, other: U) -> Chain<T, U> {\n-        Chain{a: self, b: other, flag: false}\n-    }\n-\n-    #[inline]\n-    fn zip<B, U: Iterator<B>>(self, other: U) -> Zip<T, U> {\n-        Zip{a: self, b: other}\n-    }\n-\n-    // FIXME: #5898: should be called map\n-    #[inline]\n-    fn transform<'r, B>(self, f: &'r fn(A) -> B) -> Map<'r, A, B, T> {\n-        Map{iter: self, f: f}\n-    }\n-\n-    #[inline]\n-    fn filter<'r>(self, predicate: &'r fn(&A) -> bool) -> Filter<'r, A, T> {\n-        Filter{iter: self, predicate: predicate}\n-    }\n-\n-    #[inline]\n-    fn filter_map<'r, B>(self, f: &'r fn(A) -> Option<B>) -> FilterMap<'r, A, B, T> {\n-        FilterMap { iter: self, f: f }\n-    }\n-\n-    #[inline]\n-    fn enumerate(self) -> Enumerate<T> {\n-        Enumerate{iter: self, count: 0}\n-    }\n-\n-    #[inline]\n-    fn skip_while<'r>(self, predicate: &'r fn(&A) -> bool) -> SkipWhile<'r, A, T> {\n-        SkipWhile{iter: self, flag: false, predicate: predicate}\n-    }\n-\n-    #[inline]\n-    fn take_while<'r>(self, predicate: &'r fn(&A) -> bool) -> TakeWhile<'r, A, T> {\n-        TakeWhile{iter: self, flag: false, predicate: predicate}\n-    }\n-\n-    #[inline]\n-    fn skip(self, n: uint) -> Skip<T> {\n-        Skip{iter: self, n: n}\n-    }\n-\n-    // FIXME: #5898: should be called take\n-    #[inline]\n-    fn take_(self, n: uint) -> Take<T> {\n-        Take{iter: self, n: n}\n-    }\n-\n-    #[inline]\n-    fn scan<'r, St, B>(self, initial_state: St, f: &'r fn(&mut St, A) -> Option<B>)\n-        -> Scan<'r, A, B, T, St> {\n-        Scan{iter: self, f: f, state: initial_state}\n-    }\n-\n-    #[inline]\n-    fn flat_map_<'r, B, U: Iterator<B>>(self, f: &'r fn(A) -> U)\n-        -> FlatMap<'r, A, T, U> {\n-        FlatMap{iter: self, f: f, frontiter: None, backiter: None }\n-    }\n-\n-    // FIXME: #5898: should be called `peek`\n-    #[inline]\n-    fn peek_<'r>(self, f: &'r fn(&A)) -> Peek<'r, A, T> {\n-        Peek{iter: self, f: f}\n-    }\n-\n-    /// A shim implementing the `for` loop iteration protocol for iterator objects\n-    #[inline]\n-    fn advance(&mut self, f: &fn(A) -> bool) -> bool {\n-        loop {\n-            match self.next() {\n-                Some(x) => {\n-                    if !f(x) { return false; }\n-                }\n-                None => { return true; }\n-            }\n-        }\n-    }\n-\n-    #[inline]\n-    fn collect<B: FromIterator<A, T>>(&mut self) -> B {\n-        FromIterator::from_iterator(self)\n-    }\n-\n-    #[inline]\n-    fn to_owned_vec(&mut self) -> ~[A] {\n-        self.collect()\n-    }\n-\n-    /// Return the `n`th item yielded by an iterator.\n-    #[inline]\n-    fn nth(&mut self, mut n: uint) -> Option<A> {\n-        loop {\n-            match self.next() {\n-                Some(x) => if n == 0 { return Some(x) },\n-                None => return None\n-            }\n-            n -= 1;\n-        }\n-    }\n-\n-    /// Return the last item yielded by an iterator.\n-    #[inline]\n-    fn last_(&mut self) -> Option<A> {\n-        let mut last = None;\n-        for x in *self { last = Some(x); }\n-        last\n-    }\n-\n-    /// Reduce an iterator to an accumulated value\n-    #[inline]\n-    fn fold<B>(&mut self, init: B, f: &fn(B, A) -> B) -> B {\n-        let mut accum = init;\n-        loop {\n-            match self.next() {\n-                Some(x) => { accum = f(accum, x); }\n-                None    => { break; }\n-            }\n-        }\n-        accum\n-    }\n-\n-    /// Count the number of items yielded by an iterator\n-    #[inline]\n-    fn len_(&mut self) -> uint { self.fold(0, |cnt, _x| cnt + 1) }\n-\n-    #[inline]\n-    fn all(&mut self, f: &fn(A) -> bool) -> bool {\n-        for x in *self { if !f(x) { return false; } }\n-        true\n-    }\n-\n     #[inline]\n     fn any(&mut self, f: &fn(A) -> bool) -> bool {\n         for x in *self { if f(x) { return true; } }\n@@ -640,6 +484,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         None\n     }\n \n+    /// Count the number of elements satisfying the specified predicate\n     #[inline]\n     fn count(&mut self, predicate: &fn(A) -> bool) -> uint {\n         let mut i = 0;\n@@ -649,6 +494,14 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         i\n     }\n \n+    /// Return the element that gives the maximum value from the specfied function\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let xs = [-3, 0, 1, 5, -10];\n+    /// assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n+    /// ~~~\n     #[inline]\n     fn max_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n         self.fold(None, |max: Option<(A, B)>, x| {\n@@ -664,6 +517,14 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         }).map_move(|(x, _)| x)\n     }\n \n+    /// Return the element that gives the minimum value from the specfied function\n+    ///\n+    /// # Example\n+    ///\n+    /// ~~~ {.rust}\n+    /// let xs = [-3, 0, 1, 5, -10];\n+    /// assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n+    /// ~~~\n     #[inline]\n     fn min_by<B: Ord>(&mut self, f: &fn(&A) -> B) -> Option<A> {\n         self.fold(None, |min: Option<(A, B)>, x| {\n@@ -680,6 +541,69 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n     }\n }\n \n+/// A range iterator able to yield elements from both ends\n+pub trait DoubleEndedIterator<A>: Iterator<A> {\n+    /// Yield an element from the end of the range, returning `None` if the range is empty.\n+    fn next_back(&mut self) -> Option<A>;\n+\n+    /// Flip the direction of the iterator\n+    ///\n+    /// The inverted iterator flips the ends on an iterator that can already\n+    /// be iterated from the front and from the back.\n+    ///\n+    ///\n+    /// If the iterator also implements RandomAccessIterator, the inverted\n+    /// iterator is also random access, with the indices starting at the back\n+    /// of the original iterator.\n+    ///\n+    /// Note: Random access with inverted indices still only applies to the first\n+    /// `uint::max_value` elements of the original iterator.\n+    #[inline]\n+    fn invert(self) -> Invert<Self> {\n+        Invert{iter: self}\n+    }\n+}\n+\n+/// An object implementing random access indexing by `uint`\n+///\n+/// A `RandomAccessIterator` should be either infinite or a `DoubleEndedIterator`.\n+pub trait RandomAccessIterator<A>: Iterator<A> {\n+    /// Return the number of indexable elements. At most `std::uint::max_value`\n+    /// elements are indexable, even if the iterator represents a longer range.\n+    fn indexable(&self) -> uint;\n+\n+    /// Return an element at an index\n+    fn idx(&self, index: uint) -> Option<A>;\n+}\n+\n+/// An double-ended iterator with the direction inverted\n+#[deriving(Clone)]\n+pub struct Invert<T> {\n+    priv iter: T\n+}\n+\n+impl<A, T: DoubleEndedIterator<A>> Iterator<A> for Invert<T> {\n+    #[inline]\n+    fn next(&mut self) -> Option<A> { self.iter.next_back() }\n+    #[inline]\n+    fn size_hint(&self) -> (uint, Option<uint>) { self.iter.size_hint() }\n+}\n+\n+impl<A, T: DoubleEndedIterator<A>> DoubleEndedIterator<A> for Invert<T> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<A> { self.iter.next() }\n+}\n+\n+impl<A, T: DoubleEndedIterator<A> + RandomAccessIterator<A>> RandomAccessIterator<A>\n+    for Invert<T> {\n+    #[inline]\n+    fn indexable(&self) -> uint { self.iter.indexable() }\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<A> {\n+        self.iter.idx(self.indexable() - index - 1)\n+    }\n+}\n+\n /// A trait for iterators over elements which can be added together\n pub trait AdditiveIterator<A> {\n     /// Iterates over the entire iterator, summing up all the elements\n@@ -1882,7 +1806,7 @@ mod tests {\n \n     #[test]\n     fn test_all() {\n-        let v = ~&[1, 2, 3, 4, 5];\n+        let v: ~&[int] = ~&[1, 2, 3, 4, 5];\n         assert!(v.iter().all(|&x| x < 10));\n         assert!(!v.iter().all(|&x| x.is_even()));\n         assert!(!v.iter().all(|&x| x > 100));\n@@ -1891,7 +1815,7 @@ mod tests {\n \n     #[test]\n     fn test_any() {\n-        let v = ~&[1, 2, 3, 4, 5];\n+        let v: ~&[int] = ~&[1, 2, 3, 4, 5];\n         assert!(v.iter().any(|&x| x < 10));\n         assert!(v.iter().any(|&x| x.is_even()));\n         assert!(!v.iter().any(|&x| x > 100));\n@@ -1900,7 +1824,7 @@ mod tests {\n \n     #[test]\n     fn test_find() {\n-        let v = &[1, 3, 9, 27, 103, 14, 11];\n+        let v: &[int] = &[1, 3, 9, 27, 103, 14, 11];\n         assert_eq!(*v.iter().find_(|x| *x & 1 == 0).unwrap(), 14);\n         assert_eq!(*v.iter().find_(|x| *x % 3 == 0).unwrap(), 3);\n         assert!(v.iter().find_(|x| *x % 12 == 0).is_none());\n@@ -1924,13 +1848,13 @@ mod tests {\n \n     #[test]\n     fn test_max_by() {\n-        let xs = [-3, 0, 1, 5, -10];\n+        let xs: &[int] = &[-3, 0, 1, 5, -10];\n         assert_eq!(*xs.iter().max_by(|x| x.abs()).unwrap(), -10);\n     }\n \n     #[test]\n     fn test_min_by() {\n-        let xs = [-3, 0, 1, 5, -10];\n+        let xs: &[int] = &[-3, 0, 1, 5, -10];\n         assert_eq!(*xs.iter().min_by(|x| x.abs()).unwrap(), 0);\n     }\n "}, {"sha": "c916be79c53e5a3fa13c5e0d072c3139e3a149ad", "filename": "src/libstd/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -32,7 +32,7 @@ use c_str::ToCStr;\n use clone::Clone;\n use container::Container;\n use io;\n-use iterator::{IteratorUtil, range};\n+use iterator::range;\n use libc;\n use libc::{c_char, c_void, c_int, size_t};\n use libc::FILE;"}, {"sha": "177f0efb6dad380677fef7b9d442ddbb5bf11411", "filename": "src/libstd/path.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -21,7 +21,7 @@ use c_str;\n use clone::Clone;\n use cmp::Eq;\n use container::Container;\n-use iterator::{Iterator, IteratorUtil, range};\n+use iterator::{Iterator, range};\n use libc;\n use num;\n use option::{None, Option, Some};"}, {"sha": "9a8737f4dee3f5adc01dc60f481a5d2b1b91d103", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -51,7 +51,7 @@ pub use container::{Container, Mutable, Map, MutableMap, Set, MutableSet};\n pub use hash::Hash;\n pub use iter::Times;\n pub use iterator::Extendable;\n-pub use iterator::{Iterator, IteratorUtil, DoubleEndedIterator};\n+pub use iterator::{Iterator, DoubleEndedIterator};\n pub use iterator::{ClonableIterator, OrdIterator};\n pub use num::{Num, NumCast};\n pub use num::{Orderable, Signed, Unsigned, Round};"}, {"sha": "1b9f28b95fb3fc27b5042e067f933922b41d78ee", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -63,7 +63,7 @@ Several modules in `core` are clients of `rt`:\n use cell::Cell;\n use clone::Clone;\n use container::Container;\n-use iterator::{Iterator, IteratorUtil, range};\n+use iterator::{Iterator, range};\n use option::{Some, None};\n use ptr::RawPtr;\n use rt::local::Local;"}, {"sha": "6280b64ecf51c71742a22751ef64ba176d0a0860", "filename": "src/libstd/rt/util.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Frt%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Frt%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Futil.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -10,7 +10,6 @@\n \n use container::Container;\n use from_str::FromStr;\n-use iterator::IteratorUtil;\n use libc;\n use option::{Some, None};\n use os;"}, {"sha": "7f2e5f93bdd01e075352841c166c9c2e51e44822", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -23,7 +23,7 @@ use char::Char;\n use clone::Clone;\n use container::{Container, Mutable};\n use iter::Times;\n-use iterator::{Iterator, FromIterator, Extendable, IteratorUtil};\n+use iterator::{Iterator, FromIterator, Extendable};\n use iterator::{Filter, AdditiveIterator, Map};\n use iterator::{Invert, DoubleEndedIterator};\n use libc;\n@@ -2546,7 +2546,6 @@ impl Zero for @str {\n \n #[cfg(test)]\n mod tests {\n-    use iterator::IteratorUtil;\n     use container::Container;\n     use option::Some;\n     use libc::c_char;"}, {"sha": "c6ae535c19a3c4ec6edb5a3d7db38cf74c958fc1", "filename": "src/libstd/str/ascii.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fstr%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fstr%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr%2Fascii.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -17,7 +17,7 @@ use str::OwnedStr;\n use container::Container;\n use cast;\n use ptr;\n-use iterator::{Iterator, IteratorUtil};\n+use iterator::Iterator;\n use vec::{CopyableVector, ImmutableVector};\n #[cfg(stage0)]\n use vec::OwnedVector;"}, {"sha": "f871f4ef6d6acad9db87970e8f40e271c15419ca", "filename": "src/libstd/to_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fto_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Fto_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fto_bytes.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -17,7 +17,7 @@ The `ToBytes` and `IterBytes` traits\n use cast;\n use io;\n use io::Writer;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n use option::{None, Option, Some};\n use str::StrSlice;\n use vec::ImmutableVector;"}, {"sha": "fc28e6996ba8bcb630d9ffa4a5ebc7b842cf1528", "filename": "src/libstd/trie.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Ftrie.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Ftrie.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftrie.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -11,7 +11,7 @@\n //! An ordered map and set for integer keys implemented as a radix trie\n \n use prelude::*;\n-use iterator::{IteratorUtil, FromIterator, Extendable};\n+use iterator::{FromIterator, Extendable};\n use uint;\n use util::{swap, replace};\n use vec;"}, {"sha": "93216a293192cc1339fc47b9728b8373efee14bb", "filename": "src/libstd/tuple.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Ftuple.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Flibstd%2Ftuple.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftuple.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -15,7 +15,7 @@\n use clone::Clone;\n use vec;\n use vec::ImmutableVector;\n-use iterator::IteratorUtil;\n+use iterator::Iterator;\n \n pub use self::inner::*;\n "}, {"sha": "afe84a82637cab94a6ea9b18f6efa763a7d70916", "filename": "src/test/run-pass/trait-to-str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4062b84f4a5926f1037535903b13b99b6806f490/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4062b84f4a5926f1037535903b13b99b6806f490/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-to-str.rs?ref=4062b84f4a5926f1037535903b13b99b6806f490", "patch": "@@ -16,7 +16,7 @@ extern mod std;\n \n use std::str::StrVector;\n use std::vec::ImmutableVector;\n-use std::iterator::IteratorUtil;\n+use std::iterator::Iterator;\n use std::int;\n \n trait to_str {"}]}