{"sha": "cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNDMyN2IzYTlmMDg1ODIzNWRjMjBiN2M1YzdlMjVjNmMzMzBhYWI=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-13T20:14:39Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-02-13T20:14:39Z"}, "message": "Merge #816\n\n816: Prelude & Edition 2015 import resolution r=matklad a=flodiebold\n\nI implemented the prelude import, but it turned out to be useless without being able to resolve any of the imports in the prelude :sweat_smile: So I had to add some edition handling and handle 2015-style imports (at least the simplified scheme proposed in rust-lang/rust#57745). So now finally `Option` resolves :smile: \r\n\r\nOne remaining problem is that we don't actually know the edition for sysroot crates. They're currently hardcoded to 2015, but there's already a bunch of PRs upgrading the editions of various rustc crates, so we'll have to detect the edition somehow, or just change the hardcoding to 2018 later, I guess...\r\n\r\n~Also currently missing is completion for prelude names, though that shouldn't be hard to add. And `Vec` still doesn't resolve, so I need to look into that.~\n\nCo-authored-by: Florian Diebold <flodiebold@gmail.com>", "tree": {"sha": "489b3497b2762dcabf60d2674031585431e16959", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/489b3497b2762dcabf60d2674031585431e16959"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "html_url": "https://github.com/rust-lang/rust/commit/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "65266c644a31e6b321e5afb3c5a2ee75be76cb0c", "url": "https://api.github.com/repos/rust-lang/rust/commits/65266c644a31e6b321e5afb3c5a2ee75be76cb0c", "html_url": "https://github.com/rust-lang/rust/commit/65266c644a31e6b321e5afb3c5a2ee75be76cb0c"}, {"sha": "911e32bca9b73e66eceb6bbee3768c82e94597d5", "url": "https://api.github.com/repos/rust-lang/rust/commits/911e32bca9b73e66eceb6bbee3768c82e94597d5", "html_url": "https://github.com/rust-lang/rust/commit/911e32bca9b73e66eceb6bbee3768c82e94597d5"}], "stats": {"total": 459, "additions": 399, "deletions": 60}, "files": [{"sha": "e45a510b34e8cb0bb88d61ec92ba6adc54961f45", "filename": "crates/ra_db/src/input.rs", "status": "modified", "additions": 32, "deletions": 12, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_db%2Fsrc%2Finput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_db%2Fsrc%2Finput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Finput.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -56,15 +56,31 @@ pub struct CyclicDependencies;\n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct CrateId(pub u32);\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub enum Edition {\n+    Edition2018,\n+    Edition2015,\n+}\n+\n+impl Edition {\n+    pub fn from_string(s: &str) -> Edition {\n+        match s {\n+            \"2015\" => Edition::Edition2015,\n+            \"2018\" | _ => Edition::Edition2018,\n+        }\n+    }\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq)]\n struct CrateData {\n     file_id: FileId,\n+    edition: Edition,\n     dependencies: Vec<Dependency>,\n }\n \n impl CrateData {\n-    fn new(file_id: FileId) -> CrateData {\n-        CrateData { file_id, dependencies: Vec::new() }\n+    fn new(file_id: FileId, edition: Edition) -> CrateData {\n+        CrateData { file_id, edition, dependencies: Vec::new() }\n     }\n \n     fn add_dep(&mut self, name: SmolStr, crate_id: CrateId) {\n@@ -85,9 +101,9 @@ impl Dependency {\n }\n \n impl CrateGraph {\n-    pub fn add_crate_root(&mut self, file_id: FileId) -> CrateId {\n+    pub fn add_crate_root(&mut self, file_id: FileId, edition: Edition) -> CrateId {\n         let crate_id = CrateId(self.arena.len() as u32);\n-        let prev = self.arena.insert(crate_id, CrateData::new(file_id));\n+        let prev = self.arena.insert(crate_id, CrateData::new(file_id, edition));\n         assert!(prev.is_none());\n         crate_id\n     }\n@@ -112,6 +128,10 @@ impl CrateGraph {\n         self.arena[&crate_id].file_id\n     }\n \n+    pub fn edition(&self, crate_id: CrateId) -> Edition {\n+        self.arena[&crate_id].edition\n+    }\n+\n     // TODO: this only finds one crate with the given root; we could have multiple\n     pub fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n         let (&crate_id, _) = self.arena.iter().find(|(_crate_id, data)| data.file_id == file_id)?;\n@@ -159,14 +179,14 @@ impl CrateGraph {\n \n #[cfg(test)]\n mod tests {\n-    use super::{CrateGraph, FileId, SmolStr};\n+    use super::{CrateGraph, FileId, SmolStr, Edition::Edition2018};\n \n     #[test]\n-    fn it_should_painc_because_of_cycle_dependencies() {\n+    fn it_should_panic_because_of_cycle_dependencies() {\n         let mut graph = CrateGraph::default();\n-        let crate1 = graph.add_crate_root(FileId(1u32));\n-        let crate2 = graph.add_crate_root(FileId(2u32));\n-        let crate3 = graph.add_crate_root(FileId(3u32));\n+        let crate1 = graph.add_crate_root(FileId(1u32), Edition2018);\n+        let crate2 = graph.add_crate_root(FileId(2u32), Edition2018);\n+        let crate3 = graph.add_crate_root(FileId(3u32), Edition2018);\n         assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n         assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n         assert!(graph.add_dep(crate3, SmolStr::new(\"crate1\"), crate1).is_err());\n@@ -175,9 +195,9 @@ mod tests {\n     #[test]\n     fn it_works() {\n         let mut graph = CrateGraph::default();\n-        let crate1 = graph.add_crate_root(FileId(1u32));\n-        let crate2 = graph.add_crate_root(FileId(2u32));\n-        let crate3 = graph.add_crate_root(FileId(3u32));\n+        let crate1 = graph.add_crate_root(FileId(1u32), Edition2018);\n+        let crate2 = graph.add_crate_root(FileId(2u32), Edition2018);\n+        let crate3 = graph.add_crate_root(FileId(3u32), Edition2018);\n         assert!(graph.add_dep(crate1, SmolStr::new(\"crate2\"), crate2).is_ok());\n         assert!(graph.add_dep(crate2, SmolStr::new(\"crate3\"), crate3).is_ok());\n     }"}, {"sha": "e006c6d275e3bbda5635a41a766ea2700f1ff04c", "filename": "crates/ra_db/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_db%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_db%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_db%2Fsrc%2Flib.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -14,7 +14,7 @@ pub use ::salsa as salsa;\n pub use crate::{\n     cancellation::Canceled,\n     input::{\n-        FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency,\n+        FileId, CrateId, SourceRoot, SourceRootId, CrateGraph, Dependency, Edition,\n     },\n     loc2id::LocationIntener,\n };"}, {"sha": "fb7ad086754f8a674a11beffd5383dd842138b00", "filename": "crates/ra_hir/src/code_model_api.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model_api.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -1,7 +1,7 @@\n use std::sync::Arc;\n \n use relative_path::RelativePathBuf;\n-use ra_db::{CrateId, FileId, SourceRootId};\n+use ra_db::{CrateId, FileId, SourceRootId, Edition};\n use ra_syntax::{ast::self, TreeArc, SyntaxNode};\n \n use crate::{\n@@ -38,13 +38,20 @@ impl Crate {\n     pub fn crate_id(&self) -> CrateId {\n         self.crate_id\n     }\n+\n     pub fn dependencies(&self, db: &impl PersistentHirDatabase) -> Vec<CrateDependency> {\n         self.dependencies_impl(db)\n     }\n+\n     pub fn root_module(&self, db: &impl PersistentHirDatabase) -> Option<Module> {\n         self.root_module_impl(db)\n     }\n \n+    pub fn edition(&self, db: &impl PersistentHirDatabase) -> Edition {\n+        let crate_graph = db.crate_graph();\n+        crate_graph.edition(self.crate_id)\n+    }\n+\n     // TODO: should this be in source_binder?\n     pub fn source_root_crates(\n         db: &impl PersistentHirDatabase,"}, {"sha": "16852a6a14074c87f43f84191cf3ead25ccd5c3b", "filename": "crates/ra_hir/src/marks.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fmarks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmarks.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -6,4 +6,5 @@ test_utils::marks!(\n     type_var_resolves_to_int_var\n     glob_enum\n     glob_across_crates\n+    std_prelude\n );"}, {"sha": "f1cad77c5a59c3b609e8c528ac09649f917e9de9", "filename": "crates/ra_hir/src/mock.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fmock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fmock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fmock.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -3,6 +3,7 @@ use std::{sync::Arc, panic};\n use parking_lot::Mutex;\n use ra_db::{\n     FilePosition, FileId, CrateGraph, SourceRoot, SourceRootId, SourceDatabase, salsa,\n+    Edition,\n };\n use relative_path::RelativePathBuf;\n use test_utils::{parse_fixture, CURSOR_MARKER, extract_offset};\n@@ -58,12 +59,12 @@ impl MockDatabase {\n     pub fn set_crate_graph_from_fixture(&mut self, graph: CrateGraphFixture) {\n         let mut ids = FxHashMap::default();\n         let mut crate_graph = CrateGraph::default();\n-        for (crate_name, (crate_root, _)) in graph.0.iter() {\n+        for (crate_name, (crate_root, edition, _)) in graph.0.iter() {\n             let crate_root = self.file_id_of(&crate_root);\n-            let crate_id = crate_graph.add_crate_root(crate_root);\n+            let crate_id = crate_graph.add_crate_root(crate_root, *edition);\n             ids.insert(crate_name, crate_id);\n         }\n-        for (crate_name, (_, deps)) in graph.0.iter() {\n+        for (crate_name, (_, _, deps)) in graph.0.iter() {\n             let from = ids[crate_name];\n             for dep in deps {\n                 let to = ids[dep];\n@@ -144,7 +145,7 @@ impl MockDatabase {\n \n         if is_crate_root {\n             let mut crate_graph = CrateGraph::default();\n-            crate_graph.add_crate_root(file_id);\n+            crate_graph.add_crate_root(file_id, Edition::Edition2018);\n             self.set_crate_graph(Arc::new(crate_graph));\n         }\n         file_id\n@@ -232,16 +233,19 @@ impl MockDatabase {\n }\n \n #[derive(Default)]\n-pub struct CrateGraphFixture(pub FxHashMap<String, (String, Vec<String>)>);\n+pub struct CrateGraphFixture(pub FxHashMap<String, (String, Edition, Vec<String>)>);\n \n #[macro_export]\n macro_rules! crate_graph {\n-    ($($crate_name:literal: ($crate_path:literal, [$($dep:literal),*]),)*) => {{\n+    ($($crate_name:literal: ($crate_path:literal, $($edition:literal,)? [$($dep:literal),*]),)*) => {{\n         let mut res = $crate::mock::CrateGraphFixture::default();\n         $(\n+            #[allow(unused_mut, unused_assignments)]\n+            let mut edition = ra_db::Edition::Edition2018;\n+            $(edition = ra_db::Edition::from_string($edition);)?\n             res.0.insert(\n                 $crate_name.to_string(),\n-                ($crate_path.to_string(), vec![$($dep.to_string()),*])\n+                ($crate_path.to_string(), edition, vec![$($dep.to_string()),*])\n             );\n         )*\n         res"}, {"sha": "e35b4b129cad72f8da77d80b4a1c52c7f9ac685f", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 116, "deletions": 11, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -18,9 +18,11 @@ pub(crate) mod lower;\n \n use std::{time, sync::Arc};\n \n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n use ra_arena::map::ArenaMap;\n+use ra_db::Edition;\n use test_utils::tested_by;\n-use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n     Module, ModuleDef,\n@@ -32,8 +34,13 @@ use crate::{\n \n /// `ItemMap` is the result of module name resolution. It contains, for each\n /// module, the set of visible items.\n-#[derive(Default, Debug, PartialEq, Eq)]\n+#[derive(Debug, PartialEq, Eq)]\n pub struct ItemMap {\n+    edition: Edition,\n+    /// The prelude module for this crate. This either comes from an import\n+    /// marked with the `prelude_import` attribute, or (in the normal case) from\n+    /// a dependency (`std` or `core`).\n+    pub(crate) prelude: Option<Module>,\n     pub(crate) extern_prelude: FxHashMap<Name, ModuleDef>,\n     per_module: ArenaMap<ModuleId, ModuleScope>,\n }\n@@ -176,7 +183,12 @@ where\n             module_tree,\n             processed_imports: FxHashSet::default(),\n             glob_imports: FxHashMap::default(),\n-            result: ItemMap::default(),\n+            result: ItemMap {\n+                edition: krate.edition(db),\n+                prelude: None,\n+                extern_prelude: FxHashMap::default(),\n+                per_module: ArenaMap::default(),\n+            },\n         }\n     }\n \n@@ -211,6 +223,13 @@ where\n             if let Some(module) = dep.krate.root_module(self.db) {\n                 self.result.extern_prelude.insert(dep.name.clone(), module.into());\n             }\n+            // look for the prelude\n+            if self.result.prelude.is_none() {\n+                let item_map = self.db.item_map(dep.krate);\n+                if item_map.prelude.is_some() {\n+                    self.result.prelude = item_map.prelude;\n+                }\n+            }\n         }\n     }\n \n@@ -266,10 +285,20 @@ where\n         import_id: ImportId,\n         import: &ImportData,\n     ) -> ReachedFixedPoint {\n-        log::debug!(\"resolving import: {:?}\", import);\n+        log::debug!(\"resolving import: {:?} ({:?})\", import, self.result.edition);\n         let original_module = Module { krate: self.krate, module_id };\n-        let (def, reached_fixedpoint) =\n-            self.result.resolve_path_fp(self.db, original_module, &import.path);\n+\n+        let (def, reached_fixedpoint) = if import.is_extern_crate {\n+            let res = self.result.resolve_name_in_extern_prelude(\n+                &import\n+                    .path\n+                    .as_ident()\n+                    .expect(\"extern crate should have been desugared to one-element path\"),\n+            );\n+            (res, if res.is_none() { ReachedFixedPoint::No } else { ReachedFixedPoint::Yes })\n+        } else {\n+            self.result.resolve_path_fp(self.db, ResolveMode::Import, original_module, &import.path)\n+        };\n \n         if reached_fixedpoint != ReachedFixedPoint::Yes {\n             return reached_fixedpoint;\n@@ -279,7 +308,10 @@ where\n             log::debug!(\"glob import: {:?}\", import);\n             match def.take_types() {\n                 Some(ModuleDef::Module(m)) => {\n-                    if m.krate != self.krate {\n+                    if import.is_prelude {\n+                        tested_by!(std_prelude);\n+                        self.result.prelude = Some(m);\n+                    } else if m.krate != self.krate {\n                         tested_by!(glob_across_crates);\n                         // glob import from other crate => we can just import everything once\n                         let item_map = self.db.item_map(m.krate);\n@@ -403,6 +435,12 @@ where\n     }\n }\n \n+#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n+enum ResolveMode {\n+    Import,\n+    Other,\n+}\n+\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n enum ReachedFixedPoint {\n     Yes,\n@@ -431,35 +469,102 @@ impl ItemMap {\n         original_module: Module,\n         path: &Path,\n     ) -> PerNs<ModuleDef> {\n-        self.resolve_path_fp(db, original_module, path).0\n+        self.resolve_path_fp(db, ResolveMode::Other, original_module, path).0\n+    }\n+\n+    fn resolve_in_prelude(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        original_module: Module,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        if let Some(prelude) = self.prelude {\n+            let resolution = if prelude.krate == original_module.krate {\n+                self[prelude.module_id].items.get(name).cloned()\n+            } else {\n+                db.item_map(prelude.krate)[prelude.module_id].items.get(name).cloned()\n+            };\n+            resolution.map(|r| r.def).unwrap_or_else(PerNs::none)\n+        } else {\n+            PerNs::none()\n+        }\n     }\n \n-    pub(crate) fn resolve_name_in_module(&self, module: Module, name: &Name) -> PerNs<ModuleDef> {\n+    pub(crate) fn resolve_name_in_module(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        module: Module,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        // Resolve in:\n+        //  - current module / scope\n+        //  - extern prelude\n+        //  - std prelude\n         let from_scope = self[module.module_id].items.get(name).map_or(PerNs::none(), |it| it.def);\n         let from_extern_prelude =\n             self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it));\n+        let from_prelude = self.resolve_in_prelude(db, module, name);\n+\n+        from_scope.or(from_extern_prelude).or(from_prelude)\n+    }\n+\n+    fn resolve_name_in_extern_prelude(&self, name: &Name) -> PerNs<ModuleDef> {\n+        self.extern_prelude.get(name).map_or(PerNs::none(), |&it| PerNs::types(it))\n+    }\n \n-        from_scope.or(from_extern_prelude)\n+    fn resolve_name_in_crate_root_or_extern_prelude(\n+        &self,\n+        db: &impl PersistentHirDatabase,\n+        module: Module,\n+        name: &Name,\n+    ) -> PerNs<ModuleDef> {\n+        let crate_root = module.crate_root(db);\n+        let from_crate_root =\n+            self[crate_root.module_id].items.get(name).map_or(PerNs::none(), |it| it.def);\n+        let from_extern_prelude = self.resolve_name_in_extern_prelude(name);\n+\n+        from_crate_root.or(from_extern_prelude)\n     }\n \n     // Returns Yes if we are sure that additions to `ItemMap` wouldn't change\n     // the result.\n     fn resolve_path_fp(\n         &self,\n         db: &impl PersistentHirDatabase,\n+        mode: ResolveMode,\n         original_module: Module,\n         path: &Path,\n     ) -> (PerNs<ModuleDef>, ReachedFixedPoint) {\n         let mut segments = path.segments.iter().enumerate();\n         let mut curr_per_ns: PerNs<ModuleDef> = match path.kind {\n             PathKind::Crate => PerNs::types(original_module.crate_root(db).into()),\n             PathKind::Self_ => PerNs::types(original_module.into()),\n+            // plain import or absolute path in 2015: crate-relative with\n+            // fallback to extern prelude (with the simplification in\n+            // rust-lang/rust#57745)\n+            // TODO there must be a nicer way to write this condition\n+            PathKind::Plain | PathKind::Abs\n+                if self.edition == Edition::Edition2015\n+                    && (path.kind == PathKind::Abs || mode == ResolveMode::Import) =>\n+            {\n+                let segment = match segments.next() {\n+                    Some((_, segment)) => segment,\n+                    None => return (PerNs::none(), ReachedFixedPoint::Yes),\n+                };\n+                log::debug!(\"resolving {:?} in crate root (+ extern prelude)\", segment);\n+                self.resolve_name_in_crate_root_or_extern_prelude(\n+                    db,\n+                    original_module,\n+                    &segment.name,\n+                )\n+            }\n             PathKind::Plain => {\n                 let segment = match segments.next() {\n                     Some((_, segment)) => segment,\n                     None => return (PerNs::none(), ReachedFixedPoint::Yes),\n                 };\n-                self.resolve_name_in_module(original_module, &segment.name)\n+                log::debug!(\"resolving {:?} in module\", segment);\n+                self.resolve_name_in_module(db, original_module, &segment.name)\n             }\n             PathKind::Super => {\n                 if let Some(p) = original_module.parent(db) {"}, {"sha": "81d80654c969e8012cb69e7ea6e0f39294b74063", "filename": "crates/ra_hir/src/nameres/lower.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Flower.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -2,13 +2,13 @@ use std::sync::Arc;\n \n use ra_syntax::{\n     AstNode, SourceFile, TreeArc, AstPtr,\n-    ast::{self, ModuleItemOwner, NameOwner},\n+    ast::{self, ModuleItemOwner, NameOwner, AttrsOwner},\n };\n use ra_arena::{Arena, RawId, impl_arena_id, map::ArenaMap};\n use rustc_hash::FxHashMap;\n \n use crate::{\n-    SourceItemId, Path, PathKind, ModuleSource, Name,\n+    SourceItemId, Path, ModuleSource, Name,\n     HirFileId, MacroCallLoc, AsName, PerNs, Function,\n     ModuleDef, Module, Struct, Enum, Const, Static, Trait, Type,\n     ids::LocationCtx, PersistentHirDatabase,\n@@ -23,6 +23,7 @@ pub(super) struct ImportData {\n     pub(super) path: Path,\n     pub(super) alias: Option<Name>,\n     pub(super) is_glob: bool,\n+    pub(super) is_prelude: bool,\n     pub(super) is_extern_crate: bool,\n }\n \n@@ -179,18 +180,14 @@ impl LoweredModule {\n                 self.add_use_item(source_map, it);\n             }\n             ast::ModuleItemKind::ExternCrateItem(it) => {\n-                // Lower `extern crate x` to `use ::x`. This is kind of cheating\n-                // and only works if we always interpret absolute paths in the\n-                // 2018 style; otherwise `::x` could also refer to a module in\n-                // the crate root.\n                 if let Some(name_ref) = it.name_ref() {\n-                    let mut path = Path::from_name_ref(name_ref);\n-                    path.kind = PathKind::Abs;\n+                    let path = Path::from_name_ref(name_ref);\n                     let alias = it.alias().and_then(|a| a.name()).map(AsName::as_name);\n                     self.imports.alloc(ImportData {\n                         path,\n                         alias,\n                         is_glob: false,\n+                        is_prelude: false,\n                         is_extern_crate: true,\n                     });\n                 }\n@@ -214,11 +211,14 @@ impl LoweredModule {\n     }\n \n     fn add_use_item(&mut self, source_map: &mut ImportSourceMap, item: &ast::UseItem) {\n+        let is_prelude =\n+            item.attrs().any(|attr| attr.as_atom().map(|s| s == \"prelude_import\").unwrap_or(false));\n         Path::expand_use_item(item, |path, segment, alias| {\n             let import = self.imports.alloc(ImportData {\n                 path,\n                 alias,\n                 is_glob: segment.is_none(),\n+                is_prelude,\n                 is_extern_crate: false,\n             });\n             if let Some(segment) = segment {"}, {"sha": "6402c89c08b623453292f3d6be647a9e69825572", "filename": "crates/ra_hir/src/nameres/tests.rs", "status": "modified", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Ftests.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -265,6 +265,45 @@ fn glob_across_crates() {\n     );\n }\n \n+#[test]\n+fn edition_2015_imports() {\n+    let mut db = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        mod foo;\n+        mod bar;\n+\n+        //- /bar.rs\n+        struct Bar;\n+\n+        //- /foo.rs\n+        use bar::Bar;\n+        use other_crate::FromLib;\n+\n+        //- /lib.rs\n+        struct FromLib;\n+    \",\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", \"2015\", [\"other_crate\"]),\n+        \"other_crate\": (\"/lib.rs\", \"2018\", []),\n+    });\n+    let foo_id = db.file_id_of(\"/foo.rs\");\n+\n+    let module = crate::source_binder::module_from_file_id(&db, foo_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate);\n+\n+    check_module_item_map(\n+        &item_map,\n+        module.module_id,\n+        \"\n+            Bar: t v\n+            FromLib: t v\n+        \",\n+    );\n+}\n+\n #[test]\n fn module_resolution_works_for_non_standard_filenames() {\n     let mut db = MockDatabase::with_files(\n@@ -296,6 +335,43 @@ fn module_resolution_works_for_non_standard_filenames() {\n     );\n }\n \n+#[test]\n+fn std_prelude() {\n+    covers!(std_prelude);\n+    let mut db = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        use Foo::*;\n+\n+        //- /lib.rs\n+        mod prelude;\n+        #[prelude_import]\n+        use prelude::*;\n+\n+        //- /prelude.rs\n+        pub enum Foo { Bar, Baz };\n+    \",\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", [\"test_crate\"]),\n+        \"test_crate\": (\"/lib.rs\", []),\n+    });\n+    let main_id = db.file_id_of(\"/main.rs\");\n+\n+    let module = crate::source_binder::module_from_file_id(&db, main_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate);\n+\n+    check_module_item_map(\n+        &item_map,\n+        module.module_id,\n+        \"\n+            Bar: t v\n+            Baz: t v\n+        \",\n+    );\n+}\n+\n #[test]\n fn name_res_works_for_broken_modules() {\n     covers!(name_res_works_for_broken_modules);\n@@ -466,6 +542,42 @@ fn extern_crate_rename() {\n     );\n }\n \n+#[test]\n+fn extern_crate_rename_2015_edition() {\n+    let mut db = MockDatabase::with_files(\n+        \"\n+        //- /main.rs\n+        extern crate alloc as alloc_crate;\n+\n+        mod alloc;\n+        mod sync;\n+\n+        //- /sync.rs\n+        use alloc_crate::Arc;\n+\n+        //- /lib.rs\n+        struct Arc;\n+        \",\n+    );\n+    db.set_crate_graph_from_fixture(crate_graph! {\n+        \"main\": (\"/main.rs\", \"2015\", [\"alloc\"]),\n+        \"alloc\": (\"/lib.rs\", []),\n+    });\n+    let sync_id = db.file_id_of(\"/sync.rs\");\n+\n+    let module = crate::source_binder::module_from_file_id(&db, sync_id).unwrap();\n+    let krate = module.krate(&db).unwrap();\n+    let item_map = db.item_map(krate);\n+\n+    check_module_item_map(\n+        &item_map,\n+        module.module_id,\n+        \"\n+        Arc: t v\n+        \",\n+    );\n+}\n+\n #[test]\n fn import_across_source_roots() {\n     let mut db = MockDatabase::with_files("}, {"sha": "91a531801b724c0ea4111f78cd16d3b956038505", "filename": "crates/ra_hir/src/resolve.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_hir%2Fsrc%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fresolve.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -56,10 +56,10 @@ pub enum Resolution {\n }\n \n impl Resolver {\n-    pub fn resolve_name(&self, name: &Name) -> PerNs<Resolution> {\n+    pub fn resolve_name(&self, db: &impl HirDatabase, name: &Name) -> PerNs<Resolution> {\n         let mut resolution = PerNs::none();\n         for scope in self.scopes.iter().rev() {\n-            resolution = resolution.or(scope.resolve_name(name));\n+            resolution = resolution.or(scope.resolve_name(db, name));\n             if resolution.is_both() {\n                 return resolution;\n             }\n@@ -69,9 +69,9 @@ impl Resolver {\n \n     pub fn resolve_path(&self, db: &impl HirDatabase, path: &Path) -> PerNs<Resolution> {\n         if let Some(name) = path.as_ident() {\n-            self.resolve_name(name)\n+            self.resolve_name(db, name)\n         } else if path.is_self() {\n-            self.resolve_name(&Name::self_param())\n+            self.resolve_name(db, &Name::self_param())\n         } else {\n             let (item_map, module) = match self.module() {\n                 Some(m) => m,\n@@ -82,10 +82,10 @@ impl Resolver {\n         }\n     }\n \n-    pub fn all_names(&self) -> FxHashMap<Name, PerNs<Resolution>> {\n+    pub fn all_names(&self, db: &impl HirDatabase) -> FxHashMap<Name, PerNs<Resolution>> {\n         let mut names = FxHashMap::default();\n         for scope in self.scopes.iter().rev() {\n-            scope.collect_names(&mut |name, res| {\n+            scope.collect_names(db, &mut |name, res| {\n                 let current: &mut PerNs<Resolution> = names.entry(name).or_default();\n                 if current.types.is_none() {\n                     current.types = res.types;\n@@ -143,13 +143,13 @@ impl Resolver {\n }\n \n impl Scope {\n-    fn resolve_name(&self, name: &Name) -> PerNs<Resolution> {\n+    fn resolve_name(&self, db: &impl HirDatabase, name: &Name) -> PerNs<Resolution> {\n         match self {\n             Scope::ModuleScope(m) => {\n                 if let Some(KnownName::SelfParam) = name.as_known_name() {\n                     PerNs::types(Resolution::Def(m.module.into()))\n                 } else {\n-                    m.item_map.resolve_name_in_module(m.module, name).map(Resolution::Def)\n+                    m.item_map.resolve_name_in_module(db, m.module, name).map(Resolution::Def)\n                 }\n             }\n             Scope::GenericParams(gp) => match gp.find_by_name(name) {\n@@ -174,7 +174,7 @@ impl Scope {\n         }\n     }\n \n-    fn collect_names(&self, f: &mut dyn FnMut(Name, PerNs<Resolution>)) {\n+    fn collect_names(&self, db: &impl HirDatabase, f: &mut dyn FnMut(Name, PerNs<Resolution>)) {\n         match self {\n             Scope::ModuleScope(m) => {\n                 // TODO: should we provide `self` here?\n@@ -190,6 +190,12 @@ impl Scope {\n                 m.item_map.extern_prelude.iter().for_each(|(name, def)| {\n                     f(name.clone(), PerNs::types(Resolution::Def(*def)));\n                 });\n+                if let Some(prelude) = m.item_map.prelude {\n+                    let prelude_item_map = db.item_map(prelude.krate);\n+                    prelude_item_map[prelude.module_id].entries().for_each(|(name, res)| {\n+                        f(name.clone(), res.def.map(Resolution::Def));\n+                    });\n+                }\n             }\n             Scope::GenericParams(gp) => {\n                 for param in &gp.params {"}, {"sha": "eeaf26d939ba87689e9777a1133928fa47bce49a", "filename": "crates/ra_ide_api/src/completion/complete_scope.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_scope.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -4,7 +4,7 @@ pub(super) fn complete_scope(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.is_trivial_path {\n         return;\n     }\n-    let names = ctx.resolver.all_names();\n+    let names = ctx.resolver.all_names(ctx.db);\n \n     names.into_iter().for_each(|(name, res)| {\n         CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.to_string())\n@@ -165,4 +165,23 @@ mod tests {\n     fn completes_self_in_methods() {\n         check_reference_completion(\"self_in_methods\", r\"impl S { fn foo(&self) { <|> } }\")\n     }\n+\n+    #[test]\n+    fn completes_prelude() {\n+        check_reference_completion(\n+            \"completes_prelude\",\n+            \"\n+            //- /main.rs\n+            fn foo() { let x: <|> }\n+\n+            //- /std/lib.rs\n+            #[prelude_import]\n+            use prelude::*;\n+\n+            mod prelude {\n+                struct Option;\n+            }\n+            \",\n+        );\n+    }\n }"}, {"sha": "2b5a1a8ea072f920cb7553492b38d946346e75e6", "filename": "crates/ra_ide_api/src/completion/snapshots/completion_item__completes_prelude.snap", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__completes_prelude.snap", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__completes_prelude.snap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fsnapshots%2Fcompletion_item__completes_prelude.snap?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -0,0 +1,54 @@\n+---\n+created: \"2019-02-13T19:52:43.734834624Z\"\n+creator: insta@0.6.2\n+source: crates/ra_ide_api/src/completion/completion_item.rs\n+expression: kind_completions\n+---\n+[\n+    CompletionItem {\n+        completion_kind: Reference,\n+        label: \"Option\",\n+        kind: Some(\n+            Struct\n+        ),\n+        detail: None,\n+        documentation: None,\n+        lookup: None,\n+        insert_text: None,\n+        insert_text_format: PlainText,\n+        source_range: [18; 18),\n+        text_edit: None\n+    },\n+    CompletionItem {\n+        completion_kind: Reference,\n+        label: \"foo\",\n+        kind: Some(\n+            Function\n+        ),\n+        detail: Some(\n+            \"fn foo()\"\n+        ),\n+        documentation: None,\n+        lookup: None,\n+        insert_text: Some(\n+            \"foo()$0\"\n+        ),\n+        insert_text_format: Snippet,\n+        source_range: [18; 18),\n+        text_edit: None\n+    },\n+    CompletionItem {\n+        completion_kind: Reference,\n+        label: \"std\",\n+        kind: Some(\n+            Module\n+        ),\n+        detail: None,\n+        documentation: None,\n+        lookup: None,\n+        insert_text: None,\n+        insert_text_format: PlainText,\n+        source_range: [18; 18),\n+        text_edit: None\n+    }\n+]"}, {"sha": "d77a56ce805c23a5aa2fe9b42b70271cff0309b1", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -62,7 +62,8 @@ pub use ra_ide_api_light::{\n     LineIndex, LineCol, translate_offset_with_edit,\n };\n pub use ra_db::{\n-    Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId\n+    Canceled, CrateGraph, CrateId, FileId, FilePosition, FileRange, SourceRootId,\n+    Edition\n };\n pub use hir::Documentation;\n "}, {"sha": "550d69641759debab912612d727611d27b1c2747", "filename": "crates/ra_ide_api/src/mock_analysis.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fmock_analysis.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -3,7 +3,7 @@ use std::sync::Arc;\n use relative_path::RelativePathBuf;\n use test_utils::{extract_offset, extract_range, parse_fixture, CURSOR_MARKER};\n \n-use crate::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, FilePosition, FileRange, SourceRootId};\n+use crate::{Analysis, AnalysisChange, AnalysisHost, CrateGraph, FileId, FilePosition, FileRange, SourceRootId, Edition::Edition2018};\n \n /// Mock analysis is used in test to bootstrap an AnalysisHost/Analysis\n /// from a set of in-memory files.\n@@ -89,9 +89,9 @@ impl MockAnalysis {\n             let path = RelativePathBuf::from_path(&path[1..]).unwrap();\n             let file_id = FileId(i as u32 + 1);\n             if path == \"/lib.rs\" || path == \"/main.rs\" {\n-                root_crate = Some(crate_graph.add_crate_root(file_id));\n+                root_crate = Some(crate_graph.add_crate_root(file_id, Edition2018));\n             } else if path.ends_with(\"/lib.rs\") {\n-                let other_crate = crate_graph.add_crate_root(file_id);\n+                let other_crate = crate_graph.add_crate_root(file_id, Edition2018);\n                 let crate_name = path.parent().unwrap().file_name().unwrap();\n                 if let Some(root_crate) = root_crate {\n                     crate_graph.add_dep(root_crate, crate_name.into(), other_crate).unwrap();"}, {"sha": "0526f758453bdac9898ca8d214fe92d454512284", "filename": "crates/ra_ide_api/tests/test/main.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Ftests%2Ftest%2Fmain.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -1,7 +1,7 @@\n use insta::assert_debug_snapshot_matches;\n use ra_ide_api::{\n     mock_analysis::{single_file, single_file_with_position, MockAnalysis},\n-    AnalysisChange, CrateGraph, FileId, Query, NavigationTarget,\n+    AnalysisChange, CrateGraph, Edition::Edition2018, FileId, Query, NavigationTarget\n };\n use ra_syntax::{TextRange, SmolStr};\n \n@@ -36,7 +36,7 @@ fn test_resolve_crate_root() {\n     assert!(host.analysis().crate_for(mod_file).unwrap().is_empty());\n \n     let mut crate_graph = CrateGraph::default();\n-    let crate_id = crate_graph.add_crate_root(root_file);\n+    let crate_id = crate_graph.add_crate_root(root_file, Edition2018);\n     let mut change = AnalysisChange::new();\n     change.set_crate_graph(crate_graph);\n     host.apply_change(change);"}, {"sha": "81cb506b73a7a219fb6a406e7a38f3f662fd9c76", "filename": "crates/ra_project_model/src/cargo_workspace.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Fcargo_workspace.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -4,6 +4,7 @@ use cargo_metadata::{MetadataCommand, CargoOpt};\n use ra_arena::{Arena, RawId, impl_arena_id};\n use rustc_hash::FxHashMap;\n use failure::format_err;\n+use ra_db::Edition;\n \n use crate::Result;\n \n@@ -35,6 +36,7 @@ struct PackageData {\n     targets: Vec<Target>,\n     is_member: bool,\n     dependencies: Vec<PackageDependency>,\n+    edition: Edition,\n }\n \n #[derive(Debug, Clone)]\n@@ -84,6 +86,9 @@ impl Package {\n     pub fn root(self, ws: &CargoWorkspace) -> &Path {\n         ws.packages[self].manifest.parent().unwrap()\n     }\n+    pub fn edition(self, ws: &CargoWorkspace) -> Edition {\n+        ws.packages[self].edition\n+    }\n     pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n         ws.packages[self].targets.iter().cloned()\n     }\n@@ -135,6 +140,7 @@ impl CargoWorkspace {\n                 manifest: meta_pkg.manifest_path.clone(),\n                 targets: Vec::new(),\n                 is_member,\n+                edition: Edition::from_string(&meta_pkg.edition),\n                 dependencies: Vec::new(),\n             });\n             let pkg_data = &mut packages[pkg];"}, {"sha": "1b18ac8361e03c6024f6dfad2a226c21e9b4b93e", "filename": "crates/ra_project_model/src/lib.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_project_model%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_project_model%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_project_model%2Fsrc%2Flib.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -6,7 +6,7 @@ use std::path::{Path, PathBuf};\n use failure::bail;\n use rustc_hash::FxHashMap;\n \n-use ra_db::{CrateGraph, FileId};\n+use ra_db::{CrateGraph, FileId, Edition};\n \n pub use crate::{\n     cargo_workspace::{CargoWorkspace, Package, Target, TargetKind},\n@@ -36,7 +36,8 @@ impl ProjectWorkspace {\n         let mut sysroot_crates = FxHashMap::default();\n         for krate in self.sysroot.crates() {\n             if let Some(file_id) = load(krate.root(&self.sysroot)) {\n-                sysroot_crates.insert(krate, crate_graph.add_crate_root(file_id));\n+                sysroot_crates\n+                    .insert(krate, crate_graph.add_crate_root(file_id, Edition::Edition2015));\n             }\n         }\n         for from in self.sysroot.crates() {\n@@ -62,7 +63,8 @@ impl ProjectWorkspace {\n             for tgt in pkg.targets(&self.cargo) {\n                 let root = tgt.root(&self.cargo);\n                 if let Some(file_id) = load(root) {\n-                    let crate_id = crate_graph.add_crate_root(file_id);\n+                    let edition = pkg.edition(&self.cargo);\n+                    let crate_id = crate_graph.add_crate_root(file_id, edition);\n                     if tgt.kind(&self.cargo) == TargetKind::Lib {\n                         lib_tgt = Some(crate_id);\n                         pkg_to_lib_crate.insert(pkg, crate_id);"}, {"sha": "7c5e8ce5ed0df3cc4d237ba72c2785ca93cbff00", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -4210,6 +4210,7 @@ impl ToOwned for UseItem {\n }\n \n \n+impl ast::AttrsOwner for UseItem {}\n impl UseItem {\n     pub fn use_tree(&self) -> Option<&UseTree> {\n         super::child_opt(self)"}, {"sha": "304bc59096e08e11741c2f2ae37de16ddf11385f", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/cb4327b3a9f0858235dc20b7c5c7e25c6c330aab/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=cb4327b3a9f0858235dc20b7c5c7e25c6c330aab", "patch": "@@ -596,7 +596,8 @@ Grammar(\n             options: [ \"Pat\", \"TypeRef\" ],\n         ),\n         \"UseItem\": (\n-            options: [ \"UseTree\" ]\n+            traits: [\"AttrsOwner\"],\n+            options: [ \"UseTree\" ],\n         ),\n         \"UseTree\": (\n             options: [ \"Path\", \"UseTreeList\", \"Alias\" ]"}]}