{"sha": "2e2080dee60d2bad4eaed97e0a74de54f53226ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJlMjA4MGRlZTYwZDJiYWQ0ZWFlZDk3ZTBhNzRkZTU0ZjUzMjI2YmE=", "commit": {"author": {"name": "Dylan DPC", "email": "dylan.dpc@gmail.com", "date": "2020-04-24T23:35:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-04-24T23:35:53Z"}, "message": "Rollup merge of #69456 - contrun:fix-misleading-compiler-error, r=estebank\n\nfix misleading type annotation diagonstics\n\nThis solves the method call part of issue https://github.com/rust-lang/rust/issues/69455", "tree": {"sha": "bbcef49c42c9684eb3c25802742cf608f1da1f5f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bbcef49c42c9684eb3c25802742cf608f1da1f5f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e2080dee60d2bad4eaed97e0a74de54f53226ba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeo3faCRBK7hj4Ov3rIwAAdHIIAAlWnp9Nw9jw9e4E4TivL8C+\nK2KZp97ITfOoozI8kLqEDBfGh0Mjjc7u3j1Z+jWpgxUVBgxoJPZXzYWAZ1L254Q0\nIlbwINgVzJuzekGbZbSzwlvxYh4zuNHdA7ftlvENbMu0ee8vKQ6i8Z83Pr7lr02a\nwdSsi1mcLTMvx6qZXfWtug5ndZFrwNGwslLPy6PSWamGEuv1PxYXYVH3TakpGFr/\nMtc+EuQxNnJEJSEfPhWO929aWURyqUQOlT9p4DM96LYRAVheS99pcC6Fh2sAQV0d\nZ3bKyXDlub02ZnU2u1YvEPCHOQ6lfW2rPv6uXduD1ZuBsdxFy1Swnkxy2u0C3LM=\n=bbDM\n-----END PGP SIGNATURE-----\n", "payload": "tree bbcef49c42c9684eb3c25802742cf608f1da1f5f\nparent 3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69\nparent 3ae974f025d4376c720e3b2773ccd2c201f098dc\nauthor Dylan DPC <dylan.dpc@gmail.com> 1587771353 +0200\ncommitter GitHub <noreply@github.com> 1587771353 +0200\n\nRollup merge of #69456 - contrun:fix-misleading-compiler-error, r=estebank\n\nfix misleading type annotation diagonstics\n\nThis solves the method call part of issue https://github.com/rust-lang/rust/issues/69455\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e2080dee60d2bad4eaed97e0a74de54f53226ba", "html_url": "https://github.com/rust-lang/rust/commit/2e2080dee60d2bad4eaed97e0a74de54f53226ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e2080dee60d2bad4eaed97e0a74de54f53226ba/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69", "url": "https://api.github.com/repos/rust-lang/rust/commits/3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69", "html_url": "https://github.com/rust-lang/rust/commit/3360cc3a0ea33c84d0b0b1163107b1c1acbf2a69"}, {"sha": "3ae974f025d4376c720e3b2773ccd2c201f098dc", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ae974f025d4376c720e3b2773ccd2c201f098dc", "html_url": "https://github.com/rust-lang/rust/commit/3ae974f025d4376c720e3b2773ccd2c201f098dc"}], "stats": {"total": 105, "additions": 99, "deletions": 6}, "files": [{"sha": "53f52038ed0222676ab2e1f0642f368e05ebfc8c", "filename": "src/librustc_infer/infer/error_reporting/need_type_info.rs", "status": "modified", "additions": 52, "deletions": 6, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/2e2080dee60d2bad4eaed97e0a74de54f53226ba/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2080dee60d2bad4eaed97e0a74de54f53226ba/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fneed_type_info.rs?ref=2e2080dee60d2bad4eaed97e0a74de54f53226ba", "patch": "@@ -17,23 +17,27 @@ use std::borrow::Cow;\n struct FindHirNodeVisitor<'a, 'tcx> {\n     infcx: &'a InferCtxt<'a, 'tcx>,\n     target: GenericArg<'tcx>,\n+    target_span: Span,\n     found_node_ty: Option<Ty<'tcx>>,\n     found_local_pattern: Option<&'tcx Pat<'tcx>>,\n     found_arg_pattern: Option<&'tcx Pat<'tcx>>,\n     found_closure: Option<&'tcx Expr<'tcx>>,\n     found_method_call: Option<&'tcx Expr<'tcx>>,\n+    found_exact_method_call: Option<&'tcx Expr<'tcx>>,\n }\n \n impl<'a, 'tcx> FindHirNodeVisitor<'a, 'tcx> {\n-    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>) -> Self {\n+    fn new(infcx: &'a InferCtxt<'a, 'tcx>, target: GenericArg<'tcx>, target_span: Span) -> Self {\n         Self {\n             infcx,\n             target,\n+            target_span,\n             found_node_ty: None,\n             found_local_pattern: None,\n             found_arg_pattern: None,\n             found_closure: None,\n             found_method_call: None,\n+            found_exact_method_call: None,\n         }\n     }\n \n@@ -103,6 +107,17 @@ impl<'a, 'tcx> Visitor<'tcx> for FindHirNodeVisitor<'a, 'tcx> {\n     }\n \n     fn visit_expr(&mut self, expr: &'tcx Expr<'tcx>) {\n+        if let ExprKind::MethodCall(_, call_span, exprs) = expr.kind {\n+            if call_span == self.target_span\n+                && Some(self.target)\n+                    == self.infcx.in_progress_tables.and_then(|tables| {\n+                        tables.borrow().node_type_opt(exprs.first().unwrap().hir_id).map(Into::into)\n+                    })\n+            {\n+                self.found_exact_method_call = Some(&expr);\n+                return;\n+            }\n+        }\n         if self.node_ty_contains_target(expr.hir_id).is_some() {\n             match expr.kind {\n                 ExprKind::Closure(..) => self.found_closure = Some(&expr),\n@@ -234,7 +249,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         let ty = self.resolve_vars_if_possible(&ty);\n         let (name, name_sp, descr, parent_name, parent_descr) = self.extract_type_name(&ty, None);\n \n-        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into());\n+        let mut local_visitor = FindHirNodeVisitor::new(&self, ty.into(), span);\n         let ty_to_string = |ty: Ty<'tcx>| -> String {\n             let mut s = String::new();\n             let mut printer = ty::print::FmtPrinter::new(self.tcx, &mut s, Namespace::TypeNS);\n@@ -287,14 +302,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 (!ty.is_impl_trait() || self.tcx.features().impl_trait_in_bindings)\n         };\n \n-        let ty_msg = match local_visitor.found_node_ty {\n-            Some(ty::TyS { kind: ty::Closure(_, substs), .. }) => {\n+        let ty_msg = match (local_visitor.found_node_ty, local_visitor.found_exact_method_call) {\n+            (_, Some(_)) => String::new(),\n+            (Some(ty::TyS { kind: ty::Closure(_, substs), .. }), _) => {\n                 let fn_sig = substs.as_closure().sig();\n                 let args = closure_args(&fn_sig);\n                 let ret = fn_sig.output().skip_binder().to_string();\n                 format!(\" for the closure `fn({}) -> {}`\", args, ret)\n             }\n-            Some(ty) if is_named_and_not_impl_trait(ty) => {\n+            (Some(ty), _) if is_named_and_not_impl_trait(ty) => {\n                 let ty = ty_to_string(ty);\n                 format!(\" for `{}`\", ty)\n             }\n@@ -370,7 +386,37 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => \"a type\".to_string(),\n         };\n \n-        if let Some(pattern) = local_visitor.found_arg_pattern {\n+        if let Some(e) = local_visitor.found_exact_method_call {\n+            if let ExprKind::MethodCall(segment, ..) = &e.kind {\n+                // Suggest specifying type params or point out the return type of the call:\n+                //\n+                // error[E0282]: type annotations needed\n+                //   --> $DIR/type-annotations-needed-expr.rs:2:39\n+                //    |\n+                // LL |     let _ = x.into_iter().sum() as f64;\n+                //    |                           ^^^\n+                //    |                           |\n+                //    |                           cannot infer type for `S`\n+                //    |                           help: consider specifying the type argument in\n+                //    |                           the method call: `sum::<S>`\n+                //    |\n+                //    = note: type must be known at this point\n+                //\n+                // or\n+                //\n+                // error[E0282]: type annotations needed\n+                //   --> $DIR/issue-65611.rs:59:20\n+                //    |\n+                // LL |     let x = buffer.last().unwrap().0.clone();\n+                //    |             -------^^^^--\n+                //    |             |      |\n+                //    |             |      cannot infer type for `T`\n+                //    |             this method call resolves to `std::option::Option<&T>`\n+                //    |\n+                //    = note: type must be known at this point\n+                self.annotate_method_call(segment, e, &mut err);\n+            }\n+        } else if let Some(pattern) = local_visitor.found_arg_pattern {\n             // We don't want to show the default label for closures.\n             //\n             // So, before clearing, the output would look something like this:"}, {"sha": "017654554be16086ee9ac3373b49673277e8a95b", "filename": "src/test/ui/issues/issue-69455.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/2e2080dee60d2bad4eaed97e0a74de54f53226ba/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e2080dee60d2bad4eaed97e0a74de54f53226ba/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.rs?ref=2e2080dee60d2bad4eaed97e0a74de54f53226ba", "patch": "@@ -0,0 +1,30 @@\n+// Regression test for #69455: projection predicate was not satisfied.\n+// Compiler should indicate the correct location of the\n+// unsatisfied projection predicate\n+\n+pub trait Test<Rhs = Self> {\n+    type Output;\n+\n+    fn test(self, rhs: Rhs) -> Self::Output;\n+}\n+\n+impl Test<u32> for u64 {\n+    type Output = u64;\n+\n+    fn test(self, other: u32) -> u64 {\n+        self + (other as u64)\n+    }\n+}\n+\n+impl Test<u64> for u64 {\n+    type Output = u64;\n+\n+    fn test(self, other: u64) -> u64 {\n+        (self + other) as u64\n+    }\n+}\n+\n+fn main() {\n+    let xs: Vec<u64> = vec![1, 2, 3];\n+    println!(\"{}\", 23u64.test(xs.iter().sum())); //~ ERROR: type annotations needed [E0284]\n+}"}, {"sha": "4caa1aca9fd21535e7d8efebe6b74fb3698055f2", "filename": "src/test/ui/issues/issue-69455.stderr", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e2080dee60d2bad4eaed97e0a74de54f53226ba/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2e2080dee60d2bad4eaed97e0a74de54f53226ba/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-69455.stderr?ref=2e2080dee60d2bad4eaed97e0a74de54f53226ba", "patch": "@@ -0,0 +1,17 @@\n+error[E0284]: type annotations needed\n+  --> $DIR/issue-69455.rs:29:26\n+   |\n+LL |     type Output;\n+   |     ------------ `<Self as Test<Rhs>>::Output` defined here\n+...\n+LL |     println!(\"{}\", 23u64.test(xs.iter().sum()));\n+   |                    ------^^^^-----------------\n+   |                    |     |\n+   |                    |     cannot infer type for type `u64`\n+   |                    this method call resolves to `<Self as Test<Rhs>>::Output`\n+   |\n+   = note: cannot satisfy `<u64 as Test<_>>::Output == _`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}]}