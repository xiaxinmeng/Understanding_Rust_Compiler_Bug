{"sha": "29d6a8ecc6f43bac7171267993ef07dfdf528281", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI5ZDZhOGVjYzZmNDNiYWM3MTcxMjY3OTkzZWYwN2RmZGY1MjgyODE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T03:16:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-05T03:16:50Z"}, "message": "auto merge of #15425 : jbclements/rust/hygiene-for-3-kinds-of-args, r=cmr\n\nThis pull request adds hygiene for 3 kinds of argument bindings:\r\n- arguments to item fns,\r\n- arguments to `ExprFnBlock`s, and\r\n- arguments to `ExprProc`s\r\n\r\nIt also adds a bunch of unit tests, fixes a few macro uses to be non-capturing, and has a few cleanup items.\r\n\r\nlocal `make check` succeeds.", "tree": {"sha": "0257e896e9af3512f31e30519270bdeb22b545f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0257e896e9af3512f31e30519270bdeb22b545f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/29d6a8ecc6f43bac7171267993ef07dfdf528281", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/29d6a8ecc6f43bac7171267993ef07dfdf528281", "html_url": "https://github.com/rust-lang/rust/commit/29d6a8ecc6f43bac7171267993ef07dfdf528281", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/29d6a8ecc6f43bac7171267993ef07dfdf528281/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9f2a43c1b518a674ef4bb368732ee8dac3c1f779", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f2a43c1b518a674ef4bb368732ee8dac3c1f779", "html_url": "https://github.com/rust-lang/rust/commit/9f2a43c1b518a674ef4bb368732ee8dac3c1f779"}, {"sha": "cc13f9bae8b4175513375f9de66f198a706c67d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc13f9bae8b4175513375f9de66f198a706c67d3", "html_url": "https://github.com/rust-lang/rust/commit/cc13f9bae8b4175513375f9de66f198a706c67d3"}], "stats": {"total": 420, "additions": 297, "deletions": 123}, "files": [{"sha": "d3905582a365fd1a076c1333166673ba191edcc6", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=29d6a8ecc6f43bac7171267993ef07dfdf528281", "patch": "@@ -781,9 +781,9 @@ fn extract_vec_elems<'a>(\n // matches should fit that sort of pattern or NONE (however, some of the\n // matches may be wildcards like _ or identifiers).\n macro_rules! any_pat (\n-    ($m:expr, $pattern:pat) => (\n+    ($m:expr, $col:expr, $pattern:pat) => (\n         ($m).iter().any(|br| {\n-            match br.pats.get(col).node {\n+            match br.pats.get($col).node {\n                 $pattern => true,\n                 _ => false\n             }\n@@ -792,11 +792,11 @@ macro_rules! any_pat (\n )\n \n fn any_uniq_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, ast::PatBox(_))\n+    any_pat!(m, col, ast::PatBox(_))\n }\n \n fn any_region_pat(m: &[Match], col: uint) -> bool {\n-    any_pat!(m, ast::PatRegion(_))\n+    any_pat!(m, col, ast::PatRegion(_))\n }\n \n fn any_irrefutable_adt_pat(bcx: &Block, m: &[Match], col: uint) -> bool {"}, {"sha": "ca3eee01575fd3aca54bbddd85bb875925a0a69b", "filename": "src/libstd/io/extensions.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibstd%2Fio%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibstd%2Fio%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fextensions.rs?ref=29d6a8ecc6f43bac7171267993ef07dfdf528281", "patch": "@@ -508,14 +508,15 @@ mod bench {\n     use prelude::*;\n     use self::test::Bencher;\n \n+    // why is this a macro? wouldn't an inlined function work just as well?\n     macro_rules! u64_from_be_bytes_bench_impl(\n-        ($size:expr, $stride:expr, $start_index:expr) =>\n+        ($b:expr, $size:expr, $stride:expr, $start_index:expr) =>\n         ({\n             use super::u64_from_be_bytes;\n \n             let data = Vec::from_fn($stride*100+$start_index, |i| i as u8);\n             let mut sum = 0u64;\n-            b.iter(|| {\n+            $b.iter(|| {\n                 let mut i = $start_index;\n                 while i < data.len() {\n                     sum += u64_from_be_bytes(data.as_slice(), i, $size);\n@@ -527,31 +528,31 @@ mod bench {\n \n     #[bench]\n     fn u64_from_be_bytes_4_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(4, 4, 0);\n+        u64_from_be_bytes_bench_impl!(b, 4, 4, 0);\n     }\n \n     #[bench]\n     fn u64_from_be_bytes_4_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(4, 4, 1);\n+        u64_from_be_bytes_bench_impl!(b, 4, 4, 1);\n     }\n \n     #[bench]\n     fn u64_from_be_bytes_7_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(7, 8, 0);\n+        u64_from_be_bytes_bench_impl!(b, 7, 8, 0);\n     }\n \n     #[bench]\n     fn u64_from_be_bytes_7_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(7, 8, 1);\n+        u64_from_be_bytes_bench_impl!(b, 7, 8, 1);\n     }\n \n     #[bench]\n     fn u64_from_be_bytes_8_aligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(8, 8, 0);\n+        u64_from_be_bytes_bench_impl!(b, 8, 8, 0);\n     }\n \n     #[bench]\n     fn u64_from_be_bytes_8_unaligned(b: &mut Bencher) {\n-        u64_from_be_bytes_bench_impl!(8, 8, 1);\n+        u64_from_be_bytes_bench_impl!(b, 8, 8, 1);\n     }\n }"}, {"sha": "ce1302c8db8749b31e813d3f8a132fb118d492f7", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=29d6a8ecc6f43bac7171267993ef07dfdf528281", "patch": "@@ -190,6 +190,8 @@ pub struct TyParam {\n     pub span: Span\n }\n \n+/// Represents lifetimes and type parameters attached to a declaration\n+/// of a function, enum, trait, etc.\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Generics {\n     pub lifetimes: Vec<Lifetime>,\n@@ -288,7 +290,7 @@ pub enum Pat_ {\n     PatWild,\n     PatWildMulti,\n     // A PatIdent may either be a new bound variable,\n-    // or a nullary enum (in which case the second field\n+    // or a nullary enum (in which case the third field\n     // is None).\n     // In the nullary enum case, the parser can't determine\n     // which it is. The resolver determines this, and\n@@ -453,10 +455,10 @@ pub enum Expr_ {\n     ExprCast(Gc<Expr>, P<Ty>),\n     ExprIf(Gc<Expr>, P<Block>, Option<Gc<Expr>>),\n     ExprWhile(Gc<Expr>, P<Block>),\n-    // FIXME #6993: change to Option<Name>\n+    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprForLoop(Gc<Pat>, Gc<Expr>, P<Block>, Option<Ident>),\n     // Conditionless loop (can be exited with break, cont, or ret)\n-    // FIXME #6993: change to Option<Name>\n+    // FIXME #6993: change to Option<Name> ... or not, if these are hygienic.\n     ExprLoop(P<Block>, Option<Ident>),\n     ExprMatch(Gc<Expr>, Vec<Arm>),\n     ExprFnBlock(P<FnDecl>, P<Block>),\n@@ -468,9 +470,8 @@ pub enum Expr_ {\n     ExprField(Gc<Expr>, SpannedIdent, Vec<P<Ty>>),\n     ExprIndex(Gc<Expr>, Gc<Expr>),\n \n-    /// Expression that looks like a \"name\". For example,\n-    /// `std::slice::from_elem::<uint>` is an ExprPath that's the \"name\" part\n-    /// of a function call.\n+    /// Variable reference, possibly containing `::` and/or\n+    /// type parameters, e.g. foo::bar::<baz>\n     ExprPath(Path),\n \n     ExprAddrOf(Mutability, Gc<Expr>),\n@@ -643,6 +644,8 @@ pub struct TypeField {\n     pub span: Span,\n }\n \n+/// Represents a required method in a trait declaration,\n+/// one without a default implementation\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct TypeMethod {\n     pub ident: Ident,\n@@ -656,6 +659,8 @@ pub struct TypeMethod {\n     pub vis: Visibility,\n }\n \n+/// Represents a method declaration in a trait declaration, possibly\n+/// including a default implementation\n // A trait method is either required (meaning it doesn't have an\n // implementation, just a signature) or provided (meaning it has a default\n // implementation).\n@@ -741,6 +746,7 @@ impl fmt::Show for Onceness {\n     }\n }\n \n+/// Represents the type of a closure\n #[deriving(PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct ClosureTy {\n     pub lifetimes: Vec<Lifetime>,\n@@ -809,6 +815,7 @@ pub struct InlineAsm {\n     pub dialect: AsmDialect\n }\n \n+/// represents an argument in a function header\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct Arg {\n     pub ty: P<Ty>,\n@@ -836,7 +843,7 @@ impl Arg {\n     }\n }\n \n-// represents the header (not the body) of a function declaration\n+/// represents the header (not the body) of a function declaration\n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]\n pub struct FnDecl {\n     pub inputs: Vec<Arg>,\n@@ -1107,6 +1114,7 @@ pub enum Item_ {\n     ItemTy(P<Ty>, Generics),\n     ItemEnum(EnumDef, Generics),\n     ItemStruct(Gc<StructDef>, Generics),\n+    /// Represents a Trait Declaration\n     ItemTrait(Generics, Sized, Vec<TraitRef> , Vec<TraitMethod> ),\n     ItemImpl(Generics,\n              Option<TraitRef>, // (optional) trait this impl implements"}, {"sha": "cf69277594fd5380631d8f9239a9df34ca0fb414", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=29d6a8ecc6f43bac7171267993ef07dfdf528281", "patch": "@@ -19,6 +19,7 @@ use parse::parser;\n use parse::token;\n use parse::token::{InternedString, intern, str_to_ident};\n use util::small_vector::SmallVector;\n+use ext::mtwt;\n \n use std::collections::HashMap;\n use std::gc::{Gc, GC};\n@@ -273,7 +274,7 @@ pub struct BlockInfo {\n     // should macros escape from this scope?\n     pub macros_escape: bool,\n     // what are the pending renames?\n-    pub pending_renames: RenameList,\n+    pub pending_renames: mtwt::RenameList,\n }\n \n impl BlockInfo {\n@@ -285,9 +286,6 @@ impl BlockInfo {\n     }\n }\n \n-// a list of ident->name renamings\n-pub type RenameList = Vec<(ast::Ident, Name)>;\n-\n // The base map of methods for expanding syntax extension\n // AST nodes into full ASTs\n pub fn syntax_expander_table() -> SyntaxEnv {"}, {"sha": "b30b62c8901d4059d183ff39e31bce03b2b37be6", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 214, "deletions": 69, "changes": 283, "blob_url": "https://github.com/rust-lang/rust/blob/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=29d6a8ecc6f43bac7171267993ef07dfdf528281", "patch": "@@ -21,6 +21,7 @@ use codemap;\n use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n use crateid::CrateId;\n use ext::base::*;\n+use fold;\n use fold::*;\n use parse;\n use parse::token::{fresh_mark, fresh_name, intern};\n@@ -228,6 +229,20 @@ pub fn expand_expr(e: Gc<ast::Expr>, fld: &mut MacroExpander) -> Gc<ast::Expr> {\n             fld.cx.expr(e.span, ast::ExprLoop(loop_block, opt_ident))\n         }\n \n+        ast::ExprFnBlock(fn_decl, block) => {\n+            let (rewritten_fn_decl, rewritten_block)\n+                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n+            let new_node = ast::ExprFnBlock(rewritten_fn_decl, rewritten_block);\n+            box(GC) ast::Expr{id:e.id, node: new_node, span: fld.new_span(e.span)}\n+        }\n+\n+        ast::ExprProc(fn_decl, block) => {\n+            let (rewritten_fn_decl, rewritten_block)\n+                = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n+            let new_node = ast::ExprProc(rewritten_fn_decl, rewritten_block);\n+            box(GC) ast::Expr{id:e.id, node: new_node, span: fld.new_span(e.span)}\n+        }\n+\n         _ => noop_fold_expr(e, fld)\n     }\n }\n@@ -267,7 +282,8 @@ fn expand_loop_block(loop_block: P<Block>,\n     }\n }\n \n-// eval $e with a new exts frame:\n+// eval $e with a new exts frame.\n+// must be a macro so that $e isn't evaluated too early.\n macro_rules! with_exts_frame (\n     ($extsboxexpr:expr,$macros_escape:expr,$e:expr) =>\n     ({$extsboxexpr.push_frame();\n@@ -342,15 +358,16 @@ fn expand_item(it: Gc<ast::Item>, fld: &mut MacroExpander)\n \n fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n                          -> Gc<ast::Item> {\n-    let (modifiers, attrs) = it.attrs.partitioned(|attr| {\n+    // partition the attributes into ItemModifiers and others\n+    let (modifiers, other_attrs) = it.attrs.partitioned(|attr| {\n         match fld.extsbox.find(&intern(attr.name().get())) {\n             Some(&ItemModifier(_)) => true,\n             _ => false\n         }\n     });\n-\n+    // update the attrs, leave everything else alone. Is this mutation really a good idea?\n     it = box(GC) ast::Item {\n-        attrs: attrs,\n+        attrs: other_attrs,\n         ..(*it).clone()\n     };\n \n@@ -383,6 +400,19 @@ fn expand_item_modifiers(mut it: Gc<ast::Item>, fld: &mut MacroExpander)\n     expand_item_modifiers(it, fld)\n }\n \n+/// Expand item_underscore\n+fn expand_item_underscore(item: &ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n+    match *item {\n+        ast::ItemFn(decl, fn_style, abi, ref generics, body) => {\n+            let (rewritten_fn_decl, rewritten_body)\n+                = expand_and_rename_fn_decl_and_block(decl,body,fld);\n+            let expanded_generics = fold::fold_generics(generics,fld);\n+            ast::ItemFn(rewritten_fn_decl, fn_style, abi, expanded_generics, rewritten_body)\n+        }\n+        _ => noop_fold_item_underscore(&*item, fld)\n+    }\n+}\n+\n // does this attribute list contain \"macro_escape\" ?\n fn contains_macro_escape(attrs: &[ast::Attribute]) -> bool {\n     attr::contains_name(attrs, \"macro_escape\")\n@@ -609,7 +639,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n                     } = **local;\n                     // expand the pat (it might contain macro uses):\n                     let expanded_pat = fld.fold_pat(pat);\n-                    // find the pat_idents in the pattern:\n+                    // find the PatIdents in the pattern:\n                     // oh dear heaven... this is going to include the enum\n                     // names, as well... but that should be okay, as long as\n                     // the new names are gensyms for the old ones.\n@@ -653,6 +683,7 @@ fn expand_non_macro_stmt(s: &Stmt, fld: &mut MacroExpander)\n     }\n }\n \n+// expand the arm of a 'match', renaming for macro hygiene\n fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // expand pats... they might contain macro uses:\n     let expanded_pats : Vec<Gc<ast::Pat>> = arm.pats.iter().map(|pat| fld.fold_pat(*pat)).collect();\n@@ -662,22 +693,15 @@ fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     // all of the pats must have the same set of bindings, so use the\n     // first one to extract them and generate new names:\n     let first_pat = expanded_pats.get(0);\n-    // code duplicated from 'let', above. Perhaps this can be lifted\n-    // into a separate function:\n     let idents = pattern_bindings(*first_pat);\n-    let mut new_pending_renames =\n+    let new_renames =\n         idents.iter().map(|id| (*id,fresh_name(id))).collect();\n-    // rewrite all of the patterns using the new names (the old\n-    // ones have already been applied). Note that we depend here\n-    // on the guarantee that after expansion, there can't be any\n-    // Path expressions (a.k.a. varrefs) left in the pattern. If\n-    // this were false, we'd need to apply this renaming only to\n-    // the bindings, and not to the varrefs, using a more targeted\n-    // fold-er.\n-    let mut rename_fld = IdentRenamer{renames:&mut new_pending_renames};\n+    // apply the renaming, but only to the PatIdents:\n+    let mut rename_pats_fld = PatIdentRenamer{renames:&new_renames};\n     let rewritten_pats =\n-        expanded_pats.iter().map(|pat| rename_fld.fold_pat(*pat)).collect();\n+        expanded_pats.iter().map(|pat| rename_pats_fld.fold_pat(*pat)).collect();\n     // apply renaming and then expansion to the guard and the body:\n+    let mut rename_fld = IdentRenamer{renames:&new_renames};\n     let rewritten_guard =\n         arm.guard.map(|g| fld.fold_expr(rename_fld.fold_expr(g)));\n     let rewritten_body = fld.fold_expr(rename_fld.fold_expr(arm.body));\n@@ -689,45 +713,47 @@ fn expand_arm(arm: &ast::Arm, fld: &mut MacroExpander) -> ast::Arm {\n     }\n }\n \n-\n-\n-// a visitor that extracts the pat_ident (binding) paths\n-// from a given thingy and puts them in a mutable\n-// array\n+/// A visitor that extracts the PatIdent (binding) paths\n+/// from a given thingy and puts them in a mutable\n+/// array\n #[deriving(Clone)]\n-struct NameFinderContext {\n+struct PatIdentFinder {\n     ident_accumulator: Vec<ast::Ident> ,\n }\n \n-impl Visitor<()> for NameFinderContext {\n+impl Visitor<()> for PatIdentFinder {\n     fn visit_pat(&mut self, pattern: &ast::Pat, _: ()) {\n         match *pattern {\n-            // we found a pat_ident!\n-            ast::Pat {\n-                id: _,\n-                node: ast::PatIdent(_, ref path1, ref inner),\n-                span: _\n-            } => {\n+            ast::Pat { id: _, node: ast::PatIdent(_, ref path1, ref inner), span: _ } => {\n                 self.ident_accumulator.push(path1.node);\n-                // visit optional subpattern of pat_ident:\n+                // visit optional subpattern of PatIdent:\n                 for subpat in inner.iter() {\n                     self.visit_pat(&**subpat, ())\n                 }\n             }\n-            // use the default traversal for non-pat_idents\n+            // use the default traversal for non-PatIdents\n             _ => visit::walk_pat(self, pattern, ())\n         }\n     }\n \n }\n \n-// find the pat_ident paths in a pattern\n+/// find the PatIdent paths in a pattern\n fn pattern_bindings(pat : &ast::Pat) -> Vec<ast::Ident> {\n-    let mut name_finder = NameFinderContext{ident_accumulator:Vec::new()};\n+    let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n     name_finder.visit_pat(pat,());\n     name_finder.ident_accumulator\n }\n \n+/// find the PatIdent paths in a\n+fn fn_decl_arg_bindings(fn_decl: &ast::FnDecl) -> Vec<ast::Ident> {\n+    let mut pat_idents = PatIdentFinder{ident_accumulator:Vec::new()};\n+    for arg in fn_decl.inputs.iter() {\n+        pat_idents.visit_pat(arg.pat,());\n+    }\n+    pat_idents.ident_accumulator\n+}\n+\n // expand a block. pushes a new exts_frame, then calls expand_block_elts\n fn expand_block(blk: &Block, fld: &mut MacroExpander) -> P<Block> {\n     // see note below about treatment of exts table\n@@ -844,34 +870,71 @@ fn expand_pat(p: Gc<ast::Pat>, fld: &mut MacroExpander) -> Gc<ast::Pat> {\n     }\n }\n \n-// a tree-folder that applies every rename in its (mutable) list\n-// to every identifier, including both bindings and varrefs\n-// (and lots of things that will turn out to be neither)\n+/// A tree-folder that applies every rename in its (mutable) list\n+/// to every identifier, including both bindings and varrefs\n+/// (and lots of things that will turn out to be neither)\n pub struct IdentRenamer<'a> {\n-    renames: &'a mut RenameList,\n+    renames: &'a mtwt::RenameList,\n }\n \n impl<'a> Folder for IdentRenamer<'a> {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n-        let new_ctxt = self.renames.iter().fold(id.ctxt, |ctxt, &(from, to)| {\n-            mtwt::new_rename(from, to, ctxt)\n-        });\n         Ident {\n             name: id.name,\n-            ctxt: new_ctxt,\n+            ctxt: mtwt::apply_renames(self.renames, id.ctxt),\n         }\n     }\n }\n \n-fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n-    /* this discards information in the case of macro-defining macros */\n-    Span {\n-        lo: sp.lo,\n-        hi: sp.hi,\n-        expn_info: cx.backtrace(),\n+/// A tree-folder that applies every rename in its list to\n+/// the idents that are in PatIdent patterns. This is more narrowly\n+/// focused than IdentRenamer, and is needed for FnDecl,\n+/// where we want to rename the args but not the fn name or the generics etc.\n+pub struct PatIdentRenamer<'a> {\n+    renames: &'a mtwt::RenameList,\n+}\n+\n+impl<'a> Folder for PatIdentRenamer<'a> {\n+    fn fold_pat(&mut self, pat: Gc<ast::Pat>) -> Gc<ast::Pat> {\n+        match pat.node {\n+            ast::PatIdent(binding_mode, Spanned{span: ref sp, node: id}, ref sub) => {\n+                let new_ident = Ident{name: id.name,\n+                                      ctxt: mtwt::apply_renames(self.renames, id.ctxt)};\n+                let new_node =\n+                    ast::PatIdent(binding_mode,\n+                                  Spanned{span: self.new_span(*sp), node: new_ident},\n+                                  sub.map(|p| self.fold_pat(p)));\n+                box(GC) ast::Pat {\n+                    id: pat.id,\n+                    span: self.new_span(pat.span),\n+                    node: new_node,\n+                }\n+            },\n+            _ => noop_fold_pat(pat, self)\n+        }\n     }\n }\n \n+/// Given a fn_decl and a block and a MacroExpander, expand the fn_decl, then use the\n+/// PatIdents in its arguments to perform renaming in the FnDecl and\n+/// the block, returning both the new FnDecl and the new Block.\n+fn expand_and_rename_fn_decl_and_block(fn_decl: &ast::FnDecl, block: Gc<ast::Block>,\n+                                       fld: &mut MacroExpander)\n+    -> (Gc<ast::FnDecl>, Gc<ast::Block>) {\n+    let expanded_decl = fld.fold_fn_decl(fn_decl);\n+    let idents = fn_decl_arg_bindings(expanded_decl);\n+    let renames =\n+        idents.iter().map(|id : &ast::Ident| (*id,fresh_name(id))).collect();\n+    // first, a renamer for the PatIdents, for the fn_decl:\n+    let mut rename_pat_fld = PatIdentRenamer{renames: &renames};\n+    let rewritten_fn_decl = rename_pat_fld.fold_fn_decl(expanded_decl);\n+    // now, a renamer for *all* idents, for the body:\n+    let mut rename_fld = IdentRenamer{renames: &renames};\n+    let rewritten_body = fld.fold_block(rename_fld.fold_block(block));\n+    (rewritten_fn_decl,rewritten_body)\n+}\n+\n+/// A tree-folder that performs macro expansion\n pub struct MacroExpander<'a, 'b> {\n     pub extsbox: SyntaxEnv,\n     pub cx: &'a mut ExtCtxt<'b>,\n@@ -890,6 +953,10 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n         expand_item(item, self)\n     }\n \n+    fn fold_item_underscore(&mut self, item: &ast::Item_) -> ast::Item_ {\n+        expand_item_underscore(item, self)\n+    }\n+\n     fn fold_stmt(&mut self, stmt: &ast::Stmt) -> SmallVector<Gc<ast::Stmt>> {\n         expand_stmt(stmt, self)\n     }\n@@ -907,6 +974,15 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n }\n \n+fn new_span(cx: &ExtCtxt, sp: Span) -> Span {\n+    /* this discards information in the case of macro-defining macros */\n+    Span {\n+        lo: sp.lo,\n+        hi: sp.hi,\n+        expn_info: cx.backtrace(),\n+    }\n+}\n+\n pub struct ExpansionConfig {\n     pub deriving_hash_type_parameter: bool,\n     pub crate_id: CrateId,\n@@ -966,15 +1042,15 @@ impl Folder for Marker {\n     fn fold_ident(&mut self, id: Ident) -> Ident {\n         ast::Ident {\n             name: id.name,\n-            ctxt: mtwt::new_mark(self.mark, id.ctxt)\n+            ctxt: mtwt::apply_mark(self.mark, id.ctxt)\n         }\n     }\n     fn fold_mac(&mut self, m: &ast::Mac) -> ast::Mac {\n         let macro = match m.node {\n             MacInvocTT(ref path, ref tts, ctxt) => {\n                 MacInvocTT(self.fold_path(path),\n                            fold_tts(tts.as_slice(), self),\n-                           mtwt::new_mark(self.mark, ctxt))\n+                           mtwt::apply_mark(self.mark, ctxt))\n             }\n         };\n         Spanned {\n@@ -1028,13 +1104,14 @@ fn original_span(cx: &ExtCtxt) -> Gc<codemap::ExpnInfo> {\n #[cfg(test)]\n mod test {\n     use super::{pattern_bindings, expand_crate, contains_macro_escape};\n-    use super::{NameFinderContext};\n+    use super::{PatIdentFinder, IdentRenamer, PatIdentRenamer};\n     use ast;\n     use ast::{Attribute_, AttrOuter, MetaWord};\n     use attr;\n     use codemap;\n     use codemap::Spanned;\n     use ext::mtwt;\n+    use fold::Folder;\n     use parse;\n     use parse::token;\n     use util::parser_testing::{string_to_parser};\n@@ -1072,7 +1149,24 @@ mod test {\n         path_finder.path_accumulator\n     }\n \n+    /// A Visitor that extracts the identifiers from a thingy.\n+    // as a side note, I'm starting to want to abstract over these....\n+    struct IdentFinder{\n+        ident_accumulator: Vec<ast::Ident>\n+    }\n+\n+    impl Visitor<()> for IdentFinder {\n+        fn visit_ident(&mut self, _: codemap::Span, id: ast::Ident, _: ()){\n+            self.ident_accumulator.push(id);\n+        }\n+    }\n \n+    /// Find the idents in a crate\n+    fn crate_idents(the_crate: &ast::Crate) -> Vec<ast::Ident> {\n+        let mut ident_finder = IdentFinder{ident_accumulator: Vec::new()};\n+        visit::walk_crate(&mut ident_finder, the_crate, ());\n+        ident_finder.ident_accumulator\n+    }\n \n     // these following tests are quite fragile, in that they don't test what\n     // *kind* of failure occurs.\n@@ -1167,12 +1261,11 @@ mod test {\n \n     // find the pat_ident paths in a crate\n     fn crate_bindings(the_crate : &ast::Crate) -> Vec<ast::Ident> {\n-        let mut name_finder = NameFinderContext{ident_accumulator:Vec::new()};\n+        let mut name_finder = PatIdentFinder{ident_accumulator:Vec::new()};\n         visit::walk_crate(&mut name_finder, the_crate, ());\n         name_finder.ident_accumulator\n     }\n \n-\n     //fn expand_and_resolve(crate_str: @str) -> ast::crate {\n         //let expanded_ast = expand_crate_str(crate_str);\n         // println!(\"expanded: {:?}\\n\",expanded_ast);\n@@ -1298,18 +1391,37 @@ mod test {\n     // but *shouldn't* bind because it was inserted by a different macro....\n     // can't write this test case until we have macro-generating macros.\n \n-    // FIXME #9383 : lambda var hygiene\n-    // interesting... can't even write this test, yet, because the name-finder\n-    // only finds pattern vars. Time to upgrade test framework.\n-    /*#[test]\n-    fn issue_9383(){\n+    // item fn hygiene\n+    // expands to fn q(x_1:int){fn g(x_2:int){x_2 + x_1};}\n+    #[test] fn issue_9383(){\n         run_renaming_test(\n-            &(\"macro_rules! bad_macro (($ex:expr) => ({(|_x| { $ex }) (9) }))\n-              fn takes_x(_x : int) { assert_eq!(bad_macro!(_x),8); }\n-              fn main() { takes_x(8); }\",\n-              vec!(vec!()),false),\n+            &(\"macro_rules! bad_macro (($ex:expr) => (fn g(x:int){ x + $ex }))\n+              fn q(x:int) { bad_macro!(x); }\",\n+              vec!(vec!(1),vec!(0)),true),\n             0)\n-    }*/\n+    }\n+\n+    // closure arg hygiene (ExprFnBlock)\n+    // expands to fn f(){(|x_1 : int| {(x_2 + x_1)})(3);}\n+    #[test] fn closure_arg_hygiene(){\n+        run_renaming_test(\n+            &(\"macro_rules! inject_x (()=>(x))\n+            fn f(){(|x : int| {(inject_x!() + x)})(3);}\",\n+              vec!(vec!(1)),\n+              true),\n+            0)\n+    }\n+\n+    // closure arg hygiene (ExprProc)\n+    // expands to fn f(){(proc(x_1 : int) {(x_2 + x_1)})(3);}\n+    #[test] fn closure_arg_hygiene_2(){\n+        run_renaming_test(\n+            &(\"macro_rules! inject_x (()=>(x))\n+              fn f(){ (proc(x : int){(inject_x!() + x)})(3); }\",\n+              vec!(vec!(1)),\n+              true),\n+            0)\n+    }\n \n     // run one of the renaming tests\n     fn run_renaming_test(t: &RenamingTest, test_idx: uint) {\n@@ -1359,9 +1471,9 @@ mod test {\n                         assert_eq!(varref_marks,binding_marks.clone());\n                     }\n                 } else {\n+                    let varref_name = mtwt::resolve(varref.segments.get(0).identifier);\n                     let fail = (varref.segments.len() == 1)\n-                        && (mtwt::resolve(varref.segments.get(0).identifier)\n-                            == binding_name);\n+                        && (varref_name == binding_name);\n                     // temp debugging:\n                     if fail {\n                         let varref_idents : Vec<ast::Ident>\n@@ -1372,15 +1484,18 @@ mod test {\n                         println!(\"text of test case: \\\"{}\\\"\", teststr);\n                         println!(\"\");\n                         println!(\"uh oh, matches but shouldn't:\");\n-                        println!(\"varref: {}\",varref_idents);\n+                        println!(\"varref #{}: {}, resolves to {}\",idx, varref_idents,\n+                                 varref_name);\n                         // good lord, you can't make a path with 0 segments, can you?\n                         let string = token::get_ident(varref.segments\n                                                             .get(0)\n                                                             .identifier);\n                         println!(\"varref's first segment's uint: {}, and string: \\\"{}\\\"\",\n                                  varref.segments.get(0).identifier.name,\n                                  string.get());\n-                        println!(\"binding: {}\", *bindings.get(binding_idx));\n+                        println!(\"binding #{}: {}, resolves to {}\",\n+                                 binding_idx, *bindings.get(binding_idx),\n+                                 binding_name);\n                         mtwt::with_sctable(|x| mtwt::display_sctable(x));\n                     }\n                     assert!(!fail);\n@@ -1443,13 +1558,43 @@ foo_module!()\n     // 'None' is listed as an identifier pattern because we don't yet know that\n     // it's the name of a 0-ary variant, and that 'i' appears twice in succession.\n     #[test]\n-    fn crate_idents(){\n+    fn crate_bindings_test(){\n         let the_crate = string_to_crate(\"fn main (a : int) -> int {|b| {\n         match 34 {None => 3, Some(i) | i => j, Foo{k:z,l:y} => \\\"banana\\\"}} }\".to_string());\n         let idents = crate_bindings(&the_crate);\n         assert_eq!(idents, strs_to_idents(vec!(\"a\",\"b\",\"None\",\"i\",\"i\",\"z\",\"y\")));\n     }\n \n-    //\n+    // test the IdentRenamer directly\n+    #[test]\n+    fn ident_renamer_test () {\n+        let the_crate = string_to_crate(\"fn f(x : int){let x = x; x}\".to_string());\n+        let f_ident = token::str_to_ident(\"f\");\n+        let x_ident = token::str_to_ident(\"x\");\n+        let int_ident = token::str_to_ident(\"int\");\n+        let renames = vec!((x_ident,16));\n+        let mut renamer = IdentRenamer{renames: &renames};\n+        let renamed_crate = renamer.fold_crate(the_crate);\n+        let idents = crate_idents(&renamed_crate);\n+        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n+        assert_eq!(resolved,vec!(f_ident.name,16,int_ident.name,16,16,16));\n+    }\n+\n+    // test the PatIdentRenamer; only PatIdents get renamed\n+    #[test]\n+    fn pat_ident_renamer_test () {\n+        let the_crate = string_to_crate(\"fn f(x : int){let x = x; x}\".to_string());\n+        let f_ident = token::str_to_ident(\"f\");\n+        let x_ident = token::str_to_ident(\"x\");\n+        let int_ident = token::str_to_ident(\"int\");\n+        let renames = vec!((x_ident,16));\n+        let mut renamer = PatIdentRenamer{renames: &renames};\n+        let renamed_crate = renamer.fold_crate(the_crate);\n+        let idents = crate_idents(&renamed_crate);\n+        let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n+        let x_name = x_ident.name;\n+        assert_eq!(resolved,vec!(f_ident.name,16,int_ident.name,16,x_name,x_name));\n+    }\n+\n \n }"}, {"sha": "18466e381a58ba2d5d4baa0984037ae35da5ae60", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 51, "deletions": 29, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=29d6a8ecc6f43bac7171267993ef07dfdf528281", "patch": "@@ -54,38 +54,51 @@ pub enum SyntaxContext_ {\n     IllegalCtxt\n }\n \n+/// A list of ident->name renamings\n+pub type RenameList = Vec<(Ident, Name)>;\n+\n /// Extend a syntax context with a given mark\n-pub fn new_mark(m: Mrk, tail: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| new_mark_internal(m, tail, table))\n+pub fn apply_mark(m: Mrk, ctxt: SyntaxContext) -> SyntaxContext {\n+    with_sctable(|table| apply_mark_internal(m, ctxt, table))\n }\n \n-// Extend a syntax context with a given mark and table\n-fn new_mark_internal(m: Mrk, tail: SyntaxContext, table: &SCTable) -> SyntaxContext {\n-    let key = (tail, m);\n+// Extend a syntax context with a given mark and sctable (explicit memoization)\n+fn apply_mark_internal(m: Mrk, ctxt: SyntaxContext, table: &SCTable) -> SyntaxContext {\n+    let key = (ctxt, m);\n     let new_ctxt = |_: &(SyntaxContext, Mrk)|\n-                   idx_push(&mut *table.table.borrow_mut(), Mark(m, tail));\n+                   idx_push(&mut *table.table.borrow_mut(), Mark(m, ctxt));\n \n     *table.mark_memo.borrow_mut().find_or_insert_with(key, new_ctxt)\n }\n \n /// Extend a syntax context with a given rename\n-pub fn new_rename(id: Ident, to:Name,\n-                  tail: SyntaxContext) -> SyntaxContext {\n-    with_sctable(|table| new_rename_internal(id, to, tail, table))\n+pub fn apply_rename(id: Ident, to:Name,\n+                  ctxt: SyntaxContext) -> SyntaxContext {\n+    with_sctable(|table| apply_rename_internal(id, to, ctxt, table))\n }\n \n-// Extend a syntax context with a given rename and sctable\n-fn new_rename_internal(id: Ident,\n+// Extend a syntax context with a given rename and sctable (explicit memoization)\n+fn apply_rename_internal(id: Ident,\n                        to: Name,\n-                       tail: SyntaxContext,\n+                       ctxt: SyntaxContext,\n                        table: &SCTable) -> SyntaxContext {\n-    let key = (tail,id,to);\n+    let key = (ctxt,id,to);\n     let new_ctxt = |_: &(SyntaxContext, Ident, Mrk)|\n-                   idx_push(&mut *table.table.borrow_mut(), Rename(id, to, tail));\n+                   idx_push(&mut *table.table.borrow_mut(), Rename(id, to, ctxt));\n \n     *table.rename_memo.borrow_mut().find_or_insert_with(key, new_ctxt)\n }\n \n+/// Apply a list of renamings to a context\n+// if these rename lists get long, it would make sense\n+// to consider memoizing this fold. This may come up\n+// when we add hygiene to item names.\n+pub fn apply_renames(renames: &RenameList, ctxt: SyntaxContext) -> SyntaxContext {\n+    renames.iter().fold(ctxt, |ctxt, &(from, to)| {\n+        apply_rename(from, to, ctxt)\n+    })\n+}\n+\n /// Fetch the SCTable from TLS, create one if it doesn't yet exist.\n pub fn with_sctable<T>(op: |&SCTable| -> T) -> T {\n     local_data_key!(sctable_key: Rc<SCTable>)\n@@ -263,9 +276,9 @@ fn xor_push(marks: &mut Vec<Mrk>, mark: Mrk) {\n \n #[cfg(test)]\n mod tests {\n-    use ast::*;\n-    use super::{resolve, xor_push, new_mark_internal, new_sctable_internal};\n-    use super::{new_rename_internal, marksof_internal, resolve_internal};\n+    use ast::{EMPTY_CTXT, Ident, Mrk, Name, SyntaxContext};\n+    use super::{resolve, xor_push, apply_mark_internal, new_sctable_internal};\n+    use super::{apply_rename_internal, apply_renames, marksof_internal, resolve_internal};\n     use super::{SCTable, EmptyCtxt, Mark, Rename, IllegalCtxt};\n     use std::collections::HashMap;\n \n@@ -306,8 +319,8 @@ mod tests {\n         -> SyntaxContext {\n         tscs.iter().rev().fold(tail, |tail : SyntaxContext, tsc : &TestSC|\n                   {match *tsc {\n-                      M(mrk) => new_mark_internal(mrk,tail,table),\n-                      R(ident,name) => new_rename_internal(ident,name,tail,table)}})\n+                      M(mrk) => apply_mark_internal(mrk,tail,table),\n+                      R(ident,name) => apply_rename_internal(ident,name,tail,table)}})\n     }\n \n     // gather a SyntaxContext back into a vector of TestSCs\n@@ -352,7 +365,7 @@ mod tests {\n     fn unfold_marks(mrks: Vec<Mrk> , tail: SyntaxContext, table: &SCTable)\n                     -> SyntaxContext {\n         mrks.iter().rev().fold(tail, |tail:SyntaxContext, mrk:&Mrk|\n-                   {new_mark_internal(*mrk,tail,table)})\n+                   {apply_mark_internal(*mrk,tail,table)})\n     }\n \n     #[test] fn unfold_marks_test() {\n@@ -384,13 +397,13 @@ mod tests {\n         // rename where stop doesn't match:\n         { let chain = vec!(M(9),\n                         R(id(name1,\n-                             new_mark_internal (4, EMPTY_CTXT,&mut t)),\n+                             apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           100101102),\n                         M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n          assert_eq! (marksof_internal (ans, stopname, &t), vec!(9,14));}\n         // rename where stop does match\n-        { let name1sc = new_mark_internal(4, EMPTY_CTXT, &mut t);\n+        { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = vec!(M(9),\n                        R(id(name1, name1sc),\n                          stopname),\n@@ -414,7 +427,7 @@ mod tests {\n         { let sc = unfold_test_sc(vec!(R(id(50,EMPTY_CTXT),51),M(12)),EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),a);}\n         // - rename where names do match, but marks don't\n-        { let sc1 = new_mark_internal(1,EMPTY_CTXT,&mut t);\n+        { let sc1 = apply_mark_internal(1,EMPTY_CTXT,&mut t);\n          let sc = unfold_test_sc(vec!(R(id(a,sc1),50),\n                                    M(1),\n                                    M(2)),\n@@ -437,11 +450,11 @@ mod tests {\n                                   EMPTY_CTXT,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt), 51); }\n         // the simplest double-rename:\n-        { let a_to_a50 = new_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n-         let a50_to_a51 = new_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n+        { let a_to_a50 = apply_rename_internal(id(a,EMPTY_CTXT),50,EMPTY_CTXT,&mut t);\n+         let a50_to_a51 = apply_rename_internal(id(a,a_to_a50),51,a_to_a50,&mut t);\n          assert_eq!(resolve_internal(id(a,a50_to_a51),&mut t, &mut rt),51);\n          // mark on the outside doesn't stop rename:\n-         let sc = new_mark_internal(9,a50_to_a51,&mut t);\n+         let sc = apply_mark_internal(9,a50_to_a51,&mut t);\n          assert_eq!(resolve_internal(id(a,sc),&mut t, &mut rt),51);\n          // but mark on the inside does:\n          let a50_to_a51_b = unfold_test_sc(vec!(R(id(a,a_to_a50),51),\n@@ -461,10 +474,10 @@ mod tests {\n     #[test]\n     fn hashing_tests () {\n         let mut t = new_sctable_internal();\n-        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n-        assert_eq!(new_mark_internal(13,EMPTY_CTXT,&mut t),3);\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        assert_eq!(apply_mark_internal(13,EMPTY_CTXT,&mut t),3);\n         // using the same one again should result in the same index:\n-        assert_eq!(new_mark_internal(12,EMPTY_CTXT,&mut t),2);\n+        assert_eq!(apply_mark_internal(12,EMPTY_CTXT,&mut t),2);\n         // I'm assuming that the rename table will behave the same....\n     }\n \n@@ -480,4 +493,13 @@ mod tests {\n         resolve_internal(id(30,EMPTY_CTXT),&mut t, &mut rt);\n         assert_eq!(rt.len(),2);\n     }\n+\n+    #[test]\n+    fn new_resolves_test() {\n+        let renames = vec!((Ident{name:23,ctxt:EMPTY_CTXT},24),\n+                           (Ident{name:29,ctxt:EMPTY_CTXT},29));\n+        let new_ctxt1 = apply_renames(&renames,EMPTY_CTXT);\n+        assert_eq!(resolve(Ident{name:23,ctxt:new_ctxt1}),24);\n+        assert_eq!(resolve(Ident{name:29,ctxt:new_ctxt1}),29);\n+    }\n }"}, {"sha": "04e6612daf1f008a7dcf3a7f4526fb23875dd2f9", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=29d6a8ecc6f43bac7171267993ef07dfdf528281", "patch": "@@ -794,7 +794,7 @@ pub fn noop_fold_pat<T: Folder>(p: Gc<Pat>, folder: &mut T) -> Gc<Pat> {\n         PatIdent(binding_mode, ref pth1, ref sub) => {\n             PatIdent(binding_mode,\n                      Spanned{span: folder.new_span(pth1.span),\n-                                       node: folder.fold_ident(pth1.node)},\n+                             node: folder.fold_ident(pth1.node)},\n                      sub.map(|x| folder.fold_pat(x)))\n         }\n         PatLit(e) => PatLit(folder.fold_expr(e)),"}, {"sha": "dcf37e37ff0a786f0bc40882052ec6efac5bf7d9", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/29d6a8ecc6f43bac7171267993ef07dfdf528281/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=29d6a8ecc6f43bac7171267993ef07dfdf528281", "patch": "@@ -765,7 +765,7 @@ mod test {\n     use ext::mtwt;\n \n     fn mark_ident(id : ast::Ident, m : ast::Mrk) -> ast::Ident {\n-        ast::Ident{name:id.name,ctxt:mtwt::new_mark(m,id.ctxt)}\n+        ast::Ident{name:id.name,ctxt:mtwt::apply_mark(m,id.ctxt)}\n     }\n \n     #[test] fn mtwt_token_eq_test() {"}]}