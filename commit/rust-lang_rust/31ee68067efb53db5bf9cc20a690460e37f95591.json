{"sha": "31ee68067efb53db5bf9cc20a690460e37f95591", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMxZWU2ODA2N2VmYjUzZGI1YmY5Y2MyMGE2OTA0NjBlMzdmOTU1OTE=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-06-17T12:56:41Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-06-17T12:56:41Z"}, "message": "Rollup merge of #85802 - Thomasdezeeuw:ioslice-advance, r=m-ou-se\n\nRename IoSlice(Mut)::advance to advance_slice and add IoSlice(Mut)::advance\n\nAlso changes the signature of `advance_slice` to accept a `&mut &mut [IoSlice]`, not returning anything. This will better match the `IoSlice::advance` function.\n\nUpdates https://github.com/rust-lang/rust/issues/62726.", "tree": {"sha": "808744cd32de627c62672aac044b32a3ba495ea8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/808744cd32de627c62672aac044b32a3ba495ea8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/31ee68067efb53db5bf9cc20a690460e37f95591", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgy0aJCRBK7hj4Ov3rIwAAOHYIAAPbcF/H3MMFzwO/yS8YVCTD\nx/YrDdGtskCSd3snAVbfAYm0sSEUGhFCkyXFcuBSFURsiABIdJXgITwOWzUTyC1E\nxnay4es55iQjpslXsT5oIwZK+dT5QV3MT0IOLqewIB908BMq7RNcaP6gQZgXJCeG\n50OFf6wNgT0m6qgwvp7xWEnbAcPCKp8rsUd0RoJaaHoXLvuNJYTeWLI6G1P60mR3\nppXGu/I56JxtMEGf0wypwLbUMrbkfI+z5Qq4ZUijeh7c3Ko8ajCEuVGSTSJv+JJQ\nogoucnE9mCIrinF4lQfIQJlAheSHkQF1B9nMRzcKit4/mMqoV2GhP1iQrsizAaM=\n=YCmY\n-----END PGP SIGNATURE-----\n", "payload": "tree 808744cd32de627c62672aac044b32a3ba495ea8\nparent 36b9a6ee73e1d8756b701049521fa8d50bfd56f1\nparent 5e7a8c6eb12e1fb84cf2538cf87db32c54b938a2\nauthor Yuki Okushi <jtitor@2k36.org> 1623934601 +0900\ncommitter GitHub <noreply@github.com> 1623934601 +0900\n\nRollup merge of #85802 - Thomasdezeeuw:ioslice-advance, r=m-ou-se\n\nRename IoSlice(Mut)::advance to advance_slice and add IoSlice(Mut)::advance\n\nAlso changes the signature of `advance_slice` to accept a `&mut &mut [IoSlice]`, not returning anything. This will better match the `IoSlice::advance` function.\n\nUpdates https://github.com/rust-lang/rust/issues/62726.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/31ee68067efb53db5bf9cc20a690460e37f95591", "html_url": "https://github.com/rust-lang/rust/commit/31ee68067efb53db5bf9cc20a690460e37f95591", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/31ee68067efb53db5bf9cc20a690460e37f95591/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "36b9a6ee73e1d8756b701049521fa8d50bfd56f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/36b9a6ee73e1d8756b701049521fa8d50bfd56f1", "html_url": "https://github.com/rust-lang/rust/commit/36b9a6ee73e1d8756b701049521fa8d50bfd56f1"}, {"sha": "5e7a8c6eb12e1fb84cf2538cf87db32c54b938a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/5e7a8c6eb12e1fb84cf2538cf87db32c54b938a2", "html_url": "https://github.com/rust-lang/rust/commit/5e7a8c6eb12e1fb84cf2538cf87db32c54b938a2"}], "stats": {"total": 111, "additions": 81, "deletions": 30}, "files": [{"sha": "f57529767a91a6aeaa0154cdce529796f579791d", "filename": "library/std/src/io/mod.rs", "status": "modified", "additions": 63, "deletions": 12, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/31ee68067efb53db5bf9cc20a690460e37f95591/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ee68067efb53db5bf9cc20a690460e37f95591/library%2Fstd%2Fsrc%2Fio%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fmod.rs?ref=31ee68067efb53db5bf9cc20a690460e37f95591", "patch": "@@ -253,6 +253,7 @@ mod tests;\n \n use crate::cmp;\n use crate::fmt;\n+use crate::mem::replace;\n use crate::ops::{Deref, DerefMut};\n use crate::ptr;\n use crate::slice;\n@@ -1044,6 +1045,32 @@ impl<'a> IoSliceMut<'a> {\n \n     /// Advance the internal cursor of the slice.\n     ///\n+    /// Also see [`IoSliceMut::advance_slices`] to advance the cursors of\n+    /// multiple buffers.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(io_slice_advance)]\n+    ///\n+    /// use std::io::IoSliceMut;\n+    /// use std::ops::Deref;\n+    ///\n+    /// let mut data = [1; 8];\n+    /// let mut buf = IoSliceMut::new(&mut data);\n+    ///\n+    /// // Mark 3 bytes as read.\n+    /// buf.advance(3);\n+    /// assert_eq!(buf.deref(), [1; 5].as_ref());\n+    /// ```\n+    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        self.0.advance(n)\n+    }\n+\n+    /// Advance the internal cursor of the slices.\n+    ///\n     /// # Notes\n     ///\n     /// Elements in the slice may be modified if the cursor is not advanced to\n@@ -1070,13 +1097,13 @@ impl<'a> IoSliceMut<'a> {\n     /// ][..];\n     ///\n     /// // Mark 10 bytes as read.\n-    /// bufs = IoSliceMut::advance(bufs, 10);\n+    /// IoSliceMut::advance_slices(&mut bufs, 10);\n     /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n     /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n     /// ```\n     #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n     #[inline]\n-    pub fn advance<'b>(bufs: &'b mut [IoSliceMut<'a>], n: usize) -> &'b mut [IoSliceMut<'a>] {\n+    pub fn advance_slices(bufs: &mut &mut [IoSliceMut<'a>], n: usize) {\n         // Number of buffers to remove.\n         let mut remove = 0;\n         // Total length of all the to be removed buffers.\n@@ -1090,11 +1117,10 @@ impl<'a> IoSliceMut<'a> {\n             }\n         }\n \n-        let bufs = &mut bufs[remove..];\n+        *bufs = &mut replace(bufs, &mut [])[remove..];\n         if !bufs.is_empty() {\n-            bufs[0].0.advance(n - accumulated_len)\n+            bufs[0].advance(n - accumulated_len)\n         }\n-        bufs\n     }\n }\n \n@@ -1153,6 +1179,32 @@ impl<'a> IoSlice<'a> {\n \n     /// Advance the internal cursor of the slice.\n     ///\n+    /// Also see [`IoSlice::advance_slices`] to advance the cursors of multiple\n+    /// buffers.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(io_slice_advance)]\n+    ///\n+    /// use std::io::IoSlice;\n+    /// use std::ops::Deref;\n+    ///\n+    /// let mut data = [1; 8];\n+    /// let mut buf = IoSlice::new(&mut data);\n+    ///\n+    /// // Mark 3 bytes as read.\n+    /// buf.advance(3);\n+    /// assert_eq!(buf.deref(), [1; 5].as_ref());\n+    /// ```\n+    #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n+    #[inline]\n+    pub fn advance(&mut self, n: usize) {\n+        self.0.advance(n)\n+    }\n+\n+    /// Advance the internal cursor of the slices.\n+    ///\n     /// # Notes\n     ///\n     /// Elements in the slice may be modified if the cursor is not advanced to\n@@ -1179,12 +1231,12 @@ impl<'a> IoSlice<'a> {\n     /// ][..];\n     ///\n     /// // Mark 10 bytes as written.\n-    /// bufs = IoSlice::advance(bufs, 10);\n+    /// IoSlice::advance_slices(&mut bufs, 10);\n     /// assert_eq!(bufs[0].deref(), [2; 14].as_ref());\n     /// assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n     #[unstable(feature = \"io_slice_advance\", issue = \"62726\")]\n     #[inline]\n-    pub fn advance<'b>(bufs: &'b mut [IoSlice<'a>], n: usize) -> &'b mut [IoSlice<'a>] {\n+    pub fn advance_slices(bufs: &mut &mut [IoSlice<'a>], n: usize) {\n         // Number of buffers to remove.\n         let mut remove = 0;\n         // Total length of all the to be removed buffers.\n@@ -1198,11 +1250,10 @@ impl<'a> IoSlice<'a> {\n             }\n         }\n \n-        let bufs = &mut bufs[remove..];\n+        *bufs = &mut replace(bufs, &mut [])[remove..];\n         if !bufs.is_empty() {\n-            bufs[0].0.advance(n - accumulated_len)\n+            bufs[0].advance(n - accumulated_len)\n         }\n-        bufs\n     }\n }\n \n@@ -1511,7 +1562,7 @@ pub trait Write {\n     fn write_all_vectored(&mut self, mut bufs: &mut [IoSlice<'_>]) -> Result<()> {\n         // Guarantee that bufs is empty if it contains no data,\n         // to avoid calling write_vectored if there is no data to be written.\n-        bufs = IoSlice::advance(bufs, 0);\n+        IoSlice::advance_slices(&mut bufs, 0);\n         while !bufs.is_empty() {\n             match self.write_vectored(bufs) {\n                 Ok(0) => {\n@@ -1520,7 +1571,7 @@ pub trait Write {\n                         &\"failed to write whole buffer\",\n                     ));\n                 }\n-                Ok(n) => bufs = IoSlice::advance(bufs, n),\n+                Ok(n) => IoSlice::advance_slices(&mut bufs, n),\n                 Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n                 Err(e) => return Err(e),\n             }"}, {"sha": "df0dc7e9d31f699d206d7c3fc86b3397b797c580", "filename": "library/std/src/io/tests.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/31ee68067efb53db5bf9cc20a690460e37f95591/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/31ee68067efb53db5bf9cc20a690460e37f95591/library%2Fstd%2Fsrc%2Fio%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ftests.rs?ref=31ee68067efb53db5bf9cc20a690460e37f95591", "patch": "@@ -353,7 +353,7 @@ fn test_read_to_end_capacity() -> io::Result<()> {\n }\n \n #[test]\n-fn io_slice_mut_advance() {\n+fn io_slice_mut_advance_slices() {\n     let mut buf1 = [1; 8];\n     let mut buf2 = [2; 16];\n     let mut buf3 = [3; 8];\n@@ -364,75 +364,75 @@ fn io_slice_mut_advance() {\n     ][..];\n \n     // Only in a single buffer..\n-    bufs = IoSliceMut::advance(bufs, 1);\n+    IoSliceMut::advance_slices(&mut bufs, 1);\n     assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n     assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n     assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n \n     // Removing a buffer, leaving others as is.\n-    bufs = IoSliceMut::advance(bufs, 7);\n+    IoSliceMut::advance_slices(&mut bufs, 7);\n     assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n     assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n \n     // Removing a buffer and removing from the next buffer.\n-    bufs = IoSliceMut::advance(bufs, 18);\n+    IoSliceMut::advance_slices(&mut bufs, 18);\n     assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n }\n \n #[test]\n-fn io_slice_mut_advance_empty_slice() {\n-    let empty_bufs = &mut [][..];\n+fn io_slice_mut_advance_slices_empty_slice() {\n+    let mut empty_bufs = &mut [][..];\n     // Shouldn't panic.\n-    IoSliceMut::advance(empty_bufs, 1);\n+    IoSliceMut::advance_slices(&mut empty_bufs, 1);\n }\n \n #[test]\n-fn io_slice_mut_advance_beyond_total_length() {\n+fn io_slice_mut_advance_slices_beyond_total_length() {\n     let mut buf1 = [1; 8];\n     let mut bufs = &mut [IoSliceMut::new(&mut buf1)][..];\n \n     // Going beyond the total length should be ok.\n-    bufs = IoSliceMut::advance(bufs, 9);\n+    IoSliceMut::advance_slices(&mut bufs, 9);\n     assert!(bufs.is_empty());\n }\n \n #[test]\n-fn io_slice_advance() {\n+fn io_slice_advance_slices() {\n     let buf1 = [1; 8];\n     let buf2 = [2; 16];\n     let buf3 = [3; 8];\n     let mut bufs = &mut [IoSlice::new(&buf1), IoSlice::new(&buf2), IoSlice::new(&buf3)][..];\n \n     // Only in a single buffer..\n-    bufs = IoSlice::advance(bufs, 1);\n+    IoSlice::advance_slices(&mut bufs, 1);\n     assert_eq!(bufs[0].deref(), [1; 7].as_ref());\n     assert_eq!(bufs[1].deref(), [2; 16].as_ref());\n     assert_eq!(bufs[2].deref(), [3; 8].as_ref());\n \n     // Removing a buffer, leaving others as is.\n-    bufs = IoSlice::advance(bufs, 7);\n+    IoSlice::advance_slices(&mut bufs, 7);\n     assert_eq!(bufs[0].deref(), [2; 16].as_ref());\n     assert_eq!(bufs[1].deref(), [3; 8].as_ref());\n \n     // Removing a buffer and removing from the next buffer.\n-    bufs = IoSlice::advance(bufs, 18);\n+    IoSlice::advance_slices(&mut bufs, 18);\n     assert_eq!(bufs[0].deref(), [3; 6].as_ref());\n }\n \n #[test]\n-fn io_slice_advance_empty_slice() {\n-    let empty_bufs = &mut [][..];\n+fn io_slice_advance_slices_empty_slice() {\n+    let mut empty_bufs = &mut [][..];\n     // Shouldn't panic.\n-    IoSlice::advance(empty_bufs, 1);\n+    IoSlice::advance_slices(&mut empty_bufs, 1);\n }\n \n #[test]\n-fn io_slice_advance_beyond_total_length() {\n+fn io_slice_advance_slices_beyond_total_length() {\n     let buf1 = [1; 8];\n     let mut bufs = &mut [IoSlice::new(&buf1)][..];\n \n     // Going beyond the total length should be ok.\n-    bufs = IoSlice::advance(bufs, 9);\n+    IoSlice::advance_slices(&mut bufs, 9);\n     assert!(bufs.is_empty());\n }\n "}]}