{"sha": "bdba35cc9340ff2636d69d9b772d8178374c5aa9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkYmEzNWNjOTM0MGZmMjYzNmQ2OWQ5Yjc3MmQ4MTc4Mzc0YzVhYTk=", "commit": {"author": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-09-01T16:17:32Z"}, "committer": {"name": "Jonas Schievink", "email": "jonasschievink@gmail.com", "date": "2021-09-01T17:19:16Z"}, "message": "fix: multi-token mapping aware find references", "tree": {"sha": "95800aa341f0010a43b0dec3aab08512ebeb7ea3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/95800aa341f0010a43b0dec3aab08512ebeb7ea3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdba35cc9340ff2636d69d9b772d8178374c5aa9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdba35cc9340ff2636d69d9b772d8178374c5aa9", "html_url": "https://github.com/rust-lang/rust/commit/bdba35cc9340ff2636d69d9b772d8178374c5aa9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdba35cc9340ff2636d69d9b772d8178374c5aa9/comments", "author": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jonas-schievink", "id": 1786438, "node_id": "MDQ6VXNlcjE3ODY0Mzg=", "avatar_url": "https://avatars.githubusercontent.com/u/1786438?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jonas-schievink", "html_url": "https://github.com/jonas-schievink", "followers_url": "https://api.github.com/users/jonas-schievink/followers", "following_url": "https://api.github.com/users/jonas-schievink/following{/other_user}", "gists_url": "https://api.github.com/users/jonas-schievink/gists{/gist_id}", "starred_url": "https://api.github.com/users/jonas-schievink/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jonas-schievink/subscriptions", "organizations_url": "https://api.github.com/users/jonas-schievink/orgs", "repos_url": "https://api.github.com/users/jonas-schievink/repos", "events_url": "https://api.github.com/users/jonas-schievink/events{/privacy}", "received_events_url": "https://api.github.com/users/jonas-schievink/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "81ab52c6caa9216485a024a864078f086fce2eac", "url": "https://api.github.com/repos/rust-lang/rust/commits/81ab52c6caa9216485a024a864078f086fce2eac", "html_url": "https://github.com/rust-lang/rust/commit/81ab52c6caa9216485a024a864078f086fce2eac"}], "stats": {"total": 243, "additions": 156, "deletions": 87}, "files": [{"sha": "67f1f6dbdb34323f1f3764bacce3e9772652929b", "filename": "crates/ide/src/annotations.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Fannotations.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Fannotations.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fannotations.rs?ref=bdba35cc9340ff2636d69d9b772d8178374c5aa9", "patch": "@@ -134,8 +134,8 @@ pub(crate) fn resolve_annotation(db: &RootDatabase, mut annotation: Annotation)\n         AnnotationKind::HasReferences { position, data } => {\n             *data = find_all_refs(&Semantics::new(db), *position, None).map(|result| {\n                 result\n-                    .references\n                     .into_iter()\n+                    .flat_map(|res| res.references)\n                     .map(|(file_id, access)| {\n                         access.into_iter().map(move |(range, _)| FileRange { file_id, range })\n                     })"}, {"sha": "c04a2b4362ca2dc4140baa681e6618d8502ab1b6", "filename": "crates/ide/src/call_hierarchy.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fcall_hierarchy.rs?ref=bdba35cc9340ff2636d69d9b772d8178374c5aa9", "patch": "@@ -46,7 +46,7 @@ pub(crate) fn incoming_calls(db: &RootDatabase, position: FilePosition) -> Optio\n \n     let mut calls = CallLocations::default();\n \n-    for (file_id, references) in refs.references {\n+    for (file_id, references) in refs.into_iter().flat_map(|refs| refs.references) {\n         let file = sema.parse(file_id);\n         let file = file.syntax();\n         for (relative_range, token) in references"}, {"sha": "21872c81d134788d9673aaa85fdfa90bbdb13a47", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=bdba35cc9340ff2636d69d9b772d8178374c5aa9", "patch": "@@ -405,7 +405,7 @@ impl Analysis {\n         &self,\n         position: FilePosition,\n         search_scope: Option<SearchScope>,\n-    ) -> Cancellable<Option<ReferenceSearchResult>> {\n+    ) -> Cancellable<Option<Vec<ReferenceSearchResult>>> {\n         self.with_db(|db| references::find_all_refs(&Semantics::new(db), position, search_scope))\n     }\n "}, {"sha": "0d30dafd56fb9ec3b98035fe31d0e85661cdc2b6", "filename": "crates/ide/src/references.rs", "status": "modified", "additions": 134, "deletions": 70, "changes": 204, "blob_url": "https://github.com/rust-lang/rust/blob/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences.rs?ref=bdba35cc9340ff2636d69d9b772d8178374c5aa9", "patch": "@@ -9,6 +9,9 @@\n //! at the index that the match starts at and its tree parent is\n //! resolved to the search element definition, we get a reference.\n \n+use std::iter;\n+\n+use either::Either;\n use hir::{PathResolution, Semantics};\n use ide_db::{\n     base_db::FileId,\n@@ -52,76 +55,91 @@ pub(crate) fn find_all_refs(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n     search_scope: Option<SearchScope>,\n-) -> Option<ReferenceSearchResult> {\n+) -> Option<Vec<ReferenceSearchResult>> {\n     let _p = profile::span(\"find_all_refs\");\n     let syntax = sema.parse(position.file_id).syntax().clone();\n \n     let mut is_literal_search = false;\n-    let def = if let Some(name) = name_for_constructor_search(&syntax, position) {\n-        is_literal_search = true;\n-        match NameClass::classify(sema, &name)? {\n-            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-            NameClass::PatFieldShorthand { local_def: _, field_ref } => {\n-                Definition::Field(field_ref)\n-            }\n+    let defs = match name_for_constructor_search(&syntax, position) {\n+        Some(name) => {\n+            is_literal_search = true;\n+            let def = match NameClass::classify(sema, &name)? {\n+                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                NameClass::PatFieldShorthand { local_def: _, field_ref } => {\n+                    Definition::Field(field_ref)\n+                }\n+            };\n+            Either::Left(iter::once(def))\n         }\n-    } else {\n-        find_def(sema, &syntax, position.offset)?\n+        None => Either::Right(find_defs(sema, &syntax, position.offset)),\n     };\n \n-    let mut usages = def.usages(sema).set_scope(search_scope).include_self_refs().all();\n-    let declaration = match def {\n-        Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n-            Some(NavigationTarget::from_module_to_decl(sema.db, module))\n-        }\n-        def => def.try_to_nav(sema.db),\n-    }\n-    .map(|nav| {\n-        let decl_range = nav.focus_or_full_range();\n-        Declaration { nav, access: decl_access(&def, &syntax, decl_range) }\n-    });\n-    if is_literal_search {\n-        retain_adt_literal_usages(&mut usages, def, sema);\n-    }\n-\n-    let references = usages\n-        .into_iter()\n-        .map(|(file_id, refs)| {\n-            (file_id, refs.into_iter().map(|file_ref| (file_ref.range, file_ref.access)).collect())\n-        })\n-        .collect();\n+    Some(\n+        defs.into_iter()\n+            .map(|def| {\n+                let mut usages =\n+                    def.usages(sema).set_scope(search_scope.clone()).include_self_refs().all();\n+                let declaration = match def {\n+                    Definition::ModuleDef(hir::ModuleDef::Module(module)) => {\n+                        Some(NavigationTarget::from_module_to_decl(sema.db, module))\n+                    }\n+                    def => def.try_to_nav(sema.db),\n+                }\n+                .map(|nav| {\n+                    let decl_range = nav.focus_or_full_range();\n+                    Declaration { nav, access: decl_access(&def, &syntax, decl_range) }\n+                });\n+                if is_literal_search {\n+                    retain_adt_literal_usages(&mut usages, def, sema);\n+                }\n \n-    Some(ReferenceSearchResult { declaration, references })\n+                let references = usages\n+                    .into_iter()\n+                    .map(|(file_id, refs)| {\n+                        (\n+                            file_id,\n+                            refs.into_iter()\n+                                .map(|file_ref| (file_ref.range, file_ref.access))\n+                                .collect(),\n+                        )\n+                    })\n+                    .collect();\n+\n+                ReferenceSearchResult { declaration, references }\n+            })\n+            .collect(),\n+    )\n }\n \n-pub(crate) fn find_def(\n-    sema: &Semantics<RootDatabase>,\n+pub(crate) fn find_defs<'a>(\n+    sema: &'a Semantics<RootDatabase>,\n     syntax: &SyntaxNode,\n     offset: TextSize,\n-) -> Option<Definition> {\n-    let def = match sema.find_node_at_offset_with_descend(syntax, offset)? {\n-        ast::NameLike::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n-            NameRefClass::Definition(def) => def,\n-            NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n-                Definition::Local(local_ref)\n-            }\n-        },\n-        ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n-            NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n-            NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n-                Definition::Local(local_def)\n-            }\n-        },\n-        ast::NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, &lifetime)\n-            .and_then(|class| match class {\n-                NameRefClass::Definition(it) => Some(it),\n-                _ => None,\n-            })\n-            .or_else(|| {\n-                NameClass::classify_lifetime(sema, &lifetime).and_then(NameClass::defined)\n-            })?,\n-    };\n-    Some(def)\n+) -> impl Iterator<Item = Definition> + 'a {\n+    sema.find_nodes_at_offset_with_descend(syntax, offset).filter_map(move |node| {\n+        Some(match node {\n+            ast::NameLike::NameRef(name_ref) => match NameRefClass::classify(sema, &name_ref)? {\n+                NameRefClass::Definition(def) => def,\n+                NameRefClass::FieldShorthand { local_ref, field_ref: _ } => {\n+                    Definition::Local(local_ref)\n+                }\n+            },\n+            ast::NameLike::Name(name) => match NameClass::classify(sema, &name)? {\n+                NameClass::Definition(it) | NameClass::ConstReference(it) => it,\n+                NameClass::PatFieldShorthand { local_def, field_ref: _ } => {\n+                    Definition::Local(local_def)\n+                }\n+            },\n+            ast::NameLike::Lifetime(lifetime) => NameRefClass::classify_lifetime(sema, &lifetime)\n+                .and_then(|class| match class {\n+                    NameRefClass::Definition(it) => Some(it),\n+                    _ => None,\n+                })\n+                .or_else(|| {\n+                    NameClass::classify_lifetime(sema, &lifetime).and_then(NameClass::defined)\n+                })?,\n+        })\n+    })\n }\n \n pub(crate) fn decl_access(\n@@ -609,6 +627,7 @@ impl Foo {\n             expect![[r#\"\n                 f Function FileId(0) 27..43 30..31\n \n+                (no references)\n             \"#]],\n         );\n     }\n@@ -626,6 +645,7 @@ enum Foo {\n             expect![[r#\"\n                 B Variant FileId(0) 22..23 22..23\n \n+                (no references)\n             \"#]],\n         );\n     }\n@@ -643,6 +663,7 @@ enum Foo {\n             expect![[r#\"\n                 field Field FileId(0) 26..35 26..31\n \n+                (no references)\n             \"#]],\n         );\n     }\n@@ -744,6 +765,7 @@ use self$0;\n             expect![[r#\"\n                 Module FileId(0) 0..10\n \n+                (no references)\n             \"#]],\n         );\n     }\n@@ -1065,21 +1087,29 @@ impl Foo {\n         let refs = analysis.find_all_refs(pos, search_scope).unwrap().unwrap();\n \n         let mut actual = String::new();\n-        if let Some(decl) = refs.declaration {\n-            format_to!(actual, \"{}\", decl.nav.debug_render());\n-            if let Some(access) = decl.access {\n-                format_to!(actual, \" {:?}\", access)\n-            }\n+        for refs in refs {\n             actual += \"\\n\\n\";\n-        }\n \n-        for (file_id, references) in refs.references {\n-            for (range, access) in references {\n-                format_to!(actual, \"{:?} {:?}\", file_id, range);\n-                if let Some(access) = access {\n-                    format_to!(actual, \" {:?}\", access);\n+            if let Some(decl) = refs.declaration {\n+                format_to!(actual, \"{}\", decl.nav.debug_render());\n+                if let Some(access) = decl.access {\n+                    format_to!(actual, \" {:?}\", access)\n                 }\n-                actual += \"\\n\";\n+                actual += \"\\n\\n\";\n+            }\n+\n+            for (file_id, references) in &refs.references {\n+                for (range, access) in references {\n+                    format_to!(actual, \"{:?} {:?}\", file_id, range);\n+                    if let Some(access) = access {\n+                        format_to!(actual, \" {:?}\", access);\n+                    }\n+                    actual += \"\\n\";\n+                }\n+            }\n+\n+            if refs.references.is_empty() {\n+                actual += \"(no references)\\n\";\n             }\n         }\n         expect.assert_eq(actual.trim_start())\n@@ -1440,4 +1470,38 @@ m$0!();\n             \"#]],\n         );\n     }\n+\n+    #[test]\n+    fn multi_def() {\n+        check(\n+            r#\"\n+macro_rules! m {\n+    ($name:ident) => {\n+        mod module {\n+            pub fn $name() {}\n+        }\n+\n+        pub fn $name() {}\n+    }\n+}\n+\n+m!(func$0);\n+\n+fn f() {\n+    func();\n+    module::func();\n+}\n+            \"#,\n+            expect![[r#\"\n+                func Function FileId(0) 137..146 140..144\n+\n+                FileId(0) 161..165\n+\n+\n+                func Function FileId(0) 137..146 140..144\n+\n+                FileId(0) 181..185\n+            \"#]],\n+        )\n+    }\n }"}, {"sha": "b44d95a5803d3240244d2399fd244dac0ed33f18", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=bdba35cc9340ff2636d69d9b772d8178374c5aa9", "patch": "@@ -226,7 +226,7 @@ fn find_related_tests(\n     tests: &mut FxHashSet<Runnable>,\n ) {\n     if let Some(refs) = references::find_all_refs(sema, position, search_scope) {\n-        for (file_id, refs) in refs.references {\n+        for (file_id, refs) in refs.into_iter().flat_map(|refs| refs.references) {\n             let file = sema.parse(file_id);\n             let file = file.syntax();\n             let functions = refs.iter().filter_map(|(range, _)| {"}, {"sha": "14c896cdd04ab7f1f0c0c842dcd470ae1311c4df", "filename": "crates/ide_db/src/search.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide_db%2Fsrc%2Fsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Fide_db%2Fsrc%2Fsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_db%2Fsrc%2Fsearch.rs?ref=bdba35cc9340ff2636d69d9b772d8178374c5aa9", "patch": "@@ -71,6 +71,7 @@ pub enum ReferenceAccess {\n /// For `pub(crate)` things it's a crate, for `pub` things it's a crate and dependant crates.\n /// In some cases, the location of the references is known to within a `TextRange`,\n /// e.g. for things like local variables.\n+#[derive(Clone)]\n pub struct SearchScope {\n     entries: FxHashMap<FileId, Option<TextRange>>,\n }"}, {"sha": "de96816f44b5f8d6c32337fb26435097c418b528", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdba35cc9340ff2636d69d9b772d8178374c5aa9/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=bdba35cc9340ff2636d69d9b772d8178374c5aa9", "patch": "@@ -930,21 +930,25 @@ pub(crate) fn handle_references(\n         Some(refs) => refs,\n     };\n \n-    let decl = if params.context.include_declaration {\n-        refs.declaration.map(|decl| FileRange {\n-            file_id: decl.nav.file_id,\n-            range: decl.nav.focus_or_full_range(),\n-        })\n-    } else {\n-        None\n-    };\n+    let include_declaration = params.context.include_declaration;\n     let locations = refs\n-        .references\n         .into_iter()\n-        .flat_map(|(file_id, refs)| {\n-            refs.into_iter().map(move |(range, _)| FileRange { file_id, range })\n+        .flat_map(|refs| {\n+            let decl = if include_declaration {\n+                refs.declaration.map(|decl| FileRange {\n+                    file_id: decl.nav.file_id,\n+                    range: decl.nav.focus_or_full_range(),\n+                })\n+            } else {\n+                None\n+            };\n+            refs.references\n+                .into_iter()\n+                .flat_map(|(file_id, refs)| {\n+                    refs.into_iter().map(move |(range, _)| FileRange { file_id, range })\n+                })\n+                .chain(decl)\n         })\n-        .chain(decl)\n         .filter_map(|frange| to_proto::location(&snap, frange).ok())\n         .collect();\n \n@@ -1515,8 +1519,8 @@ fn show_ref_command_link(\n             let line_index = snap.file_line_index(position.file_id).ok()?;\n             let position = to_proto::position(&line_index, position.offset);\n             let locations: Vec<_> = ref_search_res\n-                .references\n                 .into_iter()\n+                .flat_map(|res| res.references)\n                 .flat_map(|(file_id, ranges)| {\n                     ranges.into_iter().filter_map(move |(range, _)| {\n                         to_proto::location(snap, FileRange { file_id, range }).ok()"}]}