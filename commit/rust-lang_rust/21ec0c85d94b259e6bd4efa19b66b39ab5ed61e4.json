{"sha": "21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZWMwYzg1ZDk0YjI1OWU2YmQ0ZWZhMTliNjZiMzlhYjVlZDYxZTQ=", "commit": {"author": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-08T16:26:36Z"}, "committer": {"name": "Eduard Burtescu", "email": "edy.burt@gmail.com", "date": "2015-01-11T20:09:45Z"}, "message": "rustc_typeck: don't use double indirection to Expr's in check_argument_types.", "tree": {"sha": "c5c5ce41884aad5f4e8447c87a5d9fac819bb799", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c5c5ce41884aad5f4e8447c87a5d9fac819bb799"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4", "html_url": "https://github.com/rust-lang/rust/commit/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c76710ecedb459d36ae110882931143a6fd5dd1", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c76710ecedb459d36ae110882931143a6fd5dd1", "html_url": "https://github.com/rust-lang/rust/commit/2c76710ecedb459d36ae110882931143a6fd5dd1"}], "stats": {"total": 44, "additions": 21, "deletions": 23}, "files": [{"sha": "9d45a5516fa7ba69e1af68fb1f13355db350a684", "filename": "src/librustc_typeck/check/callee.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fcallee.rs?ref=21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4", "patch": "@@ -192,11 +192,10 @@ fn confirm_builtin_call<'a,'tcx>(fcx: &FnCtxt<'a,'tcx>,\n         fcx.normalize_associated_types_in(call_expr.span, &fn_sig);\n \n     // Call the generic checker.\n-    let arg_exprs: Vec<_> = arg_exprs.iter().collect(); // for some weird reason we take &[&P<...>].\n     check_argument_types(fcx,\n                          call_expr.span,\n                          fn_sig.inputs.as_slice(),\n-                         arg_exprs.as_slice(),\n+                         arg_exprs,\n                          AutorefArgs::No,\n                          fn_sig.variadic,\n                          TupleArgumentsFlag::DontTupleArguments);\n@@ -209,12 +208,11 @@ fn confirm_overloaded_call<'a,'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                     arg_exprs: &[P<ast::Expr>],\n                                     method_callee: ty::MethodCallee<'tcx>)\n {\n-    let arg_exprs: Vec<_> = arg_exprs.iter().collect(); // for some weird reason we take &[&P<...>].\n     let output_type = check_method_argument_types(fcx,\n                                                   call_expr.span,\n                                                   method_callee.ty,\n                                                   call_expr,\n-                                                  arg_exprs.as_slice(),\n+                                                  arg_exprs,\n                                                   AutorefArgs::No,\n                                                   TupleArgumentsFlag::TupleArguments);\n     let method_call = ty::MethodCall::expr(call_expr.id);"}, {"sha": "61d401a14364ebfa9427124bd4dbf1056148b15e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=21ec0c85d94b259e6bd4efa19b66b39ab5ed61e4", "patch": "@@ -112,6 +112,7 @@ use std::cell::{Cell, Ref, RefCell};\n use std::mem::replace;\n use std::rc::Rc;\n use std::iter::repeat;\n+use std::slice;\n use syntax::{self, abi, attr};\n use syntax::ast::{self, ProvidedMethod, RequiredMethod, TypeTraitItem, DefId};\n use syntax::ast_util::{self, local_def, PostExpansionMethod};\n@@ -2598,7 +2599,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                          sp: Span,\n                                          method_fn_ty: Ty<'tcx>,\n                                          callee_expr: &ast::Expr,\n-                                         args_no_rcvr: &[&P<ast::Expr>],\n+                                         args_no_rcvr: &[P<ast::Expr>],\n                                          autoref_args: AutorefArgs,\n                                          tuple_arguments: TupleArgumentsFlag)\n                                          -> ty::FnOutput<'tcx> {\n@@ -2624,7 +2625,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 // HACK(eddyb) ignore self in the definition (see above).\n                 check_argument_types(fcx,\n                                      sp,\n-                                     fty.sig.0.inputs.slice_from(1),\n+                                     &fty.sig.0.inputs[1..],\n                                      args_no_rcvr,\n                                      autoref_args,\n                                      fty.sig.0.variadic,\n@@ -2644,7 +2645,7 @@ fn check_method_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                                   sp: Span,\n                                   fn_inputs: &[Ty<'tcx>],\n-                                  args: &[&P<ast::Expr>],\n+                                  args: &[P<ast::Expr>],\n                                   autoref_args: AutorefArgs,\n                                   variadic: bool,\n                                   tuple_arguments: TupleArgumentsFlag) {\n@@ -2767,7 +2768,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     AutorefArgs::No => {}\n                 }\n \n-                check_expr_coercable_to_type(fcx, &***arg, formal_ty);\n+                check_expr_coercable_to_type(fcx, &**arg, formal_ty);\n             }\n         }\n     }\n@@ -2776,12 +2777,12 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // arguments which we skipped above.\n     if variadic {\n         for arg in args.iter().skip(expected_arg_count) {\n-            check_expr(fcx, &***arg);\n+            check_expr(fcx, &**arg);\n \n             // There are a few types which get autopromoted when passed via varargs\n             // in C but we just error out instead and require explicit casts.\n             let arg_ty = structurally_resolved_type(fcx, arg.span,\n-                                                    fcx.expr_ty(&***arg));\n+                                                    fcx.expr_ty(&**arg));\n             match arg_ty.sty {\n                 ty::ty_float(ast::TyF32) => {\n                     fcx.type_error_message(arg.span,\n@@ -3064,12 +3065,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         };\n \n         // Call the generic checker.\n-        let args: Vec<_> = args[1..].iter().map(|x| x).collect();\n         let ret_ty = check_method_argument_types(fcx,\n                                                  method_name.span,\n                                                  fn_ty,\n                                                  expr,\n-                                                 args.as_slice(),\n+                                                 &args[1..],\n                                                  AutorefArgs::No,\n                                                  DontTupleArguments);\n \n@@ -3167,8 +3167,8 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n             None => None\n         };\n         let args = match rhs {\n-            Some(rhs) => vec![rhs],\n-            None => vec![]\n+            Some(rhs) => slice::ref_slice(rhs),\n+            None => &[][]\n         };\n         match method {\n             Some(method) => {\n@@ -3177,12 +3177,12 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                 let method_call = ::middle::ty::MethodCall::expr(op_ex.id);\n                 fcx.inh.method_map.borrow_mut().insert(method_call, method);\n                 match check_method_argument_types(fcx,\n-                                            op_ex.span,\n-                                            method_ty,\n-                                            op_ex,\n-                                            args.as_slice(),\n-                                            autoref_args,\n-                                            DontTupleArguments) {\n+                                                  op_ex.span,\n+                                                  method_ty,\n+                                                  op_ex,\n+                                                  args,\n+                                                  autoref_args,\n+                                                  DontTupleArguments) {\n                     ty::FnConverging(result_type) => result_type,\n                     ty::FnDiverging => fcx.tcx().types.err\n                 }\n@@ -3196,7 +3196,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                             op_ex.span,\n                                             expected_ty,\n                                             op_ex,\n-                                            args.as_slice(),\n+                                            args,\n                                             autoref_args,\n                                             DontTupleArguments);\n                 fcx.tcx().types.err\n@@ -4045,10 +4045,10 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n         fcx.write_ty(id, fcx.node_ty(b.id));\n       }\n       ast::ExprCall(ref callee, ref args) => {\n-          callee::check_call(fcx, expr, &**callee, args.as_slice());\n+          callee::check_call(fcx, expr, &**callee, &args[]);\n       }\n       ast::ExprMethodCall(ident, ref tps, ref args) => {\n-        check_method_call(fcx, expr, ident, args.as_slice(), tps.as_slice(), lvalue_pref);\n+        check_method_call(fcx, expr, ident, &args[], &tps[], lvalue_pref);\n         let arg_tys = args.iter().map(|a| fcx.expr_ty(&**a));\n         let  args_err = arg_tys.fold(false,\n              |rest_err, a| {"}]}