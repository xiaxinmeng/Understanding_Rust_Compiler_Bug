{"sha": "ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFkMWNkOTkwNTQ5ZmRmYzhhZTlkY2Q0ZWE3ZWVhODUxMDE3ZWIwNDI=", "commit": {"author": {"name": "llogiq", "email": "bogusandre@gmail.com", "date": "2016-07-09T22:06:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-09T22:06:30Z"}, "message": "Merge pull request #1060 from Manishearth/sugg\n\nImprove suggestions", "tree": {"sha": "b46573380b99d9940161ea1c0a2bdd79dab809ef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b46573380b99d9940161ea1c0a2bdd79dab809ef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "html_url": "https://github.com/rust-lang/rust/commit/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/comments", "author": {"login": "llogiq", "id": 4200835, "node_id": "MDQ6VXNlcjQyMDA4MzU=", "avatar_url": "https://avatars.githubusercontent.com/u/4200835?v=4", "gravatar_id": "", "url": "https://api.github.com/users/llogiq", "html_url": "https://github.com/llogiq", "followers_url": "https://api.github.com/users/llogiq/followers", "following_url": "https://api.github.com/users/llogiq/following{/other_user}", "gists_url": "https://api.github.com/users/llogiq/gists{/gist_id}", "starred_url": "https://api.github.com/users/llogiq/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/llogiq/subscriptions", "organizations_url": "https://api.github.com/users/llogiq/orgs", "repos_url": "https://api.github.com/users/llogiq/repos", "events_url": "https://api.github.com/users/llogiq/events{/privacy}", "received_events_url": "https://api.github.com/users/llogiq/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "208e2fcf9be1776086f6cd15ab2e4180111e4059", "url": "https://api.github.com/repos/rust-lang/rust/commits/208e2fcf9be1776086f6cd15ab2e4180111e4059", "html_url": "https://github.com/rust-lang/rust/commit/208e2fcf9be1776086f6cd15ab2e4180111e4059"}, {"sha": "bf513229b1be77aca80199d7220257548dff32c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/bf513229b1be77aca80199d7220257548dff32c8", "html_url": "https://github.com/rust-lang/rust/commit/bf513229b1be77aca80199d7220257548dff32c8"}], "stats": {"total": 1527, "additions": 1063, "deletions": 464}, "files": [{"sha": "e0ea031c73f24828bb500fb99eb8ad2a7719b8fa", "filename": "CHANGELOG.md", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/CHANGELOG.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/CHANGELOG.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CHANGELOG.md?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -1,7 +1,10 @@\n # Change Log\n All notable changes to this project will be documented in this file.\n \n-## 0.0.78 - 2016-07-02\n+## 0.0.79 \u2014 ?\n+* Major suggestions refactoring\n+\n+## 0.0.78 \u2014 2016-07-02\n * Rustup to *rustc 1.11.0-nightly (01411937f 2016-07-01)*\n * New lints: [`wrong_transmute`, `double_neg`]\n * For compatibility, `cargo clippy` does not defines the `clippy` feature"}, {"sha": "f37d242e43449ee39874cc8b6456fbafa3fa6f9f", "filename": "README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -25,7 +25,7 @@ name\n [almost_swapped](https://github.com/Manishearth/rust-clippy/wiki#almost_swapped)                                     | warn    | `foo = bar; bar = foo` sequence\n [approx_constant](https://github.com/Manishearth/rust-clippy/wiki#approx_constant)                                   | warn    | the approximate of a known float constant (in `std::f64::consts` or `std::f32::consts`) is found; suggests to use the constant\n [assign_op_pattern](https://github.com/Manishearth/rust-clippy/wiki#assign_op_pattern)                               | warn    | assigning the result of an operation on a variable to that same variable\n-[assign_ops](https://github.com/Manishearth/rust-clippy/wiki#assign_ops)                                             | allow   | Any assignment operation\n+[assign_ops](https://github.com/Manishearth/rust-clippy/wiki#assign_ops)                                             | allow   | any assignment operation\n [bad_bit_mask](https://github.com/Manishearth/rust-clippy/wiki#bad_bit_mask)                                         | warn    | expressions of the form `_ & mask == select` that will only ever return `true` or `false` (because in the example `select` containing bits that `mask` doesn't have)\n [blacklisted_name](https://github.com/Manishearth/rust-clippy/wiki#blacklisted_name)                                 | warn    | usage of a blacklisted/placeholder name\n [block_in_if_condition_expr](https://github.com/Manishearth/rust-clippy/wiki#block_in_if_condition_expr)             | warn    | braces can be eliminated in conditions that are expressions, e.g `if { true } ...`"}, {"sha": "2c84c7cc13213fcf3bb00f76a3e8eb7386c4c5ef", "filename": "clippy_lints/src/array_indexing.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Farray_indexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Farray_indexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Farray_indexing.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -6,7 +6,7 @@ use rustc_const_eval::eval_const_expr_partial;\n use rustc_const_math::ConstInt;\n use rustc::hir::*;\n use syntax::ast::RangeLimits;\n-use utils;\n+use utils::{self, higher};\n \n /// **What it does:** Check for out of bounds array indexing with a constant index.\n ///\n@@ -77,7 +77,7 @@ impl LateLintPass for ArrayIndexing {\n                 }\n \n                 // Index is a constant range\n-                if let Some(range) = utils::unsugar_range(index) {\n+                if let Some(range) = higher::range(index) {\n                     let start = range.start\n                         .map(|start| eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None))\n                         .map(|v| v.ok());\n@@ -94,7 +94,7 @@ impl LateLintPass for ArrayIndexing {\n                 }\n             }\n \n-            if let Some(range) = utils::unsugar_range(index) {\n+            if let Some(range) = higher::range(index) {\n                 // Full ranges are always valid\n                 if range.start.is_none() && range.end.is_none() {\n                     return;"}, {"sha": "6ae76f9c3eff93607f0c04ca48f50bf3af3db9f6", "filename": "clippy_lints/src/assign_ops.rs", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fassign_ops.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -1,28 +1,29 @@\n use rustc::hir;\n use rustc::lint::*;\n use utils::{span_lint_and_then, span_lint, snippet_opt, SpanlessEq, get_trait_def_id, implements_trait};\n+use utils::{higher, sugg};\n \n-/// **What it does:** This lint checks for `+=` operations and similar\n+/// **What it does:** This lint checks for `+=` operations and similar.\n ///\n-/// **Why is this bad?** Projects with many developers from languages without those operations\n-///                      may find them unreadable and not worth their weight\n+/// **Why is this bad?** Projects with many developers from languages without those operations may\n+/// find them unreadable and not worth their weight.\n ///\n-/// **Known problems:** Types implementing `OpAssign` don't necessarily implement `Op`\n+/// **Known problems:** Types implementing `OpAssign` don't necessarily implement `Op`.\n ///\n /// **Example:**\n /// ```\n /// a += 1;\n /// ```\n declare_restriction_lint! {\n     pub ASSIGN_OPS,\n-    \"Any assignment operation\"\n+    \"any assignment operation\"\n }\n \n-/// **What it does:** Check for `a = a op b` or `a = b commutative_op a` patterns\n+/// **What it does:** Check for `a = a op b` or `a = b commutative_op a` patterns.\n ///\n-/// **Why is this bad?** These can be written as the shorter `a op= b`\n+/// **Why is this bad?** These can be written as the shorter `a op= b`.\n ///\n-/// **Known problems:** While forbidden by the spec, `OpAssign` traits may have implementations that differ from the regular `Op` impl\n+/// **Known problems:** While forbidden by the spec, `OpAssign` traits may have implementations that differ from the regular `Op` impl.\n ///\n /// **Example:**\n ///\n@@ -50,24 +51,14 @@ impl LateLintPass for AssignOps {\n     fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n         match expr.node {\n             hir::ExprAssignOp(op, ref lhs, ref rhs) => {\n-                if let (Some(l), Some(r)) = (snippet_opt(cx, lhs.span), snippet_opt(cx, rhs.span)) {\n-                    span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {\n-                        match rhs.node {\n-                            hir::ExprBinary(op2, _, _) if op2 != op => {\n-                                db.span_suggestion(expr.span,\n-                                                   \"replace it with\",\n-                                                   format!(\"{} = {} {} ({})\", l, l, op.node.as_str(), r));\n-                            }\n-                            _ => {\n-                                db.span_suggestion(expr.span,\n-                                                   \"replace it with\",\n-                                                   format!(\"{} = {} {} {}\", l, l, op.node.as_str(), r));\n-                            }\n-                        }\n-                    });\n-                } else {\n-                    span_lint(cx, ASSIGN_OPS, expr.span, \"assign operation detected\");\n-                }\n+                span_lint_and_then(cx, ASSIGN_OPS, expr.span, \"assign operation detected\", |db| {\n+                    let lhs = &sugg::Sugg::hir(cx, lhs, \"..\");\n+                    let rhs = &sugg::Sugg::hir(cx, rhs, \"..\");\n+\n+                    db.span_suggestion(expr.span,\n+                                       \"replace it with\",\n+                                       format!(\"{} = {}\", lhs, sugg::make_binop(higher::binop(op.node), lhs, rhs)));\n+                });\n             }\n             hir::ExprAssign(ref assignee, ref e) => {\n                 if let hir::ExprBinary(op, ref l, ref r) = e.node {"}, {"sha": "b952d7415b475f176bd6fb81c70be3e3c387db5e", "filename": "clippy_lints/src/collapsible_if.rs", "status": "modified", "additions": 6, "deletions": 21, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcollapsible_if.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -13,11 +13,10 @@\n //! This lint is **warn** by default\n \n use rustc::lint::*;\n-use std::borrow::Cow;\n-use syntax::codemap::Spanned;\n use syntax::ast;\n \n-use utils::{in_macro, snippet, snippet_block, span_lint_and_then};\n+use utils::{in_macro, snippet_block, span_lint_and_then};\n+use utils::sugg::Sugg;\n \n /// **What it does:** This lint checks for nested `if`-statements which can be collapsed by\n /// `&&`-combining their conditions and for `else { if .. }` expressions that can be collapsed to\n@@ -104,31 +103,17 @@ fn check_collapsible_no_if_let(\n             return;\n         }\n         span_lint_and_then(cx, COLLAPSIBLE_IF, expr.span, \"this if statement can be collapsed\", |db| {\n+            let lhs = Sugg::ast(cx, check, \"..\");\n+            let rhs = Sugg::ast(cx, check_inner, \"..\");\n             db.span_suggestion(expr.span,\n                                \"try\",\n-                               format!(\"if {} && {} {}\",\n-                                       check_to_string(cx, check),\n-                                       check_to_string(cx, check_inner),\n+                               format!(\"if {} {}\",\n+                                       lhs.and(rhs),\n                                        snippet_block(cx, content.span, \"..\")));\n         });\n     }}\n }\n \n-fn requires_brackets(e: &ast::Expr) -> bool {\n-    match e.node {\n-        ast::ExprKind::Binary(Spanned { node: n, .. }, _, _) if n == ast::BinOpKind::Eq => false,\n-        _ => true,\n-    }\n-}\n-\n-fn check_to_string(cx: &EarlyContext, e: &ast::Expr) -> Cow<'static, str> {\n-    if requires_brackets(e) {\n-        format!(\"({})\", snippet(cx, e.span, \"..\")).into()\n-    } else {\n-        snippet(cx, e.span, \"..\")\n-    }\n-}\n-\n /// If the block contains only one expression, returns it.\n fn expr_block(block: &ast::Block) -> Option<&ast::Expr> {\n     let mut it = block.stmts.iter();"}, {"sha": "c7afc2d5cd9eff6afbdc9b8ced8c6f5ebbc1b24c", "filename": "clippy_lints/src/entry.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fentry.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -121,21 +121,21 @@ impl<'a, 'tcx, 'v, 'b> Visitor<'v> for InsertVisitor<'a, 'tcx, 'b> {\n             SpanlessEq::new(self.cx).eq_expr(self.key, &params[1])\n         ], {\n             span_lint_and_then(self.cx, MAP_ENTRY, self.span,\n-                               &format!(\"usage of `contains_key` followed by `insert` on `{}`\", self.ty), |db| {\n+                               &format!(\"usage of `contains_key` followed by `insert` on a `{}`\", self.ty), |db| {\n                 if self.sole_expr {\n                     let help = format!(\"{}.entry({}).or_insert({})\",\n                                        snippet(self.cx, self.map.span, \"map\"),\n                                        snippet(self.cx, params[1].span, \"..\"),\n                                        snippet(self.cx, params[2].span, \"..\"));\n \n-                    db.span_suggestion(self.span, \"Consider using\", help);\n+                    db.span_suggestion(self.span, \"consider using\", help);\n                 }\n                 else {\n-                    let help = format!(\"Consider using `{}.entry({})`\",\n+                    let help = format!(\"{}.entry({})\",\n                                        snippet(self.cx, self.map.span, \"map\"),\n                                        snippet(self.cx, params[1].span, \"..\"));\n \n-                    db.span_note(self.span, &help);\n+                    db.span_suggestion(self.span, \"consider using\", help);\n                 }\n             });\n         }}"}, {"sha": "0bc8c2bfd961eef1f0f5e7919c02767c55bb8e67", "filename": "clippy_lints/src/formatting.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fformatting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fformatting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fformatting.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -148,7 +148,7 @@ fn check_consecutive_ifs(cx: &EarlyContext, first: &ast::Expr, second: &ast::Exp\n     }\n }\n \n-/// Match `if` or `else if` expressions and return the `then` and `else` block.\n+/// Match `if` or `if let` expressions and return the `then` and `else` block.\n fn unsugar_if(expr: &ast::Expr) -> Option<(&P<ast::Block>, &Option<P<ast::Expr>>)> {\n     match expr.node {\n         ast::ExprKind::If(_, ref then, ref else_) |"}, {"sha": "c873ef8cc57d1b227ed1015ec9a9d8bf6e449cba", "filename": "clippy_lints/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flib.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -3,6 +3,7 @@\n #![feature(box_syntax)]\n #![feature(collections)]\n #![feature(custom_attribute)]\n+#![feature(dotdot_in_tuple_patterns)]\n #![feature(question_mark)]\n #![feature(rustc_private)]\n #![feature(slice_patterns)]\n@@ -36,6 +37,7 @@ extern crate quine_mc_cluskey;\n \n extern crate rustc_serialize;\n \n+extern crate rustc_errors;\n extern crate rustc_plugin;\n extern crate rustc_const_eval;\n extern crate rustc_const_math;"}, {"sha": "a4e338053e27b003add995aafcd537020e36d6e1", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 56, "deletions": 47, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -9,15 +9,14 @@ use rustc::middle::region::CodeExtent;\n use rustc::ty;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n-use std::borrow::Cow;\n use std::collections::HashMap;\n use syntax::ast;\n+use utils::sugg;\n \n-use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, in_external_macro,\n-            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, unsugar_range,\n-            walk_ptrs_ty, recover_for_loop};\n+use utils::{snippet, span_lint, get_parent_expr, match_trait_method, match_type, multispan_sugg, in_external_macro,\n+            span_help_and_lint, is_integer_literal, get_enclosing_block, span_lint_and_then, higher,\n+            walk_ptrs_ty};\n use utils::paths;\n-use utils::UnsugaredRange;\n \n /// **What it does:** This lint checks for looping over the range of `0..len` of some collection just to get the values by index.\n ///\n@@ -224,7 +223,7 @@ impl LintPass for Pass {\n \n impl LateLintPass for Pass {\n     fn check_expr(&mut self, cx: &LateContext, expr: &Expr) {\n-        if let Some((pat, arg, body)) = recover_for_loop(expr) {\n+        if let Some((pat, arg, body)) = higher::for_loop(expr) {\n             check_for_loop(cx, pat, arg, body, expr);\n         }\n         // check for `loop { if let {} else break }` that could be `while let`\n@@ -333,7 +332,7 @@ fn check_for_loop(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &E\n /// Check for looping over a range and then indexing a sequence with it.\n /// The iteratee must be a range literal.\n fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n-    if let Some(UnsugaredRange { start: Some(ref start), ref end, .. }) = unsugar_range(arg) {\n+    if let Some(higher::Range { start: Some(ref start), ref end, limits }) = higher::range(arg) {\n         // the var must be a single name\n         if let PatKind::Binding(_, ref ident, _) = pat.node {\n             let mut visitor = VarVisitor {\n@@ -361,49 +360,58 @@ fn check_for_loop_range(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, ex\n \n                 let starts_at_zero = is_integer_literal(start, 0);\n \n-                let skip: Cow<_> = if starts_at_zero {\n-                    \"\".into()\n+                let skip = if starts_at_zero {\n+                    \"\".to_owned()\n                 } else {\n-                    format!(\".skip({})\", snippet(cx, start.span, \"..\")).into()\n+                    format!(\".skip({})\", snippet(cx, start.span, \"..\"))\n                 };\n \n-                let take: Cow<_> = if let Some(ref end) = *end {\n+                let take = if let Some(ref end) = *end {\n                     if is_len_call(end, &indexed) {\n-                        \"\".into()\n+                        \"\".to_owned()\n                     } else {\n-                        format!(\".take({})\", snippet(cx, end.span, \"..\")).into()\n+                        match limits {\n+                            ast::RangeLimits::Closed => {\n+                                let end = sugg::Sugg::hir(cx, end, \"<count>\");\n+                                format!(\".take({})\", end + sugg::ONE)\n+                            }\n+                            ast::RangeLimits::HalfOpen => {\n+                                format!(\".take({})\", snippet(cx, end.span, \"..\"))\n+                            }\n+                        }\n                     }\n                 } else {\n-                    \"\".into()\n+                    \"\".to_owned()\n                 };\n \n                 if visitor.nonindex {\n-                    span_lint(cx,\n-                              NEEDLESS_RANGE_LOOP,\n-                              expr.span,\n-                              &format!(\"the loop variable `{}` is used to index `{}`. Consider using `for ({}, \\\n-                                        item) in {}.iter().enumerate(){}{}` or similar iterators\",\n-                                       ident.node,\n-                                       indexed,\n-                                       ident.node,\n-                                       indexed,\n-                                       take,\n-                                       skip));\n+                    span_lint_and_then(cx,\n+                                       NEEDLESS_RANGE_LOOP,\n+                                       expr.span,\n+                                       &format!(\"the loop variable `{}` is used to index `{}`\", ident.node, indexed),\n+                                       |db| {\n+                        multispan_sugg(db, \"consider using an iterator\".to_string(), &[\n+                            (pat.span, &format!(\"({}, <item>)\", ident.node)),\n+                            (arg.span, &format!(\"{}.iter().enumerate(){}{}\", indexed, take, skip)),\n+                        ]);\n+                    });\n                 } else {\n                     let repl = if starts_at_zero && take.is_empty() {\n                         format!(\"&{}\", indexed)\n                     } else {\n                         format!(\"{}.iter(){}{}\", indexed, take, skip)\n                     };\n \n-                    span_lint(cx,\n-                              NEEDLESS_RANGE_LOOP,\n-                              expr.span,\n-                              &format!(\"the loop variable `{}` is only used to index `{}`. \\\n-                                        Consider using `for item in {}` or similar iterators\",\n-                                       ident.node,\n-                                       indexed,\n-                                       repl));\n+                    span_lint_and_then(cx,\n+                                       NEEDLESS_RANGE_LOOP,\n+                                       expr.span,\n+                                       &format!(\"the loop variable `{}` is only used to index `{}`.\", ident.node, indexed),\n+                                       |db| {\n+                        multispan_sugg(db, \"consider using an iterator\".to_string(), &[\n+                            (pat.span, \"<item>\"),\n+                            (arg.span, &repl),\n+                        ]);\n+                    });\n                 }\n             }\n         }\n@@ -427,7 +435,7 @@ fn is_len_call(expr: &Expr, var: &Name) -> bool {\n \n fn check_for_loop_reverse_range(cx: &LateContext, arg: &Expr, expr: &Expr) {\n     // if this for loop is iterating over a two-sided range...\n-    if let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), limits }) = unsugar_range(arg) {\n+    if let Some(higher::Range { start: Some(ref start), end: Some(ref end), limits }) = higher::range(arg) {\n         // ...and both sides are compile-time constant integers...\n         if let Ok(start_idx) = eval_const_expr_partial(cx.tcx, start, ExprTypeChecked, None) {\n             if let Ok(end_idx) = eval_const_expr_partial(cx.tcx, end, ExprTypeChecked, None) {\n@@ -588,33 +596,34 @@ fn check_for_loop_explicit_counter(cx: &LateContext, arg: &Expr, body: &Expr, ex\n \n /// Check for the `FOR_KV_MAP` lint.\n fn check_for_loop_over_map_kv(cx: &LateContext, pat: &Pat, arg: &Expr, body: &Expr, expr: &Expr) {\n+    let pat_span = pat.span;\n+\n     if let PatKind::Tuple(ref pat, _) = pat.node {\n         if pat.len() == 2 {\n-            let (pat_span, kind) = match (&pat[0].node, &pat[1].node) {\n-                (key, _) if pat_is_wild(key, body) => (&pat[1].span, \"values\"),\n-                (_, value) if pat_is_wild(value, body) => (&pat[0].span, \"keys\"),\n+            let (new_pat_span, kind) = match (&pat[0].node, &pat[1].node) {\n+                (key, _) if pat_is_wild(key, body) => (pat[1].span, \"value\"),\n+                (_, value) if pat_is_wild(value, body) => (pat[0].span, \"key\"),\n                 _ => return,\n             };\n \n-            let arg_span = match arg.node {\n-                ExprAddrOf(MutImmutable, ref expr) => expr.span,\n+            let (arg_span, arg) = match arg.node {\n+                ExprAddrOf(MutImmutable, ref expr) => (arg.span, &**expr),\n                 ExprAddrOf(MutMutable, _) => return, // for _ in &mut _, there is no {values,keys}_mut method\n-                _ => arg.span,\n+                _ => (arg.span, arg),\n             };\n \n             let ty = walk_ptrs_ty(cx.tcx.expr_ty(arg));\n             if match_type(cx, ty, &paths::HASHMAP) || match_type(cx, ty, &paths::BTREEMAP) {\n                 span_lint_and_then(cx,\n                                    FOR_KV_MAP,\n                                    expr.span,\n-                                   &format!(\"you seem to want to iterate on a map's {}\", kind),\n+                                   &format!(\"you seem to want to iterate on a map's {}s\", kind),\n                                    |db| {\n-                    db.span_suggestion(expr.span,\n-                                       \"use the corresponding method\",\n-                                       format!(\"for {} in {}.{}() {{ .. }}\",\n-                                               snippet(cx, *pat_span, \"..\"),\n-                                               snippet(cx, arg_span, \"..\"),\n-                                               kind));\n+                    let map = sugg::Sugg::hir(cx, arg, \"map\");\n+                    multispan_sugg(db, \"use the corresponding method\".into(), &[\n+                        (pat_span, &snippet(cx, new_pat_span, kind)),\n+                        (arg_span, &format!(\"{}.{}s()\", map.maybe_par(), kind)),\n+                    ]);\n                 });\n             }\n         }"}, {"sha": "de21cabc6fb422d3b83277073581d62881151fd1", "filename": "clippy_lints/src/matches.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmatches.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -10,6 +10,7 @@ use syntax::ast::LitKind;\n use syntax::codemap::Span;\n use utils::paths;\n use utils::{match_type, snippet, span_note_and_lint, span_lint_and_then, in_external_macro, expr_block};\n+use utils::sugg::Sugg;\n \n /// **What it does:** This lint checks for matches with a single arm where an `if let` will usually suffice.\n ///\n@@ -234,56 +235,54 @@ fn check_single_match_opt_like(cx: &LateContext, ex: &Expr, arms: &[Arm], expr:\n fn check_match_bool(cx: &LateContext, ex: &Expr, arms: &[Arm], expr: &Expr) {\n     // type of expression == bool\n     if cx.tcx.expr_ty(ex).sty == ty::TyBool {\n-        let sugg = if arms.len() == 2 && arms[0].pats.len() == 1 {\n-            // no guards\n-            let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n-                if let ExprLit(ref lit) = arm_bool.node {\n-                    match lit.node {\n-                        LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n-                        LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n-                        _ => None,\n+        span_lint_and_then(cx,\n+                           MATCH_BOOL,\n+                           expr.span,\n+                           \"you seem to be trying to match on a boolean expression\",\n+                           move |db| {\n+            if arms.len() == 2 && arms[0].pats.len() == 1 {\n+                // no guards\n+                let exprs = if let PatKind::Lit(ref arm_bool) = arms[0].pats[0].node {\n+                    if let ExprLit(ref lit) = arm_bool.node {\n+                        match lit.node {\n+                            LitKind::Bool(true) => Some((&*arms[0].body, &*arms[1].body)),\n+                            LitKind::Bool(false) => Some((&*arms[1].body, &*arms[0].body)),\n+                            _ => None,\n+                        }\n+                    } else {\n+                        None\n                     }\n                 } else {\n                     None\n-                }\n-            } else {\n-                None\n-            };\n-\n-            if let Some((ref true_expr, ref false_expr)) = exprs {\n-                match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n-                    (false, false) => {\n-                        Some(format!(\"if {} {} else {}\",\n-                                     snippet(cx, ex.span, \"b\"),\n-                                     expr_block(cx, true_expr, None, \"..\"),\n-                                     expr_block(cx, false_expr, None, \"..\")))\n+                };\n+\n+                if let Some((ref true_expr, ref false_expr)) = exprs {\n+                    let sugg = match (is_unit_expr(true_expr), is_unit_expr(false_expr)) {\n+                        (false, false) => {\n+                            Some(format!(\"if {} {} else {}\",\n+                                         snippet(cx, ex.span, \"b\"),\n+                                         expr_block(cx, true_expr, None, \"..\"),\n+                                         expr_block(cx, false_expr, None, \"..\")))\n+                        }\n+                        (false, true) => {\n+                            Some(format!(\"if {} {}\", snippet(cx, ex.span, \"b\"), expr_block(cx, true_expr, None, \"..\")))\n+                        }\n+                        (true, false) => {\n+                            let test = Sugg::hir(cx, ex, \"..\");\n+                            Some(format!(\"if {} {}\",\n+                                         !test,\n+                                         expr_block(cx, false_expr, None, \"..\")))\n+                        }\n+                        (true, true) => None,\n+                    };\n+\n+                    if let Some(sugg) = sugg {\n+                        db.span_suggestion(expr.span, \"consider using an if/else expression\", sugg);\n                     }\n-                    (false, true) => {\n-                        Some(format!(\"if {} {}\", snippet(cx, ex.span, \"b\"), expr_block(cx, true_expr, None, \"..\")))\n-                    }\n-                    (true, false) => {\n-                        Some(format!(\"try\\nif !{} {}\",\n-                                     snippet(cx, ex.span, \"b\"),\n-                                     expr_block(cx, false_expr, None, \"..\")))\n-                    }\n-                    (true, true) => None,\n                 }\n-            } else {\n-                None\n             }\n-        } else {\n-            None\n-        };\n \n-        span_lint_and_then(cx,\n-                           MATCH_BOOL,\n-                           expr.span,\n-                           \"you seem to be trying to match on a boolean expression. Consider using an if..else block:\",\n-                           move |db| {\n-                               if let Some(sugg) = sugg {\n-                                   db.span_suggestion(expr.span, \"try this\", sugg);\n-                               }\n-                           });\n+       });\n     }\n }\n \n@@ -307,26 +306,28 @@ fn check_overlapping_arms(cx: &LateContext, ex: &Expr, arms: &[Arm]) {\n fn check_match_ref_pats(cx: &LateContext, ex: &Expr, arms: &[Arm], source: MatchSource, expr: &Expr) {\n     if has_only_ref_pats(arms) {\n         if let ExprAddrOf(Mutability::MutImmutable, ref inner) = ex.node {\n-            let template = match_template(cx, expr.span, source, \"\", inner);\n             span_lint_and_then(cx,\n                                MATCH_REF_PATS,\n                                expr.span,\n                                \"you don't need to add `&` to both the expression and the patterns\",\n                                |db| {\n-                                   db.span_suggestion(expr.span, \"try\", template);\n-                               });\n+                let inner = Sugg::hir(cx, inner, \"..\");\n+                let template = match_template(expr.span, source, inner);\n+                db.span_suggestion(expr.span, \"try\", template);\n+            });\n         } else {\n-            let template = match_template(cx, expr.span, source, \"*\", ex);\n             span_lint_and_then(cx,\n                                MATCH_REF_PATS,\n                                expr.span,\n                                \"you don't need to add `&` to all patterns\",\n                                |db| {\n-                                   db.span_suggestion(expr.span,\n-                                                      \"instead of prefixing all patterns with `&`, you can \\\n-                                                       dereference the expression\",\n-                                                      template);\n-                               });\n+                let ex = Sugg::hir(cx, ex, \"..\");\n+                let template = match_template(expr.span, source, ex.deref());\n+                db.span_suggestion(expr.span,\n+                                   \"instead of prefixing all patterns with `&`, you can \\\n+                                   dereference the expression\",\n+                                   template);\n+            });\n         }\n     }\n }\n@@ -409,12 +410,11 @@ fn has_only_ref_pats(arms: &[Arm]) -> bool {\n     mapped.map_or(false, |v| v.iter().any(|el| *el))\n }\n \n-fn match_template(cx: &LateContext, span: Span, source: MatchSource, op: &str, expr: &Expr) -> String {\n-    let expr_snippet = snippet(cx, expr.span, \"..\");\n+fn match_template(span: Span, source: MatchSource, expr: Sugg) -> String {\n     match source {\n-        MatchSource::Normal => format!(\"match {}{} {{ .. }}\", op, expr_snippet),\n-        MatchSource::IfLetDesugar { .. } => format!(\"if let .. = {}{} {{ .. }}\", op, expr_snippet),\n-        MatchSource::WhileLetDesugar => format!(\"while let .. = {}{} {{ .. }}\", op, expr_snippet),\n+        MatchSource::Normal => format!(\"match {} {{ .. }}\", expr),\n+        MatchSource::IfLetDesugar { .. } => format!(\"if let .. = {} {{ .. }}\", expr),\n+        MatchSource::WhileLetDesugar => format!(\"while let .. = {} {{ .. }}\", expr),\n         MatchSource::ForLoopDesugar => span_bug!(span, \"for loop desugared to match with &-patterns!\"),\n         MatchSource::TryDesugar => span_bug!(span, \"`?` operator desugared to match with &-patterns!\"),\n     }"}, {"sha": "f70ec4eac9f839f6b7a462895b23ece32fb08425", "filename": "clippy_lints/src/methods.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -11,10 +11,11 @@ use std::fmt;\n use syntax::codemap::Span;\n use syntax::ptr::P;\n use utils::{get_trait_def_id, implements_trait, in_external_macro, in_macro, match_path, match_trait_method,\n-            match_type, method_chain_args, return_ty, same_tys, snippet, snippet_opt, span_lint,\n+            match_type, method_chain_args, return_ty, same_tys, snippet, span_lint,\n             span_lint_and_then, span_note_and_lint, walk_ptrs_ty, walk_ptrs_ty_depth};\n use utils::MethodArgs;\n use utils::paths;\n+use utils::sugg;\n \n #[derive(Clone)]\n pub struct Pass;\n@@ -628,8 +629,8 @@ fn lint_clone_double_ref(cx: &LateContext, expr: &hir::Expr, arg: &hir::Expr, ty\n                                expr.span,\n                                \"using `clone` on a double-reference; \\\n                                 this will copy the reference instead of cloning the inner type\",\n-                               |db| if let Some(snip) = snippet_opt(cx, arg.span) {\n-                                   db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"(*{}).clone()\", snip));\n+                               |db| if let Some(snip) = sugg::Sugg::hir_opt(cx, arg) {\n+                                   db.span_suggestion(expr.span, \"try dereferencing it\", format!(\"({}).clone()\", snip.deref()));\n                                });\n         }\n     }\n@@ -641,14 +642,13 @@ fn lint_extend(cx: &LateContext, expr: &hir::Expr, args: &MethodArgs) {\n         return;\n     }\n     let arg_ty = cx.tcx.expr_ty(&args[1]);\n-    if let Some((span, r)) = derefs_to_slice(cx, &args[1], &arg_ty) {\n+    if let Some(slice) = derefs_to_slice(cx, &args[1], &arg_ty) {\n         span_lint_and_then(cx, EXTEND_FROM_SLICE, expr.span, \"use of `extend` to extend a Vec by a slice\", |db| {\n             db.span_suggestion(expr.span,\n                                \"try this\",\n-                               format!(\"{}.extend_from_slice({}{})\",\n+                               format!(\"{}.extend_from_slice({})\",\n                                        snippet(cx, args[0].span, \"_\"),\n-                                       r,\n-                                       snippet(cx, span, \"_\")));\n+                                       slice));\n         });\n     }\n }\n@@ -672,20 +672,20 @@ fn lint_cstring_as_ptr(cx: &LateContext, expr: &hir::Expr, new: &hir::Expr, unwr\n #[allow(ptr_arg)]\n // Type of MethodArgs is potentially a Vec\n fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &MethodArgs, is_mut: bool){\n-    let caller_type;\n     let mut_str = if is_mut { \"_mut\" } else {\"\"};\n-    if let Some(_) = derefs_to_slice(cx, &iter_args[0], &cx.tcx.expr_ty(&iter_args[0])) {\n-        caller_type = \"slice\";\n+    let caller_type = if let Some(_) = derefs_to_slice(cx, &iter_args[0], &cx.tcx.expr_ty(&iter_args[0])) {\n+        \"slice\"\n     }\n     else if match_type(cx, cx.tcx.expr_ty(&iter_args[0]), &paths::VEC) {\n-        caller_type = \"Vec\";\n+        \"Vec\"\n     }\n     else if match_type(cx, cx.tcx.expr_ty(&iter_args[0]), &paths::VEC_DEQUE) {\n-        caller_type = \"VecDeque\";\n+        \"VecDeque\"\n     }\n     else {\n         return; // caller is not a type that we want to lint\n-    }\n+    };\n+\n     span_lint(\n         cx,\n         ITER_NTH,\n@@ -695,7 +695,7 @@ fn lint_iter_nth(cx: &LateContext, expr: &hir::Expr, iter_args: &MethodArgs, is_\n     );\n }\n \n-fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: &ty::Ty) -> Option<(Span, &'static str)> {\n+fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: &ty::Ty) -> Option<sugg::Sugg<'static>> {\n     fn may_slice(cx: &LateContext, ty: &ty::Ty) -> bool {\n         match ty.sty {\n             ty::TySlice(_) => true,\n@@ -706,19 +706,22 @@ fn derefs_to_slice(cx: &LateContext, expr: &hir::Expr, ty: &ty::Ty) -> Option<(S\n             _ => false,\n         }\n     }\n+\n     if let hir::ExprMethodCall(name, _, ref args) = expr.node {\n         if &name.node.as_str() == &\"iter\" && may_slice(cx, &cx.tcx.expr_ty(&args[0])) {\n-            Some((args[0].span, \"&\"))\n+            sugg::Sugg::hir_opt(cx, &*args[0]).map(|sugg| {\n+                sugg.addr()\n+            })\n         } else {\n             None\n         }\n     } else {\n         match ty.sty {\n-            ty::TySlice(_) => Some((expr.span, \"\")),\n+            ty::TySlice(_) => sugg::Sugg::hir_opt(cx, expr),\n             ty::TyRef(_, ty::TypeAndMut { ty: ref inner, .. }) |\n             ty::TyBox(ref inner) => {\n                 if may_slice(cx, inner) {\n-                    Some((expr.span, \"\"))\n+                    sugg::Sugg::hir_opt(cx, expr)\n                 } else {\n                     None\n                 }"}, {"sha": "b1627c31c8b80033517ac667d372ad5db3304b40", "filename": "clippy_lints/src/misc.rs", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -13,6 +13,7 @@ use utils::{\n     get_item_name, get_parent_expr, implements_trait, in_macro, is_integer_literal, match_path,\n     snippet, span_lint, span_lint_and_then, walk_ptrs_ty\n };\n+use utils::sugg::Sugg;\n \n /// **What it does:** This lint checks for function arguments and let bindings denoted as `ref`.\n ///\n@@ -69,14 +70,15 @@ impl LateLintPass for TopLevelRefPass {\n             span_lint_and_then(cx,\n                 TOPLEVEL_REF_ARG,\n                 l.pat.span,\n-                \"`ref` on an entire `let` pattern is discouraged, take a reference with & instead\",\n+                \"`ref` on an entire `let` pattern is discouraged, take a reference with `&` instead\",\n                 |db| {\n+                    let init = Sugg::hir(cx, init, \"..\");\n                     db.span_suggestion(s.span,\n                                        \"try\",\n-                                       format!(\"let {}{} = &{};\",\n+                                       format!(\"let {}{} = {};\",\n                                                snippet(cx, i.span, \"_\"),\n                                                tyopt,\n-                                               snippet(cx, init.span, \"_\")));\n+                                               init.addr()));\n                 }\n             );\n         }}\n@@ -164,15 +166,19 @@ impl LateLintPass for FloatCmp {\n                         return;\n                     }\n                 }\n-                span_lint(cx,\n-                          FLOAT_CMP,\n-                          expr.span,\n-                          &format!(\"{}-comparison of f32 or f64 detected. Consider changing this to `({} - {}).abs() < \\\n-                                    epsilon` for some suitable value of epsilon. \\\n-                                    std::f32::EPSILON and std::f64::EPSILON are available.\",\n-                                   op.as_str(),\n-                                   snippet(cx, left.span, \"..\"),\n-                                   snippet(cx, right.span, \"..\")));\n+                span_lint_and_then(cx,\n+                                   FLOAT_CMP,\n+                                   expr.span,\n+                                   \"strict comparison of f32 or f64\",\n+                                   |db| {\n+                    let lhs = Sugg::hir(cx, left, \"..\");\n+                    let rhs = Sugg::hir(cx, right, \"..\");\n+\n+                    db.span_suggestion(expr.span,\n+                                       \"consider comparing them within some error\",\n+                                       format!(\"({}).abs() < error\", lhs - rhs));\n+                    db.span_note(expr.span, \"std::f32::EPSILON and std::f64::EPSILON are available.\");\n+                });\n             }\n         }\n     }"}, {"sha": "c0f1c611f714dfd49d81b710bf304872077deb02", "filename": "clippy_lints/src/misc_early.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmisc_early.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmisc_early.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmisc_early.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -149,7 +149,7 @@ impl EarlyLintPass for MiscEarly {\n                                            \"Try not to call a closure in the expression where it is declared.\",\n                                            |db| {\n                                                if decl.inputs.is_empty() {\n-                                                   let hint = format!(\"{}\", snippet(cx, block.span, \"..\"));\n+                                                   let hint = snippet(cx, block.span, \"..\").into_owned();\n                                                    db.span_suggestion(expr.span, \"Try doing something like: \", hint);\n                                                }\n                                            });"}, {"sha": "d5d9fe1a0bc8ca3484ba4272ae36299f4816c6f4", "filename": "clippy_lints/src/mut_mut.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmut_mut.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fmut_mut.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmut_mut.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -2,7 +2,7 @@ use rustc::hir;\n use rustc::hir::intravisit;\n use rustc::lint::*;\n use rustc::ty::{TypeAndMut, TyRef};\n-use utils::{in_external_macro, recover_for_loop, span_lint};\n+use utils::{higher, in_external_macro, span_lint};\n \n /// **What it does:** This lint checks for instances of `mut mut` references.\n ///\n@@ -49,7 +49,7 @@ impl<'a, 'tcx, 'v> intravisit::Visitor<'v> for MutVisitor<'a, 'tcx> {\n             return;\n         }\n \n-        if let Some((_, arg, body)) = recover_for_loop(expr) {\n+        if let Some((_, arg, body)) = higher::for_loop(expr) {\n             // A `for` loop lowers to:\n             // ```rust\n             // match ::std::iter::Iterator::next(&mut iter) {"}, {"sha": "c3e2a0e61679c73e7e0fe6f999c0fabe9af5abd6", "filename": "clippy_lints/src/needless_bool.rs", "status": "modified", "additions": 23, "deletions": 13, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_bool.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -6,7 +6,8 @@ use rustc::lint::*;\n use rustc::hir::*;\n use syntax::ast::LitKind;\n use syntax::codemap::Spanned;\n-use utils::{span_lint, span_lint_and_then, snippet, snippet_opt};\n+use utils::{span_lint, span_lint_and_then, snippet};\n+use utils::sugg::Sugg;\n \n /// **What it does:** This lint checks for expressions of the form `if c { true } else { false }` (or vice versa) and suggest using the condition directly.\n ///\n@@ -49,11 +50,20 @@ impl LateLintPass for NeedlessBool {\n     fn check_expr(&mut self, cx: &LateContext, e: &Expr) {\n         use self::Expression::*;\n         if let ExprIf(ref pred, ref then_block, Some(ref else_expr)) = e.node {\n-            let reduce = |hint: &str, not| {\n-                let hint = match snippet_opt(cx, pred.span) {\n-                    Some(pred_snip) => format!(\"`{}{}`\", not, pred_snip),\n-                    None => hint.into(),\n+            let reduce = |ret, not| {\n+                let snip = Sugg::hir(cx, pred, \"<predicate>\");\n+                let snip = if not {\n+                    !snip\n+                } else {\n+                    snip\n+                };\n+\n+                let hint = if ret {\n+                    format!(\"return {}\", snip)\n+                } else {\n+                    snip.to_string()\n                 };\n+\n                 span_lint_and_then(cx,\n                                    NEEDLESS_BOOL,\n                                    e.span,\n@@ -77,10 +87,10 @@ impl LateLintPass for NeedlessBool {\n                               e.span,\n                               \"this if-then-else expression will always return false\");\n                 }\n-                (RetBool(true), RetBool(false)) => reduce(\"its predicate\", \"return \"),\n-                (Bool(true), Bool(false)) => reduce(\"its predicate\", \"\"),\n-                (RetBool(false), RetBool(true)) => reduce(\"`!` and its predicate\", \"return !\"),\n-                (Bool(false), Bool(true)) => reduce(\"`!` and its predicate\", \"!\"),\n+                (RetBool(true), RetBool(false)) => reduce(true, false),\n+                (Bool(true), Bool(false)) => reduce(false, false),\n+                (RetBool(false), RetBool(true)) => reduce(true, true),\n+                (Bool(false), Bool(true)) => reduce(false, true),\n                 _ => (),\n             }\n         }\n@@ -122,23 +132,23 @@ impl LateLintPass for BoolComparison {\n                                        });\n                 }\n                 (Bool(false), Other) => {\n-                    let hint = format!(\"!{}\", snippet(cx, right_side.span, \"..\"));\n+                    let hint = Sugg::hir(cx, right_side, \"..\");\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against false can be replaced by a negation\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n+                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n                                        });\n                 }\n                 (Other, Bool(false)) => {\n-                    let hint = format!(\"!{}\", snippet(cx, left_side.span, \"..\"));\n+                    let hint = Sugg::hir(cx, left_side, \"..\");\n                     span_lint_and_then(cx,\n                                        BOOL_COMPARISON,\n                                        e.span,\n                                        \"equality checks against false can be replaced by a negation\",\n                                        |db| {\n-                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", hint);\n+                                           db.span_suggestion(e.span, \"try simplifying it as shown:\", (!hint).to_string());\n                                        });\n                 }\n                 _ => (),"}, {"sha": "a042c966d942d9e41f8c57b7ee39200d0d23bc72", "filename": "clippy_lints/src/ranges.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Franges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Franges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Franges.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -1,7 +1,8 @@\n use rustc::lint::*;\n use rustc::hir::*;\n use syntax::codemap::Spanned;\n-use utils::{is_integer_literal, match_type, paths, snippet, span_lint, unsugar_range, UnsugaredRange};\n+use utils::{is_integer_literal, match_type, paths, snippet, span_lint};\n+use utils::higher;\n \n /// **What it does:** This lint checks for iterating over ranges with a `.step_by(0)`, which never terminates.\n ///\n@@ -54,7 +55,7 @@ impl LateLintPass for StepByZero {\n                     let ExprMethodCall( Spanned { node: ref iter_name, .. }, _, ref iter_args ) = *iter,\n                     iter_name.as_str() == \"iter\",\n                     // range expression in .zip() call: 0..x.len()\n-                    let Some(UnsugaredRange { start: Some(ref start), end: Some(ref end), .. }) = unsugar_range(zip_arg),\n+                    let Some(higher::Range { start: Some(ref start), end: Some(ref end), .. }) = higher::range(zip_arg),\n                     is_integer_literal(start, 0),\n                     // .len() call\n                     let ExprMethodCall(Spanned { node: ref len_name, .. }, _, ref len_args) = end.node,"}, {"sha": "7bda94ed639792c68b9dbd6385922a2590cba960", "filename": "clippy_lints/src/shadow.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fshadow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fshadow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fshadow.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -5,7 +5,7 @@ use rustc::hir::*;\n use rustc::hir::intravisit::{Visitor, FnKind};\n use std::ops::Deref;\n use syntax::codemap::Span;\n-use utils::{is_from_for_desugar, in_external_macro, snippet, span_lint_and_then};\n+use utils::{higher, in_external_macro, snippet, span_lint_and_then};\n \n /// **What it does:** This lint checks for bindings that shadow other bindings already in scope, while just changing reference level or mutability.\n ///\n@@ -91,7 +91,7 @@ fn check_decl(cx: &LateContext, decl: &Decl, bindings: &mut Vec<(Name, Span)>) {\n     if in_external_macro(cx, decl.span) {\n         return;\n     }\n-    if is_from_for_desugar(decl) {\n+    if higher::is_from_for_desugar(decl) {\n         return;\n     }\n     if let DeclLocal(ref local) = decl.node {"}, {"sha": "667c450e66979140967a0a0342ab0c8639e413f9", "filename": "clippy_lints/src/swap.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fswap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fswap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fswap.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -2,7 +2,8 @@ use rustc::hir::*;\n use rustc::lint::*;\n use rustc::ty;\n use syntax::codemap::mk_sp;\n-use utils::{differing_macro_contexts, match_type, paths, snippet, snippet_opt, span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n+use utils::{differing_macro_contexts, match_type, paths, snippet, span_lint_and_then, walk_ptrs_ty, SpanlessEq};\n+use utils::sugg::Sugg;\n \n /// **What it does:** This lints manual swapping.\n ///\n@@ -100,17 +101,17 @@ fn check_manual_swap(cx: &LateContext, block: &Block) {\n             }\n \n             let (replace, what, sugg) = if let Some((slice, idx1, idx2)) = check_for_slice(cx, lhs1, lhs2) {\n-                if let Some(slice) = snippet_opt(cx, slice.span) {\n+                if let Some(slice) = Sugg::hir_opt(cx, slice) {\n                     (false,\n                      format!(\" elements of `{}`\", slice),\n-                     format!(\"{}.swap({}, {})\",slice,  snippet(cx, idx1.span, \"..\"), snippet(cx, idx2.span, \"..\")))\n+                     format!(\"{}.swap({}, {})\", slice.maybe_par(), snippet(cx, idx1.span, \"..\"), snippet(cx, idx2.span, \"..\")))\n                 } else {\n                     (false, \"\".to_owned(), \"\".to_owned())\n                 }\n             } else {\n-                 if let (Some(first), Some(second)) = (snippet_opt(cx, lhs1.span), snippet_opt(cx, rhs1.span)) {\n+                 if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs1), Sugg::hir_opt(cx, rhs1)) {\n                     (true, format!(\" `{}` and `{}`\", first, second),\n-                     format!(\"std::mem::swap(&mut {}, &mut {})\", first, second))\n+                     format!(\"std::mem::swap({}, {})\", first.mut_addr(), second.mut_addr()))\n                 } else {\n                     (true, \"\".to_owned(), \"\".to_owned())\n                 }\n@@ -147,8 +148,8 @@ fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n             SpanlessEq::new(cx).ignore_fn().eq_expr(lhs0, rhs1),\n             SpanlessEq::new(cx).ignore_fn().eq_expr(lhs1, rhs0)\n         ], {\n-            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (snippet_opt(cx, lhs0.span), snippet_opt(cx, rhs0.span)) {\n-                (format!(\" `{}` and `{}`\", first, second), first, second)\n+            let (what, lhs, rhs) = if let (Some(first), Some(second)) = (Sugg::hir_opt(cx, lhs0), Sugg::hir_opt(cx, rhs0)) {\n+                (format!(\" `{}` and `{}`\", first, second), first.mut_addr().to_string(), second.mut_addr().to_string())\n             } else {\n                 (\"\".to_owned(), \"\".to_owned(), \"\".to_owned())\n             };\n@@ -162,7 +163,7 @@ fn check_suspicious_swap(cx: &LateContext, block: &Block) {\n                                |db| {\n                                    if !what.is_empty() {\n                                        db.span_suggestion(span, \"try\",\n-                                                          format!(\"std::mem::swap(&mut {}, &mut {})\", lhs, rhs));\n+                                                          format!(\"std::mem::swap({}, {})\", lhs, rhs));\n                                        db.note(\"or maybe you should use `std::mem::replace`?\");\n                                    }\n                                });"}, {"sha": "ba4da0e8f65446f3a6b5decb74c15990e8725221", "filename": "clippy_lints/src/transmute.rs", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftransmute.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -2,7 +2,8 @@ use rustc::lint::*;\n use rustc::ty::TypeVariants::{TyRawPtr, TyRef};\n use rustc::ty;\n use rustc::hir::*;\n-use utils::{match_def_path, paths, snippet_opt, span_lint, span_lint_and_then};\n+use utils::{match_def_path, paths, span_lint, span_lint_and_then};\n+use utils::sugg;\n \n /// **What it does:** This lint checks for transmutes that can't ever be correct on any architecture\n ///\n@@ -92,14 +93,14 @@ impl LateLintPass for Transmute {\n                             e.span,\n                             \"transmute from a reference to a pointer\",\n                             |db| {\n-                                if let Some(arg) = snippet_opt(cx, args[0].span) {\n+                                if let Some(arg) = sugg::Sugg::hir_opt(cx, &*args[0]) {\n                                     let sugg = if ptr_ty == rty {\n-                                        format!(\"{} as {}\", arg, to_ty)\n+                                        arg.as_ty(to_ty)\n                                     } else {\n-                                        format!(\"{} as {} as {}\", arg, cx.tcx.mk_ptr(rty), to_ty)\n+                                        arg.as_ty(cx.tcx.mk_ptr(rty)).as_ty(to_ty)\n                                     };\n \n-                                    db.span_suggestion(e.span, \"try\", sugg);\n+                                    db.span_suggestion(e.span, \"try\", sugg.to_string());\n                                 }\n                             },\n                         ),\n@@ -110,8 +111,8 @@ impl LateLintPass for Transmute {\n                             e.span,\n                             \"transmute from an integer to a pointer\",\n                             |db| {\n-                                if let Some(arg) = snippet_opt(cx, args[0].span) {\n-                                    db.span_suggestion(e.span, \"try\", format!(\"{} as {}\", arg, to_ty));\n+                                if let Some(arg) = sugg::Sugg::hir_opt(cx, &*args[0]) {\n+                                    db.span_suggestion(e.span, \"try\", arg.as_ty(&to_ty.to_string()).to_string());\n                                 }\n                             },\n                         ),\n@@ -148,28 +149,21 @@ impl LateLintPass for Transmute {\n                                     from_ty,\n                                     to_ty),\n                             |db| {\n-                                if let Some(arg) = snippet_opt(cx, args[0].span) {\n-                                    let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n-                                        (\"&mut *\", \"*mut\")\n-                                    } else {\n-                                        (\"&*\", \"*const\")\n-                                    };\n+                                let arg = sugg::Sugg::hir(cx, &args[0], \"..\");\n+                                let (deref, cast) = if to_rty.mutbl == Mutability::MutMutable {\n+                                    (\"&mut *\", \"*mut\")\n+                                } else {\n+                                    (\"&*\", \"*const\")\n+                                };\n \n \n-                                    let sugg = if from_pty.ty == to_rty.ty {\n-                                        // Put things in parentheses if they are more complex\n-                                        match args[0].node {\n-                                            ExprPath(..) | ExprCall(..) | ExprMethodCall(..) | ExprBlock(..) => {\n-                                                format!(\"{}{}\", deref, arg)\n-                                            }\n-                                            _ => format!(\"{}({})\", deref, arg)\n-                                        }\n-                                    } else {\n-                                        format!(\"{}({} as {} {})\", deref, arg, cast, to_rty.ty)\n-                                    };\n+                                let arg = if from_pty.ty == to_rty.ty {\n+                                    arg\n+                                } else {\n+                                    arg.as_ty(&format!(\"{} {}\", cast, to_rty.ty))\n+                                };\n \n-                                    db.span_suggestion(e.span, \"try\", sugg);\n-                                }\n+                                db.span_suggestion(e.span, \"try\", sugg::make_unop(deref, arg).to_string());\n                             },\n                         ),\n                         _ => return,"}, {"sha": "629834a3c0f7a3b71c728db043fca7df81ae723e", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -6,7 +6,7 @@ use rustc::ty;\n use std::cmp::Ordering;\n use syntax::ast::{IntTy, UintTy, FloatTy};\n use syntax::codemap::Span;\n-use utils::{comparisons, in_external_macro, in_macro, is_from_for_desugar, match_def_path, snippet,\n+use utils::{comparisons, higher, in_external_macro, in_macro, match_def_path, snippet,\n             span_help_and_lint, span_lint};\n use utils::paths;\n \n@@ -106,7 +106,7 @@ fn check_let_unit(cx: &LateContext, decl: &Decl) {\n             if in_external_macro(cx, decl.span) || in_macro(cx, local.pat.span) {\n                 return;\n             }\n-            if is_from_for_desugar(decl) {\n+            if higher::is_from_for_desugar(decl) {\n                 return;\n             }\n             span_lint(cx,"}, {"sha": "ab8b7d8b2b8f3b128fd47d42719ea520ce827269", "filename": "clippy_lints/src/utils/higher.rs", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Futils%2Fhigher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fhigher.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -0,0 +1,190 @@\n+//! This module contains functions for retrieve the original AST from lowered `hir`.\n+\n+use rustc::hir;\n+use rustc::lint::LateContext;\n+use syntax::ast;\n+use syntax::ptr::P;\n+use utils::{is_expn_of, match_path, paths};\n+\n+/// Convert a hir binary operator to the corresponding `ast` type.\n+pub fn binop(op: hir::BinOp_) -> ast::BinOpKind {\n+    match op {\n+        hir::BiEq => ast::BinOpKind::Eq,\n+        hir::BiGe => ast::BinOpKind::Ge,\n+        hir::BiGt => ast::BinOpKind::Gt,\n+        hir::BiLe => ast::BinOpKind::Le,\n+        hir::BiLt => ast::BinOpKind::Lt,\n+        hir::BiNe => ast::BinOpKind::Ne,\n+        hir::BiOr => ast::BinOpKind::Or,\n+        hir::BiAdd => ast::BinOpKind::Add,\n+        hir::BiAnd => ast::BinOpKind::And,\n+        hir::BiBitAnd => ast::BinOpKind::BitAnd,\n+        hir::BiBitOr => ast::BinOpKind::BitOr,\n+        hir::BiBitXor => ast::BinOpKind::BitXor,\n+        hir::BiDiv => ast::BinOpKind::Div,\n+        hir::BiMul => ast::BinOpKind::Mul,\n+        hir::BiRem => ast::BinOpKind::Rem,\n+        hir::BiShl => ast::BinOpKind::Shl,\n+        hir::BiShr => ast::BinOpKind::Shr,\n+        hir::BiSub => ast::BinOpKind::Sub,\n+    }\n+}\n+\n+/// Represent a range akin to `ast::ExprKind::Range`.\n+#[derive(Debug, Copy, Clone)]\n+pub struct Range<'a> {\n+    pub start: Option<&'a hir::Expr>,\n+    pub end: Option<&'a hir::Expr>,\n+    pub limits: ast::RangeLimits,\n+}\n+\n+/// Higher a `hir` range to something similar to `ast::ExprKind::Range`.\n+pub fn range(expr: &hir::Expr) -> Option<Range> {\n+    // To be removed when ranges get stable.\n+    fn unwrap_unstable(expr: &hir::Expr) -> &hir::Expr {\n+        if let hir::ExprBlock(ref block) = expr.node {\n+            if block.rules == hir::BlockCheckMode::PushUnstableBlock || block.rules == hir::BlockCheckMode::PopUnstableBlock {\n+                if let Some(ref expr) = block.expr {\n+                    return expr;\n+                }\n+            }\n+        }\n+\n+        expr\n+    }\n+\n+    fn get_field<'a>(name: &str, fields: &'a [hir::Field]) -> Option<&'a hir::Expr> {\n+        let expr = &fields.iter()\n+                          .find(|field| field.name.node.as_str() == name)\n+                          .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n+                          .expr;\n+\n+        Some(unwrap_unstable(expr))\n+    }\n+\n+    // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n+    // `#[no_std]`. Testing both instead of resolving the paths.\n+\n+    match unwrap_unstable(expr).node {\n+        hir::ExprPath(None, ref path) => {\n+            if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n+                Some(Range {\n+                    start: None,\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+        hir::ExprStruct(ref path, ref fields, None) => {\n+            if match_path(path, &paths::RANGE_FROM_STD) || match_path(path, &paths::RANGE_FROM) {\n+                Some(Range {\n+                    start: get_field(\"start\", fields),\n+                    end: None,\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) ||\n+               match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n+                Some(Range {\n+                    start: get_field(\"start\", fields),\n+                    end: get_field(\"end\", fields),\n+                    limits: ast::RangeLimits::Closed,\n+                })\n+            } else if match_path(path, &paths::RANGE_STD) || match_path(path, &paths::RANGE) {\n+                Some(Range {\n+                    start: get_field(\"start\", fields),\n+                    end: get_field(\"end\", fields),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n+                Some(Range {\n+                    start: None,\n+                    end: get_field(\"end\", fields),\n+                    limits: ast::RangeLimits::Closed,\n+                })\n+            } else if match_path(path, &paths::RANGE_TO_STD) || match_path(path, &paths::RANGE_TO) {\n+                Some(Range {\n+                    start: None,\n+                    end: get_field(\"end\", fields),\n+                    limits: ast::RangeLimits::HalfOpen,\n+                })\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None,\n+    }\n+}\n+\n+/// Checks if a `let` decl is from a `for` loop desugaring.\n+pub fn is_from_for_desugar(decl: &hir::Decl) -> bool {\n+    if_let_chain! {[\n+        let hir::DeclLocal(ref loc) = decl.node,\n+        let Some(ref expr) = loc.init,\n+        let hir::ExprMatch(_, _, hir::MatchSource::ForLoopDesugar) = expr.node,\n+    ], {\n+        return true;\n+    }}\n+    false\n+}\n+\n+/// Recover the essential nodes of a desugared for loop:\n+/// `for pat in arg { body }` becomes `(pat, arg, body)`.\n+pub fn for_loop(expr: &hir::Expr) -> Option<(&hir::Pat, &hir::Expr, &hir::Expr)> {\n+    if_let_chain! {[\n+        let hir::ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n+        let hir::ExprCall(_, ref iterargs) = iterexpr.node,\n+        iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n+        let hir::ExprLoop(ref block, _) = arms[0].body.node,\n+        block.stmts.is_empty(),\n+        let Some(ref loopexpr) = block.expr,\n+        let hir::ExprMatch(_, ref innerarms, hir::MatchSource::ForLoopDesugar) = loopexpr.node,\n+        innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n+        let hir::PatKind::TupleStruct(_, ref somepats, _) = innerarms[0].pats[0].node,\n+        somepats.len() == 1\n+    ], {\n+        return Some((&somepats[0],\n+                     &iterargs[0],\n+                     &innerarms[0].body));\n+    }}\n+    None\n+}\n+\n+/// Represent the pre-expansion arguments of a `vec!` invocation.\n+pub enum VecArgs<'a> {\n+    /// `vec![elem; len]`\n+    Repeat(&'a P<hir::Expr>, &'a P<hir::Expr>),\n+    /// `vec![a, b, c]`\n+    Vec(&'a [P<hir::Expr>]),\n+}\n+\n+/// Returns the arguments of the `vec!` macro if this expression was expanded from `vec!`.\n+pub fn vec_macro<'e>(cx: &LateContext, expr: &'e hir::Expr) -> Option<VecArgs<'e>> {\n+    if_let_chain!{[\n+        let hir::ExprCall(ref fun, ref args) = expr.node,\n+        let hir::ExprPath(_, ref path) = fun.node,\n+        is_expn_of(cx, fun.span, \"vec\").is_some()\n+    ], {\n+        return if match_path(path, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n+            // `vec![elem; size]` case\n+            Some(VecArgs::Repeat(&args[0], &args[1]))\n+        }\n+        else if match_path(path, &[\"into_vec\"]) && args.len() == 1 {\n+            // `vec![a, b, c]` case\n+            if_let_chain!{[\n+                let hir::ExprBox(ref boxed) = args[0].node,\n+                let hir::ExprVec(ref args) = boxed.node\n+            ], {\n+                return Some(VecArgs::Vec(&*args));\n+            }}\n+\n+            None\n+        }\n+        else {\n+            None\n+        };\n+    }}\n+\n+    None\n+}"}, {"sha": "189801c8c0b5615b778907b9553977fa900d6a75", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 26, "deletions": 125, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -9,21 +9,23 @@ use rustc::traits::ProjectionMode;\n use rustc::traits;\n use rustc::ty::subst::Subst;\n use rustc::ty;\n+use rustc_errors;\n use std::borrow::Cow;\n use std::env;\n use std::mem;\n use std::str::FromStr;\n-use syntax::ast::{self, LitKind, RangeLimits};\n-use syntax::codemap::{ExpnInfo, Span, ExpnFormat};\n+use syntax::ast::{self, LitKind};\n+use syntax::codemap::{ExpnFormat, ExpnInfo, MultiSpan, Span};\n use syntax::errors::DiagnosticBuilder;\n use syntax::ptr::P;\n \n+pub mod cargo;\n pub mod comparisons;\n pub mod conf;\n mod hir;\n pub mod paths;\n+pub mod sugg;\n pub use self::hir::{SpanlessEq, SpanlessHash};\n-pub mod cargo;\n \n pub type MethodArgs = HirVec<P<Expr>>;\n \n@@ -80,6 +82,8 @@ macro_rules! if_let_chain {\n     };\n }\n \n+pub mod higher;\n+\n /// Returns true if the two spans come from differing expansions (i.e. one is from a macro and one\n /// isn't).\n pub fn differing_macro_contexts(lhs: Span, rhs: Span) -> bool {\n@@ -317,19 +321,6 @@ pub fn get_item_name(cx: &LateContext, expr: &Expr) -> Option<Name> {\n     }\n }\n \n-/// Checks if a `let` decl is from a `for` loop desugaring.\n-pub fn is_from_for_desugar(decl: &Decl) -> bool {\n-    if_let_chain! {[\n-        let DeclLocal(ref loc) = decl.node,\n-        let Some(ref expr) = loc.init,\n-        let ExprMatch(_, _, MatchSource::ForLoopDesugar) = expr.node\n-    ], {\n-        return true;\n-    }}\n-    false\n-}\n-\n-\n /// Convert a span to a code snippet if available, otherwise use default.\n ///\n /// # Example\n@@ -500,6 +491,25 @@ pub fn span_lint_and_then<'a, T: LintContext, F>(cx: &'a T, lint: &'static Lint,\n     }\n }\n \n+/// Create a suggestion made from several `span \u2192 replacement`.\n+///\n+/// Note: in the JSON format (used by `compiletest_rs`), the help message will appear once per\n+/// replacement. In human-readable format though, it only appears once before the whole suggestion.\n+pub fn multispan_sugg(db: &mut DiagnosticBuilder, help_msg: String, sugg: &[(Span, &str)]) {\n+    let sugg = rustc_errors::RenderSpan::Suggestion(rustc_errors::CodeSuggestion {\n+        msp: MultiSpan::from_spans(sugg.iter().map(|&(span, _)| span).collect()),\n+        substitutes: sugg.iter().map(|&(_, subs)| subs.to_owned()).collect(),\n+    });\n+\n+    let sub = rustc_errors::SubDiagnostic {\n+        level: rustc_errors::Level::Help,\n+        message: help_msg,\n+        span: MultiSpan::new(),\n+        render_span: Some(sugg),\n+    };\n+    db.children.push(sub);\n+}\n+\n /// Return the base type for references and raw pointers.\n pub fn walk_ptrs_ty(ty: ty::Ty) -> ty::Ty {\n     match ty.sty {\n@@ -681,93 +691,6 @@ pub fn camel_case_from(s: &str) -> usize {\n     last_i\n }\n \n-/// Represent a range akin to `ast::ExprKind::Range`.\n-#[derive(Debug, Copy, Clone)]\n-pub struct UnsugaredRange<'a> {\n-    pub start: Option<&'a Expr>,\n-    pub end: Option<&'a Expr>,\n-    pub limits: RangeLimits,\n-}\n-\n-/// Unsugar a `hir` range.\n-pub fn unsugar_range(expr: &Expr) -> Option<UnsugaredRange> {\n-    // To be removed when ranges get stable.\n-    fn unwrap_unstable(expr: &Expr) -> &Expr {\n-        if let ExprBlock(ref block) = expr.node {\n-            if block.rules == BlockCheckMode::PushUnstableBlock || block.rules == BlockCheckMode::PopUnstableBlock {\n-                if let Some(ref expr) = block.expr {\n-                    return expr;\n-                }\n-            }\n-        }\n-\n-        expr\n-    }\n-\n-    fn get_field<'a>(name: &str, fields: &'a [Field]) -> Option<&'a Expr> {\n-        let expr = &fields.iter()\n-                          .find(|field| field.name.node.as_str() == name)\n-                          .unwrap_or_else(|| panic!(\"missing {} field for range\", name))\n-                          .expr;\n-\n-        Some(unwrap_unstable(expr))\n-    }\n-\n-    // The range syntax is expanded to literal paths starting with `core` or `std` depending on\n-    // `#[no_std]`. Testing both instead of resolving the paths.\n-\n-    match unwrap_unstable(expr).node {\n-        ExprPath(None, ref path) => {\n-            if match_path(path, &paths::RANGE_FULL_STD) || match_path(path, &paths::RANGE_FULL) {\n-                Some(UnsugaredRange {\n-                    start: None,\n-                    end: None,\n-                    limits: RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-        ExprStruct(ref path, ref fields, None) => {\n-            if match_path(path, &paths::RANGE_FROM_STD) || match_path(path, &paths::RANGE_FROM) {\n-                Some(UnsugaredRange {\n-                    start: get_field(\"start\", fields),\n-                    end: None,\n-                    limits: RangeLimits::HalfOpen,\n-                })\n-            } else if match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY_STD) ||\n-               match_path(path, &paths::RANGE_INCLUSIVE_NON_EMPTY) {\n-                Some(UnsugaredRange {\n-                    start: get_field(\"start\", fields),\n-                    end: get_field(\"end\", fields),\n-                    limits: RangeLimits::Closed,\n-                })\n-            } else if match_path(path, &paths::RANGE_STD) || match_path(path, &paths::RANGE) {\n-                Some(UnsugaredRange {\n-                    start: get_field(\"start\", fields),\n-                    end: get_field(\"end\", fields),\n-                    limits: RangeLimits::HalfOpen,\n-                })\n-            } else if match_path(path, &paths::RANGE_TO_INCLUSIVE_STD) || match_path(path, &paths::RANGE_TO_INCLUSIVE) {\n-                Some(UnsugaredRange {\n-                    start: None,\n-                    end: get_field(\"end\", fields),\n-                    limits: RangeLimits::Closed,\n-                })\n-            } else if match_path(path, &paths::RANGE_TO_STD) || match_path(path, &paths::RANGE_TO) {\n-                Some(UnsugaredRange {\n-                    start: None,\n-                    end: get_field(\"end\", fields),\n-                    limits: RangeLimits::HalfOpen,\n-                })\n-            } else {\n-                None\n-            }\n-        }\n-        _ => None,\n-    }\n-}\n-\n /// Convenience function to get the return type of a function or `None` if the function diverges.\n pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Option<ty::Ty<'tcx>> {\n     let parameter_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_item);\n@@ -792,28 +715,6 @@ pub fn same_tys<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, a: ty::Ty<'tcx>, b: ty::Ty\n     })\n }\n \n-/// Recover the essential nodes of a desugared for loop:\n-/// `for pat in arg { body }` becomes `(pat, arg, body)`.\n-pub fn recover_for_loop(expr: &Expr) -> Option<(&Pat, &Expr, &Expr)> {\n-    if_let_chain! {[\n-        let ExprMatch(ref iterexpr, ref arms, _) = expr.node,\n-        let ExprCall(_, ref iterargs) = iterexpr.node,\n-        iterargs.len() == 1 && arms.len() == 1 && arms[0].guard.is_none(),\n-        let ExprLoop(ref block, _) = arms[0].body.node,\n-        block.stmts.is_empty(),\n-        let Some(ref loopexpr) = block.expr,\n-        let ExprMatch(_, ref innerarms, MatchSource::ForLoopDesugar) = loopexpr.node,\n-        innerarms.len() == 2 && innerarms[0].pats.len() == 1,\n-        let PatKind::TupleStruct(_, ref somepats, _) = innerarms[0].pats[0].node,\n-        somepats.len() == 1\n-    ], {\n-        return Some((&somepats[0],\n-                     &iterargs[0],\n-                     &innerarms[0].body));\n-    }}\n-    None\n-}\n-\n /// Return whether the given type is an `unsafe` function.\n pub fn type_is_unsafe_function(ty: ty::Ty) -> bool {\n     match ty.sty {"}, {"sha": "624c030cdd4487d3053ec918f06da4cbdeb83abf", "filename": "clippy_lints/src/utils/sugg.rs", "status": "added", "additions": 356, "deletions": 0, "changes": 356, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Futils%2Fsugg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fsugg.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -0,0 +1,356 @@\n+use rustc::hir;\n+use rustc::lint::{EarlyContext, LateContext};\n+use std::borrow::Cow;\n+use std;\n+use syntax::ast;\n+use syntax::util::parser::AssocOp;\n+use utils::{higher, snippet, snippet_opt};\n+use syntax::print::pprust::binop_to_string;\n+\n+/// A helper type to build suggestion correctly handling parenthesis.\n+pub enum Sugg<'a> {\n+    /// An expression that never needs parenthesis such as `1337` or `[0; 42]`.\n+    NonParen(Cow<'a, str>),\n+    /// An expression that does not fit in other variants.\n+    MaybeParen(Cow<'a, str>),\n+    /// A binary operator expression, including `as`-casts and explicit type coercion.\n+    BinOp(AssocOp, Cow<'a, str>),\n+}\n+\n+/// Literal constant `1`, for convenience.\n+pub const ONE: Sugg<'static> = Sugg::NonParen(Cow::Borrowed(\"1\"));\n+\n+impl<'a> std::fmt::Display for Sugg<'a> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+        match *self {\n+            Sugg::NonParen(ref s) | Sugg::MaybeParen(ref s) | Sugg::BinOp(_, ref s) => {\n+                s.fmt(f)\n+            }\n+        }\n+    }\n+}\n+\n+#[allow(wrong_self_convention)] // ok, because of the function `as_ty` method\n+impl<'a> Sugg<'a> {\n+    pub fn hir_opt(cx: &LateContext, expr: &hir::Expr) -> Option<Sugg<'a>> {\n+        snippet_opt(cx, expr.span).map(|snippet| {\n+            let snippet = Cow::Owned(snippet);\n+            match expr.node {\n+                hir::ExprAddrOf(..) |\n+                hir::ExprBox(..) |\n+                hir::ExprClosure(..) |\n+                hir::ExprIf(..) |\n+                hir::ExprUnary(..) |\n+                hir::ExprMatch(..) => Sugg::MaybeParen(snippet),\n+                hir::ExprAgain(..) |\n+                hir::ExprBlock(..) |\n+                hir::ExprBreak(..) |\n+                hir::ExprCall(..) |\n+                hir::ExprField(..) |\n+                hir::ExprIndex(..) |\n+                hir::ExprInlineAsm(..) |\n+                hir::ExprLit(..) |\n+                hir::ExprLoop(..) |\n+                hir::ExprMethodCall(..) |\n+                hir::ExprPath(..) |\n+                hir::ExprRepeat(..) |\n+                hir::ExprRet(..) |\n+                hir::ExprStruct(..) |\n+                hir::ExprTup(..) |\n+                hir::ExprTupField(..) |\n+                hir::ExprVec(..) |\n+                hir::ExprWhile(..) => Sugg::NonParen(snippet),\n+                hir::ExprAssign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+                hir::ExprAssignOp(op, ..) => Sugg::BinOp(hirbinop2assignop(op), snippet),\n+                hir::ExprBinary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(higher::binop(op.node)), snippet),\n+                hir::ExprCast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+                hir::ExprType(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+            }\n+        })\n+    }\n+\n+    pub fn hir(cx: &LateContext, expr: &hir::Expr, default: &'a str) -> Sugg<'a> {\n+        Self::hir_opt(cx, expr).unwrap_or_else(|| Sugg::NonParen(Cow::Borrowed(default)))\n+    }\n+\n+    pub fn ast(cx: &EarlyContext, expr: &ast::Expr, default: &'a str) -> Sugg<'a> {\n+        use syntax::ast::RangeLimits;\n+\n+        let snippet = snippet(cx, expr.span, default);\n+\n+        match expr.node {\n+            ast::ExprKind::AddrOf(..) |\n+            ast::ExprKind::Box(..) |\n+            ast::ExprKind::Closure(..) |\n+            ast::ExprKind::If(..) |\n+            ast::ExprKind::IfLet(..) |\n+            ast::ExprKind::InPlace(..) |\n+            ast::ExprKind::Unary(..) |\n+            ast::ExprKind::Match(..) => Sugg::MaybeParen(snippet),\n+            ast::ExprKind::Block(..) |\n+            ast::ExprKind::Break(..) |\n+            ast::ExprKind::Call(..) |\n+            ast::ExprKind::Continue(..) |\n+            ast::ExprKind::Field(..) |\n+            ast::ExprKind::ForLoop(..) |\n+            ast::ExprKind::Index(..) |\n+            ast::ExprKind::InlineAsm(..) |\n+            ast::ExprKind::Lit(..) |\n+            ast::ExprKind::Loop(..) |\n+            ast::ExprKind::Mac(..) |\n+            ast::ExprKind::MethodCall(..) |\n+            ast::ExprKind::Paren(..) |\n+            ast::ExprKind::Path(..) |\n+            ast::ExprKind::Repeat(..) |\n+            ast::ExprKind::Ret(..) |\n+            ast::ExprKind::Struct(..) |\n+            ast::ExprKind::Try(..) |\n+            ast::ExprKind::Tup(..) |\n+            ast::ExprKind::TupField(..) |\n+            ast::ExprKind::Vec(..) |\n+            ast::ExprKind::While(..) |\n+            ast::ExprKind::WhileLet(..) => Sugg::NonParen(snippet),\n+            ast::ExprKind::Range(.., RangeLimits::HalfOpen) => Sugg::BinOp(AssocOp::DotDot, snippet),\n+            ast::ExprKind::Range(.., RangeLimits::Closed) => Sugg::BinOp(AssocOp::DotDotDot, snippet),\n+            ast::ExprKind::Assign(..) => Sugg::BinOp(AssocOp::Assign, snippet),\n+            ast::ExprKind::AssignOp(op, ..) => Sugg::BinOp(astbinop2assignop(op), snippet),\n+            ast::ExprKind::Binary(op, ..) => Sugg::BinOp(AssocOp::from_ast_binop(op.node), snippet),\n+            ast::ExprKind::Cast(..) => Sugg::BinOp(AssocOp::As, snippet),\n+            ast::ExprKind::Type(..) => Sugg::BinOp(AssocOp::Colon, snippet),\n+        }\n+    }\n+\n+    /// Convenience method to create the `<lhs> && <rhs>` suggestion.\n+    pub fn and(self, rhs: Self) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::And, &self, &rhs)\n+    }\n+\n+    /// Convenience method to create the `<lhs> as <rhs>` suggestion.\n+    pub fn as_ty<R: std::fmt::Display>(self, rhs: R) -> Sugg<'static> {\n+        make_assoc(AssocOp::As, &self, &Sugg::NonParen(rhs.to_string().into()))\n+    }\n+\n+    /// Convenience method to create the `&<expr>` suggestion.\n+    pub fn addr(self) -> Sugg<'static> {\n+        make_unop(\"&\", self)\n+    }\n+\n+    /// Convenience method to create the `&mut <expr>` suggestion.\n+    pub fn mut_addr(self) -> Sugg<'static> {\n+        make_unop(\"&mut \", self)\n+    }\n+\n+    /// Convenience method to create the `*<expr>` suggestion.\n+    pub fn deref(self) -> Sugg<'static> {\n+        make_unop(\"*\", self)\n+    }\n+\n+    /// Convenience method to create the `<lhs>..<rhs>` or `<lhs>...<rhs>` suggestion.\n+    pub fn range(self, end: Self, limit: ast::RangeLimits) -> Sugg<'static> {\n+        match limit {\n+            ast::RangeLimits::HalfOpen => make_assoc(AssocOp::DotDot, &self, &end),\n+            ast::RangeLimits::Closed => make_assoc(AssocOp::DotDotDot, &self, &end),\n+        }\n+    }\n+\n+    /// Add parenthesis to any expression that might need them. Suitable to the `self` argument of\n+    /// a method call (eg. to build `bar.foo()` or `(1 + 2).foo()`).\n+    pub fn maybe_par(self) -> Self {\n+        match self {\n+            Sugg::NonParen(..) => self,\n+            Sugg::MaybeParen(sugg) | Sugg::BinOp(_, sugg) => Sugg::NonParen(format!(\"({})\", sugg).into()),\n+        }\n+    }\n+}\n+\n+impl<'a, 'b> std::ops::Add<Sugg<'b>> for Sugg<'a> {\n+    type Output = Sugg<'static>;\n+    fn add(self, rhs: Sugg<'b>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Add, &self, &rhs)\n+    }\n+}\n+\n+impl<'a, 'b> std::ops::Sub<Sugg<'b>> for Sugg<'a> {\n+    type Output = Sugg<'static>;\n+    fn sub(self, rhs: Sugg<'b>) -> Sugg<'static> {\n+        make_binop(ast::BinOpKind::Sub, &self, &rhs)\n+    }\n+}\n+\n+impl<'a> std::ops::Not for Sugg<'a> {\n+    type Output = Sugg<'static>;\n+    fn not(self) -> Sugg<'static> {\n+        make_unop(\"!\", self)\n+    }\n+}\n+\n+struct ParenHelper<T> {\n+    paren: bool,\n+    wrapped: T,\n+}\n+\n+impl<T> ParenHelper<T> {\n+    fn new(paren: bool, wrapped: T) -> Self {\n+        ParenHelper {\n+            paren: paren,\n+            wrapped: wrapped,\n+        }\n+    }\n+}\n+\n+impl<T: std::fmt::Display> std::fmt::Display for ParenHelper<T> {\n+    fn fmt(&self, f: &mut std::fmt::Formatter) -> Result<(), std::fmt::Error> {\n+        if self.paren {\n+            write!(f, \"({})\", self.wrapped)\n+        } else {\n+            self.wrapped.fmt(f)\n+        }\n+    }\n+}\n+\n+/// Build the string for `<op><expr>` adding parenthesis when necessary.\n+///\n+/// For convenience, the operator is taken as a string because all unary operators have the same\n+/// precedence.\n+pub fn make_unop(op: &str, expr: Sugg) -> Sugg<'static> {\n+    Sugg::MaybeParen(format!(\"{}{}\", op, expr.maybe_par()).into())\n+}\n+\n+/// Build the string for `<lhs> <op> <rhs>` adding parenthesis when necessary.\n+///\n+/// Precedence of shift operator relative to other arithmetic operation is often confusing so\n+/// parenthesis will always be added for a mix of these.\n+pub fn make_assoc(op: AssocOp, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+    fn is_shift(op: &AssocOp) -> bool {\n+        matches!(*op, AssocOp::ShiftLeft | AssocOp::ShiftRight)\n+    }\n+\n+    fn is_arith(op: &AssocOp) -> bool {\n+        matches!(*op, AssocOp::Add | AssocOp::Subtract | AssocOp::Multiply | AssocOp::Divide | AssocOp::Modulus)\n+    }\n+\n+    fn needs_paren(op: &AssocOp, other: &AssocOp, dir: Associativity) -> bool {\n+        other.precedence() < op.precedence() ||\n+            (other.precedence() == op.precedence() &&\n+                ((op != other && associativity(op) != dir) ||\n+                 (op == other && associativity(op) != Associativity::Both))) ||\n+             is_shift(op) && is_arith(other) ||\n+             is_shift(other) && is_arith(op)\n+    }\n+\n+    let lhs_paren = if let Sugg::BinOp(ref lop, _) = *lhs {\n+        needs_paren(&op, lop, Associativity::Left)\n+    } else {\n+        false\n+    };\n+\n+    let rhs_paren = if let Sugg::BinOp(ref rop, _) = *rhs {\n+        needs_paren(&op, rop, Associativity::Right)\n+    } else {\n+        false\n+    };\n+\n+    let lhs = ParenHelper::new(lhs_paren, lhs);\n+    let rhs = ParenHelper::new(rhs_paren, rhs);\n+    let sugg = match op {\n+        AssocOp::Add |\n+        AssocOp::BitAnd |\n+        AssocOp::BitOr |\n+        AssocOp::BitXor |\n+        AssocOp::Divide |\n+        AssocOp::Equal |\n+        AssocOp::Greater |\n+        AssocOp::GreaterEqual |\n+        AssocOp::LAnd |\n+        AssocOp::LOr |\n+        AssocOp::Less |\n+        AssocOp::LessEqual |\n+        AssocOp::Modulus |\n+        AssocOp::Multiply |\n+        AssocOp::NotEqual |\n+        AssocOp::ShiftLeft |\n+        AssocOp::ShiftRight |\n+        AssocOp::Subtract => format!(\"{} {} {}\", lhs, op.to_ast_binop().expect(\"Those are AST ops\").to_string(), rhs),\n+        AssocOp::Inplace => format!(\"in ({}) {}\", lhs, rhs),\n+        AssocOp::Assign => format!(\"{} = {}\", lhs, rhs),\n+        AssocOp::AssignOp(op) => format!(\"{} {}= {}\", lhs, binop_to_string(op), rhs),\n+        AssocOp::As => format!(\"{} as {}\", lhs, rhs),\n+        AssocOp::DotDot => format!(\"{}..{}\", lhs, rhs),\n+        AssocOp::DotDotDot => format!(\"{}...{}\", lhs, rhs),\n+        AssocOp::Colon => format!(\"{}: {}\", lhs, rhs),\n+    };\n+\n+    Sugg::BinOp(op, sugg.into())\n+}\n+\n+/// Convinience wrapper arround `make_assoc` and `AssocOp::from_ast_binop`.\n+pub fn make_binop(op: ast::BinOpKind, lhs: &Sugg, rhs: &Sugg) -> Sugg<'static> {\n+    make_assoc(AssocOp::from_ast_binop(op), lhs, rhs)\n+}\n+\n+#[derive(PartialEq, Eq)]\n+enum Associativity {\n+    Both,\n+    Left,\n+    None,\n+    Right,\n+}\n+\n+/// Return the associativity/fixity of an operator. The difference with `AssocOp::fixity` is that\n+/// an operator can be both left and right associative (such as `+`:\n+/// `a + b + c == (a + b) + c == a + (b + c)`.\n+///\n+/// Chained `as` and explicit `:` type coercion never need inner parenthesis so they are considered\n+/// associative.\n+fn associativity(op: &AssocOp) -> Associativity {\n+    use syntax::util::parser::AssocOp::*;\n+\n+    match *op {\n+        Inplace | Assign | AssignOp(_) => Associativity::Right,\n+        Add | BitAnd | BitOr | BitXor | LAnd | LOr | Multiply |\n+        As | Colon => Associativity::Both,\n+    Divide | Equal | Greater | GreaterEqual | Less | LessEqual | Modulus | NotEqual | ShiftLeft |\n+        ShiftRight | Subtract => Associativity::Left,\n+        DotDot | DotDotDot => Associativity::None\n+    }\n+}\n+\n+/// Convert a `hir::BinOp` to the corresponding assigning binary operator.\n+fn hirbinop2assignop(op: hir::BinOp) -> AssocOp {\n+    use rustc::hir::BinOp_::*;\n+    use syntax::parse::token::BinOpToken::*;\n+\n+    AssocOp::AssignOp(match op.node {\n+        BiAdd => Plus,\n+        BiBitAnd => And,\n+        BiBitOr => Or,\n+        BiBitXor => Caret,\n+        BiDiv => Slash,\n+        BiMul => Star,\n+        BiRem => Percent,\n+        BiShl => Shl,\n+        BiShr => Shr,\n+        BiSub => Minus,\n+        BiAnd | BiEq | BiGe | BiGt | BiLe | BiLt | BiNe | BiOr => panic!(\"This operator does not exist\"),\n+    })\n+}\n+\n+/// Convert an `ast::BinOp` to the corresponding assigning binary operator.\n+fn astbinop2assignop(op: ast::BinOp) -> AssocOp {\n+    use syntax::ast::BinOpKind::*;\n+    use syntax::parse::token::BinOpToken;\n+\n+    AssocOp::AssignOp(match op.node {\n+        Add => BinOpToken::Plus,\n+        BitAnd => BinOpToken::And,\n+        BitOr => BinOpToken::Or,\n+        BitXor => BinOpToken::Caret,\n+        Div => BinOpToken::Slash,\n+        Mul => BinOpToken::Star,\n+        Rem => BinOpToken::Percent,\n+        Shl => BinOpToken::Shl,\n+        Shr => BinOpToken::Shr,\n+        Sub => BinOpToken::Minus,\n+        And | Eq | Ge | Gt | Le | Lt | Ne | Or => panic!(\"This operator does not exist\"),\n+    })\n+}"}, {"sha": "114817989d8d1f9df158b8588575ead80641da0d", "filename": "clippy_lints/src/vec.rs", "status": "modified", "additions": 5, "deletions": 45, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/clippy_lints%2Fsrc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fvec.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -4,8 +4,7 @@ use rustc::hir::*;\n use rustc_const_eval::EvalHint::ExprTypeChecked;\n use rustc_const_eval::eval_const_expr_partial;\n use syntax::codemap::Span;\n-use syntax::ptr::P;\n-use utils::{is_expn_of, match_path, paths, recover_for_loop, snippet, span_lint_and_then};\n+use utils::{higher, snippet, span_lint_and_then};\n \n /// **What it does:** This lint warns about using `&vec![..]` when using `&[..]` would be possible.\n ///\n@@ -44,7 +43,7 @@ impl LateLintPass for Pass {\n         }}\n \n         // search for `for _ in vec![\u2026]`\n-        if let Some((_, arg, _)) = recover_for_loop(expr) {\n+        if let Some((_, arg, _)) = higher::for_loop(expr) {\n             // report the error around the `vec!` not inside `<std macros>:`\n             let span = cx.sess().codemap().source_callsite(arg.span);\n             check_vec_macro(cx, arg, span);\n@@ -53,18 +52,16 @@ impl LateLintPass for Pass {\n }\n \n fn check_vec_macro(cx: &LateContext, vec: &Expr, span: Span) {\n-    if let Some(vec_args) = unexpand(cx, vec) {\n-\n+    if let Some(vec_args) = higher::vec_macro(cx, vec) {\n         let snippet = match vec_args {\n-            Args::Repeat(elem, len) => {\n-                // Check that the length is a constant expression\n+            higher::VecArgs::Repeat(elem, len) => {\n                 if eval_const_expr_partial(cx.tcx, len, ExprTypeChecked, None).is_ok() {\n                     format!(\"&[{}; {}]\", snippet(cx, elem.span, \"elem\"), snippet(cx, len.span, \"len\")).into()\n                 } else {\n                     return;\n                 }\n             }\n-            Args::Vec(args) => {\n+            higher::VecArgs::Vec(args) => {\n                 if let Some(last) = args.iter().last() {\n                     let span = Span {\n                         lo: args[0].span.lo,\n@@ -85,40 +82,3 @@ fn check_vec_macro(cx: &LateContext, vec: &Expr, span: Span) {\n     }\n }\n \n-/// Represent the pre-expansion arguments of a `vec!` invocation.\n-pub enum Args<'a> {\n-    /// `vec![elem; len]`\n-    Repeat(&'a P<Expr>, &'a P<Expr>),\n-    /// `vec![a, b, c]`\n-    Vec(&'a [P<Expr>]),\n-}\n-\n-/// Returns the arguments of the `vec!` macro if this expression was expanded from `vec!`.\n-pub fn unexpand<'e>(cx: &LateContext, expr: &'e Expr) -> Option<Args<'e>> {\n-    if_let_chain!{[\n-        let ExprCall(ref fun, ref args) = expr.node,\n-        let ExprPath(_, ref path) = fun.node,\n-        is_expn_of(cx, fun.span, \"vec\").is_some()\n-    ], {\n-        return if match_path(path, &paths::VEC_FROM_ELEM) && args.len() == 2 {\n-            // `vec![elem; size]` case\n-            Some(Args::Repeat(&args[0], &args[1]))\n-        }\n-        else if match_path(path, &[\"into_vec\"]) && args.len() == 1 {\n-            // `vec![a, b, c]` case\n-            if_let_chain!{[\n-                let ExprBox(ref boxed) = args[0].node,\n-                let ExprVec(ref args) = boxed.node\n-            ], {\n-                return Some(Args::Vec(&*args));\n-            }}\n-\n-            None\n-        }\n-        else {\n-            None\n-        };\n-    }}\n-\n-    None\n-}"}, {"sha": "2b69e110f43d7749dc9e3d93d5c4053051428c81", "filename": "tests/compile-fail/assign_ops.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fassign_ops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fassign_ops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fassign_ops.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -8,15 +8,31 @@ fn main() {\n     i += 2; //~ ERROR assign operation detected\n     //~^ HELP replace it with\n     //~| SUGGESTION i = i + 2\n+    i += 2 + 17; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i + 2 + 17\n     i -= 6; //~ ERROR assign operation detected\n     //~^ HELP replace it with\n     //~| SUGGESTION i = i - 6\n+    i -= 2 - 1;\n+    //~^ ERROR assign operation detected\n+    //~| HELP replace it with\n+    //~| SUGGESTION i = i - (2 - 1)\n     i *= 5; //~ ERROR assign operation detected\n     //~^ HELP replace it with\n     //~| SUGGESTION i = i * 5\n+    i *= 1+5; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i * (1+5)\n     i /= 32; //~ ERROR assign operation detected\n     //~^ HELP replace it with\n     //~| SUGGESTION i = i / 32\n+    i /= 32 | 5; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i / (32 | 5)\n+    i /= 32 / 5; //~ ERROR assign operation detected\n+    //~^ HELP replace it with\n+    //~| SUGGESTION i = i / (32 / 5)\n     i %= 42; //~ ERROR assign operation detected\n     //~^ HELP replace it with\n     //~| SUGGESTION i = i % 42\n@@ -26,6 +42,10 @@ fn main() {\n     i <<= 9 + 6 - 7; //~ ERROR assign operation detected\n     //~^ HELP replace it with\n     //~| SUGGESTION i = i << (9 + 6 - 7)\n+    i += 1 << 5;\n+    //~^ ERROR assign operation detected\n+    //~| HELP replace it with\n+    //~| SUGGESTION i = i + (1 << 5)\n }\n \n #[allow(dead_code, unused_assignments)]"}, {"sha": "b23d6a6e4c186c19c237d927700fdd94b27a7ba2", "filename": "tests/compile-fail/collapsible_if.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fcollapsible_if.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fcollapsible_if.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fcollapsible_if.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -23,6 +23,42 @@ fn main() {\n         }\n     }\n \n+    if x == \"hello\" && x == \"world\" {\n+    //~^ ERROR this if statement can be collapsed\n+    //~| HELP try\n+    //~| SUGGESTION if x == \"hello\" && x == \"world\" && (y == \"world\" || y == \"hello\") {\n+        if y == \"world\" || y == \"hello\" {\n+            println!(\"Hello world!\");\n+        }\n+    }\n+\n+    if x == \"hello\" || x == \"world\" {\n+    //~^ ERROR this if statement can be collapsed\n+    //~| HELP try\n+    //~| SUGGESTION if (x == \"hello\" || x == \"world\") && y == \"world\" && y == \"hello\" {\n+        if y == \"world\" && y == \"hello\" {\n+            println!(\"Hello world!\");\n+        }\n+    }\n+\n+    if x == \"hello\" && x == \"world\" {\n+    //~^ ERROR this if statement can be collapsed\n+    //~| HELP try\n+    //~| SUGGESTION if x == \"hello\" && x == \"world\" && y == \"world\" && y == \"hello\" {\n+        if y == \"world\" && y == \"hello\" {\n+            println!(\"Hello world!\");\n+        }\n+    }\n+\n+    if 42 == 1337 {\n+    //~^ ERROR this if statement can be collapsed\n+    //~| HELP try\n+    //~| SUGGESTION if 42 == 1337 && 'a' != 'A' {\n+        if 'a' != 'A' {\n+            println!(\"world!\")\n+        }\n+    }\n+\n     // Collaspe `else { if .. }` to `else if ..`\n     if x == \"hello\" {\n         print!(\"Hello \");"}, {"sha": "ec3b75abb371c3a7db3605ffe2dc0f624337b25e", "filename": "tests/compile-fail/entry.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fentry.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -11,45 +11,51 @@ fn foo() {}\n \n fn insert_if_absent0<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { m.insert(k, v); }\n-    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| HELP Consider\n+    //~^ ERROR usage of `contains_key` followed by `insert` on a `HashMap`\n+    //~| HELP consider\n     //~| SUGGESTION m.entry(k).or_insert(v)\n }\n \n fn insert_if_absent1<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { foo(); m.insert(k, v); }\n-    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| NOTE Consider using `m.entry(k)`\n+    //~^ ERROR usage of `contains_key` followed by `insert` on a `HashMap`\n+    //~| HELP consider\n+    //~| SUGGESTION m.entry(k)\n }\n \n fn insert_if_absent2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { m.insert(k, v) } else { None };\n-    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| NOTE Consider using `m.entry(k)`\n+    //~^ ERROR usage of `contains_key` followed by `insert` on a `HashMap`\n+    //~| HELP consider\n+    //~| SUGGESTION m.entry(k)\n }\n \n fn insert_if_present2<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if m.contains_key(&k) { None } else { m.insert(k, v) };\n-    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| NOTE Consider using `m.entry(k)`\n+    //~^ ERROR usage of `contains_key` followed by `insert` on a `HashMap`\n+    //~| HELP consider\n+    //~| SUGGESTION m.entry(k)\n }\n \n fn insert_if_absent3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { foo(); m.insert(k, v) } else { None };\n-    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| NOTE Consider using `m.entry(k)`\n+    //~^ ERROR usage of `contains_key` followed by `insert` on a `HashMap`\n+    //~| HELP consider\n+    //~| SUGGESTION m.entry(k)\n }\n \n fn insert_if_present3<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, v: V) {\n     if m.contains_key(&k) { None } else { foo(); m.insert(k, v) };\n-    //~^ ERROR usage of `contains_key` followed by `insert` on `HashMap`\n-    //~| NOTE Consider using `m.entry(k)`\n+    //~^ ERROR usage of `contains_key` followed by `insert` on a `HashMap`\n+    //~| HELP consider\n+    //~| SUGGESTION m.entry(k)\n }\n \n fn insert_in_btreemap<K: Ord, V>(m: &mut BTreeMap<K, V>, k: K, v: V) {\n     if !m.contains_key(&k) { foo(); m.insert(k, v) } else { None };\n-    //~^ ERROR usage of `contains_key` followed by `insert` on `BTreeMap`\n-    //~| NOTE Consider using `m.entry(k)`\n+    //~^ ERROR usage of `contains_key` followed by `insert` on a `BTreeMap`\n+    //~| HELP consider\n+    //~| SUGGESTION m.entry(k)\n }\n \n fn insert_other_if_absent<K: Eq + Hash, V>(m: &mut HashMap<K, V>, k: K, o: K, v: V) {"}, {"sha": "314cc721425507dd3ebf3d01c578f93073c51d5c", "filename": "tests/compile-fail/float_cmp.rs", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Ffloat_cmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Ffloat_cmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffloat_cmp.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -40,23 +40,47 @@ fn main() {\n     ZERO == 0.0; //no error, comparison with zero is ok\n     ZERO + ZERO != 1.0; //no error, comparison with zero is ok\n \n-    ONE == 1f32; //~ERROR ==-comparison of f32 or f64\n-    ONE == (1.0 + 0.0); //~ERROR ==-comparison of f32 or f64\n-\n-    ONE + ONE == (ZERO + ONE + ONE); //~ERROR ==-comparison of f32 or f64\n-\n-    ONE != 2.0; //~ERROR !=-comparison of f32 or f64\n+    ONE == 1f32;\n+    //~^ ERROR strict comparison of f32 or f64\n+    //~| HELP within some error\n+    //~| SUGGESTION (ONE - 1f32).abs() < error\n+    ONE == 1.0 + 0.0;\n+    //~^ ERROR strict comparison of f32 or f64\n+    //~| HELP within some error\n+    //~| SUGGESTION (ONE - (1.0 + 0.0)).abs() < error\n+\n+    ONE + ONE == ZERO + ONE + ONE;\n+    //~^ ERROR strict comparison of f32 or f64\n+    //~| HELP within some error\n+    //~| SUGGESTION (ONE + ONE - (ZERO + ONE + ONE)).abs() < error\n+\n+    ONE != 2.0;\n+    //~^ ERROR strict comparison of f32 or f64\n+    //~| HELP within some error\n+    //~| SUGGESTION (ONE - 2.0).abs() < error\n     ONE != 0.0; // no error, comparison with zero is ok\n-    twice(ONE) != ONE; //~ERROR !=-comparison of f32 or f64\n-    ONE as f64 != 2.0; //~ERROR !=-comparison of f32 or f64\n+    twice(ONE) != ONE;\n+    //~^ ERROR strict comparison of f32 or f64\n+    //~| HELP within some error\n+    //~| SUGGESTION (twice(ONE) - ONE).abs() < error\n+    ONE as f64 != 2.0;\n+    //~^ ERROR strict comparison of f32 or f64\n+    //~| HELP within some error\n+    //~| SUGGESTION (ONE as f64 - 2.0).abs() < error\n     ONE as f64 != 0.0; // no error, comparison with zero is ok\n \n     let x : f64 = 1.0;\n \n-    x == 1.0; //~ERROR ==-comparison of f32 or f64\n+    x == 1.0;\n+    //~^ ERROR strict comparison of f32 or f64\n+    //~| HELP within some error\n+    //~| SUGGESTION (x - 1.0).abs() < error\n     x != 0f64; // no error, comparison with zero is ok\n \n-    twice(x) != twice(ONE as f64); //~ERROR !=-comparison of f32 or f64\n+    twice(x) != twice(ONE as f64);\n+    //~^ ERROR strict comparison of f32 or f64\n+    //~| HELP within some error\n+    //~| SUGGESTION (twice(x) - twice(ONE as f64)).abs() < error\n \n \n     x < 0.0; // no errors, lower or greater comparisons need no fuzzyness"}, {"sha": "bcb20be4ff462d715541b840c25b6cdd094ccc55", "filename": "tests/compile-fail/for_loop.rs", "status": "modified", "additions": 68, "deletions": 12, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Ffor_loop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Ffor_loop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ffor_loop.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -2,6 +2,7 @@\n #![plugin(clippy)]\n \n use std::collections::*;\n+use std::rc::Rc;\n \n static STATIC: [usize; 4] = [ 0,  1,  8, 16 ];\n const CONST: [usize; 4] = [ 0,  1,  8, 16 ];\n@@ -96,66 +97,108 @@ fn main() {\n     let mut vec = vec![1, 2, 3, 4];\n     let vec2 = vec![1, 2, 3, 4];\n     for i in 0..vec.len() {\n-        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in &vec`\n+        //~^ ERROR `i` is only used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in &vec {\n         println!(\"{}\", vec[i]);\n     }\n \n+    for i in 0..vec.len() { let _ = vec[i]; }\n+    //~^ ERROR `i` is only used to index `vec`\n+    //~| HELP consider\n+    //~| HELP consider\n+    //~| SUGGESTION for <item> in &vec { let _ = vec[i]; }\n+\n     // ICE #746\n     for j in 0..4 {\n         //~^ ERROR `j` is only used to index `STATIC`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in STATIC.iter().take(4) {\n         println!(\"{:?}\", STATIC[j]);\n     }\n \n     for j in 0..4 {\n         //~^ ERROR `j` is only used to index `CONST`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in CONST.iter().take(4) {\n         println!(\"{:?}\", CONST[j]);\n     }\n \n     for i in 0..vec.len() {\n-        //~^ ERROR `i` is used to index `vec`. Consider using `for (i, item) in vec.iter().enumerate()`\n+        //~^ ERROR `i` is used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for (i, <item>) in vec.iter().enumerate() {\n         println!(\"{} {}\", vec[i], i);\n     }\n     for i in 0..vec.len() {      // not an error, indexing more than one variable\n         println!(\"{} {}\", vec[i], vec2[i]);\n     }\n \n     for i in 0..vec.len() {\n-        //~^ ERROR `i` is only used to index `vec2`. Consider using `for item in vec2.iter().take(vec.len())`\n+        //~^ ERROR `i` is only used to index `vec2`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in vec2.iter().take(vec.len()) {\n         println!(\"{}\", vec2[i]);\n     }\n \n     for i in 5..vec.len() {\n-        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().skip(5)`\n+        //~^ ERROR `i` is only used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in vec.iter().skip(5) {\n         println!(\"{}\", vec[i]);\n     }\n \n     for i in 0..MAX_LEN {\n-        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(MAX_LEN)`\n+        //~^ ERROR `i` is only used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in vec.iter().take(MAX_LEN) {\n         println!(\"{}\", vec[i]);\n     }\n \n     for i in 0...MAX_LEN {\n-        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(MAX_LEN)`\n+        //~^ ERROR `i` is only used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in vec.iter().take(MAX_LEN + 1) {\n         println!(\"{}\", vec[i]);\n     }\n \n     for i in 5..10 {\n-        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(10).skip(5)`\n+        //~^ ERROR `i` is only used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in vec.iter().take(10).skip(5) {\n         println!(\"{}\", vec[i]);\n     }\n \n     for i in 5...10 {\n-        //~^ ERROR `i` is only used to index `vec`. Consider using `for item in vec.iter().take(10).skip(5)`\n+        //~^ ERROR `i` is only used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for <item> in vec.iter().take(10 + 1).skip(5) {\n         println!(\"{}\", vec[i]);\n     }\n \n     for i in 5..vec.len() {\n-        //~^ ERROR `i` is used to index `vec`. Consider using `for (i, item) in vec.iter().enumerate().skip(5)`\n+        //~^ ERROR `i` is used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for (i, <item>) in vec.iter().enumerate().skip(5) {\n         println!(\"{} {}\", vec[i], i);\n     }\n \n     for i in 5..10 {\n-        //~^ ERROR `i` is used to index `vec`. Consider using `for (i, item) in vec.iter().enumerate().take(10).skip(5)`\n+        //~^ ERROR `i` is used to index `vec`\n+        //~| HELP consider\n+        //~| HELP consider\n+        //~| SUGGESTION for (i, <item>) in vec.iter().enumerate().take(10).skip(5) {\n         println!(\"{} {}\", vec[i], i);\n     }\n \n@@ -346,10 +389,22 @@ fn main() {\n     for (_, v) in &m {\n         //~^ you seem to want to iterate on a map's values\n         //~| HELP use the corresponding method\n-        //~| SUGGESTION for v in m.values()\n+        //~| HELP use the corresponding method\n+        //~| SUGGESTION for v in m.values() {\n         let _v = v;\n     }\n \n+    let m : Rc<HashMap<u64, u64>> = Rc::new(HashMap::new());\n+    for (_, v) in &*m {\n+        //~^ you seem to want to iterate on a map's values\n+        //~| HELP use the corresponding method\n+        //~| HELP use the corresponding method\n+        //~| SUGGESTION for v in (*m).values() {\n+        let _v = v;\n+        // Here the `*` is not actually necesarry, but the test tests that we don't suggest\n+        // `in *m.values()` as we used to\n+    }\n+\n     let mut m : HashMap<u64, u64> = HashMap::new();\n     for (_, v) in &mut m {\n         // Ok, there is no values_mut method or equivalent\n@@ -361,7 +416,8 @@ fn main() {\n     for (k, _value) in rm {\n         //~^ you seem to want to iterate on a map's keys\n         //~| HELP use the corresponding method\n-        //~| SUGGESTION for k in rm.keys()\n+        //~| HELP use the corresponding method\n+        //~| SUGGESTION for k in rm.keys() {\n         let _k = k;\n     }\n "}, {"sha": "f64cceb5c34711f6c7f6ae0246ad76cd8c93d5a8", "filename": "tests/compile-fail/matches.rs", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fmatches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fmatches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fmatches.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -112,7 +112,7 @@ fn match_bool() {\n \n     match test {\n     //~^ ERROR you seem to be trying to match on a boolean expression\n-    //~| HELP try\n+    //~| HELP consider\n     //~| SUGGESTION if test { 0 } else { 42 };\n         true => 0,\n         false => 42,\n@@ -121,31 +121,40 @@ fn match_bool() {\n     let option = 1;\n     match option == 1 {\n     //~^ ERROR you seem to be trying to match on a boolean expression\n-    //~| HELP try\n+    //~| HELP consider\n     //~| SUGGESTION if option == 1 { 1 } else { 0 };\n         true => 1,\n         false => 0,\n     };\n \n     match test {\n     //~^ ERROR you seem to be trying to match on a boolean expression\n-    //~| HELP try\n-    //~^^ SUGGESTION if !test { println!(\"Noooo!\"); };\n+    //~| HELP consider\n+    //~| SUGGESTION if !test { println!(\"Noooo!\"); };\n         true => (),\n         false => { println!(\"Noooo!\"); }\n     };\n \n     match test {\n     //~^ ERROR you seem to be trying to match on a boolean expression\n-    //~| HELP try\n-    //~^^ SUGGESTION if !test { println!(\"Noooo!\"); };\n+    //~| HELP consider\n+    //~| SUGGESTION if !test { println!(\"Noooo!\"); };\n+        false => { println!(\"Noooo!\"); }\n+        _ => (),\n+    };\n+\n+    match test && test {\n+    //~^ ERROR you seem to be trying to match on a boolean expression\n+    //~| HELP consider\n+    //~| SUGGESTION if !(test && test) { println!(\"Noooo!\"); };\n+    //~| ERROR equal expressions as operands\n         false => { println!(\"Noooo!\"); }\n         _ => (),\n     };\n \n     match test {\n     //~^ ERROR you seem to be trying to match on a boolean expression\n-    //~| HELP try\n+    //~| HELP consider\n     //~| SUGGESTION if test { println!(\"Yes!\"); } else { println!(\"Noooo!\"); };\n         false => { println!(\"Noooo!\"); }\n         true => { println!(\"Yes!\"); }"}, {"sha": "fb81d44308a0e8f08e9dc9f02f99f6813bbe0609", "filename": "tests/compile-fail/needless_bool.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fneedless_bool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Fneedless_bool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fneedless_bool.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -5,21 +5,28 @@\n #[allow(if_same_then_else)]\n fn main() {\n     let x = true;\n+    let y = false;\n     if x { true } else { true }; //~ERROR this if-then-else expression will always return true\n     if x { false } else { false }; //~ERROR this if-then-else expression will always return false\n     if x { true } else { false };\n     //~^ ERROR this if-then-else expression returns a bool literal\n     //~| HELP you can reduce it to\n-    //~| SUGGESTION `x`\n+    //~| SUGGESTION x\n     if x { false } else { true };\n     //~^ ERROR this if-then-else expression returns a bool literal\n     //~| HELP you can reduce it to\n-    //~| SUGGESTION `!x`\n+    //~| SUGGESTION !x\n+    if x && y { false } else { true };\n+    //~^ ERROR this if-then-else expression returns a bool literal\n+    //~| HELP you can reduce it to\n+    //~| SUGGESTION !(x && y)\n     if x { x } else { false }; // would also be questionable, but we don't catch this yet\n     bool_ret(x);\n     bool_ret2(x);\n     bool_ret3(x);\n+    bool_ret5(x, x);\n     bool_ret4(x);\n+    bool_ret6(x, x);\n }\n \n #[allow(if_same_then_else, needless_return)]\n@@ -39,13 +46,29 @@ fn bool_ret3(x: bool) -> bool {\n     if x { return true } else { return false };\n     //~^ ERROR this if-then-else expression returns a bool literal\n     //~| HELP you can reduce it to\n-    //~| SUGGESTION `return x`\n+    //~| SUGGESTION return x\n+}\n+\n+#[allow(needless_return)]\n+fn bool_ret5(x: bool, y: bool) -> bool {\n+    if x && y { return true } else { return false };\n+    //~^ ERROR this if-then-else expression returns a bool literal\n+    //~| HELP you can reduce it to\n+    //~| SUGGESTION return x && y\n }\n \n #[allow(needless_return)]\n fn bool_ret4(x: bool) -> bool {\n     if x { return false } else { return true };\n     //~^ ERROR this if-then-else expression returns a bool literal\n     //~| HELP you can reduce it to\n-    //~| SUGGESTION `return !x`\n+    //~| SUGGESTION return !x\n+}\n+\n+#[allow(needless_return)]\n+fn bool_ret6(x: bool, y: bool) -> bool {\n+    if x && y { return false } else { return true };\n+    //~^ ERROR this if-then-else expression returns a bool literal\n+    //~| HELP you can reduce it to\n+    //~| SUGGESTION return !(x && y)\n }"}, {"sha": "b2240cffb1a6638058fec7b45ab7682d4cb21aed", "filename": "tests/compile-fail/toplevel_ref_arg.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Ftoplevel_ref_arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Ftoplevel_ref_arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftoplevel_ref_arg.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -20,11 +20,16 @@ fn main() {\n   //~| HELP try\n   //~| SUGGESTION let x = &1;\n \n-  let ref y : (&_, u8) = (&1, 2);\n+  let ref y: (&_, u8) = (&1, 2);\n   //~^ ERROR `ref` on an entire `let` pattern is discouraged\n   //~| HELP try\n   //~| SUGGESTION let y: (&_, u8) = &(&1, 2);\n \n+  let ref z = 1 + 2;\n+  //~^ ERROR `ref` on an entire `let` pattern is discouraged\n+  //~| HELP try\n+  //~| SUGGESTION let z = &(1 + 2);\n+\n   let (ref x, _) = (1,2); // okay, not top level\n   println!(\"The answer is {}.\", x);\n }"}, {"sha": "1344858996e999c7355d2cf740a4ee4d6cd93911", "filename": "tests/compile-fail/transmute.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ad1cd990549fdfc8ae9dcd4ea7eea851017eb042/tests%2Fcompile-fail%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Ftransmute.rs?ref=ad1cd990549fdfc8ae9dcd4ea7eea851017eb042", "patch": "@@ -62,6 +62,7 @@ unsafe fn _ptr_to_ref<T, U>(p: *const T, m: *mut T, o: *const U, om: *mut U) {\n     //~^ ERROR transmute from a pointer type (`*mut T`) to a reference type (`&mut T`)\n     //~| HELP try\n     //~| SUGGESTION = &mut *(p as *mut T);\n+    let _ = &mut *(p as *mut T);\n \n     let _: &T = std::mem::transmute(o);\n     //~^ ERROR transmute from a pointer type (`*const U`) to a reference type (`&T`)\n@@ -110,6 +111,13 @@ fn useless() {\n         //~^ ERROR transmute from an integer to a pointer\n         //~| HELP try\n         //~| SUGGESTION 5_isize as *const usize\n+        let _  = 5_isize as *const usize;\n+\n+        let _: *const usize = std::mem::transmute(1+1usize);\n+        //~^ ERROR transmute from an integer to a pointer\n+        //~| HELP try\n+        //~| SUGGESTION (1+1usize) as *const usize\n+        let _  = (1+1_usize) as *const usize;\n     }\n }\n "}]}