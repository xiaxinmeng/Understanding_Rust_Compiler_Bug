{"sha": "abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFiYWU1ZTdlMjU4ZjI1NmNiZGI0ZmEyYTU4ZjU4ZWNiMDk1YmE2MjY=", "commit": {"author": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-09-24T15:24:34Z"}, "committer": {"name": "Ariel Ben-Yehuda", "email": "ariel.byd@gmail.com", "date": "2016-10-26T19:41:17Z"}, "message": "split the exhaustiveness-checking logic to its own module\n\n`check_match` is now left with its grab bag of random checks.", "tree": {"sha": "1edb0fd715df789b8fb27027f6c7f4caabe2a8f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1edb0fd715df789b8fb27027f6c7f4caabe2a8f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "html_url": "https://github.com/rust-lang/rust/commit/abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/comments", "author": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "committer": {"login": "arielb1", "id": 1830974, "node_id": "MDQ6VXNlcjE4MzA5NzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1830974?v=4", "gravatar_id": "", "url": "https://api.github.com/users/arielb1", "html_url": "https://github.com/arielb1", "followers_url": "https://api.github.com/users/arielb1/followers", "following_url": "https://api.github.com/users/arielb1/following{/other_user}", "gists_url": "https://api.github.com/users/arielb1/gists{/gist_id}", "starred_url": "https://api.github.com/users/arielb1/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/arielb1/subscriptions", "organizations_url": "https://api.github.com/users/arielb1/orgs", "repos_url": "https://api.github.com/users/arielb1/repos", "events_url": "https://api.github.com/users/arielb1/events{/privacy}", "received_events_url": "https://api.github.com/users/arielb1/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48387c8bd9b672c3640299d191969f7dc1e5a490", "url": "https://api.github.com/repos/rust-lang/rust/commits/48387c8bd9b672c3640299d191969f7dc1e5a490", "html_url": "https://github.com/rust-lang/rust/commit/48387c8bd9b672c3640299d191969f7dc1e5a490"}], "stats": {"total": 1408, "additions": 726, "deletions": 682}, "files": [{"sha": "dd894de96eefbfb816cdc9767aa6d1abe3e1e078", "filename": "src/librustc_const_eval/_match.rs", "status": "added", "additions": 696, "deletions": 0, "changes": 696, "blob_url": "https://github.com/rust-lang/rust/blob/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/src%2Flibrustc_const_eval%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/src%2Flibrustc_const_eval%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2F_match.rs?ref=abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "patch": "@@ -0,0 +1,696 @@\n+// Copyright 2012-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use self::Constructor::*;\n+use self::Usefulness::*;\n+use self::WitnessPreference::*;\n+\n+use rustc::middle::const_val::ConstVal;\n+use eval::{eval_const_expr, compare_const_vals};\n+\n+use rustc::hir::def::*;\n+use rustc::hir::def_id::{DefId};\n+use rustc::hir::pat_util::def_to_path;\n+use rustc::ty::{self, Ty, TyCtxt};\n+\n+use std::cmp::Ordering;\n+use std::fmt;\n+use std::iter::{FromIterator, IntoIterator, repeat};\n+\n+use rustc::hir;\n+use rustc::hir::{Pat, PatKind};\n+use rustc::hir::print::pat_to_string;\n+use rustc::util::common::ErrorReported;\n+\n+use syntax::ast::{self, DUMMY_NODE_ID};\n+use syntax::codemap::Spanned;\n+use syntax::ptr::P;\n+use syntax_pos::{Span, DUMMY_SP};\n+\n+pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n+    id: DUMMY_NODE_ID,\n+    node: PatKind::Wild,\n+    span: DUMMY_SP\n+};\n+\n+pub const DUMMY_WILD_PATTERN : Pattern<'static, 'static> = Pattern {\n+    pat: DUMMY_WILD_PAT,\n+    pattern_ty: None\n+};\n+\n+#[derive(Copy, Clone)]\n+pub struct Pattern<'a, 'tcx> {\n+    pat: &'a Pat,\n+    pattern_ty: Option<Ty<'tcx>>\n+}\n+\n+impl<'a, 'tcx> Pattern<'a, 'tcx> {\n+    fn as_raw(self) -> &'a Pat {\n+        let mut pat = self.pat;\n+\n+        while let PatKind::Binding(.., Some(ref s)) = pat.node {\n+            pat = s;\n+        }\n+\n+        return pat;\n+    }\n+\n+    pub fn span(self) -> Span {\n+        self.pat.span\n+    }\n+}\n+\n+impl<'a, 'tcx> fmt::Debug for Pattern<'a, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"{}: {:?}\", pat_to_string(self.pat), self.pattern_ty)\n+    }\n+}\n+\n+pub struct Matrix<'a, 'tcx>(Vec<Vec<Pattern<'a, 'tcx>>>);\n+\n+impl<'a, 'tcx> Matrix<'a, 'tcx> {\n+    pub fn empty() -> Self {\n+        Matrix(vec![])\n+    }\n+\n+    pub fn push(&mut self, row: Vec<Pattern<'a, 'tcx>>) {\n+        self.0.push(row)\n+    }\n+}\n+\n+/// Pretty-printer for matrices of patterns, example:\n+/// ++++++++++++++++++++++++++\n+/// + _     + []             +\n+/// ++++++++++++++++++++++++++\n+/// + true  + [First]        +\n+/// ++++++++++++++++++++++++++\n+/// + true  + [Second(true)] +\n+/// ++++++++++++++++++++++++++\n+/// + false + [_]            +\n+/// ++++++++++++++++++++++++++\n+/// + _     + [_, _, ..tail] +\n+/// ++++++++++++++++++++++++++\n+impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"\\n\")?;\n+\n+        let &Matrix(ref m) = self;\n+        let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n+            row.iter().map(|pat| format!(\"{:?}\", pat)).collect()\n+        }).collect();\n+\n+        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n+        assert!(m.iter().all(|row| row.len() == column_count));\n+        let column_widths: Vec<usize> = (0..column_count).map(|col| {\n+            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n+        }).collect();\n+\n+        let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n+        let br = repeat('+').take(total_width).collect::<String>();\n+        write!(f, \"{}\\n\", br)?;\n+        for row in pretty_printed_matrix {\n+            write!(f, \"+\")?;\n+            for (column, pat_str) in row.into_iter().enumerate() {\n+                write!(f, \" \")?;\n+                write!(f, \"{:1$}\", pat_str, column_widths[column])?;\n+                write!(f, \" +\")?;\n+            }\n+            write!(f, \"\\n\")?;\n+            write!(f, \"{}\\n\", br)?;\n+        }\n+        Ok(())\n+    }\n+}\n+\n+impl<'a, 'tcx> FromIterator<Vec<Pattern<'a, 'tcx>>> for Matrix<'a, 'tcx> {\n+    fn from_iter<T: IntoIterator<Item=Vec<Pattern<'a, 'tcx>>>>(iter: T) -> Self\n+    {\n+        Matrix(iter.into_iter().collect())\n+    }\n+}\n+\n+//NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n+pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n+    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    pub param_env: ty::ParameterEnvironment<'tcx>,\n+}\n+\n+#[derive(Clone, Debug, PartialEq)]\n+pub enum Constructor {\n+    /// The constructor of all patterns that don't vary by constructor,\n+    /// e.g. struct patterns and fixed-length arrays.\n+    Single,\n+    /// Enum variants.\n+    Variant(DefId),\n+    /// Literal values.\n+    ConstantValue(ConstVal),\n+    /// Ranges of literal values (2..5).\n+    ConstantRange(ConstVal, ConstVal),\n+    /// Array patterns of length n.\n+    Slice(usize),\n+}\n+\n+impl Constructor {\n+    fn variant_for_adt<'tcx, 'container, 'a>(&self,\n+                                             adt: &'a ty::AdtDefData<'tcx, 'container>)\n+                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n+        match self {\n+            &Variant(vid) => adt.variant_with_id(vid),\n+            _ => adt.struct_variant()\n+        }\n+    }\n+}\n+\n+#[derive(Clone, PartialEq)]\n+pub enum Usefulness {\n+    Useful,\n+    UsefulWithWitness(Vec<P<Pat>>),\n+    NotUseful\n+}\n+\n+#[derive(Copy, Clone)]\n+pub enum WitnessPreference {\n+    ConstructWitness,\n+    LeaveOutWitness\n+}\n+\n+fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n+    let node = match value {\n+        &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n+        _ => bug!()\n+    };\n+    P(hir::Expr {\n+        id: DUMMY_NODE_ID,\n+        node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n+        span: DUMMY_SP,\n+        attrs: ast::ThinVec::new(),\n+    })\n+}\n+\n+/// Constructs a partial witness for a pattern given a list of\n+/// patterns expanded by the specialization step.\n+///\n+/// When a pattern P is discovered to be useful, this function is used bottom-up\n+/// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n+/// of values, V, where each value in that set is not covered by any previously\n+/// used patterns and is covered by the pattern P'. Examples:\n+///\n+/// left_ty: tuple of 3 elements\n+/// pats: [10, 20, _]           => (10, 20, _)\n+///\n+/// left_ty: struct X { a: (bool, &'static str), b: usize}\n+/// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n+fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n+                              pats: Vec<&Pat>, left_ty: Ty<'tcx>) -> P<Pat> {\n+    let pats_len = pats.len();\n+    let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n+    let pat = match left_ty.sty {\n+        ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n+\n+        ty::TyAdt(adt, _) => {\n+            let v = ctor.variant_for_adt(adt);\n+            match v.ctor_kind {\n+                CtorKind::Fictive => {\n+                    let field_pats: hir::HirVec<_> = v.fields.iter()\n+                        .zip(pats)\n+                        .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n+                        .map(|(field, pat)| Spanned {\n+                            span: DUMMY_SP,\n+                            node: hir::FieldPat {\n+                                name: field.name,\n+                                pat: pat,\n+                                is_shorthand: false,\n+                            }\n+                        }).collect();\n+                    let has_more_fields = field_pats.len() < pats_len;\n+                    PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n+                }\n+                CtorKind::Fn => {\n+                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n+                }\n+                CtorKind::Const => {\n+                    PatKind::Path(None, def_to_path(cx.tcx, v.did))\n+                }\n+            }\n+        }\n+\n+        ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n+            assert_eq!(pats_len, 1);\n+            PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n+        }\n+\n+        ty::TySlice(_) => match ctor {\n+            &Slice(n) => {\n+                assert_eq!(pats_len, n);\n+                PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n+            },\n+            _ => unreachable!()\n+        },\n+\n+        ty::TyArray(_, len) => {\n+            assert_eq!(pats_len, len);\n+            PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n+        }\n+\n+        _ => {\n+            match *ctor {\n+                ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n+                _ => PatKind::Wild,\n+            }\n+        }\n+    };\n+\n+    P(hir::Pat {\n+        id: DUMMY_NODE_ID,\n+        node: pat,\n+        span: DUMMY_SP\n+    })\n+}\n+\n+fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n+                       left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n+    let used_constructors: Vec<Constructor> = rows.iter()\n+        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length))\n+        .collect();\n+    all_constructors(cx, left_ty, max_slice_length)\n+        .into_iter()\n+        .filter(|c| !used_constructors.contains(c))\n+        .collect()\n+}\n+\n+/// This determines the set of all possible constructors of a pattern matching\n+/// values of type `left_ty`. For vectors, this would normally be an infinite set\n+/// but is instead bounded by the maximum fixed length of slice patterns in\n+/// the column of patterns being analyzed.\n+fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n+                    max_slice_length: usize) -> Vec<Constructor> {\n+    match left_ty.sty {\n+        ty::TyBool =>\n+            [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n+        ty::TySlice(_) =>\n+            (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n+        ty::TyAdt(def, _) if def.is_enum() =>\n+            def.variants.iter().map(|v| Variant(v.did)).collect(),\n+        _ => vec![Single]\n+    }\n+}\n+\n+// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n+//\n+// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n+// vectors `m` is defined as there being a set of inputs that will match `v`\n+// but not any of the sets in `m`.\n+//\n+// This is used both for reachability checking (if a pattern isn't useful in\n+// relation to preceding patterns, it is not reachable) and exhaustiveness\n+// checking (if a wildcard pattern is useful in relation to a matrix, the\n+// matrix isn't exhaustive).\n+\n+// Note: is_useful doesn't work on empty types, as the paper notes.\n+// So it assumes that v is non-empty.\n+pub fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n+                           matrix: &Matrix<'a, 'tcx>,\n+                           v: &[Pattern<'a, 'tcx>],\n+                           witness: WitnessPreference)\n+                           -> Usefulness {\n+    let &Matrix(ref rows) = matrix;\n+    debug!(\"is_useful({:?}, {:?})\", matrix, v);\n+    if rows.is_empty() {\n+        return match witness {\n+            ConstructWitness => UsefulWithWitness(vec!()),\n+            LeaveOutWitness => Useful\n+        };\n+    }\n+    if rows[0].is_empty() {\n+        return NotUseful;\n+    }\n+    assert!(rows.iter().all(|r| r.len() == v.len()));\n+    let left_ty = match rows.iter().filter_map(|r| r[0].pattern_ty).next()\n+        .or_else(|| v[0].pattern_ty)\n+    {\n+        Some(ty) => ty,\n+        None => {\n+            // all patterns are wildcards - we can pick any type we want\n+            cx.tcx.types.bool\n+        }\n+    };\n+\n+    let max_slice_length = rows.iter().filter_map(|row| match row[0].pat.node {\n+        PatKind::Slice(ref before, _, ref after) => Some(before.len() + after.len()),\n+        _ => None\n+    }).max().map_or(0, |v| v + 1);\n+\n+    let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n+    debug!(\"is_useful - pat_constructors = {:?} left_ty = {:?}\", constructors,\n+           left_ty);\n+    if constructors.is_empty() {\n+        let constructors = missing_constructors(cx, matrix, left_ty, max_slice_length);\n+        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n+        if constructors.is_empty() {\n+            all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n+                match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n+                    UsefulWithWitness(pats) => UsefulWithWitness({\n+                        let arity = constructor_arity(cx, &c, left_ty);\n+                        let mut result = {\n+                            let pat_slice = &pats[..];\n+                            let subpats: Vec<_> = (0..arity).map(|i| {\n+                                pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n+                            }).collect();\n+                            vec![construct_witness(cx, &c, subpats, left_ty)]\n+                        };\n+                        result.extend(pats.into_iter().skip(arity));\n+                        result\n+                    }),\n+                    result => result\n+                }\n+            }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+        } else {\n+            let matrix = rows.iter().filter_map(|r| {\n+                match r[0].as_raw().node {\n+                    PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n+                    _ => None,\n+                }\n+            }).collect();\n+            match is_useful(cx, &matrix, &v[1..], witness) {\n+                UsefulWithWitness(pats) => {\n+                    let mut new_pats: Vec<_> = constructors.into_iter().map(|constructor| {\n+                        let arity = constructor_arity(cx, &constructor, left_ty);\n+                        let wild_pats = vec![DUMMY_WILD_PAT; arity];\n+                        construct_witness(cx, &constructor, wild_pats, left_ty)\n+                    }).collect();\n+                    new_pats.extend(pats);\n+                    UsefulWithWitness(new_pats)\n+                },\n+                result => result\n+            }\n+        }\n+    } else {\n+        constructors.into_iter().map(|c|\n+            is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness)\n+        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n+    }\n+}\n+\n+fn is_useful_specialized<'a, 'tcx>(\n+    cx: &MatchCheckCtxt<'a, 'tcx>,\n+    &Matrix(ref m): &Matrix<'a, 'tcx>,\n+    v: &[Pattern<'a, 'tcx>],\n+    ctor: Constructor,\n+    lty: Ty<'tcx>,\n+    witness: WitnessPreference) -> Usefulness\n+{\n+    let arity = constructor_arity(cx, &ctor, lty);\n+    let matrix = Matrix(m.iter().filter_map(|r| {\n+        specialize(cx, &r[..], &ctor, 0, arity)\n+    }).collect());\n+    match specialize(cx, v, &ctor, 0, arity) {\n+        Some(v) => is_useful(cx, &matrix, &v[..], witness),\n+        None => NotUseful\n+    }\n+}\n+\n+/// Determines the constructors that the given pattern can be specialized to.\n+///\n+/// In most cases, there's only one constructor that a specific pattern\n+/// represents, such as a specific enum variant or a specific literal value.\n+/// Slice patterns, however, can match slices of different lengths. For instance,\n+/// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n+///\n+/// On the other hand, a wild pattern and an identifier pattern cannot be\n+/// specialized in any way.\n+fn pat_constructors(cx: &MatchCheckCtxt, p: Pattern,\n+                    left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n+    let pat = p.as_raw();\n+    match pat.node {\n+        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n+            match cx.tcx.expect_def(pat.id) {\n+                Def::Variant(id) | Def::VariantCtor(id, _) => vec![Variant(id)],\n+                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n+                Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n+                    span_bug!(p.span(), \"const pattern should've been rewritten\"),\n+                def => span_bug!(p.span(), \"pat_constructors: unexpected definition {:?}\", def),\n+            },\n+        PatKind::Lit(ref expr) =>\n+            vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n+        PatKind::Range(ref lo, ref hi) =>\n+            vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))],\n+        PatKind::Slice(ref before, ref slice, ref after) =>\n+            match left_ty.sty {\n+                ty::TyArray(..) => vec![Single],\n+                ty::TySlice(_) if slice.is_some() => {\n+                    (before.len() + after.len()..max_slice_length+1)\n+                        .map(|length| Slice(length))\n+                        .collect()\n+                }\n+                ty::TySlice(_) => vec!(Slice(before.len() + after.len())),\n+                _ => span_bug!(pat.span, \"pat_constructors: unexpected \\\n+                                          slice pattern type {:?}\", left_ty)\n+            },\n+        PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n+            vec![Single],\n+        PatKind::Binding(..) | PatKind::Wild =>\n+            vec![],\n+    }\n+}\n+\n+/// This computes the arity of a constructor. The arity of a constructor\n+/// is how many subpattern patterns of that constructor should be expanded to.\n+///\n+/// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n+/// A struct pattern's arity is the number of fields it contains, etc.\n+pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n+    debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n+    match ty.sty {\n+        ty::TyTuple(ref fs) => fs.len(),\n+        ty::TyBox(_) => 1,\n+        ty::TySlice(_) => match *ctor {\n+            Slice(length) => length,\n+            ConstantValue(_) => {\n+                // TODO: this is utterly wrong, but required for byte arrays\n+                0\n+            }\n+            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n+        },\n+        ty::TyRef(..) => 1,\n+        ty::TyAdt(adt, _) => {\n+            ctor.variant_for_adt(adt).fields.len()\n+        }\n+        ty::TyArray(_, n) => n,\n+        _ => 0\n+    }\n+}\n+\n+fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n+                                ctor: &Constructor,\n+                                from: &ConstVal, to: &ConstVal)\n+                                -> Result<bool, ErrorReported> {\n+    let (c_from, c_to) = match *ctor {\n+        ConstantValue(ref value)        => (value, value),\n+        ConstantRange(ref from, ref to) => (from, to),\n+        Single                          => return Ok(true),\n+        _                               => bug!()\n+    };\n+    let cmp_from = compare_const_vals(tcx, span, c_from, from)?;\n+    let cmp_to = compare_const_vals(tcx, span, c_to, to)?;\n+    Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n+}\n+\n+pub fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n+                              pat: &'a Pat)\n+                              -> Pattern<'a, 'tcx>\n+{\n+    let pat_ty = cx.tcx.pat_ty(pat);\n+    Pattern {\n+        pat: pat,\n+        pattern_ty: Some(match pat.node {\n+            PatKind::Binding(hir::BindByRef(..), ..) => {\n+                pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n+            }\n+            _ => pat_ty\n+        })\n+    }\n+}\n+\n+/// This is the main specialization step. It expands the first pattern in the given row\n+/// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n+/// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n+///\n+/// OTOH, slice patterns with a subslice pattern (..tail) can be expanded into multiple\n+/// different patterns.\n+/// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n+/// fields filled with wild patterns.\n+fn specialize<'a, 'b, 'tcx>(\n+    cx: &MatchCheckCtxt<'b, 'tcx>,\n+    r: &[Pattern<'a, 'tcx>],\n+    constructor: &Constructor, col: usize, arity: usize)\n+    -> Option<Vec<Pattern<'a, 'tcx>>>\n+{\n+    let pat = r[col].as_raw();\n+    let &Pat {\n+        id: pat_id, ref node, span: pat_span\n+    } = pat;\n+    let wpat = |pat: &'a Pat| wrap_pat(cx, pat);\n+\n+    let head: Option<Vec<Pattern>> = match *node {\n+        PatKind::Binding(..) | PatKind::Wild =>\n+            Some(vec![DUMMY_WILD_PATTERN; arity]),\n+\n+        PatKind::Path(..) => {\n+            match cx.tcx.expect_def(pat_id) {\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n+                    span_bug!(pat_span, \"const pattern should've \\\n+                                         been rewritten\"),\n+                Def::VariantCtor(id, CtorKind::Const) if *constructor != Variant(id) => None,\n+                Def::VariantCtor(_, CtorKind::Const) |\n+                Def::StructCtor(_, CtorKind::Const) => Some(Vec::new()),\n+                def => span_bug!(pat_span, \"specialize: unexpected \\\n+                                          definition {:?}\", def),\n+            }\n+        }\n+\n+        PatKind::TupleStruct(_, ref args, ddpos) => {\n+            match cx.tcx.expect_def(pat_id) {\n+                Def::Const(..) | Def::AssociatedConst(..) =>\n+                    span_bug!(pat_span, \"const pattern should've \\\n+                                         been rewritten\"),\n+                Def::VariantCtor(id, CtorKind::Fn) if *constructor != Variant(id) => None,\n+                Def::VariantCtor(_, CtorKind::Fn) |\n+                Def::StructCtor(_, CtorKind::Fn) => {\n+                    match ddpos {\n+                        Some(ddpos) => {\n+                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n+                                wpat(p)\n+                            }).collect();\n+                            pats.extend(repeat(DUMMY_WILD_PATTERN).take(arity - args.len()));\n+                            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n+                            Some(pats)\n+                        }\n+                        None => Some(args.iter().map(|p| wpat(p)).collect())\n+                    }\n+                }\n+                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def)\n+            }\n+        }\n+\n+        PatKind::Struct(_, ref pattern_fields, _) => {\n+            let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n+            let variant = constructor.variant_for_adt(adt);\n+            let def_variant = adt.variant_of_def(cx.tcx.expect_def(pat_id));\n+            if variant.did == def_variant.did {\n+                Some(variant.fields.iter().map(|sf| {\n+                    match pattern_fields.iter().find(|f| f.node.name == sf.name) {\n+                        Some(ref f) => wpat(&f.node.pat),\n+                        _ => DUMMY_WILD_PATTERN\n+                    }\n+                }).collect())\n+            } else {\n+                None\n+            }\n+        }\n+\n+        PatKind::Tuple(ref args, Some(ddpos)) => {\n+            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| wpat(p)).collect();\n+            pats.extend(repeat(DUMMY_WILD_PATTERN).take(arity - args.len()));\n+            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n+            Some(pats)\n+        }\n+        PatKind::Tuple(ref args, None) =>\n+            Some(args.iter().map(|p| wpat(&**p)).collect()),\n+\n+        PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>\n+            Some(vec![wpat(&**inner)]),\n+\n+        PatKind::Lit(ref expr) => {\n+            match r[col].pattern_ty {\n+                Some(&ty::TyS { sty: ty::TyRef(_, mt), .. }) => {\n+                    // HACK: handle string literals. A string literal pattern\n+                    // serves both as an unary reference pattern and as a\n+                    // nullary value pattern, depending on the type.\n+                    Some(vec![Pattern {\n+                        pat: pat,\n+                        pattern_ty: Some(mt.ty)\n+                    }])\n+                }\n+                Some(ty) => {\n+                    assert_eq!(constructor_arity(cx, constructor, ty), 0);\n+                    let expr_value = eval_const_expr(cx.tcx, &expr);\n+                    match range_covered_by_constructor(\n+                        cx.tcx, expr.span, constructor, &expr_value, &expr_value\n+                            ) {\n+                        Ok(true) => Some(vec![]),\n+                        Ok(false) => None,\n+                        Err(ErrorReported) => None,\n+                    }\n+                }\n+                None => span_bug!(pat.span, \"literal pattern {:?} has no type\", pat)\n+            }\n+        }\n+\n+        PatKind::Range(ref from, ref to) => {\n+            let from_value = eval_const_expr(cx.tcx, &from);\n+            let to_value = eval_const_expr(cx.tcx, &to);\n+            match range_covered_by_constructor(\n+                cx.tcx, pat_span, constructor, &from_value, &to_value\n+            ) {\n+                Ok(true) => Some(vec![]),\n+                Ok(false) => None,\n+                Err(ErrorReported) => None,\n+            }\n+        }\n+\n+        PatKind::Slice(ref before, ref slice, ref after) => {\n+            let pat_len = before.len() + after.len();\n+            match *constructor {\n+                Single => {\n+                    // Fixed-length vectors.\n+                    Some(\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        repeat(DUMMY_WILD_PATTERN).take(arity - pat_len).chain(\n+                        after.iter().map(|p| wpat(p))\n+                    )).collect())\n+                },\n+                Slice(length) if pat_len <= length && slice.is_some() => {\n+                    Some(\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        repeat(DUMMY_WILD_PATTERN).take(arity - pat_len).chain(\n+                        after.iter().map(|p| wpat(p))\n+                    )).collect())\n+                }\n+                Slice(length) if pat_len == length => {\n+                    Some(\n+                        before.iter().map(|p| wpat(p)).chain(\n+                        after.iter().map(|p| wpat(p))\n+                    ).collect())\n+                }\n+                _ => None\n+            }\n+        }\n+    };\n+    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n+\n+    head.map(|mut head| {\n+        head.extend_from_slice(&r[..col]);\n+        head.extend_from_slice(&r[col + 1..]);\n+        head\n+    })\n+}\n+\n+pub fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F)\n+                          -> Option<A> where\n+    F: FnOnce(&Pat) -> A,\n+{\n+    let pats = Matrix(vec!(vec!(wrap_pat(cx, pat))));\n+    match is_useful(cx, &pats, &[DUMMY_WILD_PATTERN], ConstructWitness) {\n+        UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n+        NotUseful => None,\n+        Useful => bug!()\n+    }\n+}"}, {"sha": "e87f616bef28b9e8cfd5d8659fdc6ff9adfc6d2b", "filename": "src/librustc_const_eval/check_match.rs", "status": "modified", "additions": 27, "deletions": 680, "changes": 707, "blob_url": "https://github.com/rust-lang/rust/blob/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/src%2Flibrustc_const_eval%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/src%2Flibrustc_const_eval%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fcheck_match.rs?ref=abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "patch": "@@ -8,169 +8,41 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use self::Constructor::*;\n-use self::Usefulness::*;\n-use self::WitnessPreference::*;\n+use _match::{MatchCheckCtxt, Matrix, wrap_pat, is_refutable, is_useful};\n+use _match::{DUMMY_WILD_PATTERN, DUMMY_WILD_PAT};\n+use _match::Usefulness::*;\n+use _match::WitnessPreference::*;\n+\n+use eval::report_const_eval_err;\n+use eval::{eval_const_expr_partial, const_expr_to_pat, lookup_const_by_id};\n+use eval::EvalHint::ExprTypeChecked;\n \n use rustc::dep_graph::DepNode;\n+\n+use rustc::hir::pat_util::{pat_bindings, pat_contains_bindings};\n+\n use rustc::middle::const_val::ConstVal;\n-use ::{eval_const_expr, eval_const_expr_partial, compare_const_vals};\n-use ::{const_expr_to_pat, lookup_const_by_id};\n-use ::EvalHint::ExprTypeChecked;\n-use eval::report_const_eval_err;\n-use rustc::hir::def::*;\n-use rustc::hir::def_id::{DefId};\n use rustc::middle::expr_use_visitor::{ConsumeMode, Delegate, ExprUseVisitor};\n use rustc::middle::expr_use_visitor::{LoanCause, MutateMode};\n use rustc::middle::expr_use_visitor as euv;\n use rustc::middle::mem_categorization::{cmt};\n-use rustc::hir::pat_util::*;\n use rustc::session::Session;\n use rustc::traits::Reveal;\n-use rustc::ty::{self, Ty, TyCtxt};\n+use rustc::ty::{self, TyCtxt};\n use rustc_errors::DiagnosticBuilder;\n-use std::cmp::Ordering;\n-use std::fmt;\n-use std::iter::{FromIterator, IntoIterator, repeat};\n \n-use rustc::hir;\n-use rustc::hir::{Pat, PatKind};\n+use rustc::hir::def::*;\n use rustc::hir::intravisit::{self, Visitor, FnKind};\n+use rustc::hir::print::pat_to_string;\n+use rustc::hir::{self, Pat, PatKind};\n+\n use rustc_back::slice;\n \n-use syntax::ast::{self, DUMMY_NODE_ID, NodeId};\n+use syntax::ast;\n use syntax::codemap::Spanned;\n-use syntax_pos::{Span, DUMMY_SP};\n-use rustc::hir::print::pat_to_string;\n use syntax::ptr::P;\n use syntax::util::move_map::MoveMap;\n-use rustc::util::common::ErrorReported;\n-\n-pub const DUMMY_WILD_PAT: &'static Pat = &Pat {\n-    id: DUMMY_NODE_ID,\n-    node: PatKind::Wild,\n-    span: DUMMY_SP\n-};\n-\n-pub const DUMMY_WILD_PATTERN : Pattern<'static, 'static> = Pattern {\n-    pat: DUMMY_WILD_PAT,\n-    pattern_ty: None\n-};\n-\n-#[derive(Copy, Clone)]\n-pub struct Pattern<'a, 'tcx> {\n-    pat: &'a Pat,\n-    pattern_ty: Option<Ty<'tcx>>\n-}\n-\n-impl<'a, 'tcx> Pattern<'a, 'tcx> {\n-    fn as_raw(self) -> &'a Pat {\n-        let mut pat = self.pat;\n-\n-        while let PatKind::Binding(.., Some(ref s)) = pat.node {\n-            pat = s;\n-        }\n-\n-        return pat;\n-    }\n-\n-    fn span(self) -> Span {\n-        self.pat.span\n-    }\n-}\n-\n-struct Matrix<'a, 'tcx>(Vec<Vec<Pattern<'a, 'tcx>>>);\n-\n-impl<'a, 'tcx> fmt::Debug for Pattern<'a, 'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}: {:?}\", pat_to_string(self.pat), self.pattern_ty)\n-    }\n-}\n-\n-/// Pretty-printer for matrices of patterns, example:\n-/// ++++++++++++++++++++++++++\n-/// + _     + []             +\n-/// ++++++++++++++++++++++++++\n-/// + true  + [First]        +\n-/// ++++++++++++++++++++++++++\n-/// + true  + [Second(true)] +\n-/// ++++++++++++++++++++++++++\n-/// + false + [_]            +\n-/// ++++++++++++++++++++++++++\n-/// + _     + [_, _, ..tail] +\n-/// ++++++++++++++++++++++++++\n-impl<'a, 'tcx> fmt::Debug for Matrix<'a, 'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"\\n\")?;\n-\n-        let &Matrix(ref m) = self;\n-        let pretty_printed_matrix: Vec<Vec<String>> = m.iter().map(|row| {\n-            row.iter().map(|pat| format!(\"{:?}\", pat)).collect()\n-        }).collect();\n-\n-        let column_count = m.iter().map(|row| row.len()).max().unwrap_or(0);\n-        assert!(m.iter().all(|row| row.len() == column_count));\n-        let column_widths: Vec<usize> = (0..column_count).map(|col| {\n-            pretty_printed_matrix.iter().map(|row| row[col].len()).max().unwrap_or(0)\n-        }).collect();\n-\n-        let total_width = column_widths.iter().cloned().sum::<usize>() + column_count * 3 + 1;\n-        let br = repeat('+').take(total_width).collect::<String>();\n-        write!(f, \"{}\\n\", br)?;\n-        for row in pretty_printed_matrix {\n-            write!(f, \"+\")?;\n-            for (column, pat_str) in row.into_iter().enumerate() {\n-                write!(f, \" \")?;\n-                write!(f, \"{:1$}\", pat_str, column_widths[column])?;\n-                write!(f, \" +\")?;\n-            }\n-            write!(f, \"\\n\")?;\n-            write!(f, \"{}\\n\", br)?;\n-        }\n-        Ok(())\n-    }\n-}\n-\n-impl<'a, 'tcx> FromIterator<Vec<Pattern<'a, 'tcx>>> for Matrix<'a, 'tcx> {\n-    fn from_iter<T: IntoIterator<Item=Vec<Pattern<'a, 'tcx>>>>(iter: T) -> Self\n-    {\n-        Matrix(iter.into_iter().collect())\n-    }\n-}\n-\n-//NOTE: appears to be the only place other then InferCtxt to contain a ParamEnv\n-pub struct MatchCheckCtxt<'a, 'tcx: 'a> {\n-    pub tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    pub param_env: ty::ParameterEnvironment<'tcx>,\n-}\n-\n-#[derive(Clone, Debug, PartialEq)]\n-pub enum Constructor {\n-    /// The constructor of all patterns that don't vary by constructor,\n-    /// e.g. struct patterns and fixed-length arrays.\n-    Single,\n-    /// Enum variants.\n-    Variant(DefId),\n-    /// Literal values.\n-    ConstantValue(ConstVal),\n-    /// Ranges of literal values (2..5).\n-    ConstantRange(ConstVal, ConstVal),\n-    /// Array patterns of length n.\n-    Slice(usize),\n-}\n-\n-#[derive(Clone, PartialEq)]\n-enum Usefulness {\n-    Useful,\n-    UsefulWithWitness(Vec<P<Pat>>),\n-    NotUseful\n-}\n-\n-#[derive(Copy, Clone)]\n-enum WitnessPreference {\n-    ConstructWitness,\n-    LeaveOutWitness\n-}\n+use syntax_pos::Span;\n \n impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n     fn visit_expr(&mut self, ex: &hir::Expr) {\n@@ -180,7 +52,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for MatchCheckCtxt<'a, 'tcx> {\n         check_local(self, l);\n     }\n     fn visit_fn(&mut self, fk: FnKind<'v>, fd: &'v hir::FnDecl,\n-                b: &'v hir::Block, s: Span, n: NodeId) {\n+                b: &'v hir::Block, s: Span, n: ast::NodeId) {\n         check_fn(self, fk, fd, b, s, n);\n     }\n }\n@@ -341,7 +213,7 @@ fn pat_is_catchall(dm: &DefMap, pat: &Pat) -> bool {\n fn check_arms(cx: &MatchCheckCtxt,\n               arms: &[(Vec<P<Pat>>, Option<&hir::Expr>)],\n               source: hir::MatchSource) {\n-    let mut seen = Matrix(vec![]);\n+    let mut seen = Matrix::empty();\n     let mut catchall = None;\n     let mut printed_if_let_err = false;\n     for &(ref pats, guard) in arms {\n@@ -390,7 +262,7 @@ fn check_arms(cx: &MatchCheckCtxt,\n                         hir::MatchSource::Normal => {\n                             let mut err = struct_span_err!(cx.tcx.sess, pat.span, E0001,\n                                                            \"unreachable pattern\");\n-                            err.span_label(pat.span, &format!(\"this is an unreachable pattern\"));\n+                            err.span_label(pat.span, &\"this is an unreachable pattern\");\n                             // if we had a catchall pattern, hint at that\n                             if let Some(catchall) = catchall {\n                                 err.span_note(catchall, \"this pattern matches any value\");\n@@ -407,13 +279,10 @@ fn check_arms(cx: &MatchCheckCtxt,\n                 UsefulWithWitness(_) => bug!()\n             }\n             if guard.is_none() {\n-                let Matrix(mut rows) = seen;\n-                rows.push(v);\n-                seen = Matrix(rows);\n+                seen.push(v);\n                 if catchall.is_none() && pat_is_catchall(&cx.tcx.def_map.borrow(), pat) {\n                     catchall = Some(pat.span);\n                 }\n-\n             }\n         }\n     }\n@@ -485,18 +354,6 @@ fn check_exhaustive<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n     }\n }\n \n-fn const_val_to_expr(value: &ConstVal) -> P<hir::Expr> {\n-    let node = match value {\n-        &ConstVal::Bool(b) => ast::LitKind::Bool(b),\n-        _ => bug!()\n-    };\n-    P(hir::Expr {\n-        id: DUMMY_NODE_ID,\n-        node: hir::ExprLit(P(Spanned { node: node, span: DUMMY_SP })),\n-        span: DUMMY_SP,\n-        attrs: ast::ThinVec::new(),\n-    })\n-}\n \n struct StaticInliner<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n@@ -588,505 +445,6 @@ impl<'a, 'tcx> StaticInliner<'a, 'tcx> {\n     }\n }\n \n-/// Constructs a partial witness for a pattern given a list of\n-/// patterns expanded by the specialization step.\n-///\n-/// When a pattern P is discovered to be useful, this function is used bottom-up\n-/// to reconstruct a complete witness, e.g. a pattern P' that covers a subset\n-/// of values, V, where each value in that set is not covered by any previously\n-/// used patterns and is covered by the pattern P'. Examples:\n-///\n-/// left_ty: tuple of 3 elements\n-/// pats: [10, 20, _]           => (10, 20, _)\n-///\n-/// left_ty: struct X { a: (bool, &'static str), b: usize}\n-/// pats: [(false, \"foo\"), 42]  => X { a: (false, \"foo\"), b: 42 }\n-fn construct_witness<'a,'tcx>(cx: &MatchCheckCtxt<'a,'tcx>, ctor: &Constructor,\n-                              pats: Vec<&Pat>, left_ty: Ty<'tcx>) -> P<Pat> {\n-    let pats_len = pats.len();\n-    let mut pats = pats.into_iter().map(|p| P((*p).clone()));\n-    let pat = match left_ty.sty {\n-        ty::TyTuple(..) => PatKind::Tuple(pats.collect(), None),\n-\n-        ty::TyAdt(adt, _) => {\n-            let v = ctor.variant_for_adt(adt);\n-            match v.ctor_kind {\n-                CtorKind::Fictive => {\n-                    let field_pats: hir::HirVec<_> = v.fields.iter()\n-                        .zip(pats)\n-                        .filter(|&(_, ref pat)| pat.node != PatKind::Wild)\n-                        .map(|(field, pat)| Spanned {\n-                            span: DUMMY_SP,\n-                            node: hir::FieldPat {\n-                                name: field.name,\n-                                pat: pat,\n-                                is_shorthand: false,\n-                            }\n-                        }).collect();\n-                    let has_more_fields = field_pats.len() < pats_len;\n-                    PatKind::Struct(def_to_path(cx.tcx, v.did), field_pats, has_more_fields)\n-                }\n-                CtorKind::Fn => {\n-                    PatKind::TupleStruct(def_to_path(cx.tcx, v.did), pats.collect(), None)\n-                }\n-                CtorKind::Const => {\n-                    PatKind::Path(None, def_to_path(cx.tcx, v.did))\n-                }\n-            }\n-        }\n-\n-        ty::TyRef(_, ty::TypeAndMut { mutbl, .. }) => {\n-            assert_eq!(pats_len, 1);\n-            PatKind::Ref(pats.nth(0).unwrap(), mutbl)\n-        }\n-\n-        ty::TySlice(_) => match ctor {\n-            &Slice(n) => {\n-                assert_eq!(pats_len, n);\n-                PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n-            },\n-            _ => unreachable!()\n-        },\n-\n-        ty::TyArray(_, len) => {\n-            assert_eq!(pats_len, len);\n-            PatKind::Slice(pats.collect(), None, hir::HirVec::new())\n-        }\n-\n-        _ => {\n-            match *ctor {\n-                ConstantValue(ref v) => PatKind::Lit(const_val_to_expr(v)),\n-                _ => PatKind::Wild,\n-            }\n-        }\n-    };\n-\n-    P(hir::Pat {\n-        id: DUMMY_NODE_ID,\n-        node: pat,\n-        span: DUMMY_SP\n-    })\n-}\n-\n-impl Constructor {\n-    fn variant_for_adt<'tcx, 'container, 'a>(&self,\n-                                             adt: &'a ty::AdtDefData<'tcx, 'container>)\n-                                             -> &'a ty::VariantDefData<'tcx, 'container> {\n-        match self {\n-            &Variant(vid) => adt.variant_with_id(vid),\n-            _ => adt.struct_variant()\n-        }\n-    }\n-}\n-\n-fn missing_constructors(cx: &MatchCheckCtxt, &Matrix(ref rows): &Matrix,\n-                       left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n-    let used_constructors: Vec<Constructor> = rows.iter()\n-        .flat_map(|row| pat_constructors(cx, row[0], left_ty, max_slice_length))\n-        .collect();\n-    all_constructors(cx, left_ty, max_slice_length)\n-        .into_iter()\n-        .filter(|c| !used_constructors.contains(c))\n-        .collect()\n-}\n-\n-/// This determines the set of all possible constructors of a pattern matching\n-/// values of type `left_ty`. For vectors, this would normally be an infinite set\n-/// but is instead bounded by the maximum fixed length of slice patterns in\n-/// the column of patterns being analyzed.\n-fn all_constructors(_cx: &MatchCheckCtxt, left_ty: Ty,\n-                    max_slice_length: usize) -> Vec<Constructor> {\n-    match left_ty.sty {\n-        ty::TyBool =>\n-            [true, false].iter().map(|b| ConstantValue(ConstVal::Bool(*b))).collect(),\n-        ty::TySlice(_) =>\n-            (0..max_slice_length+1).map(|length| Slice(length)).collect(),\n-        ty::TyAdt(def, _) if def.is_enum() =>\n-            def.variants.iter().map(|v| Variant(v.did)).collect(),\n-        _ => vec![Single]\n-    }\n-}\n-\n-// Algorithm from http://moscova.inria.fr/~maranget/papers/warn/index.html\n-//\n-// Whether a vector `v` of patterns is 'useful' in relation to a set of such\n-// vectors `m` is defined as there being a set of inputs that will match `v`\n-// but not any of the sets in `m`.\n-//\n-// This is used both for reachability checking (if a pattern isn't useful in\n-// relation to preceding patterns, it is not reachable) and exhaustiveness\n-// checking (if a wildcard pattern is useful in relation to a matrix, the\n-// matrix isn't exhaustive).\n-\n-// Note: is_useful doesn't work on empty types, as the paper notes.\n-// So it assumes that v is non-empty.\n-fn is_useful<'a, 'tcx>(cx: &MatchCheckCtxt<'a, 'tcx>,\n-                       matrix: &Matrix<'a, 'tcx>,\n-                       v: &[Pattern<'a, 'tcx>],\n-                       witness: WitnessPreference)\n-                       -> Usefulness {\n-    let &Matrix(ref rows) = matrix;\n-    debug!(\"is_useful({:?}, {:?})\", matrix, v);\n-    if rows.is_empty() {\n-        return match witness {\n-            ConstructWitness => UsefulWithWitness(vec!()),\n-            LeaveOutWitness => Useful\n-        };\n-    }\n-    if rows[0].is_empty() {\n-        return NotUseful;\n-    }\n-    assert!(rows.iter().all(|r| r.len() == v.len()));\n-    let left_ty = match rows.iter().filter_map(|r| r[0].pattern_ty).next()\n-        .or_else(|| v[0].pattern_ty)\n-    {\n-        Some(ty) => ty,\n-        None => {\n-            // all patterns are wildcards - we can pick any type we want\n-            cx.tcx.types.bool\n-        }\n-    };\n-\n-    let max_slice_length = rows.iter().filter_map(|row| match row[0].pat.node {\n-        PatKind::Slice(ref before, _, ref after) => Some(before.len() + after.len()),\n-        _ => None\n-    }).max().map_or(0, |v| v + 1);\n-\n-    let constructors = pat_constructors(cx, v[0], left_ty, max_slice_length);\n-    debug!(\"is_useful - pat_constructors = {:?} left_ty = {:?}\", constructors,\n-           left_ty);\n-    if constructors.is_empty() {\n-        let constructors = missing_constructors(cx, matrix, left_ty, max_slice_length);\n-        debug!(\"is_useful - missing_constructors = {:?}\", constructors);\n-        if constructors.is_empty() {\n-            all_constructors(cx, left_ty, max_slice_length).into_iter().map(|c| {\n-                match is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness) {\n-                    UsefulWithWitness(pats) => UsefulWithWitness({\n-                        let arity = constructor_arity(cx, &c, left_ty);\n-                        let mut result = {\n-                            let pat_slice = &pats[..];\n-                            let subpats: Vec<_> = (0..arity).map(|i| {\n-                                pat_slice.get(i).map_or(DUMMY_WILD_PAT, |p| &**p)\n-                            }).collect();\n-                            vec![construct_witness(cx, &c, subpats, left_ty)]\n-                        };\n-                        result.extend(pats.into_iter().skip(arity));\n-                        result\n-                    }),\n-                    result => result\n-                }\n-            }).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n-        } else {\n-            let matrix = rows.iter().filter_map(|r| {\n-                match r[0].as_raw().node {\n-                    PatKind::Binding(..) | PatKind::Wild => Some(r[1..].to_vec()),\n-                    _ => None,\n-                }\n-            }).collect();\n-            match is_useful(cx, &matrix, &v[1..], witness) {\n-                UsefulWithWitness(pats) => {\n-                    let mut new_pats: Vec<_> = constructors.into_iter().map(|constructor| {\n-                        let arity = constructor_arity(cx, &constructor, left_ty);\n-                        let wild_pats = vec![DUMMY_WILD_PAT; arity];\n-                        construct_witness(cx, &constructor, wild_pats, left_ty)\n-                    }).collect();\n-                    new_pats.extend(pats);\n-                    UsefulWithWitness(new_pats)\n-                },\n-                result => result\n-            }\n-        }\n-    } else {\n-        constructors.into_iter().map(|c|\n-            is_useful_specialized(cx, matrix, v, c.clone(), left_ty, witness)\n-        ).find(|result| result != &NotUseful).unwrap_or(NotUseful)\n-    }\n-}\n-\n-fn is_useful_specialized<'a, 'tcx>(\n-    cx: &MatchCheckCtxt<'a, 'tcx>,\n-    &Matrix(ref m): &Matrix<'a, 'tcx>,\n-    v: &[Pattern<'a, 'tcx>],\n-    ctor: Constructor,\n-    lty: Ty<'tcx>,\n-    witness: WitnessPreference) -> Usefulness\n-{\n-    let arity = constructor_arity(cx, &ctor, lty);\n-    let matrix = Matrix(m.iter().filter_map(|r| {\n-        specialize(cx, &r[..], &ctor, 0, arity)\n-    }).collect());\n-    match specialize(cx, v, &ctor, 0, arity) {\n-        Some(v) => is_useful(cx, &matrix, &v[..], witness),\n-        None => NotUseful\n-    }\n-}\n-\n-/// Determines the constructors that the given pattern can be specialized to.\n-///\n-/// In most cases, there's only one constructor that a specific pattern\n-/// represents, such as a specific enum variant or a specific literal value.\n-/// Slice patterns, however, can match slices of different lengths. For instance,\n-/// `[a, b, ..tail]` can match a slice of length 2, 3, 4 and so on.\n-///\n-/// On the other hand, a wild pattern and an identifier pattern cannot be\n-/// specialized in any way.\n-fn pat_constructors(cx: &MatchCheckCtxt, p: Pattern,\n-                    left_ty: Ty, max_slice_length: usize) -> Vec<Constructor> {\n-    let pat = p.as_raw();\n-    match pat.node {\n-        PatKind::Struct(..) | PatKind::TupleStruct(..) | PatKind::Path(..) =>\n-            match cx.tcx.expect_def(pat.id) {\n-                Def::Variant(id) | Def::VariantCtor(id, ..) => vec![Variant(id)],\n-                Def::Struct(..) | Def::StructCtor(..) | Def::Union(..) |\n-                Def::TyAlias(..) | Def::AssociatedTy(..) => vec![Single],\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(p.span(), \"const pattern should've been rewritten\"),\n-                def => span_bug!(p.span(), \"pat_constructors: unexpected definition {:?}\", def),\n-            },\n-        PatKind::Lit(ref expr) =>\n-            vec![ConstantValue(eval_const_expr(cx.tcx, &expr))],\n-        PatKind::Range(ref lo, ref hi) =>\n-            vec![ConstantRange(eval_const_expr(cx.tcx, &lo), eval_const_expr(cx.tcx, &hi))],\n-        PatKind::Slice(ref before, ref slice, ref after) =>\n-            match left_ty.sty {\n-                ty::TyArray(..) => vec![Single],\n-                ty::TySlice(_) if slice.is_some() => {\n-                    (before.len() + after.len()..max_slice_length+1)\n-                        .map(|length| Slice(length))\n-                        .collect()\n-                }\n-                ty::TySlice(_) => vec!(Slice(before.len() + after.len())),\n-                _ => span_bug!(pat.span, \"pat_constructors: unexpected \\\n-                                          slice pattern type {:?}\", left_ty)\n-            },\n-        PatKind::Box(..) | PatKind::Tuple(..) | PatKind::Ref(..) =>\n-            vec![Single],\n-        PatKind::Binding(..) | PatKind::Wild =>\n-            vec![],\n-    }\n-}\n-\n-/// This computes the arity of a constructor. The arity of a constructor\n-/// is how many subpattern patterns of that constructor should be expanded to.\n-///\n-/// For instance, a tuple pattern (_, 42, Some([])) has the arity of 3.\n-/// A struct pattern's arity is the number of fields it contains, etc.\n-pub fn constructor_arity(_cx: &MatchCheckCtxt, ctor: &Constructor, ty: Ty) -> usize {\n-    debug!(\"constructor_arity({:?}, {:?})\", ctor, ty);\n-    match ty.sty {\n-        ty::TyTuple(ref fs) => fs.len(),\n-        ty::TyBox(_) => 1,\n-        ty::TySlice(_) => match *ctor {\n-            Slice(length) => length,\n-            ConstantValue(_) => {\n-                // TODO: this is utterly wrong, but required for byte arrays\n-                0\n-            }\n-            _ => bug!(\"bad slice pattern {:?} {:?}\", ctor, ty)\n-        },\n-        ty::TyRef(..) => 1,\n-        ty::TyAdt(adt, _) => {\n-            ctor.variant_for_adt(adt).fields.len()\n-        }\n-        ty::TyArray(_, n) => n,\n-        _ => 0\n-    }\n-}\n-\n-fn range_covered_by_constructor(tcx: TyCtxt, span: Span,\n-                                ctor: &Constructor,\n-                                from: &ConstVal, to: &ConstVal)\n-                                -> Result<bool, ErrorReported> {\n-    let (c_from, c_to) = match *ctor {\n-        ConstantValue(ref value)        => (value, value),\n-        ConstantRange(ref from, ref to) => (from, to),\n-        Single                          => return Ok(true),\n-        _                               => bug!()\n-    };\n-    let cmp_from = compare_const_vals(tcx, span, c_from, from)?;\n-    let cmp_to = compare_const_vals(tcx, span, c_to, to)?;\n-    Ok(cmp_from != Ordering::Less && cmp_to != Ordering::Greater)\n-}\n-\n-fn wrap_pat<'a, 'b, 'tcx>(cx: &MatchCheckCtxt<'b, 'tcx>,\n-                          pat: &'a Pat)\n-                          -> Pattern<'a, 'tcx>\n-{\n-    let pat_ty = cx.tcx.pat_ty(pat);\n-    Pattern {\n-        pat: pat,\n-        pattern_ty: Some(match pat.node {\n-            PatKind::Binding(hir::BindByRef(..), ..) => {\n-                pat_ty.builtin_deref(false, ty::NoPreference).unwrap().ty\n-            }\n-            _ => pat_ty\n-        })\n-    }\n-}\n-\n-/// This is the main specialization step. It expands the first pattern in the given row\n-/// into `arity` patterns based on the constructor. For most patterns, the step is trivial,\n-/// for instance tuple patterns are flattened and box patterns expand into their inner pattern.\n-///\n-/// OTOH, slice patterns with a subslice pattern (..tail) can be expanded into multiple\n-/// different patterns.\n-/// Structure patterns with a partial wild pattern (Foo { a: 42, .. }) have their missing\n-/// fields filled with wild patterns.\n-pub fn specialize<'a, 'b, 'tcx>(\n-    cx: &MatchCheckCtxt<'b, 'tcx>,\n-    r: &[Pattern<'a, 'tcx>],\n-    constructor: &Constructor, col: usize, arity: usize)\n-    -> Option<Vec<Pattern<'a, 'tcx>>>\n-{\n-    let pat = r[col].as_raw();\n-    let &Pat {\n-        id: pat_id, ref node, span: pat_span\n-    } = pat;\n-    let wpat = |pat: &'a Pat| wrap_pat(cx, pat);\n-\n-    let head: Option<Vec<Pattern>> = match *node {\n-        PatKind::Binding(..) | PatKind::Wild =>\n-            Some(vec![DUMMY_WILD_PATTERN; arity]),\n-\n-        PatKind::Path(..) => {\n-            match cx.tcx.expect_def(pat_id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat_span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::VariantCtor(id, CtorKind::Const) if *constructor != Variant(id) => None,\n-                Def::VariantCtor(_, CtorKind::Const) |\n-                Def::StructCtor(_, CtorKind::Const) => Some(Vec::new()),\n-                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def),\n-            }\n-        }\n-\n-        PatKind::TupleStruct(_, ref args, ddpos) => {\n-            match cx.tcx.expect_def(pat_id) {\n-                Def::Const(..) | Def::AssociatedConst(..) =>\n-                    span_bug!(pat_span, \"const pattern should've \\\n-                                         been rewritten\"),\n-                Def::VariantCtor(id, CtorKind::Fn) if *constructor != Variant(id) => None,\n-                Def::VariantCtor(_, CtorKind::Fn) |\n-                Def::StructCtor(_, CtorKind::Fn) => {\n-                    match ddpos {\n-                        Some(ddpos) => {\n-                            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| {\n-                                wpat(p)\n-                            }).collect();\n-                            pats.extend(repeat(DUMMY_WILD_PATTERN).take(arity - args.len()));\n-                            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n-                            Some(pats)\n-                        }\n-                        None => Some(args.iter().map(|p| wpat(p)).collect())\n-                    }\n-                }\n-                def => span_bug!(pat_span, \"specialize: unexpected definition: {:?}\", def),\n-            }\n-        }\n-\n-        PatKind::Struct(_, ref pattern_fields, _) => {\n-            let adt = cx.tcx.node_id_to_type(pat_id).ty_adt_def().unwrap();\n-            let variant = constructor.variant_for_adt(adt);\n-            let def_variant = adt.variant_of_def(cx.tcx.expect_def(pat_id));\n-            if variant.did == def_variant.did {\n-                Some(variant.fields.iter().map(|sf| {\n-                    match pattern_fields.iter().find(|f| f.node.name == sf.name) {\n-                        Some(ref f) => wpat(&f.node.pat),\n-                        _ => DUMMY_WILD_PATTERN\n-                    }\n-                }).collect())\n-            } else {\n-                None\n-            }\n-        }\n-\n-        PatKind::Tuple(ref args, Some(ddpos)) => {\n-            let mut pats: Vec<_> = args[..ddpos].iter().map(|p| wpat(p)).collect();\n-            pats.extend(repeat(DUMMY_WILD_PATTERN).take(arity - args.len()));\n-            pats.extend(args[ddpos..].iter().map(|p| wpat(p)));\n-            Some(pats)\n-        }\n-        PatKind::Tuple(ref args, None) =>\n-            Some(args.iter().map(|p| wpat(&**p)).collect()),\n-\n-        PatKind::Box(ref inner) | PatKind::Ref(ref inner, _) =>\n-            Some(vec![wpat(&**inner)]),\n-\n-        PatKind::Lit(ref expr) => {\n-            match r[col].pattern_ty {\n-                Some(&ty::TyS { sty: ty::TyRef(_, mt), .. }) => {\n-                    // HACK: handle string literals. A string literal pattern\n-                    // serves both as an unary reference pattern and as a\n-                    // nullary value pattern, depending on the type.\n-                    Some(vec![Pattern {\n-                        pat: pat,\n-                        pattern_ty: Some(mt.ty)\n-                    }])\n-                }\n-                Some(ty) => {\n-                    assert_eq!(constructor_arity(cx, constructor, ty), 0);\n-                    let expr_value = eval_const_expr(cx.tcx, &expr);\n-                    match range_covered_by_constructor(\n-                        cx.tcx, expr.span, constructor, &expr_value, &expr_value\n-                            ) {\n-                        Ok(true) => Some(vec![]),\n-                        Ok(false) => None,\n-                        Err(ErrorReported) => None,\n-                    }\n-                }\n-                None => span_bug!(pat.span, \"literal pattern {:?} has no type\", pat)\n-            }\n-        }\n-\n-        PatKind::Range(ref from, ref to) => {\n-            let from_value = eval_const_expr(cx.tcx, &from);\n-            let to_value = eval_const_expr(cx.tcx, &to);\n-            match range_covered_by_constructor(\n-                cx.tcx, pat_span, constructor, &from_value, &to_value\n-            ) {\n-                Ok(true) => Some(vec![]),\n-                Ok(false) => None,\n-                Err(ErrorReported) => None,\n-            }\n-        }\n-\n-        PatKind::Slice(ref before, ref slice, ref after) => {\n-            let pat_len = before.len() + after.len();\n-            match *constructor {\n-                Single => {\n-                    // Fixed-length vectors.\n-                    Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        repeat(DUMMY_WILD_PATTERN).take(arity - pat_len).chain(\n-                        after.iter().map(|p| wpat(p))\n-                    )).collect())\n-                },\n-                Slice(length) if pat_len <= length && slice.is_some() => {\n-                    Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        repeat(DUMMY_WILD_PATTERN).take(arity - pat_len).chain(\n-                        after.iter().map(|p| wpat(p))\n-                    )).collect())\n-                }\n-                Slice(length) if pat_len == length => {\n-                    Some(\n-                        before.iter().map(|p| wpat(p)).chain(\n-                        after.iter().map(|p| wpat(p))\n-                    ).collect())\n-                }\n-                _ => None\n-            }\n-        }\n-    };\n-    debug!(\"specialize({:?}, {:?}) = {:?}\", r[col], arity, head);\n-\n-    head.map(|mut head| {\n-        head.extend_from_slice(&r[..col]);\n-        head.extend_from_slice(&r[col + 1..]);\n-        head\n-    })\n-}\n-\n fn check_local(cx: &mut MatchCheckCtxt, loc: &hir::Local) {\n     intravisit::walk_local(cx, loc);\n \n@@ -1103,7 +461,7 @@ fn check_fn(cx: &mut MatchCheckCtxt,\n             decl: &hir::FnDecl,\n             body: &hir::Block,\n             sp: Span,\n-            fn_id: NodeId) {\n+            fn_id: ast::NodeId) {\n     match kind {\n         FnKind::Closure(_) => {}\n         _ => cx.param_env = ty::ParameterEnvironment::for_item(cx.tcx, fn_id),\n@@ -1135,17 +493,6 @@ fn check_irrefutable(cx: &MatchCheckCtxt, pat: &Pat, is_fn_arg: bool) {\n     });\n }\n \n-fn is_refutable<A, F>(cx: &MatchCheckCtxt, pat: &Pat, refutable: F) -> Option<A> where\n-    F: FnOnce(&Pat) -> A,\n-{\n-    let pats = Matrix(vec!(vec!(wrap_pat(cx, pat))));\n-    match is_useful(cx, &pats, &[DUMMY_WILD_PATTERN], ConstructWitness) {\n-        UsefulWithWitness(pats) => Some(refutable(&pats[0])),\n-        NotUseful => None,\n-        Useful => bug!()\n-    }\n-}\n-\n // Legality of move bindings checking\n fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n                                    has_guard: bool,\n@@ -1219,10 +566,10 @@ struct MutationChecker<'a, 'gcx: 'a> {\n \n impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n     fn matched_pat(&mut self, _: &Pat, _: cmt, _: euv::MatchMode) {}\n-    fn consume(&mut self, _: NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n+    fn consume(&mut self, _: ast::NodeId, _: Span, _: cmt, _: ConsumeMode) {}\n     fn consume_pat(&mut self, _: &Pat, _: cmt, _: ConsumeMode) {}\n     fn borrow(&mut self,\n-              _: NodeId,\n+              _: ast::NodeId,\n               span: Span,\n               _: cmt,\n               _: &'tcx ty::Region,\n@@ -1238,8 +585,8 @@ impl<'a, 'gcx, 'tcx> Delegate<'tcx> for MutationChecker<'a, 'gcx> {\n             ty::ImmBorrow | ty::UniqueImmBorrow => {}\n         }\n     }\n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n-    fn mutate(&mut self, _: NodeId, span: Span, _: cmt, mode: MutateMode) {\n+    fn decl_without_init(&mut self, _: ast::NodeId, _: Span) {}\n+    fn mutate(&mut self, _: ast::NodeId, span: Span, _: cmt, mode: MutateMode) {\n         match mode {\n             MutateMode::JustWrite | MutateMode::WriteAndRead => {\n                 struct_span_err!(self.cx.tcx.sess, span, E0302, \"cannot assign in a pattern guard\")"}, {"sha": "c2b39625e2eee48d83f47a8d29dceb5116f228b1", "filename": "src/librustc_const_eval/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/src%2Flibrustc_const_eval%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Fdiagnostics.rs?ref=abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "patch": "@@ -40,7 +40,7 @@ Ensure the ordering of the match arm is correct and remove any superfluous\n arms.\n \"##,\n \n-E0002: r##\"\n+/*E0002: r##\"\n This error indicates that an empty match expression is invalid because the type\n it is matching on is non-empty (there exist values of this type). In safe code\n it is impossible to create an instance of an empty type, so empty match\n@@ -68,7 +68,7 @@ fn foo(x: Option<String>) {\n     }\n }\n ```\n-\"##,\n+\"##,*/\n \n \n E0003: r##\""}, {"sha": "cbdb808a12747045014286adf497beedd0718bf6", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/abae5e7e258f256cbdb4fa2a58f58ecb095ba626/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=abae5e7e258f256cbdb4fa2a58f58ecb095ba626", "patch": "@@ -47,6 +47,7 @@ extern crate serialize as rustc_serialize; // used by deriving\n pub mod diagnostics;\n \n mod eval;\n+mod _match;\n pub mod check_match;\n pub mod pattern;\n "}]}