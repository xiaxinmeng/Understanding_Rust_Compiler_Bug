{"sha": "6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhZWIxY2ZiNjRlYTA0ZTMzNGQyOTZiZjlhNDdjNjU5MTE2Yzk2YmY=", "commit": {"author": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-01-15T17:44:00Z"}, "committer": {"name": "Mark Simulacrum", "email": "mark.simulacrum@gmail.com", "date": "2018-01-24T02:39:20Z"}, "message": "Add ./x.py check src/{libstd,libtest,rustc}.\n\nThis currently only supports a limited subset of the full compilation,\nbut is likely 90% of what people will want and is possible without\nbuilding a full compiler (i.e., running LLVM). In theory, this means\nthat contributors who don't want to build LLVM now have an easy way to\ncompile locally, though running tests won't work.", "tree": {"sha": "6339981e366f24829376b43410314a31feb37930", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6339981e366f24829376b43410314a31feb37930"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "html_url": "https://github.com/rust-lang/rust/commit/6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/comments", "author": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Mark-Simulacrum", "id": 5047365, "node_id": "MDQ6VXNlcjUwNDczNjU=", "avatar_url": "https://avatars.githubusercontent.com/u/5047365?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Mark-Simulacrum", "html_url": "https://github.com/Mark-Simulacrum", "followers_url": "https://api.github.com/users/Mark-Simulacrum/followers", "following_url": "https://api.github.com/users/Mark-Simulacrum/following{/other_user}", "gists_url": "https://api.github.com/users/Mark-Simulacrum/gists{/gist_id}", "starred_url": "https://api.github.com/users/Mark-Simulacrum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Mark-Simulacrum/subscriptions", "organizations_url": "https://api.github.com/users/Mark-Simulacrum/orgs", "repos_url": "https://api.github.com/users/Mark-Simulacrum/repos", "events_url": "https://api.github.com/users/Mark-Simulacrum/events{/privacy}", "received_events_url": "https://api.github.com/users/Mark-Simulacrum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "734ee0fb4301a5b38e304882de35914a87c237f3", "url": "https://api.github.com/repos/rust-lang/rust/commits/734ee0fb4301a5b38e304882de35914a87c237f3", "html_url": "https://github.com/rust-lang/rust/commit/734ee0fb4301a5b38e304882de35914a87c237f3"}], "stats": {"total": 238, "additions": 211, "deletions": 27}, "files": [{"sha": "55d104b182698d3901e6c3433301cdc48e8094b3", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "patch": "@@ -125,11 +125,6 @@ fn main() {\n             cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n-        // Pass down incremental directory, if any.\n-        if let Ok(dir) = env::var(\"RUSTC_INCREMENTAL\") {\n-            cmd.arg(format!(\"-Zincremental={}\", dir));\n-        }\n-\n         let crate_name = args.windows(2)\n             .find(|a| &*a[0] == \"--crate-name\")\n             .unwrap();"}, {"sha": "ecf9c0a75903e514f0f06b5f322c8c4e7100759c", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "patch": "@@ -602,6 +602,7 @@ def build_bootstrap(self):\n         env[\"LIBRARY_PATH\"] = os.path.join(self.bin_root(), \"lib\") + \\\n             (os.pathsep + env[\"LIBRARY_PATH\"]) \\\n             if \"LIBRARY_PATH\" in env else \"\"\n+        env[\"RUSTFLAGS\"] = \"-Cdebuginfo=2\"\n         env[\"PATH\"] = os.path.join(self.bin_root(), \"bin\") + \\\n             os.pathsep + env[\"PATH\"]\n         if not os.path.isfile(self.cargo()):"}, {"sha": "79058984b13523a0dd4795aaa9ca00f6daabd9f4", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "patch": "@@ -26,6 +26,7 @@ use util::{exe, libdir, add_lib_path};\n use {Build, Mode};\n use cache::{INTERNER, Interned, Cache};\n use check;\n+use test;\n use flags::Subcommand;\n use doc;\n use tool;\n@@ -230,6 +231,7 @@ impl<'a> ShouldRun<'a> {\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum Kind {\n     Build,\n+    Check,\n     Test,\n     Bench,\n     Dist,\n@@ -251,13 +253,13 @@ impl<'a> Builder<'a> {\n                 tool::Compiletest, tool::RemoteTestServer, tool::RemoteTestClient,\n                 tool::RustInstaller, tool::Cargo, tool::Rls, tool::Rustdoc, tool::Clippy,\n                 native::Llvm, tool::Rustfmt, tool::Miri),\n-            Kind::Test => describe!(check::Tidy, check::Bootstrap, check::DefaultCompiletest,\n-                check::HostCompiletest, check::Crate, check::CrateLibrustc, check::Rustdoc,\n-                check::Linkcheck, check::Cargotest, check::Cargo, check::Rls, check::Docs,\n-                check::ErrorIndex, check::Distcheck, check::Rustfmt, check::Miri, check::Clippy,\n-                check::RustdocJS),\n-\n-            Kind::Bench => describe!(check::Crate, check::CrateLibrustc),\n+            Kind::Check => describe!(check::Std, check::Test, check::Rustc),\n+            Kind::Test => describe!(test::Tidy, test::Bootstrap, test::DefaultCompiletest,\n+                test::HostCompiletest, test::Crate, test::CrateLibrustc, test::Rustdoc,\n+                test::Linkcheck, test::Cargotest, test::Cargo, test::Rls, test::Docs,\n+                test::ErrorIndex, test::Distcheck, test::Rustfmt, test::Miri, test::Clippy,\n+                test::RustdocJS),\n+            Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(doc::UnstableBook, doc::UnstableBookGen, doc::TheBook,\n                 doc::Standalone, doc::Std, doc::Test, doc::Rustc, doc::ErrorIndex, doc::Nomicon,\n                 doc::Reference, doc::Rustdoc, doc::RustByExample, doc::CargoBook),\n@@ -304,6 +306,7 @@ impl<'a> Builder<'a> {\n     pub fn run(build: &Build) {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n+            Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n@@ -493,13 +496,14 @@ impl<'a> Builder<'a> {\n             cargo.env(\"RUSTC_CODEGEN_UNITS\", n.to_string());\n         }\n \n+\n         if let Some(host_linker) = self.build.linker(compiler.host) {\n             cargo.env(\"RUSTC_HOST_LINKER\", host_linker);\n         }\n         if let Some(target_linker) = self.build.linker(target) {\n             cargo.env(\"RUSTC_TARGET_LINKER\", target_linker);\n         }\n-        if cmd != \"build\" {\n+        if cmd != \"build\" && cmd != \"check\" {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(self.compiler(2, self.build.build)));\n         }\n \n@@ -566,8 +570,7 @@ impl<'a> Builder<'a> {\n         // not guaranteeing correctness across builds if the compiler\n         // is changing under your feet.`\n         if self.config.incremental && compiler.stage == 0 {\n-            let incr_dir = self.incremental_dir(compiler);\n-            cargo.env(\"RUSTC_INCREMENTAL\", incr_dir);\n+            cargo.env(\"CARGO_INCREMENTAL\", \"1\");\n         }\n \n         if let Some(ref on_fail) = self.config.on_fail {"}, {"sha": "0bc82c4f9f2c2571235083bca558478f6eeaf536", "filename": "src/bootstrap/check.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "patch": "@@ -0,0 +1,163 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! Implementation of compiling the compiler and standard library, in \"check\" mode.\n+\n+use compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, add_to_sysroot};\n+use builder::{RunConfig, Builder, ShouldRun, Step};\n+use {Build, Compiler, Mode};\n+use cache::Interned;\n+use std::path::PathBuf;\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Std {\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Std {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/libstd\").krate(\"std\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Std {\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        let compiler = builder.compiler(0, build.build);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n+        println!(\"Checking std artifacts ({} -> {})\", &compiler.host, target);\n+\n+        let out_dir = build.stage_out(compiler, Mode::Libstd);\n+        build.clear_if_dirty(&out_dir, &builder.rustc(compiler));\n+        let mut cargo = builder.cargo(compiler, Mode::Libstd, target, \"check\");\n+        std_cargo(build, &compiler, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &libstd_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &libstd_stamp(build, compiler, target));\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Rustc {\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Rustc {\n+    type Output = ();\n+    const ONLY_HOSTS: bool = true;\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/librustc\").krate(\"rustc-main\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Rustc {\n+            target: run.target,\n+        });\n+    }\n+\n+    /// Build the compiler.\n+    ///\n+    /// This will build the compiler for a particular stage of the build using\n+    /// the `compiler` targeting the `target` architecture. The artifacts\n+    /// created will also be linked into the sysroot directory.\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let compiler = builder.compiler(0, build.build);\n+        let target = self.target;\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n+        println!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target);\n+\n+        let stage_out = builder.stage_out(compiler, Mode::Librustc);\n+        build.clear_if_dirty(&stage_out, &libstd_stamp(build, compiler, target));\n+        build.clear_if_dirty(&stage_out, &libtest_stamp(build, compiler, target));\n+\n+        let mut cargo = builder.cargo(compiler, Mode::Librustc, target, \"check\");\n+        rustc_cargo(build, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &librustc_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &librustc_stamp(build, compiler, target));\n+    }\n+}\n+\n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct Test {\n+    pub target: Interned<String>,\n+}\n+\n+impl Step for Test {\n+    type Output = ();\n+    const DEFAULT: bool = true;\n+\n+    fn should_run(run: ShouldRun) -> ShouldRun {\n+        run.path(\"src/libtest\").krate(\"test\")\n+    }\n+\n+    fn make_run(run: RunConfig) {\n+        run.builder.ensure(Test {\n+            target: run.target,\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder) {\n+        let build = builder.build;\n+        let target = self.target;\n+        let compiler = builder.compiler(0, build.build);\n+\n+        let _folder = build.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n+        println!(\"Checking test artifacts ({} -> {})\", &compiler.host, target);\n+        let out_dir = build.stage_out(compiler, Mode::Libtest);\n+        build.clear_if_dirty(&out_dir, &libstd_stamp(build, compiler, target));\n+        let mut cargo = builder.cargo(compiler, Mode::Libtest, target, \"check\");\n+        test_cargo(build, &compiler, target, &mut cargo);\n+        run_cargo(build,\n+                  &mut cargo,\n+                  &libtest_stamp(build, compiler, target),\n+                  true);\n+        let libdir = builder.sysroot_libdir(compiler, target);\n+        add_to_sysroot(&libdir, &libtest_stamp(build, compiler, target));\n+    }\n+}\n+\n+/// Cargo's output path for the standard library in a given stage, compiled\n+/// by a particular compiler for the specified target.\n+pub fn libstd_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libstd, target).join(\".libstd-check.stamp\")\n+}\n+\n+/// Cargo's output path for libtest in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn libtest_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Libtest, target).join(\".libtest-check.stamp\")\n+}\n+\n+/// Cargo's output path for librustc in a given stage, compiled by a particular\n+/// compiler for the specified target.\n+pub fn librustc_stamp(build: &Build, compiler: Compiler, target: Interned<String>) -> PathBuf {\n+    build.cargo_out(compiler, Mode::Librustc, target).join(\".librustc-check.stamp\")\n+}\n+"}, {"sha": "21bbd82dd333a725df98687ff1ad0559ae54fc7b", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "patch": "@@ -108,7 +108,8 @@ impl Step for Std {\n         std_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &libstd_stamp(build, compiler, target));\n+                  &libstd_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(StdLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -360,7 +361,8 @@ impl Step for Test {\n         test_cargo(build, &compiler, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &libtest_stamp(build, compiler, target));\n+                  &libtest_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(TestLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -488,7 +490,8 @@ impl Step for Rustc {\n         rustc_cargo(build, target, &mut cargo);\n         run_cargo(build,\n                   &mut cargo,\n-                  &librustc_stamp(build, compiler, target));\n+                  &librustc_stamp(build, compiler, target),\n+                  false);\n \n         builder.ensure(RustcLink {\n             compiler: builder.compiler(compiler.stage, build.build),\n@@ -755,7 +758,7 @@ impl Step for Assemble {\n ///\n /// For a particular stage this will link the file listed in `stamp` into the\n /// `sysroot_dst` provided.\n-fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n+pub fn add_to_sysroot(sysroot_dst: &Path, stamp: &Path) {\n     t!(fs::create_dir_all(&sysroot_dst));\n     for path in read_stamp_file(stamp) {\n         copy(&path, &sysroot_dst.join(path.file_name().unwrap()));\n@@ -785,7 +788,7 @@ fn stderr_isatty() -> bool {\n     }\n }\n \n-fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n+pub fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path, is_check: bool) {\n     // Instruct Cargo to give us json messages on stdout, critically leaving\n     // stderr as piped so we can get those pretty colors.\n     cargo.arg(\"--message-format\").arg(\"json\")\n@@ -836,7 +839,8 @@ fn run_cargo(build: &Build, cargo: &mut Command, stamp: &Path) {\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n-               !is_dylib(&filename) {\n+               !is_dylib(&filename) &&\n+               !(is_check && filename.ends_with(\".rmeta\")) {\n                 continue\n             }\n "}, {"sha": "478e496078add23a5b85842e820ecf78b41335c0", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "patch": "@@ -48,6 +48,9 @@ pub enum Subcommand {\n     Build {\n         paths: Vec<PathBuf>,\n     },\n+    Check {\n+        paths: Vec<PathBuf>,\n+    },\n     Doc {\n         paths: Vec<PathBuf>,\n     },\n@@ -88,6 +91,7 @@ Usage: x.py <subcommand> [options] [<paths>...]\n \n Subcommands:\n     build       Compile either the compiler or libraries\n+    check       Compile either the compiler or libraries, using cargo check\n     test        Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n@@ -128,6 +132,7 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\");\n         // there on out.\n         let subcommand = args.iter().find(|&s|\n             (s == \"build\")\n+            || (s == \"check\")\n             || (s == \"test\")\n             || (s == \"bench\")\n             || (s == \"doc\")\n@@ -217,6 +222,21 @@ Arguments:\n     arguments would), and then use the compiler built in stage 0 to build\n     src/libtest and its dependencies.\n     Once this is done, build/$ARCH/stage1 contains a usable compiler.\");\n+            }\n+            \"check\" => {\n+                subcommand_help.push_str(\"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to compile. For example:\n+\n+        ./x.py check src/libcore\n+        ./x.py check src/libcore src/libproc_macro\n+\n+    If no arguments are passed then the complete artifacts are compiled: std, test, and rustc. Note\n+    also that since we use `cargo check`, by default this will automatically enable incremental\n+    compilation, so there's no need to pass it separately, though it won't hurt. We also completely\n+    ignore the stage passed, as there's no way to compile in non-stage 0 without actually building\n+    the compiler.\");\n             }\n             \"test\" => {\n                 subcommand_help.push_str(\"\\n\n@@ -286,6 +306,9 @@ Arguments:\n             \"build\" => {\n                 Subcommand::Build { paths: paths }\n             }\n+            \"check\" => {\n+                Subcommand::Check { paths: paths }\n+            }\n             \"test\" => {\n                 Subcommand::Test {\n                     paths,"}, {"sha": "565320c95217639aa8a3182e22de466a1bf3b46d", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6aeb1cfb64ea04e334d296bf9a47c659116c96bf/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=6aeb1cfb64ea04e334d296bf9a47c659116c96bf", "patch": "@@ -150,6 +150,7 @@ use util::{exe, libdir, OutputFolder, CiEnv};\n mod cc_detect;\n mod channel;\n mod check;\n+mod test;\n mod clean;\n mod compile;\n mod metadata;\n@@ -449,12 +450,6 @@ impl Build {\n         out\n     }\n \n-    /// Get the directory for incremental by-products when using the\n-    /// given compiler.\n-    fn incremental_dir(&self, compiler: Compiler) -> PathBuf {\n-        self.out.join(&*compiler.host).join(format!(\"stage{}-incremental\", compiler.stage))\n-    }\n-\n     /// Returns the root directory for all output generated in a particular\n     /// stage when running with a particular host compiler.\n     ///"}]}