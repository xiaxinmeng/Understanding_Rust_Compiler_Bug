{"sha": "47b8479e73e40395f1b1b2d0c6281f28f80301e4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ3Yjg0NzllNzNlNDAzOTVmMWIxYjJkMGM2MjgxZjI4ZjgwMzAxZTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-01T04:01:02Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-01-01T04:01:02Z"}, "message": "auto merge of #20363 : japaric/rust/moar-uc, r=nmatsakis\n\nThe the last argument of the `ItemDecorator::expand` method has changed to `Box<FnMut>`. Syntax extensions will break.\r\n\r\n[breaking-change]\r\n\r\n---\r\n\r\nThis PR removes pretty much all the remaining uses of boxed closures from the libraries. There are still boxed closures under the `test` directory, but I think those should be removed or replaced with unboxed closures at the same time we remove boxed closures from the language.\r\n\r\nIn a few places I had to do some contortions (see the first commit for an example) to work around issue #19596. I have marked those workarounds with FIXMEs. In the future when `&mut F where F: FnMut` implements the `FnMut` trait, we should be able to remove those workarounds. I've take care to avoid placing the workaround functions in the public API.\r\n\r\nSince `let f = || {}` always gets type checked as a boxed closure, I have explictly annotated those closures (with e.g. `|&:| {}`) to force the compiler to type check them as unboxed closures.\r\n\r\nInstead of removing the type aliases (like `GetCrateDataCb`), I could have replaced them with newtypes. But this seemed like overcomplicating things for little to no gain.\r\n\r\nI think we should be able to remove the boxed closures from the languge after this PR lands. (I'm being optimistic here)\r\n\r\nr? @alexcrichton or @aturon \r\ncc @nikomatsakis", "tree": {"sha": "a8ae69e94286da9d3b153e39300130271ad1f3f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a8ae69e94286da9d3b153e39300130271ad1f3f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47b8479e73e40395f1b1b2d0c6281f28f80301e4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47b8479e73e40395f1b1b2d0c6281f28f80301e4", "html_url": "https://github.com/rust-lang/rust/commit/47b8479e73e40395f1b1b2d0c6281f28f80301e4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47b8479e73e40395f1b1b2d0c6281f28f80301e4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d4f4876d65bddf101784230c0347adcb01e5c21", "url": "https://api.github.com/repos/rust-lang/rust/commits/7d4f4876d65bddf101784230c0347adcb01e5c21", "html_url": "https://github.com/rust-lang/rust/commit/7d4f4876d65bddf101784230c0347adcb01e5c21"}, {"sha": "10bbf69488b4863378e4acd9d55bde36b4a20909", "url": "https://api.github.com/repos/rust-lang/rust/commits/10bbf69488b4863378e4acd9d55bde36b4a20909", "html_url": "https://github.com/rust-lang/rust/commit/10bbf69488b4863378e4acd9d55bde36b4a20909"}], "stats": {"total": 472, "additions": 248, "deletions": 224}, "files": [{"sha": "e5aa377b27546be34282faf5498871eeebf4fa2b", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -202,7 +202,7 @@ impl<'a> Iterator<char> for Decompositions<'a> {\n                 let buffer = &mut self.buffer;\n                 let sorted = &mut self.sorted;\n                 {\n-                    let callback = |d| {\n+                    let callback = |&mut: d| {\n                         let class =\n                             unicode::char::canonical_combining_class(d);\n                         if class == 0 && !*sorted {"}, {"sha": "d3b1d8efe8bfc889f06d6ee4993c7a59ee6da071", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -225,10 +225,10 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n         // cut off the one extra digit, and depending on its value\n         // round the remaining ones.\n         if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n+            let ascii2value = |&: chr: u8| {\n                 (chr as char).to_digit(radix).unwrap()\n             };\n-            let value2ascii = |val: uint| {\n+            let value2ascii = |&: val: uint| {\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n "}, {"sha": "95753f4b671d5c24480e02b6c34437920f4c7095", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -398,7 +398,7 @@ impl<'a> Formatter<'a> {\n         }\n \n         // Writes the sign if it exists, and then the prefix if it was requested\n-        let write_prefix = |f: &mut Formatter| {\n+        let write_prefix = |&: f: &mut Formatter| {\n             for c in sign.into_iter() {\n                 let mut b = [0, ..4];\n                 let n = c.encode_utf8(&mut b).unwrap_or(0);"}, {"sha": "0db0bd413ac949b5aa800db49f09b19265a31cba", "filename": "src/libgetopts/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibgetopts%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibgetopts%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibgetopts%2Flib.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -875,7 +875,7 @@ fn each_split_within<F>(ss: &str, lim: uint, mut it: F) -> bool where\n         lim = fake_i;\n     }\n \n-    let machine: |&mut bool, (uint, char)| -> bool = |cont, (i, c)| {\n+    let mut machine = |&mut: cont: &mut bool, (i, c): (uint, char)| -> bool {\n         let whitespace = if c.is_whitespace() { Ws }       else { Cr };\n         let limit      = if (i - slice_start + 1) <= lim  { UnderLim } else { OverLim };\n "}, {"sha": "5dac2bafaec3d847508de229b3244ca3a169f812", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -177,7 +177,7 @@ fn extract_crate_info(e: &Env, i: &ast::ViewItem) -> Option<CrateInfo> {\n }\n \n pub fn validate_crate_name(sess: Option<&Session>, s: &str, sp: Option<Span>) {\n-    let err = |s: &str| {\n+    let err = |&: s: &str| {\n         match (sp, sess) {\n             (_, None) => panic!(\"{}\", s),\n             (Some(sp), Some(sess)) => sess.span_err(sp, s),"}, {"sha": "2b11b8517b0d87658b3ec8f416688e919470dcdf", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -62,7 +62,7 @@ pub fn each_child_of_item<F>(cstore: &cstore::CStore,\n     F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n {\n     let crate_data = cstore.get_crate_data(def_id.krate);\n-    let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n+    let get_crate_data = |&mut: cnum| {\n         cstore.get_crate_data(cnum)\n     };\n     decoder::each_child_of_item(cstore.intr.clone(),\n@@ -79,7 +79,7 @@ pub fn each_top_level_item_of_crate<F>(cstore: &cstore::CStore,\n     F: FnMut(decoder::DefLike, ast::Name, ast::Visibility),\n {\n     let crate_data = cstore.get_crate_data(cnum);\n-    let get_crate_data: decoder::GetCrateDataCb = |cnum| {\n+    let get_crate_data = |&mut: cnum| {\n         cstore.get_crate_data(cnum)\n     };\n     decoder::each_top_level_item_of_crate(cstore.intr.clone(),"}, {"sha": "d079d0e52aafa523cfa2aa2bbb9af00914089de4", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -487,14 +487,13 @@ pub fn each_lang_item<F>(cdata: Cmd, mut f: F) -> bool where\n     })\n }\n \n-pub type GetCrateDataCb<'a> = |ast::CrateNum|: 'a -> Rc<crate_metadata>;\n-\n-fn each_child_of_item_or_crate<F>(intr: Rc<IdentInterner>,\n-                                  cdata: Cmd,\n-                                  item_doc: rbml::Doc,\n-                                  get_crate_data: GetCrateDataCb,\n-                                  mut callback: F) where\n+fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n+                                     cdata: Cmd,\n+                                     item_doc: rbml::Doc,\n+                                     mut get_crate_data: G,\n+                                     mut callback: F) where\n     F: FnMut(DefLike, ast::Name, ast::Visibility),\n+    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Iterate over all children.\n     let _ = reader::tagged_docs(item_doc, tag_mod_child, |child_info_doc| {\n@@ -608,12 +607,13 @@ fn each_child_of_item_or_crate<F>(intr: Rc<IdentInterner>,\n }\n \n /// Iterates over each child of the given item.\n-pub fn each_child_of_item<F>(intr: Rc<IdentInterner>,\n-                             cdata: Cmd,\n-                             id: ast::NodeId,\n-                             get_crate_data: GetCrateDataCb,\n-                             callback: F) where\n+pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n+                               cdata: Cmd,\n+                               id: ast::NodeId,\n+                               get_crate_data: G,\n+                               callback: F) where\n     F: FnMut(DefLike, ast::Name, ast::Visibility),\n+    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Find the item.\n     let root_doc = rbml::Doc::new(cdata.data());\n@@ -631,11 +631,12 @@ pub fn each_child_of_item<F>(intr: Rc<IdentInterner>,\n }\n \n /// Iterates over all the top-level crate items.\n-pub fn each_top_level_item_of_crate<F>(intr: Rc<IdentInterner>,\n-                                       cdata: Cmd,\n-                                       get_crate_data: GetCrateDataCb,\n-                                       callback: F) where\n+pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n+                                          cdata: Cmd,\n+                                          get_crate_data: G,\n+                                          callback: F) where\n     F: FnMut(DefLike, ast::Name, ast::Visibility),\n+    G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n     let misc_info_doc = reader::get_doc(root_doc, tag_misc_info);"}, {"sha": "8378c620c1d193ef5442d21b3fa3697f98e5cf57", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -1418,7 +1418,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             encode_parent_sort(rbml_w, 't');\n \n             let trait_item = &ms[i];\n-            let encode_trait_item = |rbml_w: &mut Encoder| {\n+            let encode_trait_item = |&: rbml_w: &mut Encoder| {\n                 // If this is a static method, we've already\n                 // encoded this.\n                 if is_nonstatic_method {"}, {"sha": "82071931fe3a654253b4907350f2c321d22efd38", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -30,10 +30,6 @@ pub enum FileMatch {\n // FIXME (#2658): I'm not happy how this module turned out. Should\n // probably just be folded into cstore.\n \n-/// Functions with type `pick` take a parent directory as well as\n-/// a file found in that directory.\n-pub type pick<'a> = |path: &Path|: 'a -> FileMatch;\n-\n pub struct FileSearch<'a> {\n     pub sysroot: &'a Path,\n     pub search_paths: &'a SearchPaths,\n@@ -95,7 +91,7 @@ impl<'a> FileSearch<'a> {\n         make_target_lib_path(self.sysroot, self.triple)\n     }\n \n-    pub fn search(&self, pick: pick) {\n+    pub fn search<F>(&self, mut pick: F) where F: FnMut(&Path) -> FileMatch {\n         self.for_each_lib_search_path(|lib_search_path| {\n             debug!(\"searching {}\", lib_search_path.display());\n             match fs::readdir(lib_search_path) {"}, {"sha": "6277656e03afce8e97ec780138c507075cbe03c1", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -185,7 +185,7 @@ fn check_expr(v: &mut CheckCrateVisitor, e: &ast::Expr) -> bool {\n         ast::ExprBlock(ref block) => {\n             // Check all statements in the block\n             for stmt in block.stmts.iter() {\n-                let block_span_err = |span|\n+                let block_span_err = |&: span|\n                     span_err!(v.tcx.sess, span, E0016,\n                               \"blocks in constants are limited to items and \\\n                                tail expressions\");"}, {"sha": "4c5d76a2c40e57d0507faa689fc5106f21f02677", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -1012,7 +1012,7 @@ fn check_legality_of_move_bindings(cx: &MatchCheckCtxt,\n         })\n     }\n \n-    let check_move: |&Pat, Option<&Pat>| = |p, sub| {\n+    let check_move = |&: p: &Pat, sub: Option<&Pat>| {\n         // check legality of moving out of the enum\n \n         // x @ Foo(..) is legal, but x @ Foo(y) isn't."}, {"sha": "8455ee3955bd06cefa8348dc34b4c3f89d859c5a", "filename": "src/librustc/middle/infer/region_inference/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fgraphviz.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -136,7 +136,7 @@ impl<'a, 'tcx> ConstraintGraph<'a, 'tcx> {\n         let mut i = 0;\n         let mut node_ids = FnvHashMap::new();\n         {\n-            let add_node = |node| {\n+            let mut add_node = |&mut : node| {\n                 if let Vacant(e) = node_ids.entry(node) {\n                     e.set(i);\n                     i += 1;"}, {"sha": "580b3a93d73974dbf82691424bff0b0ea4e3c387", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -1122,11 +1122,15 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n         })\n     }\n \n-    // FIXME(#19596) unbox `op`\n-    pub fn cat_pattern(&self,\n-                       cmt: cmt<'tcx>,\n-                       pat: &ast::Pat,\n-                       op: |&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat|)\n+    pub fn cat_pattern<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, mut op: F) where\n+        F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n+    {\n+        self.cat_pattern_(cmt, pat, &mut op)\n+    }\n+\n+    // FIXME(#19596) This is a workaround, but there should be a better way to do this\n+    fn cat_pattern_<F>(&self, cmt: cmt<'tcx>, pat: &ast::Pat, op: &mut F) where\n+        F: FnMut(&MemCategorizationContext<'t, TYPER>, cmt<'tcx>, &ast::Pat),\n     {\n         // Here, `cmt` is the categorization for the value being\n         // matched and pat is the pattern it is being matched against.\n@@ -1177,7 +1181,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                pat.id, pprust::pat_to_string(pat),\n                cmt.repr(self.tcx()));\n \n-        op(self, cmt.clone(), pat);\n+        (*op)(self, cmt.clone(), pat);\n \n         let def_map = self.tcx().def_map.borrow();\n         let opt_def = def_map.get(&pat.id);\n@@ -1214,7 +1218,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n \n-                        self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z));\n+                        self.cat_pattern_(subcmt, &**subpat, op);\n                     }\n                 }\n                 Some(&def::DefStruct(..)) => {\n@@ -1224,13 +1228,12 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                             self.cat_imm_interior(\n                                 pat, cmt.clone(), subpat_ty,\n                                 InteriorField(PositionalField(i)));\n-                        self.cat_pattern(cmt_field, &**subpat,\n-                                         |x,y,z| op(x,y,z));\n+                        self.cat_pattern_(cmt_field, &**subpat, op);\n                     }\n                 }\n                 Some(&def::DefConst(..)) => {\n                     for subpat in subpats.iter() {\n-                        self.cat_pattern(cmt.clone(), &**subpat, |x,y,z| op(x,y,z));\n+                        self.cat_pattern_(cmt.clone(), &**subpat, op);\n                     }\n                 }\n                 _ => {\n@@ -1242,7 +1245,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n           }\n \n           ast::PatIdent(_, _, Some(ref subpat)) => {\n-              self.cat_pattern(cmt, &**subpat, op);\n+              self.cat_pattern_(cmt, &**subpat, op);\n           }\n \n           ast::PatIdent(_, _, None) => {\n@@ -1254,7 +1257,7 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n             for fp in field_pats.iter() {\n                 let field_ty = self.pat_ty(&*fp.node.pat); // see (*2)\n                 let cmt_field = self.cat_field(pat, cmt.clone(), fp.node.ident.name, field_ty);\n-                self.cat_pattern(cmt_field, &*fp.node.pat, |x,y,z| op(x,y,z));\n+                self.cat_pattern_(cmt_field, &*fp.node.pat, op);\n             }\n           }\n \n@@ -1266,29 +1269,28 @@ impl<'t,'tcx,TYPER:Typer<'tcx>> MemCategorizationContext<'t,TYPER> {\n                     self.cat_imm_interior(\n                         pat, cmt.clone(), subpat_ty,\n                         InteriorField(PositionalField(i)));\n-                self.cat_pattern(subcmt, &**subpat, |x,y,z| op(x,y,z));\n+                self.cat_pattern_(subcmt, &**subpat, op);\n             }\n           }\n \n           ast::PatBox(ref subpat) | ast::PatRegion(ref subpat) => {\n             // @p1, ~p1, ref p1\n             let subcmt = self.cat_deref(pat, cmt, 0, false);\n-            self.cat_pattern(subcmt, &**subpat, op);\n+            self.cat_pattern_(subcmt, &**subpat, op);\n           }\n \n           ast::PatVec(ref before, ref slice, ref after) => {\n               let elt_cmt = self.cat_index(pat, self.deref_vec(pat, cmt));\n               for before_pat in before.iter() {\n-                  self.cat_pattern(elt_cmt.clone(), &**before_pat,\n-                                   |x,y,z| op(x,y,z));\n+                  self.cat_pattern_(elt_cmt.clone(), &**before_pat, op);\n               }\n               for slice_pat in slice.iter() {\n                   let slice_ty = self.pat_ty(&**slice_pat);\n                   let slice_cmt = self.cat_rvalue_node(pat.id(), pat.span(), slice_ty);\n-                  self.cat_pattern(slice_cmt, &**slice_pat, |x,y,z| op(x,y,z));\n+                  self.cat_pattern_(slice_cmt, &**slice_pat, op);\n               }\n               for after_pat in after.iter() {\n-                  self.cat_pattern(elt_cmt.clone(), &**after_pat, |x,y,z| op(x,y,z));\n+                  self.cat_pattern_(elt_cmt.clone(), &**after_pat, op);\n               }\n           }\n "}, {"sha": "cfa0d419aa3f0d53ae8f4b813edb8815e596f522", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -749,7 +749,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n     fn check_path(&mut self, span: Span, path_id: ast::NodeId, path: &ast::Path) {\n         debug!(\"privacy - path {}\", self.nodestr(path_id));\n         let orig_def = self.tcx.def_map.borrow()[path_id].clone();\n-        let ck = |tyname: &str| {\n+        let ck = |&: tyname: &str| {\n             let ck_public = |def: ast::DefId| {\n                 let name = token::get_ident(path.segments.last().unwrap().identifier);\n                 let origdid = orig_def.def_id();\n@@ -921,7 +921,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                 }\n             }\n             ast::ExprPath(..) => {\n-                let guard = |did: ast::DefId| {\n+                let guard = |&: did: ast::DefId| {\n                     let fields = ty::lookup_struct_fields(self.tcx, did);\n                     let any_priv = fields.iter().any(|f| {\n                         f.vis != ast::Public && (\n@@ -1126,7 +1126,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     /// later on down the road...\n     fn check_sane_privacy(&self, item: &ast::Item) {\n         let tcx = self.tcx;\n-        let check_inherited = |sp: Span, vis: ast::Visibility, note: &str| {\n+        let check_inherited = |&: sp: Span, vis: ast::Visibility, note: &str| {\n             if vis != ast::Inherited {\n                 tcx.sess.span_err(sp, \"unnecessary visibility qualifier\");\n                 if note.len() > 0 {\n@@ -1206,7 +1206,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n                 tcx.sess.span_err(sp, \"visibility has no effect inside functions\");\n             }\n         }\n-        let check_struct = |def: &ast::StructDef| {\n+        let check_struct = |&: def: &ast::StructDef| {\n             for f in def.fields.iter() {\n                match f.node.kind {\n                     ast::NamedField(_, p) => check_inherited(tcx, f.span, p),"}, {"sha": "be89b32cdaae623abcc75a94fe56defce6bb4c6e", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -488,7 +488,7 @@ fn resolve_expr(visitor: &mut RegionResolutionVisitor, expr: &ast::Expr) {\n \n     {\n         let region_maps = &mut visitor.region_maps;\n-        let terminating = |id| {\n+        let terminating = |&: id| {\n             let scope = CodeExtent::from_node_id(id);\n             region_maps.mark_as_terminating_scope(scope)\n         };"}, {"sha": "8e7470f5084b0cb2266b7403841251c0db032795", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 43, "deletions": 39, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -2812,49 +2812,53 @@ pub fn walk_ty<'tcx, F>(ty: Ty<'tcx>, mut f: F) where\n     maybe_walk_ty(ty, |ty| { f(ty); true });\n }\n \n-// FIXME(#19596) unbox `f`\n-pub fn maybe_walk_ty<'tcx>(ty: Ty<'tcx>, f: |Ty<'tcx>| -> bool) {\n-    if !f(ty) {\n-        return;\n-    }\n-    match ty.sty {\n-        ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n-        ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n-        ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty(ty, f),\n-        ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n-            maybe_walk_ty(tm.ty, f);\n+pub fn maybe_walk_ty<'tcx, F>(ty: Ty<'tcx>, mut f: F) where F: FnMut(Ty<'tcx>) -> bool {\n+    // FIXME(#19596) This is a workaround, but there should be a better way to do this\n+    fn maybe_walk_ty_<'tcx, F>(ty: Ty<'tcx>, f: &mut F) where F: FnMut(Ty<'tcx>) -> bool {\n+        if !(*f)(ty) {\n+            return;\n         }\n-        ty_trait(box TyTrait { ref principal, .. }) => {\n-            for subty in principal.0.substs.types.iter() {\n-                maybe_walk_ty(*subty, |x| f(x));\n+        match ty.sty {\n+            ty_bool | ty_char | ty_int(_) | ty_uint(_) | ty_float(_) |\n+            ty_str | ty_infer(_) | ty_param(_) | ty_err => {}\n+            ty_uniq(ty) | ty_vec(ty, _) | ty_open(ty) => maybe_walk_ty_(ty, f),\n+            ty_ptr(ref tm) | ty_rptr(_, ref tm) => {\n+                maybe_walk_ty_(tm.ty, f);\n+            }\n+            ty_trait(box TyTrait { ref principal, .. }) => {\n+                for subty in principal.0.substs.types.iter() {\n+                    maybe_walk_ty_(*subty, f);\n+                }\n             }\n-        }\n-        ty_projection(ProjectionTy { ref trait_ref, .. }) => {\n-            for subty in trait_ref.substs.types.iter() {\n-                maybe_walk_ty(*subty, |x| f(x));\n+            ty_projection(ProjectionTy { ref trait_ref, .. }) => {\n+                for subty in trait_ref.substs.types.iter() {\n+                    maybe_walk_ty_(*subty, f);\n+                }\n             }\n-        }\n-        ty_enum(_, ref substs) |\n-        ty_struct(_, ref substs) |\n-        ty_unboxed_closure(_, _, ref substs) => {\n-            for subty in substs.types.iter() {\n-                maybe_walk_ty(*subty, |x| f(x));\n+            ty_enum(_, ref substs) |\n+            ty_struct(_, ref substs) |\n+            ty_unboxed_closure(_, _, ref substs) => {\n+                for subty in substs.types.iter() {\n+                    maybe_walk_ty_(*subty, f);\n+                }\n             }\n-        }\n-        ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty(*tt, |x| f(x)); } }\n-        ty_bare_fn(_, ref ft) => {\n-            for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            if let ty::FnConverging(output) = ft.sig.0.output {\n-                maybe_walk_ty(output, f);\n+            ty_tup(ref ts) => { for tt in ts.iter() { maybe_walk_ty_(*tt, f); } }\n+            ty_bare_fn(_, ref ft) => {\n+                for a in ft.sig.0.inputs.iter() { maybe_walk_ty_(*a, f); }\n+                if let ty::FnConverging(output) = ft.sig.0.output {\n+                    maybe_walk_ty_(output, f);\n+                }\n             }\n-        }\n-        ty_closure(ref ft) => {\n-            for a in ft.sig.0.inputs.iter() { maybe_walk_ty(*a, |x| f(x)); }\n-            if let ty::FnConverging(output) = ft.sig.0.output {\n-                maybe_walk_ty(output, f);\n+            ty_closure(ref ft) => {\n+                for a in ft.sig.0.inputs.iter() { maybe_walk_ty_(*a, f); }\n+                if let ty::FnConverging(output) = ft.sig.0.output {\n+                    maybe_walk_ty_(output, f);\n+                }\n             }\n         }\n     }\n+\n+    maybe_walk_ty_(ty, &mut f);\n }\n \n // Folds types from the bottom up.\n@@ -6155,7 +6159,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n         macro_rules! byte( ($b:expr) => { ($b as u8).hash(state) } );\n         macro_rules! hash( ($e:expr) => { $e.hash(state) } );\n \n-        let region = |state: &mut sip::SipState, r: Region| {\n+        let region = |&: state: &mut sip::SipState, r: Region| {\n             match r {\n                 ReStatic => {}\n                 ReLateBound(db, BrAnon(i)) => {\n@@ -6172,7 +6176,7 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n                 }\n             }\n         };\n-        let did = |state: &mut sip::SipState, did: DefId| {\n+        let did = |&: state: &mut sip::SipState, did: DefId| {\n             let h = if ast_util::is_local(did) {\n                 svh.clone()\n             } else {\n@@ -6181,10 +6185,10 @@ pub fn hash_crate_independent<'tcx>(tcx: &ctxt<'tcx>, ty: Ty<'tcx>, svh: &Svh) -\n             h.as_str().hash(state);\n             did.node.hash(state);\n         };\n-        let mt = |state: &mut sip::SipState, mt: mt| {\n+        let mt = |&: state: &mut sip::SipState, mt: mt| {\n             mt.mutbl.hash(state);\n         };\n-        let fn_sig = |state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n+        let fn_sig = |&: state: &mut sip::SipState, sig: &Binder<FnSig<'tcx>>| {\n             let sig = anonymize_late_bound_regions(tcx, sig);\n             for a in sig.inputs.iter() { helper(tcx, *a, svh, state); }\n             if let ty::FnConverging(output) = sig.output {"}, {"sha": "fdc9b72f1e9df71aabfb00f4abb09317f9ea965a", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -217,7 +217,7 @@ impl Target {\n \n         let handler = diagnostic::default_handler(diagnostic::Auto, None);\n \n-        let get_req_field = |name: &str| {\n+        let get_req_field = |&: name: &str| {\n             match obj.find(name)\n                      .map(|s| s.as_string())\n                      .and_then(|os| os.map(|s| s.to_string())) {"}, {"sha": "90da8906a6fa08e19be3a7da742d7aaeb8c21da1", "filename": "src/librustc_borrowck/borrowck/fragments.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Ffragments.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -44,7 +44,7 @@ enum Fragment {\n \n impl Fragment {\n     fn loan_path_repr<'tcx>(&self, move_data: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) -> String {\n-        let repr = |mpi| move_data.path_loan_path(mpi).repr(tcx);\n+        let repr = |&: mpi| move_data.path_loan_path(mpi).repr(tcx);\n         match *self {\n             Just(mpi) => repr(mpi),\n             AllButOneFrom(mpi) => format!(\"$(allbutone {})\", repr(mpi)),\n@@ -54,7 +54,7 @@ impl Fragment {\n     fn loan_path_user_string<'tcx>(&self,\n                                    move_data: &MoveData<'tcx>,\n                                    tcx: &ty::ctxt<'tcx>) -> String {\n-        let user_string = |mpi| move_data.path_loan_path(mpi).user_string(tcx);\n+        let user_string = |&: mpi| move_data.path_loan_path(mpi).user_string(tcx);\n         match *self {\n             Just(mpi) => user_string(mpi),\n             AllButOneFrom(mpi) => format!(\"$(allbutone {})\", user_string(mpi)),\n@@ -140,9 +140,9 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n \n     if !span_err && !print { return; }\n \n-    let instrument_all_paths = |kind, vec_rc: &Vec<MovePathIndex>| {\n+    let instrument_all_paths = |&: kind, vec_rc: &Vec<MovePathIndex>| {\n         for (i, mpi) in vec_rc.iter().enumerate() {\n-            let render = || this.path_loan_path(*mpi).user_string(tcx);\n+            let render = |&:| this.path_loan_path(*mpi).user_string(tcx);\n             if span_err {\n                 tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n             }\n@@ -152,9 +152,9 @@ pub fn instrument_move_fragments<'tcx>(this: &MoveData<'tcx>,\n         }\n     };\n \n-    let instrument_all_fragments = |kind, vec_rc: &Vec<Fragment>| {\n+    let instrument_all_fragments = |&: kind, vec_rc: &Vec<Fragment>| {\n         for (i, f) in vec_rc.iter().enumerate() {\n-            let render = || f.loan_path_user_string(this, tcx);\n+            let render = |&:| f.loan_path_user_string(this, tcx);\n             if span_err {\n                 tcx.sess.span_err(sp, format!(\"{}: `{}`\", kind, render())[]);\n             }\n@@ -187,11 +187,11 @@ pub fn fixup_fragment_sets<'tcx>(this: &MoveData<'tcx>, tcx: &ty::ctxt<'tcx>) {\n     let mut moved = mem::replace(&mut fragments.moved_leaf_paths, vec![]);\n     let mut assigned = mem::replace(&mut fragments.assigned_leaf_paths, vec![]);\n \n-    let path_lps = |mpis: &[MovePathIndex]| -> Vec<String> {\n+    let path_lps = |&: mpis: &[MovePathIndex]| -> Vec<String> {\n         mpis.iter().map(|mpi| this.path_loan_path(*mpi).repr(tcx)).collect()\n     };\n \n-    let frag_lps = |fs: &[Fragment]| -> Vec<String> {\n+    let frag_lps = |&: fs: &[Fragment]| -> Vec<String> {\n         fs.iter().map(|f| f.loan_path_repr(this, tcx)).collect()\n     };\n \n@@ -344,7 +344,7 @@ fn add_fragment_siblings_for_extension<'tcx>(this: &MoveData<'tcx>,\n                                                                         Rc<LoanPath<'tcx>>)>) {\n     let parent_ty = parent_lp.to_type();\n \n-    let add_fragment_sibling_local = |field_name, variant_did| {\n+    let mut add_fragment_sibling_local = |&mut : field_name, variant_did| {\n         add_fragment_sibling_core(\n             this, tcx, gathered_fragments, parent_lp.clone(), mc, field_name, origin_lp,\n             variant_did);"}, {"sha": "ad31c52ca34f0eb150e0fdf259c06657b4674224", "filename": "src/librustc_borrowck/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -58,7 +58,7 @@ impl<'a, 'tcx> RestrictionsContext<'a, 'tcx> {\n                 cmt: mc::cmt<'tcx>) -> RestrictionResult<'tcx> {\n         debug!(\"restrict(cmt={})\", cmt.repr(self.bccx.tcx));\n \n-        let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n+        let new_lp = |&: v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n \n         match cmt.cat.clone() {\n             mc::cat_rvalue(..) => {"}, {"sha": "c27b7b30e1345fdf6997c1368b1957936c67f232", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -431,7 +431,7 @@ pub fn opt_loan_path<'tcx>(cmt: &mc::cmt<'tcx>) -> Option<Rc<LoanPath<'tcx>>> {\n     //! which allows it to share common loan path pieces as it\n     //! traverses the CMT.\n \n-    let new_lp = |v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n+    let new_lp = |&: v: LoanPathKind<'tcx>| Rc::new(LoanPath::new(v, cmt.ty));\n \n     match cmt.cat {\n         mc::cat_rvalue(..) |"}, {"sha": "547e7d272c69d9026430952264f8ce682f001c0e", "filename": "src/librustc_borrowck/borrowck/move_data.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmove_data.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -521,15 +521,17 @@ impl<'tcx> MoveData<'tcx> {\n         return true;\n     }\n \n-    // FIXME(#19596) unbox `f`\n-    fn each_extending_path(&self, index: MovePathIndex, f: |MovePathIndex| -> bool) -> bool {\n-        if !f(index) {\n+    // FIXME(#19596) This is a workaround, but there should be better way to do this\n+    fn each_extending_path_<F>(&self, index: MovePathIndex, f: &mut F) -> bool where\n+        F: FnMut(MovePathIndex) -> bool,\n+    {\n+        if !(*f)(index) {\n             return false;\n         }\n \n         let mut p = self.path_first_child(index);\n         while p != InvalidMovePathIndex {\n-            if !self.each_extending_path(p, |x| f(x)) {\n+            if !self.each_extending_path_(p, f) {\n                 return false;\n             }\n             p = self.path_next_sibling(p);\n@@ -538,6 +540,12 @@ impl<'tcx> MoveData<'tcx> {\n         return true;\n     }\n \n+    fn each_extending_path<F>(&self, index: MovePathIndex, mut f: F) -> bool where\n+        F: FnMut(MovePathIndex) -> bool,\n+    {\n+        self.each_extending_path_(index, &mut f)\n+    }\n+\n     fn each_applicable_move<F>(&self, index0: MovePathIndex, mut f: F) -> bool where\n         F: FnMut(MoveIndex) -> bool,\n     {"}, {"sha": "181f38d89939e0beda86e3d5fbbf6caf23ea390a", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -278,7 +278,7 @@ Available lint options:\n     let max_name_len = plugin.iter().chain(builtin.iter())\n         .map(|&s| s.name.width(true))\n         .max().unwrap_or(0);\n-    let padded = |x: &str| {\n+    let padded = |&: x: &str| {\n         let mut s = repeat(\" \").take(max_name_len - x.chars().count())\n                                .collect::<String>();\n         s.push_str(x);\n@@ -289,7 +289,7 @@ Available lint options:\n     println!(\"    {}  {:7.7}  {}\", padded(\"name\"), \"default\", \"meaning\");\n     println!(\"    {}  {:7.7}  {}\", padded(\"----\"), \"-------\", \"-------\");\n \n-    let print_lints = |lints: Vec<&Lint>| {\n+    let print_lints = |&: lints: Vec<&Lint>| {\n         for lint in lints.into_iter() {\n             let name = lint.name_lower().replace(\"_\", \"-\");\n             println!(\"    {}  {:7.7}  {}\",\n@@ -305,7 +305,7 @@ Available lint options:\n     let max_name_len = plugin_groups.iter().chain(builtin_groups.iter())\n         .map(|&(s, _)| s.width(true))\n         .max().unwrap_or(0);\n-    let padded = |x: &str| {\n+    let padded = |&: x: &str| {\n         let mut s = repeat(\" \").take(max_name_len - x.chars().count())\n                                .collect::<String>();\n         s.push_str(x);\n@@ -316,7 +316,7 @@ Available lint options:\n     println!(\"    {}  {}\", padded(\"name\"), \"sub-lints\");\n     println!(\"    {}  {}\", padded(\"----\"), \"---------\");\n \n-    let print_lint_groups = |lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n+    let print_lint_groups = |&: lints: Vec<(&'static str, Vec<lint::LintId>)>| {\n         for (name, to) in lints.into_iter() {\n             let name = name.chars().map(|x| x.to_lowercase())\n                            .collect::<String>().replace(\"_\", \"-\");"}, {"sha": "773ea30d401fc361fdcb422017fd119983609875", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -301,7 +301,7 @@ fn gather_flowgraph_variants(sess: &Session) -> Vec<borrowck_dot::Variant> {\n     let print_moves   = config::FLOWGRAPH_PRINT_MOVES;\n     let print_assigns = config::FLOWGRAPH_PRINT_ASSIGNS;\n     let print_all     = config::FLOWGRAPH_PRINT_ALL;\n-    let opt = |print_which| sess.debugging_opt(print_which);\n+    let opt = |&: print_which| sess.debugging_opt(print_which);\n     let mut variants = Vec::new();\n     if opt(print_all) || opt(print_loans) {\n         variants.push(borrowck_dot::Loans);\n@@ -365,7 +365,7 @@ impl UserIdentifiedItem {\n     }\n \n     fn to_one_node_id(self, user_option: &str, sess: &Session, map: &ast_map::Map) -> ast::NodeId {\n-        let fail_because = |is_wrong_because| -> ast::NodeId {\n+        let fail_because = |&: is_wrong_because| -> ast::NodeId {\n             let message =\n                 format!(\"{} needs NodeId (int) or unique \\\n                          path suffix (b::c::d); got {}, which {}\","}, {"sha": "7efa9ad737f527517a3f93de8a9821b017024349", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -1448,7 +1448,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let mut import_resolutions = module_.import_resolutions.borrow_mut();\n         let import_resolution = &mut (*import_resolutions)[target];\n         {\n-            let check_and_write_import = |namespace, result: &_, used_public: &mut bool| {\n+            let mut check_and_write_import = |&mut: namespace, result: &_, used_public: &mut bool| {\n                 let namespace_name = match namespace {\n                     TypeNS => \"type\",\n                     ValueNS => \"value\",\n@@ -1691,7 +1691,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         // Merge the child item into the import resolution.\n         {\n-            let merge_child_item = |namespace| {\n+            let mut merge_child_item = |&mut : namespace| {\n                 if name_bindings.defined_in_namespace_with(namespace, IMPORTABLE | PUBLIC) {\n                     let namespace_name = match namespace {\n                         TypeNS => \"type\","}, {"sha": "93ff9f53ec12d51297b9583a82484515aae58ca9", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -127,7 +127,7 @@ pub const RLIB_BYTECODE_OBJECT_V1_DATA_OFFSET: uint =\n pub fn find_crate_name(sess: Option<&Session>,\n                        attrs: &[ast::Attribute],\n                        input: &Input) -> String {\n-    let validate = |s: String, span: Option<Span>| {\n+    let validate = |&: s: String, span: Option<Span>| {\n         creader::validate_crate_name(sess, s[], span);\n         s\n     };"}, {"sha": "a6f2c7dfed0b18cebf9a4e7b1cb0075cf64f8b2e", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -431,7 +431,7 @@ unsafe fn optimize_and_codegen(cgcx: &CodegenContext,\n \n             // If we're verifying or linting, add them to the function pass\n             // manager.\n-            let addpass = |pass: &str| {\n+            let addpass = |&: pass: &str| {\n                 pass.with_c_str(|s| llvm::LLVMRustAddPass(fpm, s))\n             };\n             if !config.no_verify { assert!(addpass(\"verify\")); }\n@@ -652,7 +652,7 @@ pub fn run_passes(sess: &Session,\n \n     // Produce final compile outputs.\n \n-    let copy_if_one_unit = |ext: &str, output_type: config::OutputType, keep_numbered: bool| {\n+    let copy_if_one_unit = |&: ext: &str, output_type: config::OutputType, keep_numbered: bool| {\n         // Three cases:\n         if sess.opts.cg.codegen_units == 1 {\n             // 1) Only one codegen unit.  In this case it's no difficulty\n@@ -677,7 +677,7 @@ pub fn run_passes(sess: &Session,\n         }\n     };\n \n-    let link_obj = |output_path: &Path| {\n+    let link_obj = |&: output_path: &Path| {\n         // Running `ld -r` on a single input is kind of pointless.\n         if sess.opts.cg.codegen_units == 1 {\n             fs::copy(&crate_output.with_extension(\"0.o\"),\n@@ -993,7 +993,7 @@ unsafe fn configure_llvm(sess: &Session) {\n     let mut llvm_c_strs = Vec::new();\n     let mut llvm_args = Vec::new();\n     {\n-        let add = |arg: &str| {\n+        let mut add = |&mut : arg: &str| {\n             let s = arg.to_c_str();\n             llvm_args.push(s.as_ptr());\n             llvm_c_strs.push(s);"}, {"sha": "fc68d1d3258e13391a7d44a88c274c7c2cf75ad7", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -410,15 +410,15 @@ fn expand_nested_bindings<'a, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     }).collect()\n }\n \n-type EnterPatterns<'a, 'p> = |&[&'p ast::Pat]|: 'a -> Option<Vec<&'p ast::Pat>>;\n-\n-fn enter_match<'a, 'b, 'p, 'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                       dm: &DefMap,\n-                                       m: &[Match<'a, 'p, 'blk, 'tcx>],\n-                                       col: uint,\n-                                       val: ValueRef,\n-                                       e: EnterPatterns<'b, 'p>)\n-                                       -> Vec<Match<'a, 'p, 'blk, 'tcx>> {\n+fn enter_match<'a, 'b, 'p, 'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                          dm: &DefMap,\n+                                          m: &[Match<'a, 'p, 'blk, 'tcx>],\n+                                          col: uint,\n+                                          val: ValueRef,\n+                                          mut e: F)\n+                                          -> Vec<Match<'a, 'p, 'blk, 'tcx>> where\n+    F: FnMut(&[&'p ast::Pat]) -> Option<Vec<&'p ast::Pat>>,\n+{\n     debug!(\"enter_match(bcx={}, m={}, col={}, val={})\",\n            bcx.to_str(),\n            m.repr(bcx.tcx()),\n@@ -748,7 +748,7 @@ fn pick_column_to_specialize(def_map: &DefMap, m: &[Match]) -> Option<uint> {\n         }\n     }\n \n-    let column_score: |&[Match], uint| -> uint = |m, col| {\n+    let column_score = |&: m: &[Match], col: uint| -> uint {\n         let total_score = m.iter()\n             .map(|row| row.pats[col])\n             .map(|pat| pat_score(def_map, pat))"}, {"sha": "475443654264f0471b40d42f259c4fa14d572195", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -554,7 +554,7 @@ pub fn compare_scalar_types<'blk, 'tcx>(cx: Block<'blk, 'tcx>,\n                                         t: Ty<'tcx>,\n                                         op: ast::BinOp)\n                                         -> Result<'blk, 'tcx> {\n-    let f = |a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n+    let f = |&: a| Result::new(cx, compare_scalar_values(cx, lhs, rhs, a, op));\n \n     match t.sty {\n         ty::ty_tup(ref tys) if tys.is_empty() => f(nil_type),\n@@ -2749,7 +2749,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n     let val = match item {\n         ast_map::NodeItem(i) => {\n             let ty = ty::node_id_to_type(ccx.tcx(), i.id);\n-            let sym = || exported_name(ccx, id, ty, i.attrs[]);\n+            let sym = |&:| exported_name(ccx, id, ty, i.attrs[]);\n \n             let v = match i.node {\n                 ast::ItemStatic(_, _, ref expr) => {\n@@ -3013,14 +3013,14 @@ fn internalize_symbols(cx: &SharedCrateContext, reachable: &HashSet<String>) {\n     unsafe {\n         let mut declared = HashSet::new();\n \n-        let iter_globals = |llmod| {\n+        let iter_globals = |&: llmod| {\n             ValueIter {\n                 cur: llvm::LLVMGetFirstGlobal(llmod),\n                 step: llvm::LLVMGetNextGlobal,\n             }\n         };\n \n-        let iter_functions = |llmod| {\n+        let iter_functions = |&: llmod| {\n             ValueIter {\n                 cur: llvm::LLVMGetFirstFunction(llmod),\n                 step: llvm::LLVMGetNextFunction,"}, {"sha": "347ec100ae7ad10129de5334ee96fff3b564f8d6", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -305,7 +305,7 @@ pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>, e: &ast::Expr)\n // the bool returned is whether this expression can be inlined into other crates\n // if it's assigned to a static.\n fn const_expr_unadjusted(cx: &CrateContext, e: &ast::Expr) -> ValueRef {\n-    let map_list = |exprs: &[P<ast::Expr>]| {\n+    let map_list = |&: exprs: &[P<ast::Expr>]| {\n         exprs.iter().map(|e| const_expr(cx, &**e).0)\n              .fold(Vec::new(), |mut l, val| { l.push(val); l })\n     };"}, {"sha": "bce446b741271c3c5bb50c6e422f383565b8ab8c", "filename": "src/librustc_trans/trans/debuginfo.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -2489,7 +2489,7 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n         })\n         .collect();\n \n-    let discriminant_type_metadata = |inttype| {\n+    let discriminant_type_metadata = |&: inttype| {\n         // We can reuse the type of the discriminant for all monomorphized\n         // instances of an enum because it doesn't depend on any type parameters.\n         // The def_id, uniquely identifying the enum's polytype acts as key in"}, {"sha": "cf3070919cb38686940fedbba165bf15baeee829", "filename": "src/librustc_trans/trans/expr.rs", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fexpr.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -299,12 +299,16 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n     // into a type to be destructed. If we want to end up with a Box pointer,\n     // then mk_ty should make a Box pointer (T -> Box<T>), if we want a\n     // borrowed reference then it should be T -> &T.\n-    // FIXME(#19596) unbox `mk_ty`\n-    fn unsized_info<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n-                                kind: &ty::UnsizeKind<'tcx>,\n-                                id: ast::NodeId,\n-                                unadjusted_ty: Ty<'tcx>,\n-                                mk_ty: |Ty<'tcx>| -> Ty<'tcx>) -> ValueRef {\n+    fn unsized_info<'blk, 'tcx, F>(bcx: Block<'blk, 'tcx>,\n+                                   kind: &ty::UnsizeKind<'tcx>,\n+                                   id: ast::NodeId,\n+                                   unadjusted_ty: Ty<'tcx>,\n+                                   mk_ty: F) -> ValueRef where\n+        F: FnOnce(Ty<'tcx>) -> Ty<'tcx>,\n+    {\n+        // FIXME(#19596) workaround: `|t| t` causes monomorphization recursion\n+        fn identity<T>(t: T) -> T { t }\n+\n         debug!(\"unsized_info(kind={}, id={}, unadjusted_ty={})\",\n                kind, id, unadjusted_ty.repr(bcx.tcx()));\n         match kind {\n@@ -314,7 +318,7 @@ fn apply_adjustments<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n                     let ty_substs = substs.types.get_slice(subst::TypeSpace);\n                     // The dtor for a field treats it like a value, so mk_ty\n                     // should just be the identity function.\n-                    unsized_info(bcx, k, id, ty_substs[tp_index], |t| t)\n+                    unsized_info(bcx, k, id, ty_substs[tp_index], identity)\n                 }\n                 _ => bcx.sess().bug(format!(\"UnsizeStruct with bad sty: {}\",\n                                           bcx.ty_to_string(unadjusted_ty))[])"}, {"sha": "83765270ef103d4e48a1ddd7d19e4693144e6f18", "filename": "src/librustc_trans/trans/foreign.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fforeign.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -615,7 +615,7 @@ pub fn trans_rust_fn_with_foreign_abi<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // Array for the arguments we will pass to the rust function.\n         let mut llrust_args = Vec::new();\n         let mut next_foreign_arg_counter: c_uint = 0;\n-        let next_foreign_arg: |pad: bool| -> c_uint = |pad: bool| {\n+        let mut next_foreign_arg = |&mut : pad: bool| -> c_uint {\n             next_foreign_arg_counter += if pad {\n                 2\n             } else {"}, {"sha": "a22ce297828a90ab64d01c162e0ad5e813d01e67", "filename": "src/librustc_trans/trans/intrinsic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fintrinsic.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -181,7 +181,7 @@ pub fn trans_intrinsic_call<'a, 'blk, 'tcx>(mut bcx: Block<'blk, 'tcx>,\n                 // This should be caught by the intrinsicck pass\n                 assert_eq!(in_type_size, out_type_size);\n \n-                let nonpointer_nonaggregate = |llkind: TypeKind| -> bool {\n+                let nonpointer_nonaggregate = |&: llkind: TypeKind| -> bool {\n                     use llvm::TypeKind::*;\n                     match llkind {\n                         Half | Float | Double | X86_FP80 | FP128 |"}, {"sha": "7646aa086eb1c13d3f59d866c2b064db0b5d2295", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -139,7 +139,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n     // This shouldn't need to option dance.\n     let mut hash_id = Some(hash_id);\n-    let mk_lldecl = |abi: abi::Abi| {\n+    let mut mk_lldecl = |&mut : abi: abi::Abi| {\n         let lldecl = if abi != abi::Rust {\n             foreign::decl_rust_fn_with_foreign_abi(ccx, mono_ty, s[])\n         } else {\n@@ -149,7 +149,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ccx.monomorphized().borrow_mut().insert(hash_id.take().unwrap(), lldecl);\n         lldecl\n     };\n-    let setup_lldecl = |lldecl, attrs: &[ast::Attribute]| {\n+    let setup_lldecl = |&: lldecl, attrs: &[ast::Attribute]| {\n         base::update_linkage(ccx, lldecl, None, base::OriginalTranslation);\n         set_llvm_fn_attrs(ccx, attrs, lldecl);\n "}, {"sha": "15e942006f0189855085909e9ebc558f852b9e4c", "filename": "src/librustc_typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fvtable.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -223,7 +223,7 @@ fn check_object_safety_inner<'tcx>(tcx: &ty::ctxt<'tcx>,\n         }\n \n         // reason (a) above\n-        let check_for_self_ty = |ty| {\n+        let check_for_self_ty = |&: ty| {\n             if contains_illegal_self_type_reference(tcx, object_trait.def_id(), ty) {\n                 Some(format!(\n                     \"cannot call a method (`{}`) whose type contains \\"}, {"sha": "cd8bc94b111e7fddd97d16befb8f9f0173df148f", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -593,7 +593,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n         // parameter (by inspecting parent of its binding declaration\n         // to see if it is introduced by a type or by a fn/impl).\n \n-        let check_result = |this:&ConstraintContext| -> bool {\n+        let check_result = |&: this:&ConstraintContext| -> bool {\n             let tcx = this.terms_cx.tcx;\n             let decl_id = this.find_binding_for_lifetime(param_id);\n             // Currently only called on lifetimes; double-checking that."}, {"sha": "459d6409f676abd8521e0cdcb989915f374bdcf5", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -2016,7 +2016,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                 None => false,\n             }\n         });\n-        let convert = |node: &ast::ViewItem_| {\n+        let convert = |&: node: &ast::ViewItem_| {\n             Item {\n                 name: None,\n                 attrs: self.attrs.clean(cx),"}, {"sha": "cfaae1a9f80fd13b0f511fb69c6571d1441adadc", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -61,7 +61,7 @@ fn doit(sess: &parse::ParseSess, mut lexer: lexer::StringReader,\n     loop {\n         let next = lexer.next_token();\n \n-        let snip = |sp| sess.span_diagnostic.cm.span_to_snippet(sp).unwrap();\n+        let snip = |&: sp| sess.span_diagnostic.cm.span_to_snippet(sp).unwrap();\n \n         if next.tok == token::Eof { break }\n "}, {"sha": "73bcdad34c3a0433f9efd39ac2fe9975923f93e3", "filename": "src/libstd/io/net/udp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fio%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fnet%2Fudp.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -344,7 +344,7 @@ mod test {\n         let (tx2, rx2) = channel();\n \n         spawn(move|| {\n-            let send_as = |ip, val: &[u8]| {\n+            let send_as = |&: ip, val: &[u8]| {\n                 match UdpSocket::bind(ip) {\n                     Ok(client) => {\n                         let client = box client;"}, {"sha": "b7d069eb19e581313b203e57bd293078d5e5b23e", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -334,7 +334,7 @@ pub fn set_stderr(stderr: Box<Writer + Send>) -> Option<Box<Writer + Send>> {\n //          // io1 aliases io2\n //      })\n //  })\n-fn with_task_stdout(f: |&mut Writer| -> IoResult<()>) {\n+fn with_task_stdout<F>(f: F) where F: FnOnce(&mut Writer) -> IoResult<()> {\n     let mut my_stdout = LOCAL_STDOUT.with(|slot| {\n         slot.borrow_mut().take()\n     }).unwrap_or_else(|| {"}, {"sha": "25af3bf2d53835fca3b9c2f6378c49c5b201977d", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -321,10 +321,10 @@ pub fn float_to_str_bytes_common<T: Float>(\n         // cut off the one extra digit, and depending on its value\n         // round the remaining ones.\n         if limit_digits && dig == digit_count {\n-            let ascii2value = |chr: u8| {\n+            let ascii2value = |&: chr: u8| {\n                 (chr as char).to_digit(radix).unwrap()\n             };\n-            let value2ascii = |val: uint| {\n+            let value2ascii = |&: val: uint| {\n                 char::from_digit(val, radix).unwrap() as u8\n             };\n "}, {"sha": "41e91d1b6ef9be4fea4719e858efcf8a9aed1767", "filename": "src/libstd/rt/task.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Frt%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Frt%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Ftask.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -174,7 +174,7 @@ impl Task {\n     ///\n     /// It is invalid to call this function with a thread that has been previously\n     /// destroyed via a failed call to `run`.\n-    pub fn run(mut self: Box<Task>, f: ||) -> Box<Task> {\n+    pub fn run<F>(mut self: Box<Task>, f: F) -> Box<Task> where F: FnOnce() {\n         assert!(!self.is_destroyed(), \"cannot re-use a destroyed thread\");\n \n         // First, make sure that no one else is in TLS. This does not allow"}, {"sha": "8c76eb1504db72e779de18eca9bdcc7d727488ef", "filename": "src/libstd/sys/common/thread_info.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fthread_info.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -26,13 +26,13 @@ struct ThreadInfo {\n thread_local! { static THREAD_INFO: RefCell<Option<ThreadInfo>> = RefCell::new(None) }\n \n impl ThreadInfo {\n-    fn with<R>(f: |&mut ThreadInfo| -> R) -> R {\n+    fn with<R, F>(f: F) -> R where F: FnOnce(&mut ThreadInfo) -> R {\n         if THREAD_INFO.destroyed() {\n             panic!(\"Use of std::thread::Thread::current() is not possible after \\\n                     the thread's local data has been destroyed\");\n         }\n \n-        THREAD_INFO.with(|c| {\n+        THREAD_INFO.with(move |c| {\n             if c.borrow().is_none() {\n                 *c.borrow_mut() = Some(ThreadInfo {\n                     stack_bounds: (0, 0),"}, {"sha": "615e3a21bd0ac79c774f5392fd265f7728057a01", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -195,7 +195,7 @@ impl Process {\n                 // up /dev/null into that file descriptor. Otherwise, the first file\n                 // descriptor opened up in the child would be numbered as one of the\n                 // stdio file descriptors, which is likely to wreak havoc.\n-                let setup = |src: Option<P>, dst: c_int| {\n+                let setup = |&: src: Option<P>, dst: c_int| {\n                     let src = match src {\n                         None => {\n                             let flags = if dst == libc::STDIN_FILENO {"}, {"sha": "0f26e36a80fd6f85b95d5da7c0ffe4d47a091d93", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -124,7 +124,9 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n     }\n }\n \n-pub fn fill_utf16_buf_and_decode(f: |*mut u16, DWORD| -> DWORD) -> Option<String> {\n+pub fn fill_utf16_buf_and_decode<F>(mut f: F) -> Option<String> where\n+    F: FnMut(*mut u16, DWORD) -> DWORD,\n+{\n     unsafe {\n         let mut n = TMPBUF_SZ as DWORD;\n         let mut res = None;"}, {"sha": "b03c62395d1a081807296f0941aef38ec04d2ec7", "filename": "src/libstd/sys/windows/process.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -162,7 +162,7 @@ impl Process {\n             // Similarly to unix, we don't actually leave holes for the stdio file\n             // descriptors, but rather open up /dev/null equivalents. These\n             // equivalents are drawn from libuv's windows process spawning.\n-            let set_fd = |fd: &Option<P>, slot: &mut HANDLE,\n+            let set_fd = |&: fd: &Option<P>, slot: &mut HANDLE,\n                           is_stdin: bool| {\n                 match *fd {\n                     None => {"}, {"sha": "a8393ed9d39774960fbd3e9532455ae19104c1d8", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -618,34 +618,38 @@ pub fn compute_id_range_for_fn_body(fk: visit::FnKind,\n     id_visitor.operation.result\n }\n \n-// FIXME(#19596) unbox `it`\n-pub fn walk_pat(pat: &Pat, it: |&Pat| -> bool) -> bool {\n-    if !it(pat) {\n-        return false;\n-    }\n-\n-    match pat.node {\n-        PatIdent(_, _, Some(ref p)) => walk_pat(&**p, it),\n-        PatStruct(_, ref fields, _) => {\n-            fields.iter().all(|field| walk_pat(&*field.node.pat, |p| it(p)))\n-        }\n-        PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n-            s.iter().all(|p| walk_pat(&**p, |p| it(p)))\n+pub fn walk_pat<F>(pat: &Pat, mut it: F) -> bool where F: FnMut(&Pat) -> bool {\n+    // FIXME(#19596) this is a workaround, but there should be a better way\n+    fn walk_pat_<G>(pat: &Pat, it: &mut G) -> bool where G: FnMut(&Pat) -> bool {\n+        if !(*it)(pat) {\n+            return false;\n         }\n-        PatBox(ref s) | PatRegion(ref s) => {\n-            walk_pat(&**s, it)\n-        }\n-        PatVec(ref before, ref slice, ref after) => {\n-            before.iter().all(|p| walk_pat(&**p, |p| it(p))) &&\n-            slice.iter().all(|p| walk_pat(&**p, |p| it(p))) &&\n-            after.iter().all(|p| walk_pat(&**p, |p| it(p)))\n-        }\n-        PatMac(_) => panic!(\"attempted to analyze unexpanded pattern\"),\n-        PatWild(_) | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n-        PatEnum(_, _) => {\n-            true\n+\n+        match pat.node {\n+            PatIdent(_, _, Some(ref p)) => walk_pat_(&**p, it),\n+            PatStruct(_, ref fields, _) => {\n+                fields.iter().all(|field| walk_pat_(&*field.node.pat, it))\n+            }\n+            PatEnum(_, Some(ref s)) | PatTup(ref s) => {\n+                s.iter().all(|p| walk_pat_(&**p, it))\n+            }\n+            PatBox(ref s) | PatRegion(ref s) => {\n+                walk_pat_(&**s, it)\n+            }\n+            PatVec(ref before, ref slice, ref after) => {\n+                before.iter().all(|p| walk_pat_(&**p, it)) &&\n+                slice.iter().all(|p| walk_pat_(&**p, it)) &&\n+                after.iter().all(|p| walk_pat_(&**p, it))\n+            }\n+            PatMac(_) => panic!(\"attempted to analyze unexpanded pattern\"),\n+            PatWild(_) | PatLit(_) | PatRange(_, _) | PatIdent(_, _, _) |\n+            PatEnum(_, _) => {\n+                true\n+            }\n         }\n     }\n+\n+    walk_pat_(pat, &mut it)\n }\n \n pub trait EachViewItem {"}, {"sha": "5134897893f2431d469531997c5ddd20b7087ba7", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -47,18 +47,18 @@ pub trait ItemDecorator {\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &ast::Item,\n-              push: |P<ast::Item>|);\n+              push: Box<FnMut(P<ast::Item>)>);\n }\n \n impl<F> ItemDecorator for F\n-    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, |P<ast::Item>|)\n+    where F : Fn(&mut ExtCtxt, Span, &ast::MetaItem, &ast::Item, Box<FnMut(P<ast::Item>)>)\n {\n     fn expand(&self,\n               ecx: &mut ExtCtxt,\n               sp: Span,\n               meta_item: &ast::MetaItem,\n               item: &ast::Item,\n-              push: |P<ast::Item>|) {\n+              push: Box<FnMut(P<ast::Item>)>) {\n         (*self)(ecx, sp, meta_item, item, push)\n     }\n }"}, {"sha": "49bcb26a4c283027ed7e85a679480d18fef459ac", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -55,7 +55,7 @@ fn default_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructur\n         cx.ident_of(\"Default\"),\n         cx.ident_of(\"default\")\n     );\n-    let default_call = |span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n+    let default_call = |&: span| cx.expr_call_global(span, default_ident.clone(), Vec::new());\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {"}, {"sha": "9149c20ce1b57419f1b6b679595aecaa199ac5d7", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -935,7 +935,7 @@ impl<'a> MethodDef<'a> {\n         // where each tuple has length = self_args.len()\n         let mut match_arms: Vec<ast::Arm> = variants.iter().enumerate()\n             .map(|(index, variant)| {\n-                let mk_self_pat = |cx: &mut ExtCtxt, self_arg_name: &str| {\n+                let mk_self_pat = |&: cx: &mut ExtCtxt, self_arg_name: &str| {\n                     let (p, idents) = trait_.create_enum_variant_pattern(cx, type_ident,\n                                                                          &**variant,\n                                                                          self_arg_name,"}, {"sha": "9ad0ad1621765f13e71e72e2681ff838fdd20199", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -71,7 +71,7 @@ fn hash_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         _ => cx.span_bug(trait_span, \"incorrect number of arguments in `deriving(Hash)`\")\n     };\n     let hash_ident = substr.method_ident;\n-    let call_hash = |span, thing_expr| {\n+    let call_hash = |&: span, thing_expr| {\n         let expr = cx.expr_method_call(span, thing_expr, hash_ident, vec!(state_expr.clone()));\n         cx.stmt_expr(expr)\n     };"}, {"sha": "75f763b5c38ee8a4522f4248f17041497bc361db", "filename": "src/libsyntax/ext/deriving/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fmod.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -45,7 +45,7 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                             _span: Span,\n                             mitem: &MetaItem,\n                             item: &Item,\n-                            push: |P<Item>|) {\n+                            mut push: Box<FnMut(P<Item>)>) {\n     match mitem.node {\n         MetaNameValue(_, ref l) => {\n             cx.span_err(l.span, \"unexpected value in `deriving`\");\n@@ -64,7 +64,7 @@ pub fn expand_meta_deriving(cx: &mut ExtCtxt,\n                     MetaWord(ref tname) => {\n                         macro_rules! expand(($func:path) => ($func(cx, titem.span,\n                                                                    &**titem, item,\n-                                                                   |i| push(i))));\n+                                                                   |i| push.call_mut((i,)))));\n                         match tname.get() {\n                             \"Clone\" => expand!(clone::expand_deriving_clone),\n "}, {"sha": "73331f06aa4ee53a3bd6e74cc887c39a2971de52", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -71,7 +71,7 @@ fn zero_substructure(cx: &mut ExtCtxt, trait_span: Span, substr: &Substructure)\n         cx.ident_of(\"Zero\"),\n         cx.ident_of(\"zero\")\n     );\n-    let zero_call = |span| cx.expr_call_global(span, zero_ident.clone(), Vec::new());\n+    let zero_call = |&: span| cx.expr_call_global(span, zero_ident.clone(), Vec::new());\n \n     return match *substr.fields {\n         StaticStruct(_, ref summary) => {"}, {"sha": "5de7068563d59e646a06a3468e234d139834a507", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -424,7 +424,7 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n                     // but that double-mut-borrows fld\n                     let mut items: SmallVector<P<ast::Item>> = SmallVector::zero();\n                     dec.expand(fld.cx, attr.span, &*attr.node.value, &*it,\n-                               |item| items.push(item));\n+                               box |&mut : item| items.push(item));\n                     decorator_items.extend(items.into_iter()\n                         .flat_map(|item| expand_item(item, fld).into_iter()));\n \n@@ -1660,7 +1660,7 @@ mod test {\n             assert!((shouldmatch.len() == 0) ||\n                     (varrefs.len() > *shouldmatch.iter().max().unwrap()));\n             for (idx,varref) in varrefs.iter().enumerate() {\n-                let print_hygiene_debug_info = || {\n+                let print_hygiene_debug_info = |&:| {\n                     // good lord, you can't make a path with 0 segments, can you?\n                     let final_varref_ident = match varref.segments.last() {\n                         Some(pathsegment) => pathsegment.identifier,"}, {"sha": "d87960ebdb82af2d208268b9e4be8a50646309d2", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -800,11 +800,11 @@ fn expand_parse_call(cx: &ExtCtxt,\n                      tts: &[ast::TokenTree]) -> P<ast::Expr> {\n     let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n-    let cfg_call = || cx.expr_method_call(\n+    let cfg_call = |&:| cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n         id_ext(\"cfg\"), Vec::new());\n \n-    let parse_sess_call = || cx.expr_method_call(\n+    let parse_sess_call = |&:| cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n         id_ext(\"parse_sess\"), Vec::new());\n "}, {"sha": "88c485a07acdf290a28ef5dd66c543b841c6ae76", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -240,7 +240,7 @@ pub fn new_parser_from_tts<'a>(sess: &'a ParseSess,\n /// add the path to the session's codemap and return the new filemap.\n pub fn file_to_filemap(sess: &ParseSess, path: &Path, spanopt: Option<Span>)\n     -> Rc<FileMap> {\n-    let err = |msg: &str| {\n+    let err = |&: msg: &str| {\n         match spanopt {\n             Some(sp) => sess.span_diagnostic.span_fatal(sp, msg),\n             None => sess.span_diagnostic.handler().fatal(msg),\n@@ -399,7 +399,7 @@ pub fn char_lit(lit: &str) -> (char, int) {\n         .map(|x| (x, len as int))\n     }\n \n-    let unicode_escape: || -> Option<(char, int)> = ||\n+    let unicode_escape = |&: | -> Option<(char, int)>\n         if lit.as_bytes()[2] == b'{' {\n             let idx = lit.find('}').expect(msg2);\n             let subslice = lit[3..idx];\n@@ -426,7 +426,7 @@ pub fn str_lit(lit: &str) -> String {\n     let mut res = String::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n-    let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n+    let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n     fn eat<'a>(it: &mut iter::Peekable<(uint, char), str::CharIndices<'a>>) {\n@@ -561,7 +561,7 @@ pub fn float_lit(s: &str, suffix: Option<&str>, sd: &SpanHandler, sp: Span) -> a\n \n /// Parse a string representing a byte literal into its final form. Similar to `char_lit`\n pub fn byte_lit(lit: &str) -> (u8, uint) {\n-    let err = |i| format!(\"lexer accepted invalid byte literal {} step {}\", lit, i);\n+    let err = |&: i| format!(\"lexer accepted invalid byte literal {} step {}\", lit, i);\n \n     if lit.len() == 1 {\n         (lit.as_bytes()[0], 1)\n@@ -595,7 +595,7 @@ pub fn binary_lit(lit: &str) -> Rc<Vec<u8>> {\n     let mut res = Vec::with_capacity(lit.len());\n \n     // FIXME #8372: This could be a for-loop if it didn't borrow the iterator\n-    let error = |i| format!(\"lexer should have rejected {} at {}\", lit, i);\n+    let error = |&: i| format!(\"lexer should have rejected {} at {}\", lit, i);\n \n     /// Eat everything up to a non-whitespace\n     fn eat<'a, I: Iterator<(uint, u8)>>(it: &mut iter::Peekable<(uint, u8), I>) {"}, {"sha": "93fe868f52c682909887dc167bff0ab152e16c1b", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -545,11 +545,11 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n     let test_id = ecx.ident_of(\"test\");\n \n     // creates self::test::$name\n-    let test_path = |name| {\n+    let test_path = |&: name| {\n         ecx.path(span, vec![self_id, test_id, ecx.ident_of(name)])\n     };\n     // creates $name: $expr\n-    let field = |name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n+    let field = |&: name, expr| ecx.field_imm(span, ecx.ident_of(name), expr);\n \n     debug!(\"encoding {}\", ast_util::path_name_i(path[]));\n \n@@ -563,7 +563,7 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> P<ast::Expr> {\n                                   vec![name_expr]);\n \n     let ignore_expr = ecx.expr_bool(span, test.ignore);\n-    let should_fail_path = |name| {\n+    let should_fail_path = |&: name| {\n         ecx.path(span, vec![self_id, test_id, ecx.ident_of(\"ShouldFail\"), ecx.ident_of(name)])\n     };\n     let fail_expr = match test.should_fail {"}, {"sha": "87a00334c478f914ecb668833ebd9ecafb1ba877", "filename": "src/libtime/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibtime%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibtime%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtime%2Flib.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -596,7 +596,7 @@ impl<'a> fmt::Show for TmFmt<'a> {\n         }\n \n         fn parse_type(fmt: &mut fmt::Formatter, ch: char, tm: &Tm) -> fmt::Result {\n-            let die = || {\n+            let die = |&:| {\n                 unreachable!()\n             };\n             match ch {"}, {"sha": "c6f86ccd9d412c81c87a9a2b4bbdef308d60a7cc", "filename": "src/libunicode/normalize.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibunicode%2Fnormalize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47b8479e73e40395f1b1b2d0c6281f28f80301e4/src%2Flibunicode%2Fnormalize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunicode%2Fnormalize.rs?ref=47b8479e73e40395f1b1b2d0c6281f28f80301e4", "patch": "@@ -11,6 +11,7 @@\n //! Functions for computing canonical and compatible decompositions for Unicode characters.\n \n use core::cmp::Ordering::{Equal, Less, Greater};\n+use core::ops::FnMut;\n use core::option::Option;\n use core::option::Option::{Some, None};\n use core::slice::SliceExt;\n@@ -32,14 +33,15 @@ fn bsearch_table<T>(c: char, r: &'static [(char, &'static [T])]) -> Option<&'sta\n }\n \n /// Compute canonical Unicode decomposition for character\n-pub fn decompose_canonical(c: char, i: |char|) { d(c, i, false); }\n+pub fn decompose_canonical<F>(c: char, mut i: F) where F: FnMut(char) { d(c, &mut i, false); }\n \n /// Compute canonical or compatible Unicode decomposition for character\n-pub fn decompose_compatible(c: char, i: |char|) { d(c, i, true); }\n+pub fn decompose_compatible<F>(c: char, mut i: F) where F: FnMut(char) { d(c, &mut i, true); }\n \n-fn d(c: char, i: |char|, k: bool) {\n+// FIXME(#19596) This is a workaround, we should use `F` instead of `&mut F`\n+fn d<F>(c: char, i: &mut F, k: bool) where F: FnMut(char) {\n     // 7-bit ASCII never decomposes\n-    if c <= '\\x7f' { i(c); return; }\n+    if c <= '\\x7f' { (*i)(c); return; }\n \n     // Perform decomposition for Hangul\n     if (c as u32) >= S_BASE && (c as u32) < (S_BASE + S_COUNT) {\n@@ -51,29 +53,29 @@ fn d(c: char, i: |char|, k: bool) {\n     match bsearch_table(c, canonical_table) {\n         Some(canon) => {\n             for x in canon.iter() {\n-                d(*x, |b| i(b), k);\n+                d(*x, i, k);\n             }\n             return;\n         }\n         None => ()\n     }\n \n     // Bottom out if we're not doing compat.\n-    if !k { i(c); return; }\n+    if !k { (*i)(c); return; }\n \n     // Then check the compatibility decompositions\n     match bsearch_table(c, compatibility_table) {\n         Some(compat) => {\n             for x in compat.iter() {\n-                d(*x, |b| i(b), k);\n+                d(*x, i, k);\n             }\n             return;\n         }\n         None => ()\n     }\n \n     // Finally bottom out.\n-    i(c);\n+    (*i)(c);\n }\n \n pub fn compose(a: char, b: char) -> Option<char> {\n@@ -108,23 +110,24 @@ const T_COUNT: u32 = 28;\n const N_COUNT: u32 = (V_COUNT * T_COUNT);\n const S_COUNT: u32 = (L_COUNT * N_COUNT);\n \n+// FIXME(#19596) This is a workaround, we should use `F` instead of `&mut F`\n // Decompose a precomposed Hangul syllable\n #[inline(always)]\n-fn decompose_hangul(s: char, f: |char|) {\n+fn decompose_hangul<F>(s: char, f: &mut F) where F: FnMut(char) {\n     use core::mem::transmute;\n \n     let si = s as u32 - S_BASE;\n \n     let li = si / N_COUNT;\n     unsafe {\n-        f(transmute(L_BASE + li));\n+        (*f)(transmute(L_BASE + li));\n \n         let vi = (si % N_COUNT) / T_COUNT;\n-        f(transmute(V_BASE + vi));\n+        (*f)(transmute(V_BASE + vi));\n \n         let ti = si % T_COUNT;\n         if ti > 0 {\n-            f(transmute(T_BASE + ti));\n+            (*f)(transmute(T_BASE + ti));\n         }\n     }\n }"}]}