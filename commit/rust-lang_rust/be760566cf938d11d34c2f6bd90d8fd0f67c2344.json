{"sha": "be760566cf938d11d34c2f6bd90d8fd0f67c2344", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJlNzYwNTY2Y2Y5MzhkMTFkMzRjMmY2YmQ5MGQ4ZmQwZjY3YzIzNDQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-28T14:06:39Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2017-02-28T14:06:39Z"}, "message": "Auto merge of #40148 - frewsxcv:rollup, r=frewsxcv\n\nRollup of 9 pull requests\n\n- Successful merges: #39977, #40033, #40047, #40056, #40057, #40122, #40124, #40126, #40131\n- Failed merges: #40101", "tree": {"sha": "ecec25a70b0438b87db17dffe296de4c2e92165f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ecec25a70b0438b87db17dffe296de4c2e92165f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/be760566cf938d11d34c2f6bd90d8fd0f67c2344", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/be760566cf938d11d34c2f6bd90d8fd0f67c2344", "html_url": "https://github.com/rust-lang/rust/commit/be760566cf938d11d34c2f6bd90d8fd0f67c2344", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/be760566cf938d11d34c2f6bd90d8fd0f67c2344/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5872a8d78bfa6b94187af0e72cff063259d74531", "url": "https://api.github.com/repos/rust-lang/rust/commits/5872a8d78bfa6b94187af0e72cff063259d74531", "html_url": "https://github.com/rust-lang/rust/commit/5872a8d78bfa6b94187af0e72cff063259d74531"}, {"sha": "a851fc144109996cff2bbc20080258def9f06859", "url": "https://api.github.com/repos/rust-lang/rust/commits/a851fc144109996cff2bbc20080258def9f06859", "html_url": "https://github.com/rust-lang/rust/commit/a851fc144109996cff2bbc20080258def9f06859"}], "stats": {"total": 1025, "additions": 663, "deletions": 362}, "files": [{"sha": "1e983cfd726d6990c25f6ce28f30a3efa8405082", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -97,33 +97,38 @@ system internals, try asking in [`#rust-internals`][pound-rust-internals].\n \n Before you can start building the compiler you need to configure the build for\n your system. In most cases, that will just mean using the defaults provided\n-for Rust. Configuring involves invoking the `configure` script in the project\n-root.\n+for Rust.\n \n-```\n-./configure\n-```\n+To change configuration, you must copy the file `src/bootstrap/config.toml.example`\n+to `config.toml` in the directory from which you will be running the build, and\n+change the settings provided.\n+\n+There are large number of options provided in this config file that will alter the\n+configuration used in the build process. Some options to note:\n \n-There are large number of options accepted by this script to alter the\n-configuration used later in the build process. Some options to note:\n+#### `[llvm]`:\n+- `ccache = true` - Use ccache when building llvm\n \n-- `--enable-debug` - Build a debug version of the compiler (disables optimizations,\n-    which speeds up compilation of stage1 rustc)\n-- `--enable-optimize` - Enable optimizations (can be used with `--enable-debug`\n-    to make a debug build with optimizations)\n-- `--disable-valgrind-rpass` - Don't run tests with valgrind\n-- `--enable-clang` - Prefer clang to gcc for building dependencies (e.g., LLVM)\n-- `--enable-ccache` - Invoke clang/gcc with ccache to re-use object files between builds\n-- `--enable-compiler-docs` - Build compiler documentation\n+#### `[build]`:\n+- `compiler-docs = true` - Build compiler documentation\n \n-To see a full list of options, run `./configure --help`.\n+#### `[rust]`:\n+- `debuginfo = true` - Build a compiler with debuginfo\n+- `optimize = false` - Disable optimizations to speed up compilation of stage1 rust\n+\n+For more options, the `config.toml` file contains commented out defaults, with\n+descriptions of what each option will do.\n+\n+Note: Previously the `./configure` script was used to configure this\n+project. It can still be used, but it's recommended to use a `config.toml`\n+file. If you still have a `config.mk` file in your directory - from\n+`./configure` - you may need to delete it for `config.toml` to work.\n \n ### Building\n \n-Although the `./configure` script will generate a `Makefile`, this is actually\n-just a thin veneer over the actual build system driver, `x.py`. This file, at\n-the root of the repository, is used to build, test, and document various parts\n-of the compiler. You can execute it as:\n+The build system uses the `x.py` script to control the build process. This script\n+is used to build, test, and document various parts of the compiler. You can\n+execute it as:\n \n ```sh\n python x.py build\n@@ -185,6 +190,9 @@ To learn about all possible rules you can execute, run:\n python x.py build --help --verbose\n ```\n \n+Note: Previously `./configure` and `make` were used to build this project.\n+They are still available, but `x.py` is the recommended build system.\n+\n ### Useful commands\n \n Some common invocations of `x.py` are:\n@@ -235,8 +243,8 @@ feature. We use the 'fork and pull' model described there.\n \n Please make pull requests against the `master` branch.\n \n-Compiling all of `make check` can take a while. When testing your pull request,\n-consider using one of the more specialized `make` targets to cut down on the\n+Compiling all of `./x.py test` can take a while. When testing your pull request,\n+consider using one of the more specialized `./x.py` targets to cut down on the\n amount of time you have to wait. You need to have built the compiler at least\n once before running these will work, but that\u2019s only one full build rather than\n one each time.\n@@ -307,7 +315,7 @@ To find documentation-related issues, sort by the [A-docs label][adocs].\n \n [adocs]: https://github.com/rust-lang/rust/issues?q=is%3Aopen+is%3Aissue+label%3AA-docs\n \n-In many cases, you don't need a full `make doc`. You can use `rustdoc` directly\n+In many cases, you don't need a full `./x.py doc`. You can use `rustdoc` directly\n to check small fixes. For example, `rustdoc src/doc/reference.md` will render\n reference to `doc/reference.html`. The CSS might be messed up, but you can\n verify that the HTML is right."}, {"sha": "93415adc423f4b26a28dddc1856fc2b519f8f0f7", "filename": "README.md", "status": "modified", "additions": 40, "deletions": 19, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -35,15 +35,15 @@ Read [\"Installing Rust\"] from [The Book].\n 3. Build and install:\n \n     ```sh\n-    $ ./configure\n-    $ make && sudo make install\n+    $ ./x.py build && sudo ./x.py dist --install\n     ```\n \n-    > ***Note:*** Install locations can be adjusted by passing a `--prefix`\n-    > argument to `configure`. Various other options are also supported \u2013 pass\n-    > `--help` for more information on them.\n+    > ***Note:*** Install locations can be adjusted by copying the config file\n+    > from `./src/bootstrap/config.toml.example` to `./config.toml`, and\n+    > adjusting the `prefix` option under `[install]`. Various other options are\n+    > also supported, and are documented in the config file.\n \n-    When complete, `sudo make install` will place several programs into\n+    When complete, `sudo ./x.py dist --install` will place several programs into\n     `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n     API-documentation tool. This install does not include [Cargo],\n     Rust's package manager, which you may also want to build.\n@@ -59,7 +59,6 @@ for interop with software produced by Visual Studio use the MSVC build of Rust;\n for interop with GNU software built using the MinGW/MSYS2 toolchain use the GNU\n build.\n \n-\n #### MinGW\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n@@ -94,11 +93,10 @@ build.\n                mingw-w64-x86_64-gcc\n    ```\n \n-4. Navigate to Rust's source code (or clone it), then configure and build it:\n+4. Navigate to Rust's source code (or clone it), then build it:\n \n    ```sh\n-   $ ./configure\n-   $ make && make install\n+   $ ./x.py build && ./x.py dist --install\n    ```\n \n #### MSVC\n@@ -114,13 +112,6 @@ shell with:\n > python x.py build\n ```\n \n-If you're running inside of an msys shell, however, you can run:\n-\n-```sh\n-$ ./configure --build=x86_64-pc-windows-msvc\n-$ make && make install\n-```\n-\n Currently building Rust only works with some known versions of Visual Studio. If\n you have a more recent version installed the build system doesn't understand\n then you may need to force rustbuild to use an older version. This can be done\n@@ -131,13 +122,43 @@ CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.\n python x.py build\n ```\n \n+#### Specifying an ABI\n+\n+Each specific ABI can also be used from either environment (for example, using\n+the GNU ABI in powershell) by using an explicit build triple. The available\n+Windows build triples are:\n+- GNU ABI (using GCC)\n+    - `i686-pc-windows-gnu`\n+    - `x86_64-pc-windows-gnu`\n+- The MSVC ABI\n+    - `i686-pc-windows-msvc`\n+    - `x86_64-pc-windows-msvc`\n+\n+The build triple can be specified by either specifying `--build=ABI` when\n+invoking `x.py` commands, or by copying the `config.toml` file (as described\n+in Building From Source), and modifying the `build` option under the `[build]`\n+section.\n+\n+### Configure and Make\n+\n+While it's not the recommended build system, this project also provides a\n+configure script and makefile (the latter of which just invokes `x.py`).\n+\n+```sh\n+$ ./configure\n+$ make && sudo make install\n+```\n+\n+When using the configure script, the generated config.mk` file may override the\n+`config.toml` file. To go back to the `config.toml` file, delete the generated\n+`config.mk` file.\n+\n ## Building Documentation\n \n If you\u2019d like to build the documentation, it\u2019s almost the same:\n \n ```sh\n-$ ./configure\n-$ make docs\n+$ ./x.py doc\n ```\n \n The generated documentation will appear in a top-level `doc` directory,"}, {"sha": "042d9af9717d052a705f8f183bb4e998add2b0d4", "filename": "src/doc/book/src/lifetimes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Flifetimes.md?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -349,8 +349,8 @@ to it.\n \n ## Lifetime Elision\n \n-Rust supports powerful local type inference in the bodies of functions but not in their item signatures. \n-It's forbidden to allow reasoning about types based on the item signature alone. \n+Rust supports powerful local type inference in the bodies of functions, but it\n+deliberately does not perform any reasoning about types for item signatures. \n However, for ergonomic reasons, a very restricted secondary inference algorithm called \n \u201clifetime elision\u201d does apply when judging lifetimes. Lifetime elision is concerned solely with inferring \n lifetime parameters using three easily memorizable and unambiguous rules. This means lifetime elision "}, {"sha": "e02b5a6cdd79b8c27ad66bf7c675bd71c47880e5", "filename": "src/doc/book/src/procedural-macros.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fsrc%2Fprocedural-macros.md?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -128,7 +128,7 @@ pub fn hello_world(input: TokenStream) -> TokenStream {\n So there is a lot going on here. We have introduced two new crates: [`syn`] and\n [`quote`]. As you may have noticed, `input: TokenSteam` is immediately converted\n to a `String`. This `String` is a string representation of the Rust code for which\n-we are deriving `HelloWorld` for. At the moment, the only thing you can do with a\n+we are deriving `HelloWorld`. At the moment, the only thing you can do with a\n `TokenStream` is convert it to a string. A richer API will exist in the future.\n \n So what we really need is to be able to _parse_ Rust code into something"}, {"sha": "dc5a662cdb0445fea0fca104923710cb80fbaec8", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 62, "deletions": 9, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -65,12 +65,15 @@ pub struct Error;\n /// A collection of methods that are required to format a message into a stream.\n ///\n /// This trait is the type which this modules requires when formatting\n-/// information. This is similar to the standard library's `io::Write` trait,\n+/// information. This is similar to the standard library's [`io::Write`] trait,\n /// but it is only intended for use in libcore.\n ///\n /// This trait should generally not be implemented by consumers of the standard\n-/// library. The `write!` macro accepts an instance of `io::Write`, and the\n-/// `io::Write` trait is favored over implementing this trait.\n+/// library. The [`write!`] macro accepts an instance of [`io::Write`], and the\n+/// [`io::Write`] trait is favored over implementing this trait.\n+///\n+/// [`write!`]: ../../std/macro.write.html\n+/// [`io::Write`]: ../../std/io/trait.Write.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait Write {\n     /// Writes a slice of bytes into this writer, returning whether the write\n@@ -82,29 +85,79 @@ pub trait Write {\n     ///\n     /// # Errors\n     ///\n-    /// This function will return an instance of `Error` on error.\n+    /// This function will return an instance of [`Error`] on error.\n+    ///\n+    /// [`Error`]: struct.Error.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt::{Error, Write};\n+    ///\n+    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n+    ///     f.write_str(s)\n+    /// }\n+    ///\n+    /// let mut buf = String::new();\n+    /// writer(&mut buf, \"hola\").unwrap();\n+    /// assert_eq!(&buf, \"hola\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_str(&mut self, s: &str) -> Result;\n \n-    /// Writes a `char` into this writer, returning whether the write succeeded.\n+    /// Writes a [`char`] into this writer, returning whether the write succeeded.\n     ///\n-    /// A single `char` may be encoded as more than one byte.\n+    /// A single [`char`] may be encoded as more than one byte.\n     /// This method can only succeed if the entire byte sequence was successfully\n     /// written, and this method will not return until all data has been\n     /// written or an error occurs.\n     ///\n     /// # Errors\n     ///\n-    /// This function will return an instance of `Error` on error.\n+    /// This function will return an instance of [`Error`] on error.\n+    ///\n+    /// [`char`]: ../../std/primitive.char.html\n+    /// [`Error`]: struct.Error.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt::{Error, Write};\n+    ///\n+    /// fn writer<W: Write>(f: &mut W, c: char) -> Result<(), Error> {\n+    ///     f.write_char(c)\n+    /// }\n+    ///\n+    /// let mut buf = String::new();\n+    /// writer(&mut buf, 'a').unwrap();\n+    /// writer(&mut buf, 'b').unwrap();\n+    /// assert_eq!(&buf, \"ab\");\n+    /// ```\n     #[stable(feature = \"fmt_write_char\", since = \"1.1.0\")]\n     fn write_char(&mut self, c: char) -> Result {\n         self.write_str(c.encode_utf8(&mut [0; 4]))\n     }\n \n-    /// Glue for usage of the `write!` macro with implementors of this trait.\n+    /// Glue for usage of the [`write!`] macro with implementors of this trait.\n     ///\n     /// This method should generally not be invoked manually, but rather through\n-    /// the `write!` macro itself.\n+    /// the [`write!`] macro itself.\n+    ///\n+    /// [`write!`]: ../../std/macro.write.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::fmt::{Error, Write};\n+    ///\n+    /// fn writer<W: Write>(f: &mut W, s: &str) -> Result<(), Error> {\n+    ///     f.write_fmt(format_args!(\"{}\", s))\n+    /// }\n+    ///\n+    /// let mut buf = String::new();\n+    /// writer(&mut buf, \"world\").unwrap();\n+    /// assert_eq!(&buf, \"world\");\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn write_fmt(&mut self, args: Arguments) -> Result {\n         // This Adapter is needed to allow `self` (of type `&mut"}, {"sha": "f850fd97727810ca3230bed219a0d9e2b579443b", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 197, "deletions": 261, "changes": 458, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -21,7 +21,6 @@ use super::{\n     SelectionContext,\n     SelectionError,\n     ObjectSafetyViolation,\n-    MethodViolationCode,\n };\n \n use fmt_macros::{Parser, Piece, Position};\n@@ -267,61 +266,63 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n \n         let span = obligation.cause.span;\n         let mut report = None;\n-        for item in self.tcx.get_attrs(def_id).iter() {\n-            if item.check_name(\"rustc_on_unimplemented\") {\n-                let err_sp = item.meta().span.substitute_dummy(span);\n-                let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n-                if let Some(istring) = item.value_str() {\n-                    let istring = &*istring.as_str();\n-                    let generics = self.tcx.item_generics(trait_ref.def_id);\n-                    let generic_map = generics.types.iter().map(|param| {\n-                        (param.name.as_str().to_string(),\n-                         trait_ref.substs.type_for_def(param).to_string())\n-                    }).collect::<FxHashMap<String, String>>();\n-                    let parser = Parser::new(istring);\n-                    let mut errored = false;\n-                    let err: String = parser.filter_map(|p| {\n-                        match p {\n-                            Piece::String(s) => Some(s),\n-                            Piece::NextArgument(a) => match a.position {\n-                                Position::ArgumentNamed(s) => match generic_map.get(s) {\n-                                    Some(val) => Some(val),\n-                                    None => {\n-                                        span_err!(self.tcx.sess, err_sp, E0272,\n-                                                       \"the #[rustc_on_unimplemented] \\\n-                                                                attribute on \\\n-                                                                trait definition for {} refers to \\\n-                                                                non-existent type parameter {}\",\n-                                                               trait_str, s);\n-                                        errored = true;\n-                                        None\n-                                    }\n-                                },\n-                                _ => {\n-                                    span_err!(self.tcx.sess, err_sp, E0273,\n-                                              \"the #[rustc_on_unimplemented] attribute \\\n-                                               on trait definition for {} must have \\\n-                                               named format arguments, eg \\\n-                                               `#[rustc_on_unimplemented = \\\n-                                                \\\"foo {{T}}\\\"]`\", trait_str);\n+        if let Some(item) = self.tcx\n+            .get_attrs(def_id)\n+            .into_iter()\n+            .filter(|a| a.check_name(\"rustc_on_unimplemented\"))\n+            .next()\n+        {\n+            let err_sp = item.meta().span.substitute_dummy(span);\n+            let trait_str = self.tcx.item_path_str(trait_ref.def_id);\n+            if let Some(istring) = item.value_str() {\n+                let istring = &*istring.as_str();\n+                let generics = self.tcx.item_generics(trait_ref.def_id);\n+                let generic_map = generics.types.iter().map(|param| {\n+                    (param.name.as_str().to_string(),\n+                        trait_ref.substs.type_for_def(param).to_string())\n+                }).collect::<FxHashMap<String, String>>();\n+                let parser = Parser::new(istring);\n+                let mut errored = false;\n+                let err: String = parser.filter_map(|p| {\n+                    match p {\n+                        Piece::String(s) => Some(s),\n+                        Piece::NextArgument(a) => match a.position {\n+                            Position::ArgumentNamed(s) => match generic_map.get(s) {\n+                                Some(val) => Some(val),\n+                                None => {\n+                                    span_err!(self.tcx.sess, err_sp, E0272,\n+                                                    \"the #[rustc_on_unimplemented] \\\n+                                                            attribute on \\\n+                                                            trait definition for {} refers to \\\n+                                                            non-existent type parameter {}\",\n+                                                            trait_str, s);\n                                     errored = true;\n                                     None\n                                 }\n+                            },\n+                            _ => {\n+                                span_err!(self.tcx.sess, err_sp, E0273,\n+                                            \"the #[rustc_on_unimplemented] attribute \\\n+                                            on trait definition for {} must have \\\n+                                            named format arguments, eg \\\n+                                            `#[rustc_on_unimplemented = \\\n+                                            \\\"foo {{T}}\\\"]`\", trait_str);\n+                                errored = true;\n+                                None\n                             }\n                         }\n-                    }).collect();\n-                    // Report only if the format string checks out\n-                    if !errored {\n-                        report = Some(err);\n                     }\n-                } else {\n-                    span_err!(self.tcx.sess, err_sp, E0274,\n-                                            \"the #[rustc_on_unimplemented] attribute on \\\n-                                                     trait definition for {} must have a value, \\\n-                                                     eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n-                                                     trait_str);\n+                }).collect();\n+                // Report only if the format string checks out\n+                if !errored {\n+                    report = Some(err);\n                 }\n-                break;\n+            } else {\n+                span_err!(self.tcx.sess, err_sp, E0274,\n+                                        \"the #[rustc_on_unimplemented] attribute on \\\n+                                                    trait definition for {} must have a value, \\\n+                                                    eg `#[rustc_on_unimplemented = \\\"foo\\\"]`\",\n+                                                    trait_str);\n             }\n         }\n         report\n@@ -359,34 +360,9 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n     }\n \n     fn report_similar_impl_candidates(&self,\n-                                      trait_ref: ty::PolyTraitRef<'tcx>,\n+                                      impl_candidates: Vec<ty::TraitRef<'tcx>>,\n                                       err: &mut DiagnosticBuilder)\n     {\n-        let simp = fast_reject::simplify_type(self.tcx,\n-                                              trait_ref.skip_binder().self_ty(),\n-                                              true);\n-        let mut impl_candidates = Vec::new();\n-        let trait_def = self.tcx.lookup_trait_def(trait_ref.def_id());\n-\n-        match simp {\n-            Some(simp) => trait_def.for_each_impl(self.tcx, |def_id| {\n-                let imp = self.tcx.impl_trait_ref(def_id).unwrap();\n-                let imp_simp = fast_reject::simplify_type(self.tcx,\n-                                                          imp.self_ty(),\n-                                                          true);\n-                if let Some(imp_simp) = imp_simp {\n-                    if simp != imp_simp {\n-                        return;\n-                    }\n-                }\n-                impl_candidates.push(imp);\n-            }),\n-            None => trait_def.for_each_impl(self.tcx, |def_id| {\n-                impl_candidates.push(\n-                    self.tcx.impl_trait_ref(def_id).unwrap());\n-            })\n-        };\n-\n         if impl_candidates.is_empty() {\n             return;\n         }\n@@ -525,127 +501,118 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                         lint_id)\n                         .emit();\n                     return;\n-                } else {\n-                    match obligation.predicate {\n-                        ty::Predicate::Trait(ref trait_predicate) => {\n-                            let trait_predicate =\n-                                self.resolve_type_vars_if_possible(trait_predicate);\n-\n-                            if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n-                                return;\n-                            } else {\n-                                let trait_ref = trait_predicate.to_poly_trait_ref();\n-                                let (post_message, pre_message) = match self.get_parent_trait_ref(\n-                                    &obligation.cause.code)\n-                                {\n-                                    Some(t) => {\n-                                        (format!(\" in `{}`\", t), format!(\"within `{}`, \", t))\n-                                    }\n-                                    None => (String::new(), String::new()),\n-                                };\n-                                let mut err = struct_span_err!(\n-                                    self.tcx.sess,\n-                                    span,\n-                                    E0277,\n-                                    \"the trait bound `{}` is not satisfied{}\",\n-                                    trait_ref.to_predicate(),\n-                                    post_message);\n-                                err.span_label(span,\n-                                               &format!(\"{}the trait `{}` is not \\\n-                                                         implemented for `{}`\",\n-                                                        pre_message,\n-                                                        trait_ref,\n-                                                        trait_ref.self_ty()));\n-\n-                                // Try to report a help message\n-\n-                                if !trait_ref.has_infer_types() &&\n-                                    self.predicate_can_apply(trait_ref) {\n-                                    // If a where-clause may be useful, remind the\n-                                    // user that they can add it.\n-                                    //\n-                                    // don't display an on-unimplemented note, as\n-                                    // these notes will often be of the form\n-                                    //     \"the type `T` can't be frobnicated\"\n-                                    // which is somewhat confusing.\n-                                    err.help(&format!(\"consider adding a `where {}` bound\",\n-                                                      trait_ref.to_predicate()));\n-                                } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n-                                                                                   obligation) {\n-                                    // If it has a custom \"#[rustc_on_unimplemented]\"\n-                                    // error message, let's display it!\n-                                    err.note(&s);\n-                                } else {\n-                                    // If we can't show anything useful, try to find\n-                                    // similar impls.\n-                                    let impl_candidates =\n-                                        self.find_similar_impl_candidates(trait_ref);\n-                                    if impl_candidates.len() > 0 {\n-                                        self.report_similar_impl_candidates(trait_ref, &mut err);\n-                                    }\n-                                }\n-                                err\n-                            }\n-                        }\n+                }\n+                match obligation.predicate {\n+                    ty::Predicate::Trait(ref trait_predicate) => {\n+                        let trait_predicate =\n+                            self.resolve_type_vars_if_possible(trait_predicate);\n \n-                        ty::Predicate::Equate(ref predicate) => {\n-                            let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.equality_predicate(&obligation.cause,\n-                                                              &predicate).err().unwrap();\n-                            struct_span_err!(self.tcx.sess, span, E0278,\n-                                \"the requirement `{}` is not satisfied (`{}`)\",\n-                                predicate, err)\n+                        if self.tcx.sess.has_errors() && trait_predicate.references_error() {\n+                            return;\n                         }\n-\n-                        ty::Predicate::RegionOutlives(ref predicate) => {\n-                            let predicate = self.resolve_type_vars_if_possible(predicate);\n-                            let err = self.region_outlives_predicate(&obligation.cause,\n-                                                                     &predicate).err().unwrap();\n-                            struct_span_err!(self.tcx.sess, span, E0279,\n-                                \"the requirement `{}` is not satisfied (`{}`)\",\n-                                predicate, err)\n+                        let trait_ref = trait_predicate.to_poly_trait_ref();\n+                        let (post_message, pre_message) =\n+                            self.get_parent_trait_ref(&obligation.cause.code)\n+                                .map(|t| (format!(\" in `{}`\", t), format!(\"within `{}`, \", t)))\n+                                .unwrap_or((String::new(), String::new()));\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess,\n+                            span,\n+                            E0277,\n+                            \"the trait bound `{}` is not satisfied{}\",\n+                            trait_ref.to_predicate(),\n+                            post_message);\n+                        err.span_label(span,\n+                                        &format!(\"{}the trait `{}` is not \\\n+                                                    implemented for `{}`\",\n+                                                pre_message,\n+                                                trait_ref,\n+                                                trait_ref.self_ty()));\n+\n+                        // Try to report a help message\n+\n+                        if !trait_ref.has_infer_types() &&\n+                            self.predicate_can_apply(trait_ref) {\n+                            // If a where-clause may be useful, remind the\n+                            // user that they can add it.\n+                            //\n+                            // don't display an on-unimplemented note, as\n+                            // these notes will often be of the form\n+                            //     \"the type `T` can't be frobnicated\"\n+                            // which is somewhat confusing.\n+                            err.help(&format!(\"consider adding a `where {}` bound\",\n+                                                trait_ref.to_predicate()));\n+                        } else if let Some(s) = self.on_unimplemented_note(trait_ref,\n+                                                                            obligation) {\n+                            // If it has a custom \"#[rustc_on_unimplemented]\"\n+                            // error message, let's display it!\n+                            err.note(&s);\n+                        } else {\n+                            // If we can't show anything useful, try to find\n+                            // similar impls.\n+                            let impl_candidates = self.find_similar_impl_candidates(trait_ref);\n+                            self.report_similar_impl_candidates(impl_candidates, &mut err);\n                         }\n+                        err\n+                    }\n \n-                        ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n-                            let predicate =\n-                                self.resolve_type_vars_if_possible(&obligation.predicate);\n-                            struct_span_err!(self.tcx.sess, span, E0280,\n-                                \"the requirement `{}` is not satisfied\",\n-                                predicate)\n-                        }\n+                    ty::Predicate::Equate(ref predicate) => {\n+                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let err = self.equality_predicate(&obligation.cause,\n+                                                            &predicate).err().unwrap();\n+                        struct_span_err!(self.tcx.sess, span, E0278,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate, err)\n+                    }\n \n-                        ty::Predicate::ObjectSafe(trait_def_id) => {\n-                            let violations = self.tcx.object_safety_violations(trait_def_id);\n-                            self.tcx.report_object_safety_error(span,\n-                                                                trait_def_id,\n-                                                                violations)\n-                        }\n+                    ty::Predicate::RegionOutlives(ref predicate) => {\n+                        let predicate = self.resolve_type_vars_if_possible(predicate);\n+                        let err = self.region_outlives_predicate(&obligation.cause,\n+                                                                    &predicate).err().unwrap();\n+                        struct_span_err!(self.tcx.sess, span, E0279,\n+                            \"the requirement `{}` is not satisfied (`{}`)\",\n+                            predicate, err)\n+                    }\n \n-                        ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                            let found_kind = self.closure_kind(closure_def_id).unwrap();\n-                            let closure_span = self.tcx.hir.span_if_local(closure_def_id).unwrap();\n-                            let mut err = struct_span_err!(\n-                                self.tcx.sess, closure_span, E0525,\n-                                \"expected a closure that implements the `{}` trait, \\\n-                                 but this closure only implements `{}`\",\n-                                kind,\n-                                found_kind);\n-                            err.span_note(\n-                                obligation.cause.span,\n-                                &format!(\"the requirement to implement \\\n-                                          `{}` derives from here\", kind));\n-                            err.emit();\n-                            return;\n-                        }\n+                    ty::Predicate::Projection(..) | ty::Predicate::TypeOutlives(..) => {\n+                        let predicate =\n+                            self.resolve_type_vars_if_possible(&obligation.predicate);\n+                        struct_span_err!(self.tcx.sess, span, E0280,\n+                            \"the requirement `{}` is not satisfied\",\n+                            predicate)\n+                    }\n \n-                        ty::Predicate::WellFormed(ty) => {\n-                            // WF predicates cannot themselves make\n-                            // errors. They can only block due to\n-                            // ambiguity; otherwise, they always\n-                            // degenerate into other obligations\n-                            // (which may fail).\n-                            span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n-                        }\n+                    ty::Predicate::ObjectSafe(trait_def_id) => {\n+                        let violations = self.tcx.object_safety_violations(trait_def_id);\n+                        self.tcx.report_object_safety_error(span,\n+                                                            trait_def_id,\n+                                                            violations)\n+                    }\n+\n+                    ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                        let found_kind = self.closure_kind(closure_def_id).unwrap();\n+                        let closure_span = self.tcx.hir.span_if_local(closure_def_id).unwrap();\n+                        let mut err = struct_span_err!(\n+                            self.tcx.sess, closure_span, E0525,\n+                            \"expected a closure that implements the `{}` trait, \\\n+                                but this closure only implements `{}`\",\n+                            kind,\n+                            found_kind);\n+                        err.span_note(\n+                            obligation.cause.span,\n+                            &format!(\"the requirement to implement \\\n+                                        `{}` derives from here\", kind));\n+                        err.emit();\n+                        return;\n+                    }\n+\n+                    ty::Predicate::WellFormed(ty) => {\n+                        // WF predicates cannot themselves make\n+                        // errors. They can only block due to\n+                        // ambiguity; otherwise, they always\n+                        // degenerate into other obligations\n+                        // (which may fail).\n+                        span_bug!(span, \"WF predicate not satisfied for {:?}\", ty);\n                     }\n                 }\n             }\n@@ -713,38 +680,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             if !reported_violations.insert(violation.clone()) {\n                 continue;\n             }\n-            let buf;\n-            let note = match violation {\n-                ObjectSafetyViolation::SizedSelf => {\n-                    \"the trait cannot require that `Self : Sized`\"\n-                }\n-\n-                ObjectSafetyViolation::SupertraitSelf => {\n-                    \"the trait cannot use `Self` as a type parameter \\\n-                         in the supertrait listing\"\n-                }\n-\n-                ObjectSafetyViolation::Method(name,\n-                                              MethodViolationCode::StaticMethod) => {\n-                    buf = format!(\"method `{}` has no receiver\", name);\n-                    &buf\n-                }\n-\n-                ObjectSafetyViolation::Method(name,\n-                                              MethodViolationCode::ReferencesSelf) => {\n-                    buf = format!(\"method `{}` references the `Self` type \\\n-                                       in its arguments or return type\",\n-                                  name);\n-                    &buf\n-                }\n-\n-                ObjectSafetyViolation::Method(name,\n-                                              MethodViolationCode::Generic) => {\n-                    buf = format!(\"method `{}` has generic type parameters\", name);\n-                    &buf\n-                }\n-            };\n-            err.note(note);\n+            err.note(&violation.error_msg());\n         }\n         err\n     }\n@@ -774,46 +710,46 @@ impl<'a, 'gcx, 'tcx> InferCtxt<'a, 'gcx, 'tcx> {\n                 let trait_ref = data.to_poly_trait_ref();\n                 let self_ty = trait_ref.self_ty();\n                 if predicate.references_error() {\n-                } else {\n-                    // Typically, this ambiguity should only happen if\n-                    // there are unresolved type inference variables\n-                    // (otherwise it would suggest a coherence\n-                    // failure). But given #21974 that is not necessarily\n-                    // the case -- we can have multiple where clauses that\n-                    // are only distinguished by a region, which results\n-                    // in an ambiguity even when all types are fully\n-                    // known, since we don't dispatch based on region\n-                    // relationships.\n-\n-                    // This is kind of a hack: it frequently happens that some earlier\n-                    // error prevents types from being fully inferred, and then we get\n-                    // a bunch of uninteresting errors saying something like \"<generic\n-                    // #0> doesn't implement Sized\".  It may even be true that we\n-                    // could just skip over all checks where the self-ty is an\n-                    // inference variable, but I was afraid that there might be an\n-                    // inference variable created, registered as an obligation, and\n-                    // then never forced by writeback, and hence by skipping here we'd\n-                    // be ignoring the fact that we don't KNOW the type works\n-                    // out. Though even that would probably be harmless, given that\n-                    // we're only talking about builtin traits, which are known to be\n-                    // inhabited. But in any case I just threw in this check for\n-                    // has_errors() to be sure that compilation isn't happening\n-                    // anyway. In that case, why inundate the user.\n-                    if !self.tcx.sess.has_errors() {\n-                        if\n-                            self.tcx.lang_items.sized_trait()\n-                            .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n-                        {\n-                            self.need_type_info(obligation, self_ty);\n-                        } else {\n-                            let mut err = struct_span_err!(self.tcx.sess,\n-                                                           obligation.cause.span, E0283,\n-                                                           \"type annotations required: \\\n-                                                            cannot resolve `{}`\",\n-                                                           predicate);\n-                            self.note_obligation_cause(&mut err, obligation);\n-                            err.emit();\n-                        }\n+                    return;\n+                }\n+                // Typically, this ambiguity should only happen if\n+                // there are unresolved type inference variables\n+                // (otherwise it would suggest a coherence\n+                // failure). But given #21974 that is not necessarily\n+                // the case -- we can have multiple where clauses that\n+                // are only distinguished by a region, which results\n+                // in an ambiguity even when all types are fully\n+                // known, since we don't dispatch based on region\n+                // relationships.\n+\n+                // This is kind of a hack: it frequently happens that some earlier\n+                // error prevents types from being fully inferred, and then we get\n+                // a bunch of uninteresting errors saying something like \"<generic\n+                // #0> doesn't implement Sized\".  It may even be true that we\n+                // could just skip over all checks where the self-ty is an\n+                // inference variable, but I was afraid that there might be an\n+                // inference variable created, registered as an obligation, and\n+                // then never forced by writeback, and hence by skipping here we'd\n+                // be ignoring the fact that we don't KNOW the type works\n+                // out. Though even that would probably be harmless, given that\n+                // we're only talking about builtin traits, which are known to be\n+                // inhabited. But in any case I just threw in this check for\n+                // has_errors() to be sure that compilation isn't happening\n+                // anyway. In that case, why inundate the user.\n+                if !self.tcx.sess.has_errors() {\n+                    if\n+                        self.tcx.lang_items.sized_trait()\n+                        .map_or(false, |sized_id| sized_id == trait_ref.def_id())\n+                    {\n+                        self.need_type_info(obligation, self_ty);\n+                    } else {\n+                        let mut err = struct_span_err!(self.tcx.sess,\n+                                                        obligation.cause.span, E0283,\n+                                                        \"type annotations required: \\\n+                                                        cannot resolve `{}`\",\n+                                                        predicate);\n+                        self.note_obligation_cause(&mut err, obligation);\n+                        err.emit();\n                     }\n                 }\n             }"}, {"sha": "2ebe0d459fab1453451b02f4bc7fd208224ac76b", "filename": "src/librustc/traits/object_safety.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fobject_safety.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -23,6 +23,7 @@ use hir::def_id::DefId;\n use traits;\n use ty::{self, Ty, TyCtxt, TypeFoldable};\n use ty::subst::Substs;\n+use std::borrow::Cow;\n use syntax::ast;\n \n #[derive(Clone, Debug, PartialEq, Eq, Hash)]\n@@ -38,6 +39,25 @@ pub enum ObjectSafetyViolation {\n     Method(ast::Name, MethodViolationCode),\n }\n \n+impl ObjectSafetyViolation {\n+    pub fn error_msg(&self) -> Cow<'static, str> {\n+        match *self {\n+            ObjectSafetyViolation::SizedSelf =>\n+                \"the trait cannot require that `Self : Sized`\".into(),\n+            ObjectSafetyViolation::SupertraitSelf =>\n+                \"the trait cannot use `Self` as a type parameter \\\n+                 in the supertrait listing\".into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::StaticMethod) =>\n+                format!(\"method `{}` has no receiver\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::ReferencesSelf) =>\n+                format!(\"method `{}` references the `Self` type \\\n+                         in its arguments or return type\", name).into(),\n+            ObjectSafetyViolation::Method(name, MethodViolationCode::Generic) =>\n+                format!(\"method `{}` has generic type parameters\", name).into(),\n+        }\n+    }\n+}\n+\n /// Reasons a method might not be object-safe.\n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n pub enum MethodViolationCode {"}, {"sha": "656d0ddf09a52782862113f528fff3225f8ec758", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -1097,24 +1097,6 @@ impl<'tcx> InstantiatedPredicates<'tcx> {\n     }\n }\n \n-impl<'tcx> TraitRef<'tcx> {\n-    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>) -> TraitRef<'tcx> {\n-        TraitRef { def_id: def_id, substs: substs }\n-    }\n-\n-    pub fn self_ty(&self) -> Ty<'tcx> {\n-        self.substs.type_at(0)\n-    }\n-\n-    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n-        // Select only the \"input types\" from a trait-reference. For\n-        // now this is all the types that appear in the\n-        // trait-reference, but it should eventually exclude\n-        // associated types.\n-        self.substs.types()\n-    }\n-}\n-\n /// When type checking, we use the `ParameterEnvironment` to track\n /// details about the type/lifetime parameters that are in scope.\n /// It primarily stores the bounds information."}, {"sha": "e686d62019145bc13d7aaadb1d955a4116d0a86b", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -389,6 +389,24 @@ pub struct TraitRef<'tcx> {\n     pub substs: &'tcx Substs<'tcx>,\n }\n \n+impl<'tcx> TraitRef<'tcx> {\n+    pub fn new(def_id: DefId, substs: &'tcx Substs<'tcx>) -> TraitRef<'tcx> {\n+        TraitRef { def_id: def_id, substs: substs }\n+    }\n+\n+    pub fn self_ty(&self) -> Ty<'tcx> {\n+        self.substs.type_at(0)\n+    }\n+\n+    pub fn input_types<'a>(&'a self) -> impl DoubleEndedIterator<Item=Ty<'tcx>> + 'a {\n+        // Select only the \"input types\" from a trait-reference. For\n+        // now this is all the types that appear in the\n+        // trait-reference, but it should eventually exclude\n+        // associated types.\n+        self.substs.types()\n+    }\n+}\n+\n pub type PolyTraitRef<'tcx> = Binder<TraitRef<'tcx>>;\n \n impl<'tcx> PolyTraitRef<'tcx> {"}, {"sha": "bb39c8c4f22ffb53e0ec4680d1f0c91d99c72da1", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -1878,7 +1878,7 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n                                             &cx.shared.issue_tracker_base_url,\n                                             stab.issue) {\n                     (true, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n-                        format!(\" (<code>{}</code> <a href=\\\"{}{}\\\">#{}</a>)\",\n+                        format!(\" (<code>{} </code><a href=\\\"{}{}\\\">#{}</a>)\",\n                                 Escape(&stab.feature), tracker_url, issue_no, issue_no),\n                     (false, &Some(ref tracker_url), Some(issue_no)) if issue_no > 0 =>\n                         format!(\" (<a href=\\\"{}{}\\\">#{}</a>)\", Escape(&tracker_url), issue_no,\n@@ -1890,12 +1890,12 @@ fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<S\n                 if stab.unstable_reason.is_empty() {\n                     stability.push(format!(\"<div class='stab unstable'>\\\n                                             <span class=microscope>\ud83d\udd2c</span> \\\n-                                            This is a nightly-only experimental API. &nbsp;{}\\\n+                                            This is a nightly-only experimental API. {}\\\n                                             </div>\",\n-                                   unstable_extra));\n+                                           unstable_extra));\n                 } else {\n                     let text = format!(\"<summary><span class=microscope>\ud83d\udd2c</span> \\\n-                                        This is a nightly-only experimental API. &nbsp;{}\\\n+                                        This is a nightly-only experimental API. {}\\\n                                         </summary>{}\",\n                                        unstable_extra, MarkdownHtml(&stab.unstable_reason));\n                     stability.push(format!(\"<div class='stab unstable'><details>{}</details></div>\","}, {"sha": "f846ef3e69e093f24f0cb88422f62575c7bd327e", "filename": "src/libstd/process.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibstd%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibstd%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprocess.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -27,6 +27,31 @@\n //!\n //! assert!(ecode.success());\n //! ```\n+//!\n+//! Calling a command with input and reading its output:\n+//!\n+//! ```no_run\n+//! use std::process::{Command, Stdio};\n+//! use std::io::Write;\n+//!\n+//! let mut child = Command::new(\"/bin/cat\")\n+//!     .stdin(Stdio::piped())\n+//!     .stdout(Stdio::piped())\n+//!     .spawn()\n+//!     .expect(\"failed to execute child\");\n+//!\n+//! {\n+//!     // limited borrow of stdin\n+//!     let stdin = child.stdin.as_mut().expect(\"failed to get stdin\");\n+//!     stdin.write_all(b\"test\").expect(\"failed to write to stdin\");\n+//! }\n+//!\n+//! let output = child\n+//!     .wait_with_output()\n+//!     .expect(\"failed to wait on child\");\n+//!\n+//! assert_eq!(b\"test\", output.stdout.as_slice());\n+//! ```\n \n #![stable(feature = \"process\", since = \"1.0.0\")]\n "}, {"sha": "68c7e88f67fc56218f5f8fd557fc2a088ce1fe46", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 230, "deletions": 16, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -18,12 +18,57 @@ use time::Duration;\n \n /// A type indicating whether a timed wait on a condition variable returned\n /// due to a time out or not.\n+///\n+/// It is returned by the [`wait_timeout`] method.\n+///\n+/// [`wait_timeout`]: struct.Condvar.html#method.wait_timeout\n #[derive(Debug, PartialEq, Eq, Copy, Clone)]\n #[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\n pub struct WaitTimeoutResult(bool);\n \n impl WaitTimeoutResult {\n     /// Returns whether the wait was known to have timed out.\n+    ///\n+    /// # Examples\n+    ///\n+    /// This example spawns a thread which will update the boolean value and\n+    /// then wait 100 milliseconds before notifying the condvar.\n+    ///\n+    /// The main thread will wait with a timeout on the condvar and then leave\n+    /// once the boolean has been updated and notified.\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::thread;\n+    /// use std::time::Duration;\n+    ///\n+    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair2 = pair.clone();\n+    ///\n+    /// thread::spawn(move|| {\n+    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let mut started = lock.lock().unwrap();\n+    ///     // We update the boolean value.\n+    ///     *started = true;\n+    ///     // Let's wait 20 milliseconds before notifying the condvar.\n+    ///     thread::sleep(Duration::from_millis(20));\n+    ///     cvar.notify_one();\n+    /// });\n+    ///\n+    /// // Wait for the thread to start up.\n+    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let mut started = lock.lock().unwrap();\n+    /// loop {\n+    ///     // Let's put a timeout on the condvar's wait.\n+    ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n+    ///     // 10 milliseconds have passed, or maybe the value changed!\n+    ///     started = result.0;\n+    ///     if *started == true {\n+    ///         // We received the notification and the value has been updated, we can leave.\n+    ///         break\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\n     pub fn timed_out(&self) -> bool {\n         self.0\n@@ -55,15 +100,16 @@ impl WaitTimeoutResult {\n /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n /// let pair2 = pair.clone();\n ///\n-/// // Inside of our lock, spawn a new thread, and then wait for it to start\n+/// // Inside of our lock, spawn a new thread, and then wait for it to start.\n /// thread::spawn(move|| {\n ///     let &(ref lock, ref cvar) = &*pair2;\n ///     let mut started = lock.lock().unwrap();\n ///     *started = true;\n+///     // We notify the condvar that the value has changed.\n ///     cvar.notify_one();\n /// });\n ///\n-/// // wait for the thread to start up\n+/// // Wait for the thread to start up.\n /// let &(ref lock, ref cvar) = &*pair;\n /// let mut started = lock.lock().unwrap();\n /// while !*started {\n@@ -79,6 +125,14 @@ pub struct Condvar {\n impl Condvar {\n     /// Creates a new condition variable which is ready to be waited on and\n     /// notified.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::Condvar;\n+    ///\n+    /// let condvar = Condvar::new();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Condvar {\n         let mut c = Condvar {\n@@ -95,10 +149,10 @@ impl Condvar {\n     /// notification.\n     ///\n     /// This function will atomically unlock the mutex specified (represented by\n-    /// `mutex_guard`) and block the current thread. This means that any calls\n-    /// to `notify_*()` which happen logically after the mutex is unlocked are\n-    /// candidates to wake this thread up. When this function call returns, the\n-    /// lock specified will have been re-acquired.\n+    /// `guard`) and block the current thread. This means that any calls\n+    /// to [`notify_one()`] or [`notify_all()`] which happen logically after the\n+    /// mutex is unlocked are candidates to wake this thread up. When this\n+    /// function call returns, the lock specified will have been re-acquired.\n     ///\n     /// Note that this function is susceptible to spurious wakeups. Condition\n     /// variables normally have a boolean predicate associated with them, and\n@@ -109,14 +163,46 @@ impl Condvar {\n     ///\n     /// This function will return an error if the mutex being waited on is\n     /// poisoned when this thread re-acquires the lock. For more information,\n-    /// see information about poisoning on the Mutex type.\n+    /// see information about [poisoning] on the [`Mutex`] type.\n     ///\n     /// # Panics\n     ///\n-    /// This function will `panic!()` if it is used with more than one mutex\n+    /// This function will [`panic!()`] if it is used with more than one mutex\n     /// over time. Each condition variable is dynamically bound to exactly one\n     /// mutex to ensure defined behavior across platforms. If this functionality\n     /// is not desired, then unsafe primitives in `sys` are provided.\n+    ///\n+    /// [`notify_one()`]: #method.notify_one\n+    /// [`notify_all()`]: #method.notify_all\n+    /// [poisoning]: ../sync/struct.Mutex.html#poisoning\n+    /// [`Mutex`]: ../sync/struct.Mutex.html\n+    /// [`panic!()`]: ../../std/macro.panic.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::thread;\n+    ///\n+    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair2 = pair.clone();\n+    ///\n+    /// thread::spawn(move|| {\n+    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let mut started = lock.lock().unwrap();\n+    ///     *started = true;\n+    ///     // We notify the condvar that the value has changed.\n+    ///     cvar.notify_one();\n+    /// });\n+    ///\n+    /// // Wait for the thread to start up.\n+    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let mut started = lock.lock().unwrap();\n+    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// while !*started {\n+    ///     started = cvar.wait(started).unwrap();\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn wait<'a, T>(&self, guard: MutexGuard<'a, T>)\n                        -> LockResult<MutexGuard<'a, T>> {\n@@ -136,7 +222,7 @@ impl Condvar {\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n-    /// The semantics of this function are equivalent to `wait()`\n+    /// The semantics of this function are equivalent to [`wait`]\n     /// except that the thread will be blocked for roughly no longer\n     /// than `ms` milliseconds. This method should not be used for\n     /// precise timing due to anomalies such as preemption or platform\n@@ -150,8 +236,42 @@ impl Condvar {\n     /// The returned boolean is `false` only if the timeout is known\n     /// to have elapsed.\n     ///\n-    /// Like `wait`, the lock specified will be re-acquired when this function\n+    /// Like [`wait`], the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n+    ///\n+    /// [`wait`]: #method.wait\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::thread;\n+    ///\n+    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair2 = pair.clone();\n+    ///\n+    /// thread::spawn(move|| {\n+    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let mut started = lock.lock().unwrap();\n+    ///     *started = true;\n+    ///     // We notify the condvar that the value has changed.\n+    ///     cvar.notify_one();\n+    /// });\n+    ///\n+    /// // Wait for the thread to start up.\n+    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let mut started = lock.lock().unwrap();\n+    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// loop {\n+    ///     let result = cvar.wait_timeout_ms(started, 10).unwrap();\n+    ///     // 10 milliseconds have passed, or maybe the value changed!\n+    ///     started = result.0;\n+    ///     if *started == true {\n+    ///         // We received the notification and the value has been updated, we can leave.\n+    ///         break\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[rustc_deprecated(since = \"1.6.0\", reason = \"replaced by `std::sync::Condvar::wait_timeout`\")]\n     pub fn wait_timeout_ms<'a, T>(&self, guard: MutexGuard<'a, T>, ms: u32)\n@@ -165,7 +285,7 @@ impl Condvar {\n     /// Waits on this condition variable for a notification, timing out after a\n     /// specified duration.\n     ///\n-    /// The semantics of this function are equivalent to `wait()` except that\n+    /// The semantics of this function are equivalent to [`wait`] except that\n     /// the thread will be blocked for roughly no longer than `dur`. This\n     /// method should not be used for precise timing due to anomalies such as\n     /// preemption or platform differences that may not cause the maximum\n@@ -175,11 +295,47 @@ impl Condvar {\n     /// measured with a monotonic clock, and not affected by the changes made to\n     /// the system time.\n     ///\n-    /// The returned `WaitTimeoutResult` value indicates if the timeout is\n+    /// The returned [`WaitTimeoutResult`] value indicates if the timeout is\n     /// known to have elapsed.\n     ///\n-    /// Like `wait`, the lock specified will be re-acquired when this function\n+    /// Like [`wait`], the lock specified will be re-acquired when this function\n     /// returns, regardless of whether the timeout elapsed or not.\n+    ///\n+    /// [`wait`]: #method.wait\n+    /// [`WaitTimeoutResult`]: struct.WaitTimeoutResult.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::thread;\n+    /// use std::time::Duration;\n+    ///\n+    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair2 = pair.clone();\n+    ///\n+    /// thread::spawn(move|| {\n+    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let mut started = lock.lock().unwrap();\n+    ///     *started = true;\n+    ///     // We notify the condvar that the value has changed.\n+    ///     cvar.notify_one();\n+    /// });\n+    ///\n+    /// // wait for the thread to start up\n+    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let mut started = lock.lock().unwrap();\n+    /// // as long as the value inside the `Mutex` is false, we wait\n+    /// loop {\n+    ///     let result = cvar.wait_timeout(started, Duration::from_millis(10)).unwrap();\n+    ///     // 10 milliseconds have passed, or maybe the value changed!\n+    ///     started = result.0;\n+    ///     if *started == true {\n+    ///         // We received the notification and the value has been updated, we can leave.\n+    ///         break\n+    ///     }\n+    /// }\n+    /// ```\n     #[stable(feature = \"wait_timeout\", since = \"1.5.0\")]\n     pub fn wait_timeout<'a, T>(&self, guard: MutexGuard<'a, T>,\n                                dur: Duration)\n@@ -200,10 +356,40 @@ impl Condvar {\n     /// Wakes up one blocked thread on this condvar.\n     ///\n     /// If there is a blocked thread on this condition variable, then it will\n-    /// be woken up from its call to `wait` or `wait_timeout`. Calls to\n+    /// be woken up from its call to [`wait`] or [`wait_timeout`]. Calls to\n     /// `notify_one` are not buffered in any way.\n     ///\n-    /// To wake up all threads, see `notify_all()`.\n+    /// To wake up all threads, see [`notify_all()`].\n+    ///\n+    /// [`wait`]: #method.wait\n+    /// [`wait_timeout`]: #method.wait_timeout\n+    /// [`notify_all()`]: #method.notify_all\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::thread;\n+    ///\n+    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair2 = pair.clone();\n+    ///\n+    /// thread::spawn(move|| {\n+    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let mut started = lock.lock().unwrap();\n+    ///     *started = true;\n+    ///     // We notify the condvar that the value has changed.\n+    ///     cvar.notify_one();\n+    /// });\n+    ///\n+    /// // Wait for the thread to start up.\n+    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let mut started = lock.lock().unwrap();\n+    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// while !*started {\n+    ///     started = cvar.wait(started).unwrap();\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_one(&self) {\n         unsafe { self.inner.notify_one() }\n@@ -215,7 +401,35 @@ impl Condvar {\n     /// variable are awoken. Calls to `notify_all()` are not buffered in any\n     /// way.\n     ///\n-    /// To wake up only one thread, see `notify_one()`.\n+    /// To wake up only one thread, see [`notify_one()`].\n+    ///\n+    /// [`notify_one()`]: #method.notify_one\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::sync::{Arc, Mutex, Condvar};\n+    /// use std::thread;\n+    ///\n+    /// let pair = Arc::new((Mutex::new(false), Condvar::new()));\n+    /// let pair2 = pair.clone();\n+    ///\n+    /// thread::spawn(move|| {\n+    ///     let &(ref lock, ref cvar) = &*pair2;\n+    ///     let mut started = lock.lock().unwrap();\n+    ///     *started = true;\n+    ///     // We notify the condvar that the value has changed.\n+    ///     cvar.notify_all();\n+    /// });\n+    ///\n+    /// // Wait for the thread to start up.\n+    /// let &(ref lock, ref cvar) = &*pair;\n+    /// let mut started = lock.lock().unwrap();\n+    /// // As long as the value inside the `Mutex` is false, we wait.\n+    /// while !*started {\n+    ///     started = cvar.wait(started).unwrap();\n+    /// }\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn notify_all(&self) {\n         unsafe { self.inner.notify_all() }"}, {"sha": "4005021774443ec8170e42e85e8c48d5deefbbfb", "filename": "src/test/compile-fail/feature-gate-unboxed-closures.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Ffeature-gate-unboxed-closures.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct Test;\n+\n+impl FnOnce<(u32, u32)> for Test {\n+    type Output = u32;\n+\n+    extern \"rust-call\" fn call_once(self, (a, b): (u32, u32)) -> u32 {\n+        a + b\n+    }\n+    //~^^^ ERROR rust-call ABI is subject to change (see issue #29625)\n+}\n+\n+fn main() {\n+    assert_eq!(Test(1u32, 2u32), 3u32);\n+}"}, {"sha": "e82e93230aa07bf587a993254928cffffbd15491", "filename": "src/test/rustdoc/issue-27759.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Ftest%2Frustdoc%2Fissue-27759.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Ftest%2Frustdoc%2Fissue-27759.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-27759.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -14,12 +14,12 @@\n #![unstable(feature=\"test\", issue=\"27759\")]\n \n // @has issue_27759/unstable/index.html\n-// @has - '<code>test</code>'\n+// @has - '<code>test </code>'\n // @has - '<a href=\"http://issue_url/27759\">#27759</a>'\n #[unstable(feature=\"test\", issue=\"27759\")]\n pub mod unstable {\n     // @has issue_27759/unstable/fn.issue.html\n-    // @has - '<code>test_function</code>'\n+    // @has - '<code>test_function </code>'\n     // @has - '<a href=\"http://issue_url/1234567890\">#1234567890</a>'\n     #[unstable(feature=\"test_function\", issue=\"1234567890\")]\n     pub fn issue() {}"}, {"sha": "6d1f8bc1cf9bac27ccfcd6421b6dceea06d9e32c", "filename": "src/test/rustdoc/issue-32374.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Ftest%2Frustdoc%2Fissue-32374.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Ftest%2Frustdoc%2Fissue-32374.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-32374.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -18,22 +18,22 @@\n \n // @has issue_32374/struct.T.html '//*[@class=\"stab deprecated\"]' \\\n //      'Deprecated since 1.0.0: text'\n-// @has - '<code>test</code>'\n+// @has - '<code>test </code>'\n // @has - '<a href=\"http://issue_url/32374\">#32374</a>'\n // @matches issue_32374/struct.T.html '//*[@class=\"stab unstable\"]' \\\n-//      '\ud83d\udd2c This is a nightly-only experimental API.   \\(test #32374\\)$'\n+//      '\ud83d\udd2c This is a nightly-only experimental API.  \\(test #32374\\)$'\n #[rustc_deprecated(since = \"1.0.0\", reason = \"text\")]\n #[unstable(feature = \"test\", issue = \"32374\")]\n pub struct T;\n \n // @has issue_32374/struct.U.html '//*[@class=\"stab deprecated\"]' \\\n //      'Deprecated since 1.0.0: deprecated'\n // @has issue_32374/struct.U.html '//*[@class=\"stab unstable\"]' \\\n-//      '\ud83d\udd2c This is a nightly-only experimental API.  (test #32374)'\n+//      '\ud83d\udd2c This is a nightly-only experimental API. (test #32374)'\n // @has issue_32374/struct.U.html '//details' \\\n-//      '\ud83d\udd2c This is a nightly-only experimental API.  (test #32374)'\n+//      '\ud83d\udd2c This is a nightly-only experimental API. (test #32374)'\n // @has issue_32374/struct.U.html '//summary' \\\n-//      '\ud83d\udd2c This is a nightly-only experimental API.  (test #32374)'\n+//      '\ud83d\udd2c This is a nightly-only experimental API. (test #32374)'\n // @has issue_32374/struct.U.html '//details/p' \\\n //      'unstable'\n #[rustc_deprecated(since = \"1.0.0\", reason = \"deprecated\")]"}, {"sha": "c84fefd872e4718de9658bec917721ae4b1f3887", "filename": "src/tools/tidy/src/features.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "raw_url": "https://github.com/rust-lang/rust/raw/be760566cf938d11d34c2f6bd90d8fd0f67c2344/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Ffeatures.rs?ref=be760566cf938d11d34c2f6bd90d8fd0f67c2344", "patch": "@@ -169,8 +169,8 @@ pub fn check(path: &Path, bad: &mut bool) {\n     let whitelist = vec![\n         \"abi_ptx\", \"simd\",\n         \"cfg_target_has_atomic\",\n-        \"unboxed_closures\", \"stmt_expr_attributes\",\n-        \"cfg_target_thread_local\", \"unwind_attributes\"\n+        \"stmt_expr_attributes\",\n+        \"cfg_target_thread_local\", \"unwind_attributes\",\n     ];\n \n     // Only check the number of lang features."}]}