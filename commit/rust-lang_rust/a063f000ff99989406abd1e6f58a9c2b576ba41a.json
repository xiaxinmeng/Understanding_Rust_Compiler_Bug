{"sha": "a063f000ff99989406abd1e6f58a9c2b576ba41a", "node_id": "C_kwDOAAsO6NoAKGEwNjNmMDAwZmY5OTk4OTQwNmFiZDFlNmY1OGE5YzJiNTc2YmE0MWE", "commit": {"author": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-11T18:13:53Z"}, "committer": {"name": "hkalbasi", "email": "hamidrezakalbasi@protonmail.com", "date": "2023-03-17T09:38:35Z"}, "message": "Support function pointer MIR lowering", "tree": {"sha": "5b1b9658991472ce836a8521f89619aee0d862cb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b1b9658991472ce836a8521f89619aee0d862cb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a063f000ff99989406abd1e6f58a9c2b576ba41a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a063f000ff99989406abd1e6f58a9c2b576ba41a", "html_url": "https://github.com/rust-lang/rust/commit/a063f000ff99989406abd1e6f58a9c2b576ba41a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a063f000ff99989406abd1e6f58a9c2b576ba41a/comments", "author": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "committer": {"login": "HKalbasi", "id": 45197576, "node_id": "MDQ6VXNlcjQ1MTk3NTc2", "avatar_url": "https://avatars.githubusercontent.com/u/45197576?v=4", "gravatar_id": "", "url": "https://api.github.com/users/HKalbasi", "html_url": "https://github.com/HKalbasi", "followers_url": "https://api.github.com/users/HKalbasi/followers", "following_url": "https://api.github.com/users/HKalbasi/following{/other_user}", "gists_url": "https://api.github.com/users/HKalbasi/gists{/gist_id}", "starred_url": "https://api.github.com/users/HKalbasi/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/HKalbasi/subscriptions", "organizations_url": "https://api.github.com/users/HKalbasi/orgs", "repos_url": "https://api.github.com/users/HKalbasi/repos", "events_url": "https://api.github.com/users/HKalbasi/events{/privacy}", "received_events_url": "https://api.github.com/users/HKalbasi/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b85b43e6f5283963e901597c67e89b82d90df01", "url": "https://api.github.com/repos/rust-lang/rust/commits/1b85b43e6f5283963e901597c67e89b82d90df01", "html_url": "https://github.com/rust-lang/rust/commit/1b85b43e6f5283963e901597c67e89b82d90df01"}], "stats": {"total": 630, "additions": 467, "deletions": 163}, "files": [{"sha": "71eb35d9df8e4437bc4239816df4097160252d6e", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -343,6 +343,8 @@ pub mod known {\n         feature,\n         // known methods of lang items\n         call_once,\n+        call_mut,\n+        call,\n         eq,\n         ne,\n         ge,"}, {"sha": "8a9a5d254df84595948f621d3fbb4dccc988670f", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 102, "deletions": 0, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -906,6 +906,108 @@ fn or_pattern() {\n     );\n }\n \n+#[test]\n+fn function_pointer() {\n+    check_number(\n+        r#\"\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    const GOAL: u8 = {\n+        let plus2 = add2;\n+        plus2(3)\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    const GOAL: u8 = {\n+        let plus2: fn(u8) -> u8 = add2;\n+        plus2(3)\n+    };\n+        \"#,\n+        5,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: coerce_unsized, index, slice\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn mult3(x: u8) -> u8 {\n+        x * 3\n+    }\n+    const GOAL: u8 = {\n+        let x = [add2, mult3];\n+        x[0](1) + x[1](5)\n+    };\n+        \"#,\n+        18,\n+    );\n+}\n+\n+#[test]\n+fn function_traits() {\n+    check_number(\n+        r#\"\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(mut f: impl FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_once(f: impl FnOnce(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(add2, 3) + call_mut(add2, 3) + call_once(add2, 3);\n+        \"#,\n+        15,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_mut(mut f: impl FnMut(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    fn call_once(f: impl FnOnce(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = {\n+        let add2: fn(u8) -> u8 = add2;\n+        call(add2, 3) + call_mut(add2, 3) + call_once(add2, 3)\n+    };\n+        \"#,\n+        15,\n+    );\n+    check_number(\n+        r#\"\n+    //- minicore: fn\n+    fn add2(x: u8) -> u8 {\n+        x + 2\n+    }\n+    fn call(f: &&&&&impl Fn(u8) -> u8, x: u8) -> u8 {\n+        f(x)\n+    }\n+    const GOAL: u8 = call(&&&&&add2, 3);\n+        \"#,\n+        5,\n+    );\n+}\n+\n #[test]\n fn array_and_index() {\n     check_number("}, {"sha": "06d74215fffbf79d272c376a3b8dc8d2343518db", "filename": "crates/hir-ty/src/infer.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -38,9 +38,9 @@ use stdx::{always, never};\n \n use crate::{\n     db::HirDatabase, fold_tys, fold_tys_and_consts, infer::coerce::CoerceMany,\n-    lower::ImplTraitLoweringMode, to_assoc_type_id, AliasEq, AliasTy, Const, DomainGoal,\n-    GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId, Substitution,\n-    TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n+    lower::ImplTraitLoweringMode, static_lifetime, to_assoc_type_id, AliasEq, AliasTy, Const,\n+    DomainGoal, GenericArg, Goal, ImplTraitId, InEnvironment, Interner, ProjectionTy, RpitId,\n+    Substitution, TraitEnvironment, TraitRef, Ty, TyBuilder, TyExt, TyKind,\n };\n \n // This lint has a false positive here. See the link below for details.\n@@ -273,6 +273,13 @@ pub struct Adjustment {\n     pub target: Ty,\n }\n \n+impl Adjustment {\n+    pub fn borrow(m: Mutability, ty: Ty) -> Self {\n+        let ty = TyKind::Ref(m, static_lifetime(), ty).intern(Interner);\n+        Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(m)), target: ty }\n+    }\n+}\n+\n #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]\n pub enum Adjust {\n     /// Go from ! to any type."}, {"sha": "6e899249b696950536d2eba7df67247a54f404b8", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -51,11 +51,12 @@ fn success(\n pub(super) struct CoerceMany {\n     expected_ty: Ty,\n     final_ty: Option<Ty>,\n+    expressions: Vec<ExprId>,\n }\n \n impl CoerceMany {\n     pub(super) fn new(expected: Ty) -> Self {\n-        CoerceMany { expected_ty: expected, final_ty: None }\n+        CoerceMany { expected_ty: expected, final_ty: None, expressions: vec![] }\n     }\n \n     /// Returns the \"expected type\" with which this coercion was\n@@ -125,8 +126,15 @@ impl CoerceMany {\n             let result1 = ctx.table.coerce_inner(self.merged_ty(), &target_ty);\n             let result2 = ctx.table.coerce_inner(expr_ty.clone(), &target_ty);\n             if let (Ok(result1), Ok(result2)) = (result1, result2) {\n-                ctx.table.register_infer_ok(result1);\n-                ctx.table.register_infer_ok(result2);\n+                ctx.table.register_infer_ok(InferOk { value: (), goals: result1.goals });\n+                for &e in &self.expressions {\n+                    ctx.write_expr_adj(e, result1.value.0.clone());\n+                }\n+                ctx.table.register_infer_ok(InferOk { value: (), goals: result2.goals });\n+                if let Some(expr) = expr {\n+                    ctx.write_expr_adj(expr, result2.value.0);\n+                    self.expressions.push(expr);\n+                }\n                 return self.final_ty = Some(target_ty);\n             }\n         }\n@@ -148,6 +156,9 @@ impl CoerceMany {\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);\n         }\n+        if let Some(expr) = expr {\n+            self.expressions.push(expr);\n+        }\n     }\n }\n "}, {"sha": "ca285f2fec0ae8875e9617c69aadc5fd0caaf948", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -34,6 +34,7 @@ use crate::{\n     method_resolution::{self, lang_items_for_bin_op, VisibleFromModule},\n     primitive::{self, UintTy},\n     static_lifetime, to_chalk_trait_id,\n+    traits::FnTrait,\n     utils::{generics, Generics},\n     Adjust, Adjustment, AdtId, AutoBorrow, Binders, CallableDefId, FnPointer, FnSig, FnSubst,\n     Interner, Rawness, Scalar, Substitution, TraitRef, Ty, TyBuilder, TyExt,\n@@ -385,16 +386,32 @@ impl<'a> InferenceContext<'a> {\n                         || res.is_none();\n                 let (param_tys, ret_ty) = match res {\n                     Some((func, params, ret_ty)) => {\n-                        let adjustments = auto_deref_adjust_steps(&derefs);\n-                        // FIXME: Handle call adjustments for Fn/FnMut\n-                        self.write_expr_adj(*callee, adjustments);\n-                        if let Some((trait_, func)) = func {\n-                            let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n-                                .push(callee_ty.clone())\n-                                .push(TyBuilder::tuple_with(params.iter().cloned()))\n-                                .build();\n-                            self.write_method_resolution(tgt_expr, func, subst.clone());\n+                        let mut adjustments = auto_deref_adjust_steps(&derefs);\n+                        if let Some(fn_x) = func {\n+                            match fn_x {\n+                                FnTrait::FnOnce => (),\n+                                FnTrait::FnMut => adjustments.push(Adjustment::borrow(\n+                                    Mutability::Mut,\n+                                    derefed_callee.clone(),\n+                                )),\n+                                FnTrait::Fn => adjustments.push(Adjustment::borrow(\n+                                    Mutability::Not,\n+                                    derefed_callee.clone(),\n+                                )),\n+                            }\n+                            let trait_ = fn_x\n+                                .get_id(self.db, self.trait_env.krate)\n+                                .expect(\"We just used it\");\n+                            let trait_data = self.db.trait_data(trait_);\n+                            if let Some(func) = trait_data.method_by_name(&fn_x.method_name()) {\n+                                let subst = TyBuilder::subst_for_def(self.db, trait_, None)\n+                                    .push(callee_ty.clone())\n+                                    .push(TyBuilder::tuple_with(params.iter().cloned()))\n+                                    .build();\n+                                self.write_method_resolution(tgt_expr, func, subst.clone());\n+                            }\n                         }\n+                        self.write_expr_adj(*callee, adjustments);\n                         (params, ret_ty)\n                     }\n                     None => {"}, {"sha": "2a07dd708c2a5ab4cd962102a5cc73a6a64dda44", "filename": "crates/hir-ty/src/infer/unify.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Funify.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -8,16 +8,15 @@ use chalk_ir::{\n };\n use chalk_solve::infer::ParameterEnaVariableExt;\n use ena::unify::UnifyKey;\n-use hir_def::{FunctionId, TraitId};\n use hir_expand::name;\n use stdx::never;\n \n use super::{InferOk, InferResult, InferenceContext, TypeError};\n use crate::{\n-    db::HirDatabase, fold_tys, static_lifetime, traits::FnTrait, AliasEq, AliasTy, BoundVar,\n-    Canonical, Const, DebruijnIndex, GenericArg, GenericArgData, Goal, Guidance, InEnvironment,\n-    InferenceVar, Interner, Lifetime, ParamKind, ProjectionTy, ProjectionTyExt, Scalar, Solution,\n-    Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n+    db::HirDatabase, fold_tys, static_lifetime, to_chalk_trait_id, traits::FnTrait, AliasEq,\n+    AliasTy, BoundVar, Canonical, Const, DebruijnIndex, GenericArg, GenericArgData, Goal, Guidance,\n+    InEnvironment, InferenceVar, Interner, Lifetime, ParamKind, ProjectionTy, ProjectionTyExt,\n+    Scalar, Solution, Substitution, TraitEnvironment, Ty, TyBuilder, TyExt, TyKind, VariableKind,\n };\n \n impl<'a> InferenceContext<'a> {\n@@ -631,7 +630,7 @@ impl<'a> InferenceTable<'a> {\n         &mut self,\n         ty: &Ty,\n         num_args: usize,\n-    ) -> Option<(Option<(TraitId, FunctionId)>, Vec<Ty>, Ty)> {\n+    ) -> Option<(Option<FnTrait>, Vec<Ty>, Ty)> {\n         match ty.callable_sig(self.db) {\n             Some(sig) => Some((None, sig.params().to_vec(), sig.ret().clone())),\n             None => self.callable_sig_from_fn_trait(ty, num_args),\n@@ -642,7 +641,7 @@ impl<'a> InferenceTable<'a> {\n         &mut self,\n         ty: &Ty,\n         num_args: usize,\n-    ) -> Option<(Option<(TraitId, FunctionId)>, Vec<Ty>, Ty)> {\n+    ) -> Option<(Option<FnTrait>, Vec<Ty>, Ty)> {\n         let krate = self.trait_env.krate;\n         let fn_once_trait = FnTrait::FnOnce.get_id(self.db, krate)?;\n         let trait_data = self.db.trait_data(fn_once_trait);\n@@ -676,19 +675,28 @@ impl<'a> InferenceTable<'a> {\n         };\n \n         let trait_env = self.trait_env.env.clone();\n+        let mut trait_ref = projection.trait_ref(self.db);\n         let obligation = InEnvironment {\n-            goal: projection.trait_ref(self.db).cast(Interner),\n-            environment: trait_env,\n+            goal: trait_ref.clone().cast(Interner),\n+            environment: trait_env.clone(),\n         };\n         let canonical = self.canonicalize(obligation.clone());\n         if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n             self.register_obligation(obligation.goal);\n             let return_ty = self.normalize_projection_ty(projection);\n-            Some((\n-                Some(fn_once_trait).zip(trait_data.method_by_name(&name!(call_once))),\n-                arg_tys,\n-                return_ty,\n-            ))\n+            for fn_x in [FnTrait::Fn, FnTrait::FnMut, FnTrait::FnOnce] {\n+                let fn_x_trait = fn_x.get_id(self.db, krate)?;\n+                trait_ref.trait_id = to_chalk_trait_id(fn_x_trait);\n+                let obligation: chalk_ir::InEnvironment<chalk_ir::Goal<Interner>> = InEnvironment {\n+                    goal: trait_ref.clone().cast(Interner),\n+                    environment: trait_env.clone(),\n+                };\n+                let canonical = self.canonicalize(obligation.clone());\n+                if self.db.trait_solve(krate, canonical.value.cast(Interner)).is_some() {\n+                    return Some((Some(fn_x), arg_tys, return_ty));\n+                }\n+            }\n+            unreachable!(\"It should at least implement FnOnce at this point\");\n         } else {\n             None\n         }"}, {"sha": "782a8ab4aa2ab7a475a77b85d0bfab78b5de0f08", "filename": "crates/hir-ty/src/lib.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Flib.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -576,10 +576,14 @@ where\n }\n \n pub fn callable_sig_from_fnonce(\n-    self_ty: &Ty,\n+    mut self_ty: &Ty,\n     env: Arc<TraitEnvironment>,\n     db: &dyn HirDatabase,\n ) -> Option<CallableSig> {\n+    if let Some((ty, _, _)) = self_ty.as_reference() {\n+        // This will happen when it implements fn or fn mut, since we add a autoborrow adjustment\n+        self_ty = ty;\n+    }\n     let krate = env.krate;\n     let fn_once_trait = FnTrait::FnOnce.get_id(db, krate)?;\n     let output_assoc_type = db.trait_data(fn_once_trait).associated_type_by_name(&name![Output])?;"}, {"sha": "f105c94086c9bb76861d4ecfb01335b2cbcd15f2", "filename": "crates/hir-ty/src/method_resolution.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmethod_resolution.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -20,7 +20,7 @@ use crate::{\n     autoderef::{self, AutoderefKind},\n     db::HirDatabase,\n     from_chalk_trait_id, from_foreign_def_id,\n-    infer::{unify::InferenceTable, Adjust, Adjustment, AutoBorrow, OverloadedDeref, PointerCast},\n+    infer::{unify::InferenceTable, Adjust, Adjustment, OverloadedDeref, PointerCast},\n     primitive::{FloatTy, IntTy, UintTy},\n     static_lifetime, to_chalk_trait_id,\n     utils::all_super_traits,\n@@ -600,9 +600,9 @@ impl ReceiverAdjustments {\n             }\n         }\n         if let Some(m) = self.autoref {\n-            ty = TyKind::Ref(m, static_lifetime(), ty).intern(Interner);\n-            adjust\n-                .push(Adjustment { kind: Adjust::Borrow(AutoBorrow::Ref(m)), target: ty.clone() });\n+            let a = Adjustment::borrow(m, ty);\n+            ty = a.target.clone();\n+            adjust.push(a);\n         }\n         if self.unsize_array {\n             ty = 'x: {"}, {"sha": "88ef92a4ae6c865daf8073785896b8eb80fe0780", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 193, "deletions": 104, "changes": 297, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -11,7 +11,7 @@ use hir_def::{\n     builtin_type::BuiltinType,\n     lang_item::{lang_attr, LangItem},\n     layout::{Layout, LayoutError, RustcEnumVariantIdx, TagEncoding, Variants},\n-    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, Lookup, VariantId,\n+    AdtId, DefWithBodyId, EnumVariantId, FunctionId, HasModule, ItemContainerId, Lookup, VariantId,\n };\n use intern::Interned;\n use la_arena::ArenaMap;\n@@ -24,20 +24,47 @@ use crate::{\n     layout::layout_of_ty,\n     mapping::from_chalk,\n     method_resolution::lookup_impl_method,\n-    CallableDefId, Const, ConstScalar, Interner, MemoryMap, Substitution, TraitEnvironment, Ty,\n-    TyBuilder, TyExt,\n+    traits::FnTrait,\n+    CallableDefId, Const, ConstScalar, FnDefId, Interner, MemoryMap, Substitution,\n+    TraitEnvironment, Ty, TyBuilder, TyExt,\n };\n \n use super::{\n     const_as_usize, return_slot, AggregateKind, BinOp, CastKind, LocalId, MirBody, MirLowerError,\n     Operand, Place, ProjectionElem, Rvalue, StatementKind, Terminator, UnOp,\n };\n \n+#[derive(Debug, Default)]\n+struct VTableMap {\n+    ty_to_id: HashMap<Ty, usize>,\n+    id_to_ty: Vec<Ty>,\n+}\n+\n+impl VTableMap {\n+    fn id(&mut self, ty: Ty) -> usize {\n+        if let Some(x) = self.ty_to_id.get(&ty) {\n+            return *x;\n+        }\n+        let id = self.id_to_ty.len();\n+        self.id_to_ty.push(ty.clone());\n+        self.ty_to_id.insert(ty, id);\n+        id\n+    }\n+\n+    fn ty(&self, id: usize) -> Result<&Ty> {\n+        self.id_to_ty.get(id).ok_or(MirEvalError::InvalidVTableId(id))\n+    }\n+}\n+\n pub struct Evaluator<'a> {\n     db: &'a dyn HirDatabase,\n     trait_env: Arc<TraitEnvironment>,\n     stack: Vec<u8>,\n     heap: Vec<u8>,\n+    /// We don't really have function pointers, i.e. pointers to some assembly instructions that we can run. Instead, we\n+    /// store the type as an interned id in place of function and vtable pointers, and we recover back the type at the\n+    /// time of use.\n+    vtable_map: VTableMap,\n     crate_id: CrateId,\n     // FIXME: This is a workaround, see the comment on `interpret_mir`\n     assert_placeholder_ty_is_unused: bool,\n@@ -147,6 +174,7 @@ pub enum MirEvalError {\n     ExecutionLimitExceeded,\n     StackOverflow,\n     TargetDataLayoutNotAvailable,\n+    InvalidVTableId(usize),\n }\n \n impl std::fmt::Debug for MirEvalError {\n@@ -168,6 +196,7 @@ impl std::fmt::Debug for MirEvalError {\n             Self::MirLowerError(arg0, arg1) => {\n                 f.debug_tuple(\"MirLowerError\").field(arg0).field(arg1).finish()\n             }\n+            Self::InvalidVTableId(arg0) => f.debug_tuple(\"InvalidVTableId\").field(arg0).finish(),\n             Self::NotSupported(arg0) => f.debug_tuple(\"NotSupported\").field(arg0).finish(),\n             Self::InvalidConst(arg0) => {\n                 let data = &arg0.data(Interner);\n@@ -240,6 +269,7 @@ impl Evaluator<'_> {\n         Evaluator {\n             stack: vec![0],\n             heap: vec![0],\n+            vtable_map: VTableMap::default(),\n             db,\n             trait_env,\n             crate_id,\n@@ -461,108 +491,16 @@ impl Evaluator<'_> {\n                 } => {\n                     let fn_ty = self.operand_ty(func, &locals)?;\n                     match &fn_ty.data(Interner).kind {\n+                        TyKind::Function(_) => {\n+                            let bytes = self.eval_operand(func, &locals)?;\n+                            self.exec_fn_pointer(bytes, destination, args, &locals)?;\n+                        }\n                         TyKind::FnDef(def, generic_args) => {\n-                            let def: CallableDefId = from_chalk(self.db, *def);\n-                            let generic_args = self.subst_filler(generic_args, &locals);\n-                            match def {\n-                                CallableDefId::FunctionId(def) => {\n-                                    let arg_bytes = args\n-                                        .iter()\n-                                        .map(|x| {\n-                                            Ok(self\n-                                                .eval_operand(x, &locals)?\n-                                                .get(&self)?\n-                                                .to_owned())\n-                                        })\n-                                        .collect::<Result<Vec<_>>>()?\n-                                        .into_iter();\n-                                    let function_data = self.db.function_data(def);\n-                                    let is_intrinsic = match &function_data.abi {\n-                                        Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n-                                        None => match def.lookup(self.db.upcast()).container {\n-                                            hir_def::ItemContainerId::ExternBlockId(block) => {\n-                                                let id = block.lookup(self.db.upcast()).id;\n-                                                id.item_tree(self.db.upcast())[id.value]\n-                                                    .abi\n-                                                    .as_deref()\n-                                                    == Some(\"rust-intrinsic\")\n-                                            }\n-                                            _ => false,\n-                                        },\n-                                    };\n-                                    let result = if is_intrinsic {\n-                                        self.exec_intrinsic(\n-                                            function_data\n-                                                .name\n-                                                .as_text()\n-                                                .unwrap_or_default()\n-                                                .as_str(),\n-                                            arg_bytes,\n-                                            generic_args,\n-                                            &locals,\n-                                        )?\n-                                    } else if let Some(x) = self.detect_lang_function(def) {\n-                                        self.exec_lang_item(x, arg_bytes)?\n-                                    } else {\n-                                        let (imp, generic_args) = lookup_impl_method(\n-                                            self.db,\n-                                            self.trait_env.clone(),\n-                                            def,\n-                                            generic_args.clone(),\n-                                        );\n-                                        let generic_args =\n-                                            self.subst_filler(&generic_args, &locals);\n-                                        let def = imp.into();\n-                                        let mir_body = self\n-                                            .db\n-                                            .mir_body(def)\n-                                            .map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n-                                        self.interpret_mir(&mir_body, arg_bytes, generic_args)\n-                                            .map_err(|e| {\n-                                                MirEvalError::InFunction(imp, Box::new(e))\n-                                            })?\n-                                    };\n-                                    let dest_addr = self.place_addr(destination, &locals)?;\n-                                    self.write_memory(dest_addr, &result)?;\n-                                }\n-                                CallableDefId::StructId(id) => {\n-                                    let (size, variant_layout, tag) = self.layout_of_variant(\n-                                        id.into(),\n-                                        generic_args.clone(),\n-                                        &locals,\n-                                    )?;\n-                                    let result = self.make_by_layout(\n-                                        size,\n-                                        &variant_layout,\n-                                        tag,\n-                                        args,\n-                                        &locals,\n-                                    )?;\n-                                    let dest_addr = self.place_addr(destination, &locals)?;\n-                                    self.write_memory(dest_addr, &result)?;\n-                                }\n-                                CallableDefId::EnumVariantId(id) => {\n-                                    let (size, variant_layout, tag) = self.layout_of_variant(\n-                                        id.into(),\n-                                        generic_args.clone(),\n-                                        &locals,\n-                                    )?;\n-                                    let result = self.make_by_layout(\n-                                        size,\n-                                        &variant_layout,\n-                                        tag,\n-                                        args,\n-                                        &locals,\n-                                    )?;\n-                                    let dest_addr = self.place_addr(destination, &locals)?;\n-                                    self.write_memory(dest_addr, &result)?;\n-                                }\n-                            }\n-                            current_block_idx =\n-                                target.expect(\"broken mir, function without target\");\n+                            self.exec_fn_def(*def, generic_args, destination, args, &locals)?;\n                         }\n-                        _ => not_supported!(\"unknown function type\"),\n+                        x => not_supported!(\"unknown function type {x:?}\"),\n                     }\n+                    current_block_idx = target.expect(\"broken mir, function without target\");\n                 }\n                 Terminator::SwitchInt { discr, targets } => {\n                     let val = u128::from_le_bytes(pad16(\n@@ -808,6 +746,16 @@ impl Evaluator<'_> {\n                     not_supported!(\"creating pointer from exposed address\")\n                 }\n                 CastKind::Pointer(cast) => match cast {\n+                    PointerCast::ReifyFnPointer => {\n+                        let current_ty = self.operand_ty(operand, locals)?;\n+                        if let TyKind::FnDef(_, _) = &current_ty.data(Interner).kind {\n+                            let id = self.vtable_map.id(current_ty);\n+                            let ptr_size = self.ptr_size();\n+                            Owned(id.to_le_bytes()[0..ptr_size].to_vec())\n+                        } else {\n+                            not_supported!(\"ReifyFnPointer cast of a non FnDef type\");\n+                        }\n+                    }\n                     PointerCast::Unsize => {\n                         let current_ty = self.operand_ty(operand, locals)?;\n                         match &target_ty.data(Interner).kind {\n@@ -920,7 +868,7 @@ impl Evaluator<'_> {\n         size: usize, // Not neccessarily equal to variant_layout.size\n         variant_layout: &Layout,\n         tag: Option<(usize, usize, i128)>,\n-        values: &Vec<Operand>,\n+        values: &[Operand],\n         locals: &Locals<'_>,\n     ) -> Result<Vec<u8>> {\n         let mut result = vec![0; size];\n@@ -1140,6 +1088,20 @@ impl Evaluator<'_> {\n         None\n     }\n \n+    fn detect_fn_trait(&self, def: FunctionId) -> Option<FnTrait> {\n+        use LangItem::*;\n+        let ItemContainerId::TraitId(parent) = self.db.lookup_intern_function(def).container else {\n+            return None;\n+        };\n+        let l = lang_attr(self.db.upcast(), parent)?;\n+        match l {\n+            FnOnce => Some(FnTrait::FnOnce),\n+            FnMut => Some(FnTrait::FnMut),\n+            Fn => Some(FnTrait::Fn),\n+            _ => None,\n+        }\n+    }\n+\n     fn create_memory_map(&self, bytes: &[u8], ty: &Ty, locals: &Locals<'_>) -> Result<MemoryMap> {\n         // FIXME: support indirect references\n         let mut mm = MemoryMap::default();\n@@ -1228,7 +1190,134 @@ impl Evaluator<'_> {\n         }\n     }\n \n-    pub(crate) fn exec_lang_item(\n+    fn exec_fn_pointer(\n+        &mut self,\n+        bytes: Interval,\n+        destination: &Place,\n+        args: &[Operand],\n+        locals: &Locals<'_>,\n+    ) -> Result<()> {\n+        let id = from_bytes!(usize, bytes.get(self)?);\n+        let next_ty = self.vtable_map.ty(id)?.clone();\n+        if let TyKind::FnDef(def, generic_args) = &next_ty.data(Interner).kind {\n+            self.exec_fn_def(*def, generic_args, destination, args, &locals)?;\n+        } else {\n+            return Err(MirEvalError::TypeError(\"function pointer to non function\"));\n+        }\n+        Ok(())\n+    }\n+\n+    fn exec_fn_def(\n+        &mut self,\n+        def: FnDefId,\n+        generic_args: &Substitution,\n+        destination: &Place,\n+        args: &[Operand],\n+        locals: &Locals<'_>,\n+    ) -> Result<()> {\n+        let def: CallableDefId = from_chalk(self.db, def);\n+        let generic_args = self.subst_filler(generic_args, &locals);\n+        match def {\n+            CallableDefId::FunctionId(def) => {\n+                let dest_addr = self.place_addr(destination, &locals)?;\n+                if let Some(x) = self.detect_fn_trait(def) {\n+                    self.exec_fn_trait(x, &args, destination, locals)?;\n+                    return Ok(());\n+                }\n+                let arg_bytes = args\n+                    .iter()\n+                    .map(|x| Ok(self.eval_operand(x, &locals)?.get(&self)?.to_owned()))\n+                    .collect::<Result<Vec<_>>>()?\n+                    .into_iter();\n+                let function_data = self.db.function_data(def);\n+                let is_intrinsic = match &function_data.abi {\n+                    Some(abi) => *abi == Interned::new_str(\"rust-intrinsic\"),\n+                    None => match def.lookup(self.db.upcast()).container {\n+                        hir_def::ItemContainerId::ExternBlockId(block) => {\n+                            let id = block.lookup(self.db.upcast()).id;\n+                            id.item_tree(self.db.upcast())[id.value].abi.as_deref()\n+                                == Some(\"rust-intrinsic\")\n+                        }\n+                        _ => false,\n+                    },\n+                };\n+                let result = if is_intrinsic {\n+                    self.exec_intrinsic(\n+                        function_data.name.as_text().unwrap_or_default().as_str(),\n+                        arg_bytes,\n+                        generic_args,\n+                        &locals,\n+                    )?\n+                } else if let Some(x) = self.detect_lang_function(def) {\n+                    self.exec_lang_item(x, arg_bytes)?\n+                } else {\n+                    let (imp, generic_args) = lookup_impl_method(\n+                        self.db,\n+                        self.trait_env.clone(),\n+                        def,\n+                        generic_args.clone(),\n+                    );\n+                    let generic_args = self.subst_filler(&generic_args, &locals);\n+                    let def = imp.into();\n+                    let mir_body =\n+                        self.db.mir_body(def).map_err(|e| MirEvalError::MirLowerError(imp, e))?;\n+                    self.interpret_mir(&mir_body, arg_bytes, generic_args)\n+                        .map_err(|e| MirEvalError::InFunction(imp, Box::new(e)))?\n+                };\n+                self.write_memory(dest_addr, &result)?;\n+            }\n+            CallableDefId::StructId(id) => {\n+                let (size, variant_layout, tag) =\n+                    self.layout_of_variant(id.into(), generic_args.clone(), &locals)?;\n+                let result = self.make_by_layout(size, &variant_layout, tag, args, &locals)?;\n+                let dest_addr = self.place_addr(destination, &locals)?;\n+                self.write_memory(dest_addr, &result)?;\n+            }\n+            CallableDefId::EnumVariantId(id) => {\n+                let (size, variant_layout, tag) =\n+                    self.layout_of_variant(id.into(), generic_args.clone(), &locals)?;\n+                let result = self.make_by_layout(size, &variant_layout, tag, args, &locals)?;\n+                let dest_addr = self.place_addr(destination, &locals)?;\n+                self.write_memory(dest_addr, &result)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    fn exec_fn_trait(\n+        &mut self,\n+        ft: FnTrait,\n+        args: &[Operand],\n+        destination: &Place,\n+        locals: &Locals<'_>,\n+    ) -> Result<()> {\n+        let func = args.get(0).ok_or(MirEvalError::TypeError(\"fn trait with no arg\"))?;\n+        let ref_func_ty = self.operand_ty(func, locals)?;\n+        let func_ty = match ft {\n+            FnTrait::FnOnce => ref_func_ty,\n+            FnTrait::FnMut | FnTrait::Fn => match ref_func_ty.as_reference() {\n+                Some(x) => x.0.clone(),\n+                None => return Err(MirEvalError::TypeError(\"fn trait with non-reference arg\")),\n+            },\n+        };\n+        match &func_ty.data(Interner).kind {\n+            TyKind::FnDef(def, subst) => {\n+                self.exec_fn_def(*def, subst, destination, &args[1..], locals)?;\n+            }\n+            TyKind::Function(_) => {\n+                let mut func_data = self.eval_operand(func, locals)?;\n+                if let FnTrait::FnMut | FnTrait::Fn = ft {\n+                    let addr = Address::from_bytes(func_data.get(self)?)?;\n+                    func_data = Interval { addr, size: self.ptr_size() };\n+                }\n+                self.exec_fn_pointer(func_data, destination, &args[1..], locals)?;\n+            }\n+            x => not_supported!(\"Call {ft:?} trait methods with type {x:?}\"),\n+        }\n+        Ok(())\n+    }\n+\n+    fn exec_lang_item(\n         &self,\n         x: LangItem,\n         mut args: std::vec::IntoIter<Vec<u8>>,"}, {"sha": "7a5ca0894200c2c763772b36f82641e6d22245f8", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -298,7 +298,7 @@ impl MirLowerCtx<'_> {\n                         );\n                         Ok(Some(current))\n                     }\n-                    ValueNs::StructId(_) => {\n+                    ValueNs::FunctionId(_) | ValueNs::StructId(_) => {\n                         // It's probably a unit struct or a zero sized function, so no action is needed.\n                         Ok(Some(current))\n                     }\n@@ -445,36 +445,36 @@ impl MirLowerCtx<'_> {\n                 })\n             },\n             Expr::Call { callee, args, .. } => {\n+                if let Some((func_id, generic_args)) =\n+                    self.infer.method_resolution(expr_id) {\n+                    let ty = chalk_ir::TyKind::FnDef(\n+                        CallableDefId::FunctionId(func_id).to_chalk(self.db),\n+                        generic_args,\n+                    )\n+                    .intern(Interner);\n+                    let func = Operand::from_bytes(vec![], ty);\n+                    return self.lower_call_and_args(\n+                        func,\n+                        iter::once(*callee).chain(args.iter().copied()),\n+                        place,\n+                        current,\n+                        self.is_uninhabited(expr_id),\n+                    );\n+                }\n                 let callee_ty = self.expr_ty_after_adjustments(*callee);\n                 match &callee_ty.data(Interner).kind {\n                     chalk_ir::TyKind::FnDef(..) => {\n                         let func = Operand::from_bytes(vec![], callee_ty.clone());\n                         self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n                     }\n-                    TyKind::Scalar(_)\n-                    | TyKind::Tuple(_, _)\n-                    | TyKind::Array(_, _)\n-                    | TyKind::Adt(_, _)\n-                    | TyKind::Str\n-                    | TyKind::Foreign(_)\n-                    | TyKind::Slice(_) => {\n-                        return Err(MirLowerError::TypeError(\"function call on data type\"))\n+                    chalk_ir::TyKind::Function(_) => {\n+                        let Some((func, current)) = self.lower_expr_to_some_operand(*callee, current)? else {\n+                            return Ok(None);\n+                        };\n+                        self.lower_call_and_args(func, args.iter().copied(), place, current, self.is_uninhabited(expr_id))\n                     }\n                     TyKind::Error => return Err(MirLowerError::MissingFunctionDefinition),\n-                    TyKind::AssociatedType(_, _)\n-                    | TyKind::Raw(_, _)\n-                    | TyKind::Ref(_, _, _)\n-                    | TyKind::OpaqueType(_, _)\n-                    | TyKind::Never\n-                    | TyKind::Closure(_, _)\n-                    | TyKind::Generator(_, _)\n-                    | TyKind::GeneratorWitness(_, _)\n-                    | TyKind::Placeholder(_)\n-                    | TyKind::Dyn(_)\n-                    | TyKind::Alias(_)\n-                    | TyKind::Function(_)\n-                    | TyKind::BoundVar(_)\n-                    | TyKind::InferenceVar(_, _) => not_supported!(\"dynamic function call\"),\n+                    _ => return Err(MirLowerError::TypeError(\"function call on bad type\")),\n                 }\n             }\n             Expr::MethodCall { receiver, args, .. } => {"}, {"sha": "eb0002266dc56d92e9ed80e82714ac440f4da6d8", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -301,9 +301,9 @@ impl<'a> MirPrettyCtx<'a> {\n                 w!(self, \")\");\n             }\n             Rvalue::Cast(ck, op, ty) => {\n-                w!(self, \"Discriminant({ck:?}\");\n+                w!(self, \"Cast({ck:?}, \");\n                 self.operand(op);\n-                w!(self, \"{})\", ty.display(self.db));\n+                w!(self, \", {})\", ty.display(self.db));\n             }\n             Rvalue::CheckedBinaryOp(b, o1, o2) => {\n                 self.operand(o1);"}, {"sha": "696bdef03fcbaed527c699684bfd6ad9c5bcafe7", "filename": "crates/hir-ty/src/tests/coercion.rs", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftests%2Fcoercion.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -396,10 +396,40 @@ fn test() {\n     );\n }\n \n+#[test]\n+fn coerce_fn_item_to_fn_ptr_in_array() {\n+    check_no_mismatches(\n+        r\"\n+fn foo(x: u32) -> isize { 1 }\n+fn bar(x: u32) -> isize { 1 }\n+fn test() {\n+    let f = [foo, bar];\n+          // ^^^ adjustments: Pointer(ReifyFnPointer)\n+}\",\n+    );\n+}\n+\n #[test]\n fn coerce_fn_items_in_match_arms() {\n     cov_mark::check!(coerce_fn_reification);\n \n+    check_no_mismatches(\n+        r\"\n+fn foo1(x: u32) -> isize { 1 }\n+fn foo2(x: u32) -> isize { 2 }\n+fn foo3(x: u32) -> isize { 3 }\n+fn test() {\n+    let x = match 1 {\n+        1 => foo1,\n+          // ^^^^ adjustments: Pointer(ReifyFnPointer)\n+        2 => foo2,\n+          // ^^^^ adjustments: Pointer(ReifyFnPointer)\n+        _ => foo3,\n+          // ^^^^ adjustments: Pointer(ReifyFnPointer)\n+    };\n+    x;\n+}\",\n+    );\n     check_types(\n         r\"\n fn foo1(x: u32) -> isize { 1 }"}, {"sha": "aebf59f31525a8c21e8a3aa4f557147f6d0f4a57", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -11,6 +11,7 @@ use hir_def::{\n     lang_item::{LangItem, LangItemTarget},\n     TraitId,\n };\n+use hir_expand::name::{name, Name};\n use stdx::panic_context;\n \n use crate::{\n@@ -187,6 +188,14 @@ impl FnTrait {\n         }\n     }\n \n+    pub fn method_name(&self) -> Name {\n+        match self {\n+            FnTrait::FnOnce => name!(call_once),\n+            FnTrait::FnMut => name!(call_mut),\n+            FnTrait::Fn => name!(call),\n+        }\n+    }\n+\n     pub fn get_id(&self, db: &dyn HirDatabase, krate: CrateId) -> Option<TraitId> {\n         let target = db.lang_item(krate, self.lang_item())?;\n         match target {"}, {"sha": "03951ea2bf51ba47442ffd0ab17bd3067e0a46a3", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a063f000ff99989406abd1e6f58a9c2b576ba41a/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=a063f000ff99989406abd1e6f58a9c2b576ba41a", "patch": "@@ -631,6 +631,31 @@ fn f(inp: (Foo, Foo, Foo, Foo)) {\n         );\n     }\n \n+    #[test]\n+    fn fn_traits() {\n+        check_diagnostics(\n+            r#\"\n+//- minicore: fn\n+fn fn_ref(mut x: impl Fn(u8) -> u8) -> u8 {\n+        //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    x(2)\n+}\n+fn fn_mut(x: impl FnMut(u8) -> u8) -> u8 {\n+    x(2)\n+  //^ \ud83d\udca1 error: cannot mutate immutable variable `x`\n+}\n+fn fn_borrow_mut(mut x: &mut impl FnMut(u8) -> u8) -> u8 {\n+               //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    x(2)\n+}\n+fn fn_once(mut x: impl FnOnce(u8) -> u8) -> u8 {\n+         //^^^^^ \ud83d\udca1 weak: variable does not need to be mutable\n+    x(2)\n+}\n+\"#,\n+        );\n+    }\n+\n     #[test]\n     fn respect_allow_unused_mut() {\n         // FIXME: respect"}]}