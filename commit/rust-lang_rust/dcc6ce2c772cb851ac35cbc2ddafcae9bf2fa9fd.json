{"sha": "dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjYzZjZTJjNzcyY2I4NTFhYzM1Y2JjMmRkYWZjYWU5YmYyZmE5ZmQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-22T10:27:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-22T10:27:08Z"}, "message": "Auto merge of #22574 - huonw:remove-lame-statics, r=alexcirchton\n\nAdd a basic test that checks that the types catch the most glaring\r\nerrors that could occur.\r\n\r\ncc #22444", "tree": {"sha": "5c395b9b0e9b905648ed6de581ec601f4cc2ba9f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5c395b9b0e9b905648ed6de581ec601f4cc2ba9f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "html_url": "https://github.com/rust-lang/rust/commit/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb1b500a9a69b149295c37c2fe2c9409f406f9ea", "html_url": "https://github.com/rust-lang/rust/commit/eb1b500a9a69b149295c37c2fe2c9409f406f9ea"}, {"sha": "380d23b5d4b9fb8f5f0ebf178590f61528b2483e", "url": "https://api.github.com/repos/rust-lang/rust/commits/380d23b5d4b9fb8f5f0ebf178590f61528b2483e", "html_url": "https://github.com/rust-lang/rust/commit/380d23b5d4b9fb8f5f0ebf178590f61528b2483e"}], "stats": {"total": 192, "additions": 147, "deletions": 45}, "files": [{"sha": "b437549a044920a7b923fba757d4c2634576ba1e", "filename": "src/libstd/sync/mpsc/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmod.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -345,7 +345,7 @@ pub struct Receiver<T> {\n \n // The receiver port can be sent from place to place, so long as it\n // is not used to receive non-sendable things.\n-unsafe impl<T: Send + 'static> Send for Receiver<T> { }\n+unsafe impl<T: Send> Send for Receiver<T> { }\n \n /// An iterator over messages on a receiver, this iterator will block\n /// whenever `next` is called, waiting for a new message, and `None` will be\n@@ -364,7 +364,7 @@ pub struct Sender<T> {\n \n // The send port can be sent from place to place, so long as it\n // is not used to send non-sendable things.\n-unsafe impl<T: Send + 'static> Send for Sender<T> { }\n+unsafe impl<T: Send> Send for Sender<T> { }\n \n /// The sending-half of Rust's synchronous channel type. This half can only be\n /// owned by one task, but it can be cloned to send to other tasks.\n@@ -373,7 +373,7 @@ pub struct SyncSender<T> {\n     inner: Arc<UnsafeCell<sync::Packet<T>>>,\n }\n \n-unsafe impl<T: Send + 'static> Send for SyncSender<T> {}\n+unsafe impl<T: Send> Send for SyncSender<T> {}\n \n impl<T> !Sync for SyncSender<T> {}\n \n@@ -485,7 +485,7 @@ impl<T> UnsafeFlavor<T> for Receiver<T> {\n /// println!(\"{:?}\", rx.recv().unwrap());\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn channel<T: Send + 'static>() -> (Sender<T>, Receiver<T>) {\n+pub fn channel<T: Send>() -> (Sender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(oneshot::Packet::new()));\n     (Sender::new(Flavor::Oneshot(a.clone())), Receiver::new(Flavor::Oneshot(a)))\n }\n@@ -525,7 +525,7 @@ pub fn channel<T: Send + 'static>() -> (Sender<T>, Receiver<T>) {\n /// assert_eq!(rx.recv().unwrap(), 2);\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub fn sync_channel<T: Send + 'static>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n+pub fn sync_channel<T: Send>(bound: uint) -> (SyncSender<T>, Receiver<T>) {\n     let a = Arc::new(UnsafeCell::new(sync::Packet::new(bound)));\n     (SyncSender::new(a.clone()), Receiver::new(Flavor::Sync(a)))\n }\n@@ -534,7 +534,7 @@ pub fn sync_channel<T: Send + 'static>(bound: uint) -> (SyncSender<T>, Receiver<\n // Sender\n ////////////////////////////////////////////////////////////////////////////////\n \n-impl<T: Send + 'static> Sender<T> {\n+impl<T: Send> Sender<T> {\n     fn new(inner: Flavor<T>) -> Sender<T> {\n         Sender {\n             inner: UnsafeCell::new(inner),\n@@ -616,7 +616,7 @@ impl<T: Send + 'static> Sender<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + 'static> Clone for Sender<T> {\n+impl<T: Send> Clone for Sender<T> {\n     fn clone(&self) -> Sender<T> {\n         let (packet, sleeper, guard) = match *unsafe { self.inner() } {\n             Flavor::Oneshot(ref p) => {\n@@ -662,7 +662,7 @@ impl<T: Send + 'static> Clone for Sender<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + 'static> Drop for Sender<T> {\n+impl<T: Send> Drop for Sender<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n             Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_chan(); },\n@@ -677,7 +677,7 @@ impl<T: Send + 'static> Drop for Sender<T> {\n // SyncSender\n ////////////////////////////////////////////////////////////////////////////////\n \n-impl<T: Send + 'static> SyncSender<T> {\n+impl<T: Send> SyncSender<T> {\n     fn new(inner: Arc<UnsafeCell<sync::Packet<T>>>) -> SyncSender<T> {\n         SyncSender { inner: inner }\n     }\n@@ -717,7 +717,7 @@ impl<T: Send + 'static> SyncSender<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + 'static> Clone for SyncSender<T> {\n+impl<T: Send> Clone for SyncSender<T> {\n     fn clone(&self) -> SyncSender<T> {\n         unsafe { (*self.inner.get()).clone_chan(); }\n         return SyncSender::new(self.inner.clone());\n@@ -726,7 +726,7 @@ impl<T: Send + 'static> Clone for SyncSender<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + 'static> Drop for SyncSender<T> {\n+impl<T: Send> Drop for SyncSender<T> {\n     fn drop(&mut self) {\n         unsafe { (*self.inner.get()).drop_chan(); }\n     }\n@@ -736,7 +736,7 @@ impl<T: Send + 'static> Drop for SyncSender<T> {\n // Receiver\n ////////////////////////////////////////////////////////////////////////////////\n \n-impl<T: Send + 'static> Receiver<T> {\n+impl<T: Send> Receiver<T> {\n     fn new(inner: Flavor<T>) -> Receiver<T> {\n         Receiver { inner: UnsafeCell::new(inner) }\n     }\n@@ -855,7 +855,7 @@ impl<T: Send + 'static> Receiver<T> {\n     }\n }\n \n-impl<T: Send + 'static> select::Packet for Receiver<T> {\n+impl<T: Send> select::Packet for Receiver<T> {\n     fn can_recv(&self) -> bool {\n         loop {\n             let new_port = match *unsafe { self.inner() } {\n@@ -942,15 +942,15 @@ impl<T: Send + 'static> select::Packet for Receiver<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T: Send + 'static> Iterator for Iter<'a, T> {\n+impl<'a, T: Send> Iterator for Iter<'a, T> {\n     type Item = T;\n \n     fn next(&mut self) -> Option<T> { self.rx.recv().ok() }\n }\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + 'static> Drop for Receiver<T> {\n+impl<T: Send> Drop for Receiver<T> {\n     fn drop(&mut self) {\n         match *unsafe { self.inner_mut() } {\n             Flavor::Oneshot(ref mut p) => unsafe { (*p.get()).drop_port(); },"}, {"sha": "6eb7c8c5961e326dae5c75841ee560df688909be", "filename": "src/libstd/sync/mpsc/mpsc_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fmpsc_queue.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -78,7 +78,7 @@ pub struct Queue<T> {\n }\n \n unsafe impl<T:Send> Send for Queue<T> { }\n-unsafe impl<T: Send + 'static> Sync for Queue<T> { }\n+unsafe impl<T: Send> Sync for Queue<T> { }\n \n impl<T> Node<T> {\n     unsafe fn new(v: Option<T>) -> *mut Node<T> {\n@@ -89,7 +89,7 @@ impl<T> Node<T> {\n     }\n }\n \n-impl<T: Send + 'static> Queue<T> {\n+impl<T: Send> Queue<T> {\n     /// Creates a new queue that is safe to share among multiple producers and\n     /// one consumer.\n     pub fn new() -> Queue<T> {\n@@ -140,7 +140,7 @@ impl<T: Send + 'static> Queue<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + 'static> Drop for Queue<T> {\n+impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let mut cur = *self.tail.get();"}, {"sha": "eb45681fa626d6e3018447c676efe23b688ce478", "filename": "src/libstd/sync/mpsc/oneshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Foneshot.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -88,7 +88,7 @@ enum MyUpgrade<T> {\n     GoUp(Receiver<T>),\n }\n \n-impl<T: Send + 'static> Packet<T> {\n+impl<T: Send> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n             data: None,\n@@ -368,7 +368,7 @@ impl<T: Send + 'static> Packet<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send + 'static> Drop for Packet<T> {\n+impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.state.load(Ordering::SeqCst), DISCONNECTED);\n     }"}, {"sha": "db8efe19dc1df973e3f37968c5ca138c47c46d9f", "filename": "src/libstd/sync/mpsc/select.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fselect.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -134,7 +134,7 @@ impl Select {\n     /// Creates a new handle into this receiver set for a new receiver. Note\n     /// that this does *not* add the receiver to the receiver set, for that you\n     /// must call the `add` method on the handle itself.\n-    pub fn handle<'a, T: Send + 'static>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> {\n+    pub fn handle<'a, T: Send>(&'a self, rx: &'a Receiver<T>) -> Handle<'a, T> {\n         let id = self.next_id.get();\n         self.next_id.set(id + 1);\n         Handle {\n@@ -251,7 +251,7 @@ impl Select {\n     fn iter(&self) -> Packets { Packets { cur: self.head } }\n }\n \n-impl<'rx, T: Send + 'static> Handle<'rx, T> {\n+impl<'rx, T: Send> Handle<'rx, T> {\n     /// Retrieve the id of this handle.\n     #[inline]\n     pub fn id(&self) -> uint { self.id }\n@@ -322,7 +322,7 @@ impl Drop for Select {\n }\n \n #[unsafe_destructor]\n-impl<'rx, T: Send + 'static> Drop for Handle<'rx, T> {\n+impl<'rx, T: Send> Drop for Handle<'rx, T> {\n     fn drop(&mut self) {\n         unsafe { self.remove() }\n     }"}, {"sha": "729e7991f97cfb2cb03c97c2854c253ee8dd0f7d", "filename": "src/libstd/sync/mpsc/shared.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fshared.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -64,7 +64,7 @@ pub enum Failure {\n     Disconnected,\n }\n \n-impl<T: Send + 'static> Packet<T> {\n+impl<T: Send> Packet<T> {\n     // Creation of a packet *must* be followed by a call to postinit_lock\n     // and later by inherit_blocker\n     pub fn new() -> Packet<T> {\n@@ -474,7 +474,7 @@ impl<T: Send + 'static> Packet<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send + 'static> Drop for Packet<T> {\n+impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         // Note that this load is not only an assert for correctness about\n         // disconnection, but also a proper fence before the read of"}, {"sha": "f111e13975ff700a4712b33dcd43fbd5b349134b", "filename": "src/libstd/sync/mpsc/spsc_queue.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fspsc_queue.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -74,11 +74,11 @@ pub struct Queue<T> {\n     cache_subtractions: AtomicUsize,\n }\n \n-unsafe impl<T: Send + 'static> Send for Queue<T> { }\n+unsafe impl<T: Send> Send for Queue<T> { }\n \n-unsafe impl<T: Send + 'static> Sync for Queue<T> { }\n+unsafe impl<T: Send> Sync for Queue<T> { }\n \n-impl<T: Send + 'static> Node<T> {\n+impl<T: Send> Node<T> {\n     fn new() -> *mut Node<T> {\n         unsafe {\n             mem::transmute(box Node {\n@@ -89,7 +89,7 @@ impl<T: Send + 'static> Node<T> {\n     }\n }\n \n-impl<T: Send + 'static> Queue<T> {\n+impl<T: Send> Queue<T> {\n     /// Creates a new queue.\n     ///\n     /// This is unsafe as the type system doesn't enforce a single\n@@ -227,7 +227,7 @@ impl<T: Send + 'static> Queue<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send + 'static> Drop for Queue<T> {\n+impl<T: Send> Drop for Queue<T> {\n     fn drop(&mut self) {\n         unsafe {\n             let mut cur = *self.first.get();"}, {"sha": "2d528662f64fc9dd3fa2f725cb7934bcaf3303c2", "filename": "src/libstd/sync/mpsc/stream.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fstream.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -74,7 +74,7 @@ enum Message<T> {\n     GoUp(Receiver<T>),\n }\n \n-impl<T: Send + 'static> Packet<T> {\n+impl<T: Send> Packet<T> {\n     pub fn new() -> Packet<T> {\n         Packet {\n             queue: unsafe { spsc::Queue::new(128) },\n@@ -472,7 +472,7 @@ impl<T: Send + 'static> Packet<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send + 'static> Drop for Packet<T> {\n+impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         // Note that this load is not only an assert for correctness about\n         // disconnection, but also a proper fence before the read of"}, {"sha": "36b50b0d4af01fcad7a80b771e56e00a5b70fa79", "filename": "src/libstd/sync/mpsc/sync.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmpsc%2Fsync.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -55,9 +55,9 @@ pub struct Packet<T> {\n     lock: Mutex<State<T>>,\n }\n \n-unsafe impl<T: Send + 'static> Send for Packet<T> { }\n+unsafe impl<T: Send> Send for Packet<T> { }\n \n-unsafe impl<T: Send + 'static> Sync for Packet<T> { }\n+unsafe impl<T: Send> Sync for Packet<T> { }\n \n struct State<T> {\n     disconnected: bool, // Is the channel disconnected yet?\n@@ -75,7 +75,7 @@ struct State<T> {\n     canceled: Option<&'static mut bool>,\n }\n \n-unsafe impl<T: Send + 'static> Send for State<T> {}\n+unsafe impl<T: Send> Send for State<T> {}\n \n /// Possible flavors of threads who can be blocked on this channel.\n enum Blocker {\n@@ -113,7 +113,7 @@ pub enum Failure {\n \n /// Atomically blocks the current thread, placing it into `slot`, unlocking `lock`\n /// in the meantime. This re-locks the mutex upon returning.\n-fn wait<'a, 'b, T: Send + 'static>(lock: &'a Mutex<State<T>>,\n+fn wait<'a, 'b, T: Send>(lock: &'a Mutex<State<T>>,\n                          mut guard: MutexGuard<'b, State<T>>,\n                          f: fn(SignalToken) -> Blocker)\n                          -> MutexGuard<'a, State<T>>\n@@ -136,7 +136,7 @@ fn wakeup<T>(token: SignalToken, guard: MutexGuard<State<T>>) {\n     token.signal();\n }\n \n-impl<T: Send + 'static> Packet<T> {\n+impl<T: Send> Packet<T> {\n     pub fn new(cap: uint) -> Packet<T> {\n         Packet {\n             channels: AtomicUsize::new(1),\n@@ -412,7 +412,7 @@ impl<T: Send + 'static> Packet<T> {\n }\n \n #[unsafe_destructor]\n-impl<T: Send + 'static> Drop for Packet<T> {\n+impl<T: Send> Drop for Packet<T> {\n     fn drop(&mut self) {\n         assert_eq!(self.channels.load(Ordering::SeqCst), 0);\n         let mut guard = self.lock.lock().unwrap();"}, {"sha": "b71cc0c26536474db76f2501e061da337ff8b23c", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -120,9 +120,9 @@ pub struct Mutex<T> {\n     data: UnsafeCell<T>,\n }\n \n-unsafe impl<T: Send + 'static> Send for Mutex<T> { }\n+unsafe impl<T: Send> Send for Mutex<T> { }\n \n-unsafe impl<T: Send + 'static> Sync for Mutex<T> { }\n+unsafe impl<T: Send> Sync for Mutex<T> { }\n \n /// The static mutex type is provided to allow for static allocation of mutexes.\n ///\n@@ -180,7 +180,7 @@ pub const MUTEX_INIT: StaticMutex = StaticMutex {\n     poison: poison::FLAG_INIT,\n };\n \n-impl<T: Send + 'static> Mutex<T> {\n+impl<T: Send> Mutex<T> {\n     /// Creates a new mutex in an unlocked state ready for use.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(t: T) -> Mutex<T> {\n@@ -243,7 +243,7 @@ impl<T: Send + 'static> Mutex<T> {\n \n #[unsafe_destructor]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Send + 'static> Drop for Mutex<T> {\n+impl<T: Send> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n         // this mutex (it's up to the user to arrange for a mutex to get\n@@ -354,7 +354,7 @@ mod test {\n \n     struct Packet<T>(Arc<(Mutex<T>, Condvar)>);\n \n-    unsafe impl<T:'static+Send> Send for Packet<T> {}\n+    unsafe impl<T: Send> Send for Packet<T> {}\n     unsafe impl<T> Sync for Packet<T> {}\n \n     #[test]"}, {"sha": "6fd2a6ed77d264c754e19e5ae46873ce274cb117", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -64,8 +64,8 @@ pub struct RwLock<T> {\n     data: UnsafeCell<T>,\n }\n \n-unsafe impl<T:'static+Send> Send for RwLock<T> {}\n-unsafe impl<T> Sync for RwLock<T> {}\n+unsafe impl<T: Send + Sync> Send for RwLock<T> {}\n+unsafe impl<T: Send + Sync> Sync for RwLock<T> {}\n \n /// Structure representing a statically allocated RwLock.\n ///"}, {"sha": "d9d3706586ba9e3c17615b0bc141140b8ed54043", "filename": "src/test/compile-fail/send-is-not-static-std-sync-2.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-std-sync-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-std-sync-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-std-sync-2.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -0,0 +1,46 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// basic tests to see that certain \"obvious\" errors are caught by\n+// these types no longer requiring `'static` (RFC 458)\n+\n+#![allow(dead_code)]\n+\n+use std::sync::{Mutex, RwLock, mpsc};\n+\n+fn mutex() {\n+    let lock = {\n+        let x = 1;\n+        Mutex::new(&x) //~ ERROR does not live long enough\n+    };\n+\n+    let _dangling = *lock.lock().unwrap();\n+}\n+\n+fn rwlock() {\n+    let lock = {\n+        let x = 1;\n+        RwLock::new(&x) //~ ERROR does not live long enough\n+    };\n+    let _dangling = *lock.read().unwrap();\n+}\n+\n+fn channel() {\n+    let (_tx, rx) = {\n+        let x = 1;\n+        let (tx, rx) = mpsc::channel();\n+        let _ = tx.send(&x); //~ ERROR does not live long enough\n+        (tx, rx)\n+    };\n+\n+    let _dangling = rx.recv();\n+}\n+\n+fn main() {}"}, {"sha": "8ec2fe8a1ec897492a55a85a76e08a80609428e6", "filename": "src/test/compile-fail/send-is-not-static-std-sync.rs", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-std-sync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-std-sync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fsend-is-not-static-std-sync.rs?ref=dcc6ce2c772cb851ac35cbc2ddafcae9bf2fa9fd", "patch": "@@ -0,0 +1,56 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// basic tests to see that certain \"obvious\" errors are caught by\n+// these types no longer requiring `'static` (RFC 458)\n+\n+#![allow(dead_code)]\n+\n+use std::sync::{Mutex, RwLock, mpsc};\n+\n+fn mutex() {\n+    let x = 1;\n+    let y = Box::new(1);\n+    let lock = Mutex::new(&x);\n+    *lock.lock().unwrap() = &*y;\n+    drop(y); //~ ERROR cannot move out\n+    {\n+        let z = 2;\n+        *lock.lock().unwrap() = &z; //~ ERROR does not live long enough\n+    }\n+}\n+\n+fn rwlock() {\n+    let x = 1;\n+    let y = Box::new(1);\n+    let lock = RwLock::new(&x);\n+    *lock.write().unwrap() = &*y;\n+    drop(y); //~ ERROR cannot move out\n+    {\n+        let z = 2;\n+        *lock.write().unwrap() = &z; //~ ERROR does not live long enough\n+    }\n+}\n+\n+fn channel() {\n+    let x = 1;\n+    let y = Box::new(1);\n+    let (tx, rx) = mpsc::channel();\n+\n+    tx.send(&x).unwrap();\n+    tx.send(&*y);\n+    drop(y); //~ ERROR cannot move out\n+    {\n+        let z = 2;\n+        tx.send(&z).unwrap(); //~ ERROR does not live long enough\n+    }\n+}\n+\n+fn main() {}"}]}