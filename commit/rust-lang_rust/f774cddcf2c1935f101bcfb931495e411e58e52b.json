{"sha": "f774cddcf2c1935f101bcfb931495e411e58e52b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY3NzRjZGRjZjJjMTkzNWYxMDFiY2ZiOTMxNDk1ZTQxMWU1OGU1MmI=", "commit": {"author": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-08T02:10:21Z"}, "committer": {"name": "Clar Charr", "email": "clar@charr.xyz", "date": "2017-06-09T23:07:26Z"}, "message": "Move placement new operators to module.", "tree": {"sha": "4776ca8105e3a8bddc0d8366070bbf0b1943bec3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4776ca8105e3a8bddc0d8366070bbf0b1943bec3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f774cddcf2c1935f101bcfb931495e411e58e52b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f774cddcf2c1935f101bcfb931495e411e58e52b", "html_url": "https://github.com/rust-lang/rust/commit/f774cddcf2c1935f101bcfb931495e411e58e52b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f774cddcf2c1935f101bcfb931495e411e58e52b/comments", "author": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clarfonthey", "id": 15850505, "node_id": "MDQ6VXNlcjE1ODUwNTA1", "avatar_url": "https://avatars.githubusercontent.com/u/15850505?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clarfonthey", "html_url": "https://github.com/clarfonthey", "followers_url": "https://api.github.com/users/clarfonthey/followers", "following_url": "https://api.github.com/users/clarfonthey/following{/other_user}", "gists_url": "https://api.github.com/users/clarfonthey/gists{/gist_id}", "starred_url": "https://api.github.com/users/clarfonthey/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clarfonthey/subscriptions", "organizations_url": "https://api.github.com/users/clarfonthey/orgs", "repos_url": "https://api.github.com/users/clarfonthey/repos", "events_url": "https://api.github.com/users/clarfonthey/events{/privacy}", "received_events_url": "https://api.github.com/users/clarfonthey/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d460aca7204b8252f20b970937838bf70b466efe", "url": "https://api.github.com/repos/rust-lang/rust/commits/d460aca7204b8252f20b970937838bf70b466efe", "html_url": "https://github.com/rust-lang/rust/commit/d460aca7204b8252f20b970937838bf70b466efe"}], "stats": {"total": 249, "additions": 130, "deletions": 119}, "files": [{"sha": "d05365a8fddd13e0cc70cb1fc9d772bc9e3c312e", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 4, "deletions": 119, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/f774cddcf2c1935f101bcfb931495e411e58e52b/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774cddcf2c1935f101bcfb931495e411e58e52b/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=f774cddcf2c1935f101bcfb931495e411e58e52b", "patch": "@@ -150,17 +150,16 @@\n mod arith;\n mod bit;\n mod function;\n+mod place;\n mod range;\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::arith::{Add, Sub, Mul, Div, Rem, Neg};\n-\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n pub use self::arith::{AddAssign, SubAssign, MulAssign, DivAssign, RemAssign};\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use self::bit::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n-\n #[stable(feature = \"op_assign_traits\", since = \"1.8.0\")]\n pub use self::bit::{BitAndAssign, BitOrAssign, BitXorAssign, ShlAssign, ShrAssign};\n \n@@ -173,6 +172,9 @@ pub use self::range::{Range, RangeFrom, RangeFull, RangeTo};\n #[unstable(feature = \"inclusive_range\", reason = \"recently added, follows RFC\", issue = \"28237\")]\n pub use self::range::{RangeInclusive, RangeToInclusive};\n \n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub use self::place::{Place, Placer, InPlace, Boxed, BoxPlace};\n+\n use marker::Unsize;\n \n /// The `Drop` trait is used to run some code when a value goes out of scope.\n@@ -592,123 +594,6 @@ impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *mut T {}\n #[unstable(feature = \"coerce_unsized\", issue = \"27732\")]\n impl<T: ?Sized+Unsize<U>, U: ?Sized> CoerceUnsized<*const U> for *const T {}\n \n-/// Both `PLACE <- EXPR` and `box EXPR` desugar into expressions\n-/// that allocate an intermediate \"place\" that holds uninitialized\n-/// state.  The desugaring evaluates EXPR, and writes the result at\n-/// the address returned by the `pointer` method of this trait.\n-///\n-/// A `Place` can be thought of as a special representation for a\n-/// hypothetical `&uninit` reference (which Rust cannot currently\n-/// express directly). That is, it represents a pointer to\n-/// uninitialized storage.\n-///\n-/// The client is responsible for two steps: First, initializing the\n-/// payload (it can access its address via `pointer`). Second,\n-/// converting the agent to an instance of the owning pointer, via the\n-/// appropriate `finalize` method (see the `InPlace`.\n-///\n-/// If evaluating EXPR fails, then it is up to the destructor for the\n-/// implementation of Place to clean up any intermediate state\n-/// (e.g. deallocate box storage, pop a stack, etc).\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Place<Data: ?Sized> {\n-    /// Returns the address where the input value will be written.\n-    /// Note that the data at this address is generally uninitialized,\n-    /// and thus one should use `ptr::write` for initializing it.\n-    fn pointer(&mut self) -> *mut Data;\n-}\n-\n-/// Interface to implementations of  `PLACE <- EXPR`.\n-///\n-/// `PLACE <- EXPR` effectively desugars into:\n-///\n-/// ```rust,ignore\n-/// let p = PLACE;\n-/// let mut place = Placer::make_place(p);\n-/// let raw_place = Place::pointer(&mut place);\n-/// let value = EXPR;\n-/// unsafe {\n-///     std::ptr::write(raw_place, value);\n-///     InPlace::finalize(place)\n-/// }\n-/// ```\n-///\n-/// The type of `PLACE <- EXPR` is derived from the type of `PLACE`;\n-/// if the type of `PLACE` is `P`, then the final type of the whole\n-/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n-/// traits).\n-///\n-/// Values for types implementing this trait usually are transient\n-/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n-/// or `Copy`, since the `make_place` method takes `self` by value.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Placer<Data: ?Sized> {\n-    /// `Place` is the intermedate agent guarding the\n-    /// uninitialized state for `Data`.\n-    type Place: InPlace<Data>;\n-\n-    /// Creates a fresh place from `self`.\n-    fn make_place(self) -> Self::Place;\n-}\n-\n-/// Specialization of `Place` trait supporting `PLACE <- EXPR`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait InPlace<Data: ?Sized>: Place<Data> {\n-    /// `Owner` is the type of the end value of `PLACE <- EXPR`\n-    ///\n-    /// Note that when `PLACE <- EXPR` is solely used for\n-    /// side-effecting an existing data-structure,\n-    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n-    /// information at all (e.g. it can be the unit type `()` in that\n-    /// case).\n-    type Owner;\n-\n-    /// Converts self into the final value, shifting\n-    /// deallocation/cleanup responsibilities (if any remain), over to\n-    /// the returned instance of `Owner` and forgetting self.\n-    unsafe fn finalize(self) -> Self::Owner;\n-}\n-\n-/// Core trait for the `box EXPR` form.\n-///\n-/// `box EXPR` effectively desugars into:\n-///\n-/// ```rust,ignore\n-/// let mut place = BoxPlace::make_place();\n-/// let raw_place = Place::pointer(&mut place);\n-/// let value = EXPR;\n-/// unsafe {\n-///     ::std::ptr::write(raw_place, value);\n-///     Boxed::finalize(place)\n-/// }\n-/// ```\n-///\n-/// The type of `box EXPR` is supplied from its surrounding\n-/// context; in the above expansion, the result type `T` is used\n-/// to determine which implementation of `Boxed` to use, and that\n-/// `<T as Boxed>` in turn dictates determines which\n-/// implementation of `BoxPlace` to use, namely:\n-/// `<<T as Boxed>::Place as BoxPlace>`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait Boxed {\n-    /// The kind of data that is stored in this kind of box.\n-    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n-    /// The place that will negotiate the storage of the data.\n-    type Place: BoxPlace<Self::Data>;\n-\n-    /// Converts filled place into final owning value, shifting\n-    /// deallocation/cleanup responsibilities (if any remain), over to\n-    /// returned instance of `Self` and forgetting `filled`.\n-    unsafe fn finalize(filled: Self::Place) -> Self;\n-}\n-\n-/// Specialization of `Place` trait supporting `box EXPR`.\n-#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n-pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n-    /// Creates a globally fresh place.\n-    fn make_place() -> Self;\n-}\n-\n /// This trait has been superseded by the `Try` trait, but must remain\n /// here as `?` is still lowered to it in stage0 .\n #[cfg(stage0)]"}, {"sha": "996a741c96f9372fc1b95e313317d8ce3a786b52", "filename": "src/libcore/ops/place.rs", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/f774cddcf2c1935f101bcfb931495e411e58e52b/src%2Flibcore%2Fops%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f774cddcf2c1935f101bcfb931495e411e58e52b/src%2Flibcore%2Fops%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fplace.rs?ref=f774cddcf2c1935f101bcfb931495e411e58e52b", "patch": "@@ -0,0 +1,126 @@\n+// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// Both `PLACE <- EXPR` and `box EXPR` desugar into expressions\n+/// that allocate an intermediate \"place\" that holds uninitialized\n+/// state.  The desugaring evaluates EXPR, and writes the result at\n+/// the address returned by the `pointer` method of this trait.\n+///\n+/// A `Place` can be thought of as a special representation for a\n+/// hypothetical `&uninit` reference (which Rust cannot currently\n+/// express directly). That is, it represents a pointer to\n+/// uninitialized storage.\n+///\n+/// The client is responsible for two steps: First, initializing the\n+/// payload (it can access its address via `pointer`). Second,\n+/// converting the agent to an instance of the owning pointer, via the\n+/// appropriate `finalize` method (see the `InPlace`.\n+///\n+/// If evaluating EXPR fails, then it is up to the destructor for the\n+/// implementation of Place to clean up any intermediate state\n+/// (e.g. deallocate box storage, pop a stack, etc).\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Place<Data: ?Sized> {\n+    /// Returns the address where the input value will be written.\n+    /// Note that the data at this address is generally uninitialized,\n+    /// and thus one should use `ptr::write` for initializing it.\n+    fn pointer(&mut self) -> *mut Data;\n+}\n+\n+/// Interface to implementations of  `PLACE <- EXPR`.\n+///\n+/// `PLACE <- EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let p = PLACE;\n+/// let mut place = Placer::make_place(p);\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     std::ptr::write(raw_place, value);\n+///     InPlace::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `PLACE <- EXPR` is derived from the type of `PLACE`;\n+/// if the type of `PLACE` is `P`, then the final type of the whole\n+/// expression is `P::Place::Owner` (see the `InPlace` and `Boxed`\n+/// traits).\n+///\n+/// Values for types implementing this trait usually are transient\n+/// intermediate values (e.g. the return value of `Vec::emplace_back`)\n+/// or `Copy`, since the `make_place` method takes `self` by value.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Placer<Data: ?Sized> {\n+    /// `Place` is the intermedate agent guarding the\n+    /// uninitialized state for `Data`.\n+    type Place: InPlace<Data>;\n+\n+    /// Creates a fresh place from `self`.\n+    fn make_place(self) -> Self::Place;\n+}\n+\n+/// Specialization of `Place` trait supporting `PLACE <- EXPR`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait InPlace<Data: ?Sized>: Place<Data> {\n+    /// `Owner` is the type of the end value of `PLACE <- EXPR`\n+    ///\n+    /// Note that when `PLACE <- EXPR` is solely used for\n+    /// side-effecting an existing data-structure,\n+    /// e.g. `Vec::emplace_back`, then `Owner` need not carry any\n+    /// information at all (e.g. it can be the unit type `()` in that\n+    /// case).\n+    type Owner;\n+\n+    /// Converts self into the final value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// the returned instance of `Owner` and forgetting self.\n+    unsafe fn finalize(self) -> Self::Owner;\n+}\n+\n+/// Core trait for the `box EXPR` form.\n+///\n+/// `box EXPR` effectively desugars into:\n+///\n+/// ```rust,ignore\n+/// let mut place = BoxPlace::make_place();\n+/// let raw_place = Place::pointer(&mut place);\n+/// let value = EXPR;\n+/// unsafe {\n+///     ::std::ptr::write(raw_place, value);\n+///     Boxed::finalize(place)\n+/// }\n+/// ```\n+///\n+/// The type of `box EXPR` is supplied from its surrounding\n+/// context; in the above expansion, the result type `T` is used\n+/// to determine which implementation of `Boxed` to use, and that\n+/// `<T as Boxed>` in turn dictates determines which\n+/// implementation of `BoxPlace` to use, namely:\n+/// `<<T as Boxed>::Place as BoxPlace>`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait Boxed {\n+    /// The kind of data that is stored in this kind of box.\n+    type Data;  /* (`Data` unused b/c cannot yet express below bound.) */\n+    /// The place that will negotiate the storage of the data.\n+    type Place: BoxPlace<Self::Data>;\n+\n+    /// Converts filled place into final owning value, shifting\n+    /// deallocation/cleanup responsibilities (if any remain), over to\n+    /// returned instance of `Self` and forgetting `filled`.\n+    unsafe fn finalize(filled: Self::Place) -> Self;\n+}\n+\n+/// Specialization of `Place` trait supporting `box EXPR`.\n+#[unstable(feature = \"placement_new_protocol\", issue = \"27779\")]\n+pub trait BoxPlace<Data: ?Sized> : Place<Data> {\n+    /// Creates a globally fresh place.\n+    fn make_place() -> Self;\n+}"}]}