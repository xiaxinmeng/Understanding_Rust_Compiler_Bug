{"sha": "ba0e1cd8147d452c356aacb29fb87568ca26f111", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhMGUxY2Q4MTQ3ZDQ1MmMzNTZhYWNiMjlmYjg3NTY4Y2EyNmYxMTE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-24T11:12:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-24T11:12:34Z"}, "message": "Auto merge of #25609 - nikomatsakis:const-fn, r=pnkfelix\n\nThis is a port of @eddyb's `const-fn` branch. I rebased it, tweaked a few things, and added tests as well as a feature gate. The set of tests is still pretty rudimentary, I'd appreciate suggestions on new tests to write. Also, a double-check that the feature-gate covers all necessary cases.\r\n\r\nOne question: currently, the feature-gate allows the *use* of const functions from stable code, just not the definition. This seems to fit our usual strategy, and implies that we might (perhaps) allow some constant functions in libstd someday, even before stabilizing const-fn, if we were willing to commit to the existence of const fns but found some details of their impl unsatisfactory.\r\n\r\nr? @pnkfelix", "tree": {"sha": "0cf03636be9210de94e30bb07467097aeb5273c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0cf03636be9210de94e30bb07467097aeb5273c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba0e1cd8147d452c356aacb29fb87568ca26f111", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba0e1cd8147d452c356aacb29fb87568ca26f111", "html_url": "https://github.com/rust-lang/rust/commit/ba0e1cd8147d452c356aacb29fb87568ca26f111", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba0e1cd8147d452c356aacb29fb87568ca26f111/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cc56c20ba4ccc12f58e1c844b77168bc4805cbb6", "url": "https://api.github.com/repos/rust-lang/rust/commits/cc56c20ba4ccc12f58e1c844b77168bc4805cbb6", "html_url": "https://github.com/rust-lang/rust/commit/cc56c20ba4ccc12f58e1c844b77168bc4805cbb6"}, {"sha": "82ded3cd03e001e82b9dce9aedac621a5292231b", "url": "https://api.github.com/repos/rust-lang/rust/commits/82ded3cd03e001e82b9dce9aedac621a5292231b", "html_url": "https://github.com/rust-lang/rust/commit/82ded3cd03e001e82b9dce9aedac621a5292231b"}], "stats": {"total": 1060, "additions": 848, "deletions": 212}, "files": [{"sha": "b70d73c9141aebc1a572be1e0b6e0c2a79a215ff", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -845,5 +845,6 @@ register_diagnostics! {\n     E0314, // closure outlives stack frame\n     E0315, // cannot invoke closure outside of its lifetime\n     E0316, // nested quantification of lifetimes\n-    E0370  // discriminant overflow\n+    E0370, // discriminant overflow\n+    E0378  // method calls limited to constant inherent methods\n }"}, {"sha": "901afc1d1904e76ff34cb658c813b22dde6b116b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -262,3 +262,5 @@ pub const tag_item_super_predicates: usize = 0xa3;\n pub const tag_defaulted_trait: usize = 0xa4;\n \n pub const tag_impl_coerce_unsized_kind: usize = 0xa5;\n+\n+pub const tag_items_data_item_constness: usize = 0xa6;"}, {"sha": "f834076e8eab5a8602309addfd9034bb51ec9c25", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -384,6 +384,11 @@ pub fn is_typedef(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n     decoder::is_typedef(&*cdata, did.node)\n }\n \n+pub fn is_const_fn(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n+    let cdata = cstore.get_crate_data(did.krate);\n+    decoder::is_const_fn(&*cdata, did.node)\n+}\n+\n pub fn get_stability(cstore: &cstore::CStore,\n                      def: ast::DefId)\n                      -> Option<attr::Stability> {"}, {"sha": "ee5fd0202d69e90e1c8652e53bfd7535ebadaaa9", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -178,6 +178,19 @@ fn item_visibility(item: rbml::Doc) -> ast::Visibility {\n     }\n }\n \n+fn fn_constness(item: rbml::Doc) -> ast::Constness {\n+    match reader::maybe_get_doc(item, tag_items_data_item_constness) {\n+        None => ast::Constness::NotConst,\n+        Some(constness_doc) => {\n+            match reader::doc_as_u8(constness_doc) as char {\n+                'c' => ast::Constness::Const,\n+                'n' => ast::Constness::NotConst,\n+                _ => panic!(\"unknown constness character\")\n+            }\n+        }\n+    }\n+}\n+\n fn item_sort(item: rbml::Doc) -> Option<char> {\n     let mut ret = None;\n     reader::tagged_docs(item, tag_item_trait_item_sort, |doc| {\n@@ -1525,6 +1538,14 @@ pub fn is_typedef(cdata: Cmd, id: ast::NodeId) -> bool {\n     }\n }\n \n+pub fn is_const_fn(cdata: Cmd, id: ast::NodeId) -> bool {\n+    let item_doc = lookup_item(id, cdata.data());\n+    match fn_constness(item_doc) {\n+        ast::Constness::Const => true,\n+        ast::Constness::NotConst => false,\n+    }\n+}\n+\n fn doc_generics<'tcx>(base_doc: rbml::Doc,\n                       tcx: &ty::ctxt<'tcx>,\n                       cdata: Cmd,"}, {"sha": "88e0b739a0fbba683185bd3509007b941595eccf", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 19, "deletions": 4, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -581,6 +581,16 @@ fn encode_visibility(rbml_w: &mut Encoder, visibility: ast::Visibility) {\n     rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n }\n \n+fn encode_constness(rbml_w: &mut Encoder, constness: ast::Constness) {\n+    rbml_w.start_tag(tag_items_data_item_constness);\n+    let ch = match constness {\n+        ast::Constness::Const => 'c',\n+        ast::Constness::NotConst => 'n',\n+    };\n+    rbml_w.wr_str(&ch.to_string());\n+    rbml_w.end_tag();\n+}\n+\n fn encode_explicit_self(rbml_w: &mut Encoder,\n                         explicit_self: &ty::ExplicitSelfCategory) {\n     let tag = tag_item_trait_method_explicit_self;\n@@ -867,10 +877,13 @@ fn encode_info_for_method<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n             encode_attributes(rbml_w, &impl_item.attrs);\n             let scheme = ty::lookup_item_type(ecx.tcx, m.def_id);\n             let any_types = !scheme.generics.types.is_empty();\n-            if any_types || is_default_impl || attr::requests_inline(&impl_item.attrs) {\n+            let needs_inline = any_types || is_default_impl ||\n+                               attr::requests_inline(&impl_item.attrs);\n+            if needs_inline || sig.constness == ast::Constness::Const {\n                 encode_inlined_item(ecx, rbml_w, IIImplItemRef(local_def(parent_id),\n                                                                impl_item));\n             }\n+            encode_constness(rbml_w, sig.constness);\n             if !any_types {\n                 encode_symbol(ecx, rbml_w, m.def_id.node);\n             }\n@@ -1049,7 +1062,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_stability(rbml_w, stab);\n         rbml_w.end_tag();\n       }\n-      ast::ItemFn(ref decl, _, _, ref generics, _) => {\n+      ast::ItemFn(ref decl, _, constness, _, ref generics, _) => {\n         add_to_index(item, rbml_w, index);\n         rbml_w.start_tag(tag_items_data_item);\n         encode_def_id(rbml_w, def_id);\n@@ -1059,12 +1072,14 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         encode_name(rbml_w, item.ident.name);\n         encode_path(rbml_w, path);\n         encode_attributes(rbml_w, &item.attrs);\n-        if tps_len > 0 || attr::requests_inline(&item.attrs) {\n+        let needs_inline = tps_len > 0 || attr::requests_inline(&item.attrs);\n+        if needs_inline || constness == ast::Constness::Const {\n             encode_inlined_item(ecx, rbml_w, IIItemRef(item));\n         }\n         if tps_len == 0 {\n             encode_symbol(ecx, rbml_w, item.id);\n         }\n+        encode_constness(rbml_w, constness);\n         encode_visibility(rbml_w, vis);\n         encode_stability(rbml_w, stab);\n         encode_method_argument_names(rbml_w, &**decl);\n@@ -1967,7 +1982,7 @@ fn encode_reachable_extern_fns(ecx: &EncodeContext, rbml_w: &mut Encoder) {\n \n     for id in ecx.reachable {\n         if let Some(ast_map::NodeItem(i)) = ecx.tcx.map.find(*id) {\n-            if let ast::ItemFn(_, _, abi, ref generics, _) = i.node {\n+            if let ast::ItemFn(_, _, _, abi, ref generics, _) = i.node {\n                 if abi != abi::Rust && !generics.is_type_parameterized() {\n                     rbml_w.wr_tagged_u32(tag_reachable_extern_fn_id, *id);\n                 }"}, {"sha": "a70df34bd70a82037ad022031e5748cf493ff08d", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 148, "deletions": 42, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -79,6 +79,7 @@ bitflags! {\n #[derive(Copy, Clone, Eq, PartialEq)]\n enum Mode {\n     Const,\n+    ConstFn,\n     Static,\n     StaticMut,\n \n@@ -136,10 +137,87 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n         })\n     }\n \n+    fn fn_like(&mut self,\n+               fk: visit::FnKind,\n+               fd: &ast::FnDecl,\n+               b: &ast::Block,\n+               s: Span,\n+               fn_id: ast::NodeId)\n+               -> ConstQualif {\n+        match self.tcx.const_qualif_map.borrow_mut().entry(fn_id) {\n+            Entry::Occupied(entry) => return *entry.get(),\n+            Entry::Vacant(entry) => {\n+                // Prevent infinite recursion on re-entry.\n+                entry.insert(ConstQualif::empty());\n+            }\n+        }\n+\n+        let mode = match fk {\n+            visit::FkItemFn(_, _, _, ast::Constness::Const, _, _) => {\n+                Mode::ConstFn\n+            }\n+            visit::FkMethod(_, m, _) => {\n+                if m.constness == ast::Constness::Const {\n+                    Mode::ConstFn\n+                } else {\n+                    Mode::Var\n+                }\n+            }\n+            _ => Mode::Var\n+        };\n+\n+        // Ensure the arguments are simple, not mutable/by-ref or patterns.\n+        if mode == Mode::ConstFn {\n+            for arg in &fd.inputs {\n+                match arg.pat.node {\n+                    ast::PatIdent(ast::BindByValue(ast::MutImmutable), _, None) => {}\n+                    _ => {\n+                        span_err!(self.tcx.sess, arg.pat.span, E0022,\n+                                  \"arguments of constant functions can only \\\n+                                   be immutable by-value bindings\");\n+                    }\n+                }\n+            }\n+        }\n+\n+        let qualif = self.with_mode(mode, |this| {\n+            this.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n+            visit::walk_fn(this, fk, fd, b, s);\n+            this.qualif\n+        });\n+\n+        // Keep only bits that aren't affected by function body (NON_ZERO_SIZED),\n+        // and bits that don't change semantics, just optimizations (PREFER_IN_PLACE).\n+        let qualif = qualif & (ConstQualif::NON_ZERO_SIZED | ConstQualif::PREFER_IN_PLACE);\n+\n+        self.tcx.const_qualif_map.borrow_mut().insert(fn_id, qualif);\n+        qualif\n+    }\n+\n     fn add_qualif(&mut self, qualif: ConstQualif) {\n         self.qualif = self.qualif | qualif;\n     }\n \n+    /// Returns true if the call is to a const fn or method.\n+    fn handle_const_fn_call(&mut self, def_id: ast::DefId, ret_ty: Ty<'tcx>) -> bool {\n+        if let Some(fn_like) = const_eval::lookup_const_fn_by_id(self.tcx, def_id) {\n+            let qualif = self.fn_like(fn_like.kind(),\n+                                      fn_like.decl(),\n+                                      fn_like.body(),\n+                                      fn_like.span(),\n+                                      fn_like.id());\n+            self.add_qualif(qualif);\n+\n+            if ty::type_contents(self.tcx, ret_ty).interior_unsafe() {\n+                self.add_qualif(ConstQualif::MUTABLE_MEM);\n+            }\n+\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n     fn record_borrow(&mut self, id: ast::NodeId, mutbl: ast::Mutability) {\n         match self.rvalue_borrows.entry(id) {\n             Entry::Occupied(mut entry) => {\n@@ -158,6 +236,7 @@ impl<'a, 'tcx> CheckCrateVisitor<'a, 'tcx> {\n     fn msg(&self) -> &'static str {\n         match self.mode {\n             Mode::Const => \"constant\",\n+            Mode::ConstFn => \"constant function\",\n             Mode::StaticMut | Mode::Static => \"static\",\n             Mode::Var => unreachable!(),\n         }\n@@ -251,9 +330,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n                 b: &'v ast::Block,\n                 s: Span,\n                 fn_id: ast::NodeId) {\n-        assert!(self.mode == Mode::Var);\n-        self.with_euv(Some(fn_id), |euv| euv.walk_fn(fd, b));\n-        visit::walk_fn(self, fk, fd, b, s);\n+        self.fn_like(fk, fd, b, s, fn_id);\n     }\n \n     fn visit_pat(&mut self, p: &ast::Pat) {\n@@ -269,6 +346,35 @@ impl<'a, 'tcx, 'v> Visitor<'v> for CheckCrateVisitor<'a, 'tcx> {\n         }\n     }\n \n+    fn visit_block(&mut self, block: &ast::Block) {\n+        // Check all statements in the block\n+        for stmt in &block.stmts {\n+            let span = match stmt.node {\n+                ast::StmtDecl(ref decl, _) => {\n+                    match decl.node {\n+                        ast::DeclLocal(_) => decl.span,\n+\n+                        // Item statements are allowed\n+                        ast::DeclItem(_) => continue\n+                    }\n+                }\n+                ast::StmtExpr(ref expr, _) => expr.span,\n+                ast::StmtSemi(ref semi, _) => semi.span,\n+                ast::StmtMac(..) => {\n+                    self.tcx.sess.span_bug(stmt.span, \"unexpanded statement \\\n+                                                       macro in const?!\")\n+                }\n+            };\n+            self.add_qualif(ConstQualif::NOT_CONST);\n+            if self.mode != Mode::Var {\n+                span_err!(self.tcx.sess, span, E0016,\n+                          \"blocks in {}s are limited to items and \\\n+                           tail expressions\", self.msg());\n+            }\n+        }\n+        visit::walk_block(self, block);\n+    }\n+\n     fn visit_expr(&mut self, ex: &ast::Expr) {\n         let mut outer = self.qualif;\n         self.qualif = ConstQualif::empty();\n@@ -473,10 +579,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 Some(def::DefStatic(..)) => {\n                     match v.mode {\n                         Mode::Static | Mode::StaticMut => {}\n-                        Mode::Const => {\n+                        Mode::Const | Mode::ConstFn => {\n                             span_err!(v.tcx.sess, e.span, E0013,\n-                                \"constants cannot refer to other statics, \\\n-                                 insert an intermediate constant instead\");\n+                                \"{}s cannot refer to other statics, insert \\\n+                                 an intermediate constant instead\", v.msg());\n                         }\n                         Mode::Var => v.add_qualif(ConstQualif::NOT_CONST)\n                     }\n@@ -493,6 +599,10 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                                              doesn't point to a constant\");\n                     }\n                 }\n+                Some(def::DefLocal(_)) if v.mode == Mode::ConstFn => {\n+                    // Sadly, we can't determine whether the types are zero-sized.\n+                    v.add_qualif(ConstQualif::NOT_CONST | ConstQualif::NON_ZERO_SIZED);\n+                }\n                 def => {\n                     v.add_qualif(ConstQualif::NOT_CONST);\n                     if v.mode != Mode::Var {\n@@ -517,48 +627,44 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n                 };\n             }\n             let def = v.tcx.def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-            match def {\n-                Some(def::DefStruct(..)) => {}\n+            let is_const = match def {\n+                Some(def::DefStruct(..)) => true,\n                 Some(def::DefVariant(..)) => {\n                     // Count the discriminator.\n                     v.add_qualif(ConstQualif::NON_ZERO_SIZED);\n+                    true\n                 }\n-                _ => {\n-                    v.add_qualif(ConstQualif::NOT_CONST);\n-                    if v.mode != Mode::Var {\n-                        span_err!(v.tcx.sess, e.span, E0015,\n-                                  \"function calls in {}s are limited to \\\n-                                   struct and enum constructors\", v.msg());\n-                    }\n+                Some(def::DefMethod(did, def::FromImpl(_))) |\n+                Some(def::DefFn(did, _)) => {\n+                    v.handle_const_fn_call(did, node_ty)\n                 }\n-            }\n-        }\n-        ast::ExprBlock(ref block) => {\n-            // Check all statements in the block\n-            let mut block_span_err = |span| {\n+                _ => false\n+            };\n+            if !is_const {\n                 v.add_qualif(ConstQualif::NOT_CONST);\n                 if v.mode != Mode::Var {\n-                    span_err!(v.tcx.sess, span, E0016,\n-                              \"blocks in {}s are limited to items and \\\n-                               tail expressions\", v.msg());\n+                    span_err!(v.tcx.sess, e.span, E0015,\n+                              \"function calls in {}s are limited to \\\n+                               constant functions, \\\n+                               struct and enum constructors\", v.msg());\n                 }\n+            }\n+        }\n+        ast::ExprMethodCall(..) => {\n+            let method_did = match v.tcx.method_map.borrow()[&method_call].origin {\n+                ty::MethodStatic(did) => Some(did),\n+                _ => None\n             };\n-            for stmt in &block.stmts {\n-                match stmt.node {\n-                    ast::StmtDecl(ref decl, _) => {\n-                        match decl.node {\n-                            ast::DeclLocal(_) => block_span_err(decl.span),\n-\n-                            // Item statements are allowed\n-                            ast::DeclItem(_) => {}\n-                        }\n-                    }\n-                    ast::StmtExpr(ref expr, _) => block_span_err(expr.span),\n-                    ast::StmtSemi(ref semi, _) => block_span_err(semi.span),\n-                    ast::StmtMac(..) => {\n-                        v.tcx.sess.span_bug(e.span, \"unexpanded statement \\\n-                                                     macro in const?!\")\n-                    }\n+            let is_const = match method_did {\n+                Some(did) => v.handle_const_fn_call(did, node_ty),\n+                None => false\n+            };\n+            if !is_const {\n+                v.add_qualif(ConstQualif::NOT_CONST);\n+                if v.mode != Mode::Var {\n+                    span_err!(v.tcx.sess, e.span, E0378,\n+                              \"method calls in {}s are limited to \\\n+                               constant inherent methods\", v.msg());\n                 }\n             }\n         }\n@@ -579,7 +685,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         }\n \n         ast::ExprClosure(..) => {\n-            // Paths in constant constexts cannot refer to local variables,\n+            // Paths in constant contexts cannot refer to local variables,\n             // as there are none, and thus closures can't have upvars there.\n             if ty::with_freevars(v.tcx, e.id, |fv| !fv.is_empty()) {\n                 assert!(v.mode == Mode::Var,\n@@ -588,6 +694,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n             }\n         }\n \n+        ast::ExprBlock(_) |\n         ast::ExprUnary(..) |\n         ast::ExprBinary(..) |\n         ast::ExprIndex(..) |\n@@ -616,8 +723,7 @@ fn check_expr<'a, 'tcx>(v: &mut CheckCrateVisitor<'a, 'tcx>,\n         // Miscellaneous expressions that could be implemented.\n         ast::ExprRange(..) |\n \n-        // Various other expressions.\n-        ast::ExprMethodCall(..) |\n+        // Expressions with side-effects.\n         ast::ExprAssign(..) |\n         ast::ExprAssignOp(..) |\n         ast::ExprInlineAsm(_) |"}, {"sha": "e5100c32cc2da48e3bc472b360144534f6dede43", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -24,11 +24,13 @@ use util::num::ToPrimitive;\n use util::ppaux::Repr;\n \n use syntax::ast::{self, Expr};\n+use syntax::ast_map::blocks::FnLikeNode;\n+use syntax::ast_util;\n use syntax::codemap::Span;\n use syntax::feature_gate;\n use syntax::parse::token::InternedString;\n use syntax::ptr::P;\n-use syntax::{ast_map, ast_util, codemap};\n+use syntax::{ast_map, codemap, visit};\n \n use std::borrow::{Cow, IntoCow};\n use std::num::wrapping::OverflowingOps;\n@@ -198,6 +200,63 @@ pub fn lookup_const_by_id<'a, 'tcx: 'a>(tcx: &'a ty::ctxt<'tcx>,\n     }\n }\n \n+fn inline_const_fn_from_external_crate(tcx: &ty::ctxt, def_id: ast::DefId)\n+                                       -> Option<ast::NodeId> {\n+    match tcx.extern_const_fns.borrow().get(&def_id) {\n+        Some(&ast::DUMMY_NODE_ID) => return None,\n+        Some(&fn_id) => return Some(fn_id),\n+        None => {}\n+    }\n+\n+    if !csearch::is_const_fn(&tcx.sess.cstore, def_id) {\n+        tcx.extern_const_fns.borrow_mut().insert(def_id, ast::DUMMY_NODE_ID);\n+        return None;\n+    }\n+\n+    let fn_id = match csearch::maybe_get_item_ast(tcx, def_id,\n+        box |a, b, c, d| astencode::decode_inlined_item(a, b, c, d)) {\n+        csearch::FoundAst::Found(&ast::IIItem(ref item)) => Some(item.id),\n+        csearch::FoundAst::Found(&ast::IIImplItem(_, ref item)) => Some(item.id),\n+        _ => None\n+    };\n+    tcx.extern_const_fns.borrow_mut().insert(def_id,\n+                                             fn_id.unwrap_or(ast::DUMMY_NODE_ID));\n+    fn_id\n+}\n+\n+pub fn lookup_const_fn_by_id<'tcx>(tcx: &ty::ctxt<'tcx>, def_id: ast::DefId)\n+                                   -> Option<FnLikeNode<'tcx>>\n+{\n+    let fn_id = if !ast_util::is_local(def_id) {\n+        if let Some(fn_id) = inline_const_fn_from_external_crate(tcx, def_id) {\n+            fn_id\n+        } else {\n+            return None;\n+        }\n+    } else {\n+        def_id.node\n+    };\n+\n+    let fn_like = match FnLikeNode::from_node(tcx.map.get(fn_id)) {\n+        Some(fn_like) => fn_like,\n+        None => return None\n+    };\n+\n+    match fn_like.kind() {\n+        visit::FkItemFn(_, _, _, ast::Constness::Const, _, _) => {\n+            Some(fn_like)\n+        }\n+        visit::FkMethod(_, m, _) => {\n+            if m.constness == ast::Constness::Const {\n+                Some(fn_like)\n+            } else {\n+                None\n+            }\n+        }\n+        _ => None\n+    }\n+}\n+\n #[derive(Clone, PartialEq)]\n pub enum const_val {\n     const_float(f64),"}, {"sha": "cfff439f02d19d13215369ea7977cfcb2824775d", "filename": "src/librustc/middle/effect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Feffect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Feffect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Feffect.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -87,8 +87,8 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EffectCheckVisitor<'a, 'tcx> {\n                 block: &'v ast::Block, span: Span, _: ast::NodeId) {\n \n         let (is_item_fn, is_unsafe_fn) = match fn_kind {\n-            visit::FkItemFn(_, _, fn_style, _, _) =>\n-                (true, fn_style == ast::Unsafety::Unsafe),\n+            visit::FkItemFn(_, _, unsafety, _, _, _) =>\n+                (true, unsafety == ast::Unsafety::Unsafe),\n             visit::FkMethod(_, sig, _) =>\n                 (true, sig.unsafety == ast::Unsafety::Unsafe),\n             _ => (false, false),"}, {"sha": "4ec5cf03364973d241a6c1a19242dc62a522f617", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -158,6 +158,7 @@ trait ErrorReportingHelpers<'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n                                 unsafety: ast::Unsafety,\n+                                constness: ast::Constness,\n                                 ident: ast::Ident,\n                                 opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n@@ -826,8 +827,9 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             Some(ref node) => match *node {\n                 ast_map::NodeItem(ref item) => {\n                     match item.node {\n-                        ast::ItemFn(ref fn_decl, pur, _, ref gen, _) => {\n-                            Some((fn_decl, gen, pur, item.ident, None, item.span))\n+                        ast::ItemFn(ref fn_decl, unsafety, constness, _, ref gen, _) => {\n+                            Some((fn_decl, gen, unsafety, constness,\n+                                  item.ident, None, item.span))\n                         },\n                         _ => None\n                     }\n@@ -838,6 +840,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             Some((&sig.decl,\n                                   &sig.generics,\n                                   sig.unsafety,\n+                                  sig.constness,\n                                   item.ident,\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n@@ -852,6 +855,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                             Some((&sig.decl,\n                                   &sig.generics,\n                                   sig.unsafety,\n+                                  sig.constness,\n                                   item.ident,\n                                   Some(&sig.explicit_self.node),\n                                   item.span))\n@@ -863,12 +867,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n             },\n             None => None\n         };\n-        let (fn_decl, generics, unsafety, ident, expl_self, span)\n+        let (fn_decl, generics, unsafety, constness, ident, expl_self, span)\n                                     = node_inner.expect(\"expect item fn\");\n         let rebuilder = Rebuilder::new(self.tcx, fn_decl, expl_self,\n                                        generics, same_regions, &life_giver);\n         let (fn_decl, expl_self, generics) = rebuilder.rebuild();\n-        self.give_expl_lifetime_param(&fn_decl, unsafety, ident,\n+        self.give_expl_lifetime_param(&fn_decl, unsafety, constness, ident,\n                                       expl_self.as_ref(), &generics, span);\n     }\n }\n@@ -1423,12 +1427,13 @@ impl<'a, 'tcx> ErrorReportingHelpers<'tcx> for InferCtxt<'a, 'tcx> {\n     fn give_expl_lifetime_param(&self,\n                                 decl: &ast::FnDecl,\n                                 unsafety: ast::Unsafety,\n+                                constness: ast::Constness,\n                                 ident: ast::Ident,\n                                 opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                                 generics: &ast::Generics,\n                                 span: codemap::Span) {\n-        let suggested_fn = pprust::fun_to_string(decl, unsafety, ident,\n-                                              opt_explicit_self, generics);\n+        let suggested_fn = pprust::fun_to_string(decl, unsafety, constness, ident,\n+                                                 opt_explicit_self, generics);\n         let msg = format!(\"consider using an explicit lifetime \\\n                            parameter as shown: {}\", suggested_fn);\n         self.tcx.sess.span_help(span, &msg[..]);\n@@ -1710,7 +1715,7 @@ fn lifetimes_in_scope(tcx: &ty::ctxt,\n     let method_id_opt = match tcx.map.find(parent) {\n         Some(node) => match node {\n             ast_map::NodeItem(item) => match item.node {\n-                ast::ItemFn(_, _, _, ref gen, _) => {\n+                ast::ItemFn(_, _, _, _, ref gen, _) => {\n                     taken.push_all(&gen.lifetimes);\n                     None\n                 },"}, {"sha": "f374c9749c250680ca334810fb1b5c27c4e1f83a", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -46,7 +46,7 @@ fn item_might_be_inlined(item: &ast::Item) -> bool {\n \n     match item.node {\n         ast::ItemImpl(_, _, ref generics, _, _, _) |\n-        ast::ItemFn(_, _, _, ref generics, _) => {\n+        ast::ItemFn(_, _, _, _, ref generics, _) => {\n             generics_require_inlining(generics)\n         }\n         _ => false,\n@@ -256,7 +256,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n             // but all other rust-only interfaces can be private (they will not\n             // participate in linkage after this product is produced)\n             if let ast_map::NodeItem(item) = *node {\n-                if let ast::ItemFn(_, _, abi, _, _) = item.node {\n+                if let ast::ItemFn(_, _, _, abi, _, _) = item.node {\n                     if abi != abi::Rust {\n                         self.reachable_symbols.insert(search_item);\n                     }\n@@ -273,7 +273,7 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n-                    ast::ItemFn(_, _, _, _, ref search_block) => {\n+                    ast::ItemFn(_, _, _, _, _, ref search_block) => {\n                         if item_might_be_inlined(&*item) {\n                             visit::walk_block(self, &**search_block)\n                         }"}, {"sha": "dfdcba1678f19578c871d597c6421391aed4ef9e", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -154,7 +154,7 @@ impl<'a, 'v> Visitor<'v> for LifetimeContext<'a> {\n     fn visit_fn(&mut self, fk: visit::FnKind<'v>, fd: &'v ast::FnDecl,\n                 b: &'v ast::Block, s: Span, _: ast::NodeId) {\n         match fk {\n-            visit::FkItemFn(_, generics, _, _, _) => {\n+            visit::FkItemFn(_, generics, _, _, _, _) => {\n                 self.visit_early_late(subst::FnSpace, generics, |this| {\n                     this.walk_fn(fk, fd, b, s)\n                 })\n@@ -447,7 +447,7 @@ impl<'a> LifetimeContext<'a> {\n                    fb: &'b ast::Block,\n                    _span: Span) {\n         match fk {\n-            visit::FkItemFn(_, generics, _, _, _) => {\n+            visit::FkItemFn(_, generics, _, _, _, _) => {\n                 visit::walk_fn_decl(self, fd);\n                 self.visit_generics(generics);\n             }"}, {"sha": "5ff6ee3c8b0817c77cc348ee9ce18db8d2defc69", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -775,10 +775,10 @@ pub struct ctxt<'tcx> {\n     /// Borrows\n     pub upvar_capture_map: RefCell<UpvarCaptureMap>,\n \n-    /// These two caches are used by const_eval when decoding external statics\n-    /// and variants that are found.\n+    /// These caches are used by const_eval when decoding external constants.\n     pub extern_const_statics: RefCell<DefIdMap<ast::NodeId>>,\n     pub extern_const_variants: RefCell<DefIdMap<ast::NodeId>>,\n+    pub extern_const_fns: RefCell<DefIdMap<ast::NodeId>>,\n \n     pub method_map: MethodMap<'tcx>,\n \n@@ -2428,7 +2428,7 @@ impl<'a, 'tcx> ParameterEnvironment<'a, 'tcx> {\n             }\n             Some(ast_map::NodeItem(item)) => {\n                 match item.node {\n-                    ast::ItemFn(_, _, _, _, ref body) => {\n+                    ast::ItemFn(_, _, _, _, _, ref body) => {\n                         // We assume this is a function.\n                         let fn_def_id = ast_util::local_def(id);\n                         let fn_scheme = lookup_item_type(cx, fn_def_id);\n@@ -2808,6 +2808,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         upvar_capture_map: RefCell::new(FnvHashMap()),\n         extern_const_statics: RefCell::new(DefIdMap()),\n         extern_const_variants: RefCell::new(DefIdMap()),\n+        extern_const_fns: RefCell::new(DefIdMap()),\n         method_map: RefCell::new(FnvHashMap()),\n         dependency_formats: RefCell::new(FnvHashMap()),\n         closure_kinds: RefCell::new(DefIdMap()),"}, {"sha": "e9db80b71ea018e081e2ba0b9d5dd50a954f2b53", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -994,7 +994,7 @@ impl LintPass for NonSnakeCase {\n                 },\n                 _ => (),\n             },\n-            visit::FkItemFn(ident, _, _, _, _) => {\n+            visit::FkItemFn(ident, _, _, _, _, _) => {\n                 self.check_snake_case(cx, \"function\", &token::get_ident(ident), Some(span))\n             },\n             _ => (),\n@@ -1341,7 +1341,7 @@ impl LintPass for UnsafeCode {\n     fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n                 _: &ast::Block, span: Span, _: ast::NodeId) {\n         match fk {\n-            visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _, _) =>\n+            visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _, _, _) =>\n                 cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n             visit::FkMethod(_, sig, _) => {\n@@ -1870,7 +1870,7 @@ impl LintPass for UnconditionalRecursion {\n                               ast::NodeId, ast::NodeId, ast::Ident, ast::NodeId) -> bool;\n \n         let (name, checker) = match fn_kind {\n-            visit::FkItemFn(name, _, _, _, _) => (name, id_refers_to_this_fn as F),\n+            visit::FkItemFn(name, _, _, _, _, _) => (name, id_refers_to_this_fn as F),\n             visit::FkMethod(name, _, _) => (name, id_refers_to_this_method as F),\n             // closures can't recur, so they don't matter.\n             visit::FkFnBlock => return"}, {"sha": "30d5a4f111ba43e9b41bdd3636c52e947ae7714d", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -425,7 +425,7 @@ impl<'a, 'b:'a, 'tcx:'b> GraphBuilder<'a, 'b, 'tcx> {\n                     .define_value(DefConst(local_def(item.id)), sp, modifiers);\n                 parent.clone()\n             }\n-            ItemFn(_, _, _, _, _) => {\n+            ItemFn(_, _, _, _, _, _) => {\n                 let name_bindings = self.add_child(name, parent, ForbidDuplicateValues, sp);\n \n                 let def = DefFn(local_def(item.id), false);"}, {"sha": "7afc1afc224eefbd48675c476fef1452f5da7fa0", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -245,7 +245,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n                 _: Span,\n                 node_id: NodeId) {\n         let rib_kind = match function_kind {\n-            visit::FkItemFn(_, generics, _, _, _) => {\n+            visit::FkItemFn(_, generics, _, _, _, _) => {\n                 self.visit_generics(generics);\n                 ItemRibKind\n             }\n@@ -1809,7 +1809,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                                                ItemRibKind),\n                                              |this| visit::walk_item(this, item));\n             }\n-            ItemFn(_, _, _, ref generics, _) => {\n+            ItemFn(_, _, _, _, ref generics, _) => {\n                 self.with_type_parameter_rib(HasTypeParameters(generics,\n                                                                FnSpace,\n                                                                ItemRibKind),"}, {"sha": "00a1f728b9b0003e859a05810e799b8477b61dc0", "filename": "src/librustc_trans/save/dump_csv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fsave%2Fdump_csv.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -1167,7 +1167,7 @@ impl<'l, 'tcx, 'v> Visitor<'v> for DumpCsvVisitor<'l, 'tcx> {\n                                           &location[..],\n                                           self.cur_scope);\n             }\n-            ast::ItemFn(ref decl, _, _, ref ty_params, ref body) =>\n+            ast::ItemFn(ref decl, _, _, _, ref ty_params, ref body) =>\n                 self.process_fn(item, &**decl, ty_params, &**body),\n             ast::ItemStatic(ref typ, _, ref expr) =>\n                 self.process_static_or_const_item(item, typ, expr),"}, {"sha": "53a991170c70fb58841adcffbee0cf139e5928c4", "filename": "src/librustc_trans/trans/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2F_match.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -278,14 +278,14 @@ impl<'a, 'tcx> Opt<'a, 'tcx> {\n         match *self {\n             ConstantValue(ConstantExpr(lit_expr), _) => {\n                 let lit_ty = ty::node_id_to_type(bcx.tcx(), lit_expr.id);\n-                let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs);\n+                let (llval, _) = consts::const_expr(ccx, &*lit_expr, bcx.fcx.param_substs, None);\n                 let lit_datum = immediate_rvalue(llval, lit_ty);\n                 let lit_datum = unpack_datum!(bcx, lit_datum.to_appropriate_datum(bcx));\n                 SingleResult(Result::new(bcx, lit_datum.val))\n             }\n             ConstantRange(ConstantExpr(ref l1), ConstantExpr(ref l2), _) => {\n-                let (l1, _) = consts::const_expr(ccx, &**l1, bcx.fcx.param_substs);\n-                let (l2, _) = consts::const_expr(ccx, &**l2, bcx.fcx.param_substs);\n+                let (l1, _) = consts::const_expr(ccx, &**l1, bcx.fcx.param_substs, None);\n+                let (l2, _) = consts::const_expr(ccx, &**l2, bcx.fcx.param_substs, None);\n                 RangeResult(Result::new(bcx, l1), Result::new(bcx, l2))\n             }\n             Variant(disr_val, ref repr, _, _) => {"}, {"sha": "9310d1e202ab3b9d3b364aa4929f337027dbd7e4", "filename": "src/librustc_trans/trans/base.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fbase.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -1073,7 +1073,7 @@ fn build_cfg(tcx: &ty::ctxt, id: ast::NodeId) -> (ast::NodeId, Option<cfg::CFG>)\n     let blk = match tcx.map.find(id) {\n         Some(ast_map::NodeItem(i)) => {\n             match i.node {\n-                ast::ItemFn(_, _, _, _, ref blk) => {\n+                ast::ItemFn(_, _, _, _, _, ref blk) => {\n                     blk\n                 }\n                 _ => tcx.sess.bug(\"unexpected item variant in has_nested_returns\")\n@@ -1966,7 +1966,7 @@ pub fn trans_item(ccx: &CrateContext, item: &ast::Item) {\n     let from_external = ccx.external_srcs().borrow().contains_key(&item.id);\n \n     match item.node {\n-      ast::ItemFn(ref decl, _fn_style, abi, ref generics, ref body) => {\n+      ast::ItemFn(ref decl, _, _, abi, ref generics, ref body) => {\n         if !generics.is_type_parameterized() {\n             let trans_everywhere = attr::requests_inline(&item.attrs);\n             // Ignore `trans_everywhere` for cross-crate inlined items\n@@ -2307,7 +2307,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     // We need the translated value here, because for enums the\n                     // LLVM type is not fully determined by the Rust type.\n                     let empty_substs = ccx.tcx().mk_substs(Substs::trans_empty());\n-                    let (v, ty) = consts::const_expr(ccx, &**expr, empty_substs);\n+                    let (v, ty) = consts::const_expr(ccx, &**expr, empty_substs, None);\n                     ccx.static_values().borrow_mut().insert(id, v);\n                     unsafe {\n                         // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -2336,7 +2336,7 @@ pub fn get_item_val(ccx: &CrateContext, id: ast::NodeId) -> ValueRef {\n                     }\n                 }\n \n-                ast::ItemFn(_, _, abi, _, _) => {\n+                ast::ItemFn(_, _, _, abi, _, _) => {\n                     let sym = sym();\n                     let llfn = if abi == Rust {\n                         register_fn(ccx, i.span, sym, i.id, ty)"}, {"sha": "c11bb922f1cb2708413df1f75515e3df8a56f417", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 89, "deletions": 29, "changes": 118, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -33,13 +33,16 @@ use middle::cast::{CastTy,IntTy};\n use middle::subst::Substs;\n use middle::ty::{self, Ty};\n use util::ppaux::{Repr, ty_to_string};\n+use util::nodemap::NodeMap;\n \n use std::iter::repeat;\n use libc::c_uint;\n use syntax::{ast, ast_util};\n use syntax::parse::token;\n use syntax::ptr::P;\n \n+pub type FnArgMap<'a> = Option<&'a NodeMap<ValueRef>>;\n+\n pub fn const_lit(cx: &CrateContext, e: &ast::Expr, lit: &ast::Lit)\n     -> ValueRef {\n     let _icx = push_ctxt(\"trans_lit\");\n@@ -163,6 +166,29 @@ fn const_deref<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     }\n }\n \n+fn const_fn_call<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n+                           node: ExprOrMethodCall,\n+                           def_id: ast::DefId,\n+                           arg_vals: &[ValueRef],\n+                           param_substs: &'tcx Substs<'tcx>) -> ValueRef {\n+    let fn_like = const_eval::lookup_const_fn_by_id(ccx.tcx(), def_id);\n+    let fn_like = fn_like.expect(\"lookup_const_fn_by_id failed in const_fn_call\");\n+\n+    let args = &fn_like.decl().inputs;\n+    assert_eq!(args.len(), arg_vals.len());\n+\n+    let arg_ids = args.iter().map(|arg| arg.pat.id);\n+    let fn_args = arg_ids.zip(arg_vals.iter().cloned()).collect();\n+\n+    let substs = ccx.tcx().mk_substs(node_id_substs(ccx, node, param_substs));\n+    match fn_like.body().expr {\n+        Some(ref expr) => {\n+            const_expr(ccx, &**expr, substs, Some(&fn_args)).0\n+        }\n+        None => C_nil(ccx)\n+    }\n+}\n+\n pub fn get_const_expr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                                 def_id: ast::DefId,\n                                 ref_expr: &ast::Expr)\n@@ -221,9 +247,9 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         // references, even when only the latter are correct.\n         let ty = monomorphize::apply_param_substs(ccx.tcx(), param_substs,\n                                                   &ty::expr_ty(ccx.tcx(), expr));\n-        const_expr_unadjusted(ccx, expr, ty, param_substs)\n+        const_expr_unadjusted(ccx, expr, ty, param_substs, None)\n     } else {\n-        const_expr(ccx, expr, param_substs).0\n+        const_expr(ccx, expr, param_substs, None).0\n     };\n \n     // boolean SSA values are i1, but they have to be stored in i8 slots,\n@@ -243,11 +269,12 @@ pub fn get_const_expr_as_global<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n \n pub fn const_expr<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                             e: &ast::Expr,\n-                            param_substs: &'tcx Substs<'tcx>)\n+                            param_substs: &'tcx Substs<'tcx>,\n+                            fn_args: FnArgMap)\n                             -> (ValueRef, Ty<'tcx>) {\n     let ety = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                &ty::expr_ty(cx.tcx(), e));\n-    let llconst = const_expr_unadjusted(cx, e, ety, param_substs);\n+    let llconst = const_expr_unadjusted(cx, e, ety, param_substs, fn_args);\n     let mut llconst = llconst;\n     let mut ety_adjusted = monomorphize::apply_param_substs(cx.tcx(), param_substs,\n                                                             &ty::expr_ty_adjusted(cx.tcx(), e));\n@@ -440,17 +467,19 @@ fn check_binary_expr_validity(cx: &CrateContext, e: &ast::Expr, t: Ty,\n fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                    e: &ast::Expr,\n                                    ety: Ty<'tcx>,\n-                                   param_substs: &'tcx Substs<'tcx>)\n+                                   param_substs: &'tcx Substs<'tcx>,\n+                                   fn_args: FnArgMap)\n                                    -> ValueRef\n {\n     debug!(\"const_expr_unadjusted(e={}, ety={}, param_substs={})\",\n            e.repr(cx.tcx()),\n            ety.repr(cx.tcx()),\n            param_substs.repr(cx.tcx()));\n \n-    let map_list = |exprs: &[P<ast::Expr>]| {\n-        exprs.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n-             .fold(Vec::new(), |mut l, val| { l.push(val); l })\n+    let map_list = |exprs: &[P<ast::Expr>]| -> Vec<ValueRef> {\n+        exprs.iter()\n+             .map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n+             .collect()\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n@@ -461,7 +490,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprBinary(b, ref e1, ref e2) => {\n             /* Neither type is bottom, and we expect them to be unified\n              * already, so the following is safe. */\n-            let (te1, ty) = const_expr(cx, &**e1, param_substs);\n+            let (te1, ty) = const_expr(cx, &**e1, param_substs, fn_args);\n             debug!(\"const_expr_unadjusted: te1={}, ty={}\",\n                    cx.tn().val_to_string(te1),\n                    ty.repr(cx.tcx()));\n@@ -474,7 +503,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let is_float = ty::type_is_fp(intype);\n             let signed = ty::type_is_signed(intype);\n \n-            let (te2, _) = const_expr(cx, &**e2, param_substs);\n+            let (te2, _) = const_expr(cx, &**e2, param_substs, fn_args);\n \n             check_binary_expr_validity(cx, e, ty, te1, te2);\n \n@@ -534,7 +563,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           },\n           ast::ExprUnary(u, ref inner_e) => {\n-            let (te, ty) = const_expr(cx, &**inner_e, param_substs);\n+            let (te, ty) = const_expr(cx, &**inner_e, param_substs, fn_args);\n \n             check_unary_expr_validity(cx, e, ty, te);\n \n@@ -551,23 +580,23 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprField(ref base, field) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, field_tys| {\n                   let ix = ty::field_idx_strict(cx.tcx(), field.node.name, field_tys);\n                   adt::const_get_field(cx, &*brepr, bv, discr, ix)\n               })\n           }\n           ast::ExprTupField(ref base, idx) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let brepr = adt::represent_type(cx, bt);\n               expr::with_field_tys(cx.tcx(), bt, None, |discr, _| {\n                   adt::const_get_field(cx, &*brepr, bv, discr, idx.node)\n               })\n           }\n \n           ast::ExprIndex(ref base, ref index) => {\n-              let (bv, bt) = const_expr(cx, &**base, param_substs);\n+              let (bv, bt) = const_expr(cx, &**base, param_substs, fn_args);\n               let iv = match const_eval::eval_const_expr_partial(cx.tcx(), &**index, None) {\n                   Ok(const_eval::const_int(i)) => i as u64,\n                   Ok(const_eval::const_uint(u)) => u,\n@@ -619,7 +648,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprCast(ref base, _) => {\n             let t_cast = ety;\n             let llty = type_of::type_of(cx, t_cast);\n-            let (v, t_expr) = const_expr(cx, &**base, param_substs);\n+            let (v, t_expr) = const_expr(cx, &**base, param_substs, fn_args);\n             debug!(\"trans_const_cast({} as {})\", t_expr.repr(cx.tcx()), t_cast.repr(cx.tcx()));\n             if expr::cast_is_noop(cx.tcx(), base, t_expr, t_cast) {\n                 return v;\n@@ -707,12 +736,12 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               } else {\n                   // If this isn't the address of a static, then keep going through\n                   // normal constant evaluation.\n-                  let (v, _) = const_expr(cx, &**sub, param_substs);\n+                  let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n                   addr_of(cx, v, \"ref\")\n               }\n           }\n           ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n-              let (v, _) = const_expr(cx, &**sub, param_substs);\n+              let (v, _) = const_expr(cx, &**sub, param_substs, fn_args);\n               addr_of_mut(cx, v, \"ref_mut_slice\")\n           }\n           ast::ExprTup(ref es) => {\n@@ -724,15 +753,15 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               let repr = adt::represent_type(cx, ety);\n \n               let base_val = match *base_opt {\n-                Some(ref base) => Some(const_expr(cx, &**base, param_substs)),\n+                Some(ref base) => Some(const_expr(cx, &**base, param_substs, fn_args)),\n                 None => None\n               };\n \n               expr::with_field_tys(cx.tcx(), ety, Some(e.id), |discr, field_tys| {\n                   let cs = field_tys.iter().enumerate()\n                                     .map(|(ix, &field_ty)| {\n                       match fs.iter().find(|f| field_ty.name == f.ident.node.name) {\n-                          Some(ref f) => const_expr(cx, &*f.expr, param_substs).0,\n+                          Some(ref f) => const_expr(cx, &*f.expr, param_substs, fn_args).0,\n                           None => {\n                               match base_val {\n                                   Some((bv, _)) => {\n@@ -757,7 +786,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprVec(ref es) => {\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n-            let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs).0)\n+            let vs = es.iter().map(|e| const_expr(cx, &**e, param_substs, fn_args).0)\n                               .collect::<Vec<_>>();\n             // If the vector contains enums, an LLVM array won't work.\n             if vs.iter().any(|vi| val_ty(*vi) != llunitty) {\n@@ -770,7 +799,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let unit_ty = ty::sequence_element_type(cx.tcx(), ety);\n             let llunitty = type_of::type_of(cx, unit_ty);\n             let n = ty::eval_repeat_count(cx.tcx(), count);\n-            let unit_val = const_expr(cx, &**elem, param_substs).0;\n+            let unit_val = const_expr(cx, &**elem, param_substs, fn_args).0;\n             let vs: Vec<_> = repeat(unit_val).take(n).collect();\n             if val_ty(unit_val) != llunitty {\n                 C_struct(cx, &vs[..], false)\n@@ -781,6 +810,13 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprPath(..) => {\n             let def = cx.tcx().def_map.borrow().get(&e.id).unwrap().full_def();\n             match def {\n+                def::DefLocal(id) => {\n+                    if let Some(val) = fn_args.and_then(|args| args.get(&id).cloned()) {\n+                        val\n+                    } else {\n+                        cx.sess().span_bug(e.span, \"const fn argument not found\")\n+                    }\n+                }\n                 def::DefFn(..) | def::DefMethod(..) => {\n                     expr::trans_def_fn_unadjusted(cx, e, def, param_substs).val\n                 }\n@@ -816,18 +852,32 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n           }\n           ast::ExprCall(ref callee, ref args) => {\n-              let opt_def = cx.tcx().def_map.borrow().get(&callee.id).map(|d| d.full_def());\n-              let arg_vals = map_list(&args[..]);\n-              match opt_def {\n-                  Some(def::DefStruct(_)) => {\n+              let mut callee = &**callee;\n+              loop {\n+                  callee = match callee.node {\n+                      ast::ExprParen(ref inner) => &**inner,\n+                      ast::ExprBlock(ref block) => match block.expr {\n+                          Some(ref tail) => &**tail,\n+                          None => break\n+                      },\n+                      _ => break\n+                  };\n+              }\n+              let def = cx.tcx().def_map.borrow()[&callee.id].full_def();\n+              let arg_vals = map_list(args);\n+              match def {\n+                  def::DefFn(did, _) | def::DefMethod(did, _) => {\n+                      const_fn_call(cx, ExprId(callee.id), did, &arg_vals, param_substs)\n+                  }\n+                  def::DefStruct(_) => {\n                       if ty::type_is_simd(cx.tcx(), ety) {\n                           C_vector(&arg_vals[..])\n                       } else {\n                           let repr = adt::represent_type(cx, ety);\n                           adt::trans_const(cx, &*repr, 0, &arg_vals[..])\n                       }\n                   }\n-                  Some(def::DefVariant(enum_did, variant_did, _)) => {\n+                  def::DefVariant(enum_did, variant_did, _) => {\n                       let repr = adt::represent_type(cx, ety);\n                       let vinfo = ty::enum_variant_with_id(cx.tcx(),\n                                                            enum_did,\n@@ -837,13 +887,23 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                                        vinfo.disr_val,\n                                        &arg_vals[..])\n                   }\n-                  _ => cx.sess().span_bug(e.span, \"expected a struct or variant def\")\n+                  _ => cx.sess().span_bug(e.span, \"expected a struct, variant, or const fn def\")\n               }\n           }\n-          ast::ExprParen(ref e) => const_expr(cx, &**e, param_substs).0,\n+          ast::ExprMethodCall(_, _, ref args) => {\n+              let arg_vals = map_list(args);\n+              let method_call = ty::MethodCall::expr(e.id);\n+              let method_did = match cx.tcx().method_map.borrow()[&method_call].origin {\n+                  ty::MethodStatic(did) => did,\n+                  _ => cx.sess().span_bug(e.span, \"expected a const method def\")\n+              };\n+              const_fn_call(cx, MethodCallKey(method_call),\n+                            method_did, &arg_vals, param_substs)\n+          }\n+          ast::ExprParen(ref e) => const_expr(cx, &**e, param_substs, fn_args).0,\n           ast::ExprBlock(ref block) => {\n             match block.expr {\n-                Some(ref expr) => const_expr(cx, &**expr, param_substs).0,\n+                Some(ref expr) => const_expr(cx, &**expr, param_substs, fn_args).0,\n                 None => C_nil(cx)\n             }\n           }"}, {"sha": "f9ad3d1a857f11cd751f3e3977a2daa27b472a2e", "filename": "src/librustc_trans/trans/debuginfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fdebuginfo%2Fmod.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -232,7 +232,7 @@ pub fn create_function_debug_context<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             }\n \n             match item.node {\n-                ast::ItemFn(ref fn_decl, _, _, ref generics, ref top_level_block) => {\n+                ast::ItemFn(ref fn_decl, _, _, _, ref generics, ref top_level_block) => {\n                     (item.ident.name, fn_decl, generics, top_level_block, item.span, true)\n                 }\n                 _ => {"}, {"sha": "9a53c3f0bcdf588790a9c23493f4591af07454b3", "filename": "src/librustc_trans/trans/inline.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Finline.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -55,7 +55,7 @@ fn instantiate_inline(ccx: &CrateContext, fn_id: ast::DefId)\n             trans_item(ccx, &**item);\n \n             let linkage = match item.node {\n-                ast::ItemFn(_, _, _, ref generics, _) => {\n+                ast::ItemFn(_, _, _, _, ref generics, _) => {\n                     if generics.is_type_parameterized() {\n                         // Generics have no symbol, so they can't be given any\n                         // linkage."}, {"sha": "d086aa93a6f6b37d891427bd86e8df069b00d9e9", "filename": "src/librustc_trans/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmonomorphize.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -177,7 +177,7 @@ pub fn monomorphic_fn<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n         ast_map::NodeItem(i) => {\n             match *i {\n               ast::Item {\n-                  node: ast::ItemFn(ref decl, _, abi, _, ref body),\n+                  node: ast::ItemFn(ref decl, _, _, abi, _, ref body),\n                   ..\n               } => {\n                   let d = mk_lldecl(abi);"}, {"sha": "24f429a9ca015603094625f221f82afb47f57b04", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -741,7 +741,7 @@ pub fn check_item_type<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n                             &enum_definition.variants,\n                             it.id);\n       }\n-      ast::ItemFn(_, _, _, _, _) => {} // entirely within check_item_body\n+      ast::ItemFn(..) => {} // entirely within check_item_body\n       ast::ItemImpl(_, _, _, _, _, ref impl_items) => {\n           debug!(\"ItemImpl {} with id {}\", token::get_ident(it.ident), it.id);\n           match ty::impl_trait_ref(ccx.tcx, local_def(it.id)) {\n@@ -796,7 +796,7 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n            ty::item_path_str(ccx.tcx, local_def(it.id)));\n     let _indenter = indenter();\n     match it.node {\n-      ast::ItemFn(ref decl, _, _, _, ref body) => {\n+      ast::ItemFn(ref decl, _, _, _, _, ref body) => {\n         let fn_pty = ty::lookup_item_type(ccx.tcx, ast_util::local_def(it.id));\n         let param_env = ParameterEnvironment::for_item(ccx.tcx, it.id);\n         check_bare_fn(ccx, &**decl, &**body, it.id, it.span, fn_pty.ty, param_env);\n@@ -830,11 +830,15 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n                     check_const(ccx, trait_item.span, &*expr, trait_item.id)\n                 }\n                 ast::MethodTraitItem(ref sig, Some(ref body)) => {\n+                    check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n+\n                     check_method_body(ccx, &trait_def.generics, sig, body,\n                                       trait_item.id, trait_item.span);\n                 }\n+                ast::MethodTraitItem(ref sig, None) => {\n+                    check_trait_fn_not_const(ccx, trait_item.span, sig.constness);\n+                }\n                 ast::ConstTraitItem(_, None) |\n-                ast::MethodTraitItem(_, None) |\n                 ast::TypeTraitItem(..) => {\n                     // Nothing to do.\n                 }\n@@ -845,6 +849,20 @@ pub fn check_item_body<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>, it: &'tcx ast::Item) {\n     }\n }\n \n+fn check_trait_fn_not_const<'a,'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n+                                     span: Span,\n+                                     constness: ast::Constness)\n+{\n+    match constness {\n+        ast::Constness::NotConst => {\n+            // good\n+        }\n+        ast::Constness::Const => {\n+            span_err!(ccx.tcx.sess, span, E0379, \"trait fns cannot be declared const\");\n+        }\n+    }\n+}\n+\n fn check_trait_on_unimplemented<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                generics: &ast::Generics,\n                                item: &ast::Item) {\n@@ -966,7 +984,9 @@ fn check_impl_items_against_trait<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     }\n                 }\n             }\n-            ast::MethodImplItem(_, ref body) => {\n+            ast::MethodImplItem(ref sig, ref body) => {\n+                check_trait_fn_not_const(ccx, impl_item.span, sig.constness);\n+\n                 let impl_method_def_id = local_def(impl_item.id);\n                 let impl_item_ty = ty::impl_or_trait_item(ccx.tcx,\n                                                           impl_method_def_id);"}, {"sha": "48876c2a1889a38cefefd5cfc3ae2809c166af30", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -1440,7 +1440,7 @@ fn compute_type_scheme_of_item<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n             let ty = ccx.icx(&()).to_ty(&ExplicitRscope, &**t);\n             ty::TypeScheme { ty: ty, generics: ty::Generics::empty() }\n         }\n-        ast::ItemFn(ref decl, unsafety, abi, ref generics, _) => {\n+        ast::ItemFn(ref decl, unsafety, _, abi, ref generics, _) => {\n             let ty_generics = ty_generics_for_fn(ccx, generics, &ty::Generics::empty());\n             let tofd = astconv::ty_of_bare_fn(&ccx.icx(generics), unsafety, abi, &**decl);\n             let ty = ty::mk_bare_fn(tcx, Some(local_def(it.id)), tcx.mk_bare_fn(tofd));\n@@ -1492,7 +1492,7 @@ fn convert_typed_item<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n         ast::ItemStatic(..) | ast::ItemConst(..) => {\n             ty::GenericPredicates::empty()\n         }\n-        ast::ItemFn(_, _, _, ref ast_generics, _) => {\n+        ast::ItemFn(_, _, _, _, ref ast_generics, _) => {\n             ty_generic_predicates_for_fn(ccx, ast_generics, &ty::GenericPredicates::empty())\n         }\n         ast::ItemTy(_, ref generics) => {"}, {"sha": "5796a5599ce99af1b8d85d8bbdb7e69edc88f1f5", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -1113,6 +1113,7 @@ register_diagnostics! {\n            // fields need coercions\n     E0376, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures\n-    E0377  // the trait `CoerceUnsized` may only be implemented for a coercion\n+    E0377, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with the same definition\n+    E0379  // trait fns cannot be const\n }"}, {"sha": "88ce75486a202711035993347f956f6d13293da0", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -215,7 +215,7 @@ fn check_main_fn_ty(ccx: &CrateCtxt,\n             match tcx.map.find(main_id) {\n                 Some(ast_map::NodeItem(it)) => {\n                     match it.node {\n-                        ast::ItemFn(_, _, _, ref ps, _)\n+                        ast::ItemFn(_, _, _, _, ref ps, _)\n                         if ps.is_parameterized() => {\n                             span_err!(ccx.tcx.sess, main_span, E0131,\n                                       \"main function is not allowed to have type parameters\");\n@@ -262,7 +262,7 @@ fn check_start_fn_ty(ccx: &CrateCtxt,\n             match tcx.map.find(start_id) {\n                 Some(ast_map::NodeItem(it)) => {\n                     match it.node {\n-                        ast::ItemFn(_,_,_,ref ps,_)\n+                        ast::ItemFn(_,_,_,_,ref ps,_)\n                         if ps.is_parameterized() => {\n                             span_err!(tcx.sess, start_span, E0132,\n                                       \"start function is not allowed to have type parameters\");"}, {"sha": "9c64b7b4ab623dcb3aa303e32aff7f6046ff7651", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -175,6 +175,7 @@ fn build_external_function(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) ->\n         decl: decl,\n         generics: (&t.generics, &predicates, subst::FnSpace).clean(cx),\n         unsafety: style,\n+        constness: ast::Constness::NotConst,\n         abi: abi,\n     }\n }\n@@ -348,6 +349,7 @@ pub fn build_impl(cx: &DocContext,\n                     }) => {\n                         clean::MethodItem(clean::Method {\n                             unsafety: unsafety,\n+                            constness: ast::Constness::NotConst,\n                             decl: decl,\n                             self_: self_,\n                             generics: generics,"}, {"sha": "045a38228c68539060d30aa94c06d18724096ab4", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -989,6 +989,7 @@ pub struct Method {\n     pub generics: Generics,\n     pub self_: SelfTy,\n     pub unsafety: ast::Unsafety,\n+    pub constness: ast::Constness,\n     pub decl: FnDecl,\n     pub abi: abi::Abi\n }\n@@ -1010,7 +1011,8 @@ impl Clean<Method> for ast::MethodSig {\n         Method {\n             generics: self.generics.clean(cx),\n             self_: self.explicit_self.node.clean(cx),\n-            unsafety: self.unsafety.clone(),\n+            unsafety: self.unsafety,\n+            constness: self.constness,\n             decl: decl,\n             abi: self.abi\n         }\n@@ -1075,7 +1077,8 @@ pub struct Function {\n     pub decl: FnDecl,\n     pub generics: Generics,\n     pub unsafety: ast::Unsafety,\n-    pub abi: abi::Abi\n+    pub constness: ast::Constness,\n+    pub abi: abi::Abi,\n }\n \n impl Clean<Item> for doctree::Function {\n@@ -1091,6 +1094,7 @@ impl Clean<Item> for doctree::Function {\n                 decl: self.decl.clean(cx),\n                 generics: self.generics.clean(cx),\n                 unsafety: self.unsafety,\n+                constness: self.constness,\n                 abi: self.abi,\n             }),\n         }\n@@ -1348,15 +1352,18 @@ impl<'tcx> Clean<Item> for ty::Method<'tcx> {\n                 generics: generics,\n                 self_: self_,\n                 decl: decl,\n-                abi: self.fty.abi\n+                abi: self.fty.abi,\n+\n+                // trait methods canot (currently, at least) be const\n+                constness: ast::Constness::NotConst,\n             })\n         } else {\n             TyMethodItem(TyMethod {\n                 unsafety: self.fty.unsafety,\n                 generics: generics,\n                 self_: self_,\n                 decl: decl,\n-                abi: self.fty.abi\n+                abi: self.fty.abi,\n             })\n         };\n \n@@ -2453,6 +2460,7 @@ impl Clean<Item> for ast::ForeignItem {\n                     generics: generics.clean(cx),\n                     unsafety: ast::Unsafety::Unsafe,\n                     abi: abi::Rust,\n+                    constness: ast::Constness::NotConst,\n                 })\n             }\n             ast::ForeignItemStatic(ref ty, mutbl) => {"}, {"sha": "cadd43ec6bfd8eee0c380883c677d55603c4bbb4", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -133,6 +133,7 @@ pub struct Function {\n     pub vis: ast::Visibility,\n     pub stab: Option<attr::Stability>,\n     pub unsafety: ast::Unsafety,\n+    pub constness: ast::Constness,\n     pub whence: Span,\n     pub generics: ast::Generics,\n     pub abi: abi::Abi,"}, {"sha": "6e70b3711e4e8d105ef2e55ec6260f290642715c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -35,6 +35,10 @@ pub struct VisSpace(pub Option<ast::Visibility>);\n /// space after it.\n #[derive(Copy, Clone)]\n pub struct UnsafetySpace(pub ast::Unsafety);\n+/// Similarly to VisSpace, this structure is used to render a function constness\n+/// with a space after it.\n+#[derive(Copy, Clone)]\n+pub struct ConstnessSpace(pub ast::Constness);\n /// Wrapper struct for properly emitting a method declaration.\n pub struct Method<'a>(pub &'a clean::SelfTy, pub &'a clean::FnDecl);\n /// Similar to VisSpace, but used for mutability\n@@ -63,6 +67,12 @@ impl UnsafetySpace {\n     }\n }\n \n+impl ConstnessSpace {\n+    pub fn get(&self) -> ast::Constness {\n+        let ConstnessSpace(v) = *self; v\n+    }\n+}\n+\n impl<'a, T: fmt::Display> fmt::Display for CommaSep<'a, T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         for (i, item) in self.0.iter().enumerate() {\n@@ -607,6 +617,15 @@ impl fmt::Display for UnsafetySpace {\n     }\n }\n \n+impl fmt::Display for ConstnessSpace {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match self.get() {\n+            ast::Constness::Const => write!(f, \"const \"),\n+            ast::Constness::NotConst => Ok(())\n+        }\n+    }\n+}\n+\n impl fmt::Display for clean::Import {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match *self {"}, {"sha": "582f17168991ffd2ffd6a6c0fc614bdc8ab49daf", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 20, "deletions": 13, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -63,6 +63,7 @@ use clean;\n use doctree;\n use fold::DocFolder;\n use html::escape::Escape;\n+use html::format::{ConstnessSpace};\n use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::highlight;\n@@ -1753,11 +1754,12 @@ fn item_static(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn item_function(w: &mut fmt::Formatter, it: &clean::Item,\n                  f: &clean::Function) -> fmt::Result {\n-    try!(write!(w, \"<pre class='rust fn'>{vis}{unsafety}{abi}fn \\\n+    try!(write!(w, \"<pre class='rust fn'>{vis}{unsafety}{abi}{constness}fn \\\n                     {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(it.visibility),\n            unsafety = UnsafetySpace(f.unsafety),\n            abi = AbiSpace(f.abi),\n+           constness = ConstnessSpace(f.constness),\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n            where_clause = WhereClause(&f.generics),\n@@ -1957,10 +1959,16 @@ fn assoc_type(w: &mut fmt::Formatter, it: &clean::Item,\n \n fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n                      link: AssocItemLink) -> fmt::Result {\n-    fn method(w: &mut fmt::Formatter, it: &clean::Item,\n-              unsafety: ast::Unsafety, abi: abi::Abi,\n-              g: &clean::Generics, selfty: &clean::SelfTy,\n-              d: &clean::FnDecl, link: AssocItemLink) -> fmt::Result {\n+    fn method(w: &mut fmt::Formatter,\n+              it: &clean::Item,\n+              unsafety: ast::Unsafety,\n+              constness: ast::Constness,\n+              abi: abi::Abi,\n+              g: &clean::Generics,\n+              selfty: &clean::SelfTy,\n+              d: &clean::FnDecl,\n+              link: AssocItemLink)\n+              -> fmt::Result {\n         use syntax::abi::Abi;\n \n         let name = it.name.as_ref().unwrap();\n@@ -1971,12 +1979,10 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n                 href(did).map(|p| format!(\"{}{}\", p.0, anchor)).unwrap_or(anchor)\n             }\n         };\n-        write!(w, \"{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n+        write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n-               match unsafety {\n-                   ast::Unsafety::Unsafe => \"unsafe \",\n-                   _ => \"\",\n-               },\n+               UnsafetySpace(unsafety),\n+               ConstnessSpace(constness),\n                match abi {\n                    Abi::Rust => String::new(),\n                    a => format!(\"extern {} \", a.to_string())\n@@ -1989,11 +1995,12 @@ fn render_assoc_item(w: &mut fmt::Formatter, meth: &clean::Item,\n     }\n     match meth.inner {\n         clean::TyMethodItem(ref m) => {\n-            method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl,\n-                   link)\n+            method(w, meth, m.unsafety, ast::Constness::NotConst,\n+                   m.abi, &m.generics, &m.self_, &m.decl, link)\n         }\n         clean::MethodItem(ref m) => {\n-            method(w, meth, m.unsafety, m.abi, &m.generics, &m.self_, &m.decl,\n+            method(w, meth, m.unsafety, m.constness,\n+                   m.abi, &m.generics, &m.self_, &m.decl,\n                    link)\n         }\n         clean::AssociatedConstItem(ref ty, ref default) => {"}, {"sha": "e86d77a3be03e0350135dd29b1e1f15b14a375c0", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -123,7 +123,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n     pub fn visit_fn(&mut self, item: &ast::Item,\n                     name: ast::Ident, fd: &ast::FnDecl,\n-                    unsafety: &ast::Unsafety, abi: &abi::Abi,\n+                    unsafety: &ast::Unsafety,\n+                    constness: ast::Constness,\n+                    abi: &abi::Abi,\n                     gen: &ast::Generics) -> Function {\n         debug!(\"Visiting fn\");\n         Function {\n@@ -136,6 +138,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             whence: item.span,\n             generics: gen.clone(),\n             unsafety: *unsafety,\n+            constness: constness,\n             abi: *abi,\n         }\n     }\n@@ -291,8 +294,9 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.enums.push(self.visit_enum_def(item, name, ed, gen)),\n             ast::ItemStruct(ref sd, ref gen) =>\n                 om.structs.push(self.visit_struct_def(item, name, &**sd, gen)),\n-            ast::ItemFn(ref fd, ref pur, ref abi, ref gen, _) =>\n-                om.fns.push(self.visit_fn(item, name, &**fd, pur, abi, gen)),\n+            ast::ItemFn(ref fd, ref unsafety, constness, ref abi, ref gen, _) =>\n+                om.fns.push(self.visit_fn(item, name, &**fd, unsafety,\n+                                          constness, abi, gen)),\n             ast::ItemTy(ref ty, ref gen) => {\n                 let t = Typedef {\n                     ty: ty.clone(),"}, {"sha": "5b03b3bf0385c1daa4f66a2089723bcc74ea0136", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -1215,6 +1215,7 @@ pub struct TypeField {\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct MethodSig {\n     pub unsafety: Unsafety,\n+    pub constness: Constness,\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n@@ -1475,6 +1476,12 @@ pub enum Unsafety {\n     Normal,\n }\n \n+#[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n+pub enum Constness {\n+    Const,\n+    NotConst,\n+}\n+\n impl fmt::Display for Unsafety {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         fmt::Display::fmt(match *self {\n@@ -1761,7 +1768,7 @@ pub enum Item_ {\n     /// A `const` item\n     ItemConst(P<Ty>, P<Expr>),\n     /// A function declaration\n-    ItemFn(P<FnDecl>, Unsafety, Abi, Generics, P<Block>),\n+    ItemFn(P<FnDecl>, Unsafety, Constness, Abi, Generics, P<Block>),\n     /// A module\n     ItemMod(Mod),\n     /// An external module"}, {"sha": "99686d54ce5893ca638ed4c1257ba0fc19c865ff", "filename": "src/libsyntax/ast_map/blocks.rs", "status": "modified", "additions": 36, "deletions": 19, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fast_map%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_map%2Fblocks.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -96,20 +96,10 @@ impl<'a> Code<'a> {\n \n     /// Attempts to construct a Code from presumed FnLike or Block node input.\n     pub fn from_node(node: Node) -> Option<Code> {\n-        fn new(node: Node) -> FnLikeNode { FnLikeNode { node: node } }\n-        match node {\n-            ast_map::NodeItem(item) if item.is_fn_like() =>\n-                Some(FnLikeCode(new(node))),\n-            ast_map::NodeTraitItem(tm) if tm.is_fn_like() =>\n-                Some(FnLikeCode(new(node))),\n-            ast_map::NodeImplItem(_) =>\n-                Some(FnLikeCode(new(node))),\n-            ast_map::NodeExpr(e) if e.is_fn_like() =>\n-                Some(FnLikeCode(new(node))),\n-            ast_map::NodeBlock(block) =>\n-                Some(BlockCode(block)),\n-            _ =>\n-                None,\n+        if let ast_map::NodeBlock(block) = node {\n+            Some(BlockCode(block))\n+        } else {\n+            FnLikeNode::from_node(node).map(|fn_like| FnLikeCode(fn_like))\n         }\n     }\n }\n@@ -120,6 +110,7 @@ struct ItemFnParts<'a> {\n     ident:    ast::Ident,\n     decl:     &'a ast::FnDecl,\n     unsafety: ast::Unsafety,\n+    constness: ast::Constness,\n     abi:      abi::Abi,\n     vis:      ast::Visibility,\n     generics: &'a ast::Generics,\n@@ -144,6 +135,24 @@ impl<'a> ClosureParts<'a> {\n }\n \n impl<'a> FnLikeNode<'a> {\n+    /// Attempts to construct a FnLikeNode from presumed FnLike node input.\n+    pub fn from_node(node: Node) -> Option<FnLikeNode> {\n+        let fn_like = match node {\n+            ast_map::NodeItem(item) => item.is_fn_like(),\n+            ast_map::NodeTraitItem(tm) => tm.is_fn_like(),\n+            ast_map::NodeImplItem(_) => true,\n+            ast_map::NodeExpr(e) => e.is_fn_like(),\n+            _ => false\n+        };\n+        if fn_like {\n+            Some(FnLikeNode {\n+                node: node\n+            })\n+        } else {\n+            None\n+        }\n+    }\n+\n     pub fn to_fn_parts(self) -> FnParts<'a> {\n         FnParts {\n             decl: self.decl(),\n@@ -180,7 +189,7 @@ impl<'a> FnLikeNode<'a> {\n \n     pub fn kind(self) -> visit::FnKind<'a> {\n         let item = |p: ItemFnParts<'a>| -> visit::FnKind<'a> {\n-            visit::FkItemFn(p.ident, p.generics, p.unsafety, p.abi, p.vis)\n+            visit::FkItemFn(p.ident, p.generics, p.unsafety, p.constness, p.abi, p.vis)\n         };\n         let closure = |_: ClosureParts| {\n             visit::FkFnBlock\n@@ -204,10 +213,18 @@ impl<'a> FnLikeNode<'a> {\n     {\n         match self.node {\n             ast_map::NodeItem(i) => match i.node {\n-                ast::ItemFn(ref decl, unsafety, abi, ref generics, ref block) =>\n-                    item_fn(ItemFnParts{\n-                        ident: i.ident, decl: &**decl, unsafety: unsafety, body: &**block,\n-                        generics: generics, abi: abi, vis: i.vis, id: i.id, span: i.span\n+                ast::ItemFn(ref decl, unsafety, constness, abi, ref generics, ref block) =>\n+                    item_fn(ItemFnParts {\n+                        id: i.id,\n+                        ident: i.ident,\n+                        decl: &**decl,\n+                        unsafety: unsafety,\n+                        body: &**block,\n+                        generics: generics,\n+                        abi: abi,\n+                        vis: i.vis,\n+                        constness: constness,\n+                        span: i.span\n                     }),\n                 _ => panic!(\"item FnLikeNode that is not fn-like\"),\n             },"}, {"sha": "bb8096f2770693b5f23aa9bdc2cc993523a074bc", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -440,7 +440,7 @@ impl<'a, 'v, O: IdVisitingOperation> Visitor<'v> for IdVisitor<'a, O> {\n         self.operation.visit_id(node_id);\n \n         match function_kind {\n-            visit::FkItemFn(_, generics, _, _, _) => {\n+            visit::FkItemFn(_, generics, _, _, _, _) => {\n                 self.visit_generics_helper(generics)\n             }\n             visit::FkMethod(_, sig, _) => {"}, {"sha": "8a80e291a538405f38c11e9911be3d3421fa855c", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -1034,6 +1034,7 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n                   Vec::new(),\n                   ast::ItemFn(self.fn_decl(inputs, output),\n                               ast::Unsafety::Normal,\n+                              ast::Constness::NotConst,\n                               abi::Rust,\n                               generics,\n                               body))"}, {"sha": "eab6c3ae7251a1f41a2e58e7baacce72b966aca5", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -880,6 +880,7 @@ impl<'a> MethodDef<'a> {\n                 abi: abi,\n                 explicit_self: explicit_self,\n                 unsafety: unsafety,\n+                constness: ast::Constness::NotConst,\n                 decl: fn_decl\n             }, body_block)\n         })"}, {"sha": "aa74c27dc616a747250e2b1f263299e3ade01df0", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -513,11 +513,12 @@ pub fn expand_item(it: P<ast::Item>, fld: &mut MacroExpander)\n /// Expand item_underscore\n fn expand_item_underscore(item: ast::Item_, fld: &mut MacroExpander) -> ast::Item_ {\n     match item {\n-        ast::ItemFn(decl, fn_style, abi, generics, body) => {\n+        ast::ItemFn(decl, unsafety, constness, abi, generics, body) => {\n             let (rewritten_fn_decl, rewritten_body)\n                 = expand_and_rename_fn_decl_and_block(decl, body, fld);\n             let expanded_generics = fold::noop_fold_generics(generics,fld);\n-            ast::ItemFn(rewritten_fn_decl, fn_style, abi, expanded_generics, rewritten_body)\n+            ast::ItemFn(rewritten_fn_decl, unsafety, constness, abi,\n+                        expanded_generics, rewritten_body)\n         }\n         _ => noop_fold_item_underscore(item, fld)\n     }\n@@ -1395,6 +1396,7 @@ fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n         abi: sig.abi,\n         explicit_self: fld.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n+        constness: sig.constness,\n         decl: rewritten_fn_decl\n     }, rewritten_body)\n }"}, {"sha": "1177ebdc5315cf3f1135991d357ffdc112f1369c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -155,6 +155,9 @@ const KNOWN_FEATURES: &'static [(&'static str, &'static str, Status)] = &[\n     // Allows the definition of associated constants in `trait` or `impl`\n     // blocks.\n     (\"associated_consts\", \"1.0.0\", Active),\n+\n+    // Allows the definition of `const fn` functions.\n+    (\"const_fn\", \"1.2.0\", Active),\n ];\n // (changing above list without updating src/doc/reference.md makes @cmr sad)\n \n@@ -656,13 +659,26 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                 block: &'v ast::Block,\n                 span: Span,\n                 _node_id: NodeId) {\n+        // check for const fn declarations\n+        match fn_kind {\n+            visit::FkItemFn(_, _, _, ast::Constness::Const, _, _) => {\n+                self.gate_feature(\"const_fn\", span, \"const fn is unstable\");\n+            }\n+            _ => {\n+                // stability of const fn methods are covered in\n+                // visit_trait_item and visit_impl_item below; this is\n+                // because default methods don't pass through this\n+                // point.\n+            }\n+        }\n+\n         match fn_kind {\n-            visit::FkItemFn(_, _, _, abi, _) if abi == Abi::RustIntrinsic => {\n+            visit::FkItemFn(_, _, _, _, abi, _) if abi == Abi::RustIntrinsic => {\n                 self.gate_feature(\"intrinsics\",\n                                   span,\n                                   \"intrinsics are subject to change\")\n             }\n-            visit::FkItemFn(_, _, _, abi, _) |\n+            visit::FkItemFn(_, _, _, _, abi, _) |\n             visit::FkMethod(_, &ast::MethodSig { abi, .. }, _) if abi == Abi::RustCall => {\n                 self.gate_feature(\"unboxed_closures\",\n                                   span,\n@@ -680,6 +696,11 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   ti.span,\n                                   \"associated constants are experimental\")\n             }\n+            ast::MethodTraitItem(ref sig, _) => {\n+                if sig.constness == ast::Constness::Const {\n+                    self.gate_feature(\"const_fn\", ti.span, \"const fn is unstable\");\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_trait_item(self, ti);\n@@ -692,6 +713,11 @@ impl<'a, 'v> Visitor<'v> for PostExpansionVisitor<'a> {\n                                   ii.span,\n                                   \"associated constants are experimental\")\n             }\n+            ast::MethodImplItem(ref sig, _) => {\n+                if sig.constness == ast::Constness::Const {\n+                    self.gate_feature(\"const_fn\", ii.span, \"const fn is unstable\");\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_impl_item(self, ii);"}, {"sha": "7806a27c53e1c622500064631bb3917d71718080", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -917,10 +917,11 @@ pub fn noop_fold_item_underscore<T: Folder>(i: Item_, folder: &mut T) -> Item_ {\n         ItemConst(t, e) => {\n             ItemConst(folder.fold_ty(t), folder.fold_expr(e))\n         }\n-        ItemFn(decl, unsafety, abi, generics, body) => {\n+        ItemFn(decl, unsafety, constness, abi, generics, body) => {\n             ItemFn(\n                 folder.fold_fn_decl(decl),\n                 unsafety,\n+                constness,\n                 abi,\n                 folder.fold_generics(generics),\n                 folder.fold_block(body)\n@@ -1124,6 +1125,7 @@ pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> Method\n         abi: sig.abi,\n         explicit_self: folder.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n+        constness: sig.constness,\n         decl: folder.fold_fn_decl(sig.decl)\n     }\n }"}, {"sha": "d6c28d414479206c6ffadda2634647082fbd8b48", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -923,6 +923,7 @@ mod tests {\n                                 variadic: false\n                             }),\n                                     ast::Unsafety::Normal,\n+                                    ast::Constness::NotConst,\n                                     abi::Rust,\n                                     ast::Generics{ // no idea on either of these:\n                                         lifetimes: Vec::new(),"}, {"sha": "eb6420165dab7b4194f22ea253d7ebe2abfffe20", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 64, "deletions": 23, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -17,7 +17,7 @@ use ast::{Public, Unsafety};\n use ast::{Mod, BiAdd, Arg, Arm, Attribute, BindByRef, BindByValue};\n use ast::{BiBitAnd, BiBitOr, BiBitXor, BiRem, BiLt, BiGt, Block};\n use ast::{BlockCheckMode, CaptureByRef, CaptureByValue, CaptureClause};\n-use ast::{ConstImplItem, ConstTraitItem, Crate, CrateConfig};\n+use ast::{Constness, ConstImplItem, ConstTraitItem, Crate, CrateConfig};\n use ast::{Decl, DeclItem, DeclLocal, DefaultBlock, DefaultReturn};\n use ast::{UnDeref, BiDiv, EMPTY_CTXT, EnumDef, ExplicitSelf};\n use ast::{Expr, Expr_, ExprAddrOf, ExprMatch, ExprAgain};\n@@ -1160,7 +1160,8 @@ impl<'a> Parser<'a> {\n                 let TyParam {ident, bounds, default, ..} = try!(p.parse_ty_param());\n                 try!(p.expect(&token::Semi));\n                 (ident, TypeTraitItem(bounds, default))\n-            } else if try!(p.eat_keyword(keywords::Const)) {\n+            } else if p.is_const_item() {\n+                try!(p.expect_keyword(keywords::Const));\n                 let ident = try!(p.parse_ident());\n                 try!(p.expect(&token::Colon));\n                 let ty = try!(p.parse_ty_sum());\n@@ -1175,13 +1176,7 @@ impl<'a> Parser<'a> {\n                 };\n                 (ident, ConstTraitItem(ty, default))\n             } else {\n-                let style = try!(p.parse_unsafety());\n-                let abi = if try!(p.eat_keyword(keywords::Extern)) {\n-                    try!(p.parse_opt_abi()).unwrap_or(abi::C)\n-                } else {\n-                    abi::Rust\n-                };\n-                try!(p.expect_keyword(keywords::Fn));\n+                let (constness, unsafety, abi) = try!(p.parse_fn_front_matter());\n \n                 let ident = try!(p.parse_ident());\n                 let mut generics = try!(p.parse_generics());\n@@ -1195,7 +1190,8 @@ impl<'a> Parser<'a> {\n \n                 generics.where_clause = try!(p.parse_where_clause());\n                 let sig = ast::MethodSig {\n-                    unsafety: style,\n+                    unsafety: unsafety,\n+                    constness: constness,\n                     decl: d,\n                     generics: generics,\n                     abi: abi,\n@@ -4359,12 +4355,46 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse an item-position function declaration.\n-    fn parse_item_fn(&mut self, unsafety: Unsafety, abi: abi::Abi) -> PResult<ItemInfo> {\n+    fn parse_item_fn(&mut self,\n+                     unsafety: Unsafety,\n+                     constness: Constness,\n+                     abi: abi::Abi)\n+                     -> PResult<ItemInfo> {\n         let (ident, mut generics) = try!(self.parse_fn_header());\n         let decl = try!(self.parse_fn_decl(false));\n         generics.where_clause = try!(self.parse_where_clause());\n         let (inner_attrs, body) = try!(self.parse_inner_attrs_and_block());\n-        Ok((ident, ItemFn(decl, unsafety, abi, generics, body), Some(inner_attrs)))\n+        Ok((ident, ItemFn(decl, unsafety, constness, abi, generics, body), Some(inner_attrs)))\n+    }\n+\n+    /// true if we are looking at `const ID`, false for things like `const fn` etc\n+    pub fn is_const_item(&mut self) -> bool {\n+        self.token.is_keyword(keywords::Const) &&\n+            !self.look_ahead(1, |t| t.is_keyword(keywords::Fn))\n+    }\n+\n+    /// parses all the \"front matter\" for a `fn` declaration, up to\n+    /// and including the `fn` keyword:\n+    ///\n+    /// - `const fn`\n+    /// - `unsafe fn`\n+    /// - `extern fn`\n+    /// - etc\n+    pub fn parse_fn_front_matter(&mut self) -> PResult<(ast::Constness, ast::Unsafety, abi::Abi)> {\n+        let is_const_fn = try!(self.eat_keyword(keywords::Const));\n+        let (constness, unsafety, abi) = if is_const_fn {\n+            (Constness::Const, Unsafety::Normal, abi::Rust)\n+        } else {\n+            let unsafety = try!(self.parse_unsafety());\n+            let abi = if try!(self.eat_keyword(keywords::Extern)) {\n+                try!(self.parse_opt_abi()).unwrap_or(abi::C)\n+            } else {\n+                abi::Rust\n+            };\n+            (Constness::NotConst, unsafety, abi)\n+        };\n+        try!(self.expect_keyword(keywords::Fn));\n+        Ok((constness, unsafety, abi))\n     }\n \n     /// Parse an impl item.\n@@ -4380,7 +4410,8 @@ impl<'a> Parser<'a> {\n             let typ = try!(self.parse_ty_sum());\n             try!(self.expect(&token::Semi));\n             (name, TypeImplItem(typ))\n-        } else if try!(self.eat_keyword(keywords::Const)) {\n+        } else if self.is_const_item() {\n+            try!(self.expect_keyword(keywords::Const));\n             let name = try!(self.parse_ident());\n             try!(self.expect(&token::Colon));\n             let typ = try!(self.parse_ty_sum());\n@@ -4445,13 +4476,7 @@ impl<'a> Parser<'a> {\n             }\n             Ok((token::special_idents::invalid, vec![], ast::MacImplItem(m)))\n         } else {\n-            let unsafety = try!(self.parse_unsafety());\n-            let abi = if try!(self.eat_keyword(keywords::Extern)) {\n-                try!(self.parse_opt_abi()).unwrap_or(abi::C)\n-            } else {\n-                abi::Rust\n-            };\n-            try!(self.expect_keyword(keywords::Fn));\n+            let (constness, unsafety, abi) = try!(self.parse_fn_front_matter());\n             let ident = try!(self.parse_ident());\n             let mut generics = try!(self.parse_generics());\n             let (explicit_self, decl) = try!(self.parse_fn_decl_with_self(|p| {\n@@ -4464,6 +4489,7 @@ impl<'a> Parser<'a> {\n                 abi: abi,\n                 explicit_self: explicit_self,\n                 unsafety: unsafety,\n+                constness: constness,\n                 decl: decl\n              }, body)))\n         }\n@@ -5252,7 +5278,7 @@ impl<'a> Parser<'a> {\n                 // EXTERN FUNCTION ITEM\n                 let abi = opt_abi.unwrap_or(abi::C);\n                 let (ident, item_, extra_attrs) =\n-                    try!(self.parse_item_fn(Unsafety::Normal, abi));\n+                    try!(self.parse_item_fn(Unsafety::Normal, Constness::NotConst, abi));\n                 let last_span = self.last_span;\n                 let item = self.mk_item(lo,\n                                         last_span.hi,\n@@ -5287,6 +5313,21 @@ impl<'a> Parser<'a> {\n             return Ok(Some(item));\n         }\n         if try!(self.eat_keyword(keywords::Const) ){\n+            if self.check_keyword(keywords::Fn) {\n+                // CONST FUNCTION ITEM\n+                try!(self.bump());\n+                let (ident, item_, extra_attrs) =\n+                    try!(self.parse_item_fn(Unsafety::Normal, Constness::Const, abi::Rust));\n+                let last_span = self.last_span;\n+                let item = self.mk_item(lo,\n+                                        last_span.hi,\n+                                        ident,\n+                                        item_,\n+                                        visibility,\n+                                        maybe_append(attrs, extra_attrs));\n+                return Ok(Some(item));\n+            }\n+\n             // CONST ITEM\n             if try!(self.eat_keyword(keywords::Mut) ){\n                 let last_span = self.last_span;\n@@ -5340,7 +5381,7 @@ impl<'a> Parser<'a> {\n             // FUNCTION ITEM\n             try!(self.bump());\n             let (ident, item_, extra_attrs) =\n-                try!(self.parse_item_fn(Unsafety::Normal, abi::Rust));\n+                try!(self.parse_item_fn(Unsafety::Normal, Constness::NotConst, abi::Rust));\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,\n@@ -5361,7 +5402,7 @@ impl<'a> Parser<'a> {\n             };\n             try!(self.expect_keyword(keywords::Fn));\n             let (ident, item_, extra_attrs) =\n-                try!(self.parse_item_fn(Unsafety::Unsafe, abi));\n+                try!(self.parse_item_fn(Unsafety::Unsafe, Constness::NotConst, abi));\n             let last_span = self.last_span;\n             let item = self.mk_item(lo,\n                                     last_span.hi,"}, {"sha": "8958370fda544e6fb5554a05effae11c09decbee", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 32, "deletions": 11, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -378,12 +378,16 @@ pub fn ident_to_string(id: &ast::Ident) -> String {\n     to_string(|s| s.print_ident(*id))\n }\n \n-pub fn fun_to_string(decl: &ast::FnDecl, unsafety: ast::Unsafety, name: ast::Ident,\n-                  opt_explicit_self: Option<&ast::ExplicitSelf_>,\n-                  generics: &ast::Generics) -> String {\n+pub fn fun_to_string(decl: &ast::FnDecl,\n+                     unsafety: ast::Unsafety,\n+                     constness: ast::Constness,\n+                     name: ast::Ident,\n+                     opt_explicit_self: Option<&ast::ExplicitSelf_>,\n+                     generics: &ast::Generics)\n+                     -> String {\n     to_string(|s| {\n         try!(s.head(\"\"));\n-        try!(s.print_fn(decl, unsafety, abi::Rust, Some(name),\n+        try!(s.print_fn(decl, unsafety, constness, abi::Rust, Some(name),\n                         generics, opt_explicit_self, ast::Inherited));\n         try!(s.end()); // Close the head box\n         s.end() // Close the outer box\n@@ -740,7 +744,8 @@ impl<'a> State<'a> {\n         match item.node {\n             ast::ForeignItemFn(ref decl, ref generics) => {\n                 try!(self.head(\"\"));\n-                try!(self.print_fn(&**decl, ast::Unsafety::Normal,\n+                try!(self.print_fn(decl, ast::Unsafety::Normal,\n+                                   ast::Constness::NotConst,\n                                    abi::Rust, Some(item.ident),\n                                    generics, None, item.vis));\n                 try!(self.end()); // end head-ibox\n@@ -866,11 +871,12 @@ impl<'a> State<'a> {\n                 try!(word(&mut self.s, \";\"));\n                 try!(self.end()); // end the outer cbox\n             }\n-            ast::ItemFn(ref decl, unsafety, abi, ref typarams, ref body) => {\n+            ast::ItemFn(ref decl, unsafety, constness, abi, ref typarams, ref body) => {\n                 try!(self.head(\"\"));\n                 try!(self.print_fn(\n                     decl,\n                     unsafety,\n+                    constness,\n                     abi,\n                     Some(item.ident),\n                     typarams,\n@@ -1241,6 +1247,7 @@ impl<'a> State<'a> {\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n+                      m.constness,\n                       m.abi,\n                       Some(ident),\n                       &m.generics,\n@@ -2335,12 +2342,13 @@ impl<'a> State<'a> {\n     pub fn print_fn(&mut self,\n                     decl: &ast::FnDecl,\n                     unsafety: ast::Unsafety,\n+                    constness: ast::Constness,\n                     abi: abi::Abi,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n                     opt_explicit_self: Option<&ast::ExplicitSelf_>,\n                     vis: ast::Visibility) -> io::Result<()> {\n-        try!(self.print_fn_header_info(unsafety, abi, vis));\n+        try!(self.print_fn_header_info(unsafety, constness, abi, vis));\n \n         if let Some(name) = name {\n             try!(self.nbsp());\n@@ -2726,8 +2734,13 @@ impl<'a> State<'a> {\n                 predicates: Vec::new(),\n             },\n         };\n-        try!(self.print_fn(decl, unsafety, abi, name,\n-                           &generics, opt_explicit_self,\n+        try!(self.print_fn(decl,\n+                           unsafety,\n+                           ast::Constness::NotConst,\n+                           abi,\n+                           name,\n+                           &generics,\n+                           opt_explicit_self,\n                            ast::Inherited));\n         self.end()\n     }\n@@ -2976,11 +2989,17 @@ impl<'a> State<'a> {\n \n     pub fn print_fn_header_info(&mut self,\n                                 unsafety: ast::Unsafety,\n+                                constness: ast::Constness,\n                                 abi: abi::Abi,\n                                 vis: ast::Visibility) -> io::Result<()> {\n         try!(word(&mut self.s, &visibility_qualified(vis, \"\")));\n         try!(self.print_unsafety(unsafety));\n \n+        match constness {\n+            ast::Constness::NotConst => {}\n+            ast::Constness::Const => try!(self.word_nbsp(\"const\"))\n+        }\n+\n         if abi != abi::Rust {\n             try!(self.word_nbsp(\"extern\"));\n             try!(self.word_nbsp(&abi.to_string()));\n@@ -3018,8 +3037,10 @@ mod tests {\n             variadic: false\n         };\n         let generics = ast_util::empty_generics();\n-        assert_eq!(fun_to_string(&decl, ast::Unsafety::Normal, abba_ident,\n-                               None, &generics),\n+        assert_eq!(fun_to_string(&decl, ast::Unsafety::Normal,\n+                                 ast::Constness::NotConst,\n+                                 abba_ident,\n+                                 None, &generics),\n                    \"fn abba()\");\n     }\n "}, {"sha": "c680d5bbbdf7ad24581aacf11fd08e6b97edc0a3", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -123,7 +123,7 @@ impl<'a> fold::Folder for TestHarnessGenerator<'a> {\n \n         let i = if is_test_fn(&self.cx, &*i) || is_bench_fn(&self.cx, &*i) {\n             match i.node {\n-                ast::ItemFn(_, ast::Unsafety::Unsafe, _, _, _) => {\n+                ast::ItemFn(_, ast::Unsafety::Unsafe, _, _, _, _) => {\n                     let diag = self.cx.span_diagnostic;\n                     panic!(diag.span_fatal(i.span, \"unsafe functions cannot be used for tests\"));\n                 }\n@@ -320,7 +320,7 @@ fn is_test_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n     fn has_test_signature(i: &ast::Item) -> HasTestSignature {\n         match &i.node {\n-          &ast::ItemFn(ref decl, _, _, ref generics, _) => {\n+          &ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n             let no_output = match decl.output {\n                 ast::DefaultReturn(..) => true,\n                 ast::Return(ref t) if t.node == ast::TyTup(vec![]) => true,\n@@ -356,7 +356,7 @@ fn is_bench_fn(cx: &TestCtxt, i: &ast::Item) -> bool {\n \n     fn has_test_signature(i: &ast::Item) -> bool {\n         match i.node {\n-            ast::ItemFn(ref decl, _, _, ref generics, _) => {\n+            ast::ItemFn(ref decl, _, _, _, ref generics, _) => {\n                 let input_cnt = decl.inputs.len();\n                 let no_output = match decl.output {\n                     ast::DefaultReturn(..) => true,\n@@ -469,7 +469,9 @@ fn mk_main(cx: &mut TestCtxt) -> P<ast::Item> {\n     let main_ret_ty = ecx.ty(sp, ast::TyTup(vec![]));\n     let main_body = ecx.block_all(sp, vec![call_test_main], None);\n     let main = ast::ItemFn(ecx.fn_decl(vec![], main_ret_ty),\n-                           ast::Unsafety::Normal, ::abi::Rust, empty_generics(), main_body);\n+                           ast::Unsafety::Normal,\n+                           ast::Constness::NotConst,\n+                           ::abi::Rust, empty_generics(), main_body);\n     let main = P(ast::Item {\n         ident: token::str_to_ident(\"main\"),\n         attrs: vec![main_attr],"}, {"sha": "61fddd6bed801d813a51d75fe4f9912706dbfdf3", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -35,7 +35,7 @@ use owned_slice::OwnedSlice;\n #[derive(Copy, Clone)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    FkItemFn(Ident, &'a Generics, Unsafety, Abi, Visibility),\n+    FkItemFn(Ident, &'a Generics, Unsafety, Constness, Abi, Visibility),\n \n     /// fn foo(&self)\n     FkMethod(Ident, &'a MethodSig, Option<Visibility>),\n@@ -246,8 +246,9 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n             visitor.visit_ty(&**typ);\n             visitor.visit_expr(&**expr);\n         }\n-        ItemFn(ref declaration, fn_style, abi, ref generics, ref body) => {\n-            visitor.visit_fn(FkItemFn(item.ident, generics, fn_style, abi, item.vis),\n+        ItemFn(ref declaration, unsafety, constness, abi, ref generics, ref body) => {\n+            visitor.visit_fn(FkItemFn(item.ident, generics, unsafety,\n+                                      constness, abi, item.vis),\n                              &**declaration,\n                              &**body,\n                              item.span,\n@@ -604,7 +605,7 @@ pub fn walk_fn<'v, V: Visitor<'v>>(visitor: &mut V,\n     walk_fn_decl(visitor, function_declaration);\n \n     match function_kind {\n-        FkItemFn(_, generics, _, _, _) => {\n+        FkItemFn(_, generics, _, _, _, _) => {\n             visitor.visit_generics(generics);\n         }\n         FkMethod(_, sig, _) => {"}, {"sha": "c3a1de11752f813460c1d33e622a576893d23a5a", "filename": "src/test/compile-fail/check-static-values-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fcheck-static-values-constraints.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -117,7 +117,7 @@ static mut STATIC14: SafeStruct = SafeStruct {\n //~^ ERROR mutable statics are not allowed to have destructors\n     field1: SafeEnum::Variant1,\n     field2: SafeEnum::Variant4(\"str\".to_string())\n-//~^ ERROR static contains unimplemented expression type\n+//~^ ERROR method calls in statics are limited to constant inherent methods\n };\n \n static STATIC15: &'static [Box<MyOwned>] = &["}, {"sha": "d813cf32954e3349edcbfe5c1e21a7d3bb6af584", "filename": "src/test/compile-fail/const-fn-mismatch.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-mismatch.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can't declare a const fn in an impl -- right now it's\n+// just not allowed at all, though eventually it'd make sense to allow\n+// it if the trait fn is const (but right now no trait fns can be\n+// const).\n+\n+#![feature(const_fn)]\n+\n+trait Foo {\n+    fn f() -> u32;\n+}\n+\n+impl Foo for u32 {\n+    const fn f() -> u32 { 22 } //~ ERROR E0379\n+}\n+\n+fn main() { }"}, {"sha": "191f3e025270fd7c23b2911c3a7790a296ea059e", "filename": "src/test/compile-fail/const-fn-not-in-trait.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-in-trait.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that const fn is illegal in a trait declaration, whether or\n+// not a default is provided.\n+\n+#![feature(const_fn)]\n+\n+trait Foo {\n+    const fn f() -> u32; //~ ERROR trait fns cannot be declared const\n+    const fn g() -> u32 { 0 } //~ ERROR trait fns cannot be declared const\n+}\n+\n+fn main() { }"}, {"sha": "baa3eba06805facb90af3a3a33d8956dce186b3b", "filename": "src/test/compile-fail/const-fn-not-safe-for-const.rs", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-not-safe-for-const.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -0,0 +1,47 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test that we can't call random fns in a const fn or do other bad things.\n+\n+#![feature(const_fn)]\n+\n+use std::mem::transmute;\n+\n+fn random() -> u32 { 0 }\n+\n+const fn sub(x: &u32) -> usize {\n+    unsafe { transmute(x) } //~ ERROR E0015\n+}\n+\n+const fn sub1() -> u32 {\n+    random() //~ ERROR E0015\n+}\n+\n+static Y: u32 = 0;\n+\n+const fn get_Y() -> u32 {\n+    Y\n+        //~^ ERROR E0013\n+        //~| ERROR cannot refer to other statics by value\n+}\n+\n+const fn get_Y_addr() -> &'static u32 {\n+    &Y\n+        //~^ ERROR E0013\n+}\n+\n+const fn get() -> u32 {\n+    let x = 22; //~ ERROR E0016\n+    let y = 44; //~ ERROR E0016\n+    x + y\n+}\n+\n+fn main() {\n+}"}, {"sha": "8aa5189bcd6bb844a18db0734725470d48c2c7c2", "filename": "src/test/compile-fail/const-fn-stability.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-fn-stability.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test use of const fn without feature gate.\n+\n+const fn foo() -> usize { 0 } //~ ERROR const fn is unstable\n+\n+trait Foo {\n+    const fn foo() -> u32; //~ ERROR const fn is unstable\n+    const fn bar() -> u32 { 0 } //~ ERROR const fn is unstable\n+}\n+\n+impl Foo {\n+    const fn baz() -> u32 { 0 } //~ ERROR const fn is unstable\n+}\n+\n+impl Foo for u32 {\n+    const fn foo() -> u32 { 0 } //~ ERROR const fn is unstable\n+}\n+\n+fn main() { }"}, {"sha": "2b53e92d9bce6b63b3a510bfed7e096c146e1f93", "filename": "src/test/compile-fail/issue-16538.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16538.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -20,6 +20,6 @@ mod Y {\n \n static foo: *const Y::X = Y::foo(Y::x as *const Y::X);\n //~^ ERROR the trait `core::marker::Sync` is not implemented for the type\n-//~| ERROR function calls in statics are limited to struct and enum constructors\n+//~| ERROR E0015\n \n fn main() {}"}, {"sha": "5d85fe93a48886905c4aefa49ae204690569f79a", "filename": "src/test/compile-fail/issue-7364.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-7364.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -17,6 +17,6 @@ static boxed: Box<RefCell<isize>> = box RefCell::new(0);\n //~^ ERROR allocations are not allowed in statics\n //~| ERROR the trait `core::marker::Sync` is not implemented for the type\n //~| ERROR the trait `core::marker::Sync` is not implemented for the type\n-//~| ERROR function calls in statics are limited to struct and enum constructors\n+//~| ERROR E0015\n \n fn main() { }"}, {"sha": "a533a5bd54dccdd3d5d5b3b17463a458a41ee521", "filename": "src/test/compile-fail/static-vec-repeat-not-constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fstatic-vec-repeat-not-constant.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -11,6 +11,6 @@\n fn foo() -> isize { 23 }\n \n static a: [isize; 2] = [foo(); 2];\n-//~^ ERROR: function calls in statics are limited to struct and enum constructors\n+//~^ ERROR: E0015\n \n fn main() {}"}, {"sha": "86f5dedc4d1b1fdc5717999ab855fc1bc5d88d9c", "filename": "src/test/run-pass/const-fn-nested.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Frun-pass%2Fconst-fn-nested.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Frun-pass%2Fconst-fn-nested.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn-nested.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Test a call whose argument is the result of another call.\n+\n+#![feature(const_fn)]\n+\n+const fn sub(x: u32, y: u32) -> u32 {\n+    x - y\n+}\n+\n+const X: u32 = sub(sub(88, 44), 22);\n+\n+fn main() {\n+    assert_eq!(X, 22);\n+}"}, {"sha": "9bd8eb55cc388351f937a64e4bf4dd0cad349afb", "filename": "src/test/run-pass/const-fn.rs", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Frun-pass%2Fconst-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba0e1cd8147d452c356aacb29fb87568ca26f111/src%2Ftest%2Frun-pass%2Fconst-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fconst-fn.rs?ref=ba0e1cd8147d452c356aacb29fb87568ca26f111", "patch": "@@ -0,0 +1,32 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// A very basic test of const fn functionality.\n+\n+#![feature(const_fn)]\n+\n+const fn add(x: u32, y: u32) -> u32 {\n+    x + y\n+}\n+\n+const fn sub(x: u32, y: u32) -> u32 {\n+    x - y\n+}\n+\n+const SUM: u32 = add(44, 22);\n+const DIFF: u32 = sub(44, 22);\n+\n+fn main() {\n+    assert_eq!(SUM, 66);\n+    assert!(SUM != 88);\n+\n+    assert_eq!(DIFF, 22);\n+\n+}"}]}