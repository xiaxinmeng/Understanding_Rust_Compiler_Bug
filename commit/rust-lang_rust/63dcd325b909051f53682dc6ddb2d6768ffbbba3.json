{"sha": "63dcd325b909051f53682dc6ddb2d6768ffbbba3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYzZGNkMzI1YjkwOTA1MWY1MzY4MmRjNmRkYjJkNjc2OGZmYmJiYTM=", "commit": {"author": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-30T01:47:47Z"}, "committer": {"name": "Eric Holk", "email": "eholk@mozilla.com", "date": "2011-06-30T01:47:47Z"}, "message": "Adding support for pinning tasks to the currently running thread. Closes #598.", "tree": {"sha": "6bdf31fb67f6efc4f0f358a727a0053121e63780", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6bdf31fb67f6efc4f0f358a727a0053121e63780"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/63dcd325b909051f53682dc6ddb2d6768ffbbba3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/63dcd325b909051f53682dc6ddb2d6768ffbbba3", "html_url": "https://github.com/rust-lang/rust/commit/63dcd325b909051f53682dc6ddb2d6768ffbbba3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/63dcd325b909051f53682dc6ddb2d6768ffbbba3/comments", "author": null, "committer": null, "parents": [{"sha": "afabde19dcdae41fa60df37b4aa049f4dfe6ee5f", "url": "https://api.github.com/repos/rust-lang/rust/commits/afabde19dcdae41fa60df37b4aa049f4dfe6ee5f", "html_url": "https://github.com/rust-lang/rust/commit/afabde19dcdae41fa60df37b4aa049f4dfe6ee5f"}], "stats": {"total": 84, "additions": 67, "deletions": 17}, "files": [{"sha": "f15bdade360f1b68fb8a5727bb3b30f396258178", "filename": "src/lib/task.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Flib%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Flib%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Ftask.rs?ref=63dcd325b909051f53682dc6ddb2d6768ffbbba3", "patch": "@@ -2,6 +2,8 @@ native \"rust\" mod rustrt {\n     fn task_sleep(uint time_in_us);\n     fn task_yield();\n     fn task_join(task t);\n+    fn pin_task();\n+    fn unpin_task();\n }\n \n /**\n@@ -21,6 +23,14 @@ fn join(task t) {\n     ret rustrt::task_join(t);\n }\n \n+fn pin() {\n+    rustrt::pin_task();\n+}\n+\n+fn unpin() {\n+    rustrt::unpin_task();\n+}\n+\n // Local Variables:\n // mode: rust;\n // fill-column: 78;"}, {"sha": "5b5844fc13507d96a8268b5ca5302d5c01768905", "filename": "src/rt/rust_builtin.cpp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_builtin.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_builtin.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_builtin.cpp?ref=63dcd325b909051f53682dc6ddb2d6768ffbbba3", "patch": "@@ -700,6 +700,15 @@ ivec_copy_from_buf(rust_task *task, type_desc *ty, rust_ivec *v, void *ptr,\n     v->payload.ptr->fill = new_size;\n }\n \n+extern \"C\" void\n+pin_task(rust_task *task) {\n+    task->pin();\n+}\n+\n+extern \"C\" void\n+unpin_task(rust_task *task) {\n+    task->unpin();\n+}\n \n //\n // Local Variables:"}, {"sha": "740667340cdebbe34993d775a14a947b88abaabb", "filename": "src/rt/rust_scheduler.cpp", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_scheduler.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_scheduler.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.cpp?ref=63dcd325b909051f53682dc6ddb2d6768ffbbba3", "patch": "@@ -83,12 +83,12 @@ rust_scheduler::number_of_live_tasks() {\n  * Delete any dead tasks.\n  */\n void\n-rust_scheduler::reap_dead_tasks() {\n+rust_scheduler::reap_dead_tasks(int id) {\n     I(this, kernel->scheduler_lock.lock_held_by_current_thread());\n     for (size_t i = 0; i < dead_tasks.length(); ) {\n         rust_task *task = dead_tasks[i];\n         // Make sure this task isn't still running somewhere else...\n-        if (task->ref_count == 0 && task->can_schedule()) {\n+        if (task->ref_count == 0 && task->can_schedule(id)) {\n             I(this, task->tasks_waiting_to_join.is_empty());\n             dead_tasks.remove(task);\n             DLOG(this, task,\n@@ -124,7 +124,7 @@ void rust_scheduler::drain_incoming_message_queue(bool process) {\n  * Returns NULL if no tasks can be scheduled.\n  */\n rust_task *\n-rust_scheduler::schedule_task() {\n+rust_scheduler::schedule_task(int id) {\n     I(this, this);\n     // FIXME: in the face of failing tasks, this is not always right.\n     // I(this, n_live_tasks() > 0);\n@@ -133,7 +133,7 @@ rust_scheduler::schedule_task() {\n         // Look around for a runnable task, starting at k.\n         for(size_t j = 0; j < running_tasks.length(); ++j) {\n             size_t  i = (j + k) % running_tasks.length();\n-            if (running_tasks[i]->can_schedule()) {\n+            if (running_tasks[i]->can_schedule(id)) {\n                 return (rust_task *)running_tasks[i];\n             }\n         }\n@@ -202,7 +202,7 @@ rust_scheduler::start_main_loop(int id) {\n \n         drain_incoming_message_queue(true);\n \n-        rust_task *scheduled_task = schedule_task();\n+        rust_task *scheduled_task = schedule_task(id);\n \n         // The scheduler busy waits until a task is available for scheduling.\n         // Eventually we'll want a smarter way to do this, perhaps sleep\n@@ -239,10 +239,9 @@ rust_scheduler::start_main_loop(int id) {\n         DLOG(this, task,\n              \"Running task %p on worker %d\",\n              scheduled_task, id);\n-        I(this, !scheduled_task->active);\n-        scheduled_task->active = true;\n+        scheduled_task->running_on = id;\n         activate(scheduled_task);\n-        scheduled_task->active = false;\n+        scheduled_task->running_on = -1;\n \n         DLOG(this, task,\n              \"returned from task %s @0x%\" PRIxPTR\n@@ -253,7 +252,7 @@ rust_scheduler::start_main_loop(int id) {\n              scheduled_task->rust_sp,\n              id);\n \n-        reap_dead_tasks();\n+        reap_dead_tasks(id);\n     }\n \n     DLOG(this, dom,\n@@ -272,7 +271,7 @@ rust_scheduler::start_main_loop(int id) {\n         } else {\n             drain_incoming_message_queue(true);\n         }\n-        reap_dead_tasks();\n+        reap_dead_tasks(id);\n     }\n \n     DLOG(this, dom, \"finished main-loop %d (dom.rval = %d)\", id, rval);"}, {"sha": "5a00f934216fc49fa2292915115daee47b59b68d", "filename": "src/rt/rust_scheduler.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_scheduler.h", "raw_url": "https://github.com/rust-lang/rust/raw/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_scheduler.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_scheduler.h?ref=63dcd325b909051f53682dc6ddb2d6768ffbbba3", "patch": "@@ -79,8 +79,8 @@ struct rust_scheduler : public kernel_owned<rust_scheduler>,\n     rust_crate_cache *get_cache();\n     size_t number_of_live_tasks();\n \n-    void reap_dead_tasks();\n-    rust_task *schedule_task();\n+    void reap_dead_tasks(int id);\n+    rust_task *schedule_task(int id);\n \n     int start_main_loop(int id);\n "}, {"sha": "46c9aebe6cfe751960d887e7de58e09b4a4ad5c8", "filename": "src/rt/rust_task.cpp", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_task.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_task.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.cpp?ref=63dcd325b909051f53682dc6ddb2d6768ffbbba3", "patch": "@@ -70,7 +70,8 @@ rust_task::rust_task(rust_scheduler *sched, rust_task_list *state,\n     list_index(-1),\n     rendezvous_ptr(0),\n     handle(NULL),\n-    active(false),\n+    running_on(-1),\n+    pinned_on(-1),\n     local_region(&sched->srv->local_region),\n     synchronized_region(&sched->srv->synchronized_region)\n {\n@@ -471,9 +472,11 @@ rust_task::get_handle() {\n     return handle;\n }\n \n-bool rust_task::can_schedule()\n+bool rust_task::can_schedule(int id)\n {\n-    return yield_timer.has_timed_out() && !active;\n+    return yield_timer.has_timed_out() && \n+        running_on == -1 &&\n+        (pinned_on == -1 || pinned_on == id);\n }\n \n void *\n@@ -524,6 +527,14 @@ rust_task::free(void *mem, memory_region::memory_region_type type) {\n     return;\n }\n \n+void rust_task::pin() {\n+    pinned_on = running_on;\n+}\n+\n+void rust_task::unpin() {\n+    pinned_on = -1;\n+}\n+\n //\n // Local Variables:\n // mode: C++"}, {"sha": "428e3c1399321c5204c747a06ba8e8cd7571d617", "filename": "src/rt/rust_task.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_task.h", "raw_url": "https://github.com/rust-lang/rust/raw/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frust_task.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_task.h?ref=63dcd325b909051f53682dc6ddb2d6768ffbbba3", "patch": "@@ -77,7 +77,8 @@ rust_task : public maybe_proxy<rust_task>,\n     \n     // This flag indicates that a worker is either currently running the task\n     // or is about to run this task.\n-    volatile bool active;\n+    int running_on;\n+    int pinned_on;\n \n     memory_region local_region;\n     memory_region synchronized_region;\n@@ -143,14 +144,17 @@ rust_task : public maybe_proxy<rust_task>,\n     frame_glue_fns *get_frame_glue_fns(uintptr_t fp);\n     rust_crate_cache * get_crate_cache();\n \n-    bool can_schedule();\n+    bool can_schedule(int worker);\n \n     void *malloc(size_t size, memory_region::memory_region_type type);\n     void *calloc(size_t size);\n     void *calloc(size_t size, memory_region::memory_region_type type);\n     void *realloc(void *mem, size_t size,\n         memory_region::memory_region_type type);\n     void free(void *mem, memory_region::memory_region_type type);\n+\n+    void pin();\n+    void unpin();\n };\n \n //"}, {"sha": "38c5151319091b0a27c55d77c2d363b1d9387e33", "filename": "src/rt/rustrt.def.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frustrt.def.in", "raw_url": "https://github.com/rust-lang/rust/raw/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Frt%2Frustrt.def.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frustrt.def.in?ref=63dcd325b909051f53682dc6ddb2d6768ffbbba3", "patch": "@@ -15,6 +15,8 @@ ivec_on_heap\n ivec_reserve\n ivec_to_ptr\n last_os_error\n+pin_task\n+unpin_task\n rand_free\n rand_new\n rand_next"}, {"sha": "d2c4e144b94f63c3d3bed1f543c99f5c873962f5", "filename": "src/test/run-pass/task-pin.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Ftest%2Frun-pass%2Ftask-pin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/63dcd325b909051f53682dc6ddb2d6768ffbbba3/src%2Ftest%2Frun-pass%2Ftask-pin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftask-pin.rs?ref=63dcd325b909051f53682dc6ddb2d6768ffbbba3", "patch": "@@ -0,0 +1,15 @@\n+// xfail-stage0\n+\n+/**\n+   Exercises task pinning and unpinning. Doesn't really ensure it\n+   works, just makes sure it runs.\n+*/\n+\n+use std;\n+\n+import std::task;\n+\n+fn main() {\n+    task::pin();\n+    task::unpin();\n+}\n\\ No newline at end of file"}]}