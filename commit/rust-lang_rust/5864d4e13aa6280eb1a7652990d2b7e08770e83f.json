{"sha": "5864d4e13aa6280eb1a7652990d2b7e08770e83f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU4NjRkNGUxM2FhNjI4MGViMWE3NjUyOTkwZDJiN2UwODc3MGU4M2Y=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-22T09:31:43Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-07-22T09:38:30Z"}, "message": "Report unresolved names only once per function\n\nCloses #708", "tree": {"sha": "7a83d0cbeab78f3198ec5a897b28c07bac863168", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7a83d0cbeab78f3198ec5a897b28c07bac863168"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5864d4e13aa6280eb1a7652990d2b7e08770e83f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5864d4e13aa6280eb1a7652990d2b7e08770e83f", "html_url": "https://github.com/rust-lang/rust/commit/5864d4e13aa6280eb1a7652990d2b7e08770e83f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5864d4e13aa6280eb1a7652990d2b7e08770e83f/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc33897525480e5401e82081e1931693b309fa4b", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc33897525480e5401e82081e1931693b309fa4b", "html_url": "https://github.com/rust-lang/rust/commit/bc33897525480e5401e82081e1931693b309fa4b"}], "stats": {"total": 84, "additions": 52, "deletions": 32}, "files": [{"sha": "f00a53b4bfb2c47cb9bc24d6af9f7fdaffb4b87e", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 52, "deletions": 32, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/5864d4e13aa6280eb1a7652990d2b7e08770e83f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5864d4e13aa6280eb1a7652990d2b7e08770e83f/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=5864d4e13aa6280eb1a7652990d2b7e08770e83f", "patch": "@@ -27,6 +27,7 @@ import std::list::list;\n import std::list::nil;\n import std::list::cons;\n import std::option;\n+import std::option::is_none;\n import std::option::some;\n import std::option::none;\n import std::str;\n@@ -89,7 +90,6 @@ tag mod_index_entry {\n     mie_item(@ast::item);\n     mie_native_item(@ast::native_item);\n     mie_tag_variant(@ast::item /* tag item */, uint /* variant index */);\n-\n }\n \n type mod_index = hashmap[ident, list[mod_index_entry]];\n@@ -117,6 +117,7 @@ type env =\n         hashmap[ast::node_id, @indexed_mod] mod_map,\n         hashmap[def_id, ident[]] ext_map,\n         ext_hash ext_cache,\n+        mutable tup(str, scope)[] reported,\n         session sess);\n \n \n@@ -136,6 +137,7 @@ fn resolve_crate(session sess, &ast_map::map amap, @ast::crate crate)\n              mod_map=new_int_hash[@indexed_mod](),\n              ext_map=new_def_hash[ident[]](),\n              ext_cache=new_ext_hash(),\n+             mutable reported=~[],\n              sess=sess);\n     map_crate(e, crate);\n     resolve_imports(*e);\n@@ -386,7 +388,7 @@ fn follow_import(&env e, &scopes sc, &ident[] path, &span sp)\n     auto i = 1u;\n     while (true && option::is_some(dcur)) {\n         if (i == path_len) { break; }\n-        dcur = lookup_in_mod_strict(e, option::get(dcur),\n+        dcur = lookup_in_mod_strict(e, sc, option::get(dcur),\n                                     sp, path.(i), ns_module, outside);\n         i += 1u;\n     }\n@@ -424,7 +426,7 @@ fn resolve_constr(@env e, node_id id, &@ast::constr c, &scopes sc,\n }\n \n // Import resolution\n-fn resolve_import(&env e, &@ast::view_item it, scopes sc) {\n+fn resolve_import(&env e, &@ast::view_item it, &scopes sc_in) {\n     auto defid;\n     auto ids;\n     auto name;\n@@ -439,11 +441,10 @@ fn resolve_import(&env e, &@ast::view_item it, scopes sc) {\n     auto n_idents = ivec::len(ids);\n     auto end_id = ids.(n_idents - 1u);\n     // Ignore the current scope if this import would shadow itself.\n-    if (str::eq(name, ids.(0))) {\n-        sc = std::list::cdr(sc);\n-    }\n+    auto sc = if str::eq(name, ids.(0)) { std::list::cdr(sc_in) }\n+              else { sc_in };\n     if (n_idents == 1u) {\n-        register(e, defid, it.span, end_id,\n+        register(e, defid, it.span, end_id, sc_in,\n                  lookup_in_scope(e, sc, it.span, end_id, ns_value),\n                  lookup_in_scope(e, sc, it.span, end_id, ns_type),\n                  lookup_in_scope(e, sc, it.span, end_id, ns_module));\n@@ -454,15 +455,15 @@ fn resolve_import(&env e, &@ast::view_item it, scopes sc) {\n                 dcur\n             }\n             case (none) {\n-                unresolved_err(e, it.span, ids.(0), ns_name(ns_module));\n+                unresolved_err(e, sc, it.span, ids.(0), ns_name(ns_module));\n                 remove_if_unresolved(e.imports, defid._1);\n                 ret () // FIXME (issue #521)\n             }\n         };\n         auto i = 1u;\n         while (true) {\n             if (i == n_idents - 1u) {\n-                register(e, defid, it.span, end_id,\n+                register(e, defid, it.span, end_id, sc_in,\n                          lookup_in_mod(e, dcur, it.span, end_id, ns_value,\n                                        outside),\n                          lookup_in_mod(e, dcur, it.span, end_id, ns_type,\n@@ -478,7 +479,7 @@ fn resolve_import(&env e, &@ast::view_item it, scopes sc) {\n                         dcur\n                     }\n                     case (none) {\n-                        unresolved_err(e, it.span, ids.(i),\n+                        unresolved_err(e, sc, it.span, ids.(i),\n                                        ns_name(ns_module));\n                         remove_if_unresolved(e.imports, defid._1);\n                         ret () // FIXME (issue #521)\n@@ -488,12 +489,11 @@ fn resolve_import(&env e, &@ast::view_item it, scopes sc) {\n             }\n         }\n     }\n-    fn register(&env e, def_id defid, &span sp, &ident name,\n+    fn register(&env e, def_id defid, &span sp, &ident name, &scopes sc,\n                 &option::t[def] val, &option::t[def] typ,\n                 &option::t[def] md) {\n-        if (option::is_none(val) && option::is_none(typ) &&\n-                option::is_none(md)) {\n-            unresolved_err(e, sp, name, \"import\");\n+        if is_none(val) && is_none(typ) && is_none(md) {\n+            unresolved_err(e, sc, sp, name, \"import\");\n         } else {\n             e.imports.insert(defid._1, resolved(val, typ, md));\n         }\n@@ -524,7 +524,28 @@ fn ns_name(namespace ns) -> str {\n     }\n }\n \n-fn unresolved_err(&env e, &span sp, &ident name, &str kind) {\n+fn unresolved_err(&env e, &scopes sc, &span sp, &ident name, &str kind) {\n+    fn find_fn_or_mod_scope(scopes sc) -> scope {\n+        while true {\n+            alt sc {\n+              cons(?cur, ?rest) {\n+                alt cur {\n+                  scope_crate | scope_fn(_, _) |\n+                  scope_item(@{node: ast::item_mod(_), _}) {\n+                    ret cur;\n+                  }\n+                  _ { sc = *rest; }\n+                }\n+              }\n+            }\n+        }\n+        fail;\n+    }\n+    auto err_scope = find_fn_or_mod_scope(sc);\n+    for (tup(str, scope) rs in e.reported) {\n+        if str::eq(rs._0, name) && err_scope == rs._1 { ret; }\n+    }\n+    e.reported += ~[tup(name, err_scope)];\n     e.sess.span_err(sp, mk_unresolved_msg(name, kind));\n }\n \n@@ -555,7 +576,7 @@ fn lookup_path_strict(&env e, &scopes sc, &span sp, &ast::path_ pth,\n     auto i = 1u;\n     while (i < n_idents && option::is_some(dcur)) {\n         auto curns = if (n_idents == i + 1u) { ns } else { ns_module };\n-        dcur = lookup_in_mod_strict(e, option::get(dcur),\n+        dcur = lookup_in_mod_strict(e, sc, option::get(dcur),\n                                     sp, pth.idents.(i), curns, outside);\n         i += 1u;\n     }\n@@ -566,7 +587,7 @@ fn lookup_in_scope_strict(&env e, scopes sc, &span sp, &ident name,\n                           namespace ns) -> option::t[def] {\n     alt (lookup_in_scope(e, sc, sp, name, ns)) {\n         case (none) {\n-            unresolved_err(e, sp, name, ns_name(ns));\n+            unresolved_err(e, sc, sp, name, ns_name(ns));\n             ret none;\n         }\n         case (some(?d)) { ret some(d); }\n@@ -662,7 +683,7 @@ fn lookup_in_scope(&env e, scopes sc, &span sp, &ident name, namespace ns) ->\n             case (nil) { ret none[def]; }\n             case (cons(?hd, ?tl)) {\n                 auto fnd = in_scope(e, sp, name, hd, ns);\n-                if (!option::is_none(fnd)) {\n+                if (!is_none(fnd)) {\n                     auto df = option::get(fnd);\n                     if (left_fn && def_is_local(df) ||\n                         left_fn_level2 && def_is_obj_field(df)\n@@ -713,13 +734,13 @@ fn lookup_in_pat(&ident name, &ast::pat pat) -> option::t[def] {\n         case (ast::pat_tag(_, ?pats)) {\n             for (@ast::pat p in pats) {\n                 auto found = lookup_in_pat(name, *p);\n-                if (!option::is_none(found)) { ret found; }\n+                if (!is_none(found)) { ret found; }\n             }\n         }\n         case (ast::pat_rec(?fields, _)) {\n             for (ast::field_pat f in fields) {\n                 auto found = lookup_in_pat(name, *f.pat);\n-                if (!option::is_none(found)) { ret found; }\n+                if (!is_none(found)) { ret found; }\n             }\n         }\n         case (ast::pat_box(?inner)) { ret lookup_in_pat(name, *inner); }\n@@ -793,7 +814,7 @@ fn lookup_in_block(&ident name, &ast::block_ b, namespace ns) ->\n                             case (_) {\n                                 if (str::eq(it.ident, name)) {\n                                     auto found = found_def_item(it, ns);\n-                                    if (!option::is_none(found)) {\n+                                    if (!is_none(found)) {\n                                         ret found;\n                                     }\n                                 }\n@@ -861,11 +882,11 @@ fn found_def_item(&@ast::item i, namespace ns) -> option::t[def] {\n     ret none[def];\n }\n \n-fn lookup_in_mod_strict(&env e, def m, &span sp, &ident name, namespace ns,\n-                        dir dr) -> option::t[def] {\n+fn lookup_in_mod_strict(&env e, &scopes sc, def m, &span sp, &ident name,\n+                        namespace ns, dir dr) -> option::t[def] {\n     alt (lookup_in_mod(e, m, sp, name, ns, dr)) {\n         case (none) {\n-            unresolved_err(e, sp, name, ns_name(ns));\n+            unresolved_err(e, sc, sp, name, ns_name(ns));\n             ret none;\n         }\n         case (some(?d)) { ret some(d); }\n@@ -879,11 +900,11 @@ fn lookup_in_mod(&env e, &def m, &span sp, &ident name, namespace ns,\n         // examining a module in an external crate\n \n         auto cached = e.ext_cache.find(tup(defid, name, ns));\n-        if (!option::is_none(cached)) { ret cached; }\n+        if (!is_none(cached)) { ret cached; }\n         auto path = ~[name];\n         if (defid._1 != -1) { path = e.ext_map.get(defid) + path; }\n         auto fnd = lookup_external(e, defid._0, path, ns);\n-        if (!option::is_none(fnd)) {\n+        if (!is_none(fnd)) {\n             e.ext_cache.insert(tup(defid, name, ns), option::get(fnd));\n         }\n         ret fnd;\n@@ -958,7 +979,7 @@ fn lookup_in_local_mod(&env e, node_id node_id, &span sp, &ident id,\n                     case (nil) { break; }\n                     case (cons(?hd, ?tl)) {\n                         auto found = lookup_in_mie(e, hd, ns);\n-                        if (!option::is_none(found)) { ret found; }\n+                        if (!is_none(found)) { ret found; }\n                         lst = *tl;\n                     }\n                 }\n@@ -1196,17 +1217,17 @@ fn check_mod_name(&env e, &ident name, list[mod_index_entry] entries) {\n     while (true) {\n         alt (entries) {\n             case (cons(?entry, ?rest)) {\n-                if (!option::is_none(lookup_in_mie(e, entry, ns_value))) {\n+                if (!is_none(lookup_in_mie(e, entry, ns_value))) {\n                     if (saw_value) {\n                         dup(e, mie_span(entry), \"\", name);\n                     } else { saw_value = true; }\n                 }\n-                if (!option::is_none(lookup_in_mie(e, entry, ns_type))) {\n+                if (!is_none(lookup_in_mie(e, entry, ns_type))) {\n                     if (saw_type) {\n                         dup(e, mie_span(entry), \"type \", name);\n                     } else { saw_type = true; }\n                 }\n-                if (!option::is_none(lookup_in_mie(e, entry, ns_module))) {\n+                if (!is_none(lookup_in_mie(e, entry, ns_module))) {\n                     if (saw_mod) {\n                         dup(e, mie_span(entry), \"module \", name);\n                     } else { saw_mod = true; }\n@@ -1283,8 +1304,7 @@ fn check_arm(@env e, &ast::arm a, &() x, &vt[()] v) {\n                             \"inconsistent number of bindings\");\n         } else {\n             for (ident name in ch.seen) {\n-                if (option::is_none(ivec::find(bind str::eq(name, _),\n-                                               seen0))) {\n+                if (is_none(ivec::find(bind str::eq(name, _), seen0))) {\n                     // Fight the alias checker\n                     auto name_ = name;\n                     e.sess.span_err"}]}