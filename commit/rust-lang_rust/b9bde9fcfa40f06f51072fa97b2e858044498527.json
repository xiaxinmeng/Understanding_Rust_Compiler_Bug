{"sha": "b9bde9fcfa40f06f51072fa97b2e858044498527", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI5YmRlOWZjZmE0MGYwNmY1MTA3MmZhOTdiMmU4NTgwNDQ0OTg1Mjc=", "commit": {"author": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-21T19:04:52Z"}, "committer": {"name": "Patrick Walton", "email": "pcwalton@mimiga.net", "date": "2011-03-21T19:04:52Z"}, "message": "Merge branch 'ty-serialization'", "tree": {"sha": "3ec3a19c0e5a005284304ec1f3e51380f203072b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3ec3a19c0e5a005284304ec1f3e51380f203072b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b9bde9fcfa40f06f51072fa97b2e858044498527", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b9bde9fcfa40f06f51072fa97b2e858044498527", "html_url": "https://github.com/rust-lang/rust/commit/b9bde9fcfa40f06f51072fa97b2e858044498527", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b9bde9fcfa40f06f51072fa97b2e858044498527/comments", "author": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pcwalton", "id": 157897, "node_id": "MDQ6VXNlcjE1Nzg5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/157897?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pcwalton", "html_url": "https://github.com/pcwalton", "followers_url": "https://api.github.com/users/pcwalton/followers", "following_url": "https://api.github.com/users/pcwalton/following{/other_user}", "gists_url": "https://api.github.com/users/pcwalton/gists{/gist_id}", "starred_url": "https://api.github.com/users/pcwalton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pcwalton/subscriptions", "organizations_url": "https://api.github.com/users/pcwalton/orgs", "repos_url": "https://api.github.com/users/pcwalton/repos", "events_url": "https://api.github.com/users/pcwalton/events{/privacy}", "received_events_url": "https://api.github.com/users/pcwalton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5caa310e4ab803d9f467d1541b7f6eeb7361f54", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5caa310e4ab803d9f467d1541b7f6eeb7361f54", "html_url": "https://github.com/rust-lang/rust/commit/a5caa310e4ab803d9f467d1541b7f6eeb7361f54"}, {"sha": "3dec5b5e5096c33e9790d133372bcd9bc2ee8889", "url": "https://api.github.com/repos/rust-lang/rust/commits/3dec5b5e5096c33e9790d133372bcd9bc2ee8889", "html_url": "https://github.com/rust-lang/rust/commit/3dec5b5e5096c33e9790d133372bcd9bc2ee8889"}], "stats": {"total": 300, "additions": 300, "deletions": 0}, "files": [{"sha": "42bc51304068946a6c30bb5f9ef15c4bca147f8f", "filename": "src/comp/front/creader.rs", "status": "modified", "additions": 184, "deletions": 0, "changes": 184, "blob_url": "https://github.com/rust-lang/rust/blob/b9bde9fcfa40f06f51072fa97b2e858044498527/src%2Fcomp%2Ffront%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9bde9fcfa40f06f51072fa97b2e858044498527/src%2Fcomp%2Ffront%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fcreader.rs?ref=b9bde9fcfa40f06f51072fa97b2e858044498527", "patch": "@@ -6,11 +6,14 @@ import lib.llvm.llvmext;\n import lib.llvm.mk_object_file;\n import lib.llvm.mk_section_iter;\n import middle.fold;\n+import middle.ty;\n import util.common;\n import util.common.span;\n \n import std._str;\n+import std._vec;\n import std.fs;\n+import std.option;\n import std.os;\n import std.map.hashmap;\n \n@@ -20,6 +23,187 @@ type env = @rec(\n     vec[str] library_search_paths\n );\n \n+// Type decoding\n+\n+// Compact string representation for ty.t values. API ty_str & parse_from_str.\n+// (The second has to be authed pure.) Extra parameters are for converting\n+// to/from def_ids in the string rep. Whatever format you choose should not\n+// contain pipe characters.\n+\n+// Callback to translate defs to strs or back.\n+type str_def = fn(str) -> ast.def_id;\n+\n+type pstate = rec(str rep, mutable uint pos, uint len);\n+\n+fn peek(@pstate st) -> u8 {\n+    if (st.pos < st.len) {ret st.rep.(st.pos) as u8;}\n+    else {ret ' ' as u8;}\n+}\n+impure fn next(@pstate st) -> u8 { // ?? somehow not recognized as impure\n+    if (st.pos >= st.len) {fail;}\n+    auto ch = st.rep.(st.pos);\n+    st.pos = st.pos + 1u;\n+    ret ch as u8;\n+}\n+\n+impure fn parse_ty_str(str rep, str_def sd) -> @ty.t {\n+    auto len = _str.byte_len(rep);\n+    auto st = @rec(rep=rep, mutable pos=0u, len=len);\n+    auto result = parse_ty(st, sd);\n+    check(st.pos == len);\n+    ret result;\n+}\n+\n+impure fn parse_ty(@pstate st, str_def sd) -> @ty.t {\n+    ret @rec(struct=parse_sty(st, sd),\n+             cname=option.none[str]);\n+}\n+\n+impure fn parse_mt(@pstate st, str_def sd) -> ty.mt {\n+    auto mut;\n+    alt (peek(st) as char) {\n+        case ('m') {next(st); mut = ast.mut;}\n+        case ('?') {next(st); mut = ast.maybe_mut;}\n+        case (_)   {mut=ast.imm;}\n+    }\n+    ret rec(ty=parse_ty(st, sd), mut=mut);\n+}\n+\n+impure fn parse_sty(@pstate st, str_def sd) -> ty.sty {\n+    alt (next(st) as char) {\n+        case ('n') {ret ty.ty_nil;}\n+        case ('b') {ret ty.ty_bool;}\n+        case ('i') {ret ty.ty_int;}\n+        case ('u') {ret ty.ty_uint;}\n+        case ('M') {\n+            alt (next(st) as char) {\n+                case ('b') {ret ty.ty_machine(common.ty_u8);}\n+                case ('w') {ret ty.ty_machine(common.ty_u16);}\n+                case ('l') {ret ty.ty_machine(common.ty_u32);}\n+                case ('d') {ret ty.ty_machine(common.ty_u64);}\n+                case ('B') {ret ty.ty_machine(common.ty_i8);}\n+                case ('W') {ret ty.ty_machine(common.ty_i16);}\n+                case ('L') {ret ty.ty_machine(common.ty_i32);}\n+                case ('D') {ret ty.ty_machine(common.ty_i64);}\n+                case ('f') {ret ty.ty_machine(common.ty_f32);}\n+                case ('F') {ret ty.ty_machine(common.ty_f64);}\n+            }\n+        }\n+        case ('c') {ret ty.ty_char;}\n+        case ('s') {ret ty.ty_str;}\n+        case ('t') {\n+            check(next(st) as char == '[');\n+            auto def = \"\";\n+            while (peek(st) as char != '|') {\n+                def += _str.unsafe_from_byte(next(st));\n+            }\n+            st.pos = st.pos + 1u;\n+            let vec[@ty.t] params = vec();\n+            while (peek(st) as char != ']') {\n+                params += vec(parse_ty(st, sd));\n+            }\n+            st.pos = st.pos + 1u;\n+            ret ty.ty_tag(sd(def), params);\n+        }      \n+        case ('@') {ret ty.ty_box(parse_mt(st, sd));}\n+        case ('V') {ret ty.ty_vec(parse_mt(st, sd));}\n+        case ('P') {ret ty.ty_port(parse_ty(st, sd));}\n+        case ('C') {ret ty.ty_chan(parse_ty(st, sd));}\n+        case ('T') {\n+            check(next(st) as char == '[');\n+            let vec[ty.mt] params = vec();\n+            while (peek(st) as char != ']') {\n+                params += vec(parse_mt(st, sd));\n+            }\n+            st.pos = st.pos + 1u;\n+            ret ty.ty_tup(params);\n+        }\n+        case ('R') {\n+            check(next(st) as char == '[');\n+            let vec[ty.field] fields = vec();\n+            while (peek(st) as char != ']') {\n+                auto name = \"\";\n+                while (peek(st) as char != '=') {\n+                    name += _str.unsafe_from_byte(next(st));\n+                }\n+                st.pos = st.pos + 1u;\n+                fields += vec(rec(ident=name, mt=parse_mt(st, sd)));\n+            }\n+            st.pos = st.pos + 1u;\n+            ret ty.ty_rec(fields);\n+        }\n+        case ('F') {\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty.ty_fn(ast.proto_fn, func._0, func._1);\n+        }\n+        case ('W') {\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty.ty_fn(ast.proto_iter, func._0, func._1);\n+        }\n+        case ('N') {\n+            auto abi;\n+            alt (next(st) as char) {\n+                case ('r') {abi = ast.native_abi_rust;}\n+                case ('c') {abi = ast.native_abi_cdecl;}\n+            }\n+            auto func = parse_ty_fn(st, sd);\n+            ret ty.ty_native_fn(abi,func._0,func._1);\n+        }\n+        case ('O') {\n+            check(next(st) as char == '[');\n+            let vec[ty.method] methods = vec();\n+            while (peek(st) as char != ']') {\n+                auto proto;\n+                alt (next(st) as char) {\n+                    case ('W') {proto = ast.proto_iter;}\n+                    case ('F') {proto = ast.proto_fn;}\n+                }\n+                auto name = \"\";\n+                while (peek(st) as char != '[') {\n+                    name += _str.unsafe_from_byte(next(st));\n+                }\n+                auto func = parse_ty_fn(st, sd);\n+                methods += vec(rec(proto=proto,\n+                                   ident=name,\n+                                   inputs=func._0,\n+                                   output=func._1));\n+            }\n+            ret ty.ty_obj(methods);\n+        }\n+        case ('X') {ret ty.ty_var(parse_int(st));}\n+        case ('E') {ret ty.ty_native;}\n+    }\n+}\n+\n+impure fn parse_int(@pstate st) -> int {\n+    auto n = 0;\n+    while (true) {\n+        auto cur = peek(st) as char;\n+        if (cur < '0' || cur > '9') {break;}\n+        st.pos = st.pos + 1u;\n+        n *= 10;\n+        n += (cur as int) - ('0' as int);\n+    }\n+    ret n;\n+}\n+\n+impure fn parse_ty_fn(@pstate st, str_def sd) -> tup(vec[ty.arg], @ty.t) {\n+    check(next(st) as char == '[');\n+    let vec[ty.arg] inputs = vec();\n+    while (peek(st) as char != ']') {\n+        auto mode = ast.val;\n+        if (peek(st) as char == '&') {\n+            mode = ast.alias;\n+            st.pos = st.pos + 1u;\n+        }\n+        inputs += vec(rec(mode=mode, ty=parse_ty(st, sd)));\n+    }\n+    st.pos = st.pos + 1u;\n+    ret tup(inputs, parse_ty(st, sd));\n+}\n+\n+\n+\n // TODO: return something\n fn load_crate(ast.ident ident, vec[str] library_search_paths) -> @() {\n     for (str library_search_path in library_search_paths) {"}, {"sha": "06b527de89e0362cef9254cda190c42e826edddb", "filename": "src/comp/middle/metadata.rs", "status": "modified", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/b9bde9fcfa40f06f51072fa97b2e858044498527/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b9bde9fcfa40f06f51072fa97b2e858044498527/src%2Fcomp%2Fmiddle%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fmetadata.rs?ref=b9bde9fcfa40f06f51072fa97b2e858044498527", "patch": "@@ -1,12 +1,128 @@\n import std._str;\n+import std._vec;\n+import std.option;\n+\n import front.ast;\n import middle.trans;\n+import middle.ty;\n import back.x86;\n+import util.common;\n \n import lib.llvm.llvm;\n import lib.llvm.llvm.ValueRef;\n import lib.llvm.False;\n \n+// Type encoding\n+\n+// Compact string representation for ty.t values. API ty_str & parse_from_str.\n+// (The second has to be authed pure.) Extra parameters are for converting\n+// to/from def_ids in the string rep. Whatever format you choose should not\n+// contain pipe characters.\n+\n+// Callback to translate defs to strs or back.\n+type def_str = fn(ast.def_id) -> str;\n+\n+fn ty_str(@ty.t t, def_str ds) -> str {\n+    ret sty_str(t.struct, ds);\n+}\n+\n+fn mt_str(&ty.mt mt, def_str ds) -> str {\n+    auto mut_str;\n+    alt (mt.mut) {\n+        case (ast.imm)       { mut_str = \"\";  }\n+        case (ast.mut)       { mut_str = \"m\"; }\n+        case (ast.maybe_mut) { mut_str = \"?\"; }\n+    }\n+    ret mut_str + ty_str(mt.ty, ds);\n+}\n+\n+fn sty_str(ty.sty st, def_str ds) -> str {\n+    alt (st) {\n+        case (ty.ty_nil) {ret \"n\";}\n+        case (ty.ty_bool) {ret \"b\";}\n+        case (ty.ty_int) {ret \"i\";}\n+        case (ty.ty_uint) {ret \"u\";}\n+        case (ty.ty_machine(?mach)) {\n+            alt (mach) {\n+                case (common.ty_u8) {ret \"Mb\";}\n+                case (common.ty_u16) {ret \"Mw\";}\n+                case (common.ty_u32) {ret \"Ml\";}\n+                case (common.ty_u64) {ret \"Md\";}\n+                case (common.ty_i8) {ret \"MB\";}\n+                case (common.ty_i16) {ret \"MW\";}\n+                case (common.ty_i32) {ret \"ML\";}\n+                case (common.ty_i64) {ret \"MD\";}\n+                case (common.ty_f32) {ret \"Mf\";}\n+                case (common.ty_f64) {ret \"MF\";}\n+            }\n+        }\n+        case (ty.ty_char) {ret \"c\";}\n+        case (ty.ty_str) {ret \"s\";}\n+        case (ty.ty_tag(?def,?tys)) { // TODO restore def_id\n+            auto acc = \"t[\" + ds(def) + \"|\";\n+            for (@ty.t t in tys) {acc += ty_str(t, ds);}\n+            ret acc + \"]\";\n+        }\n+        case (ty.ty_box(?mt)) {ret \"@\" + mt_str(mt, ds);}\n+        case (ty.ty_vec(?mt)) {ret \"V\" + mt_str(mt, ds);}\n+        case (ty.ty_port(?t)) {ret \"P\" + ty_str(t, ds);}\n+        case (ty.ty_chan(?t)) {ret \"C\" + ty_str(t, ds);}\n+        case (ty.ty_tup(?mts)) {\n+            auto acc = \"T[\";\n+            for (ty.mt mt in mts) {acc += mt_str(mt, ds);}\n+            ret acc + \"]\";\n+        }\n+        case (ty.ty_rec(?fields)) {\n+            auto acc = \"R[\";\n+            for (ty.field field in fields) {\n+                acc += field.ident + \"=\";\n+                acc += mt_str(field.mt, ds);\n+            }\n+            ret acc + \"]\";\n+        }\n+        case (ty.ty_fn(?proto,?args,?out)) {\n+            ret proto_str(proto) + ty_fn_str(args, out, ds);\n+        }\n+        case (ty.ty_native_fn(?abi,?args,?out)) {\n+            auto abistr;\n+            alt (abi) {\n+                case (ast.native_abi_rust) {abistr = \"r\";}\n+                case (ast.native_abi_cdecl) {abistr = \"c\";}\n+            }\n+            ret \"N\" + abistr + ty_fn_str(args, out, ds);\n+        }\n+        case (ty.ty_obj(?methods)) {\n+            auto acc = \"O[\";\n+            for (ty.method m in methods) {\n+                acc += proto_str(m.proto);\n+                acc += m.ident;\n+                acc += ty_fn_str(m.inputs, m.output, ds);\n+            }\n+            ret acc + \"]\";\n+        }\n+        case (ty.ty_var(?id)) {ret \"X\" + common.istr(id);}\n+        case (ty.ty_native) {ret \"E\";}\n+        // TODO (maybe?)   ty_param(ast.def_id), ty_type;\n+    }\n+}\n+\n+fn proto_str(ast.proto proto) -> str {\n+    alt (proto) {\n+        case (ast.proto_iter) {ret \"W\";}\n+        case (ast.proto_fn) {ret \"F\";}\n+    }\n+}\n+\n+fn ty_fn_str(vec[ty.arg] args, @ty.t out, def_str ds) -> str {\n+    auto acc = \"[\";\n+    for (ty.arg arg in args) {\n+        if (arg.mode == ast.alias) {acc += \"&\";}\n+        acc += ty_str(arg.ty, ds);\n+    }\n+    ret acc + \"]\" + ty_str(out, ds);\n+}\n+\n+\n // Returns a Plain Old LLVM String.\n fn C_postr(str s) -> ValueRef {\n     ret llvm.LLVMConstString(_str.buf(s), _str.byte_len(s), False);"}]}