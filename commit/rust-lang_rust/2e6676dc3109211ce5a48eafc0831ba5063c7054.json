{"sha": "2e6676dc3109211ce5a48eafc0831ba5063c7054", "node_id": "C_kwDOAAsO6NoAKDJlNjY3NmRjMzEwOTIxMWNlNWE0OGVhZmMwODMxYmE1MDYzYzcwNTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-13T11:56:18Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-11-13T11:56:18Z"}, "message": "Auto merge of #2663 - RalfJung:sync, r=RalfJung\n\npthread: slight refactoring of how we access the sync object fields", "tree": {"sha": "051eb34932a5c56d49f0802c0c4ffab1b3592532", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/051eb34932a5c56d49f0802c0c4ffab1b3592532"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2e6676dc3109211ce5a48eafc0831ba5063c7054", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2e6676dc3109211ce5a48eafc0831ba5063c7054", "html_url": "https://github.com/rust-lang/rust/commit/2e6676dc3109211ce5a48eafc0831ba5063c7054", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2e6676dc3109211ce5a48eafc0831ba5063c7054/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93566275e3fdf10704833e172eb254646a33da61", "url": "https://api.github.com/repos/rust-lang/rust/commits/93566275e3fdf10704833e172eb254646a33da61", "html_url": "https://github.com/rust-lang/rust/commit/93566275e3fdf10704833e172eb254646a33da61"}, {"sha": "6adb2df731e424e3542c31a2c12167ff33365b2c", "url": "https://api.github.com/repos/rust-lang/rust/commits/6adb2df731e424e3542c31a2c12167ff33365b2c", "html_url": "https://github.com/rust-lang/rust/commit/6adb2df731e424e3542c31a2c12167ff33365b2c"}], "stats": {"total": 267, "additions": 91, "deletions": 176}, "files": [{"sha": "cdf1a5470ce396b079765a2a11150bcbfb6f551e", "filename": "src/tools/miri/rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Frust-version", "raw_url": "https://github.com/rust-lang/rust/raw/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Frust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Frust-version?ref=2e6676dc3109211ce5a48eafc0831ba5063c7054", "patch": "@@ -1 +1 @@\n-452cf4f7109f58433ac38be7d3da527408571054\n+11fa0850f03ae49fe1053a21bcdcf8a301668ad8"}, {"sha": "69514395bc98de1cb9115dbec23a6b930a94cd84", "filename": "src/tools/miri/src/concurrency/data_race.rs", "status": "modified", "additions": 1, "deletions": 28, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fdata_race.rs?ref=2e6676dc3109211ce5a48eafc0831ba5063c7054", "patch": "@@ -49,7 +49,7 @@ use std::{\n use rustc_ast::Mutability;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_middle::{mir, ty::layout::TyAndLayout};\n+use rustc_middle::mir;\n use rustc_target::abi::{Align, Size};\n \n use crate::*;\n@@ -440,33 +440,6 @@ impl MemoryCellClocks {\n /// Evaluation context extensions.\n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for MiriInterpCx<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriInterpCxExt<'mir, 'tcx> {\n-    /// Atomic variant of read_scalar_at_offset.\n-    fn read_scalar_at_offset_atomic(\n-        &self,\n-        op: &OpTy<'tcx, Provenance>,\n-        offset: u64,\n-        layout: TyAndLayout<'tcx>,\n-        atomic: AtomicReadOrd,\n-    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n-        let this = self.eval_context_ref();\n-        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n-        this.read_scalar_atomic(&value_place, atomic)\n-    }\n-\n-    /// Atomic variant of write_scalar_at_offset.\n-    fn write_scalar_at_offset_atomic(\n-        &mut self,\n-        op: &OpTy<'tcx, Provenance>,\n-        offset: u64,\n-        value: impl Into<Scalar<Provenance>>,\n-        layout: TyAndLayout<'tcx>,\n-        atomic: AtomicWriteOrd,\n-    ) -> InterpResult<'tcx> {\n-        let this = self.eval_context_mut();\n-        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n-        this.write_scalar_atomic(value.into(), &value_place, atomic)\n-    }\n-\n     /// Perform an atomic read operation at the memory location.\n     fn read_scalar_atomic(\n         &self,"}, {"sha": "dc4b435b7101ca1bad35fee51959de80b3691f81", "filename": "src/tools/miri/src/concurrency/sync.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fconcurrency%2Fsync.rs?ref=2e6676dc3109211ce5a48eafc0831ba5063c7054", "patch": "@@ -193,8 +193,9 @@ impl<'mir, 'tcx: 'mir> EvalContextExtPriv<'mir, 'tcx> for crate::MiriInterpCx<'m\n pub(super) trait EvalContextExtPriv<'mir, 'tcx: 'mir>:\n     crate::MiriInterpCxExt<'mir, 'tcx>\n {\n+    /// Lazily initialize the ID of this Miri sync structure.\n+    /// ('0' indicates uninit.)\n     #[inline]\n-    // Miri sync structures contain zero-initialized ids stored at some offset behind a pointer\n     fn get_or_create_id<Id: SyncId>(\n         &mut self,\n         next_id: Id,\n@@ -205,6 +206,7 @@ pub(super) trait EvalContextExtPriv<'mir, 'tcx: 'mir>:\n         let value_place =\n             this.deref_operand_and_offset(lock_op, offset, this.machine.layouts.u32)?;\n \n+        // Since we are lazy, this update has to be atomic.\n         let (old, success) = this\n             .atomic_compare_exchange_scalar(\n                 &value_place,"}, {"sha": "fb4d91a26d3ff4d89c9b99774eb58b6df31797bc", "filename": "src/tools/miri/src/helpers.rs", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fhelpers.rs?ref=2e6676dc3109211ce5a48eafc0831ba5063c7054", "patch": "@@ -667,7 +667,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, Provenance>> {\n         let this = self.eval_context_ref();\n-        let op_place = this.deref_operand(op)?;\n+        let op_place = this.deref_operand(op)?; // FIXME: we still deref with the original type!\n         let offset = Size::from_bytes(offset);\n \n         // Ensure that the access is within bounds.\n@@ -687,25 +687,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         this.read_scalar(&value_place.into())\n     }\n \n-    fn write_immediate_at_offset(\n-        &mut self,\n-        op: &OpTy<'tcx, Provenance>,\n-        offset: u64,\n-        value: &ImmTy<'tcx, Provenance>,\n-    ) -> InterpResult<'tcx, ()> {\n-        let this = self.eval_context_mut();\n-        let value_place = this.deref_operand_and_offset(op, offset, value.layout)?;\n-        this.write_immediate(**value, &value_place.into())\n-    }\n-\n     fn write_scalar_at_offset(\n         &mut self,\n         op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n         value: impl Into<Scalar<Provenance>>,\n         layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, ()> {\n-        self.write_immediate_at_offset(op, offset, &ImmTy::from_scalar(value.into(), layout))\n+        let this = self.eval_context_mut();\n+        let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n+        this.write_scalar(value, &value_place.into())\n     }\n \n     /// Parse a `timespec` struct and return it as a `std::time::Duration`. It returns `None`"}, {"sha": "e0afb500cb18a99cb4309ec40dbd08f91975ee94", "filename": "src/tools/miri/src/shims/unix/sync.rs", "status": "modified", "additions": 82, "deletions": 133, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2e6676dc3109211ce5a48eafc0831ba5063c7054/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Funix%2Fsync.rs?ref=2e6676dc3109211ce5a48eafc0831ba5063c7054", "patch": "@@ -1,8 +1,5 @@\n use std::time::SystemTime;\n \n-use rustc_hir::LangItem;\n-use rustc_middle::ty::{layout::TyAndLayout, query::TyCtxtAt, Ty};\n-\n use crate::concurrency::sync::CondvarLock;\n use crate::concurrency::thread::{MachineCallback, Time};\n use crate::*;\n@@ -20,39 +17,34 @@ use crate::*;\n /// in `pthread_mutexattr_settype` function.\n const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n-const MUTEX_ID_OFFSET: u64 = 4;\n-const RWLOCK_ID_OFFSET: u64 = 4;\n-const CONDVAR_ID_OFFSET: u64 = 4;\n-\n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    kind: Scalar<Provenance>,\n+    kind: i32,\n ) -> InterpResult<'tcx, bool> {\n-    Ok(kind == ecx.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?)\n+    Ok(kind == ecx.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?)\n }\n \n fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n-    kind: Scalar<Provenance>,\n+    kind: i32,\n ) -> InterpResult<'tcx, bool> {\n-    let kind = kind.to_i32()?;\n-    let mutex_normal_kind = ecx.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?.to_i32()?;\n+    let mutex_normal_kind = ecx.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\")?;\n     Ok(kind == (mutex_normal_kind | PTHREAD_MUTEX_NORMAL_FLAG))\n }\n \n fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n+) -> InterpResult<'tcx, i32> {\n+    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)?.to_i32()\n }\n \n fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-    kind: impl Into<Scalar<Provenance>>,\n+    kind: i32,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset(attr_op, 0, kind, layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32))\n+    ecx.write_scalar_at_offset(attr_op, 0, Scalar::from_i32(kind), ecx.machine.layouts.i32)\n }\n \n // pthread_mutex_t is between 24 and 48 bytes, depending on the platform.\n@@ -64,53 +56,35 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n // bytes 12-15 or 16-19 (depending on platform): mutex kind, as an i32\n // (the kind has to be at its offset for compatibility with static initializer macros)\n \n-fn mutex_get_kind<'mir, 'tcx: 'mir>(\n-    ecx: &MiriInterpCx<'mir, 'tcx>,\n+fn mutex_get_id<'mir, 'tcx: 'mir>(\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    ecx.read_scalar_at_offset_atomic(\n-        mutex_op,\n-        offset,\n-        ecx.machine.layouts.i32,\n-        AtomicReadOrd::Relaxed,\n-    )\n+) -> InterpResult<'tcx, MutexId> {\n+    ecx.mutex_get_or_create_id(mutex_op, 4)\n }\n \n-fn mutex_set_kind<'mir, 'tcx: 'mir>(\n+fn mutex_reset_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-    kind: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n-    let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n-    ecx.write_scalar_at_offset_atomic(\n-        mutex_op,\n-        offset,\n-        kind,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32),\n-        AtomicWriteOrd::Relaxed,\n-    )\n+    ecx.write_scalar_at_offset(mutex_op, 4, Scalar::from_i32(0), ecx.machine.layouts.u32)\n }\n \n-fn mutex_get_id<'mir, 'tcx: 'mir>(\n+fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n+) -> InterpResult<'tcx, i32> {\n+    let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n+    ecx.read_scalar_at_offset(mutex_op, offset, ecx.machine.layouts.i32)?.to_i32()\n }\n \n-fn mutex_set_id<'mir, 'tcx: 'mir>(\n+fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     mutex_op: &OpTy<'tcx, Provenance>,\n-    id: impl Into<Scalar<Provenance>>,\n+    kind: i32,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset_atomic(\n-        mutex_op,\n-        4,\n-        id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOrd::Relaxed,\n-    )\n+    let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n+    ecx.write_scalar_at_offset(mutex_op, offset, Scalar::from_i32(kind), ecx.machine.layouts.i32)\n }\n \n // pthread_rwlock_t is between 32 and 56 bytes, depending on the platform.\n@@ -121,10 +95,10 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n // bytes 4-7: rwlock id as u32 or 0 if id is not assigned yet.\n \n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriInterpCx<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     rwlock_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n+) -> InterpResult<'tcx, RwLockId> {\n+    ecx.rwlock_get_or_create_id(rwlock_op, 4)\n }\n \n // pthread_condattr_t\n@@ -136,21 +110,16 @@ fn rwlock_get_id<'mir, 'tcx: 'mir>(\n fn condattr_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n+) -> InterpResult<'tcx, i32> {\n+    ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)?.to_i32()\n }\n \n fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     attr_op: &OpTy<'tcx, Provenance>,\n-    clock_id: impl Into<Scalar<Provenance>>,\n+    clock_id: i32,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset(\n-        attr_op,\n-        0,\n-        clock_id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.machine.layouts.i32.ty),\n-    )\n+    ecx.write_scalar_at_offset(attr_op, 0, Scalar::from_i32(clock_id), ecx.machine.layouts.i32)\n }\n \n // pthread_cond_t\n@@ -163,44 +132,32 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n // bytes 8-11: the clock id constant as i32\n \n fn cond_get_id<'mir, 'tcx: 'mir>(\n-    ecx: &MiriInterpCx<'mir, 'tcx>,\n+    ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n+) -> InterpResult<'tcx, CondvarId> {\n+    ecx.condvar_get_or_create_id(cond_op, 4)\n }\n \n-fn cond_set_id<'mir, 'tcx: 'mir>(\n+fn cond_reset_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-    id: impl Into<Scalar<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset_atomic(\n-        cond_op,\n-        4,\n-        id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.u32),\n-        AtomicWriteOrd::Relaxed,\n-    )\n+    ecx.write_scalar_at_offset(cond_op, 4, Scalar::from_i32(0), ecx.machine.layouts.u32)\n }\n \n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-) -> InterpResult<'tcx, Scalar<Provenance>> {\n-    ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)\n+) -> InterpResult<'tcx, i32> {\n+    ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)?.to_i32()\n }\n \n fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriInterpCx<'mir, 'tcx>,\n     cond_op: &OpTy<'tcx, Provenance>,\n-    clock_id: impl Into<Scalar<Provenance>>,\n+    clock_id: i32,\n ) -> InterpResult<'tcx, ()> {\n-    ecx.write_scalar_at_offset(\n-        cond_op,\n-        8,\n-        clock_id,\n-        layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32),\n-    )\n+    ecx.write_scalar_at_offset(cond_op, 8, Scalar::from_i32(clock_id), ecx.machine.layouts.i32)\n }\n \n /// Try to reacquire the mutex associated with the condition variable after we\n@@ -260,7 +217,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let default_kind = this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?;\n+        let default_kind = this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?;\n         mutexattr_set_kind(this, attr_op, default_kind)?;\n \n         Ok(0)\n@@ -273,8 +230,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let kind = this.read_scalar(kind_op)?;\n-        if kind == this.eval_libc(\"PTHREAD_MUTEX_NORMAL\")? {\n+        let kind = this.read_scalar(kind_op)?.to_i32()?;\n+        if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_NORMAL\")? {\n             // In `glibc` implementation, the numeric values of\n             // `PTHREAD_MUTEX_NORMAL` and `PTHREAD_MUTEX_DEFAULT` are equal.\n             // However, a mutex created by explicitly passing\n@@ -287,16 +244,16 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             // use the same trick as glibc: for the case when\n             // `pthread_mutexattr_settype` is caled explicitly, we set the\n             // `PTHREAD_MUTEX_NORMAL_FLAG` flag.\n-            let normal_kind = kind.to_i32()? | PTHREAD_MUTEX_NORMAL_FLAG;\n+            let normal_kind = kind | PTHREAD_MUTEX_NORMAL_FLAG;\n             // Check that after setting the flag, the kind is distinguishable\n             // from all other kinds.\n-            assert_ne!(normal_kind, this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?.to_i32()?);\n-            assert_ne!(normal_kind, this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?.to_i32()?);\n-            assert_ne!(normal_kind, this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")?.to_i32()?);\n-            mutexattr_set_kind(this, attr_op, Scalar::from_i32(normal_kind))?;\n-        } else if kind == this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n-            || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n-            || kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")?\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?);\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?);\n+            assert_ne!(normal_kind, this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?);\n+            mutexattr_set_kind(this, attr_op, normal_kind)?;\n+        } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?\n+            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+            || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?\n         {\n             mutexattr_set_kind(this, attr_op, kind)?;\n         } else {\n@@ -342,13 +299,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let attr = this.read_pointer(attr_op)?;\n         let kind = if this.ptr_is_null(attr)? {\n-            this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?\n+            this.eval_libc_i32(\"PTHREAD_MUTEX_DEFAULT\")?\n         } else {\n             mutexattr_get_kind(this, attr_op)?\n         };\n \n         // Write 0 to use the same code path as the static initializers.\n-        mutex_set_id(this, mutex_op, Scalar::from_i32(0))?;\n+        mutex_reset_id(this, mutex_op)?;\n \n         mutex_set_kind(this, mutex_op, kind)?;\n \n@@ -359,7 +316,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -374,9 +331,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                     throw_ub_format!(\"trying to acquire already locked default mutex\");\n                 } else if is_mutex_kind_normal(this, kind)? {\n                     throw_machine_stop!(TerminationInfo::Deadlock);\n-                } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")? {\n                     this.eval_libc_i32(\"EDEADLK\")\n-                } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")? {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n@@ -399,7 +356,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.mutex_is_locked(id) {\n@@ -409,10 +366,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             } else {\n                 if is_mutex_kind_default(this, kind)?\n                     || is_mutex_kind_normal(this, kind)?\n-                    || kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+                    || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n                 {\n                     this.eval_libc_i32(\"EBUSY\")\n-                } else if kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")? {\n+                } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")? {\n                     this.mutex_lock(id, active_thread);\n                     Ok(0)\n                 } else {\n@@ -435,7 +392,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?;\n-        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         if let Some(_old_locked_count) = this.mutex_unlock(id, active_thread) {\n@@ -453,8 +410,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n                 throw_ub_format!(\n                     \"unlocked a PTHREAD_MUTEX_NORMAL mutex that was not locked by the current thread\"\n                 );\n-            } else if kind == this.eval_libc(\"PTHREAD_MUTEX_ERRORCHECK\")?\n-                || kind == this.eval_libc(\"PTHREAD_MUTEX_RECURSIVE\")?\n+            } else if kind == this.eval_libc_i32(\"PTHREAD_MUTEX_ERRORCHECK\")?\n+                || kind == this.eval_libc_i32(\"PTHREAD_MUTEX_RECURSIVE\")?\n             {\n                 this.eval_libc_i32(\"EPERM\")\n             } else {\n@@ -469,7 +426,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = mutex_get_id(this, mutex_op)?;\n \n         if this.mutex_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked mutex\");\n@@ -492,7 +449,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -510,7 +467,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_write_locked(id) {\n@@ -527,7 +484,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -557,7 +514,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         if this.rwlock_is_locked(id) {\n@@ -574,7 +531,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n         let active_thread = this.get_active_thread();\n \n         #[allow(clippy::if_same_then_else)]\n@@ -593,7 +550,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.rwlock_get_or_create_id(rwlock_op, RWLOCK_ID_OFFSET)?;\n+        let id = rwlock_get_id(this, rwlock_op)?;\n \n         if this.rwlock_is_locked(id) {\n             throw_ub_format!(\"destroyed a locked rwlock\");\n@@ -618,7 +575,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         // The default value of the clock attribute shall refer to the system\n         // clock.\n         // https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_condattr_setclock.html\n-        let default_clock_id = this.eval_libc(\"CLOCK_REALTIME\")?;\n+        let default_clock_id = this.eval_libc_i32(\"CLOCK_REALTIME\")?;\n         condattr_set_clock_id(this, attr_op, default_clock_id)?;\n \n         Ok(0)\n@@ -631,9 +588,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n-        let clock_id = this.read_scalar(clock_id_op)?;\n-        if clock_id == this.eval_libc(\"CLOCK_REALTIME\")?\n-            || clock_id == this.eval_libc(\"CLOCK_MONOTONIC\")?\n+        let clock_id = this.read_scalar(clock_id_op)?.to_i32()?;\n+        if clock_id == this.eval_libc_i32(\"CLOCK_REALTIME\")?\n+            || clock_id == this.eval_libc_i32(\"CLOCK_MONOTONIC\")?\n         {\n             condattr_set_clock_id(this, attr_op, clock_id)?;\n         } else {\n@@ -652,7 +609,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         let clock_id = condattr_get_clock_id(this, attr_op)?;\n-        this.write_scalar(clock_id, &this.deref_operand(clk_id_op)?.into())?;\n+        this.write_scalar(Scalar::from_i32(clock_id), &this.deref_operand(clk_id_op)?.into())?;\n \n         Ok(Scalar::from_i32(0))\n     }\n@@ -681,13 +638,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n         let attr = this.read_pointer(attr_op)?;\n         let clock_id = if this.ptr_is_null(attr)? {\n-            this.eval_libc(\"CLOCK_REALTIME\")?\n+            this.eval_libc_i32(\"CLOCK_REALTIME\")?\n         } else {\n             condattr_get_clock_id(this, attr_op)?\n         };\n \n         // Write 0 to use the same code path as the static initializers.\n-        cond_set_id(this, cond_op, Scalar::from_i32(0))?;\n+        cond_reset_id(this, cond_op)?;\n \n         cond_set_clock_id(this, cond_op, clock_id)?;\n \n@@ -696,7 +653,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n \n     fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n         if let Some((thread, lock)) = this.condvar_signal(id) {\n             if let CondvarLock::Mutex(mutex) = lock {\n                 post_cond_signal(this, thread, mutex)?;\n@@ -713,7 +670,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         cond_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n \n         while let Some((thread, lock)) = this.condvar_signal(id) {\n             if let CondvarLock::Mutex(mutex) = lock {\n@@ -733,8 +690,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n+        let mutex_id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         release_cond_mutex_and_block(this, active_thread, mutex_id)?;\n@@ -752,12 +709,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n-        let mutex_id = this.mutex_get_or_create_id(mutex_op, MUTEX_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n+        let mutex_id = mutex_get_id(this, mutex_op)?;\n         let active_thread = this.get_active_thread();\n \n         // Extract the timeout.\n-        let clock_id = cond_get_clock_id(this, cond_op)?.to_i32()?;\n+        let clock_id = cond_get_clock_id(this, cond_op)?;\n         let duration = match this.read_timespec(&this.deref_operand(abstime_op)?)? {\n             Some(duration) => duration,\n             None => {\n@@ -830,7 +787,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n-        let id = this.condvar_get_or_create_id(cond_op, CONDVAR_ID_OFFSET)?;\n+        let id = cond_get_id(this, cond_op)?;\n         if this.condvar_is_awaited(id) {\n             throw_ub_format!(\"destroying an awaited conditional variable\");\n         }\n@@ -846,11 +803,3 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         Ok(0)\n     }\n }\n-\n-fn layout_of_maybe_uninit<'tcx>(tcx: TyCtxtAt<'tcx>, param: Ty<'tcx>) -> TyAndLayout<'tcx> {\n-    let def_id = tcx.require_lang_item(LangItem::MaybeUninit, None);\n-    let ty = tcx.bound_type_of(def_id).subst(*tcx, &[param.into()]);\n-\n-    let param_env = tcx.param_env(def_id);\n-    tcx.layout_of(param_env.and(ty)).unwrap()\n-}"}]}