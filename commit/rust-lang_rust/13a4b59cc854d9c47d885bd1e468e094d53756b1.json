{"sha": "13a4b59cc854d9c47d885bd1e468e094d53756b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzYTRiNTljYzg1NGQ5YzQ3ZDg4NWJkMWU0NjhlMDk0ZDUzNzU2YjE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-02T07:04:53Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-05-03T23:38:16Z"}, "message": "core: Add send/recv/peek methods for both ports and chans\n\nCalling peek or recv on channels can fail when the associated port\nis dead or unowned.", "tree": {"sha": "e99a552a9d2b2733c45b85da8a930331ee731818", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e99a552a9d2b2733c45b85da8a930331ee731818"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13a4b59cc854d9c47d885bd1e468e094d53756b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13a4b59cc854d9c47d885bd1e468e094d53756b1", "html_url": "https://github.com/rust-lang/rust/commit/13a4b59cc854d9c47d885bd1e468e094d53756b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13a4b59cc854d9c47d885bd1e468e094d53756b1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18f898315a6b94fec729da65b536e311bc0a9f3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/18f898315a6b94fec729da65b536e311bc0a9f3d", "html_url": "https://github.com/rust-lang/rust/commit/18f898315a6b94fec729da65b536e311bc0a9f3d"}], "stats": {"total": 113, "additions": 82, "deletions": 31}, "files": [{"sha": "b9dc86fd6d6a1a5fe64ea054bb7a261f9f9afe06", "filename": "src/libcore/comm.rs", "status": "modified", "additions": 82, "deletions": 31, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/13a4b59cc854d9c47d885bd1e468e094d53756b1/src%2Flibcore%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/13a4b59cc854d9c47d885bd1e468e094d53756b1/src%2Flibcore%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcomm.rs?ref=13a4b59cc854d9c47d885bd1e468e094d53756b1", "patch": "@@ -33,6 +33,7 @@ export recv;\n export peek;\n export recv_chan;\n export select2;\n+export methods;\n \n \n #[doc = \"\n@@ -67,37 +68,22 @@ fn port<T: send>() -> port<T> {\n     port_t(@port_ptr(rustrt::new_port(sys::size_of::<T>())))\n }\n \n-#[doc = \"\n-Constructs a channel. The channel is bound to the port used to\n-construct it.\n-\"]\n-fn chan<T: send>(p: port<T>) -> chan<T> {\n-    chan_t(rustrt::get_port_id(***p))\n-}\n+impl methods<T: send> for port<T> {\n+\n+    fn chan() -> chan<T> { chan(self) }\n+    fn send(+v: T) { self.chan().send(v) }\n+    fn recv() -> T { recv(self) }\n+    fn peek() -> bool { peek(self) }\n \n-#[doc = \"\n-Sends data over a channel. The sent data is moved into the channel,\n-whereupon the caller loses access to it.\n-\"]\n-fn send<T: send>(ch: chan<T>, -data: T) {\n-    let chan_t(p) = ch;\n-    let res = rustrt::rust_port_id_send(p, data);\n-    if res != 0u unsafe {\n-        // Data sent successfully\n-        unsafe::forget(data);\n-    }\n-    task::yield();\n }\n \n-#[doc = \"\n-Receive from a port.  If no data is available on the port then the\n-task will block until data becomes available.\n-\"]\n-fn recv<T: send>(p: port<T>) -> T { recv_(***p) }\n+impl methods<T: send> for chan<T> {\n+\n+    fn chan() -> chan<T> { self }\n+    fn send(+v: T) { send(self, v) }\n+    fn recv() -> T { recv_chan(self) }\n+    fn peek() -> bool { peek_chan(self) }\n \n-#[doc = \"Returns true if there are messages available\"]\n-fn peek<T: send>(p: port<T>) -> bool {\n-    rustrt::rust_port_size(***p) != 0u as libc::size_t\n }\n \n resource port_ptr<T: send>(po: *rust_port) {\n@@ -121,9 +107,15 @@ resource port_ptr<T: send>(po: *rust_port) {\n     rustrt::del_port(po);\n }\n \n+#[doc = \"\n+Internal function for converting from a channel to a port\n \n-#[doc(hidden)]\n-fn recv_chan<T: send>(ch: comm::chan<T>) -> T {\n+# Failure\n+\n+Fails if the port is detached or dead. Fails if the port\n+is owned by a different task.\n+\"]\n+fn as_raw_port<T: send, U>(ch: comm::chan<T>, f: fn(*rust_port) -> U) -> U {\n     resource portref(p: *rust_port) {\n         if !ptr::is_null(p) {\n             rustrt::rust_port_drop(p);\n@@ -135,10 +127,50 @@ fn recv_chan<T: send>(ch: comm::chan<T>) -> T {\n     if ptr::is_null(*p) {\n         fail \"unable to locate port for channel\"\n     } else if rustrt::get_task_id() != rustrt::rust_port_task(*p) {\n-        fail \"attempting to receive on unowned channel\"\n+        fail \"unable to access unowned port\"\n     }\n \n-    recv_(*p)\n+    f(*p)\n+}\n+\n+#[doc = \"\n+Constructs a channel. The channel is bound to the port used to\n+construct it.\n+\"]\n+fn chan<T: send>(p: port<T>) -> chan<T> {\n+    chan_t(rustrt::get_port_id(***p))\n+}\n+\n+#[doc = \"\n+Sends data over a channel. The sent data is moved into the channel,\n+whereupon the caller loses access to it.\n+\"]\n+fn send<T: send>(ch: chan<T>, -data: T) {\n+    let chan_t(p) = ch;\n+    let res = rustrt::rust_port_id_send(p, data);\n+    if res != 0u unsafe {\n+        // Data sent successfully\n+        unsafe::forget(data);\n+    }\n+    task::yield();\n+}\n+\n+#[doc = \"\n+Receive from a port.  If no data is available on the port then the\n+task will block until data becomes available.\n+\"]\n+fn recv<T: send>(p: port<T>) -> T { recv_(***p) }\n+\n+#[doc = \"Returns true if there are messages available\"]\n+fn peek<T: send>(p: port<T>) -> bool { peek_(***p) }\n+\n+#[doc(hidden)]\n+fn recv_chan<T: send>(ch: comm::chan<T>) -> T {\n+    as_raw_port(ch, recv_(_))\n+}\n+\n+fn peek_chan<T: send>(ch: comm::chan<T>) -> bool {\n+    as_raw_port(ch, peek_(_))\n }\n \n #[doc = \"Receive on a raw port pointer\"]\n@@ -160,6 +192,10 @@ fn recv_<T: send>(p: *rust_port) -> T {\n     ret res;\n }\n \n+fn peek_(p: *rust_port) -> bool unsafe {\n+    rustrt::rust_port_size(p) != 0u as libc::size_t\n+}\n+\n #[doc = \"Receive on one of two ports\"]\n fn select2<A: send, B: send>(p_a: port<A>, p_b: port<B>)\n     -> either<A, B> unsafe {\n@@ -391,3 +427,18 @@ fn test_recv_chan_wrong_task() {\n         recv_chan(ch)\n     })\n }\n+\n+#[test]\n+fn test_port_send() {\n+    let po = port();\n+    po.send(());\n+    po.recv();\n+}\n+\n+#[test]\n+fn test_chan_peek() {\n+    let po = port();\n+    let ch = po.chan();\n+    ch.send(());\n+    assert ch.peek();\n+}\n\\ No newline at end of file"}]}