{"sha": "5c9dc57cb587761561e85574c821a6f9c0c7cc67", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVjOWRjNTdjYjU4Nzc2MTU2MWU4NTU3NGM4MjFhNmY5YzBjN2NjNjc=", "commit": {"author": {"name": "Pyry Kontio", "email": "pyry.kontio@drasa.eu", "date": "2020-01-25T08:47:46Z"}, "committer": {"name": "Pyry Kontio", "email": "pyry.kontio@drasa.eu", "date": "2020-02-09T14:49:44Z"}, "message": "Don't return empty slice on last iteration with matched terminator. Test reverse iteration.", "tree": {"sha": "9a2ad20c10a99667433ed446e9ecd286c4c0f9bb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a2ad20c10a99667433ed446e9ecd286c4c0f9bb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5c9dc57cb587761561e85574c821a6f9c0c7cc67", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5c9dc57cb587761561e85574c821a6f9c0c7cc67", "html_url": "https://github.com/rust-lang/rust/commit/5c9dc57cb587761561e85574c821a6f9c0c7cc67", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5c9dc57cb587761561e85574c821a6f9c0c7cc67/comments", "author": {"login": "golddranks", "id": 2675542, "node_id": "MDQ6VXNlcjI2NzU1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2675542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/golddranks", "html_url": "https://github.com/golddranks", "followers_url": "https://api.github.com/users/golddranks/followers", "following_url": "https://api.github.com/users/golddranks/following{/other_user}", "gists_url": "https://api.github.com/users/golddranks/gists{/gist_id}", "starred_url": "https://api.github.com/users/golddranks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/golddranks/subscriptions", "organizations_url": "https://api.github.com/users/golddranks/orgs", "repos_url": "https://api.github.com/users/golddranks/repos", "events_url": "https://api.github.com/users/golddranks/events{/privacy}", "received_events_url": "https://api.github.com/users/golddranks/received_events", "type": "User", "site_admin": false}, "committer": {"login": "golddranks", "id": 2675542, "node_id": "MDQ6VXNlcjI2NzU1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/2675542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/golddranks", "html_url": "https://github.com/golddranks", "followers_url": "https://api.github.com/users/golddranks/followers", "following_url": "https://api.github.com/users/golddranks/following{/other_user}", "gists_url": "https://api.github.com/users/golddranks/gists{/gist_id}", "starred_url": "https://api.github.com/users/golddranks/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/golddranks/subscriptions", "organizations_url": "https://api.github.com/users/golddranks/orgs", "repos_url": "https://api.github.com/users/golddranks/repos", "events_url": "https://api.github.com/users/golddranks/events{/privacy}", "received_events_url": "https://api.github.com/users/golddranks/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "86bf96291d8222dbec9e07461404ecb189be0a98", "url": "https://api.github.com/repos/rust-lang/rust/commits/86bf96291d8222dbec9e07461404ecb189be0a98", "html_url": "https://github.com/rust-lang/rust/commit/86bf96291d8222dbec9e07461404ecb189be0a98"}], "stats": {"total": 387, "additions": 255, "deletions": 132}, "files": [{"sha": "3d6b4bff5e06046fff2321769cda7c812bdb80ea", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 62, "deletions": 2, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/5c9dc57cb587761561e85574c821a6f9c0c7cc67/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9dc57cb587761561e85574c821a6f9c0c7cc67/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=5c9dc57cb587761561e85574c821a6f9c0c7cc67", "patch": "@@ -859,18 +859,78 @@ fn test_splitator_inclusive() {\n     assert_eq!(xs.split_inclusive(|x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n     let splits: &[&[_]] = &[&[1], &[2, 3, 4, 5]];\n     assert_eq!(xs.split_inclusive(|x| *x == 1).collect::<Vec<_>>(), splits);\n-    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5], &[]];\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n     assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<_>>(), splits);\n     let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n     assert_eq!(xs.split_inclusive(|x| *x == 10).collect::<Vec<_>>(), splits);\n-    let splits: &[&[_]] = &[&[1], &[2], &[3], &[4], &[5], &[]];\n+    let splits: &[&[_]] = &[&[1], &[2], &[3], &[4], &[5]];\n     assert_eq!(xs.split_inclusive(|_| true).collect::<Vec<&[i32]>>(), splits);\n \n     let xs: &[i32] = &[];\n     let splits: &[&[i32]] = &[&[]];\n     assert_eq!(xs.split_inclusive(|x| *x == 5).collect::<Vec<&[i32]>>(), splits);\n }\n \n+#[test]\n+fn test_splitator_inclusive_reverse() {\n+    let xs = &[1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n+    assert_eq!(xs.split_inclusive(|x| *x % 2 == 0).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[2, 3, 4, 5], &[1]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 1).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 10).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[5], &[4], &[3], &[2], &[1]];\n+    assert_eq!(xs.split_inclusive(|_| true).rev().collect::<Vec<_>>(), splits);\n+\n+    let xs: &[i32] = &[];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitator_mut_inclusive() {\n+    let xs = &mut [1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[1, 2], &[3, 4], &[5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x % 2 == 0).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 1).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 10).collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1], &[2], &[3], &[4], &[5]];\n+    assert_eq!(xs.split_inclusive_mut(|_| true).collect::<Vec<_>>(), splits);\n+\n+    let xs: &mut [i32] = &mut [];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).collect::<Vec<_>>(), splits);\n+}\n+\n+#[test]\n+fn test_splitator_mut_inclusive_reverse() {\n+    let xs = &mut [1, 2, 3, 4, 5];\n+\n+    let splits: &[&[_]] = &[&[5], &[3, 4], &[1, 2]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x % 2 == 0).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[2, 3, 4, 5], &[1]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 1).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[1, 2, 3, 4, 5]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 10).rev().collect::<Vec<_>>(), splits);\n+    let splits: &[&[_]] = &[&[5], &[4], &[3], &[2], &[1]];\n+    assert_eq!(xs.split_inclusive_mut(|_| true).rev().collect::<Vec<_>>(), splits);\n+\n+    let xs: &mut [i32] = &mut [];\n+    let splits: &[&[i32]] = &[&[]];\n+    assert_eq!(xs.split_inclusive_mut(|x| *x == 5).rev().collect::<Vec<_>>(), splits);\n+}\n+\n #[test]\n fn test_splitnator() {\n     let xs = &[1, 2, 3, 4, 5];"}, {"sha": "b703df6f3cb7de00a6d1974b418482ae2919a676", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 32, "deletions": 7, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/5c9dc57cb587761561e85574c821a6f9c0c7cc67/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9dc57cb587761561e85574c821a6f9c0c7cc67/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=5c9dc57cb587761561e85574c821a6f9c0c7cc67", "patch": "@@ -1252,18 +1252,43 @@ fn test_split_char_iterator_inclusive() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n     let split: Vec<&str> = data.split_inclusive('\\n').collect();\n-    assert_eq!(split, [\"\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"Little l\u00e4mb\\n\", \"\"]);\n+    assert_eq!(split, [\"\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"Little l\u00e4mb\\n\"]);\n \n     let uppercase_separated = \"SheePSharKTurtlECaT\";\n     let mut first_char = true;\n-    let split: Vec<&str> = uppercase_separated.split_inclusive(|c: char| {\n-        let split = !first_char && c.is_uppercase();\n-        first_char = split;\n-        split\n-    }).collect();\n-    assert_eq!(split, [\"SheeP\", \"SharK\", \"TurtlE\", \"CaT\", \"\"]);\n+    let split: Vec<&str> = uppercase_separated\n+        .split_inclusive(|c: char| {\n+            let split = !first_char && c.is_uppercase();\n+            first_char = split;\n+            split\n+        })\n+        .collect();\n+    assert_eq!(split, [\"SheeP\", \"SharK\", \"TurtlE\", \"CaT\"]);\n }\n \n+#[test]\n+fn test_split_char_iterator_inclusive_rev() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.split_inclusive('\\n').rev().collect();\n+    assert_eq!(split, [\"Little l\u00e4mb\\n\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\", \"\\n\"]);\n+\n+    // Note that the predicate is stateful and thus dependent\n+    // on the iteration order.\n+    // (A different predicate is needed for reverse iterator vs normal iterator.)\n+    // Not sure if anything can be done though.\n+    let uppercase_separated = \"SheePSharKTurtlECaT\";\n+    let mut term_char = true;\n+    let split: Vec<&str> = uppercase_separated\n+        .split_inclusive(|c: char| {\n+            let split = term_char && c.is_uppercase();\n+            term_char = c.is_uppercase();\n+            split\n+        })\n+        .rev()\n+        .collect();\n+    assert_eq!(split, [\"CaT\", \"TurtlE\", \"SharK\", \"SheeP\"]);\n+}\n \n #[test]\n fn test_rsplit() {"}, {"sha": "2f70dcff2f34341fd5f671931f3761dcfb7f4976", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 116, "deletions": 105, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/5c9dc57cb587761561e85574c821a6f9c0c7cc67/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9dc57cb587761561e85574c821a6f9c0c7cc67/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=5c9dc57cb587761561e85574c821a6f9c0c7cc67", "patch": "@@ -1171,30 +1171,26 @@ impl<T> [T] {\n     /// assert!(iter.next().is_none());\n     /// ```\n     ///\n-    /// If the first element is matched, an empty slice will be the first item\n-    /// returned by the iterator. Similarly, if the last element in the slice\n-    /// is matched, an empty slice will be the last item returned by the\n-    /// iterator:\n+    /// If the last element of the slice is matched,\n+    /// that element will be considered the terminator of the preceding slice.\n+    /// That slice will be the last item returned by the iterator.\n     ///\n     /// ```\n     /// #![feature(split_inclusive)]\n-    /// let slice = [10, 40, 33];\n+    /// let slice = [3, 10, 40, 33];\n     /// let mut iter = slice.split_inclusive(|num| num % 3 == 0);\n     ///\n+    /// assert_eq!(iter.next().unwrap(), &[3]);\n     /// assert_eq!(iter.next().unwrap(), &[10, 40, 33]);\n-    /// assert_eq!(iter.next().unwrap(), &[]);\n     /// assert!(iter.next().is_none());\n     /// ```\n-    #[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n     #[inline]\n     pub fn split_inclusive<F>(&self, pred: F) -> SplitInclusive<'_, T, F>\n-        where F: FnMut(&T) -> bool\n+    where\n+        F: FnMut(&T) -> bool,\n     {\n-        SplitInclusive {\n-            v: self,\n-            pred,\n-            finished: false\n-        }\n+        SplitInclusive { v: self, pred, finished: false }\n     }\n \n     /// Returns an iterator over mutable subslices separated by elements that\n@@ -1213,10 +1209,11 @@ impl<T> [T] {\n     /// }\n     /// assert_eq!(v, [10, 40, 1, 20, 1, 1]);\n     /// ```\n-    #[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n     #[inline]\n     pub fn split_inclusive_mut<F>(&mut self, pred: F) -> SplitInclusiveMut<'_, T, F>\n-        where F: FnMut(&T) -> bool\n+    where\n+        F: FnMut(&T) -> bool,\n     {\n         SplitInclusiveMut { v: self, pred, finished: false }\n     }\n@@ -3749,15 +3746,21 @@ impl<T, P> FusedIterator for Split<'_, T, P> where P: FnMut(&T) -> bool {}\n ///\n /// [`split_inclusive`]: ../../std/primitive.slice.html#method.split_inclusive\n /// [slices]: ../../std/primitive.slice.html\n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-pub struct SplitInclusive<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+pub struct SplitInclusive<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n     v: &'a [T],\n     pred: P,\n-    finished: bool\n+    finished: bool,\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<T: fmt::Debug, P> fmt::Debug for SplitInclusive<'_, T, P> where P: FnMut(&T) -> bool {\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusive<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SplitInclusive\")\n             .field(\"v\", &self.v)\n@@ -3767,71 +3770,71 @@ impl<T: fmt::Debug, P> fmt::Debug for SplitInclusive<'_, T, P> where P: FnMut(&T\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<T, P> Clone for SplitInclusive<'_, T, P> where P: Clone + FnMut(&T) -> bool {\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T, P> Clone for SplitInclusive<'_, T, P>\n+where\n+    P: Clone + FnMut(&T) -> bool,\n+{\n     fn clone(&self) -> Self {\n-        SplitInclusive {\n-            v: self.v,\n-            pred: self.pred.clone(),\n-            finished: self.finished,\n-        }\n+        SplitInclusive { v: self.v, pred: self.pred.clone(), finished: self.finished }\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<'a, T, P> Iterator for SplitInclusive<'a, T, P> where P: FnMut(&T) -> bool {\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> Iterator for SplitInclusive<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n     type Item = &'a [T];\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n+        if self.finished {\n+            return None;\n+        }\n \n-        match self.v.iter().position(|x| (self.pred)(x)) {\n-            None => self.finish(),\n-            Some(idx) => {\n-                let ret = Some(&self.v[..idx + 1]);\n-                self.v = &self.v[idx + 1..];\n-                ret\n-            }\n+        let idx =\n+            self.v.iter().position(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(self.v.len());\n+        if idx == self.v.len() {\n+            self.finished = true;\n         }\n+        let ret = Some(&self.v[..idx]);\n+        self.v = &self.v[idx..];\n+        ret\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.finished {\n-            (0, Some(0))\n-        } else {\n-            (1, Some(self.v.len() + 1))\n-        }\n+        if self.finished { (0, Some(0)) } else { (1, Some(self.v.len() + 1)) }\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<'a, T, P> DoubleEndedIterator for SplitInclusive<'a, T, P> where P: FnMut(&T) -> bool {\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusive<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.finished { return None; }\n-\n-        match self.v.iter().rposition(|x| (self.pred)(x)) {\n-            None => self.finish(),\n-            Some(idx) => {\n-                let ret = Some(&self.v[idx + 1..]);\n-                self.v = &self.v[..idx];\n-                ret\n-            }\n+        if self.finished {\n+            return None;\n         }\n-    }\n-}\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<'a, T, P> SplitIter for SplitInclusive<'a, T, P> where P: FnMut(&T) -> bool {\n-    #[inline]\n-    fn finish(&mut self) -> Option<&'a [T]> {\n-        if self.finished { None } else { self.finished = true; Some(self.v) }\n+        // The last index of self.v is already checked and found to match\n+        // by the last iteration, so we start searching a new match\n+        // one index to the left.\n+        let remainder = if self.v.len() == 0 { &[] } else { &self.v[..(self.v.len() - 1)] };\n+        let idx = remainder.iter().rposition(|x| (self.pred)(x)).map(|idx| idx + 1).unwrap_or(0);\n+        if idx == 0 {\n+            self.finished = true;\n+        }\n+        let ret = Some(&self.v[idx..]);\n+        self.v = &self.v[..idx];\n+        ret\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n impl<T, P> FusedIterator for SplitInclusive<'_, T, P> where P: FnMut(&T) -> bool {}\n \n /// An iterator over the mutable subslices of the vector which are separated\n@@ -3956,15 +3959,21 @@ impl<T, P> FusedIterator for SplitMut<'_, T, P> where P: FnMut(&T) -> bool {}\n ///\n /// [`split_inclusive_mut`]: ../../std/primitive.slice.html#method.split_inclusive_mut\n /// [slices]: ../../std/primitive.slice.html\n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-pub struct SplitInclusiveMut<'a, T:'a, P> where P: FnMut(&T) -> bool {\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+pub struct SplitInclusiveMut<'a, T: 'a, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n     v: &'a mut [T],\n     pred: P,\n-    finished: bool\n+    finished: bool,\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<T: fmt::Debug, P> fmt::Debug for SplitInclusiveMut<'_, T, P> where P: FnMut(&T) -> bool {\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<T: fmt::Debug, P> fmt::Debug for SplitInclusiveMut<'_, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"SplitInclusiveMut\")\n             .field(\"v\", &self.v)\n@@ -3973,40 +3982,32 @@ impl<T: fmt::Debug, P> fmt::Debug for SplitInclusiveMut<'_, T, P> where P: FnMut\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<'a, T, P> SplitIter for SplitInclusiveMut<'a, T, P> where P: FnMut(&T) -> bool {\n-    #[inline]\n-    fn finish(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished {\n-            None\n-        } else {\n-            self.finished = true;\n-            Some(mem::replace(&mut self.v, &mut []))\n-        }\n-    }\n-}\n-\n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<'a, T, P> Iterator for SplitInclusiveMut<'a, T, P> where P: FnMut(&T) -> bool {\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> Iterator for SplitInclusiveMut<'a, T, P>\n+where\n+    P: FnMut(&T) -> bool,\n+{\n     type Item = &'a mut [T];\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n+        if self.finished {\n+            return None;\n+        }\n \n-        let idx_opt = { // work around borrowck limitations\n+        let idx_opt = {\n+            // work around borrowck limitations\n             let pred = &mut self.pred;\n             self.v.iter().position(|x| (*pred)(x))\n         };\n-        match idx_opt {\n-            None => self.finish(),\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.split_at_mut(idx+1);\n-                self.v = tail;\n-                Some(head)\n-            }\n+        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(self.v.len());\n+        if idx == self.v.len() {\n+            self.finished = true;\n         }\n+        let tmp = mem::replace(&mut self.v, &mut []);\n+        let (head, tail) = tmp.split_at_mut(idx);\n+        self.v = tail;\n+        Some(head)\n     }\n \n     #[inline]\n@@ -4021,31 +4022,41 @@ impl<'a, T, P> Iterator for SplitInclusiveMut<'a, T, P> where P: FnMut(&T) -> bo\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n-impl<'a, T, P> DoubleEndedIterator for SplitInclusiveMut<'a, T, P> where\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n+impl<'a, T, P> DoubleEndedIterator for SplitInclusiveMut<'a, T, P>\n+where\n     P: FnMut(&T) -> bool,\n {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a mut [T]> {\n-        if self.finished { return None; }\n+        if self.finished {\n+            return None;\n+        }\n \n-        let idx_opt = { // work around borrowck limitations\n+        let idx_opt = if self.v.len() == 0 {\n+            None\n+        } else {\n+            // work around borrowck limitations\n             let pred = &mut self.pred;\n-            self.v.iter().rposition(|x| (*pred)(x))\n+\n+            // The last index of self.v is already checked and found to match\n+            // by the last iteration, so we start searching a new match\n+            // one index to the left.\n+            let remainder = &self.v[..(self.v.len() - 1)];\n+            remainder.iter().rposition(|x| (*pred)(x))\n         };\n-        match idx_opt {\n-            None => self.finish(),\n-            Some(idx) => {\n-                let tmp = mem::replace(&mut self.v, &mut []);\n-                let (head, tail) = tmp.split_at_mut(idx+1);\n-                self.v = head;\n-                Some(tail)\n-            }\n+        let idx = idx_opt.map(|idx| idx + 1).unwrap_or(0);\n+        if idx == 0 {\n+            self.finished = true;\n         }\n+        let tmp = mem::replace(&mut self.v, &mut []);\n+        let (head, tail) = tmp.split_at_mut(idx);\n+        self.v = head;\n+        Some(tail)\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n impl<T, P> FusedIterator for SplitInclusiveMut<'_, T, P> where P: FnMut(&T) -> bool {}\n \n /// An iterator over subslices separated by elements that match a predicate"}, {"sha": "efe6d885662e45ad7c285245585052797510e494", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 45, "deletions": 18, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/5c9dc57cb587761561e85574c821a6f9c0c7cc67/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5c9dc57cb587761561e85574c821a6f9c0c7cc67/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=5c9dc57cb587761561e85574c821a6f9c0c7cc67", "patch": "@@ -1134,10 +1134,15 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n     #[inline]\n     fn next_inclusive(&mut self) -> Option<&'a str> {\n-        if self.finished { return None }\n+        if self.finished {\n+            return None;\n+        }\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.start is either the start of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n             Some((_, b)) => unsafe {\n                 let elt = haystack.get_unchecked(self.start..b);\n                 self.start = b;\n@@ -1186,25 +1191,40 @@ impl<'a, P: Pattern<'a>> SplitInternal<'a, P> {\n \n     #[inline]\n     fn next_back_inclusive(&mut self) -> Option<&'a str>\n-        where P::Searcher: ReverseSearcher<'a>\n+    where\n+        P::Searcher: ReverseSearcher<'a>,\n     {\n-        if self.finished { return None }\n+        if self.finished {\n+            return None;\n+        }\n \n         if !self.allow_trailing_empty {\n             self.allow_trailing_empty = true;\n-            match self.next_back() {\n+            match self.next_back_inclusive() {\n                 Some(elt) if !elt.is_empty() => return Some(elt),\n-                _ => if self.finished { return None }\n+                _ => {\n+                    if self.finished {\n+                        return None;\n+                    }\n+                }\n             }\n         }\n \n         let haystack = self.matcher.haystack();\n         match self.matcher.next_match_back() {\n+            // SAFETY: `Searcher` guarantees that `b` lies on unicode boundary,\n+            // and self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n             Some((_, b)) => unsafe {\n                 let elt = haystack.get_unchecked(b..self.end);\n                 self.end = b;\n                 Some(elt)\n             },\n+            // SAFETY: self.start is either the start of the original string,\n+            // or start of a substring that represents the part of the string that hasn't\n+            // iterated yet. Either way, it is guaranteed to lie on unicode boundary.\n+            // self.end is either the end of the original string,\n+            // or `b` was assigned to it, so it also lies on unicode boundary.\n             None => unsafe {\n                 self.finished = true;\n                 Some(haystack.get_unchecked(self.start..self.end))\n@@ -3268,14 +3288,25 @@ impl str {\n     ///     .split_inclusive('\\n').collect();\n     /// assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\"]);\n     /// ```\n-    #[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+    ///\n+    /// If the last element of the string is matched,\n+    /// that element will be considered the terminator of the preceding substring.\n+    /// That substring will be the last item returned by the iterator.\n+    ///\n+    /// ```\n+    /// #![feature(split_inclusive)]\n+    /// let v: Vec<&str> = \"Mary had a little lamb\\nlittle lamb\\nlittle lamb.\\n\"\n+    ///     .split_inclusive('\\n').collect();\n+    /// assert_eq!(v, [\"Mary had a little lamb\\n\", \"little lamb\\n\", \"little lamb.\\n\"]);\n+    /// ```\n+    #[unstable(feature = \"split_inclusive\", issue = \"none\")]\n     #[inline]\n     pub fn split_inclusive<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitInclusive<'a, P> {\n         SplitInclusive(SplitInternal {\n             start: 0,\n             end: self.len(),\n             matcher: pat.into_searcher(self),\n-            allow_trailing_empty: true,\n+            allow_trailing_empty: false,\n             finished: false,\n         })\n     }\n@@ -4483,7 +4514,7 @@ pub struct SplitAsciiWhitespace<'a> {\n ///\n /// [`split_inclusive`]: ../../std/primitive.str.html#method.split_inclusive\n /// [`str`]: ../../std/primitive.str.html\n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n pub struct SplitInclusive<'a, P: Pattern<'a>>(SplitInternal<'a, P>);\n \n impl_fn_for_zst! {\n@@ -4514,8 +4545,6 @@ impl_fn_for_zst! {\n     };\n }\n \n-\n-\n #[stable(feature = \"split_whitespace\", since = \"1.1.0\")]\n impl<'a> Iterator for SplitWhitespace<'a> {\n     type Item = &'a str;\n@@ -4578,7 +4607,7 @@ impl<'a> DoubleEndedIterator for SplitAsciiWhitespace<'a> {\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n impl FusedIterator for SplitAsciiWhitespace<'_> {}\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n     type Item = &'a str;\n \n@@ -4588,24 +4617,22 @@ impl<'a, P: Pattern<'a>> Iterator for SplitInclusive<'a, P> {\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n impl<'a, P: Pattern<'a, Searcher: fmt::Debug>> fmt::Debug for SplitInclusive<'a, P> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_struct(\"SplitInclusive\")\n-            .field(\"0\", &self.0)\n-            .finish()\n+        f.debug_struct(\"SplitInclusive\").field(\"0\", &self.0).finish()\n     }\n }\n \n // FIXME(#26925) Remove in favor of `#[derive(Clone)]`\n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n impl<'a, P: Pattern<'a, Searcher: Clone>> Clone for SplitInclusive<'a, P> {\n     fn clone(&self) -> Self {\n         SplitInclusive(self.0.clone())\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n     for SplitInclusive<'a, P>\n {\n@@ -4615,7 +4642,7 @@ impl<'a, P: Pattern<'a, Searcher: ReverseSearcher<'a>>> DoubleEndedIterator\n     }\n }\n \n-#[unstable(feature = \"split_inclusive\", issue = \"0\")]\n+#[unstable(feature = \"split_inclusive\", issue = \"none\")]\n impl<'a, P: Pattern<'a>> FusedIterator for SplitInclusive<'a, P> {}\n \n /// An iterator of [`u16`] over the string encoded as UTF-16."}]}