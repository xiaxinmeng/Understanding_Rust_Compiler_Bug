{"sha": "1780d68761c840e69f039857c410cc3fcead068d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3ODBkNjg3NjFjODQwZTY5ZjAzOTg1N2M0MTBjYzNmY2VhZDA2OGQ=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-03-09T01:51:27Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2018-03-09T01:59:52Z"}, "message": "Catch panics in the parser before they crash rustfmt\n\nCloses #753", "tree": {"sha": "5527b413648984a1df79f924c11470ef9ab7746e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5527b413648984a1df79f924c11470ef9ab7746e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1780d68761c840e69f039857c410cc3fcead068d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1780d68761c840e69f039857c410cc3fcead068d", "html_url": "https://github.com/rust-lang/rust/commit/1780d68761c840e69f039857c410cc3fcead068d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1780d68761c840e69f039857c410cc3fcead068d/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8298759607952ca13f5be9b2aefd3c89aa40c4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8298759607952ca13f5be9b2aefd3c89aa40c4f", "html_url": "https://github.com/rust-lang/rust/commit/c8298759607952ca13f5be9b2aefd3c89aa40c4f"}], "stats": {"total": 75, "additions": 43, "deletions": 32}, "files": [{"sha": "fe08b68c7821722e57bdd98b56081a71e9451458", "filename": "src/lib.rs", "status": "modified", "additions": 43, "deletions": 32, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/1780d68761c840e69f039857c410cc3fcead068d/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1780d68761c840e69f039857c410cc3fcead068d/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=1780d68761c840e69f039857c410cc3fcead068d", "patch": "@@ -33,6 +33,7 @@ use std::collections::HashMap;\n use std::fmt;\n use std::io::{self, stdout, BufRead, Write};\n use std::iter::repeat;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::time::Duration;\n@@ -537,43 +538,48 @@ fn parse_input<'sess>(\n     input: Input,\n     parse_session: &'sess ParseSess,\n     config: &Config,\n-) -> Result<ast::Crate, Option<DiagnosticBuilder<'sess>>> {\n-    let result = match input {\n-        Input::File(file) => {\n-            let mut parser = parse::new_parser_from_file(parse_session, &file);\n-            parser.cfg_mods = false;\n-            if config.skip_children() {\n-                parser.recurse_into_file_modules = false;\n-            }\n-            parser.parse_crate_mod()\n-        }\n-        Input::Text(text) => {\n-            let mut parser = parse::new_parser_from_source_str(\n-                parse_session,\n-                FileName::Custom(\"stdin\".to_owned()),\n-                text,\n-            );\n-            parser.cfg_mods = false;\n-            if config.skip_children() {\n-                parser.recurse_into_file_modules = false;\n-            }\n-            parser.parse_crate_mod()\n-        }\n+) -> Result<ast::Crate, ParseError<'sess>> {\n+    let mut parser = match input {\n+        Input::File(file) => parse::new_parser_from_file(parse_session, &file),\n+        Input::Text(text) => parse::new_parser_from_source_str(\n+            parse_session,\n+            FileName::Custom(\"stdin\".to_owned()),\n+            text,\n+        ),\n     };\n \n+    parser.cfg_mods = false;\n+    if config.skip_children() {\n+        parser.recurse_into_file_modules = false;\n+    }\n+\n+    let mut parser = AssertUnwindSafe(parser);\n+    let result = catch_unwind(move || parser.0.parse_crate_mod());\n+\n     match result {\n-        Ok(c) => {\n+        Ok(Ok(c)) => {\n             if parse_session.span_diagnostic.has_errors() {\n                 // Bail out if the parser recovered from an error.\n-                Err(None)\n+                Err(ParseError::Recovered)\n             } else {\n                 Ok(c)\n             }\n         }\n-        Err(e) => Err(Some(e)),\n+        Ok(Err(e)) => Err(ParseError::Error(e)),\n+        Err(_) => Err(ParseError::Panic),\n     }\n }\n \n+/// All the ways that parsing can fail.\n+enum ParseError<'sess> {\n+    /// There was an error, but the parser recovered.\n+    Recovered,\n+    /// There was an error (supplied) and parsing failed.\n+    Error(DiagnosticBuilder<'sess>),\n+    /// The parser panicked.\n+    Panic,\n+}\n+\n /// Format the given snippet. The snippet is expected to be *complete* code.\n /// When we cannot parse the given snippet, this function returns `None`.\n pub fn format_snippet(snippet: &str, config: &Config) -> Option<String> {\n@@ -682,9 +688,18 @@ pub fn format_input<T: Write>(\n \n     let krate = match parse_input(input, &parse_session, config) {\n         Ok(krate) => krate,\n-        Err(diagnostic) => {\n-            if let Some(mut diagnostic) = diagnostic {\n-                diagnostic.emit();\n+        Err(err) => {\n+            match err {\n+                ParseError::Error(mut diagnostic) => diagnostic.emit(),\n+                ParseError::Panic => {\n+                    // Note that if you see this message and want more information,\n+                    // then go to `parse_input` and run the parse function without\n+                    // `catch_unwind` so rustfmt panics and you can get a backtrace.\n+                    should_emit_verbose(&main_file, config, || {\n+                        println!(\"The Rust parser panicked\")\n+                    });\n+                }\n+                ParseError::Recovered => {}\n             }\n             summary.add_parsing_error();\n             return Ok((summary, FileMap::new(), FormatReport::new()));\n@@ -693,10 +708,6 @@ pub fn format_input<T: Write>(\n \n     summary.mark_parse_time();\n \n-    if parse_session.span_diagnostic.has_errors() {\n-        summary.add_parsing_error();\n-    }\n-\n     // Suppress error output after parsing.\n     let silent_emitter = Box::new(EmitterWriter::new(\n         Box::new(Vec::new()),"}]}