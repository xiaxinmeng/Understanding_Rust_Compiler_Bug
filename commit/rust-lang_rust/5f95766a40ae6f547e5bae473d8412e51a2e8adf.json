{"sha": "5f95766a40ae6f547e5bae473d8412e51a2e8adf", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVmOTU3NjZhNDBhZTZmNTQ3ZTViYWU0NzNkODQxMmU1MWEyZThhZGY=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-05T01:13:00Z"}, "committer": {"name": "Lindsey Kuper", "email": "lkuper@mozilla.com", "date": "2011-06-05T01:34:40Z"}, "message": "Remove redundant 'fail' exprs and dead code; use sess.bug or\nsess.span_err instead of 'fail'.  (issue #444)", "tree": {"sha": "c7d5e6b886eed2a843d4f0633683cc34c30d8017", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7d5e6b886eed2a843d4f0633683cc34c30d8017"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5f95766a40ae6f547e5bae473d8412e51a2e8adf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5f95766a40ae6f547e5bae473d8412e51a2e8adf", "html_url": "https://github.com/rust-lang/rust/commit/5f95766a40ae6f547e5bae473d8412e51a2e8adf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5f95766a40ae6f547e5bae473d8412e51a2e8adf/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "53ea2a475150cd854d10d583ec19a0b43925fe58", "url": "https://api.github.com/repos/rust-lang/rust/commits/53ea2a475150cd854d10d583ec19a0b43925fe58", "html_url": "https://github.com/rust-lang/rust/commit/53ea2a475150cd854d10d583ec19a0b43925fe58"}], "stats": {"total": 94, "additions": 27, "deletions": 67}, "files": [{"sha": "56d8d3450ae032b757bcb439168fd83caca14252", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5f95766a40ae6f547e5bae473d8412e51a2e8adf/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f95766a40ae6f547e5bae473d8412e51a2e8adf/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=5f95766a40ae6f547e5bae473d8412e51a2e8adf", "patch": "@@ -308,7 +308,6 @@ fn resolve_names(&@env e, &ast::crate c) {\n                     case (_) {\n                         e.sess.span_err(p.span, \"not a tag variant: \" +\n                                         str::connect(p.node.idents, \"::\"));\n-                        fail;\n                     }\n                 }\n                 for (@ast::pat child in children) {\n@@ -412,7 +411,6 @@ fn follow_import(&env e, &list[scope] sc, vec[ident] path, &span sp)\n         case (_) {\n             e.sess.span_err(sp, str::connect(path, \"::\") \n                             + \" does not name a module.\");\n-            fail;\n         }\n     }\n }\n@@ -508,12 +506,13 @@ fn lookup_in_scope_strict(&env e, list[scope] sc, &span sp, &ident id,\n     alt (lookup_in_scope(e, sc, sp, id, ns)) {\n         case (none) {\n             unresolved(e, sp, id, ns_name(ns));\n-            fail;\n         }\n         case (some(?d)) {\n             ret d;\n         }\n     }\n+\n+    fail; // fools the return-checker\n }\n \n fn scope_is_fn(&scope sc) -> bool {\n@@ -640,7 +639,6 @@ fn lookup_in_scope(&env e, list[scope] sc, &span sp, &ident id, namespace ns)\n         }\n     }\n     e.sess.bug(\"reached unreachable code in lookup_in_scope\"); // sigh\n-    fail;\n }\n \n fn lookup_in_ty_params(&ident id, &vec[ast::ty_param] ty_params)\n@@ -790,12 +788,13 @@ fn lookup_in_mod_strict(&env e, def m, &span sp, &ident id,\n     alt (lookup_in_mod(e, m, sp, id, ns, dr)) {\n         case (none) {\n             unresolved(e, sp, id, ns_name(ns));\n-            fail;\n         }\n         case (some(?d)) {\n             ret d;\n         }\n     }\n+\n+    fail; // fools the return-checker\n }\n \n fn lookup_in_mod(&env e, def m, &span sp, &ident id, namespace ns, dir dr)\n@@ -855,7 +854,7 @@ fn lookup_import(&env e, def_id defid, namespace ns) -> option::t[def] {\n                            case (ns_module) { md } };\n         }\n     }\n-    fail;\n+    fail; // fools the return-checker\n }\n \n \n@@ -915,7 +914,6 @@ fn lookup_glob_in_mod(&env e, @indexed_mod info, &span sp,\n             }\n             e.sess.span_err(sp, \"'\" + id + \"' is glob-imported from\" +\n                             \" multiple different modules.\");\n-            fail;\n         }\n     }\n     // since we don't know what names we have in advance,"}, {"sha": "a5ec52b40c8bd79f3af1e5834a990ec955c12d78", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 21, "deletions": 48, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/5f95766a40ae6f547e5bae473d8412e51a2e8adf/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f95766a40ae6f547e5bae473d8412e51a2e8adf/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=5f95766a40ae6f547e5bae473d8412e51a2e8adf", "patch": "@@ -715,7 +715,6 @@ fn type_of(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n         cx.sess.span_err (sp,\n           \"type_of() called on a type with dynamic size: \" +\n                           ty::ty_to_str(cx.tcx, t));\n-        fail;\n     }\n \n     ret type_of_inner(cx, sp, t);\n@@ -937,14 +936,14 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = abs_pair;\n         }\n         case (ty::ty_var(_)) {\n-            cx.tcx.sess.span_err(sp, \"ty_var in trans::type_of\");\n+            cx.tcx.sess.span_err(sp, \"trans::type_of called on ty_var\");\n         }\n         case (ty::ty_param(_)) {\n             llty = T_i8();\n         }\n         case (ty::ty_bound_param(_)) {\n-            log_err \"ty_bound_param in trans::type_of\";\n-            fail;\n+            cx.tcx.sess.span_err(sp, \n+                                 \"trans::type_of called on ty_bound_param\");\n         }\n         case (ty::ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n     }\n@@ -1212,21 +1211,12 @@ fn find_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n             be find_scope_cx(b);\n         }\n         case (parent_none) {\n-            fail;\n+            cx.fcx.lcx.ccx.sess.bug(\"trans::find_scope_cx() \"\n+                                    + \"called on parentless block_ctxt\");\n         }\n     }\n-}\n \n-fn find_outer_scope_cx(&@block_ctxt cx) -> @block_ctxt {\n-    auto scope_cx = find_scope_cx(cx);\n-    alt (cx.parent) {\n-        case (parent_some(?b)) {\n-            be find_scope_cx(b);\n-        }\n-        case (parent_none) {\n-            fail;\n-        }\n-    }\n+    fail; // fools the return-checker\n }\n \n fn umax(&@block_ctxt cx, ValueRef a, ValueRef b) -> ValueRef {\n@@ -1320,8 +1310,8 @@ fn simplify_type(&@crate_ctxt ccx, &ty::t typ) -> ty::t {\n // Computes the size of the data part of a non-dynamically-sized tag.\n fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n     if (ty::type_has_dynamic_size(cx.tcx, t)) {\n-        log_err \"dynamically sized type passed to static_size_of_tag()\";\n-        fail;\n+        cx.tcx.sess.span_err(sp, \"dynamically sized type passed to \"\n+                             + \"static_size_of_tag()\");\n     }\n \n     if (cx.tag_sizes.contains_key(t)) {\n@@ -1336,8 +1326,8 @@ fn static_size_of_tag(&@crate_ctxt cx, &span sp, &ty::t t) -> uint {\n             subtys = subtys_;\n         }\n         case (_) {\n-            log_err \"non-tag passed to static_size_of_tag()\";\n-            fail;\n+            cx.tcx.sess.span_err(sp, \"non-tag passed to \"\n+                                 + \"static_size_of_tag()\");\n         }\n     }\n \n@@ -2570,7 +2560,8 @@ fn make_scalar_cmp_glue(&@block_ctxt cx, ValueRef lhs, ValueRef rhs,\n         }\n         case (_) {\n             // Should never get here, because t is scalar.\n-            fail;\n+            cx.fcx.lcx.ccx.sess.bug(\"non-scalar type passed to \"\n+                                    + \"make_scalar_cmp_glue\");\n         }\n     }\n }\n@@ -2812,7 +2803,6 @@ fn iter_structural_ty_full(&@block_ctxt cx,\n                                 j += 1;\n                             }\n                         }\n-                        case (_) { fail; }\n                     }\n \n                     variant_cx.build.Br(next_cx.llbb);\n@@ -2984,7 +2974,6 @@ fn iter_sequence(@block_ctxt cx,\n             cx.fcx.lcx.ccx.sess.bug(\"unexpected type in \" +\n                                     \"trans::iter_sequence: \" +\n                                     ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n-            fail; \n         }\n     }\n }\n@@ -3329,7 +3318,6 @@ fn copy_val(&@block_ctxt cx,\n \n     cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans::copy_val: \" +\n                         ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n-    fail;\n }\n \n // This works like copy_val, except that it deinitializes the source.\n@@ -3367,7 +3355,6 @@ fn move_val(&@block_ctxt cx,\n \n     cx.fcx.lcx.ccx.sess.bug(\"unexpected type in trans::move_val: \" +\n                         ty::ty_to_str(cx.fcx.lcx.ccx.tcx, t));\n-    fail;\n }\n \n \n@@ -3490,12 +3477,11 @@ fn trans_unary(&@block_ctxt cx, ast::unop op,\n             ret res(sub.bcx, box);\n         }\n         case (ast::deref) {\n-            log_err \"deref expressions should have been translated using \" +\n-                \"trans_lval(), not trans_unary()\";\n-            fail;\n+            cx.fcx.lcx.ccx.sess.bug(\"deref expressions should have been \"\n+                                    + \"translated using trans_lval(), not \"\n+                                    + \"trans_unary()\");\n         }\n     }\n-    fail;\n }\n \n fn trans_compare(&@block_ctxt cx0, ast::binop op, &ty::t t0,\n@@ -3659,7 +3645,6 @@ fn trans_eager_binop(&@block_ctxt cx, ast::binop op, &ty::t intype,\n             ret trans_compare(cx, op, intype, lhs, rhs);\n         }\n     }\n-    fail;\n }\n \n fn autoderef(&@block_ctxt cx, ValueRef v, &ty::t t) -> result {\n@@ -3783,7 +3768,6 @@ fn trans_binary(&@block_ctxt cx, ast::binop op,\n                 autoderefed_ty(cx.fcx.lcx.ccx, lhty), lhs.val, rhs.val);\n         }\n     }\n-    fail;\n }\n \n fn join_results(&@block_ctxt parent_cx,\n@@ -4211,7 +4195,6 @@ fn trans_for_each(&@block_ctxt cx,\n             ret res(r.bcx, C_nil());\n         }\n     }\n-    fail;\n }\n \n \n@@ -4325,8 +4308,6 @@ fn trans_pat_match(&@block_ctxt cx, &@ast::pat pat, ValueRef llval,\n             ret res(matched_cx, llval);\n         }\n     }\n-\n-    fail;\n }\n \n fn trans_pat_binding(&@block_ctxt cx, &@ast::pat pat,\n@@ -4650,7 +4631,6 @@ fn trans_field(&@block_ctxt cx, &span sp, ValueRef v, &ty::t t0,\n         }\n         case (_) {cx.fcx.lcx.ccx.sess.unimpl(\"field variant in trans_field\");}\n     }\n-    fail;\n }\n \n fn trans_index(&@block_ctxt cx, &span sp, &@ast::expr base,\n@@ -4747,7 +4727,9 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n                 }\n                 case (_) {\n                     // Shouldn't happen.\n-                    fail;\n+                    cx.fcx.lcx.ccx.sess.bug(\n+                        \"trans_lval called on expr_self_method in a context\"\n+                        + \"without llself\");\n                 }\n \n             }\n@@ -4758,7 +4740,6 @@ fn trans_lval(&@block_ctxt cx, &@ast::expr e) -> lval_result {\n                                             + pretty::pprust::expr_to_str(e));\n         }\n     }\n-    fail;\n }\n \n fn int_cast(&@block_ctxt bcx, TypeRef lldsttype, TypeRef llsrctype,\n@@ -5898,7 +5879,6 @@ fn trans_log(int lvl, &@block_ctxt cx, &@ast::expr e) -> result {\n                 cx.fcx.lcx.ccx.sess.span_err(e.span,\n                                  \"log called on unsupported type \" +\n                                   ty::ty_to_str(cx.fcx.lcx.ccx.tcx, e_ty));\n-                fail;\n             }\n         }\n     }\n@@ -6017,7 +5997,9 @@ fn trans_break_cont(&@block_ctxt cx, bool to_end) -> result {\n             }\n         }\n     }\n-    fail;\n+\n+    // If we get here without returning, it's a bug\n+    cx.fcx.lcx.ccx.sess.bug(\"in trans::trans_break_cont()\");\n }\n \n fn trans_break(&@block_ctxt cx) -> result {\n@@ -6085,7 +6067,6 @@ fn trans_port(&@block_ctxt cx, &ast::ann ann) -> result {\n         }\n         case (_) {\n             cx.fcx.lcx.ccx.sess.bug(\"non-port type in trans_port\");\n-            fail;\n         }\n     }\n \n@@ -6310,7 +6291,6 @@ fn trans_send(&@block_ctxt cx, &@ast::expr lhs, &@ast::expr rhs,\n         }\n         case (_) {\n             bcx.fcx.lcx.ccx.sess.bug(\"non-chan type in trans_send\");\n-            fail;\n         }\n     }\n \n@@ -6432,7 +6412,6 @@ fn trans_anon_obj(&@block_ctxt cx, &span sp,\n     // TODO: everything else.\n \n     cx.fcx.lcx.ccx.sess.unimpl(\"support for anonymous objects\");\n-    fail;\n }\n \n fn init_local(&@block_ctxt cx, &@ast::local local) -> result {\n@@ -6917,7 +6896,6 @@ fn arg_tys_of_fn(&@crate_ctxt ccx, ast::ann ann) -> vec[ty::arg] {\n             ret arg_tys;\n         }\n     }\n-    fail;\n }\n \n fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n@@ -6926,7 +6904,6 @@ fn ret_ty_of_fn_ty(&@crate_ctxt ccx, ty::t t) -> ty::t {\n             ret ret_ty;\n         }\n     }\n-    fail;\n }\n \n \n@@ -7515,7 +7492,6 @@ fn decl_fn_and_pair(&@crate_ctxt ccx, &span sp,\n         }\n         case (_) {\n             ccx.sess.bug(\"decl_fn_and_pair(): fn item doesn't have fn type!\");\n-            fail;\n         }\n     }\n \n@@ -7558,7 +7534,6 @@ fn native_fn_ty_param_count(&@crate_ctxt cx, &ast::def_id id) -> uint {\n         case (ast::native_item_ty(_,_)) {\n             cx.sess.bug(\"decl_native_fn_and_pair(): native fn isn't \" +\n                         \"actually a fn?!\");\n-            fail;\n         }\n         case (ast::native_item_fn(_, _, _, ?tps, _, _)) {\n             count = vec::len[ast::ty_param](tps);\n@@ -7574,7 +7549,6 @@ fn native_fn_wrapper_type(&@crate_ctxt cx, &span sp, uint ty_param_count,\n             ret type_of_fn(cx, sp, ast::proto_fn, args, out, ty_param_count);\n         }\n     }\n-    fail;\n }\n \n fn decl_native_fn_and_pair(&@crate_ctxt ccx,\n@@ -8013,7 +7987,6 @@ fn find_main_fn(&@crate_ctxt cx) -> ValueRef {\n             cx.sess.err(\"multiple main fns found\");\n         }\n     }\n-    fail;\n }\n \n fn trans_main_fn(@local_ctxt cx, ValueRef crate_map) {"}, {"sha": "6dd5ae76ff912fabb54901260af90e2f4ee03738", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/5f95766a40ae6f547e5bae473d8412e51a2e8adf/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f95766a40ae6f547e5bae473d8412e51a2e8adf/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=5f95766a40ae6f547e5bae473d8412e51a2e8adf", "patch": "@@ -1895,7 +1895,6 @@ fn field_idx(&session::session sess, &span sp,\n         i += 1u;\n     }\n     sess.span_err(sp, \"unknown field '\" + id + \"' of record\");\n-    fail;\n }\n \n fn method_idx(&session::session sess, &span sp,\n@@ -1908,7 +1907,6 @@ fn method_idx(&session::session sess, &span sp,\n         i += 1u;\n     }\n     sess.span_err(sp, \"unknown method '\" + id + \"' of obj\");\n-    fail;\n }\n \n fn sort_methods(&vec[method] meths) -> vec[method] {\n@@ -2904,7 +2902,6 @@ fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n             }\n         }\n     }\n-    fail;   // not reached\n }\n \n // Returns information about the tag variant with the given ID:"}, {"sha": "c373c27fc18a9d4d493eb453658bed58217a8372", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/5f95766a40ae6f547e5bae473d8412e51a2e8adf/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5f95766a40ae6f547e5bae473d8412e51a2e8adf/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=5f95766a40ae6f547e5bae473d8412e51a2e8adf", "patch": "@@ -102,7 +102,6 @@ fn substitute_ty_params(&@crate_ctxt ccx,\n                           uint::to_str(ty_param_count, 10u) +\n                           \" type parameter(s) but found \" +\n                           uint::to_str(supplied_len, 10u) + \" parameter(s)\");\n-        fail;\n     }\n \n     if (!ty::type_contains_bound_params(ccx.tcx, typ)) {\n@@ -162,13 +161,11 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &span sp, &ast::def defn)\n \n         case (ast::def_ty(_)) {\n             fcx.ccx.tcx.sess.span_err(sp, \"expected value but found type\");\n-            fail;\n         }\n \n         case (_) {\n             // FIXME: handle other names.\n             fcx.ccx.tcx.sess.unimpl(\"definition variant\");\n-            fail;\n         }\n     }\n }\n@@ -332,7 +329,7 @@ fn ast_ty_to_ty(&ty::ctxt tcx, &ty_getter getter, &@ast::ty ast_ty) -> ty::t {\n                 case (_)                   {\n                     tcx.sess.span_err(ast_ty.span,\n                        \"found type name used as a variable\");\n-                    fail; }\n+                }\n             }\n \n             cname = some(path_to_str(path));\n@@ -1041,7 +1038,6 @@ mod demand {\n \n                 // TODO: In the future, try returning \"expected\", reporting\n                 // the error, and continue.\n-                fail;\n             }\n         }\n     }\n@@ -1437,7 +1433,6 @@ mod pushdown {\n                 scx.fcx.ccx.tcx.sess.span_unimpl(e.span,\n                     #fmt(\"type unification for expression variant: %s\",\n                          pretty::pprust::expr_to_str(e)));\n-                fail;\n             }\n         }\n     }\n@@ -1468,7 +1463,6 @@ mod writeback {\n             case (none) {\n                 fcx.ccx.tcx.sess.span_err(sp,\n                     \"unable to determine type of local: \" + local.ident);\n-                fail;\n             }\n             case (some(?lt)) {\n                 local_ty = lt;\n@@ -1774,7 +1768,6 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n                     + \" instead having: \" +\n                     ty_to_str(scx.fcx.ccx.tcx,\n                               expr_ty(scx.fcx.ccx.tcx, f)));\n-                fail;\n             }\n         }\n \n@@ -1903,7 +1896,6 @@ fn check_expr(&@stmt_ctxt scx, &@ast::expr expr) {\n             if (vec::len[@ast::ty](pth.node.types) > 0u) {\n                 scx.fcx.ccx.tcx.sess.span_err(expr.span,\n                     \"this kind of value does not take type parameters\");\n-                fail;\n             }\n \n             write::ty_only_fixup(scx, old_ann.id, tpt._1);"}]}