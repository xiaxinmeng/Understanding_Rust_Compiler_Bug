{"sha": "3db5cf6f1da06c4aadc5395e69f81afcd25e7555", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkYjVjZjZmMWRhMDZjNGFhZGM1Mzk1ZTY5ZjgxYWZjZDI1ZTc1NTU=", "commit": {"author": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-07-02T21:18:39Z"}, "committer": {"name": "Kevin Ballard", "email": "kevin@sb.org", "date": "2014-07-30T17:36:45Z"}, "message": "Update docs for TLS -> TLD\n\nThe correct terminology is Task-Local Data, or TLD. Task-Local Storage,\nor TLS, is the old terminology that was abandoned because of the\nconfusion with Thread-Local Storage (TLS).", "tree": {"sha": "b220f4e2696403ec61ad9b1eb6e06ab015f7c968", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b220f4e2696403ec61ad9b1eb6e06ab015f7c968"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3db5cf6f1da06c4aadc5395e69f81afcd25e7555", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3db5cf6f1da06c4aadc5395e69f81afcd25e7555", "html_url": "https://github.com/rust-lang/rust/commit/3db5cf6f1da06c4aadc5395e69f81afcd25e7555", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3db5cf6f1da06c4aadc5395e69f81afcd25e7555/comments", "author": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lilyball", "id": 714, "node_id": "MDQ6VXNlcjcxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/714?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lilyball", "html_url": "https://github.com/lilyball", "followers_url": "https://api.github.com/users/lilyball/followers", "following_url": "https://api.github.com/users/lilyball/following{/other_user}", "gists_url": "https://api.github.com/users/lilyball/gists{/gist_id}", "starred_url": "https://api.github.com/users/lilyball/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lilyball/subscriptions", "organizations_url": "https://api.github.com/users/lilyball/orgs", "repos_url": "https://api.github.com/users/lilyball/repos", "events_url": "https://api.github.com/users/lilyball/events{/privacy}", "received_events_url": "https://api.github.com/users/lilyball/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ebf4813a6503d5312f457b8a6ba7b6998a45f2b", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ebf4813a6503d5312f457b8a6ba7b6998a45f2b", "html_url": "https://github.com/rust-lang/rust/commit/5ebf4813a6503d5312f457b8a6ba7b6998a45f2b"}], "stats": {"total": 44, "additions": 22, "deletions": 22}, "files": [{"sha": "972e19925f48b383c93f3e70a0e167c3378bf944", "filename": "src/librustrt/local_data.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/3db5cf6f1da06c4aadc5395e69f81afcd25e7555/src%2Flibrustrt%2Flocal_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3db5cf6f1da06c4aadc5395e69f81afcd25e7555/src%2Flibrustrt%2Flocal_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustrt%2Flocal_data.rs?ref=3db5cf6f1da06c4aadc5395e69f81afcd25e7555", "patch": "@@ -12,9 +12,9 @@\n \n Task local data management\n \n-Allows storing arbitrary types inside task-local-storage (TLS), to be accessed\n+Allows storing arbitrary types inside task-local-data (TLD), to be accessed\n anywhere within a task, keyed by a global pointer parameterized over the type of\n-the TLS slot.  Useful for dynamic variables, singletons, and interfacing with\n+the TLD slot. Useful for dynamic variables, singletons, and interfacing with\n foreign code with bad callback interfaces.\n \n To declare a new key for storing local data of a particular type, use the\n@@ -70,16 +70,16 @@ pub enum KeyValue<T> { Key }\n trait LocalData {}\n impl<T: 'static> LocalData for T {}\n \n-// The task-local-map stores all TLS information for the currently running task.\n+// The task-local-map stores all TLD information for the currently running task.\n // It is stored as an owned pointer into the runtime, and it's only allocated\n-// when TLS is used for the first time. This map must be very carefully\n+// when TLD is used for the first time. This map must be very carefully\n // constructed because it has many mutable loans unsoundly handed out on it to\n-// the various invocations of TLS requests.\n+// the various invocations of TLD requests.\n //\n // One of the most important operations is loaning a value via `get` to a\n-// caller. In doing so, the slot that the TLS entry is occupying cannot be\n+// caller. In doing so, the slot that the TLD entry is occupying cannot be\n // invalidated because upon returning its loan state must be updated. Currently\n-// the TLS map is a vector, but this is possibly dangerous because the vector\n+// the TLD map is a vector, but this is possibly dangerous because the vector\n // can be reallocated/moved when new values are pushed onto it.\n //\n // This problem currently isn't solved in a very elegant way. Inside the `get`\n@@ -88,11 +88,11 @@ impl<T: 'static> LocalData for T {}\n // pointers from being moved under our feet so long as LLVM doesn't go too crazy\n // with the optimizations.\n //\n-// n.b. If TLS is used heavily in future, this could be made more efficient with\n+// n.b. If TLD is used heavily in future, this could be made more efficient with\n //      a proper map.\n #[doc(hidden)]\n-pub type Map = Vec<Option<(*const u8, TLSValue, uint)>>;\n-type TLSValue = Box<LocalData + Send>;\n+pub type Map = Vec<Option<(*const u8, TLDValue, uint)>>;\n+type TLDValue = Box<LocalData + Send>;\n \n // Gets the map from the runtime. Lazily initialises if not done so already.\n unsafe fn get_local_map<'a>() -> Option<&'a mut Map> {\n@@ -101,11 +101,11 @@ unsafe fn get_local_map<'a>() -> Option<&'a mut Map> {\n     let task: *mut Task = Local::unsafe_borrow();\n     match &mut (*task).storage {\n         // If the at_exit function is already set, then we just need to take\n-        // a loan out on the TLS map stored inside\n+        // a loan out on the TLD map stored inside\n         &LocalStorage(Some(ref mut map_ptr)) => {\n             return Some(map_ptr);\n         }\n-        // If this is the first time we've accessed TLS, perform similar\n+        // If this is the first time we've accessed TLD, perform similar\n         // actions to the oldsched way of doing things.\n         &LocalStorage(ref mut slot) => {\n             *slot = Some(Vec::new());\n@@ -135,14 +135,14 @@ pub struct Ref<T> {\n }\n \n impl<T: 'static> KeyValue<T> {\n-    /// Replaces a value in task local storage.\n+    /// Replaces a value in task local data.\n     ///\n-    /// If this key is already present in TLS, then the previous value is\n+    /// If this key is already present in TLD, then the previous value is\n     /// replaced with the provided data, and then returned.\n     ///\n     /// # Failure\n     ///\n-    /// This function will fail if this key is present in TLS and currently on\n+    /// This function will fail if this key is present in TLD and currently on\n     /// loan with the `get` method.\n     ///\n     /// # Example\n@@ -171,7 +171,7 @@ impl<T: 'static> KeyValue<T> {\n         //\n         // Additionally, the type of the local data map must ascribe to Send, so\n         // we do the transmute here to add the Send bound back on. This doesn't\n-        // actually matter because TLS will always own the data (until its moved\n+        // actually matter because TLD will always own the data (until its moved\n         // out) and we're not actually sending it to other schedulers or\n         // anything.\n         let newval = data.map(|d| {\n@@ -182,7 +182,7 @@ impl<T: 'static> KeyValue<T> {\n \n         let pos = match self.find(map) {\n             Some((i, _, &0)) => Some(i),\n-            Some((_, _, _)) => fail!(\"TLS value cannot be replaced because it \\\n+            Some((_, _, _)) => fail!(\"TLD value cannot be replaced because it \\\n                                       is already borrowed\"),\n             None => map.iter().position(|entry| entry.is_none()),\n         };\n@@ -207,11 +207,11 @@ impl<T: 'static> KeyValue<T> {\n         }\n     }\n \n-    /// Borrows a value from TLS.\n+    /// Borrows a value from TLD.\n     ///\n-    /// If `None` is returned, then this key is not present in TLS. If `Some` is\n+    /// If `None` is returned, then this key is not present in TLD. If `Some` is\n     /// returned, then the returned data is a smart pointer representing a new\n-    /// loan on this TLS key. While on loan, this key cannot be altered via the\n+    /// loan on this TLD key. While on loan, this key cannot be altered via the\n     /// `replace` method.\n     ///\n     /// # Example\n@@ -246,7 +246,7 @@ impl<T: 'static> KeyValue<T> {\n     }\n \n     fn find<'a>(&'static self,\n-                map: &'a mut Map) -> Option<(uint, &'a TLSValue, &'a mut uint)>{\n+                map: &'a mut Map) -> Option<(uint, &'a TLDValue, &'a mut uint)>{\n         let key_value = key_to_key_value(self);\n         map.mut_iter().enumerate().filter_map(|(i, entry)| {\n             match *entry {\n@@ -285,7 +285,7 @@ mod tests {\n         static my_key: Key<String> = &Key;\n         my_key.replace(Some(\"parent data\".to_string()));\n         task::spawn(proc() {\n-            // TLS shouldn't carry over.\n+            // TLD shouldn't carry over.\n             assert!(my_key.get().is_none());\n             my_key.replace(Some(\"child data\".to_string()));\n             assert!(my_key.get().get_ref().as_slice() == \"child data\");"}]}