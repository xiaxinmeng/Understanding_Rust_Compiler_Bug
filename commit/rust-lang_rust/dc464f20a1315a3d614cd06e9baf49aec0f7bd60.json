{"sha": "dc464f20a1315a3d614cd06e9baf49aec0f7bd60", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRjNDY0ZjIwYTEzMTVhM2Q2MTRjZDA2ZTliYWY0OWFlYzBmN2JkNjA=", "commit": {"author": {"name": "Yuki Okushi", "email": "jtitor@2k36.org", "date": "2021-07-15T12:19:19Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-15T12:19:19Z"}, "message": "Rollup merge of #87127 - poliorcetics:ptr-rotate-safety, r=scottmcm\n\nAdd safety comments in private core::slice::rotate::ptr_rotate function\n\nHelps with #66219.\n\n```@rustbot``` label C-cleanup T-compiler T-libs", "tree": {"sha": "c62c441e7d8fe4d1d26a1bbdff02f88f026d14f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c62c441e7d8fe4d1d26a1bbdff02f88f026d14f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dc464f20a1315a3d614cd06e9baf49aec0f7bd60", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg8CfHCRBK7hj4Ov3rIwAAEXkIAIgBIXAZlzvj0lFZ1GMaQ9Zn\nS+u/5ofQTse8aWnnak2ADn5cFpLlS9rXfVfgoCjFxv/wQ07zyjcPog7gQ9ol3u2a\nthkVLdXEvOTeeJuirXT1n2pM2GeUK1dJZa+pHhIQdnmOEw9T8LpjCG+Iiq1Pxchm\nQhcsVFvnG/pJ61JwQXbocq7dCreRVItSUqRpjjFs/TxS3oOsp5XE/fjIi3EwYKM1\n08boy/Apt1E/XrvE+hRUwTD1ErSAITCDj4LKtjGlkTprOc4KXicB59w3K+GtzD8c\nqWZVp2+fKJN5LdMdq+pDGkptmnZqYNTge1nCZbf6Ua3c8UHQqnBOtH8GFfiBEvE=\n=Chgw\n-----END PGP SIGNATURE-----\n", "payload": "tree c62c441e7d8fe4d1d26a1bbdff02f88f026d14f4\nparent b99f7edad2ba7d7ac8b8a6cee5d72f4907c85b9c\nparent 4541aa971f94f5b262ac44bbba3ad0561c76477b\nauthor Yuki Okushi <jtitor@2k36.org> 1626351559 +0900\ncommitter GitHub <noreply@github.com> 1626351559 +0900\n\nRollup merge of #87127 - poliorcetics:ptr-rotate-safety, r=scottmcm\n\nAdd safety comments in private core::slice::rotate::ptr_rotate function\n\nHelps with #66219.\n\n```@rustbot``` label C-cleanup T-compiler T-libs\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dc464f20a1315a3d614cd06e9baf49aec0f7bd60", "html_url": "https://github.com/rust-lang/rust/commit/dc464f20a1315a3d614cd06e9baf49aec0f7bd60", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dc464f20a1315a3d614cd06e9baf49aec0f7bd60/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b99f7edad2ba7d7ac8b8a6cee5d72f4907c85b9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/b99f7edad2ba7d7ac8b8a6cee5d72f4907c85b9c", "html_url": "https://github.com/rust-lang/rust/commit/b99f7edad2ba7d7ac8b8a6cee5d72f4907c85b9c"}, {"sha": "4541aa971f94f5b262ac44bbba3ad0561c76477b", "url": "https://api.github.com/repos/rust-lang/rust/commits/4541aa971f94f5b262ac44bbba3ad0561c76477b", "html_url": "https://github.com/rust-lang/rust/commit/4541aa971f94f5b262ac44bbba3ad0561c76477b"}], "stats": {"total": 56, "additions": 54, "deletions": 2}, "files": [{"sha": "7528927ef33b9a57297f8330e323856cd518a5bb", "filename": "library/core/src/slice/rotate.rs", "status": "modified", "additions": 54, "deletions": 2, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/dc464f20a1315a3d614cd06e9baf49aec0f7bd60/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/dc464f20a1315a3d614cd06e9baf49aec0f7bd60/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Frotate.rs?ref=dc464f20a1315a3d614cd06e9baf49aec0f7bd60", "patch": "@@ -1,5 +1,3 @@\n-// ignore-tidy-undocumented-unsafe\n-\n use crate::cmp;\n use crate::mem::{self, MaybeUninit};\n use crate::ptr;\n@@ -79,8 +77,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the way until about `left + right == 32`, but the worst case performance breaks even\n             // around 16. 24 was chosen as middle ground. If the size of `T` is larger than 4\n             // `usize`s, this algorithm also outperforms other algorithms.\n+            // SAFETY: callers must ensure `mid - left` is valid for reading and writing.\n             let x = unsafe { mid.sub(left) };\n             // beginning of first round\n+            // SAFETY: see previous comment.\n             let mut tmp: T = unsafe { x.read() };\n             let mut i = right;\n             // `gcd` can be found before hand by calculating `gcd(left + right, right)`,\n@@ -92,6 +92,21 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // the very end. This is possibly due to the fact that swapping or replacing temporaries\n             // uses only one memory address in the loop instead of needing to manage two.\n             loop {\n+                // [long-safety-expl]\n+                // SAFETY: callers must ensure `[left, left+mid+right)` are all valid for reading and\n+                // writing.\n+                //\n+                // - `i` start with `right` so `mid-left <= x+i = x+right = mid-left+right < mid+right`\n+                // - `i <= left+right-1` is always true\n+                //   - if `i < left`, `right` is added so `i < left+right` and on the next\n+                //     iteration `left` is removed from `i` so it doesn't go further\n+                //   - if `i >= left`, `left` is removed immediately and so it doesn't go further.\n+                // - overflows cannot happen for `i` since the function's safety contract ask for\n+                //   `mid+right-1 = x+left+right` to be valid for writing\n+                // - underflows cannot happen because `i` must be bigger or equal to `left` for\n+                //   a substraction of `left` to happen.\n+                //\n+                // So `x+i` is valid for reading and writing if the caller respected the contract\n                 tmp = unsafe { x.add(i).replace(tmp) };\n                 // instead of incrementing `i` and then checking if it is outside the bounds, we\n                 // check if `i` will go outside the bounds on the next increment. This prevents\n@@ -100,6 +115,8 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n                     i -= left;\n                     if i == 0 {\n                         // end of first round\n+                        // SAFETY: tmp has been read from a valid source and x is valid for writing\n+                        // according to the caller.\n                         unsafe { x.write(tmp) };\n                         break;\n                     }\n@@ -113,13 +130,24 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             }\n             // finish the chunk with more rounds\n             for start in 1..gcd {\n+                // SAFETY: `gcd` is at most equal to `right` so all values in `1..gcd` are valid for\n+                // reading and writing as per the function's safety contract, see [long-safety-expl]\n+                // above\n                 tmp = unsafe { x.add(start).read() };\n+                // [safety-expl-addition]\n+                //\n+                // Here `start < gcd` so `start < right` so `i < right+right`: `right` being the\n+                // greatest common divisor of `(left+right, right)` means that `left = right` so\n+                // `i < left+right` so `x+i = mid-left+i` is always valid for reading and writing\n+                // according to the function's safety contract.\n                 i = start + right;\n                 loop {\n+                    // SAFETY: see [long-safety-expl] and [safety-expl-addition]\n                     tmp = unsafe { x.add(i).replace(tmp) };\n                     if i >= left {\n                         i -= left;\n                         if i == start {\n+                            // SAFETY: see [long-safety-expl] and [safety-expl-addition]\n                             unsafe { x.add(start).write(tmp) };\n                             break;\n                         }\n@@ -135,14 +163,30 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // The `[T; 0]` here is to ensure this is appropriately aligned for T\n             let mut rawarray = MaybeUninit::<(BufType, [T; 0])>::uninit();\n             let buf = rawarray.as_mut_ptr() as *mut T;\n+            // SAFETY: `mid-left <= mid-left+right < mid+right`\n             let dim = unsafe { mid.sub(left).add(right) };\n             if left <= right {\n+                // SAFETY:\n+                //\n+                // 1) The `else if` condition about the sizes ensures `[mid-left; left]` will fit in\n+                //    `buf` without overflow and `buf` was created just above and so cannot be\n+                //    overlapped with any value of `[mid-left; left]`\n+                // 2) [mid-left, mid+right) are all valid for reading and writing and we don't care\n+                //    about overlaps here.\n+                // 3) The `if` condition about `left <= right` ensures writing `left` elements to\n+                //    `dim = mid-left+right` is valid because:\n+                //    - `buf` is valid and `left` elements were written in it in 1)\n+                //    - `dim+left = mid-left+right+left = mid+right` and we write `[dim, dim+left)`\n                 unsafe {\n+                    // 1)\n                     ptr::copy_nonoverlapping(mid.sub(left), buf, left);\n+                    // 2)\n                     ptr::copy(mid, mid.sub(left), right);\n+                    // 3)\n                     ptr::copy_nonoverlapping(buf, dim, left);\n                 }\n             } else {\n+                // SAFETY: same reasoning as above but with `left` and `right` reversed\n                 unsafe {\n                     ptr::copy_nonoverlapping(mid, buf, right);\n                     ptr::copy(mid.sub(left), dim, left);\n@@ -156,6 +200,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n             // of this algorithm would be, and swapping using that last chunk instead of swapping\n             // adjacent chunks like this algorithm is doing, but this way is still faster.\n             loop {\n+                // SAFETY:\n+                // `left >= right` so `[mid-right, mid+right)` is valid for reading and writing\n+                // Substracting `right` from `mid` each turn is counterbalanced by the addition and\n+                // check after it.\n                 unsafe {\n                     ptr::swap_nonoverlapping(mid.sub(right), mid, right);\n                     mid = mid.sub(right);\n@@ -168,6 +216,10 @@ pub unsafe fn ptr_rotate<T>(mut left: usize, mut mid: *mut T, mut right: usize)\n         } else {\n             // Algorithm 3, `left < right`\n             loop {\n+                // SAFETY: `[mid-left, mid+left)` is valid for reading and writing because\n+                // `left < right` so `mid+left < mid+right`.\n+                // Adding `left` to `mid` each turn is counterbalanced by the substraction and check\n+                // after it.\n                 unsafe {\n                     ptr::swap_nonoverlapping(mid.sub(left), mid, left);\n                     mid = mid.add(left);"}]}