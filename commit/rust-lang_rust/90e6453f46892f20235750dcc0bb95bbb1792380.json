{"sha": "90e6453f46892f20235750dcc0bb95bbb1792380", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkwZTY0NTNmNDY4OTJmMjAyMzU3NTBkY2MwYmI5NWJiYjE3OTIzODA=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-20T23:09:14Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-05-22T06:10:08Z"}, "message": "stdlib: Use if/alt expressions in std::extfmt", "tree": {"sha": "fa963bdf024a5a3089451236961806f8898c1b59", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa963bdf024a5a3089451236961806f8898c1b59"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/90e6453f46892f20235750dcc0bb95bbb1792380", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/90e6453f46892f20235750dcc0bb95bbb1792380", "html_url": "https://github.com/rust-lang/rust/commit/90e6453f46892f20235750dcc0bb95bbb1792380", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/90e6453f46892f20235750dcc0bb95bbb1792380/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d7d387171c0df40f125b844256d53a007ae290d6", "url": "https://api.github.com/repos/rust-lang/rust/commits/d7d387171c0df40f125b844256d53a007ae290d6", "html_url": "https://github.com/rust-lang/rust/commit/d7d387171c0df40f125b844256d53a007ae290d6"}], "stats": {"total": 168, "additions": 80, "deletions": 88}, "files": [{"sha": "c96da7aa34cf21b6f86d1cb4514015530d9cec5f", "filename": "src/lib/extfmt.rs", "status": "modified", "additions": 80, "deletions": 88, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/90e6453f46892f20235750dcc0bb95bbb1792380/src%2Flib%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/90e6453f46892f20235750dcc0bb95bbb1792380/src%2Flib%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fextfmt.rs?ref=90e6453f46892f20235750dcc0bb95bbb1792380", "patch": "@@ -129,17 +129,16 @@ mod ct {\n         }\n \n         auto n = (c - ('0' as u8)) as uint;\n-        alt (peek_num(s, i + 1u, lim)) {\n+        ret alt (peek_num(s, i + 1u, lim)) {\n             case (none[tup(uint, uint)]) {\n-                ret some[tup(uint, uint)](tup(n, i + 1u));\n+                some[tup(uint, uint)](tup(n, i + 1u))\n             }\n             case (some[tup(uint, uint)](?next)) {\n                 auto m = next._0;\n                 auto j = next._1;\n-                ret some[tup(uint, uint)](tup(n * 10u + m, j));\n+                some[tup(uint, uint)](tup(n * 10u + m, j))\n             }\n-        }\n-\n+        };\n     }\n \n     fn parse_conversion(str s, uint i, uint lim) -> tup(piece, uint) {\n@@ -162,21 +161,21 @@ mod ct {\n         }\n \n         auto num = peek_num(s, i, lim);\n-        alt (num) {\n+        ret alt (num) {\n             case (none[tup(uint, uint)]) {\n-                ret tup(none[int], i);\n+                tup(none[int], i)\n             }\n             case (some[tup(uint, uint)](?t)) {\n                 auto n = t._0;\n                 auto j = t._1;\n                 if (j < lim && s.(j) == '$' as u8) {\n-                    ret tup(some[int](n as int), j + 1u);\n+                    tup(some[int](n as int), j + 1u)\n                 }\n                 else {\n-                    ret tup(none[int], i);\n+                    tup(none[int], i)\n                 }\n             }\n-        }\n+        };\n     }\n \n     fn parse_flags(str s, uint i, uint lim) -> tup(vec[flag], uint) {\n@@ -197,70 +196,66 @@ mod ct {\n         auto more = bind more_(_, s, i, lim);\n \n         auto f = s.(i);\n-        if (f == ('-' as u8)) {\n-            ret more(flag_left_justify);\n+        ret if (f == ('-' as u8)) {\n+            more(flag_left_justify)\n         } else if (f == ('0' as u8)) {\n-            ret more(flag_left_zero_pad);\n+            more(flag_left_zero_pad)\n         } else if (f == (' ' as u8)) {\n-            ret more(flag_space_for_sign);\n+            more(flag_space_for_sign)\n         } else if (f == ('+' as u8)) {\n-            ret more(flag_sign_always);\n+            more(flag_sign_always)\n         } else if (f == ('#' as u8)) {\n-            ret more(flag_alternate);\n+            more(flag_alternate)\n         } else {\n-            ret tup(noflags, i);\n-        }\n+            tup(noflags, i)\n+        };\n     }\n \n     fn parse_count(str s, uint i, uint lim) -> tup(count, uint) {\n-        if (i >= lim) {\n-            ret tup(count_implied, i);\n-        }\n-\n-        if (s.(i) == ('*' as u8)) {\n+        ret if (i >= lim) {\n+            tup(count_implied, i)\n+        } else if (s.(i) == ('*' as u8)) {\n             auto param = parse_parameter(s, i + 1u, lim);\n             auto j = param._1;\n             alt (param._0) {\n                 case (none[int]) {\n-                    ret tup(count_is_next_param, j);\n+                    tup(count_is_next_param, j)\n                 }\n                 case (some[int](?n)) {\n-                    ret tup(count_is_param(n), j);\n+                    tup(count_is_param(n), j)\n                 }\n             }\n         } else {\n             auto num = peek_num(s, i, lim);\n             alt (num) {\n                 case (none[tup(uint, uint)]) {\n-                    ret tup(count_implied, i);\n+                    tup(count_implied, i)\n                 }\n                 case (some[tup(uint, uint)](?num)) {\n-                    ret tup(count_is(num._0 as int), num._1);\n+                    tup(count_is(num._0 as int), num._1)\n                 }\n             }\n-        }\n+        };\n     }\n \n     fn parse_precision(str s, uint i, uint lim) -> tup(count, uint) {\n-        if (i >= lim) {\n-            ret tup(count_implied, i);\n-        }\n-\n-        if (s.(i) == '.' as u8) {\n+        ret if (i >= lim) {\n+            tup(count_implied, i)\n+        } else if (s.(i) == '.' as u8) {\n             auto count = parse_count(s, i + 1u, lim);\n             // If there were no digits specified, i.e. the precision\n             // was \".\", then the precision is 0\n             alt (count._0) {\n                 case (count_implied) {\n-                    ret tup(count_is(0), count._1);\n+                    tup(count_is(0), count._1)\n                 }\n                 case (_) {\n-                    ret count;\n+                    count\n                 }\n             }\n         } else {\n-            ret tup(count_implied, i);\n-        }\n+            tup(count_implied, i)\n+        };\n     }\n \n     fn parse_type(str s, uint i, uint lim) -> tup(ty, uint) {\n@@ -269,33 +264,32 @@ mod ct {\n             fail;\n         }\n \n-        auto t;\n         auto tstr = str::substr(s, i, 1u);\n-        if (str::eq(tstr, \"b\")) {\n-            t = ty_bool;\n+        auto t = if (str::eq(tstr, \"b\")) {\n+            ty_bool\n         } else if (str::eq(tstr, \"s\")) {\n-            t = ty_str;\n+            ty_str\n         } else if (str::eq(tstr, \"c\")) {\n-            t = ty_char;\n+            ty_char\n         } else if (str::eq(tstr, \"d\")\n                    || str::eq(tstr, \"i\")) {\n             // TODO: Do we really want two signed types here?\n             // How important is it to be printf compatible?\n-            t = ty_int(signed);\n+            ty_int(signed)\n         } else if (str::eq(tstr, \"u\")) {\n-            t = ty_int(unsigned);\n+            ty_int(unsigned)\n         } else if (str::eq(tstr, \"x\")) {\n-            t = ty_hex(case_lower);\n+            ty_hex(case_lower)\n         } else if (str::eq(tstr, \"X\")) {\n-            t = ty_hex(case_upper);\n+            ty_hex(case_upper)\n         } else if (str::eq(tstr, \"t\")) {\n-            t = ty_bits;\n+            ty_bits\n         } else if (str::eq(tstr, \"o\")) {\n-            t = ty_octal;\n+            ty_octal\n         } else {\n             log_err \"unknown type in conversion\";\n-            fail;\n-        }\n+            fail\n+        };\n \n         ret tup(t, i + 1u);\n     }\n@@ -355,34 +349,32 @@ mod rt {\n \n     fn conv_uint(&conv cv, uint u) -> str {\n         auto prec = get_int_precision(cv);\n-        auto res;\n-        alt (cv.ty) {\n+        auto res = alt (cv.ty) {\n             case (ty_default) {\n-                res = uint_to_str_prec(u, 10u, prec);\n+                uint_to_str_prec(u, 10u, prec)\n             }\n             case (ty_hex_lower) {\n-                res = uint_to_str_prec(u, 16u, prec);\n+                uint_to_str_prec(u, 16u, prec)\n             }\n             case (ty_hex_upper) {\n-                res = str::to_upper(uint_to_str_prec(u, 16u, prec));\n+                str::to_upper(uint_to_str_prec(u, 16u, prec))\n             }\n             case (ty_bits) {\n-                res = uint_to_str_prec(u, 2u, prec);\n+                uint_to_str_prec(u, 2u, prec)\n             }\n             case (ty_octal) {\n-                res = uint_to_str_prec(u, 8u, prec);\n+                uint_to_str_prec(u, 8u, prec)\n             }\n-        }\n+        };\n         ret pad(cv, res, pad_unsigned);\n     }\n \n     fn conv_bool(&conv cv, bool b) -> str {\n-        auto s;\n-        if (b) {\n-            s = \"true\";\n+        auto s = if (b) {\n+            \"true\"\n         } else {\n-            s = \"false\";\n-        }\n+            \"false\"\n+        };\n         // run the boolean conversion through the string conversion logic,\n         // giving it the same rules for precision, etc.\n         ret conv_str(cv, s);\n@@ -393,61 +385,61 @@ mod rt {\n     }\n \n     fn conv_str(&conv cv, str s) -> str {\n-        auto unpadded = s;\n-        alt (cv.precision) {\n+        auto unpadded = alt (cv.precision) {\n             case (count_implied) {\n+                s\n             }\n             case (count_is(?max)) {\n                 // For strings, precision is the maximum characters displayed\n                 if (max as uint < str::char_len(s)) {\n                     // FIXME: substr works on bytes, not chars!\n-                    unpadded = str::substr(s, 0u, max as uint);\n+                    str::substr(s, 0u, max as uint)\n+                } else {\n+                    s\n                 }\n             }\n-        }\n+        };\n         ret pad(cv, unpadded, pad_nozero);\n     }\n \n     // Convert an int to string with minimum number of digits. If precision is\n     // 0 and num is 0 then the result is the empty string.\n     fn int_to_str_prec(int num, uint radix, uint prec) -> str {\n-        if (num < 0) {\n-            ret \"-\" + uint_to_str_prec((-num) as uint, radix, prec);\n+        ret if (num < 0) {\n+            \"-\" + uint_to_str_prec((-num) as uint, radix, prec)\n         } else {\n-            ret uint_to_str_prec(num as uint, radix, prec);\n-        }\n+            uint_to_str_prec(num as uint, radix, prec)\n+        };\n     }\n \n     // Convert a uint to string with a minimum number of digits.  If precision\n     // is 0 and num is 0 then the result is the empty string. Could move this\n     // to uint: but it doesn't seem all that useful.\n     fn uint_to_str_prec(uint num, uint radix, uint prec) -> str {\n-        auto s;\n-\n-        if (prec == 0u && num == 0u) {\n-            s = \"\";\n+        ret if (prec == 0u && num == 0u) {\n+            \"\"\n         } else {\n-            s = uint::to_str(num, radix);\n+            auto s = uint::to_str(num, radix);\n             auto len = str::char_len(s);\n             if (len < prec) {\n                 auto diff = prec - len;\n                 auto pad = str_init_elt('0', diff);\n-                s = pad + s;\n+                pad + s\n+            } else {\n+                s\n             }\n-        }\n-\n-        ret s;\n+        };\n     }\n \n     fn get_int_precision(&conv cv) -> uint {\n-        alt (cv.precision) {\n+        ret alt (cv.precision) {\n             case (count_is(?c)) {\n-                ret c as uint;\n+                c as uint\n             }\n             case (count_implied) {\n-                ret 1u;\n+                1u\n             }\n-        }\n+        };\n     }\n \n     // FIXME: This might be useful in str: but needs to be utf8 safe first\n@@ -505,14 +497,14 @@ mod rt {\n         }\n \n         fn have_precision(&conv cv) -> bool {\n-            alt (cv.precision) {\n+            ret alt (cv.precision) {\n                 case (count_implied) {\n-                    ret false;\n+                    false\n                 }\n                 case (_) {\n-                    ret true;\n+                    true\n                 }\n-            }\n+            };\n         }\n \n         auto zero_padding = false;"}]}