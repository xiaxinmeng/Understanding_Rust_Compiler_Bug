{"sha": "53589b7e4ea36927f2f58c30a23df427f3560f06", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNTg5YjdlNGVhMzY5MjdmMmY1OGMzMGEyM2RmNDI3ZjM1NjBmMDY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-17T04:39:59Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-09-17T21:08:18Z"}, "message": "Some \"word\"-related improvements.\n\n- Rename `BitSet::data` and `BitMatrix::vector` as `words`, because that's\n  what they are.\n\n- Remove `BitSet::words_mut()`, which is no longer necessary.\n\n- Better distinguish multiple meanins of \"word\", i.e. \"word index\" vs\n  \"word ref\" vs \"word\" (i.e. the value itself).", "tree": {"sha": "2d3a478646ade07dc8bed0aae073bde237d607ed", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d3a478646ade07dc8bed0aae073bde237d607ed"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53589b7e4ea36927f2f58c30a23df427f3560f06", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53589b7e4ea36927f2f58c30a23df427f3560f06", "html_url": "https://github.com/rust-lang/rust/commit/53589b7e4ea36927f2f58c30a23df427f3560f06", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53589b7e4ea36927f2f58c30a23df427f3560f06/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a0da3e9f4fff6aae71f56ce3452b0e38f30de5c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/a0da3e9f4fff6aae71f56ce3452b0e38f30de5c4", "html_url": "https://github.com/rust-lang/rust/commit/a0da3e9f4fff6aae71f56ce3452b0e38f30de5c4"}], "stats": {"total": 137, "additions": 66, "deletions": 71}, "files": [{"sha": "b1fb475bce9028449c470f5a7284684cdfa961b8", "filename": "src/librustc_data_structures/bit_set.rs", "status": "modified", "additions": 66, "deletions": 71, "changes": 137, "blob_url": "https://github.com/rust-lang/rust/blob/53589b7e4ea36927f2f58c30a23df427f3560f06/src%2Flibrustc_data_structures%2Fbit_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53589b7e4ea36927f2f58c30a23df427f3560f06/src%2Flibrustc_data_structures%2Fbit_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fbit_set.rs?ref=53589b7e4ea36927f2f58c30a23df427f3560f06", "patch": "@@ -28,7 +28,7 @@ pub const WORD_BITS: usize = WORD_BYTES * 8;\n /// just be `usize`.\n #[derive(Clone, Eq, PartialEq)]\n pub struct BitSet<T: Idx> {\n-    data: Vec<Word>,\n+    words: Vec<Word>,\n     marker: PhantomData<T>,\n }\n \n@@ -37,7 +37,7 @@ impl<T: Idx> BitSet<T> {\n     pub fn new_empty(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n         BitSet {\n-            data: vec![0; num_words],\n+            words: vec![0; num_words],\n             marker: PhantomData,\n         }\n     }\n@@ -46,7 +46,7 @@ impl<T: Idx> BitSet<T> {\n     pub fn new_filled(domain_size: usize) -> BitSet<T> {\n         let num_words = num_words(domain_size);\n         let mut result = BitSet {\n-            data: vec![!0; num_words],\n+            words: vec![!0; num_words],\n             marker: PhantomData,\n         };\n         result.clear_above(domain_size);\n@@ -55,14 +55,14 @@ impl<T: Idx> BitSet<T> {\n \n     #[inline]\n     pub fn clear(&mut self) {\n-        for word in &mut self.data {\n+        for word in &mut self.words {\n             *word = 0;\n         }\n     }\n \n     /// Sets all elements up to and including `size`.\n     pub fn set_up_to(&mut self, bit: usize) {\n-        for word in &mut self.data {\n+        for word in &mut self.words {\n             *word = !0;\n         }\n         self.clear_above(bit);\n@@ -72,14 +72,14 @@ impl<T: Idx> BitSet<T> {\n     fn clear_above(&mut self, bit: usize) {\n         let first_clear_block = bit / WORD_BITS;\n \n-        if first_clear_block < self.data.len() {\n+        if first_clear_block < self.words.len() {\n             // Within `first_clear_block`, the `bit % WORD_BITS` LSBs should\n             // remain.\n             let mask = (1 << (bit % WORD_BITS)) - 1;\n-            self.data[first_clear_block] &= mask;\n+            self.words[first_clear_block] &= mask;\n \n             // All the blocks above `first_clear_block` are fully cleared.\n-            for word in &mut self.data[first_clear_block + 1..] {\n+            for word in &mut self.words[first_clear_block + 1..] {\n                 *word = 0;\n             }\n         }\n@@ -88,63 +88,63 @@ impl<T: Idx> BitSet<T> {\n     /// Efficiently overwrite `self` with `other`. Panics if `self` and `other`\n     /// don't have the same length.\n     pub fn overwrite(&mut self, other: &BitSet<T>) {\n-        self.words_mut().clone_from_slice(other.words());\n+        self.words.clone_from_slice(&other.words);\n     }\n \n     /// Count the number of set bits in the set.\n     pub fn count(&self) -> usize {\n-        self.data.iter().map(|e| e.count_ones() as usize).sum()\n+        self.words.iter().map(|e| e.count_ones() as usize).sum()\n     }\n \n     /// True if `self` contains the bit `bit`.\n     #[inline]\n     pub fn contains(&self, bit: T) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        (self.data[word] & mask) != 0\n+        let (word_index, mask) = word_index_and_mask(bit);\n+        (self.words[word_index] & mask) != 0\n     }\n \n     /// True if `self` is a (non-strict) superset of `other`.\n     ///\n-    /// The two vectors must have the same length.\n+    /// The two sets must have the same domain_size.\n     #[inline]\n     pub fn superset(&self, other: &BitSet<T>) -> bool {\n-        assert_eq!(self.data.len(), other.data.len());\n-        self.data.iter().zip(&other.data).all(|(a, b)| (a & b) == *b)\n+        assert_eq!(self.words.len(), other.words.len());\n+        self.words.iter().zip(&other.words).all(|(a, b)| (a & b) == *b)\n     }\n \n     /// Is the set empty?\n     #[inline]\n     pub fn is_empty(&self) -> bool {\n-        self.data.iter().all(|a| *a == 0)\n+        self.words.iter().all(|a| *a == 0)\n     }\n \n     /// Insert a bit. Returns true if the bit has changed.\n     #[inline]\n     pub fn insert(&mut self, bit: T) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        let data = &mut self.data[word];\n-        let value = *data;\n-        let new_value = value | mask;\n-        *data = new_value;\n-        new_value != value\n+        let (word_index, mask) = word_index_and_mask(bit);\n+        let word_ref = &mut self.words[word_index];\n+        let word = *word_ref;\n+        let new_word = word | mask;\n+        *word_ref = new_word;\n+        new_word != word\n     }\n \n     /// Sets all bits to true.\n     pub fn insert_all(&mut self) {\n-        for word in &mut self.data {\n+        for word in &mut self.words {\n             *word = !0;\n         }\n     }\n \n     /// Returns true if the bit has changed.\n     #[inline]\n     pub fn remove(&mut self, bit: T) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        let data = &mut self.data[word];\n-        let value = *data;\n-        let new_value = value & !mask;\n-        *data = new_value;\n-        new_value != value\n+        let (word_index, mask) = word_index_and_mask(bit);\n+        let word_ref = &mut self.words[word_index];\n+        let word = *word_ref;\n+        let new_word = word & !mask;\n+        *word_ref = new_word;\n+        new_word != word\n     }\n \n     /// Set `self = self | other` and return true if `self` changed\n@@ -162,25 +162,20 @@ impl<T: Idx> BitSet<T> {\n     /// Set `self = self & other` and return true if `self` changed.\n     /// (i.e., if any bits were removed).\n     pub fn intersect(&mut self, other: &BitSet<T>) -> bool {\n-        bitwise(self.words_mut(), other.words(), |a, b| { a & b })\n+        bitwise(&mut self.words, &other.words, |a, b| { a & b })\n     }\n \n     /// Get a slice of the underlying words.\n     pub fn words(&self) -> &[Word] {\n-        &self.data\n-    }\n-\n-    /// Get a mutable slice of the underlying words.\n-    pub fn words_mut(&mut self) -> &mut [Word] {\n-        &mut self.data\n+        &self.words\n     }\n \n     /// Iterates over the indices of set bits in a sorted order.\n     #[inline]\n     pub fn iter<'a>(&'a self) -> BitIter<'a, T> {\n         BitIter {\n             cur: None,\n-            iter: self.data.iter().enumerate(),\n+            iter: self.words.iter().enumerate(),\n             marker: PhantomData,\n         }\n     }\n@@ -189,7 +184,7 @@ impl<T: Idx> BitSet<T> {\n     pub fn to_hybrid(&self) -> HybridBitSet<T> {\n         // This domain_size may be slightly larger than the one specified\n         // upon creation, due to rounding up to a whole word. That's ok.\n-        let domain_size = self.words().len() * WORD_BITS;\n+        let domain_size = self.words.len() * WORD_BITS;\n \n         // Note: we currently don't bother trying to make a Sparse set.\n         HybridBitSet::Dense(self.to_owned(), domain_size)\n@@ -203,19 +198,19 @@ impl<T: Idx> BitSet<T> {\n \n         // i tracks how many bits we have printed so far.\n         let mut i = 0;\n-        for word in &self.data {\n-            let mut v = *word;\n-            for _ in 0..WORD_BYTES { // for each byte in `v`:\n+        for word in &self.words {\n+            let mut word = *word;\n+            for _ in 0..WORD_BYTES { // for each byte in `word`:\n                 let remain = bits - i;\n                 // If less than a byte remains, then mask just that many bits.\n                 let mask = if remain <= 8 { (1 << remain) - 1 } else { 0xFF };\n                 assert!(mask <= 0xFF);\n-                let byte = v & mask;\n+                let byte = word & mask;\n \n                 result.push_str(&format!(\"{}{:02x}\", sep, byte));\n \n                 if remain <= 8 { break; }\n-                v >>= 8;\n+                word >>= 8;\n                 i += 8;\n                 sep = '-';\n             }\n@@ -243,13 +238,13 @@ pub trait SubtractFromBitSet<T: Idx> {\n \n impl<T: Idx> UnionIntoBitSet<T> for BitSet<T> {\n     fn union_into(&self, other: &mut BitSet<T>) -> bool {\n-        bitwise(other.words_mut(), self.words(), |a, b| { a | b })\n+        bitwise(&mut other.words, &self.words, |a, b| { a | b })\n     }\n }\n \n impl<T: Idx> SubtractFromBitSet<T> for BitSet<T> {\n     fn subtract_from(&self, other: &mut BitSet<T>) -> bool {\n-        bitwise(other.words_mut(), self.words(), |a, b| { a & !b })\n+        bitwise(&mut other.words, &self.words, |a, b| { a & !b })\n     }\n }\n \n@@ -263,15 +258,15 @@ impl<T: Idx> fmt::Debug for BitSet<T> {\n \n impl<T: Idx> rustc_serialize::Encodable for BitSet<T> {\n     fn encode<E: rustc_serialize::Encoder>(&self, encoder: &mut E) -> Result<(), E::Error> {\n-        self.data.encode(encoder)\n+        self.words.encode(encoder)\n     }\n }\n \n impl<T: Idx> rustc_serialize::Decodable for BitSet<T> {\n     fn decode<D: rustc_serialize::Decoder>(d: &mut D) -> Result<BitSet<T>, D::Error> {\n         let words: Vec<Word> = rustc_serialize::Decodable::decode(d)?;\n         Ok(BitSet {\n-            data: words,\n+            words,\n             marker: PhantomData,\n         })\n     }\n@@ -539,8 +534,8 @@ pub struct GrowableBitSet<T: Idx> {\n impl<T: Idx> GrowableBitSet<T> {\n     pub fn grow(&mut self, domain_size: T) {\n         let num_words = num_words(domain_size);\n-        if self.bit_set.data.len() <= num_words {\n-            self.bit_set.data.resize(num_words + 1, 0)\n+        if self.bit_set.words.len() <= num_words {\n+            self.bit_set.words.resize(num_words + 1, 0)\n         }\n     }\n \n@@ -561,8 +556,8 @@ impl<T: Idx> GrowableBitSet<T> {\n \n     #[inline]\n     pub fn contains(&self, bit: T) -> bool {\n-        let (word, mask) = word_mask(bit);\n-        if let Some(word) = self.bit_set.data.get(word) {\n+        let (word_index, mask) = word_index_and_mask(bit);\n+        if let Some(word) = self.bit_set.words.get(word_index) {\n             (word & mask) != 0\n         } else {\n             false\n@@ -578,7 +573,7 @@ impl<T: Idx> GrowableBitSet<T> {\n #[derive(Clone, Debug)]\n pub struct BitMatrix<R: Idx, C: Idx> {\n     columns: usize,\n-    vector: Vec<Word>,\n+    words: Vec<Word>,\n     marker: PhantomData<(R, C)>,\n }\n \n@@ -590,7 +585,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         let words_per_row = num_words(columns);\n         BitMatrix {\n             columns,\n-            vector: vec![0; rows * words_per_row],\n+            words: vec![0; rows * words_per_row],\n             marker: PhantomData,\n         }\n     }\n@@ -609,12 +604,12 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// Returns true if this changed the matrix, and false otherwise.\n     pub fn insert(&mut self, row: R, column: R) -> bool {\n         let (start, _) = self.range(row);\n-        let (word, mask) = word_mask(column);\n-        let vector = &mut self.vector[..];\n-        let v1 = vector[start + word];\n-        let v2 = v1 | mask;\n-        vector[start + word] = v2;\n-        v1 != v2\n+        let (word_index, mask) = word_index_and_mask(column);\n+        let words = &mut self.words[..];\n+        let word = words[start + word_index];\n+        let new_word = word | mask;\n+        words[start + word_index] = new_word;\n+        word != new_word\n     }\n \n     /// Do the bits from `row` contain `column`? Put another way, is\n@@ -623,8 +618,8 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     /// `row` reach `column`?\n     pub fn contains(&self, row: R, column: R) -> bool {\n         let (start, _) = self.range(row);\n-        let (word, mask) = word_mask(column);\n-        (self.vector[start + word] & mask) != 0\n+        let (word_index, mask) = word_index_and_mask(column);\n+        (self.words[start + word_index] & mask) != 0\n     }\n \n     /// Returns those indices that are true in rows `a` and `b`.  This\n@@ -636,7 +631,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         let (b_start, b_end) = self.range(b);\n         let mut result = Vec::with_capacity(self.columns);\n         for (base, (i, j)) in (a_start..a_end).zip(b_start..b_end).enumerate() {\n-            let mut v = self.vector[i] & self.vector[j];\n+            let mut v = self.words[i] & self.words[j];\n             for bit in 0..WORD_BITS {\n                 if v == 0 {\n                     break;\n@@ -660,13 +655,13 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n     pub fn union_rows(&mut self, read: R, write: R) -> bool {\n         let (read_start, read_end) = self.range(read);\n         let (write_start, write_end) = self.range(write);\n-        let vector = &mut self.vector[..];\n+        let words = &mut self.words[..];\n         let mut changed = false;\n         for (read_index, write_index) in (read_start..read_end).zip(write_start..write_end) {\n-            let v1 = vector[write_index];\n-            let v2 = v1 | vector[read_index];\n-            vector[write_index] = v2;\n-            changed |= v1 != v2;\n+            let word = words[write_index];\n+            let new_word = word | words[read_index];\n+            words[write_index] = new_word;\n+            changed |= word != new_word;\n         }\n         changed\n     }\n@@ -677,7 +672,7 @@ impl<R: Idx, C: Idx> BitMatrix<R, C> {\n         let (start, end) = self.range(row);\n         BitIter {\n             cur: None,\n-            iter: self.vector[start..end].iter().enumerate(),\n+            iter: self.words[start..end].iter().enumerate(),\n             marker: PhantomData,\n         }\n     }\n@@ -795,11 +790,11 @@ fn num_words<T: Idx>(elements: T) -> usize {\n }\n \n #[inline]\n-fn word_mask<T: Idx>(index: T) -> (usize, Word) {\n+fn word_index_and_mask<T: Idx>(index: T) -> (usize, Word) {\n     let index = index.index();\n-    let word = index / WORD_BITS;\n+    let word_index = index / WORD_BITS;\n     let mask = 1 << (index % WORD_BITS);\n-    (word, mask)\n+    (word_index, mask)\n }\n \n #[test]"}]}