{"sha": "7905452f083ab5ac3008dfe6727048e70bbeb142", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MDU0NTJmMDgzYWI1YWMzMDA4ZGZlNjcyNzA0OGU3MGJiZWIxNDI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-27T04:27:11Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-05-27T04:27:11Z"}, "message": "Rollup merge of #33644 - petrochenkov:selfast, r=nrc\n\n The AST part of https://github.com/rust-lang/rust/pull/33505.\nhttps://github.com/rust-lang/rust/pull/33505 isn't landed yet, so this PR is based on top of it.\n\nr? @nrc\n\nplugin-[breaking-change] cc #31645 @Manishearth", "tree": {"sha": "48f73374f8f406245a88ba83c2f5407f21653b65", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/48f73374f8f406245a88ba83c2f5407f21653b65"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7905452f083ab5ac3008dfe6727048e70bbeb142", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7905452f083ab5ac3008dfe6727048e70bbeb142", "html_url": "https://github.com/rust-lang/rust/commit/7905452f083ab5ac3008dfe6727048e70bbeb142", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7905452f083ab5ac3008dfe6727048e70bbeb142/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "35785712cd5e1acbfebd168c045b2e184ae979cc", "url": "https://api.github.com/repos/rust-lang/rust/commits/35785712cd5e1acbfebd168c045b2e184ae979cc", "html_url": "https://github.com/rust-lang/rust/commit/35785712cd5e1acbfebd168c045b2e184ae979cc"}, {"sha": "dcea4b26268d19b32c7e29bf063638fa5e3bbd91", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcea4b26268d19b32c7e29bf063638fa5e3bbd91", "html_url": "https://github.com/rust-lang/rust/commit/dcea4b26268d19b32c7e29bf063638fa5e3bbd91"}], "stats": {"total": 448, "additions": 166, "deletions": 282}, "files": [{"sha": "ea9a76d982a3aea2dc14f19ca47ce27f6d2feeb3", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -273,7 +273,7 @@ impl<'a> LoweringContext<'a> {\n         P(hir::Ty {\n             id: t.id,\n             node: match t.node {\n-                Infer => hir::TyInfer,\n+                Infer | ImplicitSelf => hir::TyInfer,\n                 Vec(ref ty) => hir::TyVec(self.lower_ty(ty)),\n                 Ptr(ref mt) => hir::TyPtr(self.lower_mt(mt)),\n                 Rptr(ref region, ref mt) => {\n@@ -791,23 +791,24 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn lower_method_sig(&mut self, sig: &MethodSig) -> hir::MethodSig {\n-        // Check for `self: _` and `self: &_`\n-        if let SelfKind::Explicit(ref ty, _) = sig.explicit_self.node {\n-            match sig.decl.inputs.get(0).and_then(Arg::to_self).map(|eself| eself.node) {\n-                Some(SelfKind::Value(..)) | Some(SelfKind::Region(..)) => {\n-                    self.id_assigner.diagnostic().span_err(ty.span,\n-                        \"the type placeholder `_` is not allowed within types on item signatures\");\n-                }\n-                _ => {}\n-            }\n-        }\n-        hir::MethodSig {\n+        let hir_sig = hir::MethodSig {\n             generics: self.lower_generics(&sig.generics),\n             abi: sig.abi,\n             unsafety: self.lower_unsafety(sig.unsafety),\n             constness: self.lower_constness(sig.constness),\n             decl: self.lower_fn_decl(&sig.decl),\n+        };\n+        // Check for `self: _` and `self: &_`\n+        if let Some(SelfKind::Explicit(..)) = sig.decl.get_self().map(|eself| eself.node) {\n+            match hir_sig.decl.get_self().map(|eself| eself.node) {\n+                Some(hir::SelfKind::Value(..)) | Some(hir::SelfKind::Region(..)) => {\n+                    self.id_assigner.diagnostic().span_err(sig.decl.inputs[0].ty.span,\n+                        \"the type placeholder `_` is not allowed within types on item signatures\");\n+                }\n+                _ => {}\n+            }\n         }\n+        hir_sig\n     }\n \n     fn lower_unsafety(&mut self, u: Unsafety) -> hir::Unsafety {"}, {"sha": "ea52a393da6c7671701b9ee313ac16bc9a12d22a", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -1177,6 +1177,9 @@ pub struct FnDecl {\n }\n \n impl FnDecl {\n+    pub fn get_self(&self) -> Option<ExplicitSelf> {\n+        self.inputs.get(0).and_then(Arg::to_self)\n+    }\n     pub fn has_self(&self) -> bool {\n         self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n     }"}, {"sha": "94f17ea779ac8827b86c9176de71b52057d364c1", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -1043,11 +1043,6 @@ impl<'a, 'v> ast_visit::Visitor<'v> for EarlyContext<'a> {\n         run_lints!(self, check_lifetime_def, early_passes, lt);\n     }\n \n-    fn visit_explicit_self(&mut self, es: &ast::ExplicitSelf) {\n-        run_lints!(self, check_explicit_self, early_passes, es);\n-        ast_visit::walk_explicit_self(self, es);\n-    }\n-\n     fn visit_path(&mut self, p: &ast::Path, id: ast::NodeId) {\n         run_lints!(self, check_path, early_passes, p, id);\n         ast_visit::walk_path(self, p);"}, {"sha": "cc7fa54bd0a5ef6f7959f9b6a2108f6e2f4c51d8", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -167,7 +167,6 @@ pub trait LateLintPass: LintPass {\n     fn check_variant_post(&mut self, _: &LateContext, _: &hir::Variant, _: &hir::Generics) { }\n     fn check_lifetime(&mut self, _: &LateContext, _: &hir::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &LateContext, _: &hir::LifetimeDef) { }\n-    fn check_explicit_self(&mut self, _: &LateContext, _: &hir::ExplicitSelf) { }\n     fn check_path(&mut self, _: &LateContext, _: &hir::Path, _: ast::NodeId) { }\n     fn check_path_list_item(&mut self, _: &LateContext, _: &hir::PathListItem) { }\n     fn check_attribute(&mut self, _: &LateContext, _: &ast::Attribute) { }\n@@ -218,7 +217,6 @@ pub trait EarlyLintPass: LintPass {\n     fn check_variant_post(&mut self, _: &EarlyContext, _: &ast::Variant, _: &ast::Generics) { }\n     fn check_lifetime(&mut self, _: &EarlyContext, _: &ast::Lifetime) { }\n     fn check_lifetime_def(&mut self, _: &EarlyContext, _: &ast::LifetimeDef) { }\n-    fn check_explicit_self(&mut self, _: &EarlyContext, _: &ast::ExplicitSelf) { }\n     fn check_path(&mut self, _: &EarlyContext, _: &ast::Path, _: ast::NodeId) { }\n     fn check_path_list_item(&mut self, _: &EarlyContext, _: &ast::PathListItem) { }\n     fn check_attribute(&mut self, _: &EarlyContext, _: &ast::Attribute) { }"}, {"sha": "e0243bf4fa690eeae1171b56973d5dc03676daf9", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -35,7 +35,7 @@ use syntax::codemap::{Span, DUMMY_SP};\n use syntax::ast::{Block, Crate, DeclKind};\n use syntax::ast::{ForeignItem, ForeignItemKind, Item, ItemKind};\n use syntax::ast::{Mutability, PathListItemKind};\n-use syntax::ast::{SelfKind, Stmt, StmtKind, TraitItemKind};\n+use syntax::ast::{Stmt, StmtKind, TraitItemKind};\n use syntax::ast::{Variant, ViewPath, ViewPathGlob, ViewPathList, ViewPathSimple};\n use syntax::visit::{self, Visitor};\n \n@@ -335,7 +335,7 @@ impl<'b> Resolver<'b> {\n                     let (def, ns) = match item.node {\n                         TraitItemKind::Const(..) => (Def::AssociatedConst(item_def_id), ValueNS),\n                         TraitItemKind::Method(ref sig, _) => {\n-                            is_static_method = sig.explicit_self.node == SelfKind::Static;\n+                            is_static_method = !sig.decl.has_self();\n                             (Def::Method(item_def_id), ValueNS)\n                         }\n                         TraitItemKind::Type(..) => (Def::AssociatedTy(def_id, item_def_id), TypeNS),"}, {"sha": "2444f6acced24d6740af757f61d8869ebc5c375e", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -67,7 +67,7 @@ use syntax::ast::{Arm, BindingMode, Block, Crate, Expr, ExprKind};\n use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Pat, PatKind, Path};\n-use syntax::ast::{PathSegment, PathParameters, SelfKind, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::ast::{PathSegment, PathParameters, TraitItemKind, TraitRef, Ty, TyKind};\n \n use std::collections::{HashMap, HashSet};\n use std::cell::{Cell, RefCell};\n@@ -607,7 +607,7 @@ impl<'a, 'v> Visitor<'v> for Resolver<'a> {\n             }\n             FnKind::Method(_, sig, _) => {\n                 self.visit_generics(&sig.generics);\n-                MethodRibKind(sig.explicit_self.node == SelfKind::Static)\n+                MethodRibKind(!sig.decl.has_self())\n             }\n             FnKind::Closure => ClosureRibKind(node_id),\n         };\n@@ -1676,9 +1676,7 @@ impl<'a> Resolver<'a> {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n-                                                          MethodRibKind(\n-                                                             sig.explicit_self.node ==\n-                                                             SelfKind::Static));\n+                                                          MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_trait_item(this, trait_item)\n                                     });\n@@ -2007,9 +2005,7 @@ impl<'a> Resolver<'a> {\n                                     let type_parameters =\n                                         HasTypeParameters(&sig.generics,\n                                                           FnSpace,\n-                                                          MethodRibKind(\n-                                                            sig.explicit_self.node ==\n-                                                            SelfKind::Static));\n+                                                          MethodRibKind(!sig.decl.has_self()));\n                                     this.with_type_parameter_rib(type_parameters, |this| {\n                                         visit::walk_impl_item(this, impl_item);\n                                     });"}, {"sha": "fc1abb56d5abc61631dc42a8f7decb9d8b4136fa", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -1833,8 +1833,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> AstConv<'gcx, 'tcx>+'o {\n         // lifetime elision, we can determine it in two ways. First (determined\n         // here), if self is by-reference, then the implied output region is the\n         // region of the self parameter.\n-        let explicit_self = decl.inputs.get(0).and_then(hir::Arg::to_self);\n-        let (self_ty, explicit_self_category) = match (opt_untransformed_self_ty, explicit_self) {\n+        let (self_ty, explicit_self_category) = match (opt_untransformed_self_ty, decl.get_self()) {\n             (Some(untransformed_self_ty), Some(explicit_self)) => {\n                 let self_type = self.determine_self_type(&rb, untransformed_self_ty,\n                                                          &explicit_self);"}, {"sha": "9ecaa5b346af4f04c57a79f8b07cc2b50521a0c2", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 41, "deletions": 47, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -1389,7 +1389,6 @@ pub struct MethodSig {\n     pub abi: Abi,\n     pub decl: P<FnDecl>,\n     pub generics: Generics,\n-    pub explicit_self: ExplicitSelf,\n }\n \n /// Represents an item declaration within a trait declaration,\n@@ -1640,6 +1639,8 @@ pub enum TyKind {\n     /// TyKind::Infer means the type should be inferred instead of it having been\n     /// specified. This can appear anywhere in a type.\n     Infer,\n+    /// Inferred type of a `self` or `&self` argument in a method.\n+    ImplicitSelf,\n     // A macro in the type position.\n     Mac(Mac),\n }\n@@ -1679,81 +1680,65 @@ pub struct Arg {\n     pub id: NodeId,\n }\n \n-/// Represents the kind of 'self' associated with a method.\n-/// String representation of `Ident` here is always \"self\", but hygiene contexts may differ.\n+/// Alternative representation for `Arg`s describing `self` parameter of methods.\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum SelfKind {\n-    /// No self\n-    Static,\n     /// `self`, `mut self`\n-    Value(Ident),\n+    Value(Mutability),\n     /// `&'lt self`, `&'lt mut self`\n-    Region(Option<Lifetime>, Mutability, Ident),\n+    Region(Option<Lifetime>, Mutability),\n     /// `self: TYPE`, `mut self: TYPE`\n-    Explicit(P<Ty>, Ident),\n+    Explicit(P<Ty>, Mutability),\n }\n \n pub type ExplicitSelf = Spanned<SelfKind>;\n \n impl Arg {\n-    #[unstable(feature = \"rustc_private\", issue = \"27812\")]\n-    #[rustc_deprecated(since = \"1.10.0\", reason = \"use `from_self` instead\")]\n-    pub fn new_self(span: Span, mutability: Mutability, self_ident: Ident) -> Arg {\n-        let path = Spanned{span:span,node:self_ident};\n-        Arg {\n-            // HACK(eddyb) fake type for the self argument.\n-            ty: P(Ty {\n-                id: DUMMY_NODE_ID,\n-                node: TyKind::Infer,\n-                span: DUMMY_SP,\n-            }),\n-            pat: P(Pat {\n-                id: DUMMY_NODE_ID,\n-                node: PatKind::Ident(BindingMode::ByValue(mutability), path, None),\n-                span: span\n-            }),\n-            id: DUMMY_NODE_ID\n-        }\n-    }\n-\n     pub fn to_self(&self) -> Option<ExplicitSelf> {\n-        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+        if let PatKind::Ident(BindingMode::ByValue(mutbl), ident, _) = self.pat.node {\n             if ident.node.name == keywords::SelfValue.name() {\n                 return match self.ty.node {\n-                    TyKind::Infer => Some(respan(self.pat.span, SelfKind::Value(ident.node))),\n-                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::Infer => {\n-                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl, ident.node)))\n+                    TyKind::ImplicitSelf => Some(respan(self.pat.span, SelfKind::Value(mutbl))),\n+                    TyKind::Rptr(lt, MutTy{ref ty, mutbl}) if ty.node == TyKind::ImplicitSelf => {\n+                        Some(respan(self.pat.span, SelfKind::Region(lt, mutbl)))\n                     }\n                     _ => Some(respan(mk_sp(self.pat.span.lo, self.ty.span.hi),\n-                                     SelfKind::Explicit(self.ty.clone(), ident.node))),\n+                                     SelfKind::Explicit(self.ty.clone(), mutbl))),\n                 }\n             }\n         }\n         None\n     }\n \n-    pub fn from_self(eself: ExplicitSelf, ident_sp: Span, mutbl: Mutability) -> Arg {\n-        let pat = |ident, span| P(Pat {\n-            id: DUMMY_NODE_ID,\n-            node: PatKind::Ident(BindingMode::ByValue(mutbl), respan(ident_sp, ident), None),\n-            span: span,\n-        });\n+    pub fn is_self(&self) -> bool {\n+        if let PatKind::Ident(_, ident, _) = self.pat.node {\n+            ident.node.name == keywords::SelfValue.name()\n+        } else {\n+            false\n+        }\n+    }\n+\n+    pub fn from_self(eself: ExplicitSelf, eself_ident: SpannedIdent) -> Arg {\n         let infer_ty = P(Ty {\n             id: DUMMY_NODE_ID,\n-            node: TyKind::Infer,\n+            node: TyKind::ImplicitSelf,\n             span: DUMMY_SP,\n         });\n-        let arg = |ident, ty, span| Arg {\n-            pat: pat(ident, span),\n+        let arg = |mutbl, ty, span| Arg {\n+            pat: P(Pat {\n+                id: DUMMY_NODE_ID,\n+                node: PatKind::Ident(BindingMode::ByValue(mutbl), eself_ident, None),\n+                span: span,\n+            }),\n             ty: ty,\n             id: DUMMY_NODE_ID,\n         };\n         match eself.node {\n-            SelfKind::Static => panic!(\"bug: `Arg::from_self` is called \\\n-                                        with `SelfKind::Static` argument\"),\n-            SelfKind::Explicit(ty, ident) => arg(ident, ty, mk_sp(eself.span.lo, ident_sp.hi)),\n-            SelfKind::Value(ident) => arg(ident, infer_ty, eself.span),\n-            SelfKind::Region(lt, mutbl, ident) => arg(ident, P(Ty {\n+            SelfKind::Explicit(ty, mutbl) => {\n+                arg(mutbl, ty, mk_sp(eself.span.lo, eself_ident.span.hi))\n+            }\n+            SelfKind::Value(mutbl) => arg(mutbl, infer_ty, eself.span),\n+            SelfKind::Region(lt, mutbl) => arg(Mutability::Immutable, P(Ty {\n                 id: DUMMY_NODE_ID,\n                 node: TyKind::Rptr(lt, MutTy { ty: infer_ty, mutbl: mutbl }),\n                 span: DUMMY_SP,\n@@ -1770,6 +1755,15 @@ pub struct FnDecl {\n     pub variadic: bool\n }\n \n+impl FnDecl {\n+    pub fn get_self(&self) -> Option<ExplicitSelf> {\n+        self.inputs.get(0).and_then(Arg::to_self)\n+    }\n+    pub fn has_self(&self) -> bool {\n+        self.inputs.get(0).map(Arg::is_self).unwrap_or(false)\n+    }\n+}\n+\n #[derive(Copy, Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Unsafety {\n     Unsafe,"}, {"sha": "ecca370fb8a3a4fabb18d404a2065a0163baad67", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -950,7 +950,6 @@ fn expand_and_rename_method(sig: ast::MethodSig, body: P<ast::Block>,\n     (ast::MethodSig {\n         generics: fld.fold_generics(sig.generics),\n         abi: sig.abi,\n-        explicit_self: fld.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n         decl: rewritten_fn_decl"}, {"sha": "edf418e33325b6a51eca26b853a412470452a794", "filename": "src/libsyntax/fold.rs", "status": "modified", "additions": 1, "deletions": 32, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffold.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -179,14 +179,6 @@ pub trait Folder : Sized {\n         // fold::noop_fold_mac(_mac, self)\n     }\n \n-    fn fold_explicit_self(&mut self, es: ExplicitSelf) -> ExplicitSelf {\n-        noop_fold_explicit_self(es, self)\n-    }\n-\n-    fn fold_explicit_self_kind(&mut self, es: SelfKind) -> SelfKind {\n-        noop_fold_explicit_self_kind(es, self)\n-    }\n-\n     fn fold_lifetime(&mut self, l: Lifetime) -> Lifetime {\n         noop_fold_lifetime(l, self)\n     }\n@@ -383,7 +375,7 @@ pub fn noop_fold_ty<T: Folder>(t: P<Ty>, fld: &mut T) -> P<Ty> {\n     t.map(|Ty {id, node, span}| Ty {\n         id: fld.new_id(id),\n         node: match node {\n-            TyKind::Infer => node,\n+            TyKind::Infer | TyKind::ImplicitSelf => node,\n             TyKind::Vec(ty) => TyKind::Vec(fld.fold_ty(ty)),\n             TyKind::Ptr(mt) => TyKind::Ptr(fld.fold_mt(mt)),\n             TyKind::Rptr(region, mt) => {\n@@ -523,28 +515,6 @@ pub fn noop_fold_attribute<T: Folder>(at: Attribute, fld: &mut T) -> Option<Attr\n     })\n }\n \n-pub fn noop_fold_explicit_self_kind<T: Folder>(es: SelfKind, fld: &mut T)\n-                                                     -> SelfKind {\n-    match es {\n-        SelfKind::Static | SelfKind::Value(_) => es,\n-        SelfKind::Region(lifetime, m, ident) => {\n-            SelfKind::Region(fld.fold_opt_lifetime(lifetime), m, ident)\n-        }\n-        SelfKind::Explicit(typ, ident) => {\n-            SelfKind::Explicit(fld.fold_ty(typ), ident)\n-        }\n-    }\n-}\n-\n-pub fn noop_fold_explicit_self<T: Folder>(Spanned {span, node}: ExplicitSelf, fld: &mut T)\n-                                          -> ExplicitSelf {\n-    Spanned {\n-        node: fld.fold_explicit_self_kind(node),\n-        span: fld.new_span(span)\n-    }\n-}\n-\n-\n pub fn noop_fold_mac<T: Folder>(Spanned {node, span}: Mac, fld: &mut T) -> Mac {\n     Spanned {\n         node: Mac_ {\n@@ -1096,7 +1066,6 @@ pub fn noop_fold_method_sig<T: Folder>(sig: MethodSig, folder: &mut T) -> Method\n     MethodSig {\n         generics: folder.fold_generics(sig.generics),\n         abi: sig.abi,\n-        explicit_self: folder.fold_explicit_self(sig.explicit_self),\n         unsafety: sig.unsafety,\n         constness: sig.constness,\n         decl: folder.fold_fn_decl(sig.decl)"}, {"sha": "de74cdc8fb3dea5ca5127bd5e8308fb04533d5a8", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 52, "deletions": 61, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -17,7 +17,7 @@ use ast::Block;\n use ast::{BlockCheckMode, CaptureBy};\n use ast::{Constness, Crate, CrateConfig};\n use ast::{Decl, DeclKind, Defaultness};\n-use ast::{EMPTY_CTXT, EnumDef, ExplicitSelf};\n+use ast::{EMPTY_CTXT, EnumDef};\n use ast::{Expr, ExprKind, RangeLimits};\n use ast::{Field, FnDecl};\n use ast::{ForeignItem, ForeignItemKind, FunctionRetTy};\n@@ -1291,7 +1291,7 @@ impl<'a> Parser<'a> {\n                 let ident = p.parse_ident()?;\n                 let mut generics = p.parse_generics()?;\n \n-                let (explicit_self, d) = p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n+                let d = p.parse_fn_decl_with_self(|p: &mut Parser<'a>|{\n                     // This is somewhat dubious; We don't want to allow\n                     // argument names to be left off if there is a\n                     // definition...\n@@ -1305,7 +1305,6 @@ impl<'a> Parser<'a> {\n                     decl: d,\n                     generics: generics,\n                     abi: abi,\n-                    explicit_self: explicit_self,\n                 };\n \n                 let body = match p.token {\n@@ -4600,25 +4599,19 @@ impl<'a> Parser<'a> {\n         }))\n     }\n \n-    /// Parse the parameter list and result type of a function that may have a `self` parameter.\n-    fn parse_fn_decl_with_self<F>(&mut self,\n-                                  parse_arg_fn: F)\n-                                  -> PResult<'a, (ExplicitSelf, P<FnDecl>)>\n-        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n-    {\n+    /// Returns the parsed optional self argument and whether a self shortcut was used.\n+    fn parse_self_arg(&mut self) -> PResult<'a, Option<Arg>> {\n         let expect_ident = |this: &mut Self| match this.token {\n-            token::Ident(ident) => { this.bump(); ident } // Preserve hygienic context.\n+            // Preserve hygienic context.\n+            token::Ident(ident) => { this.bump(); codemap::respan(this.last_span, ident) }\n             _ => unreachable!()\n         };\n \n-        self.expect(&token::OpenDelim(token::Paren))?;\n-\n         // Parse optional self parameter of a method.\n         // Only a limited set of initial token sequences is considered self parameters, anything\n         // else is parsed as a normal function parameter list, so some lookahead is required.\n         let eself_lo = self.span.lo;\n-        let mut eself_mutbl = Mutability::Immutable;\n-        let (eself, eself_ident_sp) = match self.token {\n+        let (eself, eself_ident) = match self.token {\n             token::BinOp(token::And) => {\n                 // &self\n                 // &mut self\n@@ -4627,30 +4620,26 @@ impl<'a> Parser<'a> {\n                 // &not_self\n                 if self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n-                    (SelfKind::Region(None, Mutability::Immutable, expect_ident(self)),\n-                        self.last_span)\n+                    (SelfKind::Region(None, Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_keyword(keywords::Mut)) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     self.bump();\n-                    (SelfKind::Region(None, Mutability::Mutable, expect_ident(self)),\n-                        self.last_span)\n+                    (SelfKind::Region(None, Mutability::Mutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     let lt = self.parse_lifetime()?;\n-                    (SelfKind::Region(Some(lt), Mutability::Immutable, expect_ident(self)),\n-                        self.last_span)\n+                    (SelfKind::Region(Some(lt), Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_lifetime()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::Mut)) &&\n                           self.look_ahead(3, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     let lt = self.parse_lifetime()?;\n                     self.bump();\n-                    (SelfKind::Region(Some(lt), Mutability::Mutable, expect_ident(self)),\n-                        self.last_span)\n+                    (SelfKind::Region(Some(lt), Mutability::Mutable), expect_ident(self))\n                 } else {\n-                    (SelfKind::Static, codemap::DUMMY_SP)\n+                    return Ok(None);\n                 }\n             }\n             token::BinOp(token::Star) => {\n@@ -4662,80 +4651,85 @@ impl<'a> Parser<'a> {\n                 if self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n-                    (SelfKind::Value(expect_ident(self)), self.last_span)\n+                    (SelfKind::Value(Mutability::Immutable), expect_ident(self))\n                 } else if self.look_ahead(1, |t| t.is_mutability()) &&\n                           self.look_ahead(2, |t| t.is_keyword(keywords::SelfValue)) {\n                     self.bump();\n                     self.bump();\n                     self.span_err(self.span, \"cannot pass `self` by raw pointer\");\n-                    (SelfKind::Value(expect_ident(self)), self.last_span)\n+                    (SelfKind::Value(Mutability::Immutable), expect_ident(self))\n                 } else {\n-                    (SelfKind::Static, codemap::DUMMY_SP)\n+                    return Ok(None);\n                 }\n             }\n             token::Ident(..) => {\n                 if self.token.is_keyword(keywords::SelfValue) {\n                     // self\n                     // self: TYPE\n                     let eself_ident = expect_ident(self);\n-                    let eself_ident_sp = self.last_span;\n                     if self.eat(&token::Colon) {\n-                        (SelfKind::Explicit(self.parse_ty_sum()?, eself_ident), eself_ident_sp)\n+                        let ty = self.parse_ty_sum()?;\n+                        (SelfKind::Explicit(ty, Mutability::Immutable), eself_ident)\n                     } else {\n-                        (SelfKind::Value(eself_ident), eself_ident_sp)\n+                        (SelfKind::Value(Mutability::Immutable), eself_ident)\n                     }\n                 } else if self.token.is_keyword(keywords::Mut) &&\n                         self.look_ahead(1, |t| t.is_keyword(keywords::SelfValue)) {\n                     // mut self\n                     // mut self: TYPE\n-                    eself_mutbl = Mutability::Mutable;\n                     self.bump();\n                     let eself_ident = expect_ident(self);\n-                    let eself_ident_sp = self.last_span;\n                     if self.eat(&token::Colon) {\n-                        (SelfKind::Explicit(self.parse_ty_sum()?, eself_ident), eself_ident_sp)\n+                        let ty = self.parse_ty_sum()?;\n+                        (SelfKind::Explicit(ty, Mutability::Mutable), eself_ident)\n                     } else {\n-                        (SelfKind::Value(eself_ident), eself_ident_sp)\n+                        (SelfKind::Value(Mutability::Mutable), eself_ident)\n                     }\n                 } else {\n-                    (SelfKind::Static, codemap::DUMMY_SP)\n+                    return Ok(None);\n                 }\n             }\n-            _ => (SelfKind::Static, codemap::DUMMY_SP)\n+            _ => return Ok(None),\n         };\n-        let mut eself = codemap::respan(mk_sp(eself_lo, self.last_span.hi), eself);\n+\n+        let eself = codemap::respan(mk_sp(eself_lo, self.last_span.hi), eself);\n+        Ok(Some(Arg::from_self(eself, eself_ident)))\n+    }\n+\n+    /// Parse the parameter list and result type of a function that may have a `self` parameter.\n+    fn parse_fn_decl_with_self<F>(&mut self, parse_arg_fn: F) -> PResult<'a, P<FnDecl>>\n+        where F: FnMut(&mut Parser<'a>) -> PResult<'a,  Arg>,\n+    {\n+        self.expect(&token::OpenDelim(token::Paren))?;\n+\n+        // Parse optional self argument\n+        let self_arg = self.parse_self_arg()?;\n \n         // Parse the rest of the function parameter list.\n         let sep = SeqSep::trailing_allowed(token::Comma);\n-        let fn_inputs = match eself.node {\n-            SelfKind::Static => {\n-                eself.span = codemap::DUMMY_SP;\n-                self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n-            }\n-            SelfKind::Value(..) | SelfKind::Region(..) | SelfKind::Explicit(..) => {\n-                if self.check(&token::CloseDelim(token::Paren)) {\n-                    vec![Arg::from_self(eself.clone(), eself_ident_sp, eself_mutbl)]\n-                } else if self.check(&token::Comma) {\n-                    self.bump();\n-                    let mut fn_inputs = vec![Arg::from_self(eself.clone(), eself_ident_sp,\n-                                                            eself_mutbl)];\n-                    fn_inputs.append(&mut self.parse_seq_to_before_end(\n-                        &token::CloseDelim(token::Paren), sep, parse_arg_fn)\n-                    );\n-                    fn_inputs\n-                } else {\n-                    return self.unexpected();\n-                }\n+        let fn_inputs = if let Some(self_arg) = self_arg {\n+            if self.check(&token::CloseDelim(token::Paren)) {\n+                vec![self_arg]\n+            } else if self.eat(&token::Comma) {\n+                let mut fn_inputs = vec![self_arg];\n+                fn_inputs.append(&mut self.parse_seq_to_before_end(\n+                    &token::CloseDelim(token::Paren), sep, parse_arg_fn)\n+                );\n+                fn_inputs\n+            } else {\n+                return self.unexpected();\n             }\n+        } else {\n+            self.parse_seq_to_before_end(&token::CloseDelim(token::Paren), sep, parse_arg_fn)\n         };\n \n         // Parse closing paren and return type.\n         self.expect(&token::CloseDelim(token::Paren))?;\n-        Ok((eself, P(FnDecl {\n+        Ok(P(FnDecl {\n             inputs: fn_inputs,\n             output: self.parse_ret_ty()?,\n             variadic: false\n-        })))\n+        }))\n     }\n \n     // parse the |arg, arg| header on a lambda\n@@ -4928,15 +4922,12 @@ impl<'a> Parser<'a> {\n             let (constness, unsafety, abi) = self.parse_fn_front_matter()?;\n             let ident = self.parse_ident()?;\n             let mut generics = self.parse_generics()?;\n-            let (explicit_self, decl) = self.parse_fn_decl_with_self(|p| {\n-                    p.parse_arg()\n-                })?;\n+            let decl = self.parse_fn_decl_with_self(|p| p.parse_arg())?;\n             generics.where_clause = self.parse_where_clause()?;\n             let (inner_attrs, body) = self.parse_inner_attrs_and_block()?;\n             Ok((ident, inner_attrs, ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: generics,\n                 abi: abi,\n-                explicit_self: explicit_self,\n                 unsafety: unsafety,\n                 constness: constness,\n                 decl: decl"}, {"sha": "5b9ec924de953528e5ea4c0bfd476f2c69e44543", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 29, "deletions": 52, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -12,7 +12,7 @@ pub use self::AnnNode::*;\n \n use abi::{self, Abi};\n use ast::{self, TokenTree, BlockCheckMode, PatKind};\n-use ast::{RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n+use ast::{SelfKind, RegionTyParamBound, TraitTyParamBound, TraitBoundModifier};\n use ast::Attribute;\n use attr::ThinAttributesExt;\n use util::parser::AssocOp;\n@@ -382,13 +382,12 @@ pub fn fun_to_string(decl: &ast::FnDecl,\n                      unsafety: ast::Unsafety,\n                      constness: ast::Constness,\n                      name: ast::Ident,\n-                     opt_explicit_self: Option<&ast::SelfKind>,\n                      generics: &ast::Generics)\n                      -> String {\n     to_string(|s| {\n         s.head(\"\")?;\n         s.print_fn(decl, unsafety, constness, Abi::Rust, Some(name),\n-                   generics, opt_explicit_self, &ast::Visibility::Inherited)?;\n+                   generics, &ast::Visibility::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -416,10 +415,6 @@ pub fn lit_to_string(l: &ast::Lit) -> String {\n     to_string(|s| s.print_literal(l))\n }\n \n-pub fn explicit_self_to_string(explicit_self: &ast::SelfKind) -> String {\n-    to_string(|s| s.print_explicit_self(explicit_self, ast::Mutability::Immutable).map(|_| {}))\n-}\n-\n pub fn variant_to_string(var: &ast::Variant) -> String {\n     to_string(|s| s.print_variant(var))\n }\n@@ -1005,8 +1000,7 @@ impl<'a> State<'a> {\n                                  f.unsafety,\n                                  &f.decl,\n                                  None,\n-                                 &generics,\n-                                 None)?;\n+                                 &generics)?;\n             }\n             ast::TyKind::Path(None, ref path) => {\n                 self.print_path(path, false, 0)?;\n@@ -1036,6 +1030,9 @@ impl<'a> State<'a> {\n             ast::TyKind::Infer => {\n                 word(&mut self.s, \"_\")?;\n             }\n+            ast::TyKind::ImplicitSelf => {\n+                unreachable!();\n+            }\n             ast::TyKind::Mac(ref m) => {\n                 self.print_mac(m, token::Paren)?;\n             }\n@@ -1054,7 +1051,7 @@ impl<'a> State<'a> {\n                 self.print_fn(decl, ast::Unsafety::Normal,\n                               ast::Constness::NotConst,\n                               Abi::Rust, Some(item.ident),\n-                              generics, None, &item.vis)?;\n+                              generics, &item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n@@ -1182,7 +1179,6 @@ impl<'a> State<'a> {\n                     abi,\n                     Some(item.ident),\n                     typarams,\n-                    None,\n                     &item.vis\n                 )?;\n                 word(&mut self.s, \" \")?;\n@@ -1522,7 +1518,6 @@ impl<'a> State<'a> {\n                       m.abi,\n                       Some(ident),\n                       &m.generics,\n-                      None,\n                       vis)\n     }\n \n@@ -2626,29 +2621,25 @@ impl<'a> State<'a> {\n         self.end() // close enclosing cbox\n     }\n \n-    // Returns whether it printed anything\n-    fn print_explicit_self(&mut self,\n-                           explicit_self: &ast::SelfKind,\n-                           mutbl: ast::Mutability) -> io::Result<bool> {\n-        self.print_mutability(mutbl)?;\n-        match *explicit_self {\n-            ast::SelfKind::Static => { return Ok(false); }\n-            ast::SelfKind::Value(_) => {\n-                word(&mut self.s, \"self\")?;\n+    fn print_explicit_self(&mut self, explicit_self: &ast::ExplicitSelf) -> io::Result<()> {\n+        match explicit_self.node {\n+            SelfKind::Value(m) => {\n+                self.print_mutability(m)?;\n+                word(&mut self.s, \"self\")\n             }\n-            ast::SelfKind::Region(ref lt, m, _) => {\n+            SelfKind::Region(ref lt, m) => {\n                 word(&mut self.s, \"&\")?;\n                 self.print_opt_lifetime(lt)?;\n                 self.print_mutability(m)?;\n-                word(&mut self.s, \"self\")?;\n+                word(&mut self.s, \"self\")\n             }\n-            ast::SelfKind::Explicit(ref typ, _) => {\n+            SelfKind::Explicit(ref typ, m) => {\n+                self.print_mutability(m)?;\n                 word(&mut self.s, \"self\")?;\n                 self.word_space(\":\")?;\n-                self.print_type(&typ)?;\n+                self.print_type(&typ)\n             }\n         }\n-        return Ok(true);\n     }\n \n     pub fn print_fn(&mut self,\n@@ -2658,7 +2649,6 @@ impl<'a> State<'a> {\n                     abi: abi::Abi,\n                     name: Option<ast::Ident>,\n                     generics: &ast::Generics,\n-                    opt_explicit_self: Option<&ast::SelfKind>,\n                     vis: &ast::Visibility) -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n \n@@ -2667,21 +2657,14 @@ impl<'a> State<'a> {\n             self.print_ident(name)?;\n         }\n         self.print_generics(generics)?;\n-        self.print_fn_args_and_ret(decl, opt_explicit_self)?;\n+        self.print_fn_args_and_ret(decl)?;\n         self.print_where_clause(&generics.where_clause)\n     }\n \n-    pub fn print_fn_args(&mut self, decl: &ast::FnDecl,\n-                         _: Option<&ast::SelfKind>,\n-                         is_closure: bool) -> io::Result<()> {\n-        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, is_closure))\n-    }\n-\n-    pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl,\n-                                 opt_explicit_self: Option<&ast::SelfKind>)\n+    pub fn print_fn_args_and_ret(&mut self, decl: &ast::FnDecl)\n         -> io::Result<()> {\n         self.popen()?;\n-        self.print_fn_args(decl, opt_explicit_self, false)?;\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, false))?;\n         if decl.variadic {\n             word(&mut self.s, \", ...\")?;\n         }\n@@ -2695,7 +2678,7 @@ impl<'a> State<'a> {\n             decl: &ast::FnDecl)\n             -> io::Result<()> {\n         word(&mut self.s, \"|\")?;\n-        self.print_fn_args(decl, None, true)?;\n+        self.commasep(Inconsistent, &decl.inputs, |s, arg| s.print_arg(arg, true))?;\n         word(&mut self.s, \"|\")?;\n \n         if let ast::FunctionRetTy::Default(..) = decl.output {\n@@ -2945,17 +2928,14 @@ impl<'a> State<'a> {\n         match input.ty.node {\n             ast::TyKind::Infer if is_closure => self.print_pat(&input.pat)?,\n             _ => {\n-                let (mutbl, invalid) = match input.pat.node {\n-                    PatKind::Ident(ast::BindingMode::ByValue(mutbl), ident, _) |\n-                    PatKind::Ident(ast::BindingMode::ByRef(mutbl), ident, _) => {\n-                        (mutbl, ident.node.name == keywords::Invalid.name())\n-                    }\n-                    _ => (ast::Mutability::Immutable, false)\n-                };\n-\n                 if let Some(eself) = input.to_self() {\n-                    self.print_explicit_self(&eself.node, mutbl)?;\n+                    self.print_explicit_self(&eself)?;\n                 } else {\n+                    let invalid = if let PatKind::Ident(_, ident, _) = input.pat.node {\n+                        ident.node.name == keywords::Invalid.name()\n+                    } else {\n+                        false\n+                    };\n                     if !invalid {\n                         self.print_pat(&input.pat)?;\n                         word(&mut self.s, \":\")?;\n@@ -2996,8 +2976,7 @@ impl<'a> State<'a> {\n                        unsafety: ast::Unsafety,\n                        decl: &ast::FnDecl,\n                        name: Option<ast::Ident>,\n-                       generics: &ast::Generics,\n-                       opt_explicit_self: Option<&ast::SelfKind>)\n+                       generics: &ast::Generics)\n                        -> io::Result<()> {\n         self.ibox(INDENT_UNIT)?;\n         if !generics.lifetimes.is_empty() || !generics.ty_params.is_empty() {\n@@ -3018,7 +2997,6 @@ impl<'a> State<'a> {\n                       abi,\n                       name,\n                       &generics,\n-                      opt_explicit_self,\n                       &ast::Visibility::Inherited)?;\n         self.end()\n     }\n@@ -3142,8 +3120,7 @@ mod tests {\n         let generics = ast::Generics::default();\n         assert_eq!(fun_to_string(&decl, ast::Unsafety::Normal,\n                                  ast::Constness::NotConst,\n-                                 abba_ident,\n-                                 None, &generics),\n+                                 abba_ident, &generics),\n                    \"fn abba()\");\n     }\n "}, {"sha": "919dd84b117993292342e07a45ea923a77edeabf", "filename": "src/libsyntax/util/node_count.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fnode_count.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -129,10 +129,6 @@ impl<'v> Visitor<'v> for NodeCounter {\n         self.count += 1;\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n-        self.count += 1;\n-        walk_explicit_self(self, es)\n-    }\n     fn visit_mac(&mut self, _mac: &'v Mac) {\n         self.count += 1;\n         walk_mac(self, _mac)"}, {"sha": "8a02e549d4c398abe61336cf12595a5f631607e0", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 24, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -99,9 +99,6 @@ pub trait Visitor<'v> : Sized {\n     fn visit_lifetime_def(&mut self, lifetime: &'v LifetimeDef) {\n         walk_lifetime_def(self, lifetime)\n     }\n-    fn visit_explicit_self(&mut self, es: &'v ExplicitSelf) {\n-        walk_explicit_self(self, es)\n-    }\n     fn visit_mac(&mut self, _mac: &'v Mac) {\n         panic!(\"visit_mac disabled by default\");\n         // NB: see note about macros above.\n@@ -203,24 +200,6 @@ pub fn walk_lifetime_def<'v, V: Visitor<'v>>(visitor: &mut V,\n     walk_list!(visitor, visit_lifetime, &lifetime_def.bounds);\n }\n \n-pub fn walk_explicit_self<'v, V: Visitor<'v>>(visitor: &mut V,\n-                                              explicit_self: &'v ExplicitSelf) {\n-    match explicit_self.node {\n-        SelfKind::Static => {},\n-        SelfKind::Value(ident) => {\n-            visitor.visit_ident(explicit_self.span, ident)\n-        }\n-        SelfKind::Region(ref opt_lifetime, _, ident) => {\n-            visitor.visit_ident(explicit_self.span, ident);\n-            walk_list!(visitor, visit_lifetime, opt_lifetime);\n-        }\n-        SelfKind::Explicit(ref typ, ident) => {\n-            visitor.visit_ident(explicit_self.span, ident);\n-            visitor.visit_ty(typ)\n-        }\n-    }\n-}\n-\n pub fn walk_poly_trait_ref<'v, V>(visitor: &mut V,\n                                   trait_ref: &'v PolyTraitRef,\n                                   _modifier: &'v TraitBoundModifier)\n@@ -376,7 +355,7 @@ pub fn walk_ty<'v, V: Visitor<'v>>(visitor: &mut V, typ: &'v Ty) {\n         TyKind::Typeof(ref expression) => {\n             visitor.visit_expr(expression)\n         }\n-        TyKind::Infer => {}\n+        TyKind::Infer | TyKind::ImplicitSelf => {}\n         TyKind::Mac(ref mac) => {\n             visitor.visit_mac(mac)\n         }\n@@ -558,7 +537,6 @@ pub fn walk_fn_kind<'v, V: Visitor<'v>>(visitor: &mut V,\n         }\n         FnKind::Method(_, ref sig, _) => {\n             visitor.visit_generics(&sig.generics);\n-            visitor.visit_explicit_self(&sig.explicit_self);\n         }\n         FnKind::Closure => {}\n     }\n@@ -583,7 +561,6 @@ pub fn walk_trait_item<'v, V: Visitor<'v>>(visitor: &mut V, trait_item: &'v Trai\n             walk_list!(visitor, visit_expr, default);\n         }\n         TraitItemKind::Method(ref sig, None) => {\n-            visitor.visit_explicit_self(&sig.explicit_self);\n             visitor.visit_generics(&sig.generics);\n             walk_fn_decl(visitor, &sig.decl);\n         }"}, {"sha": "9095230df630a339e5b63a74e7095501aee1b039", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 15, "deletions": 24, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -197,7 +197,7 @@ use syntax::attr;\n use syntax::attr::AttrMetaMethods;\n use syntax::ext::base::{ExtCtxt, Annotatable};\n use syntax::ext::build::AstBuilder;\n-use syntax::codemap::{self, DUMMY_SP};\n+use syntax::codemap::{self, respan, DUMMY_SP};\n use syntax::codemap::Span;\n use syntax::errors::Handler;\n use syntax::util::move_map::MoveMap;\n@@ -806,25 +806,21 @@ impl<'a> MethodDef<'a> {\n                                trait_: &TraitDef,\n                                type_ident: Ident,\n                                generics: &Generics)\n-        -> (ast::ExplicitSelf, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n+        -> (Option<ast::ExplicitSelf>, Vec<P<Expr>>, Vec<P<Expr>>, Vec<(Ident, P<ast::Ty>)>) {\n \n         let mut self_args = Vec::new();\n         let mut nonself_args = Vec::new();\n         let mut arg_tys = Vec::new();\n         let mut nonstatic = false;\n \n-        let ast_explicit_self = match self.explicit_self {\n-            Some(ref self_ptr) => {\n-                let (self_expr, explicit_self) =\n-                    ty::get_explicit_self(cx, trait_.span, self_ptr);\n+        let ast_explicit_self = self.explicit_self.as_ref().map(|self_ptr| {\n+            let (self_expr, explicit_self) = ty::get_explicit_self(cx, trait_.span, self_ptr);\n \n-                self_args.push(self_expr);\n-                nonstatic = true;\n+            self_args.push(self_expr);\n+            nonstatic = true;\n \n-                explicit_self\n-            }\n-            None => codemap::respan(trait_.span, ast::SelfKind::Static),\n-        };\n+            explicit_self\n+        });\n \n         for (i, ty) in self.args.iter().enumerate() {\n             let ast_ty = ty.to_ty(cx, trait_.span, type_ident, generics);\n@@ -857,24 +853,20 @@ impl<'a> MethodDef<'a> {\n                      type_ident: Ident,\n                      generics: &Generics,\n                      abi: Abi,\n-                     explicit_self: ast::ExplicitSelf,\n+                     explicit_self: Option<ast::ExplicitSelf>,\n                      arg_types: Vec<(Ident, P<ast::Ty>)> ,\n                      body: P<Expr>) -> ast::ImplItem {\n \n         // create the generics that aren't for Self\n         let fn_generics = self.generics.to_generics(cx, trait_.span, type_ident, generics);\n \n-        let self_arg = match explicit_self.node {\n-            ast::SelfKind::Static => None,\n-            // creating fresh self id\n-            _ => Some(ast::Arg::from_self(explicit_self.clone(), trait_.span,\n-                                          ast::Mutability::Immutable)),\n-        };\n         let args = {\n-            let args = arg_types.into_iter().map(|(name, ty)| {\n-                    cx.arg(trait_.span, name, ty)\n-                });\n-            self_arg.into_iter().chain(args).collect()\n+            let self_args = explicit_self.map(|explicit_self| {\n+                ast::Arg::from_self(explicit_self, respan(trait_.span, keywords::SelfValue.ident()))\n+            });\n+            let nonself_args = arg_types.into_iter()\n+                                        .map(|(name, ty)| cx.arg(trait_.span, name, ty));\n+            self_args.into_iter().chain(nonself_args).collect()\n         };\n \n         let ret_type = self.get_ret_ty(cx, trait_, generics, type_ident);\n@@ -900,7 +892,6 @@ impl<'a> MethodDef<'a> {\n             node: ast::ImplItemKind::Method(ast::MethodSig {\n                 generics: fn_generics,\n                 abi: abi,\n-                explicit_self: explicit_self,\n                 unsafety: unsafety,\n                 constness: ast::Constness::NotConst,\n                 decl: fn_decl"}, {"sha": "b581f5267eaac221ccfa0cb708b7d0d45d19b13a", "filename": "src/libsyntax_ext/deriving/generic/ty.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7905452f083ab5ac3008dfe6727048e70bbeb142/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=7905452f083ab5ac3008dfe6727048e70bbeb142", "patch": "@@ -15,11 +15,10 @@ pub use self::PtrTy::*;\n pub use self::Ty::*;\n \n use syntax::ast;\n-use syntax::ast::{Expr,Generics,Ident};\n+use syntax::ast::{Expr, Generics, Ident, SelfKind};\n use syntax::ext::base::ExtCtxt;\n use syntax::ext::build::AstBuilder;\n use syntax::codemap::{Span,respan};\n-use syntax::parse::token::keywords;\n use syntax::ptr::P;\n \n /// The types of pointers\n@@ -258,20 +257,19 @@ impl<'a> LifetimeBounds<'a> {\n \n pub fn get_explicit_self(cx: &ExtCtxt, span: Span, self_ptr: &Option<PtrTy>)\n     -> (P<Expr>, ast::ExplicitSelf) {\n-    // this constructs a fresh `self` path, which will match the fresh `self` binding\n-    // created below.\n+    // this constructs a fresh `self` path\n     let self_path = cx.expr_self(span);\n     match *self_ptr {\n         None => {\n-            (self_path, respan(span, ast::SelfKind::Value(keywords::SelfValue.ident())))\n+            (self_path, respan(span, SelfKind::Value(ast::Mutability::Immutable)))\n         }\n         Some(ref ptr) => {\n             let self_ty = respan(\n                 span,\n                 match *ptr {\n                     Borrowed(ref lt, mutbl) => {\n                         let lt = lt.map(|s| cx.lifetime(span, cx.ident_of(s).name));\n-                        ast::SelfKind::Region(lt, mutbl, keywords::SelfValue.ident())\n+                        SelfKind::Region(lt, mutbl)\n                     }\n                     Raw(_) => cx.span_bug(span, \"attempted to use *self in deriving definition\")\n                 });"}]}