{"sha": "6d812efcd9e632a47ba85086c0a9dc72d13ff732", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkODEyZWZjZDllNjMyYTQ3YmE4NTA4NmMwYTlkYzcyZDEzZmY3MzI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-05-04T11:51:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-05-04T11:51:09Z"}, "message": "Merge #8711\n\n8711: Only resolve selected assist r=matklad a=SomeoneToIgnore\n\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/8700\r\n\r\nNow resolves only the assist that was selected out of the list, while before the whole assist list was resolved despite a single popup selection.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>", "tree": {"sha": "9d7fb6a806cdf5ba85a786bd888707e28309dd02", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d7fb6a806cdf5ba85a786bd888707e28309dd02"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d812efcd9e632a47ba85086c0a9dc72d13ff732", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgkTUtCRBK7hj4Ov3rIwAA9MQIAAwEpiI5hLPMQgNGxznKROMk\neDAWNWLC6nrxGJocwLFOi10nlNnu1fBblQu46Wod3ZP873fc00hWqTNqXGzMuUJ6\nMqrbuHTtlWeo8GTAltPiCSf3hnfZHbvGwH41TyCnVvweEaJDeoTM7uFCz0V1AMMY\nWi6g5O/qenFcln6AhYCrPcQ1XdHdmXZBoJxg/TWUE6tox+OegPbSP2mvWk+jJ4VR\nr/4XhfECDSPuX4AxyX7R3WrVjYQd7FosizHNs+4UtFP4ainu75g8LZm8Zgsotizt\niXWTcMQ0lIIiiWq2WT+eCzxwkj+vYNP9uEcWjjJmiZptX41wlJmhRVMtmRwtUxA=\n=RPUF\n-----END PGP SIGNATURE-----\n", "payload": "tree 9d7fb6a806cdf5ba85a786bd888707e28309dd02\nparent 0323045631e26bc919bcb2e50af2dfae385980ed\nparent 734b95a1ac9a65cec45d8f9024d53638e6a3cd2e\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1620129069 +0000\ncommitter GitHub <noreply@github.com> 1620129069 +0000\n\nMerge #8711\n\n8711: Only resolve selected assist r=matklad a=SomeoneToIgnore\n\nPart of https://github.com/rust-analyzer/rust-analyzer/issues/8700\r\n\r\nNow resolves only the assist that was selected out of the list, while before the whole assist list was resolved despite a single popup selection.\n\nCo-authored-by: Kirill Bulatov <mail4score@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d812efcd9e632a47ba85086c0a9dc72d13ff732", "html_url": "https://github.com/rust-lang/rust/commit/6d812efcd9e632a47ba85086c0a9dc72d13ff732", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d812efcd9e632a47ba85086c0a9dc72d13ff732/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0323045631e26bc919bcb2e50af2dfae385980ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/0323045631e26bc919bcb2e50af2dfae385980ed", "html_url": "https://github.com/rust-lang/rust/commit/0323045631e26bc919bcb2e50af2dfae385980ed"}, {"sha": "734b95a1ac9a65cec45d8f9024d53638e6a3cd2e", "url": "https://api.github.com/repos/rust-lang/rust/commits/734b95a1ac9a65cec45d8f9024d53638e6a3cd2e", "html_url": "https://github.com/rust-lang/rust/commit/734b95a1ac9a65cec45d8f9024d53638e6a3cd2e"}], "stats": {"total": 615, "additions": 518, "deletions": 97}, "files": [{"sha": "b14f908b75e189963742bce6065774a8cef1ee22", "filename": "crates/ide/src/diagnostics.rs", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -15,6 +15,7 @@ use hir::{\n     diagnostics::{Diagnostic as _, DiagnosticCode, DiagnosticSinkBuilder},\n     InFile, Semantics,\n };\n+use ide_assists::AssistResolveStrategy;\n use ide_db::{base_db::SourceDatabase, RootDatabase};\n use itertools::Itertools;\n use rustc_hash::FxHashSet;\n@@ -84,7 +85,7 @@ pub struct DiagnosticsConfig {\n pub(crate) fn diagnostics(\n     db: &RootDatabase,\n     config: &DiagnosticsConfig,\n-    resolve: bool,\n+    resolve: &AssistResolveStrategy,\n     file_id: FileId,\n ) -> Vec<Diagnostic> {\n     let _p = profile::span(\"diagnostics\");\n@@ -212,7 +213,7 @@ pub(crate) fn diagnostics(\n fn diagnostic_with_fix<D: DiagnosticWithFix>(\n     d: &D,\n     sema: &Semantics<RootDatabase>,\n-    resolve: bool,\n+    resolve: &AssistResolveStrategy,\n ) -> Diagnostic {\n     Diagnostic::error(sema.diagnostics_display_range(d.display_source()).range, d.message())\n         .with_fix(d.fix(&sema, resolve))\n@@ -222,7 +223,7 @@ fn diagnostic_with_fix<D: DiagnosticWithFix>(\n fn warning_with_fix<D: DiagnosticWithFix>(\n     d: &D,\n     sema: &Semantics<RootDatabase>,\n-    resolve: bool,\n+    resolve: &AssistResolveStrategy,\n ) -> Diagnostic {\n     Diagnostic::hint(sema.diagnostics_display_range(d.display_source()).range, d.message())\n         .with_fix(d.fix(&sema, resolve))\n@@ -299,6 +300,7 @@ fn unresolved_fix(id: &'static str, label: &str, target: TextRange) -> Assist {\n #[cfg(test)]\n mod tests {\n     use expect_test::{expect, Expect};\n+    use ide_assists::AssistResolveStrategy;\n     use stdx::trim_indent;\n     use test_utils::assert_eq_text;\n \n@@ -314,7 +316,11 @@ mod tests {\n \n         let (analysis, file_position) = fixture::position(ra_fixture_before);\n         let diagnostic = analysis\n-            .diagnostics(&DiagnosticsConfig::default(), true, file_position.file_id)\n+            .diagnostics(\n+                &DiagnosticsConfig::default(),\n+                AssistResolveStrategy::All,\n+                file_position.file_id,\n+            )\n             .unwrap()\n             .pop()\n             .unwrap();\n@@ -343,7 +349,11 @@ mod tests {\n     fn check_no_fix(ra_fixture: &str) {\n         let (analysis, file_position) = fixture::position(ra_fixture);\n         let diagnostic = analysis\n-            .diagnostics(&DiagnosticsConfig::default(), true, file_position.file_id)\n+            .diagnostics(\n+                &DiagnosticsConfig::default(),\n+                AssistResolveStrategy::All,\n+                file_position.file_id,\n+            )\n             .unwrap()\n             .pop()\n             .unwrap();\n@@ -357,16 +367,19 @@ mod tests {\n         let diagnostics = files\n             .into_iter()\n             .flat_map(|file_id| {\n-                analysis.diagnostics(&DiagnosticsConfig::default(), true, file_id).unwrap()\n+                analysis\n+                    .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::All, file_id)\n+                    .unwrap()\n             })\n             .collect::<Vec<_>>();\n         assert_eq!(diagnostics.len(), 0, \"unexpected diagnostics:\\n{:#?}\", diagnostics);\n     }\n \n     fn check_expect(ra_fixture: &str, expect: Expect) {\n         let (analysis, file_id) = fixture::file(ra_fixture);\n-        let diagnostics =\n-            analysis.diagnostics(&DiagnosticsConfig::default(), true, file_id).unwrap();\n+        let diagnostics = analysis\n+            .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::All, file_id)\n+            .unwrap();\n         expect.assert_debug_eq(&diagnostics)\n     }\n \n@@ -911,11 +924,13 @@ struct Foo {\n \n         let (analysis, file_id) = fixture::file(r#\"mod foo;\"#);\n \n-        let diagnostics = analysis.diagnostics(&config, true, file_id).unwrap();\n+        let diagnostics =\n+            analysis.diagnostics(&config, AssistResolveStrategy::All, file_id).unwrap();\n         assert!(diagnostics.is_empty());\n \n-        let diagnostics =\n-            analysis.diagnostics(&DiagnosticsConfig::default(), true, file_id).unwrap();\n+        let diagnostics = analysis\n+            .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::All, file_id)\n+            .unwrap();\n         assert!(!diagnostics.is_empty());\n     }\n \n@@ -1022,7 +1037,11 @@ impl TestStruct {\n \n         let (analysis, file_position) = fixture::position(input);\n         let diagnostics = analysis\n-            .diagnostics(&DiagnosticsConfig::default(), true, file_position.file_id)\n+            .diagnostics(\n+                &DiagnosticsConfig::default(),\n+                AssistResolveStrategy::All,\n+                file_position.file_id,\n+            )\n             .unwrap();\n         assert_eq!(diagnostics.len(), 1);\n "}, {"sha": "15821500f1acc765daddb7d5450335157617de59", "filename": "crates/ide/src/diagnostics/fixes.rs", "status": "modified", "additions": 42, "deletions": 9, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Ffixes.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -8,6 +8,7 @@ use hir::{\n     },\n     HasSource, HirDisplay, InFile, Semantics, VariantDef,\n };\n+use ide_assists::AssistResolveStrategy;\n use ide_db::{\n     base_db::{AnchoredPathBuf, FileId},\n     source_change::{FileSystemEdit, SourceChange},\n@@ -35,11 +36,19 @@ pub(crate) trait DiagnosticWithFix: Diagnostic {\n     ///\n     /// If `resolve` is false, the edit will be computed later, on demand, and\n     /// can be omitted.\n-    fn fix(&self, sema: &Semantics<RootDatabase>, _resolve: bool) -> Option<Assist>;\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist>;\n }\n \n impl DiagnosticWithFix for UnresolvedModule {\n-    fn fix(&self, sema: &Semantics<RootDatabase>, _resolve: bool) -> Option<Assist> {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         let unresolved_module = self.decl.to_node(&root);\n         Some(fix(\n@@ -59,7 +68,11 @@ impl DiagnosticWithFix for UnresolvedModule {\n }\n \n impl DiagnosticWithFix for NoSuchField {\n-    fn fix(&self, sema: &Semantics<RootDatabase>, _resolve: bool) -> Option<Assist> {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         missing_record_expr_field_fix(\n             &sema,\n@@ -70,7 +83,11 @@ impl DiagnosticWithFix for NoSuchField {\n }\n \n impl DiagnosticWithFix for MissingFields {\n-    fn fix(&self, sema: &Semantics<RootDatabase>, _resolve: bool) -> Option<Assist> {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n         // Note that although we could add a diagnostics to\n         // fill the missing tuple field, e.g :\n         // `struct A(usize);`\n@@ -106,7 +123,11 @@ impl DiagnosticWithFix for MissingFields {\n }\n \n impl DiagnosticWithFix for MissingOkOrSomeInTailExpr {\n-    fn fix(&self, sema: &Semantics<RootDatabase>, _resolve: bool) -> Option<Assist> {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         let tail_expr = self.expr.to_node(&root);\n         let tail_expr_range = tail_expr.syntax().text_range();\n@@ -119,7 +140,11 @@ impl DiagnosticWithFix for MissingOkOrSomeInTailExpr {\n }\n \n impl DiagnosticWithFix for RemoveThisSemicolon {\n-    fn fix(&self, sema: &Semantics<RootDatabase>, _resolve: bool) -> Option<Assist> {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n \n         let semicolon = self\n@@ -139,7 +164,11 @@ impl DiagnosticWithFix for RemoveThisSemicolon {\n }\n \n impl DiagnosticWithFix for IncorrectCase {\n-    fn fix(&self, sema: &Semantics<RootDatabase>, resolve: bool) -> Option<Assist> {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         let name_node = self.ident.to_node(&root);\n \n@@ -149,7 +178,7 @@ impl DiagnosticWithFix for IncorrectCase {\n \n         let label = format!(\"Rename to {}\", self.suggested_text);\n         let mut res = unresolved_fix(\"change_case\", &label, frange.range);\n-        if resolve {\n+        if resolve.should_resolve(&res.id) {\n             let source_change = rename_with_semantics(sema, file_position, &self.suggested_text);\n             res.source_change = Some(source_change.ok().unwrap_or_default());\n         }\n@@ -159,7 +188,11 @@ impl DiagnosticWithFix for IncorrectCase {\n }\n \n impl DiagnosticWithFix for ReplaceFilterMapNextWithFindMap {\n-    fn fix(&self, sema: &Semantics<RootDatabase>, _resolve: bool) -> Option<Assist> {\n+    fn fix(\n+        &self,\n+        sema: &Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n         let root = sema.db.parse_or_expand(self.file)?;\n         let next_expr = self.next_expr.to_node(&root);\n         let next_call = ast::MethodCallExpr::cast(next_expr.syntax().clone())?;"}, {"sha": "93fd25dea47d5b3306b2bb6a30fbd2f4db97c24e", "filename": "crates/ide/src/diagnostics/unlinked_file.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdiagnostics%2Funlinked_file.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -5,6 +5,7 @@ use hir::{\n     diagnostics::{Diagnostic, DiagnosticCode},\n     InFile,\n };\n+use ide_assists::AssistResolveStrategy;\n use ide_db::{\n     base_db::{FileId, FileLoader, SourceDatabase, SourceDatabaseExt},\n     source_change::SourceChange,\n@@ -50,7 +51,11 @@ impl Diagnostic for UnlinkedFile {\n }\n \n impl DiagnosticWithFix for UnlinkedFile {\n-    fn fix(&self, sema: &hir::Semantics<RootDatabase>, _resolve: bool) -> Option<Assist> {\n+    fn fix(\n+        &self,\n+        sema: &hir::Semantics<RootDatabase>,\n+        _resolve: &AssistResolveStrategy,\n+    ) -> Option<Assist> {\n         // If there's an existing module that could add a `mod` item to include the unlinked file,\n         // suggest that as a fix.\n "}, {"sha": "8e5b7204496884bb2131d230763c2c8b00951883", "filename": "crates/ide/src/lib.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Flib.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -87,7 +87,9 @@ pub use crate::{\n     },\n };\n pub use hir::{Documentation, Semantics};\n-pub use ide_assists::{Assist, AssistConfig, AssistId, AssistKind};\n+pub use ide_assists::{\n+    Assist, AssistConfig, AssistId, AssistKind, AssistResolveStrategy, SingleResolve,\n+};\n pub use ide_completion::{\n     CompletionConfig, CompletionItem, CompletionItemKind, CompletionRelevance, ImportEdit,\n     InsertTextFormat,\n@@ -518,12 +520,13 @@ impl Analysis {\n     pub fn assists(\n         &self,\n         config: &AssistConfig,\n-        resolve: bool,\n+        resolve: AssistResolveStrategy,\n         frange: FileRange,\n     ) -> Cancelable<Vec<Assist>> {\n         self.with_db(|db| {\n+            let ssr_assists = ssr::ssr_assists(db, &resolve, frange);\n             let mut acc = Assist::get(db, config, resolve, frange);\n-            ssr::add_ssr_assist(db, &mut acc, resolve, frange);\n+            acc.extend(ssr_assists.into_iter());\n             acc\n         })\n     }\n@@ -532,18 +535,18 @@ impl Analysis {\n     pub fn diagnostics(\n         &self,\n         config: &DiagnosticsConfig,\n-        resolve: bool,\n+        resolve: AssistResolveStrategy,\n         file_id: FileId,\n     ) -> Cancelable<Vec<Diagnostic>> {\n-        self.with_db(|db| diagnostics::diagnostics(db, config, resolve, file_id))\n+        self.with_db(|db| diagnostics::diagnostics(db, config, &resolve, file_id))\n     }\n \n     /// Convenience function to return assists + quick fixes for diagnostics\n     pub fn assists_with_fixes(\n         &self,\n         assist_config: &AssistConfig,\n         diagnostics_config: &DiagnosticsConfig,\n-        resolve: bool,\n+        resolve: AssistResolveStrategy,\n         frange: FileRange,\n     ) -> Cancelable<Vec<Assist>> {\n         let include_fixes = match &assist_config.allowed {\n@@ -552,17 +555,21 @@ impl Analysis {\n         };\n \n         self.with_db(|db| {\n+            let ssr_assists = ssr::ssr_assists(db, &resolve, frange);\n+            let diagnostic_assists = if include_fixes {\n+                diagnostics::diagnostics(db, diagnostics_config, &resolve, frange.file_id)\n+                    .into_iter()\n+                    .filter_map(|it| it.fix)\n+                    .filter(|it| it.target.intersect(frange.range).is_some())\n+                    .collect()\n+            } else {\n+                Vec::new()\n+            };\n+\n             let mut res = Assist::get(db, assist_config, resolve, frange);\n-            ssr::add_ssr_assist(db, &mut res, resolve, frange);\n-\n-            if include_fixes {\n-                res.extend(\n-                    diagnostics::diagnostics(db, diagnostics_config, resolve, frange.file_id)\n-                        .into_iter()\n-                        .filter_map(|it| it.fix)\n-                        .filter(|it| it.target.intersect(frange.range).is_some()),\n-                );\n-            }\n+            res.extend(ssr_assists.into_iter());\n+            res.extend(diagnostic_assists.into_iter());\n+\n             res\n         })\n     }"}, {"sha": "57ec80261402ed6ab052da60ae21cec7af35157a", "filename": "crates/ide/src/ssr.rs", "status": "modified", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fssr.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -2,18 +2,23 @@\n //! assist in ide_assists because that would require the ide_assists crate\n //! depend on the ide_ssr crate.\n \n-use ide_assists::{Assist, AssistId, AssistKind, GroupLabel};\n+use ide_assists::{Assist, AssistId, AssistKind, AssistResolveStrategy, GroupLabel};\n use ide_db::{base_db::FileRange, label::Label, source_change::SourceChange, RootDatabase};\n \n-pub(crate) fn add_ssr_assist(\n+pub(crate) fn ssr_assists(\n     db: &RootDatabase,\n-    base: &mut Vec<Assist>,\n-    resolve: bool,\n+    resolve: &AssistResolveStrategy,\n     frange: FileRange,\n-) -> Option<()> {\n-    let (match_finder, comment_range) = ide_ssr::ssr_from_comment(db, frange)?;\n+) -> Vec<Assist> {\n+    let mut ssr_assists = Vec::with_capacity(2);\n \n-    let (source_change_for_file, source_change_for_workspace) = if resolve {\n+    let (match_finder, comment_range) = match ide_ssr::ssr_from_comment(db, frange) {\n+        Some(ssr_data) => ssr_data,\n+        None => return ssr_assists,\n+    };\n+    let id = AssistId(\"ssr\", AssistKind::RefactorRewrite);\n+\n+    let (source_change_for_file, source_change_for_workspace) = if resolve.should_resolve(&id) {\n         let edits = match_finder.edits();\n \n         let source_change_for_file = {\n@@ -35,49 +40,40 @@ pub(crate) fn add_ssr_assist(\n \n     for (label, source_change) in assists.into_iter() {\n         let assist = Assist {\n-            id: AssistId(\"ssr\", AssistKind::RefactorRewrite),\n+            id,\n             label: Label::new(label),\n             group: Some(GroupLabel(\"Apply SSR\".into())),\n             target: comment_range,\n             source_change,\n         };\n \n-        base.push(assist);\n+        ssr_assists.push(assist);\n     }\n-    Some(())\n+\n+    ssr_assists\n }\n \n #[cfg(test)]\n mod tests {\n     use std::sync::Arc;\n \n     use expect_test::expect;\n-    use ide_assists::Assist;\n+    use ide_assists::{Assist, AssistResolveStrategy};\n     use ide_db::{\n         base_db::{fixture::WithFixture, salsa::Durability, FileRange},\n         symbol_index::SymbolsDatabase,\n         RootDatabase,\n     };\n     use rustc_hash::FxHashSet;\n \n-    use super::add_ssr_assist;\n+    use super::ssr_assists;\n \n-    fn get_assists(ra_fixture: &str, resolve: bool) -> Vec<Assist> {\n+    fn get_assists(ra_fixture: &str, resolve: AssistResolveStrategy) -> Vec<Assist> {\n         let (mut db, file_id, range_or_offset) = RootDatabase::with_range_or_offset(ra_fixture);\n         let mut local_roots = FxHashSet::default();\n         local_roots.insert(ide_db::base_db::fixture::WORKSPACE);\n         db.set_local_roots_with_durability(Arc::new(local_roots), Durability::HIGH);\n-\n-        let mut assists = vec![];\n-\n-        add_ssr_assist(\n-            &db,\n-            &mut assists,\n-            resolve,\n-            FileRange { file_id, range: range_or_offset.into() },\n-        );\n-\n-        assists\n+        ssr_assists(&db, &resolve, FileRange { file_id, range: range_or_offset.into() })\n     }\n \n     #[test]\n@@ -88,16 +84,13 @@ mod tests {\n             // This is foo $0\n             fn foo() {}\n             \"#;\n-        let resolve = true;\n-\n-        let assists = get_assists(ra_fixture, resolve);\n+        let assists = get_assists(ra_fixture, AssistResolveStrategy::All);\n \n         assert_eq!(0, assists.len());\n     }\n \n     #[test]\n     fn resolve_edits_true() {\n-        let resolve = true;\n         let assists = get_assists(\n             r#\"\n             //- /lib.rs\n@@ -109,7 +102,7 @@ mod tests {\n             //- /bar.rs\n             fn bar() { 2 }\n             \"#,\n-            resolve,\n+            AssistResolveStrategy::All,\n         );\n \n         assert_eq!(2, assists.len());\n@@ -200,7 +193,6 @@ mod tests {\n \n     #[test]\n     fn resolve_edits_false() {\n-        let resolve = false;\n         let assists = get_assists(\n             r#\"\n             //- /lib.rs\n@@ -212,7 +204,7 @@ mod tests {\n             //- /bar.rs\n             fn bar() { 2 }\n             \"#,\n-            resolve,\n+            AssistResolveStrategy::None,\n         );\n \n         assert_eq!(2, assists.len());"}, {"sha": "11293994848efaed9e836f26cd228f189bdb9c73", "filename": "crates/ide_assists/src/assist_context.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide_assists%2Fsrc%2Fassist_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide_assists%2Fsrc%2Fassist_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Fassist_context.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -19,7 +19,9 @@ use syntax::{\n };\n use text_edit::{TextEdit, TextEditBuilder};\n \n-use crate::{assist_config::AssistConfig, Assist, AssistId, AssistKind, GroupLabel};\n+use crate::{\n+    assist_config::AssistConfig, Assist, AssistId, AssistKind, AssistResolveStrategy, GroupLabel,\n+};\n \n /// `AssistContext` allows to apply an assist or check if it could be applied.\n ///\n@@ -105,14 +107,14 @@ impl<'a> AssistContext<'a> {\n }\n \n pub(crate) struct Assists {\n-    resolve: bool,\n     file: FileId,\n+    resolve: AssistResolveStrategy,\n     buf: Vec<Assist>,\n     allowed: Option<Vec<AssistKind>>,\n }\n \n impl Assists {\n-    pub(crate) fn new(ctx: &AssistContext, resolve: bool) -> Assists {\n+    pub(crate) fn new(ctx: &AssistContext, resolve: AssistResolveStrategy) -> Assists {\n         Assists {\n             resolve,\n             file: ctx.frange.file_id,\n@@ -158,7 +160,7 @@ impl Assists {\n     }\n \n     fn add_impl(&mut self, mut assist: Assist, f: impl FnOnce(&mut AssistBuilder)) -> Option<()> {\n-        let source_change = if self.resolve {\n+        let source_change = if self.resolve.should_resolve(&assist.id) {\n             let mut builder = AssistBuilder::new(self.file);\n             f(&mut builder);\n             Some(builder.finish())"}, {"sha": "2e0c58504c0afc580811e2a285408bbb782ec74a", "filename": "crates/ide_assists/src/lib.rs", "status": "modified", "additions": 67, "deletions": 1, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide_assists%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide_assists%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Flib.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -17,6 +17,8 @@ mod tests;\n pub mod utils;\n pub mod ast_transform;\n \n+use std::str::FromStr;\n+\n use hir::Semantics;\n use ide_db::base_db::FileRange;\n use ide_db::{label::Label, source_change::SourceChange, RootDatabase};\n@@ -56,13 +58,77 @@ impl AssistKind {\n             _ => return false,\n         }\n     }\n+\n+    pub fn name(&self) -> &str {\n+        match self {\n+            AssistKind::None => \"None\",\n+            AssistKind::QuickFix => \"QuickFix\",\n+            AssistKind::Generate => \"Generate\",\n+            AssistKind::Refactor => \"Refactor\",\n+            AssistKind::RefactorExtract => \"RefactorExtract\",\n+            AssistKind::RefactorInline => \"RefactorInline\",\n+            AssistKind::RefactorRewrite => \"RefactorRewrite\",\n+        }\n+    }\n+}\n+\n+impl FromStr for AssistKind {\n+    type Err = String;\n+\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        match s {\n+            \"None\" => Ok(AssistKind::None),\n+            \"QuickFix\" => Ok(AssistKind::QuickFix),\n+            \"Generate\" => Ok(AssistKind::Generate),\n+            \"Refactor\" => Ok(AssistKind::Refactor),\n+            \"RefactorExtract\" => Ok(AssistKind::RefactorExtract),\n+            \"RefactorInline\" => Ok(AssistKind::RefactorInline),\n+            \"RefactorRewrite\" => Ok(AssistKind::RefactorRewrite),\n+            unknown => Err(format!(\"Unknown AssistKind: '{}'\", unknown)),\n+        }\n+    }\n }\n \n /// Unique identifier of the assist, should not be shown to the user\n /// directly.\n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub struct AssistId(pub &'static str, pub AssistKind);\n \n+/// A way to control how many asssist to resolve during the assist resolution.\n+/// When an assist is resolved, its edits are calculated that might be costly to always do by default.\n+#[derive(Debug)]\n+pub enum AssistResolveStrategy {\n+    /// No assists should be resolved.\n+    None,\n+    /// All assists should be resolved.\n+    All,\n+    /// Only a certain assist should be resolved.\n+    Single(SingleResolve),\n+}\n+\n+/// Hold the [`AssistId`] data of a certain assist to resolve.\n+/// The original id object cannot be used due to a `'static` lifetime\n+/// and the requirement to construct this struct dynamically during the resolve handling.\n+#[derive(Debug)]\n+pub struct SingleResolve {\n+    /// The id of the assist.\n+    pub assist_id: String,\n+    // The kind of the assist.\n+    pub assist_kind: AssistKind,\n+}\n+\n+impl AssistResolveStrategy {\n+    pub fn should_resolve(&self, id: &AssistId) -> bool {\n+        match self {\n+            AssistResolveStrategy::None => false,\n+            AssistResolveStrategy::All => true,\n+            AssistResolveStrategy::Single(single_resolve) => {\n+                single_resolve.assist_id == id.0 && single_resolve.assist_kind == id.1\n+            }\n+        }\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct GroupLabel(pub String);\n \n@@ -91,7 +157,7 @@ impl Assist {\n     pub fn get(\n         db: &RootDatabase,\n         config: &AssistConfig,\n-        resolve: bool,\n+        resolve: AssistResolveStrategy,\n         range: FileRange,\n     ) -> Vec<Assist> {\n         let sema = Semantics::new(db);"}, {"sha": "9c2847998471bc33a059f8a7d77b40475dfbb724", "filename": "crates/ide_assists/src/tests.rs", "status": "modified", "additions": 253, "deletions": 9, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide_assists%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Fide_assists%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_assists%2Fsrc%2Ftests.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -12,7 +12,10 @@ use stdx::{format_to, trim_indent};\n use syntax::TextRange;\n use test_utils::{assert_eq_text, extract_offset};\n \n-use crate::{handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, Assists};\n+use crate::{\n+    handlers::Handler, Assist, AssistConfig, AssistContext, AssistKind, AssistResolveStrategy,\n+    Assists, SingleResolve,\n+};\n \n pub(crate) const TEST_CONFIG: AssistConfig = AssistConfig {\n     snippet_cap: SnippetCap::new(true),\n@@ -65,14 +68,14 @@ fn check_doc_test(assist_id: &str, before: &str, after: &str) {\n     let before = db.file_text(file_id).to_string();\n     let frange = FileRange { file_id, range: selection.into() };\n \n-    let assist = Assist::get(&db, &TEST_CONFIG, true, frange)\n+    let assist = Assist::get(&db, &TEST_CONFIG, AssistResolveStrategy::All, frange)\n         .into_iter()\n         .find(|assist| assist.id.0 == assist_id)\n         .unwrap_or_else(|| {\n             panic!(\n                 \"\\n\\nAssist is not applicable: {}\\nAvailable assists: {}\",\n                 assist_id,\n-                Assist::get(&db, &TEST_CONFIG, false, frange)\n+                Assist::get(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange)\n                     .into_iter()\n                     .map(|assist| assist.id.0)\n                     .collect::<Vec<_>>()\n@@ -108,7 +111,7 @@ fn check(handler: Handler, before: &str, expected: ExpectedResult, assist_label:\n     let sema = Semantics::new(&db);\n     let config = TEST_CONFIG;\n     let ctx = AssistContext::new(sema, &config, frange);\n-    let mut acc = Assists::new(&ctx, true);\n+    let mut acc = Assists::new(&ctx, AssistResolveStrategy::All);\n     handler(&mut acc, &ctx);\n     let mut res = acc.finish();\n \n@@ -186,7 +189,7 @@ fn assist_order_field_struct() {\n     let (before_cursor_pos, before) = extract_offset(before);\n     let (db, file_id) = with_single_file(&before);\n     let frange = FileRange { file_id, range: TextRange::empty(before_cursor_pos) };\n-    let assists = Assist::get(&db, &TEST_CONFIG, false, frange);\n+    let assists = Assist::get(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange);\n     let mut assists = assists.iter();\n \n     assert_eq!(assists.next().expect(\"expected assist\").label, \"Change visibility to pub(crate)\");\n@@ -211,7 +214,7 @@ pub fn test_some_range(a: int) -> bool {\n \"#,\n     );\n \n-    let assists = Assist::get(&db, &TEST_CONFIG, false, frange);\n+    let assists = Assist::get(&db, &TEST_CONFIG, AssistResolveStrategy::None, frange);\n     let expected = labels(&assists);\n \n     expect![[r#\"\n@@ -240,7 +243,7 @@ pub fn test_some_range(a: int) -> bool {\n         let mut cfg = TEST_CONFIG;\n         cfg.allowed = Some(vec![AssistKind::Refactor]);\n \n-        let assists = Assist::get(&db, &cfg, false, frange);\n+        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::None, frange);\n         let expected = labels(&assists);\n \n         expect![[r#\"\n@@ -255,7 +258,7 @@ pub fn test_some_range(a: int) -> bool {\n     {\n         let mut cfg = TEST_CONFIG;\n         cfg.allowed = Some(vec![AssistKind::RefactorExtract]);\n-        let assists = Assist::get(&db, &cfg, false, frange);\n+        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::None, frange);\n         let expected = labels(&assists);\n \n         expect![[r#\"\n@@ -268,9 +271,250 @@ pub fn test_some_range(a: int) -> bool {\n     {\n         let mut cfg = TEST_CONFIG;\n         cfg.allowed = Some(vec![AssistKind::QuickFix]);\n-        let assists = Assist::get(&db, &cfg, false, frange);\n+        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::None, frange);\n         let expected = labels(&assists);\n \n         expect![[r#\"\"#]].assert_eq(&expected);\n     }\n }\n+\n+#[test]\n+fn various_resolve_strategies() {\n+    let (db, frange) = RootDatabase::with_range(\n+        r#\"\n+pub fn test_some_range(a: int) -> bool {\n+    if let 2..6 = $05$0 {\n+        true\n+    } else {\n+        false\n+    }\n+}\n+\"#,\n+    );\n+\n+    let mut cfg = TEST_CONFIG;\n+    cfg.allowed = Some(vec![AssistKind::RefactorExtract]);\n+\n+    {\n+        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::None, frange);\n+        assert_eq!(2, assists.len());\n+        let mut assists = assists.into_iter();\n+\n+        let extract_into_variable_assist = assists.next().unwrap();\n+        expect![[r#\"\n+            Assist {\n+                id: AssistId(\n+                    \"extract_variable\",\n+                    RefactorExtract,\n+                ),\n+                label: \"Extract into variable\",\n+                group: None,\n+                target: 59..60,\n+                source_change: None,\n+            }\n+        \"#]]\n+        .assert_debug_eq(&extract_into_variable_assist);\n+\n+        let extract_into_function_assist = assists.next().unwrap();\n+        expect![[r#\"\n+            Assist {\n+                id: AssistId(\n+                    \"extract_function\",\n+                    RefactorExtract,\n+                ),\n+                label: \"Extract into function\",\n+                group: None,\n+                target: 59..60,\n+                source_change: None,\n+            }\n+        \"#]]\n+        .assert_debug_eq(&extract_into_function_assist);\n+    }\n+\n+    {\n+        let assists = Assist::get(\n+            &db,\n+            &cfg,\n+            AssistResolveStrategy::Single(SingleResolve {\n+                assist_id: \"SOMETHING_MISMATCHING\".to_string(),\n+                assist_kind: AssistKind::RefactorExtract,\n+            }),\n+            frange,\n+        );\n+        assert_eq!(2, assists.len());\n+        let mut assists = assists.into_iter();\n+\n+        let extract_into_variable_assist = assists.next().unwrap();\n+        expect![[r#\"\n+            Assist {\n+                id: AssistId(\n+                    \"extract_variable\",\n+                    RefactorExtract,\n+                ),\n+                label: \"Extract into variable\",\n+                group: None,\n+                target: 59..60,\n+                source_change: None,\n+            }\n+        \"#]]\n+        .assert_debug_eq(&extract_into_variable_assist);\n+\n+        let extract_into_function_assist = assists.next().unwrap();\n+        expect![[r#\"\n+            Assist {\n+                id: AssistId(\n+                    \"extract_function\",\n+                    RefactorExtract,\n+                ),\n+                label: \"Extract into function\",\n+                group: None,\n+                target: 59..60,\n+                source_change: None,\n+            }\n+        \"#]]\n+        .assert_debug_eq(&extract_into_function_assist);\n+    }\n+\n+    {\n+        let assists = Assist::get(\n+            &db,\n+            &cfg,\n+            AssistResolveStrategy::Single(SingleResolve {\n+                assist_id: \"extract_variable\".to_string(),\n+                assist_kind: AssistKind::RefactorExtract,\n+            }),\n+            frange,\n+        );\n+        assert_eq!(2, assists.len());\n+        let mut assists = assists.into_iter();\n+\n+        let extract_into_variable_assist = assists.next().unwrap();\n+        expect![[r#\"\n+            Assist {\n+                id: AssistId(\n+                    \"extract_variable\",\n+                    RefactorExtract,\n+                ),\n+                label: \"Extract into variable\",\n+                group: None,\n+                target: 59..60,\n+                source_change: Some(\n+                    SourceChange {\n+                        source_file_edits: {\n+                            FileId(\n+                                0,\n+                            ): TextEdit {\n+                                indels: [\n+                                    Indel {\n+                                        insert: \"let $0var_name = 5;\\n    \",\n+                                        delete: 45..45,\n+                                    },\n+                                    Indel {\n+                                        insert: \"var_name\",\n+                                        delete: 59..60,\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                        file_system_edits: [],\n+                        is_snippet: true,\n+                    },\n+                ),\n+            }\n+        \"#]]\n+        .assert_debug_eq(&extract_into_variable_assist);\n+\n+        let extract_into_function_assist = assists.next().unwrap();\n+        expect![[r#\"\n+            Assist {\n+                id: AssistId(\n+                    \"extract_function\",\n+                    RefactorExtract,\n+                ),\n+                label: \"Extract into function\",\n+                group: None,\n+                target: 59..60,\n+                source_change: None,\n+            }\n+        \"#]]\n+        .assert_debug_eq(&extract_into_function_assist);\n+    }\n+\n+    {\n+        let assists = Assist::get(&db, &cfg, AssistResolveStrategy::All, frange);\n+        assert_eq!(2, assists.len());\n+        let mut assists = assists.into_iter();\n+\n+        let extract_into_variable_assist = assists.next().unwrap();\n+        expect![[r#\"\n+            Assist {\n+                id: AssistId(\n+                    \"extract_variable\",\n+                    RefactorExtract,\n+                ),\n+                label: \"Extract into variable\",\n+                group: None,\n+                target: 59..60,\n+                source_change: Some(\n+                    SourceChange {\n+                        source_file_edits: {\n+                            FileId(\n+                                0,\n+                            ): TextEdit {\n+                                indels: [\n+                                    Indel {\n+                                        insert: \"let $0var_name = 5;\\n    \",\n+                                        delete: 45..45,\n+                                    },\n+                                    Indel {\n+                                        insert: \"var_name\",\n+                                        delete: 59..60,\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                        file_system_edits: [],\n+                        is_snippet: true,\n+                    },\n+                ),\n+            }\n+        \"#]]\n+        .assert_debug_eq(&extract_into_variable_assist);\n+\n+        let extract_into_function_assist = assists.next().unwrap();\n+        expect![[r#\"\n+            Assist {\n+                id: AssistId(\n+                    \"extract_function\",\n+                    RefactorExtract,\n+                ),\n+                label: \"Extract into function\",\n+                group: None,\n+                target: 59..60,\n+                source_change: Some(\n+                    SourceChange {\n+                        source_file_edits: {\n+                            FileId(\n+                                0,\n+                            ): TextEdit {\n+                                indels: [\n+                                    Indel {\n+                                        insert: \"fun_name()\",\n+                                        delete: 59..60,\n+                                    },\n+                                    Indel {\n+                                        insert: \"\\n\\nfn $0fun_name() -> i32 {\\n    5\\n}\",\n+                                        delete: 110..110,\n+                                    },\n+                                ],\n+                            },\n+                        },\n+                        file_system_edits: [],\n+                        is_snippet: true,\n+                    },\n+                ),\n+            }\n+        \"#]]\n+        .assert_debug_eq(&extract_into_function_assist);\n+    }\n+}"}, {"sha": "c33c8179cb3d0b88a0be14a6c9216004acb1a766", "filename": "crates/rust-analyzer/src/cli/diagnostics.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fdiagnostics.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -7,7 +7,7 @@ use anyhow::anyhow;\n use rustc_hash::FxHashSet;\n \n use hir::{db::HirDatabase, Crate, Module};\n-use ide::{DiagnosticsConfig, Severity};\n+use ide::{AssistResolveStrategy, DiagnosticsConfig, Severity};\n use ide_db::base_db::SourceDatabaseExt;\n \n use crate::cli::{\n@@ -57,8 +57,9 @@ pub fn diagnostics(\n             let crate_name =\n                 module.krate().display_name(db).as_deref().unwrap_or(\"unknown\").to_string();\n             println!(\"processing crate: {}, module: {}\", crate_name, _vfs.file_path(file_id));\n-            for diagnostic in\n-                analysis.diagnostics(&DiagnosticsConfig::default(), false, file_id).unwrap()\n+            for diagnostic in analysis\n+                .diagnostics(&DiagnosticsConfig::default(), AssistResolveStrategy::None, file_id)\n+                .unwrap()\n             {\n                 if matches!(diagnostic.severity, Severity::Error) {\n                     found_error = true;"}, {"sha": "f6e40f872228d646140ebf6eaf914304367da942", "filename": "crates/rust-analyzer/src/handlers.rs", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fhandlers.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -8,8 +8,9 @@ use std::{\n };\n \n use ide::{\n-    AnnotationConfig, FileId, FilePosition, FileRange, HoverAction, HoverGotoTypeData, Query,\n-    RangeInfo, Runnable, RunnableKind, SearchScope, SourceChange, TextEdit,\n+    AnnotationConfig, AssistKind, AssistResolveStrategy, FileId, FilePosition, FileRange,\n+    HoverAction, HoverGotoTypeData, Query, RangeInfo, Runnable, RunnableKind, SearchScope,\n+    SingleResolve, SourceChange, TextEdit,\n };\n use ide_db::SymbolKind;\n use itertools::Itertools;\n@@ -27,7 +28,7 @@ use lsp_types::{\n use project_model::TargetKind;\n use serde::{Deserialize, Serialize};\n use serde_json::to_value;\n-use stdx::{format_to, split_once};\n+use stdx::format_to;\n use syntax::{algo, ast, AstNode, TextRange, TextSize};\n \n use crate::{\n@@ -1004,10 +1005,15 @@ pub(crate) fn handle_code_action(\n     let mut res: Vec<lsp_ext::CodeAction> = Vec::new();\n \n     let code_action_resolve_cap = snap.config.code_action_resolve();\n+    let resolve = if code_action_resolve_cap {\n+        AssistResolveStrategy::None\n+    } else {\n+        AssistResolveStrategy::All\n+    };\n     let assists = snap.analysis.assists_with_fixes(\n         &assists_config,\n         &snap.config.diagnostics(),\n-        !code_action_resolve_cap,\n+        resolve,\n         frange,\n     )?;\n     for (index, assist) in assists.into_iter().enumerate() {\n@@ -1052,22 +1058,68 @@ pub(crate) fn handle_code_action_resolve(\n         .only\n         .map(|it| it.into_iter().filter_map(from_proto::assist_kind).collect());\n \n+    let (assist_index, assist_resolve) = match parse_action_id(&params.id) {\n+        Ok(parsed_data) => parsed_data,\n+        Err(e) => {\n+            return Err(LspError::new(\n+                ErrorCode::InvalidParams as i32,\n+                format!(\"Failed to parse action id string '{}': {}\", params.id, e),\n+            )\n+            .into())\n+        }\n+    };\n+\n+    let expected_assist_id = assist_resolve.assist_id.clone();\n+    let expected_kind = assist_resolve.assist_kind;\n+\n     let assists = snap.analysis.assists_with_fixes(\n         &assists_config,\n         &snap.config.diagnostics(),\n-        true,\n+        AssistResolveStrategy::Single(assist_resolve),\n         frange,\n     )?;\n \n-    let (id, index) = split_once(&params.id, ':').unwrap();\n-    let index = index.parse::<usize>().unwrap();\n-    let assist = &assists[index];\n-    assert!(assist.id.0 == id);\n+    let assist = match assists.get(assist_index) {\n+        Some(assist) => assist,\n+        None => return Err(LspError::new(\n+            ErrorCode::InvalidParams as i32,\n+            format!(\n+                \"Failed to find the assist for index {} provided by the resolve request. Resolve request assist id: {}\",\n+                assist_index, params.id,\n+            ),\n+        )\n+        .into())\n+    };\n+    if assist.id.0 != expected_assist_id || assist.id.1 != expected_kind {\n+        return Err(LspError::new(\n+            ErrorCode::InvalidParams as i32,\n+            format!(\n+                \"Mismatching assist at index {} for the resolve parameters given. Resolve request assist id: {}, actual id: {:?}.\",\n+                assist_index, params.id, assist.id\n+            ),\n+        )\n+        .into());\n+    }\n     let edit = to_proto::code_action(&snap, assist.clone(), None)?.edit;\n     code_action.edit = edit;\n     Ok(code_action)\n }\n \n+fn parse_action_id(action_id: &str) -> Result<(usize, SingleResolve), String> {\n+    let id_parts = action_id.split(':').collect_vec();\n+    match id_parts.as_slice() {\n+        &[assist_id_string, assist_kind_string, index_string] => {\n+            let assist_kind: AssistKind = assist_kind_string.parse()?;\n+            let index: usize = match index_string.parse() {\n+                Ok(index) => index,\n+                Err(e) => return Err(format!(\"Incorrect index string: {}\", e)),\n+            };\n+            Ok((index, SingleResolve { assist_id: assist_id_string.to_string(), assist_kind }))\n+        }\n+        _ => Err(\"Action id contains incorrect number of segments\".to_string()),\n+    }\n+}\n+\n pub(crate) fn handle_code_lens(\n     snap: GlobalStateSnapshot,\n     params: lsp_types::CodeLensParams,\n@@ -1182,7 +1234,7 @@ pub(crate) fn publish_diagnostics(\n \n     let diagnostics: Vec<Diagnostic> = snap\n         .analysis\n-        .diagnostics(&snap.config.diagnostics(), false, file_id)?\n+        .diagnostics(&snap.config.diagnostics(), AssistResolveStrategy::None, file_id)?\n         .into_iter()\n         .map(|d| Diagnostic {\n             range: to_proto::range(&line_index, d.range),"}, {"sha": "1d27aa7b37366351b0695fd75b7cdc1e3ee6b733", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d812efcd9e632a47ba85086c0a9dc72d13ff732/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=6d812efcd9e632a47ba85086c0a9dc72d13ff732", "patch": "@@ -897,7 +897,7 @@ pub(crate) fn code_action(\n         (Some(it), _) => res.edit = Some(snippet_workspace_edit(snap, it)?),\n         (None, Some((index, code_action_params))) => {\n             res.data = Some(lsp_ext::CodeActionData {\n-                id: format!(\"{}:{}\", assist.id.0, index.to_string()),\n+                id: format!(\"{}:{}:{}\", assist.id.0, assist.id.1.name(), index),\n                 code_action_params,\n             });\n         }"}]}