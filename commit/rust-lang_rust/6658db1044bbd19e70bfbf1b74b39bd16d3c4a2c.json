{"sha": "6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NThkYjEwNDRiYmQxOWU3MGJmYmYxYjc0YjM5YmQxNmQzYzRhMmM=", "commit": {"author": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-02-28T15:11:45Z"}, "committer": {"name": "xFrednet", "email": "xFrednet@gmail.com", "date": "2021-05-05T16:35:33Z"}, "message": "Metadata collection: processing emission closures (417/455)", "tree": {"sha": "7fc73531af1e91b404472da5bfe589dbeb6c08e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7fc73531af1e91b404472da5bfe589dbeb6c08e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "html_url": "https://github.com/rust-lang/rust/commit/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c/comments", "author": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xFrednet", "id": 17087237, "node_id": "MDQ6VXNlcjE3MDg3MjM3", "avatar_url": "https://avatars.githubusercontent.com/u/17087237?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xFrednet", "html_url": "https://github.com/xFrednet", "followers_url": "https://api.github.com/users/xFrednet/followers", "following_url": "https://api.github.com/users/xFrednet/following{/other_user}", "gists_url": "https://api.github.com/users/xFrednet/gists{/gist_id}", "starred_url": "https://api.github.com/users/xFrednet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xFrednet/subscriptions", "organizations_url": "https://api.github.com/users/xFrednet/orgs", "repos_url": "https://api.github.com/users/xFrednet/repos", "events_url": "https://api.github.com/users/xFrednet/events{/privacy}", "received_events_url": "https://api.github.com/users/xFrednet/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5830fa7c6064480863d1f90513c0c9b05630a9d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/5830fa7c6064480863d1f90513c0c9b05630a9d3", "html_url": "https://github.com/rust-lang/rust/commit/5830fa7c6064480863d1f90513c0c9b05630a9d3"}], "stats": {"total": 219, "additions": 190, "deletions": 29}, "files": [{"sha": "5a51e1141fba2c4f1553abd43ee90aab793695bd", "filename": "clippy_lints/src/slow_vector_initialization.rs", "status": "modified", "additions": 5, "deletions": 15, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fslow_vector_initialization.rs?ref=6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "patch": "@@ -157,26 +157,16 @@ impl SlowVectorInit {\n         vec_alloc: &VecAllocation<'_>,\n     ) {\n         match initialization {\n-            InitializationType::Extend(e) | InitializationType::Resize(e) => Self::emit_lint(\n-                cx,\n-                e,\n-                vec_alloc,\n-                \"slow zero-filling initialization\",\n-                SLOW_VECTOR_INITIALIZATION,\n-            ),\n+            InitializationType::Extend(e) | InitializationType::Resize(e) => {\n+                Self::emit_lint(cx, e, vec_alloc, \"slow zero-filling initialization\")\n+            },\n         };\n     }\n \n-    fn emit_lint<'tcx>(\n-        cx: &LateContext<'tcx>,\n-        slow_fill: &Expr<'_>,\n-        vec_alloc: &VecAllocation<'_>,\n-        msg: &str,\n-        lint: &'static Lint,\n-    ) {\n+    fn emit_lint<'tcx>(cx: &LateContext<'tcx>, slow_fill: &Expr<'_>, vec_alloc: &VecAllocation<'_>, msg: &str) {\n         let len_expr = Sugg::hir(cx, vec_alloc.len_expr, \"len\");\n \n-        span_lint_and_then(cx, lint, slow_fill.span, msg, |diag| {\n+        span_lint_and_then(cx, SLOW_VECTOR_INITIALIZATION, slow_fill.span, msg, |diag| {\n             diag.span_suggestion(\n                 vec_alloc.allocation_expr.span,\n                 \"consider replace allocation with\","}, {"sha": "20bd2a669aa4ebbcde8449cedc5d3f754f58abce", "filename": "clippy_lints/src/utils/internal_lints/metadata_collector.rs", "status": "modified", "additions": 183, "deletions": 14, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints%2Fmetadata_collector.rs?ref=6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "patch": "@@ -15,16 +15,25 @@\n \n // # Applicability\n // - TODO xFrednet 2021-01-17: Find lint emit and collect applicability\n-// - TODO xFrednet 2021-02-27: Link applicability from function parameters\n-//   - (Examples: suspicious_operation_groupings:267, needless_bool.rs:311)\n-// - TODO xFrednet 2021-02-27: Tuple if let thingy\n-//   - (Examples: unused_unit.rs:140, misc.rs:694)\n+//   - TODO xFrednet 2021-02-28:  1x reference to closure\n+//     - See clippy_lints/src/needless_pass_by_value.rs@NeedlessPassByValue::check_fn\n+//   - TODO xFrednet 2021-02-28:  4x weird emission forwarding\n+//     - See clippy_lints/src/enum_variants.rs@EnumVariantNames::check_name\n+//   - TODO xFrednet 2021-02-28:  6x emission forwarding with local that is initializes from\n+//     function.\n+//     - See clippy_lints/src/methods/mod.rs@lint_binary_expr_with_method_call\n+//   - TODO xFrednet 2021-02-28:  2x lint from local from function call\n+//     - See clippy_lints/src/misc.rs@check_binary\n+//   - TODO xFrednet 2021-02-28:  2x lint from local from method call\n+//     - See clippy_lints/src/non_copy_const.rs@lint\n+//   - TODO xFrednet 2021-02-28: 20x lint from local\n+//     - See clippy_lints/src/map_unit_fn.rs@lint_map_unit_fn\n // # NITs\n // - TODO xFrednet 2021-02-13: Collect depreciations and maybe renames\n \n use if_chain::if_chain;\n use rustc_data_structures::fx::FxHashMap;\n-use rustc_hir::{self as hir, intravisit, ExprKind, Item, ItemKind, Mutability};\n+use rustc_hir::{self as hir, intravisit, ExprKind, Item, ItemKind, Mutability, QPath};\n use rustc_lint::{CheckLintNameResult, LateContext, LateLintPass, LintContext, LintId};\n use rustc_middle::hir::map::Map;\n use rustc_session::{declare_tool_lint, impl_lint_pass};\n@@ -44,18 +53,36 @@ const OUTPUT_FILE: &str = \"metadata_collection.json\";\n /// These lints are excluded from the export.\n const BLACK_LISTED_LINTS: [&str; 2] = [\"lint_author\", \"deep_code_inspection\"];\n /// These groups will be ignored by the lint group matcher\n-const BLACK_LISTED_LINT_GROUP: [&str; 1] = [\"clippy::all\"];\n+const BLACK_LISTED_LINT_GROUP: [&str; 1] = [\"clippy::all\", \"clippy::internal\"];\n \n // TODO xFrednet 2021-02-15: `span_lint_and_then` & `span_lint_hir_and_then` requires special\n // handling\n-#[rustfmt::skip]\n-const LINT_EMISSION_FUNCTIONS: [&[&str]; 5] = [\n+const SIMPLE_LINT_EMISSION_FUNCTIONS: [&[&str]; 5] = [\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_help\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_note\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir\"],\n     &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_sugg\"],\n ];\n+const COMPLEX_LINT_EMISSION_FUNCTIONS: [&[&str]; 2] = [\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_and_then\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"span_lint_hir_and_then\"],\n+];\n+const SUGGESTION_DIAGNOSTIC_BUILDER_METHODS: [(&str, bool); 9] = [\n+    (\"span_suggestion\", false),\n+    (\"span_suggestion_short\", false),\n+    (\"span_suggestion_verbose\", false),\n+    (\"span_suggestion_hidden\", false),\n+    (\"tool_only_span_suggestion\", false),\n+    (\"multipart_suggestion\", true),\n+    (\"multipart_suggestions\", true),\n+    (\"tool_only_multipart_suggestion\", true),\n+    (\"span_suggestions\", true),\n+];\n+const SUGGESTION_FUNCTIONS: [&[&str]; 2] = [\n+    &[\"clippy_utils\", \"diagnostics\", \"mutispan_sugg\"],\n+    &[\"clippy_utils\", \"diagnostics\", \"multispan_sugg_with_applicability\"],\n+];\n \n /// The index of the applicability name of `paths::APPLICABILITY_VALUES`\n const APPLICABILITY_NAME_INDEX: usize = 2;\n@@ -177,7 +204,7 @@ struct ApplicabilityInfo {\n     /// Indicates if any of the lint emissions uses multiple spans. This is related to\n     /// [rustfix#141](https://github.com/rust-lang/rustfix/issues/141) as such suggestions can\n     /// currently not be applied automatically.\n-    has_multi_suggestion: bool,\n+    is_multi_suggestion: bool,\n     applicability: Option<String>,\n }\n \n@@ -250,6 +277,14 @@ impl<'hir> LateLintPass<'hir> for MetadataCollector {\n             } else {\n                 lint_collection_error_span(cx, expr.span, \"I found this but I can't get the lint or applicability\");\n             }\n+        } else if let Some(args) = match_complex_lint_emission(cx, expr) {\n+            if let Some((lint_name, applicability, is_multi_span)) = extract_complex_emission_info(cx, args) {\n+                let app_info = self.applicability_into.entry(lint_name).or_default();\n+                app_info.applicability = applicability;\n+                app_info.is_multi_suggestion = is_multi_span;\n+            } else {\n+                lint_collection_error_span(cx, expr.span, \"Look, here ... I have no clue what todo with it\");\n+            }\n         }\n     }\n }\n@@ -347,7 +382,16 @@ fn match_simple_lint_emission<'hir>(\n     cx: &LateContext<'hir>,\n     expr: &'hir hir::Expr<'_>,\n ) -> Option<&'hir [hir::Expr<'hir>]> {\n-    LINT_EMISSION_FUNCTIONS\n+    SIMPLE_LINT_EMISSION_FUNCTIONS\n+        .iter()\n+        .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n+}\n+\n+fn match_complex_lint_emission<'hir>(\n+    cx: &LateContext<'hir>,\n+    expr: &'hir hir::Expr<'_>,\n+) -> Option<&'hir [hir::Expr<'hir>]> {\n+    COMPLEX_LINT_EMISSION_FUNCTIONS\n         .iter()\n         .find_map(|emission_fn| match_function_call(cx, expr, emission_fn))\n }\n@@ -376,28 +420,60 @@ fn extract_emission_info<'hir>(\n     lint_name.map(|lint_name| (sym_to_string(lint_name).to_ascii_lowercase(), applicability))\n }\n \n+fn extract_complex_emission_info<'hir>(\n+    cx: &LateContext<'hir>,\n+    args: &'hir [hir::Expr<'hir>],\n+) -> Option<(String, Option<String>, bool)> {\n+    let mut lint_name = None;\n+    let mut applicability = None;\n+    let mut multi_span = false;\n+\n+    for arg in args {\n+        let (arg_ty, _) = walk_ptrs_ty_depth(cx.typeck_results().expr_ty(&arg));\n+\n+        if match_type(cx, arg_ty, &paths::LINT) {\n+            // If we found the lint arg, extract the lint name\n+            if let ExprKind::Path(ref lint_path) = arg.kind {\n+                lint_name = Some(last_path_segment(lint_path).ident.name);\n+            }\n+        } else if arg_ty.is_closure() {\n+            if let ExprKind::Closure(_, _, body_id, _, _) = arg.kind {\n+                let mut visitor = EmissionClosureVisitor::new(cx);\n+                intravisit::walk_body(&mut visitor, cx.tcx.hir().body(body_id));\n+                multi_span = visitor.found_multi_span();\n+                applicability = visitor.complete();\n+            } else {\n+                // TODO xfrednet 2021-02-28: linked closures, see: needless_pass_by_value.rs:292\n+                return None;\n+            }\n+        }\n+    }\n+\n+    lint_name.map(|lint_name| (sym_to_string(lint_name).to_ascii_lowercase(), applicability, multi_span))\n+}\n+\n /// This function tries to resolve the linked applicability to the given expression.\n fn resolve_applicability(cx: &LateContext<'hir>, expr: &'hir hir::Expr<'hir>) -> Option<String> {\n     match expr.kind {\n         // We can ignore ifs without an else block because those can't be used as an assignment\n-        hir::ExprKind::If(_con, if_block, Some(else_block)) => {\n+        ExprKind::If(_con, if_block, Some(else_block)) => {\n             let mut visitor = ApplicabilityVisitor::new(cx);\n             intravisit::walk_expr(&mut visitor, if_block);\n             intravisit::walk_expr(&mut visitor, else_block);\n             visitor.complete()\n         },\n-        hir::ExprKind::Match(_expr, arms, _) => {\n+        ExprKind::Match(_expr, arms, _) => {\n             let mut visitor = ApplicabilityVisitor::new(cx);\n             arms.iter()\n                 .for_each(|arm| intravisit::walk_expr(&mut visitor, arm.body));\n             visitor.complete()\n         },\n-        hir::ExprKind::Loop(block, ..) | hir::ExprKind::Block(block, ..) => {\n+        ExprKind::Loop(block, ..) | ExprKind::Block(block, ..) => {\n             let mut visitor = ApplicabilityVisitor::new(cx);\n             intravisit::walk_block(&mut visitor, block);\n             visitor.complete()\n         },\n-        ExprKind::Path(hir::QPath::Resolved(_, path)) => {\n+        ExprKind::Path(QPath::Resolved(_, path)) => {\n             // direct applicabilities are simple:\n             for enum_value in &paths::APPLICABILITY_VALUES {\n                 if match_path(path, enum_value) {\n@@ -477,3 +553,96 @@ impl<'a, 'hir> intravisit::Visitor<'hir> for ApplicabilityVisitor<'a, 'hir> {\n         }\n     }\n }\n+\n+/// This visitor finds the highest applicability value in the visited expressions\n+struct EmissionClosureVisitor<'a, 'hir> {\n+    cx: &'a LateContext<'hir>,\n+    /// This is the index of hightest `Applicability` for\n+    /// `clippy_utils::paths::APPLICABILITY_VALUES`\n+    applicability_index: Option<usize>,\n+    suggestion_count: usize,\n+}\n+\n+impl<'a, 'hir> EmissionClosureVisitor<'a, 'hir> {\n+    fn new(cx: &'a LateContext<'hir>) -> Self {\n+        Self {\n+            cx,\n+            applicability_index: None,\n+            suggestion_count: 0,\n+        }\n+    }\n+\n+    fn add_new_index(&mut self, new_index: usize) {\n+        self.applicability_index = self\n+            .applicability_index\n+            .map_or(new_index, |old_index| old_index.min(new_index))\n+            .into();\n+    }\n+\n+    fn found_multi_span(&self) -> bool {\n+        self.suggestion_count > 1\n+    }\n+\n+    fn complete(self) -> Option<String> {\n+        self.applicability_index\n+            .map(|index| paths::APPLICABILITY_VALUES[index][APPLICABILITY_NAME_INDEX].to_string())\n+    }\n+}\n+\n+impl<'a, 'hir> intravisit::Visitor<'hir> for EmissionClosureVisitor<'a, 'hir> {\n+    type Map = Map<'hir>;\n+\n+    fn nested_visit_map(&mut self) -> intravisit::NestedVisitorMap<Self::Map> {\n+        intravisit::NestedVisitorMap::All(self.cx.tcx.hir())\n+    }\n+\n+    fn visit_path(&mut self, path: &hir::Path<'_>, _id: hir::HirId) {\n+        for (index, enum_value) in paths::APPLICABILITY_VALUES.iter().enumerate() {\n+            if match_path(path, enum_value) {\n+                self.add_new_index(index);\n+                break;\n+            }\n+        }\n+    }\n+\n+    fn visit_expr(&mut self, expr: &'hir hir::Expr<'hir>) {\n+        match &expr.kind {\n+            ExprKind::Call(fn_expr, _args) => {\n+                let found_function = SUGGESTION_FUNCTIONS\n+                    .iter()\n+                    .any(|func_path| match_function_call(self.cx, fn_expr, func_path).is_some());\n+                if found_function {\n+                    // These functions are all multi part suggestions\n+                    self.suggestion_count += 2;\n+                }\n+            },\n+            ExprKind::MethodCall(path, _path_span, arg, _arg_span) => {\n+                let (self_ty, _) = walk_ptrs_ty_depth(self.cx.typeck_results().expr_ty(&arg[0]));\n+                if match_type(self.cx, self_ty, &paths::DIAGNOSTIC_BUILDER) {\n+                    let called_method = path.ident.name.as_str().to_string();\n+                    let found_suggestion =\n+                        SUGGESTION_DIAGNOSTIC_BUILDER_METHODS\n+                            .iter()\n+                            .find_map(|(method_name, is_multi_part)| {\n+                                if *method_name == called_method {\n+                                    Some(*is_multi_part)\n+                                } else {\n+                                    None\n+                                }\n+                            });\n+                    if let Some(multi_part) = found_suggestion {\n+                        if multi_part {\n+                            // two is enough to have it marked as a multipart suggestion\n+                            self.suggestion_count += 2;\n+                        } else {\n+                            self.suggestion_count += 1;\n+                        }\n+                    }\n+                }\n+            },\n+            _ => {},\n+        }\n+\n+        intravisit::walk_expr(self, expr);\n+    }\n+}"}, {"sha": "a6292b87768ab55e961a91247292c9af55925c34", "filename": "clippy_utils/src/paths.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c/clippy_utils%2Fsrc%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c/clippy_utils%2Fsrc%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_utils%2Fsrc%2Fpaths.rs?ref=6658db1044bbd19e70bfbf1b74b39bd16d3c4a2c", "patch": "@@ -14,6 +14,8 @@ pub const APPLICABILITY_VALUES: [[&str; 3]; 4] = [\n     [\"rustc_lint_defs\", \"Applicability\", \"HasPlaceholders\"],\n     [\"rustc_lint_defs\", \"Applicability\", \"Unspecified\"],\n ];\n+#[cfg(feature = \"metadata-collector-lint\")]\n+pub const DIAGNOSTIC_BUILDER: [&str; 3] = [\"rustc_errors\", \"diagnostic_builder\", \"DiagnosticBuilder\"];\n pub const ARC_PTR_EQ: [&str; 4] = [\"alloc\", \"sync\", \"Arc\", \"ptr_eq\"];\n pub const ASMUT_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsMut\"];\n pub const ASREF_TRAIT: [&str; 3] = [\"core\", \"convert\", \"AsRef\"];"}]}