{"sha": "61cc8700dfcecde9e7de132356f3c32eb01b147e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxY2M4NzAwZGZjZWNkZTllN2RlMTMyMzU2ZjNjMzJlYjAxYjE0N2U=", "commit": {"author": {"name": "QuietMisdreavus", "email": "bryan@icesoldier.me", "date": "2016-10-17T14:55:18Z"}, "committer": {"name": "QuietMisdreavus", "email": "bryan@icesoldier.me", "date": "2016-10-17T14:55:18Z"}, "message": "rustdoc: make Method/WhereClause wrappers use usize for indents", "tree": {"sha": "9e92badcb0293f98170d99e29682e6898d325a51", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9e92badcb0293f98170d99e29682e6898d325a51"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61cc8700dfcecde9e7de132356f3c32eb01b147e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61cc8700dfcecde9e7de132356f3c32eb01b147e", "html_url": "https://github.com/rust-lang/rust/commit/61cc8700dfcecde9e7de132356f3c32eb01b147e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61cc8700dfcecde9e7de132356f3c32eb01b147e/comments", "author": null, "committer": null, "parents": [{"sha": "43abad45837a15c62828b700aff7efd8eee76cfd", "url": "https://api.github.com/repos/rust-lang/rust/commits/43abad45837a15c62828b700aff7efd8eee76cfd", "html_url": "https://github.com/rust-lang/rust/commit/43abad45837a15c62828b700aff7efd8eee76cfd"}], "stats": {"total": 72, "additions": 32, "deletions": 40}, "files": [{"sha": "eef530081abe358b00ec2da39f707682f4fc76f1", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/61cc8700dfcecde9e7de132356f3c32eb01b147e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61cc8700dfcecde9e7de132356f3c32eb01b147e/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=61cc8700dfcecde9e7de132356f3c32eb01b147e", "patch": "@@ -42,15 +42,15 @@ pub struct UnsafetySpace(pub hir::Unsafety);\n #[derive(Copy, Clone)]\n pub struct ConstnessSpace(pub hir::Constness);\n /// Wrapper struct for properly emitting a method declaration.\n-pub struct Method<'a>(pub &'a clean::FnDecl, pub &'a str);\n+pub struct Method<'a>(pub &'a clean::FnDecl, pub usize);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct MutableSpace(pub clean::Mutability);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct RawMutableSpace(pub clean::Mutability);\n /// Wrapper struct for emitting a where clause from Generics.\n-pub struct WhereClause<'a>(pub &'a clean::Generics, pub String);\n+pub struct WhereClause<'a>(pub &'a clean::Generics, pub usize);\n /// Wrapper struct for emitting type parameter bounds.\n pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n /// Wrapper struct for emitting a comma-separated list of items\n@@ -157,7 +157,7 @@ impl fmt::Display for clean::Generics {\n \n impl<'a> fmt::Display for WhereClause<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let &WhereClause(gens, ref pad) = self;\n+        let &WhereClause(gens, pad) = self;\n         if gens.where_predicates.is_empty() {\n             return Ok(());\n         }\n@@ -207,14 +207,14 @@ impl<'a> fmt::Display for WhereClause<'a> {\n         if !f.alternate() {\n             clause.push_str(\"</span>\");\n             let plain = format!(\"{:#}\", self);\n-            if plain.len() + pad.len() > 80 {\n+            if plain.len() > 80 {\n                 //break it onto its own line regardless, but make sure method impls and trait\n                 //blocks keep their fixed padding (2 and 9, respectively)\n-                let padding = if pad.len() > 10 {\n+                let padding = if pad > 10 {\n                     clause = clause.replace(\"class='where'\", \"class='where fmt-newline'\");\n                     repeat(\"&nbsp;\").take(8).collect::<String>()\n                 } else {\n-                    repeat(\"&nbsp;\").take(pad.len() + 6).collect::<String>()\n+                    repeat(\"&nbsp;\").take(pad + 6).collect::<String>()\n                 };\n                 clause = clause.replace(\"<br>\", &format!(\"<br>{}\", padding));\n             } else {\n@@ -773,8 +773,7 @@ fn fmt_impl(i: &clean::Impl, f: &mut fmt::Formatter, link_trait: bool) -> fmt::R\n     fmt::Display::fmt(&i.for_, f)?;\n     plain.push_str(&format!(\"{:#}\", i.for_));\n \n-    let pad = repeat(\" \").take(plain.len() + 1).collect::<String>();\n-    fmt::Display::fmt(&WhereClause(&i.generics, pad), f)?;\n+    fmt::Display::fmt(&WhereClause(&i.generics, plain.len() + 1), f)?;\n     Ok(())\n }\n \n@@ -903,19 +902,21 @@ impl<'a> fmt::Display for Method<'a> {\n \n         let mut output: String;\n         let plain: String;\n+        let pad = repeat(\" \").take(indent).collect::<String>();\n         if arrow.is_empty() {\n             output = format!(\"({})\", args);\n-            plain = format!(\"{}({})\", indent.replace(\"&nbsp;\", \" \"), args_plain);\n+            plain = format!(\"{}({})\", pad, args_plain);\n         } else {\n             output = format!(\"({args})<br>{arrow}\", args = args, arrow = arrow);\n-            plain = format!(\"{indent}({args}){arrow}\",\n-                            indent = indent.replace(\"&nbsp;\", \" \"),\n+            plain = format!(\"{pad}({args}){arrow}\",\n+                            pad = pad,\n                             args = args_plain,\n                             arrow = arrow_plain);\n         }\n \n         if plain.len() > 80 {\n-            let pad = format!(\"<br>{}\", indent);\n+            let pad = repeat(\"&nbsp;\").take(indent).collect::<String>();\n+            let pad = format!(\"<br>{}\", pad);\n             output = output.replace(\"<br>\", &pad);\n         } else {\n             output = output.replace(\"<br>\", \"\");"}, {"sha": "c0a1abd4aec3fb17fd06fbabab8100750a6287e2", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/61cc8700dfcecde9e7de132356f3c32eb01b147e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61cc8700dfcecde9e7de132356f3c32eb01b147e/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=61cc8700dfcecde9e7de132356f3c32eb01b147e", "patch": "@@ -1967,14 +1967,13 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         UnstableFeatures::Allow => f.constness,\n         _ => hir::Constness::NotConst\n     };\n-    let prefix = format!(\"{}{}{}{:#}fn {}{:#}\",\n+    let indent = format!(\"{}{}{}{:#}fn {}{:#}\",\n                          VisSpace(&it.visibility),\n                          ConstnessSpace(vis_constness),\n                          UnsafetySpace(f.unsafety),\n                          AbiSpace(f.abi),\n                          it.name.as_ref().unwrap(),\n-                         f.generics);\n-    let indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n+                         f.generics).len();\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n            vis = VisSpace(&it.visibility),\n@@ -1983,8 +1982,8 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n            abi = AbiSpace(f.abi),\n            name = it.name.as_ref().unwrap(),\n            generics = f.generics,\n-           where_clause = WhereClause(&f.generics, \"  \".to_string()),\n-           decl = Method(&f.decl, &indent))?;\n+           where_clause = WhereClause(&f.generics, 2),\n+           decl = Method(&f.decl, indent))?;\n     document(w, cx, it)\n }\n \n@@ -2009,17 +2008,15 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         }\n     }\n \n-    // Where clauses in traits are indented nine spaces, per rustdoc.css\n-    let indent = \"         \".to_string();\n-\n     // Output the trait definition\n     write!(w, \"<pre class='rust trait'>{}{}trait {}{}{}{} \",\n            VisSpace(&it.visibility),\n            UnsafetySpace(t.unsafety),\n            it.name.as_ref().unwrap(),\n            t.generics,\n            bounds,\n-           WhereClause(&t.generics, indent))?;\n+           // Where clauses in traits are indented nine spaces, per rustdoc.css\n+           WhereClause(&t.generics, 9))?;\n \n     let types = t.items.iter().filter(|m| m.is_associated_type()).collect::<Vec<_>>();\n     let consts = t.items.iter().filter(|m| m.is_associated_const()).collect::<Vec<_>>();\n@@ -2272,16 +2269,15 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                              AbiSpace(abi),\n                              name,\n                              *g);\n-        let mut indent = repeat(\"&nbsp;\").take(prefix.len()).collect::<String>();\n+        let mut indent = prefix.len();\n         let where_indent = if parent == ItemType::Trait {\n-            indent += \"&nbsp;&nbsp;&nbsp;&nbsp;\";\n-            \"        \".to_string()\n+            indent += 4;\n+            8\n         } else if parent == ItemType::Impl {\n-            \"  \".to_string()\n+            2\n         } else {\n-            let prefix = prefix + &format!(\"{:#}\", Method(d, &indent));\n-            let prefix = prefix.lines().last().unwrap();\n-            repeat(\" \").take(prefix.len() + 1).collect::<String>()\n+            let prefix = prefix + &format!(\"{:#}\", Method(d, indent));\n+            prefix.lines().last().unwrap().len() + 1\n         };\n         write!(w, \"{}{}{}fn <a href='{href}' class='fnname'>{name}</a>\\\n                    {generics}{decl}{where_clause}\",\n@@ -2291,7 +2287,7 @@ fn render_assoc_item(w: &mut fmt::Formatter,\n                href = href,\n                name = name,\n                generics = *g,\n-               decl = Method(d, &indent),\n+               decl = Method(d, indent),\n                where_clause = WhereClause(g, where_indent))\n     }\n     match item.inner {\n@@ -2402,7 +2398,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     let padding = format!(\"{}enum {}{:#} \",\n                           VisSpace(&it.visibility),\n                           it.name.as_ref().unwrap(),\n-                          e.generics);\n+                          e.generics).len();\n     write!(w, \"{}enum {}{}{}\",\n            VisSpace(&it.visibility),\n            it.name.as_ref().unwrap(),\n@@ -2558,8 +2554,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n     match ty {\n         doctree::Plain => {\n             if let Some(g) = g {\n-                let pad = repeat(\" \").take(plain.len() + 1).collect::<String>();\n-                write!(w, \"{}\", WhereClause(g, pad))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             let mut has_visible_fields = false;\n             write!(w, \" {{\")?;\n@@ -2609,16 +2604,14 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             write!(w, \")\")?;\n             plain.push_str(\")\");\n             if let Some(g) = g {\n-                let pad = repeat(\" \").take(plain.len() + 1).collect::<String>();\n-                write!(w, \"{}\", WhereClause(g, pad))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             write!(w, \";\")?;\n         }\n         doctree::Unit => {\n             // Needed for PhantomData.\n             if let Some(g) = g {\n-                let pad = repeat(\" \").take(plain.len() + 1).collect::<String>();\n-                write!(w, \"{}\", WhereClause(g, pad))?\n+                write!(w, \"{}\", WhereClause(g, plain.len() + 1))?\n             }\n             write!(w, \";\")?;\n         }\n@@ -2643,8 +2636,7 @@ fn render_union(w: &mut fmt::Formatter, it: &clean::Item,\n     if let Some(g) = g {\n         write!(w, \"{}\", g)?;\n         plain.push_str(&format!(\"{:#}\", g));\n-        let pad = repeat(\" \").take(plain.len() + 1).collect::<String>();\n-        write!(w, \"{}\", WhereClause(g, pad))?;\n+        write!(w, \"{}\", WhereClause(g, plain.len() + 1))?;\n     }\n \n     write!(w, \" {{\\n{}\", tab)?;\n@@ -2945,8 +2937,7 @@ fn render_impl(w: &mut fmt::Formatter, cx: &Context, i: &Impl, link: AssocItemLi\n \n fn item_typedef(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                 t: &clean::Typedef) -> fmt::Result {\n-    let indent = format!(\"type {}{:#} \", it.name.as_ref().unwrap(), t.generics);\n-    let indent = repeat(\" \").take(indent.len()).collect::<String>();\n+    let indent = format!(\"type {}{:#} \", it.name.as_ref().unwrap(), t.generics).len();\n     write!(w, \"<pre class='rust typedef'>type {}{}{where_clause} = {type_};</pre>\",\n            it.name.as_ref().unwrap(),\n            t.generics,"}]}