{"sha": "67727aa7c31a24ea73a91a9134c3653fae8209ab", "node_id": "C_kwDOAAsO6NoAKDY3NzI3YWE3YzMxYTI0ZWE3M2E5MWE5MTM0YzM2NTNmYWU4MjA5YWI", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-10-20T18:59:15Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-01-15T20:26:25Z"}, "message": "Reduce use of local_def_id_to_hir_id.", "tree": {"sha": "a83a11e73a594aacfad54fadb109b53bf2bef548", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a83a11e73a594aacfad54fadb109b53bf2bef548"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/67727aa7c31a24ea73a91a9134c3653fae8209ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/67727aa7c31a24ea73a91a9134c3653fae8209ab", "html_url": "https://github.com/rust-lang/rust/commit/67727aa7c31a24ea73a91a9134c3653fae8209ab", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/67727aa7c31a24ea73a91a9134c3653fae8209ab/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ebcc847369d5b050cdde870b2261e34afed8679f", "url": "https://api.github.com/repos/rust-lang/rust/commits/ebcc847369d5b050cdde870b2261e34afed8679f", "html_url": "https://github.com/rust-lang/rust/commit/ebcc847369d5b050cdde870b2261e34afed8679f"}], "stats": {"total": 419, "additions": 182, "deletions": 237}, "files": [{"sha": "ba111d394ec26bc20dd81ddd1ae4aa2a5f5d200a", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -409,8 +409,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let generics = tcx.generics_of(self.mir_def_id());\n                     let param = generics.type_param(&param_ty, tcx);\n                     if let Some(generics) = tcx\n-                        .hir()\n-                        .get_generics(tcx.typeck_root_def_id(self.mir_def_id().to_def_id()))\n+                        .typeck_root_def_id(self.mir_def_id().to_def_id())\n+                        .as_local()\n+                        .and_then(|def_id| tcx.hir().get_generics(def_id))\n                     {\n                         suggest_constraining_type_param(\n                             tcx,"}, {"sha": "8f4e574fbd6188dfb83a607901c378e3cacde23c", "filename": "compiler/rustc_borrowck/src/diagnostics/mutability_errors.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmutability_errors.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -628,42 +628,39 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         };\n         (\n             true,\n-            td.as_local().and_then(|tld| {\n-                let h = hir_map.local_def_id_to_hir_id(tld);\n-                match hir_map.find(h) {\n-                    Some(Node::Item(hir::Item {\n-                        kind: hir::ItemKind::Trait(_, _, _, _, items),\n-                        ..\n-                    })) => {\n-                        let mut f_in_trait_opt = None;\n-                        for hir::TraitItemRef { id: fi, kind: k, .. } in *items {\n-                            let hi = fi.hir_id();\n-                            if !matches!(k, hir::AssocItemKind::Fn { .. }) {\n-                                continue;\n-                            }\n-                            if hir_map.name(hi) != hir_map.name(my_hir) {\n-                                continue;\n-                            }\n-                            f_in_trait_opt = Some(hi);\n-                            break;\n+            td.as_local().and_then(|tld| match hir_map.find_by_def_id(tld) {\n+                Some(Node::Item(hir::Item {\n+                    kind: hir::ItemKind::Trait(_, _, _, _, items),\n+                    ..\n+                })) => {\n+                    let mut f_in_trait_opt = None;\n+                    for hir::TraitItemRef { id: fi, kind: k, .. } in *items {\n+                        let hi = fi.hir_id();\n+                        if !matches!(k, hir::AssocItemKind::Fn { .. }) {\n+                            continue;\n                         }\n-                        f_in_trait_opt.and_then(|f_in_trait| match hir_map.find(f_in_trait) {\n-                            Some(Node::TraitItem(hir::TraitItem {\n-                                kind:\n-                                    hir::TraitItemKind::Fn(\n-                                        hir::FnSig { decl: hir::FnDecl { inputs, .. }, .. },\n-                                        _,\n-                                    ),\n-                                ..\n-                            })) => {\n-                                let hir::Ty { span, .. } = inputs[local.index() - 1];\n-                                Some(span)\n-                            }\n-                            _ => None,\n-                        })\n+                        if hir_map.name(hi) != hir_map.name(my_hir) {\n+                            continue;\n+                        }\n+                        f_in_trait_opt = Some(hi);\n+                        break;\n                     }\n-                    _ => None,\n+                    f_in_trait_opt.and_then(|f_in_trait| match hir_map.find(f_in_trait) {\n+                        Some(Node::TraitItem(hir::TraitItem {\n+                            kind:\n+                                hir::TraitItemKind::Fn(\n+                                    hir::FnSig { decl: hir::FnDecl { inputs, .. }, .. },\n+                                    _,\n+                                ),\n+                            ..\n+                        })) => {\n+                            let hir::Ty { span, .. } = inputs[local.index() - 1];\n+                            Some(span)\n+                        }\n+                        _ => None,\n+                    })\n                 }\n+                _ => None,\n             }),\n         )\n     }\n@@ -1075,8 +1072,7 @@ fn get_mut_span_in_struct_field<'tcx>(\n         if let ty::Adt(def, _) = ty.kind() {\n             let field = def.all_fields().nth(field.index())?;\n             // Use the HIR types to construct the diagnostic message.\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(field.did.as_local()?);\n-            let node = tcx.hir().find(hir_id)?;\n+            let node = tcx.hir().find_by_def_id(field.did.as_local()?)?;\n             // Now we're dealing with the actual struct that we're going to suggest a change to,\n             // we can expect a field that is an immutable reference to a type.\n             if let hir::Node::Field(field) = node {"}, {"sha": "aeddd926896e8233cb456ead084ac3ce997262c5", "filename": "compiler/rustc_codegen_ssa/src/back/symbol_export.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Fsymbol_export.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -76,7 +76,7 @@ fn reachable_non_generics_provider(tcx: TyCtxt<'_>, cnum: CrateNum) -> DefIdMap<\n             //\n             // As a result, if this id is an FFI item (foreign item) then we only\n             // let it through if it's included statically.\n-            match tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n+            match tcx.hir().get_by_def_id(def_id) {\n                 Node::ForeignItem(..) => {\n                     tcx.is_statically_included_foreign_item(def_id).then_some(def_id)\n                 }"}, {"sha": "05fbbf45d7c24d5e0516ab3bf0c513f0c1c27794", "filename": "compiler/rustc_const_eval/src/const_eval/fn_queries.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Ffn_queries.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -1,5 +1,5 @@\n use rustc_hir as hir;\n-use rustc_hir::def_id::DefId;\n+use rustc_hir::def_id::{DefId, LocalDefId};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n use rustc_span::symbol::Symbol;\n@@ -15,7 +15,8 @@ pub fn is_unstable_const_fn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Symbol> {\n     }\n }\n \n-pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n+pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n     let parent_id = tcx.hir().get_parent_node(hir_id);\n     matches!(\n         tcx.hir().get(parent_id),\n@@ -29,15 +30,15 @@ pub fn is_parent_const_impl_raw(tcx: TyCtxt<'_>, hir_id: hir::HirId) -> bool {\n /// Checks whether the function has a `const` modifier or, in case it is an intrinsic, whether\n /// said intrinsic has a `rustc_const_{un,}stable` attribute.\n fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-\n-    let node = tcx.hir().get(hir_id);\n+    let def_id = def_id.expect_local();\n+    let node = tcx.hir().get_by_def_id(def_id);\n \n     if let hir::Node::ForeignItem(hir::ForeignItem { kind: hir::ForeignItemKind::Fn(..), .. }) =\n         node\n     {\n         // Intrinsics use `rustc_const_{un,}stable` attributes to indicate constness. All other\n         // foreign items cannot be evaluated at compile-time.\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n         if let Abi::RustIntrinsic | Abi::PlatformIntrinsic = tcx.hir().get_foreign_abi(hir_id) {\n             tcx.lookup_const_stability(def_id).is_some()\n         } else {\n@@ -50,7 +51,7 @@ fn is_const_fn_raw(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n \n         // If the function itself is not annotated with `const`, it may still be a `const fn`\n         // if it resides in a const trait impl.\n-        is_parent_const_impl_raw(tcx, hir_id)\n+        is_parent_const_impl_raw(tcx, def_id)\n     } else {\n         matches!(node, hir::Node::Ctor(_))\n     }"}, {"sha": "1daade8f4004b7745424487b84f75d93b8ebb7db", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -221,8 +221,7 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n             // Prevent const trait methods from being annotated as `stable`.\n             // FIXME: Do this as part of stability checking.\n             if self.is_const_stable_const_fn() {\n-                let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                if crate::const_eval::is_parent_const_impl_raw(tcx, hir_id) {\n+                if crate::const_eval::is_parent_const_impl_raw(tcx, def_id) {\n                     self.ccx\n                         .tcx\n                         .sess"}, {"sha": "a3664493e18837309ef95147f4095efc78c1e265", "filename": "compiler/rustc_const_eval/src/transform/check_consts/qualifs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -210,8 +210,7 @@ impl Qualif for CustomEq {\n         // because that component may be part of an enum variant (e.g.,\n         // `Option::<NonStructuralMatchTy>::Some`), in which case some values of this type may be\n         // structural-match (`Option::None`).\n-        let id = cx.tcx.hir().local_def_id_to_hir_id(cx.def_id());\n-        traits::search_for_structural_match_violation(id, cx.body.span, cx.tcx, ty).is_some()\n+        traits::search_for_structural_match_violation(cx.body.span, cx.tcx, ty).is_some()\n     }\n \n     fn in_adt_inherently<'tcx>("}, {"sha": "7676ff3c41cc7adcc7c783f9a20e5e07e13747ea", "filename": "compiler/rustc_incremental/src/persist/dirty_clean.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_incremental%2Fsrc%2Fpersist%2Fdirty_clean.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -223,8 +223,7 @@ impl<'tcx> DirtyCleanVisitor<'tcx> {\n     /// Return all DepNode labels that should be asserted for this item.\n     /// index=0 is the \"name\" used for error messages\n     fn auto_labels(&mut self, item_id: LocalDefId, attr: &Attribute) -> (&'static str, Labels) {\n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(item_id);\n-        let node = self.tcx.hir().get(hir_id);\n+        let node = self.tcx.hir().get_by_def_id(item_id);\n         let (name, labels) = match node {\n             HirNode::Item(item) => {\n                 match item.kind {"}, {"sha": "ece7ca9df18e5217974574b871668414fddf3be0", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -151,11 +151,10 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n ) -> (String, Span) {\n     let sm = tcx.sess.source_map();\n \n-    let scope = region.free_region_binding_scope(tcx);\n-    let node = tcx.hir().local_def_id_to_hir_id(scope.expect_local());\n+    let scope = region.free_region_binding_scope(tcx).expect_local();\n     match *region {\n         ty::ReEarlyBound(ref br) => {\n-            let mut sp = sm.guess_head_span(tcx.hir().span(node));\n+            let mut sp = sm.guess_head_span(tcx.def_span(scope));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(br.name))\n             {\n@@ -166,7 +165,7 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n         ty::ReFree(ty::FreeRegion {\n             bound_region: ty::BoundRegionKind::BrNamed(_, name), ..\n         }) => {\n-            let mut sp = sm.guess_head_span(tcx.hir().span(node));\n+            let mut sp = sm.guess_head_span(tcx.def_span(scope));\n             if let Some(param) =\n                 tcx.hir().get_generics(scope).and_then(|generics| generics.get_named(name))\n             {\n@@ -181,13 +180,13 @@ fn msg_span_from_early_bound_and_free_regions<'tcx>(\n                 } else {\n                     (\n                         format!(\"the anonymous lifetime #{} defined here\", idx + 1),\n-                        tcx.hir().span(node),\n+                        tcx.def_span(scope),\n                     )\n                 }\n             }\n             _ => (\n                 format!(\"the lifetime `{}` as defined here\", region),\n-                sm.guess_head_span(tcx.hir().span(node)),\n+                sm.guess_head_span(tcx.def_span(scope)),\n             ),\n         },\n         _ => bug!(),\n@@ -1759,8 +1758,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         if let Some(ValuePairs::PolyTraitRefs(exp_found)) = values {\n             if let ty::Closure(def_id, _) = exp_found.expected.skip_binder().self_ty().kind() {\n                 if let Some(def_id) = def_id.as_local() {\n-                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n-                    let span = self.tcx.hir().span(hir_id);\n+                    let span = self.tcx.def_span(def_id);\n                     diag.span_note(span, \"this closure does not fulfill the lifetime requirements\");\n                 }\n             }\n@@ -2245,7 +2243,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                         if let Node::GenericParam(param) = hir.get(id) {\n                             has_bounds = !param.bounds.is_empty();\n                         }\n-                        let sp = hir.span(id);\n+                        let sp = self.tcx.def_span(def_id);\n                         // `sp` only covers `T`, change it so that it covers\n                         // `T:` when appropriate\n                         let is_impl_trait = bound_kind.to_string().starts_with(\"impl \");\n@@ -2291,12 +2289,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             .as_ref()\n             .and_then(|(_, g, _)| g.params.first())\n             .and_then(|param| param.def_id.as_local())\n-            .map(|def_id| {\n-                (\n-                    hir.span(hir.local_def_id_to_hir_id(def_id)).shrink_to_lo(),\n-                    format!(\"{}, \", new_lt),\n-                )\n-            });\n+            .map(|def_id| (self.tcx.def_span(def_id).shrink_to_lo(), format!(\"{}, \", new_lt)));\n \n         let labeled_user_string = match bound_kind {\n             GenericKind::Param(ref p) => format!(\"the parameter type `{}`\", p),"}, {"sha": "b73f403360a00decba6c4c9ce15d9362c4e70ff1", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -610,8 +610,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n                 // reported for missing docs.\n                 let real_trait = trait_ref.path.res.def_id();\n                 let Some(def_id) = real_trait.as_local() else { return };\n-                let hir_id = cx.tcx.hir().local_def_id_to_hir_id(def_id);\n-                let Some(Node::Item(item)) = cx.tcx.hir().find(hir_id) else { return };\n+                let Some(Node::Item(item)) = cx.tcx.hir().find_by_def_id(def_id) else { return };\n                 if let hir::VisibilityKind::Inherited = item.vis.node {\n                     for impl_item_ref in items {\n                         self.private_traits.insert(impl_item_ref.id.hir_id());\n@@ -1212,7 +1211,7 @@ impl<'tcx> LateLintPass<'tcx> for InvalidNoMangleItems {\n                             check_no_mangle_on_generic_fn(\n                                 no_mangle_attr,\n                                 Some(generics),\n-                                cx.tcx.hir().get_generics(it.id.def_id.to_def_id()).unwrap(),\n+                                cx.tcx.hir().get_generics(it.id.def_id).unwrap(),\n                                 it.span,\n                             );\n                         }"}, {"sha": "fb5bd316319036f1d17750f5eb07f8d6ec57780c", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -1579,12 +1579,12 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_closure(&mut self, def_id: LocalDefId) {\n+    fn encode_info_for_closure(&mut self, hir_id: hir::HirId) {\n+        let def_id = self.tcx.hir().local_def_id(hir_id);\n         debug!(\"EncodeContext::encode_info_for_closure({:?})\", def_id);\n \n         // NOTE(eddyb) `tcx.type_of(def_id)` isn't used because it's fully generic,\n         // including on the signature, which is inferred in `typeck.\n-        let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let ty = self.tcx.typeck(def_id).node_type(hir_id);\n \n         match ty.kind() {\n@@ -1605,9 +1605,9 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn encode_info_for_anon_const(&mut self, def_id: LocalDefId) {\n+    fn encode_info_for_anon_const(&mut self, id: hir::HirId) {\n+        let def_id = self.tcx.hir().local_def_id(id);\n         debug!(\"EncodeContext::encode_info_for_anon_const({:?})\", def_id);\n-        let id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n         let body_id = self.tcx.hir().body_owned_by(id);\n         let const_data = self.encode_rendered_const_for_body(body_id);\n         let qualifs = self.tcx.mir_const_qualif(def_id);\n@@ -1928,8 +1928,7 @@ impl<'a, 'tcx> Visitor<'tcx> for EncodeContext<'a, 'tcx> {\n     }\n     fn visit_anon_const(&mut self, c: &'tcx AnonConst) {\n         intravisit::walk_anon_const(self, c);\n-        let def_id = self.tcx.hir().local_def_id(c.hir_id);\n-        self.encode_info_for_anon_const(def_id);\n+        self.encode_info_for_anon_const(c.hir_id);\n     }\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n         intravisit::walk_item(self, item);\n@@ -1983,8 +1982,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_info_for_expr(&mut self, expr: &hir::Expr<'_>) {\n         if let hir::ExprKind::Closure(..) = expr.kind {\n-            let def_id = self.tcx.hir().local_def_id(expr.hir_id);\n-            self.encode_info_for_closure(def_id);\n+            self.encode_info_for_closure(expr.hir_id);\n         }\n     }\n "}, {"sha": "aac9595ae6bacfae0d0ce0a752c368db8732e80d", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -361,8 +361,7 @@ impl<'hir> Map<'hir> {\n         id.as_local().and_then(|id| self.find(self.local_def_id_to_hir_id(id)))\n     }\n \n-    pub fn get_generics(&self, id: DefId) -> Option<&'hir Generics<'hir>> {\n-        let id = id.as_local()?;\n+    pub fn get_generics(&self, id: LocalDefId) -> Option<&'hir Generics<'hir>> {\n         let node = self.tcx.hir_owner(id)?;\n         match node.node {\n             OwnerNode::ImplItem(impl_item) => Some(&impl_item.generics),"}, {"sha": "0890ba63e58567ac900ac10cb5fffd7f4d66927d", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -2449,15 +2449,14 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Closure(def_id, substs) => ty::tls::with(|tcx| {\n                         if let Some(def_id) = def_id.as_local() {\n-                            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n                             let name = if tcx.sess.opts.debugging_opts.span_free_formats {\n                                 let substs = tcx.lift(substs).unwrap();\n                                 format!(\n                                     \"[closure@{}]\",\n                                     tcx.def_path_str_with_substs(def_id.to_def_id(), substs),\n                                 )\n                             } else {\n-                                let span = tcx.hir().span(hir_id);\n+                                let span = tcx.def_span(def_id);\n                                 format!(\n                                     \"[closure@{}]\",\n                                     tcx.sess.source_map().span_to_diagnostic_string(span)\n@@ -2481,8 +2480,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n \n                     AggregateKind::Generator(def_id, _, _) => ty::tls::with(|tcx| {\n                         if let Some(def_id) = def_id.as_local() {\n-                            let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                            let name = format!(\"[generator@{:?}]\", tcx.hir().span(hir_id));\n+                            let name = format!(\"[generator@{:?}]\", tcx.def_span(def_id));\n                             let mut struct_fmt = fmt.debug_struct(&name);\n \n                             // FIXME(project-rfc-2229#48): This should be a list of capture names/places"}, {"sha": "892808386deef4c79bc5b3cad93d7fd711d066d1", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -179,15 +179,11 @@ impl<'tcx> MonoItem<'tcx> {\n \n     pub fn local_span(&self, tcx: TyCtxt<'tcx>) -> Option<Span> {\n         match *self {\n-            MonoItem::Fn(Instance { def, .. }) => {\n-                def.def_id().as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n-            }\n-            MonoItem::Static(def_id) => {\n-                def_id.as_local().map(|def_id| tcx.hir().local_def_id_to_hir_id(def_id))\n-            }\n-            MonoItem::GlobalAsm(item_id) => Some(item_id.hir_id()),\n+            MonoItem::Fn(Instance { def, .. }) => def.def_id().as_local(),\n+            MonoItem::Static(def_id) => def_id.as_local(),\n+            MonoItem::GlobalAsm(item_id) => Some(item_id.def_id),\n         }\n-        .map(|hir_id| tcx.hir().span(hir_id))\n+        .map(|def_id| tcx.def_span(def_id))\n     }\n \n     // Only used by rustc_codegen_cranelift"}, {"sha": "e76cf5d94d32edfdbc358ad311b99c9f19b670af", "filename": "compiler/rustc_middle/src/mir/spanview.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fspanview.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -665,9 +665,7 @@ fn trim_span_hi(span: Span, to_pos: BytePos) -> Span {\n }\n \n fn fn_span<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Span {\n-    let hir_id =\n-        tcx.hir().local_def_id_to_hir_id(def_id.as_local().expect(\"expected DefId is local\"));\n-    let fn_decl_span = tcx.hir().span(hir_id);\n+    let fn_decl_span = tcx.def_span(def_id);\n     if let Some(body_span) = hir_body(tcx, def_id).map(|hir_body| hir_body.value.span) {\n         if fn_decl_span.ctxt() == body_span.ctxt() { fn_decl_span.to(body_span) } else { body_span }\n     } else {"}, {"sha": "373823087c5c843ae1dd2cad4b004c01a45b3570", "filename": "compiler/rustc_middle/src/ty/consts.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fconsts.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -42,9 +42,7 @@ impl<'tcx> Const<'tcx> {\n     ) -> &'tcx Self {\n         debug!(\"Const::from_anon_const(def={:?})\", def);\n \n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-\n-        let body_id = match tcx.hir().get(hir_id) {\n+        let body_id = match tcx.hir().get_by_def_id(def.did) {\n             hir::Node::AnonConst(ac) => ac.body,\n             _ => span_bug!(\n                 tcx.def_span(def.did.to_def_id()),\n@@ -260,8 +258,7 @@ impl<'tcx> Const<'tcx> {\n }\n \n pub fn const_param_default<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> &'tcx Const<'tcx> {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let default_def_id = match tcx.hir().get(hir_id) {\n+    let default_def_id = match tcx.hir().get_by_def_id(def_id.expect_local()) {\n         hir::Node::GenericParam(hir::GenericParam {\n             kind: hir::GenericParamKind::Const { ty: _, default: Some(ac) },\n             .."}, {"sha": "9f38421294d9e56c39cb819ffdccb28ef862cafc", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -1461,8 +1461,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             _ => return None, // not a free region\n         };\n \n-        let hir_id = self.hir().local_def_id_to_hir_id(suitable_region_binding_scope);\n-        let is_impl_item = match self.hir().find(hir_id) {\n+        let is_impl_item = match self.hir().find_by_def_id(suitable_region_binding_scope) {\n             Some(Node::Item(..) | Node::TraitItem(..)) => false,\n             Some(Node::ImplItem(..)) => {\n                 self.is_bound_region_in_impl_item(suitable_region_binding_scope)\n@@ -1495,8 +1494,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     pub fn return_type_impl_trait(self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n         // `type_of()` will fail on these (#55796, #86483), so only allow `fn`s or closures.\n-        let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n-        match self.hir().get(hir_id) {\n+        match self.hir().get_by_def_id(scope_def_id) {\n             Node::Item(&hir::Item { kind: ItemKind::Fn(..), .. }) => {}\n             Node::TraitItem(&hir::TraitItem { kind: TraitItemKind::Fn(..), .. }) => {}\n             Node::ImplItem(&hir::ImplItem { kind: ImplItemKind::Fn(..), .. }) => {}\n@@ -1510,6 +1508,7 @@ impl<'tcx> TyCtxt<'tcx> {\n                 let sig = ret_ty.fn_sig(self);\n                 let output = self.erase_late_bound_regions(sig.output());\n                 if output.is_impl_trait() {\n+                    let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n                     Some((output, fn_decl.output.span()))\n                 } else {"}, {"sha": "c188502f34f5c83a7807c9959b719c99b4f2e0ed", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -2082,8 +2082,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// with the name of the crate containing the impl.\n     pub fn span_of_impl(self, impl_did: DefId) -> Result<Span, Symbol> {\n         if let Some(impl_did) = impl_did.as_local() {\n-            let hir_id = self.hir().local_def_id_to_hir_id(impl_did);\n-            Ok(self.hir().span(hir_id))\n+            Ok(self.def_span(impl_did))\n         } else {\n             Err(self.crate_name(impl_did.krate))\n         }\n@@ -2130,7 +2129,7 @@ impl<'tcx> TyCtxt<'tcx> {\n /// Yields the parent function's `LocalDefId` if `def_id` is an `impl Trait` definition.\n pub fn is_impl_trait_defn(tcx: TyCtxt<'_>, def_id: DefId) -> Option<LocalDefId> {\n     let def_id = def_id.as_local()?;\n-    if let Node::Item(item) = tcx.hir().get(tcx.hir().local_def_id_to_hir_id(def_id)) {\n+    if let Node::Item(item) = tcx.hir().get_by_def_id(def_id) {\n         if let hir::ItemKind::OpaqueTy(ref opaque_ty) = item.kind {\n             return match opaque_ty.origin {\n                 hir::OpaqueTyOrigin::FnReturn(parent) | hir::OpaqueTyOrigin::AsyncFn(parent) => {"}, {"sha": "32977fd42bd0a1944a681d2db20b12daa055b754", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -671,8 +671,7 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(\"generator\");\n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(did) = did.as_local() {\n-                        let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n-                        let span = self.tcx().hir().span(hir_id);\n+                        let span = self.tcx().def_span(did);\n                         p!(write(\n                             \"@{}\",\n                             // This may end up in stderr diagnostics but it may also be emitted\n@@ -708,11 +707,10 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(write(\"closure\"));\n                     // FIXME(eddyb) should use `def_span`.\n                     if let Some(did) = did.as_local() {\n-                        let hir_id = self.tcx().hir().local_def_id_to_hir_id(did);\n                         if self.tcx().sess.opts.debugging_opts.span_free_formats {\n                             p!(\"@\", print_def_path(did.to_def_id(), substs));\n                         } else {\n-                            let span = self.tcx().hir().span(hir_id);\n+                            let span = self.tcx().def_span(did);\n                             p!(write(\n                                 \"@{}\",\n                                 // This may end up in stderr diagnostics but it may also be emitted"}, {"sha": "2433a00232d7fb0b8004b8240e53d1a97a31d6d9", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -217,17 +217,14 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                 ty::ClosureKind::FnOnce => {}\n             }\n \n-            // We won't be building MIR if the closure wasn't local\n-            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n-            let closure_span = tcx.hir().span(closure_hir_id);\n-\n             let Some((capture_index, capture)) =\n                 find_capture_matching_projections(\n                     typeck_results,\n                     var_hir_id,\n                     closure_def_id,\n                     &from_builder.projection,\n                 ) else {\n+                let closure_span = tcx.def_span(closure_def_id);\n                 if !enable_precise_capture(tcx, closure_span) {\n                     bug!(\n                         \"No associated capture found for {:?}[{:#?}] even though \\\n@@ -244,6 +241,8 @@ fn to_upvars_resolved_place_builder<'a, 'tcx>(\n                 return Err(from_builder);\n             };\n \n+            // We won't be building MIR if the closure wasn't local\n+            let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n             let closure_ty = typeck_results.node_type(closure_hir_id);\n \n             let substs = match closure_ty.kind() {"}, {"sha": "d348aaa899e65d79d78b950bb8d3bd196cd231c5", "filename": "compiler/rustc_mir_build/src/lints.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Flints.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -11,9 +11,8 @@ use std::ops::ControlFlow;\n \n crate fn check<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>) {\n     let def_id = body.source.def_id().expect_local();\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n \n-    if let Some(fn_kind) = tcx.hir().get(hir_id).fn_kind() {\n+    if let Some(fn_kind) = tcx.hir().get_by_def_id(def_id).fn_kind() {\n         if let FnKind::Closure = fn_kind {\n             // closures can't recur, so they don't matter.\n             return;"}, {"sha": "8ccf6acf7034ca0ab77cfcfa5fd47754aefe010a", "filename": "compiler/rustc_mir_build/src/thir/pattern/const_to_pat.rs", "status": "modified", "additions": 26, "deletions": 28, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fthir%2Fpattern%2Fconst_to_pat.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -120,34 +120,32 @@ impl<'a, 'tcx> ConstToPat<'a, 'tcx> {\n     }\n \n     fn search_for_structural_match_violation(&self, ty: Ty<'tcx>) -> Option<String> {\n-        traits::search_for_structural_match_violation(self.id, self.span, self.tcx(), ty).map(\n-            |non_sm_ty| {\n-                with_no_trimmed_paths(|| match non_sm_ty {\n-                    traits::NonStructuralMatchTy::Adt(adt) => self.adt_derive_msg(adt),\n-                    traits::NonStructuralMatchTy::Dynamic => {\n-                        \"trait objects cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Opaque => {\n-                        \"opaque types cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Closure => {\n-                        \"closures cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Generator => {\n-                        \"generators cannot be used in patterns\".to_string()\n-                    }\n-                    traits::NonStructuralMatchTy::Param => {\n-                        bug!(\"use of a constant whose type is a parameter inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTy::Projection => {\n-                        bug!(\"use of a constant whose type is a projection inside a pattern\")\n-                    }\n-                    traits::NonStructuralMatchTy::Foreign => {\n-                        bug!(\"use of a value of a foreign type inside a pattern\")\n-                    }\n-                })\n-            },\n-        )\n+        traits::search_for_structural_match_violation(self.span, self.tcx(), ty).map(|non_sm_ty| {\n+            with_no_trimmed_paths(|| match non_sm_ty {\n+                traits::NonStructuralMatchTy::Adt(adt) => self.adt_derive_msg(adt),\n+                traits::NonStructuralMatchTy::Dynamic => {\n+                    \"trait objects cannot be used in patterns\".to_string()\n+                }\n+                traits::NonStructuralMatchTy::Opaque => {\n+                    \"opaque types cannot be used in patterns\".to_string()\n+                }\n+                traits::NonStructuralMatchTy::Closure => {\n+                    \"closures cannot be used in patterns\".to_string()\n+                }\n+                traits::NonStructuralMatchTy::Generator => {\n+                    \"generators cannot be used in patterns\".to_string()\n+                }\n+                traits::NonStructuralMatchTy::Param => {\n+                    bug!(\"use of a constant whose type is a parameter inside a pattern\")\n+                }\n+                traits::NonStructuralMatchTy::Projection => {\n+                    bug!(\"use of a constant whose type is a projection inside a pattern\")\n+                }\n+                traits::NonStructuralMatchTy::Foreign => {\n+                    bug!(\"use of a value of a foreign type inside a pattern\")\n+                }\n+            })\n+        })\n     }\n \n     fn type_marked_structural(&self, ty: Ty<'tcx>) -> bool {"}, {"sha": "b5888592f6295ea44656896fd4884030b4fe419b", "filename": "compiler/rustc_mir_transform/src/const_prop.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fconst_prop.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -76,10 +76,8 @@ impl<'tcx> MirPass<'tcx> for ConstProp {\n         }\n \n         let def_id = body.source.def_id().expect_local();\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-\n-        let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n-        let is_assoc_const = tcx.def_kind(def_id.to_def_id()) == DefKind::AssocConst;\n+        let is_fn_like = tcx.hir().get_by_def_id(def_id).fn_kind().is_some();\n+        let is_assoc_const = tcx.def_kind(def_id) == DefKind::AssocConst;\n \n         // Only run const prop on functions, methods, closures and associated constants\n         if !is_fn_like && !is_assoc_const {"}, {"sha": "82455654a8860c11501e8caf17bcf5cc5abca8fc", "filename": "compiler/rustc_mir_transform/src/coverage/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Fcoverage%2Fmod.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -66,8 +66,8 @@ impl<'tcx> MirPass<'tcx> for InstrumentCoverage {\n             return;\n         }\n \n-        let hir_id = tcx.hir().local_def_id_to_hir_id(mir_source.def_id().expect_local());\n-        let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n+        let is_fn_like =\n+            tcx.hir().get_by_def_id(mir_source.def_id().expect_local()).fn_kind().is_some();\n \n         // Only instrument functions, methods, and closures (not constants since they are evaluated\n         // at compile time by Miri)."}, {"sha": "83e442c7891c6cc84cecf355d5601f21fbc74bb7", "filename": "compiler/rustc_mir_transform/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Flib.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -366,8 +366,7 @@ fn mir_drops_elaborated_and_const_checked<'tcx>(\n         tcx.ensure().mir_borrowck(def.did);\n     }\n \n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def.did);\n-    let is_fn_like = tcx.hir().get(hir_id).fn_kind().is_some();\n+    let is_fn_like = tcx.hir().get_by_def_id(def.did).fn_kind().is_some();\n     if is_fn_like {\n         let did = def.did.to_def_id();\n         let def = ty::WithOptConstParam::unknown(did);"}, {"sha": "27540395c07892054465dc5d1a1af0c866369e81", "filename": "compiler/rustc_monomorphize/src/util.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_monomorphize%2Fsrc%2Futil.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -49,8 +49,7 @@ crate fn dump_closure_profile<'tcx>(tcx: TyCtxt<'tcx>, closure_instance: Instanc\n             .map(|l| format!(\"{:?}\", l.size.bytes()))\n             .unwrap_or_else(|e| format!(\"Failed {:?}\", e));\n \n-        let closure_hir_id = tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n-        let closure_span = tcx.hir().span(closure_hir_id);\n+        let closure_span = tcx.def_span(closure_def_id);\n         let src_file = tcx.sess.source_map().span_to_filename(closure_span);\n         let line_nos = tcx\n             .sess"}, {"sha": "f17816eff9a7429321176126ace7066adb9622d9", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -23,7 +23,7 @@ use std::mem;\n // may need to be marked as live.\n fn should_explore(tcx: TyCtxt<'_>, def_id: LocalDefId) -> bool {\n     matches!(\n-        tcx.hir().find(tcx.hir().local_def_id_to_hir_id(def_id)),\n+        tcx.hir().find_by_def_id(def_id),\n         Some(\n             Node::Item(..)\n                 | Node::ImplItem(..)\n@@ -232,7 +232,7 @@ impl<'tcx> MarkSymbolVisitor<'tcx> {\n             // tuple struct constructor function\n             let id = self.struct_constructors.get(&id).copied().unwrap_or(id);\n \n-            if let Some(node) = self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(id)) {\n+            if let Some(node) = self.tcx.hir().find_by_def_id(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }"}, {"sha": "fdabe41dafaedff61466dea6036b6be20c155163", "filename": "compiler/rustc_passes/src/entry.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_passes%2Fsrc%2Fentry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fentry.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -152,11 +152,10 @@ fn configure_main(tcx: TyCtxt<'_>, visitor: &EntryContext<'_, '_>) -> Option<(De\n             if let Some(def_id) = main_def.opt_fn_def_id() {\n                 // non-local main imports are handled below\n                 if let Some(def_id) = def_id.as_local() {\n-                    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                    if matches!(tcx.hir().find(hir_id), Some(Node::ForeignItem(_))) {\n+                    if matches!(tcx.hir().find_by_def_id(def_id), Some(Node::ForeignItem(_))) {\n                         tcx.sess\n                             .struct_span_err(\n-                                tcx.hir().span(hir_id),\n+                                tcx.def_span(def_id),\n                                 \"the `main` function cannot be declared in an `extern` block\",\n                             )\n                             .emit();"}, {"sha": "3596210036a9c65aa13aef0e974b511912cf83ba", "filename": "compiler/rustc_passes/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_passes%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Flib.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -6,6 +6,7 @@\n \n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/nightly-rustc/\")]\n #![feature(crate_visibility_modifier)]\n+#![feature(let_else)]\n #![feature(map_try_insert)]\n #![feature(min_specialization)]\n #![feature(nll)]"}, {"sha": "f4790c4335c12133f6e15d4625eedf42932f20b3", "filename": "compiler/rustc_passes/src/reachable.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_passes%2Fsrc%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Freachable.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -52,7 +52,7 @@ fn method_might_be_inlined(\n             return true;\n         }\n     }\n-    match tcx.hir().find(tcx.hir().local_def_id_to_hir_id(impl_src)) {\n+    match tcx.hir().find_by_def_id(impl_src) {\n         Some(Node::Item(item)) => item_might_be_inlined(tcx, &item, codegen_fn_attrs),\n         Some(..) | None => span_bug!(impl_item.span, \"impl did is not an item\"),\n     }\n@@ -140,14 +140,11 @@ impl<'tcx> ReachableContext<'tcx> {\n     // Returns true if the given def ID represents a local item that is\n     // eligible for inlining and false otherwise.\n     fn def_id_represents_local_inlined_item(&self, def_id: DefId) -> bool {\n-        let hir_id = match def_id.as_local() {\n-            Some(def_id) => self.tcx.hir().local_def_id_to_hir_id(def_id),\n-            None => {\n-                return false;\n-            }\n+        let Some(def_id) = def_id.as_local() else {\n+            return false;\n         };\n \n-        match self.tcx.hir().find(hir_id) {\n+        match self.tcx.hir().find_by_def_id(def_id) {\n             Some(Node::Item(item)) => match item.kind {\n                 hir::ItemKind::Fn(..) => {\n                     item_might_be_inlined(self.tcx, &item, self.tcx.codegen_fn_attrs(def_id))\n@@ -169,6 +166,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                         if generics.requires_monomorphization(self.tcx) || attrs.requests_inline() {\n                             true\n                         } else {\n+                            let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                             let impl_did = self.tcx.hir().get_parent_item(hir_id);\n                             // Check the impl. If the generics on the self\n                             // type of the impl require inlining, this method\n@@ -198,9 +196,7 @@ impl<'tcx> ReachableContext<'tcx> {\n                 continue;\n             }\n \n-            if let Some(ref item) =\n-                self.tcx.hir().find(self.tcx.hir().local_def_id_to_hir_id(search_item))\n-            {\n+            if let Some(ref item) = self.tcx.hir().find_by_def_id(search_item) {\n                 self.propagate_node(item, search_item);\n             }\n         }"}, {"sha": "01fc1b7012e2630518e1f7049a68ec2062465b9f", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 36, "deletions": 44, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -376,12 +376,9 @@ pub fn provide(providers: &mut ty::query::Providers) {\n \n         named_region_map: |tcx, id| resolve_lifetimes_for(tcx, id).defs.get(&id),\n         is_late_bound_map,\n-        object_lifetime_defaults_map: |tcx, id| {\n-            let hir_id = tcx.hir().local_def_id_to_hir_id(id);\n-            match tcx.hir().find(hir_id) {\n-                Some(Node::Item(item)) => compute_object_lifetime_defaults(tcx, item),\n-                _ => None,\n-            }\n+        object_lifetime_defaults_map: |tcx, id| match tcx.hir().find_by_def_id(id) {\n+            Some(Node::Item(item)) => compute_object_lifetime_defaults(tcx, item),\n+            _ => None,\n         },\n         late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n         lifetime_scope_map: |tcx, id| {\n@@ -514,14 +511,14 @@ fn resolve_lifetimes_for<'tcx>(tcx: TyCtxt<'tcx>, def_id: LocalDefId) -> &'tcx R\n \n /// Finds the `Item` that contains the given `LocalDefId`\n fn item_for(tcx: TyCtxt<'_>, local_def_id: LocalDefId) -> LocalDefId {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n-    match tcx.hir().find(hir_id) {\n+    match tcx.hir().find_by_def_id(local_def_id) {\n         Some(Node::Item(item)) => {\n             return item.def_id;\n         }\n         _ => {}\n     }\n     let item = {\n+        let hir_id = tcx.hir().local_def_id_to_hir_id(local_def_id);\n         let mut parent_iter = tcx.hir().parent_iter(hir_id);\n         loop {\n             let node = parent_iter.next().map(|n| n.1);\n@@ -1672,13 +1669,10 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n                     if let Some(def) =\n                         lifetimes.get(&hir::ParamName::Plain(label.normalize_to_macros_2_0()))\n                     {\n-                        let hir_id =\n-                            tcx.hir().local_def_id_to_hir_id(def.id().unwrap().expect_local());\n-\n                         signal_shadowing_problem(\n                             tcx,\n                             label.name,\n-                            original_lifetime(tcx.hir().span(hir_id)),\n+                            original_lifetime(tcx.def_span(def.id().unwrap().expect_local())),\n                             shadower_label(label.span),\n                         );\n                         return;\n@@ -1910,6 +1904,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let remove_decl = self\n             .tcx\n             .parent(def_id)\n+            .and_then(|parent_def_id| parent_def_id.as_local())\n             .and_then(|parent_def_id| self.tcx.hir().get_generics(parent_def_id))\n             .and_then(|generics| self.lifetime_deletion_span(name, generics));\n \n@@ -2032,32 +2027,31 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n-                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-                    debug!(\"hir id first={:?}\", hir_id);\n-                    if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n-                        Node::Lifetime(hir_lifetime) => Some((\n-                            hir_lifetime.hir_id,\n-                            hir_lifetime.span,\n-                            hir_lifetime.name.ident(),\n-                        )),\n-                        Node::GenericParam(param) => {\n-                            Some((param.hir_id, param.span, param.name.ident()))\n+                    debug!(?def_id);\n+                    if let Some((id, span, name)) =\n+                        match self.tcx.hir().get_by_def_id(def_id.expect_local()) {\n+                            Node::Lifetime(hir_lifetime) => Some((\n+                                hir_lifetime.hir_id,\n+                                hir_lifetime.span,\n+                                hir_lifetime.name.ident(),\n+                            )),\n+                            Node::GenericParam(param) => {\n+                                Some((param.hir_id, param.span, param.name.ident()))\n+                            }\n+                            _ => None,\n                         }\n-                        _ => None,\n-                    } {\n+                    {\n                         debug!(\"id = {:?} span = {:?} name = {:?}\", id, span, name);\n                         if name.name == kw::UnderscoreLifetime {\n                             continue;\n                         }\n \n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n                             if let Some(def_id) = parent_def_id.as_local() {\n-                                let parent_hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id);\n                                 // lifetimes in `derive` expansions don't count (Issue #53738)\n                                 if self\n                                     .tcx\n-                                    .hir()\n-                                    .attrs(parent_hir_id)\n+                                    .get_attrs(def_id.to_def_id())\n                                     .iter()\n                                     .any(|attr| attr.has_name(sym::automatically_derived))\n                                 {\n@@ -2069,7 +2063,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                 if let hir::Node::Item(hir::Item {\n                                     kind: hir::ItemKind::OpaqueTy(ref opaque),\n                                     ..\n-                                }) = self.tcx.hir().get(parent_hir_id)\n+                                }) = self.tcx.hir().get_by_def_id(def_id)\n                                 {\n                                     if !matches!(opaque.origin, hir::OpaqueTyOrigin::AsyncFn(..)) {\n                                         continue 'lifetimes;\n@@ -2115,18 +2109,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     debug!(\"not one use lifetime\");\n                 }\n                 None => {\n-                    let hir_id = self.tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-                    if let Some((id, span, name)) = match self.tcx.hir().get(hir_id) {\n-                        Node::Lifetime(hir_lifetime) => Some((\n-                            hir_lifetime.hir_id,\n-                            hir_lifetime.span,\n-                            hir_lifetime.name.ident(),\n-                        )),\n-                        Node::GenericParam(param) => {\n-                            Some((param.hir_id, param.span, param.name.ident()))\n+                    if let Some((id, span, name)) =\n+                        match self.tcx.hir().get_by_def_id(def_id.expect_local()) {\n+                            Node::Lifetime(hir_lifetime) => Some((\n+                                hir_lifetime.hir_id,\n+                                hir_lifetime.span,\n+                                hir_lifetime.name.ident(),\n+                            )),\n+                            Node::GenericParam(param) => {\n+                                Some((param.hir_id, param.span, param.name.ident()))\n+                            }\n+                            _ => None,\n                         }\n-                        _ => None,\n-                    } {\n+                    {\n                         debug!(\"id ={:?} span = {:?} name = {:?}\", id, span, name);\n                         self.tcx.struct_span_lint_hir(\n                             lint::builtin::UNUSED_LIFETIMES,\n@@ -2137,7 +2132,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                     .build(&format!(\"lifetime parameter `{}` never used\", name));\n                                 if let Some(parent_def_id) = self.tcx.parent(def_id) {\n                                     if let Some(generics) =\n-                                        self.tcx.hir().get_generics(parent_def_id)\n+                                        self.tcx.hir().get_generics(parent_def_id.expect_local())\n                                     {\n                                         let unused_lt_span =\n                                             self.lifetime_deletion_span(name, generics);\n@@ -3339,13 +3334,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Binder { ref lifetimes, s, .. } => {\n                     if let Some(&def) = lifetimes.get(&param.name.normalize_to_macros_2_0()) {\n-                        let hir_id =\n-                            self.tcx.hir().local_def_id_to_hir_id(def.id().unwrap().expect_local());\n-\n                         signal_shadowing_problem(\n                             self.tcx,\n                             param.name.ident().name,\n-                            original_lifetime(self.tcx.hir().span(hir_id)),\n+                            original_lifetime(self.tcx.def_span(def.id().unwrap())),\n                             shadower_lifetime(&param),\n                         );\n                         return;"}, {"sha": "c5e85b14421cf082dec61a34e4a74ca6de6ab0f9", "filename": "compiler/rustc_symbol_mangling/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Flib.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -173,8 +173,7 @@ fn compute_symbol_name<'tcx>(\n             let stable_crate_id = tcx.sess.local_stable_crate_id();\n             return tcx.sess.generate_proc_macro_decls_symbol(stable_crate_id);\n         }\n-        let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-        matches!(tcx.hir().get(hir_id), Node::ForeignItem(_))\n+        matches!(tcx.hir().get_by_def_id(def_id), Node::ForeignItem(_))\n     } else {\n         tcx.is_foreign_item(def_id)\n     };"}, {"sha": "b4d297a03ef21f3b552d8a15b9164fe0d77395b3", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -616,8 +616,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                             self.tcx.sess.source_map().guess_head_span(\n                                 self.tcx.hir().span_if_local(closure_def_id).unwrap(),\n                             );\n-                        let hir_id =\n-                            self.tcx.hir().local_def_id_to_hir_id(closure_def_id.expect_local());\n                         let mut err = struct_span_err!(\n                             self.tcx.sess,\n                             closure_span,\n@@ -640,6 +638,10 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // Additional context information explaining why the closure only implements\n                         // a particular trait.\n                         if let Some(typeck_results) = self.in_progress_typeck_results {\n+                            let hir_id = self\n+                                .tcx\n+                                .hir()\n+                                .local_def_id_to_hir_id(closure_def_id.expect_local());\n                             let typeck_results = typeck_results.borrow();\n                             match (found_kind, typeck_results.closure_kind_origins().get(hir_id)) {\n                                 (ty::ClosureKind::FnOnce, Some((span, place))) => {"}, {"sha": "45960bd365346ba6fe3ec36eb9d0b6733559111d", "filename": "compiler/rustc_trait_selection/src/traits/structural_match.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fstructural_match.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -48,7 +48,6 @@ pub enum NonStructuralMatchTy<'tcx> {\n /// that arose when the requirement was not enforced completely, see\n /// Rust RFC 1445, rust-lang/rust#61188, and rust-lang/rust#62307.\n pub fn search_for_structural_match_violation<'tcx>(\n-    _id: hir::HirId,\n     span: Span,\n     tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,"}, {"sha": "fb7fdacf5e6874925f5efc1e07033298146f206d", "filename": "compiler/rustc_ty_utils/src/representability.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Frepresentability.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -99,12 +99,7 @@ fn are_inner_types_recursive<'tcx>(\n             // Find non representable fields with their spans\n             fold_repr(def.all_fields().map(|field| {\n                 let ty = field.ty(tcx, substs);\n-                let span = match field\n-                    .did\n-                    .as_local()\n-                    .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n-                    .and_then(|id| tcx.hir().find(id))\n-                {\n+                let span = match field.did.as_local().and_then(|id| tcx.hir().find_by_def_id(id)) {\n                     Some(hir::Node::Field(field)) => field.ty.span,\n                     _ => sp,\n                 };"}, {"sha": "4d48cd25e362e094ec721e9c25cfd45f427a927f", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -279,8 +279,7 @@ fn well_formed_types_in_env<'tcx>(\n     if !def_id.is_local() {\n         return ty::List::empty();\n     }\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-    let node = tcx.hir().get(hir_id);\n+    let node = tcx.hir().get_by_def_id(def_id.expect_local());\n \n     enum NodeKind {\n         TraitImpl,\n@@ -436,9 +435,7 @@ fn issue33140_self_ty(tcx: TyCtxt<'_>, def_id: DefId) -> Option<Ty<'_>> {\n \n /// Check if a function is async.\n fn asyncness(tcx: TyCtxt<'_>, def_id: DefId) -> hir::IsAsync {\n-    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n-\n-    let node = tcx.hir().get(hir_id);\n+    let node = tcx.hir().get_by_def_id(def_id.expect_local());\n \n     let fn_kind = node.fn_kind().unwrap_or_else(|| {\n         bug!(\"asyncness: expected fn-like node but got `{:?}`\", def_id);"}, {"sha": "89f9cbf22562d7c6b02616f91c623df15f93d98a", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -1314,7 +1314,7 @@ fn check_enum<'tcx>(\n             let variant_i = tcx.hir().expect_variant(variant_i_hir_id);\n             let i_span = match variant_i.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),\n-                None => tcx.hir().span(variant_i_hir_id),\n+                None => tcx.def_span(variant_did),\n             };\n             let span = match v.disr_expr {\n                 Some(ref expr) => tcx.hir().span(expr.hir_id),"}, {"sha": "74327affede481e5d7e7b7913d835d42291385c0", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -435,10 +435,18 @@ fn check_region_bounds_on_impl_item<'tcx>(\n     if trait_params != impl_params {\n         let item_kind = assoc_item_kind_str(impl_m);\n         let def_span = tcx.sess.source_map().guess_head_span(span);\n-        let span = tcx.hir().get_generics(impl_m.def_id).map_or(def_span, |g| g.span);\n+        let span = impl_m\n+            .def_id\n+            .as_local()\n+            .and_then(|did| tcx.hir().get_generics(did))\n+            .map_or(def_span, |g| g.span);\n         let generics_span = tcx.hir().span_if_local(trait_m.def_id).map(|sp| {\n             let def_sp = tcx.sess.source_map().guess_head_span(sp);\n-            tcx.hir().get_generics(trait_m.def_id).map_or(def_sp, |g| g.span)\n+            trait_m\n+                .def_id\n+                .as_local()\n+                .and_then(|did| tcx.hir().get_generics(did))\n+                .map_or(def_sp, |g| g.span)\n         });\n \n         tcx.sess.emit_err(LifetimesOrBoundsMismatchOnTrait {"}, {"sha": "c8986aa7f53b04cf456b6e33c638f96723d0938a", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -184,8 +184,6 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n     // absent. So we report an error that the Drop impl injected a\n     // predicate that is not present on the struct definition.\n \n-    let self_type_hir_id = tcx.hir().local_def_id_to_hir_id(self_type_did);\n-\n     // We can assume the predicates attached to struct/enum definition\n     // hold.\n     let generic_assumptions = tcx.predicates_of(self_type_did);\n@@ -252,7 +250,7 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         };\n \n         if !assumptions_in_impl_context.iter().copied().any(predicate_matches_closure) {\n-            let item_span = tcx.hir().span(self_type_hir_id);\n+            let item_span = tcx.def_span(self_type_did);\n             let self_descr = tcx.def_kind(self_type_did).descr(self_type_did.to_def_id());\n             struct_span_err!(\n                 tcx.sess,"}, {"sha": "c7b7bb7574bdea20677dddafead3a8f4c2fc1758", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/67727aa7c31a24ea73a91a9134c3653fae8209ab/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=67727aa7c31a24ea73a91a9134c3653fae8209ab", "patch": "@@ -787,9 +787,7 @@ fn check_param_wf(tcx: TyCtxt<'_>, param: &hir::GenericParam<'_>) {\n                 }\n             };\n \n-            if traits::search_for_structural_match_violation(param.hir_id, param.span, tcx, ty)\n-                .is_some()\n-            {\n+            if traits::search_for_structural_match_violation(param.span, tcx, ty).is_some() {\n                 // We use the same error code in both branches, because this is really the same\n                 // issue: we just special-case the message for type parameters to make it\n                 // clearer."}]}