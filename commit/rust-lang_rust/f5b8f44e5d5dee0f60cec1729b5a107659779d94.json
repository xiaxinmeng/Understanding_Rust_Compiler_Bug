{"sha": "f5b8f44e5d5dee0f60cec1729b5a107659779d94", "node_id": "C_kwDOAAsO6NoAKGY1YjhmNDRlNWQ1ZGVlMGY2MGNlYzE3MjliNWExMDc2NTk3NzlkOTQ", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-06T16:29:36Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-06T16:29:36Z"}, "message": "Auto merge of #109333 - Zoxc:erase-query-cache-values, r=cjgillot\n\nErase query cache values\n\nThis replaces most concrete query values `V` with `MaybeUninit<[u8; { size_of::<V>() }]>` without introducing dynamic dispatch like https://github.com/rust-lang/rust/pull/108638 does. This is split out of https://github.com/rust-lang/rust/pull/108638 so the performance impact of only this change can be measured.\n\nr? `@cjgillot`", "tree": {"sha": "478d20460ebedf0c444e88ad6c4af02eb3d8d1c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/478d20460ebedf0c444e88ad6c4af02eb3d8d1c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f5b8f44e5d5dee0f60cec1729b5a107659779d94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f5b8f44e5d5dee0f60cec1729b5a107659779d94", "html_url": "https://github.com/rust-lang/rust/commit/f5b8f44e5d5dee0f60cec1729b5a107659779d94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f5b8f44e5d5dee0f60cec1729b5a107659779d94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "url": "https://api.github.com/repos/rust-lang/rust/commits/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee", "html_url": "https://github.com/rust-lang/rust/commit/0534655d9b5f61dbd75cf142ec8d2d3f68b550ee"}, {"sha": "0110073d035530139835585a78c3a62db838a49e", "url": "https://api.github.com/repos/rust-lang/rust/commits/0110073d035530139835585a78c3a62db838a49e", "html_url": "https://github.com/rust-lang/rust/commit/0110073d035530139835585a78c3a62db838a49e"}], "stats": {"total": 526, "additions": 465, "deletions": 61}, "files": [{"sha": "b4edb02f6c48dea096f6aecee9d9103e9e61bf9d", "filename": "compiler/rustc_middle/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_middle%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flib.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -33,6 +33,7 @@\n #![feature(generators)]\n #![feature(get_mut_unchecked)]\n #![feature(if_let_guard)]\n+#![feature(inline_const)]\n #![feature(iter_from_generator)]\n #![feature(local_key_cell_methods)]\n #![feature(negative_impls)]"}, {"sha": "5462ced16d6b221305c07ca26754a9f28949ec67", "filename": "compiler/rustc_middle/src/query/erase.rs", "status": "added", "additions": 337, "deletions": 0, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Ferase.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -0,0 +1,337 @@\n+use crate::mir;\n+use crate::traits;\n+use crate::ty::{self, Ty};\n+use std::mem::{size_of, transmute_copy, MaybeUninit};\n+\n+#[derive(Copy, Clone)]\n+pub struct Erased<T: Copy> {\n+    // We use `MaybeUninit` here so we can store any value\n+    // in `data` since we aren't actually storing a `T`.\n+    data: MaybeUninit<T>,\n+}\n+\n+pub trait EraseType: Copy {\n+    type Result: Copy;\n+}\n+\n+// Allow `type_alias_bounds` since compilation will fail without `EraseType`.\n+#[allow(type_alias_bounds)]\n+pub type Erase<T: EraseType> = Erased<impl Copy>;\n+\n+#[inline(always)]\n+pub fn erase<T: EraseType>(src: T) -> Erase<T> {\n+    // Ensure the sizes match\n+    const {\n+        if std::mem::size_of::<T>() != std::mem::size_of::<T::Result>() {\n+            panic!(\"size of T must match erased type T::Result\")\n+        }\n+    };\n+\n+    Erased::<<T as EraseType>::Result> {\n+        // SAFETY: Is it safe to transmute to MaybeUninit for types with the same sizes.\n+        data: unsafe { transmute_copy(&src) },\n+    }\n+}\n+\n+/// Restores an erased value.\n+#[inline(always)]\n+pub fn restore<T: EraseType>(value: Erase<T>) -> T {\n+    let value: Erased<<T as EraseType>::Result> = value;\n+    // SAFETY: Due to the use of impl Trait in `Erase` the only way to safetly create an instance\n+    // of `Erase` is to call `erase`, so we know that `value.data` is a valid instance of `T` of\n+    // the right size.\n+    unsafe { transmute_copy(&value.data) }\n+}\n+\n+impl<T> EraseType for &'_ T {\n+    type Result = [u8; size_of::<*const ()>()];\n+}\n+\n+impl<T> EraseType for &'_ [T] {\n+    type Result = [u8; size_of::<*const [()]>()];\n+}\n+\n+impl<T> EraseType for &'_ ty::List<T> {\n+    type Result = [u8; size_of::<*const ()>()];\n+}\n+\n+impl<T> EraseType for Result<&'_ T, traits::query::NoSolution> {\n+    type Result = [u8; size_of::<Result<&'static (), traits::query::NoSolution>>()];\n+}\n+\n+impl<T> EraseType for Result<&'_ T, rustc_errors::ErrorGuaranteed> {\n+    type Result = [u8; size_of::<Result<&'static (), rustc_errors::ErrorGuaranteed>>()];\n+}\n+\n+impl<T> EraseType for Result<&'_ T, traits::CodegenObligationError> {\n+    type Result = [u8; size_of::<Result<&'static (), traits::CodegenObligationError>>()];\n+}\n+\n+impl<T> EraseType for Result<&'_ T, ty::layout::FnAbiError<'_>> {\n+    type Result = [u8; size_of::<Result<&'static (), ty::layout::FnAbiError<'static>>>()];\n+}\n+\n+impl<T> EraseType for Result<(&'_ T, rustc_middle::thir::ExprId), rustc_errors::ErrorGuaranteed> {\n+    type Result = [u8; size_of::<\n+        Result<(&'static (), rustc_middle::thir::ExprId), rustc_errors::ErrorGuaranteed>,\n+    >()];\n+}\n+\n+impl EraseType for Result<Option<ty::Instance<'_>>, rustc_errors::ErrorGuaranteed> {\n+    type Result =\n+        [u8; size_of::<Result<Option<ty::Instance<'static>>, rustc_errors::ErrorGuaranteed>>()];\n+}\n+\n+impl EraseType for Result<Option<ty::Const<'_>>, rustc_errors::ErrorGuaranteed> {\n+    type Result =\n+        [u8; size_of::<Result<Option<ty::Const<'static>>, rustc_errors::ErrorGuaranteed>>()];\n+}\n+\n+impl EraseType for Result<ty::GenericArg<'_>, traits::query::NoSolution> {\n+    type Result = [u8; size_of::<Result<ty::GenericArg<'static>, traits::query::NoSolution>>()];\n+}\n+\n+impl EraseType for Result<bool, ty::layout::LayoutError<'_>> {\n+    type Result = [u8; size_of::<Result<bool, ty::layout::LayoutError<'static>>>()];\n+}\n+\n+impl EraseType for Result<rustc_target::abi::TyAndLayout<'_, Ty<'_>>, ty::layout::LayoutError<'_>> {\n+    type Result = [u8; size_of::<\n+        Result<\n+            rustc_target::abi::TyAndLayout<'static, Ty<'static>>,\n+            ty::layout::LayoutError<'static>,\n+        >,\n+    >()];\n+}\n+\n+impl EraseType for Result<ty::Const<'_>, mir::interpret::LitToConstError> {\n+    type Result = [u8; size_of::<Result<ty::Const<'static>, mir::interpret::LitToConstError>>()];\n+}\n+\n+impl EraseType for Result<mir::ConstantKind<'_>, mir::interpret::LitToConstError> {\n+    type Result =\n+        [u8; size_of::<Result<mir::ConstantKind<'static>, mir::interpret::LitToConstError>>()];\n+}\n+\n+impl EraseType for Result<mir::interpret::ConstAlloc<'_>, mir::interpret::ErrorHandled> {\n+    type Result = [u8; size_of::<\n+        Result<mir::interpret::ConstAlloc<'static>, mir::interpret::ErrorHandled>,\n+    >()];\n+}\n+\n+impl EraseType for Result<mir::interpret::ConstValue<'_>, mir::interpret::ErrorHandled> {\n+    type Result = [u8; size_of::<\n+        Result<mir::interpret::ConstValue<'static>, mir::interpret::ErrorHandled>,\n+    >()];\n+}\n+\n+impl EraseType for Result<Option<ty::ValTree<'_>>, mir::interpret::ErrorHandled> {\n+    type Result =\n+        [u8; size_of::<Result<Option<ty::ValTree<'static>>, mir::interpret::ErrorHandled>>()];\n+}\n+\n+impl EraseType for Result<&'_ ty::List<Ty<'_>>, ty::util::AlwaysRequiresDrop> {\n+    type Result =\n+        [u8; size_of::<Result<&'static ty::List<Ty<'static>>, ty::util::AlwaysRequiresDrop>>()];\n+}\n+\n+impl<T> EraseType for Option<&'_ T> {\n+    type Result = [u8; size_of::<Option<&'static ()>>()];\n+}\n+\n+impl<T> EraseType for Option<&'_ [T]> {\n+    type Result = [u8; size_of::<Option<&'static [()]>>()];\n+}\n+\n+impl EraseType for Option<rustc_middle::hir::Owner<'_>> {\n+    type Result = [u8; size_of::<Option<rustc_middle::hir::Owner<'static>>>()];\n+}\n+\n+impl EraseType for Option<mir::DestructuredConstant<'_>> {\n+    type Result = [u8; size_of::<Option<mir::DestructuredConstant<'static>>>()];\n+}\n+\n+impl EraseType for Option<ty::EarlyBinder<ty::TraitRef<'_>>> {\n+    type Result = [u8; size_of::<Option<ty::EarlyBinder<ty::TraitRef<'static>>>>()];\n+}\n+\n+impl EraseType for Option<ty::EarlyBinder<Ty<'_>>> {\n+    type Result = [u8; size_of::<Option<ty::EarlyBinder<Ty<'static>>>>()];\n+}\n+\n+impl<T> EraseType for rustc_hir::MaybeOwner<&'_ T> {\n+    type Result = [u8; size_of::<rustc_hir::MaybeOwner<&'static ()>>()];\n+}\n+\n+impl<T: EraseType> EraseType for ty::EarlyBinder<T> {\n+    type Result = T::Result;\n+}\n+\n+impl EraseType for ty::Binder<'_, ty::FnSig<'_>> {\n+    type Result = [u8; size_of::<ty::Binder<'static, ty::FnSig<'static>>>()];\n+}\n+\n+impl<T0, T1> EraseType for (&'_ T0, &'_ T1) {\n+    type Result = [u8; size_of::<(&'static (), &'static ())>()];\n+}\n+\n+impl<T0, T1> EraseType for (&'_ T0, &'_ [T1]) {\n+    type Result = [u8; size_of::<(&'static (), &'static [()])>()];\n+}\n+\n+macro_rules! trivial {\n+    ($($ty:ty),+ $(,)?) => {\n+        $(\n+            impl EraseType for $ty {\n+                type Result = [u8; size_of::<$ty>()];\n+            }\n+        )*\n+    }\n+}\n+\n+trivial! {\n+    (),\n+    bool,\n+    Option<(rustc_span::def_id::DefId, rustc_session::config::EntryFnType)>,\n+    Option<rustc_ast::expand::allocator::AllocatorKind>,\n+    Option<rustc_attr::ConstStability>,\n+    Option<rustc_attr::DefaultBodyStability>,\n+    Option<rustc_attr::Stability>,\n+    Option<rustc_data_structures::svh::Svh>,\n+    Option<rustc_hir::def::DefKind>,\n+    Option<rustc_hir::GeneratorKind>,\n+    Option<rustc_hir::HirId>,\n+    Option<rustc_middle::middle::stability::DeprecationEntry>,\n+    Option<rustc_middle::ty::Destructor>,\n+    Option<rustc_middle::ty::ImplTraitInTraitData>,\n+    Option<rustc_span::def_id::CrateNum>,\n+    Option<rustc_span::def_id::DefId>,\n+    Option<rustc_span::def_id::LocalDefId>,\n+    Option<rustc_span::Span>,\n+    Option<rustc_target::spec::PanicStrategy>,\n+    Option<usize>,\n+    Result<(), rustc_errors::ErrorGuaranteed>,\n+    Result<(), rustc_middle::traits::query::NoSolution>,\n+    Result<rustc_middle::traits::EvaluationResult, rustc_middle::traits::OverflowError>,\n+    rustc_ast::expand::allocator::AllocatorKind,\n+    rustc_attr::ConstStability,\n+    rustc_attr::DefaultBodyStability,\n+    rustc_attr::Deprecation,\n+    rustc_attr::Stability,\n+    rustc_data_structures::svh::Svh,\n+    rustc_errors::ErrorGuaranteed,\n+    rustc_hir::Constness,\n+    rustc_hir::def_id::DefId,\n+    rustc_hir::def_id::DefIndex,\n+    rustc_hir::def_id::LocalDefId,\n+    rustc_hir::def::DefKind,\n+    rustc_hir::Defaultness,\n+    rustc_hir::definitions::DefKey,\n+    rustc_hir::GeneratorKind,\n+    rustc_hir::HirId,\n+    rustc_hir::IsAsync,\n+    rustc_hir::ItemLocalId,\n+    rustc_hir::LangItem,\n+    rustc_hir::OwnerId,\n+    rustc_hir::Upvar,\n+    rustc_index::bit_set::FiniteBitSet<u32>,\n+    rustc_middle::metadata::ModChild,\n+    rustc_middle::middle::dependency_format::Linkage,\n+    rustc_middle::middle::exported_symbols::SymbolExportInfo,\n+    rustc_middle::middle::resolve_bound_vars::ObjectLifetimeDefault,\n+    rustc_middle::middle::resolve_bound_vars::ResolvedArg,\n+    rustc_middle::middle::stability::DeprecationEntry,\n+    rustc_middle::mir::ConstQualifs,\n+    rustc_middle::mir::interpret::AllocId,\n+    rustc_middle::mir::interpret::ErrorHandled,\n+    rustc_middle::mir::interpret::LitToConstError,\n+    rustc_middle::thir::ExprId,\n+    rustc_middle::traits::CodegenObligationError,\n+    rustc_middle::traits::EvaluationResult,\n+    rustc_middle::traits::OverflowError,\n+    rustc_middle::traits::query::NoSolution,\n+    rustc_middle::traits::WellFormedLoc,\n+    rustc_middle::ty::adjustment::CoerceUnsizedInfo,\n+    rustc_middle::ty::AssocItem,\n+    rustc_middle::ty::AssocItemContainer,\n+    rustc_middle::ty::BoundVariableKind,\n+    rustc_middle::ty::DeducedParamAttrs,\n+    rustc_middle::ty::Destructor,\n+    rustc_middle::ty::fast_reject::SimplifiedType,\n+    rustc_middle::ty::ImplPolarity,\n+    rustc_middle::ty::Representability,\n+    rustc_middle::ty::ReprOptions,\n+    rustc_middle::ty::UnusedGenericParams,\n+    rustc_middle::ty::util::AlwaysRequiresDrop,\n+    rustc_middle::ty::Visibility<rustc_span::def_id::DefId>,\n+    rustc_session::config::CrateType,\n+    rustc_session::config::EntryFnType,\n+    rustc_session::config::OptLevel,\n+    rustc_session::config::SymbolManglingVersion,\n+    rustc_session::cstore::CrateDepKind,\n+    rustc_session::cstore::ExternCrate,\n+    rustc_session::cstore::LinkagePreference,\n+    rustc_session::Limits,\n+    rustc_session::lint::LintExpectationId,\n+    rustc_span::def_id::CrateNum,\n+    rustc_span::def_id::DefPathHash,\n+    rustc_span::ExpnHash,\n+    rustc_span::ExpnId,\n+    rustc_span::Span,\n+    rustc_span::Symbol,\n+    rustc_span::symbol::Ident,\n+    rustc_target::spec::PanicStrategy,\n+    rustc_type_ir::Variance,\n+    u32,\n+    usize,\n+}\n+\n+macro_rules! tcx_lifetime {\n+    ($($($fake_path:ident)::+),+ $(,)?) => {\n+        $(\n+            impl<'tcx> EraseType for $($fake_path)::+<'tcx> {\n+                type Result = [u8; size_of::<$($fake_path)::+<'static>>()];\n+            }\n+        )*\n+    }\n+}\n+\n+tcx_lifetime! {\n+    rustc_middle::hir::Owner,\n+    rustc_middle::middle::exported_symbols::ExportedSymbol,\n+    rustc_middle::mir::ConstantKind,\n+    rustc_middle::mir::DestructuredConstant,\n+    rustc_middle::mir::interpret::ConstAlloc,\n+    rustc_middle::mir::interpret::ConstValue,\n+    rustc_middle::mir::interpret::GlobalId,\n+    rustc_middle::mir::interpret::LitToConstInput,\n+    rustc_middle::traits::ChalkEnvironmentAndGoal,\n+    rustc_middle::traits::query::MethodAutoderefStepsResult,\n+    rustc_middle::traits::query::type_op::AscribeUserType,\n+    rustc_middle::traits::query::type_op::Eq,\n+    rustc_middle::traits::query::type_op::ProvePredicate,\n+    rustc_middle::traits::query::type_op::Subtype,\n+    rustc_middle::ty::AdtDef,\n+    rustc_middle::ty::AliasTy,\n+    rustc_middle::ty::Clause,\n+    rustc_middle::ty::ClosureTypeInfo,\n+    rustc_middle::ty::Const,\n+    rustc_middle::ty::DestructuredConst,\n+    rustc_middle::ty::ExistentialTraitRef,\n+    rustc_middle::ty::FnSig,\n+    rustc_middle::ty::GenericArg,\n+    rustc_middle::ty::GenericPredicates,\n+    rustc_middle::ty::inhabitedness::InhabitedPredicate,\n+    rustc_middle::ty::Instance,\n+    rustc_middle::ty::InstanceDef,\n+    rustc_middle::ty::layout::FnAbiError,\n+    rustc_middle::ty::layout::LayoutError,\n+    rustc_middle::ty::ParamEnv,\n+    rustc_middle::ty::Predicate,\n+    rustc_middle::ty::SymbolName,\n+    rustc_middle::ty::TraitRef,\n+    rustc_middle::ty::Ty,\n+    rustc_middle::ty::UnevaluatedConst,\n+    rustc_middle::ty::ValTree,\n+    rustc_middle::ty::VtblEntry,\n+}"}, {"sha": "964168967564f5a3f57580d5fbd0e7d79e044e45", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -7,6 +7,7 @@\n use crate::ty::{self, print::describe_as_module, TyCtxt};\n use rustc_span::def_id::LOCAL_CRATE;\n \n+pub mod erase;\n mod keys;\n pub use keys::{AsLocalKey, Key, LocalCrate};\n "}, {"sha": "fa9fea723448660c44ba518a215744a29f87af20", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 23, "deletions": 12, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -17,6 +17,7 @@ use crate::mir::interpret::{\n };\n use crate::mir::interpret::{LitToConstError, LitToConstInput};\n use crate::mir::mono::CodegenUnit;\n+use crate::query::erase::{erase, restore, Erase};\n use crate::query::{AsLocalKey, Key};\n use crate::thir;\n use crate::traits::query::{\n@@ -57,6 +58,8 @@ use rustc_hir::hir_id::OwnerId;\n use rustc_hir::lang_items::{LangItem, LanguageItems};\n use rustc_hir::{Crate, ItemLocalId, TraitCandidate};\n use rustc_index::vec::IndexVec;\n+pub(crate) use rustc_query_system::query::QueryJobId;\n+use rustc_query_system::query::*;\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n@@ -66,18 +69,19 @@ use rustc_span::symbol::Symbol;\n use rustc_span::{Span, DUMMY_SP};\n use rustc_target::abi;\n use rustc_target::spec::PanicStrategy;\n+\n+use std::marker::PhantomData;\n use std::mem;\n use std::ops::Deref;\n use std::path::PathBuf;\n use std::sync::Arc;\n \n-pub(crate) use rustc_query_system::query::QueryJobId;\n-use rustc_query_system::query::*;\n-\n #[derive(Default)]\n pub struct QuerySystem<'tcx> {\n     pub arenas: QueryArenas<'tcx>,\n     pub caches: QueryCaches<'tcx>,\n+    // Since we erase query value types we tell the typesystem about them with `PhantomData`.\n+    _phantom_values: QueryPhantomValues<'tcx>,\n }\n \n #[derive(Copy, Clone)]\n@@ -263,8 +267,8 @@ macro_rules! define_callbacks {\n                 pub fn $name<'tcx>(\n                     _tcx: TyCtxt<'tcx>,\n                     value: query_provided::$name<'tcx>,\n-                ) -> query_values::$name<'tcx> {\n-                    query_if_arena!([$($modifiers)*]\n+                ) -> Erase<query_values::$name<'tcx>> {\n+                    erase(query_if_arena!([$($modifiers)*]\n                         {\n                             if mem::needs_drop::<query_provided::$name<'tcx>>() {\n                                 &*_tcx.query_system.arenas.$name.alloc(value)\n@@ -273,7 +277,7 @@ macro_rules! define_callbacks {\n                             }\n                         }\n                         (value)\n-                    )\n+                    ))\n                 }\n             )*\n         }\n@@ -282,7 +286,7 @@ macro_rules! define_callbacks {\n             use super::*;\n \n             $(\n-                pub type $name<'tcx> = <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, $V>>::Cache;\n+                pub type $name<'tcx> = <<$($K)* as Key>::CacheSelector as CacheSelector<'tcx, Erase<$V>>>::Cache;\n             )*\n         }\n \n@@ -334,6 +338,11 @@ macro_rules! define_callbacks {\n             }\n         }\n \n+        #[derive(Default)]\n+        pub struct QueryPhantomValues<'tcx> {\n+            $($(#[$attr])* pub $name: PhantomData<query_values::$name<'tcx>>,)*\n+        }\n+\n         #[derive(Default)]\n         pub struct QueryCaches<'tcx> {\n             $($(#[$attr])* pub $name: query_storage::$name<'tcx>,)*\n@@ -395,10 +404,10 @@ macro_rules! define_callbacks {\n                 let key = key.into_query_param();\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n-                match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n+                restore::<$V>(match try_get_cached(self.tcx, &self.tcx.query_system.caches.$name, &key) {\n                     Some(value) => value,\n                     None => self.tcx.queries.$name(self.tcx, self.span, key, QueryMode::Get).unwrap(),\n-                }\n+                })\n             })*\n         }\n \n@@ -459,7 +468,7 @@ macro_rules! define_callbacks {\n                 span: Span,\n                 key: query_keys::$name<'tcx>,\n                 mode: QueryMode,\n-            ) -> Option<$V>;)*\n+            ) -> Option<Erase<$V>>;)*\n         }\n     };\n }\n@@ -486,11 +495,13 @@ macro_rules! define_feedable {\n                 opt_remap_env_constness!([$($modifiers)*][key]);\n \n                 let tcx = self.tcx;\n-                let value = query_provided_to_value::$name(tcx, value);\n+                let erased = query_provided_to_value::$name(tcx, value);\n+                let value = restore::<$V>(erased);\n                 let cache = &tcx.query_system.caches.$name;\n \n                 match try_get_cached(tcx, cache, &key) {\n                     Some(old) => {\n+                        let old = restore::<$V>(old);\n                         bug!(\n                             \"Trying to feed an already recorded value for query {} key={key:?}:\\nold value: {old:?}\\nnew value: {value:?}\",\n                             stringify!($name),\n@@ -505,7 +516,7 @@ macro_rules! define_feedable {\n                             &value,\n                             hash_result!([$($modifiers)*]),\n                         );\n-                        cache.complete(key, value, dep_node_index);\n+                        cache.complete(key, erased, dep_node_index);\n                         value\n                     }\n                 }"}, {"sha": "7001a1eed57e711fdb3ceb7032d661391dbd1fda", "filename": "compiler/rustc_query_impl/src/lib.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Flib.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -18,19 +18,21 @@ extern crate rustc_middle;\n \n use rustc_data_structures::sync::AtomicU64;\n use rustc_middle::arena::Arena;\n-use rustc_middle::dep_graph::{self, DepKindStruct};\n+use rustc_middle::dep_graph::{self, DepKind, DepKindStruct};\n+use rustc_middle::query::erase::{erase, restore, Erase};\n use rustc_middle::query::AsLocalKey;\n use rustc_middle::ty::query::{\n     query_keys, query_provided, query_provided_to_value, query_storage, query_values,\n };\n use rustc_middle::ty::query::{ExternProviders, Providers, QueryEngine};\n use rustc_middle::ty::TyCtxt;\n+use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n+use rustc_query_system::Value;\n use rustc_span::Span;\n \n #[macro_use]\n mod plumbing;\n pub use plumbing::QueryCtxt;\n-use rustc_query_system::dep_graph::SerializedDepNodeIndex;\n use rustc_query_system::query::*;\n #[cfg(parallel_compiler)]\n pub use rustc_query_system::query::{deadlock, QueryContext};\n@@ -43,6 +45,13 @@ pub use on_disk_cache::OnDiskCache;\n mod profiling_support;\n pub use self::profiling_support::alloc_self_profile_query_strings;\n \n+/// This is implemented per query and restoring query values from their erased state.\n+trait QueryConfigRestored<'tcx>: QueryConfig<QueryCtxt<'tcx>> + Default {\n+    type RestoredValue;\n+\n+    fn restore(value: <Self as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue;\n+}\n+\n rustc_query_append! { define_queries! }\n \n impl<'tcx> Queries<'tcx> {"}, {"sha": "eec9dac7b9b0c6ee73119bac785f1d09b843651e", "filename": "compiler/rustc_query_impl/src/on_disk_cache.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fon_disk_cache.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -1064,14 +1064,14 @@ impl<'a, 'tcx> Encodable<CacheEncoder<'a, 'tcx>> for [u8] {\n     }\n }\n \n-pub fn encode_query_results<'a, 'tcx, Q>(\n+pub(crate) fn encode_query_results<'a, 'tcx, Q>(\n     query: Q,\n     qcx: QueryCtxt<'tcx>,\n     encoder: &mut CacheEncoder<'a, 'tcx>,\n     query_result_index: &mut EncodedDepNodeIndex,\n ) where\n-    Q: super::QueryConfig<QueryCtxt<'tcx>>,\n-    Q::Value: Encodable<CacheEncoder<'a, 'tcx>>,\n+    Q: super::QueryConfigRestored<'tcx>,\n+    Q::RestoredValue: Encodable<CacheEncoder<'a, 'tcx>>,\n {\n     let _timer = qcx\n         .tcx\n@@ -1089,7 +1089,7 @@ pub fn encode_query_results<'a, 'tcx, Q>(\n \n             // Encode the type check tables with the `SerializedDepNodeIndex`\n             // as tag.\n-            encoder.encode_tagged(dep_node, value);\n+            encoder.encode_tagged(dep_node, &Q::restore(*value));\n         }\n     });\n }"}, {"sha": "afbead7d1ae97cb486f3611fbdf4df7b47e43080", "filename": "compiler/rustc_query_impl/src/plumbing.rs", "status": "modified", "additions": 36, "deletions": 12, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fplumbing.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -263,14 +263,14 @@ macro_rules! feedable {\n }\n \n macro_rules! hash_result {\n-    ([]) => {{\n-        Some(dep_graph::hash_result)\n+    ([][$V:ty]) => {{\n+        Some(|hcx, result| dep_graph::hash_result(hcx, &restore::<$V>(*result)))\n     }};\n-    ([(no_hash) $($rest:tt)*]) => {{\n+    ([(no_hash) $($rest:tt)*][$V:ty]) => {{\n         None\n     }};\n-    ([$other:tt $($modifiers:tt)*]) => {\n-        hash_result!([$($modifiers)*])\n+    ([$other:tt $($modifiers:tt)*][$($args:tt)*]) => {\n+        hash_result!([$($modifiers)*][$($args)*])\n     };\n }\n \n@@ -479,13 +479,18 @@ macro_rules! define_queries {\n \n         $(impl<'tcx> QueryConfig<QueryCtxt<'tcx>> for queries::$name<'tcx> {\n             type Key = query_keys::$name<'tcx>;\n-            type Value = query_values::$name<'tcx>;\n+            type Value = Erase<query_values::$name<'tcx>>;\n \n             #[inline(always)]\n             fn name(self) -> &'static str {\n                 stringify!($name)\n             }\n \n+            #[inline]\n+            fn format_value(self) -> fn(&Self::Value) -> String {\n+                |value| format!(\"{:?}\", restore::<query_values::$name<'tcx>>(*value))\n+            }\n+\n             #[inline]\n             fn cache_on_disk(self, tcx: TyCtxt<'tcx>, key: &Self::Key) -> bool {\n                 ::rustc_middle::query::cached::$name(tcx, key)\n@@ -508,7 +513,7 @@ macro_rules! define_queries {\n             }\n \n             fn execute_query(self, tcx: TyCtxt<'tcx>, key: Self::Key) -> Self::Value {\n-                tcx.$name(key)\n+                erase(tcx.$name(key))\n             }\n \n             #[inline]\n@@ -558,6 +563,16 @@ macro_rules! define_queries {\n                 })\n             }\n \n+            #[inline]\n+            fn value_from_cycle_error(\n+                self,\n+                tcx: TyCtxt<'tcx>,\n+                cycle: &[QueryInfo<DepKind>],\n+            ) -> Self::Value {\n+                let result: query_values::$name<'tcx> = Value::from_cycle_error(tcx, cycle);\n+                erase(result)\n+            }\n+\n             #[inline(always)]\n             fn anon(self) -> bool {\n                 is_anon!([$($modifiers)*])\n@@ -590,7 +605,16 @@ macro_rules! define_queries {\n \n             #[inline(always)]\n             fn hash_result(self) -> rustc_query_system::query::HashResult<Self::Value> {\n-                hash_result!([$($modifiers)*])\n+                hash_result!([$($modifiers)*][query_values::$name<'tcx>])\n+            }\n+        })*\n+\n+        $(impl<'tcx> QueryConfigRestored<'tcx> for queries::$name<'tcx> {\n+            type RestoredValue = query_values::$name<'tcx>;\n+\n+            #[inline(always)]\n+            fn restore(value: <Self as QueryConfig<QueryCtxt<'tcx>>>::Value) -> Self::RestoredValue {\n+                restore::<query_values::$name<'tcx>>(value)\n             }\n         })*\n \n@@ -708,7 +732,7 @@ macro_rules! define_queries {\n                     )\n                 },\n                 encode_query_results: expand_if_cached!([$($modifiers)*], |qcx, encoder, query_result_index|\n-                    $crate::on_disk_cache::encode_query_results(\n+                    $crate::on_disk_cache::encode_query_results::<super::queries::$name<'tcx>>(\n                         super::queries::$name::default(),\n                         qcx,\n                         encoder,\n@@ -793,14 +817,14 @@ macro_rules! define_queries_struct {\n \n             $($(#[$attr])*\n             #[inline(always)]\n-            #[tracing::instrument(level = \"trace\", skip(self, tcx), ret)]\n+            #[tracing::instrument(level = \"trace\", skip(self, tcx))]\n             fn $name(\n                 &'tcx self,\n                 tcx: TyCtxt<'tcx>,\n                 span: Span,\n-                key: <queries::$name<'tcx> as QueryConfig<QueryCtxt<'tcx>>>::Key,\n+                key: query_keys::$name<'tcx>,\n                 mode: QueryMode,\n-            ) -> Option<query_values::$name<'tcx>> {\n+            ) -> Option<Erase<query_values::$name<'tcx>>> {\n                 let qcx = QueryCtxt { tcx, queries: self };\n                 get_query(\n                     queries::$name::default(),"}, {"sha": "534d13b1ae0f4a643c11022f56614c30649f259f", "filename": "compiler/rustc_query_system/src/dep_graph/graph.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fgraph.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -538,7 +538,14 @@ impl<K: DepKind> DepGraph<K> {\n             if let Some(prev_index) = data.previous.node_to_index_opt(&node) {\n                 let dep_node_index = data.current.prev_index_to_index.lock()[prev_index];\n                 if let Some(dep_node_index) = dep_node_index {\n-                    crate::query::incremental_verify_ich(cx, data, result, prev_index, hash_result);\n+                    crate::query::incremental_verify_ich(\n+                        cx,\n+                        data,\n+                        result,\n+                        prev_index,\n+                        hash_result,\n+                        |value| format!(\"{:?}\", value),\n+                    );\n \n                     #[cfg(debug_assertions)]\n                     if hash_result.is_some() {"}, {"sha": "3ac8a852a4e77b7dd993df9915912f1f003cde52", "filename": "compiler/rustc_query_system/src/query/caches.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fcaches.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -18,7 +18,7 @@ pub trait CacheSelector<'tcx, V> {\n \n pub trait QueryCache: Sized {\n     type Key: Hash + Eq + Copy + Debug;\n-    type Value: Copy + Debug;\n+    type Value: Copy;\n \n     /// Checks if the query is already computed and in the cache.\n     fn lookup(&self, key: &Self::Key) -> Option<(Self::Value, DepNodeIndex)>;\n@@ -52,7 +52,7 @@ impl<K, V> Default for DefaultCache<K, V> {\n impl<K, V> QueryCache for DefaultCache<K, V>\n where\n     K: Eq + Hash + Copy + Debug,\n-    V: Copy + Debug,\n+    V: Copy,\n {\n     type Key = K;\n     type Value = V;\n@@ -120,7 +120,7 @@ impl<V> Default for SingleCache<V> {\n \n impl<V> QueryCache for SingleCache<V>\n where\n-    V: Copy + Debug,\n+    V: Copy,\n {\n     type Key = ();\n     type Value = V;\n@@ -164,7 +164,7 @@ impl<K: Idx, V> Default for VecCache<K, V> {\n impl<K, V> QueryCache for VecCache<K, V>\n where\n     K: Eq + Idx + Copy + Debug,\n-    V: Copy + Debug,\n+    V: Copy,\n {\n     type Key = K;\n     type Value = V;"}, {"sha": "c8d779385108f04dad64cf91e2fe5713f590fc5d", "filename": "compiler/rustc_query_system/src/query/config.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fconfig.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -4,7 +4,7 @@ use crate::dep_graph::{DepNode, DepNodeParams, SerializedDepNodeIndex};\n use crate::error::HandleCycleError;\n use crate::ich::StableHashingContext;\n use crate::query::caches::QueryCache;\n-use crate::query::{QueryContext, QueryState};\n+use crate::query::{QueryContext, QueryInfo, QueryState};\n \n use rustc_data_structures::fingerprint::Fingerprint;\n use std::fmt::Debug;\n@@ -20,10 +20,12 @@ pub trait QueryConfig<Qcx: QueryContext>: Copy {\n     // `Key` and `Value` are `Copy` instead of `Clone` to ensure copying them stays cheap,\n     // but it isn't necessary.\n     type Key: DepNodeParams<Qcx::DepContext> + Eq + Hash + Copy + Debug;\n-    type Value: Debug + Copy;\n+    type Value: Copy;\n \n     type Cache: QueryCache<Key = Self::Key, Value = Self::Value>;\n \n+    fn format_value(self) -> fn(&Self::Value) -> String;\n+\n     // Don't use this method to access query results, instead use the methods on TyCtxt\n     fn query_state<'a>(self, tcx: Qcx) -> &'a QueryState<Self::Key, Qcx::DepKind>\n     where\n@@ -45,6 +47,13 @@ pub trait QueryConfig<Qcx: QueryContext>: Copy {\n \n     fn loadable_from_disk(self, qcx: Qcx, key: &Self::Key, idx: SerializedDepNodeIndex) -> bool;\n \n+    /// Synthesize an error value to let compilation continue after a cycle.\n+    fn value_from_cycle_error(\n+        self,\n+        tcx: Qcx::DepContext,\n+        cycle: &[QueryInfo<Qcx::DepKind>],\n+    ) -> Self::Value;\n+\n     fn anon(self) -> bool;\n     fn eval_always(self) -> bool;\n     fn depth_limit(self) -> bool;"}, {"sha": "20310483d7e86b2fb2262b2d9b39cabda9aa1471", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f5b8f44e5d5dee0f60cec1729b5a107659779d94/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=f5b8f44e5d5dee0f60cec1729b5a107659779d94", "patch": "@@ -11,7 +11,6 @@ use crate::query::job::QueryLatch;\n use crate::query::job::{report_cycle, QueryInfo, QueryJob, QueryJobId, QueryJobInfo};\n use crate::query::SerializedDepNodeIndex;\n use crate::query::{QueryContext, QueryMap, QuerySideEffects, QueryStackFrame};\n-use crate::values::Value;\n use crate::HandleCycleError;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::fx::FxHashMap;\n@@ -120,43 +119,45 @@ where\n \n #[cold]\n #[inline(never)]\n-fn mk_cycle<Qcx, R, D: DepKind>(\n+fn mk_cycle<Q, Qcx>(\n+    query: Q,\n     qcx: Qcx,\n-    cycle_error: CycleError<D>,\n+    cycle_error: CycleError<Qcx::DepKind>,\n     handler: HandleCycleError,\n-) -> R\n+) -> Q::Value\n where\n-    Qcx: QueryContext + HasDepContext<DepKind = D>,\n-    R: std::fmt::Debug + Value<Qcx::DepContext, Qcx::DepKind>,\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n {\n     let error = report_cycle(qcx.dep_context().sess(), &cycle_error);\n-    handle_cycle_error(*qcx.dep_context(), &cycle_error, error, handler)\n+    handle_cycle_error(query, qcx, &cycle_error, error, handler)\n }\n \n-fn handle_cycle_error<Tcx, V>(\n-    tcx: Tcx,\n-    cycle_error: &CycleError<Tcx::DepKind>,\n+fn handle_cycle_error<Q, Qcx>(\n+    query: Q,\n+    qcx: Qcx,\n+    cycle_error: &CycleError<Qcx::DepKind>,\n     mut error: DiagnosticBuilder<'_, ErrorGuaranteed>,\n     handler: HandleCycleError,\n-) -> V\n+) -> Q::Value\n where\n-    Tcx: DepContext,\n-    V: Value<Tcx, Tcx::DepKind>,\n+    Q: QueryConfig<Qcx>,\n+    Qcx: QueryContext,\n {\n     use HandleCycleError::*;\n     match handler {\n         Error => {\n             error.emit();\n-            Value::from_cycle_error(tcx, &cycle_error.cycle)\n+            query.value_from_cycle_error(*qcx.dep_context(), &cycle_error.cycle)\n         }\n         Fatal => {\n             error.emit();\n-            tcx.sess().abort_if_errors();\n+            qcx.dep_context().sess().abort_if_errors();\n             unreachable!()\n         }\n         DelayBug => {\n             error.delay_as_bug();\n-            Value::from_cycle_error(tcx, &cycle_error.cycle)\n+            query.value_from_cycle_error(*qcx.dep_context(), &cycle_error.cycle)\n         }\n     }\n }\n@@ -269,7 +270,7 @@ where\n         &qcx.current_query_job(),\n         span,\n     );\n-    (mk_cycle(qcx, error, query.handle_cycle_error()), None)\n+    (mk_cycle(query, qcx, error, query.handle_cycle_error()), None)\n }\n \n #[inline(always)]\n@@ -306,7 +307,7 @@ where\n \n             (v, Some(index))\n         }\n-        Err(cycle) => (mk_cycle(qcx, cycle, query.handle_cycle_error()), None),\n+        Err(cycle) => (mk_cycle(query, qcx, cycle, query.handle_cycle_error()), None),\n     }\n }\n \n@@ -410,7 +411,8 @@ where\n         // get evaluated first, and re-feed the query.\n         if let Some((cached_result, _)) = cache.lookup(&key) {\n             panic!(\n-                \"fed query later has its value computed. The already cached value: {cached_result:?}\"\n+                \"fed query later has its value computed. The already cached value: {}\",\n+                (query.format_value())(&cached_result)\n             );\n         }\n     }\n@@ -581,6 +583,7 @@ where\n                     &result,\n                     prev_dep_node_index,\n                     query.hash_result(),\n+                    query.format_value(),\n                 );\n             }\n \n@@ -626,19 +629,21 @@ where\n         &result,\n         prev_dep_node_index,\n         query.hash_result(),\n+        query.format_value(),\n     );\n \n     Some((result, dep_node_index))\n }\n \n #[inline]\n-#[instrument(skip(tcx, dep_graph_data, result, hash_result), level = \"debug\")]\n-pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n+#[instrument(skip(tcx, dep_graph_data, result, hash_result, format_value), level = \"debug\")]\n+pub(crate) fn incremental_verify_ich<Tcx, V>(\n     tcx: Tcx,\n     dep_graph_data: &DepGraphData<Tcx::DepKind>,\n     result: &V,\n     prev_index: SerializedDepNodeIndex,\n     hash_result: Option<fn(&mut StableHashingContext<'_>, &V) -> Fingerprint>,\n+    format_value: fn(&V) -> String,\n ) where\n     Tcx: DepContext,\n {\n@@ -653,7 +658,7 @@ pub(crate) fn incremental_verify_ich<Tcx, V: Debug>(\n     let old_hash = dep_graph_data.prev_fingerprint_of(prev_index);\n \n     if new_hash != old_hash {\n-        incremental_verify_ich_failed(tcx, prev_index, result);\n+        incremental_verify_ich_failed(tcx, prev_index, &|| format_value(&result));\n     }\n }\n \n@@ -677,7 +682,7 @@ where\n fn incremental_verify_ich_failed<Tcx>(\n     tcx: Tcx,\n     prev_index: SerializedDepNodeIndex,\n-    result: &dyn Debug,\n+    result: &dyn Fn() -> String,\n ) where\n     Tcx: DepContext,\n {\n@@ -707,7 +712,7 @@ fn incremental_verify_ich_failed<Tcx>(\n             run_cmd,\n             dep_node: format!(\"{dep_node:?}\"),\n         });\n-        panic!(\"Found unstable fingerprints for {dep_node:?}: {result:?}\");\n+        panic!(\"Found unstable fingerprints for {dep_node:?}: {}\", result());\n     }\n \n     INSIDE_VERIFY_PANIC.with(|in_panic| in_panic.set(old_in_panic));"}]}