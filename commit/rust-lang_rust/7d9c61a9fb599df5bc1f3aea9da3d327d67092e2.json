{"sha": "7d9c61a9fb599df5bc1f3aea9da3d327d67092e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdkOWM2MWE5ZmI1OTlkZjViYzFmM2FlYTlkYTNkMzI3ZDY3MDkyZTI=", "commit": {"author": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-02T03:38:37Z"}, "committer": {"name": "Ben Blum", "email": "bblum@andrew.cmu.edu", "date": "2012-08-02T03:39:44Z"}, "message": "Linked failure touchups (#1868)", "tree": {"sha": "516d6d531483145fb013760b7536c20127806803", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/516d6d531483145fb013760b7536c20127806803"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7d9c61a9fb599df5bc1f3aea9da3d327d67092e2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7d9c61a9fb599df5bc1f3aea9da3d327d67092e2", "html_url": "https://github.com/rust-lang/rust/commit/7d9c61a9fb599df5bc1f3aea9da3d327d67092e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7d9c61a9fb599df5bc1f3aea9da3d327d67092e2/comments", "author": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bblum", "id": 1820515, "node_id": "MDQ6VXNlcjE4MjA1MTU=", "avatar_url": "https://avatars.githubusercontent.com/u/1820515?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bblum", "html_url": "https://github.com/bblum", "followers_url": "https://api.github.com/users/bblum/followers", "following_url": "https://api.github.com/users/bblum/following{/other_user}", "gists_url": "https://api.github.com/users/bblum/gists{/gist_id}", "starred_url": "https://api.github.com/users/bblum/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bblum/subscriptions", "organizations_url": "https://api.github.com/users/bblum/orgs", "repos_url": "https://api.github.com/users/bblum/repos", "events_url": "https://api.github.com/users/bblum/events{/privacy}", "received_events_url": "https://api.github.com/users/bblum/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac0c8b08233b8654aa69a0902bacd7be40072c54", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac0c8b08233b8654aa69a0902bacd7be40072c54", "html_url": "https://github.com/rust-lang/rust/commit/ac0c8b08233b8654aa69a0902bacd7be40072c54"}], "stats": {"total": 69, "additions": 41, "deletions": 28}, "files": [{"sha": "fd0789d6e5007e26c75174d7aac13edc4b986528", "filename": "src/libcore/task.rs", "status": "modified", "additions": 41, "deletions": 28, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/7d9c61a9fb599df5bc1f3aea9da3d327d67092e2/src%2Flibcore%2Ftask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7d9c61a9fb599df5bc1f3aea9da3d327d67092e2/src%2Flibcore%2Ftask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftask.rs?ref=7d9c61a9fb599df5bc1f3aea9da3d327d67092e2", "patch": "@@ -185,13 +185,12 @@ type task_opts = {\n // when you try to reuse the builder to spawn a new task. We'll just\n // sidestep that whole issue by making builders uncopyable and making\n // the run function move them in.\n-class dummy { let x: (); new() { self.x = (); } drop { } }\n \n // FIXME (#2585): Replace the 'consumed' bit with move mode on self\n enum task_builder = {\n     opts: task_opts,\n     gen_body: fn@(+fn~()) -> fn~(),\n-    can_not_copy: option<dummy>,\n+    can_not_copy: option<util::noncopyable>,\n     mut consumed: bool,\n };\n \n@@ -598,8 +597,8 @@ unsafe fn atomically<U>(f: fn() -> U) -> U {\n  *\n  *     A new one of these is created each spawn_linked or spawn_supervised.\n  *\n- * (2) The \"taskgroup\" is a per-task control structure that tracks a task's\n- *     spawn configuration. It contains a reference to its taskgroup_arc,\n+ * (2) The \"tcb\" is a per-task control structure that tracks a task's spawn\n+ *     configuration. It contains a reference to its taskgroup_arc, a\n  *     a reference to its node in the ancestor list (below), a flag for\n  *     whether it's part of the 'main'/'root' taskgroup, and an optionally\n  *     configured notification port. These are stored in TLS.\n@@ -641,8 +640,8 @@ unsafe fn atomically<U>(f: fn() -> U) -> U {\n  *       (  E  )- - - - - - - > | {E}  {} |\n  *        \\___/                 |_________|\n  *\n- *     \"taskgroup\"            \"taskgroup_arc\"\n- *              \"ancestor_list\"\n+ *        \"tcb\"               \"taskgroup_arc\"\n+ *             \"ancestor_list\"\n  *\n  ****************************************************************************/\n \n@@ -694,6 +693,7 @@ type taskgroup_arc = arc::exclusive<option<taskgroup_data>>;\n \n type taskgroup_inner = &mut option<taskgroup_data>;\n \n+// A taskgroup is 'dead' when nothing can cause it to fail; only members can.\n fn taskgroup_is_dead(tg: taskgroup_data) -> bool {\n     (&mut tg.members).is_empty()\n }\n@@ -705,7 +705,7 @@ fn taskgroup_is_dead(tg: taskgroup_data) -> bool {\n // taskgroup which was spawned-unlinked. Tasks from intermediate generations\n // have references to the middle of the list; when intermediate generations\n // die, their node in the list will be collected at a descendant's spawn-time.\n-enum ancestor_list = option<arc::exclusive<{\n+type ancestor_node = {\n     // Since the ancestor list is recursive, we end up with references to\n     // exclusives within other exclusives. This is dangerous business (if\n     // circular references arise, deadlock and memory leaks are imminent).\n@@ -717,7 +717,19 @@ enum ancestor_list = option<arc::exclusive<{\n     mut parent_group: option<taskgroup_arc>,\n     // Recursive rest of the list.\n     mut ancestors:    ancestor_list,\n-}>>;\n+};\n+enum ancestor_list = option<arc::exclusive<ancestor_node>>;\n+\n+// Accessors for taskgroup arcs and ancestor arcs that wrap the unsafety.\n+#[inline(always)]\n+fn access_group<U>(x: taskgroup_arc, blk: fn(taskgroup_inner) -> U) -> U {\n+    unsafe { x.with(|_c, tg| blk(tg)) }\n+}\n+#[inline(always)]\n+fn access_ancestors<U>(x: arc::exclusive<ancestor_node>,\n+                       blk: fn(x: &mut ancestor_node) -> U) -> U {\n+    unsafe { x.with(|_c, nobe| blk(nobe)) }\n+}\n \n // Iterates over an ancestor list.\n // (1) Runs forward_blk on each ancestral taskgroup in the list\n@@ -782,7 +794,7 @@ fn each_ancestor(list:        &mut ancestor_list,\n         // the end of the list, which doesn't make sense to coalesce.\n         return do (*ancestors).map_default((none,false)) |ancestor_arc| {\n             // NB: Takes a lock! (this ancestor node)\n-            do ancestor_arc.with |_c, nobe| {\n+            do access_ancestors(ancestor_arc) |nobe| {\n                 // Check monotonicity\n                 assert last_generation > nobe.generation;\n                 /*##########################################################*\n@@ -847,15 +859,15 @@ fn each_ancestor(list:        &mut ancestor_list,\n             // If this trips, more likely the problem is 'blk' failed inside.\n             assert tmp.is_some();\n             let tmp_arc = option::unwrap(tmp);\n-            let result = do tmp_arc.with |_c, tg_opt| { blk(tg_opt) };\n+            let result = do access_group(tmp_arc) |tg_opt| { blk(tg_opt) };\n             *parent_group <- some(tmp_arc);\n             result\n         }\n     }\n }\n \n // One of these per task.\n-class taskgroup {\n+class tcb {\n     let me:            *rust_task;\n     // List of tasks with whose fates this one's is intertwined.\n     let tasks:         taskgroup_arc; // 'none' means the group has failed.\n@@ -878,12 +890,12 @@ class taskgroup {\n         if rustrt::rust_task_is_unwinding(self.me) {\n             self.notifier.iter(|x| { x.failed = true; });\n             // Take everybody down with us.\n-            do self.tasks.with |_c, tg| {\n+            do access_group(self.tasks) |tg| {\n                 kill_taskgroup(tg, self.me, self.is_main);\n             }\n         } else {\n             // Remove ourselves from the group(s).\n-            do self.tasks.with |_c, tg| {\n+            do access_group(self.tasks) |tg| {\n                 leave_taskgroup(tg, self.me, true);\n             }\n         }\n@@ -977,7 +989,7 @@ fn kill_taskgroup(state: taskgroup_inner, me: *rust_task, is_main: bool) {\n \n // FIXME (#2912): Work around core-vs-coretest function duplication. Can't use\n // a proper closure because the #[test]s won't understand. Have to fake it.\n-unsafe fn taskgroup_key() -> local_data_key<taskgroup> {\n+unsafe fn taskgroup_key() -> local_data_key<tcb> {\n     // Use a \"code pointer\" value that will never be a real code pointer.\n     unsafe::transmute((-2 as uint, 0u))\n }\n@@ -998,13 +1010,12 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n                                       mut descendants: new_taskset() }));\n             // Main task/group has no ancestors, no notifier, etc.\n             let group =\n-                @taskgroup(spawner, tasks, ancestor_list(none), true, none);\n+                @tcb(spawner, tasks, ancestor_list(none), true, none);\n             unsafe { local_set(spawner, taskgroup_key(), group); }\n             group\n         }\n         some(group) { group }\n     };\n-    //for each_ancestor(&mut spawner_group.ancestors, none) |_a| { };\n     /*######################################################################*\n      * Step 2. Process spawn options for child.\n      *######################################################################*/\n@@ -1027,7 +1038,7 @@ fn gen_child_taskgroup(linked: bool, supervised: bool)\n             // it should be enabled only in debug builds.\n             let new_generation =\n                 alt *old_ancestors {\n-                    some(arc) { do arc.with |_c,nobe| { nobe.generation+1 } }\n+                    some(arc) { access_ancestors(arc, |a| a.generation+1) }\n                     none      { 0 } // the actual value doesn't really matter.\n                 };\n             assert new_generation < uint::max_value;\n@@ -1118,8 +1129,8 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n             let notifier = notify_chan.map(|c| auto_notify(c));\n \n             if enlist_many(child, child_arc, &mut ancestors) {\n-                let group = @taskgroup(child, child_arc, ancestors,\n-                                       is_main, notifier);\n+                let group = @tcb(child, child_arc, ancestors,\n+                                 is_main, notifier);\n                 unsafe { local_set(child, taskgroup_key(), group); }\n                 // Run the child's body.\n                 f();\n@@ -1134,7 +1145,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n                        ancestors: &mut ancestor_list) -> bool {\n             // Join this taskgroup.\n             let mut result =\n-                do child_arc.with |_c, child_tg| {\n+                do access_group(child_arc) |child_tg| {\n                     enlist_in_taskgroup(child_tg, child, true) // member\n                 };\n             if result {\n@@ -1151,7 +1162,7 @@ fn spawn_raw(opts: task_opts, +f: fn~()) {\n                     };\n                 // If any ancestor group fails, need to exit this group too.\n                 if !result {\n-                    do child_arc.with |_c, child_tg| {\n+                    do access_group(child_arc) |child_tg| {\n                         leave_taskgroup(child_tg, child, true); // member\n                     }\n                 }\n@@ -1485,7 +1496,7 @@ fn test_spawn_unlinked_unsup_no_fail_down() { // grandchild sends on a port\n     do spawn_unlinked {\n         do spawn_unlinked {\n             // Give middle task a chance to fail-but-not-kill-us.\n-            for iter::repeat(128) { task::yield(); }\n+            for iter::repeat(16) { task::yield(); }\n             comm::send(ch, ()); // If killed first, grandparent hangs.\n         }\n         fail; // Shouldn't kill either (grand)parent or (grand)child.\n@@ -1500,7 +1511,7 @@ fn test_spawn_unlinked_unsup_no_fail_up() { // child unlinked fails\n fn test_spawn_unlinked_sup_no_fail_up() { // child unlinked fails\n     do spawn_supervised { fail; }\n     // Give child a chance to fail-but-not-kill-us.\n-    for iter::repeat(128) { task::yield(); }\n+    for iter::repeat(16) { task::yield(); }\n }\n #[test] #[should_fail] #[ignore(cfg(windows))]\n fn test_spawn_unlinked_sup_fail_down() {\n@@ -1569,7 +1580,7 @@ fn test_spawn_failure_propagate_grandchild() {\n             loop { task::yield(); }\n         }\n     }\n-    for iter::repeat(128) { task::yield(); }\n+    for iter::repeat(16) { task::yield(); }\n     fail;\n }\n \n@@ -1581,7 +1592,7 @@ fn test_spawn_failure_propagate_secondborn() {\n             loop { task::yield(); }\n         }\n     }\n-    for iter::repeat(128) { task::yield(); }\n+    for iter::repeat(16) { task::yield(); }\n     fail;\n }\n \n@@ -1593,7 +1604,7 @@ fn test_spawn_failure_propagate_nephew_or_niece() {\n             loop { task::yield(); }\n         }\n     }\n-    for iter::repeat(128) { task::yield(); }\n+    for iter::repeat(16) { task::yield(); }\n     fail;\n }\n \n@@ -1605,7 +1616,7 @@ fn test_spawn_linked_sup_propagate_sibling() {\n             loop { task::yield(); }\n         }\n     }\n-    for iter::repeat(128) { task::yield(); }\n+    for iter::repeat(16) { task::yield(); }\n     fail;\n }\n \n@@ -2006,7 +2017,9 @@ fn test_atomically_nested() {\n fn test_child_doesnt_ref_parent() {\n     // If the child refcounts the parent task, this will stack overflow when\n     // climbing the task tree to dereference each ancestor. (See #1789)\n-    const generations: uint = 128;\n+    // (well, it would if the constant were 8000+ - I lowered it to be more\n+    // valgrind-friendly. try this at home, instead..!)\n+    const generations: uint = 16;\n     fn child_no(x: uint) -> fn~() {\n         return || {\n             if x < generations {"}]}