{"sha": "119193497e48f686457bac7c3114d6f1877b7cfe", "node_id": "MDY6Q29tbWl0NzI0NzEyOjExOTE5MzQ5N2U0OGY2ODY0NTdiYWM3YzMxMTRkNmYxODc3YjdjZmU=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T22:53:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-27T23:30:27Z"}, "message": "Extract metadata::decoder from metadata::creader", "tree": {"sha": "0961df8911680c3edf1fd436c4840d5fb1df3925", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0961df8911680c3edf1fd436c4840d5fb1df3925"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/119193497e48f686457bac7c3114d6f1877b7cfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/119193497e48f686457bac7c3114d6f1877b7cfe", "html_url": "https://github.com/rust-lang/rust/commit/119193497e48f686457bac7c3114d6f1877b7cfe", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/119193497e48f686457bac7c3114d6f1877b7cfe/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a3a2cc3d9851aef277df40c5f53998ec72181686", "url": "https://api.github.com/repos/rust-lang/rust/commits/a3a2cc3d9851aef277df40c5f53998ec72181686", "html_url": "https://github.com/rust-lang/rust/commit/a3a2cc3d9851aef277df40c5f53998ec72181686"}], "stats": {"total": 569, "additions": 295, "deletions": 274}, "files": [{"sha": "e46b2585b1e5d1ed8be6c45f491ee81d31fe766d", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 3, "deletions": 267, "changes": 270, "blob_url": "https://github.com/rust-lang/rust/blob/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=119193497e48f686457bac7c3114d6f1877b7cfe", "patch": "@@ -9,148 +9,22 @@ import lib::llvm::mk_object_file;\n import lib::llvm::mk_section_iter;\n import middle::resolve;\n import middle::walk;\n-import cwriter;\n-import middle::trans;\n-import middle::ty;\n import back::x86;\n import util::common;\n import std::str;\n-import std::uint;\n import std::vec;\n import std::ebml;\n import std::fs;\n import std::io;\n import std::option;\n import std::option::none;\n import std::option::some;\n-import std::os;\n import std::map::hashmap;\n import defs::*;\n-import tydecode::parse_def_id;\n-import tydecode::parse_ty_data;\n \n-export get_symbol;\n-export get_tag_variants;\n-export get_type;\n export read_crates;\n-export lookup_defs;\n-export get_type;\n export list_file_metadata;\n \n-\n-fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool  eq_fn, uint hash) ->\n-   vec[ebml::doc] {\n-    auto index = ebml::get_doc(d, tag_index);\n-    auto table = ebml::get_doc(index, tag_index_table);\n-    auto hash_pos = table.start + hash % 256u * 4u;\n-    auto pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n-    auto bucket = ebml::doc_at(d.data, pos);\n-    // Awkward logic because we can't ret from foreach yet\n-\n-    let vec[ebml::doc] result = [];\n-    auto belt = tag_index_buckets_bucket_elt;\n-    for each (ebml::doc elt in ebml::tagged_docs(bucket, belt)) {\n-        auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n-        if (eq_fn(vec::slice[u8](elt.data, elt.start + 4u, elt.end))) {\n-            vec::push(result, ebml::doc_at(d.data, pos));\n-        }\n-    }\n-    ret result;\n-}\n-\n-\n-// Given a path and serialized crate metadata, returns the ID of the\n-// definition the path refers to.\n-fn resolve_path(vec[ast::ident] path, vec[u8] data) -> vec[ast::def_id] {\n-    fn eq_item(vec[u8] data, str s) -> bool {\n-        ret str::eq(str::unsafe_from_bytes(data), s);\n-    }\n-    auto s = str::connect(path, \"::\");\n-    auto md = ebml::new_doc(data);\n-    auto paths = ebml::get_doc(md, tag_paths);\n-    auto eqer = bind eq_item(_, s);\n-    let vec[ast::def_id] result = [];\n-    for (ebml::doc doc in lookup_hash(paths, eqer, encoder::hash_path(s))) {\n-        auto did_doc = ebml::get_doc(doc, tag_def_id);\n-        vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n-    }\n-    ret result;\n-}\n-\n-fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n-    fn eq_item(vec[u8] bytes, int item_id) -> bool {\n-        ret ebml::be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n-    }\n-    auto eqer = bind eq_item(_, item_id);\n-    auto found = lookup_hash(items, eqer, encoder::hash_def_id(item_id));\n-    if (vec::len(found) == 0u) {\n-        ret option::none[ebml::doc];\n-    } else { ret option::some[ebml::doc](found.(0)); }\n-}\n-\n-fn find_item(int item_id, &ebml::doc items) -> ebml::doc {\n-    ret option::get(maybe_find_item(item_id, items));\n-}\n-\n-\n-// Looks up an item in the given metadata and returns an ebml doc pointing\n-// to the item data.\n-fn lookup_item(int item_id, vec[u8] data) -> ebml::doc {\n-    auto items = ebml::get_doc(ebml::new_doc(data), tag_items);\n-    ret find_item(item_id, items);\n-}\n-\n-fn item_kind(&ebml::doc item) -> u8 {\n-    auto kind = ebml::get_doc(item, tag_items_data_item_kind);\n-    ret ebml::doc_as_uint(kind) as u8;\n-}\n-\n-fn item_symbol(&ebml::doc item) -> str {\n-    auto sym = ebml::get_doc(item, tag_items_data_item_symbol);\n-    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n-}\n-\n-fn variant_tag_id(&ebml::doc d) -> ast::def_id {\n-    auto tagdoc = ebml::get_doc(d, tag_items_data_item_tag_id);\n-    ret parse_def_id(ebml::doc_data(tagdoc));\n-}\n-\n-fn item_type(&ebml::doc item, int this_cnum, ty::ctxt tcx) -> ty::t {\n-    fn parse_external_def_id(int this_cnum, str s) -> ast::def_id {\n-        // FIXME: This is completely wrong when linking against a crate\n-        // that, in turn, links against another crate. We need a mapping\n-        // from crate ID to crate \"meta\" attributes as part of the crate\n-        // metadata:\n-\n-        auto buf = str::bytes(s);\n-        auto external_def_id = parse_def_id(buf);\n-        ret tup(this_cnum, external_def_id._1);\n-    }\n-    auto tp = ebml::get_doc(item, tag_items_data_item_type);\n-    auto s = str::unsafe_from_bytes(ebml::doc_data(tp));\n-    ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n-                      bind parse_external_def_id(this_cnum, _), tcx);\n-}\n-\n-fn item_ty_param_count(&ebml::doc item, int this_cnum) -> uint {\n-    let uint ty_param_count = 0u;\n-    auto tp = tag_items_data_item_ty_param_count;\n-    for each (ebml::doc p in ebml::tagged_docs(item, tp)) {\n-        ty_param_count = ebml::vint_at(ebml::doc_data(p), 0u)._0;\n-    }\n-    ret ty_param_count;\n-}\n-\n-fn tag_variant_ids(&ebml::doc item, int this_cnum) -> vec[ast::def_id] {\n-    let vec[ast::def_id] ids = [];\n-    auto v = tag_items_data_item_variant;\n-    for each (ebml::doc p in ebml::tagged_docs(item, v)) {\n-        auto ext = parse_def_id(ebml::doc_data(p));\n-        vec::push[ast::def_id](ids, tup(this_cnum, ext._1));\n-    }\n-    ret ids;\n-}\n-\n fn get_exported_metadata(&session::session sess, &str path, &vec[u8] data) ->\n    hashmap[str, str] {\n     auto meta_items =\n@@ -370,157 +244,19 @@ fn read_crates(session::session sess, resolve::crate_map crate_map,\n     walk::walk_crate(v, crate);\n }\n \n-fn kind_has_type_params(u8 kind_ch) -> bool {\n-    ret alt (kind_ch as char) {\n-            case ('c') { false }\n-            case ('f') { true }\n-            case ('p') { true }\n-            case ('F') { true }\n-            case ('y') { true }\n-            case ('t') { true }\n-            case ('T') { false }\n-            case ('m') { false }\n-            case ('n') { false }\n-            case ('v') { true }\n-        };\n-}\n-\n-\n-// Crate metadata queries\n-fn lookup_defs(session::session sess, int cnum, vec[ast::ident] path) ->\n-   vec[ast::def] {\n-    auto data = sess.get_external_crate(cnum).data;\n-    ret vec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n-}\n-\n-\n-// FIXME doesn't yet handle re-exported externals\n-fn lookup_def(int cnum, vec[u8] data, &ast::def_id did_) -> ast::def {\n-    auto item = lookup_item(did_._1, data);\n-    auto kind_ch = item_kind(item);\n-    auto did = tup(cnum, did_._1);\n-    auto def =\n-        alt (kind_ch as char) {\n-            case ('c') { ast::def_const(did) }\n-            case ('f') { ast::def_fn(did, ast::impure_fn) }\n-            case ('p') { ast::def_fn(did, ast::pure_fn) }\n-            case ('F') { ast::def_native_fn(did) }\n-            case ('y') { ast::def_ty(did) }\n-            case ('T') { ast::def_native_ty(did) }\n-            // We treat references to tags as references to types.\n-            case ('t') { ast::def_ty(did) }\n-            case ('m') { ast::def_mod(did) }\n-            case ('n') { ast::def_native_mod(did) }\n-            case ('v') {\n-                auto tid = variant_tag_id(item);\n-                tid = tup(cnum, tid._1);\n-                ast::def_variant(tid, did)\n-            }\n-        };\n-    ret def;\n-}\n-\n-fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n-    auto external_crate_id = def._0;\n-    auto data = tcx.sess.get_external_crate(external_crate_id).data;\n-    auto item = lookup_item(def._1, data);\n-    auto t = item_type(item, external_crate_id, tcx);\n-    auto tp_count;\n-    auto kind_ch = item_kind(item);\n-    auto has_ty_params = kind_has_type_params(kind_ch);\n-    if (has_ty_params) {\n-        tp_count = item_ty_param_count(item, external_crate_id);\n-    } else { tp_count = 0u; }\n-    ret tup(tp_count, t);\n-}\n-\n-fn get_symbol(session::session sess, ast::def_id def) -> str {\n-    auto external_crate_id = def._0;\n-    auto data = sess.get_external_crate(external_crate_id).data;\n-    ret item_symbol(lookup_item(def._1, data));\n-}\n-\n-fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> vec[ty::variant_info] {\n-    auto external_crate_id = def._0;\n-    auto data = tcx.sess.get_external_crate(external_crate_id).data;\n-    auto items = ebml::get_doc(ebml::new_doc(data), tag_items);\n-    auto item = find_item(def._1, items);\n-    let vec[ty::variant_info] infos = [];\n-    auto variant_ids = tag_variant_ids(item, external_crate_id);\n-    for (ast::def_id did in variant_ids) {\n-        auto item = find_item(did._1, items);\n-        auto ctor_ty = item_type(item, external_crate_id, tcx);\n-        let vec[ty::t] arg_tys = [];\n-        alt (ty::struct(tcx, ctor_ty)) {\n-            case (ty::ty_fn(_, ?args, _, _, _)) {\n-                for (ty::arg a in args) { arg_tys += [a.ty]; }\n-            }\n-            case (_) {\n-                // Nullary tag variant.\n-\n-            }\n-        }\n-        infos += [rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n-    }\n-    ret infos;\n-}\n \n fn list_file_metadata(str path, io::writer out) {\n     alt (get_metadata_section(path)) {\n-        case (option::some(?bytes)) { list_crate_metadata(bytes, out); }\n+        case (option::some(?bytes)) {\n+            decoder::list_crate_metadata(bytes, out);\n+        }\n         case (option::none) {\n             out.write_str(\"Could not find metadata in \" + path + \".\\n\");\n         }\n     }\n }\n \n-fn read_path(&ebml::doc d) -> tup(str, uint) {\n-    auto desc = ebml::doc_data(d);\n-    auto pos = ebml::be_uint_from_bytes(desc, 0u, 4u);\n-    auto pathbytes = vec::slice[u8](desc, 4u, vec::len[u8](desc));\n-    auto path = str::unsafe_from_bytes(pathbytes);\n-    ret tup(path, pos);\n-}\n-\n-fn list_crate_metadata(vec[u8] bytes, io::writer out) {\n-    auto md = ebml::new_doc(bytes);\n-    auto paths = ebml::get_doc(md, tag_paths);\n-    auto items = ebml::get_doc(md, tag_items);\n-    auto index = ebml::get_doc(paths, tag_index);\n-    auto bs = ebml::get_doc(index, tag_index_buckets);\n-    for each (ebml::doc bucket in\n-             ebml::tagged_docs(bs, tag_index_buckets_bucket)) {\n-        auto et = tag_index_buckets_bucket_elt;\n-        for each (ebml::doc elt in ebml::tagged_docs(bucket, et)) {\n-            auto data = read_path(elt);\n-            auto def = ebml::doc_at(bytes, data._1);\n-            auto did_doc = ebml::get_doc(def, tag_def_id);\n-            auto did = parse_def_id(ebml::doc_data(did_doc));\n-            out.write_str(#fmt(\"%s (%s)\\n\", data._0,\n-                               describe_def(items, did)));\n-        }\n-    }\n-}\n-\n-fn describe_def(&ebml::doc items, ast::def_id id) -> str {\n-    if (id._0 != 0) { ret \"external\"; }\n-    ret item_kind_to_str(item_kind(find_item(id._1, items)));\n-}\n \n-fn item_kind_to_str(u8 kind) -> str {\n-    alt (kind as char) {\n-        case ('c') { ret \"const\"; }\n-        case ('f') { ret \"fn\"; }\n-        case ('p') { ret \"pred\"; }\n-        case ('F') { ret \"native fn\"; }\n-        case ('y') { ret \"type\"; }\n-        case ('T') { ret \"native type\"; }\n-        case ('t') { ret \"type\"; }\n-        case ('m') { ret \"mod\"; }\n-        case ('n') { ret \"native mod\"; }\n-        case ('v') { ret \"tag\"; }\n-    }\n-}\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "9504cab11e82ad1efd376a17752196c930b0a030", "filename": "src/comp/metadata/decoder.rs", "status": "added", "additions": 281, "deletions": 0, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=119193497e48f686457bac7c3114d6f1877b7cfe", "patch": "@@ -0,0 +1,281 @@\n+import std::ebml;\n+import std::option;\n+import std::vec;\n+import std::str;\n+import std::io;\n+import front::ast;\n+import middle::ty;\n+import defs::*;\n+import tydecode::parse_def_id;\n+import tydecode::parse_ty_data;\n+import driver::session;\n+\n+export get_symbol;\n+export get_tag_variants;\n+export get_type;\n+export lookup_defs;\n+export get_type;\n+export list_crate_metadata;\n+\n+fn lookup_hash(&ebml::doc d, fn(vec[u8]) -> bool  eq_fn, uint hash) ->\n+   vec[ebml::doc] {\n+    auto index = ebml::get_doc(d, tag_index);\n+    auto table = ebml::get_doc(index, tag_index_table);\n+    auto hash_pos = table.start + hash % 256u * 4u;\n+    auto pos = ebml::be_uint_from_bytes(d.data, hash_pos, 4u);\n+    auto bucket = ebml::doc_at(d.data, pos);\n+    // Awkward logic because we can't ret from foreach yet\n+\n+    let vec[ebml::doc] result = [];\n+    auto belt = tag_index_buckets_bucket_elt;\n+    for each (ebml::doc elt in ebml::tagged_docs(bucket, belt)) {\n+        auto pos = ebml::be_uint_from_bytes(elt.data, elt.start, 4u);\n+        if (eq_fn(vec::slice[u8](elt.data, elt.start + 4u, elt.end))) {\n+            vec::push(result, ebml::doc_at(d.data, pos));\n+        }\n+    }\n+    ret result;\n+}\n+\n+fn maybe_find_item(int item_id, &ebml::doc items) -> option::t[ebml::doc] {\n+    fn eq_item(vec[u8] bytes, int item_id) -> bool {\n+        ret ebml::be_uint_from_bytes(bytes, 0u, 4u) as int == item_id;\n+    }\n+    auto eqer = bind eq_item(_, item_id);\n+    auto found = lookup_hash(items, eqer, encoder::hash_def_id(item_id));\n+    if (vec::len(found) == 0u) {\n+        ret option::none[ebml::doc];\n+    } else { ret option::some[ebml::doc](found.(0)); }\n+}\n+\n+fn find_item(int item_id, &ebml::doc items) -> ebml::doc {\n+    ret option::get(maybe_find_item(item_id, items));\n+}\n+\n+// Looks up an item in the given metadata and returns an ebml doc pointing\n+// to the item data.\n+fn lookup_item(int item_id, vec[u8] data) -> ebml::doc {\n+    auto items = ebml::get_doc(ebml::new_doc(data), tag_items);\n+    ret find_item(item_id, items);\n+}\n+\n+fn item_kind(&ebml::doc item) -> u8 {\n+    auto kind = ebml::get_doc(item, tag_items_data_item_kind);\n+    ret ebml::doc_as_uint(kind) as u8;\n+}\n+\n+fn item_symbol(&ebml::doc item) -> str {\n+    auto sym = ebml::get_doc(item, tag_items_data_item_symbol);\n+    ret str::unsafe_from_bytes(ebml::doc_data(sym));\n+}\n+\n+fn variant_tag_id(&ebml::doc d) -> ast::def_id {\n+    auto tagdoc = ebml::get_doc(d, tag_items_data_item_tag_id);\n+    ret parse_def_id(ebml::doc_data(tagdoc));\n+}\n+\n+fn item_type(&ebml::doc item, int this_cnum, ty::ctxt tcx) -> ty::t {\n+    fn parse_external_def_id(int this_cnum, str s) -> ast::def_id {\n+        // FIXME: This is completely wrong when linking against a crate\n+        // that, in turn, links against another crate. We need a mapping\n+        // from crate ID to crate \"meta\" attributes as part of the crate\n+        // metadata:\n+\n+        auto buf = str::bytes(s);\n+        auto external_def_id = parse_def_id(buf);\n+        ret tup(this_cnum, external_def_id._1);\n+    }\n+    auto tp = ebml::get_doc(item, tag_items_data_item_type);\n+    auto s = str::unsafe_from_bytes(ebml::doc_data(tp));\n+    ret parse_ty_data(item.data, this_cnum, tp.start, tp.end - tp.start,\n+                      bind parse_external_def_id(this_cnum, _), tcx);\n+}\n+\n+fn item_ty_param_count(&ebml::doc item, int this_cnum) -> uint {\n+    let uint ty_param_count = 0u;\n+    auto tp = tag_items_data_item_ty_param_count;\n+    for each (ebml::doc p in ebml::tagged_docs(item, tp)) {\n+        ty_param_count = ebml::vint_at(ebml::doc_data(p), 0u)._0;\n+    }\n+    ret ty_param_count;\n+}\n+\n+fn tag_variant_ids(&ebml::doc item, int this_cnum) -> vec[ast::def_id] {\n+    let vec[ast::def_id] ids = [];\n+    auto v = tag_items_data_item_variant;\n+    for each (ebml::doc p in ebml::tagged_docs(item, v)) {\n+        auto ext = parse_def_id(ebml::doc_data(p));\n+        vec::push[ast::def_id](ids, tup(this_cnum, ext._1));\n+    }\n+    ret ids;\n+}\n+\n+// Given a path and serialized crate metadata, returns the ID of the\n+// definition the path refers to.\n+fn resolve_path(vec[ast::ident] path, vec[u8] data) -> vec[ast::def_id] {\n+    fn eq_item(vec[u8] data, str s) -> bool {\n+        ret str::eq(str::unsafe_from_bytes(data), s);\n+    }\n+    auto s = str::connect(path, \"::\");\n+    auto md = ebml::new_doc(data);\n+    auto paths = ebml::get_doc(md, tag_paths);\n+    auto eqer = bind eq_item(_, s);\n+    let vec[ast::def_id] result = [];\n+    for (ebml::doc doc in lookup_hash(paths, eqer, encoder::hash_path(s))) {\n+        auto did_doc = ebml::get_doc(doc, tag_def_id);\n+        vec::push(result, parse_def_id(ebml::doc_data(did_doc)));\n+    }\n+    ret result;\n+}\n+\n+// Crate metadata queries\n+fn lookup_defs(session::session sess, int cnum, vec[ast::ident] path) ->\n+   vec[ast::def] {\n+    auto data = sess.get_external_crate(cnum).data;\n+    ret vec::map(bind lookup_def(cnum, data, _), resolve_path(path, data));\n+}\n+\n+\n+// FIXME doesn't yet handle re-exported externals\n+fn lookup_def(int cnum, vec[u8] data, &ast::def_id did_) -> ast::def {\n+    auto item = lookup_item(did_._1, data);\n+    auto kind_ch = item_kind(item);\n+    auto did = tup(cnum, did_._1);\n+    auto def =\n+        alt (kind_ch as char) {\n+            case ('c') { ast::def_const(did) }\n+            case ('f') { ast::def_fn(did, ast::impure_fn) }\n+            case ('p') { ast::def_fn(did, ast::pure_fn) }\n+            case ('F') { ast::def_native_fn(did) }\n+            case ('y') { ast::def_ty(did) }\n+            case ('T') { ast::def_native_ty(did) }\n+            // We treat references to tags as references to types.\n+            case ('t') { ast::def_ty(did) }\n+            case ('m') { ast::def_mod(did) }\n+            case ('n') { ast::def_native_mod(did) }\n+            case ('v') {\n+                auto tid = variant_tag_id(item);\n+                tid = tup(cnum, tid._1);\n+                ast::def_variant(tid, did)\n+            }\n+        };\n+    ret def;\n+}\n+\n+fn get_type(ty::ctxt tcx, ast::def_id def) -> ty::ty_param_count_and_ty {\n+    auto external_crate_id = def._0;\n+    auto data = tcx.sess.get_external_crate(external_crate_id).data;\n+    auto item = lookup_item(def._1, data);\n+    auto t = item_type(item, external_crate_id, tcx);\n+    auto tp_count;\n+    auto kind_ch = item_kind(item);\n+    auto has_ty_params = kind_has_type_params(kind_ch);\n+    if (has_ty_params) {\n+        tp_count = item_ty_param_count(item, external_crate_id);\n+    } else { tp_count = 0u; }\n+    ret tup(tp_count, t);\n+}\n+\n+fn get_symbol(session::session sess, ast::def_id def) -> str {\n+    auto external_crate_id = def._0;\n+    auto data = sess.get_external_crate(external_crate_id).data;\n+    ret item_symbol(lookup_item(def._1, data));\n+}\n+\n+fn get_tag_variants(ty::ctxt tcx, ast::def_id def) -> vec[ty::variant_info] {\n+    auto external_crate_id = def._0;\n+    auto data = tcx.sess.get_external_crate(external_crate_id).data;\n+    auto items = ebml::get_doc(ebml::new_doc(data), tag_items);\n+    auto item = find_item(def._1, items);\n+    let vec[ty::variant_info] infos = [];\n+    auto variant_ids = tag_variant_ids(item, external_crate_id);\n+    for (ast::def_id did in variant_ids) {\n+        auto item = find_item(did._1, items);\n+        auto ctor_ty = item_type(item, external_crate_id, tcx);\n+        let vec[ty::t] arg_tys = [];\n+        alt (ty::struct(tcx, ctor_ty)) {\n+            case (ty::ty_fn(_, ?args, _, _, _)) {\n+                for (ty::arg a in args) { arg_tys += [a.ty]; }\n+            }\n+            case (_) {\n+                // Nullary tag variant.\n+\n+            }\n+        }\n+        infos += [rec(args=arg_tys, ctor_ty=ctor_ty, id=did)];\n+    }\n+    ret infos;\n+}\n+\n+fn kind_has_type_params(u8 kind_ch) -> bool {\n+    ret alt (kind_ch as char) {\n+            case ('c') { false }\n+            case ('f') { true }\n+            case ('p') { true }\n+            case ('F') { true }\n+            case ('y') { true }\n+            case ('t') { true }\n+            case ('T') { false }\n+            case ('m') { false }\n+            case ('n') { false }\n+            case ('v') { true }\n+        };\n+}\n+\n+fn read_path(&ebml::doc d) -> tup(str, uint) {\n+    auto desc = ebml::doc_data(d);\n+    auto pos = ebml::be_uint_from_bytes(desc, 0u, 4u);\n+    auto pathbytes = vec::slice[u8](desc, 4u, vec::len[u8](desc));\n+    auto path = str::unsafe_from_bytes(pathbytes);\n+    ret tup(path, pos);\n+}\n+\n+fn describe_def(&ebml::doc items, ast::def_id id) -> str {\n+    if (id._0 != 0) { ret \"external\"; }\n+    ret item_kind_to_str(item_kind(find_item(id._1, items)));\n+}\n+\n+fn item_kind_to_str(u8 kind) -> str {\n+    alt (kind as char) {\n+        case ('c') { ret \"const\"; }\n+        case ('f') { ret \"fn\"; }\n+        case ('p') { ret \"pred\"; }\n+        case ('F') { ret \"native fn\"; }\n+        case ('y') { ret \"type\"; }\n+        case ('T') { ret \"native type\"; }\n+        case ('t') { ret \"type\"; }\n+        case ('m') { ret \"mod\"; }\n+        case ('n') { ret \"native mod\"; }\n+        case ('v') { ret \"tag\"; }\n+    }\n+}\n+\n+fn list_crate_metadata(vec[u8] bytes, io::writer out) {\n+    auto md = ebml::new_doc(bytes);\n+    auto paths = ebml::get_doc(md, tag_paths);\n+    auto items = ebml::get_doc(md, tag_items);\n+    auto index = ebml::get_doc(paths, tag_index);\n+    auto bs = ebml::get_doc(index, tag_index_buckets);\n+    for each (ebml::doc bucket in\n+             ebml::tagged_docs(bs, tag_index_buckets_bucket)) {\n+        auto et = tag_index_buckets_bucket_elt;\n+        for each (ebml::doc elt in ebml::tagged_docs(bucket, et)) {\n+            auto data = read_path(elt);\n+            auto def = ebml::doc_at(bytes, data._1);\n+            auto did_doc = ebml::get_doc(def, tag_def_id);\n+            auto did = parse_def_id(ebml::doc_data(did_doc));\n+            out.write_str(#fmt(\"%s (%s)\\n\", data._0,\n+                               describe_def(items, did)));\n+        }\n+    }\n+}\n+\n+\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:"}, {"sha": "858c7ea66dfbb7b9c9a26e4334e251b681c5fdc7", "filename": "src/comp/middle/resolve.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fresolve.rs?ref=119193497e48f686457bac7c3114d6f1877b7cfe", "patch": "@@ -7,6 +7,7 @@ import front::ast::node_id;\n import front::ast::local_def;\n \n import metadata::creader;\n+import metadata::decoder;\n import driver::session::session;\n import util::common::new_def_hash;\n import util::common::new_int_hash;\n@@ -1152,7 +1153,7 @@ fn ns_for_def(def d) -> namespace {\n \n fn lookup_external(&env e, int cnum, vec[ident] ids, namespace ns) ->\n    option::t[def] {\n-    for (def d in creader::lookup_defs(e.sess, cnum, ids)) {\n+    for (def d in decoder::lookup_defs(e.sess, cnum, ids)) {\n         e.ext_map.insert(ast::def_id_of_def(d), ids);\n         if (ns == ns_for_def(d)) { ret some(d); }\n     }"}, {"sha": "9c71ade709cfec4213cfff72c1bf30c9b8e60b1b", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=119193497e48f686457bac7c3114d6f1877b7cfe", "patch": "@@ -68,6 +68,7 @@ import link::crate_meta_extras_hash;\n import metadata::tyencode;\n import metadata::creader;\n import metadata::cwriter;\n+import metadata::decoder;\n import pretty::ppaux::ty_to_str;\n import pretty::ppaux::ty_to_short_str;\n import pretty::pprust::expr_to_str;\n@@ -4676,7 +4677,7 @@ fn lval_val(&@block_ctxt cx, ValueRef val) -> lval_result {\n fn trans_external_path(&@block_ctxt cx, &ast::def_id did,\n                        &ty::ty_param_count_and_ty tpt) -> lval_result {\n     auto lcx = cx.fcx.lcx;\n-    auto name = creader::get_symbol(lcx.ccx.sess, did);\n+    auto name = decoder::get_symbol(lcx.ccx.sess, did);\n     auto v =\n         get_extern_const(lcx.ccx.externs, lcx.ccx.llmod, name,\n                          type_of_ty_param_count_and_ty(lcx, cx.sp, tpt));\n@@ -4723,7 +4724,7 @@ fn lookup_discriminant(&@local_ctxt lcx, &ast::def_id tid, &ast::def_id vid)\n             // It's an external discriminant that we haven't seen yet.\n \n             assert (lcx.ccx.sess.get_targ_crate_num() != vid._0);\n-            auto sym = creader::get_symbol(lcx.ccx.sess, vid);\n+            auto sym = decoder::get_symbol(lcx.ccx.sess, vid);\n             auto gvar =\n                 llvm::LLVMAddGlobal(lcx.ccx.llmod, T_int(), str::buf(sym));\n             llvm::LLVMSetLinkage(gvar,"}, {"sha": "6e40bd5eab3e89341925a235269bfa8017ed3570", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=119193497e48f686457bac7c3114d6f1877b7cfe", "patch": "@@ -19,6 +19,7 @@ import front::ast::mutability;\n import front::ast::controlflow;\n import metadata::creader;\n import metadata::cwriter;\n+import metadata::decoder;\n import util::common::*;\n import util::data::interner;\n import pretty::ppaux::ty_to_str;\n@@ -2700,7 +2701,7 @@ type variant_info = rec(vec[ty::t] args, ty::t ctor_ty, ast::def_id id);\n \n fn tag_variants(&ctxt cx, &ast::def_id id) -> vec[variant_info] {\n     if (cx.sess.get_targ_crate_num() != id._0) {\n-        ret creader::get_tag_variants(cx, id);\n+        ret decoder::get_tag_variants(cx, id);\n     }\n     auto item = alt (cx.items.find(id._1)) {\n         case (some(?i)) { i }\n@@ -2763,7 +2764,7 @@ fn lookup_item_type(ctxt cx, ast::def_id did) -> ty_param_count_and_ty {\n     alt (cx.tcache.find(did)) {\n         case (some(?tpt)) { ret tpt; }\n         case (none) {\n-            auto tyt = creader::get_type(cx, did);\n+            auto tyt = decoder::get_type(cx, did);\n             cx.tcache.insert(did, tyt);\n             ret tyt;\n         }"}, {"sha": "d12f823d4ab7543f6dba9d7526b0dc4d0100c134", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=119193497e48f686457bac7c3114d6f1877b7cfe", "patch": "@@ -2,7 +2,7 @@\n import front::ast;\n import front::ast::mutability;\n import front::ast::local_def;\n-import metadata::creader;\n+import metadata::decoder;\n import driver::session;\n import util::common;\n import util::common::span;\n@@ -478,7 +478,7 @@ mod collect {\n         if (id._0 != cx.tcx.sess.get_targ_crate_num()) {\n             // This is a type we need to load in from the crate reader.\n \n-            ret creader::get_type(cx.tcx, id);\n+            ret decoder::get_type(cx.tcx, id);\n         }\n         auto it = cx.tcx.items.get(id._1);\n         auto tpt;"}, {"sha": "8f586556de5620bcec915618e6a8bab983771199", "filename": "src/comp/rustc.rc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/119193497e48f686457bac7c3114d6f1877b7cfe/src%2Fcomp%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Frustc.rc?ref=119193497e48f686457bac7c3114d6f1877b7cfe", "patch": "@@ -67,6 +67,7 @@ mod metadata {\n     mod tyencode;\n     mod tydecode;\n     mod encoder;\n+    mod decoder;\n     mod creader;\n     mod cwriter;\n }"}]}